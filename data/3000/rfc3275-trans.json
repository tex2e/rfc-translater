{
  "title": {
    "text": "RFC 3275 - (Extensible Markup Language) XML-Signature Syntax and Processing",
    "ja": "RFC 3275 - （拡張可能なマークアップ言語）XML署名の構文と処理"
  },
  "number": 3275,
  "created_at": "2023-11-27 09:17:39.378416+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                    D. Eastlake 3rd\nRequest for Comments: 3275                                      Motorola\nObsoletes: 3075                                                J. Reagle\nCategory: Standards Track                                            W3C\n                                                                 D. Solo\n                                                               Citigroup\n                                                              March 2002",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "(Extensible Markup Language) XML-Signature Syntax and Processing",
      "ja": "（拡張可能なマークアップ言語）XML署名の構文と処理"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのためのインターネット標準化過程のプロトコルを指定し、改善のための議論と提案を求めます。このプロトコルの標準化状態と状況については、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 3,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2002 The Internet Society & W3C (MIT, INRIA, Keio), All Rights Reserved.",
      "ja": "Copyright (c) 2002 The Internet Society & W3C (MIT, INRIA, Keio), All Rights Reserved."
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "要約"
    },
    {
      "indent": 3,
      "text": "This document specifies XML (Extensible Markup Language) digital signature processing rules and syntax. XML Signatures provide integrity, message authentication, and/or signer authentication services for data of any type, whether located within the XML that includes the signature or elsewhere.",
      "ja": "このドキュメントは、XML（拡張可能なマークアップ言語）デジタル署名の処理ルールと構文を規定するものです。XML署名は、署名を含むXML内にあるか他の場所にあるかにかかわらず、あらゆるタイプのデータに対して、整合性、メッセージ認証、および/または署名者認証サービスを提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction...................................................  3\n1.1 Editorial and Conformance Conventions.........................  4\n1.2 Design Philosophy.............................................  4\n1.3 Versions, Namespaces and Identifiers..........................  4\n1.4 Acknowledgements..............................................  6\n1.5 W3C Status....................................................  6\n2. Signature Overview and Examples................................  7\n2.1 Simple Example (Signature, SignedInfo, Methods, and References) 8\n2.1.1 More on Reference...........................................  9\n2.2 Extended Example (Object and SignatureProperty)............... 10\n2.3 Extended Example (Object and Manifest)........................ 12\n3.0 Processing Rules.............................................. 13\n3.1 Core Generation............................................... 13\n3.1.1 Reference Generation........................................ 13\n3.1.2 Signature Generation........................................ 13\n3.2 Core Validation............................................... 14\n3.2.1 Reference Validation........................................ 14\n3.2.2 Signature Validation........................................ 15\n4.0 Core Signature Syntax......................................... 15\n4.0.1 The ds:CryptoBinary Simple Type............................. 17\n4.1 The Signature element......................................... 17\n4.2 The SignatureValue Element.................................... 18\n4.3 The SignedInfo Element........................................ 18\n4.3.1 The CanonicalizationMethod Element.......................... 19\n4.3.2 The SignatureMethod Element................................. 21\n4.3.3 The Reference Element....................................... 21\n4.3.3.1 The URI Attribute......................................... 22\n4.3.3.2 The Reference Processing Model............................ 23\n4.3.3.3 Same-Document URI-References.............................. 25\n4.3.3.4 The Transforms Element.................................... 26\n4.3.3.5 The DigestMethod Element.................................. 28\n4.3.3.6 The DigestValue Element................................... 28\n4.4 The KeyInfo Element........................................... 29\n4.4.1 The KeyName Element......................................... 31\n4.4.2 The KeyValue Element........................................ 31\n4.4.2.1 The DSAKeyValue Element................................... 32\n4.4.2.2 The RSAKeyValue Element................................... 33\n4.4.3 The RetrievalMethod Element................................. 34\n4.4.4 The X509Data Element........................................ 35\n4.4.5 The PGPData Element......................................... 38\n4.4.6 The SPKIData Element........................................ 39\n4.4.7 The MgmtData Element........................................ 40\n4.5 The Object Element............................................ 40\n5.0 Additional Signature Syntax................................... 42\n5.1 The Manifest Element.......................................... 42\n5.2 The SignatureProperties Element............................... 43\n5.3 Processing Instructions in Signature Elements................. 44\n5.4 Comments in Signature Elements................................ 44\n6.0 Algorithms.................................................... 44\n6.1 Algorithm Identifiers and Implementation Requirements......... 44\n6.2 Message Digests............................................... 46\n6.2.1 SHA-1....................................................... 46\n6.3 Message Authentication Codes.................................. 46\n6.3.1 HMAC........................................................ 46\n6.4 Signature Algorithms.......................................... 47\n6.4.1 DSA......................................................... 47\n6.4.2 PKCS1 (RSA-SHA1)............................................ 48\n6.5 Canonicalization Algorithms................................... 49\n6.5.1 Canonical XML............................................... 49\n6.6 Transform Algorithms.......................................... 50\n6.6.1 Canonicalization............................................ 50\n6.6.2 Base64...................................................... 50\n6.6.3 XPath Filtering............................................. 51\n6.6.4 Enveloped Signature Transform............................... 54\n6.6.5 XSLT Transform.............................................. 54\n7. XML Canonicalization and Syntax Constraint Considerations...... 55\n7.1 XML 1.0, Syntax Constraints, and Canonicalization............. 56\n7.2 DOM/SAX Processing and Canonicalization....................... 57\n7.3 Namespace Context and Portable Signatures..................... 58\n8.0 Security Considerations....................................... 59\n8.1 Transforms.................................................... 59\n8.1.1 Only What is Signed is Secure............................... 60\n8.1.2 Only What is 'Seen' Should be Signed........................ 60\n8.1.3 'See' What is Signed........................................ 61\n8.2 Check the Security Model...................................... 62\n8.3 Algorithms, Key Lengths, Certificates, Etc.................... 62\n9. Schema, DTD, Data Model, and Valid Examples.................... 63\n10. Definitions................................................... 63\nAppendix: Changes from RFC 3075................................... 67\nReferences........................................................ 67\nAuthors' Addresses................................................ 72\nFull Copyright Statement.......................................... 73",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies XML syntax and processing rules for creating and representing digital signatures. XML Signatures can be applied to any digital content (data object), including XML. An XML Signature may be applied to the content of one or more resources. Enveloped or enveloping signatures are over data within the same XML document as the signature; detached signatures are over data external to the signature element. More specifically, this specification defines an XML signature element type and an XML signature application; conformance requirements for each are specified by way of schema definitions and prose respectively. This specification also includes other useful types that identify methods for referencing collections of resources, algorithms, and keying and management information.",
      "ja": "このドキュメントは、デジタル署名を作成および表現するためのXML構文と処理ルールを規定するものです。XML署名は、XMLを含む任意のデジタルコンテンツ（データオブジェクト）に適用できます。XML署名は、1つ以上のリソースのコンテンツに適用される場合があります。Enveloped（内包）署名またはEnveloping（包含）署名は、署名と同じXMLドキュメント内のデータを対象とします。Detached（分離）署名は、署名要素の外部のデータを対象とします。より具体的には、本仕様はXML署名要素タイプとXML署名アプリケーションを定義します。それぞれの適合要件は、スキーマ定義と記述（prose）によってそれぞれ規定されます。本仕様には、リソース、アルゴリズム、キーイングおよび管理情報のコレクションを参照する方法を特定する他の有用なタイプも含まれています。"
    },
    {
      "indent": 3,
      "text": "The XML Signature is a method of associating a key with referenced data (octets); it does not normatively specify how keys are associated with persons or institutions, nor the meaning of the data being referenced and signed. Consequently, while this specification is an important component of secure XML applications, it itself is not sufficient to address all application security/trust concerns, particularly with respect to using signed XML (or other data formats) as a basis of human-to-human communication and agreement. Such an application must specify additional key, algorithm, processing and rendering requirements. For further information, please see Security Considerations (section 8).",
      "ja": "XML署名は、参照データ（オクテット）とキーを関連付ける方法です。キーが人や機関にどのように関連付けられているか、また参照および署名されるデータの意味を規範的に指定するものではありません。したがって、本仕様は安全なXMLアプリケーションの重要なコンポーネントですが、特に人間対人間のコミュニケーションと合意の基礎として署名されたXML（または他のデータ形式）を使用することに関して、すべてのアプリケーションセキュリティ/信頼の懸念に対処するには、これだけでは十分ではありません。このようなアプリケーションは、追加のキー、アルゴリズム、処理、およびレンダリング要件を指定する必要があります。詳細については、セキュリティに関する考慮事項（セクション8）を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.1 Editorial and Conformance Conventions",
      "section_title": true,
      "ja": "1.1 編集および適合規則"
    },
    {
      "indent": 3,
      "text": "For readability, brevity, and historic reasons this document uses the term \"signature\" to generally refer to digital authentication values of all types. Obviously, the term is also strictly used to refer to authentication values that are based on public keys and that provide signer authentication. When specifically discussing authentication values based on symmetric secret key codes we use the terms authenticators or authentication codes. (See Check the Security Model, section 8.3.)",
      "ja": "読みやすさ、簡潔さ、および歴史的な理由から、このドキュメントでは「署名」という用語を使用して、一般的にすべてのタイプのデジタル認証値を指すものとします。明らかに、この用語は、公開鍵に基づき署名者認証を提供する認証値を指すために厳密にも使用されます。対称秘密鍵コードに基づく認証値について具体的に議論する場合は、認証子（authenticators）または認証コードという用語を使用します。（セキュリティモデルを確認してください、セクション8.3を参照。）"
    },
    {
      "indent": 3,
      "text": "This specification provides an XML Schema [XML-schema] and DTD [XML]. The schema definition is normative.",
      "ja": "この仕様は、XMLスキーマ[XML-schema]とDTD [XML]を提供します。スキーマ定義は規範的（normative）です。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this specification are to be interpreted as described in RFC2119 [KEYWORDS]:",
      "ja": "この仕様におけるキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、RFC 2119 [KEYWORDS]で説明されているように解釈されます。"
    },
    {
      "indent": 6,
      "text": "\"they MUST only be used where it is actually required for interoperation or to limit behavior which has potential for causing harm (e.g., limiting retransmissions)\"",
      "ja": "「それらは、実際に相互操作に必要な場合、または害を引き起こす可能性のある行動を制限するために必要な場合にのみ使用する必要があります（例えば、再送信の制限）」"
    },
    {
      "indent": 3,
      "text": "Consequently, we use these capitalized key words to unambiguously specify requirements over protocol and application features and behavior that affect the interoperability and security of implementations. These key words are not used (capitalized) to describe XML grammar; schema definitions unambiguously describe such requirements and we wish to reserve the prominence of these terms for the natural language descriptions of protocols and features. For instance, an XML attribute might be described as being \"optional.\" Compliance with the Namespaces in XML specification [XML-ns] is described as \"REQUIRED.\"",
      "ja": "その結果、これらの大文字のキーワードを使用して、実装の相互運用性とセキュリティに影響を与えるプロトコルとアプリケーションの機能と動作に関する要件を明確に指定します。これらのキーワードは、XML文法を説明するために（大文字で）使用されません。スキーマの定義は、そのような要件を明確に説明しており、プロトコルと機能の自然言語の説明のためにこれらの用語の重要性を留保したいと考えています。たとえば、XML属性は「任意（optional）」であると説明される場合があります。XML仕様[XML-NS]の名前空間への準拠は、「REQUIRED」と記述されます。"
    },
    {
      "indent": 0,
      "text": "1.2 Design Philosophy",
      "section_title": true,
      "ja": "1.2 デザイン哲学"
    },
    {
      "indent": 3,
      "text": "The design philosophy and requirements of this specification are addressed in the XML-Signature Requirements document [XML-Signature-RD].",
      "ja": "この仕様の設計哲学と要件は、XML-Signature要件ドキュメント[XML-Signature-Rd]で説明されています。"
    },
    {
      "indent": 0,
      "text": "1.3 Versions, Namespaces and Identifiers",
      "section_title": true,
      "ja": "1.3 バージョン、名前空間、識別子"
    },
    {
      "indent": 3,
      "text": "No provision is made for an explicit version number in this syntax. If a future version is needed, it will use a different namespace. The XML namespace [XML-ns] URI that MUST be used by implementations of this (dated) specification is:",
      "ja": "この構文では、明示的なバージョン番号に関する規定は設けられていません。将来のバージョンが必要な場合は、別の名前空間を使用することになります。この（日付の）仕様の実装で使用する必要があるXML名前空間[XML-ns] URIは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "xmlns=\"http://www.w3.org/2000/09/xmldsig#\"",
      "raw": true,
      "ja": "xmlns=\"http://www.w3.org/2000/09/xmldsig#\""
    },
    {
      "indent": 3,
      "text": "This namespace is also used as the prefix for algorithm identifiers used by this specification. While applications MUST support XML and XML namespaces, the use of internal entities [XML] or our \"dsig\" XML namespace prefix and defaulting/scoping conventions are OPTIONAL; we use these facilities to provide compact and readable examples.",
      "ja": "この名前空間は、この仕様で使用されるアルゴリズム識別子の接頭辞（プレフィックス）としても使用されます。アプリケーションはXMLおよびXML名前空間をサポートしなければなりませんが、内部エンティティ[XML]や、ここでの「dsig」XML名前空間接頭辞、およびデフォルト設定/スコープ規則の使用は任意（OPTIONAL）です。ここでは、コンパクトで読みやすい例を提供するためにこれらの機能を使用します。"
    },
    {
      "indent": 3,
      "text": "This specification uses Uniform Resource Identifiers [URI] to identify resources, algorithms, and semantics. The URI in the namespace declaration above is also used as a prefix for URIs under the control of this specification. For resources not under the control of this specification, we use the designated Uniform Resource Names [URN] or Uniform Resource Locators [URL] defined by its normative external specification. If an external specification has not allocated itself a Uniform Resource Identifier we allocate an identifier under our own namespace. For instance:",
      "ja": "この仕様では、均一なリソース識別子[URI]を使用して、リソース、アルゴリズム、およびセマンティクスを識別します。上記の名前空間宣言のURIは、この仕様の制御下にあるURIのプレフィックスとしても使用されます。この仕様を管理していないリソースには、指定されたユニフォームリソース名[URN]またはその規範的な外部仕様で定義された均一なリソースロケーター[URL]を使用します。外部仕様が均一なリソース識別子を割り当てていない場合、独自の名前空間の下に識別子を割り当てます。例えば："
    },
    {
      "indent": 3,
      "text": "SignatureProperties is identified and defined by this specification's namespace: http://www.w3.org/2000/09/xmldsig#SignatureProperties",
      "ja": "SignaturePropertiesは、この仕様の名前空間で識別および定義されています：http://www.w3.org/2000/09/xmldsig#signatureproperties"
    },
    {
      "indent": 3,
      "text": "XSLT is identified and defined by an external URI http://www.w3.org/TR/1999/REC-xslt-19991116",
      "ja": "XSLTは、外部URI http://www.w3.org/tr/1999/rec-xslt-1999116によって識別および定義されています"
    },
    {
      "indent": 3,
      "text": "SHA1 is identified via this specification's namespace and defined via a normative reference http://www.w3.org/2000/09/xmldsig#sha1 FIPS PUB 180-1. Secure Hash Standard. U.S. Department of Commerce/National Institute of Standards and Technology.",
      "ja": "SHA1はこの仕様の名前空間で識別され、規範的な参照 http://www.w3.org/2000/09/xmldsig#sha1 FIPS PUB 180-1 で定義されます。Secure Hash Standard。米国商務省/国立標準技術研究所。"
    },
    {
      "indent": 3,
      "text": "Finally, in order to provide for terse namespace declarations we sometimes use XML internal entities [XML] within URIs. For instance:",
      "ja": "最後に、簡潔な名前空間宣言を提供するために、URIS内でXML内部エンティティ[XML]を使用することがあります。例えば："
    },
    {
      "indent": 6,
      "text": "<?xml version='1.0'?>\n<!DOCTYPE Signature SYSTEM\n  \"xmldsig-core-schema.dtd\" [ <!ENTITY dsig\n  \"http://www.w3.org/2000/09/xmldsig#\"> ]>\n<Signature xmlns=\"&dsig;\" Id=\"MyFirstSignature\">\n  <SignedInfo>\n  ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1.4 Acknowledgements",
      "section_title": true,
      "ja": "1.4 謝辞"
    },
    {
      "indent": 3,
      "text": "The contributions of the following Working Group members to this specification are gratefully acknowledged:",
      "ja": "次のワーキンググループメンバーのこの仕様への貢献は、感謝されています。"
    },
    {
      "indent": 6,
      "text": "* Mark Bartel, Accelio (Author) * John Boyer, PureEdge (Author) * Mariano P. Consens, University of Waterloo * John Cowan, Reuters Health * Donald Eastlake 3rd, Motorola (Chair, Author/Editor) * Barb Fox, Microsoft (Author) * Christian Geuer-Pollmann, University Siegen * Tom Gindin, IBM * Phillip Hallam-Baker, VeriSign Inc * Richard Himes, US Courts * Merlin Hughes, Baltimore * Gregor Karlinger, IAIK TU Graz * Brian LaMacchia, Microsoft (Author) * Peter Lipp, IAIK TU Graz * Joseph Reagle, W3C (Chair, Author/Editor) * Ed Simon, XMLsec (Author) * David Solo, Citigroup (Author/Editor) * Petteri Stenius, DONE Information, Ltd * Raghavan Srinivas, Sun * Kent Tamura, IBM * Winchel Todd Vincent III, GSU * Carl Wallace, Corsec Security, Inc. * Greg Whitehead, Signio Inc.",
      "ja": "* マーク・バルテル、アセリオ（著者） *ジョン・ボイヤー、ピュアエッジ（著者） *マリアーノP.コンセン、ウォータールー大学ジョンコーワン、ロイターヘルス *ドナルドイーストレイク3位、モトローラ（議長、著者/編集者） *バーブフォックス、マイクロソフト（著者） * Christian Geuer-Pollmann、University Siegen * Tom Gindin、Ibm * Phillip Hallam-Baker、Verisign Inc * Richard Himes、米国裁判所 * Merlin Hughes、Baltimore * Gregor Karlinger、Iaik Tu Graz * Brian Lamacchia、Microsoft（著者） * PeterLipp、Iaik Tu Graz * Joseph Reagle、W3C（椅子、著者/編集者） * Ed Simon、XMLSec（著者） * David Solo、シティグループ（著者/編集者） * Petteri Stenius、Done Information、Ltd * Raghavan Srinivas、Sun * KentTamura、IBM * Winchel Todd Vincent III、GSU * Carl Wallace、Corsec Security、Inc。 * Greg Whitehead、Signio Inc."
    },
    {
      "indent": 3,
      "text": "As are the Last Call comments from the following:",
      "ja": "以下からの最後のコールコメントも同様です。"
    },
    {
      "indent": 6,
      "text": "* Dan Connolly, W3C * Paul Biron, Kaiser Permanente, on behalf of the XML Schema WG. * Martin J. Duerst, W3C; and Masahiro Sekiguchi, Fujitsu; on behalf of the Internationalization WG/IG. * Jonathan Marsh, Microsoft, on behalf of the Extensible Stylesheet Language WG.",
      "ja": "* Dan Connolly、W3C * Paul Biron、Kaiser Permanente、XML Schema WG。* Martin J. Duerst、W3C;藤井正田島。国際化WG/IGを代表して。*ジョナサン・マーシュ、マイクロソフト、拡張可能なStyleSheet Language WGを代表して。"
    },
    {
      "indent": 0,
      "text": "1.5 W3C Status",
      "section_title": true,
      "ja": "1.5 W3Cステータス"
    },
    {
      "indent": 3,
      "text": "The World Wide Web Consortium Recommendation corresponding to this RFC is at:",
      "ja": "このRFCに対応するWorld Wide Webコンソーシアムの推奨事項は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/",
      "ja": "http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/"
    },
    {
      "indent": 0,
      "text": "2. Signature Overview and Examples",
      "section_title": true,
      "ja": "2. 署名の概要と例"
    },
    {
      "indent": 3,
      "text": "This section provides an overview and examples of XML digital signature syntax. The specific processing is given in Processing Rules (section 3). The formal syntax is found in Core Signature Syntax (section 4) and Additional Signature Syntax (section 5).",
      "ja": "このセクションでは、XMLデジタル署名構文の概要と例を示します。特定の処理は、処理ルール（セクション3）に記載されています。正式な構文は、コア署名構文（セクション4）と追加の署名構文（セクション5）にあります。"
    },
    {
      "indent": 3,
      "text": "In this section, an informal representation and examples are used to describe the structure of the XML signature syntax. This representation and examples may omit attributes, details and potential features that are fully explained later.",
      "ja": "このセクションでは、非公式の表現と例を使用して、XML署名構文の構造を記述します。この表現と例は、後で完全に説明される属性、詳細、および潜在的な機能を省略する場合があります。"
    },
    {
      "indent": 3,
      "text": "XML Signatures are applied to arbitrary digital content (data objects) via an indirection. Data objects are digested, the resulting value is placed in an element (with other information) and that element is then digested and cryptographically signed. XML digital signatures are represented by the Signature element which has the following structure (where \"?\" denotes zero or one occurrence; \"+\" denotes one or more occurrences; and \"*\" denotes zero or more occurrences):",
      "ja": "XML署名は、間接参照（indirection）を介して任意のデジタルコンテンツ（データオブジェクト）に適用されます。データオブジェクトはダイジェスト（ハッシュ化）され、結果の値は（他の情報とともに）要素に配置され、その要素がダイジェストされ、暗号的に署名されます。XMLデジタル署名は、次の構造を持つ署名要素で表されます（ここで、「？」はゼロまたは1回の出現を示し、「+」は1回以上の出現を示し、「*」はゼロ回以上の出現を示します）。"
    },
    {
      "indent": 6,
      "text": "<Signature ID?>\n   <SignedInfo>\n     <CanonicalizationMethod/>\n     <SignatureMethod/>\n     (<Reference URI? >\n       (<Transforms>)?\n       <DigestMethod>\n       <DigestValue>\n     </Reference>)+\n   </SignedInfo>\n   <SignatureValue>\n  (<KeyInfo>)?\n  (<Object ID?>)*\n </Signature>",
      "raw": true,
      "ja": "<Signature ID?>\n   <SignedInfo>\n     <CanonicalizationMethod/>\n     <SignatureMethod/>\n     (<Reference URI? >\n       (<Transforms>)?\n       <DigestMethod>\n       <DigestValue>\n     </Reference>)+\n   </SignedInfo>\n   <SignatureValue>\n  (<KeyInfo>)?\n  (<Object ID?>)*\n </Signature>"
    },
    {
      "indent": 3,
      "text": "Signatures are related to data objects via URIs [URI]. Within an XML document, signatures are related to local data objects via fragment identifiers. Such local data can be included within an enveloping signature or can enclose an enveloped signature. Detached signatures are over external network resources or local data objects that reside within the same XML document as sibling elements; in this case, the signature is neither enveloping (signature is parent) nor enveloped attribute (signature is child). Since a Signature element (and its Id value/name) may co-exist or be combined with other elements (and their IDs) within a single XML document, care should be taken in choosing names such that there are no subsequent collisions that violate the ID uniqueness validity constraint [XML].",
      "ja": "署名は、URI [URI]を介してデータオブジェクトに関連付けられます。XMLドキュメント内では、署名はフラグメント識別子を介してローカルデータオブジェクトに関連付けられます。このようなローカルデータは、Enveloping（包含）署名内に含めることも、Enveloped（内包）署名を囲むこともできます。Detached（分離）署名は、外部ネットワークリソース、または兄弟要素として同じXMLドキュメント内に存在するローカルデータオブジェクトを対象とします。この場合、署名はEnveloping（署名が親）でもEnveloped（署名が子）でもありません。署名要素（およびそのID値/名前）は、単一のXMLドキュメント内の他の要素（およびそのID）と共存または組み合わせることができるため、ID一意性の妥当性制約[XML]に違反するような後続の衝突がないように名前を選択する際には注意が必要です。"
    },
    {
      "indent": 0,
      "text": "2.1 Simple Example (Signature, SignedInfo, Methods, and References)",
      "section_title": true,
      "ja": "2.1 簡単な例（署名、signedinfo、メソッド、参照）"
    },
    {
      "indent": 3,
      "text": "The following example is a detached signature of the content of the HTML4 in XML specification.",
      "ja": "次の例は、XML仕様におけるHTML4のコンテンツの分離された署名です。"
    },
    {
      "indent": 3,
      "text": " [s01] <Signature Id=\"MyFirstSignature\"\nxmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n [s02]   <SignedInfo>\n [s03]   <CanonicalizationMethod\nAlgorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n [s04]   <SignatureMethod\nAlgorithm=\"http://www.w3.org/2000/09/xmldsig#dsa-sha1\"/>\n [s05]   <Reference\nURI=\"http://www.w3.org/TR/2000/REC-xhtml1-20000126/\">\n [s06]     <Transforms>\n [s07]       <Transform\nAlgorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n [s08]     </Transforms>\n [s09]     <DigestMethod\nAlgorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>\n [s10]     <DigestValue>j6lwx3rvEPO0vKtMup4NbeVu8nk=</DigestValue>\n [s11]   </Reference>\n [s12] </SignedInfo>\n [s13]   <SignatureValue>MC0CFFrVLtRlk=...</SignatureValue>\n [s14]   <KeyInfo>\n [s15a]    <KeyValue>\n [s15b]      <DSAKeyValue>\n [s15c]        <P>...</P><Q>...</Q><G>...</G><Y>...</Y>\n [s15d]      </DSAKeyValue>\n [s15e]    </KeyValue>\n [s16]   </KeyInfo>\n [s17] </Signature>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[s02-12] The required SignedInfo element is the information that is actually signed. Core validation of SignedInfo consists of two mandatory processes: validation of the signature over SignedInfo and validation of each Reference digest within SignedInfo. Note that the algorithms used in calculating the SignatureValue are also included in the signed information while the SignatureValue element is outside SignedInfo.",
      "ja": "[s02-12] 必須のSignedInfo要素は、実際に署名される情報です。SignedInfoのコア検証は、2つの必須プロセスで構成されています。SignedInfoに対する署名の検証と、SignedInfo内の各Referenceダイジェストの検証です。SignatureValueの計算に使用されるアルゴリズムも署名情報に含まれている一方で、SignatureValue要素はSignedInfoの外側にあることに注意してください。"
    },
    {
      "indent": 3,
      "text": "[s03] The CanonicalizationMethod is the algorithm that is used to canonicalize the SignedInfo element before it is digested as part of the signature operation. Note that this example, and all examples in this specification, are not in canonical form.",
      "ja": "[s03] CanonicalizationMethodは、署名操作の一部としてダイジェストされる前にSignedInfo要素を正規化（canonicalize）するために使用されるアルゴリズムです。この例と、この仕様のすべての例は、正規化形式ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "[s04] The SignatureMethod is the algorithm that is used to convert the canonicalized SignedInfo into the SignatureValue. It is a combination of a digest algorithm and a key dependent algorithm and possibly other algorithms such as padding, for example RSA-SHA1. The algorithm names are signed to resist attacks based on substituting a weaker algorithm. To promote application interoperability we specify a set of signature algorithms that MUST be implemented, though their use is at the discretion of the signature creator. We specify additional algorithms as RECOMMENDED or OPTIONAL for implementation; the design also permits arbitrary user specified algorithms.",
      "ja": "[s04] SignatureMethodは、正規化されたSignedInfoをSignatureValueに変換するために使用されるアルゴリズムです。これは、ダイジェストアルゴリズムと鍵依存アルゴリズム、およびRSA-SHA1などのパディングなどの他のアルゴリズムの組み合わせです。アルゴリズム名は、より弱いアルゴリズムへの置換に基づく攻撃に抵抗するために署名されています。アプリケーションの相互運用性を促進するために、実装する必要がある一連の署名アルゴリズムを指定しますが、それらの使用は署名作成者の裁量にあります。実装に推奨またはオプションとして追加のアルゴリズムを指定します。この設計では、任意のユーザー指定されたアルゴリズムも許可します。"
    },
    {
      "indent": 3,
      "text": "[s05-11] Each Reference element includes the digest method and resulting digest value calculated over the identified data object. It may also include transformations that produced the input to the digest operation. A data object is signed by computing its digest value and a signature over that value. The signature is later checked via reference and signature validation.",
      "ja": "[s05-11] 各Reference要素には、識別されたデータオブジェクトに対して計算されたダイジェストメソッドと結果のダイジェスト値が含まれています。また、ダイジェスト操作への入力を生成する変換が含まれる場合があります。データオブジェクトは、そのダイジェスト値を計算し、その値に対して署名を行うことで署名されます。署名は、後で参照検証および署名検証によってチェックされます。"
    },
    {
      "indent": 3,
      "text": "[s14-16] KeyInfo indicates the key to be used to validate the signature. Possible forms for identification include certificates, key names, and key agreement algorithms and information -- we define only a few. KeyInfo is optional for two reasons. First, the signer may not wish to reveal key information to all document processing parties. Second, the information may be known within the application's context and need not be represented explicitly. Since KeyInfo is outside of SignedInfo, if the signer wishes to bind the keying information to the signature, a Reference can easily identify and include the KeyInfo as part of the signature.",
      "ja": "[s14-16] KeyInfoは、署名の検証に使用するキーを示します。識別のための可能な形式には、証明書、キー名、およびキー合意アルゴリズムと情報が含まれます。ここではいくつかのみを定義します。KeyInfoは、2つの理由でオプションです。まず、署名者は、すべてのドキュメント処理当事者に鍵情報を明らかにすることを望まない場合があります。第二に、情報はアプリケーションのコンテキスト内で知られている可能性があり、明示的に表現する必要はありません。KeyInfoはSignedInfoの外にあるため、署名者がキーイング情報を署名にバインドしたい場合、Referenceは署名の一部としてKeyInfoを簡単に識別して含めることができます。"
    },
    {
      "indent": 0,
      "text": "2.1.1 More on Reference",
      "section_title": true,
      "ja": "2.1.1 詳細については参照"
    },
    {
      "indent": 3,
      "text": " [s05]   <Reference\nURI=\"http://www.w3.org/TR/2000/REC-xhtml1-20000126/\">\n [s06]     <Transforms>\n [s07]       <Transform\nAlgorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n [s08]     </Transforms>\n [s09]     <DigestMethod\nAlgorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>\n [s10]     <DigestValue>j6lwx3rvEPO0vKtMup4NbeVu8nk=</DigestValue>\n [s11]   </Reference>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[s05] The optional URI attribute of Reference identifies the data object to be signed. This attribute may be omitted on at most one Reference in a Signature. (This limitation is imposed in order to ensure that references and objects may be matched unambiguously.)",
      "ja": "[s05] ReferenceのオプションのURI属性は、署名されるデータオブジェクトを識別します。この属性は、署名内の最大1つのReferenceで省略できます。（この制限は、参照とオブジェクトが一意に一致するようにするために課されます。）"
    },
    {
      "indent": 3,
      "text": "[s05-08] This identification, along with the transforms, is a description provided by the signer on how they obtained the signed data object in the form it was digested (i.e., the digested content). The verifier may obtain the digested content in another method so long as the digest verifies. In particular, the verifier may obtain the content from a different location such as a local store, as opposed to that specified in the URI.",
      "ja": "[s05-08] この識別は、変換とともに、署名者が署名対象のデータオブジェクトをダイジェストされた形式（つまり、ダイジェストされたコンテンツ）でどのように取得したかについて、署名者が提供する説明です。検証者は、ダイジェストが検証できる限り、別の方法でダイジェストされたコンテンツを取得できます。特に、検証者は、URIで指定されているものとは対照的に、ローカルストアなどの異なる場所からコンテンツを取得できます。"
    },
    {
      "indent": 3,
      "text": "[s06-08] Transforms is an optional ordered list of processing steps that were applied to the resource's content before it was digested. Transforms can include operations such as canonicalization, encoding/decoding (including compression/inflation), XSLT, XPath, XML schema validation, or XInclude. XPath transforms permit the signer to derive an XML document that omits portions of the source document. Consequently those excluded portions can change without affecting signature validity. For example, if the resource being signed encloses the signature itself, such a transform must be used to exclude the signature value from its own computation. If no Transforms element is present, the resource's content is digested directly. While the Working Group has specified mandatory (and optional) canonicalization and decoding algorithms, user specified transforms are permitted.",
      "ja": "[s06-08] Transformsは、ダイジェストされる前にリソースのコンテンツに適用された処理手順の、任意の順序付けられたリストです。変換には、正規化、エンコード/デコード（圧縮/展開を含む）、XSLT、XPath、XMLスキーマ検証、XIncludeなどの操作が含まれます。XPath変換により、署名者はソースドキュメントの一部を省略したXMLドキュメントを導き出すことができます。したがって、これらの除外された部分は、署名の有効性に影響を与えることなく変化する可能性があります。たとえば、署名されているリソースが署名自体を囲む場合、そのような変換を使用して、独自の計算から署名値を除外する必要があります。Transforms要素が存在しない場合、リソースのコンテンツは直接ダイジェストされます。ワーキンググループは、必須の（およびオプションの）正規化およびデコードアルゴリズムを指定していますが、ユーザーが指定した変換も許可されています。"
    },
    {
      "indent": 3,
      "text": "[s09-10] DigestMethod is the algorithm applied to the data after Transforms is applied (if specified) to yield the DigestValue. The signing of the DigestValue is what binds a resources content to the signer's key.",
      "ja": "[s09-10] DigestMethodは、Transformsが適用された後に（指定されている場合）データに適用され、DigestValueを生成するアルゴリズムです。DigestValueへの署名は、リソースコンテンツを署名者の鍵にバインドするものです。"
    },
    {
      "indent": 0,
      "text": "2.2 Extended Example (Object and SignatureProperty)",
      "section_title": true,
      "ja": "2.2 拡張例（オブジェクトと署名プロパティ）"
    },
    {
      "indent": 3,
      "text": "This specification does not address mechanisms for making statements or assertions. Instead, this document defines what it means for something to be signed by an XML Signature (integrity, message authentication, and/or signer authentication). Applications that wish to represent other semantics must rely upon other technologies, such as [XML, RDF]. For instance, an application might use a foo:assuredby attribute within its own markup to reference a Signature element. Consequently, it's the application that must understand and know how to make trust decisions given the validity of the signature and the meaning of assuredby syntax. We also define a SignatureProperties element type for the inclusion of assertions about the signature itself (e.g., signature semantics, the time of signing or the serial number of hardware used in cryptographic processes). Such assertions may be signed by including a Reference for the SignatureProperties in SignedInfo. While the signing application should be very careful about what it signs (it should understand what is in the SignatureProperty) a receiving application has no obligation to understand that semantic (though its parent trust engine may wish to). Any content about the signature generation may be located within the SignatureProperty element. The mandatory Target attribute references the Signature element to which the property applies.",
      "ja": "この仕様は、ステートメントやアサーションを作成するためのメカニズムについては扱っていません。代わりに、このドキュメントでは、何かがXML署名によって署名されること（完全性、メッセージ認証、および/または署名者認証）の意味を定義します。他のセマンティクスを表現したいアプリケーションは、[XML, RDF]などの他の技術に依存する必要があります。たとえば、アプリケーションは独自のマークアップ内で foo:assuredby 属性を使用してSignature要素を参照するかもしれません。その結果、署名の有効性と assuredby 構文の意味を考慮して、信頼の決定を下す方法を理解し、知る必要があるのはアプリケーションとなります。また、署名自体に関するアサーション（例えば、署名のセマンティクス、署名時刻、または暗号化プロセスで使用されるハードウェアのシリアル番号など）を含めるための SignatureProperties 要素タイプを定義します。このようなアサーションは、SignedInfo に SignatureProperties の Reference を含めることにより署名される場合があります。署名アプリケーションは、署名する内容について非常に注意する必要がありますが（SignatureProperty にあるものを理解する必要があります）、受信アプリケーションにはそのセマンティックを理解する義務はありません（親の信頼エンジンは望むかもしれませんが）。署名生成に関するコンテンツは、SignatureProperty 要素内に配置できます。必須の Target 属性は、プロパティが適用される Signature 要素を参照します。"
    },
    {
      "indent": 3,
      "text": "Consider the preceding example with an additional reference to a local Object that includes a SignatureProperty element. (Such a signature would not only be detached [p02] but enveloping [p03].)",
      "ja": "SignatureProperty要素を含むローカルObjectへの追加の参照を加えた、前の例を考えてみましょう。（そのような署名は、Detached [p02]であるだけでなく、Enveloping [p03]でもあります。）"
    },
    {
      "indent": 3,
      "text": " [   ]  <Signature Id=\"MySecondSignature\" ...>\n [p01]  <SignedInfo>\n [   ]   ...\n [p02]   <Reference URI=\"http://www.w3.org/TR/xml-stylesheet/\">\n [   ]   ...\n [p03]   <Reference URI=\"#AMadeUpTimeStamp\"\n [p04]\nType=\"http://www.w3.org/2000/09/xmldsig#SignatureProperties\">\n [p05]    <DigestMethod\nAlgorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>\n [p06]    <DigestValue>k3453rvEPO0vKtMup4NbeVu8nk=</DigestValue>\n [p07]   </Reference>\n [p08]  </SignedInfo>\n [p09]  ...\n [p10]  <Object>\n [p11]   <SignatureProperties>\n [p12]     <SignatureProperty Id=\"AMadeUpTimeStamp\"\nTarget=\"#MySecondSignature\">\n [p13]        <timestamp xmlns=\"http://www.ietf.org/rfcXXXX.txt\">\n [p14]          <date>19990908</date>\n [p15]          <time>14:34:34:34</time>\n [p16]        </timestamp>\n [p17]     </SignatureProperty>\n [p18]   </SignatureProperties>\n [p19]  </Object>\n [p20]</Signature>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[p04] The optional Type attribute of Reference provides information about the resource identified by the URI. In particular, it can indicate that it is an Object, SignatureProperty, or Manifest element. This can be used by applications to initiate special processing of some Reference elements. References to an XML data element within an Object element SHOULD identify the actual element pointed to. Where the element content is not XML (perhaps it is binary or encoded data) the reference should identify the Object and the Reference Type, if given, SHOULD indicate Object. Note that Type is advisory and no action based on it or checking of its correctness is required by core behavior.",
      "ja": "[p04] Referenceの任意のType属性は、URIによって識別されたリソースに関する情報を提供します。特に、それがObject、SignatureProperty、またはManifest要素であることを示すことができます。これは、いくつかのReference要素の特別な処理を開始するためにアプリケーションで使用できます。Object要素内のXMLデータ要素への参照は、指し示された実際の要素を識別する必要があります（SHOULD）。要素コンテンツがXMLではない場合（おそらくそれはバイナリまたはエンコードされたデータです）、参照はObjectを識別すべきであり、Reference Typeが与えられた場合、Objectを示す必要があります（SHOULD）。Typeは参考情報であり、それに基づいたアクションやその正しさのチェックは、コアの動作によって必要とされないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "[p10] Object is an optional element for including data objects within the signature element or elsewhere. The Object can be optionally typed and/or encoded.",
      "ja": "[p10] Objectは、署名要素内または他の場所にデータオブジェクトを含めるための任意の要素です。Objectは、任意で型付けおよび/またはエンコードすることができます。"
    },
    {
      "indent": 3,
      "text": "[p11-18] Signature properties, such as time of signing, can be optionally signed by identifying them from within a Reference. (These properties are traditionally called signature \"attributes\" although that term has no relationship to the XML term \"attribute\".)",
      "ja": "[p11-18] 署名時刻などの署名プロパティは、Reference内からそれらを識別することにより任意に署名できます。（これらのプロパティは伝統的に署名「属性(attributes)」と呼ばれていますが、その用語はXML用語の「属性(attribute)」とは関係ありません。）"
    },
    {
      "indent": 0,
      "text": "2.3 Extended Example (Object and Manifest)",
      "section_title": true,
      "ja": "2.3 拡張例（オブジェクトとマニフェスト）"
    },
    {
      "indent": 3,
      "text": "The Manifest element is provided to meet additional requirements not directly addressed by the mandatory parts of this specification. Two requirements and the way the Manifest satisfies them follow.",
      "ja": "マニフェスト要素は、この仕様の必須部分で直接対処されない追加の要件を満たすために提供されます。2つの要件とマニフェストがそれらを満たす方法。"
    },
    {
      "indent": 3,
      "text": "First, applications frequently need to efficiently sign multiple data objects even where the signature operation itself is an expensive public key signature. This requirement can be met by including multiple Reference elements within SignedInfo since the inclusion of each digest secures the data digested. However, some applications may not want the core validation behavior associated with this approach because it requires every Reference within SignedInfo to undergo reference validation -- the DigestValue elements are checked. These applications may wish to reserve reference validation decision logic to themselves. For example, an application might receive a signature valid SignedInfo element that includes three Reference elements. If a single Reference fails (the identified data object when digested does not yield the specified DigestValue) the signature would fail core validation. However, the application may wish to treat the signature over the two valid Reference elements as valid or take different actions depending on which fails. To accomplish this, SignedInfo would reference a Manifest element that contains one or more Reference elements (with the same structure as those in SignedInfo). Then, reference validation of the Manifest is under application control.",
      "ja": "第一に、署名操作自体が高価な公開鍵署名である場合でも、アプリケーションは複数のデータオブジェクトに効率的に署名する必要があることがよくあります。この要件は、各ダイジェストを含めることでダイジェストされたデータを保護するため、SignedInfoに複数のReference要素を含めることで満たすことができます。ただし、一部のアプリケーションでは、このアプローチに関連付けられたコア検証動作を望まない場合があります。これは、SignedInfo内のすべてのReferenceが参照検証を受ける必要があるためです（DigestValue要素がチェックされます）。これらのアプリケーションは、参照検証の決定ロジックを自分自身に委ねたいと考える場合があります。たとえば、アプリケーションは、3つのReference要素を含む、署名が有効なSignedInfo要素を受信する場合があります。単一のReferenceが失敗した場合（ダイジェストされたときに識別されたデータオブジェクトが指定されたDigestValueを生成しない）、署名はコア検証に失敗します。ただし、アプリケーションは、2つの有効なReference要素に対する署名を有効なものとして扱うか、どれが失敗したかに応じて異なるアクションを実行したいと考える場合があります。これを達成するために、SignedInfoは、1つ以上のReference要素を含むManifest要素を参照します（SignedInfoの構造と同じ構造を持つ）。そうすれば、Manifestの参照検証はアプリケーションの制御下になります。"
    },
    {
      "indent": 3,
      "text": "Second, consider an application where many signatures (using different keys) are applied to a large number of documents. An inefficient solution is to have a separate signature (per key) repeatedly applied to a large SignedInfo element (with many References); this is wasteful and redundant. A more efficient solution is to include many references in a single Manifest that is then referenced from multiple Signature elements.",
      "ja": "第二に、多くの署名（異なるキーを使用）が多数のドキュメントに適用されるアプリケーションを考えてみましょう。非効率的な解決策は、大きなSignedInfo要素（多くの参照を含む）に対して、個別の署名（キーごと）を繰り返し適用することです。これは無駄で冗長です。より効率的な解決策は、複数の署名要素から参照される単一のマニフェストに多くの参照を含めることです。"
    },
    {
      "indent": 3,
      "text": "The example below includes a Reference that signs a Manifest found within the Object element.",
      "ja": "以下の例には、オブジェクト要素内で見つかったマニフェストに署名する参照が含まれています。"
    },
    {
      "indent": 3,
      "text": " [   ] ...\n [m01]   <Reference URI=\"#MyFirstManifest\"\n [m02]     Type=\"http://www.w3.org/2000/09/xmldsig#Manifest\">\n [m03]     <DigestMethod\nAlgorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>\n [m04]     <DigestValue>345x3rvEPO0vKtMup4NbeVu8nk=</DigestValue>\n [m05]   </Reference>\n [   ] ...\n [m06] <Object>\n [m07]   <Manifest Id=\"MyFirstManifest\">\n [m08]     <Reference>\n [m09]     ...\n [m10]     </Reference>\n [m11]     <Reference>\n [m12]     ...\n [m13]     </Reference>\n [m14]   </Manifest>\n [m15] </Object>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.0 Processing Rules",
      "section_title": true,
      "ja": "3.0 処理ルール"
    },
    {
      "indent": 3,
      "text": "The sections below describe the operations to be performed as part of signature generation and validation.",
      "ja": "以下のセクションでは、署名の生成と検証の一部として実行される操作について説明します。"
    },
    {
      "indent": 0,
      "text": "3.1 Core Generation",
      "section_title": true,
      "ja": "3.1 コア生成"
    },
    {
      "indent": 3,
      "text": "The REQUIRED steps include the generation of Reference elements and the SignatureValue over SignedInfo.",
      "ja": "必要な手順には、参照要素の生成とSignedInfo上の署名バリューが含まれます。"
    },
    {
      "indent": 0,
      "text": "3.1.1 Reference Generation",
      "section_title": true,
      "ja": "3.1.1 参照生成"
    },
    {
      "indent": 3,
      "text": "For each data object being signed:",
      "ja": "署名されている各データオブジェクトについて："
    },
    {
      "indent": 3,
      "text": "1. Apply the Transforms, as determined by the application, to the data object. 2. Calculate the digest value over the resulting data object. 3. Create a Reference element, including the (optional) identification of the data object, any (optional) transform elements, the digest algorithm and the DigestValue. (Note, it is the canonical form of these references that are signed in 3.1.2 and validated in 3.2.1.)",
      "ja": "1. アプリケーションによって決定されたTransformsをデータオブジェクトに適用します。2. 結果のデータオブジェクトでダイジェスト値を計算します。3. データオブジェクトの（任意の）識別、任意の（任意の）Transform要素、ダイジェストアルゴリズム、DigestValueを含むReference要素を作成します。（注：3.1.2で署名され、3.2.1で検証されるのは、これらの参照の正規化形式です。）"
    },
    {
      "indent": 0,
      "text": "3.1.2 Signature Generation",
      "section_title": true,
      "ja": "3.1.2 署名生成"
    },
    {
      "indent": 3,
      "text": "1. Create SignedInfo element with SignatureMethod, CanonicalizationMethod and Reference(s). 2. Canonicalize and then calculate the SignatureValue over SignedInfo based on algorithms specified in SignedInfo.",
      "ja": "1. SignatureMethod、CanonicalizationMethod、およびReferenceを使用してSignedInfo要素を作成します。2. SignedInfoで指定されたアルゴリズムに基づいて、SignedInfoを正規化し、SignatureValueを計算します。"
    },
    {
      "indent": 3,
      "text": "3. Construct the Signature element that includes SignedInfo, Object(s) (if desired, encoding may be different than that used for signing), KeyInfo (if required), and SignatureValue.",
      "ja": "3. SignedInfo、Object（必要に応じて、エンコードは署名に使用されるものとは異なる場合があります）、KeyInfo（必要に応じて）、およびSignatureValueを含むSignature要素を作成します。"
    },
    {
      "indent": 3,
      "text": "Note, if the Signature includes same-document references, [XML] or [XML-schema] validation of the document might introduce changes that break the signature. Consequently, applications should be careful to consistently process the document or refrain from using external contributions (e.g., defaults and entities).",
      "ja": "署名に同じドキュメント参照が含まれている場合、[XML]または[XML-Schema]ドキュメントの検証により、署名を破る変更が導入される可能性があります。したがって、アプリケーションは、ドキュメントを一貫して処理するか、外部の貢献（デフォルトやエンティティなど）の使用を控えるように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2 Core Validation",
      "section_title": true,
      "ja": "3.2 コア検証"
    },
    {
      "indent": 3,
      "text": "The REQUIRED steps of core validation include (1) reference validation, the verification of the digest contained in each Reference in SignedInfo, and (2) the cryptographic signature validation of the signature calculated over SignedInfo.",
      "ja": "コア検証の必要な手順には、（1）参照検証、SignedInfoの各Referenceに含まれるダイジェストの検証、および（2）SignedInfoで計算された署名の暗号化署名検証が含まれます。"
    },
    {
      "indent": 3,
      "text": "Note, there may be valid signatures that some signature applications are unable to validate. Reasons for this include failure to implement optional parts of this specification, inability or unwillingness to execute specified algorithms, or inability or unwillingness to dereference specified URIs (some URI schemes may cause undesirable side effects), etc.",
      "ja": "注意：一部の署名アプリケーションが検証できない有効な署名があるかもしれません。この理由には、この仕様の任意の部分を実装していないこと、指定されたアルゴリズムを実行できない、または実行したくないこと、または指定されたURIを参照解決できない、または参照解決したくないこと（一部のURIスキームは望ましくない副作用を引き起こす可能性があります）などが含まれます。"
    },
    {
      "indent": 3,
      "text": "Comparison of values in reference and signature validation are over the numeric (e.g., integer) or decoded octet sequence of the value. Different implementations may produce different encoded digest and signature values when processing the same resources because of variances in their encoding, such as accidental white space. But if one uses numeric or octet comparison (choose one) on both the stated and computed values these problems are eliminated.",
      "ja": "参照と署名検証の値の比較は、値の数値（整数など）またはデコードされたオクテットシーケンスを介して行われます。実装が異なると、偶発的な空白などのエンコードの分散のため、同じリソースを処理するときに、異なるエンコードされたダイジェスト値と署名値が生成される場合があります。ただし、指定された値と計算値の両方で数値比較またはオクテット比較（1つを選択）を使用する場合、これらの問題は排除されます。"
    },
    {
      "indent": 0,
      "text": "3.2.1 Reference Validation",
      "section_title": true,
      "ja": "3.2.1 参照検証"
    },
    {
      "indent": 3,
      "text": "1. Canonicalize the SignedInfo element based on the CanonicalizationMethod in SignedInfo. 2. For each Reference in SignedInfo: 2.1 Obtain the data object to be digested. (For example, the signature application may dereference the URI and execute Transforms provided by the signer in the Reference element, or it may obtain the content through other means such as a local cache.) 2.2 Digest the resulting data object using the DigestMethod specified in its Reference specification. 2.3 Compare the generated digest value against DigestValue in the SignedInfo Reference; if there is any mismatch, validation fails.",
      "ja": "1. SignedInfoのCanonicalizationMethodに基づいて、SignedInfo要素を正規化します。2. SignedInfoの各Referenceについて：2.1 ダイジェストするデータオブジェクトを取得します。（たとえば、署名アプリケーションは、URIを参照解決し、Reference要素で署名者が提供するTransformsを実行するか、ローカルキャッシュなどの他の手段を介してコンテンツを取得する場合があります。）2.2 そのReference仕様で指定されたDigestMethodを使用して、結果のデータオブジェクトをダイジェストします。2.3 生成されたダイジェスト値をSignedInfo ReferenceのDigestValueと比較します。不一致がある場合、検証は失敗します。"
    },
    {
      "indent": 3,
      "text": "Note, SignedInfo is canonicalized in step 1. The application must ensure that the CanonicalizationMethod has no dangerous side affects, such as rewriting URIs, (see CanonicalizationMethod (section 4.3)) and that it Sees What is Signed, which is the canonical form.",
      "ja": "注：SignedInfoはステップ1で正規化されます。アプリケーションは、CanonicalizationMethodにURIの書き換えなどの危険な副作用がないこと（CanonicalizationMethod（セクション4.3）を参照）、および「署名されているものを見る（Sees What is Signed）」（これは正規化形式です）ことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.2 Signature Validation",
      "section_title": true,
      "ja": "3.2.2 署名検証"
    },
    {
      "indent": 3,
      "text": "1. Obtain the keying information from KeyInfo or from an external source. 2. Obtain the canonical form of the SignatureMethod using the CanonicalizationMethod and use the result (and previously obtained KeyInfo) to confirm the SignatureValue over the SignedInfo element.",
      "ja": "1. KeyInfoまたは外部ソースからキーイング情報を取得します。2. CanonicalizationMethodを使用してSignatureMethodの正規化形式を取得し、結果（および以前に取得したKeyInfo）を使用して、SignedInfo要素に対するSignatureValueを確認します。"
    },
    {
      "indent": 3,
      "text": "Note, KeyInfo (or some transformed version thereof) may be signed via a Reference element. Transformation and validation of this reference (3.2.1) is orthogonal to Signature Validation which uses the KeyInfo as parsed.",
      "ja": "注意：KeyInfo（またはその変換バージョン）は、Reference要素を介して署名される場合があります。この参照の変換と検証（3.2.1）は、解析されたKeyInfoを使用する署名検証とは直交しています。"
    },
    {
      "indent": 3,
      "text": "Additionally, the SignatureMethod URI may have been altered by the canonicalization of SignedInfo (e.g., absolutization of relative URIs) and it is the canonical form that MUST be used. However, the required canonicalization [XML-C14N] of this specification does not change URIs.",
      "ja": "さらに、SignatureMethod URIは、SignedInfo（例えば、相対URIの絶対化）の正規化によって変更された可能性があり、使用する必要があるのは正規化形式です。ただし、この仕様の必須の正規化[XML-C14N]はURIを変化させません。"
    },
    {
      "indent": 0,
      "text": "4.0 Core Signature Syntax",
      "section_title": true,
      "ja": "4.0 コア署名構文"
    },
    {
      "indent": 3,
      "text": "The general structure of an XML signature is described in Signature Overview (section 2). This section provides detailed syntax of the core signature features. Features described in this section are mandatory to implement unless otherwise indicated. The syntax is defined via DTDs and [XML-Schema] with the following XML preamble, declaration, and internal entity.",
      "ja": "XML署名の一般的な構造については、署名の概要（セクション2）で説明されています。このセクションでは、コア署名機能の詳細な構文を提供します。このセクションで説明する機能は、特に示されない限り実装することが必須です。構文は、次のXMLプリアンブル、宣言、および内部エンティティを使用して、DTDおよび[XML-Schema]を介して定義されます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 3,
      "text": "   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <!DOCTYPE schema\n     PUBLIC \"-//W3C//DTD XMLSchema 200102//EN\"\n\"http://www.w3.org/2001/XMLSchema.dtd\"\n    [\n      <!ATTLIST schema\n        xmlns:ds CDATA #FIXED \"http://www.w3.org/2000/09/xmldsig#\">\n      <!ENTITY dsig 'http://www.w3.org/2000/09/xmldsig#'>\n      <!ENTITY % p ''>\n      <!ENTITY % s ''>\n     ]>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\n        xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n        targetNamespace=\"http://www.w3.org/2000/09/xmldsig#\"\n        version=\"0.1\" elementFormDefault=\"qualified\">",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!--",
      "ja": "<！ - "
    },
    {
      "indent": 6,
      "text": "The following entity declarations enable external/flexible content in the Signature content model.",
      "ja": "次のエンティティ宣言により、署名コンテンツモデルで外部/柔軟なコンテンツが可能になります。"
    },
    {
      "indent": 6,
      "text": "#PCDATA emulates schema:string; when combined with element types it emulates schema mixed=\"true\".",
      "ja": "#pcdataはスキーマをエミュレートします：string;要素タイプと組み合わせると、スキーマMixed = \"true\"をエミュレートします。"
    },
    {
      "indent": 6,
      "text": "%foo.ANY permits the user to include their own element types from\nother namespaces, for example:\n  <!ENTITY % KeyValue.ANY '| ecds:ECDSAKeyValue'>\n  ...\n  <!ELEMENT ecds:ECDSAKeyValue (#PCDATA)  >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "-->",
      "ja": " - >"
    },
    {
      "indent": 6,
      "text": "<!ENTITY % Object.ANY ''>\n<!ENTITY % Method.ANY ''>\n<!ENTITY % Transform.ANY ''>\n<!ENTITY % SignatureProperty.ANY ''>\n<!ENTITY % KeyInfo.ANY ''>\n<!ENTITY % KeyValue.ANY ''>\n<!ENTITY % PGPData.ANY ''>\n<!ENTITY % X509Data.ANY ''>\n<!ENTITY % SPKIData.ANY ''>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.0.1 The ds:CryptoBinary Simple Type",
      "section_title": true,
      "ja": "4.0.1 DS：Cryptobinary Simple Type"
    },
    {
      "indent": 3,
      "text": "This specification defines the ds:CryptoBinary simple type for representing arbitrary-length integers (e.g., \"bignums\") in XML as octet strings. The integer value is first converted to a \"big endian\" bitstring. The bitstring is then padded with leading zero bits so that the total number of bits == 0 mod 8 (so that there are an integral number of octets). If the bitstring contains entire leading octets that are zero, these are removed (so the high-order octet is always non-zero). This octet string is then base64 [MIME] encoded. (The conversion from integer to octet string is equivalent to IEEE 1363's I2OSP [1363] with minimal length).",
      "ja": "この仕様では、XMLの任意の長さの整数（「bignum」など）をオクテット文字列として表現するためのds:CryptoBinary単純型を定義します。整数値は、最初に「ビッグエンディアン」ビットストリングに変換されます。次に、ビットストリングには、ビットの総数== 0 mod 8（オクテットの整数倍になるように）になるように、先頭にゼロビットがパディングされます。ビットストリングにゼロの先頭オクテット全体が含まれている場合、これらは削除されます（したがって、高次のオクテットは常にゼロではありません）。このオクテット文字列は、base64 [MIME]エンコードされます。（整数からオクテット文字列への変換は、長さが最小限のIEEE 1363のI2OSP [1363]と同等です）。"
    },
    {
      "indent": 3,
      "text": "This type is used by \"bignum\" values such as RSAKeyValue and DSAKeyValue. If a value can be of type base64Binary or ds:CryptoBinary they are defined as base64Binary. For example, if the signature algorithm is RSA or DSA then SignatureValue represents a bignum and could be ds:CryptoBinary. However, if HMAC-SHA1 is the signature algorithm then SignatureValue could have leading zero octets that must be preserved. Thus SignatureValue is generically defined as of type base64Binary.",
      "ja": "このタイプは、RSAKeyValueやDSAKeyValueなどの「bignum」値で使用されます。値が base64Binary または ds:CryptoBinary の型になり得る場合、それらは base64Binary として定義されます。たとえば、署名アルゴリズムがRSAまたはDSAの場合、SignatureValueはbignumを表し、ds:CryptoBinaryになる可能性があります。ただし、HMAC-SHA1が署名アルゴリズムである場合、SignatureValueは保存する必要がある先行ゼロオクテットを持つ可能性があります。したがって、SignatureValueは、base64Binary型として一般的に定義されます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<simpleType name=\"CryptoBinary\">\n  <restriction base=\"base64Binary\">\n  </restriction>\n</simpleType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1 The Signature element",
      "section_title": true,
      "ja": "4.1 署名要素"
    },
    {
      "indent": 3,
      "text": "The Signature element is the root element of an XML Signature. Implementation MUST generate laxly schema valid [XML-schema] Signature elements as specified by the following schema:",
      "ja": "Signature要素は、XML署名のルート要素です。実装は、次のスキーマで指定されているように、laxly schema valid [XML-Schema] なSignature要素を生成する必要があります。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"Signature\" type=\"ds:SignatureType\"/>\n<complexType name=\"SignatureType\">\n  <sequence>\n    <element ref=\"ds:SignedInfo\"/>\n    <element ref=\"ds:SignatureValue\"/>\n    <element ref=\"ds:KeyInfo\" minOccurs=\"0\"/>\n    <element ref=\"ds:Object\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n  </sequence>\n  <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 3,
      "text": "   <!ELEMENT Signature (SignedInfo, SignatureValue, KeyInfo?,\nObject*)  >\n   <!ATTLIST Signature\n    xmlns   CDATA   #FIXED 'http://www.w3.org/2000/09/xmldsig#'\n    Id      ID  #IMPLIED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2 The SignatureValue Element",
      "section_title": true,
      "ja": "4.2 SignatureValue要素"
    },
    {
      "indent": 3,
      "text": "The SignatureValue element contains the actual value of the digital signature; it is always encoded using base64 [MIME]. While we identify two SignatureMethod algorithms, one mandatory and one optional to implement, user specified algorithms may be used as well.",
      "ja": "SignatureValue要素には、デジタル署名の実際の値が含まれています。base64 [MIME]を使用して常にエンコードされます。2つのSignatureMethodアルゴリズムを識別しますが、1つは必須であり、1つは実装するオプションですが、ユーザーが指定したアルゴリズムも使用できます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"SignatureValue\" type=\"ds:SignatureValueType\"/>\n<complexType name=\"SignatureValueType\">\n  <simpleContent>\n    <extension base=\"base64Binary\">\n      <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n    </extension>\n  </simpleContent>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT SignatureValue (#PCDATA) >\n<!ATTLIST SignatureValue\n          Id  ID      #IMPLIED>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3 The SignedInfo Element",
      "section_title": true,
      "ja": "4.3 SignedInfo要素"
    },
    {
      "indent": 3,
      "text": "The structure of SignedInfo includes the canonicalization algorithm, a signature algorithm, and one or more references. The SignedInfo element may contain an optional ID attribute that will allow it to be referenced by other signatures and objects.",
      "ja": "SignedInfoの構造には、正規化アルゴリズム、署名アルゴリズム、および1つ以上の参照が含まれます。SignedInfo要素には、他の署名やオブジェクトによって参照できるオプションのID属性が含まれている場合があります。"
    },
    {
      "indent": 3,
      "text": "SignedInfo does not include explicit signature or digest properties (such as calculation time, cryptographic device serial number, etc.). If an application needs to associate properties with the signature or digest, it may include such information in a SignatureProperties element within an Object element.",
      "ja": "SignedInfoには、明示的な署名またはダイジェストプロパティ（計算時間、暗号化デバイスのシリアル番号など）は含まれません。アプリケーションがプロパティを署名またはダイジェストに関連付ける必要がある場合、そのような情報をオブジェクト要素内の署名プロパリティ要素に含めることができます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"SignedInfo\" type=\"ds:SignedInfoType\"/>\n<complexType name=\"SignedInfoType\">\n  <sequence>\n    <element ref=\"ds:CanonicalizationMethod\"/>\n    <element ref=\"ds:SignatureMethod\"/>\n    <element ref=\"ds:Reference\" maxOccurs=\"unbounded\"/>\n  </sequence>\n  <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT SignedInfo (CanonicalizationMethod,\n SignatureMethod,  Reference+)  >\n<!ATTLIST SignedInfo\n Id   ID      #IMPLIED",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3.1 The CanonicalizationMethod Element",
      "section_title": true,
      "ja": "4.3.1 CanonicalizationMethod要素"
    },
    {
      "indent": 3,
      "text": "CanonicalizationMethod is a required element that specifies the canonicalization algorithm applied to the SignedInfo element prior to performing signature calculations. This element uses the general structure for algorithms described in Algorithm Identifiers and Implementation Requirements (section 6.1). Implementations MUST support the REQUIRED canonicalization algorithms.",
      "ja": "CanonicalizationMethodは、署名計算を実行する前にSignedInfo要素に適用される正規化アルゴリズムを指定する必須要素です。この要素は、アルゴリズム識別子と実装要件で説明されているアルゴリズムの一般構造を使用します（セクション6.1）。実装は、必要な正規化アルゴリズムをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Alternatives to the REQUIRED canonicalization algorithms (section 6.5), such as Canonical XML with Comments (section 6.5.1) or a minimal canonicalization (such as CRLF and charset normalization), may be explicitly specified but are NOT REQUIRED. Consequently, their use may not interoperate with other applications that do not support the specified algorithm (see XML Canonicalization and Syntax Constraint Considerations, section 7). Security issues may also arise in the treatment of entity processing and comments if non-XML aware canonicalization algorithms are not properly constrained (see section 8.2: Only What is \"Seen\" Should be Signed).",
      "ja": "コメント付きのCanonical XML（セクション6.5.1）または最小限の正規化（CRLFや文字セット正規化など）など、必須の正規化アルゴリズム（セクション6.5）の代替案は、明示的に指定される場合がありますが、必須ではありません（NOT REQUIRED）。したがって、それらの使用は、指定されたアルゴリズムをサポートしていない他のアプリケーションと相互運用しない可能性があります（XML正規化および構文制約の考慮事項、セクション7を参照）。また、XMLを認識しない正規化アルゴリズムが適切に制約されていない場合、エンティティ処理とコメントの処理でセキュリティの問題が発生する可能性があります（セクション8.2：「見られる」もののみに署名する必要があるを参照してください）。"
    },
    {
      "indent": 3,
      "text": "The way in which the SignedInfo element is presented to the canonicalization method is dependent on that method. The following applies to algorithms which process XML as nodes or characters:",
      "ja": "SignedInfo要素が正規化メソッドに提示される方法は、そのメソッドに依存します。以下は、XMLをノードまたは文字として処理するアルゴリズムに適用されます。"
    },
    {
      "indent": 6,
      "text": "* XML based canonicalization implementations MUST be provided with a [XPath] node-set originally formed from the document containing the SignedInfo and currently indicating the SignedInfo, its descendants, and the attribute and namespace nodes of SignedInfo and its descendant elements.",
      "ja": "* XMLベースの正規化の実装には、SignedInfoを含むドキュメントから元々形成され、現在はSignedInfo、その子孫、およびSignedInfoとその子孫要素の属性と名前空間ノードを示す[XPath]ノードセットを提供しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* Text based canonicalization algorithms (such as CRLF and charset normalization) should be provided with the UTF-8 octets that represent the well-formed SignedInfo element, from the first character to the last character of the XML representation, inclusive. This includes the entire text of the start and end tags of the SignedInfo element as well as all descendant markup and character data (i.e., the text) between those tags. Use of text based canonicalization of SignedInfo is NOT RECOMMENDED.",
      "ja": "* テキストベースの正規化アルゴリズム（CRLFや文字セット正規化など）には、整形式のSignedInfo要素を表すUTF-8オクテットを、XML表現の最初の文字から最後の文字まで（両端を含む）提供する必要があります。これには、SignedInfo要素の開始タグと終了タグのテキスト全体と、それらのタグ間のすべての子孫マークアップおよびキャラクターデータ（つまり、テキスト）が含まれます。SignedInfoのテキストベースの正規化の使用は推奨されません。"
    },
    {
      "indent": 3,
      "text": "We recommend applications that implement a text-based instead of XML-based canonicalization -- such as resource constrained apps -- generate canonicalized XML as their output serialization so as to mitigate interoperability and security concerns. For instance, such an implementation SHOULD (at least) generate standalone XML instances [XML].",
      "ja": "リソースが制約されたアプリなど、XMLベースの正規化の代わりにテキストベースを実装するアプリケーションは、相互運用性とセキュリティの懸念を緩和するために、出力シリアル化として正規化されたXMLを生成することをお勧めします。たとえば、このような実装は、（少なくとも）スタンドアロンXMLインスタンス[XML]を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTE: The signature application must exercise great care in accepting and executing an arbitrary CanonicalizationMethod. For example, the canonicalization method could rewrite the URIs of the References being validated. Or, the method could massively transform SignedInfo so that validation would always succeed (i.e., converting it to a trivial signature with a known key over trivial data). Since CanonicalizationMethod is inside SignedInfo, in the resulting canonical form it could erase itself from SignedInfo or modify the SignedInfo element so that it appears that a different canonicalization function was used! Thus a Signature which appears to authenticate the desired data with the desired key, DigestMethod, and SignatureMethod, can be meaningless if a capricious CanonicalizationMethod is used.",
      "ja": "注：署名アプリケーションは、任意のCanonicalizationMethodの受け入れと実行に細心の注意を払わなければなりません。たとえば、正規化メソッドは、検証されているReferenceのURIを書き換えることができます。または、このメソッドはSignedInfoを大幅に変換して、常に検証が成功するようにすることができます（つまり、些細なデータに対して既知のキーを使用した些細な署名に変換する）。CanonicalizationMethodはSignedInfo内にあるため、結果の正規化形式では、SignedInfoから自身を消去したり、SignedInfo要素を変更して、異なる正規化関数が使用されたように見せかけることができます。したがって、目的のキー、DigestMethod、およびSignatureMethodを使用して目的のデータを認証するように見える署名でも、気まぐれなCanonicalizationMethodが使用されている場合は、無意味になる可能性があります。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"CanonicalizationMethod\"\n         type=\"ds:CanonicalizationMethodType\"/>\n<complexType name=\"CanonicalizationMethodType\" mixed=\"true\">\n  <sequence>\n    <any namespace=\"##any\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n    <!-- (0,unbounded) elements from (1,1) namespace -->\n  </sequence>\n  <attribute name=\"Algorithm\" type=\"anyURI\" use=\"required\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT CanonicalizationMethod (#PCDATA %Method.ANY;)* >\n<!ATTLIST CanonicalizationMethod\n Algorithm CDATA #REQUIRED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3.2 The SignatureMethod Element",
      "section_title": true,
      "ja": "4.3.2 SignatureMethod要素"
    },
    {
      "indent": 3,
      "text": "SignatureMethod is a required element that specifies the algorithm used for signature generation and validation. This algorithm identifies all cryptographic functions involved in the signature operation (e.g., hashing, public key algorithms, MACs, padding, etc.). This element uses the general structure here for algorithms described in section 6.1: Algorithm Identifiers and Implementation Requirements. While there is a single identifier, that identifier may specify a format containing multiple distinct signature values.",
      "ja": "SignatureMethodは、署名の生成と検証に使用されるアルゴリズムを指定する必須要素です。このアルゴリズムは、署名操作に関与するすべての暗号化関数（ハッシュ、公開キーアルゴリズム、MAC、パディングなど）を識別します。この要素は、セクション6.1：アルゴリズムの識別子と実装要件で説明されているアルゴリズムについて、ここで一般構造を使用します。単一の識別子がありますが、その識別子は複数の異なる署名値を含む形式を指定できます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"SignatureMethod\" type=\"ds:SignatureMethodType\"/>\n<complexType name=\"SignatureMethodType\" mixed=\"true\">\n  <sequence>\n    <element name=\"HMACOutputLength\" minOccurs=\"0\"\n             type=\"ds:HMACOutputLengthType\"/>\n    <any namespace=\"##other\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n    <!-- (0,unbounded) elements from (1,1) external namespace -->\n   </sequence>\n <attribute name=\"Algorithm\" type=\"anyURI\" use=\"required\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT SignatureMethod\n          (#PCDATA|HMACOutputLength %Method.ANY;)* >\n<!ATTLIST SignatureMethod\n Algorithm CDATA #REQUIRED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3.3 The Reference Element",
      "section_title": true,
      "ja": "4.3.3 参照要素"
    },
    {
      "indent": 3,
      "text": "Reference is an element that may occur one or more times. It specifies a digest algorithm and digest value, and optionally an identifier of the object being signed, the type of the object, and/or a list of transforms to be applied prior to digesting. The identification (URI) and transforms describe how the digested content (i.e., the input to the digest method) was created. The Type attribute facilitates the processing of referenced data. For example, while this specification makes no requirements over external data, an application may wish to signal that the referent is a Manifest. An optional ID attribute permits a Reference to be referenced from elsewhere.",
      "ja": "Referenceは、1回以上発生する可能性のある要素です。ダイジェストアルゴリズムとダイジェスト値、およびオプションで署名されているオブジェクトの識別子、オブジェクトのタイプ、および/またはダイジェスト前に適用される変換のリストを指定します。識別（URI）と変換は、ダイジェストされたコンテンツ（つまり、ダイジェストメソッドへの入力）がどのように作成されたかを説明しています。Type属性は、参照されるデータの処理を容易にします。たとえば、この仕様は外部データに対する要件を設けていませんが、アプリケーションは指示対象がManifestであることを示すことを望む場合があります。オプションのID属性により、Referenceを他の場所から参照することができます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"Reference\" type=\"ds:ReferenceType\"/>\n<complexType name=\"ReferenceType\">\n  <sequence>\n    <element ref=\"ds:Transforms\" minOccurs=\"0\"/>\n    <element ref=\"ds:DigestMethod\"/>\n    <element ref=\"ds:DigestValue\"/>\n  </sequence>\n  <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n  <attribute name=\"URI\" type=\"anyURI\" use=\"optional\"/>\n  <attribute name=\"Type\" type=\"anyURI\" use=\"optional\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT Reference (Transforms?, DigestMethod, DigestValue)  >\n<!ATTLIST Reference\n Id  ID  #IMPLIED\n URI CDATA   #IMPLIED\n Type    CDATA   #IMPLIED>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3.3.1 The URI Attribute",
      "section_title": true,
      "ja": "4.3.3.1 URI属性"
    },
    {
      "indent": 3,
      "text": "The URI attribute identifies a data object using a URI-Reference, as specified by RFC2396 [URI]. The set of allowed characters for URI attributes is the same as for XML, namely [Unicode]. However, some Unicode characters are disallowed from URI references including all non-ASCII characters and the excluded characters listed in RFC2396 [URI, section 2.4]. However, the number sign (#), percent sign (%), and square bracket characters re-allowed in RFC 2732 [URI-Literal] are permitted. Disallowed characters must be escaped as follows:",
      "ja": "URI属性は、RFC2396 [URI]で指定されているように、URI参照を使用してデータオブジェクトを識別します。URI属性の許可された文字のセットは、XML、つまり[Unicode]の場合と同じです。ただし、一部のUnicode文字は、すべての非ASCII文字やRFC2396にリストされている除外された文字を含むURI参照から許可されていません[URI、セクション2.4]。ただし、RFC 2732 [URI-LITERAL]で再許可された番号記号（＃）、パーセント記号（％）、および角括弧文字は許可されています。許可されていない文字は、次のようにエスケープしなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. Each disallowed character is converted to [UTF-8] as one or more octets. 2. Any octets corresponding to a disallowed character are escaped with the URI escaping mechanism (that is, converted to %HH, where HH is the hexadecimal notation of the octet value). 3. The original character is replaced by the resulting character sequence.",
      "ja": "1. 許可されていない各文字は、1つ以上のオクテットとして[UTF-8]に変換されます。2. 許可されていない文字に対応するオクテットは、URIエスケープメカニズム（つまり、％HHに変換されます。ここで、HHはオクテット値の16進表記です）でエスケープされます。3. 元の文字は、結果の文字シーケンスに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "XML signature applications MUST be able to parse URI syntax. We RECOMMEND they be able to dereference URIs in the HTTP scheme. Dereferencing a URI in the HTTP scheme MUST comply with the Status Code Definitions of [HTTP] (e.g., 302, 305 and 307 redirects are followed to obtain the entity-body of a 200 status code response). Applications should also be cognizant of the fact that protocol parameter and state information, (such as HTTP cookies, HTML device profiles or content negotiation), may affect the content yielded by dereferencing a URI.",
      "ja": "XML署名アプリケーションは、URI構文を解析できる必要があります。HTTPスキームでURIを参照解決できることをお勧めします。HTTPスキームでURIを参照解決する場合は、[HTTP]のステータスコード定義に準拠する必要があります（たとえば、302、305、および307リダイレクトに従って、200ステータスコード応答のエンティティボディを取得します）。アプリケーションは、プロトコルパラメーターと状態情報（HTTP Cookie、HTMLデバイスプロファイル、コンテンツネゴシエーションなど）が、URIの参照解決によって生成されるコンテンツに影響を与える可能性があるという事実も認識する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a resource is identified by more than one URI, the most specific should be used (e.g., http://www.w3.org/2000/06/interop-pressrelease.html.en instead of http://www.w3.org/2000/06/interop-pressrelease). (See the Reference Validation (section 3.2.1) for a further information on reference processing.)",
      "ja": "リソースが複数のURIによって識別されている場合、最も具体的なものを使用する必要があります（例：http://www.w3.org/2000/06/interop-pressrelease ではなく http://www.w3.org/2000/06/interop-pressrelease.html.en）。（参照処理の詳細については、参照検証（セクション3.2.1）を参照してください。）"
    },
    {
      "indent": 3,
      "text": "If the URI attribute is omitted altogether, the receiving application is expected to know the identity of the object. For example, a lightweight data protocol might omit this attribute given the identity of the object is part of the application context. This attribute may be omitted from at most one Reference in any particular SignedInfo, or Manifest.",
      "ja": "URI属性が完全に省略されている場合、受信アプリケーションはオブジェクトのIDを知っていることが期待されます。たとえば、軽量のデータプロトコルでは、オブジェクトのIDがアプリケーションコンテキストの一部であるため、この属性を省略する可能性があります。この属性は、特定のSignedInfoまたはManifest内の最大1つのReferenceから省略できます。"
    },
    {
      "indent": 3,
      "text": "The optional Type attribute contains information about the type of object being signed. This is represented as a URI. For example:",
      "ja": "オプションの型属性には、署名されているオブジェクトのタイプに関する情報が含まれています。これはURIとして表されます。例えば："
    },
    {
      "indent": 3,
      "text": "Type=\"http://www.w3.org/2000/09/xmldsig#Object\"\nType=\"http://www.w3.org/2000/09/xmldsig#Manifest\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Type attribute applies to the item being pointed at, not its contents. For example, a reference that identifies an Object element containing a SignatureProperties element is still of type #Object. The type attribute is advisory. No validation of the type information is required by this specification.",
      "ja": "Type属性は、その内容ではなく、指し示されているアイテムに適用されます。たとえば、SignatureProperties要素を含むObject要素を識別する参照は、依然として#Objectタイプです。Type属性は参考情報です。この仕様では、タイプ情報の検証は必要ありません。"
    },
    {
      "indent": 0,
      "text": "4.3.3.2 The Reference Processing Model",
      "section_title": true,
      "ja": "4.3.3.2 参照処理モデル"
    },
    {
      "indent": 3,
      "text": "Note: XPath is RECOMMENDED. Signature applications need not conform to [XPath] specification in order to conform to this specification. However, the XPath data model, definitions (e.g., node-sets) and syntax is used within this document in order to describe functionality for those that want to process XML-as-XML (instead of octets) as part of signature generation. For those that want to use these features, a conformant [XPath] implementation is one way to implement these features, but it is not required. Such applications could use a sufficiently functional replacement to a node-set and implement only those XPath expression behaviors REQUIRED by this specification. However, for simplicity we generally will use XPath terminology without including this qualification on every point. Requirements over \"XPath node-sets\" can include a node-set functional equivalent. Requirements over XPath processing can include application behaviors that are equivalent to the corresponding XPath behavior.",
      "ja": "注：XPathを推奨します（RECOMMENDED）。署名アプリケーションは、この仕様に準拠するために[XPath]仕様に準拠する必要はありません。ただし、XML-as-XML（オクテットの代わりに）を署名生成の一部として処理したいものの機能を記述するために、XPathデータモデル、定義（ノードセットなど）、および構文がこのドキュメント内で使用されます。これらの機能を使用したい人にとっては、適合する[XPath]実装はこれらの機能を実装する1つの方法ですが、必須ではありません。このようなアプリケーションは、ノードセットに十分に機能的な置換を使用し、この仕様に必要なXPath式の動作のみを実装できます。ただし、簡単にするために、一般に、すべてのポイントにこの条件を含めることなくXPath用語を使用します。「XPathノードセット」に対する要件には、ノードセットの機能的等価物を含めることができます。XPath処理に関する要件には、対応するXPathの動作に相当するアプリケーション動作を含めることができます。"
    },
    {
      "indent": 3,
      "text": "The data-type of the result of URI dereferencing or subsequent Transforms is either an octet stream or an XPath node-set.",
      "ja": "URIの参照解決またはその後のTransformsの結果のデータタイプは、オクテットストリームまたはXPathノードセットのいずれかです。"
    },
    {
      "indent": 3,
      "text": "The Transforms specified in this document are defined with respect to the input they require. The following is the default signature application behavior:",
      "ja": "このドキュメントで指定されたTransformsは、必要な入力に関して定義されます。以下は、デフォルトの署名アプリケーション動作です。"
    },
    {
      "indent": 6,
      "text": "* If the data object is an octet stream and the next transform requires a node-set, the signature application MUST attempt to parse the octets yielding the required node-set via [XML] well-formed processing. * If the data object is a node-set and the next transform requires octets, the signature application MUST attempt to convert the node-set to an octet stream using Canonical XML [XML-C14N].",
      "ja": "* データオブジェクトがオクテットストリームであり、次の変換にノードセットが必要な場合、署名アプリケーションは[XML]整形式処理を介して必要なノードセットを生成するオクテットを解析しようと試みなければなりません。* データオブジェクトがノードセットであり、次の変換にオクテットが必要な場合、署名アプリケーションは、Canonical XML [XML-C14N]を使用してノードセットをオクテットストリームに変換しようと試みなければなりません。"
    },
    {
      "indent": 3,
      "text": "Users may specify alternative transforms that override these defaults in transitions between transforms that expect different inputs. The final octet stream contains the data octets being secured. The digest algorithm specified by DigestMethod is then applied to these data octets, resulting in the DigestValue.",
      "ja": "ユーザーは、異なる入力を期待する変換間の遷移でこれらのデフォルトをオーバーライドする代替変換を指定できます。最終的なオクテットストリームには、保護されているデータオクテットが含まれています。DigestMethodで指定されたダイジェストアルゴリズムは、これらのデータオクテットに適用され、DigestValueが生成されます。"
    },
    {
      "indent": 3,
      "text": "Unless the URI-Reference is a 'same-document' reference as defined in [URI, Section 4.2], the result of dereferencing the URI-Reference MUST be an octet stream. In particular, an XML document identified by URI is not parsed by the signature application unless the URI is a same-document reference or unless a transform that requires XML parsing is applied. (See Transforms (section 4.3.3.1).)",
      "ja": "URI-Referenceが[URI、セクション4.2]で定義されている「同一ドキュメント」参照でない限り、URI-Referenceの参照解決の結果はオクテットストリームでなければなりません。特に、URIによって識別されるXMLドキュメントは、URIが同じドキュメント参照である場合、またはXML解析を必要とする変換が適用されない限り、署名アプリケーションによって解析されません。（Transforms（セクション4.3.3.1）を参照してください。）"
    },
    {
      "indent": 3,
      "text": "When a fragment is preceded by an absolute or relative URI in the URI-Reference, the meaning of the fragment is defined by the resource's MIME type. Even for XML documents, URI dereferencing (including the fragment processing) might be done for the signature application by a proxy. Therefore, reference validation might fail if fragment processing is not performed in a standard way (as defined in the following section for same-document references). Consequently, we RECOMMEND that the URI attribute not include fragment identifiers and that such processing be specified as an additional XPath Transform.",
      "ja": "URI参照において、フラグメントの前に絶対または相対URIが先行する場合、フラグメントの意味はリソースのMIMEタイプによって定義されます。XMLドキュメントであっても、URIの参照解決（フラグメント処理を含む）は、プロキシによって署名アプリケーションのために行われる場合があります。したがって、フラグメント処理が標準的な方法で実行されない場合、参照検証は失敗する可能性があります（同じドキュメント参照については、次のセクションで定義されています）。その結果、URI属性にはフラグメント識別子が含まれておらず、そのような処理を追加のXPath変換として指定することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "When a fragment is not preceded by a URI in the URI-Reference, XML signature applications MUST support the null URI and barename XPointer. We RECOMMEND support for the same-document XPointers '#xpointer(/)' and '#xpointer(id('ID'))' if the application also intends to support any canonicalization that preserves comments. (Otherwise URI=\"#foo\" will automatically remove comments before the canonicalization can even be invoked.) All other support for XPointers is OPTIONAL, especially all support for barename and other XPointers in external resources since the application may not have control over how the fragment is generated (leading to interoperability problems and validation failures).",
      "ja": "URI参照において、フラグメントの前にURIが先行しない場合、XML署名アプリケーションはnull URIおよびbarename XPointerをサポートしなければなりません（MUST）。アプリケーションがコメントを保持する正規化もサポートする予定の場合は、同じドキュメントXPointers '#xpointer(/)' および '#xpointer(id('ID'))' をサポートすることをお勧めします。（それ以外の場合は、URI=\"#foo\"は、正規化が呼び出される前にコメントを自動的に削除します。）XPointersの他のすべてのサポートはオプションです。特に、アプリケーションがフラグメントの生成方法を制御できない可能性があるため（相互運用性の問題と検証障害につながります）、外部リソースのbarenameやその他のXPointersのすべてのサポートはオプションです。"
    },
    {
      "indent": 3,
      "text": "The following examples demonstrate what the URI attribute identifies and how it is dereferenced:",
      "ja": "次の例は、URI属性が何を識別し、どのように参照解決されるかを示しています。"
    },
    {
      "indent": 3,
      "text": "URI=\"http://example.com/bar.xml\" Identifies the octets that represent the external resource 'http://example.com/bar.xml', that is probably an XML document given its file extension. URI=\"http://example.com/bar.xml#chapter1\" Identifies the element with ID attribute value 'chapter1' of the external XML resource 'http://example.com/bar.xml', provided as an octet stream. Again, for the sake of interoperability, the element identified as 'chapter1' should be obtained using an XPath transform rather than a URI fragment (barename XPointer resolution in external resources is not REQUIRED in this specification). URI=\"\" Identifies the node-set (minus any comment nodes) of the XML resource containing the signature URI=\"#chapter1\" Identifies a node-set containing the element with ID attribute value 'chapter1' of the XML resource containing the signature. XML Signature (and its applications) modify this node-set to include the element plus all descendents including namespaces and attributes -- but not comments.",
      "ja": "URI=\"http://example.com/bar.xml\" 外部リソース 'http://example.com/bar.xml' を表すオクテットを識別します。ファイル拡張子から、おそらくXMLドキュメントです。 URI=\"http://example.com/bar.xml#chapter1\" オクテットストリームとして提供される外部XMLリソース 'http://example.com/bar.xml' のID属性値 'chapter1' を持つ要素を識別します。繰り返しますが、相互運用性のために、'chapter1' として識別される要素は、URIフラグメントではなくXPath変換を使用して取得する必要があります（この仕様では、外部リソースでのbarename XPointer解決は必須ではありません）。 URI=\"\" 署名を含むXMLリソースのノードセット（コメントノードを除く）を識別します。 URI=\"#chapter1\" 署名を含むXMLリソースのID属性値 'chapter1' を持つ要素を含むノードセットを識別します。XML署名（およびそのアプリケーション）は、このノードセットを変更して、要素とそのすべての子孫（名前空間と属性を含むが、コメントは含まない）を含めます。"
    },
    {
      "indent": 0,
      "text": "4.3.3.3 Same-Document URI-References",
      "section_title": true,
      "ja": "4.3.3.3 同じドキュメントURI参照"
    },
    {
      "indent": 3,
      "text": "Dereferencing a same-document reference MUST result in an XPath node-set suitable for use by Canonical XML [XML-C14N]. Specifically, dereferencing a null URI (URI=\"\") MUST result in an XPath node-set that includes every non-comment node of the XML document containing the URI attribute. In a fragment URI, the characters after the number sign ('#') character conform to the XPointer syntax [Xptr]. When processing an XPointer, the application MUST behave as if the root node of the XML document containing the URI attribute were used to initialize the XPointer evaluation context. The application MUST behave as if the result of XPointer processing were a node-set derived from the resultant location-set as follows:",
      "ja": "同一ドキュメント参照を参照解決すると、Canonical XML [XML-C14N]での使用に適したXPathノードセットにならなければなりません（MUST）。具体的には、null URI（URI=\"\"）の参照解決は、URI属性を含むXMLドキュメントのすべての非コメントノードを含むXPathノードセットにならなければなりません（MUST）。フラグメントURIでは、番号記号（'#'）の後の文字がXPointer構文[Xptr]に適合します。XPointerを処理する場合、アプリケーションは、URI属性を含むXMLドキュメントのルートノードを使用して、XPointer評価コンテキストを初期化するかのように動作する必要があります。アプリケーションは、XPointer処理の結果が、次のように結果の位置セットから派生したノードセットであるかのように動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. discard point nodes 2. replace each range node with all XPath nodes having full or partial content within the range 3. replace the root node with its children (if it is in the node-set) 4. replace any element node E with E plus all descendants of E (text, comment, PI, element) and all namespace and attribute nodes of E and its descendant elements. 5. if the URI is not a full XPointer, then delete all comment nodes",
      "ja": "1. ポイントノードを破棄する 2. 各範囲ノードを、範囲内の完全または部分的なコンテンツを持つすべてのXPathノードに置き換える 3. ルートノードをその子に置き換える（ノードセットにある場合） 4. 任意の要素ノードEを、EとEのすべての子孫（テキスト、コメント、PI、要素）、およびEとその子孫要素のすべての名前空間と属性ノードに置き換える 5. URIが完全なXPointerでない場合は、すべてのコメントノードを削除する"
    },
    {
      "indent": 3,
      "text": "The second to last replacement is necessary because XPointer typically indicates a subtree of an XML document's parse tree using just the element node at the root of the subtree, whereas Canonical XML treats a node-set as a set of nodes in which absence of descendant nodes results in absence of their representative text from the canonical form.",
      "ja": "XPointerは通常、サブツリーのルートにある要素ノードのみを使用してXMLドキュメントの解析ツリーのサブツリーを示すのに対し、Canonical XMLはノードセットを、子孫ノードがない場合に正規化形式からその代表的なテキストが欠落するノードのセットとして扱うため、最後から2番目の置換が必要です。"
    },
    {
      "indent": 3,
      "text": "The last step is performed for null URIs, barename XPointers and child sequence XPointers. It's necessary because when [XML-C14N] is passed a node-set, it processes the node-set as is: with or without comments. Only when it's called with an octet stream does it invoke its own XPath expressions (default or without comments). Therefore to retain the default behavior of stripping comments when passed a node-set, they are removed in the last step if the URI is not a full XPointer. To retain comments while selecting an element by an identifier ID, use the following full XPointer: URI='#xpointer(id('ID'))'. To retain comments while selecting the entire document, use the following full XPointer: URI='#xpointer(/)'. This XPointer contains a simple XPath expression that includes the root node, which the second to last step above replaces with all nodes of the parse tree (all descendants, plus all attributes, plus all namespaces nodes).",
      "ja": "最後のステップは、null URI、barename XPointers、および子シーケンスXPointersに対して実行されます。[XML-C14N]にノードセットが渡されると、コメントの有無にかかわらずノードセットをそのまま処理するため、これが必要です。オクテットストリームで呼び出された場合にのみ、独自のXPath式（デフォルトまたはコメントなし）を呼び出します。したがって、ノードセットが渡されたときにコメントを取り除くデフォルトの動作を保持するために、URIが完全なXPointerでない場合、それらは最後のステップで削除されます。識別子IDで要素を選択しながらコメントを保持するには、次の完全なXPointer：URI='#xpointer(id('ID'))'を使用します。ドキュメント全体を選択しながらコメントを保持するには、次の完全なXPointer：URI='#xpointer(/)'を使用します。このXPointerには、ルートノードを含む単純なXPath式が含まれています。上記の最後から2番目のステップは、これを解析ツリーのすべてのノード（すべての子孫、すべての属性、およびすべての名前空間ノード）に置き換えます。"
    },
    {
      "indent": 0,
      "text": "4.3.3.4 The Transforms Element",
      "section_title": true,
      "ja": "4.3.3.4 変換要素"
    },
    {
      "indent": 3,
      "text": "The optional Transforms element contains an ordered list of Transform elements; these describe how the signer obtained the data object that was digested. The output of each Transform serves as input to the next Transform. The input to the first Transform is the result of dereferencing the URI attribute of the Reference element. The output from the last Transform is the input for the DigestMethod algorithm. When transforms are applied the signer is not signing the native (original) document but the resulting (transformed) document. (See Only What is Signed is Secure (section 8.1).)",
      "ja": "任意のTransforms要素には、Transform要素の順序付けられたリストが含まれています。これらは、署名者がダイジェストされたデータオブジェクトをどのように取得したかを説明しています。各Transformの出力は、次のTransformへの入力として機能します。最初のTransformへの入力は、Reference要素のURI属性を参照解決した結果です。最後のTransformからの出力は、DigestMethodアルゴリズムの入力です。Transformsが適用されると、署名者はネイティブ（元の）ドキュメントに署名するのではなく、結果の（変換された）ドキュメントに署名しています。（署名されているものだけが安全です（セクション8.1）を参照してください。）"
    },
    {
      "indent": 3,
      "text": "Each Transform consists of an Algorithm attribute and content parameters, if any, appropriate for the given algorithm. The Algorithm attribute value specifies the name of the algorithm to be performed, and the Transform content provides additional data to govern the algorithm's processing of the transform input. (See Algorithm Identifiers and Implementation Requirements (section 6).) As described in The Reference Processing Model (section 4.3.3.2), some transforms take an XPath node-set as input, while others require an octet stream. If the actual input matches the input needs of the transform, then the transform operates on the unaltered input. If the transform input requirement differs from the format of the actual input, then the input must be converted.",
      "ja": "各Transformは、特定のアルゴリズムに適したAlgorithm属性とコンテンツパラメーター（もしあれば）で構成されています。Algorithm属性値は、実行されるアルゴリズムの名前を指定し、Transformコンテンツはアルゴリズムの変換入力の処理を管理する追加データを提供します。（アルゴリズムの識別子と実装要件（セクション6）を参照してください。）参照処理モデル（セクション4.3.3.2）で説明されているように、いくつかの変換はXPathノードセットを入力として取りますが、他の変換はオクテットストリームを必要とします。実際の入力が変換の入力ニーズと一致する場合、変換は変更されていない入力で動作します。変換入力要件が実際の入力の形式と異なる場合、入力を変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some Transforms may require explicit MIME type, charset (IANA registered \"character set\"), or other such information concerning the data they are receiving from an earlier Transform or the source data, although no Transform algorithm specified in this document needs such explicit information. Such data characteristics are provided as parameters to the Transform algorithm and should be described in the specification for the algorithm.",
      "ja": "一部の変換では、明示的なMIMEタイプ、CharSet（IANA登録「文字セット」）、または以前の変換またはソースデータから受信しているデータに関するその他の情報が必要になる場合がありますが、このドキュメントで指定された変換アルゴリズムはそのような明示的な情報を必要としません。このようなデータ特性は、変換アルゴリズムのパラメーターとして提供され、アルゴリズムの仕様で説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "Examples of transforms include but are not limited to base64 decoding [MIME], canonicalization [XML-C14N], XPath filtering [XPath], and XSLT [XSLT]. The generic definition of the Transform element also allows application-specific transform algorithms. For example, the transform could be a decompression routine given by a Java class appearing as a base64 encoded parameter to a Java Transform algorithm. However, applications should refrain from using application-specific transforms if they wish their signatures to be verifiable outside of their application domain. Transform Algorithms (section 6.6) define the list of standard transformations.",
      "ja": "変換の例には、base64デコード[MIME]、正規化[XML-C14N]、XPathフィルタリング[XPath]、およびXSLT [XSLT]が含まれますが、これらに限定されません。Transform要素の汎用定義は、アプリケーション固有の変換アルゴリズムも可能にします。たとえば、変換は、Java変換アルゴリズムにbase64エンコードされたパラメーターとして表示されるJavaクラスによって提供される解凍ルーチンになる可能性があります。ただし、アプリケーションドメインの外で署名を検証できるようにしたい場合は、アプリケーション固有の変換の使用を控える必要があります。変換アルゴリズム（セクション6.6）は、標準変換のリストを定義します。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"Transforms\" type=\"ds:TransformsType\"/>\n<complexType name=\"TransformsType\">\n  <sequence>\n    <element ref=\"ds:Transform\" maxOccurs=\"unbounded\"/>\n  </sequence>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<element name=\"Transform\" type=\"ds:TransformType\"/> <complexType name=\"TransformType\" mixed=\"true\"> <choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <any namespace=\"##other\" processContents=\"lax\"/> <!-- (1,1) elements from (0,unbounded) namespaces --> <element name=\"XPath\" type=\"string\"/> </choice> <attribute name=\"Algorithm\" type=\"anyURI\" use=\"required\"/> </complexType> DTD:",
      "ja": "<要素name = \"transform\" type = \"ds：transformtype\"/> <complextype name = \"transformtype\" mixed = \"true\"> <choice minoccurs = \"0\" maxoccurs = \"unbounded\"> <any namespace = \"## other\"ProcessContents =\" lax \"/> <！ - （1,1）要素（0、unbounded）名前空間 - > <要素name =\" xpath \"type =\" string \"/> </choice> <属性name =「アルゴリズム」type = \"anyuri\" use = \"必須\"/> </complextype> dtd："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT Transforms (Transform+)>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<!ELEMENT Transform (#PCDATA|XPath %Transform.ANY;)* >\n<!ATTLIST Transform\n Algorithm    CDATA    #REQUIRED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<!ELEMENT XPath (#PCDATA) >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3.3.5 The DigestMethod Element",
      "section_title": true,
      "ja": "4.3.3.5 DigestMethod要素"
    },
    {
      "indent": 3,
      "text": "DigestMethod is a required element that identifies the digest algorithm to be applied to the signed object. This element uses the general structure here for algorithms specified in Algorithm Identifiers and Implementation Requirements (section 6.1).",
      "ja": "DigestMethodは、署名されたオブジェクトに適用されるダイジェストアルゴリズムを識別する必須要素です。この要素は、アルゴリズム識別子と実装要件で指定されたアルゴリズムについて、ここで一般構造を使用します（セクション6.1）。"
    },
    {
      "indent": 3,
      "text": "If the result of the URI dereference and application of Transforms is an XPath node-set (or sufficiently functional replacement implemented by the application) then it must be converted as described in the Reference Processing Model (section 4.3.3.2). If the result of URI dereference and application of transforms is an octet stream, then no conversion occurs (comments might be present if the Canonical XML with Comments was specified in the Transforms). The digest algorithm is applied to the data octets of the resulting octet stream.",
      "ja": "URIの参照解決とTransformsの適用の結果がXPathノードセット（またはアプリケーションによって実装された十分に機能的な置換）である場合、参照処理モデル（セクション4.3.3.2）で説明されているように変換する必要があります。URIの参照解決とTransformsの適用の結果がオクテットストリームである場合、変換は発生しません（Transformsでコメントを含むCanonical XMLが指定された場合、コメントが存在する可能性があります）。ダイジェストアルゴリズムは、結果のオクテットストリームのデータオクテットに適用されます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"DigestMethod\" type=\"ds:DigestMethodType\"/>\n<complexType name=\"DigestMethodType\" mixed=\"true\">\n  <sequence>\n    <any namespace=\"##other\" processContents=\"lax\"\n         minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n  </sequence>\n  <attribute name=\"Algorithm\" type=\"anyURI\" use=\"required\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT DigestMethod (#PCDATA %Method.ANY;)* >\n<!ATTLIST DigestMethod\n Algorithm       CDATA   #REQUIRED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3.3.6 The DigestValue Element",
      "section_title": true,
      "ja": "4.3.3.6 ダイジェストバリュー要素"
    },
    {
      "indent": 3,
      "text": "DigestValue is an element that contains the encoded value of the digest. The digest is always encoded using base64 [MIME].",
      "ja": "DigestValueは、ダイジェストのエンコードされた値を含む要素です。ダイジェストは、base64 [MIME]を使用して常にエンコードされます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"DigestValue\" type=\"ds:DigestValueType\"/>\n<simpleType name=\"DigestValueType\">\n  <restriction base=\"base64Binary\"/>\n</simpleType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT DigestValue  (#PCDATA)  >\n<!-- base64 encoded digest value -->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4 The KeyInfo Element",
      "section_title": true,
      "ja": "4.4 keyinfo要素"
    },
    {
      "indent": 3,
      "text": "KeyInfo is an optional element that enables the recipient(s) to obtain the key needed to validate the signature. KeyInfo may contain keys, names, certificates and other public key management information, such as in-band key distribution or key agreement data. This specification defines a few simple types but applications may extend those types or all together replace them with their own key identification and exchange semantics using the XML namespace facility. [XML-ns] However, questions of trust of such key information (e.g., its authenticity or strength) are out of scope of this specification and left to the application.",
      "ja": "KeyInfoは、受信者が署名を検証するために必要なキーを取得できるようにする任意の要素です。KeyInfoには、帯域内のキー配布やキー合意データなど、キー、名前、証明書、およびその他の公開キー管理情報が含まれる場合があります。この仕様ではいくつかの単純なタイプを定義しますが、アプリケーションはこれらのタイプを拡張するか、すべてを一緒にXML名前空間機能を使用して独自のキー識別と交換セマンティクスに置き換えることができます。[XML-NS]ただし、このようなキー情報（例えば、その真正性や強度）の信頼の質問は、この仕様の範囲外であり、アプリケーションに任されています。"
    },
    {
      "indent": 3,
      "text": "If KeyInfo is omitted, the recipient is expected to be able to identify the key based on application context. Multiple declarations within KeyInfo refer to the same key. While applications may define and use any mechanism they choose through inclusion of elements from a different namespace, compliant versions MUST implement KeyValue (section 4.4.2) and SHOULD implement RetrievalMethod (section 4.4.3).",
      "ja": "KeyInfoが省略されている場合、受信者はアプリケーションコンテキストに基づいてキーを識別できることが期待されます。KeyInfo内の複数の宣言は、同じキーを参照しています。アプリケーションは、異なる名前空間から要素を含めることで選択したメカニズムを定義および使用する場合がありますが、準拠バージョンはKeyValue（セクション4.4.2）を実装する必要があり、RetrievalMethod（セクション4.4.3）を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "The schema/DTD specifications of many of KeyInfo's children (e.g., PGPData, SPKIData, X509Data) permit their content to be extended/complemented with elements from another namespace. This may be done only if it is safe to ignore these extension elements while claiming support for the types defined in this specification. Otherwise, external elements, including alternative structures to those defined by this specification, MUST be a child of KeyInfo. For example, should a complete XML-PGP standard be defined, its root element MUST be a child of KeyInfo. (Of course, new structures from external namespaces can incorporate elements from the &dsig; namespace via features of the type definition language. For instance, they can create a DTD that mixes their own and dsig qualified elements, or a schema that permits, includes, imports, or derives new types based on &dsig; elements.) The following list summarizes the KeyInfo types that are allocated to an identifier in the &dsig; namespace; these can be used within the RetrievalMethod Type attribute to describe a remote KeyInfo structure.",
      "ja": "KeyInfoの多くの子供（PGPDATA、SPKIDATA、X509DATAなど）の多くのスキーマ/DTD仕様により、コンテンツを別の名前空間からの要素で拡張/補完することができます。これは、この仕様で定義されているタイプのサポートを主張しながら、これらの拡張要素を無視しても安全である場合にのみ行うことができます。それ以外の場合、この仕様で定義されたものに対する代替構造を含む外部要素は、KeyInfoの子供でなければなりません。たとえば、完全なXML-PGP標準を定義する場合、そのルート要素はKeyInfoの子でなければなりません。（もちろん、外部の名前空間からの新しい構造は、タイプ定義言語の機能を介して＆dsig;名前空間の要素を組み込むことができます。たとえば、独自の要素とDSIGの適格な要素を混合するDTD、または許可するスキーマを作成できます。＆dsig;要素に基づいて新しいタイプを導入するか、導入します。）次のリストは、＆dsigの識別子に割り当てられたkeyinfoタイプを要約しています。名前空間;これらは、RetrievalMethod型属性内で使用して、リモートKeyINFO構造を記述できます。"
    },
    {
      "indent": 6,
      "text": "* http://www.w3.org/2000/09/xmldsig#DSAKeyValue * http://www.w3.org/2000/09/xmldsig#RSAKeyValue * http://www.w3.org/2000/09/xmldsig#X509Data * http://www.w3.org/2000/09/xmldsig#PGPData * http://www.w3.org/2000/09/xmldsig#SPKIData * http://www.w3.org/2000/09/xmldsig#MgmtData",
      "ja": "* http://www.w3.org/2000/09/xmldsig#dsakeyvalue * http://www.w3.org/2000/09/xmldsig#rsakeyvalue * http://www.w3.org/2000/09/XMLDSIG＃x509DATA * http://www.w3.org/2000/09/xmldsig#pgpdata * http://www.w3.org/2000/09/xmldsig#spkidata * http://www.w.w.w.w.w.w3.org//2000/09/xmldsig＃mgmtdata"
    },
    {
      "indent": 3,
      "text": "In addition to the types above for which we define an XML structure, we specify one additional type to indicate a binary (ASN.1 DER) X.509 Certificate.",
      "ja": "XML構造を定義する上記のタイプに加えて、バイナリ（ASN.1 DER）X.509証明書を示すために1つの追加タイプを指定します。"
    },
    {
      "indent": 6,
      "text": "* http://www.w3.org/2000/09/xmldsig#rawX509Certificate",
      "ja": "* http://www.w3.org/2000/09/xmldsig#rawX509Certificate"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"KeyInfo\" type=\"ds:KeyInfoType\"/>\n<complexType name=\"KeyInfoType\" mixed=\"true\">\n  <choice maxOccurs=\"unbounded\">\n    <element ref=\"ds:KeyName\"/>\n    <element ref=\"ds:KeyValue\"/>\n    <element ref=\"ds:RetrievalMethod\"/>\n    <element ref=\"ds:X509Data\"/>\n    <element ref=\"ds:PGPData\"/>\n    <element ref=\"ds:SPKIData\"/>\n    <element ref=\"ds:MgmtData\"/>\n    <any processContents=\"lax\" namespace=\"##other\"/>\n    <!-- (1,1) elements from (0,unbounded) namespaces -->\n  </choice>\n  <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT KeyInfo (#PCDATA|KeyName|KeyValue|RetrievalMethod|\n            X509Data|PGPData|SPKIData|MgmtData %KeyInfo.ANY;)* >\n<!ATTLIST KeyInfo\n Id  ID   #IMPLIED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.1 The KeyName Element",
      "section_title": true,
      "ja": "4.4.1 キーネーム要素"
    },
    {
      "indent": 3,
      "text": "The KeyName element contains a string value (in which white space is significant) which may be used by the signer to communicate a key identifier to the recipient. Typically, KeyName contains an identifier related to the key pair used to sign the message, but it may contain other protocol-related information that indirectly identifies a key pair. (Common uses of KeyName include simple string names for keys, a key index, a distinguished name (DN), an email address, etc.)",
      "ja": "KeyName要素には、署名者がキー識別子を受信者に伝えるために使用できる文字列値（空白が重要）が含まれています。通常、KeyNameにはメッセージの署名に使用されるキーペアに関連する識別子が含まれていますが、間接的にキーペアを識別する他のプロトコル関連情報が含まれている場合があります。（KeyNameの一般的な用途には、キーの単純な文字列名、キーインデックス、識別名（DN）、電子メールアドレスなどが含まれます）"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"KeyName\" type=\"string\"/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT KeyName (#PCDATA) >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.2 The KeyValue Element",
      "section_title": true,
      "ja": "4.4.2 キーバリュー要素"
    },
    {
      "indent": 3,
      "text": "The KeyValue element contains a single public key that may be useful in validating the signature. Structured formats for defining DSA (REQUIRED) and RSA (RECOMMENDED) public keys are defined in Signature Algorithms (section 6.4). The KeyValue element may include externally defined public key values represented as PCDATA or element types from an external namespace.",
      "ja": "KeyValue要素には、署名の検証に役立つ単一の公開キーが含まれています。DSA（必須）およびRSA（推奨）を定義するための構造化された形式は、署名アルゴリズム（セクション6.4）で定義されています。KeyValue要素には、PCDATAとして表される外部から定義された公開キー値または外部名前空間の要素タイプを含めることができます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"KeyValue\" type=\"ds:KeyValueType\"/>\n<complexType name=\"KeyValueType\" mixed=\"true\">\n <choice>\n   <element ref=\"ds:DSAKeyValue\"/>\n   <element ref=\"ds:RSAKeyValue\"/>\n   <any namespace=\"##other\" processContents=\"lax\"/>\n </choice>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT KeyValue (#PCDATA|DSAKeyValue|RSAKeyValue\n                    %KeyValue.ANY;)* >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.2.1 The DSAKeyValue Element",
      "section_title": true,
      "ja": "4.4.2.1 DSAKEYVALUE要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#DSAKeyValue\" (this can be used within a RetrievalMethod or Reference element to identify the referent's type)",
      "ja": "識別子 Type=\"http://www.w3.org/2000/09/xmldsig#RSAKeyValue\"（これは、RetrievalMethodまたはReference要素内で使用して、指示対象のタイプを識別できます）"
    },
    {
      "indent": 3,
      "text": "DSA keys and the DSA signature algorithm are specified in [DSS]. DSA public key values can have the following fields:",
      "ja": "DSAキーとDSA署名アルゴリズムは[DSS]で指定されています。DSA公開鍵の値には、次のフィールドを持つことができます。"
    },
    {
      "indent": 3,
      "text": "P : a prime modulus meeting the [DSS] requirements. Q : an integer in the range 2**159 < Q < 2**160 which is a prime divisor of P-1. G : an integer with certain properties with respect to P and Q. Y : G**X mod P (where X is part of the private key and not made public). J : (P - 1) / Q seed a DSA prime generation seed pgenCounter a DSA prime generation counter",
      "ja": "P：[DSS]要件を満たす素数モジュラス、Q：範囲 2**159 < Q < 2**160 の整数で、P-1 の素因数、G：P および Q に関して特定のプロパティを持つ整数、Y：G**X mod P（X は秘密鍵の一部であり、公開されていない）、J：(P - 1) / Q、seed：DSA 素数生成シード、pgenCounter：DSA 素数生成カウンター"
    },
    {
      "indent": 3,
      "text": "Parameter J is available for inclusion solely for efficiency as it is calculatable from P and Q. Parameters seed and pgenCounter are used in the DSA prime number generation algorithm specified in [DSS]. As such, they are optional, but must either both be present or both be absent. This prime generation algorithm is designed to provide assurance that a weak prime is not being used and it yields a P and Q value. Parameters P, Q, and G can be public and common to a group of users. They might be known from application context. As such, they are optional but P and Q must either both appear or both be absent. If all of P, Q, seed, and pgenCounter are present, implementations are not required to check if they are consistent and are free to use either P and Q or seed and pgenCounter. All parameters are encoded as base64 [MIME] values.",
      "ja": "パラメーターJは、PおよびQから計算可能であるため、効率のためだけに含めることができます。パラメーターseedとpgenCounterは、[DSS]で指定されたDSA素数生成アルゴリズムで使用されます。そのため、それらは任意ですが、両方が存在するか、両方が存在しない必要があります。この素数生成アルゴリズムは、弱い素数が使用されておらず、PとQ値を生成するという保証を提供するように設計されています。パラメーターP、Q、およびGは、ユーザーのグループに公開され、共通することができます。それらはアプリケーションのコンテキストから知られているかもしれません。そのため、それらは任意ですが、PとQは両方とも表示されるか、両方が存在しない必要があります。すべてのP、Q、seed、およびpgenCounterが存在する場合、実装はそれらが一貫しているかどうかを確認する必要はなく、PとQ、またはseedとpgenCounterのいずれかを自由に使用できます。すべてのパラメーターは、base64 [MIME]値としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Arbitrary-length integers (e.g., \"bignums\" such as RSA moduli) are represented in XML as octet strings as defined by the ds:CryptoBinary type.",
      "ja": "任意の長さの整数（例：RSAモジュリなどの「bignum」）は、XMLで、ds:CryptoBinary型で定義されているオクテット文字列として表されます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"DSAKeyValue\" type=\"ds:DSAKeyValueType\"/>\n<complexType name=\"DSAKeyValueType\">\n  <sequence>\n    <sequence minOccurs=\"0\">\n      <element name=\"P\" type=\"ds:CryptoBinary\"/>\n      <element name=\"Q\" type=\"ds:CryptoBinary\"/>\n    </sequence>\n    <element name=\"G\" type=\"ds:CryptoBinary\" minOccurs=\"0\"/>\n    <element name=\"Y\" type=\"ds:CryptoBinary\"/>\n    <element name=\"J\" type=\"ds:CryptoBinary\" minOccurs=\"0\"/>\n    <sequence minOccurs=\"0\">\n      <element name=\"Seed\" type=\"ds:CryptoBinary\"/>\n      <element name=\"PgenCounter\" type=\"ds:CryptoBinary\"/>\n    </sequence>\n  </sequence>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD Definition:",
      "ja": "DTD定義："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT DSAKeyValue ((P, Q)?, G?, Y, J?, (Seed, PgenCounter)?) >\n<!ELEMENT P (#PCDATA) >\n<!ELEMENT Q (#PCDATA) >\n<!ELEMENT G (#PCDATA) >\n<!ELEMENT Y (#PCDATA) >\n<!ELEMENT J (#PCDATA) >\n<!ELEMENT Seed (#PCDATA) >\n<!ELEMENT PgenCounter (#PCDATA) >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.2.2 The RSAKeyValue Element",
      "section_title": true,
      "ja": "4.4.2.2 rsakeyvalue要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#RSAKeyValue\" (this can be used within a RetrievalMethod or Reference element to identify the referent's type)",
      "ja": "識別子 Type=\"http://www.w3.org/2000/09/xmldsig#DSAKeyValue\"（これは、RetrievalMethodまたはReference要素内で使用して、指示対象のタイプを識別できます）"
    },
    {
      "indent": 3,
      "text": "RSA key values have two fields: Modulus and Exponent.",
      "ja": "RSAキー値には、弾性率と指数の2つのフィールドがあります。"
    },
    {
      "indent": 6,
      "text": "<RSAKeyValue>\n  <Modulus>\n   xA7SEU+e0yQH5rm9kbCDN9o3aPIo7HbP7tX6WOocLZAtNfyxSZDU16ksL6W\n   jubafOqNEpcwR3RdFsT7bCqnXPBe5ELh5u4VEy19MzxkXRgrMvavzyBpVRg\n   BUwUlV5foK5hhmbktQhyNdy/6LpQRhDUDsTvK+g9Ucj47es9AQJ3U=\n  </Modulus>\n  <Exponent>AQAB</Exponent>\n</RSAKeyValue>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Arbitrary-length integers (e.g., \"bignums\" such as RSA moduli) are represented in XML as octet strings as defined by the ds:CryptoBinary type.",
      "ja": "任意の長さの整数（例：RSAモジュリなどの「bignum」）は、XMLで、ds:CryptoBinary型で定義されているオクテット文字列として表されます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"RSAKeyValue\" type=\"ds:RSAKeyValueType\"/>\n<complexType name=\"RSAKeyValueType\">\n  <sequence>\n    <element name=\"Modulus\" type=\"ds:CryptoBinary\"/>\n    <element name=\"Exponent\" type=\"ds:CryptoBinary\"/>\n  </sequence>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD Definition:",
      "ja": "DTD定義："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT RSAKeyValue (Modulus, Exponent) >\n<!ELEMENT Modulus (#PCDATA) >\n<!ELEMENT Exponent (#PCDATA) >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.3 The RetrievalMethod Element",
      "section_title": true,
      "ja": "4.4.3 取得要素"
    },
    {
      "indent": 3,
      "text": "A RetrievalMethod element within KeyInfo is used to convey a reference to KeyInfo information that is stored at another location. For example, several signatures in a document might use a key verified by an X.509v3 certificate chain appearing once in the document or remotely outside the document; each signature's KeyInfo can reference this chain using a single RetrievalMethod element instead of including the entire chain with a sequence of X509Certificate elements.",
      "ja": "KeyInfo内のRetrievalMethod要素は、別の場所に保存されているKeyInfo情報への参照を伝えるために使用されます。たとえば、ドキュメント内のいくつかの署名は、ドキュメントに一度表示されるX.509v3証明書チェーンによって検証されたキーを使用する場合、またはドキュメントの外側にリモートで表示される場合があります。各署名のKeyInfoは、X509Certificate要素のシーケンスでチェーン全体を含める代わりに、単一のRetrievalMethod要素を使用してこのチェーンを参照できます。"
    },
    {
      "indent": 3,
      "text": "RetrievalMethod uses the same syntax and dereferencing behavior as Reference's URI (section 4.3.3.1) and the Reference Processing Model (section 4.3.3.2) except that there is no DigestMethod or DigestValue child elements and presence of the URI is mandatory.",
      "ja": "RetrievalMethodは、ReferenceのURI（セクション4.3.3.1）および参照処理モデル（セクション4.3.3.2）と同じ構文と参照解決の動作を使用しますが、DigestMethodまたはDigestValue子要素がなく、URIの存在が必須である点が異なります。"
    },
    {
      "indent": 3,
      "text": "Type is an optional identifier for the type of data to be retrieved. The result of dereferencing a RetrievalMethod Reference for all KeyInfo types defined by this specification (section 4.4) with a corresponding XML structure is an XML element or document with that element as the root. The rawX509Certificate KeyInfo (for which there is no XML structure) returns a binary X509 certificate.",
      "ja": "Typeは、取得するデータのタイプの任意の識別子です。対応するXML構造を使用してこの仕様（セクション4.4）で定義されたすべてのKeyInfoタイプのRetrievalMethod参照を参照解決した結果は、その要素をルートとするXML要素またはドキュメントです。rawX509Certificate KeyInfo（XML構造がない）は、バイナリX509証明書を返します。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"RetrievalMethod\" type=\"ds:RetrievalMethodType\"/>\n<complexType name=\"RetrievalMethodType\">\n  <sequence>\n    <element ref=\"ds:Transforms\" minOccurs=\"0\"/>\n  </sequence>\n  <attribute name=\"URI\" type=\"anyURI\"/>\n  <attribute name=\"Type\" type=\"anyURI\" use=\"optional\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT RetrievalMethod (Transforms?) >\n<!ATTLIST RetrievalMethod\n   URI   CDATA #REQUIRED\n   Type  CDATA #IMPLIED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.4 The X509Data Element",
      "section_title": true,
      "ja": "4.4.4 X509DATA要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#X509Data\" (this can be used within a RetrievalMethod or Reference element to identify the referent's type)",
      "ja": "識別子 Type=\"http://www.w3.org/2000/09/xmldsig#X509Data\"（これは、RetrievalMethodまたはReference要素内で使用して、指示対象のタイプを識別できます）"
    },
    {
      "indent": 3,
      "text": "An X509Data element within KeyInfo contains one or more identifiers of keys or X509 certificates (or certificates' identifiers or a revocation list). The content of X509Data is:",
      "ja": "KeyInfo内のX509DATA要素には、キーまたはX509証明書（または証明書の識別子または失効リスト）の1つ以上の識別子が含まれています。x509Dataの含有量は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. At least one element, from the following set of element types; any of these may appear together or more than once if (if and only if) each instance describes or is related to the same certificate: 2. o The X509IssuerSerial element, which contains an X.509 issuer distinguished name/serial number pair that SHOULD be compliant with RFC 2253 [LDAP-DN], o The X509SubjectName element, which contains an X.509 subject distinguished name that SHOULD be compliant with RFC 2253 [LDAP-DN], o The X509SKI element, which contains the base64 encoded plain (i.e., non-DER-encoded) value of a X509 V.3 SubjectKeyIdentifier extension. o The X509Certificate element, which contains a base64-encoded [X509v3] certificate, and o Elements from an external namespace which accompanies/complements any of the elements above. o The X509CRL element, which contains a base64-encoded certificate revocation list (CRL) [X509v3].",
      "ja": "1. 次の要素タイプのセットからの少なくとも1つの要素。各インスタンスが同じ証明書を記述または関連している場合（その場合に限り）、これらのいずれかが一緒に、または複数回表示される場合があります。2. o RFC 2253 [LDAP-DN]に準拠すべき（SHOULD）X.509発行者識別名/シリアル番号のペアを含むX509IssuerSerial要素、o RFC 2253 [LDAP-DN]に準拠すべき（SHOULD）X.509サブジェクト識別名を含むX509SubjectName要素、o X.509 V.3 SubjectKeyIdentifier拡張のbase64エンコードされたプレーン（つまり、非DERエンコード）値を含むX509SKI要素、o base64エンコードされた[X509v3]証明書を含むX509Certificate要素、および o 上記の要素のいずれかを伴う/補完する外部名前空間からの要素、o base64エンコードされた証明書失効リスト（CRL）[X509v3]を含むX509CRL要素。"
    },
    {
      "indent": 3,
      "text": "Any X509IssuerSerial, X509SKI, and X509SubjectName elements that appear MUST refer to the certificate or certificates containing the validation key. All such elements that refer to a particular individual certificate MUST be grouped inside a single X509Data element and if the certificate to which they refer appears, it MUST also be in that X509Data element.",
      "ja": "表示されるX509ISSUERSERIAL、X509SKI、およびX509SubjectName要素は、検証キーを含む証明書または証明書を参照する必要があります。特定の個々の証明書を参照するすべての要素は、単一のx509Data要素内にグループ化する必要があり、それらが参照する証明書が表示される場合は、そのx509Data要素にも含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "Any X509IssuerSerial, X509SKI, and X509SubjectName elements that relate to the same key but different certificates MUST be grouped within a single KeyInfo but MAY occur in multiple X509Data elements.",
      "ja": "同じキーに関連するが異なる証明書に関連するX509ISSUERSERIAL、X509SKI、およびX509SubjectName要素は、単一のkeyInfo内でグループ化する必要がありますが、複数のx509Data要素で発生する場合があります。"
    },
    {
      "indent": 3,
      "text": "All certificates appearing in an X509Data element MUST relate to the validation key by either containing it or being part of a certification chain that terminates in a certificate containing the validation key.",
      "ja": "X509DATA要素に表示されるすべての証明書は、検証キーを含むか、検証キーを含む証明書で終了する認定チェーンの一部であることにより、検証キーに関連する必要があります。"
    },
    {
      "indent": 3,
      "text": "No ordering is implied by the above constraints. The comments in the following instance demonstrate these constraints:",
      "ja": "上記の制約によって順序は暗示されません。次の例のコメントは、これらの制約を示しています。"
    },
    {
      "indent": 3,
      "text": "<KeyInfo>\n  <X509Data> <!-- two pointers to certificate-A -->\n    <X509IssuerSerial>\n      <X509IssuerName>CN=TAMURA Kent, OU=TRL, O=IBM,\n        L=Yamato-shi, ST=Kanagawa, C=JP</X509IssuerName>\n      <X509SerialNumber>12345678</X509SerialNumber>\n    </X509IssuerSerial>\n    <X509SKI>31d97bd7</X509SKI>\n  </X509Data>\n  <X509Data><!-- single pointer to certificate-B -->\n    <X509SubjectName>Subject of Certificate B</X509SubjectName>\n  </X509Data>\n  <X509Data> <!-- certificate chain -->\n    <!--Signer cert, issuer CN=arbolCA,OU=FVT,O=IBM,C=US, serial 4-->\n    <X509Certificate>MIICXTCCA..</X509Certificate>\n    <!-- Intermediate cert subject CN=arbolCA,OU=FVT,O=IBM,C=US\n         issuer CN=tootiseCA,OU=FVT,O=Bridgepoint,C=US -->\n    <X509Certificate>MIICPzCCA...</X509Certificate>\n    <!-- Root cert subject CN=tootiseCA,OU=FVT,O=Bridgepoint,C=US -->\n    <X509Certificate>MIICSTCCA...</X509Certificate>\n  </X509Data>\n</KeyInfo>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note, there is no direct provision for a PKCS#7 encoded \"bag\" of certificates or CRLs. However, a set of certificates and CRLs can occur within an X509Data element and multiple X509Data elements can occur in a KeyInfo. Whenever multiple certificates occur in an X509Data element, at least one such certificate must contain the public key which verifies the signature.",
      "ja": "注意：PKCS#7でエンコードされた証明書またはCRLの「バッグ」に対する直接的な規定はありません。ただし、x509Data要素内で一連の証明書とCRLが発生する可能性があり、keyInfoで複数のx509Data要素が発生する可能性があります。X509DATA要素で複数の証明書が発生する場合はいつでも、少なくとも1つのそのような証明書には、署名を検証する公開キーを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Also, strings in DNames (X509IssuerSerial,X509SubjectName, and KeyNameif appropriate) should be encoded as follows:",
      "ja": "また、DNames（X509IssuerSerial、X509SubjectName、および適切な場合はKeyName）内の文字列は、次のようにエンコードする必要があります。"
    },
    {
      "indent": 6,
      "text": "* Consider the string as consisting of Unicode characters. * Escape occurrences of the following special characters by prefixing it with the \"\\\" character: a \"#\" character occurring at the beginning of the string or one of the characters \",\", \"+\", \"\"\", \"\\\", \"<\", \">\" or \";\" * Escape all occurrences of ASCII control characters (Unicode range \\x00 - \\x 1f) by replacing them with \"\\\" followed by a two digit hex number showing its Unicode number. * Escape any trailing white space by replacing \"\\ \" with \"\\20\". * Since a XML document logically consists of characters, not octets, the resulting Unicode string is finally encoded according to the character encoding used for producing the physical representation of the XML document.",
      "ja": "* ユニコード文字で構成される文字列を考慮してください。* 次の特殊文字の出現を、\"\\\" 文字を前に付けてエスケープします：文字列の先頭にある \"#\" 文字、または文字 \",\", \"+\", \"\"\", \"\\\", \"<\", \">\" または \";\" のいずれか。* ASCII制御文字（Unicode範囲 \\x00 - \\x1f）のすべての出現を、\"\\\" とその後にUnicode番号を示す2桁の16進数を続けたものに置き換えてエスケープします。* 末尾の空白を \"\\ \" から \"\\20\" に置き換えてエスケープします。* XMLドキュメントは論理的にオクテットではなく文字で構成されているため、結果のユニコード文字列は、XMLドキュメントの物理的表現を生成するために使用される文字エンコードに従って最終的にエンコードされます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"X509Data\" type=\"ds:X509DataType\"/>\n<complexType name=\"X509DataType\">\n  <sequence maxOccurs=\"unbounded\">\n    <choice>\n      <element name=\"X509IssuerSerial\"\n               type=\"ds:X509IssuerSerialType\"/>\n      <element name=\"X509SKI\" type=\"base64Binary\"/>\n      <element name=\"X509SubjectName\" type=\"string\"/>\n      <element name=\"X509Certificate\" type=\"base64Binary\"/>\n      <element name=\"X509CRL\" type=\"base64Binary\"/>\n      <any namespace=\"##other\" processContents=\"lax\"/>\n    </choice>\n  </sequence>\n</complexType>\n<complexType name=\"X509IssuerSerialType\">\n  <sequence>\n    <element name=\"X509IssuerName\" type=\"string\"/>\n    <element name=\"X509SerialNumber\" type=\"integer\"/>\n  </sequence>\n</complexType>\n      DTD:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<!ELEMENT X509Data ((X509IssuerSerial | X509SKI | X509SubjectName\n                     | X509Certificate | X509CRL)+ %X509.ANY;)>\n<!ELEMENT X509IssuerSerial (X509IssuerName, X509SerialNumber) >\n<!ELEMENT X509IssuerName (#PCDATA) >\n<!ELEMENT X509SubjectName (#PCDATA) >\n<!ELEMENT X509SerialNumber (#PCDATA) >\n<!ELEMENT X509SKI (#PCDATA) >\n<!ELEMENT X509Certificate (#PCDATA) >\n<!ELEMENT X509CRL (#PCDATA) >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<!-- Note, this DTD and schema permit X509Data to be empty; this is precluded by the text in KeyInfo Element (section 4.4) which states that at least one element from the dsig namespace should be present in the PGP, SPKI, and X509 structures. This is easily expressed for the other key types, but not for X509Data because of its rich structure. -->",
      "ja": "<！ - 注、このDTDとスキーマはx509Dataを空にすることを許可します。これは、DSIGネームスペースの少なくとも1つの要素がPGP、SPKI、およびX509構造に存在する必要があることを示すKeyINFO要素（セクション4.4）のテキストによって排除されています。これは、他のキータイプで簡単に表現できますが、豊富な構造のためX509Dataでは簡単に表現できます。 - >"
    },
    {
      "indent": 0,
      "text": "4.4.5 The PGPData Element",
      "section_title": true,
      "ja": "4.4.5 PGPDATA要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#PGPData\" (this can be used within a RetrievalMethod or Reference element to identify the referent's type)",
      "ja": "識別子タイプ= \"http://www.w3.org/2000/09/xmldsig#pgpdata\"（これは、retirevalmethodまたは参照要素内で使用できます。"
    },
    {
      "indent": 3,
      "text": "The PGPData element within KeyInfo is used to convey information related to PGP public key pairs and signatures on such keys. The PGPKeyID's value is a base64Binary sequence containing a standard PGP public key identifier as defined in [PGP, section 11.2]. The PGPKeyPacket contains a base64-encoded Key Material Packet as defined in [PGP, section 5.5]. These children element types can be complemented/extended by siblings from an external namespace within PGPData, or PGPData can be replaced all together with an alternative PGP XML structure as a child of KeyInfo. PGPData must contain one PGPKeyID and/or one PGPKeyPacket and 0 or more elements from an external namespace.",
      "ja": "KeyInfo内のPGPDATA要素は、そのようなキーのPGP公開キーのペアと署名に関連する情報を伝えるために使用されます。PGPKEYIDの値は、[PGP、セクション11.2]で定義されている標準のPGP公開キー識別子を含むBase64Bynaryシーケンスです。PGPKEYPACKETには、[PGP、セクション5.5]で定義されているBase64エンコードされたキーマテリアルパケットが含まれています。これらの子供の要素タイプは、PGPDATA内の外部名空間から兄弟によって補完/拡張されるか、PGPDATAは、KeyInfoの子供としての代替PGP XML構造にまとめて置き換えることができます。PGPDATAには、1つのPGPKEYIDおよび/または1つのPGPKEYPACKET、および外部ネームスペースから0以上の要素を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"PGPData\" type=\"ds:PGPDataType\"/>\n<complexType name=\"PGPDataType\">\n  <choice>\n    <sequence>\n      <element name=\"PGPKeyID\" type=\"base64Binary\"/>\n      <element name=\"PGPKeyPacket\" type=\"base64Binary\"\n               minOccurs=\"0\"/>\n      <any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\"\n       maxOccurs=\"unbounded\"/>\n    </sequence>\n    <sequence>\n      <element name=\"PGPKeyPacket\" type=\"base64Binary\"/>\n      <any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\"\n       maxOccurs=\"unbounded\"/>\n    </sequence>\n  </choice>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT PGPData ((PGPKeyID, PGPKeyPacket?) | (PGPKeyPacket)\n                  %PGPData.ANY;) >\n<!ELEMENT PGPKeyPacket  (#PCDATA)  >\n<!ELEMENT PGPKeyID  (#PCDATA)  >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.6 The SPKIData Element",
      "section_title": true,
      "ja": "4.4.6 spkidata要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#SPKIData\" (this can be used within a RetrievalMethod or Reference element to identify the referent's type)",
      "ja": "識別子タイプ= \"http://www.w3.org/2000/09/xmldsig#spkidata\"（これは、retirevalmethodまたは参照要素内で使用できます。"
    },
    {
      "indent": 3,
      "text": "The SPKIData element within KeyInfo is used to convey information related to SPKI public key pairs, certificates and other SPKI data. SPKISexp is the base64 encoding of a SPKI canonical S-expression. SPKIData must have at least one SPKISexp; SPKISexp can be complemented/extended by siblings from an external namespace within SPKIData, or SPKIData can be entirely replaced with an alternative SPKI XML structure as a child of KeyInfo.",
      "ja": "KeyInfo内のSpkidata要素は、SPKIの公開キーペア、証明書、その他のSPKIデータに関連する情報を伝えるために使用されます。spkisexpは、SPKI標準的なS発現のbase64エンコードです。spkidataには少なくとも1つのspkisexpが必要です。spkisexpは、spkidata内の外部名空間から兄弟によって補完/拡張できます。また、spkidataは、keyinfoの子供としての代替SPKI XML構造に完全に置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 3,
      "text": "<element name=\"SPKIData\" type=\"ds:SPKIDataType\"/>\n<complexType name=\"SPKIDataType\">\n  <sequence maxOccurs=\"unbounded\">\n    <element name=\"SPKISexp\" type=\"base64Binary\"/>\n    <any namespace=\"##other\" processContents=\"lax\" minOccurs=\"0\"/>\n  </sequence>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 3,
      "text": "<!ELEMENT SPKIData (SPKISexp %SPKIData.ANY;)  >\n<!ELEMENT SPKISexp  (#PCDATA)  >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.7 The MgmtData Element",
      "section_title": true,
      "ja": "4.4.7 MGMTDATA要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#MgmtData\" (this can be used within a RetrievalMethod or Reference element to identify the referent's type)",
      "ja": "識別子タイプ= \"http://www.w3.org/2000/09/xmldsig#mgmtdata\"（これは、retirevalmethodまたは参照要素内で使用できます。"
    },
    {
      "indent": 3,
      "text": "The MgmtData element within KeyInfo is a string value used to convey in-band key distribution or agreement data. For example, DH key exchange, RSA key encryption, etc. Use of this element is NOT RECOMMENDED. It provides a syntactic hook where in-band key distribution or agreement data can be placed. However, superior interoperable child elements of KeyInfo for the transmission of encrypted keys and for key agreement are being specified by the W3C XML Encryption Working Group and they should be used instead of MgmtData.",
      "ja": "KeyInfo内のMGMTDATA要素は、帯域内のキーディストリビューションまたは契約データを伝達するために使用される文字列値です。たとえば、DHキーエクスチェンジ、RSAキー暗号化など。この要素の使用は推奨されません。インバンドの主要な配布または契約データを配置できる構文フックを提供します。ただし、暗号化されたキーの送信およびキー契約のためのKeyINFOの優れた相互運用可能な子要素は、W3C XML暗号化ワーキンググループによって指定されており、MGMTDATAの代わりに使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"MgmtData\" type=\"string\"/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT MgmtData (#PCDATA)>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.5 The Object Element",
      "section_title": true,
      "ja": "4.5 オブジェクト要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#Object\" (this can be used within a Reference element to identify the referent's type)",
      "ja": "識別子タイプ= \"http://www.w3.org/2000/09/xmldsig#object\"（これは参照要素内で使用して、参照者のタイプを識別できます）"
    },
    {
      "indent": 3,
      "text": "Object is an optional element that may occur one or more times. When present, this element may contain any data. The Object element may include optional MIME type, ID, and encoding attributes.",
      "ja": "Objectは、1回以上出現する可能性のある任意の要素です。存在する場合、この要素にはデータが含まれている場合があります。オブジェクト要素には、任意のMIMEタイプ、ID、およびエンコード属性が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "The Object's Encoding attributed may be used to provide a URI that identifies the method by which the object is encoded (e.g., a binary file).",
      "ja": "ObjectのEncoding属性は、オブジェクトがエンコードされる方法（バイナリファイルなど）を識別するURIを提供するために使用できます。"
    },
    {
      "indent": 3,
      "text": "The MimeType attribute is an optional attribute which describes the data within the Object (independent of its encoding). This is a string with values defined by [MIME]. For example, if the Object contains base64 encoded PNG, the Encoding may be specified as 'base64' and the MimeType as 'image/png'. This attribute is purely advisory; no validation of the MimeType information is required by this specification. Applications which require normative type and encoding information for signature validation should specify Transforms with well defined resulting types and/or encodings.",
      "ja": "MimeType属性は、Object内のデータを記述する任意の属性です（エンコーディングとは無関係です）。これは、[MIME]で定義された値を持つ文字列です。たとえば、Objectにbase64エンコードされたPNGが含まれている場合、Encodingは「base64」として、MimeTypeは「image/png」として指定できます。この属性は純粋に参考情報です。この仕様では、MimeType情報の検証は必要ありません。署名検証のために規範的なタイプとエンコーディング情報を必要とするアプリケーションは、適切に定義された結果のタイプおよび/またはエンコーディングを備えた変換を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Object's Id is commonly referenced from a Reference in SignedInfo, or Manifest. This element is typically used for enveloping signatures where the object being signed is to be included in the signature element. The digest is calculated over the entire Object element including start and end tags.",
      "ja": "オブジェクトのIDは、一般にSignedInfoまたはマニフェストのリファレンスから参照されます。この要素は通常、署名されるオブジェクトが署名要素に含まれるEnveloping署名に使用されます。ダイジェストは、開始タグとエンドタグを含むオブジェクト要素全体にわたって計算されます。"
    },
    {
      "indent": 3,
      "text": "Note, if the application wishes to exclude the <Object> tags from the digest calculation, the Reference must identify the actual data object (easy for XML documents) or a transform must be used to remove the Object tags (likely where the data object is non-XML). Exclusion of the object tags may be desired for cases where one wants the signature to remain valid if the data object is moved from inside a signature to outside the signature (or vice versa), or where the content of the Object is an encoding of an original binary document and it is desired to extract and decode so as to sign the original bitwise representation.",
      "ja": "注：アプリケーションがダイジェスト計算から <Object> タグを除外したい場合、Referenceは実際のデータオブジェクトを識別するか（XMLドキュメントの場合は簡単）、Objectタグを削除するために変換を使用する必要があります（データオブジェクトが非XMLの場合に多い）。オブジェクトタグの除外は、データオブジェクトが署名の内側から署名の外側に（またはその逆に）移動された場合に署名を有効なままにしたい場合や、Objectのコンテンツが元のバイナリドキュメントのエンコードであり、元のビット単位の表現に署名するために抽出およびデコードしたい場合に望まれることがあります。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"Object\" type=\"ds:ObjectType\"/>\n<complexType name=\"ObjectType\" mixed=\"true\">\n  <sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n    <any namespace=\"##any\" processContents=\"lax\"/>\n  </sequence>\n  <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n  <attribute name=\"MimeType\" type=\"string\" use=\"optional\"/>\n  <attribute name=\"Encoding\" type=\"anyURI\" use=\"optional\"/>\n</complexType>\n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT Object (#PCDATA|Signature|SignatureProperties|Manifest\n                  %Object.ANY;)* >\n<!ATTLIST Object\n Id  ID  #IMPLIED\n MimeType    CDATA   #IMPLIED\n Encoding    CDATA   #IMPLIED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.0 Additional Signature Syntax",
      "section_title": true,
      "ja": "5.0 追加の署名構文"
    },
    {
      "indent": 3,
      "text": "This section describes the optional to implement Manifest and SignatureProperties elements and describes the handling of XML processing instructions and comments. With respect to the elements Manifest and SignatureProperties, this section specifies syntax and little behavior -- it is left to the application. These elements can appear anywhere the parent's content model permits; the Signature content model only permits them within Object.",
      "ja": "このセクションでは、実装が任意であるManifestおよびSignatureProperties要素について説明し、XML処理命令とコメントの処理について説明します。ManifestおよびSignatureProperties要素に関して、このセクションは構文とわずかな動作を指定します - それはアプリケーションに任されています。これらの要素は、親のコンテンツモデルが許可する場所であればどこにでも表示できます。署名コンテンツモデルは、Object内でのみそれらを許可します。"
    },
    {
      "indent": 0,
      "text": "5.1 The Manifest Element",
      "section_title": true,
      "ja": "5.1 マニフェスト要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#Manifest\" (this can be used within a Reference element to identify the referent's type)",
      "ja": "識別子タイプ= \"http://www.w3.org/2000/09/xmldsig#manifest\"（これは参照要素内で使用して、参照者のタイプを識別できます）"
    },
    {
      "indent": 3,
      "text": "The Manifest element provides a list of References. The difference from the list in SignedInfo is that it is application defined which, if any, of the digests are actually checked against the objects referenced and what to do if the object is inaccessible or the digest compare fails. If a Manifest is pointed to from SignedInfo, the digest over the Manifest itself will be checked by the core signature validation behavior. The digests within such a Manifest are checked at the application's discretion. If a Manifest is referenced from another Manifest, even the overall digest of this two level deep Manifest might not be checked.",
      "ja": "マニフェスト要素は、参照のリストを提供します。SignedInfoのリストとの違いは、参照されたオブジェクトに対して実際にチェックされるダイジェスト（もしあれば）や、オブジェクトにアクセスできない場合やダイジェストの比較が失敗した場合の対処方法が、アプリケーション定義であることです。マニフェストがSignedinfoから指されている場合、マニフェストのダイジェスト自体がコア署名検証動作によってチェックされます。このようなマニフェスト内のダイジェストは、アプリケーションの裁量でチェックされます。マニフェストが別のマニフェストから参照されている場合、この2つのレベルの深いマニフェストの全体的なダイジェストでさえチェックされない可能性があります。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"Manifest\" type=\"ds:ManifestType\"/>\n<complexType name=\"ManifestType\">\n  <sequence>\n    <element ref=\"ds:Reference\" maxOccurs=\"unbounded\"/>\n  </sequence>\n  <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT Manifest (Reference+)  >\n<!ATTLIST Manifest\n          Id ID  #IMPLIED >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2 The SignatureProperties Element",
      "section_title": true,
      "ja": "5.2 SignatureProperties要素"
    },
    {
      "indent": 3,
      "text": "Identifier Type=\"http://www.w3.org/2000/09/xmldsig#SignatureProperties\" (this can be used within a Reference element to identify the referent's type)",
      "ja": "識別子タイプ= \"http://www.w3.org/2000/09/xmldsig#signatureproperties\"（これは参照要素内で使用して、指示対象のタイプを識別できます）"
    },
    {
      "indent": 3,
      "text": "Additional information items concerning the generation of the signature(s) can be placed in a SignatureProperty element (i.e., date/time stamp or the serial number of cryptographic hardware used in signature generation).",
      "ja": "署名の生成に関する追加情報項目は、署名プロパティ要素（つまり、日付/タイムスタンプまたは署名生成で使用される暗号化ハードウェアのシリアル数）に配置できます。"
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<element name=\"SignatureProperties\"\n         type=\"ds:SignaturePropertiesType\"/>\n<complexType name=\"SignaturePropertiesType\">\n  <sequence>\n    <element ref=\"ds:SignatureProperty\" maxOccurs=\"unbounded\"/>\n  </sequence>\n  <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n</complexType>\n\n<element name=\"SignatureProperty\"\n         type=\"ds:SignaturePropertyType\"/>\n<complexType name=\"SignaturePropertyType\" mixed=\"true\">\n  <choice maxOccurs=\"unbounded\">\n    <any namespace=\"##other\" processContents=\"lax\"/>\n    <!-- (1,1) elements from (1,unbounded) namespaces -->\n  </choice>\n  <attribute name=\"Target\" type=\"anyURI\" use=\"required\"/>\n  <attribute name=\"Id\" type=\"ID\" use=\"optional\"/>\n</complexType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT SignatureProperties (SignatureProperty+)  >\n<!ATTLIST SignatureProperties\n          Id     ID      #IMPLIED  >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<!ELEMENT SignatureProperty (#PCDATA %SignatureProperty.ANY;)* >\n<!ATTLIST SignatureProperty\n          Target CDATA   #REQUIRED\n          Id     ID      #IMPLIED  >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3 Processing Instructions in Signature Elements",
      "section_title": true,
      "ja": "5.3 署名要素の処理手順"
    },
    {
      "indent": 3,
      "text": "No XML processing instructions (PIs) are used by this specification.",
      "ja": "この仕様では、XML処理命令（PI）は使用されません。"
    },
    {
      "indent": 3,
      "text": "Note that PIs placed inside SignedInfo by an application will be signed unless the CanonicalizationMethod algorithm discards them. (This is true for any signed XML content.) All of the CanonicalizationMethods identified within this specification retain PIs. When a PI is part of content that is signed (e.g., within SignedInfo or referenced XML documents) any change to the PI will obviously result in a signature failure.",
      "ja": "CanonicalizationMethodアルゴリズムがそれらを破棄しない限り、アプリケーションによってSignedInfo内に配置されたPIは署名されることに注意してください。（これは、署名されたXMLコンテンツに当てはまります。）この仕様内で特定されたすべてのCanonicalizationMethodsは、PIを保持します。PIが署名されているコンテンツの一部である場合（例：SignedInfoまたは参照XMLドキュメント内）、PIへの変更は明らかに署名障害になります。"
    },
    {
      "indent": 0,
      "text": "5.4 Comments in Signature Elements",
      "section_title": true,
      "ja": "5.4 署名要素のコメント"
    },
    {
      "indent": 3,
      "text": "XML comments are not used by this specification.",
      "ja": "XMLコメントは、この仕様では使用されません。"
    },
    {
      "indent": 3,
      "text": "Note that unless CanonicalizationMethod removes comments within SignedInfo or any other referenced XML (which [XML-C14N] does), they will be signed. Consequently, if they are retained, a change to the comment will cause a signature failure. Similarly, the XML signature over any XML data will be sensitive to comment changes unless a comment-ignoring canonicalization/transform method, such as the Canonical XML [XML-C14N], is specified.",
      "ja": "CanonicalizationMethodがSignedInfoまたはその他の参照されたXML（[XML-C14N]が行う）内でコメントを削除しない限り、署名されることに注意してください。その結果、それらが保持されている場合、コメントを変更すると署名の失敗が発生します。同様に、XMLデータ上のXML署名は、標準XML [XML-C14N]などのコメントに無知な標準化/変換法が指定されていない限り、コメントの変更に敏感です。"
    },
    {
      "indent": 0,
      "text": "6.0 Algorithms",
      "section_title": true,
      "ja": "6.0 アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This section identifies algorithms used with the XML digital signature specification. Entries contain the identifier to be used in Signature elements, a reference to the formal specification, and definitions, where applicable, for the representation of keys and the results of cryptographic operations.",
      "ja": "このセクションでは、XMLデジタル署名仕様で使用されるアルゴリズムを識別します。エントリには、署名要素で使用される識別子、正式な仕様への参照、および該当する場合、キーの表現と暗号化操作の結果のために定義が含まれています。"
    },
    {
      "indent": 0,
      "text": "6.1 Algorithm Identifiers and Implementation Requirements",
      "section_title": true,
      "ja": "6.1 アルゴリズム識別子と実装要件"
    },
    {
      "indent": 3,
      "text": "Algorithms are identified by URIs that appear as an attribute to the element that identifies the algorithms' role (DigestMethod, Transform, SignatureMethod, or CanonicalizationMethod). All algorithms used herein take parameters but in many cases the parameters are implicit. For example, a SignatureMethod is implicitly given two parameters: the keying info and the output of CanonicalizationMethod. Explicit additional parameters to an algorithm appear as content elements within the algorithm role element. Such parameter elements have a descriptive element name, which is frequently algorithm specific, and MUST be in the XML Signature namespace or an algorithm specific namespace.",
      "ja": "アルゴリズムは、アルゴリズムの役割（DigestMethod、Transform、SignatureMethod、またはCanonicalizationMethod）を識別する要素の属性として表示されるURIによって識別されます。ここで使用されるすべてのアルゴリズムはパラメーターを取りますが、多くの場合、パラメーターは暗黙的です。たとえば、SignatureMethodには、キーイング情報とCanonicalizationMethodの出力という2つのパラメーターが暗黙的に与えられます。アルゴリズムへの明示的な追加パラメーターは、アルゴリズムの役割要素内のコンテンツ要素として表示されます。このようなパラメーター要素には、記述要素名があり、これは頻繁にアルゴリズム固有であり、XML署名名空間またはアルゴリズム固有の名前空間にある必要があります。"
    },
    {
      "indent": 3,
      "text": "This specification defines a set of algorithms, their URIs, and requirements for implementation. Requirements are specified over implementation, not over requirements for signature use. Furthermore, the mechanism is extensible; alternative algorithms may be used by signature applications.",
      "ja": "この仕様は、アルゴリズムのセット、そのURI、および実装の要件を定義します。要件は、署名使用の要件を超えてではなく、実装よりも指定されています。さらに、メカニズムは拡張可能です。代替アルゴリズムは、署名アプリケーションで使用できます。"
    },
    {
      "indent": 3,
      "text": "Digest\n   1. Required SHA1\n      http://www.w3.org/2000/09/xmldsig#sha1\nEncoding\n   1. Required base64\n      http://www.w3.org/2000/09/xmldsig#base64\nMAC\n   1. Required HMAC-SHA1\n      http://www.w3.org/2000/09/xmldsig#hmac-sha1\nSignature\n   1. Required DSAwithSHA1 (DSS)\n      http://www.w3.org/2000/09/xmldsig#dsa-sha1\n   2. Recommended RSAwithSHA1\n      http://www.w3.org/2000/09/xmldsig#rsa-sha1\nCanonicalization\n   1. Required Canonical XML (omits comments)\n      http://www.w3.org/TR/2001/REC-xml-c14n-20010315\n   2. Recommended Canonical XML with Comments\n      http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\nTransform\n   1. Optional XSLT\n      http://www.w3.org/TR/1999/REC-xslt-19991116\n   2. Recommended XPath\n      http://www.w3.org/TR/1999/REC-xpath-19991116\n   3. Required Enveloped Signature*\n      http://www.w3.org/2000/09/xmldsig#enveloped-signature",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "* The Enveloped Signature transform removes the Signature element from the calculation of the signature when the signature is within the content that it is being signed. This MAY be implemented via the RECOMMENDED XPath specification specified in 6.6.4: Enveloped Signature Transform; it MUST have the same effect as that specified by the XPath Transform.",
      "ja": "* 包括的な署名変換は、署名が署名されているコンテンツ内にある場合、署名の計算から署名要素を削除します。これは、6.6.4で指定された推奨されるXpath仕様を介して実装できます。XPath変換によって指定された効果と同じ効果が必要です。"
    },
    {
      "indent": 0,
      "text": "6.2 Message Digests",
      "section_title": true,
      "ja": "6.2 メッセージダイジェスト"
    },
    {
      "indent": 3,
      "text": "Only one digest algorithm is defined herein. However, it is expected that one or more additional strong digest algorithms will be developed in connection with the US Advanced Encryption Standard effort. Use of MD5 [MD5] is NOT RECOMMENDED because recent advances in cryptanalysis have cast doubt on its strength.",
      "ja": "ここでは、1つのダイジェストアルゴリズムのみが定義されています。ただし、米国の高度な暗号化標準的な取り組みに関連して、1つまたは複数の追加の強力なダイジェストアルゴリズムが開発されることが予想されます。最近の暗号化の進歩がその強さに疑問を投げかけているため、MD5 [MD5]の使用は推奨されません。"
    },
    {
      "indent": 0,
      "text": "6.2.1 SHA-1",
      "section_title": true,
      "ja": "6.2.1 SHA-1"
    },
    {
      "indent": 3,
      "text": "Identifier: http://www.w3.org/2000/09/xmldsig#sha1",
      "ja": "識別子：http://www.w3.org/2000/09/xmldsig#sha1"
    },
    {
      "indent": 3,
      "text": "The SHA-1 algorithm [SHA-1] takes no explicit parameters. An example of an SHA-1 DigestAlg element is:",
      "ja": "SHA-1アルゴリズム[SHA-1]は、明示的なパラメーターを取得しません。SHA-1 Digestalg Elementの例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "<DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A SHA-1 digest is a 160-bit string. The content of the DigestValue element shall be the base64 encoding of this bit string viewed as a 20-octet octet stream. For example, the DigestValue element for the message digest:",
      "ja": "SHA-1ダイジェストは160ビット文字列です。DigestValue要素の内容は、20オクテットのOctetストリームと見なされるこのビット文字列のbase64エンコードでなければなりません。たとえば、メッセージダイジェストのDigestValue要素："
    },
    {
      "indent": 6,
      "text": "A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D",
      "ja": "A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D"
    },
    {
      "indent": 3,
      "text": "from Appendix A of the SHA-1 standard would be:",
      "ja": "SHA-1標準の付録Aから："
    },
    {
      "indent": 6,
      "text": "<DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.3 Message Authentication Codes",
      "section_title": true,
      "ja": "6.3 メッセージ認証コード"
    },
    {
      "indent": 3,
      "text": "MAC algorithms take two implicit parameters, their keying material determined from KeyInfo and the octet stream output by CanonicalizationMethod. MACs and signature algorithms are syntactically identical but a MAC implies a shared secret key.",
      "ja": "MACアルゴリズムは、KeyInfoから決定されたキーイング材料とCanonicalizationMethodによるオクテットストリーム出力から決定された2つの暗黙的なパラメーターを取ります。Macと署名アルゴリズムは構文的に同一ですが、Macは共有された秘密キーを意味します。"
    },
    {
      "indent": 0,
      "text": "6.3.1 HMAC",
      "section_title": true,
      "ja": "6.3.1 hmac"
    },
    {
      "indent": 3,
      "text": "Identifier: http://www.w3.org/2000/09/xmldsig#hmac-sha1",
      "ja": "識別子：http://www.w3.org/2000/09/xmldsig#hmac-sha1"
    },
    {
      "indent": 3,
      "text": "The HMAC algorithm (RFC2104 [HMAC]) takes the truncation length in bits as a parameter; if the parameter is not specified then all the bits of the hash are output. An example of an HMAC SignatureMethod element:",
      "ja": "HMACアルゴリズム（RFC2104 [HMAC]）は、ビットの切り捨ての長さをパラメーターとして取得します。パラメーターが指定されていない場合、ハッシュのすべてのビットが出力されます。HMAC SignatureMethod要素の例："
    },
    {
      "indent": 3,
      "text": "   <SignatureMethod\nAlgorithm=\"http://www.w3.org/2000/09/xmldsig#hmac-sha1\">\n      <HMACOutputLength>128</HMACOutputLength>\n   </SignatureMethod>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The output of the HMAC algorithm is ultimately the output (possibly truncated) of the chosen digest algorithm. This value shall be base64 encoded in the same straightforward fashion as the output of the digest algorithms. Example: the SignatureValue element for the HMAC-SHA1 digest",
      "ja": "HMACアルゴリズムの出力は、最終的に選択したダイジェストアルゴリズムの出力（おそらく切り捨てられた）です。この値は、Digestアルゴリズムの出力と同じ簡単な方法でベース64でエンコードされます。例：HMAC-SHA1ダイジェストの署名バリュー要素"
    },
    {
      "indent": 6,
      "text": "9294727A 3638BB1C 13F48EF8 158BFC9D",
      "ja": "9294727a 3638bb1c 13f48ef8 158bfc9d"
    },
    {
      "indent": 3,
      "text": "from the test vectors in [HMAC] would be",
      "ja": "[hmac]のテストベクトルから"
    },
    {
      "indent": 6,
      "text": "<SignatureValue>kpRyejY4uxwT9I74FYv8nQ==</SignatureValue>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Schema Definition:",
      "ja": "スキーマ定義："
    },
    {
      "indent": 6,
      "text": "<simpleType name=\"HMACOutputLengthType\">\n  <restriction base=\"integer\"/>\n</simpleType>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "DTD:",
      "ja": "DTD："
    },
    {
      "indent": 6,
      "text": "<!ELEMENT HMACOutputLength (#PCDATA)>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.4 Signature Algorithms",
      "section_title": true,
      "ja": "6.4 署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Signature algorithms take two implicit parameters, their keying material determined from KeyInfo and the octet stream output by CanonicalizationMethod. Signature and MAC algorithms are syntactically identical but a signature implies public key cryptography.",
      "ja": "署名アルゴリズムは、KeyINFOから決定されたキーイング材料とCanOnicalizationMethodによって決定されたキーイング材料の2つの暗黙的なパラメーターを取ります。署名とMacのアルゴリズムは構文的に同一ですが、署名は公開キーの暗号化を意味します。"
    },
    {
      "indent": 0,
      "text": "6.4.1 DSA",
      "section_title": true,
      "ja": "6.4.1 DSA"
    },
    {
      "indent": 3,
      "text": "Identifier: http://www.w3.org/2000/09/xmldsig#dsa-sha1",
      "ja": "識別子：http://www.w3.org/2000/09/xmldsig#dsa-sha1"
    },
    {
      "indent": 3,
      "text": "The DSA algorithm [DSS] takes no explicit parameters. An example of a DSA SignatureMethod element is:",
      "ja": "DSAアルゴリズム[DSS]は、明示的なパラメーターを取得しません。DSA SignatureMethod要素の例は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "<SignatureMethod\n Algorithm=\"http://www.w3.org/2000/09/xmldsig#dsa-sha1\"/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The output of the DSA algorithm consists of a pair of integers usually referred by the pair (r, s). The signature value consists of the base64 encoding of the concatenation of two octet-streams that respectively result from the octet-encoding of the values r and s in that order. Integer to octet-stream conversion must be done according to the I2OSP operation defined in the RFC 2437 [PKCS1] specification with a l parameter equal to 20. For example, the SignatureValue element for a DSA signature (r, s) with values specified in hexadecimal:",
      "ja": "DSAアルゴリズムの出力は、通常ペア（r、s）で言及される整数のペアで構成されています。署名値は、2つのオクテットストリームの連結のベース64エンコードで構成されています。これは、その順序での値rとsのオクテットエンコードからそれぞれ生じるものです。オクテットストリームへの変換への整数は、20に等しいLパラメーターを使用してRFC 2437 [PKCS1]仕様で定義されたI2OSP操作に従って行う必要があります。："
    },
    {
      "indent": 6,
      "text": "r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0 s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8",
      "ja": "r = 8BAC1AB6 6410435C B7181F95 B16AB97C 92B341C0 s = 41E2345F 1F56DF24 58F426D1 55B4BA2D B6DCD8C8"
    },
    {
      "indent": 3,
      "text": "from the example in Appendix 5 of the DSS standard would be",
      "ja": "DSS標準の付録5の例から"
    },
    {
      "indent": 6,
      "text": "<SignatureValue>\n i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA==\n</SignatureValue>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.4.2 PKCS1 (RSA-SHA1)",
      "section_title": true,
      "ja": "6.4.2 pkcs1（rsa-sha1）"
    },
    {
      "indent": 3,
      "text": "Identifier: http://www.w3.org/2000/09/xmldsig#rsa-sha1",
      "ja": "識別子：http://www.w3.org/2000/09/xmldsig#rsa-sha1"
    },
    {
      "indent": 3,
      "text": "The expression \"RSA algorithm\" as used in this document refers to the RSASSA-PKCS1-v1_5 algorithm described in RFC 2437 [PKCS1]. The RSA algorithm takes no explicit parameters. An example of an RSA SignatureMethod element is:",
      "ja": "このドキュメントで使用されている「RSAアルゴリズム」という式は、RFC 2437 [PKCS1]で説明されているRSASSA-PKCS1-V1_5アルゴリズムを指します。RSAアルゴリズムは明示的なパラメーターを取得しません。RSA SignatureMethod要素の例は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "<SignatureMethod\n Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SignatureValue content for an RSA signature is the base64 [MIME] encoding of the octet string computed as per RFC 2437 [PKCS1, section 8.1.1: Signature generation for the RSASSA-PKCS1-v1_5 signature scheme]. As specified in the EMSA-PKCS1-V1_5-ENCODE function RFC 2437 [PKCS1, section 9.2.1], the value input to the signature function MUST contain a pre-pended algorithm object identifier for the hash function, but the availability of an ASN.1 parser and recognition of OIDs are not required of a signature verifier. The PKCS#1 v1.5 representation appears as:",
      "ja": "RSA署名のSignatureValueコンテンツは、RFC 2437 [PKCS1、セクション8.1.1：RSASSA-PKCS1-v1_5署名スキームの署名生成]に従って計算されたオクテット文字列のbase64 [MIME]エンコードです。EMSA-PKCS1-V1_5-ENCODE関数 RFC 2437 [PKCS1、セクション9.2.1]で指定されているように、署名関数への値入力には、ハッシュ関数のためのプリペンドされたアルゴリズムオブジェクト識別子が含まれている必要がありますが、ASN.1パーサーの可用性とOIDの認識は、署名検証者には要求されません。PKCS＃1 v1.5表現は次のように表示されます。"
    },
    {
      "indent": 6,
      "text": "CRYPT (PAD (ASN.1 (OID, DIGEST (data))))",
      "ja": "Crypt（Pad（asn.1（oid、digest（data））））"
    },
    {
      "indent": 3,
      "text": "Note that the padded ASN.1 will be of the following form:",
      "ja": "パッド入りのasn.1は次の形式であることに注意してください。"
    },
    {
      "indent": 6,
      "text": "01 | FF* | 00 | prefix | hash",
      "ja": "01 |ff* |00 |プレフィックス|ハッシュ"
    },
    {
      "indent": 3,
      "text": "where \"|\" is concatenation, \"01\", \"FF\", and \"00\" are fixed octets of the corresponding hexadecimal value, \"hash\" is the SHA1 digest of the data, and \"prefix\" is the ASN.1 BER SHA1 algorithm designator prefix required in PKCS1 [RFC 2437], that is,",
      "ja": "ここで「|」は連結、「01」、「FF」、および「00」は、対応する16進数値の固定オクテットであり、「ハッシュ」はデータのSHA1ダイジェストであり、「プレフィックス」はPKCS1 [RFC 2437]で必要なASN.1 BER SHA1アルゴリズム指定子のプレフィックスです。つまり、"
    },
    {
      "indent": 6,
      "text": "hex 30 21 30 09 06 05 2B 0E 03 02 1A 05 00 04 14",
      "ja": "ヘックス30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14"
    },
    {
      "indent": 3,
      "text": "This prefix is included to make it easier to use standard cryptographic libraries. The FF octet MUST be repeated the maximum number of times such that the value of the quantity being CRYPTed is one octet shorter than the RSA modulus.",
      "ja": "このプレフィックスは、標準の暗号化ライブラリを使いやすくするために含まれています。FFオクテットは、CRYPTされる量の値がRSAモジュラスよりも1オクテット短くなるように、最大回数繰り返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The resulting base64 [MIME] string is the value of the child text node of the SignatureValue element, e.g.,",
      "ja": "結果のbase64 [mime]文字列は、署名数値要素の子テキストノードの値です。"
    },
    {
      "indent": 6,
      "text": "<SignatureValue>\n IWijxQjUrcXBYoCei4QxjWo9Kg8D3p9tlWoT4t0/gyTE96639\n In0FZFY2/rvP+/bMJ01EArmKZsR5VW3rwoPxw=\n</SignatureValue>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.5 Canonicalization Algorithms",
      "section_title": true,
      "ja": "6.5 正規化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "If canonicalization is performed over octets, the canonicalization algorithms take two implicit parameters: the content and its charset. The charset is derived according to the rules of the transport protocols and media types (e.g., RFC2376 [XML-MT] defines the media types for XML). This information is necessary to correctly sign and verify documents and often requires careful server side configuration.",
      "ja": "標準化がオクテットを介して実行される場合、標準化アルゴリズムは2つの暗黙的なパラメーターを取ります：コンテンツとその炭化。charsetは、輸送プロトコルとメディアタイプのルールに従って導出されます（例：RFC2376 [XML-MT]は、XMLのメディアタイプを定義します）。この情報は、ドキュメントを正しく署名および検証するために必要であり、多くの場合、サーバー側の慎重な構成が必要です。"
    },
    {
      "indent": 3,
      "text": "Various canonicalization algorithms require conversion to [UTF-8]. The two algorithms below understand at least [UTF-8] and [UTF-16] as input encodings. We RECOMMEND that externally specified algorithms do the same. Knowledge of other encodings is OPTIONAL.",
      "ja": "さまざまな標準化アルゴリズムが[UTF-8]への変換が必要です。以下の2つのアルゴリズムは、少なくとも[UTF-8]および[UTF-16]を入力エンコーディングとして理解しています。外部で指定されたアルゴリズムが同じことをすることをお勧めします。他のエンコーディングの知識はオプションです。"
    },
    {
      "indent": 3,
      "text": "Various canonicalization algorithms transcode from a non-Unicode encoding to Unicode. The two algorithms below perform text normalization during transcoding [NFC, NFC-Corrigendum]. We RECOMMEND that externally specified canonicalization algorithms do the same. (Note, there can be ambiguities in converting existing charsets to Unicode, for an example see the XML Japanese Profile [XML-Japanese] Note.)",
      "ja": "さまざまな標準化アルゴリズムは、非ユニコードエンコードからUnicodeに変換されます。以下の2つのアルゴリズムは、トランスコーディング中にテキスト正規化を実行します[NFC、NFC-Corrigendum]。外部で指定された標準化アルゴリズムが同じことを行うことをお勧めします。（既存の充電器をUnicodeに変換することにはあいまいなことがあります。たとえば、XML日本のプロファイル[XML-Japanese]注を参照してください。）"
    },
    {
      "indent": 0,
      "text": "6.5.1 Canonical XML",
      "section_title": true,
      "ja": "6.5.1 標準XML"
    },
    {
      "indent": 3,
      "text": "Identifier for REQUIRED Canonical XML (omits comments): http://www.w3.org/TR/2001/REC-xml-c14n-20010315",
      "ja": "必要な正規XMLの識別子（コメントを省略）：http://www.w3.org/tr/2001/rec-xml-c14n-20010315"
    },
    {
      "indent": 3,
      "text": "Identifier for Canonical XML with Comments: http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments",
      "ja": "コメント付き標準XMLの識別子：http://www.w3.org/tr/2001/rec-xml-c14n-20010315#withcomments"
    },
    {
      "indent": 3,
      "text": "An example of an XML canonicalization element is:\n   <CanonicalizationMethod\n    Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The normative specification of Canonical XML is [XML-C14N]. The algorithm is capable of taking as input either an octet stream or an XPath node-set (or sufficiently functional alternative). The algorithm produces an octet stream as output. Canonical XML is easily parameterized (via an additional URI) to omit or retain comments.",
      "ja": "標準的なXMLの規範的仕様は[XML-C14N]です。アルゴリズムは、オクテットストリームまたはXPathノードセット（または十分に機能的な代替）のいずれかを入力として取得できます。アルゴリズムは、出力としてオクテットストリームを生成します。標準的なXMLは、コメントを省略または保持するために（追加のURIを介して）簡単にパラメーター化されます。"
    },
    {
      "indent": 0,
      "text": "6.6 Transform Algorithms",
      "section_title": true,
      "ja": "6.6 変換アルゴリズム"
    },
    {
      "indent": 3,
      "text": "A Transform algorithm has a single implicit parameter: an octet stream from the Reference or the output of an earlier Transform.",
      "ja": "変換アルゴリズムには、単一の暗黙的なパラメーターがあります。参照からのオクテットストリームまたは以前の変換の出力です。"
    },
    {
      "indent": 3,
      "text": "Application developers are strongly encouraged to support all transforms listed in this section as RECOMMENDED unless the application environment has resource constraints that would make such support impractical. Compliance with this recommendation will maximize application interoperability and libraries should be available to enable support of these transforms in applications without extensive development.",
      "ja": "アプリケーション開発者は、アプリケーション環境にそのようなサポートが非現実的になるリソースの制約がない限り、このセクションにリストされているすべての変換を推奨するようにサポートすることを強くお勧めします。この推奨事項へのコンプライアンスは、アプリケーションの相互運用性を最大化し、広範な開発なしでアプリケーションでこれらの変換のサポートを可能にするためにライブラリを利用できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.1 Canonicalization",
      "section_title": true,
      "ja": "6.6.1 標準化"
    },
    {
      "indent": 3,
      "text": "Any canonicalization algorithm that can be used for CanonicalizationMethod (such as those in Canonicalization Algorithms (section 6.5)) can be used as a Transform.",
      "ja": "CanonicalizationMethod（Canonicalization Algorithms（セクション6.5）など）に使用できる標準化アルゴリズムは、変換として使用できます。"
    },
    {
      "indent": 0,
      "text": "6.6.2 Base64",
      "section_title": true,
      "ja": "6.6.2 base64"
    },
    {
      "indent": 3,
      "text": "Identifiers: http://www.w3.org/2000/09/xmldsig#base64",
      "ja": "識別子：http://www.w3.org/2000/09/xmldsig#base64"
    },
    {
      "indent": 3,
      "text": "The normative specification for base64 decoding transforms is [MIME]. The base64 Transform element has no content. The input is decoded by the algorithms. This transform is useful if an application needs to sign the raw data associated with the encoded content of an element.",
      "ja": "base64デコード変換の規範的仕様は[mime]です。base64変換要素にはコンテンツがありません。入力はアルゴリズムによってデコードされます。この変換は、アプリケーションが要素のエンコードされたコンテンツに関連付けられた生データに署名する必要がある場合に役立ちます。"
    },
    {
      "indent": 3,
      "text": "This transform requires an octet stream for input. If an XPath node-set (or sufficiently functional alternative) is given as input, then it is converted to an octet stream by performing operations logically equivalent to 1) applying an XPath transform with expression self::text(), then 2) taking the string-value of the node-set. Thus, if an XML element is identified by a barename XPointer in the Reference URI, and its content consists solely of base64 encoded character data, then this transform automatically strips away the start and end tags of the identified element and any of its descendant elements as well as any descendant comments and processing instructions. The output of this transform is an octet stream.",
      "ja": "この変換には、入力用のオクテットストリームが必要です。Xpathノードセット（または十分に機能的な代替）が入力として与えられている場合、1）XPath変換を式でself :: text（）、2）に適用することにより、Xpath変換を適用することにより、octetストリームに変換されます。ノードセットの文字列値。したがって、XML要素が参照URIのBarename XPointerによって識別され、そのコンテンツがBase64エンコードされた文字データのみで構成されている場合、この変換は、特定された要素とその子孫要素の開始タグとそのすべての末端のタグを自動的に取り除きます。同様に、子孫のコメントや処理手順。この変換の出力はオクテットストリームです。"
    },
    {
      "indent": 0,
      "text": "6.6.3 XPath Filtering",
      "section_title": true,
      "ja": "6.6.3 XPathフィルタリング"
    },
    {
      "indent": 3,
      "text": "Identifier: http://www.w3.org/TR/1999/REC-xpath-19991116",
      "ja": "識別子：http://www.w3.org/tr/1999/rec-xpath-19991116"
    },
    {
      "indent": 3,
      "text": "The normative specification for XPath expression evaluation is [XPath]. The XPath expression to be evaluated appears as the character content of a transform parameter child element named XPath.",
      "ja": "XPath発現評価の規範的仕様は[XPath]です。評価されるXpath式は、XPathという名前の変換パラメーター子要素の文字含有量として表示されます。"
    },
    {
      "indent": 3,
      "text": "The input required by this transform is an XPath node-set. Note that if the actual input is an XPath node-set resulting from a null URI or barename XPointer dereference, then comment nodes will have been omitted. If the actual input is an octet stream, then the application MUST convert the octet stream to an XPath node-set suitable for use by Canonical XML with Comments. (A subsequent application of the REQUIRED Canonical XML algorithm would strip away these comments.) In other words, the input node-set should be equivalent to the one that would be created by the following process:",
      "ja": "この変換で必要な入力は、XPathノードセットです。実際の入力がnull uriまたはbarename xpointerの規制否定に起因するxpathノードセットである場合、コメントノードは省略されていることに注意してください。実際の入力がOctetストリームの場合、アプリケーションは、コメント付きのCanonical XMLが使用するのに適したXPathノードセットにOctetストリームを変換する必要があります。（必要な正規XMLアルゴリズムの後続のアプリケーションは、これらのコメントを取り除きます。）言い換えれば、入力ノードセットは、次のプロセスで作成されるものと同等でなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. Initialize an XPath evaluation context by setting the initial node equal to the input XML document's root node, and set the context position and size to 1. 2. Evaluate the XPath expression (//. | //@* | //namespace::*)",
      "ja": "1. 入力XMLドキュメントのルートノードに等しい初期ノードを設定してXPath評価コンテキストを初期化し、コンテキストの位置とサイズを1に設定します。*）"
    },
    {
      "indent": 3,
      "text": "The evaluation of this expression includes all of the document's nodes (including comments) in the node-set representing the octet stream.",
      "ja": "この式の評価には、オクテットストリームを表すノードセットのすべてのドキュメントのノード（コメントを含む）が含まれます。"
    },
    {
      "indent": 3,
      "text": "The transform output is also an XPath node-set. The XPath expression appearing in the XPath parameter is evaluated once for each node in the input node-set. The result is converted to a boolean. If the boolean is true, then the node is included in the output node-set. If the boolean is false, then the node is omitted from the output node-set.",
      "ja": "変換出力もXPathノードセットです。XPathパラメーターに表示されるXPath式は、入力ノードセットの各ノードについて1回評価されます。結果はブールに変換されます。ブールが真の場合、ノードは出力ノードセットに含まれています。ブールが偽の場合、出力ノードセットからノードが省略されます。"
    },
    {
      "indent": 3,
      "text": "Note: Even if the input node-set has had comments removed, the comment nodes still exist in the underlying parse tree and can separate text nodes. For example, the markup <e>Hello, <!-- comment -->world!</e> contains two text nodes. Therefore, the expression self::text()[string()=\"Hello, world!\"] would fail. Should this problem arise in the application, it can be solved by either canonicalizing the document before the XPath transform to physically remove the comments or by matching the node based on the parent element's string value (e.g., by using the expression self::text()[string(parent::e)=\"Hello, world!\"]).",
      "ja": "注：入力ノードセットにコメントが削除されている場合でも、コメントノードは依然として基礎となる解析ツリーに存在し、テキストノードを分離できます。たとえば、マークアップ<e>こんにちは、<！ - コメント - > world！</e>には2つのテキストノードが含まれています。したがって、式self :: text（）[string（）= \"hello、world！\"]は失敗します。この問題がアプリケーションで発生した場合、XPathがコメントを物理的に削除する前にドキュメントを正規化するか、親要素の文字列値に基づいてノードを一致させることによって解決できます（例：式＃：テキスト（例：）[string（parent :: e）= \"hello、world！\"]）。"
    },
    {
      "indent": 3,
      "text": "The primary purpose of this transform is to ensure that only specifically defined changes to the input XML document are permitted after the signature is affixed. This is done by omitting precisely those nodes that are allowed to change once the signature is affixed, and including all other input nodes in the output. It is the responsibility of the XPath expression author to include all nodes whose change could affect the interpretation of the transform output in the application context.",
      "ja": "この変換の主な目的は、署名が貼られた後に入力XMLドキュメントの特異的に定義された変更のみが許可されるようにすることです。これは、署名が貼られた後に変更が許可されているノードを正確に省略し、出力に他のすべての入力ノードを含めることによって行われます。XPath式の著者の責任は、アプリケーションのコンテキストでの変換出力の解釈に変化に影響を与える可能性のあるすべてのノードを含めることです。"
    },
    {
      "indent": 3,
      "text": "An important scenario would be a document requiring two enveloped signatures. Each signature must omit itself from its own digest calculations, but it is also necessary to exclude the second signature element from the digest calculations of the first signature so that adding the second signature does not break the first signature.",
      "ja": "重要なシナリオは、2つの包囲された署名を必要とするドキュメントです。各署名は独自のダイジェスト計算から省略する必要がありますが、2番目の署名を追加しても最初の署名が壊れないように、最初の署名のダイジェスト計算から2番目の署名要素を除外する必要もあります。"
    },
    {
      "indent": 3,
      "text": "The XPath transform establishes the following evaluation context for each node of the input node-set:",
      "ja": "XPath変換は、入力ノードセットの各ノードの次の評価コンテキストを確立します。"
    },
    {
      "indent": 6,
      "text": "* A context node equal to a node of the input node-set. * A context position, initialized to 1. * A context size, initialized to 1. * A library of functions equal to the function set defined in [XPath] plus a function named here. * A set of variable bindings. No means for initializing these is defined. Thus, the set of variable bindings used when evaluating the XPath expression is empty, and use of a variable reference in the XPath expression results in an error. * The set of namespace declarations in scope for the XPath expression.",
      "ja": "* 入力ノードセットのノードに等しいコンテキストノード。* 1に初期化されたコンテキスト位置。 *コンテキストサイズ。*可変バインディングのセット。これらを初期化するための手段は定義されていません。したがって、XPath式を評価するときに使用される可変バインディングのセットは空であり、XPath式で変数参照を使用するとエラーが発生します。* Xpath式の範囲の名前空間宣言のセット。"
    },
    {
      "indent": 3,
      "text": "As a result of the context node setting, the XPath expressions appearing in this transform will be quite similar to those used in [XSLT], except that the size and position are always 1 to reflect the fact that the transform is automatically visiting every node (in XSLT, one recursively calls the command apply-templates to visit the nodes of the input tree).",
      "ja": "コンテキストノード設定の結果として、この変換に表示されるXPath式は[XSLT]で使用されているXPath式と非常に似ていますが、変換がすべてのノードに自動的に訪問しているという事実を反映するサイズと位置が常に1であることを除きます（XSLTでは、入力ツリーのノードにアクセスするためにコマンドを再帰的に呼び出します。"
    },
    {
      "indent": 3,
      "text": "The function here() is defined as follows:",
      "ja": "ここの関数（）は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "Function: node-set here() The here function returns a node-set containing the attribute or processing instruction node or the parent element of the text node that directly bears the XPath expression. This expression results in an error if the containing XPath expression does not appear in the same XML document against which the XPath expression is being evaluated.",
      "ja": "関数：ここでノードセット（）here関数は、xpath式を直接担うテキストノードの属性または処理命令ノードを含むノードセットを返します。この式は、XPath式が評価されているのと同じXMLドキュメントに含まれていないXPATH式が表示されない場合、エラーが発生します。"
    },
    {
      "indent": 3,
      "text": "As an example, consider creating an enveloped signature (a Signature element that is a descendant of an element being signed). Although the signed content should not be changed after signing, the elements within the Signature element are changing (e.g., the digest value must be put inside the DigestValue and the SignatureValue must be subsequently calculated). One way to prevent these changes from invalidating the digest value in DigestValue is to add an XPath Transform that omits all Signature elements and their descendants. For example,",
      "ja": "例として、包み込まれた署名（署名されている要素の子孫である署名要素）を作成することを検討してください。署名後に署名されたコンテンツを変更してはなりませんが、署名要素内の要素は変更されています（たとえば、ダイジェスト値をダイジェストバリュー内に配置する必要があり、その後署名値を計算する必要があります）。これらの変更がダイジェスト値のダイジェスト値を無効にするのを防ぐ1つの方法は、すべての署名要素とその子孫を省略するXPath変換を追加することです。例えば、"
    },
    {
      "indent": 3,
      "text": "   <Document>\n   ...\n   <Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\">\n     <SignedInfo>\n      ...\n       <Reference URI=\"\">\n         <Transforms>\n           <Transform\nAlgorithm=\"http://www.w3.org/TR/1999/REC-xpath-19991116\">\n             <XPath xmlns:dsig=\"&dsig;\">\n             not(ancestor-or-self::dsig:Signature)\n             </XPath>\n           </Transform>\n         </Transforms>\n         <DigestMethod\nAlgorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/>\n         <DigestValue></DigestValue>\n       </Reference>\n     </SignedInfo>\n     <SignatureValue></SignatureValue>\n    </Signature>\n    ...\n   </Document>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Due to the null Reference URI in this example, the XPath transform input node-set contains all nodes in the entire parse tree starting at the root node (except the comment nodes). For each node in this node-set, the node is included in the output node-set except if the node or one of its ancestors, has a tag of Signature that is in the namespace given by the replacement text for the entity &dsig;.",
      "ja": "この例のNULL参照URIのため、XPath変換入力ノードセットには、ルートノード（コメントノードを除く）から始まる解析ツリー全体のすべてのノードが含まれます。このノードセットの各ノードについては、ノードが祖先またはその祖先のいずれかを除き、出力ノードセットにノードが含まれており、エンティティの交換テキストで与えられた名前空間にある署名のタグがあります。"
    },
    {
      "indent": 3,
      "text": "A more elegant solution uses the here function to omit only the Signature containing the XPath Transform, thus allowing enveloped signatures to sign other signatures. In the example above, use the XPath element:",
      "ja": "よりエレガントなソリューションでは、here関数を使用してXpath変換を含む署名のみを省略し、包み込まれた署名が他の署名に署名できるようにします。上記の例では、XPath要素を使用します。"
    },
    {
      "indent": 6,
      "text": "<XPath xmlns:dsig=\"&dsig;\">\ncount(ancestor-or-self::dsig:Signature |\nhere()/ancestor::dsig:Signature[1]) >\ncount(ancestor-or-self::dsig:Signature)</XPath>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Since the XPath equality operator converts node sets to string values before comparison, we must instead use the XPath union operator (|). For each node of the document, the predicate expression is true if and only if the node-set containing the node and its Signature element ancestors does not include the enveloped Signature element containing the XPath expression (the union does not produce a larger set if the enveloped Signature element is in the node-set given by ancestor-or-self::Signature).",
      "ja": "Xpath Equalityオペレーターは、比較前にノードセットを文字列値に変換するため、代わりにXpath Unionオペレーター（|）を使用する必要があります。ドキュメントの各ノードについて、Nodeを含むノードセットとその署名要素の先祖には、XPath式を含む包括的な署名要素が含まれていない場合にのみ、述語式は真です（組合は、より大きなセットを生成しません。包み込まれた署名要素は、祖先またはself :: signatureによって与えられるノードセットにあります）。"
    },
    {
      "indent": 0,
      "text": "6.6.4 Enveloped Signature Transform",
      "section_title": true,
      "ja": "6.6.4 包括的な署名変換"
    },
    {
      "indent": 3,
      "text": "Identifier: http://www.w3.org/2000/09/xmldsig#enveloped-signature",
      "ja": "識別子：http://www.w3.org/2000/09/xmldsig#enveloped-signature"
    },
    {
      "indent": 3,
      "text": "An enveloped signature transform T removes the whole Signature element containing T from the digest calculation of the Reference element containing T. The entire string of characters used by an XML processor to match the Signature with the XML production element is removed. The output of the transform is equivalent to the output that would result from replacing T with an XPath transform containing the following XPath parameter element:",
      "ja": "封筒の署名変換Tは、Tを含む参照要素のダイジェスト計算からTを含む署名要素全体を削除します。XMLプロセッサで使用される文字列全体の署名とXML生産要素を一致させるために使用される文字列全体が削除されます。変換の出力は、Tを次のXPathパラメーター要素を含むXPath変換に置き換えることから生じる出力に相当します。"
    },
    {
      "indent": 6,
      "text": "<XPath xmlns:dsig=\"&dsig;\">\ncount(ancestor-or-self::dsig:Signature |\nhere()/ancestor::dsig:Signature[1]) >\ncount(ancestor-or-self::dsig:Signature)</XPath>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The input and output requirements of this transform are identical to those of the XPath transform, but may only be applied to a node-set from its parent XML document. Note that it is not necessary to use an XPath expression evaluator to create this transform. However, this transform MUST produce output in exactly the same manner as the XPath transform parameterized by the XPath expression above.",
      "ja": "この変換の入力要件と出力要件は、XPath変換の要件と同一ですが、親XMLドキュメントのノードセットにのみ適用できます。XPath Expression Evaluatorを使用してこの変換を作成する必要はないことに注意してください。ただし、この変換は、上記のXPath式によってパラメーター化されたXPath変換とまったく同じ方法で出力を生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.5 XSLT Transform",
      "section_title": true,
      "ja": "6.6.5 XSLT変換"
    },
    {
      "indent": 3,
      "text": "Identifier: http://www.w3.org/TR/1999/REC-xslt-19991116",
      "ja": "識別子：http://www.w3.org/tr/1999/rec-xslt-19991116"
    },
    {
      "indent": 3,
      "text": "The normative specification for XSL Transformations is [XSLT]. Specification of a namespace-qualified stylesheet element, which MUST be the sole child of the Transform element, indicates that the specified style sheet should be used. Whether this instantiates in-line processing of local XSLT declaration within the resource is determined by the XSLT processing model; the ordered application of multiple stylesheet may require multiple Transforms. No special provision is made for the identification of a remote stylesheet at a given URI because it can be communicated via an xsl:include or xsl:import within the stylesheet child of the Transform.",
      "ja": "XSL変換の規範的仕様は[XSLT]です。変換要素の唯一の子でなければならない名前空間認定のスタイルシート要素の仕様は、指定されたスタイルシートを使用する必要があることを示しています。これがリソース内のローカルXSLT宣言のインライン処理をインスタンス化するかどうかは、XSLT処理モデルによって決定されます。複数のスタイルシートの順序付けられたアプリケーションには、複数の変換が必要になる場合があります。XSLを介して通信できるため、特定のURIでのリモートスタイルシートを識別するための特別な規定はありません。"
    },
    {
      "indent": 3,
      "text": "This transform requires an octet stream as input. If the actual input is an XPath node-set, then the signature application should attempt to convert it to octets (apply Canonical XML]) as described in the Reference Processing Model (section 4.3.3.2).",
      "ja": "この変換には、入力としてのオクテットストリームが必要です。実際の入力がXPathノードセットの場合、署名アプリケーションは、参照処理モデル（セクション4.3.3.2）で説明されているように、オクテット（適用XML）に変換しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "The output of this transform is an octet stream. The processing rules for the XSL style sheet or transform element are stated in the XSLT specification [XSLT]. We RECOMMEND that XSLT transform authors use an output method of xml for XML and HTML. As XSLT implementations do not produce consistent serializations of their output, we further RECOMMEND inserting a transform after the XSLT transform to canonicalize the output. These steps will help to ensure interoperability of the resulting signatures among applications that support the XSLT transform. Note that if the output is actually HTML, then the result of these steps is logically equivalent [XHTML].",
      "ja": "この変換の出力はオクテットストリームです。XSLスタイルシートまたは変換要素の処理ルールは、XSLT仕様[XSLT]に記載されています。XSLT変換著者は、XMLおよびHTMLにXMLの出力方法を使用することをお勧めします。XSLTの実装は、その出力の一貫したシリアル化を生成しないため、XSLT変換後に出力を正規化するために変換を挿入することをお勧めします。これらの手順は、XSLT変換をサポートするアプリケーション間の結果の署名の相互運用性を確保するのに役立ちます。出力が実際にHTMLの場合、これらのステップの結果は論理的に等しい[XHTML]であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "7. XML Canonicalization and Syntax Constraint Considerations",
      "section_title": true,
      "ja": "7. XML Canonicalizationおよび構文の制約に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Digital signatures only work if the verification calculations are performed on exactly the same bits as the signing calculations. If the surface representation of the signed data can change between signing and verification, then some way to standardize the changeable aspect must be used before signing and verification. For example, even for simple ASCII text there are at least three widely used line ending sequences. If it is possible for signed text to be modified from one line ending convention to another between the time of signing and signature verification, then the line endings need to be canonicalized to a standard form before signing and verification or the signatures will break.",
      "ja": "デジタル署名は、署名計算とまったく同じビットで検証計算が実行される場合にのみ機能します。署名されたデータの表面表現が署名と検証の間に変更できる場合、署名と検証の前に、変更可能な側面を標準化する何らかの方法を使用する必要があります。たとえば、単純なASCIIテキストであっても、少なくとも3つの広く使用されているラインエンディングシーケンスがあります。署名時から署名検証時までの間に、署名されたテキストの行末規則が別のものに変更される可能性がある場合、署名と検証の前に行末を標準形式に正規化する必要があります。そうしないと、署名が破損します。"
    },
    {
      "indent": 3,
      "text": "XML is subject to surface representation changes and to processing which discards some surface information. For this reason, XML digital signatures have a provision for indicating canonicalization methods in the signature so that a verifier can use the same canonicalization as the signer.",
      "ja": "XMLは、表面表現の変更と、一部の表面情報を破棄する処理の対象となります。このため、XMLデジタル署名には、検証者が署名者と同じ標準化を使用できるように、署名に正規化方法を示すための規定があります。"
    },
    {
      "indent": 3,
      "text": "Throughout this specification we distinguish between the canonicalization of a Signature element and other signed XML data objects. It is possible for an isolated XML document to be treated as if it were binary data so that no changes can occur. In that case, the digest of the document will not change and it need not be canonicalized if it is signed and verified as such. However, XML that is read and processed using standard XML parsing and processing techniques is frequently changed such that some of its surface representation information is lost or modified. In particular, this will occur in many cases for the Signature and enclosed SignedInfo elements since they, and possibly an encompassing XML document, will be processed as XML.",
      "ja": "この仕様を通して、署名要素の正規化と他の署名されたXMLデータオブジェクトの標準化を区別します。孤立したXMLドキュメントが、変更が発生しないようにバイナリデータであるかのように扱われる可能性があります。その場合、ドキュメントのダイジェストは変更されず、署名および検証されている場合は標準化する必要はありません。ただし、標準のXML解析および処理技術を使用して読み取りおよび処理されるXMLは、表面表現情報の一部が失われたり変更されたりするように頻繁に変更されます。特に、これは多くの場合、署名および囲まれたSignedInfo要素に対して発生します。これは、それらがXMLとして処理される可能性があるため、おそらくXMLドキュメントを包み込む可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "Similarly, these considerations apply to Manifest, Object, and SignatureProperties elements if those elements have been digested, their DigestValue is to be checked, and they are being processed as XML.",
      "ja": "同様に、これらの考慮事項は、それらの要素が消化されている場合、それらの消化率をチェックし、XMLとして処理されている場合、マニフェスト、オブジェクト、および署名プロパティの要素に適用されます。"
    },
    {
      "indent": 3,
      "text": "The kinds of changes in XML that may need to be canonicalized can be divided into four categories. There are those related to the basic [XML], as described in 7.1 below. There are those related to [DOM], [SAX], or similar processing as described in 7.2 below. Third, there is the possibility of coded character set conversion, such as between UTF-8 and UTF-16, both of which all [XML] compliant processors are required to support, which is described in the paragraph immediately below. And, fourth, there are changes that related to namespace declaration and XML namespace attribute context as described in 7.3 below.",
      "ja": "標準化する必要があるXMLの変化の種類は、4つのカテゴリに分割できます。以下7.1で説明されているように、基本[XML]に関連するものがあります。以下の7.2で説明されているように、[dom]、[sax]、または同様の処理に関連するものがあります。第三に、UTF-8とUTF-16の間など、コード化された文字セット変換の可能性があります。どちらもすべての[XML]コンプライアンスプロセッサがサポートする必要があります。そして、第四に、以下の7.3で説明されているように、名前空間宣言とXML名属性のコンテキストに関連する変更があります。"
    },
    {
      "indent": 3,
      "text": "Any canonicalization algorithm should yield output in a specific fixed coded character set. All canonicalization algorithms identified in this document use UTF-8 (without a byte order mark (BOM)) and do not provide character normalization. We RECOMMEND that signature applications create XML content (Signature elements and their descendents/content) in Normalization Form C [NFC, NFC-Corrigendum] and check that any XML being consumed is in that form as well; (if not, signatures may consequently fail to validate). Additionally, none of these algorithms provide data type normalization. Applications that normalize data types in varying formats (e.g., (true, false) or (1,0)) may not be able to validate each other's signatures.",
      "ja": "いかなる正規化アルゴリズムも、特定の固定された符号化文字セットで出力を生成すべきです。このドキュメントで特定されたすべての正規化アルゴリズムは、UTF-8（バイト順序マーク（BOM）なし）を使用し、文字の正規化を提供しません。署名アプリケーションは、XMLコンテンツ（署名要素とその子孫/コンテンツ）を正規化フォームC [NFC、NFC-Corrigendum]で作成し、消費されているXMLもその形式であることを確認することをお勧めします。（そうでない場合、署名はその結果、検証に失敗する場合があります）。さらに、これらのアルゴリズムはいずれもデータ型の正規化を提供していません。さまざまな形式（例：（true, false）または（1,0））でデータ型を正規化するアプリケーションは、互いの署名を検証できない場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1 XML 1.0, Syntax Constraints, and Canonicalization",
      "section_title": true,
      "ja": "7.1 XML 1.0、構文制約、および正規化"
    },
    {
      "indent": 3,
      "text": "XML 1.0 [XML] defines an interface where a conformant application reading XML is given certain information from that XML and not other information. In particular, 1. line endings are normalized to the single character #xA by dropping #xD characters if they are immediately followed by a #xA and replacing them with #xA in all other cases, 2. missing attributes declared to have default values are provided to the application as if present with the default value, 3. character references are replaced with the corresponding character, 4. entity references are replaced with the corresponding declared entity, 5. attribute values are normalized by 5.1 replacing character and entity references as above, 5.2 replacing occurrences of #x9, #xA, and #xD with #x20 (space) except that the sequence #xD#xA is replaced by a single space, and 5.3 if the attribute is not declared to be CDATA, stripping all leading and trailing spaces and replacing all interior runs of spaces with a single space.",
      "ja": "XML 1.0 [XML]は、XMLを読み取る適切なアプリケーションに他の情報ではなく、そのXMLから特定の情報が与えられるインターフェイスを定義します。特に、1. 行末は、#xD文字の直後に#xAが続く場合は#xD文字を削除し、その他のすべての場合は#xDを#xAに置き換えることにより、単一文字#xAに正規化されます。2. デフォルト値を持つと宣言された欠落している属性は、デフォルト値で存在するかのようにアプリケーションに提供されます。3. 文字参照は対応する文字に置き換えられます。4. エンティティ参照は、対応する宣言されたエンティティに置き換えられます。5. 属性値は次のように正規化されます。5.1 上記のように文字およびエンティティ参照を置き換える、5.2 #x9、#xA、および#xDの出現を#x20（スペース）に置き換える（ただし、シーケンス#xD#xAは単一のスペースに置き換えられる）、および 5.3 属性がCDATAであると宣言されていない場合、すべての先頭と末尾のスペースを削除し、スペースのすべての内部の連続を単一のスペースに置き換える。"
    },
    {
      "indent": 3,
      "text": "Note that items (2), (4), and (5.3) depend on the presence of a schema, DTD or similar declarations. The Signature element type is laxly schema valid [XML-schema], consequently external XML or even XML within the same document as the signature may be (only) well-formed or from another namespace (where permitted by the signature schema); the noted items may not be present. Thus, a signature with such content will only be verifiable by other signature applications if the following syntax constraints are observed when generating any signed material including the SignedInfo element:",
      "ja": "項目（2）、（4）、および（5.3）は、スキーマ、DTD、または同様の宣言の存在に依存することに注意してください。Signature要素タイプは laxly schema valid [XML-Schema] であるため、外部XMLまたは署名と同じドキュメント内のXMLでさえ、（単に）整形式であるか、別の名前空間からのものである可能性があります（署名スキーマで許可されている場合）。そのため、上記の項目が存在しない場合があります。したがって、そのようなコンテンツを含む署名は、SignedInfo要素を含む署名対象の資料を生成するときに次の構文制約が遵守される場合にのみ、他の署名アプリケーションによって検証可能になります。"
    },
    {
      "indent": 3,
      "text": "1. attributes having default values be explicitly present, 2. all entity references (except \"amp\", \"lt\", \"gt\", \"apos\", \"quot\", and other character entities not representable in the encoding chosen) be expanded, 3. attribute value white space be normalized",
      "ja": "1. デフォルト値を持つ属性が明示的に存在する、2. すべてのエンティティ参照（「amp」、「lt」、「gt」、「apos」、「quot」、および選択したエンコーディングで表現できないその他の文字エンティティを除く）が展開される、3. 属性値の空白が正規化される"
    },
    {
      "indent": 0,
      "text": "7.2 DOM/SAX Processing and Canonicalization",
      "section_title": true,
      "ja": "7.2 DOM/SAX処理と正規化"
    },
    {
      "indent": 3,
      "text": "In addition to the canonicalization and syntax constraints discussed above, many XML applications use the Document Object Model [DOM] or the Simple API for XML [SAX]. DOM maps XML into a tree structure of nodes and typically assumes it will be used on an entire document with subsequent processing being done on this tree. SAX converts XML into a series of events such as a start tag, content, etc. In either case, many surface characteristics such as the ordering of attributes and insignificant white space within start/end tags is lost. In addition, namespace declarations are mapped over the nodes to which they apply, losing the namespace prefixes in the source text and, in most cases, losing where namespace declarations appeared in the original instance.",
      "ja": "上記の標準化と構文の制約に加えて、多くのXMLアプリケーションは、XML [SAX]のドキュメントオブジェクトモデル[DOM]または単純なAPIを使用しています。domはXMLをノードのツリー構造にマッピングし、通常、ドキュメント全体で使用されると仮定し、その後の処理がこのツリーで行われます。SAXは、XMLを開始タグ、コンテンツなどの一連のイベントに変換します。どちらの場合も、属性の順序付けや開始/エンドタグ内の重要でない空白などの多くの表面特性が失われます。さらに、名前空間宣言は、適用されるノードにマッピングされ、ソーステキストの名前空間プレフィックスを失い、ほとんどの場合、元のインスタンスで名前空間宣言が表示された場所を失います。"
    },
    {
      "indent": 3,
      "text": "If an XML Signature is to be produced or verified on a system using DOM or SAX processing, a canonical method is needed to serialize the relevant part of a DOM tree or sequence of SAX events. XML canonicalization specifications, such as [XML-C14N], are based only on information which is preserved by DOM and SAX. For an XML Signature to be verifiable by an implementation using DOM or SAX, not only must the XML 1.0 syntax constraints given in the previous section be followed, but an appropriate XML canonicalization MUST be specified so that the verifier can re-serialize DOM/SAX mediated input into the same octet stream that was signed.",
      "ja": "XML署名をDOMまたはSAX処理を使用するシステムで作成または検証する場合、DOMツリーの関連部分またはSAXイベントのシーケンスをシリアル化するために正規化メソッドが必要です。[XML-C14N]などのXML正規化仕様は、DOMとSAXによって保存されている情報のみに基づいています。DOMまたはSAXを使用した実装によって検証可能であるXML署名の場合、前のセクションに記載されているXML 1.0構文の制約に従う必要があるだけでなく、適切なXML正規化を指定して、検証者がDOM/SAXを介した入力を、署名されたのと同じオクテットストリームに再シリアル化できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3 Namespace Context and Portable Signatures",
      "section_title": true,
      "ja": "7.3 名前空間コンテキストとポータブル署名"
    },
    {
      "indent": 3,
      "text": "In [XPath] and consequently the Canonical XML data model an element has namespace nodes that correspond to those declarations within the element and its ancestors:",
      "ja": "[XPath]およびその結果としてのCanonical XMLデータモデルでは、要素には、その要素とその祖先内の宣言に対応する名前空間ノードがあります。"
    },
    {
      "indent": 6,
      "text": "\"Note: An element E has namespace nodes that represent its namespace declarations as well as any namespace declarations made by its ancestors that have not been overridden in E's declarations, the default namespace if it is non-empty, and the declaration of the prefix xml.\" [XML-C14N]",
      "ja": "「注：要素Eには、名前空間宣言を表す名前空間ノードと、eの宣言で上書きされていない先祖、デフォルトの名前空間が空である場合はデフォルトの名前空間、およびプレフィックスXMLの宣言が行われた名前空間宣言を表す名前空間ノードがあります。。」[XML-C14N]"
    },
    {
      "indent": 3,
      "text": "When serializing a Signature element or signed XML data that's the child of other elements using these data models, that Signature element and its children, may contain namespace declarations from its ancestor context. In addition, the Canonical XML and Canonical XML with Comments algorithms import all xml namespace attributes (such as xml:lang) from the nearest ancestor in which they are declared to the apex node of canonicalized XML unless they are already declared at that node. This may frustrate the intent of the signer to create a signature in one context which remains valid in another. For example, given a signature which is a child of B and a grandchild of A:",
      "ja": "これらのデータモデルを使用して他の要素の子であるSignature要素または署名されたXMLデータをシリアル化する場合、そのSignature要素とその子は、祖先のコンテキストからの名前空間宣言を含む場合があります。さらに、Canonical XMLおよびCanonical XML with Commentsアルゴリズムは、すべてのxml名前空間属性（xml:langなど）を、それらが宣言されている最も近い祖先から、正規化されたXMLの頂点ノードにインポートします（そのノードですでに宣言されていない限り）。これは、あるコンテキストで作成した署名が別のコンテキストでも有効なままであるようにするという署名者の意図を妨げる可能性があります。たとえば、Bの子供であり、Aの孫である署名が与えられます。"
    },
    {
      "indent": 6,
      "text": "<A xmlns:n1=\"&foo;\">\n  <B xmlns:n2=\"&bar;\">\n    <Signature xmlns=\"&dsig;\">   ...\n      <Reference URI=\"#signme\"/> ...\n    </Signature>\n    <C ID=\"signme\" xmlns=\"&baz;\"/>\n  </B>\n</A>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "when either the element B or the signed element C is moved into a [SOAP] envelope for transport:",
      "ja": "要素Bまたは署名された要素Cが転送用の[SOAP]エンベロープに移動される場合："
    },
    {
      "indent": 3,
      "text": "   <SOAP:Envelope\nxmlns:SOAP=\"http://schemas.xmlsoap.org/soap/envelope/\">\n     ...\n     <SOAP:Body>\n       <B xmlns:n2=\"&bar;\">\n         <Signature xmlns=\"&dsig;\">\n           ...\n         </Signature>\n         <C ID=\"signme\" xmlns=\"&baz;\"/>\n       </B>\n     </SOAP:Body>\n   </SOAP:Envelope>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The canonical form of the signature in this context will contain new namespace declarations from the SOAP:Envelope context, invalidating the signature. Also, the canonical form will lack namespace declarations it may have originally had from element A's context, also invalidating the signature. To avoid these problems, the application may:",
      "ja": "このコンテキストでの署名の正規化形式には、SOAP:Envelopeコンテキストからの新しい名前空間宣言が含まれ、署名が無効になります。また、正規化形式には、元々要素Aのコンテキストから持っていた可能性のある名前空間宣言が欠落し、これも署名を無効にします。これらの問題を回避するために、アプリケーションは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Rely upon the enveloping application to properly divorce its body (the signature payload) from the context (the envelope) before the signature is validated. Or, 2. Use a canonicalization method that \"repels/excludes\" instead of \"attracts\" ancestor context. [XML-C14N] purposefully attracts such context.",
      "ja": "1. Envelopingアプリケーションに依存して、署名が検証される前に、その本体（署名ペイロード）をコンテキスト（エンベロープ）から適切に分離します。または、2. 祖先のコンテキストを「引き付ける」のではなく、「反発/除外」する正規化方法を使用します。[XML-C14N]は、意図的にそのようなコンテキストを引き付けます。"
    },
    {
      "indent": 0,
      "text": "8.0 Security Considerations",
      "section_title": true,
      "ja": "8.0 セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The XML Signature specification provides a very flexible digital signature mechanism. Implementors must give consideration to their application threat models and to the following factors.",
      "ja": "XML署名仕様は、非常に柔軟なデジタル署名メカニズムを提供します。実装者は、アプリケーションの脅威モデルと次の要因を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1 Transforms",
      "section_title": true,
      "ja": "8.1 変換"
    },
    {
      "indent": 3,
      "text": "A requirement of this specification is to permit signatures to \"apply to a part or totality of a XML document.\" (See [XML-Signature-RD, section 3.1.3].) The Transforms mechanism meets this requirement by permitting one to sign data derived from processing the content of the identified resource. For instance, applications that wish to sign a form, but permit users to enter a limited field data without invalidating a previous signature on the form might use [XPath] to exclude those portions the user needs to change. Transforms may be arbitrarily specified and may include encoding transforms, canonicalization instructions or even XSLT transformations. Three cautions are raised with respect to this feature in the following sections.",
      "ja": "この仕様の要件は、署名が「XMLドキュメントの一部または全体性に適用される」ことを許可することです。（[XML-Signature-Rd、セクション3.1.3]を参照してください。）変換メカニズムは、特定されたリソースのコンテンツの処理から派生したデータに署名することを許可することにより、この要件を満たしています。たとえば、フォームに署名したいが、フォーム上の以前の署名を無効にすることなくユーザーが限られたフィールドデータを入力できるようにするアプリケーション[XPath]を使用して、ユーザーが変更する必要がある部分を除外する場合があります。変換は任意に指定でき、エンコード変換、正規化命令、またはXSLT変換などが含まれる場合があります。次のセクションでは、この機能に関して3つの注意が掲載されています。"
    },
    {
      "indent": 3,
      "text": "Note, core validation behavior does not confirm that the signed data was obtained by applying each step of the indicated transforms. (Though it does check that the digest of the resulting content matches that specified in the signature.) For example, some applications may be satisfied with verifying an XML signature over a cached copy of already transformed data. Other applications might require that content be freshly dereferenced and transformed.",
      "ja": "注意してください。コア検証動作は、指定された変換の各ステップを適用することによって署名されたデータが取得されたことを確認しません。（ただし、署名で指定された結果のコンテンツのダイジェストが一致することを確認します。）たとえば、一部のアプリケーションは、すでに変換されたデータのキャッシュされたコピーを介してXML署名を確認することに満足する場合があります。他のアプリケーションでは、コンテンツを新たに参照して変換する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "8.1.1 Only What is Signed is Secure",
      "section_title": true,
      "ja": "8.1.1 署名されているのは安全です"
    },
    {
      "indent": 3,
      "text": "First, obviously, signatures over a transformed document do not secure any information discarded by transforms: only what is signed is secure.",
      "ja": "第一に、明らかに、変換されたドキュメントに対する署名は、変換によって破棄される情報を保護しません：署名されているものだけが安全です。"
    },
    {
      "indent": 3,
      "text": "Note that the use of Canonical XML [XML-C14N] ensures that all internal entities and XML namespaces are expanded within the content being signed. All entities are replaced with their definitions and the canonical form explicitly represents the namespace that an element would otherwise inherit. Applications that do not canonicalize XML content (especially the SignedInfo element) SHOULD NOT use internal entities and SHOULD represent the namespace explicitly within the content being signed since they cannot rely upon canonicalization to do this for them. Also, users concerned with the integrity of the element type definitions associated with the XML instance being signed may wish to sign those definitions as well (i.e., the schema, DTD, or natural language description associated with the namespace/identifier).",
      "ja": "Canonical XML [XML-C14N]を使用すると、すべての内部エンティティとXML名前空間が署名されるコンテンツ内で展開されることが保証されることに注意してください。すべてのエンティティは定義に置き換えられ、正規化形式は要素が継承するはずの名前空間を明示的に表します。XMLコンテンツ（特にSignedInfo要素）を正規化しないアプリケーションは、内部エンティティを使用してはならず（SHOULD NOT）、署名されるコンテンツ内で名前空間を明示的に表現する必要があります（SHOULD）。これは、正規化に頼ることができないためです。また、署名されているXMLインスタンスに関連付けられた要素タイプ定義の整合性に関係するユーザーは、これらの定義にも署名することを望む場合があります（つまり、名前空間/識別子に関連付けられたスキーマ、DTD、または自然言語の説明）。"
    },
    {
      "indent": 3,
      "text": "Second, an envelope containing signed information is not secured by the signature. For instance, when an encrypted envelope contains a signature, the signature does not protect the authenticity or integrity of unsigned envelope headers nor its ciphertext form, it only secures the plaintext actually signed.",
      "ja": "第二に、署名された情報を含むエンベロープは、署名によって保護されていません。たとえば、暗号化されたエンベロープに署名が含まれている場合、署名は署名されていないエンベロープヘッダーの真正性や完全性、またはその暗号文形式を保護しません。実際に署名された平文のみを保護します。"
    },
    {
      "indent": 0,
      "text": "8.1.2 Only What is 'Seen' Should be Signed",
      "section_title": true,
      "ja": "8.1.2 「見られた」ものだけに署名する必要があります"
    },
    {
      "indent": 3,
      "text": "Additionally, the signature secures any information introduced by the transform: only what is \"seen\" (that which is represented to the user via visual, auditory or other media) should be signed. If signing is intended to convey the judgment or consent of a user (an automated mechanism or person), then it is normally necessary to secure as exactly as practical the information that was presented to that user. Note that this can be accomplished by literally signing what was presented, such as the screen images shown a user. However, this may result in data which is difficult for subsequent software to manipulate. Instead, one can sign the data along with whatever filters, style sheets, client profile or other information that affects its presentation.",
      "ja": "署名がユーザー（自動化されたメカニズムまたは個人）の判断または同意を伝えることを目的としている場合、通常、そのユーザーに提示された情報をできるだけ正確に保護する必要があります。これは、ユーザーに表示された画面画像など、提示されたものに文字通り署名することで実現できることに注意してください。ただし、これにより、後続のソフトウェアが操作するのが困難なデータになる可能性があります。代わりに、プレゼンテーションに影響を与えるフィルター、スタイルシート、クライアントプロファイル、またはその他の情報とともにデータに署名できます。"
    },
    {
      "indent": 0,
      "text": "8.1.3 'See' What is Signed",
      "section_title": true,
      "ja": "8.1.3 署名されているものを「参照」"
    },
    {
      "indent": 3,
      "text": "Just as a user should only sign what he or she \"sees,\" persons and automated mechanism that trust the validity of a transformed document on the basis of a valid signature should operate over the data that was transformed (including canonicalization) and signed, not the original pre-transformed data. This recommendation applies to transforms specified within the signature as well as those included as part of the document itself. For instance, if an XML document includes an embedded style sheet [XSLT] it is the transformed document that should be represented to the user and signed. To meet this recommendation where a document references an external style sheet, the content of that external resource should also be signed via a signature Reference, otherwise the content of that external content might change which alters the resulting document without invalidating the signature.",
      "ja": "ユーザーが自分が「見る」もののみに署名すべきであるのと同様に、有効な署名に基づいて変換されたドキュメントの有効性を信頼する人や自動化されたメカニズムは、元の変換前のデータではなく、変換（正規化を含む）および署名されたデータに対して動作する必要があります。この推奨事項は、署名内で指定された変換と、ドキュメント自体の一部として含まれる変換に適用されます。たとえば、XMLドキュメントに埋め込みスタイルシート[XSLT]が含まれている場合、ユーザーに提示され署名されるべきなのは変換されたドキュメントです。ドキュメントが外部スタイルシートを参照する場合にこの推奨事項を満たすには、その外部リソースのコンテンツも署名Referenceを介して署名する必要があります。そうしないと、その外部コンテンツの内容が変更され、署名を無効にすることなく結果のドキュメントが変更される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some applications might operate over the original or intermediary data but should be extremely careful about potential weaknesses introduced between the original and transformed data. This is a trust decision about the character and meaning of the transforms that an application needs to make with caution. Consider a canonicalization algorithm that normalizes character case (lower to upper) or character composition ('e and accent' to 'accented-e'). An adversary could introduce changes that are normalized and consequently inconsequential to signature validity but material to a DOM processor. For instance, by changing the case of a character one might influence the result of an XPath selection. A serious risk is introduced if that change is normalized for signature validation but the processor operates over the original data and returns a different result than intended.",
      "ja": "一部のアプリケーションは、元のデータまたは中間データに対して動作する場合がありますが、元のデータと変換されたデータの間に導入された潜在的な弱点に非常に注意する必要があります。これは、アプリケーションが注意して行う必要がある変換の性格と意味に関する信頼の決定です。文字の大文字小文字（小文字から大文字へ）または文字合成（「eとアクセント」から「アクセント付きe」へ）を正規化する正規化アルゴリズムを考えてみましょう。攻撃者は、正規化されるため署名の有効性には影響しないが、DOMプロセッサにとっては重要な変更を導入する可能性があります。たとえば、文字の大文字小文字を変更することで、XPath選択の結果に影響を与える可能性があります。その変更が署名検証のために正規化されているが、プロセッサは元のデータで動作し、意図したものとは異なる結果を返す場合、深刻なリスクが導入されます。"
    },
    {
      "indent": 3,
      "text": "As a result:",
      "ja": "結果として："
    },
    {
      "indent": 6,
      "text": "* All documents operated upon and generated by signature applications MUST be in [NFC, NFC-Corrigendum] (otherwise intermediate processors might unintentionally break the signature) * Encoding normalizations SHOULD NOT be done as part of a signature transform, or (to state it another way) if normalization does occur, the application SHOULD always \"see\" (operate over) the normalized form.",
      "ja": "* 署名アプリケーションによって操作および生成されるすべてのドキュメントは、[NFC、NFC-Corrigendum]（そうでない場合、中間プロセッサが意図せず署名を壊す可能性があります）である必要があります。* エンコーディングの正規化は、署名変換の一部として行われるべきではありません（SHOULD NOT）。または（別の言い方をすれば）正規化が発生する場合、アプリケーションは常に正規化された形式を「見る」（操作する）必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "8.2 Check the Security Model",
      "section_title": true,
      "ja": "8.2 セキュリティモデルを確認してください"
    },
    {
      "indent": 3,
      "text": "This specification uses public key signatures and keyed hash authentication codes. These have substantially different security models. Furthermore, it permits user specified algorithms which may have other models.",
      "ja": "この仕様では、公開キーの署名を使用し、キー付きハッシュ認証コードを使用します。これらには、セキュリティモデルが大幅に異なります。さらに、他のモデルを持つ可能性のあるユーザーが指定したアルゴリズムを許可します。"
    },
    {
      "indent": 3,
      "text": "With public key signatures, any number of parties can hold the public key and verify signatures while only the parties with the private key can create signatures. The number of holders of the private key should be minimized and preferably be one. Confidence by verifiers in the public key they are using and its binding to the entity or capabilities represented by the corresponding private key is an important issue, usually addressed by certificate or online authority systems.",
      "ja": "公開キーの署名を使用すると、任意の数の当事者が公開キーを保持し、署名を検証できますが、秘密鍵を持つ当事者のみが署名を作成できます。秘密鍵の所有者の数は最小化され、できれば1つである必要があります。検証者が使用している公開鍵に対する信頼と、対応する秘密鍵によって表されるエンティティまたは機能へのバインディングは重要な問題であり、通常は証明書またはオンライン認証局システムによって対処されます。"
    },
    {
      "indent": 3,
      "text": "Keyed hash authentication codes, based on secret keys, are typically much more efficient in terms of the computational effort required but have the characteristic that all verifiers need to have possession of the same key as the signer. Thus any verifier can forge signatures.",
      "ja": "シークレットキーに基づいたキー付きハッシュ認証コードは、通常、必要な計算作業に関してはるかに効率的ですが、すべての検証者が署名者と同じキーを所有する必要があるという特徴があります。したがって、すべての検証者は署名を偽造できます。"
    },
    {
      "indent": 3,
      "text": "This specification permits user provided signature algorithms and keying information designators. Such user provided algorithms may have different security models. For example, methods involving biometrics usually depend on a physical characteristic of the authorized user that can not be changed the way public or secret keys can be and may have other security model differences.",
      "ja": "この仕様では、ユーザー提供の署名アルゴリズムとキーイング情報指定子が許可されています。このようなユーザー提供されたアルゴリズムには、セキュリティモデルが異なる場合があります。たとえば、生体認証を含む方法は通常、公開鍵や秘密鍵のように変更できない、認可されたユーザーの身体的特徴に依存しており、他のセキュリティモデルの違いがある可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.3 Algorithms, Key Lengths, Certificates, Etc.",
      "ja": "8.3 アルゴリズム、キー長、証明書など。"
    },
    {
      "indent": 3,
      "text": "The strength of a particular signature depends on all links in the security chain. This includes the signature and digest algorithms used, the strength of the key generation [RANDOM] and the size of the key, the security of key and certificate authentication and distribution mechanisms, certificate chain validation policy, protection of cryptographic processing from hostile observation and tampering, etc.",
      "ja": "特定の署名の強さは、セキュリティチェーン内のすべてのリンクに依存します。これには、使用される署名およびダイジェストアルゴリズム、鍵生成の強度[RANDOM]と鍵のサイズ、鍵および証明書の認証および配布メカニズムのセキュリティ、証明書チェーン検証ポリシー、敵対的な観察や改ざんからの暗号化処理の保護などが含まれます。"
    },
    {
      "indent": 3,
      "text": "Care must be exercised by applications in executing the various algorithms that may be specified in an XML signature and in the processing of any \"executable content\" that might be provided to such algorithms as parameters, such as XSLT transforms. The algorithms specified in this document will usually be implemented via a trusted library, but even there perverse parameters might cause unacceptable processing or memory demand. Even more care may be warranted with application defined algorithms.",
      "ja": "XML署名で指定される可能性のあるさまざまなアルゴリズムの実行、およびXSLT変換などのパラメーターとしてそのようなアルゴリズムに提供される可能性のある「実行可能コンテンツ」の処理において、アプリケーションは注意を払う必要があります。このドキュメントで指定されているアルゴリズムは通常、信頼できるライブラリを介して実装されますが、そこでも異常なパラメーターが許容できない処理やメモリの需要を引き起こす可能性があります。アプリケーション定義のアルゴリズムでは、さらに注意が必要です。"
    },
    {
      "indent": 3,
      "text": "The security of an overall system will also depend on the security and integrity of its operating procedures, its personnel, and on the administrative enforcement of those procedures. All the factors listed in this section are important to the overall security of a system; however, most are beyond the scope of this specification.",
      "ja": "システム全体のセキュリティは、その運用手順のセキュリティと整合性、その人員、およびそれらの手順の管理的な施行にも依存します。このセクションにリストされているすべての要因は、システムの全体的なセキュリティにとって重要です。ただし、ほとんどはこの仕様の範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "9. Schema, DTD, Data Model, and Valid Examples",
      "section_title": true,
      "ja": "9. スキーマ、DTD、データモデル、有効な例"
    },
    {
      "indent": 3,
      "text": "XML Signature Schema Instance http://www.w3.org/Signature/Drafts/xmldsig-core/xmldsig-core-schema.xsd Valid XML schema instance based on the 20001024 Schema/DTD [XML-Schema].",
      "ja": "XML Signature Schema Instance http://www.w3.org/signature/drafts/xmldsig-core/xmldsig-core-schema.xsd有効なXMLスキーマインスタンス20001024スキーマ/DTD [XML-Schema]に基づく。"
    },
    {
      "indent": 3,
      "text": "XML Signature DTD http://www.w3.org/Signature/Drafts/xmldsig-core/xmldsig-core-schema.dtd",
      "ja": "XML署名DTD http://www.w3.org/signature/drafts/xmldsig-core/xmldsig-core-schema.dtd"
    },
    {
      "indent": 3,
      "text": "RDF Data Model http://www.w3.org/Signature/Drafts/xmldsig-core/xmldsig-datamodel-20000112.gif",
      "ja": "RDFデータモデルhttp://www.w3.org/signature/drafts/xmldsig-core/xmldsig-datamodel-20012.gif"
    },
    {
      "indent": 3,
      "text": "XML Signature Object Example http://www.w3.org/Signature/Drafts/xmldsig-core/signature-example.xml A cryptographical fabricated XML example that includes foreign content and validates under the schema, it also uses schemaLocation to aid automated schema fetching and validation.",
      "ja": "XML Signature Objectの例http://www.w3.org/signature/drafts/xmldsig-core/signature-example.xmlは、外国のコンテンツを含む暗号化された製造されたXML例です。また、スキーマの下での外国のコンテンツを検証します。フェッチングと検証。"
    },
    {
      "indent": 3,
      "text": "RSA XML Signature Example http://www.w3.org/Signature/Drafts/xmldsig-core/signature-example-rsa.xml An XML Signature example with generated cryptographic values by Merlin Hughes and validated by Gregor Karlinger.",
      "ja": "RSA XML署名の例http://www.w3.org/signature/drafts/xmldsig-core/signature-example-rsa.xml an XML署名例は、Merlin Hughesによって生成された暗号化値を備え、Gregor Karlingerによって検証されました。"
    },
    {
      "indent": 3,
      "text": "DSA XML Signature Example http://www.w3.org/Signature/Drafts/xmldsig-core/signature-example-dsa.xml Similar to above but uses DSA.",
      "ja": "DSA XML署名の例http://www.w3.org/signature/drafts/xmldsig-core/signature-example-dsa.xmlは上記と同様ですが、DSAを使用します。"
    },
    {
      "indent": 0,
      "text": "10. Definitions",
      "section_title": true,
      "ja": "10. 定義"
    },
    {
      "indent": 3,
      "text": "Authentication Code (Protected Checksum) A value generated from the application of a shared key to a message via a cryptographic algorithm such that it has the properties of message authentication (and integrity) but not signer authentication. Equivalent to protected checksum, \"A checksum that is computed for a data object by means that protect against active attacks that would attempt to change the checksum to make it match changes made to the data object.\" [SEC]",
      "ja": "認証コード（保護されたチェックサム） 暗号化アルゴリズムを介してメッセージに共有鍵を適用することから生成された値であり、メッセージ認証（および完全性）のプロパティを持ちますが、署名者認証のプロパティは持ちません。保護されたチェックサムに相当します。「データオブジェクトに加えられた変更と一致するようにチェックサムを変更しようとするアクティブな攻撃から保護する手段によって、データオブジェクトに対して計算されるチェックサム。」[SEC]"
    },
    {
      "indent": 3,
      "text": "Authentication, Message The property, given an authentication code/protected checksum, that tampering with both the data and checksum, so as to introduce changes while seemingly preserving integrity, are still detected. \"A signature should identify what is signed, making it impracticable to falsify or alter either the signed matter or the signature without detection.\" [Digital Signature Guidelines, ABA]. Authentication, Signer The property of the identity of the signer is as claimed. \"A signature should indicate who signed a document, message or record, and should be difficult for another person to produce without authorization.\" [Digital Signature Guidelines, ABA] Note, signer authentication is an application decision (e.g., does the signing key actually correspond to a specific identity) that is supported by, but out of the scope of, this specification. Checksum \"A value that (a) is computed by a function that is dependent on the contents of a data object and (b) is stored or transmitted together with the object, for the purpose of detecting changes in the data.\" [SEC] Core The syntax and processing defined by this specification, including core validation. We use this term to distinguish other markup, processing, and applications semantics from our own. Data Object (Content/Document) The actual binary/octet data being operated on (transformed, digested, or signed) by an application -- frequently an HTTP entity [HTTP]. Note that the proper noun Object designates a specific XML element. Occasionally we refer to a data object as a document or as a resource's content. The term element content is used to describe the data between XML start and end tags [XML]. The term XML document is used to describe data objects which conform to the XML specification [XML]. Integrity \"The property that data has not been changed, destroyed, or lost in an unauthorized or accidental manner.\" [SEC] A simple checksum can provide integrity from incidental changes in the data; message authentication is similar but also protects against an active attack to alter the data whereby a change in the checksum is introduced so as to match the change in the data. Object An XML Signature element wherein arbitrary (non-core) data may be placed. An Object element is merely one type of digital data (or document) that can be signed via a Reference.",
      "ja": "認証、メッセージ 認証コード/保護されたチェックサムが与えられた場合に、完全性を維持しているように見せかけながら変更を導入するためにデータとチェックサムの両方を改ざんしても、依然として検出されるという特性。「署名は署名されたものを識別し、検出されずに署名された事項または署名のいずれかを改ざんまたは変更することを実行不可能にする必要があります。」[デジタル署名ガイドライン、ABA]。認証、署名者 署名者の身元が主張どおりであるという特性。「署名は、誰がドキュメント、メッセージ、または記録に署名したかを示す必要があり、他の人が許可なしに作成することは困難なはずです。」[デジタル署名ガイドライン、ABA]注：署名者認証は、この仕様によってサポートされていますが、範囲外であるアプリケーションの決定（たとえば、署名キーが実際に特定のIDに対応しているかどうか）です。チェックサム 「（a）データオブジェクトの内容に依存する関数によって計算され、（b）データの変更を検出する目的で、オブジェクトとともに保存または送信される値。」[SEC]コア コア検証を含む、この仕様で定義された構文と処理。この用語を使用して、他のマークアップ、処理、およびアプリケーションセマンティクスを独自のものと区別します。データオブジェクト（コンテンツ/ドキュメント） アプリケーションによって操作（変換、ダイジェスト、または署名）されている実際のバイナリ/オクテットデータ - 頻繁にはHTTPエンティティ[HTTP]。固有名詞 Object は、特定のXML要素を指定することに注意してください。時折、データオブジェクトをドキュメントまたはリソースのコンテンツとして参照します。要素コンテンツという用語は、XMLの開始タグと終了タグ[XML]の間のデータを記述するために使用されます。XMLドキュメントという用語は、XML仕様[XML]に準拠するデータオブジェクトを記述するために使用されます。完全性（Integrity）「データが変更されていない、破壊されていない、または不正なまたは偶発的な方法で失われていないという特性。」[SEC]単純なチェックサムは、データの偶発的な変更からの完全性を提供できます。メッセージ認証は類似していますが、データの変更に合わせてチェックサムの変更が導入されるような、データを変更するためのアクティブな攻撃からも保護します。Object 任意の（非コア）データを配置できるXML署名要素。オブジェクト要素は、参照を介して署名できるデジタルデータ（またはドキュメント）の1つにすぎません。"
    },
    {
      "indent": 3,
      "text": "Resource\n   \"A resource can be anything that has identity.  Familiar examples\n   include an electronic document, an image, a service (e.g.,\n   'today's weather report for Los Angeles'), and a collection of\n   other resources....  The resource is the conceptual mapping to an\n   entity or set of entities, not necessarily the entity which\n   corresponds to that mapping at any particular instance in time.\n   Thus, a resource can remain constant even when its content---the\n   entities to which it currently corresponds---changes over time,\n   provided that the conceptual mapping is not changed in the\n   process.\" [URI] In order to avoid a collision of the term entity\n   within the URI and XML specifications, we use the term data\n   object, content or document to refer to the actual bits/octets\n   being operated upon.\nSignature\n   Formally speaking, a value generated from the application of a\n   private key to a message via a cryptographic algorithm such that\n   it has the properties of integrity, message authentication and/or\n   signer authentication.  (However, we sometimes use the term\n   signature generically such that it encompasses Authentication Code\n   values as well, but we are careful to make the distinction when\n   the property of signer authentication is relevant to the\n   exposition.)  A signature may be (non-exclusively) described as\n   detached, enveloping, or enveloped.\nSignature, Application\n   An application that implements the MANDATORY (REQUIRED/MUST)\n   portions of this specification; these conformance requirements are\n   over application behavior, the structure of the Signature element\n   type and its children (including SignatureValue) and the specified\n   algorithms.\nSignature, Detached\n   The signature is over content external to the Signature element,\n   and can be identified via a URI or transform.  Consequently, the\n   signature is \"detached\" from the content it signs.  This\n   definition typically applies to separate data objects, but it also\n   includes the instance where the Signature and data object reside\n   within the same XML document but are sibling elements.\nSignature, Enveloping\n   The signature is over content found within an Object element of\n   the signature itself.  The Object (or its content) is identified\n   via a Reference (via a URI fragment identifier or transform).\nSignature, Enveloped\n   The signature is over the XML content that contains the signature\n   as an element.  The content provides the root XML document\n   element.  Obviously, enveloped signatures must take care not to\n   include their own value in the calculation of the SignatureValue.",
      "raw": true,
      "ja": "リソース 「リソースとは、アイデンティティを持つあらゆるものです。身近な例としては、電子ドキュメント、画像、サービス（例：「ロサンゼルスの今日の天気予報」）、およびその他のリソースのコレクションなどがあります... リソースは、エンティティまたはエンティティのセットへの概念的なマッピングであり、必ずしも特定の時点でそのマッピングに対応するエンティティではありません。したがって、リソースは、そのコンテンツ（現在対応しているエンティティ）が時間の経過とともに変化しても、概念的なマッピングがプロセスで変更されない限り、一定のままでいられます。」[URI] URIおよびXML仕様内での用語「エンティティ」の衝突を避けるために、操作される実際のビット/オクテットを指すために、データオブジェクト、コンテンツ、またはドキュメントという用語を使用します。署名 正式には、整合性、メッセージ認証、および/または署名者認証のプロパティを持つように、暗号化アルゴリズムを介してメッセージに秘密鍵を適用することから生成された値。（ただし、認証コードの値も含むように署名という用語を一般的に使用することもありますが、署名者認証のプロパティが説明に関連する場合は区別するように注意しています。）署名は、（排他的ではなく）Detached、Enveloping、またはEnvelopedとして記述される場合があります。署名、アプリケーション この仕様の必須（REQUIRED/MUST）部分を実装するアプリケーション。これらの適合要件は、アプリケーションの動作、Signature要素タイプとその子（SignatureValueを含む）の構造、および指定されたアルゴリズムに関するものです。署名、Detached 署名はSignature要素の外部のコンテンツに対するものであり、URIまたは変換を介して識別できます。その結果、署名は署名するコンテンツから「分離（detached）」されます。この定義は通常、別々のデータオブジェクトに適用されますが、Signatureとデータオブジェクトが同じXMLドキュメント内に存在するが兄弟要素である場合も含まれます。署名、Enveloping 署名は、署名自体のObject要素内にあるコンテンツに対するものです。Object（またはそのコンテンツ）は、Reference（URIフラグメント識別子または変換を介して）によって識別されます。署名、Enveloped 署名は、署名を要素として含むXMLコンテンツに対するものです。コンテンツはルートXMLドキュメント要素を提供します。明らかに、Enveloped署名は、SignatureValueの計算に自身の値を含めないように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Transform The processing of a data from its source to its derived form. Typical transforms include XML Canonicalization, XPath, and XSLT. Validation, Core The core processing requirements of this specification requiring signature validation and SignedInfo reference validation. Validation, Reference The hash value of the identified and transformed content, specified by Reference, matches its specified DigestValue. Validation, Signature The SignatureValue matches the result of processing SignedInfo with CanonicalizationMethod and SignatureMethod as specified in Core Validation (section 3.2). Validation, Trust/Application The application determines that the semantics associated with a signature are valid. For example, an application may validate the time stamps or the integrity of the signer key -- though this behavior is external to this core specification.",
      "ja": "変換 ソースから派生形式へのデータの処理。典型的な変換には、XML Canonicalization、XPath、およびXSLTが含まれます。検証、コア 署名検証とSignedInfo参照検証を必要とするこの仕様のコア処理要件。検証、参照 Referenceによって指定された、識別および変換されたコンテンツのハッシュ値が、指定されたDigestValueと一致すること。検証、署名 SignatureValueが、コア検証（セクション3.2）で指定されているように、CanonicalizationMethodおよびSignatureMethodを使用してSignedInfoを処理した結果と一致すること。検証、信頼/アプリケーション アプリケーションが、署名に関連付けられたセマンティクスが有効であると判断すること。たとえば、アプリケーションはタイムスタンプまたは署名者キーの完全性を検証する場合がありますが、この動作はこのコア仕様の外部です。"
    },
    {
      "indent": 0,
      "text": "Appendix: Changes from RFC 3075",
      "ja": "付録：RFC 3075からの変更"
    },
    {
      "indent": 3,
      "text": "Numerous minor editorial changes were made. In addition, the following substantive changes have occurred based on interoperation experience or other considerations:",
      "ja": "多数のマイナーな編集の変更が行われました。さらに、次の実質的な変更は、相互操作の経験またはその他の考慮事項に基づいて発生しました。"
    },
    {
      "indent": 3,
      "text": "1. Minor but incompatible changes in the representation of DSA keys. In particular, the optionality of several fields was changed and two fields were re-ordered.",
      "ja": "1. DSAキーの表現におけるマイナーだが互換性のない変化。特に、いくつかのフィールドのオプションが変更され、2つのフィールドが再注文されました。"
    },
    {
      "indent": 3,
      "text": "2. Minor change in the X509Data KeyInfo structure to allow multiple CRLs to be grouped with certificates and other X509 information. Previously CRLs had to occur singly and each in a separate X509Data structure.",
      "ja": "2. X509DATA KeyINFO構造のわずかな変更により、複数のCRLを証明書およびその他のX509情報でグループ化できるようにします。以前はCRLSが単独で発生し、それぞれが別のx509Data構造で発生する必要がありました。"
    },
    {
      "indent": 3,
      "text": "3. Incompatible change in the type of PGPKeyID, which had previously been string, to the more correct base64Binary since it is actually a binary quantity.",
      "ja": "3. 以前はひもだったpgpkeyidのタイプの互換性のない変化は、実際にはバイナリ量であるため、より正しいbase64binaryになりました。"
    },
    {
      "indent": 3,
      "text": "4. Several warnings have been added. Of particular note, because it reflects a problem actually encountered in use and is the only warning added that has its own little section, is the warning of canonicalization problems when the namespace context of signed material changes.",
      "ja": "4. いくつかの警告が追加されました。特に注目に値するのは、実際に使用されている問題を反映しており、独自のセクションを持つ唯一の警告であるため、署名された素材の変更の名前空間コンテキストが標準化された問題の警告です。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "参考文献"
    },
    {
      "indent": 3,
      "text": "[ABA] Digital Signature Guidelines. http://www.abanet.org/scitech/ec/isc/dsgfree.html",
      "ja": "[ABA]デジタル署名ガイドライン。http://www.abanet.org/scitech/ec/isc/dsgfree.html"
    },
    {
      "indent": 3,
      "text": "[DOM] Document Object Model (DOM) Level 1 Specification. W3C Recommendation. V. Apparao, S. Byrne, M. Champion, S. Isaacs, I. Jacobs, A. Le Hors, G. Nicol, J. Robie, R. Sutor, C. Wilson, L. Wood. October 1998. http://www.w3.org/TR/1998/REC-DOM-Level-1- 19981001/",
      "ja": "[DOM]ドキュメントオブジェクトモデル（DOM）レベル1仕様。W3Cの推奨。V.アピアオ、S。バーン、M。チャンピオン、S。アイザック、I。ジェイコブス、A。ルース、G。ニコル、J。ロビー、R。スター、C。ウィルソン、L。ウッド。1998年10月。http://www.w3.org/tr/1998/recdom-level-1-19981001/"
    },
    {
      "indent": 3,
      "text": "[DSS] FIPS PUB 186-2 . Digital Signature Standard (DSS). U.S. Department of Commerce/National Institute of Standards and Technology. http://csrc.nist.gov/publications/fips/fips186- 2/fips186-2.pdf",
      "ja": "[DSS] Fips Pub 186-2。デジタル署名標準（DSS）。米国商務省/国立標準技術研究所。http://csrc.nist.gov/publications/fips/fips186-2/fips186-2.pdf"
    },
    {
      "indent": 3,
      "text": "[HMAC] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[HMAC] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：メッセージ認証のためのキードハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[HTTP] Fielding, R. Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[HTTP] Fielding、R。Gettys、J.、Mogul、J.、Frystyk、H.、Masinter、L.、Leach、P。and T. Berners-Lee、 \"HyperText Transfer Protocol-HTTP/1.1\"、RFC2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[KEYWORDS] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[キーワード] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[LDAP-DN] Wahl, M., Kille, S. and T. Howes, \"Lightweight Directory Access Protocol (v3): UTF-8 String Representation of Distinguished Names\", RFC 2253, December 1997.",
      "ja": "[LDAP-DN] Wahl、M.、Kille、S。、およびT. Howes、「Lightweight Directory Access Protocol（V3）：UTF-8文字列識別名の表現」、RFC 2253、1997年12月。"
    },
    {
      "indent": 3,
      "text": "[MD5] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[MD5] Rivest、R。、「The MD5 Message-Digest Algorithm」、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[MIME] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, November 1996.",
      "ja": "[Mime] Freed、N。and N. Borenstein、「多目的インターネットメールエクステンション（MIME）パート1：インターネットメッセージボディの形式」、RFC 2045、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[NFC] TR15, Unicode Normalization Forms. M. Davis, M. Drst. Revision 18: November 1999. http://www.unicode.org/unicode/reports/tr15/tr15- 18.html. NFC-Corrigendum Normalization Corrigendum. The Unicode Consortium. http://www.unicode.org/unicode/uni2errata/ Normalization_Corrigendum.html.",
      "ja": "[NFC] TR15、ユニコード正規化フォーム。M.デイビス、M。Drst。改訂18：1999年11月。http://www.unicode.org/unicode/reports/tr15/tr15-18.html。NFC-Corrigendum正規化回心。ユニコードコンソーシアム。http://www.unicode.org/unicode/uni2errata/ remarization_corrigendum.html。"
    },
    {
      "indent": 3,
      "text": "[PGP] Callas, J., Donnerhacke, L., Finney, H. and R. Thayer, \"OpenPGP Message Format\", RFC 2440, November 1998.",
      "ja": "[PGP] Callas、J.、Donnerhacke、L.、Finney、H。およびR. Thayer、「OpenPGPメッセージ形式」、RFC 2440、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RANDOM] Eastlake, 3rd, D., Crocker, S. and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[ランダム] Eastlake、3rd、D.、Crocker、S。and J. Schiller、「セキュリティのためのランダム性の推奨」、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RDF] Resource Description Framework (RDF) Schema Specification 1.0. W3C Candidate Recommendation. D. Brickley, R.V. Guha. March 2000. http://www.w3.org/TR/2000/CR-rdf-schema-20000327/ Resource Description Framework (RDF) Model and Syntax Specification. W3C Recommendation. O. Lassila, R. Swick. February 1999. http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/",
      "ja": "[RDF]リソース説明フレームワーク（RDF）スキーマ仕様1.0。W3C候補の推奨。D.ブリックリー、R.V。グハ。2000年3月。http://www.w3.org/tr/2000/cr-rdf-schema-20000327/リソース説明フレームワーク（RDF）モデルと構文仕様。W3Cの推奨。O.ラシラ、R。スウィック。1999年2月。http://www.w3.org/tr/1999/rec-rdf-syntax-19990222/"
    },
    {
      "indent": 3,
      "text": "[1363] IEEE 1363: Standard Specifications for Public Key Cryptography. August 2000.",
      "ja": "[1363] IEEE 1363：公開キー暗号化の標準仕様。2000年8月。"
    },
    {
      "indent": 3,
      "text": "[PKCS1] Kaliski, B. and J. Staddon, \"PKCS #1: RSA Cryptography Specifications Version 2.0\", RFC 2437, October 1998.",
      "ja": "[PKCS1] Kaliski、B。and J. Staddon、「PKCS＃1：RSA暗号化仕様バージョン2.0」、RFC 2437、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[SAX] SAX: The Simple API for XML. D. Megginson, et al. May 1998. http://www.megginson.com/SAX/index.html (THIS PAGE OUT OF DATE; GO TO www.saxproject.org)",
      "ja": "[SAX] SAX：XMLのシンプルなAPI。D. Megginson、et al。1998年5月。http://www.megginson.com/sax/index.html（このページは古くなっています。www.saxproject.orgにアクセスしてください）"
    },
    {
      "indent": 3,
      "text": "[SEC] Shirey, R., \"Internet Security Glossary\", FYI 36, RFC 2828, May 2000.",
      "ja": "[Sec] Shirey、R。、「Internet Security Glossary」、FYI 36、RFC 2828、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[SHA-1] FIPS PUB 180-1. Secure Hash Standard. U.S. Department of Commerce/National Institute of Standards and Technology. http://csrc.nist.gov/publications/fips/fips180- 1/fip180-1.txt",
      "ja": "[Sha-1] Fips Pub 180-1。安全なハッシュ標準。米国商務省/国立標準技術研究所。http://csrc.nist.gov/publications/fips/fips180-1/fip180-1.txt"
    },
    {
      "indent": 3,
      "text": "[SOAP] Simple Object Access Protocol (SOAP) Version 1.1. W3C Note. D. Box, D. Ehnebuske, G. Kakivaya, A. Layman, N. Mendelsohn, H. Frystyk Nielsen, S. Thatte, D. Winer. May 2001. http://www.w3.org/TR/2000/NOTE-SOAP-20000508/",
      "ja": "[SOAP] Simple Object Access Protocol（SOAP）バージョン1.1。W3Cノート。D. Box、D。Ehnebuske、G。Kakivaya、A。Layman、N。Mendelsohn、H。FrystykNielsen、S。Shatte、D。Winer。2001年5月。http://www.w3.org/tr/2000/note-soap-20000508/"
    },
    {
      "indent": 3,
      "text": "[Unicode] The Unicode Consortium. The Unicode Standard. http://www.unicode.org/unicode/standard/ standard.html",
      "ja": "[Unicode] Unicodeコンソーシアム。ユニコード標準。http://www.unicode.org/unicode/standard/ Standard.html"
    },
    {
      "indent": 3,
      "text": "[UTF-16] Hoffman, P. and F. Yergeau, \"UTF-16, an encoding of ISO 10646\", RFC 2781, February 2000.",
      "ja": "[UTF-16] Hoffman、P。およびF. Yergeau、「UTF-16、ISO 10646のエンコーディング」、RFC 2781、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[UTF-8] Yergeau, R., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "ja": "[UTF-8] Yergeau、R。、「UTF-8、ISO 10646の変換形式」、RFC 2279、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[URI] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource Identifiers (URI): Generic Syntax\", RFC 2396, August 1998.",
      "ja": "[URI] Berners-Lee、T.、Fielding、R。and L. Masinter、「ユニフォームリソース識別子（URI）：汎用構文」、RFC 2396、1998年8月。"
    },
    {
      "indent": 3,
      "text": "[URI-Literal] Hinden, R., Carpenter, B. and L. Masinter, \"Format for Literal IPv6 Addresses in URL's\", RFC 2732, December 1999.",
      "ja": "[Uri-Literal] Hinden、R.、Carpenter、B。and L. Masinter、「URLのリテラルIPv6アドレスの形式」、RFC 2732、1999年12月。"
    },
    {
      "indent": 3,
      "text": "[URL] Berners-Lee, T., Masinter, L. and M. McCahill, \"Uniform Resource Locators (URL)\", RFC 1738, December 1994.",
      "ja": "[URL] Berners-Lee、T.、Masinter、L。およびM. McCahill、「Uniform Resource Locators（URL）」、RFC 1738、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[URN] Moats, R., \"URN Syntax\", RFC 2141, May 1997.",
      "ja": "[urn] Moats、R。、「urn構文」、RFC 2141、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[X509v3] ITU-T Recommendation X.509 version 3 (1997). \"Information Technology - Open Systems Interconnection - The Directory Authentication Framework\" ISO/IEC 9594-8:1997.",
      "ja": "[X509V3] ITU-T推奨X.509バージョン3（1997）。「情報技術 - オープンシステムの相互接続 - ディレクトリ認証フレームワーク」ISO/IEC 9594-8：1997。"
    },
    {
      "indent": 3,
      "text": "[XHTML 1.0] XHTML(tm) 1.0: The Extensible Hypertext Markup Language. W3C Recommendation. S. Pemberton, D. Raggett, et al. January 2000. http://www.w3.org/TR/2000/REC-xhtml1-20000126/",
      "ja": "[XHTML 1.0] XHTML（TM）1.0：拡張可能なハイパーテキストマークアップ言語。W3Cの推奨。S.ペンバートン、D。ラゲット、他2000年1月。http://www.w3.org/tr/2000/rec-xhtml1-20000126/"
    },
    {
      "indent": 3,
      "text": "[XLink] XML Linking Language. W3C Recommendation. S. DeRose, E. Maler, D. Orchard. June 2001. http://www.w3.org/TR/2000/REC-xlink-20010627/",
      "ja": "[xlink] xmlリンク言語。W3Cの推奨。S.デロース、E。マラー、D。オーチャード。2001年6月。http://www.w3.org/tr/2000/rec-xlink-20010627/"
    },
    {
      "indent": 3,
      "text": "[XML] Extensible Markup Language (XML) 1.0 (Second Edition). W3C Recommendation. T. Bray, E. Maler, J. Paoli, C. M. Sperberg-McQueen. October 2000. http://www.w3.org/TR/2000/REC-xml-20001006",
      "ja": "[XML]拡張可能なマークアップ言語（XML）1.0（第2版）。W3Cの推奨。T.ブレイ、E。マラー、J。パオリ、C。M。スペルバーグ-mcqueen。2000年10月。http://www.w3.org/tr/2000/rec-xml-20001006"
    },
    {
      "indent": 3,
      "text": "[XML-C14N] Boyer, J., \"Canonical XML Version 1.0\", RFC 3076, March 2001.",
      "ja": "[XML-C14N] Boyer、J。、「Canonical XMLバージョン1.0」、RFC 3076、2001年3月。"
    },
    {
      "indent": 3,
      "text": "[XML-Japanese] XML Japanese Profile. W3C Note. M. Murata April 2000 http://www.w3.org/TR/2000/NOTE-japanese-xml-20000414/",
      "ja": "[XML-Japanese] XML日本のプロファイル。W3Cノート。M.ムラタ2000年4月http://www.w3.org/tr/2000/note-japanese-xml-20000414/"
    },
    {
      "indent": 3,
      "text": "[XML-MT] Whitehead, E. and M. Murata, \"XML Media Types\", RFC 2376, July 1998.",
      "ja": "[XML-MT]ホワイトヘッド、E。およびM.ムラタ、「XMLメディアタイプ」、RFC 2376、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[XML-ns] Namespaces in XML. W3C Recommendation. T. Bray, D. Hollander, A. Layman. January 1999. http://www.w3.org/TR/1999/REC-xml-names-19990114",
      "ja": "[XML-NS] XMLの名前空間。W3Cの推奨。T.ブレイ、D。ホランダー、A。レイマン。1999年1月。http://www.w3.org/tr/1999/rec-xml-names-19990114"
    },
    {
      "indent": 3,
      "text": "[XML-schema] XML Schema Part 1: Structures. W3C Recommendation. D. Beech, M. Maloney, N. Mendelsohn, H. Thompson. May 2001. http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/ XML Schema Part 2: Datatypes W3C Recommendation. P. Biron, A. Malhotra. May 2001. http://www.w3.org/TR/2001/REC-xmlschema-2- 20010502/",
      "ja": "[XML-Schema] XMLスキーマパート1：構造。W3Cの推奨。D.ビーチ、M。マロニー、N。メンデルソーン、H。トンプソン。2001年5月。http://www.w3.org/tr/2001/rec-xmlschema-1-20010502/ xmlスキーマパート2：データ型W3C推奨。P.ビロン、A。マルホトラ。2001年5月。http://www.w3.org/tr/2001/rec-xmlschema-2- 20010502/"
    },
    {
      "indent": 3,
      "text": "[XML-Signature-RD] Reagle, J., \"XML Signature Requirements\", RFC 2807, July 2000.",
      "ja": "[XML-Signature-Rd] Reagle、J。、「XML Signature Recomations」、RFC 2807、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[XPath] XML Path Language (XPath) Version 1.0. W3C Recommendation. J. Clark, S. DeRose. October 1999. http://www.w3.org/TR/1999/REC-xpath-19991116",
      "ja": "[XPath] XMLパス言語（XPath）バージョン1.0。W3Cの推奨。J.クラーク、S。デロース。1999年10月。http://www.w3.org/tr/1999/rec-xpath-19991116"
    },
    {
      "indent": 3,
      "text": "[XPointer] XML Pointer Language (XPointer). W3C Working Draft. S. DeRose, R. Daniel, E. Maler. January 2001. http://www.w3.org/TR/2001/WD-xptr-20010108",
      "ja": "[Xpointer] XMLポインター言語（XPointer）。W3Cワーキングドラフト。S.デロース、R。ダニエル、E。マラー。2001年1月。http://www.w3.org/tr/2001/wd-xptr-20010108"
    },
    {
      "indent": 3,
      "text": "[XSL] Extensible Stylesheet Language (XSL). W3C Proposed Recommendation. S. Adler, A. Berglund, J. Caruso, S. Deach, P. Grosso, E. Gutentag, A. Milowski, S. Parnell, J. Richman, S. Zilles. August 2001. http://www.w3.org/TR/2001/PR-xsl-20010828/",
      "ja": "[XSL]拡張可能なスタイルシート言語（XSL）。W3C提案勧告。S. Adler、A。Berglund、J。Caruso、S。Deach、P。Grosso、E。Gutentag、A。Milowski、S。Parnell、J。Richman、S。Zilles。2001年8月。http://www.w3.org/tr/2001/pr-xsl-20010828/"
    },
    {
      "indent": 3,
      "text": "[XSLT] XSL Transforms (XSLT) Version 1.0. W3C Recommendation. J. Clark. November 1999. http://www.w3.org/TR/1999/REC-xslt-19991116.html",
      "ja": "[XSLT] XSL変換（XSLT）バージョン1.0。W3Cの推奨。J.クラーク。1999年11月。http://www.w3.org/tr/1999/rec-xslt-1991116.html"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Donald E. Eastlake 3rd Motorola, 20 Forbes Boulevard Mansfield, MA 02048 USA",
      "ja": "ドナルドE.イーストレイク第3モトローラ、20フォーブス大通りマンスフィールド、マサチューセッツ州02048 USA"
    },
    {
      "indent": 3,
      "text": "Phone: 1-508-851-8280 EMail: Donald.Eastlake@motorola.com",
      "ja": "電話：1-508-851-8280メール：donald.eastlake@motorola.com"
    },
    {
      "indent": 3,
      "text": "Joseph M. Reagle Jr., W3C Massachusetts Institute of Technology Laboratory for Computer Science NE43-350, 545 Technology Square Cambridge, MA 02139",
      "ja": "Joseph M. Reagle Jr.、W3C Massachusetts Institute of Technology Laboratory for Computer Science NE43-350、545 Technology Square Cambridge、MA 02139"
    },
    {
      "indent": 3,
      "text": "Phone: +1.617.258.7621\nEMail: reagle@w3.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David Solo Citigroup 909 Third Ave, 16th Floor NY, NY 10043 USA",
      "ja": "David Solo Citigroup 909 Third Ave、16階、ニューヨーク州10043 USA"
    },
    {
      "indent": 3,
      "text": "Phone +1-212-559-2900 EMail: dsolo@alum.mit.edu",
      "ja": "電話1-212-559-2900メール：dsolo@alum.mit.edu"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2002 The Internet Society & W3C (MIT, INRIA, Keio), All Rights Reserved.",
      "ja": "Copyright（c）2002 The Internet Society＆W3C（MIT、INRIA、KEIO）、All Rights Reserved。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントと本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}