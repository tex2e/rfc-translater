{
  "title": {
    "text": "RFC 3711 - The Secure Real-time Transport Protocol (SRTP)",
    "ja": "RFC 3711 - 安全なリアルタイムトランスポートプロトコル（SRTP）"
  },
  "number": 3711,
  "created_at": "2021-04-10 09:18:33.120129+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         M. Baugher\nRequest for Comments: 3711                                     D. McGrew\nCategory: Standards Track                            Cisco Systems, Inc.\n                                                              M. Naslund\n                                                              E. Carrara\n                                                              K. Norrman\n                                                       Ericsson Research\n                                                              March 2004",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "The Secure Real-time Transport Protocol (SRTP)",
      "ja": "安全なリアルタイムトランスポートプロトコル（SRTP）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状況については、「Internet Official Protocol Standards」（STD 1）の現在の版を参照してください。このメモの分布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット社会（2004）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, the Real-time Transport Control Protocol (RTCP).",
      "ja": "この文書では、Secure Real-Time Transport Protocol（SRTP）、リアルタイムトランスポートプロトコル（RTP）のプロファイルで、機密性、メッセージ認証、およびRTPトラフィックおよびRTPの制御トラフィックへの保護を提供できます。リアルタイムトランスポート制御プロトコル（RTCP）"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n    1.1.  Notational Conventions . . . . . . . . . . . . . . . . .  3\n2.  Goals and Features . . . . . . . . . . . . . . . . . . . . . .  4\n    2.1.  Features . . . . . . . . . . . . . . . . . . . . . . . .  5\n3.  SRTP Framework . . . . . . . . . . . . . . . . . . . . . . . .  5\n    3.1.  Secure RTP . . . . . . . . . . . . . . . . . . . . . . .  6\n    3.2.  SRTP Cryptographic Contexts. . . . . . . . . . . . . . .  7\n          3.2.1.  Transform-independent parameters . . . . . . . .  8\n          3.2.2.  Transform-dependent parameters . . . . . . . . . 10\n          3.2.3.  Mapping SRTP Packets to Cryptographic Contexts . 10\n    3.3.  SRTP Packet Processing . . . . . . . . . . . . . . . . . 11\n          3.3.1.  Packet Index Determination, and ROC, s_l Update. 13\n          3.3.2.  Replay Protection. . . . . . . . . . . . . . . . 15\n   3.4.  Secure RTCP . . . . . . . . . . . . . . . . . . . . . . . 15",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "4.  Pre-Defined Cryptographic Transforms . . . . . . . . . . . . . 19\n    4.1.  Encryption . . . . . . . . . . . . . . . . . . . . . . . 19\n          4.1.1.  AES in Counter Mode. . . . . . . . . . . . . . . 21\n          4.1.2.  AES in f8-mode . . . . . . . . . . . . . . . . . 22\n          4.1.3.  NULL Cipher. . . . . . . . . . . . . . . . . . . 25\n    4.2.  Message Authentication and Integrity . . . . . . . . . . 25\n          4.2.1.  HMAC-SHA1. . . . . . . . . . . . . . . . . . . . 25\n    4.3.  Key Derivation . . . . . . . . . . . . . . . . . . . . . 26\n          4.3.1.  Key Derivation Algorithm . . . . . . . . . . . . 26\n          4.3.2.  SRTCP Key Derivation . . . . . . . . . . . . . . 28\n          4.3.3.  AES-CM PRF . . . . . . . . . . . . . . . . . . . 28\n5.  Default and mandatory-to-implement Transforms. . . . . . . . . 28\n    5.1.  Encryption: AES-CM and NULL. . . . . . . . . . . . . . . 29\n    5.2.  Message Authentication/Integrity: HMAC-SHA1. . . . . . . 29\n    5.3.  Key Derivation: AES-CM PRF . . . . . . . . . . . . . . . 29\n6.  Adding SRTP Transforms . . . . . . . . . . . . . . . . . . . . 29\n7.  Rationale. . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n    7.1.  Key derivation . . . . . . . . . . . . . . . . . . . . . 30\n    7.2.  Salting key. . . . . . . . . . . . . . . . . . . . . . . 30\n    7.3.  Message Integrity from Universal Hashing . . . . . . . . 31\n    7.4.  Data Origin Authentication Considerations. . . . . . . . 31\n    7.5.  Short and Zero-length Message Authentication . . . . . . 32\n8.  Key Management Considerations. . . . . . . . . . . . . . . . . 33\n    8.1.  Re-keying  . . . . . . . . . . . . . . . . . . . . . . . 34\n          8.1.1.  Use of the <From, To> for re-keying. . . . . . . 34\n    8.2.  Key Management parameters. . . . . . . . . . . . . . . . 35\n9.  Security Considerations. . . . . . . . . . . . . . . . . . . . 37\n    9.1.  SSRC collision and two-time pad. . . . . . . . . . . . . 37\n    9.2.  Key Usage. . . . . . . . . . . . . . . . . . . . . . . . 38\n    9.3.  Confidentiality of the RTP Payload . . . . . . . . . . . 39\n    9.4.  Confidentiality of the RTP Header. . . . . . . . . . . . 40\n    9.5.  Integrity of the RTP payload and header. . . . . . . . . 40\n          9.5.1. Risks of Weak or Null Message Authentication. . . 42\n          9.5.2.  Implicit Header Authentication . . . . . . . . . 43\n10.  Interaction with Forward Error Correction mechanisms. . . . . 43\n11.  Scenarios . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n    11.1. Unicast. . . . . . . . . . . . . . . . . . . . . . . . . 43\n    11.2. Multicast (one sender) . . . . . . . . . . . . . . . . . 44\n    11.3. Re-keying and access control . . . . . . . . . . . . . . 45\n    11.4. Summary of basic scenarios . . . . . . . . . . . . . . . 46\n12. IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 46\n13. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 47\n14. References . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n    14.1. Normative References . . . . . . . . . . . . . . . . . . 47\n    14.2. Informative References . . . . . . . . . . . . . . . . . 48\nAppendix A: Pseudocode for Index Determination . . . . . . . . . . 51\nAppendix B: Test Vectors . . . . . . . . . . . . . . . . . . . . . 51\n    B.1.  AES-f8 Test Vectors. . . . . . . . . . . . . . . . . . . 51",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    B.2.  AES-CM Test Vectors. . . . . . . . . . . . . . . . . . . 52\n    B.3.  Key Derivation Test Vectors. . . . . . . . . . . . . . . 53\nAuthors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 55\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . . 56",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, RTCP (the Real-time Transport Control Protocol) [RFC3350].",
      "ja": "この文書では、Secure Real-Time Transport Protocol（SRTP）、リアルタイムトランスポートプロトコル（RTP）のプロファイルで、機密性、メッセージ認証、およびRTPトラフィックおよびRTPの制御トラフィックへの保護を提供できます。RTCP（リアルタイムトランスポート制御プロトコル）[RFC3350]。"
    },
    {
      "indent": 3,
      "text": "SRTP provides a framework for encryption and message authentication of RTP and RTCP streams (Section 3). SRTP defines a set of default cryptographic transforms (Sections 4 and 5), and it allows new transforms to be introduced in the future (Section 6). With appropriate key management (Sections 7 and 8), SRTP is secure (Sections 9) for unicast and multicast RTP applications (Section 11).",
      "ja": "SRTPは、RTPおよびRTCPストリームの暗号化およびメッセージ認証のためのフレームワークを提供します（セクション3）。SRTPは、デフォルトの暗号変換のセットを定義します（セクション4と5）、新しい変換を将来導入することができます（セクション6）。適切な鍵管理（セクション7と8）では、SRTPはユニキャストとマルチキャストRTPアプリケーションのセキュリティ（セクション9）です（セクション11）。"
    },
    {
      "indent": 3,
      "text": "SRTP can achieve high throughput and low packet expansion. SRTP proves to be a suitable protection for heterogeneous environments (mix of wired and wireless networks). To get such features, default transforms are described, based on an additive stream cipher for encryption, a keyed-hash based function for message authentication, and an \"implicit\" index for sequencing/synchronization based on the RTP sequence number for SRTP and an index number for Secure RTCP (SRTCP).",
      "ja": "SRTPは、高いスループットと低パケット展開を実現できます。SRTPは、異種環境のための適切な保護であることが証明されています（有線ネットワークと無線ネットワークの組み合わせ）。そのような機能を得るために、暗号化のための加法的ストリーム暗号、メッセージ認証のためのキー付きハッシュベース関数、およびSRTPのRTPシーケンス番号に基づく「暗黙的」索引、およびSRTPとインデックスに基づく順序付け/同期のための「暗黙的」索引に基づいて、デフォルトの変換が記述されています。セキュアRTCP（SRTCP）の数。"
    },
    {
      "indent": 0,
      "text": "1.1. Notational Conventions",
      "section_title": true,
      "ja": "1.1. 表記規則"
    },
    {
      "indent": 3,
      "text": "The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119]. The terminology conforms to [RFC2828] with the following exception. For simplicity we use the term \"random\" throughout the document to denote randomly or pseudo-randomly generated values. Large amounts of random bits may be difficult to obtain, and for the security of SRTP, pseudo-randomness is sufficient [RFC1750].",
      "ja": "「必須」、「必須」、「SEQUR」、「しない」、「推奨する」、「推奨」、「5月」、「オプション」、「オプション」、「オプション」、「オプション」、「オプション」、「オプション」、「オプション」[RFC2119]に記載されているように解釈されます。この用語は、次の例外を除いて[RFC2828]に準拠しています。簡単にするために、私たちは文書全体にわたって「ランダム」という用語を使用して、ランダムにまたは疑似ランダムに生成された値を示す。大量のランダムビットを得ることは困難であり、SRTPのセキュリティのために、擬似ランダム性で十分である[RFC1750]。"
    },
    {
      "indent": 3,
      "text": "By convention, the adopted representation is the network byte order, i.e., the left most bit (octet) is the most significant one. By XOR we mean bitwise addition modulo 2 of binary strings, and || denotes concatenation. In other words, if C = A || B, then the most significant bits of C are the bits of A, and the least significant bits of C equal the bits of B. Hexadecimal numbers are prefixed by 0x.",
      "ja": "慣例により、採用された表現はネットワークバイト順、すなわちほとんどのビット（オクテット）が最も重要なものである。XORによるバイナリストリングのビット単位の追加モジュロ2を意味します。"
    },
    {
      "indent": 3,
      "text": "The word \"encryption\" includes also use of the NULL algorithm (which in practice does leave the data in the clear).",
      "ja": "「暗号化」という単語には、ヌルアルゴリズム（実際にはデータをクリアに残している）の使用も含まれます。"
    },
    {
      "indent": 3,
      "text": "With slight abuse of notation, we use the terms \"message authentication\" and \"authentication tag\" as is common practice, even though in some circumstances, e.g., group communication, the service provided is actually only integrity protection and not data origin authentication.",
      "ja": "表記のわずかな乱用で、一般的な方法では一般的な慣習のように「メッセージ認証」と「認証タグ」という用語を使用しています。"
    },
    {
      "indent": 0,
      "text": "2. Goals and Features",
      "section_title": true,
      "ja": "2. 目標と機能"
    },
    {
      "indent": 3,
      "text": "The security goals for SRTP are to ensure:",
      "ja": "SRTPのセキュリティ目標は、次のことを確認することです。"
    },
    {
      "indent": 3,
      "text": "* the confidentiality of the RTP and RTCP payloads, and",
      "ja": "* RTPおよびRTCPペイロードの機密性、および"
    },
    {
      "indent": 3,
      "text": "* the integrity of the entire RTP and RTCP packets, together with protection against replayed packets.",
      "ja": "* RTPパケット全体とRTCPパケット全体の完全性は、再生されたパケットに対する保護とともに。"
    },
    {
      "indent": 3,
      "text": "These security services are optional and independent from each other, except that SRTCP integrity protection is mandatory (malicious or erroneous alteration of RTCP messages could otherwise disrupt the processing of the RTP stream).",
      "ja": "これらのセキュリティサービスはオプションで独立しており、SRTCP Integrity保護は必須であることを除いて、互いに独立しています（RTCPメッセージの悪意のあるまたは誤った変更は、そうでなければRTPストリームの処理を中断することができる）。"
    },
    {
      "indent": 3,
      "text": "Other, functional, goals for the protocol are:",
      "ja": "その他、機能的、プロトコルの目標は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* a framework that permits upgrading with new cryptographic transforms,",
      "ja": "* 新しい暗号変換でアップグレードを許可するフレームワーク。"
    },
    {
      "indent": 3,
      "text": "* low bandwidth cost, i.e., a framework preserving RTP header compression efficiency,",
      "ja": "* 低帯域幅コスト、すなわちRTPヘッダ圧縮効率を維持するフレームワーク"
    },
    {
      "indent": 3,
      "text": "and, asserted by the pre-defined transforms:",
      "ja": "そして、事前定義された変換によってアサートされます。"
    },
    {
      "indent": 3,
      "text": "* a low computational cost,",
      "ja": "* 低い計算コスト"
    },
    {
      "indent": 3,
      "text": "* a small footprint (i.e., small code size and data memory for keying information and replay lists),",
      "ja": "* 小さなフットプリント（すなわち、キー情報および再生リストのための小さいコードサイズおよびデータメモリ）"
    },
    {
      "indent": 3,
      "text": "* limited packet expansion to support the bandwidth economy goal,",
      "ja": "* 帯域幅経済の目標をサポートするための制限されたパケット拡張"
    },
    {
      "indent": 3,
      "text": "* independence from the underlying transport, network, and physical layers used by RTP, in particular high tolerance to packet loss and re-ordering.",
      "ja": "* RTPによって使用される基礎となる輸送、ネットワーク、および物理層からの独立性、特にパケット損失および並べ替えに対する高い許容範囲。"
    },
    {
      "indent": 3,
      "text": "These properties ensure that SRTP is a suitable protection scheme for RTP/RTCP in both wired and wireless scenarios.",
      "ja": "これらのプロパティは、SRTPが有線および無線のシナリオの両方でRTP / RTCPの適切な保護方式であることを確認してください。"
    },
    {
      "indent": 0,
      "text": "2.1. Features",
      "section_title": true,
      "ja": "2.1. 特徴"
    },
    {
      "indent": 3,
      "text": "Besides the above mentioned direct goals, SRTP provides for some additional features. They have been introduced to lighten the burden on key management and to further increase security. They include:",
      "ja": "上記の直接目標の他に、SRTPはいくつかの追加機能を提供します。彼らは主要管理の負担を軽減し、さらにセキュリティを高めるために導入されました。それらは以下を含みます："
    },
    {
      "indent": 3,
      "text": "* A single \"master key\" can provide keying material for confidentiality and integrity protection, both for the SRTP stream and the corresponding SRTCP stream. This is achieved with a key derivation function (see Section 4.3), providing \"session keys\" for the respective security primitive, securely derived from the master key.",
      "ja": "* 単一の「マスターキー」は、SRTPストリームと対応するSRTCPストリームの両方で、機密性と完全性保護のためのキー化材料を提供することができます。これは重要な派生機能（セクション4.3を参照）で達成され、それぞれのセキュリティプリミティブの「セッションキー」を、マスターキーから安全に派生させます。"
    },
    {
      "indent": 3,
      "text": "* In addition, the key derivation can be configured to periodically refresh the session keys, which limits the amount of ciphertext produced by a fixed key, available for an adversary to cryptanalyze.",
      "ja": "* さらに、キーの導出は、セッションキーを定期的に更新するように設定できます。これにより、固定キーによって生成された暗号文の量がCryptanalyzeに逆行するために利用可能です。"
    },
    {
      "indent": 3,
      "text": "* \"Salting keys\" are used to protect against pre-computation and time-memory tradeoff attacks [MF00] [BS00].",
      "ja": "* 「塩漬けキー」は、事前計算およびタイムメモリトレードオフ攻撃[MF00] [BS00]から保護するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Detailed rationale for these features can be found in Section 7.",
      "ja": "これらの機能の詳細な理論的根拠はセクション7にあります。"
    },
    {
      "indent": 0,
      "text": "3. SRTP Framework",
      "section_title": true,
      "ja": "3. SRTPフレームワーク"
    },
    {
      "indent": 3,
      "text": "RTP is the Real-time Transport Protocol [RFC3550]. We define SRTP as a profile of RTP. This profile is an extension to the RTP Audio/Video Profile [RFC3551]. Except where explicitly noted, all aspects of that profile apply, with the addition of the SRTP security features. Conceptually, we consider SRTP to be a \"bump in the stack\" implementation which resides between the RTP application and the transport layer. SRTP intercepts RTP packets and then forwards an equivalent SRTP packet on the sending side, and intercepts SRTP packets and passes an equivalent RTP packet up the stack on the receiving side.",
      "ja": "RTPはリアルタイムトランスポートプロトコル[RFC3550]です。SRTPをRTPのプロファイルとして定義します。このプロファイルは、RTPオーディオ/ビデオプロファイル[RFC3551]の拡張です。明示的に注目されている場合を除き、そのプロファイルのすべての側面が適用されます.SRTPセキュリティ機能を追加します。概念的には、SRTPは、RTPアプリケーションとトランスポート層との間に存在する「スタック内のバンプ」実装であると考えています。SRTPはRTPパケットをインターセプトしてから、送信側で同等のSRTPパケットを転送し、SRTPパケットをインターセプトして受信側のスタックの上に同等のRTPパケットを渡します。"
    },
    {
      "indent": 3,
      "text": "Secure RTCP (SRTCP) provides the same security services to RTCP as SRTP does to RTP. SRTCP message authentication is MANDATORY and thereby protects the RTCP fields to keep track of membership, provide feedback to RTP senders, or maintain packet sequence counters. SRTCP is described in Section 3.4.",
      "ja": "Secure RTCP（SRTCP）は、SRTPがRTPにするため、RTCPに同じセキュリティサービスを提供します。SRTCPメッセージ認証は必須であり、それによってRTCPフィールドを保護してメンバーシップを追跡し、RTP送信者にフィードバックを提供する、またはパケットシーケンスカウンタを維持します。SRTCPについてはセクション3.4に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.1. Secure RTP",
      "section_title": true,
      "ja": "3.1. 安全なRTP"
    },
    {
      "indent": 6,
      "text": "The format of an SRTP packet is illustrated in Figure 1.",
      "ja": "SRTPパケットのフォーマットを図1に示します。"
    },
    {
      "indent": 3,
      "text": "     0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n  |V=2|P|X|  CC   |M|     PT      |       sequence number         | |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n  |                           timestamp                           | |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n  |           synchronization source (SSRC) identifier            | |\n  +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n  |            contributing source (CSRC) identifiers             | |\n  |                               ....                            | |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n  |                   RTP extension (OPTIONAL)                    | |\n+>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| |                          payload  ...                         | |\n| |                               +-------------------------------+ |\n| |                               | RTP padding   | RTP pad count | |\n+>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n| ~                     SRTP MKI (OPTIONAL)                       ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| :                 authentication tag (RECOMMENDED)              : |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n|                                                                   |\n+- Encrypted Portion*                      Authenticated Portion ---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 1. The format of an SRTP packet. *Encrypted Portion is the same size as the plaintext for the Section 4 pre-defined transforms.",
      "ja": "図1. SRTPパケットのフォーマット。*暗号化部分は、セクション4の事前定義の変換のための平文と同じサイズです。"
    },
    {
      "indent": 3,
      "text": "The \"Encrypted Portion\" of an SRTP packet consists of the encryption of the RTP payload (including RTP padding when present) of the equivalent RTP packet. The Encrypted Portion MAY be the exact size of the plaintext or MAY be larger. Figure 1 shows the RTP payload including any possible padding for RTP [RFC3550].",
      "ja": "SRTPパケットの「暗号化部分」は、等価RTPパケットのRTPペイロードの暗号化（存在する場合はRTPパディングを含む）からなる。暗号化部分は平文の正確なサイズでも大きくてもよい。図1は、RTPの可能なパディングを含むRTPペイロード[RFC3550]を示しています。"
    },
    {
      "indent": 0,
      "text": " None of the pre-defined encryption transforms uses any padding; for these, the RTP and SRTP payload sizes match exactly. New transforms added to SRTP (following Section 6) may require padding, and may hence produce larger payloads. RTP provides its own padding format (as seen in Fig. 1), which due to the padding indicator in the RTP header has merits in terms of compactness relative to paddings using prefix-free codes. This RTP padding SHALL be the default method for transforms requiring padding. Transforms MAY specify other padding methods, and MUST then specify the amount, format, and processing of their padding. It is important to note that encryption transforms that use padding are vulnerable to subtle attacks, especially when message authentication is not used [V02]. Each specification for a new encryption transform needs to carefully consider and describe the security implications of the padding that it uses. Message authentication codes define their own padding, so this default does not apply to authentication transforms.",
      "ja": "事前定義された暗号化変換のどれもパディングを使用しません。これらのために、RTPおよびSRTPペイロードサイズは正確に一致します。 SRTPに追加された新しい変換（後続セクション6）はパディングを必要とし、したがってより大きなペイロードを生成することができる。 RTPは（図1に見られるように）独自のパディングフォーマットを提供します。これは、RTPヘッダー内のパディングインジケータのために、プレフィックスフリーコードを使用したパディングに対してコンパクトさに関してメリットを持っています。このRTPパディングは、パディングを必要とする変換のデフォルトの方法です。変換は他のパディングメソッドを指定し、そのパディングの量、フォーマット、および処理を指定する必要があります。特にメッセージ認証が使用されていない場合、パディングを使用する暗号化変換は微妙な攻撃に対して脆弱であることに注意することが重要です。[V02]。新しい暗号化変換の各指定は、それが使用するパディングのセキュリティの意味を慎重に検討し、記述する必要があります。メッセージ認証コードは独自のパディングを定義するため、このデフォルトは認証変換には適用されません。"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL MKI and the RECOMMENDED authentication tag are the only fields defined by SRTP that are not in RTP. Only 8-bit alignment is assumed.",
      "ja": "オプションのMKIと推奨認証タグは、RTPにはないSRTPによって定義されている唯一のフィールドです。8ビットの位置合わせのみが想定されています。"
    },
    {
      "indent": 6,
      "text": "MKI (Master Key Identifier): configurable length, OPTIONAL. The MKI is defined, signaled, and used by key management. The MKI identifies the master key from which the session key(s) were derived that authenticate and/or encrypt the particular packet. Note that the MKI SHALL NOT identify the SRTP cryptographic context, which is identified according to Section 3.2.3. The MKI MAY be used by key management for the purposes of re-keying, identifying a particular master key within the cryptographic context (Section 3.2.1).",
      "ja": "MKI（マスターキー識別子）：設定可能な長さ、オプション。MKIは、キー管理によって定義され、シグナリングされ、使用されます。MKIは、特定のパケットを認証および/または暗号化するセッションキーが導出されたマスターキーを識別します。MKIはSRTP暗号化コンテキストを識別してはならず、セクション3.2.3に従って識別されます。MKIは、暗号化されたコンテキスト内の特定のマスターキーを識別し、キーイングの目的のために鍵管理によって使用されてもよい（セクション3.2.1）。"
    },
    {
      "indent": 6,
      "text": "Authentication tag: configurable length, RECOMMENDED. The authentication tag is used to carry message authentication data. The Authenticated Portion of an SRTP packet consists of the RTP header followed by the Encrypted Portion of the SRTP packet. Thus, if both encryption and authentication are applied, encryption SHALL be applied before authentication on the sender side and conversely on the receiver side. The authentication tag provides authentication of the RTP header and payload, and it indirectly provides replay protection by authenticating the sequence number. Note that the MKI is not integrity protected as this does not provide any extra protection.",
      "ja": "認証タグ：設定可能な長さ、推奨。認証タグはメッセージ認証データを搬送するために使用されます。SRTPパケットの認証された部分は、RTPヘッダとそれに続くSRTPパケットの暗号化部分からなる。したがって、暗号化と認証の両方が適用されている場合は、送信者側で認証前に、逆に受信側での認証前に暗号化を適用する。認証タグは、RTPヘッダーとペイロードの認証を提供し、シーケンス番号を認証することによって再生保護を間接的に提供します。これは特別な保護を提供しないので、MKIは完全性が保護されていないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2. SRTP Cryptographic Contexts",
      "section_title": true,
      "ja": "3.2. SRTP暗号化コンテキスト"
    },
    {
      "indent": 3,
      "text": "Each SRTP stream requires the sender and receiver to maintain cryptographic state information. This information is called the \"cryptographic context\".",
      "ja": "各SRTPストリームは、暗号状態情報を維持するために送信者および受信者を必要とする。この情報は「暗号的コンテキスト」と呼ばれます。"
    },
    {
      "indent": 0,
      "text": " SRTP uses two types of keys: session keys and master keys. By a \"session key\", we mean a key which is used directly in a cryptographic transform (e.g., encryption or message authentication), and by a \"master key\", we mean a random bit string (given by the key management protocol) from which session keys are derived in a cryptographically secure way. The master key(s) and other parameters in the cryptographic context are provided by key management mechanisms external to SRTP, see Section 8.",
      "ja": "SRTPは、セッションキーとマスターキーの2種類のキーを使用します。「セッションキー」とは、暗号変換（例えば、暗号化またはメッセージ認証）で直接使用されるキー、および「マスターキー」によって、ランダムビット文字列を意味する（鍵管理プロトコルによって与えられる）。どのセッションキーから暗号的に安全な方法で導き出されます。暗号化コンテキスト内のマスターキーおよび他のパラメータは、SRTPの外部の鍵管理メカニズムによって提供される、セクション8を参照されたい。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Transform-independent parameters",
      "section_title": true,
      "ja": "3.2.1. 変換に依存しないパラメータ"
    },
    {
      "indent": 3,
      "text": "Transform-independent parameters are present in the cryptographic context independently of the particular encryption or authentication transforms that are used. The transform-independent parameters of the cryptographic context for SRTP consist of:",
      "ja": "変換に依存しないパラメータは、使用される特定の暗号化または認証変換とは無関係に暗号化されたコンテキストに存在します。SRTPの暗号化コンテキストの変換に依存しないパラメータは次のもので構成されています。"
    },
    {
      "indent": 3,
      "text": "* a 32-bit unsigned rollover counter (ROC), which records how many times the 16-bit RTP sequence number has been reset to zero after passing through 65,535. Unlike the sequence number (SEQ), which SRTP extracts from the RTP packet header, the ROC is maintained by SRTP as described in Section 3.3.1.",
      "ja": "* 32ビットの符号なしロールオーバーカウンタ（ROC）。これは、65,535を通過した後に16ビットRTPシーケンス番号がゼロにリセットされた回数を記録します。SRTPがRTPパケットヘッダーから抽出されているシーケンス番号（seq）とは異なり、ROCはセクション3.3.1で説明されているようにSRTPによって維持されます。"
    },
    {
      "indent": 6,
      "text": "We define the index of the SRTP packet corresponding to a given ROC and RTP sequence number to be the 48-bit quantity",
      "ja": "特定のROCおよびRTPシーケンス番号に対応するSRTPパケットのインデックスを48ビット数量に定義します。"
    },
    {
      "indent": 12,
      "text": "i = 2^16 * ROC + SEQ.",
      "ja": "I = 2 ^ 16 * ROC SEQ。"
    },
    {
      "indent": 3,
      "text": "* for the receiver only, a 16-bit sequence number s_l, which can be thought of as the highest received RTP sequence number (see Section 3.3.1 for its handling), which SHOULD be authenticated since message authentication is RECOMMENDED,",
      "ja": "* 受信機のみの場合は、メッセージ認証が推奨されて以降、受信したRTPシーケンス番号と考えることができる16ビットのシーケンス番号S_L（その処理のセクション3.3.1を参照）を参照してください。"
    },
    {
      "indent": 3,
      "text": "* an identifier for the encryption algorithm, i.e., the cipher and its mode of operation,",
      "ja": "* 暗号化アルゴリズム、すなわち暗号およびその動作モードの識別子、"
    },
    {
      "indent": 3,
      "text": "* an identifier for the message authentication algorithm,",
      "ja": "* メッセージ認証アルゴリズムの識別子"
    },
    {
      "indent": 3,
      "text": "* a replay list, maintained by the receiver only (when authentication and replay protection are provided), containing indices of recently received and authenticated SRTP packets,",
      "ja": "* 受信者によってのみ維持された（認証および再生保護が提供されている場合）、最近受信および認証されたSRTPパケットのインデックスを含む再生リスト。"
    },
    {
      "indent": 3,
      "text": "* an MKI indicator (0/1) as to whether an MKI is present in SRTP and SRTCP packets,",
      "ja": "* MKIがSRTPおよびSRTCPパケットに存在するかどうかについてのMKIインジケータ（0/1）"
    },
    {
      "indent": 3,
      "text": "* if the MKI indicator is set to one, the length (in octets) of the MKI field, and (for the sender) the actual value of the currently active MKI (the value of the MKI indicator and length MUST be kept fixed for the lifetime of the context),",
      "ja": "* MKIインジケータが1に設定されている場合、MKIフィールドの長さ（オクテット内）、および（送信者の場合）現在アクティブなMKIの実際の値（MKIインジケータと長さの値は、生涯に固定されている必要があります。コンテキストの"
    },
    {
      "indent": 3,
      "text": "* the master key(s), which MUST be random and kept secret,",
      "ja": "* マスターキー（S）は、ランダムで秘密になっている必要があります。"
    },
    {
      "indent": 3,
      "text": "* for each master key, there is a counter of the number of SRTP packets that have been processed (sent) with that master key (essential for security, see Sections 3.3.1 and 9),",
      "ja": "* マスターキーごとに、そのマスターキーで処理された（送信された）SRTPパケットの数のカウンタがあります（セキュリティに不可欠なセクション3.3.1および9を参照）。"
    },
    {
      "indent": 3,
      "text": "* non-negative integers n_e, and n_a, determining the length of the session keys for encryption, and message authentication.",
      "ja": "* 非負の整数n_e、およびn_a、暗号化のためのセッションキーの長さ、およびメッセージ認証を決定します。"
    },
    {
      "indent": 3,
      "text": "In addition, for each master key, an SRTP stream MAY use the following associated values:",
      "ja": "さらに、各マスターキーについて、SRTPストリームは以下の関連する値を使用することがあります。"
    },
    {
      "indent": 3,
      "text": "* a master salt, to be used in the key derivation of session keys. This value, when used, MUST be random, but MAY be public. Use of master salt is strongly RECOMMENDED, see Section 9.2. A \"NULL\" salt is treated as 00...0.",
      "ja": "* セッションキーの鍵導出に使用されるマスターソルト。使用されている場合は、この値はランダムでなければなりませんが、公開されている可能性があります。マスターソルトの使用が強くお勧めします.9.2節を参照してください。「ヌル」塩は00 ... 0として扱われます。"
    },
    {
      "indent": 3,
      "text": "* an integer in the set {1,2,4,...,2^24}, the \"key_derivation_rate\", where an unspecified value is treated as zero. The constraint to be a power of 2 simplifies the session-key derivation implementation, see Section 4.3.",
      "ja": "* SET {1,2,4、...、2 ^ 24}の整数、指定されていない値はゼロとして扱われます。2の電源であることの制約はセッションキー導出実装を簡素化します。セクション4.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "* an MKI value,",
      "ja": "* MKI値、"
    },
    {
      "indent": 3,
      "text": "* <From, To> values, specifying the lifetime for a master key, expressed in terms of the two 48-bit index values inside whose range (including the range end-points) the master key is valid. For the use of <From, To>, see Section 8.1.1. <From, To> is an alternative to the MKI and assumes that a master key is in one-to-one correspondence with the SRTP session key on which the <From, To> range is defined.",
      "ja": "* <From、to>値は、マスターキーの2つの48ビットのインデックス値で表されるマスターキーの有効期間を指定します（範囲終了点を含む）。<from、to>を使用するには、セクション8.1.1を参照してください。<from、to>はMKIの代わりになり、<FROMALキーと>範囲が定義されているSRTPセッションキーとの一対一の対応であると仮定します。"
    },
    {
      "indent": 3,
      "text": "SRTCP SHALL by default share the crypto context with SRTP, except:",
      "ja": "SRTCPはデフォルトでSRTPを使用してCrypoコンテキストを共有します。"
    },
    {
      "indent": 3,
      "text": "* no rollover counter and s_l-value need to be maintained as the RTCP index is explicitly carried in each SRTCP packet,",
      "ja": "* RTCPインデックスが各SRTCPパケットで明示的に搬送されるため、ロールオーバーカウンタとS_L値を維持する必要はありません。"
    },
    {
      "indent": 3,
      "text": "* a separate replay list is maintained (when replay protection is provided),",
      "ja": "* 別の再生リストが維持されます（再生保護が提供されている場合）、"
    },
    {
      "indent": 3,
      "text": "* SRTCP maintains a separate counter for its master key (even if the master key is the same as that for SRTP, see below), as a means to maintain a count of the number of SRTCP packets that have been processed with that key.",
      "ja": "* SRTCPは、そのマスターキーに個別のカウンタを維持します（マスターキーがSRTPの場合でも、下記参照）、そのキーで処理されたSRTCPパケットの数の数をカウントする手段として。"
    },
    {
      "indent": 3,
      "text": "Note in particular that the master key(s) MAY be shared between SRTP and the corresponding SRTCP, if the pre-defined transforms (including the key derivation) are used but the session key(s) MUST NOT be so shared.",
      "ja": "特に、事前定義された変換（鍵導出を含む）が使用されているがセッションキーをそれほど共有してはならない場合、マスターキーがSRTPと対応するSRTCPとの間で共有され得ることに注意してください。"
    },
    {
      "indent": 3,
      "text": "In addition, there can be cases (see Sections 8 and 9.1) where several SRTP streams within a given RTP session, identified by their synchronization source (SSRCs, which is part of the RTP header), share most of the crypto context parameters (including possibly master and session keys). In such cases, just as in the normal SRTP/SRTCP parameter sharing above, separate replay lists and packet counters for each stream (SSRC) MUST still be maintained. Also, separate SRTP indices MUST then be maintained.",
      "ja": "さらに、特定のRTPセッション内のいくつかのSRTPストリームが、それらの同期ソース（RTPヘッダーの一部であるSSRC）で識別されるいくつかのSRTPストリームがある場合（セクション8および9.1を参照）、ほとんどの暗号コンテキストパラメータを共有します（おそらくマスターキーとセッションキー）。そのような場合、上記の通常のSRTP / SRTCPパラメータ共有と同様に、各ストリーム（SSRC）の別々の再生リストとパケットカウンタを維持する必要があります。また、別々のSRTPインデックスを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "A summary of parameters, pre-defined transforms, and default values for the above parameters (and other SRTP parameters) can be found in Sections 5 and 8.2.",
      "ja": "上記のパラメータ（および他のSRTPパラメータ）のパラメータ、事前定義変換、およびデフォルト値の概要は、セクション5および8.2にあります。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Transform-dependent parameters",
      "section_title": true,
      "ja": "3.2.2. 変換依存パラメータ"
    },
    {
      "indent": 3,
      "text": "All encryption, authentication/integrity, and key derivation parameters are defined in the transforms section (Section 4). Typical examples of such parameters are block size of ciphers, session keys, data for the Initialization Vector (IV) formation, etc. Future SRTP transform specifications MUST include a section to list the additional cryptographic context's parameters for that transform, if any.",
      "ja": "すべての暗号化、認証/整合性、およびキー導出パラメータは、変換セクションで定義されています（セクション4）。そのようなパラメータの典型的な例は、暗号化キーのブロックサイズ、セッションキー、初期化ベクトル（IV）形成のためのデータなどである。将来のSRTP変換仕様は、あればその変換のための追加の暗号化コンテキストのパラメータをリストするためのセクションを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Mapping SRTP Packets to Cryptographic Contexts",
      "section_title": true,
      "ja": "3.2.3. SRTPパケットを暗号化コンテキストにマッピングする"
    },
    {
      "indent": 3,
      "text": "Recall that an RTP session for each participant is defined [RFC3550] by a pair of destination transport addresses (one network address plus a port pair for RTP and RTCP), and that a multimedia session is defined as a collection of RTP sessions. For example, a particular multimedia session could include an audio RTP session, a video RTP session, and a text RTP session.",
      "ja": "各参加者のRTPセッションは、一対の宛先トランスポートアドレス（1つのネットワークアドレスとRTPおよびRTCPのポートペア）によって定義されていること、およびマルチメディアセッションがRTPセッションのコレクションとして定義されていることを思い出してください。例えば、特定のマルチメディアセッションは、オーディオRTPセッション、ビデオRTPセッション、およびテキストRTPセッションを含み得る。"
    },
    {
      "indent": 3,
      "text": "A cryptographic context SHALL be uniquely identified by the triplet context identifier:",
      "ja": "暗号文脈は、トリプレットのコンテキスト識別子によって一意に識別されなければならない。"
    },
    {
      "indent": 3,
      "text": "context id = <SSRC, destination network address, destination\ntransport port number>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where the destination network address and the destination transport port are the ones in the SRTP packet. It is assumed that, when presented with this information, the key management returns a context with the information as described in Section 3.2.",
      "ja": "宛先ネットワークアドレスと宛先トランスポートポートとがSRTPパケット内のものである場合。この情報を提示すると、鍵管理はセクション3.2で説明されているように情報を含むコンテキストを返すと仮定する。"
    },
    {
      "indent": 0,
      "text": " As noted above, SRTP and SRTCP by default share the bulk of the parameters in the cryptographic context. Thus, retrieving the crypto context parameters for an SRTCP stream in practice may imply a binding to the correspondent SRTP crypto context. It is up to the implementation to assure such binding, since the RTCP port may not be directly deducible from the RTP port only. Alternatively, the key management may choose to provide separate SRTP- and SRTCP- contexts, duplicating the common parameters (such as master key(s)). The latter approach then also enables SRTP and SRTCP to use, e.g., distinct transforms, if so desired. Similar considerations arise when multiple SRTP streams, forming part of one single RTP session, share keys and other parameters.",
      "ja": "上記のように、SRTPおよびSRTCPはデフォルトでは暗号化コンテキスト内のパラメータの大部分を共有します。したがって、実際にはSRTCPストリームの暗号コンテキストパラメータを検索することは、対応するSRTP暗号コンテキストへのバインディングを意味するかもしれない。RTCPポートはRTPポートからのみ直接損尽のない場合があるため、このようなバインディングを保証するのは実装次第です。あるいは、鍵管理は、個別のSRTP-およびSRTCPコンテキストを提供し、共通パラメータ（マスターキーなど）を複製することを選択することができる。次に、後者のアプローチはまた、SRTPおよびSRTCPが所望であれば、例えば明確な変換を使用することを可能にする。複数のSRTPストリーム、1つのRTPセッションの一部を形成すると、同様の考慮事項が発生し、1つのRTPセッション、共有キー、およびその他のパラメータを形成します。"
    },
    {
      "indent": 3,
      "text": "If no valid context can be found for a packet corresponding to a certain context identifier, that packet MUST be discarded.",
      "ja": "特定のコンテキスト識別子に対応するパケットに対して有効なコンテキストが見つからない場合、そのパケットは破棄されなければならない。"
    },
    {
      "indent": 0,
      "text": "3.3. SRTP Packet Processing",
      "section_title": true,
      "ja": "3.3. SRTPパケット処理"
    },
    {
      "indent": 3,
      "text": "The following applies to SRTP. SRTCP is described in Section 3.4.",
      "ja": "以下はSRTPに適用されます。SRTCPについてはセクション3.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "Assuming initialization of the cryptographic context(s) has taken place via key management, the sender SHALL do the following to construct an SRTP packet:",
      "ja": "暗号化文脈の初期化を想定して鍵管理を介して行われたと仮定して、送信者は次のことを行い、SRTPパケットを構築します。"
    },
    {
      "indent": 3,
      "text": "1. Determine which cryptographic context to use as described in Section 3.2.3.",
      "ja": "1. セクション3.2.3で説明されているように使用する暗号化コンテキストを決定します。"
    },
    {
      "indent": 3,
      "text": "2. Determine the index of the SRTP packet using the rollover counter, the highest sequence number in the cryptographic context, and the sequence number in the RTP packet, as described in Section 3.3.1.",
      "ja": "2. 3.3.1項で説明したように、ロールオーバーカウンタ、暗号化コンテキスト内の最も高いシーケンス番号、およびRTPパケット内のシーケンス番号を使用してSRTPパケットのインデックスを決定します。"
    },
    {
      "indent": 3,
      "text": "3. Determine the master key and master salt. This is done using the index determined in the previous step or the current MKI in the cryptographic context, according to Section 8.1.",
      "ja": "3. マスターキーとマスターソルトを決定します。これは、セクション8.1に従って、暗号化コンテキスト内の前のステップまたは現在のMKIで決定されたインデックスを使用して行われる。"
    },
    {
      "indent": 3,
      "text": "4. Determine the session keys and session salt (if they are used by the transform) as described in Section 4.3, using master key, master salt, key_derivation_rate, and session key-lengths in the cryptographic context with the index, determined in Steps 2 and 3.",
      "ja": "4. セクション4.3で説明されているセッションキーとセッションSALT（変換によって使用されている場合）を決定します。。"
    },
    {
      "indent": 3,
      "text": "5. Encrypt the RTP payload to produce the Encrypted Portion of the packet (see Section 4.1, for the defined ciphers). This step uses the encryption algorithm indicated in the cryptographic context, the session encryption key and the session salt (if used) found in Step 4 together with the index found in Step 2.",
      "ja": "5. RTPペイロードを暗号化して、パケットの暗号化部分を作成します（定義済み暗号化のセクション4.1を参照）。このステップでは、ステップ2で見つかったインデックスとともに、暗号化コンテキスト、セッション暗号化キー、およびセッション塩（使用されている場合）に示されている暗号化アルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "6. If the MKI indicator is set to one, append the MKI to the packet.",
      "ja": "6. MKIインジケータが1に設定されている場合は、MKIをパケットに追加します。"
    },
    {
      "indent": 0,
      "text": " 7. For message authentication, compute the authentication tag for the Authenticated Portion of the packet, as described in Section 4.2. This step uses the current rollover counter, the authentication algorithm indicated in the cryptographic context, and the session authentication key found in Step 4. Append the authentication tag to the packet.",
      "ja": "7.メッセージ認証の場合は、セクション4.2で説明されているように、パケットの認証部分の認証タグを計算します。このステップでは、現在のロールオーバーカウンタ、暗号化コンテキストに示されている認証アルゴリズム、および手順4で見つかったセッション認証キーを使用します。認証タグをパケットに追加します。"
    },
    {
      "indent": 3,
      "text": "8. If necessary, update the ROC as in Section 3.3.1, using the packet index determined in Step 2.",
      "ja": "8. 必要に応じて、ステップ2で決定されたパケットインデックスを使用して、セクション3.3.1のようにROCを更新してください。"
    },
    {
      "indent": 3,
      "text": "To authenticate and decrypt an SRTP packet, the receiver SHALL do the following:",
      "ja": "SRTPパケットを認証し復号化するために、受信者は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Determine which cryptographic context to use as described in Section 3.2.3.",
      "ja": "1. セクション3.2.3で説明されているように使用する暗号化コンテキストを決定します。"
    },
    {
      "indent": 3,
      "text": "2. Run the algorithm in Section 3.3.1 to get the index of the SRTP packet. The algorithm uses the rollover counter and highest sequence number in the cryptographic context with the sequence number in the SRTP packet, as described in Section 3.3.1.",
      "ja": "2. SRTPパケットのインデックスを取得するには、3.3.1項でアルゴリズムを実行します。このアルゴリズムは、セクション3.3.1で説明されているように、SRTPパケット内のシーケンス番号を持つ、暗号化コンテキストでロールオーバーカウンタと最高のシーケンス番号を使用します。"
    },
    {
      "indent": 3,
      "text": "3. Determine the master key and master salt. If the MKI indicator in the context is set to one, use the MKI in the SRTP packet, otherwise use the index from the previous step, according to Section 8.1.",
      "ja": "3. マスターキーとマスターソルトを決定します。コンテキスト内のMKIインジケータが1に設定されている場合は、SRTPパケット内のMKIを使用してください。それ以外の場合は、セクション8.1に従って前の手順からインデックスを使用してください。"
    },
    {
      "indent": 3,
      "text": "4. Determine the session keys, and session salt (if used by the transform) as described in Section 4.3, using master key, master salt, key_derivation_rate and session key-lengths in the cryptographic context with the index, determined in Steps 2 and 3.",
      "ja": "4. セクション4.3で説明されているセッション鍵、およびセッションSALT（変換で使用されている場合）は、ステップ2と3で決定された暗号化コンテキストのマスターキー、マスターSALT、KEY_DERIVATIVED_RATE、およびセッションキー長を使用します。"
    },
    {
      "indent": 3,
      "text": "5. For message authentication and replay protection, first check if the packet has been replayed (Section 3.3.2), using the Replay List and the index as determined in Step 2. If the packet is judged to be replayed, then the packet MUST be discarded, and the event SHOULD be logged.",
      "ja": "5. メッセージ認証および再生保護のために、最初にパケットが再生リストとステップ2で決定されたインデックスを使用して、パケットが再生されたかどうか（セクション3.3.2）を確認します。パケットが再生されると判断された場合、パケットは破棄されなければなりませんイベントはログに記録されるべきです。"
    },
    {
      "indent": 6,
      "text": "Next, perform verification of the authentication tag, using the rollover counter from Step 2, the authentication algorithm indicated in the cryptographic context, and the session authentication key from Step 4. If the result is \"AUTHENTICATION FAILURE\" (see Section 4.2), the packet MUST be discarded from further processing and the event SHOULD be logged.",
      "ja": "次に、ステップ2からのロールオーバーカウンタ、暗号化コンテキストに示されている認証アルゴリズム、およびステップ4からのセッション認証キーを使用して、認証タグの検証を実行します。結果が「認証失敗」である場合（セクション4.2を参照）パケットはさらなる処理から破棄されなければならず、イベントはログに記録されるべきです。"
    },
    {
      "indent": 3,
      "text": "6. Decrypt the Encrypted Portion of the packet (see Section 4.1, for the defined ciphers), using the decryption algorithm indicated in the cryptographic context, the session encryption key and salt (if used) found in Step 4 with the index from Step 2.",
      "ja": "6. 暗号化コンテキストに示されている復号化アルゴリズム、セッション暗号化キーとSALT（Section 4.1を参照）の暗号化部分を復号化します。"
    },
    {
      "indent": 3,
      "text": "7. Update the rollover counter and highest sequence number, s_l, in the cryptographic context as in Section 3.3.1, using the packet index estimated in Step 2. If replay protection is provided, also update the Replay List as described in Section 3.3.2.",
      "ja": "7. ステップ2で推定されているパケットインデックスを使用して、セクション3.3.1のように、ロールオーバーカウンタと最も高いシーケンス番号S_Lを更新します。"
    },
    {
      "indent": 3,
      "text": "8. When present, remove the MKI and authentication tag fields from the packet.",
      "ja": "8. 存在する場合は、パケットからMKIと認証タグフィールドを削除します。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Packet Index Determination, and ROC, s_l Update",
      "section_title": true,
      "ja": "3.3.1. パケットインデックスの決定、およびROC、S_Lアップデート"
    },
    {
      "indent": 3,
      "text": "SRTP implementations use an \"implicit\" packet index for sequencing, i.e., not all of the index is explicitly carried in the SRTP packet. For the pre-defined transforms, the index i is used in replay protection (Section 3.3.2), encryption (Section 4.1), message authentication (Section 4.2), and for the key derivation (Section 4.3).",
      "ja": "SRTPの実装は、シーケンスのための「暗黙的」パケットインデックス、すなわち、すべてのインデックスがSRTPパケットで明示的に運ばれるわけではありません。事前定義された変換では、インデックスiは再生保護（セクション3.3.2）、暗号化（セクション4.1）、メッセージ認証（セクション4.2）、およびキー導出（セクション4.3）で使用されます（セクション4.3）。"
    },
    {
      "indent": 3,
      "text": "When the session starts, the sender side MUST set the rollover counter, ROC, to zero. Each time the RTP sequence number, SEQ, wraps modulo 2^16, the sender side MUST increment ROC by one, modulo 2^32 (see security aspects below). The sender's packet index is then defined as",
      "ja": "セッションが開始されると、送信側はロールオーバーカウンタ、ROCをゼロに設定する必要があります。RTPシーケンス番号SEQ、SEQ、Modulo 2 ^ 16をラップするたびに、送信側は1つのモジュロ2 ^ 32でROCを増やす必要があります（以下のセキュリティの側面を参照）。送信者のパケットインデックスはASとして定義されます"
    },
    {
      "indent": 6,
      "text": "i = 2^16 * ROC + SEQ.",
      "ja": "I = 2 ^ 16 * ROC SEQ。"
    },
    {
      "indent": 3,
      "text": "Receiver-side implementations use the RTP sequence number to determine the correct index of a packet, which is the location of the packet in the sequence of all SRTP packets. A robust approach for the proper use of a rollover counter requires its handling and use to be well defined. In particular, out-of-order RTP packets with sequence numbers close to 2^16 or zero must be properly handled.",
      "ja": "受信側の実装では、RTPシーケンス番号を使用して、パケットの正しいインデックスを決定します。これは、すべてのSRTPパケットのシーケンス内のパケットの場所です。ロールオーバーカウンターを適切に使用するための堅牢なアプローチは、その取り扱いおよび使用を明確に定義することを必要とする。特に、2 ^ 16またはゼロに近いシーケンス番号を持つオーダーのRTPパケットを適切に処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "The index estimate is based on the receiver's locally maintained ROC and s_l values. At the setup of the session, the ROC MUST be set to zero. Receivers joining an on-going session MUST be given the current ROC value using out-of-band signaling such as key-management signaling. Furthermore, the receiver SHALL initialize s_l to the RTP sequence number (SEQ) of the first observed SRTP packet (unless the initial value is provided by out of band signaling such as key management).",
      "ja": "索引推定値は、受信者のローカルに維持されたROCおよびS_L値に基づいています。セッションの設定で、ROCはゼロに設定されている必要があります。継続的なセッションに参加する受信機は、キー管理シグナリングなどの帯域外シグナリングを使用して現在のROC値を与えなければなりません。さらに、受信機は、最初の観測されたSRTPパケットのRTPシーケンス番号（SEQ）にS_Lを初期化しなければならない（初期値がキー管理のような帯域のシグナリングによって提供されない限り）。"
    },
    {
      "indent": 3,
      "text": "On consecutive SRTP packets, the receiver SHOULD estimate the index as i = 2^16 * v + SEQ,",
      "ja": "連続したSRTPパケットでは、受信機はI = 2 ^ 16 * V SEQとしてインデックスを推定する必要があります。"
    },
    {
      "indent": 3,
      "text": "where v is chosen from the set { ROC-1, ROC, ROC+1 } (modulo 2^32) such that i is closest (in modulo 2^48 sense) to the value 2^16 * ROC + s_l (see Appendix A for pseudocode).",
      "ja": "ここで、Vはセット{ROC-1、ROC、ROC 1}（Modulo 2 ^ 32）から選択されます（Modulo 2 ^ 32）、値2 ^ 16 * ROC S_L（付録Aを参照）疑似コード）。"
    },
    {
      "indent": 3,
      "text": "After the packet has been processed and authenticated (when enabled for SRTP packets for the session), the receiver MUST use v to conditionally update its s_l and ROC variables as follows. If v=(ROC-1) mod 2^32, then there is no update to s_l or ROC. If v=ROC, then s_l is set to SEQ if and only if SEQ is larger than the current s_l; there is no change to ROC. If v=(ROC+1) mod 2^32, then s_l is set to SEQ and ROC is set to v.",
      "ja": "パケットが処理および認証された後（セッションのSRTPパケットに対して有効にすると）、受信側は次のようにそのS_LおよびROC変数を条件付きで更新するためにvを使用する必要があります。v =（ROC-1）MOD 2 ^ 32の場合、S_LまたはROCに更新はありません。V = ROCの場合、SEQが現在のS_Lよりも大きい場合に限り、S_LはSEQに設定されます。ROCに変更はありません。V =（ROC 1）MOD 2 ^ 32の場合、S_LはSEQに設定され、ROCはVに設定されます。"
    },
    {
      "indent": 3,
      "text": "After a re-keying occurs (changing to a new master key), the rollover counter always maintains its sequence of values, i.e., it MUST NOT be reset to zero.",
      "ja": "再キーイングが発生した後（新しいマスターキーに変更）、ロールオーバーカウンタは常にそのシーケンスを維持します。すなわち、ゼロにリセットされてはいけません。"
    },
    {
      "indent": 3,
      "text": "As the rollover counter is 32 bits long and the sequence number is 16 bits long, the maximum number of packets belonging to a given SRTP stream that can be secured with the same key is 2^48 using the pre-defined transforms. After that number of SRTP packets have been sent with a given (master or session) key, the sender MUST NOT send any more packets with that key. (There exists a similar limit for SRTCP, which in practice may be more restrictive, see Section 9.2.) This limitation enforces a security benefit by providing an upper bound on the amount of traffic that can pass before cryptographic keys are changed. Re-keying (see Section 8.1) MUST be triggered, before this amount of traffic, and MAY be triggered earlier, e.g., for increased security and access control to media. Recurring key derivation by means of a non-zero key_derivation_rate (see Section 4.3), also gives stronger security but does not change the above absolute maximum value.",
      "ja": "ロールオーバーカウンタが32ビット長であり、シーケンス番号は16ビット長であるため、同じキーで保護することができる特定のSRTPストリームに属するパケットの最大数は、定義済み変換を使用して2 ^ 48です。その数のSRTPパケットが与えられた（マスターまたはセッション）キーで送信された後、送信者はそのキーを使用してさらにパケットを送信してはなりません。（実際にはより制限的な場合があります。）この制限は、暗号鍵が変更される前に通過できるトラフィックの量に上限を提供することで、セキュリティ上の利益を強制することができます。このトラフィックの前に、再キーイング（セクション8.1を参照）は、このトラフィックの前にトリガーされなければならず、例えばセキュリティとメディアへのアクセス制御を増やすために、以前にトリガーされます。ゼロ以外のkey_delivation_rateによる繰り返しキー導出（セクション4.3を参照）は、より強力なセキュリティを与えますが、上記の絶対最大値を変更しません。"
    },
    {
      "indent": 3,
      "text": "On the receiver side, there is a caveat to updating s_l and ROC: if message authentication is not present, neither the initialization of s_l, nor the ROC update can be made completely robust. The receiver's \"implicit index\" approach works for the pre-defined transforms as long as the reorder and loss of the packets are not too great and bit-errors do not occur in unfortunate ways. In particular, 2^15 packets would need to be lost, or a packet would need to be 2^15 packets out of sequence before synchronization is lost. Such drastic loss or reorder is likely to disrupt the RTP application itself.",
      "ja": "受信側では、S_LとROCを更新するための注意があります。メッセージ認証が存在しない場合は、S_Lの初期化もROC更新も完全に堅牢にすることはできません。受信者の「暗黙的インデックス」アプローチは、パケットの並べ替えや損失が大きくなり過ぎず、ビットエラーが残念な点で発生しない限り、事前定義の変換に取り組んでいます。特に、2 ^ 15パケットを失われる必要があるか、同期が失われる前にパケットがシーケンスから2 ^ 15パケットである必要があるだろう。そのような劇的な損失または並べ替えは、RTPアプリケーション自体を破壊する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The algorithm for the index estimate and ROC update is a matter of implementation, and should take into consideration the environment (e.g., packet loss rate) and the cases when synchronization is likely to be lost, e.g., when the initial sequence number (randomly chosen by RTP) is not known in advance (not sent in the key management protocol) but may be near to wrap modulo 2^16.",
      "ja": "索引推定値およびROC更新のアルゴリズムは実装の問題であり、初期シーケンス番号（ランダムに選択されたときに、パケット損失率など）および同期が失われる可能性がある場合を考慮に入れるべきである。RTPによる）は事前に知られていない（鍵管理プロトコルでは送信されていません）が、モジュロ2 ^ 16をラップするのが近くなる可能性があります。"
    },
    {
      "indent": 3,
      "text": "A more elaborate and more robust scheme than the one given above is the handling of RTP's own \"rollover counter\", see Appendix A.1 of [RFC3550].",
      "ja": "上記のものよりも精巧でより堅牢なスキームは、RTP自身の「ロールオーバーカウンター」の取り扱いです。[RFC3550]の付録A.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Replay Protection",
      "section_title": true,
      "ja": "3.3.2. リプレイ保護"
    },
    {
      "indent": 3,
      "text": "Secure replay protection is only possible when integrity protection is present. It is RECOMMENDED to use replay protection, both for RTP and RTCP, as integrity protection alone cannot assure security against replay attacks.",
      "ja": "安全な再生保護は、完全性保護が存在する場合にのみ可能です。RTPとRTCPの両方で再生保護を使用することをお勧めします。整合性保護だけでは、リプレイ攻撃に対するセキュリティを保証できません。"
    },
    {
      "indent": 3,
      "text": "A packet is \"replayed\" when it is stored by an adversary, and then re-injected into the network. When message authentication is provided, SRTP protects against such attacks through a Replay List. Each SRTP receiver maintains a Replay List, which conceptually contains the indices of all of the packets which have been received and authenticated. In practice, the list can use a \"sliding window\" approach, so that a fixed amount of storage suffices for replay protection. Packet indices which lag behind the packet index in the context by more than SRTP-WINDOW-SIZE can be assumed to have been received, where SRTP-WINDOW-SIZE is a receiver-side, implementation-dependent parameter and MUST be at least 64, but which MAY be set to a higher value.",
      "ja": "パケットは、敵対者によって保存されてからネットワークに再注入されたときに「再生」されます。メッセージ認証が提供されると、SRTPは再生リストを介してそのような攻撃から保護します。各SRTP受信機は再生リストを維持しており、これは概念的に受信および認証されたパケットのインデックスを含む。実際には、リストは「スライディングウィンドウ」アプローチを使用することができ、その結果、一定量のストレージが再生保護に十分である。srtp-windowsサイズを超えてコンテキスト内のパケットインデックスの背後に遅れて、srtp-windows sizeは受信側、実装依存パラメータで、少なくとも64でなければならないと見なすことができます。しかし、それはより高い値に設定され得る。"
    },
    {
      "indent": 3,
      "text": "The receiver checks the index of an incoming packet against the replay list and the window. Only packets with index ahead of the window, or, inside the window but not already received, SHALL be accepted.",
      "ja": "受信機は、再生リストとウィンドウに対して着信パケットのインデックスを確認します。ウィンドウの前にインデックスを持つパケットのみ、またはウィンドウ内には受信されていないが、承認されていない。"
    },
    {
      "indent": 3,
      "text": "After the packet has been authenticated (if necessary the window is first moved ahead), the replay list SHALL be updated with the new index.",
      "ja": "パケットが認証された後（必要な場合は、ウィンドウが先に移動されます）、再生リストは新しいインデックスで更新されます。"
    },
    {
      "indent": 3,
      "text": "The Replay List can be efficiently implemented by using a bitmap to represent which packets have been received, as described in the Security Architecture for IP [RFC2401].",
      "ja": "IP [RFC2401]のセキュリティアーキテクチャーで説明されているように、ビットマップを使用することで、再生リストを効率的に実装することができる。"
    },
    {
      "indent": 0,
      "text": "3.4. Secure RTCP",
      "section_title": true,
      "ja": "3.4. 安全なRTCP"
    },
    {
      "indent": 3,
      "text": "Secure RTCP follows the definition of Secure RTP. SRTCP adds three mandatory new fields (the SRTCP index, an \"encrypt-flag\", and the authentication tag) and one optional field (the MKI) to the RTCP packet definition. The three mandatory fields MUST be appended to an RTCP packet in order to form an equivalent SRTCP packet. The added fields follow any other profile-specific extensions.",
      "ja": "Secure RTCPはSecure RTPの定義に従います。SRTCPは、RTCPパケット定義に3つの必須の新しいフィールド（SRTCPインデックス、「暗号化フラグ」、および認証タグ）と1つのオプションフィールド（MKI）を追加します。同等のSRTCPパケットを形成するために、3つの必須フィールドをRTCPパケットに追加する必要があります。追加されたフィールドは他のプロファイル固有の拡張機能に従います。"
    },
    {
      "indent": 3,
      "text": "According to Section 6.1 of [RFC3550], there is a REQUIRED packet format for compound packets. SRTCP MUST be given packets according to that requirement in the sense that the first part MUST be a sender report or a receiver report. However, the RTCP encryption prefix (a random 32-bit quantity) specified in that Section MUST NOT be used since, as is stated there, it is only applicable to the encryption method specified in [RFC3550] and is not needed by the cryptographic mechanisms used in SRTP.",
      "ja": "[RFC3550]のセクション6.1によると、複合パケットに必要なパケットフォーマットがあります。SRTCPは、最初の部分が送信者レポートまたは受信者レポートでなければならないという意味で、その要件に従ってパケットを与えなければなりません。ただし、そのセクションで指定されたRTCP暗号化プレフィックス（ランダム32ビット数量）は、[RFC3550]で指定された暗号化方法にのみ適用されていて、暗号化メカニズムには必要ないため、使用してはなりません。SRTPで使用されます。"
    },
    {
      "indent": 3,
      "text": "   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n  |V=2|P|    RC   |   PT=SR or RR   |             length          | |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n  |                         SSRC of sender                        | |\n+>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n| ~                          sender info                          ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| ~                         report block 1                        ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| ~                         report block 2                        ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| ~                              ...                              ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| |V=2|P|    SC   |  PT=SDES=202  |             length            | |\n| +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n| |                          SSRC/CSRC_1                          | |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| ~                           SDES items                          ~ |\n| +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n| ~                              ...                              ~ |\n+>+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ |\n| |E|                         SRTCP index                         | |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<+\n| ~                     SRTCP MKI (OPTIONAL)                      ~ |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n| :                     authentication tag                        : |\n| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |\n|                                                                   |\n+-- Encrypted Portion                    Authenticated Portion -----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 2. An example of the format of a Secure RTCP packet, consisting of an underlying RTCP compound packet with a Sender Report and SDES packet.",
      "ja": "図2.送信者レポートとSDESパケットを含む基盤となるRTCP複合パケットからなる安全なRTCPパケットのフォーマットの例。"
    },
    {
      "indent": 3,
      "text": "The Encrypted Portion of an SRTCP packet consists of the encryption (Section 4.1) of the RTCP payload of the equivalent compound RTCP packet, from the first RTCP packet, i.e., from the ninth (9) octet to the end of the compound packet. The Authenticated Portion of an SRTCP packet consists of the entire equivalent (eventually compound) RTCP packet, the E flag, and the SRTCP index (after any encryption has been applied to the payload).",
      "ja": "SRTCPパケットの暗号化部分は、第1のRTCPパケット、すなわち第9の（9）オクテットから、複合パケットの終わりまでの等価化合物RTCPパケットのRTCPペイロードの暗号化（セクション4.1）からなる。SRTCPパケットの認証された部分は、同等の（最終的に複合）RTCPパケット、Eフラグ、およびSRTCPインデックスからなる（任意の暗号化がペイロードに適用された後）。"
    },
    {
      "indent": 3,
      "text": "The added fields are:",
      "ja": "追加されたフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "E-flag: 1 bit, REQUIRED The E-flag indicates if the current SRTCP packet is encrypted or unencrypted. Section 9.1 of [RFC3550] allows the split of a compound RTCP packet into two lower-layer packets, one to be encrypted and one to be sent in the clear. The E bit set to \"1\" indicates encrypted packet, and \"0\" indicates non-encrypted packet.",
      "ja": "E-Flag：1ビット、必須Eフラグは、現在のSRTCPパケットが暗号化または暗号化されていないかを示します。[RFC3550]のセクション9.1は、複合RTCPパケットの分割を2つの下位パケットに分割し、暗号化され、クリアに送信されるものを使用できます。「1」に設定されたEビットは暗号化パケットを示し、「0」は非暗号化パケットを示す。"
    },
    {
      "indent": 3,
      "text": "SRTCP index: 31 bits, REQUIRED The SRTCP index is a 31-bit counter for the SRTCP packet. The index is explicitly included in each packet, in contrast to the \"implicit\" index approach used for SRTP. The SRTCP index MUST be set to zero before the first SRTCP packet is sent, and MUST be incremented by one, modulo 2^31, after each SRTCP packet is sent. In particular, after a re-key, the SRTCP index MUST NOT be reset to zero again.",
      "ja": "SRTCPインデックス：31ビット、必要なSRTCPインデックスはSRTCPパケットの31ビットカウンタです。SRTPに使用される「暗黙的な」インデックスアプローチとは対照的に、インデックスは各パケットに明示的に含まれています。SRTCPインデックスは、最初のSRTCPパケットが送信される前にゼロに設定されなければならず、各SRTCPパケットが送信された後に1つ、モジュロ2 ^ 31によってインクリメントされなければなりません。特に、再キーの後、SRTCPインデックスをもう一度ゼロにリセットしないでください。"
    },
    {
      "indent": 3,
      "text": "Authentication Tag: configurable length, REQUIRED The authentication tag is used to carry message authentication data.",
      "ja": "認証タグ：設定可能な長さ、必要な認証タグはメッセージ認証データを搬送するために使用されます。"
    },
    {
      "indent": 3,
      "text": "MKI: configurable length, OPTIONAL The MKI is the Master Key Indicator, and functions according to the MKI definition in Section 3.",
      "ja": "MKI：設定可能な長さ、MKIはマスターキーインジケータであり、セクション3のMKI定義に従って機能します。"
    },
    {
      "indent": 3,
      "text": "SRTCP uses the cryptographic context parameters and packet processing of SRTP by default, with the following changes:",
      "ja": "SRTCPは、デフォルトでSRTPの暗号化コンテキストパラメータとパケット処理を使用しています。"
    },
    {
      "indent": 3,
      "text": "* The receiver does not need to \"estimate\" the index, as it is explicitly signaled in the packet.",
      "ja": "* 受信機は、パケット内で明示的にシグナリングされているため、インデックスを「推定」する必要はありません。"
    },
    {
      "indent": 0,
      "text": " * Pre-defined SRTCP encryption is as specified in Section 4.1, but using the definition of the SRTCP Encrypted Portion given in this section, and using the SRTCP index as the index i. The encryption transform and related parameters SHALL by default be the same selected for the protection of the associated SRTP stream(s), while the NULL algorithm SHALL be applied to the RTCP packets not to be encrypted. SRTCP may have a different encryption transform than the one used by the corresponding SRTP. The expected use for this feature is when the former has NULL-encryption and the latter has a non NULL-encryption.",
      "ja": "*定義済みのSRTCP暗号化はセクション4.1で指定されていますが、このセクションに記載されているSRTCP暗号化部分の定義を使用し、SRTCPインデックスをインデックスiとして使用します。暗号化変換および関連パラメータは、デフォルトでは、関連するSRTPストリームの保護に対して選択されたものとするものとしますが、NULLアルゴリズムは暗号化されないRTCPパケットに適用されます。SRTCPは、対応するSRTPによって使用されるものよりも異なる暗号化変換を持つことができます。この機能のための予想される使用は、前者がNULL暗号化を持ち、後者はヌル以外の暗号化を持ちます。"
    },
    {
      "indent": 3,
      "text": "The E-flag is assigned a value by the sender depending on whether the packet was encrypted or not.",
      "ja": "電子フラグには、パケットが暗号化されているかどうかに応じて送信者によって値が割り当てられます。"
    },
    {
      "indent": 3,
      "text": "* SRTCP decryption is performed as in Section 4, but only if the E flag is equal to 1. If so, the Encrypted Portion is decrypted, using the SRTCP index as the index i. In case the E-flag is 0, the payload is simply left unmodified.",
      "ja": "* SRTCP復号化はセクション4のように実行されますが、Eフラグが1に等しい場合に限り、IFである場合、暗号化部分は索引IとしてSRTCPインデックスを使用して復号化されます。Eフラグが0の場合、ペイロードは単に変更されていないままにされます。"
    },
    {
      "indent": 3,
      "text": "* SRTCP replay protection is as defined in Section 3.3.2, but using the SRTCP index as the index i and a separate Replay List that is specific to SRTCP.",
      "ja": "* SRTCPリプレイ保護はセクション3.3.2で定義されているが、SRTCPインデックスをインデックスiとして使用し、SRTCPに固有の別の再生リストを使用しています。"
    },
    {
      "indent": 3,
      "text": "* The pre-defined SRTCP authentication tag is specified as in Section 4.2, but with the Authenticated Portion of the SRTCP packet given in this section (which includes the index). The authentication transform and related parameters (e.g., key size) SHALL by default be the same as selected for the protection of the associated SRTP stream(s).",
      "ja": "* 事前定義されたSRTCP認証タグはセクション4.2のように指定されていますが、このセクションで指定されたSRTCPパケットの認証済み部分は（インデックスを含む）。認証変換および関連パラメータ（例えば、鍵サイズ）は、デフォルトでは、関連するSRTPストリームの保護に対して選択されたものと同じでなければならない。"
    },
    {
      "indent": 3,
      "text": "* In the last step of the processing, only the sender needs to update the value of the SRTCP index by incrementing it modulo 2^31 and for security reasons the sender MUST also check the number of SRTCP packets processed, see Section 9.2.",
      "ja": "* 処理の最後のステップでは、送信者のみがModulo 2 ^ 31をインクリメントしてSRTCPインデックスの値を更新する必要があり、セキュリティ上の理由から、送信者は処理されたSRTCPパケットの数も確認する必要があります。セクション9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Message authentication for RTCP is REQUIRED, as it is the control protocol (e.g., it has a BYE packet) for RTP.",
      "ja": "RTP用の制御プロトコル（例えば、BYEパケットがある）であるため、RTCPのメッセージ認証が必要です。"
    },
    {
      "indent": 3,
      "text": "Precautions must be taken so that the packet expansion in SRTCP (due to the added fields) does not cause SRTCP messages to use more than their share of RTCP bandwidth. To avoid this, the following two measures MUST be taken:",
      "ja": "SRTCPのパケット拡張（追加フィールドのため）にSRTCPメッセージがRTCP帯域幅のシェア以上の使用を引き起こさないように予防措置を講じる必要があります。これを回避するために、次の2つの対策をとる必要があります。"
    },
    {
      "indent": 3,
      "text": "1. When initializing the RTCP variable \"avg_rtcp_size\" defined in chapter 6.3 of [RFC3550], it MUST include the size of the fields that will be added by SRTCP (index, E-bit, authentication tag, and when present, the MKI).",
      "ja": "1. [RFC3550]の第6.3章で定義されているRTCP変数 \"AVG_RTCP_SIZE\"を初期化する場合は、SRTCP（索引、電子ビット、認証タグ、および現在、MKI）によって追加されるフィールドのサイズを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "2. When updating the \"avg_rtcp_size\" using the variable \"packet_size\" (section 6.3.3 of [RFC3550]), the value of \"packet_size\" MUST include the size of the additional fields added by SRTCP.",
      "ja": "2. 変数 \"packet_size\"（[RFC3550]のセクション6.3.3）を使用して \"AVG_RTCP_SIZE\"を更新する場合、 \"packet_size\"の値にはsrtcpによって追加された追加のフィールドのサイズが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "With these measures in place the SRTCP messages will not use more than the allotted bandwidth. The effect of the size of the added fields on the SRTCP traffic will be that messages will be sent with longer packet intervals. The increase in the intervals will be directly proportional to size of the added fields. For the pre-defined transforms, the size of the added fields will be at least 14 octets, and upper bounded depending on MKI and the authentication tag sizes.",
      "ja": "これらの対策を整って、SRTCPメッセージは割り当てられた帯域幅を超えて使用されません。SRTCPトラフィックに追加されたフィールドのサイズの効果は、メッセージが長いパケット間隔で送信されることになります。間隔の増加は、追加されたフィールドのサイズに正比例します。事前定義された変換については、追加されたフィールドのサイズは少なくとも14オクテット、およびMKIと認証タグのサイズによっては上限があります。"
    },
    {
      "indent": 0,
      "text": "4. Pre-Defined Cryptographic Transforms",
      "section_title": true,
      "ja": "4. 事前定義された暗号変換"
    },
    {
      "indent": 3,
      "text": "While there are numerous encryption and message authentication algorithms that can be used in SRTP, below we define default algorithms in order to avoid the complexity of specifying the encodings for the signaling of algorithm and parameter identifiers. The defined algorithms have been chosen as they fulfill the goals listed in Section 2. Recommendations on how to extend SRTP with new transforms are given in Section 6.",
      "ja": "SRTPで使用できる多数の暗号化およびメッセージ認証アルゴリズムがありますが、アルゴリズムとパラメータ識別子のシグナリングのためのエンコーディングを指定する複雑さを回避するために、デフォルトのアルゴリズムを定義します。定義されたアルゴリズムは、それらがセクション2にリストされている目標を満たすときに選択されました.SRTPを新しい変換で拡張する方法についての推奨事項をセクション6に示します。"
    },
    {
      "indent": 0,
      "text": "4.1. Encryption",
      "section_title": true,
      "ja": "4.1. 暗号化"
    },
    {
      "indent": 3,
      "text": "The following parameters are common to both pre-defined, non-NULL, encryption transforms specified in this section.",
      "ja": "以下のパラメータは、このセクションで指定されている事前定義されていない非NULLの暗号化変換の両方に共通です。"
    },
    {
      "indent": 3,
      "text": "* BLOCK_CIPHER-MODE indicates the block cipher used and its mode of operation * n_b is the bit-size of the block for the block cipher * k_e is the session encryption key * n_e is the bit-length of k_e * k_s is the session salting key * n_s is the bit-length of k_s * SRTP_PREFIX_LENGTH is the octet length of the keystream prefix, a non-negative integer, specified by the message authentication code in use.",
      "ja": "* block_cipher-modeさんのブロック暗号を示し、その動作モード* N_Bはブロック暗号* k_eのブロックのビットサイズです。* N_SはK_S * SRTP_PREFIX_LENGTHのビット長です.SRTP_PREFIX_LENGTHは、使用中のメッセージ認証コードで指定された負の負の整数のオクテット長です。"
    },
    {
      "indent": 3,
      "text": "The distinct session keys and salts for SRTP/SRTCP are by default derived as specified in Section 4.3.",
      "ja": "SRTP / SRTCPのための異なるセッションキーと塩は、デフォルトではセクション4.3で指定されています。"
    },
    {
      "indent": 3,
      "text": "The encryption transforms defined in SRTP map the SRTP packet index and secret key into a pseudo-random keystream segment. Each keystream segment encrypts a single RTP packet. The process of encrypting a packet consists of generating the keystream segment corresponding to the packet, and then bitwise exclusive-oring that keystream segment onto the payload of the RTP packet to produce the Encrypted Portion of the SRTP packet. In case the payload size is not an integer multiple of n_b bits, the excess (least significant) bits of the keystream are simply discarded. Decryption is done the same way, but swapping the roles of the plaintext and ciphertext.",
      "ja": "SRTPで定義されている暗号化変換は、SRTPパケットインデックスと秘密鍵を疑似ランダムキーストリームセグメントにマッピングします。各キーストリームセグメントは単一のRTPパケットを暗号化します。パケットを暗号化するプロセスは、パケットに対応するキーストリームセグメントを生成し、次いでそのキーストリームセグメントをRTPパケットのペイロード上にビットごとに排他的またはSRTPパケットの暗号化部分を生成することからなる。ペイロードサイズがN_Bビットの整数倍ではない場合、キーストリームの過剰な（最下位）ビットは単に破棄されます。復号化は同じ方法で行われますが、平文と暗号文の役割を交換します。"
    },
    {
      "indent": 3,
      "text": "+----+   +------------------+---------------------------------+\n| KG |-->| Keystream Prefix |          Keystream Suffix       |---+\n+----+   +------------------+---------------------------------+   |\n                                                                  |\n                            +---------------------------------+   v\n                            |     Payload of RTP Packet       |->(*)\n                            +---------------------------------+   |\n                                                                  |\n                            +---------------------------------+   |\n                            | Encrypted Portion of SRTP Packet|<--+\n                            +---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3: Default SRTP Encryption Processing. Here KG denotes the keystream generator, and (*) denotes bitwise exclusive-or.",
      "ja": "図3：デフォルトのSRTP暗号化処理。ここで、Kgはキーストリーム発生器を表し、（*）はビット単位の排他的またはである。"
    },
    {
      "indent": 3,
      "text": "The definition of how the keystream is generated, given the index, depends on the cipher and its mode of operation. Below, two such keystream generators are defined. The NULL cipher is also defined, to be used when encryption of RTP is not required.",
      "ja": "インデックスを指定して、キーストリームの生成方法の定義は、暗号とその動作モードによって異なります。以下では、2つのそのようなキーストリーム発生器が定義されています。NULL暗号は、RTPの暗号化が不要な場合に使用されるように定義されています。"
    },
    {
      "indent": 3,
      "text": "The SRTP definition of the keystream is illustrated in Figure 3. The initial octets of each keystream segment MAY be reserved for use in a message authentication code, in which case the keystream used for encryption starts immediately after the last reserved octet. The initial reserved octets are called the \"keystream prefix\" (not to be confused with the \"encryption prefix\" of [RFC3550, Section 6.1]), and the remaining octets are called the \"keystream suffix\". The keystream prefix MUST NOT be used for encryption. The process is illustrated in Figure 3.",
      "ja": "キーストリームのSRTP定義を図3に示します。各キーストリームセグメントの初期オクテットは、メッセージ認証コードで使用するために予約されている可能性があります。その場合、暗号化に使用されるキーストリームは最後の予約オクテットの直後に開始されます。初期予約済みオクテットは、「キーストリームプレフィックス」と呼ばれます（[RFC3550、セクション6.1]の「暗号化プレフィックス」と混乱しないでください）、残りのオクテットは「キーストリームサフィックス」と呼ばれます。キーストリームプレフィックスは暗号化に使用しないでください。プロセスを図3に示す。"
    },
    {
      "indent": 3,
      "text": "The number of octets in the keystream prefix is denoted as SRTP_PREFIX_LENGTH. The keystream prefix is indicated by a positive, non-zero value of SRTP_PREFIX_LENGTH. This means that, even if confidentiality is not to be provided, the keystream generator output may still need to be computed for packet authentication, in which case the default keystream generator (mode) SHALL be used.",
      "ja": "キーストリームプレフィックス内のオクテット数はsrtp_prefix_lengthとして示されます。キーストリームプレフィックスは、srtp_prefix_lengthの正のゼロ以外の値で示されます。これは、機密性が提供されない場合であっても、キーストリームジェネレータ出力は依然としてパケット認証のために計算される必要があるかもしれないことを意味し、その場合、デフォルトのキーストリーム発生器（モード）を使用する。"
    },
    {
      "indent": 3,
      "text": "The default cipher is the Advanced Encryption Standard (AES) [AES], and we define two modes of running AES, (1) Segmented Integer Counter Mode AES and (2) AES in f8-mode. In the remainder of this section, let E(k,x) be AES applied to key k and input block x.",
      "ja": "デフォルトの暗号は高度な暗号化標準（AES）[AES]で、AESを実行している2つのモード、（1）セグメント化された整数モードAESと（2）AESがF8モードで定義します。このセクションの残りの部分では、e（k、x）をキーkおよび入力ブロックxに適用されたAESとする。"
    },
    {
      "indent": 0,
      "text": "4.1.1. AES in Counter Mode",
      "section_title": true,
      "ja": "4.1.1. カウンターモードのAES"
    },
    {
      "indent": 3,
      "text": "Conceptually, counter mode [AES-CTR] consists of encrypting successive integers. The actual definition is somewhat more complicated, in order to randomize the starting point of the integer sequence. Each packet is encrypted with a distinct keystream segment, which SHALL be computed as follows.",
      "ja": "概念的には、カウンタモード[AES-CTR]は、連続する整数を暗号化することです。整数シーケンスの開始点をランダム化するために、実際の定義はやや複雑です。各パケットは異なるキーストリームセグメントで暗号化されています。これは次のように計算されます。"
    },
    {
      "indent": 3,
      "text": "A keystream segment SHALL be the concatenation of the 128-bit output blocks of the AES cipher in the encrypt direction, using key k = k_e, in which the block indices are in increasing order. Symbolically, each keystream segment looks like",
      "ja": "キーストリームセグメントは、キーK = K_eを使用して、AES暗号の128ビットの出力ブロックを暗号化方向に連結し、ブロックインデックスは順序が増えています。象徴的には、各キーストリームセグメントはように見えます"
    },
    {
      "indent": 6,
      "text": "E(k, IV) || E(k, IV + 1 mod 2^128) || E(k, IV + 2 mod 2^128) ...",
      "ja": "E（k、iv）"
    },
    {
      "indent": 3,
      "text": "where the 128-bit integer value IV SHALL be defined by the SSRC, the SRTP packet index i, and the SRTP session salting key k_s, as below.",
      "ja": "128ビット整数値IVは、SSRC、SRTPパケットインデックスI、およびSRTPセッション販売キーK_Sによって定義されるものとする。"
    },
    {
      "indent": 6,
      "text": "IV = (k_s * 2^16) XOR (SSRC * 2^64) XOR (i * 2^16)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each of the three terms in the XOR-sum above is padded with as many leading zeros as needed to make the operation well-defined, considered as a 128-bit value.",
      "ja": "上記のXOR-SUMの3つの項のそれぞれには、128ビット値と見なされる操作を明確に定義するために必要なだけ多くの先行ゼロで埋められます。"
    },
    {
      "indent": 3,
      "text": "The inclusion of the SSRC allows the use of the same key to protect distinct SRTP streams within the same RTP session, see the security caveats in Section 9.1.",
      "ja": "SSRCを含めると、同じキーの使用が同じRTPセッション内で異なるSRTPストリームを保護するために、セクション9.1のセキュリティ警告を参照してください。"
    },
    {
      "indent": 3,
      "text": "In the case of SRTCP, the SSRC of the first header of the compound packet MUST be used, i SHALL be the 31-bit SRTCP index and k_e, k_s SHALL be replaced by the SRTCP encryption session key and salt.",
      "ja": "SRTCPの場合、複合パケットの最初のヘッダーのSSRCを使用する必要があります.31ビットSRTCP IndexとK_Eとする必要があります.K_SはSRTCP暗号化セッションキーとSALTに置き換えます。"
    },
    {
      "indent": 3,
      "text": "Note that the initial value, IV, is fixed for each packet and is formed by \"reserving\" 16 zeros in the least significant bits for the purpose of the counter. The number of blocks of keystream generated for any fixed value of IV MUST NOT exceed 2^16 to avoid keystream re-use, see below. The AES has a block size of 128 bits, so 2^16 output blocks are sufficient to generate the 2^23 bits of keystream needed to encrypt the largest possible RTP packet (except for IPv6 \"jumbograms\" [RFC2675], which are not likely to be used for RTP-based multimedia traffic). This restriction on the maximum bit-size of the packet that can be encrypted ensures the security of the encryption method by limiting the effectiveness of probabilistic attacks [BDJR].",
      "ja": "なお、初期値IVは各パケットに対して固定され、カウンタの目的のために最下位ビットに「予約」16ゼロによって形成される。IVの固定値に対して生成されたキーストリームのブロック数は、キーストリームの再利用を避けるために2 ^ 16を超えてはいけません。AESはブロックサイズが128ビットであるため、2 ^ 16出力ブロックでは、最大できる可能性のあるRTPパケットを暗号化するのに必要な2 ^ 23ビットのキーストリームを生成するのに十分です（IPv6 \"Jumbograms\" [RFC2675]を除く。RTPベースのマルチメディアトラフィックに使用されます。暗号化できるパケットの最大ビットサイズに対するこの制限は、確率論的攻撃の有効性を制限することによって暗号化方法のセキュリティを確保します[BDJR]。"
    },
    {
      "indent": 0,
      "text": " For a particular Counter Mode key, each IV value used as an input MUST be distinct, in order to avoid the security exposure of a two-time pad situation (Section 9.1). To satisfy this constraint, an implementation MUST ensure that the combination of the SRTP packet index of ROC || SEQ, and the SSRC used in the construction of the IV are distinct for any particular key. The failure to ensure this uniqueness could be catastrophic for Secure RTP. This is in contrast to the situation for RTP itself, which may be able to tolerate such failures. It is RECOMMENDED that, if a dedicated security module is present, the RTP sequence numbers and SSRC either be generated or checked by that module (i.e., sequence-number and SSRC processing in an SRTP system needs to be protected as well as the key).",
      "ja": "特定のカウンタモードキーの場合、2タイムパッド状況のセキュリティエクスポージャーを回避するために、入力として使用される各IV値は異なる必要があります（セクション9.1）。この制約を満たすために、実装はROCのSRTPパケットインデックスの組み合わせを確実にする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.2. AES in f8-mode",
      "section_title": true,
      "ja": "4.1.2. F8モードのAES"
    },
    {
      "indent": 3,
      "text": "To encrypt UMTS (Universal Mobile Telecommunications System, as 3G networks) data, a solution (see [f8-a] [f8-b]) known as the f8- algorithm has been developed. On a high level, the proposed scheme is a variant of Output Feedback Mode (OFB) [HAC], with a more elaborate initialization and feedback function. As in normal OFB, the core consists of a block cipher. We also define here the use of AES as a block cipher to be used in what we shall call \"f8-mode of operation\" RTP encryption. The AES f8-mode SHALL use the same default sizes for session key and salt as AES counter mode.",
      "ja": "UMTS（ユニバーサル移動体通信システム、3Gネットワークとして）データを暗号化するために、F8アルゴリズムとして知られている解（F8  -  A] [F8  -  B]参照）が開発された。高レベルでは、提案方式は出力フィードバックモード（OFB）[HAC]の変形であり、より複雑な初期化およびフィードバック機能を有する。OFBのOFBのように、コアはブロック暗号からなる。ここでは、「F8-Operation」RTP暗号化を呼び出すもので使用されるブロック暗号としてのAESを定義します。AES F8モードは、セッションキーとSALTのために同じデフォルトサイズをAESカウンタモードとして使用しなければならない。"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows the structure of block cipher, E, running in f8-mode.",
      "ja": "図4は、F8モードで動作しているブロック暗号、Eの構造を示しています。"
    },
    {
      "indent": 4,
      "text": "                IV\n                |\n                v\n            +------+\n            |      |\n       +--->|  E   |\n       |    +------+\n       |        |\n m -> (*)       +-----------+-------------+--  ...     ------+\n       |    IV' |           |             |                  |\n       |        |   j=1 -> (*)    j=2 -> (*)   ...  j=L-1 ->(*)\n       |        |           |             |                  |\n       |        |      +-> (*)       +-> (*)   ...      +-> (*)\n       |        |      |    |        |    |             |    |\n       |        v      |    v        |    v             |    v\n       |    +------+   | +------+    | +------+         | +------+\nk_e ---+--->|  E   |   | |  E   |    | |  E   |         | |  E   |\n            |      |   | |      |    | |      |         | |      |\n            +------+   | +------+    | +------+         | +------+\n                |      |    |        |    |             |    |\n                +------+    +--------+    +--  ...  ----+    |\n                |           |             |                  |\n                v           v             v                  v\n               S(0)        S(1)          S(2)  . . .       S(L-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 4. f8-mode of operation (asterisk, (*), denotes bitwise XOR). The figure represents the KG in Figure 3, when AES-f8 is used.",
      "ja": "図4. F8モードの動作モード（アスタリスク、（*）、ビット単位XORを表します）。図は、AES-F8が使用されている場合の図3のKGを表します。"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. f8 Keystream Generation",
      "section_title": true,
      "ja": "4.1.2.1. F8キーストリームジェネレーション"
    },
    {
      "indent": 3,
      "text": "The Initialization Vector (IV) SHALL be determined as described in Section 4.1.2.2 (and in Section 4.1.2.3 for SRTCP).",
      "ja": "初期化ベクトル（IV）は、セクション4.1.2.2（およびSRTCPの4.1.2.3項で）に記載されているように決定されなければならない。"
    },
    {
      "indent": 3,
      "text": "Let IV', S(j), and m denote n_b-bit blocks.  The keystream,\nS(0) ||... || S(L-1), for an N-bit message SHALL be defined by\nsetting IV' = E(k_e XOR m, IV), and S(-1) = 00..0.  For\nj = 0,1,..,L-1 where L = N/n_b (rounded up to nearest integer if it\nis not already an integer) compute",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "S(j) = E(k_e, IV' XOR j XOR S(j-1))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Notice that the IV is not used directly. Instead it is fed through E under another key to produce an internal, \"masked\" value (denoted IV') to prevent an attacker from gaining known input/output pairs.",
      "ja": "IVが直接使用されていないことに注意してください。代わりに、攻撃者が既知の入出力ペアを得るのを防ぐために、他のキーの下でEを供給して、内部「マスクされた」値（IV 'を表しています）を生成する。"
    },
    {
      "indent": 3,
      "text": "The role of the internal counter, j, is to prevent short keystream cycles. The value of the key mask m SHALL be",
      "ja": "内部カウンタ、jの役割は、短いキーストリームサイクルを防ぐことです。キーマスクMの値は"
    },
    {
      "indent": 11,
      "text": "m = k_s || 0x555..5,",
      "ja": "m = k_s"
    },
    {
      "indent": 3,
      "text": "i.e., the session salting key, appended by the binary pattern 0101.. to fill out the entire desired key size, n_e.",
      "ja": "すなわち、所望のキーサイズ全体を記入するために、2値パターン0101によって追加されたセッション販売キー、N_E。"
    },
    {
      "indent": 3,
      "text": "The sender SHOULD NOT generate more than 2^32 blocks, which is sufficient to generate 2^39 bits of keystream. Unlike counter mode, there is no absolute threshold above (below) which f8 is guaranteed to be insecure (secure). The above bound has been chosen to limit, with sufficient security margin, the probability of degenerative behavior in the f8 keystream generation.",
      "ja": "送信者は2 ^ 32ブロックを増やさないでください。これは、キーストリームの2 ^ 39ビットを生成するのに十分です。カウンタモードとは異なり、上記（下）の絶対閾値はない（安全な）ことが保証されている。上記の範囲は、十分なセキュリティマージン、F8キーストリーム生成における変性行動の確率で制限するように選択されています。"
    },
    {
      "indent": 0,
      "text": "4.1.2.2. f8 SRTP IV Formation",
      "section_title": true,
      "ja": "4.1.2.2. F8 SRTP IV形成"
    },
    {
      "indent": 3,
      "text": "The purpose of the following IV formation is to provide a feature which we call implicit header authentication (IHA), see Section 9.5.",
      "ja": "次のIV形成の目的は、暗黙的ヘッダー認証（IHA）を呼び出す機能を提供することです。セクション9.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The SRTP IV for 128-bit block AES-f8 SHALL be formed in the following way:",
      "ja": "128ビットブロックAES-F8のSRTP IVは次のようにして形成されます。"
    },
    {
      "indent": 8,
      "text": "IV = 0x00 || M || PT || SEQ || TS || SSRC || ROC",
      "ja": "IV = 0x00"
    },
    {
      "indent": 3,
      "text": "M, PT, SEQ, TS, SSRC SHALL be taken from the RTP header; ROC is from the cryptographic context.",
      "ja": "M、PT、SEQ、TS、SSRCはRTPヘッダーから取得されなければならない。ROCは暗号文脈からのものです。"
    },
    {
      "indent": 3,
      "text": "The presence of the SSRC as part of the IV allows AES-f8 to be used when a master key is shared between multiple streams within the same RTP session, see Section 9.1.",
      "ja": "IVの一部としてのSSRCの存在は、同じRTPセッション内の複数のストリーム間でマスターキーが共有されているときにAES-F8を使用することを可能にします。セクション9.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.1.2.3. f8 SRTCP IV Formation",
      "section_title": true,
      "ja": "4.1.2.3. F8 SRTCP IV形成"
    },
    {
      "indent": 3,
      "text": "The SRTCP IV for 128-bit block AES-f8 SHALL be formed in the following way:",
      "ja": "128ビットブロックAES-F8のSRTCP IVは次のようにして形成されます。"
    },
    {
      "indent": 3,
      "text": "IV= 0..0 || E || SRTCP index || V || P || RC || PT || length || SSRC",
      "ja": "iv = 0..0"
    },
    {
      "indent": 3,
      "text": "where V, P, RC, PT, length, SSRC SHALL be taken from the first header in the RTCP compound packet. E and SRTCP index are the 1-bit and 31-bit fields added to the packet.",
      "ja": "V、P、RC、PT、長さ、SSRCは、RTCP複合パケットの最初のヘッダーから取得されます。EとSRTCP Indexは、パケットに追加された1ビットフィールドと31ビットのフィールドです。"
    },
    {
      "indent": 0,
      "text": "4.1.3. NULL Cipher",
      "section_title": true,
      "ja": "4.1.3. ヌルシニカ"
    },
    {
      "indent": 3,
      "text": "The NULL cipher is used when no confidentiality for RTP/RTCP is requested. The keystream can be thought of as \"000..0\", i.e., the encryption SHALL simply copy the plaintext input into the ciphertext output.",
      "ja": "NULL暗号は、RTP / RTCPの機密性が要求されていない場合に使用されます。キーストリームは「000..0」と考えることができます。すなわち、暗号化は単に暗号文出力に平文の入力を単にコピーするだけでよい。"
    },
    {
      "indent": 0,
      "text": "4.2. Message Authentication and Integrity",
      "section_title": true,
      "ja": "4.2. メッセージ認証と整合性"
    },
    {
      "indent": 3,
      "text": "Throughout this section, M will denote data to be integrity protected. In the case of SRTP, M SHALL consist of the Authenticated Portion of the packet (as specified in Figure 1) concatenated with the ROC, M = Authenticated Portion || ROC; in the case of SRTCP, M SHALL consist of the Authenticated Portion (as specified in Figure 2) only.",
      "ja": "このセクションを通して、Mは整合性に保護されるデータを表します。SRTPの場合、Mは、ROC、M =認証部分と連結されたパケットの認証された部分（図1で指定）からなるものとする。"
    },
    {
      "indent": 3,
      "text": "Common parameters:",
      "ja": "一般的なパラメータ："
    },
    {
      "indent": 3,
      "text": "* AUTH_ALG is the authentication algorithm * k_a is the session message authentication key * n_a is the bit-length of the authentication key * n_tag is the bit-length of the output authentication tag * SRTP_PREFIX_LENGTH is the octet length of the keystream prefix as defined above, a parameter of AUTH_ALG",
      "ja": "* AUTH_ALGは認証アルゴリズムです* K_Aはセッションメッセージ認証キー* N_Aです。auth_algのパラメータ"
    },
    {
      "indent": 3,
      "text": "The distinct session authentication keys for SRTP/SRTCP are by default derived as specified in Section 4.3.",
      "ja": "SRTP / SRTCPのための異なるセッション認証キーは、セクション4.3で指定されているようにデフォルトで派生しています。"
    },
    {
      "indent": 3,
      "text": "The values of n_a, n_tag, and SRTP_PREFIX_LENGTH MUST be fixed for any particular fixed value of the key.",
      "ja": "n_a、n_tag、およびsrtp_prefix_lengthの値は、キーの特定の固定値に対して固定する必要があります。"
    },
    {
      "indent": 3,
      "text": "We describe the process of computing authentication tags as follows. The sender computes the tag of M and appends it to the packet. The SRTP receiver verifies a message/authentication tag pair by computing a new authentication tag over M using the selected algorithm and key, and then compares it to the tag associated with the received message. If the two tags are equal, then the message/tag pair is valid; otherwise, it is invalid and the error audit message \"AUTHENTICATION FAILURE\" MUST be returned.",
      "ja": "次のように認証タグを計算するプロセスについて説明します。送信者はMのタグを計算し、それをパケットに追加します。SRTP受信機は、選択されたアルゴリズムとキーを使用してMを介して新しい認証タグを計算してメッセージ/認証タグのペアを検証し、それを受信したメッセージに関連付けられたタグと比較します。2つのタグが等しい場合、メッセージ/タグのペアは有効です。それ以外の場合は無効で、エラー監査メッセージ「認証失敗」を返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.1. HMAC-SHA1",
      "section_title": true,
      "ja": "4.2.1. HMAC-SHA1"
    },
    {
      "indent": 3,
      "text": "The pre-defined authentication transform for SRTP is HMAC-SHA1 [RFC2104]. With HMAC-SHA1, the SRTP_PREFIX_LENGTH (Figure 3) SHALL be 0. For SRTP (respectively SRTCP), the HMAC SHALL be applied to the session authentication key and M as specified above, i.e., HMAC(k_a, M). The HMAC output SHALL then be truncated to the n_tag left-most bits.",
      "ja": "SRTPの事前定義された認証変換はHMAC-SHA1 [RFC2104]です。HMAC-SHA1では、SRTP_PREFIX_LENGTH（図3）は0とします.SRTP（それぞれSRTCP）では、HMACをセッション認証キーに適用し、すなわちHMAC（k_A、M）。その後、HMAC出力はN_TAGの左端のビットに切り捨てられます。"
    },
    {
      "indent": 0,
      "text": "4.3. Key Derivation",
      "section_title": true,
      "ja": "4.3. 鍵の派生"
    },
    {
      "indent": 0,
      "text": "4.3.1. Key Derivation Algorithm",
      "section_title": true,
      "ja": "4.3.1. キー派生アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Regardless of the encryption or message authentication transform that is employed (it may be an SRTP pre-defined transform or newly introduced according to Section 6), interoperable SRTP implementations MUST use the SRTP key derivation to generate session keys. Once the key derivation rate is properly signaled at the start of the session, there is no need for extra communication between the parties that use SRTP key derivation.",
      "ja": "採用されている暗号化またはメッセージ認証変換に関係なく（セクション6に従ってSRTP予め定義された変換または新しく導入されている可能性がある）、相互運用可能なSRTP実装はSRTPキー導出を使用してセッションキーを生成する必要があります。キー導出率がセッションの開始時に正しくシグナリングされると、SRTPキー導出を使用する当事者間の追加の通信が必要ない。"
    },
    {
      "indent": 15,
      "text": "          packet index ---+\n                          |\n                          v\n+-----------+ master  +--------+ session encr_key\n| ext       | key     |        |---------->\n| key mgmt  |-------->|  key   | session auth_key\n| (optional |         | deriv  |---------->\n| rekey)    |-------->|        | session salt_key\n|           | master  |        |---------->\n+-----------+ salt    +--------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 5: SRTP key derivation.",
      "ja": "図5：SRTPキーの派生"
    },
    {
      "indent": 3,
      "text": "At least one initial key derivation SHALL be performed by SRTP, i.e., the first key derivation is REQUIRED. Further applications of the key derivation MAY be performed, according to the \"key_derivation_rate\" value in the cryptographic context. The key derivation function SHALL initially be invoked before the first packet and then, when r > 0, a key derivation is performed whenever index mod r equals zero. This can be thought of as \"refreshing\" the session keys. The value of \"key_derivation_rate\" MUST be kept fixed for the lifetime of the associated master key.",
      "ja": "少なくとも1つの初期鍵導出は、SRTP、すなわち最初の鍵導出が必要とされなければならない。暗号化コンテキスト内の「key_delivation_rate」値に従って、鍵導出のさらなる用途を実行することができる。キー導出関数は最初のパケットの前に最初に呼び出され、次にR> 0のときに、索引MOD Rがゼロに等しいときはいつでもキー導出が実行される。これはセッションキーを「更新」すると考えることができます。「key_delivation_rate」の値は、関連付けられているマスターキーの有効期間に合わせて固定されている必要があります。"
    },
    {
      "indent": 3,
      "text": "Interoperable SRTP implementations MAY also derive session salting keys for encryption transforms, as is done in both of the pre-defined transforms.",
      "ja": "相互運用可能なSRTP実装はまた、予め定義された変換の両方で行われるように、暗号化変換のためのセッション給紙キーを導出する可能性がある。"
    },
    {
      "indent": 3,
      "text": "Let m and n be positive integers. A pseudo-random function family is a set of keyed functions {PRF_n(k,x)} such that for the (secret) random key k, given m-bit x, PRF_n(k,x) is an n-bit string, computationally indistinguishable from random n-bit strings, see [HAC]. For the purpose of key derivation in SRTP, a secure PRF with m = 128 (or more) MUST be used, and a default PRF transform is defined in Section 4.3.3.",
      "ja": "mとnを正の整数とする。疑似ランダム関数ファミリは、（秘密）random key kの場合、mビットx、prf_n（k、x）がnビット列であるように、{PRF_n（k、x）}のセットのセットです。ランダムなnビット文字列と計算的に区別がつづくと、[HAC]を参照してください。SRTPの鍵導出を目的として、M = 128（またはそれ以上）のセキュアPRFを使用する必要があり、4.3.3項でデフォルトのPRF変換が定義されています。"
    },
    {
      "indent": 3,
      "text": "Let \"a DIV t\" denote integer division of a by t, rounded down, and with the convention that \"a DIV 0 = 0\" for all a. We also make the convention of treating \"a DIV t\" as a bit string of the same length as a, and thus \"a DIV t\" will in general have leading zeros.",
      "ja": "「DIV T」を、丸みを帯びた、全体の「DIV 0 = 0」であるという条約との整数分割を示す。また、「a div t」の扱いは、Aと同じ長さのビット列として、一般に先行ゼロを持ちます。"
    },
    {
      "indent": 3,
      "text": "Key derivation SHALL be defined as follows in terms of <label>, an 8-bit constant (see below), master_salt and key_derivation_rate, as determined in the cryptographic context, and index, the packet index (i.e., the 48-bit ROC || SEQ for SRTP):",
      "ja": "キー導出は、暗号化コンテキスト、およびインデックス、パケットインデックス（すなわち、48ビットROC）で決定されるように、<ラベル>、8ビット定数（下記参照）、master_saltおよびkey_delivation_rateに関して次のように定義されなければならない。"
    },
    {
      "indent": 3,
      "text": "* Let r = index DIV key_derivation_rate (with DIV as defined above).",
      "ja": "* R = Index Div Key._Delivation_Rateを（上で定義されているようにDIV付き）。"
    },
    {
      "indent": 3,
      "text": "* Let key_id = <label> || r.",
      "ja": "* key_id = <label>"
    },
    {
      "indent": 3,
      "text": "* Let x = key_id XOR master_salt, where key_id and master_salt are aligned so that their least significant bits agree (right-alignment).",
      "ja": "* key_idおよびmaster_saltが最も整列され、最下位ビットが一致するように、x = key_id xor master_saltを整列させます。"
    },
    {
      "indent": 3,
      "text": "<label> MUST be unique for each type of key to be derived. We currently define <label> 0x00 to 0x05 (see below), and future extensions MAY specify new values in the range 0x06 to 0xff for other purposes. The n-bit SRTP key (or salt) for this packet SHALL then be derived from the master key, k_master as follows:",
      "ja": "<LABEL>は、派生する鍵の種類ごとに固有でなければなりません。現在<label> 0x00から0x05を定義します（下記参照）、将来の拡張子は他の目的で0x06から0xFFの範囲で新しい値を指定できます。このパケットのNビットSRTPキー（または塩）は、次のようにマスターキー、K_MASTERから導出されます。"
    },
    {
      "indent": 6,
      "text": "PRF_n(k_master, x).",
      "ja": "PRF_N（k_master、x）。"
    },
    {
      "indent": 3,
      "text": "(The PRF may internally specify additional formatting and padding of x, see e.g., Section 4.3.3 for the default PRF.)",
      "ja": "（PRFは、Xの追加のフォーマットとパディングを内部的に指定することができます。既定のPRFについては、例えば4.3.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The session keys and salt SHALL now be derived using:",
      "ja": "セッションキーと塩は次のものを使って導き出されます。"
    },
    {
      "indent": 3,
      "text": "- k_e (SRTP encryption): <label> = 0x00, n = n_e.",
      "ja": "- k_e（SRTP暗号化）：<label> = 0x00、n = n_e。"
    },
    {
      "indent": 3,
      "text": "- k_a (SRTP message authentication): <label> = 0x01, n = n_a.",
      "ja": "- K_A（SRTPメッセージ認証）：<label> = 0x01、n = n_a。"
    },
    {
      "indent": 3,
      "text": "- k_s (SRTP salting key): <label> = 0x02, n = n_s.",
      "ja": "- K_S（SRTP給台）：<label> = 0x02、n = n_s。"
    },
    {
      "indent": 3,
      "text": "where n_e, n_s, and n_a are from the cryptographic context.",
      "ja": "ここで、n_e、n_s、およびn_aは暗号化コンテキストからのものです。"
    },
    {
      "indent": 3,
      "text": "The master key and master salt MUST be random, but the master salt MAY be public.",
      "ja": "マスターキーとマスター塩はランダムでなければなりませんが、マスターソルトは公開されている可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that for a key_derivation_rate of 0, the application of the key derivation SHALL take place exactly once.",
      "ja": "key_delivation_rate 0の場合、キー導出のアプリケーションは正確に1回行われます。"
    },
    {
      "indent": 0,
      "text": " The definition of DIV above is purely for notational convenience. For a non-zero t among the set of allowed key derivation rates, \"a DIV t\" can be implemented as a right-shift by the base-2 logarithm of t. The derivation operation is further facilitated if the rates are chosen to be powers of 256, but that granularity was considered too coarse to be a requirement of this specification.",
      "ja": "上記のDIVの定義は純粋に表記上の利便性のためです。許容された鍵導出率のセットのうち、ゼロ以外のTの場合、「a div t」は、tの基本2対数によって右シフトとして実施することができる。レートが256の電力であるように選択されている場合、導出動作はさらに促進されるが、その粒度は粗大すぎると考えられていた。"
    },
    {
      "indent": 3,
      "text": "The upper limit on the number of packets that can be secured using the same master key (see Section 9.2) is independent of the key derivation.",
      "ja": "同じマスターキーを使用して固定できるパケット数の上限（セクション9.2参照）は、キー導出とは無関係です。"
    },
    {
      "indent": 0,
      "text": "4.3.2. SRTCP Key Derivation",
      "section_title": true,
      "ja": "4.3.2. SRTCPキーの派生"
    },
    {
      "indent": 3,
      "text": "SRTCP SHALL by default use the same master key (and master salt) as SRTP. To do this securely, the following changes SHALL be done to the definitions in Section 4.3.1 when applying session key derivation for SRTCP.",
      "ja": "SRTCPはデフォルトでSRTPとして同じマスターキー（およびマスターソルト）を使用します。これをしっかりとするために、SRTCPのセッションキー導出を適用する場合は、セクション4.3.1の定義に対して次の変更を行うものとします。"
    },
    {
      "indent": 3,
      "text": "Replace the SRTP index by the 32-bit quantity: 0 || SRTCP index (i.e., excluding the E-bit, replacing it with a fixed 0-bit), and use <label> = 0x03 for the SRTCP encryption key, <label> = 0x04 for the SRTCP authentication key, and, <label> = 0x05 for the SRTCP salting key.",
      "ja": "SRTPインデックスを32ビット数量で置き換える：0"
    },
    {
      "indent": 0,
      "text": "4.3.3. AES-CM PRF",
      "section_title": true,
      "ja": "4.3.3. AES-CM PRF"
    },
    {
      "indent": 3,
      "text": "The currently defined PRF, keyed by 128, 192, or 256 bit master key, has input block size m = 128 and can produce n-bit outputs for n up to 2^23. PRF_n(k_master,x) SHALL be AES in Counter Mode as described in Section 4.1.1, applied to key k_master, and IV equal to (x*2^16), and with the output keystream truncated to the n first (left-most) bits. (Requiring n/128, rounded up, applications of AES.)",
      "ja": "128,192、または256ビットマスターキーで入力されている現在定義されているPRFは、入力ブロックサイズM = 128を有し、最大2 ^ 23までのNビット出力を生成することができる。PRF_N（K_MASTER、X）は、4.1.1項に記載されているCART K_MASTER、およびIVに（X * 2 ^ 16）に等しく、出力キーストリームが最初に切り捨てられた（左（左）。ほとんどの）ビット。（N / 128を要求し、切り上げ、AESのアプリケーション。）"
    },
    {
      "indent": 0,
      "text": "5. Default and mandatory-to-implement Transforms",
      "section_title": true,
      "ja": "5. デフォルトおよび必須の変換"
    },
    {
      "indent": 3,
      "text": "The default transforms also are mandatory-to-implement transforms in SRTP. Of course, \"mandatory-to-implement\" does not imply \"mandatory-to-use\". Table 1 summarizes the pre-defined transforms. The default values below are valid for the pre-defined transforms.",
      "ja": "デフォルトの変換は、SRTPの必須の変換も行われます。もちろん、「必須の実装」は「使い捨て」を意味するものではありません。表1は、事前定義された変換を要約する。以下のデフォルト値は、事前定義の変換に有効です。"
    },
    {
      "indent": 25,
      "text": "mandatory-to-impl. optional default",
      "ja": "不可欠な指示オプションのデフォルト"
    },
    {
      "indent": 3,
      "text": "encryption AES-CM, NULL AES-f8 AES-CM message integrity HMAC-SHA1 - HMAC-SHA1 key derivation (PRF) AES-CM - AES-CM",
      "ja": "暗号化AES-CM、NULL AES-F8 AES-CMメッセージ整合性HMAC-SHA1  -  HMAC-SHA1キー派生（PRF）AES-CM  -  AES-CM"
    },
    {
      "indent": 3,
      "text": "Table 1: Mandatory-to-implement, optional and default transforms in SRTP and SRTCP.",
      "ja": "表1：SRTPとSRTCPの必須の実行、オプションおよびデフォルトの変換。"
    },
    {
      "indent": 0,
      "text": "5.1. Encryption: AES-CM and NULL",
      "section_title": true,
      "ja": "5.1. 暗号化：AES-CMとNULL"
    },
    {
      "indent": 3,
      "text": "AES running in Segmented Integer Counter Mode, as defined in Section 4.1.1, SHALL be the default encryption algorithm. The default key lengths SHALL be 128-bit for the session encryption key (n_e). The default session salt key-length (n_s) SHALL be 112 bits.",
      "ja": "セクション4.1.1で定義されているように、セグメント化された整数カウンタモードで実行されているAESは、デフォルトの暗号化アルゴリズムとする。デフォルトのキー長は、セッション暗号化キー（N_E）に対して128ビットになります。デフォルトのセッションSALTキー長（N_S）は112ビットになります。"
    },
    {
      "indent": 3,
      "text": "The NULL cipher SHALL also be mandatory-to-implement.",
      "ja": "NULL暗号はまた必須の実施とするものとします。"
    },
    {
      "indent": 0,
      "text": "5.2. Message Authentication/Integrity: HMAC-SHA1",
      "section_title": true,
      "ja": "5.2. メッセージ認証/整合性：HMAC-SHA1"
    },
    {
      "indent": 3,
      "text": "HMAC-SHA1, as defined in Section 4.2.1, SHALL be the default message authentication code. The default session authentication key-length (n_a) SHALL be 160 bits, the default authentication tag length (n_tag) SHALL be 80 bits, and the SRTP_PREFIX_LENGTH SHALL be zero for HMAC-SHA1. In addition, for SRTCP, the pre-defined HMAC-SHA1 MUST NOT be applied with a value of n_tag, nor n_a, that are smaller than these defaults. For SRTP, smaller values are NOT RECOMMENDED, but MAY be used after careful consideration of the issues in Section 7.5 and 9.5.",
      "ja": "セクション4.2.1で定義されているように、HMAC-SHA1は、デフォルトのメッセージ認証コードとなります。デフォルトのセッション認証キー長（N_A）は160ビットとすると、デフォルトの認証タグ長（N_TAG）は80ビットとなり、SRTP_PREFIX_LENGTHはHMAC-SHA1に対してゼロとなります。さらに、SRTCPの場合、事前定義されたHMAC-SHA1には、これらのデフォルトよりも小さいN_TAG、N_Aの値で適用してはいけません。SRTPの場合、小さい値はお勧めできませんが、7.5節と9.5の問題を慎重に検討しても使用できます。"
    },
    {
      "indent": 0,
      "text": "5.3. Key Derivation: AES-CM PRF",
      "section_title": true,
      "ja": "5.3. キー導出：AES-CM PRF"
    },
    {
      "indent": 3,
      "text": "The AES Counter Mode based key derivation and PRF defined in Sections 4.3.1 to 4.3.3, using a 128-bit master key, SHALL be the default method for generating session keys. The default master salt length SHALL be 112 bits and the default key-derivation rate SHALL be zero.",
      "ja": "128ビットマスターキーを使用して、セクション4.3.1から4.3.3で定義されているAESカウンタモードベースのキー導出とPRFは、セッションキーを生成するためのデフォルトの方法となります。デフォルトのマスター塩の長さは112ビットでなければならず、デフォルトのキー派生率はゼロになります。"
    },
    {
      "indent": 0,
      "text": "6. Adding SRTP Transforms",
      "section_title": true,
      "ja": "6. SRTP変換の追加"
    },
    {
      "indent": 3,
      "text": "Section 4 provides examples of the level of detail needed for defining transforms. Whenever a new transform is to be added to SRTP, a companion standard track RFC MUST be written to exactly define how the new transform can be used with SRTP (and SRTCP). Such a companion RFC SHOULD avoid overlap with the SRTP protocol document. Note however, that it MAY be necessary to extend the SRTP or SRTCP cryptographic context definition with new parameters (including fixed or default values), add steps to the packet processing, or even add fields to the SRTP/SRTCP packets. The companion RFC SHALL explain any known issues regarding interactions between the transform and other aspects of SRTP.",
      "ja": "第4章では、変換を定義するために必要な詳細レベルの例を示します。SRTPに新しい変換を追加する場合は、Companion標準トラックRFCを書き込むには、SRTP（およびSRTCP）で新しい変換を使用できる方法を正確に定義する必要があります。そのようなコンパニオンRFCはSRTPプロトコル文書と重複を避けるべきです。ただし、SRTPまたはSRTCP暗号化コンテキスト定義を新しいパラメータ（固定値またはデフォルト値を含む）で拡張し、パケット処理に手順を追加したり、SRTP / SRTCPパケットにフィールドを追加したりする必要がある場合があります。コンパニオンRFCは、変換とSRTPの他の側面との間の相互作用に関する既知の問題を説明しなければならない。"
    },
    {
      "indent": 3,
      "text": "Each new transform document SHOULD specify its key attributes, e.g., size of keys (minimum, maximum, recommended), format of keys, recommended/required processing of input keying material, requirements/recommendations on key lifetime, re-keying and key derivation, whether sharing of keys between SRTP and SRTCP is allowed or not, etc.",
      "ja": "新しい変換文書は、そのキー属性、例えば、キーのサイズ（最小、最大、推奨）、キーの形式、推奨/必要な入力キーワード、要件/推奨事項、再キーイング、キー導出、鍵導出など、SRTPとSRTCP間のキーの共有が許可されているかどうかなど"
    },
    {
      "indent": 3,
      "text": "An added message integrity transform SHOULD define a minimum acceptable key/tag size for SRTCP, equivalent in strength to the minimum values as defined in Section 5.2.",
      "ja": "追加されたメッセージ整合性変換は、SRTCPのための最小許容鍵/タグサイズを定義し、セクション5.2で定義されている最小値に等価な値を定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Rationale",
      "section_title": true,
      "ja": "7. 根拠"
    },
    {
      "indent": 3,
      "text": "This section explains the rationale behind several important features of SRTP.",
      "ja": "このセクションでは、SRTPのいくつかの重要な機能の背後にある根拠について説明します。"
    },
    {
      "indent": 0,
      "text": "7.1. Key derivation",
      "section_title": true,
      "ja": "7.1. 鍵の派生"
    },
    {
      "indent": 3,
      "text": "Key derivation reduces the burden on the key establishment. As many as six different keys are needed per crypto context (SRTP and SRTCP encryption keys and salts, SRTP and SRTCP authentication keys), but these are derived from a single master key in a cryptographically secure way. Thus, the key management protocol needs to exchange only one master key (plus master salt when required), and then SRTP itself derives all the necessary session keys (via the first, mandatory application of the key derivation function).",
      "ja": "キーの派生キー設立の負担を軽減します。Cryptoコンテキスト（SRTPとSRTCP暗号化キーとSRTS、SRTP認証キーとSRTCP認証キー）ごとに必要なさまざまなキーが必要ですが、これらは暗号的に安全な方法で単一のマスターキーから導出されます。したがって、鍵管理プロトコルは1つのマスターキー（必要なときにマスターソルト）のみを交換する必要があり、SRTP自体はすべての必要なセッションキーを派生させます（最初の派生機能の必須のアプリケーションを介して）。"
    },
    {
      "indent": 3,
      "text": "Multiple applications of the key derivation function are optional, but will give security benefits when enabled. They prevent an attacker from obtaining large amounts of ciphertext produced by a single fixed session key. If the attacker was able to collect a large amount of ciphertext for a certain session key, he might be helped in mounting certain attacks.",
      "ja": "キー導出関数の複数のアプリケーションはオプションですが、有効になっている場合はセキュリティ上の利点があります。彼らは、攻撃者が単一の固定セッション鍵によって生成された大量の暗号文を得ることを防ぎます。攻撃者が特定のセッション鍵のために大量の暗号文を集めることができた場合、彼は特定の攻撃を取り付けるのに役立つかもしれません。"
    },
    {
      "indent": 3,
      "text": "Multiple applications of the key derivation function provide backwards and forward security in the sense that a compromised session key does not compromise other session keys derived from the same master key. This means that the attacker who is able to recover a certain session key, is anyway not able to have access to messages secured under previous and later session keys (derived from the same master key). (Note that, of course, a leaked master key reveals all the session keys derived from it.)",
      "ja": "キー導出関数の複数のアプリケーションは、妥協のあるセッションキーが同じマスターキーから派生した他のセッションキーを損なわないという意味で、後方と転送セキュリティを提供します。つまり、特定のセッションキーを回復できる攻撃者は、前後のセッションキー（同じマスターキーから派生した）の下に保護されたメッセージにアクセスできないことを意味します。（もちろん、リークされたマスターキーはそれから派生したすべてのセッションキーを明らかにすることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Considerations arise with high-rate key refresh, especially in large multicast settings, see Section 11.",
      "ja": "特に大規模なマルチキャスト設定では、高速キーのリフレッシュで考慮して考慮してください。セクション11を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Salting key",
      "section_title": true,
      "ja": "7.2. 塩漬け鍵"
    },
    {
      "indent": 3,
      "text": "The master salt guarantees security against off-line key-collision attacks on the key derivation that might otherwise reduce the effective key size [MF00].",
      "ja": "マスターソルトは、そうでなければ効果的なキーサイズ[MF00]を減らすかもしれないキー導出に対するオフラインのキー衝突攻撃に対するセキュリティを保証します。"
    },
    {
      "indent": 3,
      "text": "The derived session salting key used in the encryption, has been introduced to protect against some attacks on additive stream ciphers, see Section 9.2. The explicit inclusion method of the salt in the IV has been selected for ease of hardware implementation.",
      "ja": "暗号化で使用された派生セッション給与鍵は、加法的ストリーム暗号に対するいくつかの攻撃から保護するために導入されています。セクション9.2を参照してください。IV内の塩の明示的な包含方法は、ハードウェア実装を容易にするために選択されています。"
    },
    {
      "indent": 0,
      "text": "7.3. Message Integrity from Universal Hashing",
      "section_title": true,
      "ja": "7.3. Universal Hashingからのメッセージの整合性"
    },
    {
      "indent": 3,
      "text": "The particular definition of the keystream given in Section 4.1 (the keystream prefix) is to give provision for particular universal hash functions, suitable for message authentication in the Wegman-Carter paradigm [WC81]. Such functions are provably secure, simple, quick, and especially appropriate for Digital Signal Processors and other processors with a fast multiply operation.",
      "ja": "セクション4.1（キーストリームプレフィックス）に示すキーストリームの特定の定義は、Wegman-Carter Paradigm [WC81]のメッセージ認証に適した特定のユニバーサルハッシュ関数を提供することです。そのような機能は、デジタル信号プロセッサや他のプロセッサには、高速な乗算操作を備えた他のプロセッサには、特に安全で、簡単、迅速で、特に適しています。"
    },
    {
      "indent": 3,
      "text": "No authentication transforms are currently provided in SRTP other than HMAC-SHA1. Future transforms, like the above mentioned universal hash functions, MAY be added following the guidelines in Section 6.",
      "ja": "HMAC-SHA1以外のSRTPで現在認証変換は提供されていません。将来の変換は、上述のユニバーサルハッシュ関数のような将来の変換を、セクション6のガイドラインに従って追加することができる。"
    },
    {
      "indent": 0,
      "text": "7.4. Data Origin Authentication Considerations",
      "section_title": true,
      "ja": "7.4. データオリジナル認証に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Note that in pair-wise communications, integrity and data origin authentication are provided together. However, in group scenarios where the keys are shared between members, the MAC tag only proves that a member of the group sent the packet, but does not prevent against a member impersonating another. Data origin authentication (DOA) for multicast and group RTP sessions is a hard problem that needs a solution; while some promising proposals are being investigated [PCST1] [PCST2], more work is needed to rigorously specify these technologies. Thus SRTP data origin authentication in groups is for further study.",
      "ja": "ペアワード通信では、整合性とデータの原点認証が一緒に提供されていることに注意してください。ただし、キーがメンバー間で共有されているグループシナリオでは、MACタグは、グループのメンバーがパケットを送信したが、別のメンバを偽装するのを防ぐことはできません。マルチキャストとグループRTPセッションのデータ原点認証（DOA）は、解を必要とするハードな問題です。いくつかの有望な提案が調査されているが[PCST1] [PCST2]、これらの技術を厳密に指定するために多くの作業が必要です。したがって、グループ内のSRTPデータの原点認証はさらなる研究のためのものです。"
    },
    {
      "indent": 3,
      "text": "DOA can be done otherwise using signatures. However, this has high impact in terms of bandwidth and processing time, therefore we do not offer this form of authentication in the pre-defined packet-integrity transform.",
      "ja": "署名を使用してDOAを実行できます。ただし、これは帯域幅と処理時間の点で大きな影響を及ぼします。したがって、定義されたパケット整合性変換でこの形式の認証を提供しません。"
    },
    {
      "indent": 3,
      "text": "The presence of mixers and translators does not allow data origin authentication in case the RTP payload and/or the RTP header are manipulated. Note that these types of middle entities also disrupt end-to-end confidentiality (as the IV formation depends e.g., on the RTP header preservation). A certain trust model may choose to trust the mixers/translators to decrypt/re-encrypt the media (this would imply breaking the end-to-end security, with related security implications).",
      "ja": "RTPペイロードおよび/またはRTPヘッダーが操作されている場合、ミキサーとトランスレータの存在はデータの原点認証を許可しません。これらのタイプの中間体はまた、（IV形成が例えばRTPヘッダ保存に依存するので）エンドツーエンドの機密性を妨害することに留意されたい。特定の信頼モデルは、メディアを復号化/再暗号化するためにミキサー/翻訳者を信頼することを選択することができます（これは、関連するセキュリティの影響を伴うエンドツーエンドのセキュリティを壊すことになります）。"
    },
    {
      "indent": 0,
      "text": "7.5. Short and Zero-length Message Authentication",
      "section_title": true,
      "ja": "7.5. 短くゼロのメッセージ認証"
    },
    {
      "indent": 3,
      "text": "As shown in Figure 1, the authentication tag is RECOMMENDED in SRTP. A full 80-bit authentication-tag SHOULD be used, but a shorter tag or even a zero-length tag (i.e., no message authentication) MAY be used under certain conditions to support either of the following two application environments.",
      "ja": "図1に示すように、認証タグはSRTPで推奨されています。完全な80ビット認証タグを使用する必要がありますが、タグまたはゼロ長タグ（すなわち、メッセージ認証なし）を特定の条件下で使用して、次の2つのアプリケーション環境をサポートすることができます。"
    },
    {
      "indent": 6,
      "text": "1. Strong authentication can be impractical in environments where bandwidth preservation is imperative. An important special case is wireless communication systems, in which bandwidth is a scarce and expensive resource. Studies have shown that for certain applications and link technologies, additional bytes may result in a significant decrease in spectrum efficiency [SWO]. Considerable effort has been made to design IP header compression techniques to improve spectrum efficiency [RFC3095]. A typical voice application produces 20 byte samples, and the RTP, UDP and IP headers need to be jointly compressed to one or two bytes on average in order to obtain acceptable wireless bandwidth economy [RFC3095]. In this case, strong authentication would impose nearly fifty percent overhead.",
      "ja": "1. 帯域幅の保存が不可欠である環境では、強力な認証を非実用化できます。重要な特別なケースは無線通信システムであり、帯域幅は希少性で高価なリソースです。研究によると、特定のアプリケーションやリンク技術では、追加のバイトがスペクトル効率の大幅な減少をもたらす可能性があることがわかりました[SWO]。スペクトル効率を改善するためにIPヘッダ圧縮技術を設計するためにかなりの努力がなされてきた[RFC3095]。典型的な音声アプリケーションは20バイトのサンプルを生成し、許容できる無線帯域幅経済を得るために、RTP、UDP、およびIPヘッダーを平均して1バイトまたは2バイトに共同圧縮する必要があります[RFC3095]。この場合、強い認証は約50パーセントのオーバーヘッドを課すでしょう。"
    },
    {
      "indent": 6,
      "text": "2. Authentication is impractical for applications that use data links with fixed-width fields that cannot accommodate the expansion due to the authentication tag. This is the case for some important existing wireless channels. For example, zero-byte header compression is used to adapt EVRC/SMV voice with the legacy IS-95 bearer channel in CDMA2000 VoIP services. It was found that not a single additional octet could be added to the data, which motivated the creation of a zero-byte profile for ROHC [RFC3242].",
      "ja": "2. 認証タグによる拡大に対応できない固定幅フィールドを持つデータリンクを使用するアプリケーションには認証が実用化されていません。これはいくつかの重要な既存の無線チャネルの場合です。たとえば、ゼロバイトヘッダー圧縮は、CDMA2000 VoIPサービスのレガシーIS-95ベアラチャネルでEVRC / SMVボイスをレガシーで調整するために使用されます。ROHCのゼロバイトプロファイルの作成を動機づけたデータに単一の追加オクテットを追加することができたことがわかりました[RFC3242]。"
    },
    {
      "indent": 3,
      "text": "A short tag is secure for a restricted set of applications. Consider a voice telephony application, for example, such as a G.729 audio codec with a 20-millisecond packetization interval, protected by a 32-bit message authentication tag. The likelihood of any given packet being successfully forged is only one in 2^32. Thus an adversary can control no more than 20 milliseconds of audio output during a 994-day period, on average. In contrast, the effect of a single forged packet can be much larger if the application is stateful. A codec that uses relative or predictive compression across packets will propagate the maliciously generated state, affecting a longer duration of output.",
      "ja": "短いタグは、制限されたアプリケーションセットに対して安全です。32ビットメッセージ認証タグによって保護された、20ミリ秒のパケット化間隔を備えたG.729オーディオコーデックなどの音声テレフォニーアプリケーションを検討してください。任意の与えられたパケットが求められている可能性は、2 ^ 32に1つだけです。したがって、敵対者は、平均して994日間に20ミリ秒のオーディオ出力を制御することができます。対照的に、アプリケーションがステートフルである場合、単一の偽造パケットの効果ははるかに大きくなる可能性があります。パケット間で相対的または予測的な圧縮を使用するコーデックは、悪意を持って生成された状態を伝播し、より長い出力期間に影響します。"
    },
    {
      "indent": 3,
      "text": "Certainly not all SRTP or telephony applications meet the criteria for short or zero-length authentication tags. Section 9.5.1 discusses the risks of weak or no message authentication, and section 9.5 describes the circumstances when it is acceptable and when it is unacceptable.",
      "ja": "確かに、すべてのSRTPまたはテレフォニーアプリケーションが短いまたはゼロの認証タグの基準を満たすわけではありません。セクション9.5.1は、メッセージ認証の弱いまたはNOのリスクについて説明し、セクション9.5は許容されているときとそれが受け入れられないときの状況を説明しています。"
    },
    {
      "indent": 0,
      "text": "8. Key Management Considerations",
      "section_title": true,
      "ja": "8. 主な管理に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There are emerging key management standards [MIKEY] [KEYMGT] [SDMS] for establishing an SRTP cryptographic context (e.g., an SRTP master key). Both proprietary and open-standard key management methods are likely to be used for telephony applications [MIKEY] [KINK] and multicast applications [GDOI]. This section provides guidance for key management systems that service SRTP session.",
      "ja": "SRTP暗号化コンテキスト（例えばSRTPマスターキー）を確立するための新たな鍵管理規格[Mikey] [SDMS]があります。独自の鍵管理方法とオープンスタンダードの両方の鍵管理方法は、テレフォニーアプリケーション[Mikey] [Kink]とマルチキャストアプリケーションで使用される可能性があります[Gdoi]。このセクションでは、SRTPセッションをサービスするキー管理システムのガイダンスについて説明します。"
    },
    {
      "indent": 3,
      "text": "For initialization, an interoperable SRTP implementation SHOULD be given the SSRC and MAY be given the initial RTP sequence number for the RTP stream by key management (thus, key management has a dependency on RTP operational parameters). Sending the RTP sequence number in the key management may be useful e.g., when the initial sequence number is close to wrapping (to avoid synchronization problems), and to communicate the current sequence number to a joining endpoint (to properly initialize its replay list).",
      "ja": "初期化のために、相互運用可能なSRTP実装にSSRCを与えられ、鍵管理によってRTPストリームの初期RTPシーケンス番号が与えられてもよい（したがって、鍵管理はRTP運用パラメータに依存します）。キー管理内のRTPシーケンス番号を送信することは、（同期の問題を回避するために）初期シーケンス番号が折り返し（同期の問題を回避するために）に近い場合、現在のシーケンス番号を（再生リストを適切に初期化するために）現在のシーケンス番号を通信することができる。"
    },
    {
      "indent": 3,
      "text": "If the pre-defined transforms are used, SRTP allows sharing of the same master key between SRTP/SRTCP streams belonging to the same RTP session.",
      "ja": "事前定義された変換が使用されている場合、SRTPは同じRTPセッションに属するSRTP / SRTCPストリーム間の同じマスターキーを共有することを可能にします。"
    },
    {
      "indent": 3,
      "text": "First, sharing between SRTP streams belonging to the same RTP session is secure if the design of the synchronization mechanism, i.e., the IV, avoids keystream re-use (the two-time pad, Section 9.1). This is taken care of by the fact that RTP provides for unique SSRCs for streams belonging to the same RTP session. See Section 9.1 for further discussion.",
      "ja": "第1に、同期メカニズムの設計、すなわちIVがキーストリーム再利用を回避する場合、同じRTPセッションに属するSRTPストリーム間の共有は安全である（2タイムパッド、セクション9.1）。これは、RTPが同じRTPセッションに属するストリームのための固有のSSRCを提供するという事実によって治療されます。さらなる議論についてはセクション9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Second, sharing between SRTP and the corresponding SRTCP is secure. The fact that an SRTP stream and its associated SRTCP stream both carry the same SSRC does not constitute a problem for the two-time pad due to the key derivation. Thus, SRTP and SRTCP corresponding to one RTP session MAY share master keys (as they do by default).",
      "ja": "第二に、SRTPと対応するSRTCP間の共有は安全です。SRTPストリームとその関連するSRTCPストリームが同じSSRCを搬送するという事実は、キー導出による2タイムパッドの問題を構成しません。したがって、1つのRTPセッションに対応するSRTPおよびSRTCPは、マスターキーを共有することがあります（デフォルトで行うため）。"
    },
    {
      "indent": 0,
      "text": " Note that message authentication also has a dependency on SSRC uniqueness that is unrelated to the problem of keystream reuse: SRTP streams authenticated under the same key MUST have a distinct SSRC in order to identify the sender of the message. This requirement is needed because the SSRC is the cryptographically authenticated field used to distinguish between different SRTP streams. Were two streams to use identical SSRC values, then an adversary could substitute messages from one stream into the other without detection.",
      "ja": "メッセージ認証は、キーストリーム再利用の問題とは無関係のSSRCの一意性にも依存していることに注意してください。同じキーの下で認証されたSRTP Streamは、メッセージの送信者を識別するために異なるSSRCを持つ必要があります。SSRCは、異なるSRTPストリームを区別するために使用される暗号化認証フィールドであるため、この要件が必要です。同一のSSRC値を使用するための2つのストリームで、敵対者は検出なしであるストリームから他のストリームへのメッセージを代替することができました。"
    },
    {
      "indent": 3,
      "text": "SRTP/SRTCP MUST NOT share master keys under any other circumstances than the ones given above, i.e., between SRTP and its corresponding SRTCP, and, between streams belonging to the same RTP session.",
      "ja": "SRTP / SRTCPは、上記のもの、すなわちSRTPとそれに対応するSRTCPとの間、および同じRTPセッションに属するストリーム間で、他の状況下でマスターキーを共有してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.1. Re-keying",
      "section_title": true,
      "ja": "8.1. 再キーイング"
    },
    {
      "indent": 3,
      "text": "The recommended way for a particular key management system to provide re-key within SRTP is by associating a master key in a crypto context with an MKI.",
      "ja": "特定の鍵管理システムがSRTP内に再キーを提供するための推奨される方法は、マスターキーを暗号コンテキストにMKIと関連付けることである。"
    },
    {
      "indent": 3,
      "text": "This provides for easy master key retrieval (see Scenarios in Section 11), but has the disadvantage of adding extra bits to each packet. As noted in Section 7.5, some wireless links do not cater for added bits, therefore SRTP also defines a more economic way of triggering re-keying, via use of <From, To>, which works in some specific, simple scenarios (see Section 8.1.1).",
      "ja": "これは簡単なマスターキーの検索を提供します（セクション11のシナリオを参照）、各パケットに余分なビットを追加するという欠点があります。セクション7.5に記載されているように、いくつかの無線リンクは追加ビットに対応しないため、SRTPは<FROM、TO>の使用を介して再キーイングを引き起こすより多くの経済的な方法を定義します。これは、特定の単純なシナリオで機能します（セクションを参照）。8.1.1）。"
    },
    {
      "indent": 3,
      "text": "SRTP senders SHALL count the amount of SRTP and SRTCP traffic being used for a master key and invoke key management to re-key if needed (Section 9.2). These interactions are defined by the key management interface to SRTP and are not defined by this protocol specification.",
      "ja": "SRTP送信者は、マスターキーに使用されているSRTPとSRTCPトラフィックの量を数えるものとし、必要に応じてキー管理を再キーに戻します（セクション9.2）。これらのインタラクションは、鍵管理インターフェースによってSRTPに定義され、このプロトコル仕様によって定義されていません。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Use of the <From, To> for re-keying",
      "section_title": true,
      "ja": "8.1.1. 再キーイングのための<from、to>の使用"
    },
    {
      "indent": 3,
      "text": "In addition to the use of the MKI, SRTP defines another optional mechanism for master key retrieval, the <From, To>. The <From, To> specifies the range of SRTP indices (a pair of sequence number and ROC) within which a certain master key is valid, and is (when used) part of the crypto context. By looking at the 48-bit SRTP index of the current SRTP packet, the corresponding master key can be found by determining which From-To interval it belongs to. For SRTCP, the most recently observed/used SRTP index (which can be obtained from the cryptographic context) is used for this purpose, even though SRTCP has its own (31-bit) index (see caveat below).",
      "ja": "MKIの使用に加えて、SRTPはマスターキー検索、<FROM、TO>の別のオプションメカニズムを定義します。<from、to>は、特定のマスターキーが有効であるSRTPインデックス（シーケンス番号とROCペア）の範囲を指定し、暗号コンテキストの一部です。現在のSRTPパケットの48ビットSRTPインデックスを見ると、対応するマスターキーは、どのから間隔が属するかを判断することによって見つけることができます。SRTCPの場合、SRTCPには独自の（31ビット）インデックスがある場合でも、この目的のために最後に観察された/使用されているSRTPインデックスがこの目的のために使用されます（警告を参照）。"
    },
    {
      "indent": 0,
      "text": " This method, compared to the MKI, has the advantage of identifying the master key and defining its lifetime without adding extra bits to each packet. This could be useful, as already noted, for some wireless links that do not cater for added bits. However, its use SHOULD be limited to specific, very simple scenarios. We recommend to limit its use when the RTP session is a simple unidirectional or bi-directional stream. This is because in case of multiple streams, it is difficult to trigger the re-key based on the <From, To> of a single RTP stream. For example, if several streams share a master key, there is no simple one-to-one correspondence between the index sequence space of a certain stream, and the index sequence space on which the <From, To> values are based. Consequently, when a master key is shared between streams, one of these streams MUST be designated by key management as the one whose index space defines the re-keying points. Also, the re-key triggering on SRTCP is based on the correspondent SRTP stream, i.e., when the SRTP stream changes the master key, so does the correspondent SRTCP. This becomes obviously more and more complex with multiple streams.",
      "ja": "この方法は、MKIと比較して、各パケットに余分なビットを追加することなく、マスターキーを識別し、その寿命を定義するという利点を有する。これは、追加されたビットに対応しない一部の無線リンクについて、すでに注目されているように、便利である可能性があります。ただし、その使用は特定の非常に単純なシナリオに限定されるべきです。 RTPセッションが単純な一方向または双方向のストリームである場合は、その使用を制限することをお勧めします。これは、複数のストリームの場合、単一のRTPストリームの<from、to>に基づいて再キーを起動することは困難です。例えば、複数のストリームがマスターキーを共有している場合、特定のストリームのインデックスシーケンススペースと、<FROM、To>値が基づいているインデックスシーケンススペースとの間に単純な1対1対応の対応はない。したがって、マスターキーがストリーム間で共有されると、これらのストリームのうちの1つは、索引スペースが再キーイングポイントを定義するものとして鍵管理によって指定されなければなりません。また、SRTCP上での再キートリガは、対応したSRTPストリーム、すなわちSRTPストリームがマスターキーを変更するときに、対応するSRTCPに基づいている。これは明らかに複数のストリームとより複雑になります。"
    },
    {
      "indent": 3,
      "text": "The default values for the <From, To> are \"from the first observed packet\" and \"until further notice\". However, the maximum limit of SRTP/SRTCP packets that are sent under each given master/session key (Section 9.2) MUST NOT be exceeded.",
      "ja": "<from、to>のデフォルト値は、「最初の観測パケットから」、「さらなる通知まで」です。ただし、特定のマスター/セッションキー（セクション9.2）の下で送信されるSRTP / SRTCPパケットの最大制限を超えてはいけません。"
    },
    {
      "indent": 3,
      "text": "In case the <From, To> is used as key retrieval, then the MKI is not inserted in the packet (and its indicator in the crypto context is zero). However, using the MKI does not exclude using <From, To> key lifetime simultaneously. This can for instance be useful to signal at the sender side at which point in time an MKI is to be made active.",
      "ja": "<from、to>がキー検索として使用される場合、MKIはパケットに挿入されていません（そして暗号コンテキスト内のそのインジケータはゼロです）。ただし、MKIを使用すると、<from、to> key lifetimeを同時に除外しません。これは、例えば、MKIが活性化される時点で送信者側で信号を送信するのに有用であり得る。"
    },
    {
      "indent": 0,
      "text": "8.2. Key Management parameters",
      "section_title": true,
      "ja": "8.2. 鍵管理パラメータ"
    },
    {
      "indent": 3,
      "text": "The table below lists all SRTP parameters that key management can supply. For reference, it also provides a summary of the default and mandatory-to-support values for an SRTP implementation as described in Section 5.",
      "ja": "以下の表は、鍵管理が提供できるすべてのSRTPパラメータを示しています。参考のために、セクション5で説明されているように、SRTP実装のデフォルトおよび必須の値の概要も提供します。"
    },
    {
      "indent": 3,
      "text": "Parameter                     Mandatory-to-support    Default\n---------                     --------------------    -------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SRTP and SRTCP encr transf. AES_CM, NULL AES_CM (Other possible values: AES_f8)",
      "ja": "SRTPとSRTCP ENCR TRANSF。AES_CM、NULL AES_CM（その他の可能な値：AES_F8）"
    },
    {
      "indent": 3,
      "text": "SRTP and SRTCP auth transf. HMAC-SHA1 HMAC-SHA1",
      "ja": "SRTPとSRTCP認証トランスF。HMAC-SHA1 HMAC-SHA1"
    },
    {
      "indent": 3,
      "text": "SRTP and SRTCP auth params: n_tag (tag length) 80 80 SRTP prefix_length 0 0",
      "ja": "SRTPとSRTCP AUTH PARAMS：N_TAG（タグ長）80 80 SRTP prefix_length 0 0"
    },
    {
      "indent": 3,
      "text": "Key derivation PRF AES_CM AES_CM",
      "ja": "キー派生PRF AES_CM AES_CM"
    },
    {
      "indent": 3,
      "text": "Key material params (for each master key): master key length 128 128 n_e (encr session key length) 128 128 n_a (auth session key length) 160 160 master salt key length of the master salt 112 112 n_s (session salt key length) 112 112 key derivation rate 0 0",
      "ja": "キーマテリアルパラメータ（各マスターキーの場合）：マスターキー長128 128 N_E（ENCR SESSIONキー長）128 128 N_A（AUTHセッションキー長）160 160 160マスターソルトキー長112 112 N_S（セッション塩キー長）112 112キー導出率0 0."
    },
    {
      "indent": 5,
      "text": "key lifetime SRTP-packets-max-lifetime 2^48 2^48 SRTCP-packets-max-lifetime 2^31 2^31 from-to-lifetime <From, To> MKI indicator 0 0 length of the MKI 0 0 value of the MKI",
      "ja": "キーライフタイムSRTP-Packets-Max-Lifetime 2 ^ 48 2 ^ 48 SRTCP-Packets-Max-Lifetime 2 ^ 31 2 31からLiftime <From、To> MKIインジケータ0 0 mki 0 0 0 0MKI."
    },
    {
      "indent": 3,
      "text": "Crypto context index params: SSRC value ROC SEQ SRTCP Index Transport address Port number",
      "ja": "Cryptoコンテキストインデックスparams：SSRC値ROC SEQ SRTCPインデックストランスポートアドレスポート番号"
    },
    {
      "indent": 3,
      "text": "Relation to other RTP profiles: sender's order between FEC and SRTP FEC-SRTP FEC-SRTP (see Section 10)",
      "ja": "他のRTPプロファイルとの関係：FECとSRTP FEC-SRTP FEC-SRTPの間の送信者の順序（セクション10を参照）"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. SSRC collision and two-time pad",
      "section_title": true,
      "ja": "9.1. SSRCの衝突と2回のパッド"
    },
    {
      "indent": 3,
      "text": "Any fixed keystream output, generated from the same key and index MUST only be used to encrypt once. Re-using such keystream (jokingly called a \"two-time pad\" system by cryptographers), can seriously compromise security. The NSA's VENONA project [C99] provides a historical example of such a compromise. It is REQUIRED that automatic key management be used for establishing and maintaining SRTP and SRTCP keying material; this requirement is to avoid keystream reuse, which is more likely to occur with manual key management. Furthermore, in SRTP, a \"two-time pad\" is avoided by requiring the key, or some other parameter of cryptographic significance, to be unique per RTP/RTCP stream and packet. The pre-defined SRTP transforms accomplish packet-uniqueness by including the packet index and stream-uniqueness by inclusion of the SSRC.",
      "ja": "同じキーとインデックスから生成された固定キーストリーム出力は、一度暗号化するためにのみ使用されている必要があります。そのようなキーストリーム（冗談を暗号化された「2タイムパッド」システムと呼ばれる）を再利用すると、セキュリティを深刻に侵害することができます。NSAのVenona Project [C99]はそのような妥協の歴史的な例を提供します。自動鍵管理は、SRTPおよびSRTCPキーイング材料の確立および維持に使用されることが必要です。この要件はキーストリームの再利用を回避することであり、手動キー管理で発生する可能性が高いです。さらに、SRTPでは、RTP / RTCPストリームおよびパケットごとにユニットになるように、キー、または暗号的有意性の他のパラメータを必要とすることによって「2タイムパッド」が回避される。事前定義されたSRTP変換は、SSRCを含めることによってパケットインデックスとストリーム一意性を含むことによってパケット一意性を変換する。"
    },
    {
      "indent": 3,
      "text": "The pre-defined transforms (AES-CM and AES-f8) allow master keys to be shared across streams belonging to the same RTP session by the inclusion of the SSRC in the IV. A master key MUST NOT be shared among different RTP sessions.",
      "ja": "事前定義された変換（AES-CMおよびAES-F8）は、IV内のSSRCを含めることによって、同じRTPセッションに属するストリーム間でマスターキーを共有することができます。マスターキーは、さまざまなRTPセッション間で共有されてはいけません。"
    },
    {
      "indent": 3,
      "text": "Thus, the SSRC MUST be unique between all the RTP streams within the same RTP session that share the same master key. RTP itself provides an algorithm for detecting SSRC collisions within the same RTP session. Thus, temporary collisions could lead to temporary two-time pad, in the unfortunate event that SSRCs collide at a point in time when the streams also have identical sequence numbers (occurring with probability roughly 2^(-48)). Therefore, the key management SHOULD take care of avoiding such SSRC collisions by including the SSRCs to be used in the session as negotiation parameters, proactively assuring their uniqueness. This is a strong requirements in scenarios where for example, there are multiple senders that can start to transmit simultaneously, before SSRC collision are detected at the RTP level.",
      "ja": "したがって、SSRCは、同じRTPセッション内のすべてのRTPストリーム間で同じマスターキーを共有するすべてのRTPストリーム間で一意でなければなりません。RTP自体は、同じRTPセッション内のSSRC衝突を検出するためのアルゴリズムを提供します。したがって、一時的な衝突は、ストリームが同一のシーケンス番号を有する時点で衝突する不幸なイベントで、一時的な2タイムパッドにつながる可能性があります（約2 ^（ -  48））。したがって、キー管理は、セッションで使用されるSSRCを交渉パラメータとして積極的に保証することで、そのようなSSRC衝突を回避するのを避けるべきです。これはシナリオの強力な要件です。たとえば、SSRCの衝突がRTPレベルで検出される前に、同時に送信し始めることができる複数の送信者がいます。"
    },
    {
      "indent": 3,
      "text": "Note also that even with distinct SSRCs, extensive use of the same key might improve chances of probabilistic collision and time-memory-tradeoff attacks succeeding.",
      "ja": "また、異なるSSRCを使用しても、同じキーを広く使用することは、確率論的衝突とタイムメモリ - トレードオフ攻撃の可能性を向上させる可能性があります。"
    },
    {
      "indent": 3,
      "text": "As described, master keys MAY be shared between streams belonging to the same RTP session, but it is RECOMMENDED that each SSRC have its own master key. When master keys are shared among SSRC participants and SSRCs are managed by a key management module as recommended above, the RECOMMENDED policy for an SSRC collision error is for the participant to leave the SRTP session as it is a sign of malfunction.",
      "ja": "説明したように、マスターキーは、同じRTPセッションに属するストリーム間で共有されていてもよいが、各SSRCに独自のマスターキーがあることをお勧めします。SSRC参加者間でマスターキーが共有され、SSRCSが推奨されているように鍵管理モジュールによって管理されている場合、SSRC衝突エラーの推奨ポリシーは、参加者が誤動作の兆候としてSRTPセッションを残すためのものです。"
    },
    {
      "indent": 0,
      "text": "9.2. Key Usage",
      "section_title": true,
      "ja": "9.2. 鍵利用"
    },
    {
      "indent": 3,
      "text": "The effective key size is determined (upper bounded) by the size of the master key and, for encryption, the size of the salting key. Any additive stream cipher is vulnerable to attacks that use statistical knowledge about the plaintext source to enable key collision and time-memory tradeoff attacks [MF00] [H80] [BS00]. These attacks take advantage of commonalities among plaintexts, and provide a way for a cryptanalyst to amortize the computational effort of decryption over many keys, or over many bytes of output, thus reducing the effective key size of the cipher. A detailed analysis of these attacks and their applicability to the encryption of Internet traffic is provided in [MF00]. In summary, the effective key size of SRTP when used in a security system in which m distinct keys are used, is equal to the key size of the cipher less the logarithm (base two) of m. Protection against such attacks can be provided simply by increasing the size of the keys used, which here can be accomplished by the use of the salting key. Note that the salting key MUST be random but MAY be public. A salt size of (the suggested) size 112 bits protects against attacks in scenarios where at most 2^112 keys are in use. This is sufficient for all practical purposes.",
      "ja": "有効なキーサイズは、マスターキーのサイズと暗号化のために、塩漬けキーのサイズによって決定されます（上限）。 Addivent Stream暗号は、主要な衝突とタイムメモリのトレードオフ攻撃を有効にするために平文ソースに関する統計的な知識を使用する攻撃に対して脆弱です[MF00] [H80] [BS00]。これらの攻撃は平文の間の共通点を利用し、暗号広告が多くのキーにわたって復号化の計算努力を償却する方法を提供し、したがって暗号の有効なキーサイズを減らす。これらの攻撃の詳細な分析とそのインターネットトラフィックの暗号化への適用性が[MF00]に提供されています。要約すると、M個の異なるキーが使用されるセキュリティシステムで使用されたときのSRTPの有効鍵サイズは、Mの対数（基本2）の暗号のキーサイズと等しい。そのような攻撃に対する保護は、使用されるキーのサイズを増やすことによって簡単に提供することができます。ここではここでは塩漬けキーを使用して実現できます。塩漬け鍵はランダムでなければならないが、一般にあるかもしれないことに注意してください。 （提案された）サイズ112ビットの塩サイズは、最大2 ^ 112キーが使用されているシナリオの攻撃から保護します。これはすべての実用的な目的に十分です。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD use keys that are as large as possible. Please note that in many cases increasing the key size of a cipher does not affect the throughput of that cipher.",
      "ja": "実装はできるだけ大きいキーを使用する必要があります。多くの場合、暗号のキーサイズを大きくすると、その暗号のスループットには影響しません。"
    },
    {
      "indent": 3,
      "text": "The use of the SRTP and SRTCP indices in the pre-defined transforms fixes the maximum number of packets that can be secured with the same key. This limit is fixed to 2^48 SRTP packets for an SRTP stream, and 2^31 SRTCP packets, when SRTP and SRTCP are considered independently. Due to for example re-keying, reaching this limit may or may not coincide with wrapping of the indices, and thus the sender MUST keep packet counts. However, when the session keys for related SRTP and SRTCP streams are derived from the same master key (the default behavior, Section 4.3), the upper bound that has to be considered is in practice the minimum of the two quantities. That is, when 2^48 SRTP packets or 2^31 SRTCP packets have been secured with the same key (whichever occurs before), the key management MUST be called to provide new master key(s) (previously stored and used keys MUST NOT be used again), or the session MUST be terminated. If a sender of RTCP discovers that the sender of SRTP (or SRTCP) has not updated the master or session key prior to sending 2^48 SRTP (or 2^31 SRTCP) packets belonging to the same SRTP (SRTCP) stream, it is up to the security policy of the RTCP sender how to behave, e.g., whether an RTCP BYE-packet should be sent and/or if the event should be logged.",
      "ja": "事前定義された変換のSRTPとSRTCPインデックスの使用は、同じキーで保護できるパケットの最大数を修正します。この制限は、SRTPストリームの2 ^ 48 SRTPパケットに固定され、SRTPとSRTCPが独立して考慮される場合は、2 ^ 31 SRTCPパケットが固定されています。たとえば、再キーイングがあるため、この制限に達すると、インデックスのラッピングと一致しない場合があります。したがって、送信者はパケット数を保存しなければなりません。ただし、関連するSRTPおよびSRTCPストリームのセッションキーが同じマスターキー（デフォルトの動作（セクション4.3）から派生した場合、考慮されなければならない上限は実際には2つの量の最小値です。つまり、2 ^ 48 SRTPパケットまたは2 ^ 31 SRTCPパケットが同じキーで（どちらか行われた方）、新しいマスターキーを提供するために鍵管理を呼び出す必要があります（以前は保存されている鍵と使用されてはいけません）。再び使用するか、またはセッションを終了する必要があります。 RTCPの送信者がSRTP（またはSRTCP）の送信者が、同じSRTP（SRTCP）ストリームに属する2 ^ 48 SRTP（または2 ^ 31 SRTCP）パケットを送信する前に、SRTP（またはSRTCP）の送信者がマスターまたはセッションキーを更新していない場合は、 RTCP送信者のセキュリティポリシーの動作、例えば、RTCP BYE-PACKETを送信するかどうか、および/またはイベントを記録する必要があるかどうか。"
    },
    {
      "indent": 3,
      "text": "Note: in most typical applications (assuming at least one RTCP packet for every 128,000 RTP packets), it will be the SRTCP index that first reaches the upper limit, although the time until this occurs is very long: even at 200 SRTCP packets/sec, the 2^31 index space of SRTCP is enough to secure approximately 4 months of communication.",
      "ja": "注：最も一般的なアプリケーションでは、（128,000 RTPパケットごとに少なくとも1つのRTCPパケットを想定）、これが発生するまでの時間は非常に長いですが、最初に上限に達するSRTCPインデックスになります。SRTCPの2 31インデックス空間は、約4ヶ月の通信を確保するのに十分です。"
    },
    {
      "indent": 3,
      "text": "Note that if the master key is to be shared between SRTP streams within the same RTP session (Section 9.1), although the above bounds are on a per stream (i.e., per SSRC) basis, the sender MUST base re-key decision on the stream whose sequence number space is the first to be exhausted.",
      "ja": "同じRTPセッション内のSRTPストリーム間でマスターキーを共有する場合（セクション9.1）、上記の範囲はストリームごとに（すなわち、SSRCごとに）ベースであるため、送信者は次の再キーの決定を基本させる必要があります。シーケンス番号スペースが最初に使い果たされるストリーム。"
    },
    {
      "indent": 3,
      "text": "Key derivation limits the amount of plaintext that is encrypted with a fixed session key, and made available to an attacker for analysis, but key derivation does not extend the master key's lifetime. To see this, simply consider our requirements to avoid two-time pad: two distinct packets MUST either be processed with distinct IVs, or with distinct session keys, and both the distinctness of IV and of the session keys are (for the pre-defined transforms) dependent on the distinctness of the packet indices.",
      "ja": "キーの派生は、固定セッションキーで暗号化され、分析のために攻撃者が利用できる平文の量を制限しますが、鍵導出はマスター鍵の寿命を延長しません。これを確認するには、2タイムパッドを避けるための当社の要件を考慮してください。2つの異なるパケットは、異なるIVS、または異なるセッションキーで処理され、IVとセッションキーの独立しさの両方（事前定義の場合）が必要です。パケットインデックスの異なる性に依存します。"
    },
    {
      "indent": 3,
      "text": "Note that with the key derivation, the effective key size is at most that of the master key, even if the derived session key is considerably longer. With the pre-defined authentication transform, the session authentication key is 160 bits, but the master key by default is only 128 bits. This design choice was made to comply with certain recommendations in [RFC2104] so that an existing HMAC implementation can be plugged into SRTP without problems. Since the default tag size is 80 bits, it is, for the applications in mind, also considered acceptable from security point of view. Users having concerns about this are RECOMMENDED to instead use a 192 bit master key in the key derivation. It was, however, chosen not to mandate 192-bit keys since existing AES implementations to be used in the key-derivation may not always support key-lengths other than 128 bits. Since AES is not defined (or properly analyzed) for use with 160 bit keys it is NOT RECOMMENDED that ad-hoc key-padding schemes are used to pad shorter keys to 192 or 256 bits.",
      "ja": "鍵導出では、派生セッション鍵がかなり長い場合でも、有効なキーサイズはマスターキーのものです。事前定義された認証変換では、セッション認証キーは160ビットですが、デフォルトのマスターキーは128ビットです。既存のHMAC実装を問題なくSRTPに差し込むことができるように、[RFC2104]で特定の推奨事項に準拠していました。デフォルトのタグサイズは80ビットであるため、アプリケーションがセキュリティの観点から受け入れられると見なされます。これを懸念しているユーザーは、代わりにキー導出で192ビットのマスターキーを使用することをお勧めします。しかしながら、鍵導出に使用される既存のAES実装は、常に128ビット以外のキー長をサポートしない可能性があるため、192ビットキーを義務付けないことが選択されていました。 160ビットキーでは、AESが定義されていない（または適切に分析されています）ので、アドホックキーパディング方式を使用して短いキーを192または256ビットにパッドすることはお勧めできません。"
    },
    {
      "indent": 0,
      "text": "9.3. Confidentiality of the RTP Payload",
      "section_title": true,
      "ja": "9.3. RTPペイロードの機密性"
    },
    {
      "indent": 0,
      "text": " SRTP's pre-defined ciphers are \"seekable\" stream ciphers, i.e., ciphers able to efficiently seek to arbitrary locations in their keystream (so that the encryption or decryption of one packet does not depend on preceding packets). By using seekable stream ciphers, SRTP avoids the denial of service attacks that are possible on stream ciphers that lack this property. It is important to be aware that, as with any stream cipher, the exact length of the payload is revealed by the encryption. This means that it may be possible to deduce certain \"formatting bits\" of the payload, as the length of the codec output might vary due to certain parameter settings etc. This, in turn, implies that the corresponding bit of the keystream can be deduced. However, if the stream cipher is secure (counter mode and f8 are provably secure under certain assumptions [BDJR] [KSYH] [IK]), knowledge of a few bits of the keystream will not aid an attacker in predicting subsequent keystream bits. Thus, the payload length (and information deducible from this) will leak, but nothing else.",
      "ja": "SRTPの予め定義された暗号は「準備策」ストリーム暗号、すなわち、それらのキーストリーム内の任意の位置に効率的にシークすることができる暗号化（1つのパケットの暗号化または復号化が前のパケットに依存しないようにする）である。 SEEKABLEストリーム暗号を使用することによって、SRTPはこのプロパティを欠いているストリーム暗号で可能なサービス拒否攻撃を回避します。任意のストリーム暗号と同様に、ペイロードの正確な長さが暗号化によって明らかにされることに注意することが重要です。これは、コーデック出力の長さが特定のパラメータ設定などにより異なる可能性があるため、ペイロードの特定の「フォーマットビット」を推定することが可能である可能性があることを意味します。これは、キーストリームの対応するビットを推測できることを意味します。 。ただし、ストリーム暗号が安全である場合（カウンタモードとF8は特定の仮定[BDJR] [KSYH] [IK]では実際的には確実に保護されています）、キーストリームの数ビットの知識は、後続のキーストリームビットを予測する際の攻撃者に役立ちません。したがって、ペイロード長（およびこれと推定される情報）は漏れますが、他には何もありません。"
    },
    {
      "indent": 3,
      "text": "As some RTP packet could contain highly predictable data, e.g., SID, it is important to use a cipher designed to resist known plaintext attacks (which is the current practice).",
      "ja": "いくつかのRTPパケットは非常に予測可能なデータを含む可能性があるので、例えばSIDは、既知の平文攻撃に抵抗するように設計された暗号を使用することが重要である（これは現在の練習である）。"
    },
    {
      "indent": 0,
      "text": "9.4. Confidentiality of the RTP Header",
      "section_title": true,
      "ja": "9.4. RTPヘッダの機密性"
    },
    {
      "indent": 3,
      "text": "In SRTP, RTP headers are sent in the clear to allow for header compression. This means that data such as payload type, synchronization source identifier, and timestamp are available to an eavesdropper. Moreover, since RTP allows for future extensions of headers, we cannot foresee what kind of possibly sensitive information might also be \"leaked\".",
      "ja": "SRTPでは、RTPヘッダーがクリアに送信され、ヘッダー圧縮を可能にします。これは、ペイロードタイプ、同期ソース識別子、およびタイムスタンプなどのデータが盗聴者に利用可能であることを意味します。さらに、RTPは将来のヘッダーの拡張を可能にするので、私達はどのような種類の敏感な情報も「漏洩」され得るものを予測することはできません。"
    },
    {
      "indent": 3,
      "text": "SRTP is a low-cost method, which allows header compression to reduce bandwidth. It is up to the endpoints' policies to decide about the security protocol to employ. If one really needs to protect headers, and is allowed to do so by the surrounding environment, then one should also look at alternatives, e.g., IPsec [RFC2401].",
      "ja": "SRTPは低コストのメソッドで、ヘッダー圧縮が帯域幅を減らすことができます。採用するセキュリティプロトコルについて決定するのはエンドポイントのポリシー次第です。周囲の環境によって本当にそうすることが許されている場合は、代替手段、例えばIPsec [RFC2401]を見る必要があります。"
    },
    {
      "indent": 0,
      "text": "9.5. Integrity of the RTP payload and header",
      "section_title": true,
      "ja": "9.5. RTPペイロードとヘッダーの整合性"
    },
    {
      "indent": 3,
      "text": "SRTP messages are subject to attacks on their integrity and source identification, and these risks are discussed in Section 9.5.1. To protect against these attacks, each SRTP stream SHOULD be protected by HMAC-SHA1 [RFC2104] with an 80-bit output tag and a 160-bit key, or a message authentication code with equivalent strength. Secure RTP SHOULD NOT be used without message authentication, except under the circumstances described in this section. It is important to note that encryption algorithms, including AES Counter Mode and f8, do not provide message authentication. SRTCP MUST NOT be used with weak (or NULL) authentication.",
      "ja": "SRTPメッセージは、整合性とソースの識別に対する攻撃の対象となり、これらのリスクは9.5.1項で議論されています。これらの攻撃から保護するために、各SRTPストリームは、80ビットの出力タグと160ビットキーでHMAC-SHA1 [RFC2104]、または同等の強度を持つメッセージ認証コードで保護する必要があります。このセクションで説明されている状況下では、セキュアRTPはメッセージ認証なしで使用しないでください。AESカウンタモードおよびF8を含む暗号化アルゴリズムは、メッセージ認証を提供しないことに注意することが重要です。SRTCPは、弱い（またはNULL）認証で使用しないでください。"
    },
    {
      "indent": 3,
      "text": "SRTP MAY be used with weak authentication (e.g., a 32-bit authentication tag), or with no authentication (the NULL authentication algorithm). These options allow SRTP to be used to provide confidentiality in situations where",
      "ja": "SRTPは、弱い認証（例えば、32ビット認証タグ）、または認証なし（NULL認証アルゴリズム）と共に使用され得る。これらのオプションにより、SRTPを使用して、状況で機密性を提供できます。"
    },
    {
      "indent": 4,
      "text": "* weak or null authentication is an acceptable security risk, and * it is impractical to provide strong message authentication.",
      "ja": "* 弱いまたはNULL認証は許容できるセキュリティリスクであり、*強いメッセージ認証を提供することは実用的ではありません。"
    },
    {
      "indent": 3,
      "text": "These conditions are described below and in Section 7.5. Note that both conditions MUST hold in order for weak or null authentication to be used. The risks associated with exercising the weak or null authentication options need to be considered by a security audit prior to their use for a particular application or environment given the risks, which are discussed in Section 9.5.1.",
      "ja": "これらの条件については、7.5節で説明します。弱い認証またはヌル認証を使用するためには、両方の条件が保持されなければなりません。弱い認証オプションを実行することに関連するリスクは、9.5.1項で説明されているリスクを考慮して、特定のアプリケーションまたは環境の使用前にセキュリティ監査によって考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Weak authentication is acceptable when the RTP application is such that the effect of a small fraction of successful forgeries is negligible. If the application is stateless, then the effect of a single forged RTP packet is limited to the decoding of that particular packet. Under this condition, the size of the authentication tag MUST ensure that only a negligible fraction of the packets passed to the RTP application by the SRTP receiver can be forgeries. This fraction is negligible when an adversary, if given control of the forged packets, is not able to make a significant impact on the output of the RTP application (see the example of Section 7.5).",
      "ja": "RTPアプリケーションが、成功した偽造者の影響が無視できるほどの影響が少ない場合には、弱い認証が許容されます。アプリケーションがステートレスの場合、単一の鍛造RTPパケットの効果はその特定のパケットの復号化に制限されます。この条件では、認証タグのサイズは、SRTP受信者によってRTPアプリケーションに渡されたパケットのごくわずかな割合のみが偽物になることを保証する必要があります。鍛造パケットの制御が与えられている場合、このフラクタリーは無視できない場合、鍛造パケットの制御がRTPアプリケーションの出力に大きな影響を与えることができない（セクション7.5の例を参照）。"
    },
    {
      "indent": 3,
      "text": "Weak or null authentication MAY be acceptable when it is unlikely that an adversary can modify ciphertext so that it decrypts to an intelligible value. One important case is when it is difficult for an adversary to acquire the RTP plaintext data, since for many codecs, an adversary that does not know the input signal cannot manipulate the output signal in a controlled way. In many cases it may be difficult for the adversary to determine the actual value of the plaintext. For example, a hidden snooping device might be required in order to know a live audio or video signal. The adversary's signal must have a quality equivalent to or greater than that of the signal under attack, since otherwise the adversary would not have enough information to encode that signal with the codec used by the victim. Plaintext prediction may also be especially difficult for an interactive application such as a telephone call.",
      "ja": "弱いまたはNULL認証は、敵対者が暗号文を修正することができることがわかりやすい場合には許容可能であり得る。1つの重要なケースは、多くのコーデックでは、入力信号が制御された方法で出力信号を操作できないことを知らない敵対者がRTP平文データを取得することが困難である場合です。多くの場合、敵対者が平文の実際の価値を決定するのが難しいかもしれません。たとえば、ライブオーディオまたはビデオ信号を知るためには、隠されたスヌーピングデバイスが必要になる場合があります。逆の信号は、攻撃の影響を受けている信号のそれ以上の品質と同等かそれ以上の品質を持たなければなりません。平文の予測はまた、電話などの対話型アプリケーションにとって特に困難であり得る。"
    },
    {
      "indent": 3,
      "text": "Weak or null authentication MUST NOT be used when the RTP application makes data forwarding or access control decisions based on the RTP data. In such a case, an attacker may be able to subvert confidentiality by causing the receiver to forward data to an attacker. See Section 3 of [B96] for a real-life example of such attacks.",
      "ja": "RTPアプリケーションがRTPデータに基づいてデータ転送またはアクセス制御の決定を下す場合は、弱いまたはNULL認証を使用しないでください。そのような場合、攻撃者は受信機にデータを攻撃者に転送させることによって機密性を阻止することができるかもしれない。そのような攻撃の実際の例では、[B96]のセクション3を参照してください。"
    },
    {
      "indent": 0,
      "text": " Null authentication MUST NOT be used when a replay attack, in which an adversary stores packets then replays them later in the session, could have a non-negligible impact on the receiver. An example of a successful replay attack is the storing of the output of a surveillance camera for a period of time, later followed by the injection of that output to the monitoring station to avoid surveillance. Encryption does not protect against this attack, and non-null authentication is REQUIRED in order to defeat it.",
      "ja": "敵対認証は、敵対者がパケットを保存する再生攻撃がセッションの後半で再利用する場合は、受信者に無視できない影響を与える可能性があります。再生攻撃が成功した例は、監視カメラの出力の保存であり、後で監視局へのその出力の注入が続いて監視を回避することが成功することである。暗号化はこの攻撃から保護されません、そしてそれを倒すためにはヌル以外の認証が必要です。"
    },
    {
      "indent": 3,
      "text": "If existential message forgery is an issue, i.e., when the accuracy of the received data is of non-negligible importance, null authentication MUST NOT be used.",
      "ja": "存在メッセージの偽造が問題である場合、すなわち受信データの正確さが無視されない重要である場合、NULL認証は使用されてはならない。"
    },
    {
      "indent": 0,
      "text": "9.5.1. Risks of Weak or Null Message Authentication",
      "section_title": true,
      "ja": "9.5.1. 弱いまたはNULLメッセージ認証のリスク"
    },
    {
      "indent": 3,
      "text": "During a security audit considering the use of weak or null authentication, it is important to keep in mind the following attacks which are possible when no message authentication algorithm is used.",
      "ja": "弱い認証またはヌル認証の使用を考慮したセキュリティ監査中に、メッセージ認証アルゴリズムが使用されていない場合に可能な次の攻撃を留意することが重要です。"
    },
    {
      "indent": 3,
      "text": "An attacker who cannot predict the plaintext is still always able to modify the message sent between the sender and the receiver so that it decrypts to a random plaintext value, or to send a stream of bogus packets to the receiver that will decrypt to random plaintext values. This attack is essentially a denial of service attack, though in the absence of message authentication, the RTP application will have inputs that are bit-wise correlated with the true value. Some multimedia codecs and common operating systems will crash when such data are accepted as valid video data. This denial of service attack may be a much larger threat than that due to an attacker dropping, delaying, or re-ordering packets.",
      "ja": "プレーンテキストを予測できない攻撃者は、まだ、送信者と受信者との間で送信されたメッセージを無作為平文の値に復号化するか、またはランダム平文の値に復号化する受信者にBogusパケットのストリームを送信することができる。。この攻撃は基本的にはサービス拒否攻撃であるが、メッセージ認証がないが、RTPアプリケーションは、真の値とビット的に相関している入力を有することになる。そのようなデータが有効なビデオデータとして受け入れられると、いくつかのマルチメディアコーデックと共通オペレーティングシステムがクラッシュします。このサービス拒否攻撃は、攻撃者の落下、遅延、または並べ替えることによるものよりはるかに大きな脅威となる可能性があります。"
    },
    {
      "indent": 3,
      "text": "An attacker who cannot predict the plaintext can still replay a previous message with certainty that the receiver will accept it. Applications with stateless codecs might be robust against this type of attack, but for other, more complex applications these attacks may be far more grave.",
      "ja": "平文を予測できない攻撃者は、受信者がそれを受け入れることを確実に確実に確実に再生することができます。ステートレスコーデックを持つアプリケーションは、このタイプの攻撃に対して堅牢になる可能性がありますが、他の複雑なアプリケーションでは、これらの攻撃ははるかに墓になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "An attacker who can predict the plaintext can modify the ciphertext so that it will decrypt to any value of her choosing. With an additive stream cipher, an attacker will always be able to change individual bits.",
      "ja": "平文を予測できる攻撃者は、それが選択された任意の価値に復号化するように暗号文を修正することができます。加法ストリーム暗号を使用すると、攻撃者は常に個々のビットを変更することができます。"
    },
    {
      "indent": 0,
      "text": " An attacker may be able to subvert confidentiality due to the lack of authentication when a data forwarding or access control decision is made on decrypted but unauthenticated plaintext. This is because the receiver may be fooled into forwarding data to an attacker, leading to an indirect breach of confidentiality (see Section 3 of [B96]). This is because data-forwarding decisions are made on the decrypted plaintext; information in the plaintext will determine to what subnet (or process) the plaintext is forwarded in ESP [RFC2401] tunnel mode (respectively, transport mode). When Secure RTP is used without message authentication, it should be verified that the application does not make data forwarding or access control decisions based on the decrypted plaintext.",
      "ja": "攻撃者は、データ転送またはアクセス制御の決定が復号化されているが認証されていない平文で行われたときに認証の欠如のために機密性を避けることができるかもしれません。これは、受信機がデータを攻撃者に転送するようにだまされている可能性があるため、機密性の間接的な違反をもたらすからです（[B96]のセクション3を参照）。これは、データ転送の決定が復号化された平文で行われるためです。Plaintextの情報は、PlaintextがESP（RFC2401]トンネルモード（それぞれトランスポートモード）で転送されたサブネット（またはプロセス）を決定します。セキュアRTPをメッセージ認証なしで使用すると、アプリケーションが復号化された平文に基づいてデータ転送またはアクセス制御の決定を下さないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some cipher modes of operation that require padding, e.g., standard cipher block chaining (CBC) are very sensitive to attacks on confidentiality if certain padding types are used in the absence of integrity. The attack [V02] shows that this is indeed the case for the standard RTP padding as discussed in reference to Figure 1, when used together with CBC mode. Later transform additions to SRTP MUST therefore carefully consider the risk of using this padding without proper integrity protection.",
      "ja": "パディング、例えば標準暗号ブロック連鎖（CBC）を必要とするいくつかの暗号化操作モードは、一定のパディングタイプが完全性がない場合に使用される場合、機密性に対する攻撃に対して非常に敏感です。Attack [V02]は、これが実際には、図1を参照して、CBCモードと一緒に使用されるときに標準的なRTPパディングの場合が実際にあることを示しています。したがって、後の変換SRTPへの追加は、適切な完全性保護なしにこのパディングを使用する危険性を慎重に検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.5.2. Implicit Header Authentication",
      "section_title": true,
      "ja": "9.5.2. 暗黙のヘッダー認証"
    },
    {
      "indent": 3,
      "text": "The IV formation of the f8-mode gives implicit authentication (IHA) of the RTP header, even when message authentication is not used. When IHA is used, an attacker that modifies the value of the RTP header will cause the decryption process at the receiver to produce random plaintext values. While this protection is not equivalent to message authentication, it may be useful for some applications.",
      "ja": "F8モードのIV形成は、メッセージ認証が使用されていない場合でも、RTPヘッダの暗黙の認証（IHA）を与えます。IHAが使用されるとき、RTPヘッダーの値を変更する攻撃者は、受信側の復号化プロセスによってランダムな平文の値を生成させます。この保護はメッセージ認証と同等ではありませんが、一部のアプリケーションに役立ちます。"
    },
    {
      "indent": 0,
      "text": "10. Interaction with Forward Error Correction mechanisms",
      "section_title": true,
      "ja": "10. 前方誤り訂正機構との相互作用"
    },
    {
      "indent": 3,
      "text": "The default processing when using Forward Error Correction (e.g., RFC 2733) processing with SRTP SHALL be to perform FEC processing prior to SRTP processing on the sender side and to perform SRTP processing prior to FEC processing on the receiver side. Any change to this ordering (reversing it, or, placing FEC between SRTP encryption and SRTP authentication) SHALL be signaled out of band.",
      "ja": "SRTPを用いた前方誤り訂正（例えばRFC2733）処理を用いた場合のデフォルト処理は、送信側でSRTP処理の前にFEC処理を行い、受信側でのFEC処理の前にSRTP処理を行うものとする。この順序付け（反転、またはSRTP暗号化とSRTP認証の間にFECを配置する）の変更は、帯域外に通知されます。"
    },
    {
      "indent": 0,
      "text": "11. Scenarios",
      "section_title": true,
      "ja": "11. シナリオ"
    },
    {
      "indent": 3,
      "text": "SRTP can be used as security protocol for the RTP/RTCP traffic in many different scenarios. SRTP has a number of configuration options, in particular regarding key usage, and can have impact on the total performance of the application according to the way it is used. Hence, the use of SRTP is dependent on the kind of scenario and application it is used with. In the following, we briefly illustrate some use cases for SRTP, and give some guidelines for recommended setting of its options.",
      "ja": "SRTPは、さまざまなシナリオでRTP / RTCPトラフィックのセキュリティプロトコルとして使用できます。SRTPには、特に鍵の使用法に関して、いくつかの設定オプションがあり、使用方法に従ってアプリケーションの全体的なパフォーマンスに影響を与える可能性があります。したがって、SRTPの使用はシナリオの種類やアプリケーションに依存しています。以下では、SRTPのユースケースを簡単に説明し、そのオプションの推奨設定のためのガイドラインをいくつか示します。"
    },
    {
      "indent": 0,
      "text": "11.1. Unicast",
      "section_title": true,
      "ja": "11.1. ユニキャスト"
    },
    {
      "indent": 3,
      "text": "A typical example would be a voice call or video-on-demand application.",
      "ja": "典型的な例は、音声通話またはビデオオンデマンドアプリケーションです。"
    },
    {
      "indent": 3,
      "text": "Consider one bi-directional RTP stream, as one RTP session. It is possible for the two parties to share the same master key in the two directions according to the principles of Section 9.1. The first round of the key derivation splits the master key into any or all of the following session keys (according to the provided security functions):",
      "ja": "1つのRTPセッションとして、1つの双方向RTPストリームを検討してください。セクション9.1の原理に従って、2人の当事者が2つの方向に同じマスターキーを共有することが可能です。キー導出の最初のラウンドは、マスターキーを次のセッションキーのいずれかまたはすべてに分割します（提供されたセキュリティ機能に従って）。"
    },
    {
      "indent": 3,
      "text": "SRTP_encr_key, SRTP_auth_key, SRTCP_encr_key, and SRTCP_auth key.",
      "ja": "SRTP_ENCR_KEY、SRTP_AUTH_KEY、SRTCP_ENCR_KEY、およびSRTCP_AUTHキー。"
    },
    {
      "indent": 3,
      "text": "(For simplicity, we omit discussion of the salts, which are also derived.) In this scenario, it will in most cases suffice to have a single master key with the default lifetime. This guarantees sufficiently long lifetime of the keys and a minimum set of keys in place for most practical purposes. Also, in this case RTCP protection can be applied smoothly. Under these assumptions, use of the MKI can be omitted. As the key-derivation in combination with large difference in the packet rate in the respective directions may require simultaneous storage of several session keys, if storage is an issue, we recommended to use low-rate key derivation.",
      "ja": "（簡単にするために、我々はまた導出される塩の議論を省略します。）このシナリオでは、ほとんどの場合、デフォルトの寿命を持つ単一のマスターキーを持つことは十分です。これにより、最も実用的な目的のために、鍵の十分に長い寿命と最低限の鍵のセットが適所に保証されます。また、この場合、RTCP保護をスムーズに適用することができます。これらの仮定の下で、MKIの使用は省略することができます。それぞれの方向のパケットレートの大きな違いと組み合わせることで、複数のセッションキーを同時に記憶する必要があるかもしれない、ストレージが問題である場合、我々は低速鍵導出を使用することを勧告する。"
    },
    {
      "indent": 3,
      "text": "The same considerations can be extended to the unicast scenario with multiple RTP sessions, where each session would have a distinct master key.",
      "ja": "同じ考察は、複数のRTPセッションを使用してユニキャストシナリオに拡張することができます。各セッションは異なるマスターキーを持つことになります。"
    },
    {
      "indent": 0,
      "text": "11.2. Multicast (one sender)",
      "section_title": true,
      "ja": "11.2. マルチキャスト（1つの送信者）"
    },
    {
      "indent": 3,
      "text": "Just as with (unprotected) RTP, a scalability issue arises in big groups due to the possibly very large amount of SRTCP Receiver Reports that the sender might need to process. In SRTP, the sender may have to keep state (the cryptographic context) for each receiver, or more precisely, for the SRTCP used to protect Receiver Reports. The overhead increases proportionally to the size of the group. In particular, re-keying requires special concern, see below.",
      "ja": "（保護されていない）RTPと同じように、送信者が処理する必要があるかもしれないほど非常に大量のSRTCP受信機が報告されるため、スケーラビリティの問題が大きなグループで発生します。SRTPでは、送信者は、受信者レポートを保護するために使用されるSRTCPに対して、各受信者の状態（暗号化コンテキスト）を保持する必要がある場合があります。オーバーヘッドはグループのサイズに比例して増加します。特に、リーキーリングには特別な懸念が必要です。下記を参照してください。"
    },
    {
      "indent": 3,
      "text": "Consider first a small group of receivers. There are a few possible setups with the distribution of master keys among the receivers. Given a single RTP session, one possibility is that the receivers share the same master key as per Section 9.1 to secure all their respective RTCP traffic. This shared master key could then be the same one used by the sender to protect its outbound SRTP traffic. Alternatively, it could be a master key shared only among the receivers and used solely for their SRTCP traffic. Both alternatives require the receivers to trust each other.",
      "ja": "最初に少数の受信機グループを検討してください。受信者間のマスターキーの配布を伴う可能なセットアップがいくつかあります。単一のRTPセッションを考慮すると、受信者はセクション9.1と同じマスターキーを共有して、すべてのRTCPトラフィックを保護することです。この共有マスターキーは、送信者がそのアウトバウンドSRTPトラフィックを保護するために使用されるものと同じものになる可能性があります。あるいは、それは受信機間でのみ共有され、それらのSRTCPトラフィックのためだけに使用されているマスターキーであり得る。両方の選択肢は受信機が互いに信頼することを要求する。"
    },
    {
      "indent": 0,
      "text": " Considering SRTCP and key storage, it is recommended to use low-rate (or zero) key_derivation (except the mandatory initial one), so that the sender does not need to store too many session keys (each SRTCP stream might otherwise have a different session key at a given point in time, as the SRTCP sources send at different times). Thus, in case key derivation is wanted for SRTP, the cryptographic context for SRTP can be kept separate from the SRTCP crypto context, so that it is possible to have a key_derivation_rate of 0 for SRTCP and a non-zero value for SRTP.",
      "ja": "SRTCPおよびキーストレージを考慮すると、低レート（またはゼロ）キーを使用することをお勧めします（必須の最初の1つを除く）、送信側はあまりにも多くのセッションキーを保存する必要はありません（各SRTCPストリームでは別のセッションが異なる場合があります。SRTCPソースが異なる時点で送信されるときに、特定の時点でのキーのキー。したがって、SRTPに対して鍵導出が望まれる場合、SRTPの暗号化コンテキストをSRTCP暗号コンテキストとは別に保つことができ、SRTCPの場合は0のkey_delivation_rateおよびSRTPのゼロ以外の値を得ることができる。"
    },
    {
      "indent": 3,
      "text": "Use of the MKI for re-keying is RECOMMENDED for most applications (see Section 8.1).",
      "ja": "ほとんどのアプリケーションには、REキーイングのためのMKIを使用することをお勧めします（セクション8.1を参照）。"
    },
    {
      "indent": 3,
      "text": "If there are more than one SRTP/SRTCP stream (within the same RTP session) that share the master key, the upper limit of 2^48 SRTP packets / 2^31 SRTCP packets means that, before one of the streams reaches its maximum number of packets, re-keying MUST be triggered on ALL streams sharing the master key. (From strict security point of view, only the stream reaching the maximum would need to be re-keyed, but then the streams would no longer be sharing master key, which is the intention.) A local policy at the sender side should force rekeying in a way that the maximum packet limit is not reached on any of the streams. Use of the MKI for re-keying is RECOMMENDED.",
      "ja": "マスターキーを共有するSRTP / SRTCPストリーム（同じRTPセッション内）が複数ある場合は、2 ^ 48 SRTPパケット/ 2 31 SRTCPパケットの上限は、一方のストリームが最大数に達する前にそれを意味します。パケットのうち、マスターキーを共有するすべてのストリームで再キーイングを起動する必要があります。（厳密なセキュリティの観点からは、最大のセキュリティの観点からは、最大に達するだけでは再キーが付いている必要がありますが、ストリームはマスターキーを共有しなくなりました。最大パケット制限がいずれかのストリームに到達しないように。再キーイングのためのMKIを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "In large multicast with one sender, the same considerations as for the small group multicast hold. The biggest issue in this scenario is the additional load placed at the sender side, due to the state (cryptographic contexts) that has to be maintained for each receiver, sending back RTCP Receiver Reports. At minimum, a replay window might need to be maintained for each RTCP source.",
      "ja": "1つの送信者との大規模なマルチキャストでは、小グループマルチキャストホールドと同じ考察。このシナリオで最大の問題は、各受信者に対して維持されなければならない状態（暗号化コンテキスト）がRTCP受信側レポートを送信する状態（暗号化コンテキスト）のために、送信者側に追加の負荷をかけています。最低限、RTCPソースごとに再生ウィンドウを維持する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "11.3. Re-keying and access control",
      "section_title": true,
      "ja": "11.3. 再キーイングとアクセス制御"
    },
    {
      "indent": 3,
      "text": "Re-keying may occur due to access control (e.g., when a member is removed during a multicast RTP session), or for pure cryptographic reasons (e.g., the key is at the end of its lifetime). When using SRTP default transforms, the master key MUST be replaced before any of the index spaces are exhausted for any of the streams protected by one and the same master key.",
      "ja": "アクセス制御（例えば、マルチキャストRTPセッション中にメンバが取り外されるとき）、または純粋な暗号理由のために（例えば、鍵はその生涯の終わりにある）アクセス制御のために起こり得る。SRTPのデフォルト変換を使用する場合、マスターキーは、1つおよび同じマスターキーによって保護されたストリームのいずれかに対して任意の索引スペースが使い果たされる前に置き換える必要があります。"
    },
    {
      "indent": 0,
      "text": " How key management re-keys SRTP implementations is out of scope, but it is clear that there are straightforward ways to manage keys for a multicast group. In one-sender multicast, for example, it is typically the responsibility of the sender to determine when a new key is needed. The sender is the one entity that can keep track of when the maximum number of packets has been sent, as receivers may join and leave the session at any time, there may be packet loss and delay etc. In scenarios other than one-sender multicast, other methods can be used. Here, one must take into consideration that key exchange can be a costly operation, taking several seconds for a single exchange. Hence, some time before the master key is exhausted/expires, out-of-band key management is initiated, resulting in a new master key that is shared with the receiver(s). In any event, to maintain synchronization when switching to the new key, group policy might choose between using the MKI and the <From, To>, as described in Section 8.1.",
      "ja": "キー管理の再キーSRTPの実装が範囲外ですが、マルチキャストグループのキーを管理する方法が簡単です。たとえば、1つの送信者マルチキャストでは、通常、新しいキーがいつ必要かを判断するための送信者の責任です。送信者は、受信者がいつでも参加してセッションを終了することができるので、パケットの最大数が送信されてセッションを終了することができる場合、1つの送信者マルチキャスト以外のシナリオでは、パケットの損失と遅延などがある場合があります。他の方法を使用することができる。ここでは、単一の交換のために数秒かかり、鍵交換が費用のかかる操作になる可能性があることを考慮に入れる必要があります。したがって、マスターキーが使い果たされた/期限切れになるまでの時間は、帯域外鍵管理が開始され、その結果、受信者と共有される新しいマスターキーが生成されます。いずれにせよ、新しいキーに切り替えるときに同期を維持するために、セクション8.1で説明されているように、グループポリシーはMKIと<FROM、TO>を使用して選択することがあります。"
    },
    {
      "indent": 3,
      "text": "For access control purposes, the <From, To> periods are set at the desired granularity, dependent on the packet rate. High rate re-keying can be problematic for SRTCP in some large-group scenarios. As mentioned, there are potential problems in using the SRTP index, rather than the SRTCP index, for determining the master key. In particular, for short periods during switching of master keys, it may be the case that SRTCP packets are not under the current master key of the correspondent SRTP. Therefore, using the MKI for re-keying in such scenarios will produce better results.",
      "ja": "アクセス制御の目的のために、パケットレートに応じて、<from、to>期間が所望の粒度に設定される。いくつかの大グループシナリオでは、SRTCPにとって高いレートの再キーイングが問題になる可能性があります。前述のように、マスターキーを決定するためのSRTCPインデックスではなく、SRTPインデックスを使用する潜在的な問題があります。特に、マスターキーの切り替え中の短期間の場合、SRTCPパケットがCROPENT SRTPの現在のマスターキーの下にない場合であり得る。したがって、このようなシナリオでの再キーイングにMKIを使用すると、より良い結果が得られます。"
    },
    {
      "indent": 0,
      "text": "11.4. Summary of basic scenarios",
      "section_title": true,
      "ja": "11.4. 基本シナリオの概要"
    },
    {
      "indent": 3,
      "text": "The description of these scenarios highlights some recommendations on the use of SRTP, mainly related to re-keying and large scale multicast:",
      "ja": "これらのシナリオの説明は、主に再キーイングおよび大規模マルチキャストに関連するSRTPの使用に関するいくつかの推奨事項を強調しています。"
    },
    {
      "indent": 3,
      "text": "- Do not use fast re-keying with the <From, To> feature. It may, in particular, give problems in retrieving the correct SRTCP key, if an SRTCP packet arrives close to the re-keying time. The MKI SHOULD be used in this case.",
      "ja": "- <FROM、TO>機能で高速再キーイングを使用しないでください。特に、SRTCPパケットがリダイータイムに近づくと、特に正しいSRTCPキーを検索する際に問題がある可能性があります。この場合、MKIを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "- If multiple SRTP streams in the same RTP session share the same master key, also moderate rate re-keying MAY have the same problems, and the MKI SHOULD be used.",
      "ja": "- 同じRTPセッション内の複数のSRTPストリームが同じマスターキーを共有している場合も、適度なレートの再キーイングに同じ問題があり、MKIを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "- Though offering increased security, a non-zero key_derivation_rate is NOT RECOMMENDED when trying to minimize the number of keys in use with multiple streams.",
      "ja": "- セキュリティを強化することは、複数のストリームで使用されているキーの数を最小化しようとすると、ゼロ以外のkey_delivation_rateはお勧めできません。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The RTP specification establishes a registry of profile names for use by higher-level control protocols, such as the Session Description Protocol (SDP), to refer to transport methods. This profile registers the name \"RTP/SAVP\".",
      "ja": "RTP仕様は、トランスポート方法を参照するために、セッション記述プロトコル（SDP）などの上位レベルの制御プロトコルで使用するためのプロファイル名のレジストリを確立します。このプロファイルは \"rtp / savp\"という名前を登録します。"
    },
    {
      "indent": 3,
      "text": "SRTP uses cryptographic transforms which a key management protocol signals. It is the task of each particular key management protocol to register the cryptographic transforms or suites of transforms with IANA. The key management protocol conveys these protocol numbers, not SRTP, and each key management protocol chooses the numbering scheme and syntax that it requires.",
      "ja": "SRTPは、キー管理プロトコル信号がどの暗号変換を使用します。暗号変換または変換のスイートをIANAで登録するのは、特定の鍵管理プロトコルのタスクです。キー管理プロトコルは、SRTPではなくこれらのプロトコル番号を伝達し、各キー管理プロトコルは必要な番号付け方式と構文を選択します。"
    },
    {
      "indent": 3,
      "text": "Specification of a key management protocol for SRTP is out of scope here. Section 8.2, however, provides guidance on the parameters that need to be defined for the default and mandatory transforms.",
      "ja": "SRTPの鍵管理プロトコルの指定はここでは範囲外です。ただし、セクション8.2は、デフォルトの変換と必須変換に対して定義する必要があるパラメータに対するガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "13. Acknowledgements",
      "section_title": true,
      "ja": "13. 謝辞"
    },
    {
      "indent": 3,
      "text": "David Oran (Cisco) and Rolf Blom (Ericsson) are co-authors of this document but their valuable contributions are acknowledged here to keep the length of the author list down.",
      "ja": "David Oran（Cisco）とRolf Blom（Ericsson）はこの文書の共著者ですが、著者リストの長さを抑えるためにここで貴重な貢献が認められています。"
    },
    {
      "indent": 3,
      "text": "The authors would in addition like to thank Magnus Westerlund, Brian Weis, Ghyslain Pelletier, Morgan Lindqvist, Robert Fairlie-Cuninghame, Adrian Perrig, the AVT WG and in particular the chairmen Colin Perkins and Stephen Casner, the Transport and Security Area Directors, and Eric Rescorla for their reviews and support.",
      "ja": "著者らはさらにMagnus Westerlund、Brian Weis、Ghyslain Pelletier、Morgan Lindqvist、Robert Fairlie-Cuninghame、Avt WG、特に議長のColin Perkins and Stephen Casner、輸送および警備員の取締役会長、レビューやサポートのためのEric Rescorla。"
    },
    {
      "indent": 0,
      "text": "14. References",
      "section_title": true,
      "ja": "14. 参考文献"
    },
    {
      "indent": 0,
      "text": "14.1. Normative References",
      "section_title": true,
      "ja": "14.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[AES]     NIST, \"Advanced Encryption Standard (AES)\", FIPS PUB 197,\n          http://www.nist.gov/aes/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M.およびR. Canetti、「HMAC：メッセージ認証用鍵付きハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S、「RFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2401] Kent, S. and R. Atkinson, \"Security Architecture for Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[RFC2401]ケント、S.およびR.Atkinson、1998年11月、RFC 2401、RFC 2401。"
    },
    {
      "indent": 3,
      "text": "[RFC2828] Shirey, R., \"Internet Security Glossary\", FYI 36, RFC 2828, May 2000.",
      "ja": "[RFC2828] Shirey、R。、「インターネットセキュリティ用語集」、FYI 36、RFC 2828、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, \"RTP: A Transport Protocol for Real-time Applications\", RFC 3550, July 2003.",
      "ja": "[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R.およびV.Jacobson、「RTP：リアルタイムアプリケーション用のトランスポートプロトコル」、RFC 3550、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", RFC 3551, July 2003.",
      "ja": "[RFC3551] Schulzrinne、H.およびS.Casner、2003年7月、RFC 3551、RFC 3551、「オーディオおよびビデオカンファレンスのためのRTPプロファイル」。"
    },
    {
      "indent": 0,
      "text": "14.2. Informative References",
      "section_title": true,
      "ja": "14.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AES-CTR] Lipmaa, H., Rogaway, P. and D. Wagner, \"CTR-Mode\n          Encryption\", NIST, http://csrc.nist.gov/encryption/modes/\n          workshop1/papers/lipmaa-ctr.pdf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[B96] Bellovin, S., \"Problem Areas for the IP Security Protocols,\" in Proceedings of the Sixth Usenix Unix Security Symposium, pp. 1-16, San Jose, CA, July 1996 (http://www.research.att.com/~smb/papers/index.html).",
      "ja": "[B96] Bellovin、S。、Sixtth Usenix Unix Security Symposium、PP。1-16、San Jose、CA、2006年7月（http：//www.research。att.com/~smb/papers/index.html）。"
    },
    {
      "indent": 3,
      "text": "[BDJR] Bellare, M., Desai, A., Jokipii, E. and P. Rogaway, \"A Concrete Treatment of Symmetric Encryption: Analysis of DES Modes of Operation\", Proceedings 38th IEEE FOCS, pp. 394- 403, 1997.",
      "ja": "[BDJR] Bellare、M.、Desai、A.、Jokipii、E.およびP. Rogaway、「対称暗号化の具体的な扱い：DES運用モードの分析」、第38回IEEE FOC、PP。394- 403,1997。"
    },
    {
      "indent": 3,
      "text": "[BS00] Biryukov, A. and A. Shamir, \"Cryptanalytic Time/Memory/Data Tradeoffs for Stream Ciphers\", Proceedings, ASIACRYPT 2000, LNCS 1976, pp. 1-13, Springer Verlag.",
      "ja": "[BS00] Biryukov、A.およびA. Shamir、「ストリーム暗号化時間/メモリ/データトレードオフ」、議事録、議事録、Asiacrypt 2000、LNCS 1976、PP。1-13、Springer Verlag。"
    },
    {
      "indent": 3,
      "text": "[C99] Crowell, W. P., \"Introduction to the VENONA Project\", http://www.nsa.gov:8080/docs/venona/index.html.",
      "ja": "[C99] Crowell、W. P.、「Venona Projectの紹介」、http://www.nsa.gov：8080/docs/venna/index.html。"
    },
    {
      "indent": 3,
      "text": "[CTR] Dworkin, M., NIST Special Publication 800-38A, \"Recommendation for Block Cipher Modes of Operation: Methods and Techniques\", 2001. http://csrc.nist.gov/publications/nistpubs/800-38a/sp800- 38a.pdf.",
      "ja": "[CTR] Dwork、M.、NIST特別出版物800-38A、「ブロック暗号化モードのための推奨事項：方法とテクニック」、2001. http://csrc.nist.gov/publications/nistpubs/800-38a/SP800 -  38a.pdf。"
    },
    {
      "indent": 3,
      "text": "[f8-a] 3GPP TS 35.201 V4.1.0 (2001-12) Technical Specification 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; Specification of the 3GPP Confidentiality and Integrity Algorithms; Document 1: f8 and f9 Specification (Release 4).",
      "ja": "[F8-A] 3GPP TS 35.201 V4.1.0（2001-12）技術仕様第3世代パートナーシッププロジェクト。技術仕様グループサービスおよびシステムの側面3Gセキュリティ3GPP機密性と完全性アルゴリズムの指定文書1：F8およびF9仕様（リリース4）。"
    },
    {
      "indent": 3,
      "text": "[f8-b] 3GPP TR 33.908 V4.0.0 (2001-09) Technical Report 3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; 3G Security; General Report on the Design, Specification and Evaluation of 3GPP Standard Confidentiality and Integrity Algorithms (Release 4).",
      "ja": "[F8-B] 3GPP TR 33.908 V4.0.0（2001-09）テクニカルレポート第3世代パートナーシッププロジェクト。技術仕様グループサービスおよびシステムの側面3Gセキュリティ3GPP標準機密性と完全性アルゴリズムの設計、仕様、評価に関する一般的な報告（リリース4）"
    },
    {
      "indent": 3,
      "text": "[GDOI] Baugher, M., Weis, B., Hardjono, T. and H. Harney, \"The Group Domain of Interpretation, RFC 3547, July 2003.",
      "ja": "[Gdoi] Baugher、M.、Weis、B.、Hardjono、T.およびH. Harney \"、\" Interprationのグループドメイン、RFC 3547、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[HAC] Menezes, A., Van Oorschot, P. and S. Vanstone, \"Handbook of Applied Cryptography\", CRC Press, 1997, ISBN 0-8493- 8523-7.",
      "ja": "[HAC] Menezes、A.、Van Oorschot、P.およびS. Vanstone、「Applied Cryptographyのハンドブック」、CRC Press、1997、ISBN 0-8493-8523-7。"
    },
    {
      "indent": 3,
      "text": "[H80] Hellman, M. E., \"A cryptanalytic time-memory trade-off\", IEEE Transactions on Information Theory, July 1980, pp. 401-406.",
      "ja": "[H80] Hellman、M. E.、「暗号化タイムメモリトレードオフ」、1980年7月1980日、PP。401-406。"
    },
    {
      "indent": 3,
      "text": "[IK] T. Iwata and T. Kohno: \"New Security Proofs for the 3GPP Confidentiality and Integrity Algorithms\", Proceedings of FSE 2004.",
      "ja": "[IK]岩田氏とT. kohno：「3GPP機密性と完全性アルゴリズムのための新しいセキュリティ証明」、FSE 2004の議事録。"
    },
    {
      "indent": 3,
      "text": "[KINK] Thomas, M. and J. Vilhuber, \"Kerberized Internet Negotiation of Keys (KINK)\", Work in Progress.",
      "ja": "[Kink] Thomas、M.およびJ.Vilhuber、「Keys（Kink）のKerberizedインターネット交渉」、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[KEYMGT] Arrko, J., et al., \"Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)\", Work in Progress.",
      "ja": "[keymgt] Arrko、J.、et al。、「セッション記述プロトコル（SDP）およびリアルタイムストリーミングプロトコル（RTSP）のための鍵管理拡張（RTSP）」、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[KSYH] Kang, J-S., Shin, S-U., Hong, D. and O. Yi, \"Provable Security of KASUMI and 3GPP Encryption Mode f8\", Proceedings Asiacrypt 2001, Springer Verlag LNCS 2248, pp. 255-271, 2001.",
      "ja": "[KSYH] Kang、JS、Shin、Su、Su。、香港、D.およびO. Yi、「霞の証明され、3GPP暗号化モードF8」、議事録Asiacrypt 2001、Springer Verlag LNCS 2248、PP.255-271,2001。"
    },
    {
      "indent": 3,
      "text": "[MIKEY] Arrko, J., et. al., \"MIKEY: Multimedia Internet KEYing\", Work in Progress.",
      "ja": "[Mikey] Arrko、J.ら。al。、 \"Mikey：Multimedia Internet Keying\"、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[MF00] McGrew, D. and S. Fluhrer, \"Attacks on Encryption of Redundant Plaintext and Implications on Internet Security\", the Proceedings of the Seventh Annual Workshop on Selected Areas in Cryptography (SAC 2000), Springer-Verlag.",
      "ja": "[MF00] MCGREW、D.およびS.Fulhrer、「冗長平文の暗号化とインターネットセキュリティへの影響についての攻撃」、Cryptography（SAC 2000）、Springer-Verlagの選択された分野に関する7番目の年次ワークショップの手続き。"
    },
    {
      "indent": 3,
      "text": "[PCST1] Perrig, A., Canetti, R., Tygar, D. and D. Song, \"Efficient and Secure Source Authentication for Multicast\", in Proc. of Network and Distributed System Security Symposium NDSS 2001, pp. 35-46, 2001.",
      "ja": "[PCST1] Perrig、A.、Canetti、R.、Tygar、D.、D.曲、「マルチキャストのための効率的で安全なソース認証」、Proc。ネットワークおよび分散システムセキュリティシンポジウムNDSS 2001、PP。35-46,2001。"
    },
    {
      "indent": 3,
      "text": "[PCST2] Perrig, A., Canetti, R., Tygar, D. and D. Song, \"Efficient Authentication and Signing of Multicast Streams over Lossy Channels\", in Proc. of IEEE Security and Privacy Symposium S&P2000, pp. 56-73, 2000.",
      "ja": "[PCST2] Perrig、A.、Canetti、R.、Tygar、D.およびD.歌、「無制限のチャネル上でのマルチキャストストリームのマルチキャストストリームの署名」、Proc。Security and Privacy Symposium S＆P2000、PP。56-73,2000。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレイク、D.、Crocker、S.およびJ.Schiller、「セキュリティのためのランダム性勧告」、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2675] Borman, D., Deering, S. and R. Hinden, \"IPv6 Jumbograms\", RFC 2675, August 1999.",
      "ja": "[RFC2675] Borman、D.、Theering、S.およびR.hinden、「IPv6ザンボグラム」、RFC 2675、1999年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukuhsima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T. and H. Zheng, \"RObust Header Compression: Framework and Four Profiles: RTP, UDP, ESP, and uncompressed (ROHC)\", RFC 3095, July 2001.",
      "ja": "[RFC3095]ボルマン、C、Burmeister、C.、Degermark、M.、福島、H.、H.、H.、H.、H.、H.、H.、Le。、Hakenberg、R.、Koren、T.、Le、K.、Liu、Z.、Martensson、A.、宮崎、A。、Svanbro、K.、Wiebke、T.、Yoshimura、T.およびH.Zheng、「堅牢なヘッダー圧縮：フレームワークと4つのプロファイル：RTP、UDP、ESP、非圧縮（ROHC） \"、RFC 3095、2001年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3242] Jonsson, L-E. and G. Pelletier, \"RObust Header Compression (ROHC): A Link-Layer Assisted Profile for IP/UDP/RTP \", RFC 3242, April 2002.",
      "ja": "[RFC3242] Jonsson、L-E。G. Pelletier、「Robustヘッダー圧縮（RoHC）：IP / UDP / RTPのリンク層支援プロファイル」、RFC 3242、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[SDMS] Andreasen, F., Baugher, M. and D. Wing, \"Session Description Protocol Security Descriptions for Media Streams\", Work in Progress.",
      "ja": "[SDMS] Andreasen、F.、Baugher、M.およびD. Wing、「セッション説明プロトコルセキュリティ説明」、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[SWO] Svanbro, K., Wiorek, J. and B. Olin, \"Voice-over-IP-over-wireless\", Proc. PIMRC 2000, London, Sept. 2000.",
      "ja": "[SWO] Svanbro、K.、Wiorek、J.およびB. Olin、「音声オーバーIPオーバーワイヤレス」、PROC。PIMRC 2000、ロンドン、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[V02] Vaudenay, S., \"Security Flaws Induced by CBC Padding - Application to SSL, IPsec, WTLS...\", Advances in Cryptology, EUROCRYPT'02, LNCS 2332, pp. 534-545.",
      "ja": "[V02] Vaudenay、S.、「CBCパディングによって引き起こされるセキュリティ上の欠陥 -  SSL、IPSec、WTLSへの適用」、暗号学、eurocrypt'02、LNCS 2332、PP。534-545。"
    },
    {
      "indent": 3,
      "text": "[WC81] Wegman, M. N., and J.L. Carter, \"New Hash Functions and Their Use in Authentication and Set Equality\", JCSS 22, 265-279, 1981.",
      "ja": "[WC81] Wegman、M.N.、およびJ.L. Carter、「新しいハッシュ関数とその認証および平等におけるそれらの使用」、JCSS 22,265-279,1981。"
    },
    {
      "indent": 0,
      "text": "Appendix A: Pseudocode for Index Determination",
      "ja": "付録A：インデックス決定用の疑似コード"
    },
    {
      "indent": 3,
      "text": "The following is an example of pseudo-code for the algorithm to determine the index i of an SRTP packet with sequence number SEQ. In the following, signed arithmetic is assumed.",
      "ja": "以下は、シーケンス番号SEQを有するSRTPパケットのインデックスiを決定するためのアルゴリズムの疑似コードの例である。以下では、符号付き算術演算が想定されます。"
    },
    {
      "indent": 9,
      "text": "if (s_l < 32,768) if (SEQ - s_l > 32,768) set v to (ROC-1) mod 2^32 else set v to ROC endif else if (s_l - 32,768 > SEQ) set v to (ROC+1) mod 2^32 else set v to ROC endif endif return SEQ + v*65,536",
      "ja": "（SEQ-S_L> 32,768）IF（SEQ  -  S_L> 32,768）IF（ROC-1）MOD 2 ^ 32をSET V~ROC SET V~ROCE SET V~（S_L  -  32,768> SEQ）SET V~（ROC 1）MOD 2^ 32 Roc Endif Endif Return Seq V * 65,536"
    },
    {
      "indent": 0,
      "text": "Appendix B: Test Vectors",
      "ja": "付録B：テストベクトル"
    },
    {
      "indent": 3,
      "text": "All values are in hexadecimal.",
      "ja": "すべての値は16進数です。"
    },
    {
      "indent": 0,
      "text": "B.1. AES-f8 Test Vectors",
      "section_title": true,
      "ja": "B.1. AES-F8テストベクトル"
    },
    {
      "indent": 3,
      "text": "SRTP PREFIX LENGTH : 0",
      "ja": "SRTPプレフィックス長：0"
    },
    {
      "indent": 3,
      "text": "RTP packet header : 806e5cba50681de55c621599",
      "ja": "RTPパケットヘッダー：806E5CBA50681DE55C621599."
    },
    {
      "indent": 3,
      "text": "RTP packet payload : 70736575646f72616e646f6d6e657373 20697320746865206e65787420626573 74207468696e67",
      "ja": "RTPパケットのペイロード：7420746869606573,20697320746065737373,206973207460657373,2069732074606573,7420746869606573"
    },
    {
      "indent": 3,
      "text": "ROC                 :   d462564a\nkey                 :   234829008467be186c3de14aae72d62c\nsalt key            :   32f2870d\nkey-mask (m)        :   32f2870d555555555555555555555555\nkey XOR key-mask    :   11baae0dd132eb4d3968b41ffb278379",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   IV                  :   006e5cba50681de55c621599d462564a\n   IV'                 :   595b699bbd3bc0df26062093c1ad8f73\n   j = 0\n   IV' xor j           :   595b699bbd3bc0df26062093c1ad8f73\n   S(-1)               :   00000000000000000000000000000000\n   IV' xor S(-1) xor j :   595b699bbd3bc0df26062093c1ad8f73\n   S(0)                :   71ef82d70a172660240709c7fbb19d8e\n   plaintext           :   70736575646f72616e646f6d6e657373\n   ciphertext          :   019ce7a26e7854014a6366aa95d4eefd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "j = 1\nIV' xor j           :   595b699bbd3bc0df26062093c1ad8f72\nS(0)                :   71ef82d70a172660240709c7fbb19d8e\nIV' xor S(0) xor j  :   28b4eb4cb72ce6bf020129543a1c12fc\nS(1)                :   3abd640a60919fd43bd289a09649b5fc\nplaintext           :   20697320746865206e65787420626573\nciphertext          :   1ad4172a14f9faf455b7f1d4b62bd08f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "j = 2\nIV' xor j           :   595b699bbd3bc0df26062093c1ad8f71\nS(1)                :   3abd640a60919fd43bd289a09649b5fc\nIV' xor S(1) xor j  :   63e60d91ddaa5f0b1dd4a93357e43a8d\nS(2)                :   220c7a8715266565b09ecc8a2a62b11b\nplaintext           :   74207468696e67\nciphertext          :   562c0eef7c4802",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "B.2. AES-CM Test Vectors",
      "section_title": true,
      "ja": "B.2. AES-CMテストベクトル"
    },
    {
      "indent": 4,
      "text": "Keystream segment length: 1044512 octets (65282 AES blocks)\nSession Key:      2B7E151628AED2A6ABF7158809CF4F3C\nRollover Counter: 00000000\nSequence Number:  0000\nSSRC:             00000000\nSession Salt:     F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000 (already shifted)\nOffset:           F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Counter Keystream",
      "ja": "カウンターキーストリーム"
    },
    {
      "indent": 4,
      "text": "F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000   E03EAD0935C95E80E166B16DD92B4EB4\nF0F1F2F3F4F5F6F7F8F9FAFBFCFD0001   D23513162B02D0F72A43A2FE4A5F97AB\nF0F1F2F3F4F5F6F7F8F9FAFBFCFD0002   41E95B3BB0A2E8DD477901E4FCA894C0\n...                                ...\nF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF   EC8CDF7398607CB0F2D21675EA9EA1E4\nF0F1F2F3F4F5F6F7F8F9FAFBFCFDFF00   362B7C3C6773516318A077D7FC5073AE\nF0F1F2F3F4F5F6F7F8F9FAFBFCFDFF01   6A2CC3787889374FBEB4C81B17BA6C44",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nota Bene: this test case is contrived so that the latter part of the keystream segment coincides with the test case in Section F.5.1 of [CTR].",
      "ja": "Nota Bene：このテストケースは、キーストリームセグメントの後半部分が[CTR]のセクションF.5.1のテストケースと一致するように考案されています。"
    },
    {
      "indent": 0,
      "text": "B.3. Key Derivation Test Vectors",
      "section_title": true,
      "ja": "B.3. キー導出テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section provides test data for the default key derivation function, which uses AES-128 in Counter Mode. In the following, we walk through the initial key derivation for the AES-128 Counter Mode cipher, which requires a 16 octet session encryption key and a 14 octet session salt, and an authentication function which requires a 94-octet session authentication key. These values are called the cipher key, the cipher salt, and the auth key in the following. Since this is the initial key derivation and the key derivation rate is equal to zero, the value of (index DIV key_derivation_rate) is zero (actually, a six-octet string of zeros). In the following, we shorten key_derivation_rate to kdr.",
      "ja": "このセクションでは、カウンタモードでAES-128を使用するデフォルトのキー派生機能のテストデータを提供します。以下では、AES-128カウンタモード暗号の初期キー導出を歩きます。これは、16オクテットセッション暗号化キーと14オクテットセッション塩、および94オクテット・セッション認証キーを必要とする認証機能を必要とします。これらの値は、以下の暗号鍵、暗号塩、および認証キーと呼ばれます。これは初期キー導出であり、鍵導出率がゼロに等しいので、（Index Div Key_Delivation_Rate）の値はゼロ（実際にはゼロの6オクテット文字列）です。以下では、KDRへのkey_delivation_rateを短くします。"
    },
    {
      "indent": 3,
      "text": "The inputs to the key derivation function are the 16 octet master key and the 14 octet master salt:",
      "ja": "キー派生機能への入力は16オクテットマスターキーと14オクテットマスターソルトです。"
    },
    {
      "indent": 6,
      "text": "master key: E1F97A0D3E018BE0D64FA32C06DE4139 master salt: 0EC675AD498AFEEBB6960B3AABE6",
      "ja": "マスターキー：E1F97A0D3E018BE0D64FA32C06DE4139マスターソルト：0ec675AD498AV6960B3AABE6."
    },
    {
      "indent": 3,
      "text": "We first show how the cipher key is generated. The input block for AES-CM is generated by exclusive-oring the master salt with the concatenation of the encryption key label 0x00 with (index DIV kdr), then padding on the right with two null octets (which implements the multiply-by-2^16 operation, see Section 4.3.3). The resulting value is then AES-CM- encrypted using the master key to get the cipher key.",
      "ja": "まず、暗号鍵の生成方法を説明します。AES-CMの入力ブロックは、（Index Div KDR）とともに暗号鍵ラベル0x00の連結でマスター塩を排他的または（Index Div KDR）、次に2つのヌルオクテットで埋め込む（Multiply-2を実装する）によって生成されます。^ 16操作、4.3.3節を参照してください。結果として得られた値は、暗号鍵を取得するためにマスターキーを使用してAES-CM暗号化されます。"
    },
    {
      "indent": 6,
      "text": "index DIV kdr:                 000000000000\nlabel:                       00\nmaster salt:   0EC675AD498AFEEBB6960B3AABE6\n-----------------------------------------------\nxor:           0EC675AD498AFEEBB6960B3AABE6     (x, PRF input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "x*2^16:        0EC675AD498AFEEBB6960B3AABE60000 (AES-CM input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "cipher key: C61E7A93744F39EE10734AFE3FF7A087 (AES-CM output)",
      "ja": "暗号キー：C61E7A93744F39EE10734AFE3FF7A087（AES-CM出力）"
    },
    {
      "indent": 3,
      "text": "Next, we show how the cipher salt is generated. The input block for AES-CM is generated by exclusive-oring the master salt with the concatenation of the encryption salt label. That value is padded and encrypted as above.",
      "ja": "次に、暗号塩の発生方法を示します。AES-CMの入力ブロックは、暗号化ソルトラベルの連結でマスター塩の排他的またはマスター塩を除くことによって生成されます。その値は上記のように埋められて暗号化されます。"
    },
    {
      "indent": 6,
      "text": "index DIV kdr: 000000000000 label: 02 master salt: 0EC675AD498AFEEBB6960B3AABE6",
      "ja": "インデックスDIV KDR：000000000000レーベル：02マスターソルト：0EC675AD498AV6960B3AABE6"
    },
    {
      "indent": 6,
      "text": "----------------------------------------------\nxor:           0EC675AD498AFEE9B6960B3AABE6     (x, PRF input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "x*2^16:        0EC675AD498AFEE9B6960B3AABE60000 (AES-CM input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "30CBBC08863D8C85D49DB34A9AE17AC6 (AES-CM ouptut)",
      "ja": "30CBC08863D8C85D49DB34A9AE17AC6（AES-CM OUPTUT）"
    },
    {
      "indent": 6,
      "text": "cipher salt: 30CBBC08863D8C85D49DB34A9AE1",
      "ja": "暗号塩：30CBC08863D8C85D49DB34A9AE1"
    },
    {
      "indent": 3,
      "text": "We now show how the auth key is generated. The input block for AES-CM is generated as above, but using the authentication key label.",
      "ja": "認証キーがどのように生成されるかを示します。AES-CMの入力ブロックは上記のように生成されますが、認証キーのラベルを使用しています。"
    },
    {
      "indent": 6,
      "text": "index DIV kdr:                   000000000000\nlabel:                         01\nmaster salt:     0EC675AD498AFEEBB6960B3AABE6\n-----------------------------------------------\nxor:             0EC675AD498AFEEAB6960B3AABE6     (x, PRF input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "x*2^16:          0EC675AD498AFEEAB6960B3AABE60000 (AES-CM input)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Below, the auth key is shown on the left, while the corresponding AES input blocks are shown on the right.",
      "ja": "以下では、AUTHキーが左側に表示され、対応するAES入力ブロックは右側に表示されます。"
    },
    {
      "indent": 3,
      "text": "auth key                           AES input blocks\nCEBE321F6FF7716B6FD4AB49AF256A15   0EC675AD498AFEEAB6960B3AABE60000\n6D38BAA48F0A0ACF3C34E2359E6CDBCE   0EC675AD498AFEEAB6960B3AABE60001\nE049646C43D9327AD175578EF7227098   0EC675AD498AFEEAB6960B3AABE60002\n6371C10C9A369AC2F94A8C5FBCDDDC25   0EC675AD498AFEEAB6960B3AABE60003\n6D6E919A48B610EF17C2041E47403576   0EC675AD498AFEEAB6960B3AABE60004\n6B68642C59BBFC2F34DB60DBDFB2       0EC675AD498AFEEAB6960B3AABE60005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Questions and comments should be directed to the authors and avt@ietf.org:",
      "ja": "質問とコメントは著者とavt@ietf.orgに向けられるべきです："
    },
    {
      "indent": 3,
      "text": "Mark Baugher Cisco Systems, Inc. 5510 SW Orchid Street Portland, OR 97219 USA",
      "ja": "Mark Baugher Cisco Systems、Inc。5510 SW Orchid Street Portland、または97219 USA"
    },
    {
      "indent": 3,
      "text": "Phone:  +1 408-853-4418\nEMail:  mbaugher@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Elisabetta Carrara Ericsson Research SE-16480 Stockholm Sweden",
      "ja": "Elisabetta Carrara Ericsson Research SE-16480ストックホルムスウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone:  +46 8 50877040\nEMail:  elisabetta.carrara@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David A. McGrew Cisco Systems, Inc. San Jose, CA 95134-1706 USA",
      "ja": "David A. McGrew Cisco Systems、Inc。サンノゼ、CA 95134-1706 USA"
    },
    {
      "indent": 3,
      "text": "Phone:  +1 301-349-5815\nEMail:  mcgrew@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mats Naslund Ericsson Research SE-16480 Stockholm Sweden",
      "ja": "Mats Naslund Ericsson Research SE-16480ストックホルムスウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone:  +46 8 58533739\nEMail:  mats.naslund@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Karl Norrman Ericsson Research SE-16480 Stockholm Sweden",
      "ja": "Karl Norrman Ericsson Research SE-16480ストックホルムスウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone:  +46 8 4044502\nEMail:  karl.norrman@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全著作権宣言"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004). This document is subject to the rights, licenses and restrictions contained in BCP 78 and except as set forth therein, the authors retain all their rights.",
      "ja": "著作権（C）インターネット社会（2004）。この文書は、BCP 78に含まれている権利、ライセンス、制限の対象となり、そこに記載されている場合を除き、著者らはすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本明細書に含まれる情報は、「現状のまま」基準で提供されており、投稿者、または（いずれかの場合）、インターネット社会とインターネットエンジニアリングのタスクフォースがすべての保証を損なう、または本明細書における情報の使用が、特定の目的のためのあらゆる権利または黙示の保証を侵害しないことを含むがこれらに限定されないが、これに限定されない。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "この文書に記載されているテクノロジの実装または使用に関連すると主張される可能性がある、またはそのような権利の下でのライセンスの使用に関連すると主張される可能性がある、またはその他の権利の下にある範囲内である可能性がある、またはその他の権利の使用に関連すると主張する可能性がある、IETFは、IETFを取りません。利用可能です。そのような権利を特定するためにそれが独立した努力をしたことを表していません。RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局へのIETF事務局と利用可能なライセンスの保証のコピー、またはこの仕様書の実装者や利用者による一般的なライセンスまたは許可を得るための試みの結果を得ることができます。IETFオンラインIPRリポジトリからhttp://www.ietf.org/ipr。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、著作権、特許または特許出願、またはこの規格を実装することが要求される可能性がある技術をカバーする可能性のある他の独自の権利を注意を及ぼすように興味のある当事者を勧めます。ietf-ipr@ietf.orgのIETFに情報を宛先に宛ててください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディタ機能のための資金は、現在インターネット社会によって提供されています。"
    }
  ]
}