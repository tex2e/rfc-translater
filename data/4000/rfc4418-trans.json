{
  "title": {
    "text": "RFC 4418 - UMAC: Message Authentication Code using Universal Hashing",
    "ja": "RFC 4418 - UMAC：ユニバーサルハッシュを使用したメッセージ認証コード"
  },
  "number": 4418,
  "created_at": "2023-07-08 13:17:45.491149+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                    T. Krovetz, Ed.\nRequest for Comments: 4418                                CSU Sacramento\nCategory: Informational                                       March 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "UMAC: Message Authentication Code using Universal Hashing",
      "ja": "UMAC：ユニバーサルハッシュを使用したメッセージ認証コード"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This specification describes how to generate an authentication tag using the UMAC message authentication algorithm. UMAC is designed to be very fast to compute in software on contemporary uniprocessors. Measured speeds are as low as one cycle per byte. UMAC relies on addition of 32-bit and 64-bit numbers and multiplication of 32-bit numbers, operations well-supported by contemporary machines.",
      "ja": "この仕様は、UMACメッセージ認証アルゴリズムを用いて認証タグを生成する方法を規定しています。UMACは、現代のユニプロセッサ上でソフトウェアによる計算が非常に高速になるように設計されています。測定された速度は1バイトあたり1サイクルと非常に低速です。UMACは、32ビットおよび64ビットの数値の加算、および32ビットの数値の乗算に依存しており、これらの演算は現代のマシンで十分にサポートされています。"
    },
    {
      "indent": 3,
      "text": "To generate the authentication tag on a given message, a \"universal\" hash function is applied to the message and key to produce a short, fixed-length hash value, and this hash value is then xor'ed with a key-derived pseudorandom pad. UMAC enjoys a rigorous security analysis, and its only internal \"cryptographic\" component is a block cipher used to generate the pseudorandom pads and internal key material.",
      "ja": "特定のメッセージの認証タグを生成するには、メッセージと鍵に「ユニバーサル」ハッシュ関数を適用して短い固定長のハッシュ値を生成します。このハッシュ値は、鍵から導出された疑似ランダムパッドと排他的論理和（XOR）演算されます。UMACは厳格なセキュリティ分析を備えており、内部の「暗号化」コンポーネントは、疑似ランダムパッドと内部鍵マテリアルを生成するために使用されるブロック暗号のみです。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Notation and Basic Operations ...................................4\n   2.1. Operations on strings ......................................4\n   2.2. Operations on Integers .....................................5\n   2.3. String-Integer Conversion Operations .......................6\n   2.4. Mathematical Operations on Strings .........................6\n   2.5. ENDIAN-SWAP: Adjusting Endian Orientation ..................6\n        2.5.1. ENDIAN-SWAP Algorithm ...............................6\n3. Key- and Pad-Derivation Functions ...............................7\n   3.1. Block Cipher Choice ........................................7\n   3.2. KDF: Key-Derivation Function ...............................8\n        3.2.1. KDF Algorithm .......................................8\n   3.3. PDF: Pad-Derivation Function ...............................8\n        3.3.1. PDF Algorithm .......................................9\n4. UMAC Tag Generation ............................................10\n   4.1. UMAC Algorithm ............................................10\n   4.2. UMAC-32, UMAC-64, UMAC-96, and UMAC-128 ...................10\n5. UHASH: Universal Hash Function .................................10\n   5.1. UHASH Algorithm ...........................................11\n   5.2. L1-HASH: First-Layer Hash .................................12\n        5.2.1. L1-HASH Algorithm ..................................12\n        5.2.2. NH Algorithm .......................................13\n   5.3. L2-HASH: Second-Layer Hash ................................14\n        5.3.1. L2-HASH Algorithm ..................................14\n        5.3.2. POLY Algorithm .....................................15\n   5.4. L3-HASH: Third-Layer Hash .................................16\n        5.4.1. L3-HASH Algorithm ..................................16\n6. Security Considerations ........................................17\n   6.1. Resistance to Cryptanalysis ...............................17\n   6.2. Tag Lengths and Forging Probability .......................17\n   6.3. Nonce Considerations ......................................19\n   6.4. Replay Attacks ............................................20\n   6.5. Tag-Prefix Verification ...................................21\n   6.6. Side-Channel Attacks ......................................21\n7. Acknowledgements ...............................................21\nAppendix. Test Vectors ............................................22\nReferences ........................................................24\n   Normative References ...........................................24\n   Informative References .........................................24",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "UMAC is a message authentication code (MAC) algorithm designed for high performance. It is backed by a rigorous formal analysis, and there are no intellectual property claims made by any of the authors to any ideas used in its design.",
      "ja": "UMACは、高性能のために設計されたメッセージ認証コード（MAC）アルゴリズムです。これは、厳格な正式な分析に裏付けられており、そのデザインで使用されているアイデアに対して著者のいずれも行われた知的財産の主張はありません。"
    },
    {
      "indent": 3,
      "text": "UMAC is a MAC in the style of Wegman and Carter [4, 7]. A fast \"universal\" hash function is used to hash an input message M into a short string. This short string is then masked by xor'ing with a pseudorandom pad, resulting in the UMAC tag. Security depends on the sender and receiver sharing a randomly-chosen secret hash function and pseudorandom pad. This is achieved by using keyed hash function H and pseudorandom function F. A tag is generated by performing the computation",
      "ja": "UMACは、WegmanとCarterのスタイルのMacです[4、7]。高速な「ユニバーサル」ハッシュ関数を使用して、入力メッセージmを短い文字列にハッシュします。この短い文字列は、擬似ランダムパッドでXorをマスクし、UMACタグになります。セキュリティは、ランダムに選択された秘密のハッシュ関数と擬似ランダムパッドを共有する送信者と受信機に依存します。これは、キー付きハッシュ関数Hと擬似ランダム関数Fを使用することで実現されます。タグは、計算を実行することで生成されます。"
    },
    {
      "indent": 5,
      "text": "Tag = H_K1(M) xor F_K2(Nonce)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where K1 and K2 are secret random keys shared by sender and receiver, and Nonce is a value that changes with each generated tag. The receiver needs to know which nonce was used by the sender, so some method of synchronizing nonces needs to be used. This can be done by explicitly sending the nonce along with the message and tag, or agreeing upon the use of some other non-repeating value such as a sequence number. The nonce need not be kept secret, but care needs to be taken to ensure that, over the lifetime of a UMAC key, a different nonce is used with each message.",
      "ja": "ここで、K1とK2は送信者と受信機が共有する秘密のランダムキーであり、NonCEは各生成されたタグで変化する値です。受信者は、送信者がどの非CEを使用しているかを知る必要があるため、Nonceを同期する方法を使用する必要があります。これは、メッセージとタグとともにNonceを明示的に送信すること、またはシーケンス番号などの他の非反復値の使用に同意することで実行できます。ノンスは秘密にする必要はありませんが、UMACキーの生涯にわたって、各メッセージで異なるノンスが使用されることを保証するために注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "UMAC uses a keyed function, called UHASH (also specified in this document), as the keyed hash function H and uses a pseudorandom function F whose default implementation uses the Advanced Encryption Standard (AES) algorithm. UMAC is designed to produce 32-, 64-, 96-, or 128-bit tags, depending on the desired security level. The theory of Wegman-Carter MACs and the analysis of UMAC show that if one \"instantiates\" UMAC with truly random keys and pads then the probability that an attacker (even a computationally unbounded one) produces a correct tag for any message of its choosing is no more than 1/2^30, 1/2^60, 1/2^90, or 1/2^120 if the tags output by UMAC are of length 32, 64, 96, or 128 bits, respectively (here the symbol ^ represents exponentiation). When an attacker makes N forgery attempts, the probability of getting one or more tags right increases linearly to at most N/2^30, N/2^60, N/2^90, or N/2^120. In a real implementation of UMAC, using AES to produce keys and pads, the forgery probabilities listed above increase by a small amount related to the security of AES. As long as AES is secure, this small additive term is insignificant for any practical attack. See Section 6.2 for more details. Analysis relevant to UMAC security is in [3, 6].",
      "ja": "UMACは、UHASH（このドキュメントでも指定されている）と呼ばれるキー付き関数を使用して、キー付きハッシュ関数Hとして使用し、デフォルトの実装が高度な暗号化標準（AES）アルゴリズムを使用する擬似ランダム関数Fを使用します。UMACは、目的のセキュリティレベルに応じて、32、64-、96-、または128ビットタグを生成するように設計されています。Wegman-Carter Macの理論とUMACの分析は、真にランダムなキーとパッドを使用してUMACを「インスタンス化」すると、攻撃者（計算上未結合のものでも）が選択のメッセージの正しいタグを生成する確率があることを示しています。UMACによるタグ出力がそれぞれ長さ32、64、96、または128ビットの場合、1/2^30、1/2^60、1/2^90、または1/2^120以下（ここでシンボル ^は指数を表します）。攻撃者がN Forgeryの試みを行うと、1つ以上のタグを正しく取得する確率は、最大のn/2^30、n/2^60、n/2^90、またはn/2^120で直線的に増加します。UMACの実際の実装では、AESを使用してキーとパッドを生成すると、上記の偽造確率はAESのセキュリティに関連する少量だけ増加します。AESが安全である限り、この小さな追加項は、実際の攻撃に対しては重要ではありません。詳細については、セクション6.2を参照してください。UMACセキュリティに関連する分析は[3、6]にあります。"
    },
    {
      "indent": 3,
      "text": "UMAC performs best in environments where 32-bit quantities are efficiently multiplied into 64-bit results. In producing 64-bit tags on an Intel Pentium 4 using SSE2 instructions, which do two of these multiplications in parallel, UMAC processes messages at a peak rate of about one CPU cycle per byte, with the peak being achieved on messages of around four kilobytes and longer. On the Pentium III, without the use of SSE parallelism, UMAC achieves a peak of two cycles per byte. On shorter messages, UMAC still performs well: around four cycles per byte on 256-byte messages and under two cycles per byte on 1500-byte messages. The time to produce a 32-bit tag is a little more than half that needed to produce a 64-bit tag, while 96- and 128-bit tags take one-and-a-half and twice as long, respectively.",
      "ja": "UMACは、32ビットの量が効率的に64ビットの結果に増加している環境で最高のパフォーマンスを発揮します。SSE2命令を使用してIntel Pentium 4で64ビットタグを生成する際に、これらの乗算のうち2つを並行してUMACを処理すると、BYTEあたり約1 CPUサイクルのピークレートでメッセージを処理します。そして長い。Pentium IIIでは、SSE並列性を使用せずに、UMACはバイトあたり2サイクルのピークを達成します。短いメッセージでは、UMACは引き続きうまく機能します。256バイトのメッセージでバイトあたり約4サイクル、1500バイトメッセージでバイトごとに2サイクル以下です。32ビットタグを作成する時間は、64ビットタグを作成するために必要な半分を少し超えていますが、96ビットと128ビットのタグはそれぞれ1.5倍、2倍の長さです。"
    },
    {
      "indent": 3,
      "text": "Optimized source code, performance data, errata, and papers concerning UMAC can be found at http://www.cs.ucdavis.edu/~rogaway/umac/.",
      "ja": "UMACに関する最適化されたソースコード、パフォーマンスデータ、ERRATA、および論文は、http://www.cs.ucdavis.edu/~rogaway/umac/にあります。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Basic Operations",
      "section_title": true,
      "ja": "2. 表記および基本操作"
    },
    {
      "indent": 3,
      "text": "The specification of UMAC involves the manipulation of both strings and numbers. String variables are denoted with an initial uppercase letter, whereas numeric variables are denoted in all lowercase. The algorithms of UMAC are denoted in all uppercase letters. Simple functions, like those for string-length and string-xor, are written in all lowercase.",
      "ja": "UMACの仕様には、文字列と数字の両方の操作が含まれます。文字列変数は初期大文字で示されますが、数値変数はすべての小文字で示されます。UMACのアルゴリズムは、すべての大文字で示されています。string-lengthやstring-xorのような単純な関数は、すべての小文字で書かれています。"
    },
    {
      "indent": 3,
      "text": "Whenever a variable is followed by an underscore (\"_\"), the underscore is intended to denote a subscript, with the subscripted expression evaluated to resolve the meaning of the variable. For example, if i=2, then M_{2 * i} refers to the variable M_4.",
      "ja": "変数の後にアンダースコア（\"_\"）が続く場合、アンダースコアは添字を表すことを意図しており、添字付きの式が評価されて変数の意味が解釈されます。例えば、i=2の場合、M_{2 * i}は変数M_4を指します。"
    },
    {
      "indent": 0,
      "text": "2.1. Operations on strings",
      "section_title": true,
      "ja": "2.1. 文字列の操作"
    },
    {
      "indent": 3,
      "text": "Messages to be hashed are viewed as strings of bits that get zero-padded to an appropriate byte length. Once the message is padded, all strings are viewed as strings of bytes. A \"byte\" is an 8-bit string. The following notation is used to manipulate these strings.",
      "ja": "ハッシュ化されるメッセージは、適切なバイト長になるようにゼロパディングされたビット列として扱われます。メッセージがパディングされると、すべての文字列はバイト列として扱われます。「バイト」は8ビットの文字列です。これらの文字列を操作するには、以下の表記法を使用します。"
    },
    {
      "indent": 9,
      "text": "bytelength(S): The length of string S in bytes.",
      "ja": "bytelength(S): 文字列Sのバイト単位の長さ。"
    },
    {
      "indent": 9,
      "text": "bitlength(S): The length of string S in bits.",
      "ja": "bitlength(S): 文字列Sのビット単位の長さ。"
    },
    {
      "indent": 9,
      "text": "zeroes(n): The string made of n zero-bytes.",
      "ja": "zeroes(n): n 個のゼロバイトで構成される文字列。"
    },
    {
      "indent": 9,
      "text": "S xor T: The string that is the bitwise exclusive-or of S and T. Strings S and T always have the same length.",
      "ja": "S xor T：S と T のビット単位の排他的論理和である文字列。文字列 S と T は常に同じ長さになります。"
    },
    {
      "indent": 9,
      "text": "S and T: The string that is the bitwise conjunction of S and T. Strings S and T always have the same length.",
      "ja": "S and T: S と T のビット単位の結合である文字列。文字列 S と T は常に同じ長さになります。"
    },
    {
      "indent": 9,
      "text": "S[i]: The i-th byte of the string S (indices begin at 1).",
      "ja": "S[i]: 文字列Sのi番目のバイト（インデックスは1から始まります）。"
    },
    {
      "indent": 9,
      "text": "S[i...j]: The substring of S consisting of bytes i through j.",
      "ja": "S[i...j]: iからjまでのバイトで構成されるSの部分文字列。"
    },
    {
      "indent": 9,
      "text": "S || T: The string S concatenated with string T.",
      "ja": "S || T: 文字列 S と文字列 T を連結したもの。"
    },
    {
      "indent": 9,
      "text": "zeropad(S,n): The string S, padded with zero-bits to the nearest positive multiple of n bytes. Formally, zeropad(S,n) = S || T, where T is the shortest string of zero-bits (possibly empty) so that S || T is non-empty and 8n divides bitlength(S || T).",
      "ja": "zeropad(S,n): 文字列Sに、nバイトの正の倍数に最も近いゼロビットをパディングしたもの。正式には、zeropad(S,n) = S || T であり、Tはゼロビットの最短文字列（空文字列も含む）であり、S || Tは空文字列ではなく、8nでbitlength(S || T)を割り切れる。"
    },
    {
      "indent": 0,
      "text": "2.2. Operations on Integers",
      "section_title": true,
      "ja": "2.2. 整数の操作"
    },
    {
      "indent": 3,
      "text": "Standard notation is used for most mathematical operations, such as \"*\" for multiplication, \"+\" for addition and \"mod\" for modular reduction. Some less standard notations are defined here.",
      "ja": "標準表記は、「乗算のための*」、追加のための「*」、モジュラー削減のための「MOD」など、ほとんどの数学操作に使用されます。ここでは、いくつかの標準表記が定義されています。"
    },
    {
      "indent": 6,
      "text": "a^i: The integer a raised to the i-th power.",
      "ja": "a^i: 整数 a の i 乗。"
    },
    {
      "indent": 6,
      "text": "ceil(x): The smallest integer greater than or equal to x.",
      "ja": "ceil(x): x以上の最小の整数。"
    },
    {
      "indent": 6,
      "text": "prime(n): The largest prime number less than 2^n.",
      "ja": "prime(n): 2^n未満の最大の素数。"
    },
    {
      "indent": 3,
      "text": "The prime numbers used in UMAC are:",
      "ja": "UMACで使用される主要な数字は次のとおりです。"
    },
    {
      "indent": 4,
      "text": "+-----+--------------------+---------------------------------------+\n|  n  | prime(n) [Decimal] | prime(n) [Hexadecimal]                |\n+-----+--------------------+---------------------------------------+\n| 36  | 2^36  - 5          | 0x0000000F FFFFFFFB                   |\n| 64  | 2^64  - 59         | 0xFFFFFFFF FFFFFFC5                   |\n| 128 | 2^128 - 159        | 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFF61 |\n+-----+--------------------+---------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.3. String-Integer Conversion Operations",
      "section_title": true,
      "ja": "2.3. String-Integer変換操作"
    },
    {
      "indent": 3,
      "text": "Conversion between strings and integers is done using the following functions. Each function treats initial bits as more significant than later ones.",
      "ja": "文字列と整数の間の変換は、次の関数を使用して行われます。各関数は、初期ビットを後のビットよりも重要なものとして扱います。"
    },
    {
      "indent": 6,
      "text": "bit(S,n): Returns the integer 1 if the n-th bit of the string S is 1, otherwise returns the integer 0 (indices begin at 1).",
      "ja": "bit(S,n): 文字列 S の n 番目のビットが 1 の場合、整数 1 を返します。それ以外の場合は整数 0 を返します (インデックスは 1 から始まります)。"
    },
    {
      "indent": 6,
      "text": "str2uint(S): The non-negative integer whose binary representation is the string S. More formally, if S is t bits long then str2uint(S) = 2^{t-1} * bit(S,1) + 2^{t-2} * bit(S,2) + ... + 2^{1} * bit(S,t-1) + bit(S,t).",
      "ja": "str2uint(S): バイナリ表現が文字列 S である非負の整数。より正式には、S が t ビット長の場合、str2uint(S) = 2^{t-1} * bit(S,1) + 2^{t-2} * bit(S,2) + ... + 2^{1} * bit(S,t-1) + bit(S,t) となります。"
    },
    {
      "indent": 6,
      "text": "uint2str(n,i): The i-byte string S such that str2uint(S) = n.",
      "ja": "uint2str(n,i): str2uint(S) = nとなるiバイトの文字列S。"
    },
    {
      "indent": 0,
      "text": "2.4. Mathematical Operations on Strings",
      "section_title": true,
      "ja": "2.4. 文字列の数学操作"
    },
    {
      "indent": 3,
      "text": "One of the primary operations in UMAC is repeated application of addition and multiplication on strings. The operations \"+_32\", \"+_64\", and \"*_64\" are defined",
      "ja": "UMACにおける主要な演算の一つは、文字列に対する加算と乗算の繰り返しです。演算「+_32」、「+_64」、「*_64」は次のように定義されています。"
    },
    {
      "indent": 5,
      "text": "\"S +_32 T\" as uint2str(str2uint(S) + str2uint(T) mod 2^32, 4),\n\"S +_64 T\" as uint2str(str2uint(S) + str2uint(T) mod 2^64, 8), and\n\"S *_64 T\" as uint2str(str2uint(S) * str2uint(T) mod 2^64, 8).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These operations correspond well with the addition and multiplication operations that are performed efficiently by modern computers.",
      "ja": "これらの演算は、現代のコンピュータによって効率的に実行される加算および乗算演算とよく一致しています。"
    },
    {
      "indent": 0,
      "text": "2.5. ENDIAN-SWAP: Adjusting Endian Orientation",
      "section_title": true,
      "ja": "2.5. ENDIAN-SWAP：エンディアン方向の調整"
    },
    {
      "indent": 3,
      "text": "Message data is read little-endian to speed tag generation on little-endian computers.",
      "ja": "メッセージデータは、リトルエンディアンコンピューターのタグ生成をスピードアップするために、リトルエンディアンを読み取ります。"
    },
    {
      "indent": 0,
      "text": "2.5.1. ENDIAN-SWAP Algorithm",
      "section_title": true,
      "ja": "2.5.1. Endian-Swapアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  S, string with length divisible by 4 bytes.\nOutput:\n  T, string S with each 4-byte word endian-reversed.\n\nCompute T using the following algorithm.\n\n  //\n  // Break S into 4-byte chunks\n  //\n  n = bytelength(S) / 4\n  Let S_1, S_2, ..., S_n be strings of length 4 bytes\n     so that S_1 || S_2 || ... || S_n = S.\n\n  //\n  // Byte-reverse each chunk, and build-up T\n  //\n  T = <empty string>\n  for i = 1 to n do\n    Let W_1, W_2, W_3, W_4  be bytes\n       so that W_1 || W_2 || W_3 || W_4 = S_i\n    SReversed_i = W_4 || W_3 || W_2 || W_1\n    T = T || SReversed_i\n  end for\n\n  Return T",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. Key- and Pad-Derivation Functions",
      "section_title": true,
      "ja": "3. キーとパッドの導出関数"
    },
    {
      "indent": 3,
      "text": "Pseudorandom bits are needed internally by UHASH and at the time of tag generation. The functions listed in this section use a block cipher to generate these bits.",
      "ja": "擬似ランダムビットは、Uhashによって内部的にタグ生成時に必要です。このセクションにリストされている関数は、ブロック暗号を使用してこれらのビットを生成します。"
    },
    {
      "indent": 0,
      "text": "3.1. Block Cipher Choice",
      "section_title": true,
      "ja": "3.1. ブロック暗号の選択"
    },
    {
      "indent": 3,
      "text": "UMAC uses the services of a block cipher. The selection of a block cipher defines the following constants and functions.",
      "ja": "UMACはブロック暗号のサービスを使用します。ブロック暗号の選択によって、以下の定数と関数が定義されます。"
    },
    {
      "indent": 6,
      "text": "BLOCKLEN : The length, in bytes, of the plaintext block on which the block cipher operates.",
      "ja": "BLOCKLEN: ブロック暗号が動作するプレーンテキスト ブロックの長さ (バイト単位)。"
    },
    {
      "indent": 6,
      "text": "KEYLEN : The block cipher's key length, in bytes.",
      "ja": "KEYLEN: ブロック暗号のキーの長さ（バイト単位）。"
    },
    {
      "indent": 6,
      "text": "ENCIPHER(K,P) : The application of the block cipher on P (a string of BLOCKLEN bytes) using key K (a string of KEYLEN bytes).",
      "ja": "ENCIPHER(K,P) : キー K (KEYLEN バイトの文字列) を使用して、P (BLOCKLEN バイトの文字列) にブロック暗号を適用します。"
    },
    {
      "indent": 3,
      "text": "As an example, if AES is used with 16-byte keys, then BLOCKLEN would equal 16 (because AES employs 16-byte blocks), KEYLEN would equal 16, and ENCIPHER would refer to the AES function.",
      "ja": "たとえば、AES が 16 バイトのキーで使用される場合、BLOCKLEN は 16 になり (AES は 16 バイトのブロックを使用するため)、KEYLEN は 16 になり、ENCIPHER は AES 関数を参照します。"
    },
    {
      "indent": 3,
      "text": "Unless specified otherwise, AES with 128-bit keys shall be assumed to be the chosen block cipher for UMAC. Only if explicitly specified otherwise, and agreed to by communicating parties, shall some other block cipher be used. In any case, BLOCKLEN must be at least 16 and a power of two.",
      "ja": "別途指定がない限り、UMACでは128ビット鍵のAESがブロック暗号として選択されるものとします。明示的に別途指定され、通信当事者間で合意された場合にのみ、他のブロック暗号が使用されます。いずれの場合も、BLOCKLENは16以上かつ2のべき乗でなければなりません。"
    },
    {
      "indent": 3,
      "text": "AES is defined in another document [1].",
      "ja": "AESは別のドキュメント[1]で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.2. KDF: Key-Derivation Function",
      "section_title": true,
      "ja": "3.2. KDF：キー導出関数"
    },
    {
      "indent": 3,
      "text": "The key-derivation function generates pseudorandom bits used to key the hash functions.",
      "ja": "キー導出関数は、ハッシュ関数の鍵に使用される擬似ランダムビットを生成します。"
    },
    {
      "indent": 0,
      "text": "3.2.1. KDF Algorithm",
      "section_title": true,
      "ja": "3.2.1. KDFアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  K, string of length KEYLEN bytes.\n  index, a non-negative integer less than 2^64.\n  numbytes, a non-negative integer less than 2^64.\nOutput:\n  Y, string of length numbytes bytes.\n\nCompute Y using the following algorithm.\n\n  //\n  // Calculate number of block cipher iterations\n  //\n  n = ceil(numbytes / BLOCKLEN)\n  Y = <empty string>\n\n  //\n  // Build Y using block cipher in a counter mode\n  //\n  for i = 1 to n do\n    T = uint2str(index, BLOCKLEN-8) || uint2str(i, 8)\n    T = ENCIPHER(K, T)\n    Y = Y || T\n  end for\n\n  Y = Y[1...numbytes]\n\n  Return Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3. PDF: Pad-Derivation Function",
      "section_title": true,
      "ja": "3.3. PDF：パッド導出関数"
    },
    {
      "indent": 3,
      "text": "This function takes a key and a nonce and returns a pseudorandom pad for use in tag generation. A pad of length 4, 8, 12, or 16 bytes can be generated. Notice that pads generated using nonces that differ only in their last bit (when generating 8-byte pads) or last two bits (when generating 4-byte pads) are derived from the same block cipher encryption. This allows caching and sharing a single block cipher invocation for sequential nonces.",
      "ja": "この関数はキーとノンスを取り、タグ生成で使用するために擬似ランダムパッドを返します。長さ4、8、12、または16バイトのパッドを生成できます。最後のビット（8バイトパッドを生成するとき）または最後の2ビット（4バイトパッドを生成するとき）でのみ異なる非セースを使用して生成されたパッドは、同じブロック暗号化から派生していることに注意してください。これにより、シーケンシャルノンスのための単一のブロック暗号の呼び出しをキャッシュして共有できます。"
    },
    {
      "indent": 0,
      "text": "3.3.1. PDF Algorithm",
      "section_title": true,
      "ja": "3.3.1. PDFアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  K, string of length KEYLEN bytes.\n  Nonce, string of length 1 to BLOCKLEN bytes.\n  taglen, the integer 4, 8, 12 or 16.\nOutput:\n  Y, string of length taglen bytes.\n\nCompute Y using the following algorithm.\n\n   //\n   // Extract and zero low bit(s) of Nonce if needed\n   //\n   if (taglen = 4 or taglen = 8)\n     index = str2uint(Nonce) mod (BLOCKLEN/taglen)\n     Nonce = Nonce xor uint2str(index, bytelength(Nonce))\n   end if\n\n   //\n   // Make Nonce BLOCKLEN bytes by appending zeroes if needed\n   //\n   Nonce = Nonce || zeroes(BLOCKLEN - bytelength(Nonce))\n\n   //\n   // Generate subkey, encipher and extract indexed substring\n   //\n   K' = KDF(K, 0, KEYLEN)\n   T = ENCIPHER(K', Nonce)\n   if (taglen = 4 or taglen = 8)\n     Y = T[1 + (index*taglen) ... taglen + (index*taglen)]\n   else\n     Y = T[1...taglen]\n   end if\n\n   Return Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. UMAC Tag Generation",
      "section_title": true,
      "ja": "4. UMACタグ生成"
    },
    {
      "indent": 3,
      "text": "Tag generation for UMAC proceeds by using UHASH (defined in the next section) to hash the message, applying the PDF to the nonce, and computing the xor of the resulting strings. The length of the pad and hash can be either 4, 8, 12, or 16 bytes.",
      "ja": "UMACのタグ生成は、UHASH（次のセクションで定義されている）を使用してメッセージをハッシュし、PDFを非CEに適用し、結果の文字列のXORを計算します。パッドとハッシュの長さは、4、8、12、または16バイトのいずれかです。"
    },
    {
      "indent": 0,
      "text": "4.1. UMAC Algorithm",
      "section_title": true,
      "ja": "4.1. UMACアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  K, string of length KEYLEN bytes.\n  M, string of length less than 2^67 bits.\n  Nonce, string of length 1 to BLOCKLEN bytes.\n  taglen, the integer 4, 8, 12 or 16.\nOutput:\n  Tag, string of length taglen bytes.\n\nCompute Tag using the following algorithm.\n\n  HashedMessage = UHASH(K, M, taglen)\n  Pad           = PDF(K, Nonce, taglen)\n  Tag           = Pad xor HashedMessage\n\n  Return Tag",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. UMAC-32, UMAC-64, UMAC-96, and UMAC-128",
      "section_title": true,
      "ja": "4.2. UMAC-32、UMAC-64、UMAC-96、およびUMAC-128"
    },
    {
      "indent": 3,
      "text": "The preceding UMAC definition has a parameter \"taglen\", which specifies the length of tag generated by the algorithm. The following aliases define names that make tag length explicit in the name.",
      "ja": "上記のUMAC定義には、アルゴリズムによって生成されるタグの長さを指定するパラメータ「taglen」があります。以下のエイリアスは、タグの長さを名前に明示的に示す名前を定義します。"
    },
    {
      "indent": 5,
      "text": "UMAC-32(K, M, Nonce) = UMAC(K, M, Nonce, 4)\nUMAC-64(K, M, Nonce) = UMAC(K, M, Nonce, 8)\nUMAC-96(K, M, Nonce) = UMAC(K, M, Nonce, 12)\nUMAC-128(K, M, Nonce) = UMAC(K, M, Nonce, 16)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. UHASH: Universal Hash Function",
      "section_title": true,
      "ja": "5. UHASH：ユニバーサルハッシュ関数"
    },
    {
      "indent": 3,
      "text": "UHASH is a keyed hash function, which takes as input a string of arbitrary length, and produces a 4-, 8-, 12-, or 16-byte output. UHASH does its work in three stages, or layers. A message is first hashed by L1-HASH, its output is then hashed by L2-HASH, whose output is then hashed by L3-HASH. If the message being hashed is no longer than 1024 bytes, then L2-HASH is skipped as an optimization. Because L3-HASH outputs a string whose length is only four bytes long, multiple iterations of this three-layer hash are used if a total hash-output longer than four bytes is requested. To reduce memory use, L1-HASH reuses most of its key material between iterations. A significant amount of internal key is required for UHASH, but it remains constant so long as UMAC's key is unchanged. It is the implementer's choice whether to generate the internal keys each time a message is hashed, or to cache them between messages.",
      "ja": "UHASH はキー付きハッシュ関数で、任意の長さの文字列を入力として受け取り、4、8、12、または 16 バイトの出力を生成します。UHASH は 3 つのステージ、つまりレイヤーで動作します。メッセージは最初に L1-HASH でハッシュされ、その出力は次に L2-HASH でハッシュされ、その出力は L3-HASH でハッシュされます。ハッシュされるメッセージが 1024 バイト以下の場合、最適化のため L2-HASH はスキップされます。L3-HASH は 4 バイトの長さの文字列を出力するため、合計 4 バイトを超えるハッシュ出力が要求された場合、この 3 レイヤー ハッシュを複数回繰り返して使用します。メモリ使用量を削減するため、L1-HASH は繰り返しの間でキー マテリアルのほとんどを再利用します。UHASH には大量の内部キーが必要ですが、UMAC のキーが変更されない限り、その量は一定のままです。メッセージがハッシュされるたびに内部キーを生成するか、メッセージ間で内部キーをキャッシュするかは実装者が選択します。"
    },
    {
      "indent": 3,
      "text": "Please note that UHASH has certain combinatoric properties making it suitable for Wegman-Carter message authentication. UHASH is not a cryptographic hash function and is not a suitable general replacement for functions like SHA-1.",
      "ja": "UHASHは、Wegman-Carterメッセージ認証に適した特定の組み合わせ特性を備えていることにご注意ください。UHASHは暗号ハッシュ関数ではなく、SHA-1などの関数の一般的な代替として適していません。"
    },
    {
      "indent": 3,
      "text": "UHASH is presented here in a top-down manner. First, UHASH is described, then each of its component hashes is presented.",
      "ja": "ここではUHASHをトップダウン方式で説明します。まずUHASHについて説明し、次にUHASHを構成するハッシュをそれぞれ紹介します。"
    },
    {
      "indent": 0,
      "text": "5.1. UHASH Algorithm",
      "section_title": true,
      "ja": "5.1. UHASHアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  K, string of length KEYLEN bytes.\n  M, string of length less than 2^67 bits.\n  taglen, the integer 4, 8, 12 or 16.\nOutput:\n  Y, string of length taglen bytes.\n\nCompute Y using the following algorithm.\n\n  //\n  // One internal iteration per 4 bytes of output\n  //\n  iters = taglen / 4\n\n  //\n  // Define total key needed for all iterations using KDF.\n  // L1Key reuses most key material between iterations.\n  //\n  L1Key  = KDF(K, 1, 1024 + (iters - 1) * 16)\n  L2Key  = KDF(K, 2, iters * 24)\n  L3Key1 = KDF(K, 3, iters * 64)\n  L3Key2 = KDF(K, 4, iters * 4)\n\n  //\n  // For each iteration, extract key and do three-layer hash.\n  // If bytelength(M) <= 1024, then skip L2-HASH.\n  //\n  Y = <empty string>\n  for i = 1 to iters do\n    L1Key_i  = L1Key [(i-1) * 16 + 1 ... (i-1) * 16 + 1024]\n    L2Key_i  = L2Key [(i-1) * 24 + 1 ... i * 24]\n    L3Key1_i = L3Key1[(i-1) * 64 + 1 ... i * 64]\n    L3Key2_i = L3Key2[(i-1) * 4  + 1 ... i * 4]\n\n    A = L1-HASH(L1Key_i, M)\n    if (bitlength(M) <= bitlength(L1Key_i)) then\n      B = zeroes(8) || A\n    else\n      B = L2-HASH(L2Key_i, A)\n    end if\n    C = L3-HASH(L3Key1_i, L3Key2_i, B)\n    Y = Y || C\n  end for\n\n  Return Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2. L1-HASH: First-Layer Hash",
      "section_title": true,
      "ja": "5.2. L1-HASH：ファーストレイヤーハッシュ"
    },
    {
      "indent": 3,
      "text": "The first-layer hash breaks the message into 1024-byte chunks and hashes each with a function called NH. Concatenating the results forms a string, which is up to 128 times shorter than the original.",
      "ja": "ファーストレイヤーのハッシュは、メッセージを1024バイトのチャンクに分割し、それぞれがNHと呼ばれる関数でハッシュします。結果を連結すると、文字列が形成されますが、これは元の文字列よりも最大128倍短くなっています。"
    },
    {
      "indent": 0,
      "text": "5.2.1. L1-HASH Algorithm",
      "section_title": true,
      "ja": "5.2.1. L1-HASHアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  K, string of length 1024 bytes.\n  M, string of length less than 2^67 bits.\nOutput:\n  Y, string of length (8 * ceil(bitlength(M)/8192)) bytes.\n\nCompute Y using the following algorithm.\n\n  //\n  // Break M into 1024 byte chunks (final chunk may be shorter)\n  //\n  t = max(ceil(bitlength(M)/8192), 1)\n  Let M_1, M_2, ..., M_t be strings so that M = M_1 || M_2 || ... ||\n     M_t, and bytelength(M_i) = 1024 for all 0 < i < t.\n\n  //\n  // For each chunk, except the last: endian-adjust, NH hash\n  // and add bit-length.  Use results to build Y.\n  //\n  Len = uint2str(1024 * 8, 8)\n  Y = <empty string>\n  for i = 1 to t-1 do\n    ENDIAN-SWAP(M_i)\n    Y = Y || (NH(K, M_i) +_64 Len)\n  end for\n\n  //\n  // For the last chunk: pad to 32-byte boundary, endian-adjust,\n  // NH hash and add bit-length.  Concatenate the result to Y.\n  //\n  Len = uint2str(bitlength(M_t), 8)\n  M_t = zeropad(M_t, 32)\n  ENDIAN-SWAP(M_t)\n  Y = Y || (NH(K, M_t) +_64 Len)\n\n  return Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2.2. NH Algorithm",
      "section_title": true,
      "ja": "5.2.2. NHアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Because this routine is applied directly to every bit of input data, optimized implementation of it yields great benefit.",
      "ja": "このルーチンは入力データのすべてのビットに直接適用されるため、最適化された実装によって大きなメリットが得られます。"
    },
    {
      "indent": 3,
      "text": "Input:\n  K, string of length 1024 bytes.\n  M, string with length divisible by 32 bytes.\nOutput:\n  Y, string of length 8 bytes.\n\nCompute Y using the following algorithm.\n\n  //\n  // Break M and K into 4-byte chunks\n  //\n  t = bytelength(M) / 4\n  Let M_1, M_2, ..., M_t be 4-byte strings\n    so that M = M_1 || M_2 || ... || M_t.\n  Let K_1, K_2, ..., K_t be 4-byte strings\n    so that K_1 || K_2 || ... || K_t  is a prefix of K.\n\n  //\n  // Perform NH hash on the chunks, pairing words for multiplication\n  // which are 4 apart to accommodate vector-parallelism.\n  //\n  Y = zeroes(8)\n  i = 1\n  while (i < t) do\n    Y = Y +_64 ((M_{i+0} +_32 K_{i+0}) *_64 (M_{i+4} +_32 K_{i+4}))\n    Y = Y +_64 ((M_{i+1} +_32 K_{i+1}) *_64 (M_{i+5} +_32 K_{i+5}))\n    Y = Y +_64 ((M_{i+2} +_32 K_{i+2}) *_64 (M_{i+6} +_32 K_{i+6}))\n    Y = Y +_64 ((M_{i+3} +_32 K_{i+3}) *_64 (M_{i+7} +_32 K_{i+7}))\n    i = i + 8\n  end while\n\n  Return Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3. L2-HASH: Second-Layer Hash",
      "section_title": true,
      "ja": "5.3. L2-HASH：セカンドレイヤーハッシュ"
    },
    {
      "indent": 3,
      "text": "The second-layer rehashes the L1-HASH output using a polynomial hash called POLY. If the L1-HASH output is long, then POLY is called once on a prefix of the L1-HASH output and called using different settings on the remainder. (This two-step hashing of the L1-HASH output is needed only if the message length is greater than 16 megabytes.) Careful implementation of POLY is necessary to avoid a possible timing attack (see Section 6.6 for more information).",
      "ja": "第2層は、L1-HASH出力をPOLYと呼ばれる多項式ハッシュを用いて再ハッシュします。L1-HASH出力が長い場合、L1-HASH出力のプレフィックスに対してPOLYを1回呼び出し、残りの部分に対しては異なる設定を用いてPOLYを呼び出します。（このL1-HASH出力の2段階ハッシュは、メッセージ長が16MBを超える場合にのみ必要です。）タイミング攻撃の可能性を回避するために、POLYの実装には注意が必要です（詳細はセクション6.6を参照）。"
    },
    {
      "indent": 0,
      "text": "5.3.1. L2-HASH Algorithm",
      "section_title": true,
      "ja": "5.3.1. L2-HASHアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  K, string of length 24 bytes.\n  M, string of length less than 2^64 bytes.\nOutput:\n  Y, string of length 16 bytes.\n\nCompute y using the following algorithm.\n\n  //\n  //  Extract keys and restrict to special key-sets\n  //\n  Mask64  = uint2str(0x01ffffff01ffffff, 8)\n  Mask128 = uint2str(0x01ffffff01ffffff01ffffff01ffffff, 16)\n  k64    = str2uint(K[1...8]  and Mask64)\n  k128   = str2uint(K[9...24] and Mask128)\n\n  //\n  // If M is no more than 2^17 bytes, hash under 64-bit prime,\n  // otherwise, hash first 2^17 bytes under 64-bit prime and\n  // remainder under 128-bit prime.\n  //\n  if (bytelength(M) <= 2^17) then             // 2^14 64-bit words\n\n     //\n     // View M as an array of 64-bit words, and use POLY modulo\n     // prime(64) (and with bound 2^64 - 2^32) to hash it.\n     //\n     y = POLY(64, 2^64 - 2^32,  k64, M)\n  else\n     M_1 = M[1...2^17]\n     M_2 = M[2^17 + 1 ... bytelength(M)]\n     M_2 = zeropad(M_2 || uint2str(0x80,1), 16)\n     y = POLY(64, 2^64 - 2^32, k64, M_1)\n     y = POLY(128, 2^128 - 2^96, k128, uint2str(y, 16) || M_2)\n   end if\n\n  Y = uint2str(y, 16)\n\n  Return Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.2. POLY Algorithm",
      "section_title": true,
      "ja": "5.3.2. POLYアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  wordbits, the integer 64 or 128.\n  maxwordrange, positive integer less than 2^wordbits.\n  k, integer in the range 0 ... prime(wordbits) - 1.\n  M, string with length divisible by (wordbits / 8) bytes.\nOutput:\n  y, integer in the range 0 ... prime(wordbits) - 1.\n\nCompute y using the following algorithm.\n\n  //\n  // Define constants used for fixing out-of-range words\n  //\n  wordbytes = wordbits / 8\n  p = prime(wordbits)\n  offset = 2^wordbits - p\n  marker = p - 1\n\n  //\n  // Break M into chunks of length wordbytes bytes\n  //\n  n = bytelength(M) / wordbytes\n  Let M_1, M_2, ..., M_n be strings of length wordbytes bytes\n    so that M = M_1 || M_2 || ... || M_n\n\n  //\n  // Each input word m is compared with maxwordrange.  If not smaller\n  // then 'marker' and (m - offset), both in range, are hashed.\n  //\n  y = 1\n  for i = 1 to n do\n    m = str2uint(M_i)\n    if (m >= maxwordrange) then\n      y = (k * y + marker) mod p\n      y = (k * y + (m - offset)) mod p\n    else\n      y = (k * y + m) mod p\n    end if\n  end for\n\n  Return y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.4. L3-HASH: Third-Layer Hash",
      "section_title": true,
      "ja": "5.4. L3-HASH：サードレイヤーハッシュ"
    },
    {
      "indent": 3,
      "text": "The output from L2-HASH is 16 bytes long. This final hash function hashes the 16-byte string to a fixed length of 4 bytes.",
      "ja": "L2-Hashからの出力の長さは16バイトです。この最後のハッシュ関数は、16バイトの文字列を固定長の4バイトにハッシュします。"
    },
    {
      "indent": 0,
      "text": "5.4.1. L3-HASH Algorithm",
      "section_title": true,
      "ja": "5.4.1. L3-HASHアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Input:\n  K1, string of length 64 bytes.\n  K2, string of length 4 bytes.\n  M, string of length 16 bytes.\nOutput:\n  Y, string of length 4 bytes.\n\nCompute Y using the following algorithm.\n\n  y = 0\n\n  //\n  // Break M and K1 into 8 chunks and convert to integers\n  //\n  for i = 1 to 8 do\n    M_i = M [(i - 1) * 2 + 1 ... i * 2]\n    K_i = K1[(i - 1) * 8 + 1 ... i * 8]\n    m_i = str2uint(M_i)\n    k_i = str2uint(K_i) mod prime(36)\n  end for\n\n  //\n  // Inner-product hash, extract last 32 bits and affine-translate\n  //\n  y = (m_1 * k_1 + ... + m_8 * k_8) mod prime(36)\n  y = y mod 2^32\n  Y = uint2str(y, 4)\n  Y = Y xor K2\n\n  Return Y\n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "As a message authentication code specification, this entire document is about security. Here we describe some security considerations important for the proper understanding and use of UMAC.",
      "ja": "メッセージ認証コードの仕様として、このドキュメント全体はセキュリティに関するものです。ここでは、UMACの適切な理解と使用に重要なセキュリティ上の考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. Resistance to Cryptanalysis",
      "section_title": true,
      "ja": "6.1. 暗号化に対する耐性"
    },
    {
      "indent": 3,
      "text": "The strength of UMAC depends on the strength of its underlying cryptographic functions: the key-derivation function (KDF) and the pad-derivation function (PDF). In this specification, both operations are implemented using a block cipher, by default the Advanced Encryption Standard (AES). However, the design of UMAC allows for the replacement of these components. Indeed, it is possible to use other block ciphers or other cryptographic objects, such as (properly keyed) SHA-1 or HMAC for the realization of the KDF or PDF.",
      "ja": "UMACの強度は、基礎となる暗号化関数の強度、つまりキーダリベーション関数（KDF）とパッド剥離関数（PDF）に依存します。この仕様では、両方の操作がブロック暗号を使用して実装されています。デフォルトでは、Advanced暗号化標準（AES）です。ただし、UMACの設計により、これらのコンポーネントを交換できます。実際、KDFまたはPDFの実現には、（適切にキー付き）SHA-1やHMACなどの他のブロック暗号または他の暗号化オブジェクトを使用することが可能です。"
    },
    {
      "indent": 3,
      "text": "The core of the UMAC design, the UHASH function, does not depend on cryptographic assumptions: its strength is specified by a purely mathematical property stated in terms of collision probability, and this property is proven unconditionally [3, 6]. This means the strength of UHASH is guaranteed regardless of advances in cryptanalysis.",
      "ja": "UMACデザインの中核であるUhash関数は、暗号化の仮定に依存しません。その強度は、衝突確率の観点から述べられている純粋に数学的なプロパティによって指定され、この特性は無条件に証明されています[3、6]。これは、暗号化の進歩に関係なく、Uhashの強度が保証されることを意味します。"
    },
    {
      "indent": 3,
      "text": "The analysis of UMAC [3, 6] shows this scheme to have provable security, in the sense of modern cryptography, by way of tight reductions. What this means is that an adversarial attack on UMAC that forges with probability that significantly exceeds the established collision probability of UHASH will give rise to an attack of comparable complexity. This attack will break the block cipher, in the sense of distinguishing the block cipher from a family of random permutations. This design approach essentially obviates the need for cryptanalysis on UMAC: cryptanalytic efforts might as well focus on the block cipher, the results imply.",
      "ja": "UMAC [3、6]の分析は、このスキームが、緊密な削減によって、現代の暗号化の意味で、証明可能なセキュリティを持つことを示しています。これが意味することは、UHASHの確立された衝突確率を大幅に超える確率で鍛えられるUMACに対する敵対的な攻撃が、同等の複雑さの攻撃を引き起こすということです。この攻撃は、ブロック暗号をランダムな順列のファミリーと区別するという意味で、ブロック暗号を破壊します。この設計アプローチは、本質的にUMACでの暗号化の必要性を回避します。暗号化の取り組みは、ブロック暗号に焦点を合わせている可能性があり、結果は暗示されています。"
    },
    {
      "indent": 0,
      "text": "6.2. Tag Lengths and Forging Probability",
      "section_title": true,
      "ja": "6.2. タグの長さと偽造確率"
    },
    {
      "indent": 3,
      "text": "A MAC algorithm is used to authenticate messages between two parties that share a secret MAC key K. An authentication tag is computed for a message using K and, in some MAC algorithms such as UMAC, a nonce. Messages transmitted between parties are accompanied by their tag and, possibly, nonce. Breaking the MAC means that the attacker is able to generate, on its own, with no knowledge of the key K, a new message M (i.e., one not previously transmitted between the legitimate parties) and to compute on M a correct authentication tag under the key K. This is called a forgery. Note that if the authentication tag is specified to be of length t, then the attacker can trivially break the MAC with probability 1/2^t. For this, the attacker can just generate any message of its choice and try a random tag; obviously, the tag is correct with probability 1/2^t. By repeated guesses, the attacker can increase linearly its probability of success.",
      "ja": "MACアルゴリズムは、秘密MAC鍵Kを共有する2者間のメッセージを認証するために使用されます。メッセージの認証タグは、Kと、UMACなどの一部のMACアルゴリズムではノンスを用いて計算されます。当事者間で送信されるメッセージには、タグと、場合によってはノンスが付随します。MACを破るということは、攻撃者が鍵Kを知らずに、新しいメッセージM（つまり、正当な当事者間で以前に送信されたことのないメッセージ）を独自に生成し、鍵Kを用いてM上で正しい認証タグを計算できることを意味します。これは偽造と呼ばれます。認証タグの長さがtに指定されている場合、攻撃者は確率1/2^tでMACを簡単に破ることができることに注意してください。これを行うには、攻撃者は任意のメッセージを生成し、ランダムなタグを試すだけで済みます。明らかに、そのタグは確率1/2^tで正しいものです。攻撃者は推測を繰り返すことで、成功確率を線形的に高めることができます。"
    },
    {
      "indent": 3,
      "text": "In the case of UMAC-64, for example, the above guessing-attack strategy is close to optimal. An adversary can correctly guess an 8-byte UMAC tag with probability 1/2^64 by simply guessing a random value. The results of [3, 6] show that no attack strategy can produce a correct tag with probability better than 1/2^60 if UMAC were to use a random function in its work rather than AES. Another result [2], when combined with [3, 6], shows that so long as AES is secure as a pseudorandom permutation, it can be used instead of a random function without significantly increasing the 1/2^60 forging probability, assuming that no more than 2^64 messages are authenticated. Likewise, 32-, 96-, and 128-bit tags cannot be forged with more than 1/2^30, 1/2^90, and 1/2^120 probability plus the probability of a successful attack against AES as a pseudorandom permutation.",
      "ja": "例えばUMAC-64の場合、上記の推測攻撃戦略はほぼ最適である。攻撃者はランダムな値を推測するだけで、8バイトのUMACタグを1/2^64の確率で正しく推測できる。[3, 6]の結果は、UMACがAESではなくランダム関数を使用する場合、1/2^60より高い確率で正しいタグを生成する攻撃戦略は存在しないことを示している。[2]の別の結果と[3, 6]を組み合わせると、AESが疑似ランダム順列として安全である限り、認証されるメッセージが2^64以下であれば、1/2^60の偽造確率を大幅に増加させることなく、ランダム関数の代わりにAESを使用できることがわかる。同様に、32 ビット、96 ビット、および 128 ビットのタグは、1/2^30、1/2^90、および 1/2^120 の確率と、疑似ランダム順列としての AES に対する攻撃が成功する確率以上では偽造できません。"
    },
    {
      "indent": 3,
      "text": "AES has undergone extensive study and is assumed to be very secure as a pseudorandom permutation. If we assume that no attacker with feasible computational power can distinguish randomly-keyed AES from a randomly-chosen permutation with probability delta (more precisely, delta is a function of the computational resources of the attacker and of its ability to sample the function), then we obtain that no such attacker can forge UMAC with probability greater than 1/2^30, 1/^60, 1/2^90, or 1/2^120, plus 3*delta. Over N forgery attempts, forgery occurs with probability no more than N/2^30, N/^60, N/2^90, or N/2^120, plus 3*delta. The value delta may exceed 1/2^30, 1/2^60, 1/2^90, or 1/2^120, in which case the probability of UMAC forging is dominated by a term representing the security of AES.",
      "ja": "AESは広範囲に研究され、疑似ランダム順列として非常に安全であると想定されています。実現可能な計算能力を持つ攻撃者が、ランダム鍵AESとランダムに選択された順列を確率デルタ（より正確には、デルタは攻撃者の計算リソースと関数をサンプリングする能力の関数）で区別できないと仮定すると、そのような攻撃者は1/2^30、1/^60、1/2^90、または1/2^120に3*デルタを加えた値を超える確率でUMACを偽造できないことがわかります。N回の偽造試行において、偽造が発生する確率はN/2^30、N/^60、N/2^90、またはN/2^120に3*デルタを加えた値以下です。値のデルタは 1/2^30、1/2^60、1/2^90、または 1/2^120 を超える場合があり、その場合、UMAC 偽造の確率は AES のセキュリティを表す項によって左右されます。"
    },
    {
      "indent": 3,
      "text": "With UMAC, off-line computation aimed at exceeding the forging probability is hopeless as long as the underlying cipher is not broken. An attacker attempting to forge UMAC tags will need to interact with the entity that verifies message tags and try a large number of forgeries before one is likely to succeed. The system architecture will determine the extent to which this is possible. In a well-architected system, there should not be any high-bandwidth capability for presenting forged MACs and determining if they are valid. In particular, the number of authentication failures at the verifying party should be limited. If a large number of such attempts are detected, the session key in use should be dropped and the event be recorded in an audit log.",
      "ja": "UMACでは、基盤となる暗号が破られない限り、偽造確率を超えることを目的としたオフライン計算は不可能です。UMACタグの偽造を試みる攻撃者は、メッセージタグを検証するエンティティとやり取りし、成功確率が上がるまでに多数の偽造を試行する必要があります。これがどの程度可能であるかは、システムアーキテクチャによって決まります。適切に設計されたシステムでは、偽造されたMACを提示し、その有効性を判断するために高帯域幅の能力を必要としません。特に、検証側での認証失敗回数を制限する必要があります。このような試行が多数検出された場合、使用中のセッションキーを削除し、そのイベントを監査ログに記録する必要があります。"
    },
    {
      "indent": 3,
      "text": "Let us reemphasize: a forging probability of 1/2^60 does not mean that there is an attack that runs in 2^60 time; to the contrary, as long as the block cipher in use is not broken there is no such attack for UMAC. Instead, a 1/2^60 forging probability means that if an attacker could have N forgery attempts, then the attacker would have no more than N/2^60 probability of getting one or more of them right.",
      "ja": "改めて強調しておきますが、偽造確率が1/2^60であるということは、2^60の時間で実行される攻撃が存在するという意味ではありません。むしろ、使用されているブロック暗号が破られない限り、UMACに対してそのような攻撃は存在しません。偽造確率が1/2^60であるということは、攻撃者がN回の偽造試行を行った場合、そのうち1回以上正解する確率はN/2^60以下であることを意味します。"
    },
    {
      "indent": 3,
      "text": "It should be pointed out that once an attempted forgery is successful, it is possible, in principle, that subsequent messages under this key may be easily forged. This is important to understand in gauging the severity of a successful forgery, even though no such attack on UMAC is known to date.",
      "ja": "一度偽造の試みが成功すると、原理的には、この鍵を使用した後続のメッセージも容易に偽造される可能性があることを指摘しておく必要があります。UMACに対するそのような攻撃は今のところ知られていませんが、偽造の成功の重大性を判断する上で、この点を理解することが重要です。"
    },
    {
      "indent": 3,
      "text": "In conclusion, 64-bit tags seem appropriate for many security architectures and commercial applications. If one wants a more conservative option, at a cost of about 50% or 100% more computation, UMAC can produce 96- or 128-bit tags that have basic collision probabilities of at most 1/2^90 and 1/2^120. If one needs less security, with the benefit of about 50% less computation, UMAC can produce 32-bit tags. In this case, under the same assumptions as before, one cannot forge a message with probability better than 1/2^30. Special care must be taken when using 32-bit tags because 1/2^30 forgery probability is considered fairly high. Still, high-speed low-security authentication can be applied usefully on low-value data or rapidly-changing key environments.",
      "ja": "結論として、64 ビット タグは多くのセキュリティ アーキテクチャと商用アプリケーションに適していると思われます。より保守的なオプションが必要な場合は、約 50% または 100% 多くの計算コストがかかりますが、UMAC は、最大で 1/2^90 と 1/2^120 の基本衝突確率を持つ 96 ビットまたは 128 ビットのタグを生成できます。それほどセキュリティを必要としない場合は、計算が約 50% 少なくなるという利点で、UMAC は 32 ビットのタグを生成できます。この場合、前と同じ仮定の下では、1/2^30 よりも高い確率でメッセージを偽造することはできません。1/2^30 の偽造確率はかなり高いと考えられるため、32 ビット タグを使用する場合は特別な注意が必要です。それでも、高速でセキュリティの低い認証は、価値の低いデータや急速に変化するキー環境に適用できます。"
    },
    {
      "indent": 0,
      "text": "6.3. Nonce Considerations",
      "section_title": true,
      "ja": "6.3. ノンスの考慮事項"
    },
    {
      "indent": 3,
      "text": "UMAC requires a nonce with length in the range 1 to BLOCKLEN bytes. All nonces in an authentication session must be equal in length. For secure operation, no nonce value should be repeated within the life of a single UMAC session key. There is no guarantee of message authenticity when a nonce is repeated, and so messages accompanied by a repeated nonce should be considered inauthentic.",
      "ja": "UMACは、1バイトからBLOCKLENバイトまでの長さのノンスを必要とします。認証セッション内のすべてのノンスの長さは同じでなければなりません。安全な運用のために、単一のUMACセッション鍵の有効期間中は、ノンス値が重複してはなりません。ノンスが重複した場合、メッセージの真正性は保証されません。したがって、ノンスが重複しているメッセージは真正ではないとみなされます。"
    },
    {
      "indent": 3,
      "text": "To authenticate messages over a duplex channel (where two parties send messages to each other), a different key could be used for each direction. If the same key is used in both directions, then it is crucial that all nonces be distinct. For example, one party can use even nonces while the other party uses odd ones. The receiving party must verify that the sender is using a nonce of the correct form.",
      "ja": "双方向チャネル（2者が互いにメッセージを送信するチャネル）でメッセージを認証するには、方向ごとに異なる鍵を使用できます。双方向で同じ鍵を使用する場合は、すべてのナンスが異なっていることが重要です。例えば、一方の当事者が偶数のナンスを使用し、もう一方の当事者が奇数のナンスを使用するといったことが可能です。受信側は、送信者が正しい形式のナンスを使用していることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "This specification does not indicate how nonce values are created, updated, or communicated between the entity producing a tag and the entity verifying a tag. The following are possibilities:",
      "ja": "この仕様では、タグを生成するエンティティとタグを検証するエンティティの間で、ノンス値がどのように作成、更新、または通信されるかについては規定していません。以下の可能性が考えられます。"
    },
    {
      "indent": 3,
      "text": "1. The nonce is an 8-byte unsigned number, Counter, which is initialized to zero, which is incremented by one following the generation of each authentication tag, and which is always communicated along with the message and the authentication tag. An error occurs at the sender if there is an attempt to authenticate more than 2^64 messages within a session.",
      "ja": "1. ノンスは8バイトの符号なし数値（Counter）であり、0に初期化され、認証タグが生成されるたびに1ずつ増加し、常にメッセージと認証タグと共に通信されます。1つのセッション内で2^64を超えるメッセージの認証を試行すると、送信側でエラーが発生します。"
    },
    {
      "indent": 3,
      "text": "2. The nonce is a BLOCKLEN-byte unsigned number, Counter, which is initialized to zero and which is incremented by one following the generation of each authentication tag. The Counter is not explicitly communicated between the sender and receiver. Instead, the two are assumed to communicate over a reliable transport, and each maintains its own counter so as to keep track of what the current nonce value is.",
      "ja": "2. nonceはBLOCKLENバイトの符号なし数値Counterで、0に初期化され、認証タグが生成されるたびに1ずつ増加します。Counterは送信者と受信者の間で明示的に伝達されることはありません。送信者と受信者は信頼性の高いトランスポートを介して通信することが前提とされており、それぞれが現在のnonce値を追跡するために独自のCounterを保持しています。"
    },
    {
      "indent": 3,
      "text": "3. The nonce is a BLOCKLEN-byte random value. (Because repetitions in a random n-bit value are expected at around 2^(n/2) trials, the number of messages to be communicated in a session using n-bit nonces should not be allowed to approach 2^(n/2).)",
      "ja": "3. NonCeはブロックバイバイトのランダム値です。（ランダムなn-bit値の繰り返しは約2^（n/2）試行で予想されるため、n-bit noncesを使用したセッションで伝達されるメッセージの数は2^（n/2に近づくことを許可されないでください）。）"
    },
    {
      "indent": 3,
      "text": "We emphasize that the value of the nonce need not be kept secret.",
      "ja": "nonce の値を秘密にする必要がないことを強調します。"
    },
    {
      "indent": 3,
      "text": "When UMAC is used within a higher-level protocol, there may already be a field, such as a sequence number, which can be co-opted so as to specify the nonce needed by UMAC [5]. The application will then specify how to construct the nonce from this already-existing field.",
      "ja": "UMACが高レベルのプロトコル内で使用される場合、Sequence番号などのフィールドが既にある可能性があります。これは、UMACが必要とする非CEを指定するために採用できます[5]。その後、アプリケーションは、この既存のフィールドからノンスを構築する方法を指定します。"
    },
    {
      "indent": 0,
      "text": "6.4. Replay Attacks",
      "section_title": true,
      "ja": "6.4. リプレイ攻撃"
    },
    {
      "indent": 3,
      "text": "A replay attack entails the attacker repeating a message, nonce, and authentication tag. In many applications, replay attacks may be quite damaging and must be prevented. In UMAC, this would normally be done at the receiver by having the receiver check that no nonce value is used twice. On a reliable connection, when the nonce is a counter, this is trivial. On an unreliable connection, when the nonce is a counter, one would normally cache some window of recent nonces. Out-of-order message delivery in excess of what the window allows will result in rejecting otherwise valid authentication tags. We emphasize that it is up to the receiver when a given (message, nonce, tag) triple will be deemed authentic. Certainly, the tag should be valid for the message and nonce, as determined by UMAC, but the message may still be deemed inauthentic because the nonce is detected to be a replay.",
      "ja": "リプレイ攻撃には、攻撃者がメッセージ、NonCE、および認証タグを繰り返していることを伴います。多くのアプリケーションでは、リプレイ攻撃は非常に損害を与える可能性があり、防止する必要があります。UMACでは、これは通常、受信機に2回使用されていないことを受信機にチェックさせることにより、受信機で行われます。信頼できる接続では、ノンスがカウンターである場合、これは些細なことです。信頼できない接続では、ノンスがカウンターである場合、通常、最近のノンスのウィンドウをキャッシュします。ウィンドウが許可するものを超えるオーダーアウトメッセージ配信により、他の方法では有効な認証タグが拒否されます。特定の（メッセージ、ノンス、タグ）トリプルが本物と見なされる場合、レシーバー次第であることを強調します。確かに、UMACによって決定されるように、タグはメッセージとNonCEに対して有効である必要がありますが、ノンスがリプレイであると検出されるため、メッセージは依然として不正であるとみなされる場合があります。"
    },
    {
      "indent": 0,
      "text": "6.5. Tag-Prefix Verification",
      "section_title": true,
      "ja": "6.5. Tag-Prefix検証"
    },
    {
      "indent": 3,
      "text": "UMAC's definition makes it possible to implement tag-prefix verification; for example, a receiver might verify only the 32-bit prefix of a 64-bit tag if its computational load is high. Or a receiver might reject out-of-hand a 64-bit tag whose 32-bit prefix is incorrect. Such practices are potentially dangerous and can lead to attacks that reduce the security of the session to the length of the verified prefix. A UMAC key (or session) must have an associated and immutable tag length and the implementation should not leak information that would reveal if a given proper prefix of a tag is valid or invalid.",
      "ja": "UMACの定義により、Tag-Prefix検証を実装できます。たとえば、レシーバーは、計算負荷が高い場合、64ビットタグの32ビットプレフィックスのみを確認できます。または、レシーバーは、32ビットのプレフィックスが正しくない64ビットタグを手で拒否する場合があります。このようなプラクティスは潜在的に危険であり、セッションのセキュリティを検証済みのプレフィックスの長さまで減らす攻撃につながる可能性があります。UMACキー（またはセッション）には、関連付けられた不変のタグの長さが必要であり、実装は、タグの特定の適切なプレフィックスが有効または無効である場合に明らかにする情報を漏らしてはなりません。"
    },
    {
      "indent": 0,
      "text": "6.6. Side-Channel Attacks",
      "section_title": true,
      "ja": "6.6. サイドチャネル攻撃"
    },
    {
      "indent": 3,
      "text": "Side-channel attacks have the goal of subverting the security of a cryptographic system by exploiting its implementation characteristics. One common side-channel attack is to measure system response time and derive information regarding conditions met by the data being processed. Such attacks are known as \"timing attacks\". Discussion of timing and other side-channel attacks is outside of this document's scope. However, we warn that there are places in the UMAC algorithm where timing information could be unintentionally leaked. In particular, the POLY algorithm (Section 5.3.2) tests whether a value m is out of a particular range, and the behavior of the algorithm differs depending on the result. If timing attacks are to be avoided, care should be taken to equalize the computation time in both cases. Timing attacks can also occur for more subtle reasons, including caching effects.",
      "ja": "サイドチャネル攻撃には、実装特性を活用することにより、暗号化システムのセキュリティを破壊するという目標があります。一般的なサイドチャネル攻撃の1つは、システムの応答時間を測定し、処理されるデータによって満たされた条件に関する情報を導き出すことです。このような攻撃は「タイミング攻撃」として知られています。タイミングおよびその他のサイドチャネル攻撃の議論は、このドキュメントの範囲外です。ただし、タイミング情報が意図せずにリークされる可能性があるUMACアルゴリズムには場所があることを警告します。特に、ポリアルゴリズム（セクション5.3.2）は、値mが特定の範囲から外れているかどうかをテストし、アルゴリズムの動作は結果によって異なります。タイミング攻撃を回避する場合、どちらの場合も計算時間を均等にするように注意する必要があります。また、キャッシュ効果など、より微妙な理由でタイミング攻撃が発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgements",
      "section_title": true,
      "ja": "7. 謝辞"
    },
    {
      "indent": 3,
      "text": "David McGrew and Scott Fluhrer, of Cisco Systems, played a significant role in improving UMAC by encouraging us to pay more attention to the performance of short messages. Thanks go to Jim Schaad and to those who made helpful suggestions to the CFRG mailing list for improving this document during RFC consideration. Black, Krovetz, and Rogaway have received support for this work under NSF awards 0208842, 0240000, and 9624560, and a gift from Cisco Systems.",
      "ja": "Cisco SystemsのDavid McGrewとScott Fluhrerは、短いメッセージのパフォーマンスにもっと注意を払うことを奨励することで、UMACを改善する上で重要な役割を果たしました。Jim Schaadと、RFCの検討中にこのドキュメントを改善してくれたCFRGメーリングリストに有益な提案をした人に感謝します。Black、Krovetz、およびRogawayは、NSF Awards 0208842、0240000、および9624560の下でこの作業を支持しており、Cisco Systemsからの贈り物を受けています。"
    },
    {
      "indent": 0,
      "text": "Appendix. Test Vectors",
      "section_title": true,
      "ja": "Appendix. テストベクトル"
    },
    {
      "indent": 3,
      "text": "Following are some sample UMAC outputs over a collection of input values, using AES with 16-byte keys. Let",
      "ja": "以下は、16バイトの鍵を持つAESを使用して、入力値の集合に対するUMAC出力のサンプルです。"
    },
    {
      "indent": 5,
      "text": "K  = \"abcdefghijklmnop\"                  // A 16-byte UMAC key\nN  = \"bcdefghi\"                          // An 8-byte nonce",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The tags generated by UMAC using key K and nonce N are:",
      "ja": "キーKとノンスnを使用してUMACによって生成されたタグは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "Message      32-bit Tag    64-bit Tag            96-bit Tag\n-------      ----------    ----------            ----------\n<empty>       113145FB  6E155FAD26900BE1  32FEDB100C79AD58F07FF764\n'a' * 3       3B91D102  44B5CB542F220104  185E4FE905CBA7BD85E4C2DC\n'a' * 2^10    599B350B  26BF2F5D60118BD9  7A54ABE04AF82D60FB298C3C\n'a' * 2^15    58DCF532  27F8EF643B0D118D  7B136BD911E4B734286EF2BE\n'a' * 2^20    DB6364D1  A4477E87E9F55853  F8ACFA3AC31CFEEA047F7B11\n'a' * 2^25    5109A660  2E2DBC36860A0A5F  72C6388BACE3ACE6FBF062D9\n'abc' * 1     ABF3A3A0  D4D7B9F6BD4FBFCF  883C3D4B97A61976FFCF2323\n'abc' * 500   ABEB3C8B  D4CF26DDEFD5C01A  8824A260C53C66A36C9260A6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first column lists a small sample of messages that are strings of repeated ASCII 'a' bytes or 'abc' strings. The remaining columns give in hexadecimal the tags generated when UMAC is called with the corresponding message, nonce N and key K.",
      "ja": "最初の列には、ASCII 文字の「a」バイトまたは「abc」文字列が繰り返されるメッセージの小さなサンプルがリストされています。残りの列には、対応するメッセージ、ノンス N、キー K を指定して UMAC が呼び出されたときに生成されるタグが 16 進数で示されています。"
    },
    {
      "indent": 3,
      "text": "When using key K and producing a 64-bit tag, the following relevant keys are generated:",
      "ja": "キーKを使用して64ビットタグを作成する場合、次の関連キーが生成されます。"
    },
    {
      "indent": 5,
      "text": "                         Iteration 1         Iteration 2\n                         -----------         -----------\nNH (Section 5.2.2)\n\n  K_1                     ACD79B4F            C6DFECA2\n  K_2                     6EDA0D0E            964A710D\n  K_3                     1625B603            AD7EDE4D\n  K_4                     84F9FC93            A1D3935E\n  K_5                     C6DFECA2            62EC8672\n  ...\n  K_256                   0BF0F56C            744C294F\n\nL2-HASH (Section 5.3.1)\n\n  k64             0094B8DD0137BEF8    01036F4D000E7E72\n\nL3-HASH (Section 5.4.1)\n\n  k_5                   056533C3A8          0504BF4D4E\n  k_6                   07591E062E          0126E922FF\n  k_7                   0C2D30F89D          030C0399E2\n  k_8                   046786437C          04C1CB8FED\n  K2                      2E79F461            A74C03AA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(Note that k_1 ... k_4 are not listed in this example because they are multiplied by zero in L3-HASH.)",
      "ja": "（K_1 ... K_4は、L3-HASHでゼロを掛けているため、この例にはリストされていません。）"
    },
    {
      "indent": 3,
      "text": "When generating a 64-bit tag on input \"'abc' * 500\", the following intermediate results are produced:",
      "ja": "入力「 'ABC * 500」で64ビットタグを生成する場合、次の中間結果が生成されます。"
    },
    {
      "indent": 5,
      "text": "              Iteration 1\n              -----------\nL1-HASH  E6096F94EDC45CAC1BEDCD0E7FDAA906\nL2-HASH  0000000000000000A6C537D7986FA4AA\nL3-HASH  05F86309",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "              Iteration 2\n              -----------\nL1-HASH  2665EAD321CFAE79C82F3B90261641E5\nL2-HASH  00000000000000001D79EAF247B394BF\nL3-HASH  DF9AD858",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Concatenating the two L3-HASH results produces a final UHASH result of 05F86309DF9AD858. The pad generated for nonce N is D13745D4304F1842, which when xor'ed with the L3-HASH result yields a tag of D4CF26DDEFD5C01A.",
      "ja": "2つのL3-HASH結果を連結すると、05F86309DF9AD858の最終的なUHASH結果が生成されます。NonCe N用に生成されたパッドはD13745D4304F1842であり、L3-HASH結果でXOR'edがD4CF26DDEFD5C01Aのタグを生成します。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "参考文献"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用文献"
    },
    {
      "indent": 3,
      "text": "[1] FIPS-197, \"Advanced Encryption Standard (AES)\", National Institute of Standards and Technology, 2001.",
      "ja": "[1] FIPS-197、「Advanced Encryption Standard（AES）」、国立標準技術研究所、2001年。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考引用"
    },
    {
      "indent": 3,
      "text": "[2] D. Bernstein, \"Stronger security bounds for permutations\", unpublished manuscript, 2005. This work refines \"Stronger security bounds for Wegman-Carter-Shoup authenticators\", Advances in Cryptology - EUROCRYPT 2005, LNCS vol. 3494, pp. 164-180, Springer-Verlag, 2005.",
      "ja": "[2] D.バーンスタイン、「順列のより強力なセキュリティ境界」、未発表の原稿、2005年。この作業は、「Wegman-Carter-Shoup Authenticatorsのより強いセキュリティ境界線」を洗練し、暗号化の進歩-EuroCrypt 2005、LNCS Vol。3494、pp。164-180、Springer-Verlag、2005。"
    },
    {
      "indent": 3,
      "text": "[3] J. Black, S. Halevi, H. Krawczyk, T. Krovetz, and P. Rogaway, \"UMAC: Fast and provably secure message authentication\", Advances in Cryptology - CRYPTO '99, LNCS vol. 1666, pp. 216- 233, Springer-Verlag, 1999.",
      "ja": "[3] J. Black、S。Halevi、H。Krawczyk、T。Krovetz、およびP. Rogaway、「UMAC：高速かつ証明されたメッセージ認証」、暗号学の進歩-Crypto '99、LNCS Vol。1666、pp。216-233、Springer-Verlag、1999。"
    },
    {
      "indent": 3,
      "text": "[4] L. Carter and M. Wegman, \"Universal classes of hash functions\", Journal of Computer and System Sciences, 18 (1979), pp. 143- 154.",
      "ja": "[4] L.カーターとM.ウェグマン、「ハッシュ機能のユニバーサルクラス」、Journal of Computer and System Sciences、18（1979）、pp。143-154。"
    },
    {
      "indent": 3,
      "text": "[5] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[5] Kent、S。、「セキュリティペイロード（ESP）のカプセル化IP」、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[6] T. Krovetz, \"Software-optimized universal hashing and message authentication\", UMI Dissertation Services, 2000.",
      "ja": "[6] T. Krovetz、「ソフトウェアが最適化されたユニバーサルハッシュおよびメッセージ認証」、UMI論文サービス、2000。"
    },
    {
      "indent": 3,
      "text": "[7] M. Wegman and L. Carter, \"New hash functions and their use in authentication and set equality\", Journal of Computer and System Sciences, 22 (1981), pp. 265-279.",
      "ja": "[7] M.ウェグマンとL.カーター、「新しいハッシュ機能と認証とセットの平等におけるそれらの使用」、Journal of Computer and System Sciences、22（1981）、pp。265-279。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "John Black Department of Computer Science University of Colorado Boulder, CO 80309 USA",
      "ja": "ジョンブラックコンピュータサイエンス大学コロラド大学ボルダー、コロラド州80309米国"
    },
    {
      "indent": 3,
      "text": "EMail: jrblack@cs.colorado.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Shai Halevi IBM T.J. Watson Research Center P.O. Box 704 Yorktown Heights, NY 10598 USA",
      "ja": "Shai Halevi Ibm T.J.ワトソン研究センターP.O.ボックス704ヨークタウンハイツ、ニューヨーク10598 USA"
    },
    {
      "indent": 3,
      "text": "EMail: shaih@alum.mit.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Alejandro Hevia Department of Computer Science University of Chile Santiago 837-0459 CHILE",
      "ja": "アレハンドロヘビアコンピュータサイエンス学科チリサンティアゴ837-0459チリ"
    },
    {
      "indent": 3,
      "text": "EMail: ahevia@dcc.uchile.cl",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hugo Krawczyk IBM Research 19 Skyline Dr Hawthorne, NY 10533 USA",
      "ja": "Hugo Krawczyk IBM Research 19 Skyline Dr Hawthorne、NY 10533 USA"
    },
    {
      "indent": 3,
      "text": "EMail: hugo@ee.technion.ac.il",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ted Krovetz (Editor) Department of Computer Science California State University Sacramento, CA 95819 USA",
      "ja": "テッドクロベッツ（編集者）コンピュータサイエンス学科カリフォルニア州立大学サクラメント、カリフォルニア州95819米国"
    },
    {
      "indent": 3,
      "text": "EMail: tdk@acm.org\n   Phillip Rogaway\nDepartment of Computer Science\nUniversity of California\nDavis, CA 95616\nUSA\nand\nDepartment of Computer Science\nFaculty of Science\nChiang Mai University\nChiang Mai 50200\nTHAILAND",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EMail: rogaway@cs.ucdavis.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要なテクノロジーをカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます。"
    }
  ]
}