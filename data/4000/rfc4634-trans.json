{
  "title": {
    "text": "RFC 4634 - US Secure Hash Algorithms (SHA and HMAC-SHA)",
    "ja": "RFC 4634 - USセキュアハッシュアルゴリズム（SHAおよびHMAC-SHA）"
  },
  "number": 4634,
  "created_at": "2020-08-15 18:32:42.221535+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                    D. Eastlake 3rd\nRequest for Comments: 4634                                 Motorola Labs\nUpdates: 3174                                                  T. Hansen\nCategory: Informational                                        AT&T Labs\n                                                               July 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "US Secure Hash Algorithms (SHA and HMAC-SHA)",
      "ja": "USセキュアハッシュアルゴリズム（SHAおよびHMAC-SHA）"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準も規定していません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（C）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The United States of America has adopted a suite of Secure Hash Algorithms (SHAs), including four beyond SHA-1, as part of a Federal Information Processing Standard (FIPS), specifically SHA-224 (RFC 3874), SHA-256, SHA-384, and SHA-512. The purpose of this document is to make source code performing these hash functions conveniently available to the Internet community. The sample code supports input strings of arbitrary bit length. SHA-1's sample code from RFC 3174 has also been updated to handle input strings of arbitrary bit length. Most of the text herein was adapted by the authors from FIPS 180-2.",
      "ja": "アメリカ合衆国は、連邦情報処理標準（FIPS）、特にSHA-224（RFC 3874）、SHA-256、SHAの一部として、SHA-1を超える4つを含む一連のセキュアハッシュアルゴリズム（SHA）を採用しています。 -384、およびSHA-512。このドキュメントの目的は、これらのハッシュ関数を実行するソースコードをインターネットコミュニティで便利に利用できるようにすることです。サンプルコードは、任意のビット長の入力文字列をサポートしています。 RFC 3174のSHA-1のサンプルコードも更新され、任意のビット長の入力文字列を処理できるようになりました。ここでのテキストのほとんどは、FIPS 180-2の作成者によって修正されました。"
    },
    {
      "indent": 3,
      "text": "Code to perform SHA-based HMACs, with arbitrary bit length text, is also included.",
      "ja": "任意のビット長のテキストで、SHAベースのHMACを実行するコードも含まれています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Overview of Contents ............................................3\n   1.1. License ....................................................4\n2. Notation for Bit Strings and Integers ...........................4\n3. Operations on Words .............................................5\n4. Message Padding and Parsing .....................................6\n   4.1. SHA-224 and SHA-256 ........................................7\n   4.2. SHA-384 and SHA-512 ........................................8\n5. Functions and Constants Used ....................................9\n   5.1. SHA-224 and SHA-256 ........................................9\n   5.2. SHA-384 and SHA-512 .......................................10\n6. Computing the Message Digest ...................................11\n   6.1. SHA-224 and SHA-256 Initialization ........................11\n   6.2. SHA-224 and SHA-256 Processing ............................11\n   6.3. SHA-384 and SHA-512 Initialization ........................13\n   6.4. SHA-384 and SHA-512 Processing ............................14\n7. SHA-Based HMACs ................................................15\n8. C Code for SHAs ................................................15\n   8.1. The .h File ...............................................18\n   8.2. The SHA Code ..............................................24\n        8.2.1. sha1.c .............................................24\n        8.2.2. sha224-256.c .......................................33\n        8.2.3. sha384-512.c .......................................45\n        8.2.4. usha.c .............................................67\n        8.2.5. sha-private.h ......................................72\n   8.3. The HMAC Code .............................................73\n   8.4. The Test Driver ...........................................78\n9. Security Considerations .......................................106\n10. Normative References .........................................106\n11. Informative References .......................................106",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Overview of Contents",
      "section_title": true,
      "ja": "1. 内容の概要"
    },
    {
      "indent": 3,
      "text": "NOTE: Much of the text below is taken from [FIPS180-2] and assertions therein of the security of the algorithms described are made by the US Government, the author of [FIPS180-2], and not by the authors of this document.",
      "ja": "注：以下のテキストの多くは[FIPS180-2]から引用されており、その中で説明されているアルゴリズムのセキュリティに関するアサーションは、[FIPS180-2]の作成者である米国政府によって作成され、このドキュメントの作成者によって作成されたものではありません。"
    },
    {
      "indent": 3,
      "text": "The text below specifies Secure Hash Algorithms, SHA-224 [RFC3874], SHA-256, SHA-384, and SHA-512, for computing a condensed representation of a message or a data file. (SHA-1 is specified in [RFC3174].) When a message of any length < 2^64 bits (for SHA-224 and SHA-256) or < 2^128 bits (for SHA-384 and SHA-512) is input to one of these algorithms, the result is an output called a message digest. The message digests range in length from 224 to 512 bits, depending on the algorithm. Secure hash algorithms are typically used with other cryptographic algorithms, such as digital signature algorithms and keyed hash authentication codes, or in the generation of random numbers [RFC4086].",
      "ja": "以下のテキストは、メッセージまたはデータファイルの圧縮表現を計算するためのセキュアハッシュアルゴリズム、SHA-224 [RFC3874]、SHA-256、SHA-384、およびSHA-512を指定しています。 （SHA-1は[RFC3174]で指定されています。）長さが<2 ^ 64ビット（SHA-224およびSHA-256の場合）または<2 ^ 128ビット（SHA-384およびSHA-512の場合）のメッセージがこれらのアルゴリズムのいずれかに入力すると、結果はメッセージダイジェストと呼ばれる出力になります。メッセージダイジェストの長さは、アルゴリズムに応じて、224〜512ビットです。安全なハッシュアルゴリズムは、通常、デジタル署名アルゴリズムやキー付きハッシュ認証コードなどの他の暗号化アルゴリズムとともに、または乱数の生成に使用されます[RFC4086]。"
    },
    {
      "indent": 3,
      "text": "The four algorithms specified in this document are called secure because it is computationally infeasible to (1) find a message that corresponds to a given message digest, or (2) find two different messages that produce the same message digest. Any change to a message in transit will, with very high probability, result in a different message digest. This will result in a verification failure when the secure hash algorithm is used with a digital signature algorithm or a keyed-hash message authentication algorithm.",
      "ja": "このドキュメントで指定されている4つのアルゴリズムは、（1）特定のメッセージダイジェストに対応するメッセージを見つける、または（2）同じメッセージダイジェストを生成する2つの異なるメッセージを見つけることが計算上実行不可能であるため、セキュアと呼ばれます。送信中のメッセージに対する変更は、非常に高い確率で、別のメッセージダイジェストになります。これにより、安全なハッシュアルゴリズムがデジタル署名アルゴリズムまたはキー付きハッシュメッセージ認証アルゴリズムと一緒に使用されると、検証が失敗します。"
    },
    {
      "indent": 3,
      "text": "The code provided herein supports input strings of arbitrary bit length. SHA-1's sample code from [RFC3174] has also been updated to handle input strings of arbitrary bit length. See Section 1.1 for license information for this code.",
      "ja": "ここで提供されるコードは、任意のビット長の入力文字列をサポートします。 [RFC3174]のSHA-1のサンプルコードも更新され、任意のビット長の入力文字列を処理できるようになりました。このコードのライセンス情報については、セクション1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Section 2 below defines the terminology and functions used as building blocks to form these algorithms. Section 3 describes the fundamental operations on words from which these algorithms are built. Section 4 describes how messages are padded up to an integral multiple of the required block size and then parsed into blocks. Section 5 defines the constants and the composite functions used to specify these algorithms. Section 6 gives the actual specification for the SHA-224, SHA-256, SHA-384, and SHA-512 functions. Section 7 provides pointers to the specification of HMAC keyed message authentication codes based on the SHA algorithms. Section 8 gives sample code for the SHA algorithms and Section 9 code for SHA-based HMACs. The SHA-based HMACs will accept arbitrary bit length text.",
      "ja": "以下のセクション2では、これらのアルゴリズムを形成するためのビルディングブロックとして使用される用語と機能を定義します。セクション3では、これらのアルゴリズムが構築されている単語に対する基本的な操作について説明します。セクション4では、メッセージが必要なブロックサイズの整数倍になるまでパディングされ、ブロックに解析される方法について説明します。セクション5では、これらのアルゴリズムを指定するために使用される定数と複合関数を定義します。セクション6では、SHA-224、SHA-256、SHA-384、およびSHA-512機能の実際の仕様を示します。セクション7は、SHAアルゴリズムに基づくHMACキー付きメッセージ認証コードの仕様へのポインターを提供します。セクション8では、SHAアルゴリズムのサンプルコードと、SHAベースのHMACのセクション9コードを示します。 SHAベースのHMACは、任意のビット長のテキストを受け入れます。"
    },
    {
      "indent": 0,
      "text": "1.1. License",
      "section_title": true,
      "ja": "1.1. ライセンス"
    },
    {
      "indent": 3,
      "text": "Permission is granted for all uses, commercial and non-commercial, of the sample code found in Section 8. Royalty free license to use, copy, modify and distribute the software found in Section 8 is granted, provided that this document is identified in all material mentioning or referencing this software, and provided that redistributed derivative works do not contain misleading author or version information.",
      "ja": "セクション8にあるサンプルコードの商用および非商用を問わず、すべての使用が許可されます。このドキュメントがすべてで特定されている場合、セクション8にあるソフトウェアの使用、コピー、変更、および配布のロイヤリティフリーライセンスが付与されます。このソフトウェアについて言及または参照している資料、および再配布された二次的著作物に誤解を招く著者またはバージョン情報が含まれていないことを条件とします。"
    },
    {
      "indent": 3,
      "text": "The authors make no representations concerning either the merchantability of this software or the suitability of this software for any particular purpose. It is provided \"as is\" without express or implied warranty of any kind.",
      "ja": "作者は、このソフトウェアの商品性またはこのソフトウェアの特定の目的への適合性のいずれについても表明しません。 「現状有姿」で提供され、いかなる種類の明示的または黙示的な保証もありません。"
    },
    {
      "indent": 0,
      "text": "2. Notation for Bit Strings and Integers",
      "section_title": true,
      "ja": "2. ビット文字列と整数の表記"
    },
    {
      "indent": 3,
      "text": "The following terminology related to bit strings and integers will be used:",
      "ja": "ビット文字列と整数に関連する次の用語が使用されます。"
    },
    {
      "indent": 4,
      "text": "a. A hex digit is an element of the set {0, 1, ... , 9, A, ... , F}. A hex digit is the representation of a 4-bit string. Examples: 7 = 0111, A = 1010.",
      "ja": "a. 16進数字は、セット{0、1、...、9、A、...、F}の要素です。 16進数は、4ビット文字列を表します。例：7 = 0111、A = 1010。"
    },
    {
      "indent": 4,
      "text": "b. A word equals a 32-bit or 64-bit string, which may be represented as a sequence of 8 or 16 hex digits, respectively. To convert a word to hex digits, each 4-bit string is converted to its hex equivalent as described in (a) above. Example:",
      "ja": "b. ワードは32ビットまたは64ビットの文字列に相当し、それぞれ8桁または16桁の16進数として表されます。ワードを16進数に変換するには、上記の（a）で説明したように、各4ビット文字列を対応する16進数に変換します。例："
    },
    {
      "indent": 8,
      "text": "1010 0001 0000 0011 1111 1110 0010 0011 = A103FE23.",
      "ja": "1010 0001 000 0011 1111 1110 0010 0011 = A 103 VAT。"
    },
    {
      "indent": 8,
      "text": "Throughout this document, the \"big-endian\" convention is used when expressing both 32-bit and 64-bit words, so that within each word the most significant bit is shown in the left-most bit position.",
      "ja": "このドキュメントでは、32ビットワードと64ビットワードの両方を表すときに「ビッグエンディアン」規則を使用しているため、各ワード内で最上位ビットが左端のビット位置に表示されます。"
    },
    {
      "indent": 4,
      "text": "c. An integer may be represented as a word or pair of words.",
      "ja": "c. 整数は、単語または単語のペアとして表すことができます。"
    },
    {
      "indent": 8,
      "text": "An integer between 0 and 2^32 - 1 inclusive may be represented as a 32-bit word. The least significant four bits of the integer are represented by the right-most hex digit of the word representation. Example: the integer 291 = 2^8+2^5+2^1+2^0 = 256+32+2+1 is represented by the hex word 00000123.",
      "ja": "0から2 ^ 32-1までの整数は、32ビットワードとして表すことができます。整数の最下位4ビットは、単語表現の右端の16進数で表されます。例：整数291 = 2 ^ 8 + 2 ^ 5 + 2 ^ 1 + 2 ^ 0 = 256 + 32 + 2 + 1は、16進ワード00000123で表されます。"
    },
    {
      "indent": 8,
      "text": "The same holds true for an integer between 0 and 2^64-1 inclusive, which may be represented as a 64-bit word.",
      "ja": "同じことは、0から2 ^ 64-1までの整数にも当てはまり、64ビットワードとして表すことができます。"
    },
    {
      "indent": 8,
      "text": "If Z is an integer, 0 <= z < 2^64, then z = (2^32)x + y where 0\n<= x < 2^32 and 0 <= y < 2^32.  Since x and y can be represented\nas words X and Y, respectively, z can be represented as the pair\nof words (X,Y).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "d. block = 512-bit or 1024-bit string. A block (e.g., B) may be represented as a sequence of 32-bit or 64-bit words.",
      "ja": "d. ブロック= 512ビットまたは1024ビットの文字列。ブロック（たとえば、B）は、32ビットまたは64ビットのワードのシーケンスとして表すことができます。"
    },
    {
      "indent": 0,
      "text": "3. Operations on Words",
      "section_title": true,
      "ja": "3. 単語の操作"
    },
    {
      "indent": 3,
      "text": "The following logical operators will be applied to words in all four hash operations specified herein. SHA-224 and SHA-256 operate on 32-bit words, while SHA-384 and SHA-512 operate on 64-bit words.",
      "ja": "次の論理演算子は、ここで指定された4つのハッシュ演算すべての単語に適用されます。 SHA-224およびSHA-256は32ビットワードで動作し、SHA-384およびSHA-512は64ビットワードで動作します。"
    },
    {
      "indent": 3,
      "text": "In the operations below, x<<n is obtained as follows: discard the left-most n bits of x and then pad the result with n zeroed bits on the right (the result will still be the same number of bits).",
      "ja": "以下の操作では、x << nは次のように取得されます。xの左端のnビットを破棄し、右側のnゼロ化ビットで結果を埋め込みます（結果は同じビット数になります）。"
    },
    {
      "indent": 4,
      "text": "a. Bitwise logical word operations",
      "ja": "a. ビットごとの論理ワード演算"
    },
    {
      "indent": 8,
      "text": "X AND Y = bitwise logical \"and\" of X and Y.",
      "ja": "X AND Y = XとYのビット単位の論理「and」。"
    },
    {
      "indent": 8,
      "text": "X OR Y = bitwise logical \"inclusive-or\" of X and Y.",
      "ja": "X OR Y = XとYのビット単位の論理「包含的OR」。"
    },
    {
      "indent": 8,
      "text": "X XOR Y = bitwise logical \"exclusive-or\" of X and Y.",
      "ja": "X XOR Y = XとYのビット単位の論理「排他的論理和」。"
    },
    {
      "indent": 8,
      "text": "NOT X = bitwise logical \"complement\" of X.",
      "ja": "NOT X = Xのビット単位の論理「補数」。"
    },
    {
      "indent": 8,
      "text": "Example:\n         01101100101110011101001001111011\n   XOR   01100101110000010110100110110111\n         --------------------------------\n     =   00001001011110001011101111001100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "b.  The operation X + Y is defined as follows: words X and Y\n    represent w-bit integers x and y, where 0 <= x < 2^w and\n    0 <= y < 2^w.  For positive integers n and m, let",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "n mod m",
      "ja": "n mod m"
    },
    {
      "indent": 8,
      "text": "be the remainder upon dividing n by m. Compute",
      "ja": "nをmで割ったときの剰余計算する"
    },
    {
      "indent": 13,
      "text": "z  =  (x + y) mod 2^w.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Then 0 <= z < 2^w. Convert z to a word, Z, and define Z = X + Y.",
      "ja": "次に、0 <= z <2 ^ wです。 zを単語Zに変換し、Z = X + Yを定義します。"
    },
    {
      "indent": 4,
      "text": "c.  The right shift operation SHR^n(x), where x is a w-bit word and\n    n is an integer with 0 <= n < w, is defined by",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "SHR^n(x) = x>>n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "d.  The rotate right (circular right shift) operation ROTR^n(x),\n    where x is a w-bit word and n is an integer with 0 <= n < w, is\n    defined by",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "ROTR^n(x) = (x>>n) OR (x<<(w-n))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "e.  The rotate left (circular left shift) operation ROTL^n(x), where\n    x is a w-bit word and n is an integer with 0 <= n < w, is\n    defined by",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "ROTL^n(X)  =  (x<<n) OR (x>>w-n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Note the following equivalence relationships, where w is fixed in each relationship:",
      "ja": "次の同値関係に注意してください。ここで、wは各関係で固定されています。"
    },
    {
      "indent": 13,
      "text": "ROTL^n(x) = ROTR^(w-x)(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "ROTR^n(x) = ROTL^(w-n)(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Message Padding and Parsing",
      "section_title": true,
      "ja": "4. メッセージのパディングと解析"
    },
    {
      "indent": 3,
      "text": "The hash functions specified herein are used to compute a message digest for a message or data file that is provided as input. The message or data file should be considered to be a bit string. The length of the message is the number of bits in the message (the empty message has length 0). If the number of bits in a message is a multiple of 8, for compactness we can represent the message in hex. The purpose of message padding is to make the total length of a padded message a multiple of 512 for SHA-224 and SHA-256 or a multiple of 1024 for SHA-384 and SHA-512.",
      "ja": "ここで指定されたハッシュ関数は、入力として提供されるメッセージまたはデータファイルのメッセージダイジェストを計算するために使用されます。メッセージまたはデータファイルはビット文字列と見なす必要があります。メッセージの長さは、メッセージのビット数です（空のメッセージの長さは0です）。メッセージのビット数が8の倍数の場合、簡潔にするためにメッセージを16進数で表すことができます。メッセージパディングの目的は、パディングされたメッセージの全長を、SHA-224およびSHA-256の場合は512の倍数、SHA-384およびSHA-512の場合は1024の倍数にすることです。"
    },
    {
      "indent": 3,
      "text": "The following specifies how this padding shall be performed. As a summary, a \"1\" followed by a number of \"0\"s followed by a 64-bit or 128-bit integer are appended to the end of the message to produce a padded message of length 512*n or 1024*n. The minimum number of \"0\"s necessary to meet this criterion is used. The appended integer is the length of the original message. The padded message is then processed by the hash function as n 512-bit or 1024-bit blocks.",
      "ja": "以下は、このパディングがどのように実行されるかを指定します。要約すると、「1」の後に「0」が続き、その後に64ビットまたは128ビットの整数がメッセージの最後に追加されて、長さが512 * nまたは1024 * nの埋め込みメッセージが生成されます。 。この基準を満たすために必要な最小数の「0」が使用されます。追加された整数は、元のメッセージの長さです。次に、パディングされたメッセージは、ハッシュ関数によってn個の512ビットまたは1024ビットブロックとして処理されます。"
    },
    {
      "indent": 0,
      "text": "4.1. SHA-224 and SHA-256",
      "section_title": true,
      "ja": "4.1. SHA-224およびSHA-256"
    },
    {
      "indent": 3,
      "text": "Suppose a message has length L < 2^64. Before it is input to the hash function, the message is padded on the right as follows:",
      "ja": "メッセージの長さがL <2 ^ 64であるとします。ハッシュ関数に入力される前に、メッセージは次のように右側に埋め込まれます。"
    },
    {
      "indent": 4,
      "text": "a. \"1\" is appended. Example: if the original message is \"01010000\", this is padded to \"010100001\".",
      "ja": "a. 「1」が追加されます。例：元のメッセージが「01010000」の場合、「010100001」まで埋め込まれます。"
    },
    {
      "indent": 4,
      "text": "b. K \"0\"s are appended where K is the smallest, non-negative solution to the equation",
      "ja": "b. K \"0\"が追加されます。ここで、Kは方程式の最小の非負の解です"
    },
    {
      "indent": 13,
      "text": "L + 1 + K = 448 (mod 512)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "c. Then append the 64-bit block that is L in binary representation. After appending this block, the length of the message will be a multiple of 512 bits.",
      "ja": "c. 次に、バイナリ表現でLである64ビットブロックを追加します。このブロックを追加すると、メッセージの長さは512ビットの倍数になります。"
    },
    {
      "indent": 8,
      "text": "Example: Suppose the original message is the bit string",
      "ja": "例：元のメッセージがビット文字列であると仮定します"
    },
    {
      "indent": 13,
      "text": "01100001 01100010 01100011 01100100 01100101",
      "ja": "０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１"
    },
    {
      "indent": 8,
      "text": "After step (a), this gives",
      "ja": "ステップ（a）の後、これにより"
    },
    {
      "indent": 13,
      "text": "01100001 01100010 01100011 01100100 01100101 1",
      "ja": "０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１ １"
    },
    {
      "indent": 8,
      "text": "Since L = 40, the number of bits in the above is 41 and K = 407 \"0\"s are appended, making the total now 448. This gives the following in hex:",
      "ja": "L = 40であるため、上記のビット数は41であり、K = 407 \"0\"が追加され、合計は448になります。これにより、16進数で次のようになります。"
    },
    {
      "indent": 13,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000",
      "ja": "６１６２６３６４ ６５８０００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００"
    },
    {
      "indent": 8,
      "text": "The 64-bit representation of L = 40 is hex 00000000 00000028. Hence the final padded message is the following hex:",
      "ja": "L = 40の64ビット表現は16進数00000000 00000028です。したがって、最後の埋め込みメッセージは次の16進数です。"
    },
    {
      "indent": 13,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028",
      "ja": "６１６２６３６４ ６５８０００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００２８"
    },
    {
      "indent": 0,
      "text": "4.2. SHA-384 and SHA-512",
      "section_title": true,
      "ja": "4.2. SHA-384およびSHA-512"
    },
    {
      "indent": 3,
      "text": "Suppose a message has length L < 2^128. Before it is input to the hash function, the message is padded on the right as follows:",
      "ja": "メッセージの長さがL <2 ^ 128であるとします。ハッシュ関数に入力される前に、メッセージは次のように右側に埋め込まれます。"
    },
    {
      "indent": 4,
      "text": "a. \"1\" is appended. Example: if the original message is \"01010000\", this is padded to \"010100001\".",
      "ja": "a. 「1」が追加されます。例：元のメッセージが「01010000」の場合、「010100001」まで埋め込まれます。"
    },
    {
      "indent": 4,
      "text": "b. K \"0\"s are appended where K is the smallest, non-negative solution to the equation",
      "ja": "b. K \"0\"が追加されます。ここで、Kは方程式の最小の非負の解です"
    },
    {
      "indent": 13,
      "text": "L + 1 + K = 896 (mod 1024)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "c. Then append the 128-bit block that is L in binary representation. After appending this block, the length of the message will be a multiple of 1024 bits.",
      "ja": "c. 次に、バイナリ表現でLである128ビットブロックを追加します。このブロックを追加すると、メッセージの長さは1024ビットの倍数になります。"
    },
    {
      "indent": 8,
      "text": "Example: Suppose the original message is the bit string",
      "ja": "例：元のメッセージがビット文字列であると仮定します"
    },
    {
      "indent": 13,
      "text": "01100001 01100010 01100011 01100100 01100101",
      "ja": "０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１"
    },
    {
      "indent": 8,
      "text": "After step (a) this gives",
      "ja": "ステップ（a）の後、これは"
    },
    {
      "indent": 13,
      "text": "01100001 01100010 01100011 01100100 01100101 1",
      "ja": "０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１ １"
    },
    {
      "indent": 8,
      "text": "Since L = 40, the number of bits in the above is 41 and K = 855 \"0\"s are appended, making the total now 896. This gives the following in hex:",
      "ja": "L = 40であるため、上記のビット数は41で、K = 855 \"0\"が追加され、合計は896になります。これにより、16進数で次のようになります。"
    },
    {
      "indent": 13,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000",
      "ja": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000"
    },
    {
      "indent": 8,
      "text": "The 128-bit representation of L = 40 is hex 00000000 00000000 00000000 00000028. Hence the final padded message is the following hex:",
      "ja": "L = 40の128ビット表現は16進数00000000 00000000 00000000 00000028です。したがって、最後の埋め込みメッセージは次の16進数です。"
    },
    {
      "indent": 0,
      "text": " 61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028",
      "ja": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028"
    },
    {
      "indent": 0,
      "text": "5. Functions and Constants Used",
      "section_title": true,
      "ja": "5. 使用される関数と定数"
    },
    {
      "indent": 3,
      "text": "The following subsections give the six logical functions and the table of constants used in each of the hash functions.",
      "ja": "以下のサブセクションでは、6つの論理関数と、各ハッシュ関数で使用される定数の表を示します。"
    },
    {
      "indent": 0,
      "text": "5.1. SHA-224 and SHA-256",
      "section_title": true,
      "ja": "5.1. SHA-224およびSHA-256"
    },
    {
      "indent": 3,
      "text": "SHA-224 and SHA-256 use six logical functions, where each function operates on 32-bit words, which are represented as x, y, and z. The result of each function is a new 32-bit word.",
      "ja": "SHA-224およびSHA-256は、6つの論理関数を使用します。各関数は、x、y、およびzとして表される32ビットワードで動作します。各関数の結果は、新しい32ビットワードです。"
    },
    {
      "indent": 8,
      "text": "CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "SSIG0(x) = ROTR^7(x) XOR ROTR^18(x) XOR SHR^3(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "SSIG1(x) = ROTR^17(x) XOR ROTR^19(x) XOR SHR^10(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SHA-224 and SHA-256 use the same sequence of sixty-four constant 32-bit words, K0, K1, ..., K63. These words represent the first thirty-two bits of the fractional parts of the cube roots of the first sixty-four prime numbers. In hex, these constant words are as follows (from left to right):",
      "ja": "SHA-224およびSHA-256は、64の定数32ビットワード、K0、K1、...、K63の同じシーケンスを使用します。これらの単語は、最初の64の素数の立方根の小数部の最初の32ビットを表します。 16進数では、これらの定数語は次のとおりです（左から右へ）。"
    },
    {
      "indent": 0,
      "text": " 428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5 d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174 e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da 983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967 27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85 a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070 19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3 748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2",
      "ja": "428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5 d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174 e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da 983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967 27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85 a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070 19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3 748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2"
    },
    {
      "indent": 0,
      "text": "5.2. SHA-384 and SHA-512",
      "section_title": true,
      "ja": "5.2. SHA-384およびSHA-512"
    },
    {
      "indent": 3,
      "text": "SHA-384 and SHA-512 each use six logical functions, where each function operates on 64-bit words, which are represented as x, y, and z. The result of each function is a new 64-bit word.",
      "ja": "SHA-384およびSHA-512は、それぞれ6つの論理関数を使用します。各関数は、x、y、およびzとして表される64ビットワードで動作します。各関数の結果は、新しい64ビットワードです。"
    },
    {
      "indent": 8,
      "text": "CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "BSIG0(x) = ROTR^28(x) XOR ROTR^34(x) XOR ROTR^39(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "BSIG1(x) = ROTR^14(x) XOR ROTR^18(x) XOR ROTR^41(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "SSIG0(x) = ROTR^1(x) XOR ROTR^8(x) XOR SHR^7(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "SSIG1(x) = ROTR^19(x) XOR ROTR^61(x) XOR SHR^6(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SHA-384 and SHA-512 use the same sequence of eighty constant 64-bit words, K0, K1, ... K79. These words represent the first sixty-four bits of the fractional parts of the cube roots of the first eighty prime numbers. In hex, these constant words are as follows (from left to right):",
      "ja": "SHA-384およびSHA-512は、80の定数64ビットワードの同じシーケンス、K0、K1、... K79を使用します。これらの単語は、最初の80の素数の立方根の小数部の最初の64ビットを表します。 16進数では、これらの定数語は次のとおりです（左から右へ）。"
    },
    {
      "indent": 3,
      "text": "428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc 3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118 d807aa98a3030242 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2 72be5d74f27b896f 80deb1fe3b1696b1 9bdc06a725c71235 c19bf174cf692694 e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65 2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5 983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4 c6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670a0e6e70 27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df 650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6 92722c851482353b a2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30 d192e819d6ef5218 d69906245565a910 f40e35855771202a 106aa07032bbd1b8 19a4c116b8d2d0c8 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8 391c0cb3c5c95a63 4ed8aa4ae3418acb 5b9cca4f7763e373 682e6ff3d6b2b8a3 748f82ee5defb2fc 78a5636f43172f60 84c87814a1f0ab72 8cc702081a6439ec 90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b ca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e f57d4f7fee6ed178 06f067aa72176fba 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b 28db77f523047d84 32caab7b40c72493 3c9ebe0a15c9bebc 431d67c49c100d4c 4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec 6c44198c4a475817",
      "ja": "428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc 3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118 d807aa98a3030242 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2 72be5d74f27b896f 80deb1fe3b1696b1 9bdc06a725c71235 c19bf174cf692694 e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65 2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5 983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4 c6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670a0e6e70 27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df 650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6 92722c851482353b a2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30 d192e819d6ef5218 d69906245565a910 f40e35855771202a 106aa07032bbd1b8 19a4c116b8d2d0c8 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8 391c0cb3c5c95a63 4ed8aa4ae3418acb 5b9cca4f7763e373 682e6ff3d6b2b8a3 748f82ee5defb2fc 78a5636f43172f601f60 78f560a4343172 72 8cc702081a6439ec 90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b ca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e f57d4f7fee6ed178 06f067aa72176fba 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b 28db77f523047d84 32caab7b40c72493 3c9ebe0a15c9bebc 431d67c49c100d4c 4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec 6c44198c4a475817"
    },
    {
      "indent": 0,
      "text": "6. Computing the Message Digest",
      "section_title": true,
      "ja": "6. メッセージダイジェストの計算"
    },
    {
      "indent": 3,
      "text": "The output of each of the secure hash functions, after being applied to a message of N blocks, is the hash quantity H(N). For SHA-224 and SHA-256, H(i) can be considered to be eight 32-bit words, H(i)0, H(i)1, ... H(i)7. For SHA-384 and SHA-512, it can be considered to be eight 64-bit words, H(i)0, H(i)1, ..., H(i)7.",
      "ja": "セキュアハッシュ関数のそれぞれの出力は、Nブロックのメッセージに適用された後、ハッシュ量H（N）になります。 SHA-224およびSHA-256の場合、H（i）は8つの32ビットワード、H（i）0、H（i）1、... H（i）7と見なすことができます。 SHA-384およびSHA-512の場合、8つの64ビットワード、H（i）0、H（i）1、...、H（i）7と見なすことができます。"
    },
    {
      "indent": 3,
      "text": "As described below, the hash words are initialized, modified as each message block is processed, and finally concatenated after processing the last block to yield the output. For SHA-256 and SHA-512, all of the H(N) variables are concatenated while the SHA-224 and SHA-384 hashes are produced by omitting some from the final concatenation.",
      "ja": "以下で説明するように、ハッシュワードは初期化され、各メッセージブロックが処理されるたびに変更され、最後のブロックを処理して出力を生成した後、最終的に連結されます。 SHA-256およびSHA-512の場合、すべてのH（N）変数が連結されますが、SHA-224およびSHA-384ハッシュは、最終的な連結から一部を省略することによって生成されます。"
    },
    {
      "indent": 0,
      "text": "6.1. SHA-224 and SHA-256 Initialization",
      "section_title": true,
      "ja": "6.1. SHA-224およびSHA-256の初期化"
    },
    {
      "indent": 3,
      "text": "For SHA-224, the initial hash value, H(0), consists of the following 32-bit words in hex:",
      "ja": "SHA-224の場合、初期ハッシュ値H（0）は、16進数の次の32ビットワードで構成されます。"
    },
    {
      "indent": 8,
      "text": "H(0)0 = c1059ed8\nH(0)1 = 367cd507\nH(0)2 = 3070dd17\nH(0)3 = f70e5939\nH(0)4 = ffc00b31\nH(0)5 = 68581511\nH(0)6 = 64f98fa7\nH(0)7 = befa4fa4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For SHA-256, the initial hash value, H(0), consists of the following eight 32-bit words, in hex. These words were obtained by taking the first thirty-two bits of the fractional parts of the square roots of the first eight prime numbers.",
      "ja": "SHA-256の場合、初期ハッシュ値H（0）は、次の8つの32ビットワード（16進数）で構成されます。これらの単語は、最初の8つの素数の平方根の小数部の最初の32ビットを取得することによって取得されました。"
    },
    {
      "indent": 8,
      "text": "H(0)0 = 6a09e667\nH(0)1 = bb67ae85\nH(0)2 = 3c6ef372\nH(0)3 = a54ff53a\nH(0)4 = 510e527f\nH(0)5 = 9b05688c\nH(0)6 = 1f83d9ab\nH(0)7 = 5be0cd19",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. SHA-224 and SHA-256 Processing",
      "section_title": true,
      "ja": "6.2. SHA-224およびSHA-256処理"
    },
    {
      "indent": 0,
      "text": " SHA-224 and SHA-256 perform identical processing on messages blocks and differ only in how H(0) is initialized and how they produce their final output. They may be used to hash a message, M, having a length of L bits, where 0 <= L < 2^64. The algorithm uses (1) a message schedule of sixty-four 32-bit words, (2) eight working variables of 32 bits each, and (3) a hash value of eight 32-bit words.",
      "ja": "SHA-224とSHA-256はメッセージブロックに対して同じ処理を実行し、H（0）の初期化方法と最終出力の生成方法のみが異なります。これらは、Lビットの長さのメッセージMをハッシュするために使用できます。ここで、0 <= L <2 ^ 64です。このアルゴリズムでは、（1）64ビットの32ビットワードのメッセージスケジュール、（2）それぞれ32ビットの8つの作業変数、（3）8つの32ビットワードのハッシュ値を使用します。"
    },
    {
      "indent": 3,
      "text": "The words of the message schedule are labeled W0, W1, ..., W63. The eight working variables are labeled a, b, c, d, e, f, g, and h. The words of the hash value are labeled H(i)0, H(i)1, ..., H(i)7, which will hold the initial hash value, H(0), replaced by each successive intermediate hash value (after each message block is processed), H(i), and ending with the final hash value, H(N), after all N blocks are processed. They also use two temporary words, T1 and T2.",
      "ja": "メッセージスケジュールの単語には、W0、W1、...、W63というラベルが付いています。 8つの作業変数には、a、b、c、d、e、f、g、およびhというラベルが付いています。ハッシュ値の単語にはH（i）0、H（i）1、...、H（i）7のラベルが付けられます。これは、初期のハッシュ値H（0）を保持し、連続する各中間ハッシュ値に置き換えられます。 （各メッセージブロックが処理された後）、H（i）、N個のブロックすべてが処理された後、最終的なハッシュ値H（N）で終了します。また、T1とT2の2つの一時的な単語も使用します。"
    },
    {
      "indent": 3,
      "text": "The input message is padded as described in Section 4.1 above then parsed into 512-bit blocks, which are considered to be composed of 16 32-bit words M(i)0, M(i)1, ..., M(i)15. The following computations are then performed for each of the N message blocks. All addition is performed modulo 2^32.",
      "ja": "入力メッセージは、上記のセクション4.1で説明されているようにパディングされ、次に512ビットブロックに解析されます。これは、16個の32ビットワードM（i）0、M（i）1、...、M（iで構成されると見なされます）15。次に、N個のメッセージブロックのそれぞれに対して次の計算が実行されます。すべての加算は2 ^ 32を法として実行されます。"
    },
    {
      "indent": 3,
      "text": "For i = 1 to N",
      "ja": "i = 1からNの場合"
    },
    {
      "indent": 6,
      "text": "1. Prepare the message schedule W: For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(t-15) + W(t-16)",
      "ja": "1. メッセージスケジュールの準備W：t = 0〜15 Wt = M（i）t For t = 16〜63 Wt = SSIG1（W（t-2））+ W（t-7）+ SSIG0（t-15） + W（t-16）"
    },
    {
      "indent": 6,
      "text": "2. Initialize the working variables: a = H(i-1)0 b = H(i-1)1 c = H(i-1)2 d = H(i-1)3 e = H(i-1)4 f = H(i-1)5 g = H(i-1)6 h = H(i-1)7",
      "ja": "2. 作業変数を初期化します：a = H（i-1）0 b = H（i-1）1 c = H（i-1）2 d = H（i-1）3 e = H（i-1）4 f = H（i-1）5 g = H（i-1）6 h = H（i-1）7"
    },
    {
      "indent": 6,
      "text": "3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2",
      "ja": "3. メインハッシュ計算を実行します。t= 0〜63の場合T1 = h + BSIG1（e）+ CH（e、f、g）+ Kt + Wt T2 = BSIG0（a）+ MAJ（a、b、c）h = gg = ff = ee = d + T1 d = cc = bb = aa = T1 + T2"
    },
    {
      "indent": 6,
      "text": "4. Compute the intermediate hash value H(i): H(i)0 = a + H(i-1)0 H(i)1 = b + H(i-1)1 H(i)2 = c + H(i-1)2 H(i)3 = d + H(i-1)3 H(i)4 = e + H(i-1)4 H(i)5 = f + H(i-1)5 H(i)6 = g + H(i-1)6 H(i)7 = h + H(i-1)7",
      "ja": "4. 中間ハッシュ値H（i）を計算します：H（i）0 = a + H（i-1）0 H（i）1 = b + H（i-1）1 H（i）2 = c + H（ i-1）2 H（i）3 = d + H（i-1）3 H（i）4 = e + H（i-1）4 H（i）5 = f + H（i-1）5 H（i）6 = g + H（i-1）6 H（i）7 = h + H（i-1）7"
    },
    {
      "indent": 3,
      "text": "After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated. For SHA-256, this is the concatenation of all of H(N)0, H(N)1, through H(N)7. For SHA-224, this is the concatenation of H(N)0, H(N)1, through H(N)6.",
      "ja": "上記の計算がメッセージ内のすべてのブロックに対して順次実行された後、最終的な出力が計算されます。 SHA-256の場合、これはH（N）0、H（N）1からH（N）7のすべての連結です。 SHA-224の場合、これはH（N）0、H（N）1からH（N）6を連結したものです。"
    },
    {
      "indent": 0,
      "text": "6.3. SHA-384 and SHA-512 Initialization",
      "section_title": true,
      "ja": "6.3. SHA-384およびSHA-512の初期化"
    },
    {
      "indent": 3,
      "text": "For SHA-384, the initial hash value, H(0), consists of the following eight 64-bit words, in hex. These words were obtained by taking the first sixty-four bits of the fractional parts of the square roots of the ninth through sixteenth prime numbers.",
      "ja": "SHA-384の場合、初期ハッシュ値H（0）は、次の8つの64ビットワード（16進数）で構成されます。これらの単語は、9番目から16番目の素数の平方根の小数部の最初の64ビットを取得することによって取得されました。"
    },
    {
      "indent": 8,
      "text": "H(0)0 = cbbb9d5dc1059ed8\nH(0)1 = 629a292a367cd507\nH(0)2 = 9159015a3070dd17\nH(0)3 = 152fecd8f70e5939\nH(0)4 = 67332667ffc00b31\nH(0)5 = 8eb44a8768581511\nH(0)6 = db0c2e0d64f98fa7\nH(0)7 = 47b5481dbefa4fa4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For SHA-512, the initial hash value, H(0), consists of the following eight 64-bit words, in hex. These words were obtained by taking the first sixty-four bits of the fractional parts of the square roots of the first eight prime numbers.",
      "ja": "SHA-512の場合、初期ハッシュ値H（0）は、次の8つの64ビットワード（16進数）で構成されます。これらの単語は、最初の8つの素数の平方根の小数部の最初の64ビットを取得することによって取得されました。"
    },
    {
      "indent": 8,
      "text": "H(0)0 = 6a09e667f3bcc908\nH(0)1 = bb67ae8584caa73b\nH(0)2 = 3c6ef372fe94f82b\nH(0)3 = a54ff53a5f1d36f1\nH(0)4 = 510e527fade682d1\nH(0)5 = 9b05688c2b3e6c1f\nH(0)6 = 1f83d9abfb41bd6b\nH(0)7 = 5be0cd19137e2179",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.4. SHA-384 and SHA-512 Processing",
      "section_title": true,
      "ja": "6.4. SHA-384およびSHA-512処理"
    },
    {
      "indent": 3,
      "text": "SHA-384 and SHA-512 perform identical processing on message blocks and differ only in how H(0) is initialized and how they produce their final output. They may be used to hash a message, M, having a length of L bits, where 0 <= L < 2^128. The algorithm uses (1) a message schedule of eighty 64-bit words, (2) eight working variables of 64 bits each, and (3) a hash value of eight 64-bit words.",
      "ja": "SHA-384とSHA-512はメッセージブロックで同じ処理を実行し、H（0）の初期化方法と最終出力の生成方法のみが異なります。これらは、Lビットの長さのメッセージMをハッシュするために使用できます。ここで、0 <= L <2 ^ 128です。このアルゴリズムは、（1）64ビットワード80個のメッセージスケジュール、（2）それぞれ64ビットの8つの作業変数、および（3）64ビットワード8個のハッシュ値を使用します。"
    },
    {
      "indent": 3,
      "text": "The words of the message schedule are labeled W0, W1, ..., W79. The eight working variables are labeled a, b, c, d, e, f, g, and h. The words of the hash value are labeled H(i)0, H(i)1, ..., H(i)7, which will hold the initial hash value, H(0), replaced by each successive intermediate hash value (after each message block is processed), H(i), and ending with the final hash value, H(N) after all N blocks are processed.",
      "ja": "メッセージスケジュールの単語には、W0、W1、...、W79というラベルが付いています。 8つの作業変数には、a、b、c、d、e、f、g、およびhというラベルが付いています。ハッシュ値の単語にはH（i）0、H（i）1、...、H（i）7のラベルが付けられます。これは、初期のハッシュ値H（0）を保持し、連続する各中間ハッシュ値に置き換えられます。 （各メッセージブロックが処理された後）、H（i）、およびすべてのNブロックが処理された後の最終ハッシュ値H（N）で終了。"
    },
    {
      "indent": 3,
      "text": "The input message is padded as described in Section 4.2 above, then parsed into 1024-bit blocks, which are considered to be composed of 16 64-bit words M(i)0, M(i)1, ..., M(i)15. The following computations are then performed for each of the N message blocks. All addition is performed modulo 2^64.",
      "ja": "入力メッセージは、上記のセクション4.2で説明したようにパディングされ、1024ビットブロックに解析されます。これは、16ビットの64ビットワードM（i）0、M（i）1、...、M（ i）15。次に、N個のメッセージブロックのそれぞれに対して次の計算が実行されます。すべての加算は2 ^ 64を法として実行されます。"
    },
    {
      "indent": 3,
      "text": "For i = 1 to N",
      "ja": "i = 1からNの場合"
    },
    {
      "indent": 6,
      "text": "1. Prepare the message schedule W: For t = 0 to 15 Wt = M(i)t For t = 16 to 79 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(t-15) + W(t-16)",
      "ja": "1. メッセージスケジュールの準備W：t = 0〜15 Wt = M（i）t For t = 16〜79 Wt = SSIG1（W（t-2））+ W（t-7）+ SSIG0（t-15） + W（t-16）"
    },
    {
      "indent": 6,
      "text": "2. Initialize the working variables: a = H(i-1)0 b = H(i-1)1 c = H(i-1)2 d = H(i-1)3 e = H(i-1)4 f = H(i-1)5 g = H(i-1)6 h = H(i-1)7",
      "ja": "2. 作業変数を初期化します：a = H（i-1）0 b = H（i-1）1 c = H（i-1）2 d = H（i-1）3 e = H（i-1）4 f = H（i-1）5 g = H（i-1）6 h = H（i-1）7"
    },
    {
      "indent": 0,
      "text": "      3. Perform the main hash computation:\n         For t = 0 to 79\n            T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt\n            T2 = BSIG0(a) + MAJ(a,b,c)\n            h = g\n            g = f\n            f = e\n            e = d + T1\n            d = c\n            c = b\n            b = a\n            a = T1 + T2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "4. Compute the intermediate hash value H(i): H(i)0 = a + H(i-1)0 H(i)1 = b + H(i-1)1 H(i)2 = c + H(i-1)2 H(i)3 = d + H(i-1)3 H(i)4 = e + H(i-1)4 H(i)5 = f + H(i-1)5 H(i)6 = g + H(i-1)6 H(i)7 = h + H(i-1)7",
      "ja": "4. 中間ハッシュ値H（i）を計算します：H（i）0 = a + H（i-1）0 H（i）1 = b + H（i-1）1 H（i）2 = c + H（ i-1）2 H（i）3 = d + H（i-1）3 H（i）4 = e + H（i-1）4 H（i）5 = f + H（i-1）5 H（i）6 = g + H（i-1）6 H（i）7 = h + H（i-1）7"
    },
    {
      "indent": 3,
      "text": "After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated. For SHA-512, this is the concatenation of all of H(N)0, H(N)1, through H(N)7. For SHA-384, this is the concatenation of H(N)0, H(N)1, through H(N)5.",
      "ja": "上記の計算がメッセージ内のすべてのブロックに対して順次実行された後、最終的な出力が計算されます。 SHA-512の場合、これはH（N）0、H（N）1からH（N）7のすべての連結です。 SHA-384の場合、これはH（N）0、H（N）1からH（N）5を連結したものです。"
    },
    {
      "indent": 0,
      "text": "7. SHA-Based HMACs",
      "section_title": true,
      "ja": "7. SHAベースのHMAC"
    },
    {
      "indent": 3,
      "text": "HMAC is a method for computing a keyed MAC (message authentication code) using a hash function as described in [RFC2104]. It uses a key to mix in with the input text to produce the final hash.",
      "ja": "HMACは、[RFC2104]で説明されているように、ハッシュ関数を使用してキー付きMAC（メッセージ認証コード）を計算する方法です。キーを使用して入力テキストと混合し、最終的なハッシュを生成します。"
    },
    {
      "indent": 3,
      "text": "Sample code is also provided, in Section 8.3 below, to perform HMAC based on any of the SHA algorithms described herein. The sample code found in [RFC2104] was written in terms of a specified text size. Since SHA is defined in terms of an arbitrary number of bits, the sample HMAC code has been written to allow the text input to HMAC to have an arbitrary number of octets and bits. A fixed-length interface is also provided.",
      "ja": "以下のセクション8.3では、ここで説明するSHAアルゴリズムのいずれかに基づいてHMACを実行するためのサンプルコードも提供されています。 [RFC2104]にあるサンプルコードは、指定されたテキストサイズに関して記述されています。 SHAは任意のビット数で定義されているため、HMACへのテキスト入力が任意の数のオクテットとビットを持つことができるようにサンプルHMACコードが記述されています。固定長インターフェースも提供されます。"
    },
    {
      "indent": 0,
      "text": "8. C Code for SHAs",
      "section_title": true,
      "ja": "8. SHAのCコード"
    },
    {
      "indent": 3,
      "text": "Below is a demonstration implementation of these secure hash functions in C. Section 8.1 contains the header file sha.h, which declares all constants, structures, and functions used by the sha and hmac functions. Section 8.2 contains the C code for sha1.c, sha224-256.c, sha384-512.c, and usha.c along with sha-private.h, which provides some declarations common to all the sha functions. Section 8.3 contains the C code for the hmac functions. Section 8.4 contains a test driver to exercise the code.",
      "ja": "以下は、Cでのこれらのセキュアハッシュ関数のデモ実装です。セクション8.1には、shaおよびhmac関数で使用されるすべての定数、構造体、関数を宣言するヘッダーファイルsha.hが含まれています。セクション8.2には、sha1.c、sha224-256.c、sha384-512.c、usha.cのCコードと、すべてのsha関数に共通の宣言を提供するsha-private.hが含まれています。セクション8.3には、hmac関数のCコードが含まれています。セクション8.4には、コードを実行するためのテストドライバーが含まれています。"
    },
    {
      "indent": 3,
      "text": "For each of the digest length $$$, there is the following set of constants, a structure, and functions:",
      "ja": "ダイジェストの長さ$$$ごとに、次の定数、構造、および関数のセットがあります。"
    },
    {
      "indent": 3,
      "text": "Constants: SHA$$$HashSize number of octets in the hash SHA$$$HashSizeBits number of bits in the hash SHA$$$_Message_Block_Size number of octets used in the intermediate message blocks shaSuccess = 0 constant returned by each function on success shaNull = 1 constant returned by each function when presented with a null pointer parameter shaInputTooLong = 2 constant returned by each function when the input data is too long shaStateError constant returned by each function when SHA$$$Input is called after SHA$$$FinalBits or SHA$$$Result.",
      "ja": "定数：SHA $$$ HashSizeハッシュ内のオクテット数SHA $$$ HashSizeBitsハッシュ内のビット数SHA $$$ _ Message_Block_Size中間メッセージブロックで使用されるオクテット数shaSuccess = 0成功時に各関数によって返される定数shaNull =ヌルポインターパラメーターが提示されたときに各関数によって返される1つの定数shaInputTooLong =入力データが長すぎるときに各関数によって返される2つの定数SHA $$$ InputがSHA $$$ FinalBitsまたはSHAの後に呼び出されたときに各関数によって返されるshaStateError定数$$$ Result。"
    },
    {
      "indent": 3,
      "text": "Structure: typedef SHA$$$Context an opaque structure holding the complete state for producing the hash",
      "ja": "構造：typedef SHA $$$ Contextハッシュを生成するための完全な状態を保持する不透明な構造"
    },
    {
      "indent": 3,
      "text": "Functions:\n               int SHA$$$Reset(SHA$$$Context *);\n         Reset the hash context state\n   int SHA$$$Input(SHA$$$Context *, const uint8_t *octets,\n               unsigned int bytecount);\n         Incorporate bytecount octets into the hash.\n   int SHA$$$FinalBits(SHA$$$Context *, const uint8_t octet,\n               unsigned int bitcount);\n         Incorporate bitcount bits into the hash.  The bits are in\n         the upper portion of the octet.  SHA$$$Input() cannot be\n         called after this.\n   int SHA$$$Result(SHA$$$Context *,\n               uint8_t Message_Digest[SHA$$$HashSize]);\n         Do the final calculations on the hash and copy the value\n         into Message_Digest.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In addition, functions with the prefix USHA are provided that take a SHAversion value (SHA$$$) to select the SHA function suite. They add the following constants, structure, and functions:",
      "ja": "さらに、SHAversionスイート（SHA $$$）を使用してSHA関数スイートを選択する、プレフィックスUSHAを持つ関数が提供されます。次の定数、構造、および関数を追加します。"
    },
    {
      "indent": 3,
      "text": "Constants: shaBadParam constant returned by USHA functions when presented with a bad SHAversion (SHA$$$) parameter",
      "ja": "定数：不適切なSHAversion（SHA $$$）パラメーターが提示されたときにUSHA関数によって返されるshaBadParam定数"
    },
    {
      "indent": 6,
      "text": "SHA$$$ SHAversion enumeration values, used by usha and hmac functions to select the SHA function suite",
      "ja": "SHA $$$ SHAversion列挙値。ushaおよびhmac関数がSHA関数スイートを選択するために使用します"
    },
    {
      "indent": 3,
      "text": "Structure: typedef USHAContext an opaque structure holding the complete state for producing the hash",
      "ja": "構造：typedef USHAContextハッシュを生成するための完全な状態を保持する不透明な構造"
    },
    {
      "indent": 3,
      "text": "Functions:\n   int USHAReset(USHAContext *, SHAversion whichSha);\n         Reset the hash context state.\n   int USHAInput(USHAContext *,\n               const uint8_t *bytes, unsigned int bytecount);\n         Incorporate bytecount octets into the hash.\n   int USHAFinalBits(USHAContext *,\n               const uint8_t bits, unsigned int bitcount);\n               Incorporate bitcount bits into the hash.\n   int USHAResult(USHAContext *,\n               uint8_t Message_Digest[USHAMaxHashSize]);\n         Do the final calculations on the hash and copy the value\n         into Message_Digest.  Octets in Message_Digest beyond\n   USHAHashSize(whichSha) are left untouched.\n               int USHAHashSize(enum SHAversion whichSha);\n         The number of octets in the given hash.\n   int USHAHashSizeBits(enum SHAversion whichSha);\n         The number of bits in the given hash.\n   int USHABlockSize(enum SHAversion whichSha);\n         The internal block size for the given hash.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The hmac functions follow the same pattern to allow any length of text input to be used.",
      "ja": "hmac関数は同じパターンに従って、任意の長さのテキスト入力を使用できるようにします。"
    },
    {
      "indent": 3,
      "text": "Structure: typedef HMACContext an opaque structure holding the complete state for producing the hash",
      "ja": "構造：typedef HMACContextハッシュを生成するための完全な状態を保持する不透明な構造"
    },
    {
      "indent": 3,
      "text": "Functions:\n   int hmacReset(HMACContext *ctx, enum SHAversion whichSha,\n               const unsigned char *key, int key_len);\n         Reset the hash context state.\n   int hmacInput(HMACContext *ctx, const unsigned char *text,\n               int text_len);\n         Incorporate text_len octets into the hash.\n   int hmacFinalBits(HMACContext *ctx, const uint8_t bits,\n               unsigned int bitcount);\n         Incorporate bitcount bits into the hash.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "int hmacResult(HMACContext *ctx, uint8_t Message_Digest[USHAMaxHashSize]); Do the final calculations on the hash and copy the value into Message_Digest. Octets in Message_Digest beyond USHAHashSize(whichSha) are left untouched.",
      "ja": "int hmacResult（HMACContext * ctx、uint8_t Message_Digest [USHAMaxHashSize]）;ハッシュの最終計算を行い、値をMessage_Digestにコピーします。 USHAHashSize（whichSha）を超えるMessage_Digestのオクテットは変更されません。"
    },
    {
      "indent": 3,
      "text": "In addition, a combined interface is provided, similar to that shown in RFC 2104, that allows a fixed-length text input to be used.",
      "ja": "さらに、RFC 2104に示されているものと同様に、固定長のテキスト入力を使用できるようにする結合インターフェースが提供されます。"
    },
    {
      "indent": 6,
      "text": "int hmac(SHAversion whichSha, const unsigned char *text, int text_len, const unsigned char *key, int key_len, uint8_t Message_Digest[USHAMaxHashSize]); Calculate the given digest for the given text and key, and return the resulting hash. Octets in Message_Digest beyond USHAHashSize(whichSha) are left untouched.",
      "ja": "int hmac（SHAversion whichSha、const unsigned char * text、int text_len、const unsigned char * key、int key_len、uint8_t Message_Digest [USHAMaxHashSize]）;指定されたテキストとキーに対して指定されたダイジェストを計算し、結果のハッシュを返します。 USHAHashSize（whichSha）を超えるMessage_Digestのオクテットは変更されません。"
    },
    {
      "indent": 0,
      "text": "8.1. The .h File",
      "section_title": true,
      "ja": "8.1. .hファイル"
    },
    {
      "indent": 0,
      "text": "/**************************** sha.h ****************************/\n/******************* See RFC 4634 for details ******************/\n#ifndef _SHA_H_\n#define _SHA_H_",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  Description:\n *      This file implements the Secure Hash Signature Standard\n *      algorithms as defined in the National Institute of Standards\n *      and Technology Federal Information Processing Standards\n *      Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\n *      published on August 1, 2002, and the FIPS PUB 180-2 Change\n *      Notice published on February 28, 2004.\n *\n *      A combined document showing all algorithms is available at\n *              http://csrc.nist.gov/publications/fips/\n *              fips180-2/fips180-2withchangenotice.pdf\n *\n *      The five hashes are defined in these sizes:\n *              SHA-1           20 byte / 160 bit\n *              SHA-224         28 byte / 224 bit\n *              SHA-256         32 byte / 256 bit\n *              SHA-384         48 byte / 384 bit\n *              SHA-512         64 byte / 512 bit\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include <stdint.h>\n/*\n * If you do not have the ISO standard stdint.h header file, then you",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "* must typedef the following: * name meaning * uint64_t unsigned 64 bit integer * uint32_t unsigned 32 bit integer * uint8_t unsigned 8 bit integer (i.e., unsigned char) * int_least16_t integer of >= 16 bits * */",
      "ja": "* 以下をtypedefする必要があります：*名前の意味* uint64_t符号なし64ビット整数* uint32_t符号なし32ビット整数* uint8_t符号なし8ビット整数（つまり、符号なしchar）* int_least16_t整数> = 16ビット* * /"
    },
    {
      "indent": 0,
      "text": "#ifndef _SHA_enum_\n#define _SHA_enum_\n/*\n *  All SHA functions return one of these values.\n */\nenum {\n    shaSuccess = 0,\n    shaNull,            /* Null pointer parameter */\n    shaInputTooLong,    /* input data too long */\n    shaStateError,      /* called Input after FinalBits or Result */\n    shaBadParam         /* passed a bad parameter */\n};\n#endif /* _SHA_enum_ */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  These constants hold size information for each of the SHA\n *  hashing operations\n */\nenum {\n    SHA1_Message_Block_Size = 64, SHA224_Message_Block_Size = 64,\n    SHA256_Message_Block_Size = 64, SHA384_Message_Block_Size = 128,\n    SHA512_Message_Block_Size = 128,\n    USHA_Max_Message_Block_Size = SHA512_Message_Block_Size,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "SHA1HashSize = 20, SHA224HashSize = 28, SHA256HashSize = 32, SHA384HashSize = 48, SHA512HashSize = 64, USHAMaxHashSize = SHA512HashSize,",
      "ja": "SHA1HashSize = 20、SHA224HashSize = 28、SHA256HashSize = 32、SHA384HashSize = 48、SHA512HashSize = 64、USHAMaxHashSize = SHA512HashSize、"
    },
    {
      "indent": 0,
      "text": "    SHA1HashSizeBits = 160, SHA224HashSizeBits = 224,\n    SHA256HashSizeBits = 256, SHA384HashSizeBits = 384,\n    SHA512HashSizeBits = 512, USHAMaxHashSizeBits = SHA512HashSizeBits\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  These constants are used in the USHA (unified sha) functions.\n */\ntypedef enum SHAversion {\n    SHA1, SHA224, SHA256, SHA384, SHA512\n} SHAversion;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-1\n *  hashing operation.\n */\ntypedef struct SHA1Context {\n    uint32_t Intermediate_Hash[SHA1HashSize/4]; /* Message Digest */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "uint32_t Length_Low;                /* Message length in bits */\nuint32_t Length_High;               /* Message length in bits */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "int_least16_t Message_Block_Index;  /* Message_Block array index */\n                                    /* 512-bit message blocks */\nuint8_t Message_Block[SHA1_Message_Block_Size];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    int Computed;                       /* Is the digest computed? */\n    int Corrupted;                      /* Is the digest corrupted? */\n} SHA1Context;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-256\n *  hashing operation.\n */\ntypedef struct SHA256Context {\n    uint32_t Intermediate_Hash[SHA256HashSize/4]; /* Message Digest */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "uint32_t Length_Low;                /* Message length in bits */\nuint32_t Length_High;               /* Message length in bits */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "int_least16_t Message_Block_Index;  /* Message_Block array index */\n                                    /* 512-bit message blocks */\nuint8_t Message_Block[SHA256_Message_Block_Size];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    int Computed;                       /* Is the digest computed? */\n    int Corrupted;                      /* Is the digest corrupted? */\n} SHA256Context;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-512\n *  hashing operation.\n */\ntypedef struct SHA512Context {\n#ifdef USE_32BIT_ONLY\n    uint32_t Intermediate_Hash[SHA512HashSize/4]; /* Message Digest  */\n    uint32_t Length[4];                 /* Message length in bits */\n#else /* !USE_32BIT_ONLY */\n    uint64_t Intermediate_Hash[SHA512HashSize/8]; /* Message Digest */\n    uint64_t Length_Low, Length_High;   /* Message length in bits */\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "int_least16_t Message_Block_Index;  /* Message_Block array index */\n                                    /* 1024-bit message blocks */\nuint8_t Message_Block[SHA512_Message_Block_Size];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    int Computed;                       /* Is the digest computed?*/\n    int Corrupted;                      /* Is the digest corrupted? */\n} SHA512Context;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-224\n *  hashing operation. It uses the SHA-256 structure for computation.\n */\ntypedef struct SHA256Context SHA224Context;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-384\n *  hashing operation. It uses the SHA-512 structure for computation.\n */\ntypedef struct SHA512Context SHA384Context;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure holds context information for all SHA\n *  hashing operations.\n */\ntypedef struct USHAContext {\n    int whichSha;               /* which SHA is being used */\n    union {\n      SHA1Context sha1Context;\n      SHA224Context sha224Context; SHA256Context sha256Context;\n      SHA384Context sha384Context; SHA512Context sha512Context;\n    } ctx;\n} USHAContext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the HMAC\n *  keyed hashing operation.\n */\ntypedef struct HMACContext {\n    int whichSha;               /* which SHA is being used */\n    int hashSize;               /* hash size of SHA being used */\n    int blockSize;              /* block size of SHA being used */\n    USHAContext shaContext;     /* SHA context */\n    unsigned char k_opad[USHA_Max_Message_Block_Size];\n                        /* outer padding - key XORd with opad */\n} HMACContext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  Function Prototypes\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* SHA-1 */\nextern int SHA1Reset(SHA1Context *);\nextern int SHA1Input(SHA1Context *, const uint8_t *bytes,\n                     unsigned int bytecount);\nextern int SHA1FinalBits(SHA1Context *, const uint8_t bits,\n                         unsigned int bitcount);\nextern int SHA1Result(SHA1Context *,\n                      uint8_t Message_Digest[SHA1HashSize]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* SHA-224 */\nextern int SHA224Reset(SHA224Context *);\nextern int SHA224Input(SHA224Context *, const uint8_t *bytes,\n                       unsigned int bytecount);\nextern int SHA224FinalBits(SHA224Context *, const uint8_t bits,\n                           unsigned int bitcount);\nextern int SHA224Result(SHA224Context *,\n                        uint8_t Message_Digest[SHA224HashSize]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* SHA-256 */\nextern int SHA256Reset(SHA256Context *);\nextern int SHA256Input(SHA256Context *, const uint8_t *bytes,\n                       unsigned int bytecount);\nextern int SHA256FinalBits(SHA256Context *, const uint8_t bits,\n                           unsigned int bitcount);\nextern int SHA256Result(SHA256Context *,\n                        uint8_t Message_Digest[SHA256HashSize]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* SHA-384 */\nextern int SHA384Reset(SHA384Context *);\nextern int SHA384Input(SHA384Context *, const uint8_t *bytes,\n                       unsigned int bytecount);\nextern int SHA384FinalBits(SHA384Context *, const uint8_t bits,\n                           unsigned int bitcount);\nextern int SHA384Result(SHA384Context *,\n                        uint8_t Message_Digest[SHA384HashSize]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* SHA-512 */\nextern int SHA512Reset(SHA512Context *);\nextern int SHA512Input(SHA512Context *, const uint8_t *bytes,\n                       unsigned int bytecount);\nextern int SHA512FinalBits(SHA512Context *, const uint8_t bits,\n                           unsigned int bitcount);\nextern int SHA512Result(SHA512Context *,\n                        uint8_t Message_Digest[SHA512HashSize]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Unified SHA functions, chosen by whichSha */\nextern int USHAReset(USHAContext *, SHAversion whichSha);\nextern int USHAInput(USHAContext *,\n                     const uint8_t *bytes, unsigned int bytecount);\nextern int USHAFinalBits(USHAContext *,\n                         const uint8_t bits, unsigned int bitcount);\nextern int USHAResult(USHAContext *,\n                      uint8_t Message_Digest[USHAMaxHashSize]);\nextern int USHABlockSize(enum SHAversion whichSha);\nextern int USHAHashSize(enum SHAversion whichSha);\nextern int USHAHashSizeBits(enum SHAversion whichSha);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * HMAC Keyed-Hashing for Message Authentication, RFC2104,\n * for all SHAs.\n * This interface allows a fixed-length text input to be used.\n */\nextern int hmac(SHAversion whichSha, /* which SHA algorithm to use */\n    const unsigned char *text,     /* pointer to data stream */\n    int text_len,                  /* length of data stream */\n    const unsigned char *key,      /* pointer to authentication key */\n    int key_len,                   /* length of authentication key */\n    uint8_t digest[USHAMaxHashSize]); /* caller digest to fill in */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * HMAC Keyed-Hashing for Message Authentication, RFC2104,\n * for all SHAs.\n * This interface allows any length of text input to be used.\n */\nextern int hmacReset(HMACContext *ctx, enum SHAversion whichSha,\n                     const unsigned char *key, int key_len);\nextern int hmacInput(HMACContext *ctx, const unsigned char *text,\n                     int text_len);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "extern int hmacFinalBits(HMACContext *ctx, const uint8_t bits,\n                         unsigned int bitcount);\nextern int hmacResult(HMACContext *ctx,\n                      uint8_t digest[USHAMaxHashSize]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#endif /* _SHA_H_ */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. The SHA Code",
      "section_title": true,
      "ja": "8.2. SHAコード"
    },
    {
      "indent": 3,
      "text": "This code is primarily intended as expository and could be optimized further. For example, the assignment rotations through the variables a, b, ..., h could be treated as a cycle and the loop unrolled, rather than doing the explicit copying.",
      "ja": "このコードは、主に説明のためのものであり、さらに最適化することができます。たとえば、変数a、b、...、hによる割り当てのローテーションは、明示的なコピーを行うのではなく、サイクルおよびループの展開として扱うことができます。"
    },
    {
      "indent": 3,
      "text": "Note that there are alternative representations of the Ch() and Maj() functions controlled by an ifdef.",
      "ja": "ifdefによって制御されるCh()関数とMaj()関数の代替表現があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "8.2.1. sha1.c",
      "section_title": true,
      "ja": "8.2.1. sha1.c"
    },
    {
      "indent": 0,
      "text": "/**************************** sha1.c ****************************/\n/******************** See RFC 4634 for details ******************/\n/*\n *  Description:\n *      This file implements the Secure Hash Signature Standard\n *      algorithms as defined in the National Institute of Standards\n *      and Technology Federal Information Processing Standards\n *      Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\n *      published on August 1, 2002, and the FIPS PUB 180-2 Change\n *      Notice published on February 28, 2004.\n *\n *      A combined document showing all algorithms is available at\n *              http://csrc.nist.gov/publications/fips/\n *              fips180-2/fips180-2withchangenotice.pdf\n *\n *      The SHA-1 algorithm produces a 160-bit message digest for a\n *      given data stream.  It should take about 2**n steps to find a\n *      message with the same digest as a given message and\n *      2**(n/2) to find any two messages with the same digest,\n *      when n is the digest size in bits.  Therefore, this\n *      algorithm can serve as a means of providing a\n *      \"fingerprint\" for a message.\n *\n *  Portability Issues:\n *      SHA-1 is defined in terms of 32-bit \"words\".  This code\n *      uses <stdint.h> (included via \"sha.h\") to define 32 and 8\n *      bit unsigned integer types.  If your C compiler does not\n *      support 32 bit unsigned integers, this code is not\n *      appropriate.\n *\n *  Caveats:\n *      SHA-1 is designed to work with messages less than 2^64 bits\n *      long. This implementation uses SHA1Input() to hash the bits\n *      that are a multiple of the size of an 8-bit character, and then\n *      uses SHA1FinalBits() to hash the final few bits of the input.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\" #include \"sha-private.h\"",
      "ja": "#include \"sha.h\" #include \"sha-private.h\""
    },
    {
      "indent": 0,
      "text": "/*\n *  Define the SHA1 circular left shift macro\n */\n#define SHA1_ROTL(bits,word) \\\n                (((word) << (bits)) | ((word) >> (32-(bits))))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * add \"length\" to the length\n */\nstatic uint32_t addTemp;\n#define SHA1AddLength(context, length)                     \\\n    (addTemp = (context)->Length_Low,                      \\\n     (context)->Corrupted =                                \\\n        (((context)->Length_Low += (length)) < addTemp) && \\\n        (++(context)->Length_High == 0) ? 1 : 0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototypes */\nstatic void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte);\nstatic void SHA1PadMessage(SHA1Context *, uint8_t Pad_Byte);\nstatic void SHA1ProcessMessageBlock(SHA1Context *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Reset\n *\n *  Description:\n *      This function will initialize the SHA1Context in preparation\n *      for computing a new SHA1 message digest.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Reset(SHA1Context *context)\n{\n    if (!context)\n        return shaNull;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "context->Length_Low             = 0;\ncontext->Length_High            = 0;\ncontext->Message_Block_Index    = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Initial Hash Values: FIPS-180-2 section 5.3.1 */\ncontext->Intermediate_Hash[0]   = 0x67452301;\ncontext->Intermediate_Hash[1]   = 0xEFCDAB89;\ncontext->Intermediate_Hash[2]   = 0x98BADCFE;\ncontext->Intermediate_Hash[3]   = 0x10325476;\ncontext->Intermediate_Hash[4]   = 0xC3D2E1F0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "context->Computed   = 0;\ncontext->Corrupted  = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Input\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n *      context: [in/out]\n *          The SHA context to update\n *      message_array: [in]\n *          An array of characters representing the next portion of\n *          the message.\n *      length: [in]\n *          The length of the message in message_array\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Input(SHA1Context *context,\n    const uint8_t *message_array, unsigned length)\n{\n  if (!length)\n    return shaSuccess;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!context || !message_array) return shaNull;",
      "ja": "if（！context ||！message_array）return shaNull;"
    },
    {
      "indent": 2,
      "text": "if (context->Computed) {\n  context->Corrupted = shaStateError;\n  return shaStateError;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted)",
      "ja": "if（コンテキスト->破損）"
    },
    {
      "indent": 5,
      "text": "return context->Corrupted;",
      "ja": "コンテキストを返す->破損。"
    },
    {
      "indent": 2,
      "text": "while (length-- && !context->Corrupted) {\n  context->Message_Block[context->Message_Block_Index++] =\n    (*message_array & 0xFF);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "if (!SHA1AddLength(context, 8) &&\n  (context->Message_Block_Index == SHA1_Message_Block_Size))\n  SHA1ProcessMessageBlock(context);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  message_array++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA1FinalBits(SHA1Context *context, const uint8_t message_bits,\n    unsigned int length)\n{\n  uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE\n  };\n  uint8_t markbit[8] = {\n      /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,\n      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "    /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!length) return shaSuccess;",
      "ja": "if（！length）return shaSuccess;"
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;",
      "ja": "if（！context）はshaNullを返します。"
    },
    {
      "indent": 2,
      "text": "if (context->Computed || (length >= 8) || (length == 0)) {\n  context->Corrupted = shaStateError;\n  return shaStateError;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted) return context->Corrupted;",
      "ja": "if（context-> Corrupted）return context-> Corrupted;"
    },
    {
      "indent": 2,
      "text": "SHA1AddLength(context, length);\nSHA1Finalize(context,\n  (uint8_t) ((message_bits & masks[length]) | markbit[length]));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1Result\n *\n * Description:\n *   This function will return the 160-bit message digest into the\n *   Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the 19th element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA-1 hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA1Result(SHA1Context *context,\n    uint8_t Message_Digest[SHA1HashSize])\n{\n  int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!context || !Message_Digest) return shaNull;",
      "ja": "if（！context ||！Message_Digest）return shaNull;"
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted) return context->Corrupted;",
      "ja": "if（context-> Corrupted）return context-> Corrupted;"
    },
    {
      "indent": 2,
      "text": "if (!context->Computed)\n  SHA1Finalize(context, 0x80);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (i = 0; i < SHA1HashSize; ++i)\n  Message_Digest[i] = (uint8_t) (context->Intermediate_Hash[i>>2]\n            >> 8 * ( 3 - ( i & 0x03 ) ));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1Finalize\n *\n * Description:\n *   This helper function finishes off the digest calculations.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   Pad_Byte: [in]\n *     The last byte to add to the digest before the 0-padding\n *     and length. This will contain the last bits of the message\n *     followed by another single bit. If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nstatic void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte)\n{\n  int i;\n  SHA1PadMessage(context, Pad_Byte);\n  /* message may be sensitive, clear it out */\n  for (i = 0; i < SHA1_Message_Block_Size; ++i)\n    context->Message_Block[i] = 0;\n  context->Length_Low = 0;  /* and clear length */\n  context->Length_High = 0;\n  context->Computed = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " * SHA1PadMessage\n *\n * Description:\n *   According to the standard, the message must be padded to an\n *   even 512 bits. The first padding bit must be a '1'. The last\n *   64 bits represent the length of the original message. All bits\n *   in between should be 0. This helper function will pad the\n *   message according to those rules by filling the Message_Block\n *   array accordingly. When it returns, it can be assumed that the\n *   message digest has been computed.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to pad\n *   Pad_Byte: [in]\n *     The last byte to add to the digest before the 0-padding\n *     and length. This will contain the last bits of the message\n *     followed by another single bit. If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   Nothing.\n */\nstatic void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte)\n{\n  /*\n   * Check to see if the current message block is too small to hold\n   * the initial padding bits and length. If so, we will pad the\n   * block, process it, and then continue padding into a second\n   * block.\n   */\n  if (context->Message_Block_Index >= (SHA1_Message_Block_Size - 8)) {\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n    while (context->Message_Block_Index < SHA1_Message_Block_Size)\n      context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  SHA1ProcessMessageBlock(context);\n} else\n  context->Message_Block[context->Message_Block_Index++] = Pad_Byte;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "while (context->Message_Block_Index < (SHA1_Message_Block_Size - 8))\n  context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/*\n * Store the message length as the last 8 octets\n */\ncontext->Message_Block[56] = (uint8_t) (context->Length_High >> 24);\ncontext->Message_Block[57] = (uint8_t) (context->Length_High >> 16);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Message_Block[58] = (uint8_t) (context->Length_High >> 8);\ncontext->Message_Block[59] = (uint8_t) (context->Length_High);\ncontext->Message_Block[60] = (uint8_t) (context->Length_Low >> 24);\ncontext->Message_Block[61] = (uint8_t) (context->Length_Low >> 16);\ncontext->Message_Block[62] = (uint8_t) (context->Length_Low >> 8);\ncontext->Message_Block[63] = (uint8_t) (context->Length_Low);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  SHA1ProcessMessageBlock(context);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA1ProcessMessageBlock\n *\n * Description:\n *   This helper function will process the next 512 bits of the\n *   message stored in the Message_Block array.\n *\n * Parameters:\n *   None.\n *\n * Returns:\n *   Nothing.\n *\n * Comments:\n *   Many of the variable names in this code, especially the\n *   single character names, were used because those were the\n *   names used in the publication.\n */\nstatic void SHA1ProcessMessageBlock(SHA1Context *context)\n{\n  /* Constants defined in FIPS-180-2, section 4.2.1 */\n  const uint32_t K[4] = {\n      0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6\n  };\n  int        t;               /* Loop counter */\n  uint32_t   temp;            /* Temporary word value */\n  uint32_t   W[80];           /* Word sequence */\n  uint32_t   A, B, C, D, E;   /* Word buffers */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  /*\n   * Initialize the first 16 words in the array W\n   */\n  for (t = 0; t < 16; t++) {\n    W[t]  = ((uint32_t)context->Message_Block[t * 4]) << 24;\n    W[t] |= ((uint32_t)context->Message_Block[t * 4 + 1]) << 16;\n    W[t] |= ((uint32_t)context->Message_Block[t * 4 + 2]) << 8;\n    W[t] |= ((uint32_t)context->Message_Block[t * 4 + 3]);\n  }\n  for (t = 16; t < 80; t++)\n    W[t] = SHA1_ROTL(1, W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "A = context->Intermediate_Hash[0];\nB = context->Intermediate_Hash[1];\nC = context->Intermediate_Hash[2];\nD = context->Intermediate_Hash[3];\nE = context->Intermediate_Hash[4];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 0; t < 20; t++) {\n  temp = SHA1_ROTL(5,A) + SHA_Ch(B, C, D) + E + W[t] + K[0];\n  E = D;\n  D = C;\n  C = SHA1_ROTL(30,B);\n  B = A;\n  A = temp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 20; t < 40; t++) {\n  temp = SHA1_ROTL(5,A) + SHA_Parity(B, C, D) + E + W[t] + K[1];\n  E = D;\n  D = C;\n  C = SHA1_ROTL(30,B);\n  B = A;\n  A = temp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 40; t < 60; t++) {\n  temp = SHA1_ROTL(5,A) + SHA_Maj(B, C, D) + E + W[t] + K[2];\n  E = D;\n  D = C;\n  C = SHA1_ROTL(30,B);\n  B = A;\n  A = temp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 60; t < 80; t++) {\n  temp = SHA1_ROTL(5,A) + SHA_Parity(B, C, D) + E + W[t] + K[3];\n  E = D;\n  D = C;\n  C = SHA1_ROTL(30,B);\n  B = A;\n  A = temp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Intermediate_Hash[0] += A;\ncontext->Intermediate_Hash[1] += B;\ncontext->Intermediate_Hash[2] += C;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Intermediate_Hash[3] += D;\ncontext->Intermediate_Hash[4] += E;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  context->Message_Block_Index = 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2.2. sha224-256.c",
      "section_title": true,
      "ja": "8.2.2. sha224-256.c"
    },
    {
      "indent": 0,
      "text": "/*************************** sha224-256.c ***************************/\n/********************* See RFC 4634 for details *********************/\n/*\n * Description:\n *   This file implements the Secure Hash Signature Standard\n *   algorithms as defined in the National Institute of Standards\n *   and Technology Federal Information Processing Standards\n *   Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\n *   published on August 1, 2002, and the FIPS PUB 180-2 Change\n *   Notice published on February 28, 2004.\n *\n *   A combined document showing all algorithms is available at\n *       http://csrc.nist.gov/publications/fips/\n *       fips180-2/fips180-2withchangenotice.pdf\n *\n *   The SHA-224 and SHA-256 algorithms produce 224-bit and 256-bit\n *   message digests for a given data stream. It should take about\n *   2**n steps to find a message with the same digest as a given\n *   message and 2**(n/2) to find any two messages with the same\n *   digest, when n is the digest size in bits. Therefore, this\n *   algorithm can serve as a means of providing a\n *   \"fingerprint\" for a message.\n *\n * Portability Issues:\n *   SHA-224 and SHA-256 are defined in terms of 32-bit \"words\".\n *   This code uses <stdint.h> (included via \"sha.h\") to define 32\n *   and 8 bit unsigned integer types. If your C compiler does not\n *   support 32 bit unsigned integers, this code is not\n *   appropriate.\n *\n * Caveats:\n *   SHA-224 and SHA-256 are designed to work with messages less\n *   than 2^64 bits long. This implementation uses SHA224/256Input()\n *   to hash the bits that are a multiple of the size of an 8-bit\n *   character, and then uses SHA224/256FinalBits() to hash the\n *   final few bits of the input.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\" #include \"sha-private.h\"",
      "ja": "#include \"sha.h\" #include \"sha-private.h\""
    },
    {
      "indent": 0,
      "text": "/* Define the SHA shift, rotate left and rotate right macro */\n#define SHA256_SHR(bits,word)      ((word) >> (bits))\n#define SHA256_ROTL(bits,word)                         \\\n  (((word) << (bits)) | ((word) >> (32-(bits))))\n#define SHA256_ROTR(bits,word)                         \\\n  (((word) >> (bits)) | ((word) << (32-(bits))))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Define the SHA SIGMA and sigma macros */\n#define SHA256_SIGMA0(word)   \\\n  (SHA256_ROTR( 2,word) ^ SHA256_ROTR(13,word) ^ SHA256_ROTR(22,word))\n#define SHA256_SIGMA1(word)   \\\n  (SHA256_ROTR( 6,word) ^ SHA256_ROTR(11,word) ^ SHA256_ROTR(25,word))\n#define SHA256_sigma0(word)   \\\n  (SHA256_ROTR( 7,word) ^ SHA256_ROTR(18,word) ^ SHA256_SHR( 3,word))\n#define SHA256_sigma1(word)   \\\n  (SHA256_ROTR(17,word) ^ SHA256_ROTR(19,word) ^ SHA256_SHR(10,word))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * add \"length\" to the length\n */\nstatic uint32_t addTemp;\n#define SHA224_256AddLength(context, length)               \\\n  (addTemp = (context)->Length_Low, (context)->Corrupted = \\\n    (((context)->Length_Low += (length)) < addTemp) &&     \\\n    (++(context)->Length_High == 0) ? 1 : 0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototypes */\nstatic void SHA224_256Finalize(SHA256Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA224_256PadMessage(SHA256Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA224_256ProcessMessageBlock(SHA256Context *context);\nstatic int SHA224_256Reset(SHA256Context *context, uint32_t *H0);\nstatic int SHA224_256ResultN(SHA256Context *context,\n  uint8_t Message_Digest[], int HashSize);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Initial Hash Values: FIPS-180-2 Change Notice 1 */\nstatic uint32_t SHA224_H0[SHA256HashSize/4] = {\n    0xC1059ED8, 0x367CD507, 0x3070DD17, 0xF70E5939,\n    0xFFC00B31, 0x68581511, 0x64F98FA7, 0xBEFA4FA4\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Initial Hash Values: FIPS-180-2 section 5.3.2 */\nstatic uint32_t SHA256_H0[SHA256HashSize/4] = {\n  0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224Reset\n *\n * Description:\n *   This function will initialize the SHA384Context in preparation\n *   for computing a new SHA224 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA224Reset(SHA224Context *context)\n{\n  return SHA224_256Reset(context, SHA224_H0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224Input\n *\n * Description:\n *   This function accepts an array of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_array: [in]\n *     An array of characters representing the next portion of\n *     the message.\n *   length: [in]\n *     The length of the message in message_array\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA224Input(SHA224Context *context, const uint8_t *message_array,\n    unsigned int length)\n{\n  return SHA256Input(context, message_array, length);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224FinalBits\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA224FinalBits( SHA224Context *context,\n    const uint8_t message_bits, unsigned int length)\n{\n  return SHA256FinalBits(context, message_bits, length);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224Result\n *\n * Description:\n *   This function will return the 224-bit message\n *   digest into the Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the 28th element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA224Result(SHA224Context *context,\n    uint8_t Message_Digest[SHA224HashSize])\n{\n  return SHA224_256ResultN(context, Message_Digest, SHA224HashSize);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA256Reset",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *\n * Description:\n *   This function will initialize the SHA256Context in preparation\n *   for computing a new SHA256 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA256Reset(SHA256Context *context)\n{\n  return SHA224_256Reset(context, SHA256_H0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA256Input\n *\n * Description:\n *   This function accepts an array of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_array: [in]\n *     An array of characters representing the next portion of\n *     the message.\n *   length: [in]\n *     The length of the message in message_array\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA256Input(SHA256Context *context, const uint8_t *message_array,\n    unsigned int length)\n{\n  if (!length)\n    return shaSuccess;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!context || !message_array) return shaNull;",
      "ja": "if（！context ||！message_array）return shaNull;"
    },
    {
      "indent": 2,
      "text": "if (context->Computed) {\n  context->Corrupted = shaStateError;\n  return shaStateError;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted) return context->Corrupted;",
      "ja": "if（context-> Corrupted）return context-> Corrupted;"
    },
    {
      "indent": 2,
      "text": "while (length-- && !context->Corrupted) {\n  context->Message_Block[context->Message_Block_Index++] =\n          (*message_array & 0xFF);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "if (!SHA224_256AddLength(context, 8) &&\n  (context->Message_Block_Index == SHA256_Message_Block_Size))\n  SHA224_256ProcessMessageBlock(context);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  message_array++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "return shaSuccess;",
      "ja": "shaSuccessを返します。"
    },
    {
      "indent": 0,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "/*\n * SHA256FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA256FinalBits(SHA256Context *context,\n    const uint8_t message_bits, unsigned int length)\n{\n  uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE\n  };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "uint8_t markbit[8] = {\n    /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,\n    /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n    /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,\n    /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!length) return shaSuccess;",
      "ja": "if（！length）return shaSuccess;"
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;",
      "ja": "if（！context）はshaNullを返します。"
    },
    {
      "indent": 2,
      "text": "if ((context->Computed) || (length >= 8) || (length == 0)) {\n  context->Corrupted = shaStateError;\n  return shaStateError;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted) return context->Corrupted;",
      "ja": "if（context-> Corrupted）return context-> Corrupted;"
    },
    {
      "indent": 2,
      "text": "SHA224_256AddLength(context, length);\nSHA224_256Finalize(context, (uint8_t)\n  ((message_bits & masks[length]) | markbit[length]));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA256Result\n *\n * Description:\n *   This function will return the 256-bit message\n *   digest into the Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the 32nd element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n */\nint SHA256Result(SHA256Context *context, uint8_t Message_Digest[])\n{",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return SHA224_256ResultN(context, Message_Digest, SHA256HashSize);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256Finalize\n *\n * Description:\n *   This helper function finishes off the digest calculations.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   Pad_Byte: [in]\n *     The last byte to add to the digest before the 0-padding\n *     and length. This will contain the last bits of the message\n *     followed by another single bit. If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   sha Error Code.\n */\nstatic void SHA224_256Finalize(SHA256Context *context,\n    uint8_t Pad_Byte)\n{\n  int i;\n  SHA224_256PadMessage(context, Pad_Byte);\n  /* message may be sensitive, so clear it out */\n  for (i = 0; i < SHA256_Message_Block_Size; ++i)\n    context->Message_Block[i] = 0;\n  context->Length_Low = 0;  /* and clear length */\n  context->Length_High = 0;\n  context->Computed = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256PadMessage\n *\n * Description:\n *   According to the standard, the message must be padded to an\n *   even 512 bits. The first padding bit must be a '1'. The\n *   last 64 bits represent the length of the original message.\n *   All bits in between should be 0. This helper function will pad\n *   the message according to those rules by filling the\n *   Message_Block array accordingly. When it returns, it can be\n *   assumed that the message digest has been computed.\n *\n * Parameters:\n *   context: [in/out]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *     The context to pad\n *   Pad_Byte: [in]\n *     The last byte to add to the digest before the 0-padding\n *     and length. This will contain the last bits of the message\n *     followed by another single bit. If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   Nothing.\n */\nstatic void SHA224_256PadMessage(SHA256Context *context,\n    uint8_t Pad_Byte)\n{\n  /*\n   * Check to see if the current message block is too small to hold\n   * the initial padding bits and length. If so, we will pad the\n   * block, process it, and then continue padding into a second\n   * block.\n   */\n  if (context->Message_Block_Index >= (SHA256_Message_Block_Size-8)) {\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n    while (context->Message_Block_Index < SHA256_Message_Block_Size)\n      context->Message_Block[context->Message_Block_Index++] = 0;\n    SHA224_256ProcessMessageBlock(context);\n  } else\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "while (context->Message_Block_Index < (SHA256_Message_Block_Size-8))\n  context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/*\n * Store the message length as the last 8 octets\n */\ncontext->Message_Block[56] = (uint8_t)(context->Length_High >> 24);\ncontext->Message_Block[57] = (uint8_t)(context->Length_High >> 16);\ncontext->Message_Block[58] = (uint8_t)(context->Length_High >> 8);\ncontext->Message_Block[59] = (uint8_t)(context->Length_High);\ncontext->Message_Block[60] = (uint8_t)(context->Length_Low >> 24);\ncontext->Message_Block[61] = (uint8_t)(context->Length_Low >> 16);\ncontext->Message_Block[62] = (uint8_t)(context->Length_Low >> 8);\ncontext->Message_Block[63] = (uint8_t)(context->Length_Low);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  SHA224_256ProcessMessageBlock(context);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256ProcessMessageBlock\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " * Description:\n *   This function will process the next 512 bits of the message\n *   stored in the Message_Block array.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *\n * Returns:\n *   Nothing.\n *\n * Comments:\n *   Many of the variable names in this code, especially the\n *   single character names, were used because those were the\n *   names used in the publication.\n */\nstatic void SHA224_256ProcessMessageBlock(SHA256Context *context)\n{\n  /* Constants defined in FIPS-180-2, section 4.2.2 */\n  static const uint32_t K[64] = {\n      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n      0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n      0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n      0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n      0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n      0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n      0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n      0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n      0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n      0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n      0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  };\n  int        t, t4;                   /* Loop counter */\n  uint32_t   temp1, temp2;            /* Temporary word value */\n  uint32_t   W[64];                   /* Word sequence */\n  uint32_t   A, B, C, D, E, F, G, H;  /* Word buffers */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/*\n * Initialize the first 16 words in the array W\n */\nfor (t = t4 = 0; t < 16; t++, t4 += 4)\n  W[t] = (((uint32_t)context->Message_Block[t4]) << 24) |\n         (((uint32_t)context->Message_Block[t4 + 1]) << 16) |\n         (((uint32_t)context->Message_Block[t4 + 2]) << 8) |\n         (((uint32_t)context->Message_Block[t4 + 3]));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 16; t < 64; t++)\n  W[t] = SHA256_sigma1(W[t-2]) + W[t-7] +\n      SHA256_sigma0(W[t-15]) + W[t-16];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "A = context->Intermediate_Hash[0];\nB = context->Intermediate_Hash[1];\nC = context->Intermediate_Hash[2];\nD = context->Intermediate_Hash[3];\nE = context->Intermediate_Hash[4];\nF = context->Intermediate_Hash[5];\nG = context->Intermediate_Hash[6];\nH = context->Intermediate_Hash[7];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 0; t < 64; t++) {\n  temp1 = H + SHA256_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];\n  temp2 = SHA256_SIGMA0(A) + SHA_Maj(A,B,C);\n  H = G;\n  G = F;\n  F = E;\n  E = D + temp1;\n  D = C;\n  C = B;\n  B = A;\n  A = temp1 + temp2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Intermediate_Hash[0] += A;\ncontext->Intermediate_Hash[1] += B;\ncontext->Intermediate_Hash[2] += C;\ncontext->Intermediate_Hash[3] += D;\ncontext->Intermediate_Hash[4] += E;\ncontext->Intermediate_Hash[5] += F;\ncontext->Intermediate_Hash[6] += G;\ncontext->Intermediate_Hash[7] += H;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  context->Message_Block_Index = 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256Reset\n *\n * Description:\n *   This helper function will initialize the SHA256Context in\n *   preparation for computing a new SHA256 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *   H0\n *     The initial hash value to use.\n *\n * Returns:\n *   sha Error Code.\n */\nstatic int SHA224_256Reset(SHA256Context *context, uint32_t *H0)\n{\n  if (!context)\n    return shaNull;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Length_Low           = 0;\ncontext->Length_High          = 0;\ncontext->Message_Block_Index  = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Intermediate_Hash[0] = H0[0];\ncontext->Intermediate_Hash[1] = H0[1];\ncontext->Intermediate_Hash[2] = H0[2];\ncontext->Intermediate_Hash[3] = H0[3];\ncontext->Intermediate_Hash[4] = H0[4];\ncontext->Intermediate_Hash[5] = H0[5];\ncontext->Intermediate_Hash[6] = H0[6];\ncontext->Intermediate_Hash[7] = H0[7];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Computed  = 0;\ncontext->Corrupted = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA224_256ResultN\n *\n * Description:\n *   This helper function will return the 224-bit or 256-bit message\n *   digest into the Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the 28th/32nd element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *   HashSize: [in]\n *     The size of the hash, either 28 or 32.\n *\n * Returns:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *   sha Error Code.\n */\nstatic int SHA224_256ResultN(SHA256Context *context,\n    uint8_t Message_Digest[], int HashSize)\n{\n  int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!context || !Message_Digest) return shaNull;",
      "ja": "if（！context ||！Message_Digest）return shaNull;"
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted) return context->Corrupted;",
      "ja": "if（context-> Corrupted）return context-> Corrupted;"
    },
    {
      "indent": 2,
      "text": "if (!context->Computed)\n  SHA224_256Finalize(context, 0x80);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (i = 0; i < HashSize; ++i)\n  Message_Digest[i] = (uint8_t)\n    (context->Intermediate_Hash[i>>2] >> 8 * ( 3 - ( i & 0x03 ) ));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2.3. sha384-512.c",
      "section_title": true,
      "ja": "8.2.3. sha384-512.c"
    },
    {
      "indent": 0,
      "text": "/*************************** sha384-512.c ***************************/\n/********************* See RFC 4634 for details *********************/\n/*\n * Description:\n *   This file implements the Secure Hash Signature Standard\n *   algorithms as defined in the National Institute of Standards\n *   and Technology Federal Information Processing Standards\n *   Publication (FIPS PUB) 180-1 published on April 17, 1995, 180-2\n *   published on August 1, 2002, and the FIPS PUB 180-2 Change\n *   Notice published on February 28, 2004.\n *\n *   A combined document showing all algorithms is available at\n *       http://csrc.nist.gov/publications/fips/\n *       fips180-2/fips180-2withchangenotice.pdf\n *\n *   The SHA-384 and SHA-512 algorithms produce 384-bit and 512-bit\n *   message digests for a given data stream. It should take about\n *   2**n steps to find a message with the same digest as a given\n *   message and 2**(n/2) to find any two messages with the same\n *   digest, when n is the digest size in bits. Therefore, this\n *   algorithm can serve as a means of providing a\n *   \"fingerprint\" for a message.\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "* Portability Issues: * SHA-384 and SHA-512 are defined in terms of 64-bit \"words\", * but if USE_32BIT_ONLY is #defined, this code is implemented in * terms of 32-bit \"words\". This code uses <stdint.h> (included * via \"sha.h\") to define the 64, 32 and 8 bit unsigned integer * types. If your C compiler does not support 64 bit unsigned * integers, and you do not #define USE_32BIT_ONLY, this code is * not appropriate. * * Caveats: * SHA-384 and SHA-512 are designed to work with messages less * than 2^128 bits long. This implementation uses * SHA384/512Input() to hash the bits that are a multiple of the * size of an 8-bit character, and then uses SHA384/256FinalBits() * to hash the final few bits of the input. * */",
      "ja": "* 移植性の問題：* SHA-384およびSHA-512は、64ビットの「ワード」に関して定義されています。*ただし、USE_32BIT_ONLYが#definedの場合、このコードは、32ビットの「ワード」に関して実装されます。このコードは、<stdint.h>（「sha.h」を介して*に含まれる）を使用して、64、32、および8ビットの符号なし整数*型を定義します。 Cコンパイラが64ビットの符号なし整数をサポートしておらず、USE_32BIT_ONLYを#defineしていない場合、このコードは適切ではありません。 * *警告：* SHA-384およびSHA-512は、長さが2 ^ 128ビット未満のメッセージで動作するように設計されています。この実装は* SHA384 / 512Input()を使用して* 8ビット文字のサイズの倍数であるビットをハッシュし、* SHA384 / 256FinalBits()*を使用して入力の最後の数ビットをハッシュします。 * * /"
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\" #include \"sha-private.h\"",
      "ja": "#include \"sha.h\" #include \"sha-private.h\""
    },
    {
      "indent": 0,
      "text": "#ifdef USE_32BIT_ONLY\n/*\n * Define 64-bit arithmetic in terms of 32-bit arithmetic.\n * Each 64-bit number is represented in a 2-word array.\n * All macros are defined such that the result is the last parameter.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Define shift, rotate left and rotate right functions\n */\n#define SHA512_SHR(bits, word, ret) (                          \\\n    /* (((uint64_t)((word))) >> (bits)) */                     \\\n    (ret)[0] = (((bits) < 32) && ((bits) >= 0)) ?              \\\n      ((word)[0] >> (bits)) : 0,                               \\\n    (ret)[1] = ((bits) > 32) ? ((word)[0] >> ((bits) - 32)) :  \\\n      ((bits) == 32) ? (word)[0] :                             \\\n      ((bits) >= 0) ?                                          \\\n        (((word)[0] << (32 - (bits))) |                        \\\n        ((word)[1] >> (bits))) : 0 )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#define SHA512_SHL(bits, word, ret) (                          \\\n    /* (((uint64_t)(word)) << (bits)) */                       \\\n    (ret)[0] = ((bits) > 32) ? ((word)[1] << ((bits) - 32)) :  \\\n         ((bits) == 32) ? (word)[1] :                          \\\n         ((bits) >= 0) ?                                       \\\n           (((word)[0] << (bits)) |                            \\\n           ((word)[1] >> (32 - (bits)))) :                     \\",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     0,                                                    \\\n(ret)[1] = (((bits) < 32) && ((bits) >= 0)) ?              \\\n    ((word)[1] << (bits)) : 0 )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit OR\n */\n#define SHA512_OR(word1, word2, ret) (                         \\\n    (ret)[0] = (word1)[0] | (word2)[0],                        \\\n    (ret)[1] = (word1)[1] | (word2)[1] )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit XOR\n */\n#define SHA512_XOR(word1, word2, ret) (                        \\\n    (ret)[0] = (word1)[0] ^ (word2)[0],                        \\\n    (ret)[1] = (word1)[1] ^ (word2)[1] )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit AND\n */\n#define SHA512_AND(word1, word2, ret) (                        \\\n    (ret)[0] = (word1)[0] & (word2)[0],                        \\\n    (ret)[1] = (word1)[1] & (word2)[1] )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit TILDA\n */\n#define SHA512_TILDA(word, ret)                                \\\n  ( (ret)[0] = ~(word)[0], (ret)[1] = ~(word)[1] )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Define 64-bit ADD\n */\n#define SHA512_ADD(word1, word2, ret) (                        \\\n    (ret)[1] = (word1)[1], (ret)[1] += (word2)[1],             \\\n    (ret)[0] = (word1)[0] + (word2)[0] + ((ret)[1] < (word1)[1]) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Add the 4word value in word2 to word1.\n */\nstatic uint32_t ADDTO4_temp, ADDTO4_temp2;\n#define SHA512_ADDTO4(word1, word2) (                          \\\n    ADDTO4_temp = (word1)[3],                                  \\\n    (word1)[3] += (word2)[3],                                  \\\n    ADDTO4_temp2 = (word1)[2],                                 \\\n    (word1)[2] += (word2)[2] + ((word1)[3] < ADDTO4_temp),     \\\n    ADDTO4_temp = (word1)[1],                                  \\\n    (word1)[1] += (word2)[1] + ((word1)[2] < ADDTO4_temp2),    \\\n    (word1)[0] += (word2)[0] + ((word1)[1] < ADDTO4_temp) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Add the 2word value in word2 to word1.\n */\nstatic uint32_t ADDTO2_temp;\n#define SHA512_ADDTO2(word1, word2) (                          \\\n    ADDTO2_temp = (word1)[1],                                  \\\n    (word1)[1] += (word2)[1],                                  \\\n    (word1)[0] += (word2)[0] + ((word1)[1] < ADDTO2_temp) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA rotate   ((word >> bits) | (word << (64-bits)))\n */\nstatic uint32_t ROTR_temp1[2], ROTR_temp2[2];\n#define SHA512_ROTR(bits, word, ret) (                         \\\n    SHA512_SHR((bits), (word), ROTR_temp1),                    \\\n    SHA512_SHL(64-(bits), (word), ROTR_temp2),                 \\\n    SHA512_OR(ROTR_temp1, ROTR_temp2, (ret)) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Define the SHA SIGMA and sigma macros\n *  SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word)\n */\nstatic uint32_t SIGMA0_temp1[2], SIGMA0_temp2[2],\n  SIGMA0_temp3[2], SIGMA0_temp4[2];\n#define SHA512_SIGMA0(word, ret) (                             \\\n    SHA512_ROTR(28, (word), SIGMA0_temp1),                     \\\n    SHA512_ROTR(34, (word), SIGMA0_temp2),                     \\\n    SHA512_ROTR(39, (word), SIGMA0_temp3),                     \\\n    SHA512_XOR(SIGMA0_temp2, SIGMA0_temp3, SIGMA0_temp4),      \\\n    SHA512_XOR(SIGMA0_temp1, SIGMA0_temp4, (ret)) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word)\n */\nstatic uint32_t SIGMA1_temp1[2], SIGMA1_temp2[2],\n  SIGMA1_temp3[2], SIGMA1_temp4[2];\n#define SHA512_SIGMA1(word, ret) (                             \\\n    SHA512_ROTR(14, (word), SIGMA1_temp1),                     \\\n    SHA512_ROTR(18, (word), SIGMA1_temp2),                     \\\n    SHA512_ROTR(41, (word), SIGMA1_temp3),                     \\\n    SHA512_XOR(SIGMA1_temp2, SIGMA1_temp3, SIGMA1_temp4),      \\\n    SHA512_XOR(SIGMA1_temp1, SIGMA1_temp4, (ret)) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " */ static uint32_t sigma0_temp1[2], sigma0_temp2[2], sigma0_temp3[2], sigma0_temp4[2]; #define SHA512_sigma0(word, ret) ( \\ SHA512_ROTR( 1, (word), sigma0_temp1), \\ SHA512_ROTR( 8, (word), sigma0_temp2), \\ SHA512_SHR( 7, (word), sigma0_temp3), \\ SHA512_XOR(sigma0_temp2, sigma0_temp3, sigma0_temp4), \\ SHA512_XOR(sigma0_temp1, sigma0_temp4, (ret)) )",
      "ja": "* / static uint32_t sigma0_temp1 [2]、sigma0_temp2 [2]、sigma0_temp3 [2]、sigma0_temp4 [2]; #define SHA512_sigma0（word、ret）（\\ SHA512_ROTR（1、（word）、sigma0_temp1）、\\ SHA512_ROTR（8、（word）、sigma0_temp2）、\\ SHA512_SHR（7、（word）、sigma0_temp3）、\\ SHA512 sigma0_temp3、sigma0_temp4）、\\ SHA512_XOR（sigma0_temp1、sigma0_temp4、（ret）））"
    },
    {
      "indent": 0,
      "text": "/*\n * (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))\n */\nstatic uint32_t sigma1_temp1[2], sigma1_temp2[2],\n  sigma1_temp3[2], sigma1_temp4[2];\n#define SHA512_sigma1(word, ret) (                             \\\n    SHA512_ROTR(19, (word), sigma1_temp1),                     \\\n    SHA512_ROTR(61, (word), sigma1_temp2),                     \\\n    SHA512_SHR( 6, (word), sigma1_temp3),                      \\\n    SHA512_XOR(sigma1_temp2, sigma1_temp3, sigma1_temp4),      \\\n    SHA512_XOR(sigma1_temp1, sigma1_temp4, (ret)) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#undef SHA_Ch #undef SHA_Maj",
      "ja": "#undef SHA_Ch #undef SHA_Maj"
    },
    {
      "indent": 0,
      "text": "#ifndef USE_MODIFIED_MACROS\n/*\n * These definitions are the ones used in FIPS-180-2, section 4.1.3\n *  Ch(x,y,z)   ((x & y) ^ (~x & z))\n */\nstatic uint32_t Ch_temp1[2], Ch_temp2[2], Ch_temp3[2];\n#define SHA_Ch(x, y, z, ret) (                                 \\\n    SHA512_AND(x, y, Ch_temp1),                                \\\n    SHA512_TILDA(x, Ch_temp2),                                 \\\n    SHA512_AND(Ch_temp2, z, Ch_temp3),                         \\\n    SHA512_XOR(Ch_temp1, Ch_temp3, (ret)) )\n/*\n *  Maj(x,y,z)  (((x)&(y)) ^ ((x)&(z)) ^ ((y)&(z)))\n */\nstatic uint32_t Maj_temp1[2], Maj_temp2[2],\n  Maj_temp3[2], Maj_temp4[2];\n#define SHA_Maj(x, y, z, ret) (                                \\\n    SHA512_AND(x, y, Maj_temp1),                               \\\n    SHA512_AND(x, z, Maj_temp2),                               \\\n    SHA512_AND(y, z, Maj_temp3),                               \\\n    SHA512_XOR(Maj_temp2, Maj_temp3, Maj_temp4),               \\\n    SHA512_XOR(Maj_temp1, Maj_temp4, (ret)) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#else /* !USE_32BIT_ONLY */\n/*\n * These definitions are potentially faster equivalents for the ones\n * used in FIPS-180-2, section 4.1.3.\n *   ((x & y) ^ (~x & z)) becomes\n *   ((x & (y ^ z)) ^ z)\n */\n#define SHA_Ch(x, y, z, ret) (                                 \\\n   (ret)[0] = (((x)[0] & ((y)[0] ^ (z)[0])) ^ (z)[0]),         \\\n   (ret)[1] = (((x)[1] & ((y)[1] ^ (z)[1])) ^ (z)[1]) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *   ((x & y) ^ (x & z) ^ (y & z)) becomes\n *   ((x & (y | z)) | (y & z))\n */\n#define SHA_Maj(x, y, z, ret) (                                 \\\n   ret[0] = (((x)[0] & ((y)[0] | (z)[0])) | ((y)[0] & (z)[0])), \\\n   ret[1] = (((x)[1] & ((y)[1] | (z)[1])) | ((y)[1] & (z)[1])) )\n#endif /* USE_MODIFIED_MACROS */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * add \"length\" to the length\n */\nstatic uint32_t addTemp[4] = { 0, 0, 0, 0 };\n#define SHA384_512AddLength(context, length) (                        \\\n    addTemp[3] = (length), SHA512_ADDTO4((context)->Length, addTemp), \\\n    (context)->Corrupted = (((context)->Length[3] == 0) &&            \\\n       ((context)->Length[2] == 0) && ((context)->Length[1] == 0) &&  \\\n       ((context)->Length[0] < 8)) ? 1 : 0 )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototypes */\nstatic void SHA384_512Finalize(SHA512Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA384_512PadMessage(SHA512Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA384_512ProcessMessageBlock(SHA512Context *context);\nstatic int SHA384_512Reset(SHA512Context *context, uint32_t H0[]);\nstatic int SHA384_512ResultN( SHA512Context *context,\n  uint8_t Message_Digest[], int HashSize);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Initial Hash Values: FIPS-180-2 sections 5.3.3 and 5.3.4 */\nstatic uint32_t SHA384_H0[SHA512HashSize/4] = {\n    0xCBBB9D5D, 0xC1059ED8, 0x629A292A, 0x367CD507, 0x9159015A,\n    0x3070DD17, 0x152FECD8, 0xF70E5939, 0x67332667, 0xFFC00B31,\n    0x8EB44A87, 0x68581511, 0xDB0C2E0D, 0x64F98FA7, 0x47B5481D,\n    0xBEFA4FA4\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static uint32_t SHA512_H0[SHA512HashSize/4] = {\n    0x6A09E667, 0xF3BCC908, 0xBB67AE85, 0x84CAA73B, 0x3C6EF372,\n    0xFE94F82B, 0xA54FF53A, 0x5F1D36F1, 0x510E527F, 0xADE682D1,\n    0x9B05688C, 0x2B3E6C1F, 0x1F83D9AB, 0xFB41BD6B, 0x5BE0CD19,\n    0x137E2179\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#else /* !USE_32BIT_ONLY */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Define the SHA shift, rotate left and rotate right macro */\n#define SHA512_SHR(bits,word)  (((uint64_t)(word)) >> (bits))\n#define SHA512_ROTR(bits,word) ((((uint64_t)(word)) >> (bits)) | \\\n                                (((uint64_t)(word)) << (64-(bits))))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Define the SHA SIGMA and sigma macros */\n#define SHA512_SIGMA0(word)   \\\n (SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word))\n#define SHA512_SIGMA1(word)   \\\n (SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word))\n#define SHA512_sigma0(word)   \\\n (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))\n#define SHA512_sigma1(word)   \\\n (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * add \"length\" to the length\n */\nstatic uint64_t addTemp;\n#define SHA384_512AddLength(context, length)                   \\\n   (addTemp = context->Length_Low, context->Corrupted =        \\\n    ((context->Length_Low += length) < addTemp) &&             \\\n    (++context->Length_High == 0) ? 1 : 0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototypes */\nstatic void SHA384_512Finalize(SHA512Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA384_512PadMessage(SHA512Context *context,\n  uint8_t Pad_Byte);\nstatic void SHA384_512ProcessMessageBlock(SHA512Context *context);\nstatic int SHA384_512Reset(SHA512Context *context, uint64_t H0[]);\nstatic int SHA384_512ResultN(SHA512Context *context,\n  uint8_t Message_Digest[], int HashSize);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Initial Hash Values: FIPS-180-2 sections 5.3.3 and 5.3.4 */\nstatic uint64_t SHA384_H0[] = {\n    0xCBBB9D5DC1059ED8ll, 0x629A292A367CD507ll, 0x9159015A3070DD17ll,\n    0x152FECD8F70E5939ll, 0x67332667FFC00B31ll, 0x8EB44A8768581511ll,\n    0xDB0C2E0D64F98FA7ll, 0x47B5481DBEFA4FA4ll",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "};\nstatic uint64_t SHA512_H0[] = {\n    0x6A09E667F3BCC908ll, 0xBB67AE8584CAA73Bll, 0x3C6EF372FE94F82Bll,\n    0xA54FF53A5F1D36F1ll, 0x510E527FADE682D1ll, 0x9B05688C2B3E6C1Fll,\n    0x1F83D9ABFB41BD6Bll, 0x5BE0CD19137E2179ll\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384Reset\n *\n * Description:\n *   This function will initialize the SHA384Context in preparation\n *   for computing a new SHA384 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA384Reset(SHA384Context *context)\n{\n  return SHA384_512Reset(context, SHA384_H0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384Input\n *\n * Description:\n *   This function accepts an array of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_array: [in]\n *     An array of characters representing the next portion of\n *     the message.\n *   length: [in]\n *     The length of the message in message_array\n *\n * Returns:\n *   sha Error Code.\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " */\nint SHA384Input(SHA384Context *context,\n    const uint8_t *message_array, unsigned int length)\n{\n  return SHA512Input(context, message_array, length);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA384FinalBits(SHA384Context *context,\n    const uint8_t message_bits, unsigned int length)\n{\n  return SHA512FinalBits(context, message_bits, length);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384Result\n *\n * Description:\n *   This function will return the 384-bit message\n *   digest into the Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the 48th element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " * Returns:\n *   sha Error Code.\n *\n */\nint SHA384Result(SHA384Context *context,\n    uint8_t Message_Digest[SHA384HashSize])\n{\n  return SHA384_512ResultN(context, Message_Digest, SHA384HashSize);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512Reset\n *\n * Description:\n *   This function will initialize the SHA512Context in preparation\n *   for computing a new SHA512 message digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA512Reset(SHA512Context *context)\n{\n  return SHA384_512Reset(context, SHA512_H0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512Input\n *\n * Description:\n *   This function accepts an array of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_array: [in]\n *     An array of characters representing the next portion of\n *     the message.\n *   length: [in]\n *     The length of the message in message_array\n *\n * Returns:\n *   sha Error Code.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *\n */\nint SHA512Input(SHA512Context *context,\n        const uint8_t *message_array,\n        unsigned int length)\n{\n  if (!length)\n    return shaSuccess;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!context || !message_array) return shaNull;",
      "ja": "if（！context ||！message_array）return shaNull;"
    },
    {
      "indent": 2,
      "text": "if (context->Computed) {\n  context->Corrupted = shaStateError;\n  return shaStateError;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted) return context->Corrupted;",
      "ja": "if（context-> Corrupted）return context-> Corrupted;"
    },
    {
      "indent": 2,
      "text": "while (length-- && !context->Corrupted) {\n  context->Message_Block[context->Message_Block_Index++] =\n          (*message_array & 0xFF);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "if (!SHA384_512AddLength(context, 8) &&\n  (context->Message_Block_Index == SHA512_Message_Block_Size))\n  SHA384_512ProcessMessageBlock(context);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  message_array++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512FinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint SHA512FinalBits(SHA512Context *context,\n    const uint8_t message_bits, unsigned int length)\n{\n  uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE\n  };\n  uint8_t markbit[8] = {\n      /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,\n      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,\n      /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01\n  };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!length) return shaSuccess;",
      "ja": "if（！length）return shaSuccess;"
    },
    {
      "indent": 2,
      "text": "if (!context) return shaNull;",
      "ja": "if（！context）はshaNullを返します。"
    },
    {
      "indent": 2,
      "text": "if ((context->Computed) || (length >= 8) || (length == 0)) {\n  context->Corrupted = shaStateError;\n  return shaStateError;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted) return context->Corrupted;",
      "ja": "if（context-> Corrupted）return context-> Corrupted;"
    },
    {
      "indent": 2,
      "text": "SHA384_512AddLength(context, length);\nSHA384_512Finalize(context, (uint8_t)\n  ((message_bits & masks[length]) | markbit[length]));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512Finalize\n *\n * Description:\n *   This helper function finishes off the digest calculations.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   Pad_Byte: [in]\n *     The last byte to add to the digest before the 0-padding\n *     and length. This will contain the last bits of the message\n *     followed by another single bit. If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nstatic void SHA384_512Finalize(SHA512Context *context,\n    uint8_t Pad_Byte)\n{\n  int_least16_t i;\n  SHA384_512PadMessage(context, Pad_Byte);\n  /* message may be sensitive, clear it out */\n  for (i = 0; i < SHA512_Message_Block_Size; ++i)\n    context->Message_Block[i] = 0;\n#ifdef USE_32BIT_ONLY    /* and clear length */\n  context->Length[0] = context->Length[1] = 0;\n  context->Length[2] = context->Length[3] = 0;\n#else /* !USE_32BIT_ONLY */\n  context->Length_Low = 0;\n  context->Length_High = 0;\n#endif /* USE_32BIT_ONLY */\n  context->Computed = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA512Result\n *\n * Description:\n *   This function will return the 512-bit message\n *   digest into the Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the 64th element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *\n * Returns:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *   sha Error Code.\n *\n */\nint SHA512Result(SHA512Context *context,\n    uint8_t Message_Digest[SHA512HashSize])\n{\n  return SHA384_512ResultN(context, Message_Digest, SHA512HashSize);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512PadMessage\n *\n * Description:\n *   According to the standard, the message must be padded to an\n *   even 1024 bits. The first padding bit must be a '1'. The\n *   last 128 bits represent the length of the original message.\n *   All bits in between should be 0. This helper function will\n *   pad the message according to those rules by filling the\n *   Message_Block array accordingly. When it returns, it can be\n *   assumed that the message digest has been computed.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to pad\n *   Pad_Byte: [in]\n *     The last byte to add to the digest before the 0-padding\n *     and length. This will contain the last bits of the message\n *     followed by another single bit. If the message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   Nothing.\n *\n */\nstatic void SHA384_512PadMessage(SHA512Context *context,\n    uint8_t Pad_Byte)\n{\n  /*\n   * Check to see if the current message block is too small to hold\n   * the initial padding bits and length. If so, we will pad the\n   * block, process it, and then continue padding into a second\n   * block.\n   */\n  if (context->Message_Block_Index >= (SHA512_Message_Block_Size-16)) {\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n    while (context->Message_Block_Index < SHA512_Message_Block_Size)\n      context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  SHA384_512ProcessMessageBlock(context);\n} else\n  context->Message_Block[context->Message_Block_Index++] = Pad_Byte;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "while (context->Message_Block_Index < (SHA512_Message_Block_Size-16))\n  context->Message_Block[context->Message_Block_Index++] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  /*\n   * Store the message length as the last 16 octets\n   */\n#ifdef USE_32BIT_ONLY\n  context->Message_Block[112] = (uint8_t)(context->Length[0] >> 24);\n  context->Message_Block[113] = (uint8_t)(context->Length[0] >> 16);\n  context->Message_Block[114] = (uint8_t)(context->Length[0] >> 8);\n  context->Message_Block[115] = (uint8_t)(context->Length[0]);\n  context->Message_Block[116] = (uint8_t)(context->Length[1] >> 24);\n  context->Message_Block[117] = (uint8_t)(context->Length[1] >> 16);\n  context->Message_Block[118] = (uint8_t)(context->Length[1] >> 8);\n  context->Message_Block[119] = (uint8_t)(context->Length[1]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  context->Message_Block[120] = (uint8_t)(context->Length[2] >> 24);\n  context->Message_Block[121] = (uint8_t)(context->Length[2] >> 16);\n  context->Message_Block[122] = (uint8_t)(context->Length[2] >> 8);\n  context->Message_Block[123] = (uint8_t)(context->Length[2]);\n  context->Message_Block[124] = (uint8_t)(context->Length[3] >> 24);\n  context->Message_Block[125] = (uint8_t)(context->Length[3] >> 16);\n  context->Message_Block[126] = (uint8_t)(context->Length[3] >> 8);\n  context->Message_Block[127] = (uint8_t)(context->Length[3]);\n#else /* !USE_32BIT_ONLY */\n  context->Message_Block[112] = (uint8_t)(context->Length_High >> 56);\n  context->Message_Block[113] = (uint8_t)(context->Length_High >> 48);\n  context->Message_Block[114] = (uint8_t)(context->Length_High >> 40);\n  context->Message_Block[115] = (uint8_t)(context->Length_High >> 32);\n  context->Message_Block[116] = (uint8_t)(context->Length_High >> 24);\n  context->Message_Block[117] = (uint8_t)(context->Length_High >> 16);\n  context->Message_Block[118] = (uint8_t)(context->Length_High >> 8);\n  context->Message_Block[119] = (uint8_t)(context->Length_High);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  context->Message_Block[120] = (uint8_t)(context->Length_Low >> 56);\n  context->Message_Block[121] = (uint8_t)(context->Length_Low >> 48);\n  context->Message_Block[122] = (uint8_t)(context->Length_Low >> 40);\n  context->Message_Block[123] = (uint8_t)(context->Length_Low >> 32);\n  context->Message_Block[124] = (uint8_t)(context->Length_Low >> 24);\n  context->Message_Block[125] = (uint8_t)(context->Length_Low >> 16);\n  context->Message_Block[126] = (uint8_t)(context->Length_Low >> 8);\n  context->Message_Block[127] = (uint8_t)(context->Length_Low);\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  SHA384_512ProcessMessageBlock(context);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512ProcessMessageBlock\n *\n * Description:\n *   This helper function will process the next 1024 bits of the\n *   message stored in the Message_Block array.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *\n * Returns:\n *   Nothing.\n *\n * Comments:\n *   Many of the variable names in this code, especially the\n *   single character names, were used because those were the\n *   names used in the publication.\n *\n *\n */\nstatic void SHA384_512ProcessMessageBlock(SHA512Context *context)\n{\n  /* Constants defined in FIPS-180-2, section 4.2.3 */\n#ifdef USE_32BIT_ONLY\n  static const uint32_t K[80*2] = {\n      0x428A2F98, 0xD728AE22, 0x71374491, 0x23EF65CD, 0xB5C0FBCF,\n      0xEC4D3B2F, 0xE9B5DBA5, 0x8189DBBC, 0x3956C25B, 0xF348B538,\n      0x59F111F1, 0xB605D019, 0x923F82A4, 0xAF194F9B, 0xAB1C5ED5,\n      0xDA6D8118, 0xD807AA98, 0xA3030242, 0x12835B01, 0x45706FBE,\n      0x243185BE, 0x4EE4B28C, 0x550C7DC3, 0xD5FFB4E2, 0x72BE5D74,\n      0xF27B896F, 0x80DEB1FE, 0x3B1696B1, 0x9BDC06A7, 0x25C71235,\n      0xC19BF174, 0xCF692694, 0xE49B69C1, 0x9EF14AD2, 0xEFBE4786,\n      0x384F25E3, 0x0FC19DC6, 0x8B8CD5B5, 0x240CA1CC, 0x77AC9C65,\n      0x2DE92C6F, 0x592B0275, 0x4A7484AA, 0x6EA6E483, 0x5CB0A9DC,\n      0xBD41FBD4, 0x76F988DA, 0x831153B5, 0x983E5152, 0xEE66DFAB,\n      0xA831C66D, 0x2DB43210, 0xB00327C8, 0x98FB213F, 0xBF597FC7,\n      0xBEEF0EE4, 0xC6E00BF3, 0x3DA88FC2, 0xD5A79147, 0x930AA725,\n      0x06CA6351, 0xE003826F, 0x14292967, 0x0A0E6E70, 0x27B70A85,\n      0x46D22FFC, 0x2E1B2138, 0x5C26C926, 0x4D2C6DFC, 0x5AC42AED,\n      0x53380D13, 0x9D95B3DF, 0x650A7354, 0x8BAF63DE, 0x766A0ABB,\n      0x3C77B2A8, 0x81C2C92E, 0x47EDAEE6, 0x92722C85, 0x1482353B,\n      0xA2BFE8A1, 0x4CF10364, 0xA81A664B, 0xBC423001, 0xC24B8B70,\n      0xD0F89791, 0xC76C51A3, 0x0654BE30, 0xD192E819, 0xD6EF5218,\n      0xD6990624, 0x5565A910, 0xF40E3585, 0x5771202A, 0x106AA070,\n      0x32BBD1B8, 0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53,\n      0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8, 0x391C0CB3,\n      0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB, 0x5B9CCA4F, 0x7763E373,\n      0x682E6FF3, 0xD6B2B8A3, 0x748F82EE, 0x5DEFB2FC, 0x78A5636F,\n      0x43172F60, 0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC,\n      0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9, 0xBEF9A3F7,\n      0xB2C67915, 0xC67178F2, 0xE372532B, 0xCA273ECE, 0xEA26619C,\n      0xD186B8C7, 0x21C0C207, 0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F,\n      0xEE6ED178, 0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6,\n      0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B, 0x28DB77F5,\n      0x23047D84, 0x32CAAB7B, 0x40C72493, 0x3C9EBE0A, 0x15C9BEBC,\n      0x431D67C4, 0x9C100D4C, 0x4CC5D4BE, 0xCB3E42B6, 0x597F299C,\n      0xFC657E2A, 0x5FCB6FAB, 0x3AD6FAEC, 0x6C44198C, 0x4A475817\n  };\n  int     t, t2, t8;                  /* Loop counter */\n  uint32_t  temp1[2], temp2[2],       /* Temporary word values */\n        temp3[2], temp4[2], temp5[2];\n  uint32_t  W[2*80];                  /* Word sequence */\n  uint32_t  A[2], B[2], C[2], D[2],   /* Word buffers */\n        E[2], F[2], G[2], H[2];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* Initialize the first 16 words in the array W */\nfor (t = t2 = t8 = 0; t < 16; t++, t8 += 8) {\n  W[t2++] = ((((uint32_t)context->Message_Block[t8    ])) << 24) |\n            ((((uint32_t)context->Message_Block[t8 + 1])) << 16) |\n            ((((uint32_t)context->Message_Block[t8 + 2])) << 8) |\n            ((((uint32_t)context->Message_Block[t8 + 3])));\n  W[t2++] = ((((uint32_t)context->Message_Block[t8 + 4])) << 24) |\n            ((((uint32_t)context->Message_Block[t8 + 5])) << 16) |\n            ((((uint32_t)context->Message_Block[t8 + 6])) << 8) |\n            ((((uint32_t)context->Message_Block[t8 + 7])));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 16; t < 80; t++, t2 += 2) {\n  /* W[t] = SHA512_sigma1(W[t-2]) + W[t-7] +\n    SHA512_sigma0(W[t-15]) + W[t-16]; */\n  uint32_t *Wt2 = &W[t2-2*2];\n  uint32_t *Wt7 = &W[t2-7*2];\n  uint32_t *Wt15 = &W[t2-15*2];\n  uint32_t *Wt16 = &W[t2-16*2];\n  SHA512_sigma1(Wt2, temp1);\n  SHA512_ADD(temp1, Wt7, temp2);\n  SHA512_sigma0(Wt15, temp1);\n  SHA512_ADD(temp1, Wt16, temp3);\n  SHA512_ADD(temp2, temp3, &W[t2]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "A[0] = context->Intermediate_Hash[0];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "A[1] = context->Intermediate_Hash[1];\nB[0] = context->Intermediate_Hash[2];\nB[1] = context->Intermediate_Hash[3];\nC[0] = context->Intermediate_Hash[4];\nC[1] = context->Intermediate_Hash[5];\nD[0] = context->Intermediate_Hash[6];\nD[1] = context->Intermediate_Hash[7];\nE[0] = context->Intermediate_Hash[8];\nE[1] = context->Intermediate_Hash[9];\nF[0] = context->Intermediate_Hash[10];\nF[1] = context->Intermediate_Hash[11];\nG[0] = context->Intermediate_Hash[12];\nG[1] = context->Intermediate_Hash[13];\nH[0] = context->Intermediate_Hash[14];\nH[1] = context->Intermediate_Hash[15];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = t2 = 0; t < 80; t++, t2 += 2) {\n  /*\n   * temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];\n   */\n  SHA512_SIGMA1(E,temp1);\n  SHA512_ADD(H, temp1, temp2);\n  SHA_Ch(E,F,G,temp3);\n  SHA512_ADD(temp2, temp3, temp4);\n  SHA512_ADD(&K[t2], &W[t2], temp5);\n  SHA512_ADD(temp4, temp5, temp1);\n  /*\n   * temp2 = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);\n   */\n  SHA512_SIGMA0(A,temp3);\n  SHA_Maj(A,B,C,temp4);\n  SHA512_ADD(temp3, temp4, temp2);\n  H[0] = G[0]; H[1] = G[1];\n  G[0] = F[0]; G[1] = F[1];\n  F[0] = E[0]; F[1] = E[1];\n  SHA512_ADD(D, temp1, E);\n  D[0] = C[0]; D[1] = C[1];\n  C[0] = B[0]; C[1] = B[1];\n  B[0] = A[0]; B[1] = A[1];\n  SHA512_ADD(temp1, temp2, A);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "SHA512_ADDTO2(&context->Intermediate_Hash[0], A);\nSHA512_ADDTO2(&context->Intermediate_Hash[2], B);\nSHA512_ADDTO2(&context->Intermediate_Hash[4], C);\nSHA512_ADDTO2(&context->Intermediate_Hash[6], D);\nSHA512_ADDTO2(&context->Intermediate_Hash[8], E);\nSHA512_ADDTO2(&context->Intermediate_Hash[10], F);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "SHA512_ADDTO2(&context->Intermediate_Hash[12], G);\nSHA512_ADDTO2(&context->Intermediate_Hash[14], H);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#else /* !USE_32BIT_ONLY */\n  static const uint64_t K[80] = {\n      0x428A2F98D728AE22ll, 0x7137449123EF65CDll, 0xB5C0FBCFEC4D3B2Fll,\n      0xE9B5DBA58189DBBCll, 0x3956C25BF348B538ll, 0x59F111F1B605D019ll,\n      0x923F82A4AF194F9Bll, 0xAB1C5ED5DA6D8118ll, 0xD807AA98A3030242ll,\n      0x12835B0145706FBEll, 0x243185BE4EE4B28Cll, 0x550C7DC3D5FFB4E2ll,\n      0x72BE5D74F27B896Fll, 0x80DEB1FE3B1696B1ll, 0x9BDC06A725C71235ll,\n      0xC19BF174CF692694ll, 0xE49B69C19EF14AD2ll, 0xEFBE4786384F25E3ll,\n      0x0FC19DC68B8CD5B5ll, 0x240CA1CC77AC9C65ll, 0x2DE92C6F592B0275ll,\n      0x4A7484AA6EA6E483ll, 0x5CB0A9DCBD41FBD4ll, 0x76F988DA831153B5ll,\n      0x983E5152EE66DFABll, 0xA831C66D2DB43210ll, 0xB00327C898FB213Fll,\n      0xBF597FC7BEEF0EE4ll, 0xC6E00BF33DA88FC2ll, 0xD5A79147930AA725ll,\n      0x06CA6351E003826Fll, 0x142929670A0E6E70ll, 0x27B70A8546D22FFCll,\n      0x2E1B21385C26C926ll, 0x4D2C6DFC5AC42AEDll, 0x53380D139D95B3DFll,\n      0x650A73548BAF63DEll, 0x766A0ABB3C77B2A8ll, 0x81C2C92E47EDAEE6ll,\n      0x92722C851482353Bll, 0xA2BFE8A14CF10364ll, 0xA81A664BBC423001ll,\n      0xC24B8B70D0F89791ll, 0xC76C51A30654BE30ll, 0xD192E819D6EF5218ll,\n      0xD69906245565A910ll, 0xF40E35855771202All, 0x106AA07032BBD1B8ll,\n      0x19A4C116B8D2D0C8ll, 0x1E376C085141AB53ll, 0x2748774CDF8EEB99ll,\n      0x34B0BCB5E19B48A8ll, 0x391C0CB3C5C95A63ll, 0x4ED8AA4AE3418ACBll,\n      0x5B9CCA4F7763E373ll, 0x682E6FF3D6B2B8A3ll, 0x748F82EE5DEFB2FCll,\n      0x78A5636F43172F60ll, 0x84C87814A1F0AB72ll, 0x8CC702081A6439ECll,\n      0x90BEFFFA23631E28ll, 0xA4506CEBDE82BDE9ll, 0xBEF9A3F7B2C67915ll,\n      0xC67178F2E372532Bll, 0xCA273ECEEA26619Cll, 0xD186B8C721C0C207ll,\n      0xEADA7DD6CDE0EB1Ell, 0xF57D4F7FEE6ED178ll, 0x06F067AA72176FBAll,\n      0x0A637DC5A2C898A6ll, 0x113F9804BEF90DAEll, 0x1B710B35131C471Bll,\n      0x28DB77F523047D84ll, 0x32CAAB7B40C72493ll, 0x3C9EBE0A15C9BEBCll,\n      0x431D67C49C100D4Cll, 0x4CC5D4BECB3E42B6ll, 0x597F299CFC657E2All,\n      0x5FCB6FAB3AD6FAECll, 0x6C44198C4A475817ll\n  };\n  int        t, t8;                   /* Loop counter */\n  uint64_t   temp1, temp2;            /* Temporary word value */\n  uint64_t   W[80];                   /* Word sequence */\n  uint64_t   A, B, C, D, E, F, G, H;  /* Word buffers */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  /*\n   * Initialize the first 16 words in the array W\n   */\n  for (t = t8 = 0; t < 16; t++, t8 += 8)\n    W[t] = ((uint64_t)(context->Message_Block[t8  ]) << 56) |\n           ((uint64_t)(context->Message_Block[t8 + 1]) << 48) |\n           ((uint64_t)(context->Message_Block[t8 + 2]) << 40) |\n           ((uint64_t)(context->Message_Block[t8 + 3]) << 32) |\n           ((uint64_t)(context->Message_Block[t8 + 4]) << 24) |\n           ((uint64_t)(context->Message_Block[t8 + 5]) << 16) |\n           ((uint64_t)(context->Message_Block[t8 + 6]) << 8) |\n           ((uint64_t)(context->Message_Block[t8 + 7]));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 16; t < 80; t++)\n  W[t] = SHA512_sigma1(W[t-2]) + W[t-7] +\n      SHA512_sigma0(W[t-15]) + W[t-16];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "A = context->Intermediate_Hash[0];\nB = context->Intermediate_Hash[1];\nC = context->Intermediate_Hash[2];\nD = context->Intermediate_Hash[3];\nE = context->Intermediate_Hash[4];\nF = context->Intermediate_Hash[5];\nG = context->Intermediate_Hash[6];\nH = context->Intermediate_Hash[7];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (t = 0; t < 80; t++) {\n  temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];\n  temp2 = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);\n  H = G;\n  G = F;\n  F = E;\n  E = D + temp1;\n  D = C;\n  C = B;\n  B = A;\n  A = temp1 + temp2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  context->Intermediate_Hash[0] += A;\n  context->Intermediate_Hash[1] += B;\n  context->Intermediate_Hash[2] += C;\n  context->Intermediate_Hash[3] += D;\n  context->Intermediate_Hash[4] += E;\n  context->Intermediate_Hash[5] += F;\n  context->Intermediate_Hash[6] += G;\n  context->Intermediate_Hash[7] += H;\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  context->Message_Block_Index = 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512Reset\n *\n * Description:\n *   This helper function will initialize the SHA512Context in\n *   preparation for computing a new SHA384 or SHA512 message",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *   digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *   H0\n *     The initial hash value to use.\n *\n * Returns:\n *   sha Error Code.\n *\n */\n#ifdef USE_32BIT_ONLY\nstatic int SHA384_512Reset(SHA512Context *context, uint32_t H0[])\n#else /* !USE_32BIT_ONLY */\nstatic int SHA384_512Reset(SHA512Context *context, uint64_t H0[])\n#endif /* USE_32BIT_ONLY */\n{\n  int i;\n  if (!context)\n    return shaNull;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Message_Block_Index = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#ifdef USE_32BIT_ONLY\n  context->Length[0] = context->Length[1] = 0;\n  context->Length[2] = context->Length[3] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  for (i = 0; i < SHA512HashSize/4; i++)\n    context->Intermediate_Hash[i] = H0[i];\n#else /* !USE_32BIT_ONLY */\n  context->Length_High = context->Length_Low = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  for (i = 0; i < SHA512HashSize/8; i++)\n    context->Intermediate_Hash[i] = H0[i];\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "context->Computed = 0;\ncontext->Corrupted = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * SHA384_512ResultN\n *\n * Description:\n *   This helper function will return the 384-bit or 512-bit message",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *   digest into the Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the 48th/64th element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *   HashSize: [in]\n *     The size of the hash, either 48 or 64.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nstatic int SHA384_512ResultN(SHA512Context *context,\n    uint8_t Message_Digest[], int HashSize)\n{\n  int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#ifdef USE_32BIT_ONLY\n  int i2;\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!context || !Message_Digest) return shaNull;",
      "ja": "if（！context ||！Message_Digest）return shaNull;"
    },
    {
      "indent": 2,
      "text": "if (context->Corrupted) return context->Corrupted;",
      "ja": "if (context->Corrupted) return context->Corrupted;"
    },
    {
      "indent": 2,
      "text": "if (!context->Computed)\n  SHA384_512Finalize(context, 0x80);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#ifdef USE_32BIT_ONLY\n  for (i = i2 = 0; i < HashSize; ) {\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>24);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>16);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>8);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2++]);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>24);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>16);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>8);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2++]);\n  }\n#else /* !USE_32BIT_ONLY */\n  for (i = 0; i < HashSize; ++i)\n    Message_Digest[i] = (uint8_t)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "      (context->Intermediate_Hash[i>>3] >> 8 * ( 7 - ( i % 8 ) ));\n#endif /* USE_32BIT_ONLY */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return shaSuccess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2.4. usha.c",
      "section_title": true,
      "ja": "8.2.4. usha.c"
    },
    {
      "indent": 0,
      "text": "/**************************** usha.c ****************************/\n/******************** See RFC 4634 for details ******************/\n/*\n *  Description:\n *     This file implements a unified interface to the SHA algorithms.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\"",
      "ja": "#include \"sha.h\""
    },
    {
      "indent": 0,
      "text": "/*\n *  USHAReset\n *\n *  Description:\n *      This function will initialize the SHA Context in preparation\n *      for computing a new SHA message digest.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *      whichSha: [in]\n *          Selects which SHA reset to call\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint USHAReset(USHAContext *ctx, enum SHAversion whichSha)\n{\n  if (ctx) {\n    ctx->whichSha = whichSha;\n    switch (whichSha) {\n      case SHA1:   return SHA1Reset((SHA1Context*)&ctx->ctx);\n      case SHA224: return SHA224Reset((SHA224Context*)&ctx->ctx);\n      case SHA256: return SHA256Reset((SHA256Context*)&ctx->ctx);\n      case SHA384: return SHA384Reset((SHA384Context*)&ctx->ctx);\n      case SHA512: return SHA512Reset((SHA512Context*)&ctx->ctx);\n      default: return shaBadParam;\n    }\n  } else {\n    return shaNull;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  USHAInput\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n *      context: [in/out]\n *          The SHA context to update\n *      message_array: [in]\n *          An array of characters representing the next portion of\n *          the message.\n *      length: [in]\n *          The length of the message in message_array\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint USHAInput(USHAContext *ctx,\n              const uint8_t *bytes, unsigned int bytecount)\n{\n  if (ctx) {\n    switch (ctx->whichSha) {\n      case SHA1:\n        return SHA1Input((SHA1Context*)&ctx->ctx, bytes, bytecount);\n      case SHA224:\n        return SHA224Input((SHA224Context*)&ctx->ctx, bytes,\n            bytecount);\n      case SHA256:\n        return SHA256Input((SHA256Context*)&ctx->ctx, bytes,\n            bytecount);\n      case SHA384:\n        return SHA384Input((SHA384Context*)&ctx->ctx, bytes,\n            bytecount);\n      case SHA512:\n        return SHA512Input((SHA512Context*)&ctx->ctx, bytes,\n            bytecount);\n      default: return shaBadParam;\n    }\n  } else {\n    return shaNull;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * USHAFinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to update\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint USHAFinalBits(USHAContext *ctx,\n                  const uint8_t bits, unsigned int bitcount)\n{\n  if (ctx) {\n    switch (ctx->whichSha) {\n      case SHA1:\n        return SHA1FinalBits((SHA1Context*)&ctx->ctx, bits, bitcount);\n      case SHA224:\n        return SHA224FinalBits((SHA224Context*)&ctx->ctx, bits,\n            bitcount);\n      case SHA256:\n        return SHA256FinalBits((SHA256Context*)&ctx->ctx, bits,\n            bitcount);\n      case SHA384:\n        return SHA384FinalBits((SHA384Context*)&ctx->ctx, bits,\n            bitcount);\n      case SHA512:\n        return SHA512FinalBits((SHA512Context*)&ctx->ctx, bits,\n            bitcount);\n      default: return shaBadParam;\n    }\n  } else {\n    return shaNull;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * USHAResult\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " * Description:\n *   This function will return the 160-bit message digest into the\n *   Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the 19th element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the SHA-1 hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint USHAResult(USHAContext *ctx,\n               uint8_t Message_Digest[USHAMaxHashSize])\n{\n  if (ctx) {\n    switch (ctx->whichSha) {\n      case SHA1:\n        return SHA1Result((SHA1Context*)&ctx->ctx, Message_Digest);\n      case SHA224:\n        return SHA224Result((SHA224Context*)&ctx->ctx, Message_Digest);\n      case SHA256:\n        return SHA256Result((SHA256Context*)&ctx->ctx, Message_Digest);\n      case SHA384:\n        return SHA384Result((SHA384Context*)&ctx->ctx, Message_Digest);\n      case SHA512:\n        return SHA512Result((SHA512Context*)&ctx->ctx, Message_Digest);\n      default: return shaBadParam;\n    }\n  } else {\n    return shaNull;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * USHABlockSize\n *\n * Description:\n *   This function will return the blocksize for the given SHA\n *   algorithm.\n *\n * Parameters:\n *   whichSha:\n *     which SHA algorithm to query",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *\n * Returns:\n *   block size\n *\n */\nint USHABlockSize(enum SHAversion whichSha)\n{\n  switch (whichSha) {\n    case SHA1:   return SHA1_Message_Block_Size;\n    case SHA224: return SHA224_Message_Block_Size;\n    case SHA256: return SHA256_Message_Block_Size;\n    case SHA384: return SHA384_Message_Block_Size;\n    default:\n    case SHA512: return SHA512_Message_Block_Size;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * USHAHashSize\n *\n * Description:\n *   This function will return the hashsize for the given SHA\n *   algorithm.\n *\n * Parameters:\n *   whichSha:\n *     which SHA algorithm to query\n *\n * Returns:\n *   hash size\n *\n */\nint USHAHashSize(enum SHAversion whichSha)\n{\n  switch (whichSha) {\n    case SHA1:   return SHA1HashSize;\n    case SHA224: return SHA224HashSize;\n    case SHA256: return SHA256HashSize;\n    case SHA384: return SHA384HashSize;\n    default:\n    case SHA512: return SHA512HashSize;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * USHAHashSizeBits\n *\n * Description:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *   This function will return the hashsize for the given SHA\n *   algorithm, expressed in bits.\n *\n * Parameters:\n *   whichSha:\n *     which SHA algorithm to query\n *\n * Returns:\n *   hash size in bits\n *\n */\nint USHAHashSizeBits(enum SHAversion whichSha)\n{\n  switch (whichSha) {\n    case SHA1:   return SHA1HashSizeBits;\n    case SHA224: return SHA224HashSizeBits;\n    case SHA256: return SHA256HashSizeBits;\n    case SHA384: return SHA384HashSizeBits;\n    default:\n    case SHA512: return SHA512HashSizeBits;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2.5. sha-private.h",
      "section_title": true,
      "ja": "8.2.5. sha-private.h"
    },
    {
      "indent": 0,
      "text": "/*************************** sha-private.h ***************************/\n/********************** See RFC 4634 for details *********************/\n#ifndef _SHA_PRIVATE__H\n#define _SHA_PRIVATE__H\n/*\n * These definitions are defined in FIPS-180-2, section 4.1.\n * Ch() and Maj() are defined identically in sections 4.1.1,\n * 4.1.2 and 4.1.3.\n *\n * The definitions used in FIPS-180-2 are as follows:\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#ifndef USE_MODIFIED_MACROS\n#define SHA_Ch(x,y,z)        (((x) & (y)) ^ ((~(x)) & (z)))\n#define SHA_Maj(x,y,z)       (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#else /* USE_MODIFIED_MACROS */\n/*\n * The following definitions are equivalent and potentially faster.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#define SHA_Ch(x, y, z)      (((x) & ((y) ^ (z))) ^ (z))\n#define SHA_Maj(x, y, z)     (((x) & ((y) | (z))) | ((y) & (z)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#endif /* USE_MODIFIED_MACROS */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#define SHA_Parity(x, y, z)  ((x) ^ (y) ^ (z))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#endif /* _SHA_PRIVATE__H */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.3 The HMAC Code",
      "section_title": true,
      "ja": "8.3 HMACコード"
    },
    {
      "indent": 0,
      "text": "/**************************** hmac.c ****************************/\n/******************** See RFC 4634 for details ******************/\n/*\n *  Description:\n *      This file implements the HMAC algorithm (Keyed-Hashing for\n *      Message Authentication, RFC2104), expressed in terms of the\n *      various SHA algorithms.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include \"sha.h\"",
      "ja": "#include \"sha.h\""
    },
    {
      "indent": 0,
      "text": "/*\n *  hmac\n *\n *  Description:\n *      This function will compute an HMAC message digest.\n *\n *  Parameters:\n *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n *      key: [in]\n *          The secret shared key.\n *      key_len: [in]\n *          The length of the secret shared key.\n *      message_array: [in]\n *          An array of characters representing the message.\n *      length: [in]\n *          The length of the message in message_array\n *      digest: [out]\n *          Where the digest is returned.\n *          NOTE: The length of the digest is determined by\n *              the value of whichSha.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hmac(SHAversion whichSha, const unsigned char *text, int text_len,\n    const unsigned char *key, int key_len,\n    uint8_t digest[USHAMaxHashSize])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "{\n  HMACContext ctx;\n  return hmacReset(&ctx, whichSha, key, key_len) ||\n         hmacInput(&ctx, text, text_len) ||\n         hmacResult(&ctx, digest);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  hmacReset\n *\n *  Description:\n *      This function will initialize the hmacContext in preparation\n *      for computing a new HMAC message digest.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n *      key: [in]\n *          The secret shared key.\n *      key_len: [in]\n *          The length of the secret shared key.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hmacReset(HMACContext *ctx, enum SHAversion whichSha,\n    const unsigned char *key, int key_len)\n{\n  int i, blocksize, hashsize;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* inner padding - key XORd with ipad */\nunsigned char k_ipad[USHA_Max_Message_Block_Size];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* temporary buffer when keylen > blocksize */\nunsigned char tempkey[USHAMaxHashSize];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!ctx) return shaNull;",
      "ja": "if (!ctx) return shaNull;"
    },
    {
      "indent": 2,
      "text": "blocksize = ctx->blockSize = USHABlockSize(whichSha);\nhashsize = ctx->hashSize = USHAHashSize(whichSha);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "ctx->whichSha = whichSha;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/*\n * If key is longer than the hash blocksize,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": " * reset it to key = HASH(key).\n */\nif (key_len > blocksize) {\n  USHAContext tctx;\n  int err = USHAReset(&tctx, whichSha) ||\n            USHAInput(&tctx, key, key_len) ||\n            USHAResult(&tctx, tempkey);\n  if (err != shaSuccess) return err;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  key = tempkey;\n  key_len = hashsize;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/*\n * The HMAC transform looks like:\n *\n * SHA(K XOR opad, SHA(K XOR ipad, text))\n *\n * where K is an n byte key.\n * ipad is the byte 0x36 repeated blocksize times\n * opad is the byte 0x5c repeated blocksize times\n * and text is the data being protected.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* store key into the pads, XOR'd with ipad and opad values */\nfor (i = 0; i < key_len; i++) {\n  k_ipad[i] = key[i] ^ 0x36;\n  ctx->k_opad[i] = key[i] ^ 0x5c;\n}\n/* remaining pad bytes are '\\0' XOR'd with ipad and opad values */\nfor ( ; i < blocksize; i++) {\n  k_ipad[i] = 0x36;\n  ctx->k_opad[i] = 0x5c;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  /* perform inner hash */\n  /* init context for 1st pass */\n  return USHAReset(&ctx->shaContext, whichSha) ||\n         /* and start with inner pad */\n         USHAInput(&ctx->shaContext, k_ipad, blocksize);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  hmacInput\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the message.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " *\n *  Parameters:\n *      context: [in/out]\n *          The HMAC context to update\n *      message_array: [in]\n *          An array of characters representing the next portion of\n *          the message.\n *      length: [in]\n *          The length of the message in message_array\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint hmacInput(HMACContext *ctx, const unsigned char *text,\n    int text_len)\n{\n  if (!ctx) return shaNull;\n  /* then text of datagram */\n  return USHAInput(&ctx->shaContext, text, text_len);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * HMACFinalBits\n *\n * Description:\n *   This function will add in any final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n *     The HMAC context to update\n *   message_bits: [in]\n *     The final bits of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n *     The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *   sha Error Code.\n */\nint hmacFinalBits(HMACContext *ctx,\n    const uint8_t bits,\n    unsigned int bitcount)\n{\n  if (!ctx) return shaNull;\n  /* then final bits of datagram */\n  return USHAFinalBits(&ctx->shaContext, bits, bitcount);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "/*\n * HMACResult\n *\n * Description:\n *   This function will return the N-byte message digest into the\n *   Message_Digest array provided by the caller.\n *   NOTE: The first octet of hash is stored in the 0th element,\n *      the last octet of hash in the Nth element.\n *\n * Parameters:\n *   context: [in/out]\n *     The context to use to calculate the HMAC hash.\n *   digest: [out]\n *     Where the digest is returned.\n *   NOTE 2: The length of the hash is determined by the value of\n *      whichSha that was passed to hmacReset().\n *\n * Returns:\n *   sha Error Code.\n *\n */\nint hmacResult(HMACContext *ctx, uint8_t *digest)\n{\n  if (!ctx) return shaNull;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* finish up 1st pass */\n/* (Use digest here as a temporary buffer.) */\nreturn USHAResult(&ctx->shaContext, digest) ||",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "/* perform outer SHA */\n/* init context for 2nd pass */\nUSHAReset(&ctx->shaContext, ctx->whichSha) ||",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "/* start with outer pad */\nUSHAInput(&ctx->shaContext, ctx->k_opad, ctx->blockSize) ||",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "/* then results of 1st hash */\nUSHAInput(&ctx->shaContext, digest, ctx->hashSize) ||",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "         /* finish up 2nd pass */\n         USHAResult(&ctx->shaContext, digest);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.4. The Test Driver",
      "section_title": true,
      "ja": "8.4. テストドライバー"
    },
    {
      "indent": 3,
      "text": "The following code is a main program test driver to exercise the code in sha1.c, sha224-256.c, and sha384-512.c. The test driver can also be used as a stand-alone program for generating the hashes.",
      "ja": "次のコードは、sha1.c、sha224-256.c、およびsha384-512.cのコードを実行するためのメインプログラムテストドライバーです。テストドライバは、ハッシュを生成するためのスタンドアロンプ​​ログラムとしても使用できます。"
    },
    {
      "indent": 3,
      "text": "See also [RFC2202], [RFC4231], and [SHAVS].",
      "ja": "[RFC2202]、[RFC4231]、および[SHAVS]も参照してください。"
    },
    {
      "indent": 0,
      "text": "/**************************** shatest.c ****************************/\n/********************* See RFC 4634 for details ********************/\n/*\n *  Description:\n *    This file will exercise the SHA code performing\n *      the three tests documented in FIPS PUB 180-2\n *        (http://csrc.nist.gov/publications/fips/\n *         fips180-2/fips180-2withchangenotice.pdf)\n *      one that calls SHAInput with an exact multiple of 512 bits\n *      the seven tests documented for each algorithm in\n *        \"The Secure Hash Algorithm Validation System (SHAVS)\",\n *        three of which are bit-level tests\n *        (http://csrc.nist.gov/cryptval/shs/SHAVS.pdf)\n *\n *    This file will exercise the HMAC SHA1 code performing\n *      the seven tests documented in RFCs 2202 and 4231.\n *\n *    To run the tests and just see PASSED/FAILED, use the -p option.\n *\n *    Other options exercise:\n *      hashing an arbitrary string\n *      hashing a file's contents\n *      a few error test checks\n *      printing the results in raw format\n *\n *  Portability Issues:\n *    None.\n *\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"sha.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static int xgetopt(int argc, char **argv, const char *optstring);\nextern char *xoptarg;\nstatic int scasecmp(const char *s1, const char *s2);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n *  Define patterns for testing\n */\n#define TEST1    \"abc\"\n#define TEST2_1  \\\n        \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n#define TEST2_2a \\\n        \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\"\n#define TEST2_2b \\\n        \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\n#define TEST2_2  TEST2_2a TEST2_2b\n#define TEST3    \"a\"                            /* times 1000000 */\n#define TEST4a   \"01234567012345670123456701234567\"\n#define TEST4b   \"01234567012345670123456701234567\"\n    /* an exact multiple of 512 bits */\n#define TEST4   TEST4a TEST4b                   /* times 10 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#define TEST7_1 \\ \"\\x49\\xb2\\xae\\xc2\\x59\\x4b\\xbe\\x3a\\x3b\\x11\\x75\\x42\\xd9\\x4a\\xc8\" #define TEST8_1 \\ \"\\x9a\\x7d\\xfd\\xf1\\xec\\xea\\xd0\\x6e\\xd6\\x46\\xaa\\x55\\xfe\\x75\\x71\\x46\" #define TEST9_1 \\ \"\\x65\\xf9\\x32\\x99\\x5b\\xa4\\xce\\x2c\\xb1\\xb4\\xa2\\xe7\\x1a\\xe7\\x02\\x20\" \\ \"\\xaa\\xce\\xc8\\x96\\x2d\\xd4\\x49\\x9c\\xbd\\x7c\\x88\\x7a\\x94\\xea\\xaa\\x10\" \\ \"\\x1e\\xa5\\xaa\\xbc\\x52\\x9b\\x4e\\x7e\\x43\\x66\\x5a\\x5a\\xf2\\xcd\\x03\\xfe\" \\ \"\\x67\\x8e\\xa6\\xa5\\x00\\x5b\\xba\\x3b\\x08\\x22\\x04\\xc2\\x8b\\x91\\x09\\xf4\" \\ \"\\x69\\xda\\xc9\\x2a\\xaa\\xb3\\xaa\\x7c\\x11\\xa1\\xb3\\x2a\" #define TEST10_1 \\ \"\\xf7\\x8f\\x92\\x14\\x1b\\xcd\\x17\\x0a\\xe8\\x9b\\x4f\\xba\\x15\\xa1\\xd5\\x9f\" \\ \"\\x3f\\xd8\\x4d\\x22\\x3c\\x92\\x51\\xbd\\xac\\xbb\\xae\\x61\\xd0\\x5e\\xd1\\x15\" \\ \"\\xa0\\x6a\\x7c\\xe1\\x17\\xb7\\xbe\\xea\\xd2\\x44\\x21\\xde\\xd9\\xc3\\x25\\x92\" \\ \"\\xbd\\x57\\xed\\xea\\xe3\\x9c\\x39\\xfa\\x1f\\xe8\\x94\\x6a\\x84\\xd0\\xcf\\x1f\" \\ \"\\x7b\\xee\\xad\\x17\\x13\\xe2\\xe0\\x95\\x98\\x97\\x34\\x7f\\x67\\xc8\\x0b\\x04\" \\ \"\\x00\\xc2\\x09\\x81\\x5d\\x6b\\x10\\xa6\\x83\\x83\\x6f\\xd5\\x56\\x2a\\x56\\xca\" \\ \"\\xb1\\xa2\\x8e\\x81\\xb6\\x57\\x66\\x54\\x63\\x1c\\xf1\\x65\\x66\\xb8\\x6e\\x3b\" \\ \"\\x33\\xa1\\x08\\xb0\\x53\\x07\\xc0\\x0a\\xff\\x14\\xa7\\x68\\xed\\x73\\x50\\x60\" \\ \"\\x6a\\x0f\\x85\\xe6\\xa9\\x1d\\x39\\x6f\\x5b\\x5c\\xbe\\x57\\x7f\\x9b\\x38\\x80\" \\ \"\\x7c\\x7d\\x52\\x3d\\x6d\\x79\\x2f\\x6e\\xbc\\x24\\xa4\\xec\\xf2\\xb3\\xa4\\x27\" \\ \"\\xcd\\xbb\\xfb\" #define TEST7_224 \\ \"\\xf0\\x70\\x06\\xf2\\x5a\\x0b\\xea\\x68\\xcd\\x76\\xa2\\x95\\x87\\xc2\\x8d\" #define TEST8_224 \\ \"\\x18\\x80\\x40\\x05\\xdd\\x4f\\xbd\\x15\\x56\\x29\\x9d\\x6f\\x9d\\x93\\xdf\\x62\" #define TEST9_224 \\ \"\\xa2\\xbe\\x6e\\x46\\x32\\x81\\x09\\x02\\x94\\xd9\\xce\\x94\\x82\\x65\\x69\\x42\" \\ \"\\x3a\\x3a\\x30\\x5e\\xd5\\xe2\\x11\\x6c\\xd4\\xa4\\xc9\\x87\\xfc\\x06\\x57\\x00\" \\ \"\\x64\\x91\\xb1\\x49\\xcc\\xd4\\xb5\\x11\\x30\\xac\\x62\\xb1\\x9d\\xc2\\x48\\xc7\" \\ \"\\x44\\x54\\x3d\\x20\\xcd\\x39\\x52\\xdc\\xed\\x1f\\x06\\xcc\\x3b\\x18\\xb9\\x1f\" \\",
      "ja": "#define TEST7_1 \\ \"\\ x49 \\ xb2 \\ xae \\ xc2 \\ x59 \\ x4b \\ xbe \\ x3a \\ x3b \\ x11 \\ x75 \\ x42 \\ xd9 \\ x4a \\ xc8\" #define TEST8_1 \\ \"\\ x9a \\ x7d \\ xfd \\ xf1 \\ xec \\ xea \\ xd0 \\ x6e \\ xd6 \\ x46 \\ xaa \\ x55 \\ xfe \\ x75 \\ x71 \\ x46 \"#define TEST9_1 \\\" \\ x65 \\ xf9 \\ x32 \\ x99 \\ x5b \\ xa4 \\ xce \\ x2c \\ xb1 \\ xb4 \\ xa2 \\ xe7 \\ x1a \\ xe7 \\ x02 \\ x20 \"\\\" \\ xaa \\ xce \\ xc8 \\ x96 \\ x2d \\ xd4 \\ x49 \\ x9c \\ xbd \\ x7c \\ x88 \\ x7a \\ x94 \\ xea \\ xaa \\ x10 \"\\\" \\ x1e \\ xa5 \\ xaa \\ xbc \\ x52 \\ x9b \\ x4e \\ x7e \\ x43 \\ x66 \\ x5a \\ x5a \\ xf2 \\ xcd \\ x03 \\ xfe \"\\\" \\ x67 \\ x8e \\ xa6 \\ xa5 \\ x00 \\ x5b \\ xba \\ x3b \\ x08 \\ x22 \\ x04 \\ xc2 \\ x8b \\ x91 \\ x09 \\ xf4 \"\\\" \\ x69 \\ xda \\ xc9 \\ x2a \\ xaa \\ xb3 \\ xaa \\ x7c \\ x11 \\ xa1 \\ xb3 \\ x2a \"#define TEST10_1 \\\" \\ xf7 \\ x8f \\ x92 \\ x14 \\ x1b \\ xcd \\ x17 \\ x0a \\ xe8 \\ x9b \\ x4f \\ xba \\ x15 \\ xa1 \\ xd5 \\ x9f \"\\\" \\ x3f \\ xd8 \\ x4d \\ x22 \\ x3c \\ x92 \\ x51 \\ xbd \\ xac \\ xbb \\ xae \\ x61 \\ xd0 \\ x5e \\ xd1 \\ x15 \"\\\" \\ xa0 \\ x6a \\ x7c \\ xe1 \\ x17 \\ xb7 \\ xbe \\ xea \\ xd2 \\ x44 \\ x21 \\ xde \\ xd9 \\ xc3 \\ x25 \\ x92 \"\\\" \\ xbd \\ x57 \\ xed \\ xea \\ xe3 \\ x9c \\ x39 \\ xfa \\ x1f \\ xe8 \\ x94 \\ x6a \\ x84 \\ xd0 \\ xcf \\ x1f \"\\\" \\ x7b \\ xee \\ xad \\ x17 \\ x13 \\ xe2 \\ xe0 \\ x95 \\ x98 \\ x97 \\ x34 \\ x7f \\ x67 \\ xc8 \\ x0b \\ x04 \"\\\" \\ x00 \\ xc2 \\ x09 \\ x81 \\ x5d \\ x6b \\ x10 \\ xa6 \\ x83 \\ x83 \\ x6f \\ xd5 \\ x56 \\ x2a \\ x56 \\ xca \"\\\" \\ xb1 \\ xa2 \\ x8e \\ x81 \\ xb6 \\ x57 \\ x66 \\ x54 \\ x63 \\ x1c \\ xf1 \\ x65 \\ x66 \\ xb 8 \\ x6e \\ x3b \"\\\" \\ x33 \\ xa1 \\ x08 \\ xb0 \\ x53 \\ x07 \\ xc0 \\ x0a \\ xff \\ x14 \\ xa7 \\ x68 \\ xed \\ x73 \\ x50 \\ x60 \"\\\" \\ x6a \\ x0f \\ x85 \\ xe6 \\ xa9 \\ x1d \\ x39 \\ x6f \\ x5b \\ x5c \\ xbe \\ x57 \\ x7f \\ x9b \\ x38 \\ x80 \"\\\" \\ x7c \\ x7d \\ x52 \\ x3d \\ x6d \\ x79 \\ x2f \\ x6e \\ xbc \\ x24 \\ xa4 \\ xec \\ xf2 \\ xb3 \\ xa4 \\ x27 \"\\\" \\ xcd \\ xbb \\ xfb \"#define TEST7_224 \\\" \\ xf0 \\ x70 \\ x06 \\ xf2 \\ x5a \\ x0b \\ xea \\ x68 \\ xcd \\ x76 \\ xa2 \\ x95 \\ x87 \\ xc2 \\ x8d \"#define TEST8_224 \\\" \\ x18 \\ x80 \\ x40 \\ x05 \\ xdd \\ x4f \\ xbd \\ x15 \\ x56 \\ x29 \\ x9d \\ x6f \\ x9d \\ x93 \\ xdf \\ x62 \"#define TEST9_224 \\\" \\ xa2 \\ xbe \\ x6e \\ x46 \\ x32 \\ x81 \\ x09 \\ x02 \\ x94 \\ xd9 \\ xce \\ x94 \\ x82 \\ x65 \\ x69 \\ x42 \"\\\" \\ x3a \\ x3a \\ x30 \\ x5e \\ xd5 \\ xe2 \\ x11 \\ x6c \\ xd4 \\ xa4 \\ xc9 \\ x87 \\ xfc \\ x06 \\ x57 \\ x00 \"\\\" \\ x64 \\ x91 \\ xb1 \\ x49 \\ xcc \\ xd4 \\ xb5 \\ x11 \\ x30 \\ xac \\ x62 \\ xb1 \\ x9d \\ xc2 \\ x48 \\ xc7 \"\\\" \\ x44 \\ x54 \\ x3d \\ x20 \\ xcd \\ x39 \\ x52 \\ xdc \\ xed \\ x1f \\ x06 \\ xcc \\ x3b \\ x18 \\ xb9 \\ x1f \"\\"
    },
    {
      "indent": 0,
      "text": " \"\\x3f\\x55\\x63\\x3e\\xcc\\x30\\x85\\xf4\\x90\\x70\\x60\\xd2\" #define TEST10_224 \\ \"\\x55\\xb2\\x10\\x07\\x9c\\x61\\xb5\\x3a\\xdd\\x52\\x06\\x22\\xd1\\xac\\x97\\xd5\" \\ \"\\xcd\\xbe\\x8c\\xb3\\x3a\\xa0\\xae\\x34\\x45\\x17\\xbe\\xe4\\xd7\\xba\\x09\\xab\" \\ \"\\xc8\\x53\\x3c\\x52\\x50\\x88\\x7a\\x43\\xbe\\xbb\\xac\\x90\\x6c\\x2e\\x18\\x37\" \\ \"\\xf2\\x6b\\x36\\xa5\\x9a\\xe3\\xbe\\x78\\x14\\xd5\\x06\\x89\\x6b\\x71\\x8b\\x2a\" \\ \"\\x38\\x3e\\xcd\\xac\\x16\\xb9\\x61\\x25\\x55\\x3f\\x41\\x6f\\xf3\\x2c\\x66\\x74\" \\ \"\\xc7\\x45\\x99\\xa9\\x00\\x53\\x86\\xd9\\xce\\x11\\x12\\x24\\x5f\\x48\\xee\\x47\" \\ \"\\x0d\\x39\\x6c\\x1e\\xd6\\x3b\\x92\\x67\\x0c\\xa5\\x6e\\xc8\\x4d\\xee\\xa8\\x14\" \\ \"\\xb6\\x13\\x5e\\xca\\x54\\x39\\x2b\\xde\\xdb\\x94\\x89\\xbc\\x9b\\x87\\x5a\\x8b\" \\ \"\\xaf\\x0d\\xc1\\xae\\x78\\x57\\x36\\x91\\x4a\\xb7\\xda\\xa2\\x64\\xbc\\x07\\x9d\" \\ \"\\x26\\x9f\\x2c\\x0d\\x7e\\xdd\\xd8\\x10\\xa4\\x26\\x14\\x5a\\x07\\x76\\xf6\\x7c\" \\ \"\\x87\\x82\\x73\" #define TEST7_256 \\ \"\\xbe\\x27\\x46\\xc6\\xdb\\x52\\x76\\x5f\\xdb\\x2f\\x88\\x70\\x0f\\x9a\\x73\" #define TEST8_256 \\ \"\\xe3\\xd7\\x25\\x70\\xdc\\xdd\\x78\\x7c\\xe3\\x88\\x7a\\xb2\\xcd\\x68\\x46\\x52\" #define TEST9_256 \\ \"\\x3e\\x74\\x03\\x71\\xc8\\x10\\xc2\\xb9\\x9f\\xc0\\x4e\\x80\\x49\\x07\\xef\\x7c\" \\ \"\\xf2\\x6b\\xe2\\x8b\\x57\\xcb\\x58\\xa3\\xe2\\xf3\\xc0\\x07\\x16\\x6e\\x49\\xc1\" \\ \"\\x2e\\x9b\\xa3\\x4c\\x01\\x04\\x06\\x91\\x29\\xea\\x76\\x15\\x64\\x25\\x45\\x70\" \\ \"\\x3a\\x2b\\xd9\\x01\\xe1\\x6e\\xb0\\xe0\\x5d\\xeb\\xa0\\x14\\xeb\\xff\\x64\\x06\" \\ \"\\xa0\\x7d\\x54\\x36\\x4e\\xff\\x74\\x2d\\xa7\\x79\\xb0\\xb3\" #define TEST10_256 \\ \"\\x83\\x26\\x75\\x4e\\x22\\x77\\x37\\x2f\\x4f\\xc1\\x2b\\x20\\x52\\x7a\\xfe\\xf0\" \\ \"\\x4d\\x8a\\x05\\x69\\x71\\xb1\\x1a\\xd5\\x71\\x23\\xa7\\xc1\\x37\\x76\\x00\\x00\" \\ \"\\xd7\\xbe\\xf6\\xf3\\xc1\\xf7\\xa9\\x08\\x3a\\xa3\\x9d\\x81\\x0d\\xb3\\x10\\x77\" \\ \"\\x7d\\xab\\x8b\\x1e\\x7f\\x02\\xb8\\x4a\\x26\\xc7\\x73\\x32\\x5f\\x8b\\x23\\x74\" \\ \"\\xde\\x7a\\x4b\\x5a\\x58\\xcb\\x5c\\x5c\\xf3\\x5b\\xce\\xe6\\xfb\\x94\\x6e\\x5b\" \\ \"\\xd6\\x94\\xfa\\x59\\x3a\\x8b\\xeb\\x3f\\x9d\\x65\\x92\\xec\\xed\\xaa\\x66\\xca\" \\ \"\\x82\\xa2\\x9d\\x0c\\x51\\xbc\\xf9\\x33\\x62\\x30\\xe5\\xd7\\x84\\xe4\\xc0\\xa4\" \\ \"\\x3f\\x8d\\x79\\xa3\\x0a\\x16\\x5c\\xba\\xbe\\x45\\x2b\\x77\\x4b\\x9c\\x71\\x09\" \\ \"\\xa9\\x7d\\x13\\x8f\\x12\\x92\\x28\\x96\\x6f\\x6c\\x0a\\xdc\\x10\\x6a\\xad\\x5a\" \\ \"\\x9f\\xdd\\x30\\x82\\x57\\x69\\xb2\\xc6\\x71\\xaf\\x67\\x59\\xdf\\x28\\xeb\\x39\" \\ \"\\x3d\\x54\\xd6\" #define TEST7_384 \\ \"\\x8b\\xc5\\x00\\xc7\\x7c\\xee\\xd9\\x87\\x9d\\xa9\\x89\\x10\\x7c\\xe0\\xaa\" #define TEST8_384 \\ \"\\xa4\\x1c\\x49\\x77\\x79\\xc0\\x37\\x5f\\xf1\\x0a\\x7f\\x4e\\x08\\x59\\x17\\x39\" #define TEST9_384 \\ \"\\x68\\xf5\\x01\\x79\\x2d\\xea\\x97\\x96\\x76\\x70\\x22\\xd9\\x3d\\xa7\\x16\\x79\" \\ \"\\x30\\x99\\x20\\xfa\\x10\\x12\\xae\\xa3\\x57\\xb2\\xb1\\x33\\x1d\\x40\\xa1\\xd0\" \\ \"\\x3c\\x41\\xc2\\x40\\xb3\\xc9\\xa7\\x5b\\x48\\x92\\xf4\\xc0\\x72\\x4b\\x68\\xc8\" \\ \"\\x75\\x32\\x1a\\xb8\\xcf\\xe5\\x02\\x3b\\xd3\\x75\\xbc\\x0f\\x94\\xbd\\x89\\xfe\" \\ \"\\x04\\xf2\\x97\\x10\\x5d\\x7b\\x82\\xff\\xc0\\x02\\x1a\\xeb\\x1c\\xcb\\x67\\x4f\" \\ \"\\x52\\x44\\xea\\x34\\x97\\xde\\x26\\xa4\\x19\\x1c\\x5f\\x62\\xe5\\xe9\\xa2\\xd8\" \\ \"\\x08\\x2f\\x05\\x51\\xf4\\xa5\\x30\\x68\\x26\\xe9\\x1c\\xc0\\x06\\xce\\x1b\\xf6\" \\ \"\\x0f\\xf7\\x19\\xd4\\x2f\\xa5\\x21\\xc8\\x71\\xcd\\x23\\x94\\xd9\\x6e\\xf4\\x46\" \\",
      "ja": "\"\\ x3f \\ x55 \\ x63 \\ x3e \\ xcc \\ x30 \\ x85 \\ xf4 \\ x90 \\ x70 \\ x60 \\ xd2\" #define TEST10_224 \\ \"\\ x55 \\ xb2 \\ x10 \\ x07 \\ x9c \\ x61 \\ xb5 \\ x3a \\ xdd \\ x52 \\ x06 \\ x22 \\ xd1 \\ xac \\ x97 \\ xd5 \"\\\" \\ xcd \\ xbe \\ x8c \\ xb3 \\ x3a \\ xa0 \\ xae \\ x34 \\ x45 \\ x17 \\ xbe \\ xe4 \\ xd7 \\ xba \\ x09 \\ xab \"\\ \"\\ xc8 \\ x53 \\ x3c \\ x52 \\ x50 \\ x88 \\ x7a \\ x43 \\ xbe \\ xbb \\ xac \\ x90 \\ x6c \\ x2e \\ x18 \\ x37\" \\ \"\\ xf2 \\ x6b \\ x36 \\ xa5 \\ x9a \\ xe3 \\ xbe \\ x78 \\ x14 \\ xd5 \\ x06 \\ x89 \\ x6b \\ x71 \\ x8b \\ x2a \"\\\" \\ x38 \\ x3e \\ xcd \\ xac \\ x16 \\ xb9 \\ x61 \\ x25 \\ x55 \\ x3f \\ x41 \\ x6f \\ xf3 \\ x2c \\ x66 \\ x74 \"\\\" \\ xc7 \\ x45 \\ x99 \\ xa9 \\ x00 \\ x53 \\ x86 \\ xd9 \\ xce \\ x11 \\ x12 \\ x24 \\ x5f \\ x48 \\ xee \\ x47 \"\\\" \\ x0d \\ x39 \\ x6c \\ x1e \\ xd6 \\ x3b \\ x92 \\ x67 \\ x0c \\ xa5 \\ x6e \\ xc8 \\ x4d \\ xee \\ xa8 \\ x14 \"\\\" \\ xb6 \\ x13 \\ x5e \\ xca \\ x54 \\ x39 \\ x2b \\ xde \\ xdb \\ x94 \\ x89 \\ xbc \\ x9b \\ x87 \\ x5a \\ x8b \"\\\" \\ xaf \\ x0d \\ xc1 \\ xae \\ x78 \\ x57 \\ x36 \\ x91 \\ x4a \\ xb7 \\ xda \\ xa2 \\ x64 \\ xbc \\ x07 \\ x9d \"\\\" \\ x26 \\ x9f \\ x2c \\ x0d \\ x7e \\ xdd \\ xd8 \\ x10 \\ xa4 \\ x26 \\ x14 \\ x5a \\ x07 \\ x76 \\ xf6 \\ x7c \"\\\" \\ x87 \\ x82 \\ x73 \"#define TEST7_256 \\\" \\ xbe \\ x27 \\ x46 \\ xc6 \\ xdb \\ x52 \\ x76 \\ x5f \\ xdb \\ x2f \\ x88 \\ x70 \\ x0f \\ x9a \\ x73 \"#define TEST8_256 \\\" \\ xe3 \\ xd7 \\ x25 \\ x70 \\ xdc \\ xdd \\ x78 \\ x7c \\ xe3 \\ x88 \\ x7a \\ xb2 \\ xcd \\ x68 \\ x46 \\ x52 \"#define TEST9_256 \\\" \\ x3e \\ x74 \\ x03 \\ x71 \\ xc8 \\ x10 \\ xc2 \\ xb9 \\ x9f \\ xc0 \\ x4e \\ x80 \\ x49 \\ x07 \\ xef \\ x7c \"\\\" \\ xf2 \\ x6b \\ xe2 \\ x8b \\ x57 \\ xcb \\ x58 \\ xa3 \\ xe2 \\ xf3 \\ xc0 \\ x07 \\ x16 \\ x6e \\ x49 \\ xc1 \"\\\" \\ x2e \\ x9b \\ xa3 \\ x4c \\ x01 \\ x04 \\ x06 \\ x91 \\ x29 \\ xea \\ x76 \\ x15 \\ x64 \\ x25 \\ x45 \\ x70 \"\\\" \\ x3a \\ x2b \\ xd9 \\ x01 \\ xe1 \\ x6e \\ xb0 \\ xe0 \\ x5d \\ xeb \\ xa0 \\ x14 \\ xeb \\ xff \\ x64 \\ x06 \"\\\" \\ xa0 \\ x7d \\ x54 \\ x36 \\ x4e \\ xff \\ x74 \\ x2d \\ xa7 \\ x79 \\ xb0 \\ xb3 \"＃ TEST10_256 \\ \"\\ x83 \\ x26 \\ x75 \\ x4e \\ x22 \\ x77 \\ x37 \\ x2f \\ x4f \\ xc1 \\ x2b \\ x20 \\ x52 \\ x7a \\ xfe \\ xf0\" \\ \"\\ x4d \\ x8a \\ x05 \\ x69 \\ x71 \\ xb1 \\ x1a \\ xd5 \\ x71 \\ x23 \\ xa7 \\ xc1 \\ x37 \\ x76 \\ x00 \\ x00 \"\\\" \\ xd7 \\ xbe \\ xf6 \\ xf3 \\ xc1 \\ xf7 \\ xa9 \\ x08 \\ x3a \\ xa3 \\ x9d \\ x81 \\ x0d \\ xb3 \\ x10 \\ x77 \"\\\" \\ x7d \\ xab \\ x8b \\ x1e \\ x7f \\ x02 \\ xb8 \\ x4a \\ x26 \\ xc7 \\ x73 \\ x32 \\ x5f \\ x8b \\ x23 \\ x74 \"\\\" \\ xde \\ x7a \\ x4b \\ x5a \\ x58 \\ xcb \\ x5c \\ x5c \\ xf3 \\ x5b \\ xce \\ xe6 \\ xfb \\ x94 \\ x6e \\ x5b \"\\\" \\ xd6 \\ x94 \\ xfa \\ x59 \\ x3a \\ x8b \\ xeb \\ x3f \\ x9d \\ x65 \\ x92 \\ xec \\ xed \\ xaa \\ x66 \\ xca \"\\\" \\ x82 \\ xa2 \\ x9d \\ x0c \\ x51 \\ xbc \\ xf9 \\ x33 \\ x62 \\ x30 \\ xe5 \\ xd7 \\ x84 \\ xe4 \\ xc0 \\ xa4 \"\\\" \\ x3f \\ x8d \\ x79 \\ xa3 \\ x0a \\ x16 \\ x5c \\ xba \\ xbe \\ x45 \\ x2b \\ x77 \\ x4b \\ x9c \\ x71 \\ x09 \"\\\" \\ xa9 \\ x7d \\ x13 \\ x8f \\ x12 \\ x92 \\ x28 \\ x96 \\ x6f \\ x6c \\ x0a \\ xdc \\ x10 \\ x6a \\ xad \\ x5a \"\\\" \\ x9f \\ xdd \\ x30 \\ x82 \\ x57 \\ x69 \\ xb2 \\ xc6 \\ x71 \\ xaf \\ x67 \\ x59 \\ xdf \\ x28 \\ xeb \\ x3 9 \"\\\" \\ x3d \\ x54 \\ xd6 \"#define TEST7_384 \\\" \\ x8b \\ xc5 \\ x00 \\ xc7 \\ x7c \\ xee \\ xd9 \\ x87 \\ x9d \\ xa9 \\ x89 \\ x10 \\ x7c \\ xe0 \\ xaa \"#define TEST8_384 \\ \"\\ xa4 \\ x1c \\ x49 \\ x77 \\ x79 \\ xc0 \\ x37 \\ x5f \\ xf1 \\ x0a \\ x7f \\ x4e \\ x08 \\ x59 \\ x17 \\ x39\" #define TEST9_384 \\ \"\\ x68 \\ xf5 \\ x01 \\ x79 \\ x2d \\ xea \\ x97 \\ x96 \\ x76 \\ x70 \\ x22 \\ xd9 \\ x3d \\ xa7 \\ x16 \\ x79 \"\\\" \\ x30 \\ x99 \\ x20 \\ xfa \\ x10 \\ x12 \\ xae \\ xa3 \\ x57 \\ xb2 \\ xb1 \\ x33 \\ x1d \\ x40 \\ xa1 \\ xd0 \"\\\" \\ x3c \\ x41 \\ xc2 \\ x40 \\ xb3 \\ xc9 \\ xa7 \\ x5b \\ x48 \\ x92 \\ xf4 \\ xc0 \\ x72 \\ x4b \\ x68 \\ xc8 \"\\\" \\ x75 \\ x32 \\ x1a \\ xb8 \\ xcf \\ xe5 \\ x02 \\ x3b \\ xd3 \\ x75 \\ xbc \\ x0f \\ x94 \\ xbd \\ x89 \\ xfe \"\\\" \\ x04 \\ xf2 \\ x97 \\ x10 \\ x5d \\ x7b \\ x82 \\ xff \\ xc0 \\ x02 \\ x1a \\ xeb \\ x1c \\ xcb \\ x67 \\ x4f \"\\\" \\ x52 \\ x44 \\ xea \\ x34 \\ x97 \\ xde \\ x26 \\ xa4 \\ x19 \\ x1c \\ x5f \\ x62 \\ xe5 \\ xe9 \\ xa2 \\ xd8 \"\\\" \\ x08 \\ x2f \\ x05 \\ x51 \\ xf4 \\ xa5 \\ x30 \\ x68 \\ x26 \\ xe9 \\ x1c \\ xc0 \\ x06 \\ xce \\ x1b \\ xf6 \"\\\" \\ x0f \\ xf7 \\ x19 \\ xd4 \\ x2f \\ xa5 \\ x21 \\ xc8 \\ x71 \\ xcd \\ x23 \\ x94 \\ xd9 \\ x6e \\ xf4 \\ x46 \"\\"
    },
    {
      "indent": 0,
      "text": " \"\\x8f\\x21\\x96\\x6b\\x41\\xf2\\xba\\x80\\xc2\\x6e\\x83\\xa9\" #define TEST10_384 \\ \"\\x39\\x96\\x69\\xe2\\x8f\\x6b\\x9c\\x6d\\xbc\\xbb\\x69\\x12\\xec\\x10\\xff\\xcf\" \\ \"\\x74\\x79\\x03\\x49\\xb7\\xdc\\x8f\\xbe\\x4a\\x8e\\x7b\\x3b\\x56\\x21\\xdb\\x0f\" \\ \"\\x3e\\x7d\\xc8\\x7f\\x82\\x32\\x64\\xbb\\xe4\\x0d\\x18\\x11\\xc9\\xea\\x20\\x61\" \\ \"\\xe1\\xc8\\x4a\\xd1\\x0a\\x23\\xfa\\xc1\\x72\\x7e\\x72\\x02\\xfc\\x3f\\x50\\x42\" \\ \"\\xe6\\xbf\\x58\\xcb\\xa8\\xa2\\x74\\x6e\\x1f\\x64\\xf9\\xb9\\xea\\x35\\x2c\\x71\" \\ \"\\x15\\x07\\x05\\x3c\\xf4\\xe5\\x33\\x9d\\x52\\x86\\x5f\\x25\\xcc\\x22\\xb5\\xe8\" \\ \"\\x77\\x84\\xa1\\x2f\\xc9\\x61\\xd6\\x6c\\xb6\\xe8\\x95\\x73\\x19\\x9a\\x2c\\xe6\" \\ \"\\x56\\x5c\\xbd\\xf1\\x3d\\xca\\x40\\x38\\x32\\xcf\\xcb\\x0e\\x8b\\x72\\x11\\xe8\" \\ \"\\x3a\\xf3\\x2a\\x11\\xac\\x17\\x92\\x9f\\xf1\\xc0\\x73\\xa5\\x1c\\xc0\\x27\\xaa\" \\ \"\\xed\\xef\\xf8\\x5a\\xad\\x7c\\x2b\\x7c\\x5a\\x80\\x3e\\x24\\x04\\xd9\\x6d\\x2a\" \\ \"\\x77\\x35\\x7b\\xda\\x1a\\x6d\\xae\\xed\\x17\\x15\\x1c\\xb9\\xbc\\x51\\x25\\xa4\" \\ \"\\x22\\xe9\\x41\\xde\\x0c\\xa0\\xfc\\x50\\x11\\xc2\\x3e\\xcf\\xfe\\xfd\\xd0\\x96\" \\ \"\\x76\\x71\\x1c\\xf3\\xdb\\x0a\\x34\\x40\\x72\\x0e\\x16\\x15\\xc1\\xf2\\x2f\\xbc\" \\ \"\\x3c\\x72\\x1d\\xe5\\x21\\xe1\\xb9\\x9b\\xa1\\xbd\\x55\\x77\\x40\\x86\\x42\\x14\" \\ \"\\x7e\\xd0\\x96\" #define TEST7_512 \\ \"\\x08\\xec\\xb5\\x2e\\xba\\xe1\\xf7\\x42\\x2d\\xb6\\x2b\\xcd\\x54\\x26\\x70\" #define TEST8_512 \\ \"\\x8d\\x4e\\x3c\\x0e\\x38\\x89\\x19\\x14\\x91\\x81\\x6e\\x9d\\x98\\xbf\\xf0\\xa0\" #define TEST9_512 \\ \"\\x3a\\xdd\\xec\\x85\\x59\\x32\\x16\\xd1\\x61\\x9a\\xa0\\x2d\\x97\\x56\\x97\\x0b\" \\ \"\\xfc\\x70\\xac\\xe2\\x74\\x4f\\x7c\\x6b\\x27\\x88\\x15\\x10\\x28\\xf7\\xb6\\xa2\" \\ \"\\x55\\x0f\\xd7\\x4a\\x7e\\x6e\\x69\\xc2\\xc9\\xb4\\x5f\\xc4\\x54\\x96\\x6d\\xc3\" \\ \"\\x1d\\x2e\\x10\\xda\\x1f\\x95\\xce\\x02\\xbe\\xb4\\xbf\\x87\\x65\\x57\\x4c\\xbd\" \\ \"\\x6e\\x83\\x37\\xef\\x42\\x0a\\xdc\\x98\\xc1\\x5c\\xb6\\xd5\\xe4\\xa0\\x24\\x1b\" \\ \"\\xa0\\x04\\x6d\\x25\\x0e\\x51\\x02\\x31\\xca\\xc2\\x04\\x6c\\x99\\x16\\x06\\xab\" \\ \"\\x4e\\xe4\\x14\\x5b\\xee\\x2f\\xf4\\xbb\\x12\\x3a\\xab\\x49\\x8d\\x9d\\x44\\x79\" \\ \"\\x4f\\x99\\xcc\\xad\\x89\\xa9\\xa1\\x62\\x12\\x59\\xed\\xa7\\x0a\\x5b\\x6d\\xd4\" \\ \"\\xbd\\xd8\\x77\\x78\\xc9\\x04\\x3b\\x93\\x84\\xf5\\x49\\x06\" #define TEST10_512 \\ \"\\xa5\\x5f\\x20\\xc4\\x11\\xaa\\xd1\\x32\\x80\\x7a\\x50\\x2d\\x65\\x82\\x4e\\x31\" \\ \"\\xa2\\x30\\x54\\x32\\xaa\\x3d\\x06\\xd3\\xe2\\x82\\xa8\\xd8\\x4e\\x0d\\xe1\\xde\" \\ \"\\x69\\x74\\xbf\\x49\\x54\\x69\\xfc\\x7f\\x33\\x8f\\x80\\x54\\xd5\\x8c\\x26\\xc4\" \\ \"\\x93\\x60\\xc3\\xe8\\x7a\\xf5\\x65\\x23\\xac\\xf6\\xd8\\x9d\\x03\\xe5\\x6f\\xf2\" \\ \"\\xf8\\x68\\x00\\x2b\\xc3\\xe4\\x31\\xed\\xc4\\x4d\\xf2\\xf0\\x22\\x3d\\x4b\\xb3\" \\ \"\\xb2\\x43\\x58\\x6e\\x1a\\x7d\\x92\\x49\\x36\\x69\\x4f\\xcb\\xba\\xf8\\x8d\\x95\" \\ \"\\x19\\xe4\\xeb\\x50\\xa6\\x44\\xf8\\xe4\\xf9\\x5e\\xb0\\xea\\x95\\xbc\\x44\\x65\" \\ \"\\xc8\\x82\\x1a\\xac\\xd2\\xfe\\x15\\xab\\x49\\x81\\x16\\x4b\\xbb\\x6d\\xc3\\x2f\" \\ \"\\x96\\x90\\x87\\xa1\\x45\\xb0\\xd9\\xcc\\x9c\\x67\\xc2\\x2b\\x76\\x32\\x99\\x41\" \\ \"\\x9c\\xc4\\x12\\x8b\\xe9\\xa0\\x77\\xb3\\xac\\xe6\\x34\\x06\\x4e\\x6d\\x99\\x28\" \\ \"\\x35\\x13\\xdc\\x06\\xe7\\x51\\x5d\\x0d\\x73\\x13\\x2e\\x9a\\x0d\\xc6\\xd3\\xb1\" \\ \"\\xf8\\xb2\\x46\\xf1\\xa9\\x8a\\x3f\\xc7\\x29\\x41\\xb1\\xe3\\xbb\\x20\\x98\\xe8\" \\ \"\\xbf\\x16\\xf2\\x68\\xd6\\x4f\\x0b\\x0f\\x47\\x07\\xfe\\x1e\\xa1\\xa1\\x79\\x1b\" \\ \"\\xa2\\xf3\\xc0\\xc7\\x58\\xe5\\xf5\\x51\\x86\\x3a\\x96\\xc9\\x49\\xad\\x47\\xd7\" \\ \"\\xfb\\x40\\xd2\" #define SHA1_SEED \"\\xd0\\x56\\x9c\\xb3\\x66\\x5a\\x8a\\x43\\xeb\\x6e\\xa2\\x3d\" \\",
      "ja": "\"\\ x8f \\ x21 \\ x96 \\ x6b \\ x41 \\ xf2 \\ xba \\ x80 \\ xc2 \\ x6e \\ x83 \\ xa9\" #define TEST10_384 \\ \"\\ x39 \\ x96 \\ x69 \\ xe2 \\ x8f \\ x6b \\ x9c \\ x6d \\ xbc \\ xbb \\ x69 \\ x12 \\ xec \\ x10 \\ xff \\ xcf \"\\\" \\ x74 \\ x79 \\ x03 \\ x49 \\ xb7 \\ xdc \\ x8f \\ xbe \\ x4a \\ x8e \\ x7b \\ x3b \\ x56 \\ x21 \\ xdb \\ x0f \"\\ \"\\ x3e \\ x7d \\ xc8 \\ x7f \\ x82 \\ x32 \\ x64 \\ xbb \\ xe4 \\ x0d \\ x18 \\ x11 \\ xc9 \\ xea \\ x20 \\ x61\" \\ \"\\ xe1 \\ xc8 \\ x4a \\ xd1 \\ x0a \\ x23 \\ xfa \\ xc1 \\ x72 \\ x7e \\ x72 \\ x02 \\ xfc \\ x3f \\ x50 \\ x42 \"\\\" \\ xe6 \\ xbf \\ x58 \\ xcb \\ xa8 \\ xa2 \\ x74 \\ x6e \\ x1f \\ x64 \\ xf9 \\ xb9 \\ xea \\ x35 \\ x2c \\ x71 \"\\\" \\ x15 \\ x07 \\ x05 \\ x3c \\ xf4 \\ xe5 \\ x33 \\ x9d \\ x52 \\ x86 \\ x5f \\ x25 \\ xcc \\ x22 \\ xb5 \\ xe8 \"\\\" \\ x77 \\ x84 \\ xa1 \\ x2f \\ xc9 \\ x61 \\ xd6 \\ x6c \\ xb6 \\ xe8 \\ x95 \\ x73 \\ x19 \\ x9a \\ x2c \\ xe6 \"\\\" \\ x56 \\ x5c \\ xbd \\ xf1 \\ x3d \\ xca \\ x40 \\ x38 \\ x32 \\ xcf \\ xcb \\ x0e \\ x8b \\ x72 \\ x11 \\ xe8 \"\\\" \\ x3a \\ xf3 \\ x2a \\ x11 \\ xac \\ x17 \\ x92 \\ x9f \\ xf1 \\ xc0 \\ x73 \\ xa5 \\ x1c \\ xc0 \\ x27 \\ xaa \"\\\" \\ xed \\ xef \\ xf8 \\ x5a \\ xad \\ x7c \\ x2b \\ x7c \\ x5a \\ x80 \\ x3e \\ x24 \\ x04 \\ xd9 \\ x6d \\ x2a \"\\\" \\ x77 \\ x35 \\ x7b \\ xda \\ x1a \\ x6d \\ xae \\ xed \\ x17 \\ x15 \\ x1c \\ xb9 \\ xbc \\ x51 \\ x25 \\ xa4 \"\\\" \\ x22 \\ xe9 \\ x41 \\ xde \\ x0c \\ xa0 \\ xfc \\ x50 \\ x11 \\ xc2 \\ x3e \\ xcf \\ xfe \\ xfd \\ xd0 \\ x96 \"\\ \"\\ x76 \\ x71 \\ x1c \\ xf3 \\ xdb \\ x0a \\ x34 \\ x40 \\ x72 \\ x0e \\ x16 \\ x15 \\ xc1 \\ xf2 \\ x2f \\ xbc\" \\ \"\\ x3c \\ x72 \\ x1d \\ xe5 \\ x21 \\ xe1 \\ xb9 \\バツ9b \\ xa1 \\ xbd \\ x55 \\ x77 \\ x40 \\ x86 \\ x42 \\ x14 \"\\\" \\ x7e \\ xd0 \\ x96 \"#define TEST7_512 \\\" \\ x08 \\ xec \\ xb5 \\ x2e \\ xba \\ xe1 \\ xf7 \\ x42 \\ x2d \\ xb6 \\ x2b \\ xcd \\ x54 \\ x26 \\ x70 \"#define TEST8_512 \\\" \\ x8d \\ x4e \\ x3c \\ x0e \\ x38 \\ x89 \\ x19 \\ x14 \\ x91 \\ x81 \\ x6e \\ x9d \\ x98 \\ xbf \\ xf0 \\ xa0 \"#define TEST9_512 \\\" \\ x3a \\ xdd \\ xec \\ x85 \\ x59 \\ x32 \\ x16 \\ xd1 \\ x61 \\ x9a \\ xa0 \\ x2d \\ x97 \\ x56 \\ x97 \\ x0b \"\\\" \\ xfc \\ x70 \\ xac \\ xe2 \\ x74 \\ x4f \\ x7c \\ x6b \\ x27 \\ x88 \\ x15 \\ x10 \\ x28 \\ xf7 \\ xb6 \\ xa2 \"\\\" \\ x55 \\ x0f \\ xd7 \\ x4a \\ x7e \\ x6e \\ x69 \\ xc2 \\ xc9 \\ xb4 \\ x5f \\ xc4 \\ x54 \\ x96 \\ x6d \\ xc3 \"\\\" \\ x1d \\ x2e \\ x10 \\ xda \\ x1f \\ x95 \\ xce \\ x02 \\ xbe \\ xb4 \\ xbf \\ x87 \\ x65 \\ x57 \\ x4c \\ xbd \"\\\" \\ x6e \\ x83 \\ x37 \\ xef \\ x42 \\ x0a \\ xdc \\ x98 \\ xc1 \\ x5c \\ xb6 \\ xd5 \\ xe4 \\ xa0 \\ x24 \\ x1b \"\\\" \\ xa0 \\ x04 \\ x6d \\ x25 \\ x0e \\ x51 \\ x02 \\ x31 \\ xca \\ xc2 \\ x04 \\ x6c \\ x99 \\ x16 \\ x06 \\ xab \"\\\" \\ x4e \\ xe4 \\ x14 \\ x5b \\ xee \\ x2f \\ xf4 \\ xbb \\ x12 \\ x3a \\ xab \\ x49 \\ x8d \\ x9d \\ x44 \\ x79 \"\\ \"\\ x4f \\ x99 \\ xcc \\ xad \\ x89 \\ xa9 \\ xa1 \\ x62 \\ x12 \\ x59 \\ xed \\ xa7 \\ x0a \\ x5b \\ x6d \\ xd4\" \\ \"\\ xbd \\ xd8 \\ x77 \\ x78 \\ xc9 \\ x04 \\ x3b \\ x93 \\ x84 \\ xf5 \\ x49 \\ x06 \"#define TEST10_512 \\\" \\ xa5 \\ x5f \\ x20 \\ xc4 \\ x11 \\ xaa \\ xd1 \\ x32 \\ x80 \\ x7a \\ x50 \\ x2d \\ x65 \\ x82 \\ x4e \\ x31 \"\\ 「\\ xa2 \\ x30 \\ x54 \\ x32 \\ xaa \\ x3d \\ x06 \\ xd3 \\ xe2 \\ x82 \\ xa8 \\ xd8 \\ x4e \\ x0d \\ xe1 \\ xd e \"\\\" \\ x69 \\ x74 \\ xbf \\ x49 \\ x54 \\ x69 \\ xfc \\ x7f \\ x33 \\ x8f \\ x80 \\ x54 \\ xd5 \\ x8c \\ x26 \\ xc4 \"\\\" \\ x93 \\ x60 \\ xc3 \\ xe8 \\ x7a \\ xf5 \\ x65 \\ x23 \\ xac \\ xf6 \\ xd8 \\ x9d \\ x03 \\ xe5 \\ x6f \\ xf2 \"\\\" \\ xf8 \\ x68 \\ x00 \\ x2b \\ xc3 \\ xe4 \\ x31 \\ xed \\ xc4 \\ x4d \\ xf2 \\ xf0 \\ x22 \\ x3d \\ x4b \\ xb3 \"\\\" \\ xb2 \\ x43 \\ x58 \\ x6e \\ x1a \\ x7d \\ x92 \\ x49 \\ x36 \\ x69 \\ x4f \\ xcb \\ xba \\ xf8 \\ x8d \\ x95 \"\\\" \\ x19 \\ xe4 \\ xeb \\ x50 \\ xa6 \\ x44 \\ xf8 \\ xe4 \\ xf9 \\ x5e \\ xb0 \\ xea \\ x95 \\ xbc \\ x44 \\ x65 \"\\\" \\ xc8 \\ x82 \\ x1a \\ xac \\ xd2 \\ xfe \\ x15 \\ xab \\ x49 \\ x81 \\ x16 \\ x4b \\ xbb \\ x6d \\ xc3 \\ x2f \"\\\" \\ x96 \\ x90 \\ x87 \\ xa1 \\ x45 \\ xb0 \\ xd9 \\ xcc \\ x9c \\ x67 \\ xc2 \\ x2b \\ x76 \\ x32 \\ x99 \\ x41 \"\\\" \\ x9c \\ xc4 \\ x12 \\ x8b \\ xe9 \\ xa0 \\ x77 \\ xb3 \\ xac \\ xe6 \\ x34 \\ x06 \\ x4e \\ x6d \\ x99 \\ x28 \"\\\" \\ x35 \\ x13 \\ xdc \\ x06 \\ xe7 \\ x51 \\ x5d \\ x0d \\ x73 \\ x13 \\ x2e \\ x9a \\ x0d \\ xc6 \\ xd3 \\ xb1 \"\\\" \\ xf8 \\ xb2 \\ x46 \\ xf1 \\ xa9 \\ x8a \\ x3f \\ xc7 \\ x29 \\ x41 \\ xb1 \\ xe3 \\ xbb \\ x20 \\ x98 \\ xe8 \"\\\" \\ xbf \\ x16 \\ xf2 \\ x68 \\ xd6 \\ x4f \\ x0b \\ x0f \\ x47 \\ x07 \\ xfe \\ x1e \\ xa1 \\ xa1 \\ x79 \\ x1b \"\\\" \\ xa2 \\ xf3 \\ xc0 \\ xc7 \\ x58 \\ xe5 \\ xf5 \\ x51 \\ x86 \\ x3a \\ x96 \\ xc9 \\ x49 \\ xad \\ x47 \\ xd7 \"\\\" \\ xfb \\ x40 \\ xd2 \"#define SHA1_SEED\" \\ xd0 \\ x56 \\ x9c \\ xb3 \\ x66 \\ x5a \\ x8a \\ x43 \\ xeb \\ x6e \\ xa2 \\ x3d \"\\"
    },
    {
      "indent": 0,
      "text": " \"\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\" #define SHA224_SEED \"\\xd0\\x56\\x9c\\xb3\\x66\\x5a\\x8a\\x43\\xeb\\x6e\\xa2\" \\ \"\\x3d\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\\x66\\xa9\\xca\\x99\\xc9\\xce\\xb0\" \\ \"\\x27\" #define SHA256_SEED \"\\xf4\\x1e\\xce\\x26\\x13\\xe4\\x57\\x39\\x15\\x69\\x6b\" \\ \"\\x5a\\xdc\\xd5\\x1c\\xa3\\x28\\xbe\\x3b\\xf5\\x66\\xa9\\xca\\x99\\xc9\\xce\\xb0\" \\ \"\\x27\\x9c\\x1c\\xb0\\xa7\" #define SHA384_SEED \"\\x82\\x40\\xbc\\x51\\xe4\\xec\\x7e\\xf7\\x6d\\x18\\xe3\" \\ \"\\x52\\x04\\xa1\\x9f\\x51\\xa5\\x21\\x3a\\x73\\xa8\\x1d\\x6f\\x94\\x46\\x80\\xd3\" \\ \"\\x07\\x59\\x48\\xb7\\xe4\\x63\\x80\\x4e\\xa3\\xd2\\x6e\\x13\\xea\\x82\\x0d\\x65\" \\ \"\\xa4\\x84\\xbe\\x74\\x53\" #define SHA512_SEED \"\\x47\\x3f\\xf1\\xb9\\xb3\\xff\\xdf\\xa1\\x26\\x69\\x9a\" \\ \"\\xc7\\xef\\x9e\\x8e\\x78\\x77\\x73\\x09\\x58\\x24\\xc6\\x42\\x55\\x7c\\x13\\x99\" \\ \"\\xd9\\x8e\\x42\\x20\\x44\\x8d\\xc3\\x5b\\x99\\xbf\\xdd\\x44\\x77\\x95\\x43\\x92\" \\ \"\\x4c\\x1c\\xe9\\x3b\\xc5\\x94\\x15\\x38\\x89\\x5d\\xb9\\x88\\x26\\x1b\\x00\\x77\" \\ \"\\x4b\\x12\\x27\\x20\\x39\"",
      "ja": " \"\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\" #define SHA224_SEED \"\\xd0\\x56\\x9c\\xb3\\x66\\x5a\\x8a\\x43\\xeb\\x6e\\xa2\" \\ \"\\x3d\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\\x66\\xa9\\xca\\x99\\xc9\\xce\\xb0\" \\ \"\\x27\" #define SHA256_SEED \"\\xf4\\x1e\\xce\\x26\\x13\\xe4\\x57\\x39\\x15\\x69\\x6b\" \\ \"\\x5a\\xdc\\xd5\\x1c\\xa3\\x28\\xbe\\x3b\\xf5\\x66\\xa9\\xca\\x99\\xc9\\xce\\xb0\" \\ \"\\x27\\x9c\\x1c\\xb0\\xa7\" #define SHA384_SEED \"\\x82\\x40\\xbc\\x51\\xe4\\xec\\x7e\\xf7\\x6d\\x18\\xe3\" \\ \"\\x52\\x04\\xa1\\x9f\\x51\\xa5\\x21\\x3a\\x73\\xa8\\x1d\\x6f\\x94\\x46\\x80\\xd3\" \\ \"\\x07\\x59\\x48\\xb7\\xe4\\x63\\x80\\x4e\\xa3\\xd2\\x6e\\x13\\xea\\x82\\x0d\\x65\" \\ \"\\xa4\\x84\\xbe\\x74\\x53\" #define SHA512_SEED \"\\x47\\x3f\\xf1\\xb9\\xb3\\xff\\xdf\\xa1\\x26\\x69\\x9a\" \\ \"\\xc7\\xef\\x9e\\x8e\\x78\\x77\\x73\\x09\\x58\\x24\\xc6\\x42\\x55\\x7c\\x13\\x99\" \\ \"\\xd9\\x8e\\x42\\x20\\x44\\x8d\\xc3\\x5b\\x99\\xbf\\xdd\\x44\\x77\\x95\\x43\\x92\" \\ \"\\x4c\\x1c\\xe9\\x3b\\xc5\\x94\\x15\\x38\\x89\\x5d\\xb9\\x88\\x26\\x1b\\x00\\x77\" \\ \"\\x4b\\x12\\x27\\x20\\x39\""
    },
    {
      "indent": 0,
      "text": "#define TESTCOUNT 10 #define HASHCOUNT 5 #define RANDOMCOUNT 4 #define HMACTESTCOUNT 7",
      "ja": "#define TESTCOUNT 10 #define HASHCOUNT 5 #define RANDOMCOUNT 4 #define HMACTESTCOUNT 7"
    },
    {
      "indent": 0,
      "text": "#define PRINTNONE 0 #define PRINTTEXT 1 #define PRINTRAW 2 #define PRINTHEX 3 #define PRINTBASE64 4",
      "ja": "#define PRINTNONE 0 #define PRINTTEXT 1 #define PRINTRAW 2 #define PRINTHEX 3 #define PRINTBASE64 4"
    },
    {
      "indent": 0,
      "text": "#define PRINTPASSFAIL 1 #define PRINTFAIL 2",
      "ja": "#define PRINTPASSFAIL 1 #define PRINTFAIL 2"
    },
    {
      "indent": 0,
      "text": "#define length(x) (sizeof(x)-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Test arrays for hashes. */\nstruct hash {\n    const char *name;\n    SHAversion whichSha;\n    int hashsize;\n    struct {\n        const char *testarray;\n        int length;\n        long repeatcount;\n        int extrabits;\n        int numberExtrabits;\n        const char *resultarray;\n    } tests[TESTCOUNT];\n    const char *randomtest;\n    const char *randomresults[RANDOMCOUNT];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "} hashes[HASHCOUNT] = {\n  { \"SHA1\", SHA1, SHA1HashSize,\n    {\n      /* 1 */ { TEST1, length(TEST1), 1, 0, 0,\n        \"A9993E364706816ABA3E25717850C26C9CD0D89D\" },\n      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,\n        \"84983E441C3BD26EBAAE4AA1F95129E5E54670F1\" },\n      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n        \"34AA973CD4C4DAA4F61EEB2BDBAD27316534016F\" },\n      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n        \"DEA356A2CDDD90C7A7ECEDC5EBB563934F460452\" },\n      /* 5 */ { \"\", 0, 0, 0x98, 5,\n        \"29826B003B906E660EFF4027CE98AF3531AC75BA\" },\n      /* 6 */ { \"\\x5e\", 1, 1, 0, 0,\n        \"5E6F80A34A9798CAFC6A5DB96CC57BA4C4DB59C2\" },\n      /* 7 */ { TEST7_1, length(TEST7_1), 1, 0x80, 3,\n        \"6239781E03729919C01955B3FFA8ACB60B988340\" },\n      /* 8 */ { TEST8_1, length(TEST8_1), 1, 0, 0,\n        \"82ABFF6605DBE1C17DEF12A394FA22A82B544A35\" },\n      /* 9 */ { TEST9_1, length(TEST9_1), 1, 0xE0, 3,\n        \"8C5B2A5DDAE5A97FC7F9D85661C672ADBF7933D4\" },\n      /* 10 */ { TEST10_1, length(TEST10_1), 1, 0, 0,\n        \"CB0082C8F197D260991BA6A460E76E202BAD27B3\" }\n    }, SHA1_SEED, { \"E216836819477C7F78E0D843FE4FF1B6D6C14CD4\",\n        \"A2DBC7A5B1C6C0A8BCB7AAA41252A6A7D0690DBC\",\n        \"DB1F9050BB863DFEF4CE37186044E2EEB17EE013\",\n        \"127FDEDF43D372A51D5747C48FBFFE38EF6CDF7B\"\n     } },\n  { \"SHA224\", SHA224, SHA224HashSize,\n    {\n      /* 1 */ { TEST1, length(TEST1), 1, 0, 0,\n        \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\" },\n      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,\n        \"75388B16512776CC5DBA5DA1FD890150B0C6455CB4F58B1952522525\" },\n      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n        \"20794655980C91D8BBB4C1EA97618A4BF03F42581948B2EE4EE7AD67\" },\n      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n        \"567F69F168CD7844E65259CE658FE7AADFA25216E68ECA0EB7AB8262\" },\n      /* 5 */ { \"\", 0, 0, 0x68, 5,\n        \"E3B048552C3C387BCAB37F6EB06BB79B96A4AEE5FF27F51531A9551C\" },\n      /* 6 */ { \"\\x07\", 1, 1, 0, 0,\n        \"00ECD5F138422B8AD74C9799FD826C531BAD2FCABC7450BEE2AA8C2A\" },\n      /* 7 */ { TEST7_224, length(TEST7_224), 1, 0xA0, 3,\n        \"1B01DB6CB4A9E43DED1516BEB3DB0B87B6D1EA43187462C608137150\" },\n      /* 8 */ { TEST8_224, length(TEST8_224), 1, 0, 0,\n        \"DF90D78AA78821C99B40BA4C966921ACCD8FFB1E98AC388E56191DB1\" },\n      /* 9 */ { TEST9_224, length(TEST9_224), 1, 0xE0, 3,\n        \"54BEA6EAB8195A2EB0A7906A4B4A876666300EEFBD1F3B8474F9CD57\" },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "    /* 10 */ { TEST10_224, length(TEST10_224), 1, 0, 0,\n      \"0B31894EC8937AD9B91BDFBCBA294D9ADEFAA18E09305E9F20D5C3A4\" }\n  }, SHA224_SEED, { \"100966A5B4FDE0B42E2A6C5953D4D7F41BA7CF79FD\"\n      \"2DF431416734BE\", \"1DCA396B0C417715DEFAAE9641E10A2E99D55A\"\n      \"BCB8A00061EB3BE8BD\", \"1864E627BDB2319973CD5ED7D68DA71D8B\"\n      \"F0F983D8D9AB32C34ADB34\", \"A2406481FC1BCAF24DD08E6752E844\"\n      \"709563FB916227FED598EB621F\"\n   } },\n{ \"SHA256\", SHA256, SHA256HashSize,\n{\n    /* 1 */ { TEST1, length(TEST1), 1, 0, 0, \"BA7816BF8F01CFEA4141\"\n      \"40DE5DAE2223B00361A396177A9CB410FF61F20015AD\" },\n    /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0, \"248D6A61D20638B8\"\n      \"E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1\" },\n    /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0, \"CDC76E5C9914FB92\"\n      \"81A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0\" },\n    /* 4 */ { TEST4, length(TEST4), 10, 0, 0, \"594847328451BDFA\"\n      \"85056225462CC1D867D877FB388DF0CE35F25AB5562BFBB5\" },\n    /* 5 */ { \"\", 0, 0, 0x68, 5, \"D6D3E02A31A84A8CAA9718ED6C2057BE\"\n      \"09DB45E7823EB5079CE7A573A3760F95\" },\n    /* 6 */ { \"\\x19\", 1, 1, 0, 0, \"68AA2E2EE5DFF96E3355E6C7EE373E3D\"\n      \"6A4E17F75F9518D843709C0C9BC3E3D4\" },\n    /* 7 */ { TEST7_256, length(TEST7_256), 1, 0x60, 3, \"77EC1DC8\"\n      \"9C821FF2A1279089FA091B35B8CD960BCAF7DE01C6A7680756BEB972\" },\n    /* 8 */ { TEST8_256, length(TEST8_256), 1, 0, 0, \"175EE69B02BA\"\n      \"9B58E2B0A5FD13819CEA573F3940A94F825128CF4209BEABB4E8\" },\n    /* 9 */ { TEST9_256, length(TEST9_256), 1, 0xA0, 3, \"3E9AD646\"\n      \"8BBBAD2AC3C2CDC292E018BA5FD70B960CF1679777FCE708FDB066E9\" },\n    /* 10 */ { TEST10_256, length(TEST10_256), 1, 0, 0, \"97DBCA7D\"\n      \"F46D62C8A422C941DD7E835B8AD3361763F7E9B2D95F4F0DA6E1CCBC\" },\n  }, SHA256_SEED, { \"83D28614D49C3ADC1D6FC05DB5F48037C056F8D2A4CE44\"\n      \"EC6457DEA5DD797CD1\", \"99DBE3127EF2E93DD9322D6A07909EB33B6399\"\n      \"5E529B3F954B8581621BB74D39\", \"8D4BE295BB64661CA3C7EFD129A2F7\"\n      \"25B33072DBDDE32385B9A87B9AF88EA76F\", \"40AF5D3F9716B040DF9408\"\n      \"E31536B70FF906EC51B00447CA97D7DD97C12411F4\"\n  } },\n{ \"SHA384\", SHA384, SHA384HashSize,\n  {\n    /* 1 */ { TEST1, length(TEST1), 1, 0, 0,\n      \"CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED163\"\n      \"1A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7\" },\n    /* 2 */ { TEST2_2, length(TEST2_2), 1, 0, 0,\n      \"09330C33F71147E83D192FC782CD1B4753111B173B3B05D2\"\n      \"2FA08086E3B0F712FCC7C71A557E2DB966C3E9FA91746039\" },\n    /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n      \"9D0E1809716474CB086E834E310A4A1CED149E9C00F24852\"\n      \"7972CEC5704C2A5B07B8B3DC38ECC4EBAE97DDD87F3D8985\" },\n    /* 4 */ { TEST4, length(TEST4), 10, 0, 0,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "      \"2FC64A4F500DDB6828F6A3430B8DD72A368EB7F3A8322A70\"\n      \"BC84275B9C0B3AB00D27A5CC3C2D224AA6B61A0D79FB4596\" },\n    /* 5 */ { \"\", 0, 0, 0x10, 5,\n      \"8D17BE79E32B6718E07D8A603EB84BA0478F7FCFD1BB9399\"\n      \"5F7D1149E09143AC1FFCFC56820E469F3878D957A15A3FE4\" },\n    /* 6 */ { \"\\xb9\", 1, 1, 0, 0,\n      \"BC8089A19007C0B14195F4ECC74094FEC64F01F90929282C\"\n      \"2FB392881578208AD466828B1C6C283D2722CF0AD1AB6938\" },\n    /* 7 */ { TEST7_384, length(TEST7_384), 1, 0xA0, 3,\n      \"D8C43B38E12E7C42A7C9B810299FD6A770BEF30920F17532\"\n      \"A898DE62C7A07E4293449C0B5FA70109F0783211CFC4BCE3\" },\n    /* 8 */ { TEST8_384, length(TEST8_384), 1, 0, 0,\n      \"C9A68443A005812256B8EC76B00516F0DBB74FAB26D66591\"\n      \"3F194B6FFB0E91EA9967566B58109CBC675CC208E4C823F7\" },\n    /* 9 */ { TEST9_384, length(TEST9_384), 1, 0xE0, 3,\n      \"5860E8DE91C21578BB4174D227898A98E0B45C4C760F0095\"\n      \"49495614DAEDC0775D92D11D9F8CE9B064EEAC8DAFC3A297\" },\n    /* 10 */ { TEST10_384, length(TEST10_384), 1, 0, 0,\n      \"4F440DB1E6EDD2899FA335F09515AA025EE177A79F4B4AAF\"\n      \"38E42B5C4DE660F5DE8FB2A5B2FBD2A3CBFFD20CFF1288C0\" }\n  }, SHA384_SEED, { \"CE44D7D63AE0C91482998CF662A51EC80BF6FC68661A3C\"\n      \"57F87566112BD635A743EA904DEB7D7A42AC808CABE697F38F\", \"F9C6D2\"\n      \"61881FEE41ACD39E67AA8D0BAD507C7363EB67E2B81F45759F9C0FD7B503\"\n      \"DF1A0B9E80BDE7BC333D75B804197D\", \"D96512D8C9F4A7A4967A366C01\"\n      \"C6FD97384225B58343A88264847C18E4EF8AB7AEE4765FFBC3E30BD485D3\"\n      \"638A01418F\", \"0CA76BD0813AF1509E170907A96005938BC985628290B2\"\n      \"5FEF73CF6FAD68DDBA0AC8920C94E0541607B0915A7B4457F7\"\n  } },\n{ \"SHA512\", SHA512, SHA512HashSize,\n  {\n    /* 1 */ { TEST1, length(TEST1), 1, 0, 0,\n      \"DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA2\"\n      \"0A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD\"\n      \"454D4423643CE80E2A9AC94FA54CA49F\" },\n    /* 2 */ { TEST2_2, length(TEST2_2), 1, 0, 0,\n      \"8E959B75DAE313DA8CF4F72814FC143F8F7779C6EB9F7FA1\"\n      \"7299AEADB6889018501D289E4900F7E4331B99DEC4B5433A\"\n      \"C7D329EEB6DD26545E96E55B874BE909\" },\n     /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n      \"E718483D0CE769644E2E42C7BC15B4638E1F98B13B204428\"\n      \"5632A803AFA973EBDE0FF244877EA60A4CB0432CE577C31B\"\n      \"EB009C5C2C49AA2E4EADB217AD8CC09B\" },\n    /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n      \"89D05BA632C699C31231DED4FFC127D5A894DAD412C0E024\"\n      \"DB872D1ABD2BA8141A0F85072A9BE1E2AA04CF33C765CB51\"\n      \"0813A39CD5A84C4ACAA64D3F3FB7BAE9\" },\n    /* 5 */ { \"\", 0, 0, 0xB0, 5,\n      \"D4EE29A9E90985446B913CF1D1376C836F4BE2C1CF3CADA0\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "        \"720A6BF4857D886A7ECB3C4E4C0FA8C7F95214E41DC1B0D2\"\n        \"1B22A84CC03BF8CE4845F34DD5BDBAD4\" },\n      /* 6 */ { \"\\xD0\", 1, 1, 0, 0,\n        \"9992202938E882E73E20F6B69E68A0A7149090423D93C81B\"\n        \"AB3F21678D4ACEEEE50E4E8CAFADA4C85A54EA8306826C4A\"\n        \"D6E74CECE9631BFA8A549B4AB3FBBA15\" },\n      /* 7 */ { TEST7_512, length(TEST7_512), 1, 0x80, 3,\n        \"ED8DC78E8B01B69750053DBB7A0A9EDA0FB9E9D292B1ED71\"\n        \"5E80A7FE290A4E16664FD913E85854400C5AF05E6DAD316B\"\n        \"7359B43E64F8BEC3C1F237119986BBB6\" },\n      /* 8 */ { TEST8_512, length(TEST8_512), 1, 0, 0,\n        \"CB0B67A4B8712CD73C9AABC0B199E9269B20844AFB75ACBD\"\n        \"D1C153C9828924C3DDEDAAFE669C5FDD0BC66F630F677398\"\n        \"8213EB1B16F517AD0DE4B2F0C95C90F8\" },\n      /* 9 */ { TEST9_512, length(TEST9_512), 1, 0x80, 3,\n        \"32BA76FC30EAA0208AEB50FFB5AF1864FDBF17902A4DC0A6\"\n        \"82C61FCEA6D92B783267B21080301837F59DE79C6B337DB2\"\n        \"526F8A0A510E5E53CAFED4355FE7C2F1\" },\n      /* 10 */ { TEST10_512, length(TEST10_512), 1, 0, 0,\n        \"C665BEFB36DA189D78822D10528CBF3B12B3EEF726039909\"\n        \"C1A16A270D48719377966B957A878E720584779A62825C18\"\n        \"DA26415E49A7176A894E7510FD1451F5\" }\n    }, SHA512_SEED, { \"2FBB1E7E00F746BA514FBC8C421F36792EC0E11FF5EFC3\"\n        \"78E1AB0C079AA5F0F66A1E3EDBAEB4F9984BE14437123038A452004A5576\"\n        \"8C1FD8EED49E4A21BEDCD0\", \"25CBE5A4F2C7B1D7EF07011705D50C62C5\"\n        \"000594243EAFD1241FC9F3D22B58184AE2FEE38E171CF8129E29459C9BC2\"\n        \"EF461AF5708887315F15419D8D17FE7949\", \"5B8B1F2687555CE2D7182B\"\n        \"92E5C3F6C36547DA1C13DBB9EA4F73EA4CBBAF89411527906D35B1B06C1B\"\n        \"6A8007D05EC66DF0A406066829EAB618BDE3976515AAFC\", \"46E36B007D\"\n        \"19876CDB0B29AD074FE3C08CDD174D42169D6ABE5A1414B6E79707DF5877\"\n        \"6A98091CF431854147BB6D3C66D43BFBC108FD715BDE6AA127C2B0E79F\"\n    }\n  }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* Test arrays for HMAC. */\nstruct hmachash {\n    const char *keyarray[5];\n    int keylength[5];\n    const char *dataarray[5];\n    int datalength[5];\n    const char *resultarray[5];\n    int resultlength[5];\n} hmachashes[HMACTESTCOUNT] = {\n  { /* 1 */ {\n      \"\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"\n      \"\\x0b\\x0b\\x0b\\x0b\\x0b\"\n    }, { 20 }, {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "    \"\\x48\\x69\\x20\\x54\\x68\\x65\\x72\\x65\" /* \"Hi There\" */\n  }, { 8 }, {\n    /* HMAC-SHA-1 */\n    \"B617318655057264E28BC0B6FB378C8EF146BE00\",\n    /* HMAC-SHA-224 */\n    \"896FB1128ABBDF196832107CD49DF33F47B4B1169912BA4F53684B22\",\n    /* HMAC-SHA-256 */\n    \"B0344C61D8DB38535CA8AFCEAF0BF12B881DC200C9833DA726E9376C2E32\"\n    \"CFF7\",\n    /* HMAC-SHA-384 */\n    \"AFD03944D84895626B0825F4AB46907F15F9DADBE4101EC682AA034C7CEB\"\n    \"C59CFAEA9EA9076EDE7F4AF152E8B2FA9CB6\",\n    /* HMAC-SHA-512 */\n    \"87AA7CDEA5EF619D4FF0B4241A1D6CB02379F4E2CE4EC2787AD0B30545E1\"\n    \"7CDEDAA833B7D6B8A702038B274EAEA3F4E4BE9D914EEB61F1702E696C20\"\n    \"3A126854\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},\n{ /* 2 */ {\n    \"\\x4a\\x65\\x66\\x65\" /* \"Jefe\" */\n  }, { 4 }, {\n    \"\\x77\\x68\\x61\\x74\\x20\\x64\\x6f\\x20\\x79\\x61\\x20\\x77\\x61\\x6e\\x74\"\n    \"\\x20\\x66\\x6f\\x72\\x20\\x6e\\x6f\\x74\\x68\\x69\\x6e\\x67\\x3f\"\n    /* \"what do ya want for nothing?\" */\n  }, { 28 }, {\n    /* HMAC-SHA-1 */\n    \"EFFCDF6AE5EB2FA2D27416D5F184DF9C259A7C79\",\n    /* HMAC-SHA-224 */\n    \"A30E01098BC6DBBF45690F3A7E9E6D0F8BBEA2A39E6148008FD05E44\",\n    /* HMAC-SHA-256 */\n    \"5BDCC146BF60754E6A042426089575C75A003F089D2739839DEC58B964EC\"\n    \"3843\",\n    /* HMAC-SHA-384 */\n    \"AF45D2E376484031617F78D2B58A6B1B9C7EF464F5A01B47E42EC3736322\"\n    \"445E8E2240CA5E69E2C78B3239ECFAB21649\",\n    /* HMAC-SHA-512 */\n    \"164B7A7BFCF819E2E395FBE73B56E0A387BD64222E831FD610270CD7EA25\"\n    \"05549758BF75C05A994A6D034F65F8F0E6FDCAEAB1A34D4A6B4B636E070A\"\n    \"38BCE737\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},\n{ /* 3 */\n  {\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\"\n  }, { 20 }, {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "    \"\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n    \"\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n    \"\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n    \"\\xdd\\xdd\\xdd\\xdd\\xdd\"\n  }, { 50 }, {\n    /* HMAC-SHA-1 */\n    \"125D7342B9AC11CD91A39AF48AA17B4F63F175D3\",\n    /* HMAC-SHA-224 */\n    \"7FB3CB3588C6C1F6FFA9694D7D6AD2649365B0C1F65D69D1EC8333EA\",\n    /* HMAC-SHA-256 */\n    \"773EA91E36800E46854DB8EBD09181A72959098B3EF8C122D9635514CED5\"\n    \"65FE\",\n    /* HMAC-SHA-384 */\n    \"88062608D3E6AD8A0AA2ACE014C8A86F0AA635D947AC9FEBE83EF4E55966\"\n    \"144B2A5AB39DC13814B94E3AB6E101A34F27\",\n    /* HMAC-SHA-512 */\n    \"FA73B0089D56A284EFB0F0756C890BE9B1B5DBDD8EE81A3655F83E33B227\"\n    \"9D39BF3E848279A722C806B485A47E67C807B946A337BEE8942674278859\"\n    \"E13292FB\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},\n{ /* 4 */ {\n    \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\"\n    \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\"\n  }, { 25 }, {\n    \"\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n    \"\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n    \"\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n    \"\\xcd\\xcd\\xcd\\xcd\\xcd\"\n  }, { 50 }, {\n    /* HMAC-SHA-1 */\n    \"4C9007F4026250C6BC8414F9BF50C86C2D7235DA\",\n    /* HMAC-SHA-224 */\n    \"6C11506874013CAC6A2ABC1BB382627CEC6A90D86EFC012DE7AFEC5A\",\n    /* HMAC-SHA-256 */\n    \"82558A389A443C0EA4CC819899F2083A85F0FAA3E578F8077A2E3FF46729\"\n    \"665B\",\n    /* HMAC-SHA-384 */\n    \"3E8A69B7783C25851933AB6290AF6CA77A9981480850009CC5577C6E1F57\"\n    \"3B4E6801DD23C4A7D679CCF8A386C674CFFB\",\n    /* HMAC-SHA-512 */\n    \"B0BA465637458C6990E5A8C5F61D4AF7E576D97FF94B872DE76F8050361E\"\n    \"E3DBA91CA5C11AA25EB4D679275CC5788063A5F19741120C4F2DE2ADEBEB\"\n    \"10A298DD\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "{ /* 5 */ {\n    \"\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\"\n    \"\\x0c\\x0c\\x0c\\x0c\\x0c\"\n  }, { 20 }, {\n    \"Test With Truncation\"\n  }, { 20 }, {\n    /* HMAC-SHA-1 */\n    \"4C1A03424B55E07FE7F27BE1\",\n    /* HMAC-SHA-224 */\n    \"0E2AEA68A90C8D37C988BCDB9FCA6FA8\",\n    /* HMAC-SHA-256 */\n    \"A3B6167473100EE06E0C796C2955552B\",\n    /* HMAC-SHA-384 */\n    \"3ABF34C3503B2A23A46EFC619BAEF897\",\n    /* HMAC-SHA-512 */\n    \"415FAD6271580A531D4179BC891D87A6\"\n  }, { 12, 16, 16, 16, 16 }\n},\n{ /* 6 */ {\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n  }, { 80, 131 }, {\n    \"Test Using Larger Than Block-Size Key - Hash Key First\"\n  }, { 54 }, {\n    /* HMAC-SHA-1 */\n    \"AA4AE5E15272D00E95705637CE8A3B55ED402112\",\n    /* HMAC-SHA-224 */\n    \"95E9A0DB962095ADAEBE9B2D6F0DBCE2D499F112F2D2B7273FA6870E\",\n    /* HMAC-SHA-256 */\n    \"60E431591EE0B67F0D8A26AACBF5B77F8E0BC6213728C5140546040F0EE3\"\n    \"7F54\",\n    /* HMAC-SHA-384 */\n    \"4ECE084485813E9088D2C63A041BC5B44F9EF1012A2B588F3CD11F05033A\"\n    \"C4C60C2EF6AB4030FE8296248DF163F44952\",\n    /* HMAC-SHA-512 */\n    \"80B24263C7C1A3EBB71493C1DD7BE8B49B46D1F41B4AEEC1121B013783F8\"\n    \"F3526B56D037E05F2598BD0FD2215D6A1E5295E64F73F63F0AEC8B915A98\"\n    \"5D786598\"\n  }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n    SHA384HashSize, SHA512HashSize }\n},",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  { /* 7 */ {\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    }, { 80, 131 }, {\n      \"Test Using Larger Than Block-Size Key and \"\n      \"Larger Than One Block-Size Data\",\n      \"\\x54\\x68\\x69\\x73\\x20\\x69\\x73\\x20\\x61\\x20\\x74\\x65\\x73\\x74\\x20\"\n      \"\\x75\\x73\\x69\\x6e\\x67\\x20\\x61\\x20\\x6c\\x61\\x72\\x67\\x65\\x72\\x20\"\n      \"\\x74\\x68\\x61\\x6e\\x20\\x62\\x6c\\x6f\\x63\\x6b\\x2d\\x73\\x69\\x7a\\x65\"\n      \"\\x20\\x6b\\x65\\x79\\x20\\x61\\x6e\\x64\\x20\\x61\\x20\\x6c\\x61\\x72\\x67\"\n      \"\\x65\\x72\\x20\\x74\\x68\\x61\\x6e\\x20\\x62\\x6c\\x6f\\x63\\x6b\\x2d\\x73\"\n      \"\\x69\\x7a\\x65\\x20\\x64\\x61\\x74\\x61\\x2e\\x20\\x54\\x68\\x65\\x20\\x6b\"\n      \"\\x65\\x79\\x20\\x6e\\x65\\x65\\x64\\x73\\x20\\x74\\x6f\\x20\\x62\\x65\\x20\"\n      \"\\x68\\x61\\x73\\x68\\x65\\x64\\x20\\x62\\x65\\x66\\x6f\\x72\\x65\\x20\\x62\"\n      \"\\x65\\x69\\x6e\\x67\\x20\\x75\\x73\\x65\\x64\\x20\\x62\\x79\\x20\\x74\\x68\"\n      \"\\x65\\x20\\x48\\x4d\\x41\\x43\\x20\\x61\\x6c\\x67\\x6f\\x72\\x69\\x74\\x68\"\n      \"\\x6d\\x2e\"\n      /* \"This is a test using a larger than block-size key and a \"\n          \"larger than block-size data. The key needs to be hashed \"\n          \"before being used by the HMAC algorithm.\" */\n    }, { 73, 152 }, {\n      /* HMAC-SHA-1 */\n      \"E8E99D0F45237D786D6BBAA7965C7808BBFF1A91\",\n      /* HMAC-SHA-224 */\n      \"3A854166AC5D9F023F54D517D0B39DBD946770DB9C2B95C9F6F565D1\",\n      /* HMAC-SHA-256 */\n      \"9B09FFA71B942FCB27635FBCD5B0E944BFDC63644F0713938A7F51535C3A\"\n      \"35E2\",\n      /* HMAC-SHA-384 */\n      \"6617178E941F020D351E2F254E8FD32C602420FEB0B8FB9ADCCEBB82461E\"\n      \"99C5A678CC31E799176D3860E6110C46523E\",\n      /* HMAC-SHA-512 */\n      \"E37B6A775DC87DBAA4DFA9F96E5E3FFDDEBD71F8867289865DF5A32D20CD\"\n      \"C944B6022CAC3C4982B10D5EEB55C3E4DE15134676FB6DE0446065C97440\"\n      \"FA8C6A58\"\n    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n      SHA384HashSize, SHA512HashSize }\n  }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " * Check the hash value against the expected string, expressed in hex\n */\nstatic const char hexdigits[] = \"0123456789ABCDEF\";\nint checkmatch(const unsigned char *hashvalue,\n  const char *hexstr, int hashsize)\n{\n  int i;\n  for (i = 0; i < hashsize; ++i) {\n    if (*hexstr++ != hexdigits[(hashvalue[i] >> 4) & 0xF])\n      return 0;\n    if (*hexstr++ != hexdigits[hashvalue[i] & 0xF]) return 0;\n  }\n  return 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Print the string, converting non-printable characters to \".\"\n */\nvoid printstr(const char *str, int len)\n{\n  for ( ; len-- > 0; str++)\n    putchar(isprint((unsigned char)*str) ? *str : '.');\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Print the string, converting non-printable characters to hex \"## \".\n */\nvoid printxstr(const char *str, int len)\n{\n  for ( ; len-- > 0; str++)\n    printf(\"%c%c \", hexdigits[(*str >> 4) & 0xF],\n      hexdigits[*str & 0xF]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Print a usage message.\n */\nvoid usage(const char *argv0)\n{\n  fprintf(stderr,\n    \"Usage:\\n\"\n    \"Common options: [-h hash] [-w|-x] [-H]\\n\"\n    \"Standard tests:\\n\"\n      \"\\t%s [-m] [-l loopcount] [-t test#] [-e]\\n\"\n      \"\\t\\t[-r randomseed] [-R randomloop-count] \"\n        \"[-p] [-P|-X]\\n\"\n    \"Hash a string:\\n\"\n      \"\\t%s [-S expectedresult] -s hashstr [-k key]\\n\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    \"Hash a file:\\n\"\n      \"\\t%s [-S expectedresult] -f file [-k key]\\n\"\n    \"Hash a file, ignoring whitespace:\\n\"\n      \"\\t%s [-S expectedresult] -F file [-k key]\\n\"\n    \"Additional bits to add in: [-B bitcount -b bits]\\n\"\n    \"-h\\thash to test: \"\n      \"0|SHA1, 1|SHA224, 2|SHA256, 3|SHA384, 4|SHA512\\n\"\n    \"-m\\tperform hmac test\\n\"\n    \"-k\\tkey for hmac test\\n\"\n    \"-t\\ttest case to run, 1-10\\n\"\n    \"-l\\thow many times to run the test\\n\"\n    \"-e\\ttest error returns\\n\"\n    \"-p\\tdo not print results\\n\"\n    \"-P\\tdo not print PASSED/FAILED\\n\"\n    \"-X\\tprint FAILED, but not PASSED\\n\"\n    \"-r\\tseed for random test\\n\"\n    \"-R\\thow many times to run random test\\n\"\n    \"-s\\tstring to hash\\n\"\n    \"-S\\texpected result of hashed string, in hex\\n\"\n    \"-w\\toutput hash in raw format\\n\"\n    \"-x\\toutput hash in hex format\\n\"\n    \"-B\\t# extra bits to add in after string or file input\\n\"\n    \"-b\\textra bits to add (high order bits of #, 0# or 0x#)\\n\"\n    \"-H\\tinput hashstr or randomseed is in hex\\n\"\n    , argv0, argv0, argv0, argv0);\n  exit(1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Print the results and PASS/FAIL.\n */\nvoid printResult(uint8_t *Message_Digest, int hashsize,\n    const char *hashname, const char *testtype, const char *testname,\n    const char *resultarray, int printResults, int printPassFail)\n{\n  int i, k;\n  if (printResults == PRINTTEXT) {\n    putchar('\\t');\n    for (i = 0; i < hashsize ; ++i) {\n      putchar(hexdigits[(Message_Digest[i] >> 4) & 0xF]);\n      putchar(hexdigits[Message_Digest[i] & 0xF]);\n      putchar(' ');\n    }\n    putchar('\\n');\n  } else if (printResults == PRINTRAW) {\n    fwrite(Message_Digest, 1, hashsize, stdout);\n  } else if (printResults == PRINTHEX) {\n    for (i = 0; i < hashsize ; ++i) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "    putchar(hexdigits[(Message_Digest[i] >> 4) & 0xF]);\n    putchar(hexdigits[Message_Digest[i] & 0xF]);\n  }\n  putchar('\\n');\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (printResults && resultarray) {\n  printf(\"    Should match:\\n\\t\");\n  for (i = 0, k = 0; i < hashsize; i++, k += 2) {\n    putchar(resultarray[k]);\n    putchar(resultarray[k+1]);\n    putchar(' ');\n  }\n  putchar('\\n');\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  if (printPassFail && resultarray) {\n    int ret = checkmatch(Message_Digest, resultarray, hashsize);\n    if ((printPassFail == PRINTPASSFAIL) || !ret)\n      printf(\"%s %s %s: %s\\n\", hashname, testtype, testname,\n        ret ? \"PASSED\" : \"FAILED\");\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Exercise a hash series of functions. The input is the testarray,\n * repeated repeatcount times, followed by the extrabits. If the\n * result is known, it is in resultarray in uppercase hex.\n */\nint hash(int testno, int loopno, int hashno,\n  const char *testarray, int length, long repeatcount,\n  int numberExtrabits, int extrabits, const unsigned char *keyarray,\n  int keylen, const char *resultarray, int hashsize, int printResults,\n  int printPassFail)\n{\n  USHAContext sha;\n  HMACContext hmac;\n  int err, i;\n  uint8_t Message_Digest[USHAMaxHashSize];\n  char buf[20];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (printResults == PRINTTEXT) {\n  printf(\"\\nTest %d: Iteration %d, Repeat %ld\\n\\t'\", testno+1,\n    loopno, repeatcount);\n  printstr(testarray, length);\n  printf(\"'\\n\\t'\");\n  printxstr(testarray, length);\n  printf(\"'\\n\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  printf(\"    Length=%d bytes (%d bits), \", length, length * 8);\n  printf(\"ExtraBits %d: %2.2x\\n\", numberExtrabits, extrabits);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "memset(&sha, '\\343', sizeof(sha)); /* force bad data into struct */\nmemset(&hmac, '\\343', sizeof(hmac));\nerr = keyarray ? hmacReset(&hmac, hashes[hashno].whichSha,\n                           keyarray, keylen) :\n                 USHAReset(&sha, hashes[hashno].whichSha);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hash(): %sReset Error %d.\\n\",\n          keyarray ? \"hmac\" : \"sha\", err);\n  return err;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (i = 0; i < repeatcount; ++i) {\n  err = keyarray ? hmacInput(&hmac, (const uint8_t *) testarray,\n                             length) :\n                   USHAInput(&sha, (const uint8_t *) testarray,\n                             length);\n  if (err != shaSuccess) {\n    fprintf(stderr, \"hash(): %sInput Error %d.\\n\",\n            keyarray ? \"hmac\" : \"sha\", err);\n    return err;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (numberExtrabits > 0) {\n  err = keyarray ? hmacFinalBits(&hmac, (uint8_t) extrabits,\n                                 numberExtrabits) :\n                   USHAFinalBits(&sha, (uint8_t) extrabits,\n                                 numberExtrabits);\n  if (err != shaSuccess) {\n    fprintf(stderr, \"hash(): %sFinalBits Error %d.\\n\",\n            keyarray ? \"hmac\" : \"sha\", err);\n    return err;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "err = keyarray ? hmacResult(&hmac, Message_Digest) :\n                 USHAResult(&sha, Message_Digest);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hash(): %s Result Error %d, could not \"\n    \"compute message digest.\\n\", keyarray ? \"hmac\" : \"sha\", err);\n  return err;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "sprintf(buf, \"%d\", testno+1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "printResult(Message_Digest, hashsize, hashes[hashno].name, keyarray ? \"hmac standard test\" : \"sha standard test\", buf, resultarray, printResults, printPassFail);",
      "ja": "printResult（Message_Digest、hashsize、hashes [hashno] .name、keyarray？ \"hmac standard test\"： \"sha standard test\"、buf、resultarray、printResults、printPassFail）;"
    },
    {
      "indent": 0,
      "text": "  return err;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Exercise a hash series of functions. The input is a filename.\n * If the result is known, it is in resultarray in uppercase hex.\n */\nint hashfile(int hashno, const char *hashfilename, int bits,\n  int bitcount, int skipSpaces, const unsigned char *keyarray,\n  int keylen, const char *resultarray, int hashsize,\n  int printResults, int printPassFail)\n{\n  USHAContext sha;\n  HMACContext hmac;\n  int err, nread, c;\n  unsigned char buf[4096];\n  uint8_t Message_Digest[USHAMaxHashSize];\n  unsigned char cc;\n  FILE *hashfp = (strcmp(hashfilename, \"-\") == 0) ? stdin :\n    fopen(hashfilename, \"r\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (!hashfp) {\n  fprintf(stderr, \"cannot open file '%s'\\n\", hashfilename);\n  return shaStateError;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "memset(&sha, '\\343', sizeof(sha)); /* force bad data into struct */\nmemset(&hmac, '\\343', sizeof(hmac));\nerr = keyarray ? hmacReset(&hmac, hashes[hashno].whichSha,\n                           keyarray, keylen) :\n                 USHAReset(&sha, hashes[hashno].whichSha);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (err != shaSuccess) {\n  fprintf(stderr, \"hashfile(): %sReset Error %d.\\n\",\n          keyarray ? \"hmac\" : \"sha\", err);\n  return err;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (skipSpaces)\n  while ((c = getc(hashfp)) != EOF) {\n    if (!isspace(c)) {\n      cc = (unsigned char)c;\n      err = keyarray ? hmacInput(&hmac, &cc, 1) :\n                       USHAInput(&sha, &cc, 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "      if (err != shaSuccess) {\n        fprintf(stderr, \"hashfile(): %sInput Error %d.\\n\",\n                keyarray ? \"hmac\" : \"sha\", err);\n        if (hashfp != stdin) fclose(hashfp);\n        return err;\n      }\n    }\n  }\nelse\n  while ((nread = fread(buf, 1, sizeof(buf), hashfp)) > 0) {\n    err = keyarray ? hmacInput(&hmac, buf, nread) :\n                     USHAInput(&sha, buf, nread);\n    if (err != shaSuccess) {\n      fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\n              keyarray ? \"hmacInput\" : \"shaInput\", err);\n      if (hashfp != stdin) fclose(hashfp);\n      return err;\n    }\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (bitcount > 0)\n  err = keyarray ? hmacFinalBits(&hmac, bits, bitcount) :\n                 USHAFinalBits(&sha, bits, bitcount);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\n          keyarray ? \"hmacResult\" : \"shaResult\", err);\n  if (hashfp != stdin) fclose(hashfp);\n  return err;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "err = keyarray ? hmacResult(&hmac, Message_Digest) :\n                 USHAResult(&sha, Message_Digest);\nif (err != shaSuccess) {\n  fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\n          keyarray ? \"hmacResult\" : \"shaResult\", err);\n  if (hashfp != stdin) fclose(hashfp);\n  return err;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "printResult(Message_Digest, hashsize, hashes[hashno].name, \"file\", hashfilename, resultarray, printResults, printPassFail);",
      "ja": "printResult(Message_Digest, hashsize, hashes[hashno].name, \"file\", hashfilename, resultarray, printResults, printPassFail);"
    },
    {
      "indent": 0,
      "text": "  if (hashfp != stdin) fclose(hashfp);\n  return err;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Exercise a hash series of functions through multiple permutations.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " * The input is an initial seed. That seed is replicated 3 times.\n * For 1000 rounds, the previous three results are used as the input.\n * This result is then checked, and used to seed the next cycle.\n * If the result is known, it is in resultarrays in uppercase hex.\n */\nvoid randomtest(int hashno, const char *seed, int hashsize,\n    const char **resultarrays, int randomcount,\n    int printResults, int printPassFail)\n{\n  int i, j; char buf[20];\n  unsigned char SEED[USHAMaxHashSize], MD[1003][USHAMaxHashSize];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* INPUT: Seed - A random seed n bits long */\nmemcpy(SEED, seed, hashsize);\nif (printResults == PRINTTEXT) {\n  printf(\"%s random test seed= '\", hashes[hashno].name);\n  printxstr(seed, hashsize);\n  printf(\"'\\n\");\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (j = 0; j < randomcount; j++) {\n  /* MD0 = MD1 = MD2 = Seed; */\n  memcpy(MD[0], SEED, hashsize);\n  memcpy(MD[1], SEED, hashsize);\n  memcpy(MD[2], SEED, hashsize);\n  for (i=3; i<1003; i++) {\n    /* Mi = MDi-3 || MDi-2 || MDi-1; */\n    USHAContext Mi;\n    memset(&Mi, '\\343', sizeof(Mi)); /* force bad data into struct */\n    USHAReset(&Mi, hashes[hashno].whichSha);\n    USHAInput(&Mi, MD[i-3], hashsize);\n    USHAInput(&Mi, MD[i-2], hashsize);\n    USHAInput(&Mi, MD[i-1], hashsize);\n    /* MDi = SHA(Mi); */\n    USHAResult(&Mi, MD[i]);\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* MDj = Seed = MDi; */\nmemcpy(SEED, MD[i-1], hashsize);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    /* OUTPUT: MDj */\n    sprintf(buf, \"%d\", j);\n    printResult(SEED, hashsize, hashes[hashno].name, \"random test\",\n      buf, resultarrays ? resultarrays[j] : 0, printResults,\n      (j < RANDOMCOUNT) ? printPassFail : 0);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Look up a hash name.\n */\nint findhash(const char *argv0, const char *opt)\n{\n  int i;\n  const char *names[HASHCOUNT][2] = {\n    { \"0\", \"sha1\" }, { \"1\", \"sha224\" }, { \"2\", \"sha256\" },\n    { \"3\", \"sha384\" }, { \"4\", \"sha512\" }\n  };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (i = 0; i < HASHCOUNT; i++)\n  if ((strcmp(opt, names[i][0]) == 0) ||\n      (scasecmp(opt, names[i][1]) == 0))\n    return i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  fprintf(stderr, \"%s: Unknown hash name: '%s'\\n\", argv0, opt);\n  usage(argv0);\n  return 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Run some tests that should invoke errors.\n */\nvoid testErrors(int hashnolow, int hashnohigh, int printResults,\n    int printPassFail)\n{\n  USHAContext usha;\n  uint8_t Message_Digest[USHAMaxHashSize];\n  int hashno, err;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (hashno = hashnolow; hashno <= hashnohigh; hashno++) {\n  memset(&usha, '\\343', sizeof(usha)); /* force bad data */\n  USHAReset(&usha, hashno);\n  USHAResult(&usha, Message_Digest);\n  err = USHAInput(&usha, (const unsigned char *)\"foo\", 3);\n  if (printResults == PRINTTEXT)\n    printf (\"\\nError %d. Should be %d.\\n\", err, shaStateError);\n  if ((printPassFail == PRINTPASSFAIL) ||\n      ((printPassFail == PRINTFAIL) && (err != shaStateError)))\n    printf(\"%s se: %s\\n\", hashes[hashno].name,\n      (err == shaStateError) ? \"PASSED\" : \"FAILED\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "err = USHAFinalBits(&usha, 0x80, 3);\nif (printResults == PRINTTEXT)\n  printf (\"\\nError %d. Should be %d.\\n\", err, shaStateError);\nif ((printPassFail == PRINTPASSFAIL) ||\n    ((printPassFail == PRINTFAIL) && (err != shaStateError)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "printf(\"%s se: %s\\n\", hashes[hashno].name,\n  (err == shaStateError) ? \"PASSED\" : \"FAILED\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "err = USHAReset(0, hashes[hashno].whichSha);\nif (printResults == PRINTTEXT)\n   printf(\"\\nError %d. Should be %d.\\n\", err, shaNull);\nif ((printPassFail == PRINTPASSFAIL) ||\n    ((printPassFail == PRINTFAIL) && (err != shaNull)))\n   printf(\"%s usha null: %s\\n\", hashes[hashno].name,\n    (err == shaNull) ? \"PASSED\" : \"FAILED\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    switch (hashno) {\n      case SHA1: err = SHA1Reset(0); break;\n      case SHA224: err = SHA224Reset(0); break;\n      case SHA256: err = SHA256Reset(0); break;\n      case SHA384: err = SHA384Reset(0); break;\n      case SHA512: err = SHA512Reset(0); break;\n    }\n    if (printResults == PRINTTEXT)\n       printf(\"\\nError %d. Should be %d.\\n\", err, shaNull);\n    if ((printPassFail == PRINTPASSFAIL) ||\n        ((printPassFail == PRINTFAIL) && (err != shaNull)))\n       printf(\"%s sha null: %s\\n\", hashes[hashno].name,\n        (err == shaNull) ? \"PASSED\" : \"FAILED\");\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* replace a hex string in place with its value */\nint unhexStr(char *hexstr)\n{\n  char *o = hexstr;\n  int len = 0, nibble1 = 0, nibble2 = 0;\n  if (!hexstr) return 0;\n  for ( ; *hexstr; hexstr++) {\n    if (isalpha((int)(unsigned char)(*hexstr))) {\n      nibble1 = tolower(*hexstr) - 'a' + 10;\n    } else if (isdigit((int)(unsigned char)(*hexstr))) {\n      nibble1 = *hexstr - '0';\n    } else {\n      printf(\"\\nError: bad hex character '%c'\\n\", *hexstr);\n    }\n    if (!*++hexstr) break;\n    if (isalpha((int)(unsigned char)(*hexstr))) {\n      nibble2 = tolower(*hexstr) - 'a' + 10;\n    } else if (isdigit((int)(unsigned char)(*hexstr))) {\n      nibble2 = *hexstr - '0';\n    } else {\n      printf(\"\\nError: bad hex character '%c'\\n\", *hexstr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    }\n    *o++ = (char)((nibble1 << 4) | nibble2);\n    len++;\n  }\n  return len;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "int main(int argc, char **argv)\n{\n  int i, err;\n  int loopno, loopnohigh = 1;\n  int hashno, hashnolow = 0, hashnohigh = HASHCOUNT - 1;\n  int testno, testnolow = 0, testnohigh;\n  int ntestnohigh = 0;\n  int printResults = PRINTTEXT;\n  int printPassFail = 1;\n  int checkErrors = 0;\n  char *hashstr = 0;\n  int hashlen = 0;\n  const char *resultstr = 0;\n  char *randomseedstr = 0;\n  int runHmacTests = 0;\n  char *hmacKey = 0;\n  int hmaclen = 0;\n  int randomcount = RANDOMCOUNT;\n  const char *hashfilename = 0;\n  const char *hashFilename = 0;\n  int extrabits = 0, numberExtrabits = 0;\n  int strIsHex = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "while ((i = xgetopt(argc, argv, \"b:B:ef:F:h:Hk:l:mpPr:R:s:S:t:wxX\"))\n       != -1)\n  switch (i) {\n    case 'b': extrabits = strtol(xoptarg, 0, 0); break;\n    case 'B': numberExtrabits = atoi(xoptarg); break;\n    case 'e': checkErrors = 1; break;\n    case 'f': hashfilename = xoptarg; break;\n    case 'F': hashFilename = xoptarg; break;\n    case 'h': hashnolow = hashnohigh = findhash(argv[0], xoptarg);\n      break;\n    case 'H': strIsHex = 1; break;\n    case 'k': hmacKey = xoptarg; hmaclen = strlen(xoptarg); break;\n    case 'l': loopnohigh = atoi(xoptarg); break;\n    case 'm': runHmacTests = 1; break;\n    case 'P': printPassFail = 0; break;\n    case 'p': printResults = PRINTNONE; break;\n    case 'R': randomcount = atoi(xoptarg); break;\n    case 'r': randomseedstr = xoptarg; break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "case 's': hashstr = xoptarg; hashlen = strlen(hashstr); break;\ncase 'S': resultstr = xoptarg; break;\ncase 't': testnolow = ntestnohigh = atoi(xoptarg) - 1; break;\ncase 'w': printResults = PRINTRAW; break;\ncase 'x': printResults = PRINTHEX; break;\ncase 'X': printPassFail = 2; break;\ndefault: usage(argv[0]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (strIsHex) {\n  hashlen = unhexStr(hashstr);\n  unhexStr(randomseedstr);\n  hmaclen = unhexStr(hmacKey);\n}\ntestnohigh = (ntestnohigh != 0) ? ntestnohigh:\n             runHmacTests ? (HMACTESTCOUNT-1) : (TESTCOUNT-1);\nif ((testnolow < 0) ||\n    (testnohigh >= (runHmacTests ? HMACTESTCOUNT : TESTCOUNT)) ||\n    (hashnolow < 0) || (hashnohigh >= HASHCOUNT) ||\n    (hashstr && (testnolow == testnohigh)) ||\n    (randomcount < 0) ||\n    (resultstr && (!hashstr && !hashfilename && !hashFilename)) ||\n    ((runHmacTests || hmacKey) && randomseedstr) ||\n    (hashfilename && hashFilename))\n  usage(argv[0]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/*\n *  Perform SHA/HMAC tests\n */\nfor (hashno = hashnolow; hashno <= hashnohigh; ++hashno) {\n  if (printResults == PRINTTEXT)\n    printf(\"Hash %s\\n\", hashes[hashno].name);\n  err = shaSuccess;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "for (loopno = 1; (loopno <= loopnohigh) && (err == shaSuccess);\n     ++loopno) {\n  if (hashstr)\n    err = hash(0, loopno, hashno, hashstr, hashlen, 1,\n      numberExtrabits, extrabits, (const unsigned char *)hmacKey,\n      hmaclen, resultstr, hashes[hashno].hashsize, printResults,\n      printPassFail);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "else if (randomseedstr) randomtest(hashno, randomseedstr, hashes[hashno].hashsize, 0, randomcount, printResults, printPassFail);",
      "ja": "else if (randomseedstr) randomtest(hashno, randomseedstr, hashes[hashno].hashsize, 0, randomcount, printResults, printPassFail);"
    },
    {
      "indent": 6,
      "text": "else if (hashfilename) err = hashfile(hashno, hashfilename, extrabits,",
      "ja": "else if（hashfilename）err = hashfile（hashno、hashfilename、extrabits、"
    },
    {
      "indent": 23,
      "text": "numberExtrabits, 0, (const unsigned char *)hmacKey, hmaclen, resultstr, hashes[hashno].hashsize, printResults, printPassFail);",
      "ja": "numberExtrabits, 0, (const unsigned char *)hmacKey, hmaclen, resultstr, hashes[hashno].hashsize, printResults, printPassFail);"
    },
    {
      "indent": 6,
      "text": "else if (hashFilename) err = hashfile(hashno, hashFilename, extrabits, numberExtrabits, 1, (const unsigned char *)hmacKey, hmaclen, resultstr, hashes[hashno].hashsize, printResults, printPassFail);",
      "ja": "else if (hashFilename) err = hashfile(hashno, hashFilename, extrabits, numberExtrabits, 1, (const unsigned char *)hmacKey, hmaclen, resultstr, hashes[hashno].hashsize, printResults, printPassFail);"
    },
    {
      "indent": 0,
      "text": "      else /* standard tests */ {\n        for (testno = testnolow;\n             (testno <= testnohigh) && (err == shaSuccess); ++testno) {\n          if (runHmacTests) {\n            err = hash(testno, loopno, hashno,\n                       hmachashes[testno].dataarray[hashno] ?\n                       hmachashes[testno].dataarray[hashno] :\n                       hmachashes[testno].dataarray[1] ?\n                       hmachashes[testno].dataarray[1] :\n                       hmachashes[testno].dataarray[0],\n                       hmachashes[testno].datalength[hashno] ?\n                       hmachashes[testno].datalength[hashno] :\n                       hmachashes[testno].datalength[1] ?\n                       hmachashes[testno].datalength[1] :\n                       hmachashes[testno].datalength[0],\n                       1, 0, 0,\n                       (const unsigned char *)(\n                        hmachashes[testno].keyarray[hashno] ?\n                        hmachashes[testno].keyarray[hashno] :\n                        hmachashes[testno].keyarray[1] ?\n                        hmachashes[testno].keyarray[1] :\n                        hmachashes[testno].keyarray[0]),\n                       hmachashes[testno].keylength[hashno] ?\n                       hmachashes[testno].keylength[hashno] :\n                       hmachashes[testno].keylength[1] ?\n                       hmachashes[testno].keylength[1] :\n                       hmachashes[testno].keylength[0],\n                       hmachashes[testno].resultarray[hashno],\n                       hmachashes[testno].resultlength[hashno],\n                       printResults, printPassFail);\n          } else {\n            err = hash(testno, loopno, hashno,\n                       hashes[hashno].tests[testno].testarray,\n                       hashes[hashno].tests[testno].length,\n                       hashes[hashno].tests[testno].repeatcount,\n                       hashes[hashno].tests[testno].numberExtrabits,\n                       hashes[hashno].tests[testno].extrabits, 0, 0,\n                       hashes[hashno].tests[testno].resultarray,\n                       hashes[hashno].hashsize,\n                       printResults, printPassFail);\n          }\n        }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "      if (!runHmacTests) {\n        randomtest(hashno, hashes[hashno].randomtest,\n          hashes[hashno].hashsize, hashes[hashno].randomresults,\n          RANDOMCOUNT, printResults, printPassFail);\n      }\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* Test some error returns */\nif (checkErrors) {\n  testErrors(hashnolow, hashnohigh, printResults, printPassFail);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * Compare two strings, case independently.\n * Equivalent to strcasecmp() found on some systems.\n */\nint scasecmp(const char *s1, const char *s2)\n{\n  for (;;) {\n    char u1 = tolower(*s1++);\n    char u2 = tolower(*s2++);\n    if (u1 != u2)\n      return u1 - u2;\n    if (u1 == '\\0')\n      return 0;\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*\n * This is a copy of getopt provided for those systems that do not\n * have it. The name was changed to xgetopt to not conflict on those\n * systems that do have it. Similarly, optarg, optind and opterr\n * were renamed to xoptarg, xoptind and xopterr.\n *\n * Copyright 1990, 1991, 1992 by the Massachusetts Institute of\n * Technology and UniSoft Group Limited.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "*\n* Permission to use, copy, modify, distribute, and sell this software\n* and its documentation for any purpose is hereby granted without fee,\n* provided that the above copyright notice appear in all copies and\n* that both that copyright notice and this permission notice appear in\n* supporting documentation, and that the names of MIT and UniSoft not\n* be used in advertising or publicity pertaining to distribution of\n* the software without specific, written prior permission.  MIT and\n* UniSoft make no representations about the suitability of this\n* software for any purpose.  It is provided \"as is\" without express\n* or implied warranty.\n*\n* $XConsortium: getopt.c,v 1.2 92/07/01 11:59:04 rws Exp $\n* NB: Reformatted to match above style.\n*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "char    *xoptarg;\nint     xoptind = 1;\nint     xopterr = 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static int xgetopt(int argc, char **argv, const char *optstring)\n{\n  static int avplace;\n  char    *ap;\n  char    *cp;\n  int     c;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (xoptind >= argc) return EOF;",
      "ja": "if（xoptind> = argc）はEOFを返します。"
    },
    {
      "indent": 2,
      "text": "ap = argv[xoptind] + avplace;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* At beginning of arg but not an option */\nif (avplace == 0) {\n  if (ap[0] != '-')\n    return EOF;\n  else if (ap[1] == '-') {\n    /* Special end of options option */\n    xoptind++;\n    return EOF;\n  } else if (ap[1] == '\\0')\n    return EOF;  /* single '-' is not allowed */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* Get next letter */\navplace++;\nc = *++ap;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "cp = strchr(optstring, c);\nif (cp == NULL || c == ':') {\n  if (xopterr)\n    fprintf(stderr, \"Unrecognised option -- %c\\n\", c);\n  return '?';\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (cp[1] == ':') {\n  /* There should be an option arg */\n  avplace = 0;\n  if (ap[1] == '\\0') {\n    /* It is a separate arg */\n    if (++xoptind >= argc) {\n      if (xopterr)\n        fprintf(stderr, \"Option requires an argument\\n\");\n      return '?';\n    }\n    xoptarg = argv[xoptind++];\n  } else {\n    /* is attached to option letter */\n    xoptarg = ap + 1;\n    ++xoptind;\n  }\n} else {\n  /* If we are out of letters then go to next arg */\n  if (ap[1] == '\\0') {\n    ++xoptind;\n    avplace = 0;\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "    xoptarg = NULL;\n  }\n  return c;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document is intended to provides the Internet community convenient access to source code that implements the United States of America Federal Information Processing Standard Secure Hash Algorithms (SHAs) [FIPS180-2] and HMACs based upon these one-way hash functions. See license in Section 1.1. No independent assertion of the security of this hash function by the authors for any particular use is intended.",
      "ja": "このドキュメントは、これらの一方向ハッシュ関数に基づく米国連邦情報処理標準のセキュアハッシュアルゴリズム（SHA）[FIPS180-2]およびHMACを実装するソースコードへのインターネットコミュニティへの便利なアクセスを提供することを目的としています。セクション1.1のライセンスを参照してください。作成者による特定の使用のためのこのハッシュ関数のセキュリティの独立した主張は意図されていません。"
    },
    {
      "indent": 0,
      "text": "10. Normative References",
      "section_title": true,
      "ja": "10. 引用文献"
    },
    {
      "indent": 3,
      "text": "[FIPS180-2] \"Secure Hash Standard\", United States of America, National Institute of Standards and Technology, Federal Information Processing Standard (FIPS) 180-2, http://csrc.nist.gov/publications/fips/fips180-2/ fips180-2withchangenotice.pdf.",
      "ja": "[FIPS180-2]「Secure Hash Standard」、アメリカ合衆国、米国連邦情報・技術局、連邦情報処理標準（FIPS）180-2、http：//csrc.nist.gov/publications/fips/fips180- 2 / fips180-2withchangenotice.pdf。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。"
    },
    {
      "indent": 0,
      "text": "11. Informative References",
      "section_title": true,
      "ja": "11. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC2202] Cheng, P. and R. Glenn, \"Test Cases for HMAC-MD5 and HMAC-SHA-1\", RFC 2202, September 1997.",
      "ja": "[RFC2202] Cheng、P。およびR. Glenn、「HMAC-MD5およびHMAC-SHA-1のテストケース」、RFC 2202、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3174] Eastlake 3rd, D. and P. Jones, \"US Secure Hash Algorithm 1 (SHA1)\", RFC 3174, September 2001.",
      "ja": "[RFC3174] Eastlake 3rd、D。およびP. Jones、「US Secure Hash Algorithm 1（SHA1）」、RFC 3174、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3874] Housley, R., \"A 224-bit One-way Hash Function: SHA-224\", RFC 3874, September 2004.",
      "ja": "[RFC3874] Housley, R., \"A 224-bit One-way Hash Function: SHA-224\", RFC 3874, September 2004."
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4231] Nystrom, M., \"Identifiers and Test Vectors for HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\", RFC 4231, December 2005.",
      "ja": "[RFC4231] Nystrom、M。、「HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、およびHMAC-SHA-512の識別子とテストベクトル」、RFC 4231、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[SHAVS] \"The Secure Hash Algorithm Validation System (SHAVS)\", http://csrc.nist.gov/cryptval/shs/SHAVS.pdf.",
      "ja": "[SHAVS]「セキュアハッシュアルゴリズム検証システム（SHAVS）」、http：//csrc.nist.gov/cryptval/shs/SHAVS.pdf。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Donald E. Eastlake, 3rd Motorola Laboratories 155 Beaver Street Milford, MA 01757 USA",
      "ja": "ドナルドE.イーストレイク、第3モトローラ研究所155 Beaver Street Milford、MA 01757 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-508-786-7554 (w)\nEMail: donald.eastlake@motorola.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tony Hansen AT&T Laboratories 200 Laurel Ave. Middletown, NJ 07748 USA",
      "ja": "Tony Hansen AT＆T Laboratories 200 Laurel Ave. Middletown、NJ 07748 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-732-420-8934 (w)\nEMail: tony+shs@maillennium.att.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（C）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人、または組織（ある場合）、インターネットエンジニアリングおよびインターネットエンジニアリングタスクフォースは、すべての保証を明示的または明示的に後援します。ここに含まれる情報の使用により、商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害されないという保証を含みますが、これに限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません。利用できる;また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に対して行われたIPR開示のコピー、および使用可能にされるライセンスの保証、または一般ライセンスを取得する試みの結果、またはこの仕様の実装者またはユーザーがそのような所有権を使用するための許可を取得できるhttp://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA)."
    }
  ]
}