{
  "title": {
    "text": "RFC 5246 - The Transport Layer Security (TLS) Protocol Version 1.2",
    "ja": "RFC 5246 - トランスポート層セキュリティ（TLS）プロトコルバージョン1.2"
  },
  "number": 5246,
  "created_at": "2020-08-14 20:52:57.866610+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          T. Dierks\nRequest for Comments: 5246                                   Independent\nObsoletes: 3268, 4346, 4366                                  E. Rescorla\nUpdates: 4492                                                 RTFM, Inc.\nCategory: Standards Track                                    August 2008",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "The Transport Layer Security (TLS) Protocol Version 1.2",
      "ja": "トランスポート層セキュリティ（TLS）プロトコルバージョン1.2"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を求めます。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.",
      "ja": "このドキュメントは、Transport Layer Security（TLS）プロトコルのバージョン1.2を規定しています。 TLSプロトコルは、インターネット上の通信セキュリティを提供します。このプロトコルにより、クライアント/サーバーアプリケーションは、盗聴、改ざん、またはメッセージの偽造を防止するように設計された方法で通信できます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Requirements Terminology ...................................5\n   1.2. Major Differences from TLS 1.1 .............................5\n2. Goals ...........................................................6\n3. Goals of This Document ..........................................7\n4. Presentation Language ...........................................7\n   4.1. Basic Block Size ...........................................7\n   4.2. Miscellaneous ..............................................8\n   4.3. Vectors ....................................................8\n   4.4. Numbers ....................................................9\n   4.5. Enumerateds ................................................9\n   4.6. Constructed Types .........................................10\n        4.6.1. Variants ...........................................10\n   4.7. Cryptographic Attributes ..................................12\n   4.8. Constants .................................................14\n5. HMAC and the Pseudorandom Function .............................14\n6. The TLS Record Protocol ........................................15\n   6.1. Connection States .........................................16\n   6.2. Record Layer ..............................................19\n        6.2.1. Fragmentation ......................................19",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        6.2.2. Record Compression and Decompression ...............20\n        6.2.3. Record Payload Protection ..........................21\n               6.2.3.1. Null or Standard Stream Cipher ............22\n               6.2.3.2. CBC Block Cipher ..........................22\n               6.2.3.3. AEAD Ciphers ..............................24\n   6.3. Key Calculation ...........................................25\n7. The TLS Handshaking Protocols ..................................26\n   7.1. Change Cipher Spec Protocol ...............................27\n   7.2. Alert Protocol ............................................28\n        7.2.1. Closure Alerts .....................................29\n        7.2.2. Error Alerts .......................................30\n   7.3. Handshake Protocol Overview ...............................33\n   7.4. Handshake Protocol ........................................37\n        7.4.1. Hello Messages .....................................38\n               7.4.1.1. Hello Request .............................38\n               7.4.1.2. Client Hello ..............................39\n               7.4.1.3. Server Hello ..............................42\n               7.4.1.4. Hello Extensions ..........................44\n                        7.4.1.4.1. Signature Algorithms ...........45\n        7.4.2. Server Certificate .................................47\n        7.4.3. Server Key Exchange Message ........................50\n        7.4.4. Certificate Request ................................53\n        7.4.5. Server Hello Done ..................................55\n        7.4.6. Client Certificate .................................55\n        7.4.7. Client Key Exchange Message ........................57\n               7.4.7.1. RSA-Encrypted Premaster Secret Message ....58\n               7.4.7.2. Client Diffie-Hellman Public Value ........61\n        7.4.8. Certificate Verify .................................62\n        7.4.9. Finished ...........................................63\n8. Cryptographic Computations .....................................64\n   8.1. Computing the Master Secret ...............................64\n        8.1.1. RSA ................................................65\n        8.1.2. Diffie-Hellman .....................................65\n9. Mandatory Cipher Suites ........................................65\n10. Application Data Protocol .....................................65\n11. Security Considerations .......................................65\n12. IANA Considerations ...........................................65\nAppendix A. Protocol Data Structures and Constant Values ..........68\n   A.1. Record Layer ..............................................68\n   A.2. Change Cipher Specs Message ...............................69\n   A.3. Alert Messages ............................................69\n   A.4. Handshake Protocol ........................................70\n        A.4.1. Hello Messages .....................................71\n        A.4.2. Server Authentication and Key Exchange Messages ....72\n        A.4.3. Client Authentication and Key Exchange Messages ....74\n        A.4.4. Handshake Finalization Message .....................74\n   A.5. The Cipher Suite ..........................................75\n   A.6. The Security Parameters ...................................77",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   A.7. Changes to RFC 4492 .......................................78\nAppendix B. Glossary ..............................................78\nAppendix C. Cipher Suite Definitions ..............................83\nAppendix D. Implementation Notes ..................................85\n   D.1. Random Number Generation and Seeding ......................85\n   D.2. Certificates and Authentication ...........................85\n   D.3. Cipher Suites .............................................85\n   D.4. Implementation Pitfalls ...................................85\nAppendix E. Backward Compatibility ................................87\n   E.1. Compatibility with TLS 1.0/1.1 and SSL 3.0 ................87\n   E.2. Compatibility with SSL 2.0 ................................88\n   E.3. Avoiding Man-in-the-Middle Version Rollback ...............90\nAppendix F. Security Analysis .....................................91\n   F.1. Handshake Protocol ........................................91\n        F.1.1. Authentication and Key Exchange ....................91\n               F.1.1.1. Anonymous Key Exchange ....................91\n               F.1.1.2. RSA Key Exchange and Authentication .......92\n               F.1.1.3. Diffie-Hellman Key Exchange with\n                        Authentication ............................92\n        F.1.2. Version Rollback Attacks ...........................93\n        F.1.3. Detecting Attacks Against the Handshake Protocol ...94\n        F.1.4. Resuming Sessions ..................................94\n   F.2. Protecting Application Data ...............................94\n   F.3. Explicit IVs ..............................................95\n   F.4. Security of Composite Cipher Modes ........................95\n   F.5. Denial of Service .........................................96\n   F.6. Final Notes ...............................................96\nNormative References ..............................................97\nInformative References ............................................98\nWorking Group Information ........................................101\nContributors .....................................................101",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The primary goal of the TLS protocol is to provide privacy and data integrity between two communicating applications. The protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP [TCP]), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:",
      "ja": "TLSプロトコルの主な目的は、2つの通信アプリケーション間でプライバシーとデータの整合性を提供することです。このプロトコルは、TLSレコードプロトコルとTLSハンドシェイクプロトコルの2つの層で構成されています。ある信頼性のあるトランスポートプロトコル（TCP [TCP]など）の上に階層化された最下位レベルにあるのが、TLSレコードプロトコルです。TLSレコードプロトコルは、2つの基本的なプロパティを持つ接続セキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "- The connection is private. Symmetric cryptography is used for data encryption (e.g., AES [AES], RC4 [SCH], etc.). The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another protocol (such as the TLS Handshake Protocol). The Record Protocol can also be used without encryption.",
      "ja": "- 接続はプライベートです。対称暗号化は、データの暗号化に使用されます（AES [AES]、RC4 [SCH]など）。この対称暗号化のキーは、接続ごとに一意に生成され、別のプロトコル（TLSハンドシェイクプロトコルなど）によってネゴシエートされた秘密に基づいています。レコードプロトコルは暗号化せずに使用することもできます。"
    },
    {
      "indent": 3,
      "text": "- The connection is reliable. Message transport includes a message integrity check using a keyed MAC. Secure hash functions (e.g., SHA-1, etc.) are used for MAC computations. The Record Protocol can operate without a MAC, but is generally only used in this mode while another protocol is using the Record Protocol as a transport for negotiating security parameters.",
      "ja": "- 接続は信頼できます。メッセージ転送には、キー付きMACを使用したメッセージ整合性チェックが含まれます。安全なハッシュ関数（SHA-1など）がMAC計算に使用されます。 Record ProtocolはMACなしで動作できますが、通常、別のプロトコルがセキュリティパラメータをネゴシエートするためのトランスポートとしてRecord Protocolを使用している間のみ、このモードで使用されます。"
    },
    {
      "indent": 3,
      "text": "The TLS Record Protocol is used for encapsulation of various higher-level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:",
      "ja": "TLS Record Protocolは、さまざまな上位プロトコルのカプセル化に使用されます。このようなカプセル化されたプロトコルの1つであるTLSハンドシェイクプロトコルを使用すると、サーバーとクライアントは相互に認証し、アプリケーションプロトコルがデータの最初のバイトを送信または受信する前に、暗号化アルゴリズムと暗号化キーをネゴシエートできます。 TLSハンドシェイクプロトコルは、3つの基本的なプロパティを持つ接続セキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "- The peer's identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA [RSA], DSA [DSS], etc.). This authentication can be made optional, but is generally required for at least one of the peers.",
      "ja": "- ピアのIDは、非対称または公開キー暗号化（RSA [RSA]、DSA [DSS]など）を使用して認証できます。この認証はオプションにすることができますが、通常、少なくとも1つのピアに必要です。"
    },
    {
      "indent": 3,
      "text": "- The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.",
      "ja": "- 共有シークレットのネゴシエーションは安全です。ネゴシエートされたシークレットは盗聴者が利用できません。認証された接続では、接続の真ん中に攻撃者が侵入してもシークレットを取得できません。"
    },
    {
      "indent": 3,
      "text": "- The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.",
      "ja": "- ネゴシエーションは信頼できます。通信の当事者によって検出されることなく、攻撃者がネゴシエーション通信を変更することはできません。"
    },
    {
      "indent": 3,
      "text": "One advantage of TLS is that it is application protocol independent. Higher-level protocols can layer on top of the TLS protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left to the judgment of the designers and implementors of protocols that run on top of TLS.",
      "ja": "TLSの1つの利点は、TLSがアプリケーションプロトコルに依存しないことです。上位レベルのプロトコルは、TLSプロトコルの上に透過的に階層化できます。ただし、TLS標準では、プロトコルがTLSでセキュリティを追加する方法は指定されていません。 TLSハンドシェイクの開始方法と交換される認証証明書の解釈方法の決定は、TLSの上で実行されるプロトコルの設計者と実装者の判断に委ねられます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Terminology",
      "section_title": true,
      "ja": "1.1. 要件の用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [REQ].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [REQ]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Major Differences from TLS 1.1",
      "section_title": true,
      "ja": "1.2. TLS 1.1との主な違い"
    },
    {
      "indent": 3,
      "text": "This document is a revision of the TLS 1.1 [TLS1.1] protocol which contains improved flexibility, particularly for negotiation of cryptographic algorithms. The major changes are:",
      "ja": "このドキュメントはTLS 1.1 [TLS1.1]プロトコルの改訂版であり、特に暗号化アルゴリズムのネゴシエーションのために柔軟性が向上しています。主な変更点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "- The MD5/SHA-1 combination in the pseudorandom function (PRF) has been replaced with cipher-suite-specified PRFs. All cipher suites in this document use P_SHA256.",
      "ja": "- 疑似ランダム関数（PRF）のMD5 / SHA-1の組み合わせは、暗号スイート指定のPRFに置き換えられました。このドキュメントのすべての暗号スイートはP_SHA256を使用します。"
    },
    {
      "indent": 3,
      "text": "- The MD5/SHA-1 combination in the digitally-signed element has been replaced with a single hash. Signed elements now include a field that explicitly specifies the hash algorithm used.",
      "ja": "- デジタル署名された要素のMD5 / SHA-1の組み合わせは、単一のハッシュに置き換えられました。署名された要素には、使用されるハッシュアルゴリズムを明示的に指定するフィールドが含まれるようになりました。"
    },
    {
      "indent": 3,
      "text": "- Substantial cleanup to the client's and server's ability to specify which hash and signature algorithms they will accept. Note that this also relaxes some of the constraints on signature and hash algorithms from previous versions of TLS.",
      "ja": "- クライアントおよびサーバーが受け入れるハッシュおよび署名アルゴリズムを指定する機能の実質的なクリーンアップ。これにより、以前のバージョンのTLSの署名アルゴリズムとハッシュアルゴリズムに対する制約の一部も緩和されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "- Addition of support for authenticated encryption with additional data modes.",
      "ja": "- 追加のデータモードでの認証済み暗号化のサポートの追加。"
    },
    {
      "indent": 3,
      "text": "- TLS Extensions definition and AES Cipher Suites were merged in from external [TLSEXT] and [TLSAES].",
      "ja": "- TLS拡張定義とAES暗号スイートは、外部の[TLSEXT]と[TLSAES]から統合されました。"
    },
    {
      "indent": 3,
      "text": "- Tighter checking of EncryptedPreMasterSecret version numbers.",
      "ja": "- EncryptedPreMasterSecretのバージョン番号の厳密なチェック。"
    },
    {
      "indent": 3,
      "text": "- Tightened up a number of requirements.",
      "ja": "- 多くの要件を厳しくしました。"
    },
    {
      "indent": 3,
      "text": "- Verify_data length now depends on the cipher suite (default is still 12).",
      "ja": "- Verify_dataの長さは暗号スイートに依存するようになりました（デフォルトは12のままです）。"
    },
    {
      "indent": 3,
      "text": "- Cleaned up description of Bleichenbacher/Klima attack defenses.",
      "ja": "- ブライヘンバッハー/クリマ攻撃防御の説明をクリーンアップ。"
    },
    {
      "indent": 3,
      "text": "- Alerts MUST now be sent in many cases.",
      "ja": "- 多くの場合、アラートを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "- After a certificate_request, if no certificates are available, clients now MUST send an empty certificate list.",
      "ja": "- certificate_requestの後で、利用できる証明書がない場合、クライアントは空の証明書リストを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "- TLS_RSA_WITH_AES_128_CBC_SHA is now the mandatory to implement cipher suite.",
      "ja": "- TLS_RSA_WITH_AES_128_CBC_SHAは、暗号スイートの実装に必須になりました。"
    },
    {
      "indent": 3,
      "text": "- Added HMAC-SHA256 cipher suites.",
      "ja": "- HMAC-SHA256暗号スイートが追加されました。"
    },
    {
      "indent": 3,
      "text": "- Removed IDEA and DES cipher suites. They are now deprecated and will be documented in a separate document.",
      "ja": "- IDEAおよびDES暗号スイートを削除しました。現在は非推奨であり、別のドキュメントに記載される予定です。"
    },
    {
      "indent": 3,
      "text": "- Support for the SSLv2 backward-compatible hello is now a MAY, not a SHOULD, with sending it a SHOULD NOT. Support will probably become a SHOULD NOT in the future.",
      "ja": "- SSLv2下位互換性のあるHelloのサポートは、SHOULDではなくMAYになりました。また、送信することはSHOULD NOTになりました。将来的にはサポートもおそらくSHOULD NOTになるでしょう。"
    },
    {
      "indent": 3,
      "text": "- Added limited \"fall-through\" to the presentation language to allow multiple case arms to have the same encoding.",
      "ja": "- プレゼンテーション言語に制限付きの「フォールスルー」を追加して、複数のケースアームで同じエンコーディングを使用できるようにしました。"
    },
    {
      "indent": 3,
      "text": "- Added an Implementation Pitfalls sections",
      "ja": "- 実装の落とし穴セクションを追加"
    },
    {
      "indent": 3,
      "text": "- The usual clarifications and editorial work.",
      "ja": "- 通常の説明と編集作業。"
    },
    {
      "indent": 0,
      "text": "2. Goals",
      "section_title": true,
      "ja": "2. ゴール"
    },
    {
      "indent": 3,
      "text": "The goals of the TLS protocol, in order of priority, are as follows:",
      "ja": "TLSプロトコルの目標は、優先度順に、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Cryptographic security: TLS should be used to establish a secure connection between two parties.",
      "ja": "1. 暗号化セキュリティ：TLSを使用して、2者間の安全な接続を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. Interoperability: Independent programmers should be able to develop applications utilizing TLS that can successfully exchange cryptographic parameters without knowledge of one another's code.",
      "ja": "2. 相互運用性：独立したプログラマーは、お互いのコードを知らなくても暗号パラメーターを正常に交換できるTLSを利用したアプリケーションを開発できるはずです。"
    },
    {
      "indent": 3,
      "text": "3. Extensibility: TLS seeks to provide a framework into which new public key and bulk encryption methods can be incorporated as necessary. This will also accomplish two sub-goals: preventing the need to create a new protocol (and risking the introduction of possible new weaknesses) and avoiding the need to implement an entire new security library.",
      "ja": "3. 拡張性：TLSは、必要に応じて新しい公開鍵とバルク暗号化方式を組み込むことができるフレームワークを提供しようとしています。これはまた、2つのサブゴールを達成します。新しいプロトコルを作成する必要をなくし（そして考えられる新しい弱点の導入を危険にさらす）、新しいセキュリティライブラリ全体を実装する必要を回避します。"
    },
    {
      "indent": 3,
      "text": "4. Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.",
      "ja": "4. 相対的な効率：暗号化操作は、CPUを集中的に使用する傾向があり、特に公開鍵の操作です。このため、TLSプロトコルにはオプションのセッションキャッシングスキームが組み込まれており、最初から確立する必要のある接続の数を減らすことができます。さらに、ネットワークアクティビティを減らすように注意が払われています。"
    },
    {
      "indent": 0,
      "text": "3. Goals of This Document",
      "section_title": true,
      "ja": "3. このドキュメントの目的"
    },
    {
      "indent": 3,
      "text": "This document and the TLS protocol itself are based on the SSL 3.0 Protocol Specification as published by Netscape. The differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that the various versions of TLS and SSL 3.0 do not interoperate (although each protocol incorporates a mechanism by which an implementation can back down to prior versions). This document is intended primarily for readers who will be implementing the protocol and for those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.",
      "ja": "このドキュメントとTLSプロトコル自体は、Netscapeによって発行されたSSL 3.0プロトコル仕様に基づいています。このプロトコルとSSL 3.0の違いは劇的ではありませんが、TLSとSSL 3.0のさまざまなバージョンが相互運用できないほど重要です（ただし、各プロトコルには、実装が以前のバージョンに戻るメカニズムが組み込まれています）。このドキュメントは、主にプロトコルを実装する読者、およびプロトコルの暗号分析を行う読者を対象としています。仕様はこれを念頭に置いて作成されており、2つのグループのニーズを反映することを目的としています。そのため、アルゴリズムに依存するデータ構造とルールの多くが（付録ではなく）テキストの本文に含まれ、それらに簡単にアクセスできます。"
    },
    {
      "indent": 3,
      "text": "This document is not intended to supply any details of service definition or of interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.",
      "ja": "このドキュメントは、サービス定義またはインターフェイス定義の詳細を提供することを意図していませんが、堅固なセキュリティの維持に必要なポリシーの特定の領域をカバーしています。"
    },
    {
      "indent": 0,
      "text": "4. Presentation Language",
      "section_title": true,
      "ja": "4. プレゼンテーション言語"
    },
    {
      "indent": 3,
      "text": "This document deals with the formatting of data in an external representation. The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language \"C\" in its syntax and XDR [XDR] in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only; it has no general application beyond that particular goal.",
      "ja": "このドキュメントでは、外部表現でのデータのフォーマットを扱います。次の非常に基本的で、ややカジュアルに定義されたプレゼンテーション構文が使用されます。構文は、その構造のいくつかのソースから引き出されます。構文はプログラミング言語「C」に似ており、構文も意図もXDR [XDR]に似ていますが、あまりにも多くの類似点を描くのは危険です。このプレゼンテーション言語の目的は、TLSのみを文書化することです。その特定の目標を超える一般的な用途はありません。"
    },
    {
      "indent": 0,
      "text": "4.1. Basic Block Size",
      "section_title": true,
      "ja": "4.1. 基本ブロックサイズ"
    },
    {
      "indent": 3,
      "text": "The representation of all data items is explicitly specified. The basic data block size is one byte (i.e., 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the byte stream, a multi-byte item (a numeric in the example) is formed (using C notation) by:",
      "ja": "すべてのデータ項目の表現は明示的に指定されています。基本的なデータブロックサイズは1バイト（8ビット）です。複数バイトのデータ項目は、左から右、上から下へのバイトの連結です。バイトストリームから、マルチバイトアイテム（この例では数値）は（C表記を使用して）次のように形成されます。"
    },
    {
      "indent": 6,
      "text": "value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |\n        ... | byte[n-1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This byte ordering for multi-byte values is the commonplace network byte order or big-endian format.",
      "ja": "このマルチバイト値のバイト順序は、一般的なネットワークバイト順序またはビッグエンディアン形式です。"
    },
    {
      "indent": 0,
      "text": "4.2. Miscellaneous",
      "section_title": true,
      "ja": "4.2. 雑多"
    },
    {
      "indent": 3,
      "text": "Comments begin with \"/*\" and end with \"*/\".",
      "ja": "コメントは「/ *」で始まり、「* /」で終わります。"
    },
    {
      "indent": 3,
      "text": "Optional components are denoted by enclosing them in \"[[ ]]\" double brackets.",
      "ja": "オプションのコンポーネントは、 \"[[]]\"の二重括弧で囲んで示されます。"
    },
    {
      "indent": 3,
      "text": "Single-byte entities containing uninterpreted data are of type opaque.",
      "ja": "未解釈のデータを含むシングルバイトエンティティは、不透明タイプです。"
    },
    {
      "indent": 0,
      "text": "4.3. Vectors",
      "section_title": true,
      "ja": "4.3. ベクタ"
    },
    {
      "indent": 3,
      "text": "A vector (single-dimensioned array) is a stream of homogeneous data elements. The size of the vector may be specified at documentation time or left unspecified until runtime. In either case, the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type, T', that is a fixed-length vector of type T is",
      "ja": "ベクトル（1次元配列）は、同種のデータ要素のストリームです。ベクトルのサイズは、ドキュメント化時に指定するか、実行時まで指定しないでおくことができます。どちらの場合も、長さはベクトルの要素数ではなくバイト数を宣言します。 T型の固定長ベクトルである新しい型T 'を指定する構文は、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "T T'[n];",
      "ja": "T T '[n];"
    },
    {
      "indent": 3,
      "text": "Here, T' occupies n bytes in the data stream, where n is a multiple of the size of T. The length of the vector is not included in the encoded stream.",
      "ja": "ここで、T 'はデータストリームのnバイトを占めます。nはTのサイズの倍数です。ベクトルの長さは、エンコードされたストリームには含まれません。"
    },
    {
      "indent": 3,
      "text": "In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.",
      "ja": "次の例では、Datumはプロトコルが解釈しない3つの連続したバイトとして定義されていますが、Dataは3つの連続したDatumであり、合計9バイトを消費します。"
    },
    {
      "indent": 6,
      "text": "opaque Datum[3];      /* three uninterpreted bytes */\nDatum Data[9];        /* 3 consecutive 3 byte vectors */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Variable-length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation <floor..ceiling>. When these are encoded, the actual length precedes the vector's contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector's specified maximum (ceiling) length. A variable-length vector with an actual length field of zero is referred to as an empty vector.",
      "ja": "可変長ベクトルは、表記<floor..ceiling>を使用して、有効な長さの部分範囲を包括的に指定することによって定義されます。これらがエンコードされると、実際の長さはバイトストリーム内のベクトルの内容に先行します。長さは、ベクターの指定された最大（天井）長さを保持するために必要なバイト数を消費する数の形式になります。実際の長さがゼロの可変長ベクトルは、空のベクトルと呼ばれます。"
    },
    {
      "indent": 6,
      "text": "T T'<floor..ceiling>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, which is sufficient to represent the value 400 (see Section 4.4). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two-byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17-byte vector of uint16 would be illegal).",
      "ja": "次の例では、必須は、不透明なタイプの300〜400バイトを含む必要があるベクトルです。空にすることはできません。実際の長さフィールドは、値400を表すのに十分なuint16の2バイトを消費します（セクション4.4を参照）。一方、longerは最大800バイトのデータ、または400 uint16要素を表すことができ、空の場合があります。そのエンコードには、ベクターの前に付加される2バイトの実際の長さフィールドが含まれます。エンコードされたベクトルの長さは、単一の要素の長さの偶数倍でなければなりません（たとえば、uint16の17バイトのベクトルは不正です）。"
    },
    {
      "indent": 6,
      "text": "opaque mandatory<300..400>;\n      /* length field is 2 bytes, cannot be empty */\nuint16 longer<0..800>;\n      /* zero to 400 16-bit unsigned integers */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4. Numbers",
      "section_title": true,
      "ja": "4.4. 数字"
    },
    {
      "indent": 3,
      "text": "The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed-length series of bytes concatenated as described in Section 4.1 and are also unsigned. The following numeric types are predefined.",
      "ja": "基本的な数値データ型は、符号なしバイト（uint8）です。より大きな数値データ型はすべて、セクション4.1で説明されているように連結された固定長の一連のバイトから形成され、これも符号なしです。次の数値タイプが事前定義されています。"
    },
    {
      "indent": 6,
      "text": "uint8 uint16[2];\nuint8 uint24[3];\nuint8 uint32[4];\nuint8 uint64[8];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "All values, here and elsewhere in the specification, are stored in network byte (big-endian) order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.",
      "ja": "仕様のここや他の場所にあるすべての値は、ネットワークバイト（ビッグエンディアン）順序で格納されます。 16進バイト01 02 03 04で表されるuint32は、10進値16909060と同等です。"
    },
    {
      "indent": 3,
      "text": "Note that in some cases (e.g., DH parameters) it is necessary to represent integers as opaque vectors. In such cases, they are represented as unsigned integers (i.e., leading zero octets are not required even if the most significant bit is set).",
      "ja": "場合によっては（DHパラメータなど）、整数を不透明なベクトルとして表す必要があることに注意してください。そのような場合、それらは符号なし整数として表されます（つまり、最上位ビットが設定されていても、先行ゼロオクテットは必要ありません）。"
    },
    {
      "indent": 0,
      "text": "4.5. Enumerateds",
      "section_title": true,
      "ja": "4.5. 列挙型"
    },
    {
      "indent": 3,
      "text": "An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared. Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.",
      "ja": "enumと呼ばれる追加のスパースデータタイプを使用できます。 enum型のフィールドは、定義で宣言された値のみを想定できます。各定義は異なるタイプです。同じタイプの列挙型のみを割り当てたり、比較したりできます。次の例に示すように、列挙型のすべての要素に値を割り当てる必要があります。列挙型の要素は順序付けされていないため、一意の値を任意の順序で割り当てることができます。"
    },
    {
      "indent": 6,
      "text": "enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An enumerated occupies as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.",
      "ja": "列挙型は、バイトストリーム内で定義されている最大の序数値と同じだけのスペースを占有します。次の定義では、1バイトを使用してColorタイプのフィールドを伝送します。"
    },
    {
      "indent": 6,
      "text": "enum { red(3), blue(5), white(7) } Color;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element.",
      "ja": "オプションで、関連するタグなしで値を指定して、余分な要素を定義せずに幅の定義を強制できます。"
    },
    {
      "indent": 3,
      "text": "In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2, or 4.",
      "ja": "次の例では、Tasteはデータストリームで2バイトを消費しますが、1、2、または4の値しか想定できません。"
    },
    {
      "indent": 6,
      "text": "enum { sweet(1), sour(2), bitter(4), (32000) } Taste;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The names of the elements of an enumeration are scoped within the defined type. In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.",
      "ja": "列挙型の要素の名前は、定義された型内でスコープされます。最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueになります。割り当てのターゲットが明確に指定されている場合、そのような修飾は必要ありません。"
    },
    {
      "indent": 6,
      "text": "Color color = Color.blue;     /* overspecified, legal */\nColor color = blue;           /* correct, type implicit */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For enumerateds that are never converted to external representation, the numerical information may be omitted.",
      "ja": "外部表現に変換されない列挙型の場合、数値情報は省略できます。"
    },
    {
      "indent": 6,
      "text": "enum { low, medium, high } Amount;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6. Constructed Types",
      "section_title": true,
      "ja": "4.6. 構築された型"
    },
    {
      "indent": 3,
      "text": "Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.",
      "ja": "構造型は、便宜上、プリミティブ型から構築できます。各仕様は、新しい一意の型を宣言します。定義の構文はCの構文によく似ています。"
    },
    {
      "indent": 6,
      "text": "struct {\n    T1 f1;\n    T2 f2;\n    ...\n    Tn fn;\n} [[T]];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields within a structure may be qualified using the type's name, with a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.",
      "ja": "構造体内のフィールドは、列挙型で使用できる構文とよく似た構文で、型の名前を使用して修飾できます。たとえば、T.f2は前の宣言の2番目のフィールドを参照します。構造定義を埋め込むことができます。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Variants",
      "section_title": true,
      "ja": "4.6.1. バリアント"
    },
    {
      "indent": 3,
      "text": "Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. Case arms have limited fall-through: if two case arms follow in immediate succession with no fields in between, then they both contain the same fields. Thus, in the example below, \"orange\" and \"banana\" both contain V2. Note that this is a new piece of syntax in TLS 1.2.",
      "ja": "定義された構造には、環境内で利用可能ないくつかの知識に基づいたバリアントがある場合があります。セレクターは、構造が定義する可能なバリアントを定義する列挙型である必要があります。 selectで宣言された列挙のすべての要素にケースアームが必要です。ケースアームのフォールスルーは限られています。2つのケースアームが間にフィールドがない状態で連続して続く場合、両方に同じフィールドが含まれます。したがって、以下の例では、「オレンジ」と「バナナ」の両方にV2が含まれています。これはTLS 1.2の新しい構文であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.",
      "ja": "バリアント構造の本体には、参照用のラベルを付けることができます。実行時にバリアントが選択されるメカニズムは、プレゼンテーション言語では規定されていません。"
    },
    {
      "indent": 6,
      "text": "struct {\n    T1 f1;\n    T2 f2;\n    ....\n    Tn fn;\n     select (E) {\n         case e1: Te1;\n         case e2: Te2;\n         case e3: case e4: Te3;\n         ....\n         case en: Ten;\n     } [[fv]];\n} [[Tv]];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 6,
      "text": "enum { apple, orange, banana } VariantTag;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    uint16 number;\n    opaque string<0..10>; /* variable length */\n} V1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    uint32 number;\n    opaque string[10];    /* fixed length */\n} V2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    select (VariantTag) { /* value of selector is implicit */\n        case apple:\n          V1;   /* VariantBody, tag = apple */\n        case orange:\n        case banana:\n          V2;   /* VariantBody, tag = orange or banana */\n    } variant_body;       /* optional label on variant */\n} VariantRecord;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.7. Cryptographic Attributes",
      "section_title": true,
      "ja": "4.7. 暗号化属性"
    },
    {
      "indent": 3,
      "text": "The five cryptographic operations -- digital signing, stream cipher encryption, block cipher encryption, authenticated encryption with additional data (AEAD) encryption, and public key encryption -- are designated digitally-signed, stream-ciphered, block-ciphered, aead-ciphered, and public-key-encrypted, respectively. A field's cryptographic processing is specified by prepending an appropriate key word designation before the field's type specification. Cryptographic keys are implied by the current session state (see Section 6.1).",
      "ja": "5つの暗号操作-デジタル署名、ストリーム暗号暗号化、ブロック暗号化暗号化、追加データ付き認証暗号化（AEAD）暗号化、および公開鍵暗号化-は、デジタル署名、ストリーム暗号化、ブロック暗号化、ead暗号化に指定されています、公開鍵で暗号化されています。フィールドの暗号処理は、フィールドのタイプ指定の前に適切なキーワード指定を付加することによって指定されます。暗号化キーは、現在のセッション状態によって暗示されます（セクション6.1を参照）。"
    },
    {
      "indent": 3,
      "text": "A digitally-signed element is encoded as a struct DigitallySigned:",
      "ja": "デジタル署名された要素は、DigitallySigned構造体としてエンコードされます。"
    },
    {
      "indent": 6,
      "text": "struct {\n   SignatureAndHashAlgorithm algorithm;\n   opaque signature<0..2^16-1>;\n} DigitallySigned;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The algorithm field specifies the algorithm used (see Section 7.4.1.4.1 for the definition of this field). Note that the introduction of the algorithm field is a change from previous versions. The signature is a digital signature using those algorithms over the contents of the element. The contents themselves do not appear on the wire but are simply calculated. The length of the signature is specified by the signing algorithm and key.",
      "ja": "アルゴリズムフィールドは、使用されるアルゴリズムを指定します（このフィールドの定義については、セクション7.4.1.4.1を参照してください）。アルゴリズムフィールドの導入は、以前のバージョンからの変更であることに注意してください。署名は、要素のコンテンツに対してこれらのアルゴリズムを使用するデジタル署名です。コンテンツ自体はネットワークに表示されず、単純に計算されます。署名の長さは、署名アルゴリズムと鍵によって指定されます。"
    },
    {
      "indent": 3,
      "text": "In RSA signing, the opaque vector contains the signature generated using the RSASSA-PKCS1-v1_5 signature scheme defined in [PKCS1]. As discussed in [PKCS1], the DigestInfo MUST be DER-encoded [X680] [X690]. For hash algorithms without parameters (which includes SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be NULL, but implementations MUST accept both without parameters and with NULL parameters. Note that earlier versions of TLS used a different RSA signature scheme that did not include a DigestInfo encoding.",
      "ja": "RSA署名では、不透明なベクターには、[PKCS1]で定義されているRSASSA-PKCS1-v1_5署名方式を使用して生成された署名が含まれています。 [PKCS1]で説明されているように、DigestInfoはDERエンコード[X680] [X690]する必要があります。パラメータなしのハッシュアルゴリズム（SHA-1を含む）の場合、DigestInfo.AlgorithmIdentifier.parametersフィールドはNULLでなければならない（MUST）が、実装は、パラメータなしとNULLパラメータありの両方を受け入れなければならない（MUST）。以前のバージョンのTLSは、DigestInfoエンコーディングを含まない別のRSA署名方式を使用していたことに注意してください。"
    },
    {
      "indent": 3,
      "text": "In DSA, the 20 bytes of the SHA-1 hash are run directly through the Digital Signing Algorithm with no additional hashing. This produces two values, r and s. The DSA signature is an opaque vector, as above, the contents of which are the DER encoding of:",
      "ja": "DSAでは、SHA-1ハッシュの20バイトは、追加のハッシュなしでデジタル署名アルゴリズムを介して直接実行されます。これにより、rとsの2つの値が生成されます。 DSA署名は、上記のように不透明なベクトルであり、その内容は次のDERエンコードです。"
    },
    {
      "indent": 6,
      "text": "Dss-Sig-Value ::= SEQUENCE {\n    r INTEGER,\n    s INTEGER\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: In current terminology, DSA refers to the Digital Signature Algorithm and DSS refers to the NIST standard. In the original SSL and TLS specs, \"DSS\" was used universally. This document uses \"DSA\" to refer to the algorithm, \"DSS\" to refer to the standard, and it uses \"DSS\" in the code point definitions for historical continuity.",
      "ja": "注：現在の用語では、DSAはデジタル署名アルゴリズムを指し、DSSはNIST標準を指します。元のSSLおよびTLS仕様では、「DSS」が広く使用されていました。このドキュメントでは、「DSA」を使用してアルゴリズムを参照し、「DSS」を使用して標準を参照し、履歴継続性のコードポイント定義で「DSS」を使用しています。"
    },
    {
      "indent": 3,
      "text": "In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically secure keyed pseudorandom number generator.",
      "ja": "ストリーム暗号の暗号化では、平文は、暗号で保護されたキー付きの疑似乱数ジェネレータから生成された同じ量の出力と排他的論理和がとられます。"
    },
    {
      "indent": 3,
      "text": "In block cipher encryption, every block of plaintext encrypts to a block of ciphertext. All block cipher encryption is done in CBC (Cipher Block Chaining) mode, and all items that are block-ciphered will be an exact multiple of the cipher block length.",
      "ja": "ブロック暗号化暗号化では、平文のすべてのブロックが暗号文のブロックに暗号化されます。すべてのブロック暗号化暗号化はCBC（Cipher Block Chaining）モードで行われ、ブロック暗号化されるすべてのアイテムは、暗号化ブロック長の正確な倍数になります。"
    },
    {
      "indent": 3,
      "text": "In AEAD encryption, the plaintext is simultaneously encrypted and integrity protected. The input may be of any length, and aead-ciphered output is generally larger than the input in order to accommodate the integrity check value.",
      "ja": "AEAD暗号化では、平文は同時に暗号化され、整合性が保護されます。入力は任意の長さにすることができ、整合性チェック値に対応するために、一般にaead暗号化出力は入力よりも大きくなります。"
    },
    {
      "indent": 3,
      "text": "In public key encryption, a public key algorithm is used to encrypt data in such a way that it can be decrypted only with the matching private key. A public-key-encrypted element is encoded as an opaque vector <0..2^16-1>, where the length is specified by the encryption algorithm and key.",
      "ja": "公開鍵暗号化では、公開鍵アルゴリズムを使用して、一致する秘密鍵でのみ復号化できるようにデータを暗号化します。公開鍵で暗号化された要素は、不透明なベクトル<0..2 ^ 16-1>としてエンコードされ、長さは暗号化アルゴリズムと鍵によって指定されます。"
    },
    {
      "indent": 3,
      "text": "RSA encryption is done using the RSAES-PKCS1-v1_5 encryption scheme defined in [PKCS1].",
      "ja": "RSA暗号化は、[PKCS1]で定義されているRSAES-PKCS1-v1_5暗号化スキームを使用して行われます。"
    },
    {
      "indent": 3,
      "text": "In the following example",
      "ja": "次の例では"
    },
    {
      "indent": 6,
      "text": "stream-ciphered struct {\n    uint8 field1;\n    uint8 field2;\n    digitally-signed opaque {\n      uint8 field3<0..255>;\n      uint8 field4;\n    };\n} UserType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The contents of the inner struct (field3 and field4) are used as input for the signature/hash algorithm, and then the entire structure is encrypted with a stream cipher. The length of this structure, in bytes, would be equal to two bytes for field1 and field2, plus two bytes for the signature and hash algorithm, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. The length of the signature is known because the algorithm and key used for the signing are known prior to encoding or decoding this structure.",
      "ja": "内部構造体（field3およびfield4）の内容は、署名/ハッシュアルゴリズムの入力として使用され、構造全体がストリーム暗号で暗号化されます。この構造の長さ（バイト単位）は、field1とfield2の2バイト、署名とハッシュアルゴリズムの2バイト、署名の長さの2バイト、および署名アルゴリズムの出力の長さに等しいです。 。この構造をエンコードまたはデコードする前に、署名に使用されるアルゴリズムとキーがわかっているため、署名の長さがわかります。"
    },
    {
      "indent": 0,
      "text": "4.8. Constants",
      "section_title": true,
      "ja": "4.8. 定数"
    },
    {
      "indent": 3,
      "text": "Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it.",
      "ja": "型付き定数は、目的の型のシンボルを宣言してそれに値を割り当てることにより、仕様の目的で定義できます。"
    },
    {
      "indent": 3,
      "text": "Under-specified types (opaque, variable-length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.",
      "ja": "指定不足の型（不透明、可変長のベクトル、および不透明を含む構造体）には値を割り当てることができません。複数要素の構造体またはベクトルのフィールドは省略できません。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 6,
      "text": "struct {\n    uint8 f1;\n    uint8 f2;\n} Example1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. HMAC and the Pseudorandom Function",
      "section_title": true,
      "ja": "5. HMACと疑似ランダム関数"
    },
    {
      "indent": 3,
      "text": "The TLS record layer uses a keyed Message Authentication Code (MAC) to protect message integrity. The cipher suites defined in this document use a construction known as HMAC, described in [HMAC], which is based on a hash function. Other cipher suites MAY define their own MAC constructions, if needed.",
      "ja": "TLSレコードレイヤーは、キー付きのメッセージ認証コード（MAC）を使用してメッセージの整合性を保護します。このドキュメントで定義されている暗号スイートは、[HMAC]で説明されているHMACと呼ばれる構造を使用しており、これはハッシュ関数に基づいています。他の暗号スイートは、必要に応じて、独自のMAC構造を定義してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "In addition, a construction is required to do expansion of secrets into blocks of data for the purposes of key generation or validation. This pseudorandom function (PRF) takes as input a secret, a seed, and an identifying label and produces an output of arbitrary length.",
      "ja": "さらに、キーの生成または検証のために、シークレットをデータのブロックに拡張するための構造が必要です。この疑似ランダム関数（PRF）は、秘密、シード、および識別ラベルを入力として受け取り、任意の長さの出力を生成します。"
    },
    {
      "indent": 3,
      "text": "In this section, we define one PRF, based on HMAC. This PRF with the SHA-256 hash function is used for all cipher suites defined in this document and in TLS documents published prior to this document when TLS 1.2 is negotiated. New cipher suites MUST explicitly specify a PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a stronger standard hash function.",
      "ja": "このセクションでは、HMACに基づいて1つのPRFを定義します。 SHA-256ハッシュ関数を備えたこのPRFは、このドキュメント、およびこのドキュメントの前に公開されたTLSドキュメントで定義されているすべての暗号スイートで、TLS 1.2のネゴシエート時に使用されます。新しい暗号スイートは、PRFを明示的に指定する必要があり、一般に、SHA-256またはより強力な標準ハッシュ関数でTLS PRFを使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "First, we define a data expansion function, P_hash(secret, data), that uses a single hash function to expand a secret and seed into an arbitrary quantity of output:",
      "ja": "最初に、単一のハッシュ関数を使用してシークレットを拡張し、任意の数の出力にシードするデータ拡張関数P_hash（secret、data）を定義します。"
    },
    {
      "indent": 6,
      "text": "P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + HMAC_hash(secret, A(2) + seed) + HMAC_hash(secret, A(3) + seed) + ...",
      "ja": "P_hash（secret、seed）= HMAC_hash（secret、A（1）+ seed）+ HMAC_hash（secret、A（2）+ seed）+ HMAC_hash（secret、A（3）+ seed）+ ..."
    },
    {
      "indent": 3,
      "text": "where + indicates concatenation.",
      "ja": "+は連結を示します。"
    },
    {
      "indent": 3,
      "text": "A() is defined as:",
      "ja": "A()は次のように定義されます。"
    },
    {
      "indent": 6,
      "text": "A(0) = seed\nA(i) = HMAC_hash(secret, A(i-1))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "P_hash can be iterated as many times as necessary to produce the required quantity of data. For example, if P_SHA256 is being used to create 80 bytes of data, it will have to be iterated three times (through A(3)), creating 96 bytes of output data; the last 16 bytes of the final iteration will then be discarded, leaving 80 bytes of output data.",
      "ja": "P_hashは、必要な量のデータを生成するために必要な回数だけ繰り返すことができます。たとえば、80バイトのデータを作成するためにP_SHA256が使用されている場合、（A（3）を介して）3回繰り返す必要があり、96バイトの出力データが作成されます。最後の反復の最後の16バイトは破棄され、80バイトの出力データが残ります。"
    },
    {
      "indent": 3,
      "text": "TLS's PRF is created by applying P_hash to the secret as:",
      "ja": "TLSのPRFは、P_hashをシークレットに次のように適用することによって作成されます。"
    },
    {
      "indent": 6,
      "text": "PRF(secret, label, seed) = P_<hash>(secret, label + seed)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The label is an ASCII string. It should be included in the exact form it is given without a length byte or trailing null character. For example, the label \"slithy toves\" would be processed by hashing the following bytes:",
      "ja": "ラベルはASCII文字列です。これは、長さバイトまたは末尾のヌル文字なしで指定された正確な形式で含める必要があります。たとえば、「slithy toves」というラベルは、次のバイトをハッシュすることによって処理されます。"
    },
    {
      "indent": 6,
      "text": "73 6C 69 74 68 79 20 74 6F 76 65 73",
      "ja": "73 6C 69 74 68 79 20 74 6F 76 65 73"
    },
    {
      "indent": 0,
      "text": "6. The TLS Record Protocol",
      "section_title": true,
      "ja": "6. TLSレコードプロトコル"
    },
    {
      "indent": 3,
      "text": "The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. Received data is decrypted, verified, decompressed, reassembled, and then delivered to higher-level clients.",
      "ja": "TLS Record Protocolは階層型プロトコルです。各層で、メッセージには長さ、説明、および内容のフィールドが含まれる場合があります。 Record Protocolは、送信されるメッセージを受け取り、データを管理可能なブロックに断片化し、オプションでデータを圧縮し、MACを適用し、暗号化して、結果を送信します。受信したデータは、復号化、検証、解凍、再構成されてから、上位のクライアントに配信されます。"
    },
    {
      "indent": 3,
      "text": "Four protocols that use the record protocol are described in this document: the handshake protocol, the alert protocol, the change cipher spec protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record content types can be supported by the record protocol. New record content type values are assigned by IANA in the TLS Content Type Registry as described in Section 12.",
      "ja": "このドキュメントでは、レコードプロトコルを使用する4つのプロトコル（ハンドシェイクプロトコル、アラートプロトコル、暗号仕様変更プロトコル、およびアプリケーションデータプロトコル）について説明します。 TLSプロトコルの拡張を可能にするために、追加のレコードコンテンツタイプをレコードプロトコルでサポートできます。セクション12で説明されているように、新しいレコードコンテンツタイプの値は、TLSコンテンツタイプレジストリのIANAによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST send an unexpected_message alert.",
      "ja": "実装は、何らかの拡張によって交渉されない限り、このドキュメントで定義されていないレコードタイプを送信してはなりません。 TLS実装が予期しないレコードタイプを受信した場合は、予期しないメッセージアラートを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Any protocol designed for use over TLS must be carefully designed to deal with all possible attacks against it. As a practical matter, this means that the protocol designer must be aware of what security properties TLS does and does not provide and cannot safely rely on the latter.",
      "ja": "TLSを介して使用するために設計されたプロトコルは、それに対する可能なすべての攻撃に対処するように注意深く設計する必要があります。実際問題として、これはプロトコル設計者がTLSが提供するセキュリティプロパティと提供しないセキュリティプロパティを認識しなければならず、後者に安全に依存できないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Note in particular that type and length of a record are not protected by encryption. If this information is itself sensitive, application designers may wish to take steps (padding, cover traffic) to minimize information leakage.",
      "ja": "特に、レコードのタイプと長さは暗号化によって保護されないことに注意してください。この情報自体が機密情報である場合、アプリケーション設計者は、情報漏えいを最小限に抑えるための手順（パディング、トラフィックのカバー）を実行する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Connection States",
      "section_title": true,
      "ja": "6.1. 接続状態"
    },
    {
      "indent": 3,
      "text": "A TLS connection state is the operating environment of the TLS Record Protocol. It specifies a compression algorithm, an encryption algorithm, and a MAC algorithm. In addition, the parameters for these algorithms are known: the MAC key and the bulk encryption keys for the connection in both the read and the write directions. Logically, there are always four connection states outstanding: the current read and write states, and the pending read and write states. All records are processed under the current read and write states. The security parameters for the pending states can be set by the TLS Handshake Protocol, and the ChangeCipherSpec can selectively make either of the pending states current, in which case the appropriate current state is disposed of and replaced with the pending state; the pending state is then reinitialized to an empty state. It is illegal to make a state that has not been initialized with security parameters a current state. The initial current state always specifies that no encryption, compression, or MAC will be used.",
      "ja": "TLS接続状態は、TLSレコードプロトコルの動作環境です。圧縮アルゴリズム、暗号化アルゴリズム、およびMACアルゴリズムを指定します。さらに、これらのアルゴリズムのパラメーターは既知です。読み取りおよび書き込みの両方向の接続のMACキーとバルク暗号化キーです。論理的には、未処理の接続状態が常に4つあります。現在の読み取り状態と書き込み状態、および保留中の読み取り状態と書き込み状態です。すべてのレコードは、現在の読み取り状態と書き込み状態で処理されます。保留状態のセキュリティパラメータはTLSハンドシェイクプロトコルによって設定でき、ChangeCipherSpecは保留状態のいずれかを選択的に最新にすることができます。この場合、適切な現在の状態が破棄され、保留状態に置き換えられます。次に、保留状態が空の状態に再初期化されます。セキュリティパラメータで初期化されていない状態を現在の状態にすることは違法です。初期の現在の状態では、暗号化、圧縮、またはMACが使用されないことが常に指定されています。"
    },
    {
      "indent": 3,
      "text": "The security parameters for a TLS Connection read and write state are set by providing the following values:",
      "ja": "TLS接続の読み取りおよび書き込み状態のセキュリティパラメータは、次の値を指定することによって設定されます。"
    },
    {
      "indent": 3,
      "text": "connection end Whether this entity is considered the \"client\" or the \"server\" in this connection.",
      "ja": "connection end このエンティティがこの接続で「クライアント」または「サーバー」と見なされるかどうか。"
    },
    {
      "indent": 3,
      "text": "PRF algorithm An algorithm used to generate keys from the master secret (see Sections 5 and 6.3).",
      "ja": "PRFアルゴリズム マスターシークレットからキーを生成するために使用されるアルゴリズム（セクション5および6.3を参照）。"
    },
    {
      "indent": 3,
      "text": "bulk encryption algorithm An algorithm to be used for bulk encryption. This specification includes the key size of this algorithm, whether it is a block, stream, or AEAD cipher, the block size of the cipher (if appropriate), and the lengths of explicit and implicit initialization vectors (or nonces).",
      "ja": "バルク暗号化アルゴリズム バルク暗号化に使用されるアルゴリズム。この仕様には、このアルゴリズムのキーサイズ、ブロック、ストリーム、またはAEAD暗号であるかどうか、暗号のブロックサイズ（該当する場合）、および明示的および暗黙的な初期化ベクトル（またはノンス）の長さが含まれます。"
    },
    {
      "indent": 3,
      "text": "MAC algorithm An algorithm to be used for message authentication. This specification includes the size of the value returned by the MAC algorithm.",
      "ja": "MACアルゴリズム メッセージ認証に使用されるアルゴリズム。この仕様には、MACアルゴリズムによって返される値のサイズが含まれます。"
    },
    {
      "indent": 3,
      "text": "compression algorithm An algorithm to be used for data compression. This specification must include all information the algorithm requires to do compression.",
      "ja": "圧縮アルゴリズム データ圧縮に使用されるアルゴリズム。この仕様には、アルゴリズムが圧縮を行うために必要なすべての情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "master secret A 48-byte secret shared between the two peers in the connection.",
      "ja": "マスターシークレット 接続の2つのピア間で共有される48バイトのシークレット。"
    },
    {
      "indent": 3,
      "text": "client random A 32-byte value provided by the client.",
      "ja": "クライアントランダム クライアントが提供する32バイトの値。"
    },
    {
      "indent": 3,
      "text": "server random A 32-byte value provided by the server.",
      "ja": "サーバーランダム サーバーが提供する32バイトの値。"
    },
    {
      "indent": 6,
      "text": "These parameters are defined in the presentation language as:",
      "ja": "これらのパラメータは、プレゼンテーション言語で次のように定義されています。"
    },
    {
      "indent": 6,
      "text": "enum { server, client } ConnectionEnd;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum { tls_prf_sha256 } PRFAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum { null, rc4, 3des, aes }\n  BulkCipherAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum { stream, block, aead } CipherType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum { null, hmac_md5, hmac_sha1, hmac_sha256,\n     hmac_sha384, hmac_sha512} MACAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* The algorithms specified in CompressionMethod, PRFAlgorithm,\n   BulkCipherAlgorithm, and MACAlgorithm may be added to. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    ConnectionEnd          entity;\n    PRFAlgorithm           prf_algorithm;\n    BulkCipherAlgorithm    bulk_cipher_algorithm;\n    CipherType             cipher_type;\n    uint8                  enc_key_length;\n    uint8                  block_length;\n    uint8                  fixed_iv_length;\n    uint8                  record_iv_length;\n    MACAlgorithm           mac_algorithm;\n    uint8                  mac_length;\n    uint8                  mac_key_length;\n    CompressionMethod      compression_algorithm;\n    opaque                 master_secret[48];\n    opaque                 client_random[32];\n    opaque                 server_random[32];\n} SecurityParameters;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The record layer will use the security parameters to generate the following six items (some of which are not required by all ciphers, and are thus empty):",
      "ja": "レコードレイヤーは、セキュリティパラメーターを使用して、次の6つの項目を生成します（一部はすべての暗号で必要とされないため、空です）。"
    },
    {
      "indent": 6,
      "text": "client write MAC key server write MAC key client write encryption key server write encryption key client write IV server write IV",
      "ja": "クライアント書き込みMACキー、サーバー書き込みMACキー、クライアント書き込み暗号化キー、サーバー書き込み暗号化キー、クライアント書き込みIV、サーバー書き込みIV"
    },
    {
      "indent": 3,
      "text": "The client write parameters are used by the server when receiving and processing records and vice versa. The algorithm used for generating these items from the security parameters is described in Section 6.3.",
      "ja": "クライアントの書き込みパラメータは、レコードを受信して処理するときにサーバーによって使用され、その逆も同様です。セキュリティパラメータからこれらのアイテムを生成するために使用されるアルゴリズムについては、セクション6.3で説明します。"
    },
    {
      "indent": 3,
      "text": "Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states. These current states MUST be updated for each record processed. Each connection state includes the following elements:",
      "ja": "セキュリティパラメータを設定してキーを生成したら、現在の状態にすることで接続状態をインスタンス化できます。これらの現在の状態は、処理されるレコードごとに更新する必要があります。各接続状態には、次の要素が含まれます。"
    },
    {
      "indent": 3,
      "text": "compression state The current state of the compression algorithm.",
      "ja": "圧縮状態 圧縮アルゴリズムの現在の状態。"
    },
    {
      "indent": 3,
      "text": "cipher state The current state of the encryption algorithm. This will consist of the scheduled key for that connection. For stream ciphers, this will also contain whatever state information is necessary to allow the stream to continue to encrypt or decrypt data.",
      "ja": "暗号化状態暗号化アルゴリズムの現在の状態。これは、その接続用にスケジュールされたキーで構成されます。ストリーム暗号の場合、ストリームにデータの暗号化または復号化を継続させるために必要な状態情報も含まれます。"
    },
    {
      "indent": 3,
      "text": "MAC key The MAC key for this connection, as generated above.",
      "ja": "MACキー 上記で生成された、この接続のMACキー。"
    },
    {
      "indent": 3,
      "text": "sequence number Each connection state contains a sequence number, which is maintained separately for read and write states. The sequence number MUST be set to zero whenever a connection state is made the active state. Sequence numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do not wrap. If a TLS implementation would need to wrap a sequence number, it must renegotiate instead. A sequence number is incremented after each record: specifically, the first record transmitted under a particular connection state MUST use sequence number 0.",
      "ja": "シーケンス番号 各接続状態にはシーケンス番号が含まれており、読み取り状態と書き込み状態で別々に保持されます。接続状態がアクティブ状態になるときは常に、シーケンス番号をゼロに設定する必要があります。シーケンス番号のタイプはuint64で、2 ^ 64-1を超えることはできません。シーケンス番号は折り返されません。 TLS実装でシーケンス番号をラップする必要がある場合は、代わりに再ネゴシエーションする必要があります。シーケンス番号は各レコードの後に増加します。具体的には、特定の接続状態で送信される最初のレコードはシーケンス番号0を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Record Layer",
      "section_title": true,
      "ja": "6.2. レコード層"
    },
    {
      "indent": 3,
      "text": "The TLS record layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.",
      "ja": "TLSレコードレイヤーは、任意のサイズの空でないブロックで上位レイヤーから未解釈のデータを受け取ります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Fragmentation",
      "section_title": true,
      "ja": "6.2.1. 断片化"
    },
    {
      "indent": 3,
      "text": "The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Client message boundaries are not preserved in the record layer (i.e., multiple client messages of the same ContentType MAY be coalesced into a single TLSPlaintext record, or a single message MAY be fragmented across several records).",
      "ja": "レコード層は、情報ブロックを2 ^ 14バイト以下のチャンクでデータを運ぶTLSPlaintextレコードにフラグメント化します。クライアントメッセージの境界はレコードレイヤーで保持されません（つまり、同じContentTypeの複数のクライアントメッセージが単一のTLSPlaintextレコードに合体されるか、単一のメッセージが複数のレコードにフラグメント化される場合があります）。"
    },
    {
      "indent": 6,
      "text": "struct {\n    uint8 major;\n    uint8 minor;\n} ProtocolVersion;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum {\n    change_cipher_spec(20), alert(21), handshake(22),\n    application_data(23), (255)\n} ContentType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSPlaintext.length];\n} TLSPlaintext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "type The higher-level protocol used to process the enclosed fragment.",
      "ja": "type 囲まれたフラグメントの処理に使用される上位レベルのプロトコル。"
    },
    {
      "indent": 3,
      "text": "version The version of the protocol being employed. This document describes TLS Version 1.2, which uses the version { 3, 3 }. The version value 3.3 is historical, deriving from the use of {3, 1} for TLS 1.0. (See Appendix A.1.) Note that a client that supports multiple versions of TLS may not know what version will be employed before it receives the ServerHello. See Appendix E for discussion about what record layer version number should be employed for ClientHello.",
      "ja": "version 使用されているプロトコルのバージョン。このドキュメントでは、バージョン{3、3}を使用するTLSバージョン1.2について説明します。バージョン値3.3は歴史的であり、TLS 1.0の{3、1}の使用から派生しています。 （付録A.1を参照してください。）TLSの複数のバージョンをサポートするクライアントは、ServerHelloを受信する前にどのバージョンが使用されるかを認識していない場合があります。 ClientHelloに使用する必要があるレコードレイヤーのバージョン番号については、付録Eを参照してください。"
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSPlaintext.fragment. The length MUST NOT exceed 2^14.",
      "ja": "length 次のTLSPlaintext.fragmentの長さ（バイト単位）。長さは2 ^ 14を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment The application data. This data is transparent and treated as an independent block to be dealt with by the higher-level protocol specified by the type field.",
      "ja": "fragment アプリケーションデータ。このデータは透過的であり、typeフィールドで指定された上位プロトコルによって処理される独立したブロックとして扱われます。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST NOT send zero-length fragments of Handshake, Alert, or ChangeCipherSpec content types. Zero-length fragments of Application data MAY be sent as they are potentially useful as a traffic analysis countermeasure.",
      "ja": "実装は、Handshake、Alert、またはChangeCipherSpecコンテンツタイプのゼロ長フラグメントを送信してはなりません（MUST NOT）。アプリケーションデータのゼロ長フラグメントは、トラフィック分析の対策として潜在的に役立つため、送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "Note: Data of different TLS record layer content types MAY be interleaved. Application data is generally of lower precedence for transmission than other content types. However, records MUST be delivered to the network in the same order as they are protected by the record layer. Recipients MUST receive and process interleaved application layer traffic during handshakes subsequent to the first one on a connection.",
      "ja": "注：異なるTLSレコードレイヤーコンテンツタイプのデータはインターリーブされる場合があります。アプリケーションデータは一般に、他のコンテンツタイプよりも送信の優先順位が低くなります。ただし、レコードは、レコードレイヤーによって保護されているのと同じ順序でネットワークに配信する必要があります。受信者は、接続の最初のハンドシェイクに続くハンドシェイク中に、インターリーブされたアプリケーションレイヤートラフィックを受信して処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Record Compression and Decompression",
      "section_title": true,
      "ja": "6.2.2. レコードの圧縮と解凍"
    },
    {
      "indent": 3,
      "text": "All records are compressed using the compression algorithm defined in the current session state. There is always an active compression algorithm; however, initially it is defined as CompressionMethod.null. The compression algorithm translates a TLSPlaintext structure into a TLSCompressed structure. Compression functions are initialized with default state information whenever a connection state is made active. [RFC3749] describes compression algorithms for TLS.",
      "ja": "すべてのレコードは、現在のセッション状態で定義された圧縮アルゴリズムを使用して圧縮されます。常にアクティブな圧縮アルゴリズムがあります。ただし、最初はCompressionMethod.nullとして定義されています。圧縮アルゴリズムは、TLSPlaintext構造をTLSCompressed構造に変換します。接続状態がアクティブになると、圧縮関数はデフォルトの状態情報で初期化されます。 [RFC3749]は、TLSの圧縮アルゴリズムについて説明しています。"
    },
    {
      "indent": 3,
      "text": "Compression must be lossless and may not increase the content length by more than 1024 bytes. If the decompression function encounters a TLSCompressed.fragment that would decompress to a length in excess of 2^14 bytes, it MUST report a fatal decompression failure error.",
      "ja": "圧縮はロスレスでなければならず、コンテンツの長さが1024バイトを超えないようにする必要があります。解凍関数が2 ^ 14バイトを超える長さに解凍するTLSCompressed.fragmentを検出した場合、致命的な解凍エラーを報告する必要があります。"
    },
    {
      "indent": 6,
      "text": "struct {\n    ContentType type;       /* same as TLSPlaintext.type */\n    ProtocolVersion version;/* same as TLSPlaintext.version */\n    uint16 length;\n    opaque fragment[TLSCompressed.length];\n} TLSCompressed;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSCompressed.fragment. The length MUST NOT exceed 2^14 + 1024.",
      "ja": "length 次のTLSCompressed.fragmentの長さ（バイト単位）。長さは2 ^ 14 + 1024を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment The compressed form of TLSPlaintext.fragment.",
      "ja": "fragment TLSPlaintext.fragmentの圧縮形式。"
    },
    {
      "indent": 6,
      "text": "Note: A CompressionMethod.null operation is an identity operation; no fields are altered.",
      "ja": "注：CompressionMethod.null操作はID操作です。フィールドは変更されません。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Decompression functions are responsible for ensuring that messages cannot cause internal buffer overflows.",
      "ja": "実装上の注意：解凍関数は、メッセージが内部バッファオーバーフローを引き起こさないようにする責任があります。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Record Payload Protection",
      "section_title": true,
      "ja": "6.2.3. ペイロード保護の記録"
    },
    {
      "indent": 6,
      "text": "The encryption and MAC functions translate a TLSCompressed structure into a TLSCiphertext. The decryption functions reverse the process. The MAC of the record also includes a sequence number so that missing, extra, or repeated messages are detectable.",
      "ja": "暗号化およびMAC関数は、TLSCompressed構造をTLSCiphertextに変換します。復号化関数はプロセスを逆にします。レコードのMACにはシーケンス番号も含まれているため、欠落、余分、または繰り返しのメッセージを検出できます。"
    },
    {
      "indent": 6,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    select (SecurityParameters.cipher_type) {\n        case stream: GenericStreamCipher;\n        case block:  GenericBlockCipher;\n        case aead:   GenericAEADCipher;\n    } fragment;\n} TLSCiphertext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "type The type field is identical to TLSCompressed.type.",
      "ja": "type typeフィールドはTLSCompressed.typeと同じです。"
    },
    {
      "indent": 3,
      "text": "version The version field is identical to TLSCompressed.version.",
      "ja": "version versionフィールドはTLSCompressed.versionと同じです。"
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSCiphertext.fragment. The length MUST NOT exceed 2^14 + 2048.",
      "ja": "length 次のTLSCiphertext.fragmentの長さ（バイト単位）。長さは2 ^ 14 + 2048を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment The encrypted form of TLSCompressed.fragment, with the MAC.",
      "ja": "fragment 暗号化された形式のTLSCompressed.fragmentとMAC。"
    },
    {
      "indent": 0,
      "text": "6.2.3.1. Null or Standard Stream Cipher",
      "section_title": true,
      "ja": "6.2.3.1. ヌルまたは標準ストリーム暗号"
    },
    {
      "indent": 3,
      "text": "Stream ciphers (including BulkCipherAlgorithm.null; see Appendix A.6) convert TLSCompressed.fragment structures to and from stream TLSCiphertext.fragment structures.",
      "ja": "ストリーム暗号（BulkCipherAlgorithm.nullを含む。付録A.6を参照）は、TLSCompressed.fragment構造をストリームTLSCiphertext.fragment構造との間で変換します。"
    },
    {
      "indent": 6,
      "text": "stream-ciphered struct {\n    opaque content[TLSCompressed.length];\n    opaque MAC[SecurityParameters.mac_length];\n} GenericStreamCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The MAC is generated as:",
      "ja": "MACは次のように生成されます。"
    },
    {
      "indent": 6,
      "text": "MAC(MAC_write_key, seq_num + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length + TLSCompressed.fragment);",
      "ja": "MAC（MAC_write_key、seq_num + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length + TLSCompressed.fragment）;"
    },
    {
      "indent": 3,
      "text": "where \"+\" denotes concatenation.",
      "ja": "「+」は連結を示します。"
    },
    {
      "indent": 3,
      "text": "seq_num The sequence number for this record.",
      "ja": "seq_num このレコードのシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "MAC The MAC algorithm specified by SecurityParameters.mac_algorithm.",
      "ja": "MAC SecurityParameters.mac_algorithmで指定されたMACアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "Note that the MAC is computed before encryption. The stream cipher encrypts the entire block, including the MAC. For stream ciphers that do not use a synchronization vector (such as RC4), the stream cipher state from the end of one record is simply used on the subsequent packet. If the cipher suite is TLS_NULL_WITH_NULL_NULL, encryption consists of the identity operation (i.e., the data is not encrypted, and the MAC size is zero, implying that no MAC is used). For both null and stream ciphers, TLSCiphertext.length is TLSCompressed.length plus SecurityParameters.mac_length.",
      "ja": "MACは暗号化の前に計算されることに注意してください。ストリーム暗号は、MACを含むブロック全体を暗号化します。同期ベクトルを使用しないストリーム暗号（RC4など）の場合、1つのレコードの終わりからのストリーム暗号の状態は、後続のパケットで単純に使用されます。暗号スイートがTLS_NULL_WITH_NULL_NULLの場合、暗号化はID操作で構成されます（つまり、データは暗号化されず、MACサイズはゼロであり、MACが使用されないことを意味します）。 null暗号とストリーム暗号の両方で、TLSCiphertext.lengthはTLSCompressed.lengthにSecurityParameters.mac_lengthを加えたものです。"
    },
    {
      "indent": 0,
      "text": "6.2.3.2. CBC Block Cipher",
      "section_title": true,
      "ja": "6.2.3.2. CBCブロック暗号"
    },
    {
      "indent": 3,
      "text": "For block ciphers (such as 3DES or AES), the encryption and MAC functions convert TLSCompressed.fragment structures to and from block TLSCiphertext.fragment structures.",
      "ja": "ブロック暗号（3DESやAESなど）の場合、暗号化およびMAC関数は、TLSCompressed.fragment構造とブロックTLSCiphertext.fragment構造との間で変換を行います。"
    },
    {
      "indent": 6,
      "text": "struct {\n    opaque IV[SecurityParameters.record_iv_length];\n    block-ciphered struct {\n        opaque content[TLSCompressed.length];\n        opaque MAC[SecurityParameters.mac_length];\n        uint8 padding[GenericBlockCipher.padding_length];\n        uint8 padding_length;\n    };\n} GenericBlockCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The MAC is generated as described in Section 6.2.3.1.",
      "ja": "MACはセクション6.2.3.1で説明されているように生成されます。"
    },
    {
      "indent": 3,
      "text": "IV The Initialization Vector (IV) SHOULD be chosen at random, and MUST be unpredictable. Note that in versions of TLS prior to 1.1, there was no IV field, and the last ciphertext block of the previous record (the \"CBC residue\") was used as the IV. This was changed to prevent the attacks described in [CBCATT]. For block ciphers, the IV length is of length SecurityParameters.record_iv_length, which is equal to the SecurityParameters.block_size.",
      "ja": "IV 初期化ベクトル（IV）はランダムに選択する必要があり（SHOULD）、予測不可能である必要があります。 1.1より前のバージョンのTLSでは、IVフィールドはなく、前のレコードの最後の暗号文ブロック（「CBC残差」）がIVとして使用されていました。これは、[CBCATT]で説明されている攻撃を防ぐために変更されました。ブロック暗号の場合、IVの長さはSecurityParameters.record_iv_lengthであり、SecurityParameters.block_sizeと同じです。"
    },
    {
      "indent": 3,
      "text": "padding Padding that is added to force the length of the plaintext to be an integral multiple of the block cipher's block length. The padding MAY be any length up to 255 bytes, as long as it results in the TLSCiphertext.length being an integral multiple of the block length. Lengths longer than necessary might be desirable to frustrate attacks on a protocol that are based on analysis of the lengths of exchanged messages. Each uint8 in the padding data vector MUST be filled with the padding length value. The receiver MUST check this padding and MUST use the bad_record_mac alert to indicate padding errors.",
      "ja": "padding 平文の長さをブロック暗号のブロック長の整数倍にするために追加されるパディング。パディングは、TLSCiphertext.lengthがブロック長の整数倍になる限り、255バイトまでの任意の長さである可能性があります。交換されたメッセージの長さの分析に基づくプロトコルへの攻撃を妨げるには、必要以上に長い長さが望ましい場合があります。パディングデータベクトルの各uint8には、パディング長の値を入力する必要があります。受信者はこのパディングをチェックする必要があり、パディングエラーを示すためにbad_record_macアラートを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "padding_length The padding length MUST be such that the total size of the GenericBlockCipher structure is a multiple of the cipher's block length. Legal values range from zero to 255, inclusive. This length specifies the length of the padding field exclusive of the padding_length field itself.",
      "ja": "padding_length パディングの長さは、GenericBlockCipher構造の合計サイズが暗号のブロック長の倍数になるようにする必要があります。有効な値の範囲は0〜255です。この長さは、padding_lengthフィールド自体を除いたpaddingフィールドの長さを指定します。"
    },
    {
      "indent": 3,
      "text": "The encrypted data length (TLSCiphertext.length) is one more than the sum of SecurityParameters.block_length, TLSCompressed.length, SecurityParameters.mac_length, and padding_length.",
      "ja": "暗号化されたデータの長さ（TLSCiphertext.length）は、SecurityParameters.block_length、TLSCompressed.length、SecurityParameters.mac_length、およびpadding_lengthの合計よりも1つ長くなります。"
    },
    {
      "indent": 3,
      "text": "Example: If the block length is 8 bytes, the content length (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the length before padding is 82 bytes (this does not include the IV. Thus, the padding length modulo 8 must be equal to 6 in order to make the total length an even multiple of 8 bytes (the block length). The padding length can be 6, 14, 22, and so on, through 254. If the padding length were the minimum necessary, 6, the padding would be 6 bytes, each containing the value 6. Thus, the last 8 octets of the GenericBlockCipher before block encryption would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.",
      "ja": "例：ブロック長が8バイト、コンテンツ長（TLSCompressed.length）が61バイト、MAC長が20バイトの場合、パディング前の長さは82バイトです（これにはIVは含まれません。したがって、パディング長さモジュロ8は、合計長を8バイト（ブロック長）の偶数倍にするために6に等しくなければなりません。パディング長は、6、14、22などの254まで可能です。パディング長が必要最低限の6、パディングは6バイトで、それぞれに値6が含まれます。したがって、ブロック暗号化の前のGenericBlockCipherの最後の8オクテットはxx 06 06 06 06 06 06となります。ここで、xxはMACの最後のオクテットです。"
    },
    {
      "indent": 3,
      "text": "Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical that the entire plaintext of the record be known before any ciphertext is transmitted. Otherwise, it is possible for the attacker to mount the attack described in [CBCATT].",
      "ja": "注：CBCモード（暗号ブロック連鎖）のブロック暗号では、暗号文を送信する前に、レコードの平文全体を知っておくことが重要です。それ以外の場合、攻撃者は[CBCATT]で説明されている攻撃を仕掛けることができます。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Canvel et al. [CBCTIME] have demonstrated a timing attack on CBC padding based on the time required to compute the MAC. In order to defend against this attack, implementations MUST ensure that record processing time is essentially the same whether or not the padding is correct. In general, the best way to do this is to compute the MAC even if the padding is incorrect, and only then reject the packet. For instance, if the pad appears to be incorrect, the implementation might assume a zero-length pad and then compute the MAC. This leaves a small timing channel, since MAC performance depends to some extent on the size of the data fragment, but it is not believed to be large enough to be exploitable, due to the large block size of existing MACs and the small size of the timing signal.",
      "ja": "実装メモ：Canvel et al。 [CBCTIME]は、MACの計算に必要な時間に基づいて、CBCパディングに対するタイミング攻撃を実証しました。この攻撃を防ぐために、実装では、パディングが正しいかどうかに関係なく、レコード処理時間が基本的に同じであることを確認する必要があります。一般に、これを行う最良の方法は、パディングが正しくない場合でもMACを計算し、その後でのみパケットを拒否することです。たとえば、パッドが正しくないように見える場合、実装では長さゼロのパッドを想定し、MACを計算する場合があります。 MACのパフォーマンスはデータフラグメントのサイズにある程度依存するため、これにより小さなタイミングチャネルが残りますが、既存のMACのブロックサイズが大きく、MACのサイズが小さいため、悪用できるほど十分に大きいとは考えられていません。タイミング信号。"
    },
    {
      "indent": 0,
      "text": "6.2.3.3. AEAD Ciphers",
      "section_title": true,
      "ja": "6.2.3.3. AEAD暗号"
    },
    {
      "indent": 3,
      "text": "For AEAD [AEAD] ciphers (such as [CCM] or [GCM]), the AEAD function converts TLSCompressed.fragment structures to and from AEAD TLSCiphertext.fragment structures.",
      "ja": "AEAD [AEAD]暗号（[CCM]や[GCM]など）の場合、AEAD関数はTLSCompressed.fragment構造とAEAD TLSCiphertext.fragment構造との間で変換を行います。"
    },
    {
      "indent": 6,
      "text": "struct {\n   opaque nonce_explicit[SecurityParameters.record_iv_length];\n   aead-ciphered struct {\n       opaque content[TLSCompressed.length];\n   };\n} GenericAEADCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AEAD ciphers take as input a single key, a nonce, a plaintext, and \"additional data\" to be included in the authentication check, as described in Section 2.1 of [AEAD]. The key is either the client_write_key or the server_write_key. No MAC key is used.",
      "ja": "AEAD暗号は、[AEAD]のセクション2.1で説明されているように、認証チェックに含まれる単一の鍵、ノンス、平文、および「追加データ」を入力として受け取ります。キーはclient_write_keyまたはserver_write_keyです。 MACキーは使用されません。"
    },
    {
      "indent": 3,
      "text": "Each AEAD cipher suite MUST specify how the nonce supplied to the AEAD operation is constructed, and what is the length of the GenericAEADCipher.nonce_explicit part. In many cases, it is appropriate to use the partially implicit nonce technique described in Section 3.2.1 of [AEAD]; with record_iv_length being the length of the explicit part. In this case, the implicit part SHOULD be derived from key_block as client_write_iv and server_write_iv (as described in Section 6.3), and the explicit part is included in GenericAEAEDCipher.nonce_explicit.",
      "ja": "各AEAD暗号スイートは、AEAD操作に提供されるナンスの構築方法と、GenericAEADCipher.nonce_explicit部分の長さを指定する必要があります。多くの場合、[AEAD]のセクション3.2.1で説明されている部分的に暗黙的なナンス手法を使用するのが適切です。 record_iv_lengthは、明示的な部分の長さです。この場合、暗黙の部分はclient_write_ivおよびserver_write_ivとしてkey_blockから派生する必要があり（セクション6.3で説明）、明示的な部分はGenericAEAEDCipher.nonce_explicitに含まれています。"
    },
    {
      "indent": 3,
      "text": "The plaintext is the TLSCompressed.fragment.",
      "ja": "平文はTLSCompressed.fragmentです。"
    },
    {
      "indent": 3,
      "text": "The additional authenticated data, which we denote as additional_data, is defined as follows:",
      "ja": "追加の認証済みデータ（additional_dataと表記）は、次のように定義されます。"
    },
    {
      "indent": 6,
      "text": "additional_data = seq_num + TLSCompressed.type +\n                  TLSCompressed.version + TLSCompressed.length;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where \"+\" denotes concatenation.",
      "ja": "「+」は連結を示します。"
    },
    {
      "indent": 3,
      "text": "The aead_output consists of the ciphertext output by the AEAD encryption operation. The length will generally be larger than TLSCompressed.length, but by an amount that varies with the AEAD cipher. Since the ciphers might incorporate padding, the amount of overhead could vary with different TLSCompressed.length values. Each AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes. Symbolically,",
      "ja": "aead_outputは、AEAD暗号化操作によって出力された暗号文で構成されます。長さは通常TLSCompressed.lengthよりも長くなりますが、量はAEAD暗号によって異なります。暗号にはパディングが組み込まれている場合があるため、オーバーヘッドの量はTLSCompressed.lengthの値によって異なります。各AEAD暗号は、1024バイトを超える拡張を生成してはなりません（MUST NOT）。象徴的に、"
    },
    {
      "indent": 6,
      "text": "AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext, additional_data)",
      "ja": "AEADEncrypted = AEAD-Encrypt（write_key、nonce、plaintext、additional_data）"
    },
    {
      "indent": 3,
      "text": "In order to decrypt and verify, the cipher takes as input the key, nonce, the \"additional_data\", and the AEADEncrypted value. The output is either the plaintext or an error indicating that the decryption failed. There is no separate integrity check. That is:",
      "ja": "暗号化を解除して検証するために、暗号はキー、ノンス、「additional_data」、およびAEADEncrypted値を入力として受け取ります。出力は、平文または復号化が失敗したことを示すエラーのいずれかです。個別の整合性チェックはありません。あれは："
    },
    {
      "indent": 6,
      "text": "TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce, AEADEncrypted, additional_data)",
      "ja": "TLSCompressed.fragment = AEAD-Decrypt（write_key、nonce、AEADEncrypted、additional_data）"
    },
    {
      "indent": 3,
      "text": "If the decryption fails, a fatal bad_record_mac alert MUST be generated.",
      "ja": "復号化が失敗した場合、致命的なbad_record_macアラートを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Key Calculation",
      "section_title": true,
      "ja": "6.3. キー計算"
    },
    {
      "indent": 3,
      "text": "The Record Protocol requires an algorithm to generate keys required by the current connection state (see Appendix A.6) from the security parameters provided by the handshake protocol.",
      "ja": "レコードプロトコルには、ハンドシェイクプロトコルによって提供されるセキュリティパラメータから現在の接続状態（付録A.6を参照）で必要なキーを生成するアルゴリズムが必要です。"
    },
    {
      "indent": 3,
      "text": "The master secret is expanded into a sequence of secure bytes, which is then split to a client write MAC key, a server write MAC key, a client write encryption key, and a server write encryption key. Each of these is generated from the byte sequence in that order. Unused values are empty. Some AEAD ciphers may additionally require a client write IV and a server write IV (see Section 6.2.3.3).",
      "ja": "マスターシークレットは一連の安全なバイトに展開され、クライアントの書き込みMACキー、サーバーの書き込みMACキー、クライアントの書き込み暗号化キー、サーバーの書き込み暗号化キーに分割されます。これらはそれぞれ、バイトシーケンスからこの順序で生成されます。未使用の値は空です。一部のAEAD暗号では、クライアント書き込みIVとサーバー書き込みIVがさらに必要になる場合があります（セクション6.2.3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "When keys and MAC keys are generated, the master secret is used as an entropy source.",
      "ja": "キーとMACキーが生成されると、マスターシークレットがエントロピーソースとして使用されます。"
    },
    {
      "indent": 3,
      "text": "To generate the key material, compute",
      "ja": "キーマテリアルを生成するには、"
    },
    {
      "indent": 6,
      "text": "key_block = PRF(SecurityParameters.master_secret, \"key expansion\", SecurityParameters.server_random + SecurityParameters.client_random);",
      "ja": "key_block = PRF（SecurityParameters.master_secret、 \"key Expansion\"、SecurityParameters.server_random + SecurityParameters.client_random）;"
    },
    {
      "indent": 3,
      "text": "until enough output has been generated. Then, the key_block is partitioned as follows:",
      "ja": "十分な出力が生成されるまで。次に、key_blockは次のようにパーティション化されます。"
    },
    {
      "indent": 6,
      "text": "client_write_MAC_key[SecurityParameters.mac_key_length] server_write_MAC_key[SecurityParameters.mac_key_length] client_write_key[SecurityParameters.enc_key_length] server_write_key[SecurityParameters.enc_key_length] client_write_IV[SecurityParameters.fixed_iv_length] server_write_IV[SecurityParameters.fixed_iv_length]",
      "ja": "client_write_MAC_key[SecurityParameters.mac_key_length] server_write_MAC_key[SecurityParameters.mac_key_length] client_write_key[SecurityParameters.enc_key_length] server_write_key[SecurityParameters.enc_key_length] client_write_IV[SecurityParameters.fixed_iv_length] server_write_IV[SecurityParameters.fixed_iv_length]"
    },
    {
      "indent": 3,
      "text": "Currently, the client_write_IV and server_write_IV are only generated for implicit nonce techniques as described in Section 3.2.1 of [AEAD].",
      "ja": "現在、client_write_IVとserver_write_IVは、[AEAD]のセクション3.2.1で説明されているように、暗黙のナンス手法に対してのみ生成されます。"
    },
    {
      "indent": 3,
      "text": "Implementation note: The currently defined cipher suite which requires the most material is AES_256_CBC_SHA256. It requires 2 x 32 byte keys and 2 x 32 byte MAC keys, for a total 128 bytes of key material.",
      "ja": "実装上の注意：最も定義が必要な現在定義されている暗号スイートは、AES_256_CBC_SHA256です。合計128バイトの鍵データのために、2 x 32バイトの鍵と2 x 32バイトのMAC鍵が必要です。"
    },
    {
      "indent": 0,
      "text": "7. The TLS Handshaking Protocols",
      "section_title": true,
      "ja": "7. TLSハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "TLS has three subprotocols that are used to allow peers to agree upon security parameters for the record layer, to authenticate themselves, to instantiate negotiated security parameters, and to report error conditions to each other.",
      "ja": "TLSには3つのサブプロトコルがあり、ピアがレコードレイヤーのセキュリティパラメーターについて合意し、自身を認証し、ネゴシエートされたセキュリティパラメーターをインスタンス化し、エラー状態を互いに報告することができます。"
    },
    {
      "indent": 3,
      "text": "The Handshake Protocol is responsible for negotiating a session, which consists of the following items: session identifier An arbitrary byte sequence chosen by the server to identify an active or resumable session state.",
      "ja": "ハンドシェイクプロトコルは、次の項目で構成されるセッションのネゴシエーションを担当します。セッション識別子 アクティブまたは再開可能なセッション状態を識別するためにサーバーによって選択された任意のバイトシーケンス。"
    },
    {
      "indent": 3,
      "text": "peer certificate X509v3 [PKIX] certificate of the peer. This element of the state may be null.",
      "ja": "ピア証明書 X509v3 [PKIX]ピアの証明書。状態のこの要素はnullである可能性があります。"
    },
    {
      "indent": 3,
      "text": "compression method The algorithm used to compress data prior to encryption.",
      "ja": "圧縮方式 暗号化の前にデータを圧縮するために使用されるアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "cipher spec Specifies the pseudorandom function (PRF) used to generate keying material, the bulk data encryption algorithm (such as null, AES, etc.) and the MAC algorithm (such as HMAC-SHA1). It also defines cryptographic attributes such as the mac_length. (See Appendix A.6 for formal definition.)",
      "ja": "暗号仕様 キーイングマテリアル、バルクデータ暗号化アルゴリズム（null、AESなど）、およびMACアルゴリズム（HMAC-SHA1など）の生成に使用される疑似ランダム関数（PRF）を指定します。また、mac_lengthなどの暗号属性も定義します。 （正式な定義については、付録A.6を参照してください。）"
    },
    {
      "indent": 3,
      "text": "master secret 48-byte secret shared between the client and server.",
      "ja": "マスターシークレット クライアントとサーバー間で共有される48バイトのシークレット。"
    },
    {
      "indent": 3,
      "text": "is resumable A flag indicating whether the session can be used to initiate new connections.",
      "ja": "is resumable セッションを使用して新しい接続を開始できるかどうかを示すフラグ。"
    },
    {
      "indent": 3,
      "text": "These items are then used to create security parameters for use by the record layer when protecting application data. Many connections can be instantiated using the same session through the resumption feature of the TLS Handshake Protocol.",
      "ja": "これらのアイテムは、アプリケーションデータを保護するときにレコードレイヤーで使用するセキュリティパラメーターを作成するために使用されます。 TLSハンドシェイクプロトコルの再開機能により、同じセッションを使用して多くの接続をインスタンス化できます。"
    },
    {
      "indent": 0,
      "text": "7.1. Change Cipher Spec Protocol",
      "section_title": true,
      "ja": "7.1. 暗号仕様プロトコルの変更"
    },
    {
      "indent": 3,
      "text": "The change cipher spec protocol exists to signal transitions in ciphering strategies. The protocol consists of a single message, which is encrypted and compressed under the current (not the pending) connection state. The message consists of a single byte of value 1.",
      "ja": "暗号仕様の変更プロトコルは、暗号化戦略の移行を知らせるために存在します。プロトコルは単一のメッセージで構成され、現在の（保留中ではない）接続状態で暗号化および圧縮されます。メッセージは、値1の1バイトで構成されます。"
    },
    {
      "indent": 6,
      "text": "struct {\n    enum { change_cipher_spec(1), (255) } type;\n} ChangeCipherSpec;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ChangeCipherSpec message is sent by both the client and the server to notify the receiving party that subsequent records will be protected under the newly negotiated CipherSpec and keys. Reception of this message causes the receiver to instruct the record layer to immediately copy the read pending state into the read current state. Immediately after sending this message, the sender MUST instruct the record layer to make the write pending state the write active state.",
      "ja": "ChangeCipherSpecメッセージはクライアントとサーバーの両方から送信され、後続のレコードが新しくネゴシエートされたCipherSpecとキーで保護されることを受信側に通知します。このメッセージを受信すると、受信側はレコードレイヤーに読み取り保留状態を読み取り現在状態にすぐにコピーするように指示します。このメッセージを送信した直後に、送信者はレコードレイヤーに書き込み保留状態を書き込みアクティブ状態にするように指示する必要があります。"
    },
    {
      "indent": 3,
      "text": "(See Section 6.1.) The ChangeCipherSpec message is sent during the handshake after the security parameters have been agreed upon, but before the verifying Finished message is sent.",
      "ja": "（セクション6.1を参照してください。）ChangeCipherSpecメッセージは、ハンドシェイク中にセキュリティパラメータが合意された後、確認済みのFinishedメッセージが送信される前に送信されます。"
    },
    {
      "indent": 3,
      "text": "Note: If a rehandshake occurs while data is flowing on a connection, the communicating parties may continue to send data using the old CipherSpec. However, once the ChangeCipherSpec has been sent, the new CipherSpec MUST be used. The first side to send the ChangeCipherSpec does not know that the other side has finished computing the new keying material (e.g., if it has to perform a time-consuming public key operation). Thus, a small window of time, during which the recipient must buffer the data, MAY exist. In practice, with modern machines this interval is likely to be fairly short.",
      "ja": "注：データが接続上を流れている間に再ハンドシェイクが発生した場合、通信側は古いCipherSpecを使用してデータを送信し続ける場合があります。ただし、ChangeCipherSpecが送信されたら、新しいCipherSpecを使用する必要があります。 ChangeCipherSpecを送信する最初の側は、反対側が新しいキー生成情報の計算を完了したことを知りません（たとえば、時間がかかる公開キー操作を実行する必要がある場合）。したがって、受信者がデータをバッファリングしなければならない小さな時間枠が存在する場合があります。実際には、最近のマシンでは、この間隔はかなり短い可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.2. Alert Protocol",
      "section_title": true,
      "ja": "7.2. アラートプロトコル"
    },
    {
      "indent": 3,
      "text": "One of the content types supported by the TLS record layer is the alert type. Alert messages convey the severity of the message (warning or fatal) and a description of the alert. Alert messages with a level of fatal result in the immediate termination of the connection. In this case, other connections corresponding to the session may continue, but the session identifier MUST be invalidated, preventing the failed session from being used to establish new connections. Like other messages, alert messages are encrypted and compressed, as specified by the current connection state.",
      "ja": "TLSレコードレイヤーでサポートされているコンテンツタイプの1つはアラートタイプです。アラートメッセージは、メッセージの重大度（警告または致命的）とアラートの説明を伝えます。致命的なレベルのアラートメッセージは、接続を即座に終了させます。この場合、セッションに対応する他の接続は継続できますが、セッション識別子を無効にして、失敗したセッションが新しい接続の確立に使用されないようにする必要があります。他のメッセージと同様に、現在の接続状態で指定されているように、アラートメッセージは暗号化および圧縮されます。"
    },
    {
      "indent": 6,
      "text": "enum { warning(1), fatal(2), (255) } AlertLevel;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum {\n    close_notify(0),\n    unexpected_message(10),\n    bad_record_mac(20),\n    decryption_failed_RESERVED(21),\n    record_overflow(22),\n    decompression_failure(30),\n    handshake_failure(40),\n    no_certificate_RESERVED(41),\n    bad_certificate(42),\n    unsupported_certificate(43),\n    certificate_revoked(44),\n    certificate_expired(45),\n    certificate_unknown(46),\n    illegal_parameter(47),\n    unknown_ca(48),\n    access_denied(49),\n    decode_error(50),\n    decrypt_error(51), export_restriction_RESERVED(60),\n    protocol_version(70),\n    insufficient_security(71),\n    internal_error(80),\n    user_canceled(90),\n    no_renegotiation(100),\n    unsupported_extension(110),\n    (255)\n} AlertDescription;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    AlertLevel level;\n    AlertDescription description;\n} Alert;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.1. Closure Alerts",
      "section_title": true,
      "ja": "7.2.1. 閉鎖アラート"
    },
    {
      "indent": 3,
      "text": "The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Either party may initiate the exchange of closing messages.",
      "ja": "クライアントとサーバーは、切り捨て攻撃を回避するために、接続が終了しているという知識を共有する必要があります。どちらの当事者も終了メッセージの交換を開始できます。"
    },
    {
      "indent": 3,
      "text": "close_notify This message notifies the recipient that the sender will not send any more messages on this connection. Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be resumed. This is a change from TLS 1.0 to conform with widespread implementation practice.",
      "ja": "close_notify このメッセージは、送信者がこの接続でこれ以上メッセージを送信しないことを受信者に通知します。 TLS 1.1以降、接続を適切に閉じるのに失敗しても、セッションを再開してはならないということはなくなりました。これは、広く普及している実装慣行に準拠するためのTLS 1.0からの変更点です。"
    },
    {
      "indent": 3,
      "text": "Either party may initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored.",
      "ja": "どちらのパーティも、close_notifyアラートを送信してクローズを開始できます。閉鎖アラートの後に受信したデータは無視されます。"
    },
    {
      "indent": 3,
      "text": "Unless some other fatal alert has been transmitted, each party is required to send a close_notify alert before closing the write side of the connection. The other party MUST respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes. It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.",
      "ja": "他の致命的なアラートが送信されない限り、各パーティは接続の書き込み側を閉じる前にclose_notifyアラートを送信する必要があります。他方のパーティは、自分自身のclose_notifyアラートで応答し、保留中の書き込みを破棄して、接続をすぐに閉じる必要があります。クローズのイニシエーターが、接続の読み取り側を閉じる前に、応答するclose_notifyアラートを待つ必要はありません。"
    },
    {
      "indent": 3,
      "text": "If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding close_notify alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation MAY choose to close the transport without waiting for the responding close_notify. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.",
      "ja": "TLSを使用するアプリケーションプロトコルが、TLS接続が閉じられた後、基になるトランスポートを介してデータが伝送される可能性がある場合、TLS実装は、TLS接続が終了したことをアプリケーション層に示す前に、応答するclose_notifyアラートを受信する必要があります。アプリケーションプロトコルが追加のデータを転送せず、基になるトランスポート接続のみを閉じる場合、実装は、応答するclose_notifyを待たずにトランスポートを閉じることを選択できます（MAY）。この標準のどの部分も、接続のオープンまたはクローズ時を含め、TLSの使用プロファイルがデータ転送を管理する方法を決定するために取られるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note: It is assumed that closing a connection reliably delivers pending data before destroying the transport.",
      "ja": "注：接続を閉じると、トランスポートを破棄する前に、保留中のデータが確実に配信されると想定されています。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Error Alerts",
      "section_title": true,
      "ja": "7.2.2. エラーアラート"
    },
    {
      "indent": 3,
      "text": "Error handling in the TLS Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Upon transmission or receipt of a fatal alert message, both parties immediately close the connection. Servers and clients MUST forget any session-identifiers, keys, and secrets associated with a failed connection. Thus, any connection terminated with a fatal alert MUST NOT be resumed.",
      "ja": "TLSハンドシェイクプロトコルでのエラー処理は非常に簡単です。エラーが検出されると、検出側は相手にメッセージを送信します。致命的な警告メッセージを送信または受信すると、両者は直ちに接続を閉じます。サーバーとクライアントは、失敗した接続に関連付けられたセッション識別子、キー、およびシークレットをすべて忘れる必要があります。したがって、致命的なアラートで終了した接続は再開してはなりません。"
    },
    {
      "indent": 3,
      "text": "Whenever an implementation encounters a condition which is defined as a fatal alert, it MUST send the appropriate alert prior to closing the connection. For all errors where an alert level is not explicitly specified, the sending party MAY determine at its discretion whether to treat this as a fatal error or not. If the implementation chooses to send an alert but intends to close the connection immediately afterwards, it MUST send that alert at the fatal alert level.",
      "ja": "実装が致命的なアラートとして定義されている条件に遭遇した場合は常に、接続を閉じる前に適切なアラートを送信する必要があります。アラートレベルが明示的に指定されていないすべてのエラーについて、送信側は、これを致命的なエラーとして扱うかどうかを自由裁量で決定できます（MAY）。実装がアラートを送信することを選択したが、すぐに接続を閉じるつもりである場合は、そのアラートを致命的なアラートレベルで送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an alert with a level of warning is sent and received, generally the connection can continue normally. If the receiving party decides not to proceed with the connection (e.g., after having received a no_renegotiation alert that it is not willing to accept), it SHOULD send a fatal alert to terminate the connection. Given this, the sending party cannot, in general, know how the receiving party will behave. Therefore, warning alerts are not very useful when the sending party wants to continue the connection, and thus are sometimes omitted. For example, if a peer decides to accept an expired certificate (perhaps after confirming this with the user) and wants to continue the connection, it would not generally send a certificate_expired alert.",
      "ja": "警告レベルのアラートが送受信された場合、通常、接続は正常に続行できます。受信側が接続を続行しないことを決定した場合（たとえば、受け入れる意思がないというno_renegotiationアラートを受信した後）、接続を終了するために致命的なアラートを送信する必要があります（SHOULD）。このため、一般的に、送信側は受信側の動作を知ることができません。したがって、警告アラートは、送信側が接続を継続したい場合にはあまり有用ではないため、省略されることがあります。たとえば、ピアが期限切れの証明書を受け入れることを決定し（おそらくこれをユーザーに確認した後）、接続を続行したい場合、通常はcertificate_expiredアラートを送信しません。"
    },
    {
      "indent": 3,
      "text": "The following error alerts are defined:",
      "ja": "次のエラーアラートが定義されています。"
    },
    {
      "indent": 3,
      "text": "unexpected_message An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.",
      "ja": "unexpected_message 予期しないメッセージを受信しました。このアラートは常に致命的であり、適切な実装間の通信で監視されることはありません。"
    },
    {
      "indent": 3,
      "text": "bad_record_mac This alert is returned if a record is received with an incorrect MAC. This alert also MUST be returned if an alert is sent because a TLSCiphertext decrypted in an invalid way: either it wasn't an even multiple of the block length, or its padding values, when checked, weren't correct. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).",
      "ja": "bad_record_mac このアラートは、不正なMACでレコードを受信した場合に返されます。このアラートは、TLSCiphertextが無効な方法で復号化されたためにアラートが送信された場合にも返される必要があります。つまり、ブロック長の偶数倍でなかったか、チェックされたときのパディング値が正しくなかったかのいずれかです。このメッセージは常に致命的であり、適切な実装間の通信で観察されることはありません（ネットワークでメッセージが破損した場合を除く）。"
    },
    {
      "indent": 3,
      "text": "decryption_failed_RESERVED This alert was used in some earlier versions of TLS, and may have permitted certain attacks against the CBC mode [CBCATT]. It MUST NOT be sent by compliant implementations.",
      "ja": "decryption_failed_RESERVED このアラートは、TLSの以前のバージョンの一部で使用されており、CBCモード[CBCATT]に対する特定の攻撃を許可している可能性があります。準拠した実装から送信してはいけません。"
    },
    {
      "indent": 3,
      "text": "record_overflow A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).",
      "ja": "record_overflow 2 ^ 14 + 2048バイトを超える長さのTLSCiphertextレコード、または2 ^ 14 + 1024バイトを超えるTLSCompressedレコードに復号化されたレコードを受信しました。このメッセージは常に致命的であり、適切な実装間の通信で観察されることはありません（ネットワークでメッセージが破損した場合を除く）。"
    },
    {
      "indent": 3,
      "text": "decompression_failure The decompression function received improper input (e.g., data that would expand to excessive length). This message is always fatal and should never be observed in communication between proper implementations.",
      "ja": "decompression_failure 解凍関数が不適切な入力（たとえば、過度に長くなるデータ）を受け取りました。このメッセージは常に致命的であり、適切な実装間の通信で決して観察されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "handshake_failure Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.",
      "ja": "handshake_failure handshake_failureアラートメッセージの受信は、送信者が、利用可能なオプションを前提として、許容可能なセキュリティパラメータのセットをネゴシエートできなかったことを示します。これは致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "no_certificate_RESERVED This alert was used in SSLv3 but not any version of TLS. It MUST NOT be sent by compliant implementations.",
      "ja": "no_certificate_RESERVED このアラートはSSLv3で使用されましたが、TLSのどのバージョンでも使用されていません。準拠した実装から送信してはいけません。"
    },
    {
      "indent": 3,
      "text": "bad_certificate A certificate was corrupt, contained signatures that did not verify correctly, etc.",
      "ja": "bad_certificate 証明書が破損しているか、正しく検証されない署名が含まれているなど。"
    },
    {
      "indent": 3,
      "text": "unsupported_certificate A certificate was of an unsupported type.",
      "ja": "unsupported_certificate 証明書のタイプはサポートされていません。"
    },
    {
      "indent": 3,
      "text": "certificate_revoked A certificate was revoked by its signer.",
      "ja": "certificate_revoked 証明書が署名者によって取り消されました。"
    },
    {
      "indent": 3,
      "text": "certificate_expired A certificate has expired or is not currently valid.",
      "ja": "certificate_expired 証明書の有効期限が切れているか、現在有効ではありません。"
    },
    {
      "indent": 3,
      "text": "certificate_unknown Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.",
      "ja": "certificate_unknown 証明書の処理中に他の（指定されていない）問題が発生し、受け入れられなくなりました。"
    },
    {
      "indent": 3,
      "text": "illegal_parameter A field in the handshake was out of range or inconsistent with other fields. This message is always fatal.",
      "ja": "illegal_parameter ハンドシェイクのフィールドが範囲外であるか、他のフィールドと矛盾しています。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "unknown_ca A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn't be matched with a known, trusted CA. This message is always fatal.",
      "ja": "unknown_ca 有効な証明書チェーンまたは部分チェーンを受け取りましたが、CA証明書が見つからなかったか、既知の信頼できるCAと一致しなかったため、証明書は受け入れられませんでした。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "access_denied A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.",
      "ja": "access_denied 有効な証明書が受信されましたが、アクセス制御が適用されたときに、送信者はネゴシエーションを続行しないことを決定しました。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decode_error A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).",
      "ja": "decode_error 一部のフィールドが指定された範囲外だったか、メッセージの長さが正しくなかったため、メッセージをデコードできませんでした。このメッセージは常に致命的であり、適切な実装間の通信で観察されることはありません（ネットワークでメッセージが破損した場合を除く）。"
    },
    {
      "indent": 3,
      "text": "decrypt_error A handshake cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message. This message is always fatal.",
      "ja": "decrypt_error ハンドシェイク暗号化操作が失敗しました。これには、署名を正しく検証できない、または完了したメッセージを検証できないなどが含まれます。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "export_restriction_RESERVED This alert was used in some earlier versions of TLS. It MUST NOT be sent by compliant implementations.",
      "ja": "export_restriction_RESERVED このアラートは、一部の以前のバージョンのTLSで使用されていました。準拠した実装から送信してはいけません。"
    },
    {
      "indent": 3,
      "text": "protocol_version The protocol version the client has attempted to negotiate is recognized but not supported. (For example, old protocol versions might be avoided for security reasons.) This message is always fatal.",
      "ja": "protocol_version クライアントが交渉しようとしたプロトコルバージョンは認識されますが、サポートされていません。 （たとえば、セキュリティ上の理由から古いプロトコルバージョンは避けられる場合があります。）このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "insufficient_security Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.",
      "ja": "insufficient_security サーバーがクライアントでサポートされているものよりも安全な暗号を必要とするため、ネゴシエーションが失敗したときにhandshake_failureの代わりに不十分なセキュリティが返されます。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "internal_error An internal error unrelated to the peer or the correctness of the protocol (such as a memory allocation failure) makes it impossible to continue. This message is always fatal.",
      "ja": "internal_error ピアに関係のない内部エラーまたはプロトコルの正確性（メモリ割り当ての失敗など）により、続行できません。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "user_canceled This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.",
      "ja": "user_canceled このハンドシェイクは、プロトコル障害とは無関係の何らかの理由でキャンセルされています。ハンドシェイクの完了後にユーザーが操作をキャンセルした場合は、close_notifyを送信して接続を閉じるだけの方が適切です。このアラートの後には、close_notifyが続く必要があります。このメッセージは通常警告です。"
    },
    {
      "indent": 3,
      "text": "no_renegotiation Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert. At that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate is where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup, and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.",
      "ja": "no_renegotiation 最初のハンドシェイク後に、hello要求に応答してクライアントから送信されるか、クライアントhelloに応答してサーバーから送信されます。これらのいずれかは通常、再交渉につながります。それが適切でない場合、受信者はこのアラートで応答する必要があります。その時点で、元のリクエスターは接続を続行するかどうかを決定できます。これが適切なケースの1つは、サーバーが要求を満たすためにプロセスを生成した場合です。プロセスは起動時にセキュリティパラメータ（キーの長さ、認証など）を受け取り、それ以降にこれらのパラメータへの変更を伝達することが困難になる場合があります。このメッセージは常に警告です。"
    },
    {
      "indent": 3,
      "text": "unsupported_extension sent by clients that receive an extended server hello containing an extension that they did not put in the corresponding client hello. This message is always fatal.",
      "ja": "unsupported_extension 対応するクライアントhelloに入れなかった拡張を含む拡張サーバーhelloを受信するクライアントによって送信されます。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "New Alert values are assigned by IANA as described in Section 12.",
      "ja": "セクション12で説明するように、新しいアラート値はIANAによって割り当てられます。"
    },
    {
      "indent": 0,
      "text": "7.3. Handshake Protocol Overview",
      "section_title": true,
      "ja": "7.3. ハンドシェイクプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS record layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and use public-key encryption techniques to generate shared secrets.",
      "ja": "セッション状態の暗号化パラメーターは、TLSレコードレイヤー上で動作するTLSハンドシェイクプロトコルによって生成されます。 TLSクライアントとサーバーが最初に通信を開始すると、プロトコルバージョンに同意し、暗号化アルゴリズムを選択し、オプションで相互に認証し、公開鍵暗号化技術を使用して共有シークレットを生成します。"
    },
    {
      "indent": 3,
      "text": "The TLS Handshake Protocol involves the following steps:",
      "ja": "TLSハンドシェイクプロトコルには、次の手順が含まれます。"
    },
    {
      "indent": 3,
      "text": "- Exchange hello messages to agree on algorithms, exchange random values, and check for session resumption.",
      "ja": "- helloメッセージを交換してアルゴリズムについて合意し、ランダムな値を交換し、セッションの再開を確認します。"
    },
    {
      "indent": 3,
      "text": "- Exchange the necessary cryptographic parameters to allow the client and server to agree on a premaster secret.",
      "ja": "- 必要な暗号化パラメーターを交換して、クライアントとサーバーがプリマスターシークレットについて合意できるようにします。"
    },
    {
      "indent": 3,
      "text": "- Exchange certificates and cryptographic information to allow the client and server to authenticate themselves.",
      "ja": "- 証明書と暗号化情報を交換して、クライアントとサーバーが自分自身を認証できるようにします。"
    },
    {
      "indent": 3,
      "text": "- Generate a master secret from the premaster secret and exchanged random values.",
      "ja": "- プリマスターシークレットからマスターシークレットを生成し、ランダムな値を交換します。"
    },
    {
      "indent": 3,
      "text": "- Provide security parameters to the record layer.",
      "ja": "- レコードパラメータにセキュリティパラメータを提供します。"
    },
    {
      "indent": 3,
      "text": "- Allow the client and server to verify that their peer has calculated the same security parameters and that the handshake occurred without tampering by an attacker.",
      "ja": "- クライアントとサーバーが、ピアが同じセキュリティパラメータを計算したことと、攻撃者が改ざんせずにハンドシェイクが行われたことを確認できるようにします。"
    },
    {
      "indent": 3,
      "text": "Note that higher layers should not be overly reliant on whether TLS always negotiates the strongest possible connection between two peers. There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support. The protocol has been designed to minimize this risk, but there are still attacks available: for example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure in that any cipher suite offers its promised level of security: if you negotiate 3DES with a 1024-bit RSA key exchange with a host whose certificate you have verified, you can expect to be that secure.",
      "ja": "上位層は、TLSが常に2つのピア間の可能な限り最強の接続をネゴシエートするかどうかに過度に依存すべきではないことに注意してください。中間者攻撃者が2つのエンティティをサポートする最も安全性の低い方法にドロップダウンさせる方法はいくつかあります。プロトコルはこのリスクを最小限に抑えるように設計されていますが、利用可能な攻撃はまだあります。たとえば、攻撃者は安全なサービスが実行されているポートへのアクセスをブロックしたり、ピアに認証されていない接続をネゴシエートさせたりする可能性があります。基本的なルールは、上位レベルはセキュリティ要件が何であるかを認識している必要があり、必要なものよりも安全性の低いチャネルを介して情報を送信してはならないということです。 TLSプロトコルは安全であり、どの暗号スイートでも約束されたレベルのセキュリティが提供されます。1024ビットのRSA鍵交換で3DESを、証明書を検証したホストとネゴシエートすると、その安全性が期待できます。"
    },
    {
      "indent": 3,
      "text": "These goals are achieved by the handshake protocol, which can be summarized as follows: The client sends a ClientHello message to which the server must respond with a ServerHello message, or else a fatal error will occur and the connection will fail. The ClientHello and ServerHello are used to establish security enhancement capabilities between client and server. The ClientHello and ServerHello establish the following attributes: Protocol Version, Session ID, Cipher Suite, and Compression Method. Additionally, two random values are generated and exchanged: ClientHello.random and ServerHello.random.",
      "ja": "これらの目標は、次のように要約できるハンドシェイクプロトコルによって達成されます。クライアントはClientHelloメッセージを送信します。これに対してサーバーはServerHelloメッセージで応答する必要があります。そうしないと、致命的なエラーが発生して接続が失敗します。 ClientHelloとServerHelloは、クライアントとサーバー間のセキュリティ強化機能を確立するために使用されます。 ClientHelloとServerHelloは、プロトコルバージョン、セッションID、暗号スイート、および圧縮方法の属性を確立します。さらに、2つのランダムな値が生成および交換されます：ClientHello.randomとServerHello.random。"
    },
    {
      "indent": 3,
      "text": "The actual key exchange uses up to four messages: the server Certificate, the ServerKeyExchange, the client Certificate, and the ClientKeyExchange. New key exchange methods can be created by specifying a format for these messages and by defining the use of the messages to allow the client and server to agree upon a shared secret. This secret MUST be quite long; currently defined key exchange methods exchange secrets that range from 46 bytes upwards.",
      "ja": "実際の鍵交換では、最大4つのメッセージ（サーバー証明書、ServerKeyExchange、クライアント証明書、およびClientKeyExchange）を使用します。これらのメッセージの形式を指定し、メッセージの使用を定義してクライアントとサーバーが共有シークレットに同意できるようにすることで、新しい鍵交換方法を作成できます。この秘密はかなり長くなければなりません。現在定義されている鍵交換メソッドは、46バイト以上の範囲の秘密を交換します。"
    },
    {
      "indent": 3,
      "text": "Following the hello messages, the server will send its certificate in a Certificate message if it is to be authenticated. Additionally, a ServerKeyExchange message may be sent, if it is required (e.g., if the server has no certificate, or if its certificate is for signing only). If the server is authenticated, it may request a certificate from the client, if that is appropriate to the cipher suite selected. Next, the server will send the ServerHelloDone message, indicating that the hello-message phase of the handshake is complete. The server will then wait for a client response. If the server has sent a CertificateRequest message, the client MUST send the Certificate message. The ClientKeyExchange message is now sent, and the content of that message will depend on the public key algorithm selected between the ClientHello and the ServerHello. If the client has sent a certificate with signing ability, a digitally-signed CertificateVerify message is sent to explicitly verify possession of the private key in the certificate.",
      "ja": "helloメッセージに続いて、サーバーは、認証される場合、証明書メッセージで証明書を送信します。さらに、ServerKeyExchangeメッセージは、必要な場合（サーバーに証明書がない場合、またはサーバーの証明書が署名専用の場合など）に送信される場合があります。サーバーが認証されると、選択された暗号スイートに適切である場合、サーバーはクライアントに証明書を要求します。次に、サーバーはServerHelloDoneメッセージを送信し、ハンドシェイクのhello-messageフェーズが完了したことを示します。その後、サーバーはクライアントの応答を待ちます。サーバーがCertificateRequestメッセージを送信した場合、クライアントはCertificateメッセージを送信する必要があります。これでClientKeyExchangeメッセージが送信され、そのメッセージの内容は、ClientHelloとServerHelloの間で選択された公開鍵アルゴリズムに依存します。クライアントが署名機能付きの証明書を送信した場合、デジタル署名されたCertificateVerifyメッセージが送信され、証明書内の秘密鍵の所有を明示的に確認します。"
    },
    {
      "indent": 3,
      "text": "At this point, a ChangeCipherSpec message is sent by the client, and the client copies the pending Cipher Spec into the current Cipher Spec. The client then immediately sends the Finished message under the new algorithms, keys, and secrets. In response, the server will send its own ChangeCipherSpec message, transfer the pending to the current Cipher Spec, and send its Finished message under the new Cipher Spec. At this point, the handshake is complete, and the client and server may begin to exchange application layer data. (See flow chart below.) Application data MUST NOT be sent prior to the completion of the first handshake (before a cipher suite other than TLS_NULL_WITH_NULL_NULL is established).",
      "ja": "この時点で、クライアントからChangeCipherSpecメッセージが送信され、クライアントは保留中の暗号仕様を現在の暗号仕様にコピーします。次に、クライアントは、新しいアルゴリズム、キー、およびシークレットを使用して、直ちにFinishedメッセージを送信します。応答として、サーバーは独自のChangeCipherSpecメッセージを送信し、保留を現在の暗号仕様に転送し、新しい暗号仕様の下で完了メッセージを送信します。この時点で、ハンドシェイクが完了し、クライアントとサーバーがアプリケーション層データの交換を開始します。 （以下のフローチャートを参照してください。）最初のハンドシェイクが完了する前（TLS_NULL_WITH_NULL_NULL以外の暗号スイートが確立される前）に、アプリケーションデータを送信してはなりません（MUST NOT）。"
    },
    {
      "indent": 6,
      "text": "Client Server",
      "ja": "クライアントサーバー"
    },
    {
      "indent": 6,
      "text": "ClientHello                  -------->\n                                                ServerHello\n                                               Certificate*\n                                         ServerKeyExchange*\n                                        CertificateRequest*\n                             <--------      ServerHelloDone\nCertificate*\nClientKeyExchange\nCertificateVerify*\n[ChangeCipherSpec]\nFinished                     -------->\n                                         [ChangeCipherSpec]\n                             <--------             Finished\nApplication Data             <------->     Application Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 1. Message flow for a full handshake",
      "ja": "図1.フルハンドシェイクのメッセージフロー"
    },
    {
      "indent": 3,
      "text": "* Indicates optional or situation-dependent messages that are not always sent.",
      "ja": "* 常に送信されるわけではないオプションのメッセージまたは状況依存のメッセージを示します。"
    },
    {
      "indent": 3,
      "text": "Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS protocol content type, and is not actually a TLS handshake message.",
      "ja": "注：パイプラインのストールを回避するために、ChangeCipherSpecは独立したTLSプロトコルコンテンツタイプであり、実際にはTLSハンドシェイクメッセージではありません。"
    },
    {
      "indent": 3,
      "text": "When the client and server decide to resume a previous session or duplicate an existing session (instead of negotiating new security parameters), the message flow is as follows:",
      "ja": "クライアントとサーバーが（新しいセキュリティパラメータをネゴシエートする代わりに）以前のセッションを再開するか、既存のセッションを複製することを決定した場合、メッセージフローは次のようになります。"
    },
    {
      "indent": 3,
      "text": "The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match. If a match is found, and the server is willing to re-establish the connection under the specified session state, it will send a ServerHello with the same Session ID value. At this point, both client and server MUST send ChangeCipherSpec messages and proceed directly to Finished messages. Once the re-establishment is complete, the client and server MAY begin to exchange application layer data. (See flow chart below.) If a Session ID match is not found, the server generates a new session ID, and the TLS client and server perform a full handshake.",
      "ja": "クライアントは、再開するセッションのセッションIDを使用してClientHelloを送信します。次に、サーバーはセッションキャッシュをチェックして一致するかどうかを確認します。一致が見つかり、サーバーが指定されたセッション状態で接続を再確立する用意がある場合、同じセッションID値でServerHelloを送信します。この時点で、クライアントとサーバーの両方がChangeCipherSpecメッセージを送信し、完了メッセージに直接進む必要があります。再確立が完了すると、クライアントとサーバーはアプリケーション層データの交換を開始する場合があります。 （以下のフローチャートを参照してください。）セッションIDの一致が見つからない場合、サーバーは新しいセッションIDを生成し、TLSクライアントとサーバーは完全なハンドシェイクを実行します。"
    },
    {
      "indent": 6,
      "text": "Client Server",
      "ja": "クライアントサーバー"
    },
    {
      "indent": 6,
      "text": "ClientHello                   -------->\n                                                 ServerHello\n                                          [ChangeCipherSpec]\n                              <--------             Finished\n[ChangeCipherSpec]\nFinished                      -------->\nApplication Data              <------->     Application Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 2. Message flow for an abbreviated handshake",
      "ja": "図2.省略されたハンドシェイクのメッセージフロー"
    },
    {
      "indent": 3,
      "text": "The contents and significance of each message will be presented in detail in the following sections.",
      "ja": "各メッセージの内容と重要性については、次のセクションで詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "7.4. Handshake Protocol",
      "section_title": true,
      "ja": "7.4. ハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "The TLS Handshake Protocol is one of the defined higher-level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext structures, which are processed and transmitted as specified by the current active session state.",
      "ja": "TLSハンドシェイクプロトコルは、TLSレコードプロトコルの定義済みの高レベルクライアントの1つです。このプロトコルは、セッションの安全な属性をネゴシエートするために使用されます。ハンドシェイクメッセージはTLSレコードレイヤーに提供され、1つ以上のTLSPlaintext構造内にカプセル化されます。これらの構造は、現在のアクティブセッション状態で指定されたとおりに処理および送信されます。"
    },
    {
      "indent": 6,
      "text": "enum {\n    hello_request(0), client_hello(1), server_hello(2),\n    certificate(11), server_key_exchange (12),\n    certificate_request(13), server_hello_done(14),\n    certificate_verify(15), client_key_exchange(16),\n    finished(20), (255)\n} HandshakeType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    HandshakeType msg_type;    /* handshake type */\n    uint24 length;             /* bytes in message */\n    select (HandshakeType) {\n        case hello_request:       HelloRequest;\n        case client_hello:        ClientHello;\n        case server_hello:        ServerHello;\n        case certificate:         Certificate;\n        case server_key_exchange: ServerKeyExchange;\n        case certificate_request: CertificateRequest;\n        case server_hello_done:   ServerHelloDone;\n        case certificate_verify:  CertificateVerify;\n        case client_key_exchange: ClientKeyExchange;\n        case finished:            Finished;\n    } body;\n} Handshake;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The handshake protocol messages are presented below in the order they MUST be sent; sending handshake messages in an unexpected order results in a fatal error. Unneeded handshake messages can be omitted, however. Note one exception to the ordering: the Certificate message is used twice in the handshake (from server to client, then from client to server), but described only in its first position. The one message that is not bound by these ordering rules is the HelloRequest message, which can be sent at any time, but which SHOULD be ignored by the client if it arrives in the middle of a handshake.",
      "ja": "以下に、ハンドシェイクプロトコルメッセージを送信する必要がある順序で示します。予期しない順序でハンドシェイクメッセージを送信すると、致命的なエラーが発生します。ただし、不要なハンドシェイクメッセージは省略できます。順序付けの1つの例外に注意してください。証明書メッセージはハンドシェイクで2回（サーバーからクライアントへ、次にクライアントからサーバーへ）使用されますが、最初の位置でのみ説明されています。これらの順序付けルールに拘束されない1つのメッセージはHelloRequestメッセージであり、いつでも送信できますが、ハンドシェイクの途中で到着した場合、クライアントはこれを無視する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "New handshake message types are assigned by IANA as described in Section 12.",
      "ja": "セクション12で説明するように、新しいハンドシェイクメッセージタイプはIANAによって割り当てられます。"
    },
    {
      "indent": 0,
      "text": "7.4.1. Hello Messages",
      "section_title": true,
      "ja": "7.4.1. こんにちはメッセージ"
    },
    {
      "indent": 3,
      "text": "The hello phase messages are used to exchange security enhancement capabilities between the client and server. When a new session begins, the record layer's connection state encryption, hash, and compression algorithms are initialized to null. The current connection state is used for renegotiation messages.",
      "ja": "helloフェーズメッセージは、クライアントとサーバー間でセキュリティ強化機能を交換するために使用されます。新しいセッションが始まると、レコードレイヤーの接続状態の暗号化、ハッシュ、および圧縮アルゴリズムはnullに初期化されます。現在の接続状態は、再ネゴシエーションメッセージに使用されます。"
    },
    {
      "indent": 0,
      "text": "7.4.1.1. Hello Request",
      "section_title": true,
      "ja": "7.4.1.1. こんにちはリクエスト"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "The HelloRequest message MAY be sent by the server at any time.",
      "ja": "HelloRequestメッセージはいつでもサーバーから送信できます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "HelloRequest is a simple notification that the client should begin the negotiation process anew. In response, the client should send a ClientHello message when convenient. This message is not intended to establish which side is the client or server but merely to initiate a new negotiation. Servers SHOULD NOT send a HelloRequest immediately upon the client's initial connection. It is the client's job to send a ClientHello at that time.",
      "ja": "HelloRequestは、クライアントがネゴシエーションプロセスを新たに開始する必要があるという単純な通知です。応答として、クライアントは都合のよいときにClientHelloメッセージを送信する必要があります。このメッセージは、どちらの側がクライアントまたはサーバーであるかを確立するためのものではなく、単に新しいネゴシエーションを開始するためのものです。サーバーは、クライアントの初期接続時にすぐにHelloRequestを送信しないでください。その時にClientHelloを送信するのはクライアントの仕事です。"
    },
    {
      "indent": 6,
      "text": "This message will be ignored by the client if the client is currently negotiating a session. This message MAY be ignored by the client if it does not wish to renegotiate a session, or the client may, if it wishes, respond with a no_renegotiation alert. Since handshake messages are intended to have transmission precedence over application data, it is expected that the negotiation will begin before no more than a few records are received from the client. If the server sends a HelloRequest but does not receive a ClientHello in response, it may close the connection with a fatal alert.",
      "ja": "クライアントが現在セッションをネゴシエートしている場合、このメッセージはクライアントによって無視されます。このメッセージは、セッションを再ネゴシエートしたくない場合はクライアントによって無視される場合があります。または、クライアントが希望する場合は、no_renegotiationアラートで応答できます。ハンドシェイクメッセージはアプリケーションデータよりも送信の優先度を高くすることを目的としているため、クライアントから受信するレコードが数個以下になる前にネゴシエーションが開始されることが予想されます。サーバーがHelloRequestを送信してもClientHelloを受信しない場合、致命的なアラートで接続を閉じることがあります。"
    },
    {
      "indent": 6,
      "text": "After sending a HelloRequest, servers SHOULD NOT repeat the request until the subsequent handshake negotiation is complete.",
      "ja": "HelloRequestを送信した後、サーバーは次のハンドシェイクネゴシエーションが完了するまで要求を繰り返さないでください（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct { } HelloRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This message MUST NOT be included in the message hashes that are maintained throughout the handshake and used in the Finished messages and the certificate verify message.",
      "ja": "このメッセージは、ハンドシェイク全体で維持され、終了メッセージと証明書検証メッセージで使用されるメッセージハッシュに含めることはできません。"
    },
    {
      "indent": 0,
      "text": "7.4.1.2. Client Hello",
      "section_title": true,
      "ja": "7.4.1.2. こんにちは"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "When a client first connects to a server, it is required to send the ClientHello as its first message. The client can also send a ClientHello in response to a HelloRequest or on its own initiative in order to renegotiate the security parameters in an existing connection.",
      "ja": "クライアントが最初にサーバーに接続するとき、最初のメッセージとしてClientHelloを送信する必要があります。クライアントは、HelloRequestへの応答として、または既存の接続でセキュリティパラメータを再ネゴシエートするために独自のイニシアチブでClientHelloを送信することもできます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "The ClientHello message includes a random structure, which is used later in the protocol.",
      "ja": "ClientHelloメッセージには、後でプロトコルで使用されるランダムな構造が含まれています。"
    },
    {
      "indent": 9,
      "text": "struct {\n    uint32 gmt_unix_time;\n    opaque random_bytes[28];\n} Random;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "gmt_unix_time The current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, UTC, ignoring leap seconds) according to the sender's internal clock. Clocks are not required to be set correctly by the basic TLS protocol; higher-level or application protocols may define additional requirements. Note that, for historical reasons, the data element is named using GMT, the predecessor of the current worldwide time base, UTC.",
      "ja": "gmt_unix_time送信者の内部クロックによる、標準のUNIX 32ビット形式の現在の日時（1970年1月1日から始まる午前0時からの秒数、UTC、うるう秒は無視）。基本的なTLSプロトコルでクロックを正しく設定する必要はありません。より高いレベルまたはアプリケーションプロトコルは、追加の要件を定義する場合があります。歴史的な理由により、データ要素は現在の世界的なタイムベースであるUTCの前身であるGMTを使用して名前が付けられていることに注意してください。"
    },
    {
      "indent": 6,
      "text": "random_bytes 28 bytes generated by a secure random number generator.",
      "ja": "random_bytes安全な乱数ジェネレータによって生成された28バイト。"
    },
    {
      "indent": 3,
      "text": "The ClientHello message includes a variable-length session identifier. If not empty, the value identifies a session between the same client and server whose security parameters the client wishes to reuse. The session identifier MAY be from an earlier connection, this connection, or from another currently active connection. The second option is useful if the client only wishes to update the random structures and derived values of a connection, and the third option makes it possible to establish several independent secure connections without repeating the full handshake protocol. These independent connections may occur sequentially or simultaneously; a SessionID becomes valid when the handshake negotiating it completes with the exchange of Finished messages and persists until it is removed due to aging or because a fatal error was encountered on a connection associated with the session. The actual contents of the SessionID are defined by the server.",
      "ja": "ClientHelloメッセージには、可変長のセッション識別子が含まれています。空でない場合、値は、同じクライアントと、クライアントが再利用したいセキュリティパラメータを持つサーバー間のセッションを識別します。セッション識別子は、以前の接続、この接続、または現在アクティブな別の接続からのものである場合があります。 2番目のオプションは、クライアントが接続のランダムな構造と派生値のみを更新する場合に便利です。3番目のオプションを使用すると、完全なハンドシェイクプロトコルを繰り返さなくても、複数の独立した安全な接続を確立できます。これらの独立した接続は、順次または同時に発生します。セッションIDは、ネゴシエートするハンドシェイクが完了メッセージの交換で完了したときに有効になり、エージングまたはセッションに関連付けられた接続で致命的なエラーが発生したために削除されるまで保持されます。 SessionIDの実際の内容はサーバーによって定義されます。"
    },
    {
      "indent": 6,
      "text": "opaque SessionID<0..32>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Warning: Because the SessionID is transmitted without encryption or immediate MAC protection, servers MUST NOT place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)",
      "ja": "警告：SessionIDは暗号化または即時MAC保護なしで送信されるため、サーバーはセッション識別子に機密情報を入れたり、偽のセッション識別子の内容がセキュリティ違反を引き起こしてはなりません。 （SessionIDを含む、全体としてのハンドシェイクのコンテンツは、ハンドシェイクの最後に交換されるFinishedメッセージによって保護されることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "The cipher suite list, passed from the client to the server in the ClientHello message, contains the combinations of cryptographic algorithms supported by the client in order of the client's preference (favorite choice first). Each cipher suite defines a key exchange algorithm, a bulk encryption algorithm (including secret key length), a MAC algorithm, and a PRF. The server will select a cipher suite or, if no acceptable choices are presented, return a handshake failure alert and close the connection. If the list contains cipher suites the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites, and process the remaining ones as usual.",
      "ja": "ClientHelloメッセージでクライアントからサーバーに渡される暗号スイートリストには、クライアントの優先順（優先順が最初）でクライアントがサポートする暗号化アルゴリズムの組み合わせが含まれています。各暗号スイートは、鍵交換アルゴリズム、バルク暗号化アルゴリズム（秘密鍵の長さを含む）、MACアルゴリズム、およびPRFを定義します。サーバーは暗号スイートを選択するか、受け入れ可能な選択肢が提示されない場合は、ハンドシェイク失敗アラートを返し、接続を閉じます。リストにサーバーが認識、サポート、または使用を希望しない暗号スイートが含まれている場合、サーバーはそれらの暗号スイートを無視し、残りの暗号スイートを通常どおり処理する必要があります。"
    },
    {
      "indent": 6,
      "text": "uint8 CipherSuite[2];    /* Cryptographic suite selector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ClientHello includes a list of compression algorithms supported by the client, ordered according to the client's preference.",
      "ja": "ClientHelloには、クライアントの設定に従って並べられた、クライアントでサポートされている圧縮アルゴリズムのリストが含まれています。"
    },
    {
      "indent": 6,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    ProtocolVersion client_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suites<2..2^16-2>;\n    CompressionMethod compression_methods<1..2^8-1>;\n    select (extensions_present) {\n        case false:\n            struct {};\n        case true:\n            Extension extensions<0..2^16-1>;\n    };\n} ClientHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TLS allows extensions to follow the compression_methods field in an extensions block. The presence of extensions can be detected by determining whether there are bytes following the compression_methods at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined.",
      "ja": "TLSでは、拡張機能が拡張機能ブロックのcompression_methodsフィールドに続くことができます。拡張の存在は、ClientHelloの最後にあるcompression_methodsに続くバイトがあるかどうかを判断することで検出できます。このオプションのデータを検出する方法は、可変長フィールドを持つ通常のTLS方法とは異なりますが、拡張が定義される前のTLSとの互換性のために使用されます。"
    },
    {
      "indent": 3,
      "text": "client_version The version of the TLS protocol by which the client wishes to communicate during this session. This SHOULD be the latest (highest valued) version supported by the client. For this version of the specification, the version will be 3.3 (see Appendix E for details about backward compatibility).",
      "ja": "client_versionクライアントがこのセッション中に通信したいTLSプロトコルのバージョン。これは、クライアントがサポートする最新の（最も価値の高い）バージョンである必要があります（SHOULD）。このバージョンの仕様では、バージョンは3.3になります（下位互換性の詳細については、付録Eを参照してください）。"
    },
    {
      "indent": 3,
      "text": "random A client-generated random structure.",
      "ja": "randomクライアントが生成したランダムな構造。"
    },
    {
      "indent": 3,
      "text": "session_id The ID of a session the client wishes to use for this connection. This field is empty if no session_id is available, or if the client wishes to generate new security parameters.",
      "ja": "session_idクライアントがこの接続に使用するセッションのID。使用可能なsession_idがない場合、またはクライアントが新しいセキュリティパラメータを生成する場合は、このフィールドは空です。"
    },
    {
      "indent": 3,
      "text": "cipher_suites This is a list of the cryptographic options supported by the client, with the client's first preference first. If the session_id field is not empty (implying a session resumption request), this vector MUST include at least the cipher_suite from that session. Values are defined in Appendix A.5.",
      "ja": "cipher_suitesこれは、クライアントがサポートする暗号化オプションのリストで、クライアントの最初の設定が最初です。 session_idフィールドが空でない場合（セッション再開要求を意味します）、このベクターには少なくともそのセッションからのcipher_suiteが含まれている必要があります。値は付録A.5で定義されています。"
    },
    {
      "indent": 3,
      "text": "compression_methods This is a list of the compression methods supported by the client, sorted by client preference. If the session_id field is not empty (implying a session resumption request), it MUST include the compression_method from that session. This vector MUST contain, and all implementations MUST support, CompressionMethod.null. Thus, a client and server will always be able to agree on a compression method.",
      "ja": "compression_methodsこれは、クライアント設定でソートされた、クライアントでサポートされている圧縮方式のリストです。 session_idフィールドが空でない場合（セッション再開要求を意味します）、そのセッションからのcompression_methodを含める必要があります。このベクターはCompressionMethod.nullを含んでいる必要があり、すべての実装がサポートする必要があります。したがって、クライアントとサーバーは常に圧縮方法について合意することができます。"
    },
    {
      "indent": 3,
      "text": "extensions Clients MAY request extended functionality from servers by sending data in the extensions field. The actual \"Extension\" format is defined in Section 7.4.1.4.",
      "ja": "extensionsクライアントは、extensionsフィールドでデータを送信することにより、サーバーに拡張機能を要求できます。実際の「拡張子」フォーマットは、セクション7.4.1.4で定義されています。"
    },
    {
      "indent": 3,
      "text": "In the event that a client requests additional functionality using extensions, and this functionality is not supplied by the server, the client MAY abort the handshake. A server MUST accept ClientHello messages both with and without the extensions field, and (as for all other messages) it MUST check that the amount of data in the message precisely matches one of these formats; if not, then it MUST send a fatal \"decode_error\" alert.",
      "ja": "クライアントが拡張機能を使用して追加の機能を要求し、この機能がサーバーによって提供されていない場合、クライアントはハンドシェイクを中止してもよい（MAY）。サーバーは、拡張フィールドがある場合とない場合の両方でClientHelloメッセージを受け入れる必要があり、（他のすべてのメッセージと同様に）メッセージ内のデータ量がこれらの形式のいずれかに正確に一致することを確認する必要があります。そうでない場合は、致命的な「decode_error」アラートを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "After sending the ClientHello message, the client waits for a ServerHello message. Any handshake message returned by the server, except for a HelloRequest, is treated as a fatal error.",
      "ja": "ClientHelloメッセージを送信した後、クライアントはServerHelloメッセージを待ちます。 HelloRequestを除き、サーバーから返されたハンドシェイクメッセージはすべて致命的なエラーとして扱われます。"
    },
    {
      "indent": 0,
      "text": "7.4.1.3. Server Hello",
      "section_title": true,
      "ja": "7.4.1.3. サーバーこんにちは"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "The server will send this message in response to a ClientHello message when it was able to find an acceptable set of algorithms. If it cannot find such a match, it will respond with a handshake failure alert.",
      "ja": "サーバーは、許容可能なアルゴリズムのセットを見つけることができたときに、ClientHelloメッセージへの応答としてこのメ​​ッセージを送信します。そのような一致が見つからない場合は、ハンドシェイク失敗アラートで応答します。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct {\n    ProtocolVersion server_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suite;\n    CompressionMethod compression_method;\n    select (extensions_present) {\n        case false:\n            struct {};\n        case true:\n            Extension extensions<0..2^16-1>;\n    };\n} ServerHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The presence of extensions can be detected by determining whether there are bytes following the compression_method field at the end of the ServerHello.",
      "ja": "拡張機能の存在は、ServerHelloの最後にあるcompression_methodフィールドに続くバイトがあるかどうかを判断することで検出できます。"
    },
    {
      "indent": 3,
      "text": "server_version This field will contain the lower of that suggested by the client in the client hello and the highest supported by the server. For this version of the specification, the version is 3.3. (See Appendix E for details about backward compatibility.)",
      "ja": "server_version このフィールドには、クライアントがクライアントhelloで提案した値の低い方と、サーバーがサポートする最も高い方が含まれます。このバージョンの仕様では、バージョンは3.3です。 （下位互換性の詳細については、付録Eを参照してください。）"
    },
    {
      "indent": 3,
      "text": "random This structure is generated by the server and MUST be independently generated from the ClientHello.random.",
      "ja": "random この構造はサーバーによって生成され、ClientHello.randomから独立して生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "session_id This is the identity of the session corresponding to this connection. If the ClientHello.session_id was non-empty, the server will look in its session cache for a match. If a match is found and the server is willing to establish the new connection using the specified session state, the server will respond with the same value as was supplied by the client. This indicates a resumed session and dictates that the parties must proceed directly to the Finished messages. Otherwise, this field will contain a different value identifying the new session. The server may return an empty session_id to indicate that the session will not be cached and therefore cannot be resumed. If a session is resumed, it must be resumed using the same cipher suite it was originally negotiated with. Note that there is no requirement that the server resume any session even if it had formerly provided a session_id. Clients MUST be prepared to do a full negotiation -- including negotiating new cipher suites -- during any handshake.",
      "ja": "session_id これは、この接続に対応するセッションのIDです。 ClientHello.session_idが空でない場合、サーバーは一致するかどうかセッションキャッシュを調べます。一致が見つかり、サーバーが指定されたセッション状態を使用して新しい接続を確立する用意がある場合、サーバーはクライアントから提供されたものと同じ値で応答します。これは、再開されたセッションを示し、当事者が終了メッセージに直接進む必要があることを示します。それ以外の場合、このフィールドには、新しいセッションを識別する別の値が含まれます。サーバーは空のsession_idを返し、セッションがキャッシュされないため再開できないことを示します。セッションを再開する場合は、最初にネゴシエートしたときと同じ暗号スイートを使用して再開する必要があります。以前にsession_idを提供していた場合でも、サーバーがセッションを再開する必要はないことに注意してください。クライアントは、すべてのハンドシェイク中に、完全なネゴシエーション（新しい暗号スイートのネゴシエーションを含む）を実行できるように準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "cipher_suite The single cipher suite selected by the server from the list in ClientHello.cipher_suites. For resumed sessions, this field is the value from the state of the session being resumed.",
      "ja": "cipher_suite サーバーがClientHello.cipher_suitesのリストから選択した単一の暗号スイート。再開されたセッションの場合、このフィールドは、再開されているセッションの状態からの値です。"
    },
    {
      "indent": 3,
      "text": "compression_method The single compression algorithm selected by the server from the list in ClientHello.compression_methods. For resumed sessions, this field is the value from the resumed session state.",
      "ja": "compression_method ClientHello.compression_methodsのリストからサーバーが選択した単一の圧縮アルゴリズム。再開されたセッションの場合、このフィールドは再開されたセッション状態からの値です。"
    },
    {
      "indent": 3,
      "text": "extensions A list of extensions. Note that only extensions offered by the client can appear in the server's list.",
      "ja": "extensions 拡張機能のリスト。クライアントが提供する拡張機能のみがサーバーのリストに表示されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.4.1.4. Hello Extensions",
      "section_title": true,
      "ja": "7.4.1.4. こんにちは拡張"
    },
    {
      "indent": 3,
      "text": "The extension format is:",
      "ja": "拡張形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "struct {\n    ExtensionType extension_type;\n    opaque extension_data<0..2^16-1>;\n} Extension;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum {\n    signature_algorithms(13), (65535)\n} ExtensionType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Here:",
      "ja": "ここに："
    },
    {
      "indent": 3,
      "text": "- \"extension_type\" identifies the particular extension type.",
      "ja": "- 「extension_type」は、特定の拡張タイプを識別します。"
    },
    {
      "indent": 3,
      "text": "- \"extension_data\" contains information specific to the particular extension type.",
      "ja": "- 「extension_data」には、特定の拡張タイプに固有の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The initial set of extensions is defined in a companion document [TLSEXT]. The list of extension types is maintained by IANA as described in Section 12.",
      "ja": "拡張機能の最初のセットは、関連ドキュメント[TLSEXT]で定義されています。拡張タイプのリストは、セクション12で説明されているように、IANAによって維持されます。"
    },
    {
      "indent": 3,
      "text": "An extension type MUST NOT appear in the ServerHello unless the same extension type appeared in the corresponding ClientHello. If a client receives an extension type in ServerHello that it did not request in the associated ClientHello, it MUST abort the handshake with an unsupported_extension fatal alert.",
      "ja": "拡張タイプは、同じ拡張タイプが対応するClientHelloに表示されない限り、ServerHelloに表示してはなりません（MUST NOT）。クライアントが、関連付けられたClientHelloで要求しなかった拡張タイプをServerHelloで受信した場合、unsupported_extensionの致命的なアラートでハンドシェイクを中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "Nonetheless, \"server-oriented\" extensions may be provided in the future within this framework. Such an extension (say, of type x) would require the client to first send an extension of type x in a ClientHello with empty extension_data to indicate that it supports the extension type. In this case, the client is offering the capability to understand the extension type, and the server is taking the client up on its offer.",
      "ja": "それにもかかわらず、「サーバー指向」の拡張機能は、このフレームワーク内で将来提供される可能性があります。そのような拡張（たとえば、タイプx）は、クライアントが拡張タイプをサポートすることを示すために、最初に空のextension_dataを使用してClientHelloでタイプxの拡張を送信する必要があります。この場合、クライアントは拡張機能のタイプを理解する機能を提供しており、サーバーはその提案に基づいてクライアントを取り上げます。"
    },
    {
      "indent": 3,
      "text": "When multiple extensions of different types are present in the ClientHello or ServerHello messages, the extensions MAY appear in any order. There MUST NOT be more than one extension of the same type.",
      "ja": "ClientHelloまたはServerHelloメッセージに異なるタイプの複数の拡張が存在する場合、拡張は任意の順序で表示される場合があります。同じタイプの複数の拡張があってはなりません。"
    },
    {
      "indent": 3,
      "text": "Finally, note that extensions can be sent both when starting a new session and when requesting session resumption. Indeed, a client that requests session resumption does not in general know whether the server will accept this request, and therefore it SHOULD send the same extensions as it would send if it were not attempting resumption.",
      "ja": "最後に、新しいセッションを開始するときとセッションの再開を要求するときの両方で拡張機能を送信できることに注意してください。実際、セッションの再開を要求するクライアントは通常、サーバーがこの要求を受け入れるかどうかを認識していないため、再開を試みなかった場合と同じ拡張子を送信する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "In general, the specification of each extension type needs to describe the effect of the extension both during full handshake and session resumption. Most current TLS extensions are relevant only when a session is initiated: when an older session is resumed, the server does not process these extensions in Client Hello, and does not include them in Server Hello. However, some extensions may specify different behavior during session resumption.",
      "ja": "一般に、各拡張タイプの仕様は、完全なハンドシェイクとセッション再開の両方の間の拡張の効果を記述する必要があります。最新のTLS拡張は、セッションが開始されたときにのみ関連します。古いセッションが再開されると、サーバーはこれらの拡張をClient Helloで処理せず、Server Helloに含めません。ただし、一部の拡張機能では、セッション再開時に異なる動作を指定する場合があります。"
    },
    {
      "indent": 3,
      "text": "There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:",
      "ja": "新しいプロトコルと既存の機能の間でこのプロトコルで発生する可能性がある微妙な（それほど微妙ではない）相互作用があり、全体的なセキュリティが大幅に低下する可能性があります。新しい拡張機能を設計するときは、次の考慮事項を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "- Some cases where a server does not agree to an extension are error conditions, and some are simply refusals to support particular features. In general, error alerts should be used for the former, and a field in the server extension response for the latter.",
      "ja": "- サーバーが拡張機能に同意しない場合や、特定の機能のサポートを拒否する場合もあります。一般的に、前者にはエラーアラートを、後者にはサーバーエクステンション応答のフィールドを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "- Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem.",
      "ja": "- 拡張機能は、ハンドシェイクメッセージの操作によって特定の機能の使用（または非使用）を強制する攻撃をできるだけ防ぐように設計する必要があります。この機能がセキュリティ上の問題を引き起こすと考えられているかどうかにかかわらず、この原則に従う必要があります。"
    },
    {
      "indent": 6,
      "text": "Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase. Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions.",
      "ja": "多くの場合、拡張フィールドがFinishedメッセージハッシュへの入力に含まれているという事実で十分ですが、拡張機能がハンドシェイクフェーズで送信されるメッセージの意味を変更する場合は、細心の注意が必要です。設計者と実装者は、ハンドシェイクが認証されるまで、アクティブな攻撃者がメッセージを変更し、拡張機能を挿入、削除、または置き換えることができるという事実に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "- It would be technically possible to use extensions to change major aspects of the design of TLS; for example the design of cipher suite negotiation. This is not recommended; it would be more appropriate to define a new version of TLS -- particularly since the TLS handshake algorithms have specific protection against version rollback attacks based on the version number, and the possibility of version rollback should be a significant consideration in any major design change.",
      "ja": "- 拡張を使用してTLSの設計の主要な側面を変更することは技術的に可能です。たとえば、暗号スイートのネゴシエーションの設計。これは推奨されません。新しいバージョンのTLSを定義する方が適切です。特に、TLSハンドシェイクアルゴリズムにはバージョン番号に基づくバージョンロールバック攻撃に対する特別な保護があり、バージョンのロールバックの可能性は、あらゆる主要な設計変更において重要な考慮事項です。"
    },
    {
      "indent": 0,
      "text": "7.4.1.4.1. Signature Algorithms",
      "section_title": true,
      "ja": "7.4.1.4.1. 署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The client uses the \"signature_algorithms\" extension to indicate to the server which signature/hash algorithm pairs may be used in digital signatures. The \"extension_data\" field of this extension contains a \"supported_signature_algorithms\" value.",
      "ja": "クライアントは、「signature_algorithms」拡張を使用して、デジタル署名で使用できる署名/ハッシュアルゴリズムのペアをサーバーに示します。この拡張の「extension_data」フィールドには、「supported_signature_algorithms」値が含まれています。"
    },
    {
      "indent": 6,
      "text": "enum {\n    none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),\n    sha512(6), (255)\n} HashAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }\n  SignatureAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n      HashAlgorithm hash;\n      SignatureAlgorithm signature;\n} SignatureAndHashAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "SignatureAndHashAlgorithm\n  supported_signature_algorithms<2..2^16-2>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each SignatureAndHashAlgorithm value lists a single hash/signature pair that the client is willing to verify. The values are indicated in descending order of preference.",
      "ja": "各SignatureAndHashAlgorithm値は、クライアントが確認する用意があるハッシュ/署名ペアを1つリストします。値は優先度の高い順に示されています。"
    },
    {
      "indent": 3,
      "text": "Note: Because not all signature algorithms and hash algorithms may be accepted by an implementation (e.g., DSA with SHA-1, but not SHA-256), algorithms here are listed in pairs.",
      "ja": "注：すべての署名アルゴリズムとハッシュアルゴリズムが実装で受け入れられるとは限らないため（たとえば、SHA-1を使用したDSAではなく、SHA-256を使用しない）、ここでのアルゴリズムはペアでリストされます。"
    },
    {
      "indent": 3,
      "text": "hash This field indicates the hash algorithm which may be used. The values indicate support for unhashed data, MD5 [MD5], SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 [SHS], respectively. The \"none\" value is provided for future extensibility, in case of a signature algorithm which does not require hashing before signing.",
      "ja": "hash このフィールドは、使用可能なハッシュアルゴリズムを示します。値は、ハッシュ化されていないデータ、MD5 [MD5]、SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 [SHS]のサポートをそれぞれ示します。 「なし」の値は、署名前にハッシュを必要としない署名アルゴリズムの場合に、将来の拡張性のために提供されています。"
    },
    {
      "indent": 3,
      "text": "signature This field indicates the signature algorithm that may be used. The values indicate anonymous signatures, RSASSA-PKCS1-v1_5 [PKCS1] and DSA [DSS], and ECDSA [ECDSA], respectively. The \"anonymous\" value is meaningless in this context but used in Section 7.4.3. It MUST NOT appear in this extension.",
      "ja": "signature このフィールドは、使用可能な署名アルゴリズムを示します。値は、匿名の署名、RSASSA-PKCS1-v1_5 [PKCS1]、DSA [DSS]、およびECDSA [ECDSA]をそれぞれ示します。 「匿名」の値はこのコンテキストでは意味がありませんが、7.4.3節で使用されています。それはこの拡張に現れてはいけません。"
    },
    {
      "indent": 3,
      "text": "The semantics of this extension are somewhat complicated because the cipher suite indicates permissible signature algorithms but not hash algorithms. Sections 7.4.2 and 7.4.3 describe the appropriate rules.",
      "ja": "暗号スイートが許容可能な署名アルゴリズムを示し、ハッシュアルゴリズムを示さないため、この拡張のセマンティクスは多少複雑です。セクション7.4.2および7.4.3は、適切なルールについて説明しています。"
    },
    {
      "indent": 3,
      "text": "If the client supports only the default hash and signature algorithms (listed in this section), it MAY omit the signature_algorithms extension. If the client does not support the default algorithms, or supports other hash and signature algorithms (and it is willing to use them for verifying messages sent by the server, i.e., server certificates and server key exchange), it MUST send the signature_algorithms extension, listing the algorithms it is willing to accept.",
      "ja": "クライアントがデフォルトのハッシュおよび署名アルゴリズム（このセクションにリストされている）のみをサポートしている場合、signature_algorithms拡張を省略できます（MAY）。クライアントがデフォルトのアルゴリズムをサポートしていない場合、または他のハッシュアルゴリズムと署名アルゴリズムをサポートしている場合（そして、サーバーから送信されたメッセージ（つまり、サーバー証明書とサーバーキー交換）を検証するためにそれらを使用しても構わない場合）は、signature_algorithms拡張を送信する必要があります。受け入れることをいとわないアルゴリズムのリスト。"
    },
    {
      "indent": 3,
      "text": "If the client does not send the signature_algorithms extension, the server MUST do the following:",
      "ja": "クライアントがsignature_algorithms拡張を送信しない場合、サーバーは以下を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "- If the negotiated key exchange algorithm is one of (RSA, DHE_RSA, DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA), behave as if client had sent the value {sha1,rsa}.",
      "ja": "- ネゴシエートされたキー交換アルゴリズムが（RSA、DHE_RSA、DH_RSA、RSA_PSK、ECDH_RSA、ECDHE_RSA）のいずれかである場合、クライアントが値{sha1、rsa}を送信したかのように動作します。"
    },
    {
      "indent": 3,
      "text": "- If the negotiated key exchange algorithm is one of (DHE_DSS, DH_DSS), behave as if the client had sent the value {sha1,dsa}.",
      "ja": "- ネゴシエートされたキー交換アルゴリズムが（DHE_DSS、DH_DSS）のいずれかである場合、クライアントが値{sha1、dsa}を送信したかのように動作します。"
    },
    {
      "indent": 3,
      "text": "- If the negotiated key exchange algorithm is one of (ECDH_ECDSA, ECDHE_ECDSA), behave as if the client had sent value {sha1,ecdsa}.",
      "ja": "- ネゴシエートされたキー交換アルゴリズムが（ECDH_ECDSA、ECDHE_ECDSA）のいずれかである場合、クライアントが値{sha1、ecdsa}を送信したかのように動作します。"
    },
    {
      "indent": 3,
      "text": "Note: this is a change from TLS 1.1 where there are no explicit rules, but as a practical matter one can assume that the peer supports MD5 and SHA-1.",
      "ja": "注：これはTLS 1.1からの変更であり、明示的なルールはありませんが、実際には、ピアがMD5およびSHA-1をサポートしていると想定できます。"
    },
    {
      "indent": 3,
      "text": "Note: this extension is not meaningful for TLS versions prior to 1.2. Clients MUST NOT offer it if they are offering prior versions. However, even if clients do offer it, the rules specified in [TLSEXT] require servers to ignore extensions they do not understand.",
      "ja": "注：この拡張機能は、1.2より前のTLSバージョンでは意味がありません。クライアントは、以前のバージョンを提供している場合、それを提供してはなりません。ただし、クライアントが提供する場合でも、[TLSEXT]で指定されたルールでは、サーバーが理解していない拡張を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Servers MUST NOT send this extension. TLS servers MUST support receiving this extension.",
      "ja": "サーバーはこの拡張機能を送信してはなりません。 TLSサーバーは、この拡張の受信をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When performing session resumption, this extension is not included in Server Hello, and the server ignores the extension in Client Hello (if present).",
      "ja": "セッション再開を実行するとき、この拡張機能はServer Helloに含まれず、サーバーはClient Hello（存在する場合）の拡張機能を無視します。"
    },
    {
      "indent": 0,
      "text": "7.4.2. Server Certificate",
      "section_title": true,
      "ja": "7.4.2. サーバー証明書"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except DH_anon). This message will always immediately follow the ServerHello message.",
      "ja": "合意された鍵交換方法が認証に証明書を使用するときはいつでも、サーバーは証明書メッセージを送信しなければなりません（これには、DH_anonを除く、このドキュメントで定義されたすべての鍵交換方法が含まれます）。このメッセージは、常にServerHelloメッセージの直後に続きます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "This message conveys the server's certificate chain to the client.",
      "ja": "このメッセージは、サーバーの証明書チェーンをクライアントに伝えます。"
    },
    {
      "indent": 6,
      "text": "The certificate MUST be appropriate for the negotiated cipher suite's key exchange algorithm and any negotiated extensions.",
      "ja": "証明書は、交渉された暗号スイートの鍵交換アルゴリズムと交渉された拡張に適切でなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "opaque ASN.1Cert<1..2^24-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    ASN.1Cert certificate_list<0..2^24-1>;\n} Certificate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "certificate_list This is a sequence (chain) of certificates. The sender's certificate MUST come first in the list. Each following certificate MUST directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority MAY be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.",
      "ja": "certificate_list 証明書のシーケンス（チェーン）です。送信者の証明書はリストの最初に来る必要があります。次の各証明書は、その前の証明書を直接証明する必要があります。証明書の検証ではルートキーを個別に配布する必要があるため、ルートの証明機関を指定する自己署名証明書は、リモートエンドがそれを検証するためにすでに所有している必要があるという前提の下で、チェーンから省略される場合があります。"
    },
    {
      "indent": 3,
      "text": "The same message type and structure will be used for the client's response to a certificate request message. Note that a client MAY send no certificates if it does not have an appropriate certificate to send in response to the server's authentication request.",
      "ja": "証明書要求メッセージに対するクライアントの応答には、同じメッセージタイプと構造が使用されます。サーバーの認証要求に応答して送信する適切な証明書がない場合、クライアントは証明書を送信しない場合があります。"
    },
    {
      "indent": 3,
      "text": "Note: PKCS #7 [PKCS7] is not used as the format for the certificate vector because PKCS #6 [PKCS6] extended certificates are not used. Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task of parsing the list more difficult.",
      "ja": "注：PKCS＃6 [PKCS6]拡張証明書は使用されないため、PKCS＃7 [PKCS7]は証明書ベクトルの形式として使用されません。また、PKCS＃7はSEQUENCEではなくSETを定義しているため、リストを解析するタスクがより困難になります。"
    },
    {
      "indent": 3,
      "text": "The following rules apply to the certificates sent by the server:",
      "ja": "サーバーから送信される証明書には、次のルールが適用されます。"
    },
    {
      "indent": 3,
      "text": "- The certificate type MUST be X.509v3, unless explicitly negotiated otherwise (e.g., [TLSPGP]).",
      "ja": "- 明示的に別の方法でネゴシエートされていない限り（[TLSPGP]など）、証明書のタイプはX.509v3でなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "- The end entity certificate's public key (and associated restrictions) MUST be compatible with the selected key exchange algorithm.",
      "ja": "- エンドエンティティ証明書の公開キー（および関連する制限）は、選択したキー交換アルゴリズムと互換性がある必要があります。"
    },
    {
      "indent": 6,
      "text": "Key Exchange Alg. Certificate Key Type",
      "ja": "鍵交換Alg。証明書のキータイプ"
    },
    {
      "indent": 6,
      "text": "RSA RSA public key; the certificate MUST allow the RSA_PSK key to be used for encryption (the keyEncipherment bit MUST be set if the key usage extension is present). Note: RSA_PSK is defined in [TLSPSK].",
      "ja": "RSA RSA公開鍵。証明書は、RSA_PSKキーが暗号化に使用されることを許可する必要があります（キー使用拡張が存在する場合、keyEnciphermentビットを設定する必要があります）。注：RSA_PSKは[TLSPSK]で定義されています。"
    },
    {
      "indent": 6,
      "text": "DHE_RSA RSA public key; the certificate MUST allow the ECDHE_RSA key to be used for signing (the digitalSignature bit MUST be set if the key usage extension is present) with the signature scheme and hash algorithm that will be employed in the server key exchange message. Note: ECDHE_RSA is defined in [TLSECC].",
      "ja": "DHE_RSA RSA公開鍵。証明書では、サーバーの鍵交換メッセージで使用される署名方式とハッシュアルゴリズムを使用して、ECDHE_RSA鍵を署名に使用できるようにする必要があります（鍵用途拡張が存在する場合はdigitalSignatureビットを設定する必要があります）。注：ECDHE_RSAは[TLSECC]で定義されています。"
    },
    {
      "indent": 6,
      "text": "DHE_DSS DSA public key; the certificate MUST allow the key to be used for signing with the hash algorithm that will be employed in the server key exchange message.",
      "ja": "DHE_DSS DSA公開鍵。証明書では、サーバーの鍵交換メッセージで使用されるハッシュアルゴリズムで署名するために鍵を使用できるようにする必要があります。"
    },
    {
      "indent": 6,
      "text": "DH_DSS Diffie-Hellman public key; the keyAgreement bit DH_RSA MUST be set if the key usage extension is present.",
      "ja": "DH_DSS Diffie-Hellman公開鍵。鍵用途拡張が存在する場合、keyAgreementビットDH_RSAを設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "ECDH_ECDSA ECDH-capable public key; the public key MUST ECDH_RSA use a curve and point format supported by the client, as described in [TLSECC].",
      "ja": "ECDH_ECDSA ECDH対応の公開鍵。公開鍵は、[TLSECC]で説明されているように、クライアントがサポートする曲線と点の形式をECDH_RSAが使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "ECDHE_ECDSA ECDSA-capable public key; the certificate MUST allow the key to be used for signing with the hash algorithm that will be employed in the server key exchange message. The public key MUST use a curve and point format supported by the client, as described in [TLSECC].",
      "ja": "ECDHE_ECDSA ECDSA対応の公開鍵。証明書では、サーバーの鍵交換メッセージで使用されるハッシュアルゴリズムで署名するために鍵を使用できるようにする必要があります。 [TLSECC]で説明されているように、公開鍵はクライアントがサポートする曲線と点の形式を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "- The \"server_name\" and \"trusted_ca_keys\" extensions [TLSEXT] are used to guide certificate selection.",
      "ja": "- 「server_name」および「trusted_ca_keys」拡張[TLSEXT]は、証明書の選択をガイドするために使用されます。"
    },
    {
      "indent": 3,
      "text": "If the client provided a \"signature_algorithms\" extension, then all certificates provided by the server MUST be signed by a hash/signature algorithm pair that appears in that extension. Note that this implies that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with a DSA key). This is a departure from TLS 1.1, which required that the algorithms be the same. Note that this also implies that the DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA key exchange algorithms do not restrict the algorithm used to sign the certificate. Fixed DH certificates MAY be signed with any hash/signature algorithm pair appearing in the extension. The names DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA are historical.",
      "ja": "クライアントが「signature_algorithms」拡張を提供した場合、サーバーによって提供されるすべての証明書は、その拡張に表示されるハッシュ/署名アルゴリズムのペアによって署名されなければなりません（MUST）。これは、ある署名アルゴリズムの鍵を含む証明書が、別の署名アルゴリズム（たとえば、DSA鍵で署名されたRSA鍵）を使用して署名される場合があることを意味することに注意してください。これは、アルゴリズムが同じである必要があるTLS 1.1からの逸脱です。これは、DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSA鍵交換アルゴリズムが、証明書の署名に使用されるアルゴリズムを制限しないことも意味することに注意してください。固定DH証明書は、拡張に表示されるハッシュ/署名アルゴリズムのペアで署名される場合があります。 DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSAという名前は歴史的なものです。"
    },
    {
      "indent": 3,
      "text": "If the server has multiple certificates, it chooses one of them based on the above-mentioned criteria (in addition to other criteria, such as transport layer endpoint, local configuration and preferences, etc.). If the server has a single certificate, it SHOULD attempt to validate that it meets these criteria.",
      "ja": "サーバーに複数の証明書がある場合、サーバーは上記の基準（トランスポート層のエンドポイント、ローカルの構成や設定などの他の基準に加えて）に基づいてそれらの1つを選択します。サーバーが単一の証明書を持っている場合、サーバーはこれらの基準を満たしていることを検証しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that there are certificates that use algorithms and/or algorithm combinations that cannot be currently used with TLS. For example, a certificate with RSASSA-PSS signature key (id-RSASSA-PSS OID in SubjectPublicKeyInfo) cannot be used because TLS defines no corresponding signature algorithm.",
      "ja": "現在TLSで使用できないアルゴリズムやアルゴリズムの組み合わせを使用する証明書があることに注意してください。たとえば、TLSで対応する署名アルゴリズムが定義されていないため、RSASSA-PSS署名キー（SubjectPublicKeyInfoのid-RSASSA-PSS OID）を持つ証明書は使用できません。"
    },
    {
      "indent": 3,
      "text": "As cipher suites that specify new key exchange methods are specified for the TLS protocol, they will imply the certificate format and the required encoded keying information.",
      "ja": "TLSプロトコルには新しい鍵交換方式を指定する暗号スイートが指定されているため、それらは証明書形式と必要なエンコードされたキー情報を意味します。"
    },
    {
      "indent": 0,
      "text": "7.4.3. Server Key Exchange Message",
      "section_title": true,
      "ja": "7.4.3. サーバーキー交換メッセージ"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "This message will be sent immediately after the server Certificate message (or the ServerHello message, if this is an anonymous negotiation).",
      "ja": "このメッセージは、サーバーの証明書メッセージ（または匿名のネゴシエーションの場合はServerHelloメッセージ）の直後に送信されます。"
    },
    {
      "indent": 6,
      "text": "The ServerKeyExchange message is sent by the server only when the server Certificate message (if sent) does not contain enough data to allow the client to exchange a premaster secret. This is true for the following key exchange methods:",
      "ja": "サーバー証明書メッセージ（送信された場合）に、クライアントがプリマスターシークレットを交換するのに十分なデータが含まれていない場合にのみ、ServerKeyExchangeメッセージがサーバーによって送信されます。これは、次の鍵交換方法に当てはまります。"
    },
    {
      "indent": 9,
      "text": "DHE_DSS DHE_RSA DH_anon",
      "ja": "DHE_DSS AND_RSA DH_anon"
    },
    {
      "indent": 6,
      "text": "It is not legal to send the ServerKeyExchange message for the following key exchange methods:",
      "ja": "次の鍵交換方法でServerKeyExchangeメッセージを送信することはできません。"
    },
    {
      "indent": 9,
      "text": "RSA DH_DSS DH_RSA",
      "ja": "RSA DH_DSS DH_RSA"
    },
    {
      "indent": 6,
      "text": "Other key exchange algorithms, such as those defined in [TLSECC], MUST specify whether the ServerKeyExchange message is sent or not; and if the message is sent, its contents.",
      "ja": "[TLSECC]で定義されているような他の鍵交換アルゴリズムは、ServerKeyExchangeメッセージが送信されるかどうかを指定しなければなりません。メッセージが送信された場合、その内容。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "This message conveys cryptographic information to allow the client to communicate the premaster secret: a Diffie-Hellman public key with which the client can complete a key exchange (with the result being the premaster secret) or a public key for some other algorithm.",
      "ja": "このメッセージは、クライアントがプリマスターシークレット（クライアントがキー交換を完了することができるDiffie-Hellman公開鍵（結果はプリマスターシークレット））または他のアルゴリズムの公開鍵を通信できるようにする暗号情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa\n      /* may be extended, e.g., for ECDH -- see [TLSECC] */\n     } KeyExchangeAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    opaque dh_p<1..2^16-1>;\n    opaque dh_g<1..2^16-1>;\n    opaque dh_Ys<1..2^16-1>;\n} ServerDHParams;     /* Ephemeral DH parameters */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "dh_p The prime modulus used for the Diffie-Hellman operation.",
      "ja": "dh_p Diffie-Hellman演算に使用される素数係数。"
    },
    {
      "indent": 6,
      "text": "dh_g The generator used for the Diffie-Hellman operation.",
      "ja": "dh_g Diffie-Hellman操作に使用されるジェネレータ。"
    },
    {
      "indent": 6,
      "text": "dh_Ys The server's Diffie-Hellman public value (g^X mod p).",
      "ja": "dh_Ys サーバーのDiffie-Hellmanパブリック値（g ^ X mod p）。"
    },
    {
      "indent": 6,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case dh_anon:\n            ServerDHParams params;\n        case dhe_dss:\n        case dhe_rsa:\n            ServerDHParams params;\n            digitally-signed struct {\n                opaque client_random[32];\n                opaque server_random[32];\n                ServerDHParams params;\n            } signed_params;\n        case rsa:\n        case dh_dss:\n        case dh_rsa:\n            struct {} ;\n           /* message is omitted for rsa, dh_dss, and dh_rsa */\n        /* may be extended, e.g., for ECDH -- see [TLSECC] */\n    };\n} ServerKeyExchange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "params The server's key exchange parameters.",
      "ja": "params サーバーの鍵交換パラメーター。"
    },
    {
      "indent": 6,
      "text": "signed_params For non-anonymous key exchanges, a signature over the server's key exchange parameters.",
      "ja": "signed_params 非匿名の鍵交換の場合、サーバーの鍵交換パラメーターに対する署名。"
    },
    {
      "indent": 3,
      "text": "If the client has offered the \"signature_algorithms\" extension, the signature algorithm and hash algorithm MUST be a pair listed in that extension. Note that there is a possibility for inconsistencies here. For instance, the client might offer DHE_DSS key exchange but omit any DSA pairs from its \"signature_algorithms\" extension. In order to negotiate correctly, the server MUST check any candidate cipher suites against the \"signature_algorithms\" extension before selecting them. This is somewhat inelegant but is a compromise designed to minimize changes to the original cipher suite design.",
      "ja": "クライアントが「signature_algorithms」拡張を提供している場合、署名アルゴリズムとハッシュアルゴリズムは、その拡張にリストされているペアでなければなりません。ここで矛盾が生じる可能性があることに注意してください。たとえば、クライアントはDHE_DSS鍵交換を提供しますが、「signature_algorithms」拡張からDSAペアを省略します。正しくネゴシエートするために、サーバーは、候補となる暗号スイートを選択する前に、「signature_algorithms」拡張に対してチェックする必要があります。これは多少洗練されていませんが、元の暗号スイート設計への変更を最小限に抑えるように設計された妥協案です。"
    },
    {
      "indent": 3,
      "text": "In addition, the hash and signature algorithms MUST be compatible with the key in the server's end-entity certificate. RSA keys MAY be used with any permitted hash algorithm, subject to restrictions in the certificate, if any.",
      "ja": "さらに、ハッシュおよび署名アルゴリズムは、サーバーのエンドエンティティ証明書のキーと互換性がある必要があります。 RSAキーは、許可されたハッシュアルゴリズムで使用できます（証明書の制限がある場合）。"
    },
    {
      "indent": 3,
      "text": "Because DSA signatures do not contain any secure indication of hash algorithm, there is a risk of hash substitution if multiple hashes may be used with any key. Currently, DSA [DSS] may only be used with SHA-1. Future revisions of DSS [DSS-3] are expected to allow the use of other digest algorithms with DSA, as well as guidance as to which digest algorithms should be used with each key size. In addition, future revisions of [PKIX] may specify mechanisms for certificates to indicate which digest algorithms are to be used with DSA.",
      "ja": "DSA署名にはハッシュアルゴリズムの安全な表示が含まれていないため、任意のキーで複数のハッシュが使用される可能性がある場合は、ハッシュ置換のリスクがあります。現在、DSA [DSS]はSHA-1でのみ使用できます。 DSS [DSS-3]の将来の改訂では、DSAで他のダイジェストアルゴリズムを使用できるようになる予定であり、各ダイジェストアルゴリズムを各キーサイズで使用する必要があるかどうかに関するガイダンスも含まれます。さらに、[PKIX]の将来の改訂では、DSAで使用するダイジェストアルゴリズムを示す証明書のメカニズムを指定する可能性があります。"
    },
    {
      "indent": 3,
      "text": "As additional cipher suites are defined for TLS that include new key exchange algorithms, the server key exchange message will be sent if and only if the certificate type associated with the key exchange algorithm does not provide enough information for the client to exchange a premaster secret.",
      "ja": "新しいキー交換アルゴリズムを含む追加の暗号スイートがTLSに定義されているため、サーバー交換キーメッセージは、キー交換アルゴリズムに関連付けられた証明書タイプがクライアントがプリマスターシークレットを交換するのに十分な情報を提供しない場合にのみ送信されます。"
    },
    {
      "indent": 0,
      "text": "7.4.4. Certificate Request",
      "section_title": true,
      "ja": "7.4.4. 証明書リクエスト"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 7,
      "text": "A non-anonymous server can optionally request a certificate from the client, if appropriate for the selected cipher suite. This message, if sent, will immediately follow the ServerKeyExchange message (if it is sent; otherwise, this message follows the server's Certificate message).",
      "ja": "非匿名サーバーは、選択した暗号スイートに適している場合は、オプションでクライアントに証明書を要求できます。このメッセージは、送信された場合、ServerKeyExchangeメッセージの直後に送信されます（送信された場合、送信されない場合、サーバーの証明書メッセージの後に送信されます）。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "enum {\n    rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n    rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\n    fortezza_dms_RESERVED(20), (255)\n} ClientCertificateType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "opaque DistinguishedName<1..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    ClientCertificateType certificate_types<1..2^8-1>;\n    SignatureAndHashAlgorithm\n      supported_signature_algorithms<2^16-1>;\n    DistinguishedName certificate_authorities<0..2^16-1>;\n} CertificateRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "certificate_types A list of the types of certificate types that the client may offer.",
      "ja": "certificate_types クライアントが提供できる証明書タイプのタイプのリスト。"
    },
    {
      "indent": 9,
      "text": "rsa_sign a certificate containing an RSA key dss_sign a certificate containing a DSA key rsa_fixed_dh a certificate containing a static DH key. dss_fixed_dh a certificate containing a static DH key",
      "ja": "rsa_sign RSAキーを含む証明書、dss_sign DSAキーを含む証明書、rsa_fixed_dh 静的DHキーを含む証明書、dss_fixed_dh 静的DHキーを含む証明書"
    },
    {
      "indent": 3,
      "text": "supported_signature_algorithms A list of the hash/signature algorithm pairs that the server is able to verify, listed in descending order of preference.",
      "ja": "supported_signature_algorithms サーバーが検証できるハッシュ/署名アルゴリズムのペアのリスト。優先度の高い順にリストされています。"
    },
    {
      "indent": 3,
      "text": "certificate_authorities A list of the distinguished names [X501] of acceptable certificate_authorities, represented in DER-encoded format. These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe known roots as well as a desired authorization space. If the certificate_authorities list is empty, then the client MAY send any certificate of the appropriate ClientCertificateType, unless there is some external arrangement to the contrary.",
      "ja": "certificate_authorities DERエンコード形式で表された、受け入れ可能なcertificate_authoritiesの識別名[X501]のリスト。これらの識別名は、ルートCAまたは下位CAに必要な識別名を指定できます。したがって、このメッセージを使用して、既知のルートと必要な承認スペースを説明できます。 certificate_authoritiesリストが空の場合、反対の外部配置がない限り、クライアントは適切なClientCertificateTypeの証明書を送信できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "The interaction of the certificate_types and supported_signature_algorithms fields is somewhat complicated. certificate_types has been present in TLS since SSLv3, but was somewhat underspecified. Much of its functionality is superseded by supported_signature_algorithms. The following rules apply:",
      "ja": "certificate_typesフィールドとsupported_signature_algorithmsフィールドの相互作用はやや複雑です。 SSL_3以降、certificate_typesはTLSに存在していましたが、仕様がやや不十分でした。その機能の多くは、supported_signature_algorithmsに置き換えられています。次の規則が適用されます。"
    },
    {
      "indent": 3,
      "text": "- Any certificates provided by the client MUST be signed using a hash/signature algorithm pair found in supported_signature_algorithms.",
      "ja": "- クライアントが提供する証明書は、supported_signature_algorithmsにあるハッシュ/署名アルゴリズムのペアを使用して署名する必要があります。"
    },
    {
      "indent": 3,
      "text": "- The end-entity certificate provided by the client MUST contain a key that is compatible with certificate_types. If the key is a signature key, it MUST be usable with some hash/signature algorithm pair in supported_signature_algorithms.",
      "ja": "- クライアントが提供するエンドエンティティ証明書には、certificate_typesと互換性のあるキーを含める必要があります。鍵が署名鍵の場合は、supported_signature_algorithmsのハッシュ/署名アルゴリズムのペアで使用できる必要があります。"
    },
    {
      "indent": 3,
      "text": "- For historical reasons, the names of some client certificate types include the algorithm used to sign the certificate. For example, in earlier versions of TLS, rsa_fixed_dh meant a certificate signed with RSA and containing a static DH key. In TLS 1.2, this functionality has been obsoleted by the supported_signature_algorithms, and the certificate type no longer restricts the algorithm used to sign the certificate. For example, if the server sends dss_fixed_dh certificate type and {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply with a certificate containing a static DH key, signed with RSA-SHA1.",
      "ja": "- 歴史的な理由により、一部のクライアント証明書タイプの名前には、証明書の署名に使用されるアルゴリズムが含まれています。たとえば、TLSの以前のバージョンでは、rsa_fixed_dhはRSAで署名され、静的DHキーを含む証明書を意味していました。 TLS 1.2では、この機能はsupported_signature_algorithmsによって廃止され、証明書のタイプは証明書への署名に使用されるアルゴリズムを制限しなくなりました。たとえば、サーバーがdss_fixed_dh証明書タイプと{{sha1、dsa}、{sha1、rsa}}署名タイプを送信する場合、クライアントは、RSA-SHA1で署名された静的DHキーを含む証明書で応答できます。"
    },
    {
      "indent": 3,
      "text": "New ClientCertificateType values are assigned by IANA as described in Section 12.",
      "ja": "セクション12で説明するように、新しいClientCertificateType値はIANAによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Note: Values listed as RESERVED may not be used. They were used in SSLv3.",
      "ja": "注：RESERVEDとしてリストされている値は使用できません。 SSLv3で使用されました。"
    },
    {
      "indent": 3,
      "text": "Note: It is a fatal handshake_failure alert for an anonymous server to request client authentication.",
      "ja": "注：匿名サーバーがクライアント認証を要求することは、致命的なhandshake_failureアラートです。"
    },
    {
      "indent": 0,
      "text": "7.4.5. Server Hello Done",
      "section_title": true,
      "ja": "7.4.5. サーバーこんにちは完了"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "The ServerHelloDone message is sent by the server to indicate the end of the ServerHello and associated messages. After sending this message, the server will wait for a client response.",
      "ja": "ServerHelloDoneメッセージはサーバーによって送信され、ServerHelloおよび関連メッセージの終わりを示します。このメッセージを送信した後、サーバーはクライアントの応答を待ちます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "This message means that the server is done sending messages to support the key exchange, and the client can proceed with its phase of the key exchange.",
      "ja": "このメッセージは、サーバーが鍵交換をサポートするメッセージの送信を完了し、クライアントが鍵交換のフェーズを続行できることを意味します。"
    },
    {
      "indent": 6,
      "text": "Upon receipt of the ServerHelloDone message, the client SHOULD verify that the server provided a valid certificate, if required, and check that the server hello parameters are acceptable.",
      "ja": "ServerHelloDoneメッセージを受信すると、クライアントは、必要に応じてサーバーが有効な証明書を提供したことを確認し、サーバーのhelloパラメータが受け入れ可能であることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct { } ServerHelloDone;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4.6. Client Certificate",
      "section_title": true,
      "ja": "7.4.6. クライアント証明書"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "This is the first message the client can send after receiving a ServerHelloDone message. This message is only sent if the server requests a certificate. If no suitable certificate is available, the client MUST send a certificate message containing no certificates. That is, the certificate_list structure has a length of zero. If the client does not send any certificates, the server MAY at its discretion either continue the handshake without client authentication, or respond with a fatal handshake_failure alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or send a fatal alert.",
      "ja": "これは、ServerHelloDoneメッセージを受信した後にクライアントが送信できる最初のメッセージです。このメッセージは、サーバーが証明書を要求した場合にのみ送信されます。適切な証明書がない場合、クライアントは証明書を含まない証明書メッセージを送信する必要があります。つまり、certificate_list構造の長さはゼロです。クライアントが証明書を送信しない場合、サーバーは独自の裁量で、クライアント認証なしでハンドシェイクを続行するか、致命的なhandshake_failureアラートで応答できます。また、証明書チェーンの一部の側面が受け入れられない場合（たとえば、既知の信頼できるCAによって署名されていない場合）、サーバーは独自の裁量でハンドシェイクを続行するか（クライアントが認証されていないことを考慮して）、致命的なアラートを送信できます。"
    },
    {
      "indent": 6,
      "text": "Client certificates are sent using the Certificate structure defined in Section 7.4.2.",
      "ja": "クライアント証明書は、セクション7.4.2で定義された証明書構造を使用して送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "This message conveys the client's certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie-Hellman). The certificate MUST be appropriate for the negotiated cipher suite's key exchange algorithm, and any negotiated extensions.",
      "ja": "このメッセージは、クライアントの証明書チェーンをサーバーに伝えます。サーバーは、CertificateVerifyメッセージの検証（クライアント認証が署名に基づく場合）またはプリマスターシークレットの計算（非一時的なDiffie-Hellmanの場合）に使用します。証明書は、ネゴシエートされた暗号スイートの鍵交換アルゴリズム、およびネゴシエートされた拡張に適切である必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular:",
      "ja": "特に："
    },
    {
      "indent": 3,
      "text": "- The certificate type MUST be X.509v3, unless explicitly negotiated otherwise (e.g., [TLSPGP]).",
      "ja": "- 明示的に別の方法でネゴシエートされていない限り（[TLSPGP]など）、証明書のタイプはX.509v3でなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "- The end-entity certificate's public key (and associated restrictions) has to be compatible with the certificate types listed in CertificateRequest:",
      "ja": "- エンドエンティティ証明書の公開キー（および関連する制限）は、証明書リクエストにリストされている証明書タイプと互換性がある必要があります。"
    },
    {
      "indent": 6,
      "text": "Client Cert. Type Certificate Key Type",
      "ja": "クライアント証明書。タイプ証明書のキータイプ"
    },
    {
      "indent": 6,
      "text": "rsa_sign RSA public key; the certificate MUST allow the key to be used for signing with the signature scheme and hash algorithm that will be employed in the certificate verify message.",
      "ja": "rsa_sign RSA公開鍵。証明書は、証明書検証メッセージで使用される署名スキームとハッシュアルゴリズムで署名するために使用されるキーを許可する必要があります。"
    },
    {
      "indent": 6,
      "text": "dss_sign DSA public key; the certificate MUST allow the key to be used for signing with the hash algorithm that will be employed in the certificate verify message.",
      "ja": "dss_sign DSA公開鍵。証明書は、証明書検証メッセージで使用されるハッシュアルゴリズムで署名するために使用されるキーを許可する必要があります。"
    },
    {
      "indent": 6,
      "text": "ecdsa_sign ECDSA-capable public key; the certificate MUST allow the key to be used for signing with the hash algorithm that will be employed in the certificate verify message; the public key MUST use a curve and point format supported by the server.",
      "ja": "ecdsa_sign ECDSA対応の公開鍵。証明書は、証明書検証メッセージで使用されるハッシュアルゴリズムで署名するために使用されるキーを許可する必要があります。公開鍵は、サーバーがサポートする曲線と点の形式を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "rsa_fixed_dh Diffie-Hellman public key; MUST use the same dss_fixed_dh parameters as server's key.",
      "ja": "rsa_fixed_dh Diffie-Hellman公開鍵。サーバーのキーと同じdss_fixed_dhパラメータを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "rsa_fixed_ecdh ECDH-capable public key; MUST use the ecdsa_fixed_ecdh same curve as the server's key, and MUST use a point format supported by the server.",
      "ja": "rsa_fixed_ecdh ECDH対応の公開鍵。 ecdsa_fixed_ecdhはサーバーのキーと同じ曲線を使用する必要があり、サーバーがサポートするポイント形式を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "- If the certificate_authorities list in the certificate request message was non-empty, one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.",
      "ja": "- 証明書要求メッセージのcertificate_authoritiesリストが空ではない場合、証明書チェーン内の証明書の1つが、リストされたCAの1つによって発行される必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "- The certificates MUST be signed using an acceptable hash/ signature algorithm pair, as described in Section 7.4.4. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.",
      "ja": "- 証明書は、セクション7.4.4で説明されているように、受け入れ可能なハッシュ/署名アルゴリズムのペアを使用して署名しなければなりません（MUST）。これにより、以前のバージョンのTLSにあった証明書署名アルゴリズムの制約が緩和されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that, as with the server certificate, there are certificates that use algorithms/algorithm combinations that cannot be currently used with TLS.",
      "ja": "サーバー証明書と同様に、現在TLSで使用できないアルゴリズム/アルゴリズムの組み合わせを使用する証明書があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.4.7. Client Key Exchange Message",
      "section_title": true,
      "ja": "7.4.7. クライアントキー交換メッセージ"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "This message is always sent by the client. It MUST immediately follow the client certificate message, if it is sent. Otherwise, it MUST be the first message sent by the client after it receives the ServerHelloDone message.",
      "ja": "このメッセージは常にクライアントによって送信されます。送信される場合、クライアント証明書メッセージの直後に続く必要があります。それ以外の場合は、ServerHelloDoneメッセージを受信した後にクライアントが送信する最初のメッセージでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "With this message, the premaster secret is set, either by direct transmission of the RSA-encrypted secret or by the transmission of Diffie-Hellman parameters that will allow each side to agree upon the same premaster secret.",
      "ja": "このメッセージでは、RSAで暗号化されたシークレットを直接送信するか、各サイドが同じプリマスターシークレットに同意できるDiffie-Hellmanパラメータを送信することによって、プリマスターシークレットが設定されます。"
    },
    {
      "indent": 6,
      "text": "When the client is using an ephemeral Diffie-Hellman exponent, then this message contains the client's Diffie-Hellman public value. If the client is sending a certificate containing a static DH exponent (i.e., it is doing fixed_dh client authentication), then this message MUST be sent but MUST be empty.",
      "ja": "クライアントが一時的なDiffie-Hellman指数を使用している場合、このメッセージにはクライアントのDiffie-Hellmanパブリック値が含まれます。クライアントが静的DH指数を含む証明書を送信している場合（つまり、fixed_dhクライアント認証を実行している場合）、このメッセージを送信する必要がありますが、空である必要があります。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "The choice of messages depends on which key exchange method has been selected. See Section 7.4.3 for the KeyExchangeAlgorithm definition.",
      "ja": "メッセージの選択は、選択された鍵交換方式によって異なります。 KeyExchangeAlgorithmの定義については、7.4.3項を参照してください。"
    },
    {
      "indent": 6,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case rsa:\n            EncryptedPreMasterSecret;\n        case dhe_dss:\n        case dhe_rsa:\n        case dh_dss:\n        case dh_rsa:\n        case dh_anon:\n            ClientDiffieHellmanPublic;\n    } exchange_keys;\n} ClientKeyExchange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4.7.1. RSA-Encrypted Premaster Secret Message",
      "section_title": true,
      "ja": "7.4.7.1. RSA暗号化プリマスターシークレットメッセージ"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "If RSA is being used for key agreement and authentication, the client generates a 48-byte premaster secret, encrypts it using the public key from the server's certificate, and sends the result in an encrypted premaster secret message. This structure is a variant of the ClientKeyExchange message and is not a message in itself.",
      "ja": "キーの合意と認証にRSAが使用されている場合、クライアントは48バイトのプリマスターシークレットを生成し、サーバーの証明書の公開キーを使用してそれを暗号化し、暗号化されたプリマスターシークレットメッセージで結果を送信します。この構造はClientKeyExchangeメッセージのバリアントであり、それ自体はメッセージではありません。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct {\n    ProtocolVersion client_version;\n    opaque random[46];\n} PreMasterSecret;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "client_version The latest (newest) version supported by the client. This is used to detect version rollback attacks.",
      "ja": "client_versionクライアントがサポートする最新（最新）バージョン。これは、バージョンロールバック攻撃を検出するために使用されます。"
    },
    {
      "indent": 6,
      "text": "random 46 securely-generated random bytes.",
      "ja": "random 46の安全に生成されたランダムバイト。"
    },
    {
      "indent": 6,
      "text": "struct {\n    public-key-encrypted PreMasterSecret pre_master_secret;\n} EncryptedPreMasterSecret;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "pre_master_secret This random value is generated by the client and is used to generate the master secret, as specified in Section 8.1.",
      "ja": "pre_master_secretこのランダムな値はクライアントによって生成され、セクション8.1で指定されているように、マスターシークレットを生成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Note: The version number in the PreMasterSecret is the version offered by the client in the ClientHello.client_version, not the version negotiated for the connection. This feature is designed to prevent rollback attacks. Unfortunately, some old implementations use the negotiated version instead, and therefore checking the version number may lead to failure to interoperate with such incorrect client implementations.",
      "ja": "注：PreMasterSecretのバージョン番号は、クライアントがClientHello.client_versionで提供するバージョンであり、接続についてネゴシエートされたバージョンではありません。この機能は、ロールバック攻撃を防ぐように設計されています。残念ながら、一部の古い実装では代わりにネゴシエートされたバージョンを使用するため、バージョン番号を確認すると、このような不適切なクライアント実装との相互運用に失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Client implementations MUST always send the correct version number in PreMasterSecret. If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST check the version number as described in the note below. If the version number is TLS 1.0 or earlier, server implementations SHOULD check the version number, but MAY have a configuration option to disable the check. Note that if the check fails, the PreMasterSecret SHOULD be randomized as described below.",
      "ja": "クライアントの実装は、常にPreMasterSecretで正しいバージョン番号を送信する必要があります。 ClientHello.client_versionがTLS 1.1以降の場合、サーバーの実装は、以下のメモに記載されているようにバージョン番号を確認する必要があります。バージョン番号がTLS 1.0以前の場合、サーバー実装はバージョン番号をチェックする必要があります（SHOULD）が、チェックを無効にする構成オプションがある場合があります。チェックが失敗した場合、PreMasterSecretは以下で説明するようにランダム化する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note: Attacks discovered by Bleichenbacher [BLEI] and Klima et al. [KPR03] can be used to attack a TLS server that reveals whether a particular message, when decrypted, is properly PKCS#1 formatted, contains a valid PreMasterSecret structure, or has the correct version number.",
      "ja": "注：Bleichenbacher [BLEI]およびKlimaらによって発見された攻撃。 [KPR03]は、特定のメッセージが復号化されたときに、適切にPKCS＃1形式であるか、有効なPreMasterSecret構造を含むか、または正しいバージョン番号を持っているかを明らかにするTLSサーバーを攻撃するために使用できます。"
    },
    {
      "indent": 3,
      "text": "As described by Klima [KPR03], these vulnerabilities can be avoided by treating incorrectly formatted message blocks and/or mismatched version numbers in a manner indistinguishable from correctly formatted RSA blocks. In other words:",
      "ja": "Klima [KPR03]で説明されているように、これらの脆弱性は、正しくフォーマットされたRSAブロックと区別できない方法で、誤ってフォーマットされたメッセージブロックや不一致のバージョン番号を処理することで回避できます。言い換えると："
    },
    {
      "indent": 6,
      "text": "1. Generate a string R of 46 random bytes",
      "ja": "1. ランダムな46バイトの文字列Rを生成する"
    },
    {
      "indent": 6,
      "text": "2. Decrypt the message to recover the plaintext M",
      "ja": "2. メッセージを解読して平文Mを復元する"
    },
    {
      "indent": 6,
      "text": "3. If the PKCS#1 padding is not correct, or the length of message M is not exactly 48 bytes: pre_master_secret = ClientHello.client_version || R else If ClientHello.client_version <= TLS 1.0, and version number check is explicitly disabled: pre_master_secret = M else: pre_master_secret = ClientHello.client_version || M[2..47]",
      "ja": "3. PKCS＃1パディングが正しくない場合、またはメッセージMの長さが正確に48バイトでない場合：pre_master_secret = ClientHello.client_version || R else ClientHello.client_version <= TLS 1.0で、バージョン番号のチェックが明示的に無効になっている場合：pre_master_secret = M else：pre_master_secret = ClientHello.client_version || M [2..47]"
    },
    {
      "indent": 3,
      "text": "Note that explicitly constructing the pre_master_secret with the ClientHello.client_version produces an invalid master_secret if the client has sent the wrong version in the original pre_master_secret.",
      "ja": "クライアントが元のpre_master_secretで間違ったバージョンを送信した場合、ClientHello.client_versionを使用して明示的にpre_master_secretを構築すると、無効なmaster_secretが生成されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "An alternative approach is to treat a version number mismatch as a PKCS-1 formatting error and randomize the premaster secret completely:",
      "ja": "別の方法は、バージョン番号の不一致をPKCS-1のフォーマットエラーとして扱い、プリマスターシークレットを完全にランダム化することです。"
    },
    {
      "indent": 6,
      "text": "1. Generate a string R of 48 random bytes",
      "ja": "1. ランダムな48バイトの文字列Rを生成する"
    },
    {
      "indent": 6,
      "text": "2. Decrypt the message to recover the plaintext M",
      "ja": "2. メッセージを解読して平文Mを復元する"
    },
    {
      "indent": 6,
      "text": "3. If the PKCS#1 padding is not correct, or the length of message M is not exactly 48 bytes: pre_master_secret = R else If ClientHello.client_version <= TLS 1.0, and version number check is explicitly disabled: premaster secret = M else If M[0..1] != ClientHello.client_version: premaster secret = R else: premaster secret = M",
      "ja": "3. PKCS＃1パディングが正しくない場合、またはメッセージMの長さが正確に48バイトでない場合：pre_master_secret = R else ClientHello.client_version <= TLS 1.0で、バージョン番号のチェックが明示的に無効になっている場合：premaster secret = M else If M [0..1]！= ClientHello.client_version：premaster secret = R else：premaster secret = M"
    },
    {
      "indent": 3,
      "text": "Although no practical attacks against this construction are known, Klima et al. [KPR03] describe some theoretical attacks, and therefore the first construction described is RECOMMENDED.",
      "ja": "この構造に対する実際的な攻撃は知られていないが、クリマ等。 [KPR03]はいくつかの理論的な攻撃について説明しているため、最初に説明する構成をお勧めします。"
    },
    {
      "indent": 3,
      "text": "In any case, a TLS server MUST NOT generate an alert if processing an RSA-encrypted premaster secret message fails, or the version number is not as expected. Instead, it MUST continue the handshake with a randomly generated premaster secret. It may be useful to log the real cause of failure for troubleshooting purposes; however, care must be taken to avoid leaking the information to an attacker (through, e.g., timing, log files, or other channels.)",
      "ja": "いずれの場合でも、RSAで暗号化されたプリマスターシークレットメッセージの処理が失敗した場合、またはバージョン番号が期待どおりでない場合、TLSサーバーはアラートを生成してはなりません（MUST NOT）。代わりに、ランダムに生成されたプリマスターシークレットを使用してハンドシェイクを継続する必要があります。トラブルシューティングの目的で、失敗の実際の原因をログに記録すると役立つ場合があります。ただし、（タイミング、ログファイル、その他のチャネルなどを介して）攻撃者に情報が漏洩しないように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The RSAES-OAEP encryption scheme defined in [PKCS1] is more secure against the Bleichenbacher attack. However, for maximal compatibility with earlier versions of TLS, this specification uses the RSAES-PKCS1-v1_5 scheme. No variants of the Bleichenbacher attack are known to exist provided that the above recommendations are followed.",
      "ja": "[PKCS1]で定義されているRSAES-OAEP暗号化スキームは、ブライチェンバッハ攻撃に対してより安全です。ただし、TLSの以前のバージョンとの互換性を最大限に高めるために、この仕様ではRSAES-PKCS1-v1_5スキームを使用しています。上記の推奨事項に従う限り、ブライチェンバッハー攻撃の亜種は存在しないことがわかっています。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Public-key-encrypted data is represented as an opaque vector <0..2^16-1> (see Section 4.7). Thus, the RSA-encrypted PreMasterSecret in a ClientKeyExchange is preceded by two length bytes. These bytes are redundant in the case of RSA because the EncryptedPreMasterSecret is the only data in the ClientKeyExchange and its length can therefore be unambiguously determined. The SSLv3 specification was not clear about the encoding of public-key-encrypted data, and therefore many SSLv3 implementations do not include the length bytes -- they encode the RSA-encrypted data directly in the ClientKeyExchange message.",
      "ja": "実装上の注意：公開鍵で暗号化されたデータは、不透明なベクトル<0..2 ^ 16-1>として表されます（セクション4.7を参照）。したがって、ClientKeyExchange内のRSA暗号化されたPreMasterSecretの前には、2バイトの長さがあります。 EncryptedPreMasterSecretはClientKeyExchange内の唯一のデータであり、その長さは明確に決定できるため、RSAの場合、これらのバイトは冗長です。 SSLv3仕様では、公開鍵暗号化データのエンコードについて明確ではなかったため、多くのSSLv3実装には長さバイトが含まれていません。RSA暗号化データはClientKeyExchangeメッセージに直接エンコードされています。"
    },
    {
      "indent": 3,
      "text": "This specification requires correct encoding of the EncryptedPreMasterSecret complete with length bytes. The resulting PDU is incompatible with many SSLv3 implementations. Implementors upgrading from SSLv3 MUST modify their implementations to generate and accept the correct encoding. Implementors who wish to be compatible with both SSLv3 and TLS should make their implementation's behavior dependent on the protocol version.",
      "ja": "この仕様では、長さバイトで完全なEncryptedPreMasterSecretの正しいエンコードが必要です。結果のPDUは、多くのSSLv3実装と互換性がありません。 SSLv3からアップグレードする実装者は、正しいエンコーディングを生成して受け入れるように実装を変更する必要があります。 SSLv3とTLSの両方との互換性を希望する実装者は、実装の動作をプロトコルバージョンに依存させる必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementation note: It is now known that remote timing-based attacks on TLS are possible, at least when the client and server are on the same LAN. Accordingly, implementations that use static RSA keys MUST use RSA blinding or some other anti-timing technique, as described in [TIMING].",
      "ja": "実装メモ：少なくともクライアントとサーバーが同じLAN上にある場合、TLSに対するリモートタイミングベースの攻撃が可能であることが判明しました。したがって、静的なRSAキーを使用する実装では、[タイミング]で説明されているように、RSAブラインドまたはその他のアンチタイミング技術を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4.7.2. Client Diffie-Hellman Public Value",
      "section_title": true,
      "ja": "7.4.7.2. クライアントDiffie-Hellmanパブリックバリュー"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "This structure conveys the client's Diffie-Hellman public value (Yc) if it was not already included in the client's certificate. The encoding used for Yc is determined by the enumerated PublicValueEncoding. This structure is a variant of the client key exchange message, and not a message in itself.",
      "ja": "この構造は、クライアントの証明書にまだ含まれていない場合、クライアントのDiffie-Hellmanパブリック値（Yc）を伝えます。 Ycに使用されるエンコーディングは、列挙されたPublicValueEncodingによって決定されます。この構造はクライアント鍵交換メッセージの変形であり、それ自体はメッセージではありません。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "enum { implicit, explicit } PublicValueEncoding;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "implicit If the client has sent a certificate which contains a suitable Diffie-Hellman key (for fixed_dh client authentication), then Yc is implicit and does not need to be sent again. In this case, the client key exchange message will be sent, but it MUST be empty.",
      "ja": "暗黙的 クライアントが適切なDiffie-Hellman鍵（fixed_dhクライアント認証用）を含む証明書を送信した場合、Ycは暗黙的であり、再度送信する必要はありません。この場合、クライアントの鍵交換メッセージが送信されますが、空でなければなりません。"
    },
    {
      "indent": 6,
      "text": "explicit Yc needs to be sent.",
      "ja": "明示的な Ycを送信する必要があります。"
    },
    {
      "indent": 6,
      "text": "struct {\n    select (PublicValueEncoding) {\n        case implicit: struct { };\n        case explicit: opaque dh_Yc<1..2^16-1>;\n    } dh_public;\n} ClientDiffieHellmanPublic;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "dh_Yc The client's Diffie-Hellman public value (Yc).",
      "ja": "dh_Yc クライアントのDiffie-Hellmanパブリック値（Yc）。"
    },
    {
      "indent": 0,
      "text": "7.4.8. Certificate Verify",
      "section_title": true,
      "ja": "7.4.8. 証明書の確認"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "This message is used to provide explicit verification of a client certificate. This message is only sent following a client certificate that has signing capability (i.e., all certificates except those containing fixed Diffie-Hellman parameters). When sent, it MUST immediately follow the client key exchange message.",
      "ja": "このメッセージは、クライアント証明書の明示的な検証を提供するために使用されます。このメッセージは、署名機能を持つクライアント証明書（つまり、固定Diffie-Hellmanパラメータを含むものを除くすべての証明書）に続いてのみ送信されます。送信されると、クライアント鍵交換メッセージの直後に続く必要があります。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct {\n     digitally-signed struct {\n         opaque handshake_messages[handshake_messages_length];\n     }\n} CertificateVerify;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Here handshake_messages refers to all handshake messages sent or received, starting at client hello and up to, but not including, this message, including the type and length fields of the handshake messages. This is the concatenation of all the Handshake structures (as defined in Section 7.4) exchanged thus far. Note that this requires both sides to either buffer the messages or compute running hashes for all potential hash algorithms up to the time of the CertificateVerify computation. Servers can minimize this computation cost by offering a restricted set of digest algorithms in the CertificateRequest message.",
      "ja": "ここで、handshake_messagesは、クライアントのhelloから始まり、ハンドシェイクメッセージのタイプフィールドと長さフィールドを含む、このメッセージを除く（このメッセージを含まない）送受信されるすべてのハンドシェイクメッセージを指します。これは、これまでに交換されたすべてのハンドシェイク構造（7.4節で定義）の連結です。これには、CertificateVerifyの計算時まで、すべての潜在的なハッシュアルゴリズムについて、メッセージをバッファリングするか、実行中のハッシュを計算する必要があることに注意してください。サーバーは、CertificateRequestメッセージでダイジェストアルゴリズムの制限されたセットを提供することにより、この計算コストを最小限に抑えることができます。"
    },
    {
      "indent": 6,
      "text": "The hash and signature algorithms used in the signature MUST be one of those present in the supported_signature_algorithms field of the CertificateRequest message. In addition, the hash and signature algorithms MUST be compatible with the key in the client's end-entity certificate. RSA keys MAY be used with any permitted hash algorithm, subject to restrictions in the certificate, if any.",
      "ja": "署名で使用されるハッシュおよび署名アルゴリズムは、CertificateRequestメッセージのsupported_signature_algorithmsフィールドに存在するものの1つである必要があります。さらに、ハッシュアルゴリズムと署名アルゴリズムは、クライアントのエンドエンティティ証明書のキーと互換性がある必要があります。 RSAキーは、許可されたハッシュアルゴリズムで使用できます（証明書の制限がある場合）。"
    },
    {
      "indent": 6,
      "text": "Because DSA signatures do not contain any secure indication of hash algorithm, there is a risk of hash substitution if multiple hashes may be used with any key. Currently, DSA [DSS] may only be used with SHA-1. Future revisions of DSS [DSS-3] are expected to allow the use of other digest algorithms with DSA, as well as guidance as to which digest algorithms should be used with each key size. In addition, future revisions of [PKIX] may specify mechanisms for certificates to indicate which digest algorithms are to be used with DSA.",
      "ja": "DSA署名にはハッシュアルゴリズムの安全な表示が含まれていないため、任意のキーで複数のハッシュが使用される可能性がある場合は、ハッシュ置換のリスクがあります。現在、DSA [DSS]はSHA-1でのみ使用できます。 DSS [DSS-3]の将来の改訂では、DSAで他のダイジェストアルゴリズムを使用できるようになる予定であり、各ダイジェストアルゴリズムを各キーサイズで使用する必要があるかどうかに関するガイダンスも含まれます。さらに、[PKIX]の将来の改訂では、DSAで使用するダイジェストアルゴリズムを示す証明書のメカニズムを指定する可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.4.9. Finished",
      "section_title": true,
      "ja": "7.4.9. 完成した"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "A Finished message is always sent immediately after a change cipher spec message to verify that the key exchange and authentication processes were successful. It is essential that a change cipher spec message be received between the other handshake messages and the Finished message.",
      "ja": "暗号仕様変更メッセージの直後に終了メッセージが常に送信され、鍵交換と認証プロセスが成功したことを確認します。他のハンドシェイクメッセージと完了メッセージの間に、暗号仕様変更メッセージを受信することが不可欠です。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "The Finished message is the first one protected with the just negotiated algorithms, keys, and secrets. Recipients of Finished messages MUST verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.",
      "ja": "Finishedメッセージは、交渉されたばかりのアルゴリズム、キー、およびシークレットで保護された最初のメッセージです。 Finishedメッセージの受信者は、内容が正しいことを確認する必要があります。サイドが完了メッセージを送信し、ピアから完了メッセージを受信して​​検証すると、接続を介してアプリケーションデータの送受信を開始できます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct {\n    opaque verify_data[verify_data_length];\n} Finished;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "verify_data PRF(master_secret, finished_label, Hash(handshake_messages)) [0..verify_data_length-1];",
      "ja": "verify_data PRF（master_secret、finished_label、Hash（handshake_messages））[0..verify_data_length-1];"
    },
    {
      "indent": 6,
      "text": "finished_label For Finished messages sent by the client, the string \"client finished\". For Finished messages sent by the server, the string \"server finished\".",
      "ja": "finished_labelクライアントが送信した完了メッセージの場合、ストリング「client finished」。サーバーによって送信された終了メッセージの場合、文字列「サーバー終了」。"
    },
    {
      "indent": 6,
      "text": "Hash denotes a Hash of the handshake messages. For the PRF defined in Section 5, the Hash MUST be the Hash used as the basis for the PRF. Any cipher suite which defines a different PRF MUST also define the Hash to use in the Finished computation.",
      "ja": "ハッシュは、ハンドシェイクメッセージのハッシュを示します。セクション5で定義されているPRFの場合、ハッシュはPRFの基礎として使用されるハッシュでなければなりません。異なるPRFを定義する暗号スイートは、Finished計算で使用するハッシュも定義する必要があります。"
    },
    {
      "indent": 6,
      "text": "In previous versions of TLS, the verify_data was always 12 octets long. In the current version of TLS, it depends on the cipher suite. Any cipher suite which does not explicitly specify verify_data_length has a verify_data_length equal to 12. This includes all existing cipher suites. Note that this representation has the same encoding as with previous versions. Future cipher suites MAY specify other lengths but such length MUST be at least 12 bytes.",
      "ja": "以前のバージョンのTLSでは、verify_dataは常に12オクテット長でした。 TLSの現在のバージョンでは、暗号スイートに依存しています。 verify_data_lengthを明示的に指定しない暗号スイートは、verify_data_lengthが12です。これには、既存のすべての暗号スイートが含まれます。この表現のエンコーディングは、以前のバージョンと同じであることに注意してください。将来の暗号スイートは他の長さを指定するかもしれませんが、そのような長さは少なくとも12バイトでなければなりません（MUST）。"
    },
    {
      "indent": 6,
      "text": "handshake_messages All of the data from all messages in this handshake (not including any HelloRequest messages) up to, but not including, this message. This is only data visible at the handshake layer and does not include record layer headers. This is the concatenation of all the Handshake structures as defined in Section 7.4, exchanged thus far.",
      "ja": "handshake_messagesこのハンドシェイク内のすべてのメッセージ（HelloRequestメッセージは含まない）からこのメッセージまでのすべてのデータ。これは、ハンドシェイクレイヤーでのみ表示されるデータであり、レコードレイヤーヘッダーは含まれません。これは、これまでに交換された、セクション7.4で定義されたすべてのハンドシェイク構造の連結です。"
    },
    {
      "indent": 3,
      "text": "It is a fatal error if a Finished message is not preceded by a ChangeCipherSpec message at the appropriate point in the handshake.",
      "ja": "ハンドシェイクの適切な時点で、Finishedメッセージの前にChangeCipherSpecメッセージがない場合は、致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "The value handshake_messages includes all handshake messages starting at ClientHello up to, but not including, this Finished message. This may be different from handshake_messages in Section 7.4.8 because it would include the CertificateVerify message (if sent). Also, the handshake_messages for the Finished message sent by the client will be different from that for the Finished message sent by the server, because the one that is sent second will include the prior one.",
      "ja": "値handshake_messagesには、ClientHelloで始まり、このFinishedメッセージまでのすべてのハンドシェイクメッセージが含まれますが、含まれません。これは、CertificateVerifyメッセージ（送信された場合）が含まれるため、セクション7.4.8のhandshake_messagesとは異なる場合があります。また、クライアントが送信する終了メッセージのhandshake_messagesは、サーバーが送信する終了メッセージのhandshake_messagesとは異なります。これは、2番目に送信されるメッセージに前のメッセージが含まれるためです。"
    },
    {
      "indent": 3,
      "text": "Note: ChangeCipherSpec messages, alerts, and any other record types are not handshake messages and are not included in the hash computations. Also, HelloRequest messages are omitted from handshake hashes.",
      "ja": "注：ChangeCipherSpecメッセージ、アラート、およびその他のレコードタイプはハンドシェイクメッセージではないため、ハッシュ計算には含まれません。また、HelloRequestメッセージはハンドシェイクハッシュから省略されます。"
    },
    {
      "indent": 0,
      "text": "8. Cryptographic Computations",
      "section_title": true,
      "ja": "8. 暗号計算"
    },
    {
      "indent": 3,
      "text": "In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, encryption, and MAC algorithms are determined by the cipher_suite selected by the server and revealed in the ServerHello message. The compression algorithm is negotiated in the hello messages, and the random values are exchanged in the hello messages. All that remains is to calculate the master secret.",
      "ja": "接続保護を開始するために、TLSレコードプロトコルでは、一連のアルゴリズム、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります。認証、暗号化、およびMACアルゴリズムは、サーバーによって選択され、ServerHelloメッセージで明らかにされたcipher_suiteによって決定されます。圧縮アルゴリズムはhelloメッセージでネゴシエートされ、ランダムな値はhelloメッセージで交換されます。あとは、マスターシークレットを計算するだけです。"
    },
    {
      "indent": 0,
      "text": "8.1. Computing the Master Secret",
      "section_title": true,
      "ja": "8.1. マスターシークレットの計算"
    },
    {
      "indent": 3,
      "text": "For all key exchange methods, the same algorithm is used to convert the pre_master_secret into the master_secret. The pre_master_secret should be deleted from memory once the master_secret has been computed.",
      "ja": "すべての鍵交換方法で、同じアルゴリズムを使用してpre_master_secretをmaster_secretに変換します。 master_secretが計算されたら、pre_master_secretをメモリから削除する必要があります。"
    },
    {
      "indent": 6,
      "text": "master_secret = PRF(pre_master_secret, \"master secret\", ClientHello.random + ServerHello.random) [0..47];",
      "ja": "master_secret = PRF（pre_master_secret、 \"master secret\"、ClientHello.random + ServerHello.random）[0..47];"
    },
    {
      "indent": 3,
      "text": "The master secret is always exactly 48 bytes in length. The length of the premaster secret will vary depending on key exchange method.",
      "ja": "マスターシークレットの長さは常に正確に48バイトです。プリマスターシークレットの長さは、鍵の交換方法によって異なります。"
    },
    {
      "indent": 0,
      "text": "8.1.1. RSA",
      "section_title": true,
      "ja": "8.1.1. RSA"
    },
    {
      "indent": 3,
      "text": "When RSA is used for server authentication and key exchange, a 48- byte pre_master_secret is generated by the client, encrypted under the server's public key, and sent to the server. The server uses its private key to decrypt the pre_master_secret. Both parties then convert the pre_master_secret into the master_secret, as specified above.",
      "ja": "RSAがサーバー認証と鍵交換に使用される場合、48バイトのpre_master_secretがクライアントによって生成され、サーバーの公開鍵で暗号化されてサーバーに送信されます。サーバーは、その秘密鍵を使用してpre_master_secretを復号化します。次に、両方の当事者が、上記のようにpre_master_secretをmaster_secretに変換します。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Diffie-Hellman",
      "section_title": true,
      "ja": "8.1.2. ディフィーヘルマン"
    },
    {
      "indent": 3,
      "text": "A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is used as the pre_master_secret, and is converted into the master_secret, as specified above. Leading bytes of Z that contain all zero bits are stripped before it is used as the pre_master_secret.",
      "ja": "従来のDiffie-Hellman計算が実行されます。ネゴシエートされたキー（Z）はpre_master_secretとして使用され、上記のようにmaster_secretに変換されます。すべてゼロのビットを含むZの先頭バイトは、pre_master_secretとして使用される前に取り除かれます。"
    },
    {
      "indent": 3,
      "text": "Note: Diffie-Hellman parameters are specified by the server and may be either ephemeral or contained within the server's certificate.",
      "ja": "注：Diffie-Hellmanパラメーターはサーバーによって指定され、一時的なものか、サーバーの証明書内に含まれるもののいずれかです。"
    },
    {
      "indent": 0,
      "text": "9. Mandatory Cipher Suites",
      "section_title": true,
      "ja": "9. 必須の暗号スイート"
    },
    {
      "indent": 3,
      "text": "In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the definition).",
      "ja": "特に指定しないアプリケーションプロファイル標準がない場合、TLS準拠のアプリケーションは、暗号スイートTLS_RSA_WITH_AES_128_CBC_SHAを実装する必要があります（定義については、付録A.5を参照）。"
    },
    {
      "indent": 0,
      "text": "10. Application Data Protocol",
      "section_title": true,
      "ja": "10. アプリケーションデータプロトコル"
    },
    {
      "indent": 3,
      "text": "Application data messages are carried by the record layer and are fragmented, compressed, and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.",
      "ja": "アプリケーションデータメッセージはレコードレイヤーによって運ばれ、現在の接続状態に基づいて断片化、圧縮、および暗号化されます。メッセージは、レコードレイヤーに対して透過的なデータとして扱われます。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are discussed throughout this memo, especially in Appendices D, E, and F.",
      "ja": "セキュリティの問題は、このメモ全体で、特に付録D、E、Fで説明されています。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document uses several registries that were originally created in [TLS1.1]. IANA has updated these to reference this document. The registries and their allocation policies (unchanged from [TLS1.1]) are listed below.",
      "ja": "このドキュメントでは、[TLS1.1]で最初に作成されたいくつかのレジストリを使用します。 IANAは、このドキュメントを参照するようにこれらを更新しました。レジストリとその割り当てポリシー（[TLS1.1]から変更なし）を以下に示します。"
    },
    {
      "indent": 3,
      "text": "- TLS ClientCertificateType Identifiers Registry: Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action [RFC2434]. Values in the range 64-223 (decimal) inclusive are assigned via Specification Required [RFC2434]. Values from 224-255 (decimal) inclusive are reserved for Private Use [RFC2434].",
      "ja": "- TLS ClientCertificateType Identifiers Registry：0〜63（10進数）の範囲の将来の値は、標準アクション[RFC2434]を介して割り当てられます。 64-223（10進数）を含む範囲の値は、Specification Required [RFC2434]によって割り当てられます。 224-255（10進数）を含む値は、私的使用のために予約されています[RFC2434]。"
    },
    {
      "indent": 3,
      "text": "- TLS Cipher Suite Registry: Future values with the first byte in the range 0-191 (decimal) inclusive are assigned via Standards Action [RFC2434]. Values with the first byte in the range 192-254 (decimal) are assigned via Specification Required [RFC2434]. Values with the first byte 255 (decimal) are reserved for Private Use [RFC2434].",
      "ja": "- TLS暗号スイートレジストリ：最初のバイトが0〜191（10進数）の範囲にある将来の値は、標準アクション[RFC2434]によって割り当てられます。 192〜254（10進数）の範囲の最初のバイトを持つ値は、Specification Required [RFC2434]によって割り当てられます。最初のバイトが255（10進数）の値は、個人使用のために予約されています[RFC2434]。"
    },
    {
      "indent": 3,
      "text": "- This document defines several new HMAC-SHA256-based cipher suites, whose values (in Appendix A.5) have been allocated from the TLS Cipher Suite registry.",
      "ja": "- このドキュメントは、いくつかの新しいHMAC-SHA256ベースの暗号スイートを定義します。それらの値（付録A.5）は、TLS暗号スイートレジストリから割り当てられています。"
    },
    {
      "indent": 3,
      "text": "- TLS ContentType Registry: Future values are allocated via Standards Action [RFC2434].",
      "ja": "- TLS ContentTypeレジストリ：将来の値は、標準アクション[RFC2434]を介して割り当てられます。"
    },
    {
      "indent": 3,
      "text": "- TLS Alert Registry: Future values are allocated via Standards Action [RFC2434].",
      "ja": "- TLS Alert Registry：将来の値は標準アクション[RFC2434]を通じて割り当てられます。"
    },
    {
      "indent": 3,
      "text": "- TLS HandshakeType Registry: Future values are allocated via Standards Action [RFC2434].",
      "ja": "- TLS HandshakeTypeレジストリ：将来の値は、標準アクション[RFC2434]を介して割り当てられます。"
    },
    {
      "indent": 3,
      "text": "This document also uses a registry originally created in [RFC4366]. IANA has updated it to reference this document. The registry and its allocation policy (unchanged from [RFC4366]) is listed below:",
      "ja": "このドキュメントでは、[RFC4366]で最初に作成されたレジストリも使用しています。 IANAは、このドキュメントを参照するように更新しました。レジストリとその割り当てポリシー（[RFC4366]から変更なし）を以下に示します。"
    },
    {
      "indent": 3,
      "text": "- TLS ExtensionType Registry: Future values are allocated via IETF Consensus [RFC2434]. IANA has updated this registry to include the signature_algorithms extension and its corresponding value (see Section 7.4.1.4).",
      "ja": "- TLS ExtensionType Registry：将来の値はIETFコンセンサス[RFC2434]を介して割り当てられます。 IANAはこのレジストリを更新して、signature_algorithms拡張機能とそれに対応する値を追加しました（セクション7.4.1.4を参照）。"
    },
    {
      "indent": 3,
      "text": "In addition, this document defines two new registries to be maintained by IANA:",
      "ja": "さらに、このドキュメントでは、IANAによって維持される2つの新しいレジストリを定義しています。"
    },
    {
      "indent": 3,
      "text": "- TLS SignatureAlgorithm Registry: The registry has been initially populated with the values described in Section 7.4.1.4.1. Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action [RFC2434]. Values in the range 64-223 (decimal) inclusive are assigned via Specification Required [RFC2434]. Values from 224-255 (decimal) inclusive are reserved for Private Use [RFC2434].",
      "ja": "- TLS SignatureAlgorithmレジストリ：レジストリには、セクション7.4.1.4.1で説明されている値が最初に入力されています。 0〜63（10進数）の範囲の将来の値は、標準アクション[RFC2434]を介して割り当てられます。 64-223（10進数）を含む範囲の値は、Specification Required [RFC2434]によって割り当てられます。 224-255（10進数）を含む値は、私的使用のために予約されています[RFC2434]。"
    },
    {
      "indent": 3,
      "text": "- TLS HashAlgorithm Registry: The registry has been initially populated with the values described in Section 7.4.1.4.1. Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action [RFC2434]. Values in the range 64-223 (decimal) inclusive are assigned via Specification Required [RFC2434]. Values from 224-255 (decimal) inclusive are reserved for Private Use [RFC2434].",
      "ja": "- TLS HashAlgorithmレジストリ：レジストリには、セクション7.4.1.4.1で説明されている値が最初に入力されています。 0〜63（10進数）の範囲の将来の値は、標準アクション[RFC2434]を介して割り当てられます。 64-223（10進数）を含む範囲の値は、Specification Required [RFC2434]によって割り当てられます。 224-255（10進数）を含む値は、私的使用のために予約されています[RFC2434]。"
    },
    {
      "indent": 6,
      "text": "This document also uses the TLS Compression Method Identifiers Registry, defined in [RFC3749]. IANA has allocated value 0 for the \"null\" compression method.",
      "ja": "このドキュメントでは、[RFC3749]で定義されているTLS圧縮方式識別子レジストリも使用しています。 IANAは、「null」圧縮方法に値0を割り当てました。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Protocol Data Structures and Constant Values",
      "section_title": true,
      "ja": "付録A.プロトコルデータ構造と定数値"
    },
    {
      "indent": 3,
      "text": "This section describes protocol types and constants.",
      "ja": "このセクションでは、プロトコルのタイプと定数について説明します。"
    },
    {
      "indent": 0,
      "text": "A.1. Record Layer",
      "section_title": true,
      "ja": "A.1. レコード層"
    },
    {
      "indent": 3,
      "text": "struct {\n    uint8 major;\n    uint8 minor;\n} ProtocolVersion;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ProtocolVersion version = { 3, 3 };     /* TLS v1.2*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum {\n    change_cipher_spec(20), alert(21), handshake(22),\n    application_data(23), (255)\n} ContentType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSPlaintext.length];\n} TLSPlaintext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSCompressed.length];\n} TLSCompressed;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    select (SecurityParameters.cipher_type) {\n        case stream: GenericStreamCipher;\n        case block:  GenericBlockCipher;\n        case aead:   GenericAEADCipher;\n    } fragment;\n} TLSCiphertext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "stream-ciphered struct {\n    opaque content[TLSCompressed.length];\n    opaque MAC[SecurityParameters.mac_length];\n} GenericStreamCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque IV[SecurityParameters.record_iv_length];\n    block-ciphered struct {\n        opaque content[TLSCompressed.length];\n        opaque MAC[SecurityParameters.mac_length];\n        uint8 padding[GenericBlockCipher.padding_length];\n        uint8 padding_length;\n    };\n} GenericBlockCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n   opaque nonce_explicit[SecurityParameters.record_iv_length];\n   aead-ciphered struct {\n       opaque content[TLSCompressed.length];\n   };\n} GenericAEADCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. Change Cipher Specs Message",
      "section_title": true,
      "ja": "A.2. 暗号仕様メッセージの変更"
    },
    {
      "indent": 3,
      "text": "struct {\n    enum { change_cipher_spec(1), (255) } type;\n} ChangeCipherSpec;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. Alert Messages",
      "section_title": true,
      "ja": "A.3. 警告メッセージ"
    },
    {
      "indent": 3,
      "text": "enum { warning(1), fatal(2), (255) } AlertLevel;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum {\n    close_notify(0),\n    unexpected_message(10),\n    bad_record_mac(20),\n    decryption_failed_RESERVED(21),\n    record_overflow(22),\n    decompression_failure(30),\n    handshake_failure(40),\n    no_certificate_RESERVED(41),\n    bad_certificate(42),\n    unsupported_certificate(43),\n    certificate_revoked(44),\n    certificate_expired(45),\n    certificate_unknown(46),\n    illegal_parameter(47),\n    unknown_ca(48),\n    access_denied(49),\n    decode_error(50),\n    decrypt_error(51),\n    export_restriction_RESERVED(60),\n    protocol_version(70), insufficient_security(71),\n    internal_error(80),\n    user_canceled(90),\n    no_renegotiation(100),\n    unsupported_extension(110),           /* new */\n    (255)\n} AlertDescription;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    AlertLevel level;\n    AlertDescription description;\n} Alert;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. Handshake Protocol",
      "section_title": true,
      "ja": "A.4. ハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "enum {\n    hello_request(0), client_hello(1), server_hello(2),\n    certificate(11), server_key_exchange (12),\n    certificate_request(13), server_hello_done(14),\n    certificate_verify(15), client_key_exchange(16),\n    finished(20)\n    (255)\n} HandshakeType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    HandshakeType msg_type;\n    uint24 length;\n    select (HandshakeType) {\n        case hello_request:       HelloRequest;\n        case client_hello:        ClientHello;\n        case server_hello:        ServerHello;\n        case certificate:         Certificate;\n        case server_key_exchange: ServerKeyExchange;\n        case certificate_request: CertificateRequest;\n        case server_hello_done:   ServerHelloDone;\n        case certificate_verify:  CertificateVerify;\n        case client_key_exchange: ClientKeyExchange;\n        case finished:            Finished;\n    } body;\n} Handshake;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.1. Hello Messages",
      "section_title": true,
      "ja": "A.4.1. こんにちはメッセージ"
    },
    {
      "indent": 3,
      "text": "struct { } HelloRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    uint32 gmt_unix_time;\n    opaque random_bytes[28];\n} Random;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "opaque SessionID<0..32>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uint8 CipherSuite[2];",
      "ja": "uint8 CipherSuite [2];"
    },
    {
      "indent": 3,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion client_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suites<2..2^16-2>;\n    CompressionMethod compression_methods<1..2^8-1>;\n    select (extensions_present) {\n        case false:\n            struct {};\n        case true:\n            Extension extensions<0..2^16-1>;\n    };\n} ClientHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion server_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suite;\n    CompressionMethod compression_method;\n    select (extensions_present) {\n        case false:\n            struct {};\n        case true:\n            Extension extensions<0..2^16-1>;\n    };\n} ServerHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ExtensionType extension_type;\n    opaque extension_data<0..2^16-1>;\n} Extension;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum {\n    signature_algorithms(13), (65535)\n} ExtensionType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum{\n    none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),\n    sha512(6), (255)\n} HashAlgorithm;\nenum {\n   anonymous(0), rsa(1), dsa(2), ecdsa(3), (255)\n} SignatureAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n      HashAlgorithm hash;\n      SignatureAlgorithm signature;\n} SignatureAndHashAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SignatureAndHashAlgorithm\n supported_signature_algorithms<2..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2. Server Authentication and Key Exchange Messages",
      "section_title": true,
      "ja": "A.4.2. サーバー認証と主要交換メッセージ"
    },
    {
      "indent": 3,
      "text": "opaque ASN.1Cert<2^24-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ASN.1Cert certificate_list<0..2^24-1>;\n} Certificate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { dhe_dss, dhe_rsa, dh_anon, rsa,dh_dss, dh_rsa\n       /* may be extended, e.g., for ECDH -- see [TLSECC] */\n     } KeyExchangeAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque dh_p<1..2^16-1>;\n    opaque dh_g<1..2^16-1>;\n    opaque dh_Ys<1..2^16-1>;\n} ServerDHParams;     /* Ephemeral DH parameters */ struct {\n    select (KeyExchangeAlgorithm) {\n        case dh_anon:\n            ServerDHParams params;\n        case dhe_dss:\n        case dhe_rsa:\n            ServerDHParams params;\n            digitally-signed struct {\n                opaque client_random[32];\n                opaque server_random[32];\n                ServerDHParams params;\n            } signed_params;\n        case rsa:\n        case dh_dss:\n        case dh_rsa:\n            struct {} ;\n           /* message is omitted for rsa, dh_dss, and dh_rsa */\n        /* may be extended, e.g., for ECDH -- see [TLSECC] */\n} ServerKeyExchange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum {\n    rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n    rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\n    fortezza_dms_RESERVED(20),\n    (255)\n} ClientCertificateType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "opaque DistinguishedName<1..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ClientCertificateType certificate_types<1..2^8-1>;\n    DistinguishedName certificate_authorities<0..2^16-1>;\n} CertificateRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct { } ServerHelloDone;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3. Client Authentication and Key Exchange Messages",
      "section_title": true,
      "ja": "A.4.3. クライアント認証と主要交換メッセージ"
    },
    {
      "indent": 3,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case rsa:\n            EncryptedPreMasterSecret;\n        case dhe_dss:\n        case dhe_rsa:\n        case dh_dss:\n        case dh_rsa:\n        case dh_anon:\n            ClientDiffieHellmanPublic;\n    } exchange_keys;\n} ClientKeyExchange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion client_version;\n    opaque random[46];\n} PreMasterSecret;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    public-key-encrypted PreMasterSecret pre_master_secret;\n} EncryptedPreMasterSecret;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { implicit, explicit } PublicValueEncoding;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    select (PublicValueEncoding) {\n        case implicit: struct {};\n        case explicit: opaque DH_Yc<1..2^16-1>;\n    } dh_public;\n} ClientDiffieHellmanPublic;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n     digitally-signed struct {\n         opaque handshake_messages[handshake_messages_length];\n     }\n} CertificateVerify;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.4. Handshake Finalization Message",
      "section_title": true,
      "ja": "A.4.4. ハンドシェイク終了メッセージ"
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque verify_data[verify_data_length];\n} Finished;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5. The Cipher Suite",
      "section_title": true,
      "ja": "A.5. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "The following values define the cipher suite codes used in the ClientHello and ServerHello messages.",
      "ja": "次の値は、ClientHelloおよびServerHelloメッセージで使用される暗号スイートコードを定義します。"
    },
    {
      "indent": 3,
      "text": "A cipher suite defines a cipher specification supported in TLS Version 1.2.",
      "ja": "暗号スイートは、TLSバージョン1.2でサポートされる暗号仕様を定義します。"
    },
    {
      "indent": 3,
      "text": "TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a TLS connection during the first handshake on that channel, but MUST NOT be negotiated, as it provides no more protection than an unsecured connection.",
      "ja": "TLS_NULL_WITH_NULL_NULLが指定されており、そのチャネルでの最初のハンドシェイク中のTLS接続の初期状態ですが、セキュリティで保護されていない接続以外の保護を提供しないため、ネゴシエートしてはなりません。"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_NULL_WITH_NULL_NULL               = { 0x00,0x00 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following CipherSuite definitions require that the server provide an RSA certificate that can be used for key exchange. The server may request any signature-capable certificate in the certificate request message.",
      "ja": "以下のCipherSuite定義では、サーバーが鍵交換に使用できるRSA証明書を提供する必要があります。サーバーは、証明書要求メッセージで署名可能な証明書を要求できます。"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_RSA_WITH_NULL_MD5                 = { 0x00,0x01 };\nCipherSuite TLS_RSA_WITH_NULL_SHA                 = { 0x00,0x02 };\nCipherSuite TLS_RSA_WITH_NULL_SHA256              = { 0x00,0x3B };\nCipherSuite TLS_RSA_WITH_RC4_128_MD5              = { 0x00,0x04 };\nCipherSuite TLS_RSA_WITH_RC4_128_SHA              = { 0x00,0x05 };\nCipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA         = { 0x00,0x0A };\nCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA          = { 0x00,0x2F };\nCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA          = { 0x00,0x35 };\nCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256       = { 0x00,0x3C };\nCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256       = { 0x00,0x3D };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following cipher suite definitions are used for server-authenticated (and optionally client-authenticated) Diffie-Hellman. DH denotes cipher suites in which the server's certificate contains the Diffie-Hellman parameters signed by the certificate authority (CA). DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a signature-capable certificate, which has been signed by the CA. The signing algorithm used by the server is specified after the DHE component of the CipherSuite name. The server can request any signature-capable certificate from the client for client authentication, or it may request a Diffie-Hellman certificate. Any Diffie-Hellman certificate provided by the client must use the parameters (group and generator) described by the server.",
      "ja": "以下の暗号スイート定義は、サーバー認証（およびオプションでクライアント認証）Diffie-Hellmanに使用されます。 DHは、サーバーの証明書に認証局（CA）によって署名されたDiffie-Hellmanパラメーターが含まれている暗号スイートを示します。 DHEは一時的なDiffie-Hellmanを示します。Diffie-Hellmanパラメータは、CAによって署名された署名対応証明書によって署名されます。サーバーが使用する署名アルゴリズムは、CipherSuite名のDHEコンポーネントの後に指定されます。サーバーは、クライアント認証のためにクライアントから署名可能な証明書を要求できます。または、Diffie-Hellman証明書を要求することもできます。クライアントによって提供されるすべてのDiffie-Hellman証明書は、サーバーによって記述されたパラメーター（グループおよびジェネレーター）を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x0D };\nCipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x10 };\nCipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x13 };\nCipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x16 };\nCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA       = { 0x00,0x30 };\nCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA       = { 0x00,0x31 };\nCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA      = { 0x00,0x32 };\nCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA      = { 0x00,0x33 };\nCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA       = { 0x00,0x36 };\nCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA       = { 0x00,0x37 };\nCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA      = { 0x00,0x38 };\nCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA      = { 0x00,0x39 };\nCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256    = { 0x00,0x3E };\nCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256    = { 0x00,0x3F };\nCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   = { 0x00,0x40 };\nCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256   = { 0x00,0x67 };\nCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256    = { 0x00,0x68 };\nCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256    = { 0x00,0x69 };\nCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256   = { 0x00,0x6A };\nCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256   = { 0x00,0x6B };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following cipher suites are used for completely anonymous Diffie-Hellman communications in which neither party is authenticated. Note that this mode is vulnerable to man-in-the-middle attacks. Using this mode therefore is of limited use: These cipher suites MUST NOT be used by TLS 1.2 implementations unless the application layer has specifically requested to allow anonymous key exchange. (Anonymous key exchange may sometimes be acceptable, for example, to support opportunistic encryption when no set-up for authentication is in place, or when TLS is used as part of more complex security protocols that have other means to ensure authentication.)",
      "ja": "次の暗号スイートは、どちらの当事者も認証されない完全に匿名のDiffie-Hellman通信に使用されます。このモードは中間者攻撃に対して脆弱であることに注意してください。したがって、このモードの使用は制限されています。これらの暗号スイートは、アプリケーション層が匿名キー交換を許可するように特別に要求していない限り、TLS 1.2実装で使用してはなりません（MUST NOT）。 （たとえば、認証のセットアップが行われていない場合や、認証を保証する他の手段を持つより複雑なセキュリティプロトコルの一部としてTLSが使用されている場合など、日和見暗号化をサポートするために、匿名の鍵交換が受け入れられる場合があります。）"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_DH_anon_WITH_RC4_128_MD5          = { 0x00,0x18 };\nCipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x1B };\nCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA      = { 0x00,0x34 };\nCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA      = { 0x00,0x3A };\nCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256   = { 0x00,0x6C };\nCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256   = { 0x00,0x6D };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that using non-anonymous key exchange without actually verifying the key exchange is essentially equivalent to anonymous key exchange, and the same precautions apply. While non-anonymous key exchange will generally involve a higher computational and communicational cost than anonymous key exchange, it may be in the interest of interoperability not to disable non-anonymous key exchange when the application layer is allowing anonymous key exchange.",
      "ja": "キー交換を実際に確認せずに非匿名キー交換を使用することは、本質的に匿名キー交換と同等であり、同じ予防策が適用されることに注意してください。非匿名キー交換は、一般に匿名キー交換よりも高い計算および通信コストを伴いますが、アプリケーション層が匿名キー交換を許可しているときに非匿名キー交換を無効にしないことが相互運用性の利益になる場合があります。"
    },
    {
      "indent": 3,
      "text": "New cipher suite values have been assigned by IANA as described in Section 12.",
      "ja": "セクション12で説明されているように、新しい暗号スイートの値がIANAによって割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid collision with Fortezza-based cipher suites in SSL 3.",
      "ja": "注：暗号スイートの値{0x00、0x1C}および{0x00、0x1D}は、SSL 3のFortezzaベースの暗号スイートとの衝突を避けるために予約されています。"
    },
    {
      "indent": 0,
      "text": "A.6. The Security Parameters",
      "section_title": true,
      "ja": "A.6. セキュリティパラメータ"
    },
    {
      "indent": 3,
      "text": "These security parameters are determined by the TLS Handshake Protocol and provided as parameters to the TLS record layer in order to initialize a connection state. SecurityParameters includes:",
      "ja": "これらのセキュリティパラメータはTLSハンドシェイクプロトコルによって決定され、接続状態を初期化するためにパラメータとしてTLSレコードレイヤに提供されます。 SecurityParametersには以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { server, client } ConnectionEnd;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { tls_prf_sha256 } PRFAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { null, rc4, 3des, aes } BulkCipherAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { stream, block, aead } CipherType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384,\n  hmac_sha512} MACAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Other values may be added to the algorithms specified in\nCompressionMethod, PRFAlgorithm, BulkCipherAlgorithm, and\nMACAlgorithm. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ConnectionEnd          entity;\n    PRFAlgorithm           prf_algorithm;\n    BulkCipherAlgorithm    bulk_cipher_algorithm;\n    CipherType             cipher_type;\n    uint8                  enc_key_length;\n    uint8                  block_length;\n    uint8                  fixed_iv_length;\n    uint8                  record_iv_length;\n    MACAlgorithm           mac_algorithm;\n    uint8                  mac_length;\n    uint8                  mac_key_length;\n    CompressionMethod      compression_algorithm;\n    opaque                 master_secret[48];\n    opaque                 client_random[32];\n    opaque                 server_random[32];\n} SecurityParameters;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.7. Changes to RFC 4492",
      "section_title": true,
      "ja": "A.7. RFC 4492の変更"
    },
    {
      "indent": 3,
      "text": "RFC 4492 [TLSECC] adds Elliptic Curve cipher suites to TLS. This document changes some of the structures used in that document. This section details the required changes for implementors of both RFC 4492 and TLS 1.2. Implementors of TLS 1.2 who are not implementing RFC 4492 do not need to read this section.",
      "ja": "RFC 4492 [TLSECC]は、Elliptic Curve暗号スイートをTLSに追加します。このドキュメントは、そのドキュメントで使用されている構造の一部を変更します。このセクションでは、RFC 4492とTLS 1.2の両方の実装者に必要な変更について詳しく説明します。 RFC 4492を実装していないTLS 1.2の実装者は、このセクションを読む必要はありません。"
    },
    {
      "indent": 3,
      "text": "This document adds a \"signature_algorithm\" field to the digitally-signed element in order to identify the signature and digest algorithms used to create a signature. This change applies to digital signatures formed using ECDSA as well, thus allowing ECDSA signatures to be used with digest algorithms other than SHA-1, provided such use is compatible with the certificate and any restrictions imposed by future revisions of [PKIX].",
      "ja": "このドキュメントでは、署名を作成するために使用される署名とダイジェストアルゴリズムを識別するために、デジタル署名された要素に「signature_algorithm」フィールドを追加します。この変更はECDSAを使用して形成されたデジタル署名にも適用されるため、証明書と将来のリビジョン[PKIX]によって課される制限との互換性があれば、ECDSA署名をSHA-1以外のダイジェストアルゴリズムで使用できます。"
    },
    {
      "indent": 3,
      "text": "As described in Sections 7.4.2 and 7.4.6, the restrictions on the signature algorithms used to sign certificates are no longer tied to the cipher suite (when used by the server) or the ClientCertificateType (when used by the client). Thus, the restrictions on the algorithm used to sign certificates specified in Sections 2 and 3 of RFC 4492 are also relaxed. As in this document, the restrictions on the keys in the end-entity certificate remain.",
      "ja": "セクション7.4.2および7.4.6で説明されているように、証明書の署名に使用される署名アルゴリズムの制限は、暗号スイート（サーバーで使用される場合）またはClientCertificateType（クライアントで使用される場合）に関連付けられなくなりました。したがって、RFC 4492のセクション2および3で指定された証明書の署名に使用されるアルゴリズムの制限も緩和されます。このドキュメントのように、エンドエンティティ証明書のキーの制限は残ります。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Glossary",
      "section_title": true,
      "ja": "付録B用語集"
    },
    {
      "indent": 3,
      "text": "Advanced Encryption Standard (AES) AES [AES] is a widely used symmetric encryption algorithm. AES is a block cipher with a 128-, 192-, or 256-bit keys and a 16-byte block size. TLS currently only supports the 128- and 256-bit key sizes.",
      "ja": "Advanced Encryption Standard（AES）AES [AES]は、広く使用されている対称暗号化アルゴリズムです。 AESは、128ビット、192ビット、または256ビットの鍵と16バイトのブロックサイズを持つブロック暗号です。 TLSは現在、128ビットおよび256ビットの鍵サイズのみをサポートしています。"
    },
    {
      "indent": 3,
      "text": "application protocol An application protocol is a protocol that normally layers directly on top of the transport layer (e.g., TCP/IP). Examples include HTTP, TELNET, FTP, and SMTP.",
      "ja": "アプリケーションプロトコルアプリケーションプロトコルは、通常、トランスポート層（TCP / IPなど）の上に直接階層化されるプロトコルです。例としては、HTTP、TELNET、FTP、SMTPなどがあります。"
    },
    {
      "indent": 3,
      "text": "asymmetric cipher See public key cryptography.",
      "ja": "非対称暗号公開鍵暗号を参照してください。"
    },
    {
      "indent": 3,
      "text": "authenticated encryption with additional data (AEAD) A symmetric encryption algorithm that simultaneously provides confidentiality and message integrity.",
      "ja": "認証付き暗号化と追加データ（AEAD）機密性とメッセージの整合性を同時に提供する対称暗号化アルゴリズム。"
    },
    {
      "indent": 3,
      "text": "authentication Authentication is the ability of one entity to determine the identity of another entity.",
      "ja": "認証認証とは、あるエンティティが別のエンティティのIDを決定する機能です。"
    },
    {
      "indent": 3,
      "text": "block cipher A block cipher is an algorithm that operates on plaintext in groups of bits, called blocks. 64 bits was, and 128 bits is, a common block size.",
      "ja": "ブロック暗号ブロック暗号は、ブロックと呼ばれるビットのグループでプレーンテキストを操作するアルゴリズムです。一般的なブロックサイズは64ビットで、128ビットです。"
    },
    {
      "indent": 3,
      "text": "bulk cipher A symmetric encryption algorithm used to encrypt large quantities of data.",
      "ja": "バルク暗号大量のデータを暗号化するために使用される対称暗号化アルゴリズム。"
    },
    {
      "indent": 3,
      "text": "cipher block chaining (CBC) CBC is a mode in which every plaintext block encrypted with a block cipher is first exclusive-ORed with the previous ciphertext block (or, in the case of the first block, with the initialization vector). For decryption, every block is first decrypted, then exclusive-ORed with the previous ciphertext block (or IV).",
      "ja": "暗号ブロック連鎖（CBC）CBCは、ブロック暗号で暗号化されたすべての平文ブロックが、前の暗号テキストブロック（または、最初のブロックの場合は、初期化ベクトル）と最初に排他的ORされるモードです。復号化では、すべてのブロックが最初に復号化され、次に前の暗号文ブロック（またはIV）と排他的論理和がとられます。"
    },
    {
      "indent": 3,
      "text": "certificate As part of the X.509 protocol (a.k.a. ISO Authentication framework), certificates are assigned by a trusted Certificate Authority and provide a strong binding between a party's identity or some other attributes and its public key.",
      "ja": "証明書X.509プロトコル（別名ISO認証フレームワーク）の一部として、証明書は信頼できる認証局によって割り当てられ、パーティのIDまたはその他の属性とその公開鍵の間の強力なバインディングを提供します。"
    },
    {
      "indent": 3,
      "text": "client The application entity that initiates a TLS connection to a server. This may or may not imply that the client initiated the underlying transport connection. The primary operational difference between the server and client is that the server is generally authenticated, while the client is only optionally authenticated.",
      "ja": "クライアントサーバーへのTLS接続を開始するアプリケーションエンティティ。これは、クライアントが基になるトランスポート接続を開始したことを意味する場合とそうでない場合があります。サーバーとクライアントの主な運用上の違いは、サーバーは通常認証されるのに対し、クライアントはオプションでのみ認証されることです。"
    },
    {
      "indent": 3,
      "text": "client write key The key used to encrypt data written by the client.",
      "ja": "クライアント書き込みキークライアントによって書き込まれたデータを暗号化するために使用されるキー。"
    },
    {
      "indent": 3,
      "text": "client write MAC key The secret data used to authenticate data written by the client.",
      "ja": "クライアント書き込みMACキークライアントによって書き込まれたデータを認証するために使用される秘密データ。"
    },
    {
      "indent": 3,
      "text": "connection A connection is a transport (in the OSI layering model definition) that provides a suitable type of service. For TLS, such connections are peer-to-peer relationships. The connections are transient. Every connection is associated with one session.",
      "ja": "接続接続は、適切なタイプのサービスを提供するトランスポート（OSIレイヤーモデル定義内）です。 TLSの場合、このような接続はピアツーピア関係です。接続は一時的です。すべての接続は1つのセッションに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Data Encryption Standard DES [DES] still is a very widely used symmetric encryption algorithm although it is considered as rather weak now. DES is a block cipher with a 56-bit key and an 8-byte block size. Note that in TLS, for key generation purposes, DES is treated as having an 8-byte key length (64 bits), but it still only provides 56 bits of protection. (The low bit of each key byte is presumed to be set to produce odd parity in that key byte.) DES can also be operated in a mode [3DES] where three independent keys and three encryptions are used for each block of data; this uses 168 bits of key (24 bytes in the TLS key generation method) and provides the equivalent of 112 bits of security.",
      "ja": "データ暗号化標準DES [DES]は、現在かなり弱いと考えられていますが、依然として非常に広く使用されている対称暗号化アルゴリズムです。 DESは、56ビットのキーと8バイトのブロックサイズを持つブロック暗号です。 TLSでは、鍵生成の目的で、DESは8バイトの鍵長（64ビット）を持つものとして扱われますが、それでも56ビットの保護しか提供しません。 （各キーバイトの下位ビットは、そのキーバイトで奇数パリティを生成するように設定されていると想定されています。）DESは、3つの独立したキーと3つの暗号化が各データブロックに使用されるモード[3DES]でも動作できます。これは、168ビットの鍵（TLS鍵生成方式では24バイト）を使用し、112ビットのセキュリティと同等のものを提供します。"
    },
    {
      "indent": 3,
      "text": "Digital Signature Standard (DSS) A standard for digital signing, including the Digital Signing Algorithm, approved by the National Institute of Standards and Technology, defined in NIST FIPS PUB 186-2, \"Digital Signature Standard\", published January 2000 by the U.S. Department of Commerce [DSS]. A significant update [DSS-3] has been drafted and was published in March 2006.",
      "ja": "デジタル署名標準（DSS）NIST FIPS PUB 186-2「デジタル署名標準」で定義された、国立標準技術研究所によって承認された、デジタル署名アルゴリズムを含むデジタル署名の標準。商取引[DSS]。重要な更新[DSS-3]が起草され、2006年3月に公開されました。"
    },
    {
      "indent": 3,
      "text": "digital signatures Digital signatures utilize public key cryptography and one-way hash functions to produce a signature of the data that can be authenticated, and is difficult to forge or repudiate.",
      "ja": "デジタル署名デジタル署名は、公開鍵暗号と一方向ハッシュ関数を利用して、認証可能なデータの署名を生成します。この署名は、偽造または否認が困難です。"
    },
    {
      "indent": 3,
      "text": "handshake An initial negotiation between client and server that establishes the parameters of their transactions.",
      "ja": "ハンドシェイクトランザクションのパラメータを確立するクライアントとサーバー間の初期のネゴシエーション。"
    },
    {
      "indent": 3,
      "text": "Initialization Vector (IV) When a block cipher is used in CBC mode, the initialization vector is exclusive-ORed with the first plaintext block prior to encryption.",
      "ja": "初期化ベクトル（IV）CBCモードでブロック暗号が使用される場合、初期化ベクトルは暗号化の前に最初の平文ブロックと排他的論理和がとられます。"
    },
    {
      "indent": 3,
      "text": "Message Authentication Code (MAC) A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.",
      "ja": "メッセージ認証コード（MAC）メッセージ認証コードは、メッセージといくつかの秘密データから計算された一方向のハッシュです。秘密のデータを知らずに偽造することは困難です。その目的は、メッセージが変更されたかどうかを検出することです。"
    },
    {
      "indent": 3,
      "text": "master secret Secure secret data used for generating encryption keys, MAC secrets, and IVs.",
      "ja": "マスターシークレット暗号化キー、MACシークレット、およびIVの生成に使用される安全なシークレットデータ。"
    },
    {
      "indent": 3,
      "text": "MD5 MD5 [MD5] is a hashing function that converts an arbitrarily long data stream into a hash of fixed size (16 bytes). Due to significant progress in cryptanalysis, at the time of publication of this document, MD5 no longer can be considered a 'secure' hashing function.",
      "ja": "MD5 MD5 [MD5]は、任意の長いデータストリームを固定サイズ（16バイト）のハッシュに変換するハッシュ関数です。暗号解読が大幅に進歩したため、このドキュメントの公開時点では、MD5は「安全な」ハッシュ関数と見なすことはできません。"
    },
    {
      "indent": 3,
      "text": "public key cryptography A class of cryptographic techniques employing two-key ciphers. Messages encrypted with the public key can only be decrypted with the associated private key. Conversely, messages signed with the private key can be verified with the public key.",
      "ja": "公開鍵暗号2鍵暗号を使用する暗号技術のクラス。公開鍵で暗号化されたメッセージは、関連付けられた秘密鍵でのみ復号化できます。逆に、秘密鍵で署名されたメッセージは、公開鍵で検証できます。"
    },
    {
      "indent": 3,
      "text": "one-way hash function A one-way transformation that converts an arbitrary amount of data into a fixed-length hash. It is computationally hard to reverse the transformation or to find collisions. MD5 and SHA are examples of one-way hash functions.",
      "ja": "一方向ハッシュ関数任意量のデータを固定長ハッシュに変換する一方向変換。変換を元に戻したり、衝突を見つけることは、計算上困難です。 MD5とSHAは一方向ハッシュ関数の例です。"
    },
    {
      "indent": 3,
      "text": "RC4 A stream cipher invented by Ron Rivest. A compatible cipher is described in [SCH].",
      "ja": "RC4 Ron Rivestが発明したストリーム暗号。互換性のある暗号は[SCH]で説明されています。"
    },
    {
      "indent": 3,
      "text": "RSA A very widely used public key algorithm that can be used for either encryption or digital signing. [RSA]",
      "ja": "RSA暗号化またはデジタル署名のいずれかに使用できる、非常に広く使用されている公開鍵アルゴリズム。 [RSA]"
    },
    {
      "indent": 3,
      "text": "server The server is the application entity that responds to requests for connections from clients. See also \"client\".",
      "ja": "サーバーサーバーは、クライアントからの接続要求に応答するアプリケーションエンティティです。 「クライアント」も参照してください。"
    },
    {
      "indent": 3,
      "text": "session A TLS session is an association between a client and a server. Sessions are created by the handshake protocol. Sessions define a set of cryptographic security parameters that can be shared among multiple connections. Sessions are used to avoid the expensive negotiation of new security parameters for each connection.",
      "ja": "セッションTLSセッションは、クライアントとサーバー間の関連付けです。セッションは、ハンドシェイクプロトコルによって作成されます。セッションは、複数の接続間で共有できる一連の暗号化セキュリティパラメータを定義します。セッションは、各接続の新しいセキュリティパラメータの高価なネゴシエーションを回避するために使用されます。"
    },
    {
      "indent": 3,
      "text": "session identifier A session identifier is a value generated by a server that identifies a particular session.",
      "ja": "セッション識別子セッション識別子は、特定のセッションを識別するサーバーによって生成される値です。"
    },
    {
      "indent": 3,
      "text": "server write key The key used to encrypt data written by the server.",
      "ja": "サーバー書き込みキーサーバーによって書き込まれたデータを暗号化するために使用されるキー。"
    },
    {
      "indent": 3,
      "text": "server write MAC key The secret data used to authenticate data written by the server.",
      "ja": "サーバー書き込みMACキーサーバーによって書き込まれたデータを認証するために使用される秘密データ。"
    },
    {
      "indent": 3,
      "text": "SHA The Secure Hash Algorithm [SHS] is defined in FIPS PUB 180-2. It produces a 20-byte output. Note that all references to SHA (without a numerical suffix) actually use the modified SHA-1 algorithm.",
      "ja": "SHAセキュアハッシュアルゴリズム[SHS]は、FIPS PUB 180-2で定義されています。 20バイトの出力を生成します。 SHAへのすべての参照（数値のサフィックスなし）は、実際には変更されたSHA-1アルゴリズムを使用することに注意してください。"
    },
    {
      "indent": 3,
      "text": "SHA-256 The 256-bit Secure Hash Algorithm is defined in FIPS PUB 180-2. It produces a 32-byte output.",
      "ja": "SHA-256 256ビットのセキュアハッシュアルゴリズムは、FIPS PUB 180-2で定義されています。 32バイトの出力を生成します。"
    },
    {
      "indent": 3,
      "text": "SSL Netscape's Secure Socket Layer protocol [SSL3]. TLS is based on SSL Version 3.0.",
      "ja": "SSL NetscapeのSecure Socket Layerプロトコル[SSL3]。 TLSはSSLバージョン3.0に基づいています。"
    },
    {
      "indent": 3,
      "text": "stream cipher An encryption algorithm that converts a key into a cryptographically strong keystream, which is then exclusive-ORed with the plaintext.",
      "ja": "ストリーム暗号鍵を暗号的に強力な鍵ストリームに変換する暗号化アルゴリズム。次に、平文と排他的論理和がとられます。"
    },
    {
      "indent": 3,
      "text": "symmetric cipher See bulk cipher.",
      "ja": "対称暗号バルク暗号を参照してください。"
    },
    {
      "indent": 3,
      "text": "Transport Layer Security (TLS) This protocol; also, the Transport Layer Security working group of the Internet Engineering Task Force (IETF). See \"Working Group Information\" at the end of this document (see page 99).",
      "ja": "トランスポート層セキュリティ（TLS）このプロトコル。また、Internet Engineering Task Force（IETF）のTransport Layer Securityワーキンググループ。このドキュメントの最後にある「ワーキンググループ情報」を参照してください（P. 101）。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Cipher Suite Definitions",
      "section_title": true,
      "ja": "付録C.暗号スイートの定義"
    },
    {
      "indent": 0,
      "text": "Cipher Suite Key Cipher Mac Exchange",
      "ja": "Cipher Suite Key Cipher Mac Exchange"
    },
    {
      "indent": 0,
      "text": "TLS_NULL_WITH_NULL_NULL NULL NULL NULL TLS_RSA_WITH_NULL_MD5 RSA NULL MD5 TLS_RSA_WITH_NULL_SHA RSA NULL SHA TLS_RSA_WITH_NULL_SHA256 RSA NULL SHA256 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA RSA AES_128_CBC SHA TLS_RSA_WITH_AES_256_CBC_SHA RSA AES_256_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA256 RSA AES_128_CBC SHA256 TLS_RSA_WITH_AES_256_CBC_SHA256 RSA AES_256_CBC SHA256 TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA DH_DSS AES_128_CBC SHA TLS_DH_RSA_WITH_AES_128_CBC_SHA DH_RSA AES_128_CBC SHA TLS_DHE_DSS_WITH_AES_128_CBC_SHA DHE_DSS AES_128_CBC SHA TLS_DHE_RSA_WITH_AES_128_CBC_SHA DHE_RSA AES_128_CBC SHA TLS_DH_anon_WITH_AES_128_CBC_SHA DH_anon AES_128_CBC SHA TLS_DH_DSS_WITH_AES_256_CBC_SHA DH_DSS AES_256_CBC SHA TLS_DH_RSA_WITH_AES_256_CBC_SHA DH_RSA AES_256_CBC SHA TLS_DHE_DSS_WITH_AES_256_CBC_SHA DHE_DSS AES_256_CBC SHA TLS_DHE_RSA_WITH_AES_256_CBC_SHA DHE_RSA AES_256_CBC SHA TLS_DH_anon_WITH_AES_256_CBC_SHA DH_anon AES_256_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA256 DH_DSS AES_128_CBC SHA256 TLS_DH_RSA_WITH_AES_128_CBC_SHA256 DH_RSA AES_128_CBC SHA256 TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 DHE_DSS AES_128_CBC SHA256 TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 DHE_RSA AES_128_CBC SHA256 TLS_DH_anon_WITH_AES_128_CBC_SHA256 DH_anon AES_128_CBC SHA256 TLS_DH_DSS_WITH_AES_256_CBC_SHA256 DH_DSS AES_256_CBC SHA256 TLS_DH_RSA_WITH_AES_256_CBC_SHA256 DH_RSA AES_256_CBC SHA256 TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 DHE_DSS AES_256_CBC SHA256 TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 DHE_RSA AES_256_CBC SHA256 TLS_DH_anon_WITH_AES_256_CBC_SHA256 DH_anon AES_256_CBC SHA256",
      "ja": "TLS_NULL_WITH_NULL_NULL NULL NULL NULL TLS_RSA_WITH_NULL_MD5 RSA NULL MD5 TLS_RSA_WITH_NULL_SHA RSA NULL SHA TLS_RSA_WITH_NULL_SHA256 RSA NULL SHA256 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA RSA AES_128_CBC SHA TLS_RSA_WITH_AES_256_CBC_SHA RSA AES_256_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA256 RSA AES_128_CBC SHA256 TLS_RSA_WITH_AES_256_CBC_SHA256 RSA AES_256_CBC SHA256 TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA DH_DSS AES_128_CBC SHA TLS_DH_RSA_WITH_AES_128_CBC_SHA DH_RSA AES_128_CBC SHA TLS_DHE_DSS_WITH_AES_128_CBC_SHA DHE_DSS AES_128_CBC SHA TL S_DHE_RSA_WITH_AES_128_CBC_SHA DHE_RSA AES_128_CBC SHA TLS_DH_anon_WITH_AES_128_CBC_SHA DH_anon AES_128_CBC SHA TLS_DH_DSS_WITH_AES_256_CBC_SHA DH_DSS AES_256_CBC SHA TLS_DH_RSA_WITH_AES_256_CBC_SHA DH_RSA AES_256_CBC SHA TLS_DHE_DSS_WITH_AES_256_CBC_SHA DHE_DSS AES_256_CBC SHA TLS_DHE_RSA_WITH_AES_256_CBC_SHA DHE_RSA AES_256_CBC SHA TLS_DH_anon_WITH_AES_256_CBC_SHA DH_anon AES_256_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA256 DH_DSS AES_128_CBC SHA256 TLS_DH_RSA_WITH_AES_128_CBC_SHA256 DH_RSA AES_128_CBC SHA256 TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 DHE_DSS AES_128_CBC SHA256 TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 DHE_RSA AES_128_CBC SHA256 TLS_DH_anon_WITH_AES_128_CBC_SHA256 DH_anon AES_128_CBC SHA256 TLS_DH_DSS_WITH_AES_256_CBC_SHA256 DH_DSS AES_256_CBC SHA256 TLS_DH_RSA_WITH_AES_256_CBC_SHA256 DH_RSA AES_256_CBC SHA256 TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 DHE_DSS AES_256_CBC SHA256 TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 DHE_RSA AES_256_CBC SHA256 TLS_DH_anon_WITH_AES_256_CBC_SHA256 DH_anon AES_ 256_CBC SHA256"
    },
    {
      "indent": 0,
      "text": "                        Key      IV   Block\nCipher        Type    Material  Size  Size\n------------  ------  --------  ----  -----\nNULL          Stream      0       0    N/A\nRC4_128       Stream     16       0    N/A\n3DES_EDE_CBC  Block      24       8      8\nAES_128_CBC   Block      16      16     16\nAES_256_CBC   Block      32      16     16",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "MAC       Algorithm    mac_length  mac_key_length\n--------  -----------  ----------  --------------\nNULL      N/A              0             0\nMD5       HMAC-MD5        16            16\nSHA       HMAC-SHA1       20            20\nSHA256    HMAC-SHA256     32            32",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Type Indicates whether this is a stream cipher or a block cipher running in CBC mode.",
      "ja": "タイプこれがストリーム暗号であるか、CBCモードで実行されているブロック暗号であるかを示します。"
    },
    {
      "indent": 3,
      "text": "Key Material The number of bytes from the key_block that are used for generating the write keys.",
      "ja": "Key Material書き込みキーの生成に使用されるkey_blockからのバイト数。"
    },
    {
      "indent": 3,
      "text": "IV Size The amount of data needed to be generated for the initialization vector. Zero for stream ciphers; equal to the block size for block ciphers (this is equal to SecurityParameters.record_iv_length).",
      "ja": "IVサイズ初期化ベクトル用に生成する必要があるデータの量。ストリーム暗号の場合はゼロ。ブロック暗号のブロックサイズと同じです（これはSecurityParameters.record_iv_lengthと同じです）。"
    },
    {
      "indent": 3,
      "text": "Block Size The amount of data a block cipher enciphers in one chunk; a block cipher running in CBC mode can only encrypt an even multiple of its block size.",
      "ja": "ブロックサイズブロ​​ック暗号が1つのチャンクで暗号化するデータの量。 CBCモードで実行されているブロック暗号は、そのブロックサイズの偶数倍しか暗号化できません。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Implementation Notes",
      "section_title": true,
      "ja": "付録D.実装上の注意"
    },
    {
      "indent": 3,
      "text": "The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.",
      "ja": "TLSプロトコルは、多くの一般的なセキュリティミスを防ぐことはできません。このセクションでは、実装者を支援するためのいくつかの推奨事項を示します。"
    },
    {
      "indent": 0,
      "text": "D.1. Random Number Generation and Seeding",
      "section_title": true,
      "ja": "D.1. 乱数の生成とシード"
    },
    {
      "indent": 3,
      "text": "TLS requires a cryptographically secure pseudorandom number generator (PRNG). Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably SHA-1, are acceptable, but cannot provide more security than the size of the random number generator state.",
      "ja": "TLSには、暗号で保護された疑似乱数ジェネレータ（PRNG）が必要です。 PRNGの設計とシードには注意が必要です。安全なハッシュ操作、特にSHA-1に基づくPRNGは受け入れられますが、乱数ジェネレーターの状態のサイズよりも高いセキュリティを提供することはできません。"
    },
    {
      "indent": 3,
      "text": "To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible's 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more. Seeding a 128-bit PRNG would thus require approximately 100 such timer values.",
      "ja": "生成されるシードマテリアルの量を見積もるには、各シードバイトに予測できない情報のビット数を追加します。たとえば、PC互換の18.2 Hzタイマーから取得したキーストロークタイミング値は、カウンター値の合計サイズが16ビット以上であっても、それぞれ1ビットまたは2ビットのセキュアビットを提供します。したがって、128ビットのPRNGをシードすると、約100個のタイマー値が必要になります。"
    },
    {
      "indent": 3,
      "text": "[RANDOM] provides guidance on the generation of random values.",
      "ja": "[ランダム]は、ランダムな値の生成に関するガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "D.2. Certificates and Authentication",
      "section_title": true,
      "ja": "D.2. 証明書と認証"
    },
    {
      "indent": 3,
      "text": "Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully. Users should be able to view information about the certificate and root CA.",
      "ja": "実装は証明書の整合性を検証する責任があり、通常は証明書失効メッセージをサポートする必要があります。信頼できる認証局（CA）による適切な署名を確実にするために、証明書を常に検証する必要があります。信頼できるCAの選択と追加は、非常に慎重に行う必要があります。ユーザーは、証明書とルートCAに関する情報を表示できる必要があります。"
    },
    {
      "indent": 0,
      "text": "D.3. Cipher Suites",
      "section_title": true,
      "ja": "D.3. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "TLS supports a range of key sizes and security levels, including some that provide no or minimal security. A proper implementation will probably not support many cipher suites. For instance, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man-in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512- bit RSA keys or signatures are not appropriate for high-security applications.",
      "ja": "TLSは、キーサイズとセキュリティレベルの範囲をサポートしています。適切な実装はおそらく多くの暗号スイートをサポートしません。たとえば、匿名のDiffie-Hellmanは、中間者攻撃を防ぐことができないため、強くお勧めしません。アプリケーションは、最小および最大のキーサイズも適用する必要があります。たとえば、512ビットのRSAキーまたは署名を含む証明書チェーンは、高セキュリティアプリケーションには適していません。"
    },
    {
      "indent": 0,
      "text": "D.4. Implementation Pitfalls",
      "section_title": true,
      "ja": "D.4. 実装の落とし穴"
    },
    {
      "indent": 3,
      "text": "Implementation experience has shown that certain parts of earlier TLS specifications are not easy to understand, and have been a source of interoperability and security problems. Many of these areas have been clarified in this document, but this appendix contains a short list of the most important things that require special attention from implementors.",
      "ja": "実装の経験から、以前のTLS仕様の特定の部分は理解しにくいことがわかり、相互運用性とセキュリティの問題の原因になっています。これらの領域の多くはこのドキュメントで明確にされていますが、この付録には、実装者による特別な注意を必要とする最も重要な事項の短いリストが含まれています。"
    },
    {
      "indent": 3,
      "text": "TLS protocol issues:",
      "ja": "TLSプロトコルの問題："
    },
    {
      "indent": 3,
      "text": "- Do you correctly handle handshake messages that are fragmented to multiple TLS records (see Section 6.2.1)? Including corner cases like a ClientHello that is split to several small fragments? Do you fragment handshake messages that exceed the maximum fragment size? In particular, the certificate and certificate request handshake messages can be large enough to require fragmentation.",
      "ja": "- 複数のTLSレコードに断片化されたハンドシェイクメッセージを正しく処理しますか（セクション6.2.1を参照）？いくつかの小さなフラグメントに分割されるClientHelloのようなコーナーケースを含みますか？最大フラグメントサイズを超えるハンドシェイクメッセージをフラグメント化しますか？特に、証明書と証明書要求のハンドシェイクメッセージは、断片化を必要とするほど大きくなる可能性があります。"
    },
    {
      "indent": 3,
      "text": "- Do you ignore the TLS record layer version number in all TLS records before ServerHello (see Appendix E.1)?",
      "ja": "- ServerHelloの前のすべてのTLSレコードのTLSレコードレイヤーバージョン番号を無視しますか（付録E.1を参照）？"
    },
    {
      "indent": 3,
      "text": "- Do you handle TLS extensions in ClientHello correctly, including omitting the extensions field completely?",
      "ja": "- 拡張フィールドを完全に省略して、ClientHelloでTLS拡張を正しく処理していますか？"
    },
    {
      "indent": 3,
      "text": "- Do you support renegotiation, both client and server initiated? While renegotiation is an optional feature, supporting it is highly recommended.",
      "ja": "- クライアントとサーバーの両方が開始した再ネゴシエーションをサポートしていますか？再ネゴシエーションはオプション機能ですが、サポートすることを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "- When the server has requested a client certificate, but no suitable certificate is available, do you correctly send an empty Certificate message, instead of omitting the whole message (see Section 7.4.6)?",
      "ja": "- サーバーがクライアント証明書を要求したが、適切な証明書がない場合、メッセージ全体を省略するのではなく、空の証明書メッセージを正しく送信しますか（セクション7.4.6を参照）？"
    },
    {
      "indent": 3,
      "text": "Cryptographic details:",
      "ja": "暗号化の詳細："
    },
    {
      "indent": 3,
      "text": "- In the RSA-encrypted Premaster Secret, do you correctly send and verify the version number? When an error is encountered, do you continue the handshake to avoid the Bleichenbacher attack (see Section 7.4.7.1)?",
      "ja": "- RSAで暗号化されたプリマスターシークレットで、バージョン番号を正しく送信して確認しますか？エラーが発生した場合、ブライヒェンバッハー攻撃を回避するためにハンドシェイクを続行しますか（セクション7.4.7.1を参照）？"
    },
    {
      "indent": 3,
      "text": "- What countermeasures do you use to prevent timing attacks against RSA decryption and signing operations (see Section 7.4.7.1)?",
      "ja": "- RSA復号および署名操作に対するタイミング攻撃を防ぐためにどのような対策を使用しますか（セクション7.4.7.1を参照）？"
    },
    {
      "indent": 3,
      "text": "- When verifying RSA signatures, do you accept both NULL and missing parameters (see Section 4.7)? Do you verify that the RSA padding doesn't have additional data after the hash value? [FI06]",
      "ja": "- RSA署名を検証するとき、NULLパラメータと欠落しているパラメータの両方を受け入れますか（セクション4.7を参照）？ RSAパディングにハッシュ値の後に追加のデータがないことを確認しますか？ [FI06]"
    },
    {
      "indent": 3,
      "text": "- When using Diffie-Hellman key exchange, do you correctly strip leading zero bytes from the negotiated key (see Section 8.1.2)?",
      "ja": "- Diffie-Hellmanキー交換を使用する場合、ネゴシエートされたキーから先頭の0バイトを正しく削除しますか（セクション8.1.2を参照）？"
    },
    {
      "indent": 3,
      "text": "- Does your TLS client check that the Diffie-Hellman parameters sent by the server are acceptable (see Section F.1.1.3)?",
      "ja": "- TLSクライアントは、サーバーから送信されたDiffie-Hellmanパラメータが受け入れ可能であることを確認していますか（セクションF.1.1.3を参照）？"
    },
    {
      "indent": 3,
      "text": "- How do you generate unpredictable IVs for CBC mode ciphers (see Section 6.2.3.2)?",
      "ja": "- CBCモード暗号の予測不可能なIVをどのように生成しますか（セクション6.2.3.2を参照）？"
    },
    {
      "indent": 3,
      "text": "- Do you accept long CBC mode padding (up to 255 bytes; see Section 6.2.3.2)?",
      "ja": "- 長いCBCモードのパディング（最大255バイト。セクション6.2.3.2を参照）を受け入れますか？"
    },
    {
      "indent": 3,
      "text": "- How do you address CBC mode timing attacks (Section 6.2.3.2)?",
      "ja": "- CBCモードのタイミング攻撃（セクション6.2.3.2）にどのように対処しますか？"
    },
    {
      "indent": 3,
      "text": "- Do you use a strong and, most importantly, properly seeded random number generator (see Appendix D.1) for generating the premaster secret (for RSA key exchange), Diffie-Hellman private values, the DSA \"k\" parameter, and other security-critical values?",
      "ja": "- プリマスターシークレット（RSAキー交換用）、Diffie-Hellmanプライベート値、DSA \"k\"パラメーター、およびその他のセキュリティを生成するために、強力で最も重要な、適切にシードされた乱数ジェネレータ（付録D.1を参照）を使用しますか？ -重要な値？"
    },
    {
      "indent": 0,
      "text": "Appendix E. Backward Compatibility",
      "section_title": true,
      "ja": "付録E.下位互換性"
    },
    {
      "indent": 0,
      "text": "E.1. Compatibility with TLS 1.0/1.1 and SSL 3.0",
      "section_title": true,
      "ja": "E.1. TLS 1.0 / 1.1およびSSL 3.0との互換性"
    },
    {
      "indent": 3,
      "text": "Since there are various versions of TLS (1.0, 1.1, 1.2, and any future versions) and SSL (2.0 and 3.0), means are needed to negotiate the specific protocol version to use. The TLS protocol provides a built-in mechanism for version negotiation so as not to bother other protocol components with the complexities of version selection.",
      "ja": "TLSにはさまざまなバージョン（1.0、1.1、1.2、および将来のバージョン）とSSL（2.0および3.0）があるため、使用する特定のプロトコルバージョンをネゴシエートする手段が必要です。 TLSプロトコルは、バージョンのネゴシエーションのための組み込みメカニズムを提供し、他のプロトコルコンポーネントがバージョン選択の複雑さに煩わされないようにします。"
    },
    {
      "indent": 3,
      "text": "TLS versions 1.0, 1.1, and 1.2, and SSL 3.0 are very similar, and use compatible ClientHello messages; thus, supporting all of them is relatively easy. Similarly, servers can easily handle clients trying to use future versions of TLS as long as the ClientHello format remains compatible, and the client supports the highest protocol version available in the server.",
      "ja": "TLSバージョン1.0、1.1、1.2、およびSSL 3.0は非常によく似ており、互換性のあるClientHelloメッセージを使用します。したがって、それらすべてのサポートは比較的簡単です。同様に、ClientHelloフォーマットの互換性が維持され、クライアントがサーバーで利用可能な最高のプロトコルバージョンをサポートしている限り、サーバーはTLSの将来のバージョンを使用しようとするクライアントを簡単に処理できます。"
    },
    {
      "indent": 3,
      "text": "A TLS 1.2 client who wishes to negotiate with such older servers will send a normal TLS 1.2 ClientHello, containing { 3, 3 } (TLS 1.2) in ClientHello.client_version. If the server does not support this version, it will respond with a ServerHello containing an older version number. If the client agrees to use this version, the negotiation will proceed as appropriate for the negotiated protocol.",
      "ja": "そのような古いサーバーと交渉したいTLS 1.2クライアントは、ClientHello.client_versionに{3、3}（TLS 1.2）を含む通常のTLS 1.2 ClientHelloを送信します。サーバーがこのバージョンをサポートしていない場合、サーバーは古いバージョン番号を含むServerHelloで応答します。クライアントがこのバージョンの使用に同意した場合、ネゴシエートされたプロトコルに応じてネゴシエーションが続行されます。"
    },
    {
      "indent": 3,
      "text": "If the version chosen by the server is not supported by the client (or not acceptable), the client MUST send a \"protocol_version\" alert message and close the connection.",
      "ja": "サーバーによって選択されたバージョンがクライアントによってサポートされていない（または受け入れられない）場合、クライアントは \"protocol_version\"警告メッセージを送信して接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "If a TLS server receives a ClientHello containing a version number greater than the highest version supported by the server, it MUST reply according to the highest version supported by the server.",
      "ja": "TLSサーバーが、サーバーでサポートされている最高のバージョンより大きいバージョン番号を含むClientHelloを受信した場合、サーバーでサポートされている最高のバージョンに従って応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "A TLS server can also receive a ClientHello containing a version number smaller than the highest supported version. If the server wishes to negotiate with old clients, it will proceed as appropriate for the highest version supported by the server that is not greater than ClientHello.client_version. For example, if the server supports TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If server supports (or is willing to use) only versions greater than client_version, it MUST send a \"protocol_version\" alert message and close the connection.",
      "ja": "TLSサーバーは、サポートされている最高のバージョンより小さいバージョン番号を含むClientHelloも受信できます。サーバーが古いクライアントとネゴシエートしたい場合は、サーバーがサポートするClientHello.client_version以下の最高バージョンに応じて適切に処理されます。たとえば、サーバーがTLS 1.0、1.1、および1.2をサポートし、client_versionがTLS 1.0である場合、サーバーはTLS 1.0 ServerHelloを続行します。サーバーがclient_versionより大きいバージョンのみをサポートする（または使用する意思がある）場合、「protocol_version」アラートメッセージを送信して接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Whenever a client already knows the highest protocol version known to a server (for example, when resuming a session), it SHOULD initiate the connection in that native protocol.",
      "ja": "クライアントがサーバーに認識されている最も高いプロトコルバージョンをすでに知っている場合（たとえば、セッションを再開する場合）は、そのネイティブプロトコルで接続を開始する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Note: some server implementations are known to implement version negotiation incorrectly. For example, there are buggy TLS 1.0 servers that simply close the connection when the client offers a version newer than TLS 1.0. Also, it is known that some servers will refuse the connection if any TLS extensions are included in ClientHello. Interoperability with such buggy servers is a complex topic beyond the scope of this document, and may require multiple connection attempts by the client.",
      "ja": "注：一部のサーバー実装では、バージョンネゴシエーションが正しく実装されていないことがわかっています。たとえば、クライアントがTLS 1.0より新しいバージョンを提供すると、接続を閉じるだけのバグのあるTLS 1.0サーバーがあります。また、TLSの拡張機能がClientHelloに含まれている場合、一部のサーバーは接続を拒否することがわかっています。このようなバグのあるサーバーとの相互運用性は、このドキュメントの範囲を超える複雑なトピックであり、クライアントによる複数の接続試行が必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "Earlier versions of the TLS specification were not fully clear on what the record layer version number (TLSPlaintext.version) should contain when sending ClientHello (i.e., before it is known which version of the protocol will be employed). Thus, TLS servers compliant with this specification MUST accept any value {03,XX} as the record layer version number for ClientHello.",
      "ja": "TLS仕様の以前のバージョンでは、ClientHelloを送信するときに（つまり、プロトコルのどのバージョンが使用されるかがわかる前に）、レコードレイヤーのバージョン番号（TLSPlaintext.version）に何を含める必要があるかが完全に明確ではありませんでした。したがって、この仕様に準拠するTLSサーバーは、ClientHelloのレコードレイヤーバージョン番号として任意の値{03、XX}を受け入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "TLS clients that wish to negotiate with older servers MAY send any value {03,XX} as the record layer version number. Typical values would be {03,00}, the lowest version number supported by the client, and the value of ClientHello.client_version. No single value will guarantee interoperability with all old servers, but this is a complex topic beyond the scope of this document.",
      "ja": "古いサーバーとネゴシエートしたいTLSクライアントは、レコードレイヤーのバージョン番号として値{03、XX}を送信する場合があります。通常の値は{03,00}、クライアントがサポートする最小のバージョン番号、ClientHello.client_versionの値です。すべての古いサーバーとの相互運用性を保証する単一の値はありませんが、これはこのドキュメントの範囲を超える複雑なトピックです。"
    },
    {
      "indent": 0,
      "text": "E.2. Compatibility with SSL 2.0",
      "section_title": true,
      "ja": "E.2. SSL 2.0との互換性"
    },
    {
      "indent": 3,
      "text": "TLS 1.2 clients that wish to support SSL 2.0 servers MUST send version 2.0 CLIENT-HELLO messages defined in [SSL2]. The message MUST contain the same version number as would be used for ordinary ClientHello, and MUST encode the supported TLS cipher suites in the CIPHER-SPECS-DATA field as described below.",
      "ja": "SSL 2.0サーバーをサポートしたいTLS 1.2クライアントは、[SSL2]で定義されたバージョン2.0 CLIENT-HELLOメッセージを送信する必要があります。メッセージには、通常のClientHelloに使用されるのと同じバージョン番号が含まれている必要があり、サポートされているTLS暗号スイートをCIPHER-SPECS-DATAフィールドにエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "Warning: The ability to send version 2.0 CLIENT-HELLO messages will be phased out with all due haste, since the newer ClientHello format provides better mechanisms for moving to newer versions and negotiating extensions. TLS 1.2 clients SHOULD NOT support SSL 2.0.",
      "ja": "警告：バージョン2.0のCLIENT-HELLOメッセージを送信する機能は、新しいClientHello形式が新しいバージョンへの移行と拡張機能のネゴシエーションにより優れたメカニズムを提供するため、当然のことながらすべて段階的に廃止されます。 TLS 1.2クライアントはSSL 2.0をサポートしてはいけません。"
    },
    {
      "indent": 3,
      "text": "However, even TLS servers that do not support SSL 2.0 MAY accept version 2.0 CLIENT-HELLO messages. The message is presented below in sufficient detail for TLS server implementors; the true definition is still assumed to be [SSL2].",
      "ja": "ただし、SSL 2.0をサポートしていないTLSサーバーでも、バージョン2.0のCLIENT-HELLOメッセージを受け入れる場合があります。メッセージは、TLSサーバーの実装者のために以下に詳細に示されています。真の定義は依然として[SSL2]であると想定されています。"
    },
    {
      "indent": 3,
      "text": "For negotiation purposes, 2.0 CLIENT-HELLO is interpreted the same way as a ClientHello with a \"null\" compression method and no extensions. Note that this message MUST be sent directly on the wire, not wrapped as a TLS record. For the purposes of calculating Finished and CertificateVerify, the msg_length field is not considered to be a part of the handshake message.",
      "ja": "ネゴシエーションのために、2.0 CLIENT-HELLOは、ClientNelloと同じように解釈され、「null」圧縮方式で拡張されません。このメッセージは、TLSレコードとしてラップされるのではなく、ネットワーク上で直接送信される必要があることに注意してください。 FinishedおよびCertificateVerifyを計算するために、msg_lengthフィールドはハンドシェイクメッセージの一部とは見なされません。"
    },
    {
      "indent": 6,
      "text": "uint8 V2CipherSpec[3];\nstruct {\n    uint16 msg_length;\n    uint8 msg_type;\n    Version version;\n    uint16 cipher_spec_length;\n    uint16 session_id_length;\n    uint16 challenge_length;\n    V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];\n    opaque session_id[V2ClientHello.session_id_length];\n    opaque challenge[V2ClientHello.challenge_length;\n} V2ClientHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "msg_length The highest bit MUST be 1; the remaining bits contain the length of the following data in bytes.",
      "ja": "msg_length最上位ビットは1でなければなりません。残りのビットには、次のデータの長さがバイト単位で含まれています。"
    },
    {
      "indent": 3,
      "text": "msg_type This field, in conjunction with the version field, identifies a version 2 ClientHello message. The value MUST be 1.",
      "ja": "msg_typeこのフィールドは、バージョンフィールドと組み合わせて、バージョン2のClientHelloメッセージを識別します。値は1でなければなりません。"
    },
    {
      "indent": 3,
      "text": "version Equal to ClientHello.client_version.",
      "ja": "version ClientHello.client_versionと同じです。"
    },
    {
      "indent": 3,
      "text": "cipher_spec_length This field is the total length of the field cipher_specs. It cannot be zero and MUST be a multiple of the V2CipherSpec length (3).",
      "ja": "cipher_spec_lengthこのフィールドは、フィールドcipher_specsの全長です。ゼロにすることはできず、V2CipherSpecの長さ（3）の倍数にする必要があります。"
    },
    {
      "indent": 3,
      "text": "session_id_length This field MUST have a value of zero for a client that claims to support TLS 1.2.",
      "ja": "session_id_lengthこのフィールドは、TLS 1.2をサポートすることを要求するクライアントに対してはゼロの値を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "challenge_length The length in bytes of the client's challenge to the server to authenticate itself. Historically, permissible values are between 16 and 32 bytes inclusive. When using the SSLv2 backward-compatible handshake the client SHOULD use a 32-byte challenge.",
      "ja": "challenge_length自身を認証するためのサーバーへのクライアントのチャレンジの長さ（バイト単位）。これまで、許容される値は16〜32バイトです。 SSLv2下位互換ハンドシェイクを使用する場合、クライアントは32バイトのチャレンジを使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "cipher_specs This is a list of all CipherSpecs the client is willing and able to use. In addition to the 2.0 cipher specs defined in [SSL2], this includes the TLS cipher suites normally sent in ClientHello.cipher_suites, with each cipher suite prefixed by a zero byte. For example, the TLS cipher suite {0x00,0x0A} would be sent as {0x00,0x00,0x0A}.",
      "ja": "cipher_specsこれは、クライアントが喜んで使用できるすべてのCipherSpecのリストです。 [SSL2]で定義された2.0暗号仕様に加えて、これには通常ClientHello.cipher_suitesで送信されるTLS暗号スイートが含まれ、各暗号スイートには0バイトがプレフィックスとして付加されます。たとえば、TLS暗号スイート{0x00,0x0A}は{0x00,0x00,0x0A}として送信されます。"
    },
    {
      "indent": 3,
      "text": "session_id This field MUST be empty.",
      "ja": "session_idこのフィールドは空でなければなりません。"
    },
    {
      "indent": 3,
      "text": "challenge Corresponds to ClientHello.random. If the challenge length is less than 32, the TLS server will pad the data with leading (note: not trailing) zero bytes to make it 32 bytes long.",
      "ja": "challenge ClientHello.randomに対応します。チャレンジの長さが32未満である場合、TLSサーバーはデータを先頭（末尾ではない）のゼロバイトで埋め込み、32バイトの長さにします。"
    },
    {
      "indent": 3,
      "text": "Note: Requests to resume a TLS session MUST use a TLS client hello.",
      "ja": "注：TLSセッションを再開する要求は、TLSクライアントのHelloを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "E.3. Avoiding Man-in-the-Middle Version Rollback",
      "section_title": true,
      "ja": "E.3. 中間者バージョンのロールバックの回避"
    },
    {
      "indent": 3,
      "text": "When TLS clients fall back to Version 2.0 compatibility mode, they MUST use special PKCS#1 block formatting. This is done so that TLS servers will reject Version 2.0 sessions with TLS-capable clients.",
      "ja": "TLSクライアントがバージョン2.0互換モードにフォールバックする場合、クライアントは特別なPKCS＃1ブロックフォーマットを使用する必要があります。これは、TLSサーバーがTLS対応クライアントとのバージョン2.0セッションを拒否するように行われます。"
    },
    {
      "indent": 3,
      "text": "When a client negotiates SSL 2.0 but also supports TLS, it MUST set the right-hand (least-significant) 8 random bytes of the PKCS padding (not including the terminal null of the padding) for the RSA encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY to 0x03 (the other padding bytes are random).",
      "ja": "クライアントがSSL 2.0をネゴシエートするがTLSもサポートする場合、ENCRYPTED-KEY-のRSA暗号化のために、PKCSパディングの右側（最下位）の8バイトをランダムに設定する必要があります（パディングの端末ヌルを含まない）。 CLIENT-MASTER-KEYのDATAフィールドを0x03に変更します（他のパディングバイトはランダムです）。"
    },
    {
      "indent": 3,
      "text": "When a TLS-capable server negotiates SSL 2.0 it SHOULD, after decrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding bytes are 0x03. If they are not, the server SHOULD generate a random value for SECRET-KEY-DATA, and continue the handshake (which will eventually fail since the keys will not match). Note that reporting the error situation to the client could make the server vulnerable to attacks described in [BLEI].",
      "ja": "TLS対応サーバーがSSL 2.0をネゴシエートするときは、SHOULD、ENCRYPTED-KEY-DATAフィールドを復号化した後、これらの8つのパディングバイトが0x03であることを確認します。そうでない場合、サーバーはSECRET-KEY-DATAのランダムな値を生成し、ハンドシェイクを続行する必要があります（キーが一致しないため、最終的に失敗します）。エラー状況をクライアントに報告すると、サーバーが[BLEI]で説明されている攻撃に対して脆弱になる可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Security Analysis",
      "section_title": true,
      "ja": "付録F.セキュリティ分析"
    },
    {
      "indent": 3,
      "text": "The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.",
      "ja": "TLSプロトコルは、安全でないチャネルを介して通信するクライアントとサーバー間の安全な接続を確立するように設計されています。このドキュメントは、攻撃者がかなりの計算リソースを持ち、プロトコルの外部のソースから秘密情報を取得できないことを含め、いくつかの従来の仮定を行います。攻撃者は、通信チャネルを介して送信されたメッセージをキャプチャ、変更、削除、再生、その他改ざんする機能を持っていると想定されています。この付録では、さまざまな攻撃に対抗するためにTLSがどのように設計されているかについて概説します。"
    },
    {
      "indent": 0,
      "text": "F.1. Handshake Protocol",
      "section_title": true,
      "ja": "F.1. ハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "The handshake protocol is responsible for selecting a cipher spec and generating a master secret, which together comprise the primary cryptographic parameters associated with a secure session. The handshake protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.",
      "ja": "ハンドシェイクプロトコルは、暗号仕様の選択とマスターシークレットの生成を担当します。マスターシークレットは、安全なセッションに関連付けられた主要な暗号化パラメーターをまとめて構成します。ハンドシェイクプロトコルは、信頼できる認証局によって署名された証明書を持つ当事者をオプションで認証することもできます。"
    },
    {
      "indent": 0,
      "text": "F.1.1. Authentication and Key Exchange",
      "section_title": true,
      "ja": "F.1.1. 認証と鍵交換"
    },
    {
      "indent": 3,
      "text": "TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other's certificate is valid and has not expired or been revoked.",
      "ja": "TLSは3つの認証モードをサポートします。両方の認証、非認証クライアントによるサーバー認証、完全な匿名性です。サーバーが認証されるたびに、チャネルは中間者攻撃に対して安全ですが、完全に匿名のセッションは本質的にそのような攻撃に対して脆弱です。匿名サーバーはクライアントを認証できません。サーバーが認証される場合、その証明書メッセージは、受け入れ可能な認証局につながる有効な証明書チェーンを提供する必要があります。同様に、認証されたクライアントは、受け入れ可能な証明書をサーバーに提供する必要があります。各当事者は、相手の証明書が有効であり、有効期限が切れていない、または取り消されていないことを確認する責任があります。"
    },
    {
      "indent": 3,
      "text": "The general goal of the key exchange process is to create a pre_master_secret known to the communicating parties and not to attackers. The pre_master_secret will be used to generate the master_secret (see Section 8.1). The master_secret is required to generate the Finished messages, encryption keys, and MAC keys (see Sections 7.4.9 and 6.3). By sending a correct Finished message, parties thus prove that they know the correct pre_master_secret.",
      "ja": "鍵交換プロセスの一般的な目標は、攻撃者ではなく通信相手に知られるpre_master_secretを作成することです。 pre_master_secretは、master_secretを生成するために使用されます（セクション8.1を参照）。完成したメッセージ、暗号化キー、およびMACキーを生成するには、master_secretが必要です（セクション7.4.9および6.3を参照）。したがって、正しいFinishedメッセージを送信することにより、パーティは正しいpre_master_secretを知っていることを証明します。"
    },
    {
      "indent": 0,
      "text": "F.1.1.1. Anonymous Key Exchange",
      "section_title": true,
      "ja": "F.1.1.1. 匿名キー交換"
    },
    {
      "indent": 3,
      "text": "Completely anonymous sessions can be established using Diffie-Hellman for key exchange. The server's public parameters are contained in the server key exchange message, and the client's are sent in the client key exchange message. Eavesdroppers who do not know the private values should not be able to find the Diffie-Hellman result (i.e., the pre_master_secret).",
      "ja": "キーの交換にDiffie-Hellmanを使用すると、完全に匿名のセッションを確立できます。サーバーの公開パラメーターはサーバーの鍵交換メッセージに含まれ、クライアントの公開パラメーターはクライアントの鍵交換メッセージで送信されます。プライベートな値を知らない盗聴者は、Diffie-Hellmanの結果（つまり、pre_master_secret）を見つけることができません。"
    },
    {
      "indent": 3,
      "text": "Warning: Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the Finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.",
      "ja": "警告：完全に匿名の接続は、受動的な盗聴に対する保護のみを提供します。独立した改ざん防止チャネルを使用して終了メッセージが攻撃者に置き換えられていないことを確認しない限り、アクティブな中間者攻撃が懸念される環境ではサーバー認証が必要です。"
    },
    {
      "indent": 0,
      "text": "F.1.1.2. RSA Key Exchange and Authentication",
      "section_title": true,
      "ja": "F.1.1.2. RSAキー交換と認証"
    },
    {
      "indent": 3,
      "text": "With RSA, key exchange and server authentication are combined. The public key is contained in the server's certificate. Note that compromise of the server's static RSA key results in a loss of confidentiality for all sessions protected under that static key. TLS users desiring Perfect Forward Secrecy should use DHE cipher suites. The damage done by exposure of a private key can be limited by changing one's private key (and certificate) frequently.",
      "ja": "RSAでは、鍵交換とサーバー認証が組み合わされています。公開鍵はサーバーの証明書に含まれています。サーバーの静的RSAキーが侵害されると、その静的キーで保護されているすべてのセッションの機密性が失われることに注意してください。 Perfect Forward Secrecyを希望するTLSユーザーは、DHE暗号スイートを使用する必要があります。秘密鍵の公開による被害は、自分の秘密鍵（および証明書）を頻繁に変更することで制限できます。"
    },
    {
      "indent": 3,
      "text": "After verifying the server's certificate, the client encrypts a pre_master_secret with the server's public key. By successfully decoding the pre_master_secret and producing a correct Finished message, the server demonstrates that it knows the private key corresponding to the server certificate.",
      "ja": "サーバーの証明書を確認した後、クライアントはサーバーの公開鍵を使用してpre_master_secretを暗号化します。 pre_master_secretを正常にデコードして正しいFinishedメッセージを生成することにより、サーバーは、サーバー証明書に対応する秘密鍵を知っていることを示します。"
    },
    {
      "indent": 3,
      "text": "When RSA is used for key exchange, clients are authenticated using the certificate verify message (see Section 7.4.8). The client signs a value derived from all preceding handshake messages. These handshake messages include the server certificate, which binds the signature to the server, and ServerHello.random, which binds the signature to the current handshake process.",
      "ja": "RSAをキー交換に使用する場合、クライアントは証明書検証メッセージを使用して認証されます（セクション7.4.8を参照）。クライアントは、先行するすべてのハンドシェイクメッセージから派生した値に署名します。これらのハンドシェイクメッセージには、署名をサーバーにバインドするサーバー証明書と、署名を現在のハンドシェイクプロセスにバインドするServerHello.randomが含まれます。"
    },
    {
      "indent": 0,
      "text": "F.1.1.3. Diffie-Hellman Key Exchange with Authentication",
      "section_title": true,
      "ja": "F.1.1.3. 認証付きのDiffie-Hellman鍵交換"
    },
    {
      "indent": 3,
      "text": "When Diffie-Hellman key exchange is used, the server can either supply a certificate containing fixed Diffie-Hellman parameters or use the server key exchange message to send a set of temporary Diffie-Hellman parameters signed with a DSA or RSA certificate. Temporary parameters are hashed with the hello.random values before signing to ensure that attackers do not replay old parameters. In either case, the client can verify the certificate or signature to ensure that the parameters belong to the server.",
      "ja": "Diffie-Hellman鍵交換を使用する場合、サーバーは、固定Diffie-Hellmanパラメーターを含む証明書を提供するか、サーバー鍵交換メッセージを使用して、DSAまたはRSA証明書で署名された一時的なDiffie-Hellmanパラメーターのセットを送信できます。一時的なパラメーターは、署名前にhello.random値でハッシュされ、攻撃者が古いパラメーターを再生しないようにします。どちらの場合でも、クライアントは証明書または署名を検証して、パラメーターがサーバーに属していることを確認できます。"
    },
    {
      "indent": 3,
      "text": "If the client has a certificate containing fixed Diffie-Hellman parameters, its certificate contains the information required to complete the key exchange. Note that in this case the client and server will generate the same Diffie-Hellman result (i.e., pre_master_secret) every time they communicate. To prevent the pre_master_secret from staying in memory any longer than necessary, it should be converted into the master_secret as soon as possible. Client Diffie-Hellman parameters must be compatible with those supplied by the server for the key exchange to work.",
      "ja": "クライアントに固定Diffie-Hellmanパラメーターを含む証明書がある場合、その証明書には、鍵交換を完了するために必要な情報が含まれています。この場合、クライアントとサーバーは、通信するたびに同じDiffie-Hellman結果（つまり、pre_master_secret）を生成することに注意してください。 pre_master_secretが必要以上に長くメモリに留まるのを防ぐには、できるだけ早くmaster_secretに変換する必要があります。クライアントのDiffie-Hellmanパラメータは、鍵交換が機能するために、サーバーによって提供されるものと互換性がある必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client has a standard DSA or RSA certificate or is unauthenticated, it sends a set of temporary parameters to the server in the client key exchange message, then optionally uses a certificate verify message to authenticate itself.",
      "ja": "クライアントが標準のDSAまたはRSA証明書を持っているか、認証されていない場合、クライアントは一連の一時パラメーターをクライアントの鍵交換メッセージでサーバーに送信し、オプションで証明書検証メッセージを使用して自身を認証します。"
    },
    {
      "indent": 3,
      "text": "If the same DH keypair is to be used for multiple handshakes, either because the client or server has a certificate containing a fixed DH keypair or because the server is reusing DH keys, care must be taken to prevent small subgroup attacks. Implementations SHOULD follow the guidelines found in [SUBGROUP].",
      "ja": "同じDHキーペアを複数のハンドシェイクに使用する場合、クライアントまたはサーバーに固定DHキーペアを含む証明書があるか、サーバーがDHキーを再利用しているため、小さなサブグループ攻撃を防ぐように注意する必要があります。実装は[サブグループ]にあるガイドラインに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "Small subgroup attacks are most easily avoided by using one of the DHE cipher suites and generating a fresh DH private key (X) for each handshake. If a suitable base (such as 2) is chosen, g^X mod p can be computed very quickly; therefore, the performance cost is minimized. Additionally, using a fresh key for each handshake provides Perfect Forward Secrecy. Implementations SHOULD generate a new X for each handshake when using DHE cipher suites.",
      "ja": "小さなサブグループ攻撃は、DHE暗号スイートの1つを使用し、ハンドシェイクごとに新しいDH秘密キー（X）を生成することで最も簡単に回避できます。適切なベース（2など）を選択すると、g ^ X mod pを非常に迅速に計算できます。したがって、パフォーマンスコストは最小限に抑えられます。さらに、ハンドシェイクごとに新しいキーを使用すると、Perfect Forward Secrecyが提供されます。実装は、DHE暗号スイートを使用する場合、ハンドシェイクごとに新しいXを生成する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Because TLS allows the server to provide arbitrary DH groups, the client should verify that the DH group is of suitable size as defined by local policy. The client SHOULD also verify that the DH public exponent appears to be of adequate size. [KEYSIZ] provides a useful guide to the strength of various group sizes. The server MAY choose to assist the client by providing a known group, such as those defined in [IKEALG] or [MODP]. These can be verified by simple comparison.",
      "ja": "TLSではサーバーが任意のDHグループを提供できるため、クライアントは、DHグループがローカルポリシーで定義されている適切なサイズであることを確認する必要があります。クライアントは、DH公開指数が適切なサイズであるように見えることも確認する必要があります（SHOULD）。 [KEYSIZ]は、さまざまなグループサイズの強さを示す便利なガイドです。サーバーは、[IKEALG]や[MODP]で定義されているような既知のグループを提供することにより、クライアントを支援することを選択できます（MAY）。これらは簡単な比較で確認できます。"
    },
    {
      "indent": 0,
      "text": "F.1.2. Version Rollback Attacks",
      "section_title": true,
      "ja": "F.1.2. バージョンロールバック攻撃"
    },
    {
      "indent": 3,
      "text": "Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS-capable parties use an SSL 2.0 handshake.",
      "ja": "TLSにはSSLバージョン2.0に対する大幅な改善が含まれているため、攻撃者はTLS対応のクライアントとサーバーをバージョン2.0にフォールバックしようとする可能性があります。この攻撃は、2つのTLS対応パーティがSSL 2.0ハンドシェイクを使用している場合にのみ発生します。"
    },
    {
      "indent": 3,
      "text": "Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute-force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application-specified wait threshold has expired. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.",
      "ja": "非ランダムPKCS＃1ブロックタイプ2メッセージパディングを使用するソリューションは洗練されていませんが、バージョン3.0サーバーが攻撃を検出するためのかなり安全な方法を提供します。このソリューションは、攻撃者がキーをブルートフォースし、同じキーを含む新しいENCRYPTED-KEY-DATAメッセージを（ただし、通常のパディングを使用して）置き換え、アプリケーション指定の待機しきい値が期限切れになる前に保護することはできません。 PKCSパディングの最下位8バイトのパディングを変更しても、プロトコルで使用される署名付きハッシュのサイズとRSAキー長のセキュリティには影響しません。これは、入力ブロックサイズを8バイト増やすことと本質的に同じであるためです。"
    },
    {
      "indent": 0,
      "text": "F.1.3. Detecting Attacks Against the Handshake Protocol",
      "section_title": true,
      "ja": "F.1.3. ハンドシェイクプロトコルに対する攻撃の検出"
    },
    {
      "indent": 3,
      "text": "An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally choose.",
      "ja": "攻撃者は、ハンドシェイク交換に影響を与え、当事者が通常選択するのとは異なる暗号化アルゴリズムを選択させる可能性があります。"
    },
    {
      "indent": 3,
      "text": "For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others' Finished messages. Without the master_secret, the attacker cannot repair the Finished messages, so the attack will be discovered.",
      "ja": "この攻撃では、攻撃者は1つ以上のハンドシェイクメッセージを積極的に変更する必要があります。これが発生した場合、クライアントとサーバーは、ハンドシェイクメッセージハッシュの異なる値を計算します。その結果、当事者はお互いの完了メッセージを受け入れません。 master_secretがないと、攻撃者は完了メッセージを修復できないため、攻撃が発見されます。"
    },
    {
      "indent": 0,
      "text": "F.1.4. Resuming Sessions",
      "section_title": true,
      "ja": "F.1.4. セッションの再開"
    },
    {
      "indent": 3,
      "text": "When a connection is established by resuming a session, new ClientHello.random and ServerHello.random values are hashed with the session's master_secret. Provided that the master_secret has not been compromised and that the secure hash operations used to produce the encryption keys and MAC keys are secure, the connection should be secure and effectively independent from previous connections. Attackers cannot use known encryption keys or MAC secrets to compromise the master_secret without breaking the secure hash operations.",
      "ja": "セッションを再開して接続が確立されると、新しいClientHello.randomとServerHello.randomの値がセッションのmaster_secretでハッシュされます。 master_secretが危険にさらされておらず、暗号化キーとMACキーの生成に使用される安全なハッシュ操作が安全であれば、接続は安全で、以前の接続から事実上独立している必要があります。攻撃者は、既知の暗号化キーやMACシークレットを使用して、安全なハッシュ操作を壊さずにmaster_secretを侵害することはできません。"
    },
    {
      "indent": 3,
      "text": "Sessions cannot be resumed unless both the client and server agree. If either party suspects that the session may have been compromised, or that certificates may have expired or been revoked, it should force a full handshake. An upper limit of 24 hours is suggested for session ID lifetimes, since an attacker who obtains a master_secret may be able to impersonate the compromised party until the corresponding session ID is retired. Applications that may be run in relatively insecure environments should not write session IDs to stable storage.",
      "ja": "クライアントとサーバーの両方が同意しない限り、セッションを再開することはできません。どちらかの当事者が、セッションが危険にさらされている可能性がある、または証明書が期限切れになっている、または取り消されている可能性があると疑う場合は、完全なハンドシェイクを強制する必要があります。 master_secretを取得した攻撃者は、対応するセッションIDが廃止されるまで、侵害されたパーティを偽装できる可能性があるため、セッションIDのライフタイムには24時間の上限をお勧めします。比較的安全でない環境で実行される可能性のあるアプリケーションは、セッションIDを安定したストレージに書き込むべきではありません。"
    },
    {
      "indent": 0,
      "text": "F.2. Protecting Application Data",
      "section_title": true,
      "ja": "F.2. アプリケーションデータの保護"
    },
    {
      "indent": 3,
      "text": "The master_secret is hashed with the ClientHello.random and ServerHello.random to produce unique data encryption keys and MAC secrets for each connection.",
      "ja": "master_secretはClientHello.randomとServerHello.randomでハッシュされ、接続ごとに一意のデータ暗号化キーとMACシークレットが生成されます。"
    },
    {
      "indent": 3,
      "text": "Outgoing data is protected with a MAC before transmission. To prevent message replay or modification attacks, the MAC is computed from the MAC key, the sequence number, the message length, the message contents, and two fixed character strings. The message type field is necessary to ensure that messages intended for one TLS record layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64 bits long, they should never overflow. Messages from one party cannot be inserted into the other's output, since they use independent MAC keys. Similarly, the server write and client write keys are independent, so stream cipher keys are used only once.",
      "ja": "送信データは、送信前にMACで保護されます。メッセージの再生や変更攻撃を防ぐために、MACはMACキー、シーケンス番号、メッセージの長さ、メッセージの内容、および2つの固定文字列から計算されます。メッセージタイプフィールドは、あるTLSレコードレイヤクライアント宛のメッセージが別のクライアントにリダイレクトされないようにするために必要です。シーケンス番号により、メッセージの削除または並べ替えの試行が確実に検出されます。シーケンス番号は64ビット長であるため、オーバーフローすることはありません。あるパーティからのメッセージは、独立したMACキーを使用するため、他のパーティの出力には挿入できません。同様に、サーバー書き込みキーとクライアント書き込みキーは独立しているため、ストリーム暗号キーは1回だけ使用されます。"
    },
    {
      "indent": 3,
      "text": "If an attacker does break an encryption key, all messages encrypted with it can be read. Similarly, compromise of a MAC key can make message-modification attacks possible. Because MACs are also encrypted, message-alteration attacks generally require breaking the encryption algorithm as well as the MAC.",
      "ja": "攻撃者が暗号化キーを破った場合、それを使用して暗号化されたすべてのメッセージを読み取ることができます。同様に、MACキーが侵害されると、メッセージ変更攻撃が可能になります。 MACも暗号化されているため、メッセージ変更攻撃では通常、MACだけでなく暗号化アルゴリズムを破る必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: MAC keys may be larger than encryption keys, so messages can remain tamper resistant even if encryption keys are broken.",
      "ja": "注：MACキーは暗号化キーよりも大きい場合があるため、暗号化キーが壊れていてもメッセージは改ざんされないままです。"
    },
    {
      "indent": 0,
      "text": "F.3. Explicit IVs",
      "section_title": true,
      "ja": "F.3. 明示的なIV"
    },
    {
      "indent": 3,
      "text": "[CBCATT] describes a chosen plaintext attack on TLS that depends on knowing the IV for a record. Previous versions of TLS [TLS1.0] used the CBC residue of the previous record as the IV and therefore enabled this attack. This version uses an explicit IV in order to protect against this attack.",
      "ja": "[CBCATT]は、レコードのIVを知ることに依存する、TLSに対する選択された平文攻撃について説明しています。以前のバージョンのTLS [TLS1.0]では、以前のレコードのCBC残差をIVとして使用していたため、この攻撃が可能でした。このバージョンでは、この攻撃から保護するために明示的なIVを使用しています。"
    },
    {
      "indent": 0,
      "text": "F.4. Security of Composite Cipher Modes",
      "section_title": true,
      "ja": "F.4. 複合暗号モードのセキュリティ"
    },
    {
      "indent": 3,
      "text": "TLS secures transmitted application data via the use of symmetric encryption and authentication functions defined in the negotiated cipher suite. The objective is to protect both the integrity and confidentiality of the transmitted data from malicious actions by active attackers in the network. It turns out that the order in which encryption and authentication functions are applied to the data plays an important role for achieving this goal [ENCAUTH].",
      "ja": "TLSは、ネゴシエートされた暗号スイートで定義された対称暗号化および認証機能を使用して、送信されたアプリケーションデータを保護します。目的は、ネットワーク内のアクティブな攻撃者による悪意のあるアクションから送信データの整合性と機密性の両方を保護することです。暗号化および認証機能がデータに適用される順序が、この目標を達成するために重要な役割を果たすことがわかります[ENCAUTH]。"
    },
    {
      "indent": 3,
      "text": "The most robust method, called encrypt-then-authenticate, first applies encryption to the data and then applies a MAC to the ciphertext. This method ensures that the integrity and confidentiality goals are obtained with ANY pair of encryption and MAC functions, provided that the former is secure against chosen plaintext attacks and that the MAC is secure against chosen-message attacks. TLS uses another method, called authenticate-then-encrypt, in which first a MAC is computed on the plaintext and then the concatenation of plaintext and MAC is encrypted. This method has been proven secure for CERTAIN combinations of encryption functions and MAC functions, but it is not guaranteed to be secure in general.",
      "ja": "暗号化してから認証と呼ばれる最も堅牢な方法は、最初にデータに暗号化を適用し、次に暗号文にMACを適用します。この方法は、暗号化機能とMAC機能の任意のペアで整合性と機密性の目標が確実に得られることを保証します。 TLSは、authenticate-then-encryptと呼ばれる別の方法を使用します。この方法では、最初に平文でMACが計算され、次に平文とMACの連結が暗号化されます。この方法は、暗号化関数とMAC関数のCERTAINの組み合わせに対して安全であることが証明されていますが、一般的に安全であるとは限りません。"
    },
    {
      "indent": 3,
      "text": "In particular, it has been shown that there exist perfectly secure encryption functions (secure even in the information-theoretic sense) that combined with any secure MAC function, fail to provide the confidentiality goal against an active attack. Therefore, new cipher suites and operation modes adopted into TLS need to be analyzed under the authenticate-then-encrypt method to verify that they achieve the stated integrity and confidentiality goals.",
      "ja": "特に、安全なMAC機能と組み合わせると完全に安全な暗号化機能（情報理論的にも安全）が存在し、アクティブな攻撃に対する機密性の目標を達成できないことが示されています。したがって、TLSに採用された新しい暗号スイートと操作モードは、認証後暗号化方式で分析して、指定された整合性と機密性の目標を達成していることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Currently, the security of the authenticate-then-encrypt method has been proven for some important cases. One is the case of stream ciphers in which a computationally unpredictable pad of the length of the message, plus the length of the MAC tag, is produced using a pseudorandom generator and this pad is exclusive-ORed with the concatenation of plaintext and MAC tag. The other is the case of CBC mode using a secure block cipher. In this case, security can be shown if one applies one CBC encryption pass to the concatenation of plaintext and MAC and uses a new, independent, and unpredictable IV for each new pair of plaintext and MAC. In versions of TLS prior to 1.1, CBC mode was used properly EXCEPT that it used a predictable IV in the form of the last block of the previous ciphertext. This made TLS open to chosen plaintext attacks. This version of the protocol is immune to those attacks. For exact details in the encryption modes proven secure, see [ENCAUTH].",
      "ja": "現在、authenticate-then-encryptメソッドのセキュリティは、いくつかの重要なケースで証明されています。 1つは、ストリーム暗号の場合で、メッセージの長さとMACタグの長さの計算上予測不可能なパッドが疑似ランダムジェネレーターを使用して生成され、このパッドはプレーンテキストとMACタグの連結と排他的論理和がとられます。もう1つは、安全なブロック暗号を使用するCBCモードの場合です。この場合、プレーンテキストとMACの連結に1つのCBC暗号化パスを適用し、プレーンテキストとMACの新しいペアごとに新しい独立した予測不可能なIVを使用すると、セキュリティを示すことができます。 1.1より前のバージョンのTLSでは、CBCモードは、前の暗号文の最後のブロックの形式で予測可能なIVを使用することを除いて、適切に使用されていました。これにより、選択したプレーンテキスト攻撃に対してTLSが開かれました。このバージョンのプロトコルは、これらの攻撃の影響を受けません。安全であることが証明された暗号化モードの詳細については、[ENCAUTH]を参照してください。"
    },
    {
      "indent": 0,
      "text": "F.5. Denial of Service",
      "section_title": true,
      "ja": "F.5. サービス拒否"
    },
    {
      "indent": 3,
      "text": "TLS is susceptible to a number of denial-of-service (DoS) attacks. In particular, an attacker who initiates a large number of TCP connections can cause a server to consume large amounts of CPU for doing RSA decryption. However, because TLS is generally used over TCP, it is difficult for the attacker to hide his point of origin if proper TCP SYN randomization is used [SEQNUM] by the TCP stack.",
      "ja": "TLSは、多くのサービス拒否（DoS）攻撃の影響を受けます。特に、多数のTCP接続を開始する攻撃者は、RSA復号化を実行するためにサーバーに大量のCPUを消費させる可能性があります。ただし、TLSは一般にTCPで使用されるため、TCPスタックで適切なTCP SYNランダム化[SEQNUM]が使用されている場合、攻撃者が攻撃元を隠すのは困難です。"
    },
    {
      "indent": 3,
      "text": "Because TLS runs over TCP, it is also susceptible to a number of DoS attacks on individual connections. In particular, attackers can forge RSTs, thereby terminating connections, or forge partial TLS records, thereby causing the connection to stall. These attacks cannot in general be defended against by a TCP-using protocol. Implementors or users who are concerned with this class of attack should use IPsec AH [AH] or ESP [ESP].",
      "ja": "TLSはTCPを介して実行されるため、個々の接続で多数のDoS攻撃を受けやすくなります。特に、攻撃者はRSTを偽造して接続を終了するか、部分的なTLSレコードを偽造して接続を停止させる可能性があります。これらの攻撃は、一般に、TCPを使用するプロトコルでは防御できません。このクラスの攻撃に関心のある実装者またはユーザーは、IPsec AH [AH]またはESP [ESP]を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "F.6. Final Notes",
      "section_title": true,
      "ja": "F.6. 最終メモ"
    },
    {
      "indent": 3,
      "text": "For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.",
      "ja": "TLSが安全な接続を提供できるようにするには、クライアントとサーバーの両方のシステム、キー、およびアプリケーションが安全である必要があります。さらに、実装にはセキュリティエラーがないことが必要です。"
    },
    {
      "indent": 3,
      "text": "The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.",
      "ja": "このシステムは、サポートされている最も弱い鍵交換および認証アルゴリズムと同じくらい強力であり、信頼できる暗号化機能のみを使用する必要があります。短い公開鍵と匿名サーバーは慎重に使用する必要があります。実装とユーザーは、どの証明書と認証局が許容できるかを決定するときに注意する必要があります。不正な認証局は多大な損害を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用文献"
    },
    {
      "indent": 3,
      "text": "[AES] National Institute of Standards and Technology, \"Specification for the Advanced Encryption Standard (AES)\" FIPS 197. November 26, 2001.",
      "ja": "[AES]米国国立標準技術研究所、「Advanced Encryption Standard（AES）の仕様」FIPS197。2001年11月26日。"
    },
    {
      "indent": 3,
      "text": "[3DES] National Institute of Standards and Technology, \"Recommendation for the Triple Data Encryption Algorithm (TDEA) Block Cipher\", NIST Special Publication 800-67, May 2004.",
      "ja": "[3DES]米国国立標準技術研究所、「トリプルデータ暗号化アルゴリズム（TDEA）ブロック暗号の推奨」、NIST Special Publication 800-67、2004年5月。"
    },
    {
      "indent": 3,
      "text": "[DSS] NIST FIPS PUB 186-2, \"Digital Signature Standard\", National Institute of Standards and Technology, U.S. Department of Commerce, 2000.",
      "ja": "[DSS] NIST FIPS PUB 186-2、「デジタル署名標準」、米国標準技術研究所、米国商務省、2000年。"
    },
    {
      "indent": 3,
      "text": "[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[HMAC] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[MD5] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[MD5] Rivest、R。、「MD5メッセージダイジェストアルゴリズム」、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[PKCS1] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[PKCS1] Jonsson、J。およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA Cryptography Specifications Version 2.1」、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[PKIX] Housley, R., Polk, W., Ford, W., and D. Solo, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3280, April 2002.",
      "ja": "[PKIX] Housley、R.、Polk、W.、Ford、W。、およびD. Solo、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile」、RFC 3280、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[SCH] B. Schneier. \"Applied Cryptography: Protocols, Algorithms, and Source Code in C, 2nd ed.\", Published by John Wiley & Sons, Inc. 1996.",
      "ja": "[SCH] B.シュナイアー。 「Applied Cryptography：Protocols、Algorithms、and Source Code in C、2nd ed。」、John Wiley＆Sons、Inc. 1996年発行。"
    },
    {
      "indent": 3,
      "text": "[SHS] NIST FIPS PUB 180-2, \"Secure Hash Standard\", National Institute of Standards and Technology, U.S. Department of Commerce, August 2002.",
      "ja": "[SHS] NIST FIPS PUB 180-2、「Secure Hash Standard」、米国連邦情報・技術局、米国商務省、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[REQ] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[REQ] Bradner、S。、「RFCで使用して要件レベルを示すためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[X680] ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002, Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation.",
      "ja": "[X680] ITU-T勧告X.680（2002）| ISO / IEC 8824-1：2002、情報技術-抽象構文記法1（ASN.1）：基本記法の仕様。"
    },
    {
      "indent": 3,
      "text": "[X690] ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002, Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER).",
      "ja": "[X690] ITU-T勧告X.690（2002）| ISO / IEC 8825-1：2002、情報技術-ASN.1エンコーディングルール：Basic Encoding Rules（BER）、Canonical Encoding Rules（CER）およびDistinguished Encoding Rules（DER）の仕様。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考引用"
    },
    {
      "indent": 3,
      "text": "[AEAD] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, January 2008.",
      "ja": "[AEAD] McGrew、D。、「認証された暗号化のためのインターフェイスとアルゴリズム」、RFC 5116、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[AH] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.",
      "ja": "[AH]ケント、S。、「IP認証ヘッダー」、RFC 4302、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[BLEI] Bleichenbacher D., \"Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1\" in Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462, pages: 1-12, 1998.",
      "ja": "[BLEI] Bleichenbacher D。、「Advance in Cryptology-CRYPTO'98、LNCS vol。のRSA暗号化標準PKCS＃1に基づくプロトコルに対する選択された暗号文攻撃」 1462、ページ：1-12、1998。"
    },
    {
      "indent": 3,
      "text": "[CBCATT] Moeller, B., \"Security of CBC Ciphersuites in SSL/TLS: Problems and Countermeasures\", http://www.openssl.org/~bodo/tls-cbc.txt.",
      "ja": "[CBCATT] Moeller、B。、「SSL / TLSにおけるCBC暗号スイートのセキュリティ：問題と対策」、http：//www.openssl.org/~bodo/tls-cbc.txt。"
    },
    {
      "indent": 3,
      "text": "[CBCTIME] Canvel, B., Hiltgen, A., Vaudenay, S., and M. Vuagnoux, \"Password Interception in a SSL/TLS Channel\", Advances in Cryptology -- CRYPTO 2003, LNCS vol. 2729, 2003.",
      "ja": "[CBCTIME] Canvel、B.、Hiltgen、A.、Vaudenay、S。、およびM. Vuagnoux、「SSL / TLSチャネルでのパスワード傍受」、Cryptologyの進歩-CRYPTO 2003、LNCS vol。 2729、2003。"
    },
    {
      "indent": 3,
      "text": "[CCM]      \"NIST Special Publication 800-38C: The CCM Mode for\n           Authentication and Confidentiality\",\n           http://csrc.nist.gov/publications/nistpubs/800-38C/\n           SP800-38C.pdf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DES] National Institute of Standards and Technology, \"Data Encryption Standard (DES)\", FIPS PUB 46-3, October 1999.",
      "ja": "[DES]米国国立標準技術研究所、「Data Encryption Standard（DES）」、FIPS PUB 46-3、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[DSS-3] NIST FIPS PUB 186-3 Draft, \"Digital Signature Standard\", National Institute of Standards and Technology, U.S. Department of Commerce, 2006.",
      "ja": "[DSS-3] NIST FIPS PUB 186-3ドラフト、「デジタル署名標準」、米国連邦情報・技術研究所、米国商務省、2006年。"
    },
    {
      "indent": 3,
      "text": "[ECDSA] American National Standards Institute, \"Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)\", ANS X9.62-2005, November 2005.",
      "ja": "[ECDSA] American National Standards Institute、「金融サービス業界の公開鍵暗号化：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANS X9.62-2005、2005年11月。"
    },
    {
      "indent": 3,
      "text": "[ENCAUTH] Krawczyk, H., \"The Order of Encryption and Authentication for Protecting Communications (Or: How Secure is SSL?)\", Crypto 2001.",
      "ja": "[ENCAUTH] Krawczyk、H。、「通信を保護するための暗号化と認証の順序（または、SSLの安全性は？）」、Crypto 2001。"
    },
    {
      "indent": 3,
      "text": "[ESP] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[ESP]ケントS。、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[FI06] Hal Finney, \"Bleichenbacher's RSA signature forgery based on implementation error\", ietf-openpgp@imc.org mailing list, 27 August 2006, http://www.imc.org/ietf-openpgp/ mail-archive/msg14307.html.",
      "ja": "[FI06] Hal Finney、「実装エラーに基づくブライチェンバッハーのRSA署名偽造」、ietf-openpgp @ imc.orgメーリングリスト、2006年8月27日、http：//www.imc.org/ietf-openpgp/ mail-archive / msg14307 .html。"
    },
    {
      "indent": 3,
      "text": "[GCM] Dworkin, M., NIST Special Publication 800-38D, \"Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC\", November 2007.",
      "ja": "[GCM] Dworkin、M.、NIST Special Publication 800-38D、「Recommendation for Block Cipher Modes of Operation：Galois / Counter Mode（GCM）and GMAC」、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[IKEALG] Schiller, J., \"Cryptographic Algorithms for Use in the Internet Key Exchange Version 2 (IKEv2)\", RFC 4307, December 2005.",
      "ja": "[IKEALG] Schiller、J.、「インターネットキーエクスチェンジバージョン2（IKEv2）で使用する暗号化アルゴリズム」、RFC 4307、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[KEYSIZ] Orman, H. and P. Hoffman, \"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys\", BCP 86, RFC 3766, April 2004.",
      "ja": "[KEYSIZ]オーマン、H。、およびP.ホフマン、「対称鍵の交換に使用される公開鍵の強度の決定」、BCP 86、RFC 3766、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[KPR03] Klima, V., Pokorny, O., Rosa, T., \"Attacking RSA-based Sessions in SSL/TLS\", http://eprint.iacr.org/2003/052/, March 2003.",
      "ja": "[KPR03] Klima、V.、Pokorny、O.、Rosa、T。、「SSL / TLSでのRSAベースのセッションへの攻撃」、http：//eprint.iacr.org/2003/052/、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[MODP] Kivinen, T. and M. Kojo, \"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)\", RFC 3526, May 2003.",
      "ja": "[MODP] Kivinen、T。、およびM. Kojo、「インターネット鍵交換（IKE）のためのより多くのモジュラー指数（MODP）Diffie-Hellmanグループ」、RFC 3526、2003年5月。"
    },
    {
      "indent": 3,
      "text": "[PKCS6] RSA Laboratories, \"PKCS #6: RSA Extended Certificate Syntax Standard\", version 1.5, November 1993.",
      "ja": "[PKCS6] RSA Laboratories、「PKCS＃6：RSA Extended Certificate Syntax Standard」、バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[PKCS7] RSA Laboratories, \"PKCS #7: RSA Cryptographic Message Syntax Standard\", version 1.5, November 1993.",
      "ja": "[PKCS7] RSA Laboratories、「PKCS＃7：RSA Cryptographic Message Syntax Standard」、バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[RANDOM] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[ランダム] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3749] Hollenbeck, S., \"Transport Layer Security Protocol Compression Methods\", RFC 3749, May 2004.",
      "ja": "[RFC3749] Hollenbeck、S。、「Transport Layer Security Protocol Compression Methods」、RFC 3749、2004年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4366] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 4366, April 2006.",
      "ja": "[RFC4366] Blake-Wilson、S.、Nystrom、M.、Hopwood、D.、Mikkelsen、J。、およびT. Wright、「Transport Layer Security（TLS）Extensions」、RFC 4366、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[RSA] R. Rivest, A. Shamir, and L. M. Adleman, \"A Method for Obtaining Digital Signatures and Public-Key Cryptosystems\", Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120-126.",
      "ja": "[RSA] R.リベスト、A。シャミール、およびL. M.アドルマン、「デジタル署名と公開鍵暗号システムを取得する方法」、ACMの通信、v。21、n。 1978年2月2日、120-126ページ。"
    },
    {
      "indent": 3,
      "text": "[SEQNUM] Bellovin, S., \"Defending Against Sequence Number Attacks\", RFC 1948, May 1996.",
      "ja": "[SEQNUM] Bellovin、S.、「シーケンス番号攻撃に対する防御」、RFC 1948、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[SSL2] Hickman, Kipp, \"The SSL Protocol\", Netscape Communications Corp., Feb 9, 1995.",
      "ja": "[SSL2] Hickman、Kipp、「The SSL Protocol」、Netscape Communications Corp.、1995年2月9日。"
    },
    {
      "indent": 3,
      "text": "[SSL3] A. Freier, P. Karlton, and P. Kocher, \"The SSL 3.0 Protocol\", Netscape Communications Corp., Nov 18, 1996.",
      "ja": "[SSL3] A. Freier、P。Karlton、およびP. Kocher、「The SSL 3.0 Protocol」、Netscape Communications Corp.、1996年11月18日。"
    },
    {
      "indent": 3,
      "text": "[SUBGROUP] Zuccherato, R., \"Methods for Avoiding the \"Small-Subgroup\" Attacks on the Diffie-Hellman Key Agreement Method for S/MIME\", RFC 2785, March 2000.",
      "ja": "[サブグループ] Zuccherato、R。、「S / MIMEのDiffie-Hellman鍵合意方法に対する「小サブグループ」攻撃を回避する方法」、RFC 2785、2000年3月。"
    },
    {
      "indent": 3,
      "text": "[TCP] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[TCP] Postel、J。、「Transmission Control Protocol」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[TIMING] Boneh, D., Brumley, D., \"Remote timing attacks are practical\", USENIX Security Symposium 2003.",
      "ja": "[タイミング] Boneh、D.、Brumley、D。、「リモートタイミング攻撃は実用的」、USENIXセキュリティシンポジウム2003。"
    },
    {
      "indent": 3,
      "text": "[TLSAES] Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)\", RFC 3268, June 2002.",
      "ja": "[TLSAES] Chown、P。、「Advanced Encryption Standard（AES）Ciphersuites for Transport Layer Security（TLS）」、RFC 3268、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[TLSECC] Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, \"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)\", RFC 4492, May 2006.",
      "ja": "[TLSECC] Blake-Wilson、S.、Bolyard、N.、Gupta、V.、Hawk、C。、およびB. Moeller、「Elliptic Curve Cryptography（ECC）Cipher Suites for Transport Layer Security（TLS）」、RFC 4492 、2006年5月。"
    },
    {
      "indent": 3,
      "text": "[TLSEXT] Eastlake, D., 3rd, \"Transport Layer Security (TLS) Extensions: Extension Definitions\", Work in Progress, February 2008.",
      "ja": "[TLSEXT] Eastlake、D.、3番目、「Transport Layer Security（TLS）Extensions：Extension Definitions」、Work in Progress、2008年2月。"
    },
    {
      "indent": 3,
      "text": "[TLSPGP] Mavrogiannopoulos, N., \"Using OpenPGP Keys for Transport Layer Security (TLS) Authentication\", RFC 5081, November 2007.",
      "ja": "[TLSPGP] Mavrogiannopoulos、N。、「トランスポート層セキュリティ（TLS）認証のためのOpenPGPキーの使用」、RFC 5081、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[TLSPSK] Eronen, P., Ed., and H. Tschofenig, Ed., \"Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)\", RFC 4279, December 2005.",
      "ja": "[TLSPSK] Eronen、P.、Ed。およびH. Tschofenig、Ed。、 \"Pre-Shared Key Ciphersuites for Transport Layer Security（TLS）\"、RFC 4279、December 2005。"
    },
    {
      "indent": 3,
      "text": "[TLS1.0] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[TLS1.0] Dierks、T。およびC. Allen、「The TLS Protocol Version 1.0」、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[TLS1.1] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.1\", RFC 4346, April 2006.",
      "ja": "[TLS1.1] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.1」、RFC 4346、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[X501] ITU-T Recommendation X.501: Information Technology - Open Systems Interconnection - The Directory: Models, 1993.",
      "ja": "[X501] ITU-T勧告X.501：情報技術-オープンシステム相互接続-ディレクトリ：モデル、1993。"
    },
    {
      "indent": 3,
      "text": "[XDR] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, May 2006.",
      "ja": "[XDR] Eisler、M。、編、「XDR：外部データ表現標準」、STD 67、RFC 4506、2006年5月。"
    },
    {
      "indent": 0,
      "text": "Working Group Information",
      "ja": "ワーキンググループ情報"
    },
    {
      "indent": 3,
      "text": "The discussion list for the IETF TLS working group is located at the\ne-mail address <tls@ietf.org>. Information on the group and\ninformation on how to subscribe to the list is at\n<https://www1.ietf.org/mailman/listinfo/tls>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Archives of the list can be found at:\n<http://www.ietf.org/mail-archive/web/tls/current/index.html>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "Christopher Allen (co-editor of TLS 1.0) Alacrity Ventures ChristopherA@AlacrityManagement.com",
      "ja": "Christopher Allen（TLS 1.0の共同編集者）Alacrity Ventures ChristopherA@AlacrityManagement.com"
    },
    {
      "indent": 3,
      "text": "Martin Abadi University of California, Santa Cruz abadi@cs.ucsc.edu",
      "ja": "カリフォルニア州マーティンアバディ大学、サンタクルーズabadi@cs.ucsc.edu"
    },
    {
      "indent": 3,
      "text": "Steven M. Bellovin Columbia University smb@cs.columbia.edu",
      "ja": "スティーブンM.ベロビンコロンビア大学smb@cs.columbia.edu"
    },
    {
      "indent": 3,
      "text": "Simon Blake-Wilson BCI sblakewilson@bcisse.com Ran Canetti IBM canetti@watson.ibm.com",
      "ja": "Simon Blake-Wilson BCI sblakewilson@bcisse.com Ran Canetti IBM canetti@watson.ibm.com"
    },
    {
      "indent": 3,
      "text": "Pete Chown Skygate Technology Ltd pc@skygate.co.uk",
      "ja": "ピートチョウスカイゲートテクノロジー株式会社pc@skygate.co.uk"
    },
    {
      "indent": 3,
      "text": "Taher Elgamal taher@securify.com Securify",
      "ja": "Taher Elgamal taher@s​​ecurify.com Securify"
    },
    {
      "indent": 3,
      "text": "Pasi Eronen pasi.eronen@nokia.com Nokia",
      "ja": "Pasi Eronen pasi.eronen@nokia.comノキア"
    },
    {
      "indent": 3,
      "text": "Anil Gangolli anil@busybuddha.org",
      "ja": "Anil Gangolli Anil@businessbuddha.org"
    },
    {
      "indent": 3,
      "text": "Kipp Hickman",
      "ja": "キップ・ヒックマン"
    },
    {
      "indent": 3,
      "text": "Alfred Hoenes",
      "ja": "アルフレッド・ホーネス"
    },
    {
      "indent": 3,
      "text": "David Hopwood Independent Consultant david.hopwood@blueyonder.co.uk",
      "ja": "デビッドホップウッド独立コンサルタントdavid.hopwood@blueyonder.co.uk"
    },
    {
      "indent": 3,
      "text": "Phil Karlton (co-author of SSLv3)",
      "ja": "Phil Karlton（SSLv3の共著者）"
    },
    {
      "indent": 3,
      "text": "Paul Kocher (co-author of SSLv3) Cryptography Research paul@cryptography.com",
      "ja": "Paul Kocher（SSLv3の共著者）Cryptography Research paul@cryptography.com"
    },
    {
      "indent": 3,
      "text": "Hugo Krawczyk IBM hugo@ee.technion.ac.il",
      "ja": "Hugo Krawczyk IBM hugo@ee.technion.ac.il"
    },
    {
      "indent": 3,
      "text": "Jan Mikkelsen Transactionware janm@transactionware.com",
      "ja": "Jan Mikkelsenトランザクションウェアjanm@transactionware.com"
    },
    {
      "indent": 3,
      "text": "Magnus Nystrom RSA Security magnus@rsasecurity.com",
      "ja": "Magnus Nystrom RSAセキュリティmagnus@rsasecurity.com"
    },
    {
      "indent": 3,
      "text": "Robert Relyea Netscape Communications relyea@netscape.com Jim Roskind Netscape Communications jar@netscape.com",
      "ja": "Robert Relyea Netscape Communications relyea@netscape.com Jim Roskind Netscape Communications jar@netscape.com"
    },
    {
      "indent": 3,
      "text": "Michael Sabin",
      "ja": "マイケル・サビン"
    },
    {
      "indent": 3,
      "text": "Dan Simon Microsoft, Inc. dansimon@microsoft.com",
      "ja": "Dan Simon Microsoft、Inc.、ただしSimon@Microsoft.com"
    },
    {
      "indent": 3,
      "text": "Tom Weinstein",
      "ja": "トム・ワインスタイン"
    },
    {
      "indent": 3,
      "text": "Tim Wright Vodafone timothy.wright@vodafone.com",
      "ja": "ティムライトボーダフォンtimothy.wright@vodafone.com"
    },
    {
      "indent": 0,
      "text": "Editors' Addresses",
      "ja": "編集者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tim Dierks Independent EMail: tim@dierks.org",
      "ja": "Tim Dierks独立メール：tim@dierks.org"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc. EMail: ekr@rtfm.com",
      "ja": "Eric Rescorla RTFM、Inc.メール：ekr@rtfm.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2008).",
      "ja": "Copyright（C）IETF Trust（2008）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントおよびここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代表者、または（もしあれば）組織、インターネット社会、IETFトラストおよびインターネットエンジニアリングタスクフォースはすべてを否認します。明示または黙示を問わず、ここに記載されている情報の使用が商品性または特定の目的への適合性に関するいかなる権利または黙示の保証を侵害しないことを保証するものではありません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません。利用できる;また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、または一般ライセンスを取得しようとした試み、またはこの仕様の実装者またはユーザーがそのような所有権を使用するための許可を取得した結果を取得できます。 http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。"
    }
  ]
}