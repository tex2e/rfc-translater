{
  "title": {
    "text": "RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF)",
    "ja": "RFC 5869 - HMACベースの抽出および展開鍵導出関数（HKDF）"
  },
  "number": 5869,
  "created_at": "2022-12-24 16:19:50.628405+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       H. Krawczyk\nRequest for Comments: 5869                                  IBM Research\nCategory: Informational                                        P. Eronen\nISSN: 2070-1721                                                    Nokia\n                                                                May 2010",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "HMAC-based Extract-and-Expand Key Derivation Function (HKDF)",
      "ja": "HMACベースの抽出および展開鍵導出関数（HKDF）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications. The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions.",
      "ja": "このドキュメントは、さまざまなプロトコルとアプリケーションのビルディングブロックとして使用できる、単純なハッシュメッセージ認証コード（HMAC）ベースの鍵導出関数（HKDF）を指定します。鍵導出関数（KDF）は、幅広いアプリケーションと要件をサポートすることを目的としており、暗号学的ハッシュ関数の使用において保守的です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準化過程の仕様ではありません。情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の成果物です。IETFコミュニティの合意を表しています。公開レビューを受けており、Internet Engineering Steering Group（IESG）からの出版が承認されています。IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補ではありません。RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5869.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http://www.rfc-editor.org/info/rfc5869 で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2010 IETF Trustおよび文書の著者として特定された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定（本書の発行日に有効なもの）の対象となります。この文書に関するあなたの権利と制限を説明しているので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストを含まなければならず、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A key derivation function (KDF) is a basic and essential component of cryptographic systems. Its goal is to take some source of initial keying material and derive from it one or more cryptographically strong secret keys.",
      "ja": "鍵導出関数（KDF）は、暗号システムの基本的かつ必須のコンポーネントです。その目標は、初期キーイングマテリアルのソースを取り、そこから1つ以上の暗号学的に強力な秘密鍵を導出することです。"
    },
    {
      "indent": 3,
      "text": "This document specifies a simple HMAC-based [HMAC] KDF, named HKDF, which can be used as a building block in various protocols and applications, and is already used in several IETF protocols, including [IKEv2], [PANA], and [EAP-AKA]. The purpose is to document this KDF in a general way to facilitate adoption in future protocols and applications, and to discourage the proliferation of multiple KDF mechanisms. It is not intended as a call to change existing protocols and does not change or update existing specifications using this KDF.",
      "ja": "このドキュメントは、さまざまなプロトコルおよびアプリケーションでビルディングブロックとして使用できるHKDFという名前の単純なHMACベースの[HMAC] KDFを指定します。これはすでに[IKEv2]、[PANA]、[EAP-AKA]を含むいくつかのIETFプロトコルで使用されています。目的は、このKDFを一般的な方法で文書化し、将来のプロトコルとアプリケーションでの採用を促進し、複数のKDFメカニズムの乱立を抑制することです。既存のプロトコルを変更することを意図したものではなく、このKDFを使用している既存の仕様を変更または更新するものでもありません。"
    },
    {
      "indent": 3,
      "text": "HKDF follows the \"extract-then-expand\" paradigm, where the KDF logically consists of two modules. The first stage takes the input keying material and \"extracts\" from it a fixed-length pseudorandom key K. The second stage \"expands\" the key K into several additional pseudorandom keys (the output of the KDF).",
      "ja": "HKDFは、「抽出・展開（extract-then-expand）」パラダイムに従います。ここで、KDFは論理的に2つのモジュールで構成されています。最初の段階では、入力キーイングマテリアルを取り、そこから固定長の擬似ランダム鍵Kを「抽出」します。第2段階では、鍵Kをいくつかの追加の擬似ランダム鍵（KDFの出力）に「展開」します。"
    },
    {
      "indent": 3,
      "text": "In many applications, the input keying material is not necessarily distributed uniformly, and the attacker may have some partial knowledge about it (for example, a Diffie-Hellman value computed by a key exchange protocol) or even partial control of it (as in some entropy-gathering applications). Thus, the goal of the \"extract\" stage is to \"concentrate\" the possibly dispersed entropy of the input keying material into a short, but cryptographically strong, pseudorandom key. In some applications, the input may already be a good pseudorandom key; in these cases, the \"extract\" stage is not necessary, and the \"expand\" part can be used alone.",
      "ja": "多くのアプリケーションでは、入力キーイングマテリアルが必ずしも均一に分布しているわけではなく、攻撃者はそれについての部分的な知識（たとえば、鍵交換プロトコルによって計算されたDiffie-Hellman値）またはそれに対する部分的な制御（一部のエントロピー収集アプリケーションのように）を持っている可能性があります。したがって、「抽出」段階の目標は、入力キーイングマテリアルの分散している可能性のあるエントロピーを、短いが暗号学的に強力な擬似ランダム鍵に「凝縮」することです。一部のアプリケーションでは、入力はすでに良好な擬似ランダム鍵である可能性があります。これらの場合、「抽出」段階は必要なく、「展開」部分を単独で使用できます。"
    },
    {
      "indent": 3,
      "text": "The second stage \"expands\" the pseudorandom key to the desired length; the number and lengths of the output keys depend on the specific cryptographic algorithms for which the keys are needed.",
      "ja": "第2段階は、擬似ランダム鍵を目的の長さに「展開」します。出力鍵の数と長さは、鍵が必要な特定の暗号アルゴリズムに依存します。"
    },
    {
      "indent": 3,
      "text": "Note that some existing KDF specifications, such as NIST Special Publication 800-56A [800-56A], NIST Special Publication 800-108 [800-108] and IEEE Standard 1363a-2004 [1363a], either only consider the second stage (expanding a pseudorandom key), or do not explicitly differentiate between the \"extract\" and \"expand\" stages, often resulting in design shortcomings. The goal of this specification is to accommodate a wide range of KDF requirements while minimizing the assumptions about the underlying hash function. The \"extract-then-expand\" paradigm supports well this goal (see [HKDF-paper] for more information about the design rationale).",
      "ja": "NIST Special Publication 800-56A [800-56A]、NIST Special Publication 800-108 [800-108]、IEEE Standard 1363a-2004 [1363a]などの既存のKDF仕様の一部は、第2段階（擬似ランダム鍵の展開）のみを考慮しているか、または「抽出」と「展開」の段階を明示的に区別しておらず、その結果、設計上の欠点が生じることがよくあることに注意してください。この仕様の目標は、基礎となるハッシュ関数に関する仮定を最小限に抑えながら、幅広いKDF要件に対応することです。「抽出・展開」パラダイムはこの目標をよくサポートしています（設計の理論的根拠の詳細については[HKDF-paper]を参照）。"
    },
    {
      "indent": 0,
      "text": "2. HMAC-based Key Derivation Function (HKDF)",
      "section_title": true,
      "ja": "2. HMACベースの鍵導出関数（HKDF）"
    },
    {
      "indent": 0,
      "text": "2.1. Notation",
      "section_title": true,
      "ja": "2.1. 表記"
    },
    {
      "indent": 3,
      "text": "HMAC-Hash denotes the HMAC function [HMAC] instantiated with hash function 'Hash'. HMAC always has two arguments: the first is a key and the second an input (or message). (Note that in the extract step, 'IKM' is used as the HMAC input, not as the HMAC key.)",
      "ja": "HMAC-Hashは、ハッシュ関数 'Hash' でインスタンス化されたHMAC関数[HMAC]を示します。HMACには常に2つの引数があります。1つ目は鍵、2つ目は入力（またはメッセージ）です。（抽出ステップでは、「IKM」はHMAC鍵としてではなく、HMAC入力として使用されることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "When the message is composed of several elements we use concatenation (denoted |) in the second argument; for example, HMAC(K, elem1 | elem2 | elem3).",
      "ja": "メッセージがいくつかの要素で構成されている場合、2番目の引数で連結（|で表記）を使用します。たとえば、HMAC(K, elem1 | elem2 | elem3)。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [KEYWORDS].",
      "ja": "本書のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、[KEYWORDS]で説明されているように解釈されるものとします。"
    },
    {
      "indent": 0,
      "text": "2.2. Step 1: Extract",
      "section_title": true,
      "ja": "2.2. ステップ1：抽出"
    },
    {
      "indent": 3,
      "text": "HKDF-Extract(salt, IKM) -> PRK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Options: Hash a hash function; HashLen denotes the length of the hash function output in octets",
      "ja": "オプション：Hash ハッシュ関数。HashLen はオクテット単位のハッシュ関数出力の長さを示します。"
    },
    {
      "indent": 3,
      "text": "Inputs: salt optional salt value (a non-secret random value); if not provided, it is set to a string of HashLen zeros. IKM input keying material",
      "ja": "入力：salt オプションのソルト値（非秘密のランダム値）。提供されない場合は、HashLen個のゼロの文字列に設定されます。IKM 入力キーイングマテリアル"
    },
    {
      "indent": 3,
      "text": "Output: PRK a pseudorandom key (of HashLen octets)",
      "ja": "出力：PRK 擬似ランダム鍵（HashLenオクテット）"
    },
    {
      "indent": 3,
      "text": "The output PRK is calculated as follows:",
      "ja": "出力PRKは次のように計算されます。"
    },
    {
      "indent": 3,
      "text": "PRK = HMAC-Hash(salt, IKM)",
      "ja": "PRK = HMAC-Hash(salt, IKM)"
    },
    {
      "indent": 0,
      "text": "2.3. Step 2: Expand",
      "section_title": true,
      "ja": "2.3. ステップ2：展開"
    },
    {
      "indent": 3,
      "text": "HKDF-Expand(PRK, info, L) -> OKM",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Options: Hash a hash function; HashLen denotes the length of the hash function output in octets",
      "ja": "オプション：Hash ハッシュ関数。HashLen はオクテット単位のハッシュ関数出力の長さを示します。"
    },
    {
      "indent": 3,
      "text": "Inputs: PRK a pseudorandom key of at least HashLen octets (usually, the output from the extract step) info optional context and application specific information (can be a zero-length string) L length of output keying material in octets (<= 255*HashLen)",
      "ja": "入力：PRK 少なくともHashLenオクテットの擬似ランダム鍵（通常、抽出ステップからの出力）。info オプションのコンテキストおよびアプリケーション固有情報（長さゼロの文字列も可）。L オクテット単位の出力キーイングマテリアルの長さ（<= 255*HashLen）。"
    },
    {
      "indent": 3,
      "text": "Output: OKM output keying material (of L octets)",
      "ja": "出力：OKM 出力キーイングマテリアル（Lオクテット）"
    },
    {
      "indent": 3,
      "text": "The output OKM is calculated as follows:",
      "ja": "出力OKMは次のように計算されます。"
    },
    {
      "indent": 3,
      "text": "N = ceil(L/HashLen)\nT = T(1) | T(2) | T(3) | ... | T(N)\nOKM = first L octets of T",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where:\nT(0) = empty string (zero length)\nT(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\nT(2) = HMAC-Hash(PRK, T(1) | info | 0x02)\nT(3) = HMAC-Hash(PRK, T(2) | info | 0x03)\n...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(where the constant concatenated to the end of each T(n) is a single octet.)",
      "ja": "（ここで、各T(n)の末尾に連結される定数は単一のオクテットです。）"
    },
    {
      "indent": 0,
      "text": "3. Notes to HKDF Users",
      "section_title": true,
      "ja": "3. HKDFユーザーへのメモ"
    },
    {
      "indent": 3,
      "text": "This section contains a set of guiding principles regarding the use of HKDF. A much more extensive account of such principles and design rationale can be found in [HKDF-paper].",
      "ja": "このセクションには、HKDFの使用に関する一連のガイド原則が含まれています。このような原則と設計の理論的根拠のはるかに広範な説明は、[HKDF-Paper]にあります。"
    },
    {
      "indent": 0,
      "text": "3.1. To Salt or not to Salt",
      "section_title": true,
      "ja": "3.1. ソルトを使用するか否か"
    },
    {
      "indent": 3,
      "text": "HKDF is defined to operate with and without random salt. This is done to accommodate applications where a salt value is not available. We stress, however, that the use of salt adds significantly to the strength of HKDF, ensuring independence between different uses of the hash function, supporting \"source-independent\" extraction, and strengthening the analytical results that back the HKDF design.",
      "ja": "HKDFは、ランダムソルトの有無にかかわらず動作するように定義されています。これは、ソルト値が利用できないアプリケーションに対応するために行われます。しかし、ソルトの使用はHKDFの強度を大きく増加させ、ハッシュ関数の異なる使用間の独立性を確保し、「ソースに依存しない」抽出をサポートし、HKDF設計を裏付ける分析結果を強化することを強調します。"
    },
    {
      "indent": 3,
      "text": "Random salt differs fundamentally from the initial keying material in two ways: it is non-secret and can be re-used. As such, salt values are available to many applications. For example, a pseudorandom number generator (PRNG) that continuously produces outputs by applying HKDF to renewable pools of entropy (e.g., sampled system events) can fix a salt value and use it for multiple applications of HKDF without having to protect the secrecy of the salt. In a different application domain, a key agreement protocol deriving cryptographic keys from a Diffie-Hellman exchange can derive a salt value from public nonces exchanged and authenticated between communicating parties as part of the key agreement (this is the approach taken in [IKEv2]).",
      "ja": "ランダムソルトは、2つの点で初期キーイングマテリアルと根本的に異なります。それは非秘密であり、再利用することができます。そのため、多くのアプリケーションでソルト値を利用できます。たとえば、HKDFをエントロピーの再生可能プール（サンプリングされたシステムイベントなど）に適用することにより出力を継続的に生成する擬似乱数生成器（PRNG）は、ソルト値を固定し、ソルトの機密性を保護することなくHKDFの複数のアプリケーションに使用できます。別のアプリケーションドメインでは、Diffie-Hellman交換から暗号鍵を導出する鍵合意プロトコルは、鍵合意の一部として通信当事者間で交換および認証された公開ノンスからソルト値を導出できます（これは[IKEv2]で採用されているアプローチです）。"
    },
    {
      "indent": 3,
      "text": "Ideally, the salt value is a random (or pseudorandom) string of the length HashLen. Yet, even a salt value of less quality (shorter in size or with limited entropy) may still make a significant contribution to the security of the output keying material; designers of applications are therefore encouraged to provide salt values to HKDF if such values can be obtained by the application.",
      "ja": "理想的には、ソルト値は長さHashLenのランダムな（または擬似ランダム）文字列です。しかし、品質が低い（サイズが短い、またはエントロピーが限られている）ソルト値でさえ、出力キーイングマテリアルのセキュリティに大きく貢献する可能性があります。したがって、アプリケーションによってそのような値を取得できる場合、アプリケーションの設計者はHKDFにソルト値を提供することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that, while not the typical case, some applications may even have a secret salt value available for use; in such a case, HKDF provides an even stronger security guarantee. An example of such application is IKEv1 in its \"public-key encryption mode\", where the \"salt\" to the extractor is computed from nonces that are secret; similarly, the pre-shared mode of IKEv1 uses a secret salt derived from the pre-shared key.",
      "ja": "典型的なケースではありませんが、一部のアプリケーションには使用可能な秘密のソルト値があることさえあります。そのような場合、HKDFはさらに強力なセキュリティ保証を提供します。このようなアプリケーションの例は、「公開鍵暗号モード」のIKEv1です。ここで、抽出器への「ソルト」は秘密のノンスから計算されます。同様に、IKEv1の事前共有モードは、事前共有鍵から派生した秘密のソルトを使用します。"
    },
    {
      "indent": 0,
      "text": "3.2. The 'info' Input to HKDF",
      "section_title": true,
      "ja": "3.2. HKDFへの「情報」入力"
    },
    {
      "indent": 3,
      "text": "While the 'info' value is optional in the definition of HKDF, it is often of great importance in applications. Its main objective is to bind the derived key material to application- and context-specific information. For example, 'info' may contain a protocol number, algorithm identifiers, user identities, etc. In particular, it may prevent the derivation of the same keying material for different contexts (when the same input key material (IKM) is used in such different contexts). It may also accommodate additional inputs to the key expansion part, if so desired (e.g., an application may want to bind the key material to its length L, thus making L part of the 'info' field). There is one technical requirement from 'info': it should be independent of the input key material value IKM.",
      "ja": "「info」値はHKDFの定義ではオプションですが、アプリケーションでは非常に重要なことがよくあります。その主な目的は、導出された鍵材料をアプリケーションおよびコンテキスト固有の情報に結合することです。たとえば、「info」には、プロトコル番号、アルゴリズム識別子、ユーザーIDなどが含まれる場合があります。特に、異なるコンテキストで同じキーイングマテリアルが導出されるのを防ぐことができます（同じ入力キーマテリアル（IKM）がそのような異なるコンテキストで使用される場合）。また、必要に応じて、鍵展開部分への追加の入力に対応することもできます（たとえば、アプリケーションは、鍵材料をその長さLにバインドするため、Lを「info」フィールドの一部にすることができます）。「info」には1つの技術的要件があります。入力キーマテリアル値IKMとは独立している必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. To Skip or not to Skip",
      "section_title": true,
      "ja": "3.3. スキップするか否か"
    },
    {
      "indent": 3,
      "text": "In some applications, the input key material IKM may already be present as a cryptographically strong key (for example, the premaster secret in TLS RSA cipher suites would be a pseudorandom string, except for the first two octets). In this case, one can skip the extract part and use IKM directly to key HMAC in the expand step. On the other hand, applications may still use the extract part for the sake of compatibility with the general case. In particular, if IKM is random (or pseudorandom) but longer than an HMAC key, the extract step can serve to output a suitable HMAC key (in the case of HMAC this shortening via the extractor is not strictly necessary since HMAC is defined to work with long keys too). Note, however, that if the IKM is a Diffie-Hellman value, as in the case of TLS with Diffie-Hellman, then the extract part SHOULD NOT be skipped. Doing so would result in using the Diffie-Hellman value g^{xy} itself (which is NOT a uniformly random or pseudorandom string) as the key PRK for HMAC. Instead, HKDF should apply the extract step to g^{xy} (preferably with a salt value) and use the resultant PRK as a key to HMAC in the expansion part.",
      "ja": "一部のアプリケーションでは、入力キーマテリアルIKMがすでに暗号学的に強力な鍵として存在している場合があります（たとえば、TLS RSA暗号スイートのプリマスターシークレットは、最初の2オクテットを除いて擬似ランダム文字列になります）。この場合、抽出部分をスキップし、展開ステップでHMACの鍵としてIKMを直接使用できます。一方、アプリケーションは、一般的なケースとの互換性のために、引き続き抽出部分を使用する場合があります。特に、IKMがランダム（または擬似ランダム）であるがHMAC鍵よりも長い場合、抽出ステップは適切なHMAC鍵を出力するのに役立ちます（HMACの場合、HMACは長い鍵でも動作するように定義されているため、抽出器によるこの短縮は厳密には必要ありません）。ただし、Diffie-Hellmanを使用したTLSの場合のように、IKMがDiffie-Hellman値である場合、抽出部分をスキップすべきではありません（SHOULD NOT）。そうすることで、Diffie-Hellman値 g^{xy} 自体（均一にランダムまたは擬似ランダム文字列ではありません）をHMACの鍵PRKとして使用することになります。代わりに、HKDFは抽出ステップを g^{xy} に適用し（できればソルト値を使用して）、得られたPRKを展開部分のHMACの鍵として使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the case where the amount of required key bits, L, is no more than HashLen, one could use PRK directly as the OKM. This, however, is NOT RECOMMENDED, especially because it would omit the use of 'info' as part of the derivation process (and adding 'info' as an input to the extract step is not advisable -- see [HKDF-paper]).",
      "ja": "必要な鍵ビットの量LがHashLen以下の場合、PRKをOKMとして直接使用できます。ただし、これは推奨されません（NOT RECOMMENDED）。特に、導出プロセスの一部として「info」の使用を省略するためです（また、抽出ステップへの入力として「info」を追加することはお勧めできません。[HKDF-paper]を参照）。"
    },
    {
      "indent": 0,
      "text": "3.4. The Role of Independence",
      "section_title": true,
      "ja": "3.4. 独立性の役割"
    },
    {
      "indent": 3,
      "text": "The analysis of key derivation functions assumes that the input keying material (IKM) comes from some source modeled as a probability distribution over bit streams of a certain length (e.g., streams produced by an entropy pool, values derived from Diffie-Hellman exponents chosen at random, etc.); each instance of IKM is a sample from that distribution. A major goal of key derivation functions is to ensure that, when applying the KDF to any two values IKM and IKM' sampled from the (same) source distribution, the resultant keys OKM and OKM' are essentially independent of each other (in a statistical or computational sense). To achieve this goal, it is important that inputs to KDF are selected from appropriate input distributions and also that inputs are chosen independently of each other (technically, it is necessary that each sample will have sufficient entropy, even when conditioned on other inputs to KDF).",
      "ja": "鍵導出関数の分析は、入力キーイングマテリアル（IKM）が特定の長さのビットストリーム上の確率分布としてモデル化された何らかのソース（例えば、エントロピープールによって生成されるストリーム、ランダムに選択されたDiffie-Hellman指数から派生した値など）から得られると想定しています。IKMの各インスタンスは、その分布のサンプルです。鍵導出関数の主要な目標は、（同じ）ソース分布からサンプリングされた任意の2つの値IKMとIKM'にKDFを適用するとき、結果の鍵OKMとOKM'が（統計的または計算的な意味で）本質的に互いに独立していることを保証することです。この目標を達成するには、KDFへの入力が適切な入力分布から選択され、入力が互いに独立して選択されることが重要です（技術的には、KDFへの他の入力に条件付けられていても、各サンプルが十分なエントロピーを持つ必要があります）。"
    },
    {
      "indent": 3,
      "text": "Independence is also an important aspect of the salt value provided to a KDF. While there is no need to keep the salt secret, and the same salt value can be used with multiple IKM values, it is assumed that salt values are independent of the input keying material. In particular, an application needs to make sure that salt values are not chosen or manipulated by an attacker. As an example, consider the case (as in IKE) where the salt is derived from nonces supplied by the parties in a key exchange protocol. Before the protocol can use such salt to derive keys, it needs to make sure that these nonces are authenticated as coming from the legitimate parties rather than selected by the attacker (in IKE, for example this authentication is an integral part of the authenticated Diffie-Hellman exchange).",
      "ja": "独立性は、KDFに提供されるソルト値の重要な側面でもあります。ソルトを秘密に保つ必要はなく、同じソルト値を複数のIKM値で使用できますが、ソルト値は入力キーイングマテリアルに依存しないと想定されています。特に、アプリケーションは、ソルト値が攻撃者によって選択または操作されないことを確認する必要があります。例として、ソルトが鍵交換プロトコルで当事者によって供給されたノンスに由来するケース（IKEのように）を考慮してください。プロトコルがそのようなソルトを使用して鍵を導出する前に、攻撃者によって選択されるのではなく、これらのノンスが正当な関係者から来ると認証されることを確認する必要があります（たとえば、IKEでは、この認証は認証されたDiffie-Hellman交換の不可欠な部分です）。"
    },
    {
      "indent": 0,
      "text": "4. Applications of HKDF",
      "section_title": true,
      "ja": "4. HKDFのアプリケーション"
    },
    {
      "indent": 3,
      "text": "HKDF is intended for use in a wide variety of KDF applications. These include the building of pseudorandom generators from imperfect sources of randomness (such as a physical random number generator (RNG)); the generation of pseudorandomness out of weak sources of randomness, such as entropy collected from system events, user's keystrokes, etc.; the derivation of cryptographic keys from a shared Diffie-Hellman value in a key-agreement protocol; derivation of symmetric keys from a hybrid public-key encryption scheme; key derivation for key-wrapping mechanisms; and more. All of these applications can benefit from the simplicity and multi-purpose nature of HKDF, as well as from its analytical foundation.",
      "ja": "HKDFは、さまざまなKDFアプリケーションで使用することを目的としています。これらには、不完全なランダム性（物理的乱数生成器（RNG）など）からの擬似乱数生成器の構築、システムイベントやユーザーのキーストロークなどから収集されたエントロピーなど、ランダム性の弱いソースからの擬似ランダム性の生成、鍵合意プロトコルにおける共有Diffie-Hellman値からの暗号鍵の導出、ハイブリッド公開鍵暗号スキームからの対称鍵の導出、キーラップメカニズムの鍵導出などが含まれます。これらのアプリケーションはすべて、HKDFのシンプルさと多目的性質、およびその分析基盤の恩恵を受けることができます。"
    },
    {
      "indent": 3,
      "text": "On the other hand, it is anticipated that some applications will not be able to use HKDF \"as-is\" due to specific operational requirements, or will be able to use it but without the full benefits of the scheme. One significant example is the derivation of cryptographic keys from a source of low entropy, such as a user's password. The extract step in HKDF can concentrate existing entropy but cannot amplify entropy. In the case of password-based KDFs, a main goal is to slow down dictionary attacks using two ingredients: a salt value, and the intentional slowing of the key derivation computation. HKDF naturally accommodates the use of salt; however, a slowing down mechanism is not part of this specification. Applications interested in a password-based KDF should consider whether, for example, [PKCS5] meets their needs better than HKDF.",
      "ja": "一方、一部のアプリケーションは、特定の運用要件のためにHKDFを「そのまま」使用できないか、使用できてもスキームの完全な利点が得られないと予想されます。重要な例の1つは、ユーザーのパスワードなど、低エントロピーのソースからの暗号鍵の導出です。HKDFの抽出ステップは、既存のエントロピーを凝縮させることはできますが、エントロピーを増幅することはできません。パスワードベースのKDFの場合、主な目標は、2つの要素を使用して辞書攻撃を遅らせることです。ソルト値と、鍵導出計算の意図的な遅延です。HKDFは自然にソルトの使用に対応します。ただし、遅延メカニズムはこの仕様の一部ではありません。パスワードベースのKDFに関心のあるアプリケーションは、たとえば、[PKCS5]がHKDFよりもニーズをよりよく満たすかどうかを検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In spite of the simplicity of HKDF, there are many security considerations that have been taken into account in the design and analysis of this construction. An exposition of all of these aspects is beyond the scope of this document. Please refer to [HKDF-paper] for detailed information, including rationale for the design and for the guidelines presented in Section 3.",
      "ja": "HKDFの単純さにもかかわらず、この構造の設計と分析で考慮されている多くのセキュリティ上の考慮事項があります。これらすべての側面の説明は、このドキュメントの範囲を超えています。設計の理論的根拠やセクション3に示されているガイドラインを含む詳細については、[HKDF-paper]を参照してください。"
    },
    {
      "indent": 3,
      "text": "A major effort has been made in the above paper [HKDF-paper] to provide a cryptographic analysis of HKDF as a multi-purpose KDF that exercises much care in the way it utilizes cryptographic hash functions. This is particularly important due to the limited confidence we have in the strength of current hash functions. This analysis, however, does not imply the absolute security of any scheme, and it depends heavily on the strength of the underlying hash function and on modeling choices. Yet, it serves as a strong indication of the correct structure of the HKDF design and its advantages over other common KDF schemes.",
      "ja": "上記の論文[HKDF-paper]では、暗号学的ハッシュ関数の利用方法に細心の注意を払った多目的KDFとしてのHKDFの暗号学的分析を提供するために、多大な努力が払われています。これは、現在のハッシュ関数の強度に対する信頼が限られているため、特に重要です。ただし、この分析は、スキームの絶対的なセキュリティを意味するものではなく、基礎となるハッシュ関数の強度とモデリングの選択に大きく依存します。しかし、それはHKDF設計の正しい構造と、他の一般的なKDFスキームに対するその利点の強力な兆候として機能します。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgments",
      "section_title": true,
      "ja": "6. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank members of the CFRG (Crypto Forum Research Group) list for their useful comments, and to Dan Harkins for providing test vectors.",
      "ja": "著者は、有用なコメントを寄せられたCFRG（Crypto Forum Research Group）リストのメンバー、およびテストベクターを提供してくれたDan Harkinsに感謝します。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[HMAC] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：メッセージ認証のためのキー付きハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[KEYWORDS] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[キーワード] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[SHS] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-3, October 2008.",
      "ja": "[SHS]国立標準技術研究所、「Secure Hash Standard」、FIPS PUB 180-3、2008年10月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考資料"
    },
    {
      "indent": 3,
      "text": "[1363a] Institute of Electrical and Electronics Engineers, \"IEEE Standard Specifications for Public-Key Cryptography - Amendment 1: Additional Techniques\", IEEE Std 1363a-2004, 2004.",
      "ja": "[1363a]米国電気電子学会、「公開鍵暗号のIEEE標準仕様 - 修正1：追加技術」、IEEE Std 1363a-2004、2004。"
    },
    {
      "indent": 3,
      "text": "[800-108] National Institute of Standards and Technology, \"Recommendation for Key Derivation Using Pseudorandom Functions\", NIST Special Publication 800-108, November 2008.",
      "ja": "[800-108]国立標準技術研究所、「擬似ランダム関数を使用した鍵導出の推奨事項」、NIST Special Publication 800-108、2008年11月。"
    },
    {
      "indent": 3,
      "text": "[800-56A] National Institute of Standards and Technology, \"Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography (Revised)\", NIST Special Publication 800-56A, March 2007.",
      "ja": "[800-56A]国立標準技術研究所、「離散対数暗号（改訂）を使用したペアワイズ鍵確立スキームの推奨事項」、NIST Special Publication 800-56A、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[EAP-AKA] Arkko, J., Lehtovirta, V., and P. Eronen, \"Improved Extensible Authentication Protocol Method for 3rd Generation Authentication and Key Agreement (EAP-AKA')\", RFC 5448, May 2009.",
      "ja": "[EAP-AKA] Arkko、J.、Lehtovirta、V。、およびP. Eronen、「第3世代認証と鍵合意（EAP-AKA '）のための拡張可能な認証プロトコル法の改善」、RFC 5448、2009年5月。"
    },
    {
      "indent": 3,
      "text": "[HKDF-paper] Krawczyk, H., \"Cryptographic Extraction and Key Derivation: The HKDF Scheme\", Proceedings of CRYPTO 2010 (to appear), 2010, <http://eprint.iacr.org/2010/264>.",
      "ja": "[HKDF-paper] Krawczyk、H。、「暗号学的抽出と鍵導出：HKDFスキーム」、Proceedings of CRYPTO 2010 (to appear)、2010年、<http://eprint.iacr.org/2010/264>。"
    },
    {
      "indent": 3,
      "text": "[IKEv2] Kaufman, C., Ed., \"Internet Key Exchange (IKEv2) Protocol\", RFC 4306, December 2005.",
      "ja": "[IKEv2] Kaufman、C.、Ed。、「Internet Key Exchange（IKEv2）Protocol」、RFC 4306、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[PANA] Forsberg, D., Ohba, Y., Ed., Patil, B., Tschofenig, H., and A. Yegin, \"Protocol for Carrying Authentication for Network Access (PANA)\", RFC 5191, May 2008.",
      "ja": "[PANA] Forsberg、D.、Ohba、Y.、Ed。、Patil、B.、Tschofenig、H。、およびA. Yegin、「ネットワークアクセスのための認証を運ぶためのプロトコル（PANA）」、RFC 5191、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[PKCS5] Kaliski, B., \"PKCS #5: Password-Based Cryptography Specification Version 2.0\", RFC 2898, September 2000.",
      "ja": "[PKCS5] Kaliski、B。、「PKCS＃5：パスワードベースの暗号化仕様バージョン2.0」、RFC 2898、2000年9月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Test Vectors",
      "section_title": true,
      "ja": "付録A. テストベクトル"
    },
    {
      "indent": 3,
      "text": "This appendix provides test vectors for SHA-256 and SHA-1 hash functions [SHS].",
      "ja": "この付録は、SHA-256およびSHA-1ハッシュ関数のテストベクトル[SHS]を提供します。"
    },
    {
      "indent": 0,
      "text": "A.1. Test Case 1",
      "section_title": true,
      "ja": "A.1. テストケース1"
    },
    {
      "indent": 3,
      "text": "Basic test case with SHA-256",
      "ja": "SHA-256の基本的なテストケース"
    },
    {
      "indent": 3,
      "text": "Hash = SHA-256\nIKM  = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b (22 octets)\nsalt = 0x000102030405060708090a0b0c (13 octets)\ninfo = 0xf0f1f2f3f4f5f6f7f8f9 (10 octets)\nL    = 42\n\nPRK  = 0x077709362c2e32df0ddc3f0dc47bba63\n       90b6c73bb50f9c3122ec844ad7c2b3e5 (32 octets)\nOKM  = 0x3cb25f25faacd57a90434f64d0362f2a\n       2d2d0a90cf1a5a4c5db02d56ecc4c5bf\n       34007208d5b887185865 (42 octets)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. Test Case 2",
      "section_title": true,
      "ja": "A.2. テストケース2"
    },
    {
      "indent": 3,
      "text": "Test with SHA-256 and longer inputs/outputs",
      "ja": "SHA-256およびより長い入力/出力でのテスト"
    },
    {
      "indent": 3,
      "text": "Hash = SHA-256\nIKM  = 0x000102030405060708090a0b0c0d0e0f\n       101112131415161718191a1b1c1d1e1f\n       202122232425262728292a2b2c2d2e2f\n       303132333435363738393a3b3c3d3e3f\n       404142434445464748494a4b4c4d4e4f (80 octets)\nsalt = 0x606162636465666768696a6b6c6d6e6f\n       707172737475767778797a7b7c7d7e7f\n       808182838485868788898a8b8c8d8e8f\n       909192939495969798999a9b9c9d9e9f\n       a0a1a2a3a4a5a6a7a8a9aaabacadaeaf (80 octets)\ninfo = 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\n       c0c1c2c3c4c5c6c7c8c9cacbcccdcecf\n       d0d1d2d3d4d5d6d7d8d9dadbdcdddedf\n       e0e1e2e3e4e5e6e7e8e9eaebecedeeef\n       f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff (80 octets)\nL    = 82\n\nPRK  = 0x06a6b88c5853361a06104c9ceb35b45c\n       ef760014904671014a193f40c15fc244 (32 octets)\nOKM  = 0xb11e398dc80327a1c8e7f78c596a4934\n       4f012eda2d4efad8a050cc4c19afa97c\n       59045a99cac7827271cb41c65e590e09\n       da3275600c2f09b8367793a9aca3db71\n       cc30c58179ec3e87c14c01d5c1f3434f\n       1d87 (82 octets)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. Test Case 3",
      "section_title": true,
      "ja": "A.3. テストケース3"
    },
    {
      "indent": 3,
      "text": "Test with SHA-256 and zero-length salt/info",
      "ja": "SHA-256およびゼロ長のソルト/情報でのテスト"
    },
    {
      "indent": 3,
      "text": "Hash = SHA-256\nIKM  = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b (22 octets)\nsalt = (0 octets)\ninfo = (0 octets)\nL    = 42\n\nPRK  = 0x19ef24a32c717b167f33a91d6f648bdf\n       96596776afdb6377ac434c1c293ccb04 (32 octets)\nOKM  = 0x8da4e775a563c18f715f802a063c5a31\n       b8a11f5c5ee1879ec3454e5f3c738d2d\n       9d201395faa4b61a96c8 (42 octets)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. Test Case 4",
      "section_title": true,
      "ja": "A.4. テストケース4"
    },
    {
      "indent": 3,
      "text": "Basic test case with SHA-1",
      "ja": "SHA-1の基本的なテストケース"
    },
    {
      "indent": 3,
      "text": "Hash = SHA-1\nIKM  = 0x0b0b0b0b0b0b0b0b0b0b0b (11 octets)\nsalt = 0x000102030405060708090a0b0c (13 octets)\ninfo = 0xf0f1f2f3f4f5f6f7f8f9 (10 octets)\nL    = 42\n\nPRK  = 0x9b6c18c432a7bf8f0e71c8eb88f4b30baa2ba243 (20 octets)\nOKM  = 0x085a01ea1b10f36933068b56efa5ad81\n       a4f14b822f5b091568a9cdd4f155fda2\n       c22e422478d305f3f896 (42 octets)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5. Test Case 5",
      "section_title": true,
      "ja": "A.5. テストケース5"
    },
    {
      "indent": 3,
      "text": "Test with SHA-1 and longer inputs/outputs",
      "ja": "SHA-1およびより長い入力/出力でのテスト"
    },
    {
      "indent": 3,
      "text": "Hash = SHA-1\nIKM  = 0x000102030405060708090a0b0c0d0e0f\n       101112131415161718191a1b1c1d1e1f\n       202122232425262728292a2b2c2d2e2f\n       303132333435363738393a3b3c3d3e3f\n       404142434445464748494a4b4c4d4e4f (80 octets)\nsalt = 0x606162636465666768696a6b6c6d6e6f\n       707172737475767778797a7b7c7d7e7f\n       808182838485868788898a8b8c8d8e8f\n       909192939495969798999a9b9c9d9e9f\n       a0a1a2a3a4a5a6a7a8a9aaabacadaeaf (80 octets)\ninfo = 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\n       c0c1c2c3c4c5c6c7c8c9cacbcccdcecf\n       d0d1d2d3d4d5d6d7d8d9dadbdcdddedf\n       e0e1e2e3e4e5e6e7e8e9eaebecedeeef\n       f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff (80 octets)\nL    = 82\n\nPRK  = 0x8adae09a2a307059478d309b26c4115a224cfaf6 (20 octets)\nOKM  = 0x0bd770a74d1160f7c9f12cd5912a06eb\n       ff6adcae899d92191fe4305673ba2ffe\n       8fa3f1a4e5ad79f3f334b3b202b2173c\n       486ea37ce3d397ed034c7f9dfeb15c5e\n       927336d0441f4c4300e2cff0d0900b52\n       d3b4 (82 octets)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.6. Test Case 6",
      "section_title": true,
      "ja": "A.6. テストケース6"
    },
    {
      "indent": 3,
      "text": "Test with SHA-1 and zero-length salt/info",
      "ja": "SHA-1およびゼロ長のソルト/情報でのテスト"
    },
    {
      "indent": 3,
      "text": "Hash = SHA-1\nIKM  = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b (22 octets)\nsalt = (0 octets)\ninfo = (0 octets)\nL    = 42\n\nPRK  = 0xda8c8a73c7fa77288ec6f5e7c297786aa0d32d01 (20 octets)\nOKM  = 0x0ac1af7002b3d761d1e55298da9d0506\n       b9ae52057220a306e07b6b87e8df21d0\n       ea00033de03984d34918 (42 octets)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.7. Test Case 7",
      "section_title": true,
      "ja": "A.7. テストケース7"
    },
    {
      "indent": 3,
      "text": "Test with SHA-1, salt not provided (defaults to HashLen zero octets), zero-length info",
      "ja": "SHA-1でのテスト、ソルト提供なし（デフォルトはHashLen個のゼロオクテット）、ゼロ長のinfo"
    },
    {
      "indent": 3,
      "text": "Hash = SHA-1\nIKM  = 0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c (22 octets)\nsalt = not provided (defaults to HashLen zero octets)\ninfo = (0 octets)\nL    = 42\n\nPRK  = 0x2adccada18779e7c2077ad2eb19d3f3e731385dd (20 octets)\nOKM  = 0x2c91117204d745f3500d636a62f64f0a\n       b3bae548aa53d423b0d1f27ebba6f5e5\n       673a081d70cce7acfc48 (42 octets)\n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Hugo Krawczyk IBM Research 19 Skyline Drive Hawthorne, NY 10532 USA",
      "ja": "Hugo Krawczyk IBM Research 19スカイラインドライブホーソーン、ニューヨーク10532 USA"
    },
    {
      "indent": 3,
      "text": "EMail: hugokraw@us.ibm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pasi Eronen Nokia Research Center P.O. Box 407 FI-00045 Nokia Group Finland",
      "ja": "Pasi Eronen Nokia Research Center P.O.Box 407 FI-00045 Nokia Group Finland"
    },
    {
      "indent": 3,
      "text": "EMail: pasi.eronen@nokia.com",
      "raw": true,
      "ja": ""
    }
  ]
}