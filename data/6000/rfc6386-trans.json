{
  "title": {
    "text": "RFC 6386 - VP8 Data Format and Decoding Guide",
    "ja": "RFC 6386 - VP8データ形式とデコードガイド"
  },
  "number": 6386,
  "created_at": "2022-11-28 21:17:18.338437+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                       J. Bankoski\nRequest for Comments: 6386                                   J. Koleszar\nCategory: Informational                                       L. Quillio\nISSN: 2070-1721                                               J. Salonen\n                                                              P. Wilkins\n                                                                   Y. Xu\n                                                             Google Inc.\n                                                           November 2011",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "VP8 Data Format and Decoding Guide",
      "ja": "VP8データ形式とデコードガイド"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the VP8 compressed video data format, together with a discussion of the decoding procedure for the format.",
      "ja": "このドキュメントでは、VP8圧縮ビデオデータ形式と、形式のデコード手順の説明について説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。情報目的で公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "これは、他のRFCストリームとは無関係に、RFCシリーズへの貢献です。RFCエディターは、このドキュメントの裁量でこのドキュメントを公開することを選択しており、実装または展開に対する価値について声明を発表しません。RFCエディターによって公開が承認されたドキュメントは、インターネット標準のレベルの候補者ではありません。RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6386.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、http：//www.rfc-editor.org/info/rfc6386で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2011 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. Format Overview .................................................5\n3. Compressed Frame Types ..........................................7\n4. Overview of Compressed Data Format ..............................8\n5. Overview of the Decoding Process ................................9\n6. Description of Algorithms ......................................14\n7. Boolean Entropy Decoder ........................................16\n   7.1. Underlying Theory of Coding ...............................17\n   7.2. Practical Algorithm Description ...........................18\n   7.3. Actual Implementation .....................................20\n8. Compressed Data Components .....................................25\n   8.1. Tree Coding Implementation ................................27\n   8.2. Tree Coding Example .......................................28\n9. Frame Header ...................................................30\n   9.1. Uncompressed Data Chunk ...................................30\n   9.2. Color Space and Pixel Type (Key Frames Only) ..............33\n   9.3. Segment-Based Adjustments .................................34\n   9.4. Loop Filter Type and Levels ...............................35\n   9.5. Token Partition and Partition Data Offsets ................36\n   9.6. Dequantization Indices ....................................37\n   9.7. Refresh Golden Frame and Altref Frame .....................38\n   9.8. Refresh Last Frame Buffer .................................39\n   9.9. DCT Coefficient Probability Update ........................39\n   9.10. Remaining Frame Header Data (Non-Key Frame) ..............40\n   9.11. Remaining Frame Header Data (Key Frame) ..................41\n10. Segment-Based Feature Adjustments .............................41\n11. Key Frame Macroblock Prediction Records .......................42\n   11.1. mb_skip_coeff ............................................42\n   11.2. Luma Modes ...............................................42\n   11.3. Subblock Mode Contexts ...................................45\n   11.4. Chroma Modes .............................................46\n   11.5. Subblock Mode Probability Table ..........................47\n12. Intraframe Prediction .........................................50\n   12.1. mb_skip_coeff ............................................51\n   12.2. Chroma Prediction ........................................51\n   12.3. Luma Prediction ..........................................54\n13. DCT Coefficient Decoding ......................................60\n   13.1. Macroblock without Non-Zero Coefficient Values ...........61\n   13.2. Coding of Individual Coefficient Values ..................61\n   13.3. Token Probabilities ......................................63\n   13.4. Token Probability Updates ................................68\n   13.5. Default Token Probability Table ..........................73",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "14. DCT and WHT Inversion and Macroblock Reconstruction ...........76\n   14.1. Dequantization ...........................................76\n   14.2. Inverse Transforms .......................................78\n   14.3. Implementation of the WHT Inversion ......................78\n   14.4. Implementation of the DCT Inversion ......................81\n   14.5. Summation of Predictor and Residue .......................83\n15. Loop Filter ...................................................84\n   15.1. Filter Geometry and Overall Procedure ....................85\n   15.2. Simple Filter ............................................87\n   15.3. Normal Filter ............................................91\n   15.4. Calculation of Control Parameters ........................95\n16. Interframe Macroblock Prediction Records ......................97\n   16.1. Intra-Predicted Macroblocks ..............................97\n   16.2. Inter-Predicted Macroblocks ..............................98\n   16.3. Mode and Motion Vector Contexts ..........................99\n   16.4. Split Prediction ........................................105\n17. Motion Vector Decoding .......................................108\n   17.1. Coding of Each Component ................................108\n   17.2. Probability Updates .....................................110\n18. Interframe Prediction ........................................113\n   18.1. Bounds on, and Adjustment of, Motion Vectors ............113\n   18.2. Prediction Subblocks ....................................115\n   18.3. Sub-Pixel Interpolation .................................115\n   18.4. Filter Properties .......................................118\n19. Annex A: Bitstream Syntax ....................................120\n   19.1. Uncompressed Data Chunk .................................121\n   19.2. Frame Header ............................................122\n   19.3. Macroblock Data .........................................130\n20. Attachment One: Reference Decoder Source Code ................133\n   20.1. bit_ops.h ...............................................133\n   20.2. bool_decoder.h ..........................................133\n   20.3. dequant_data.h ..........................................137\n   20.4. dixie.c .................................................138\n   20.5. dixie.h .................................................151\n   20.6. dixie_loopfilter.c ......................................158\n   20.7. dixie_loopfilter.h ......................................170\n   20.8. idct_add.c ..............................................171\n   20.9. idct_add.h ..............................................174\n   20.10. mem.h ..................................................175\n   20.11. modemv.c ...............................................176\n   20.12. modemv.h ...............................................192\n   20.13. modemv_data.h ..........................................193\n   20.14. predict.c ..............................................198\n   20.15. predict.h ..............................................231\n   20.16. tokens.c ...............................................232\n   20.17. tokens.h ...............................................242\n   20.18. vp8_prob_data.h ........................................243\n   20.19. vpx_codec_internal.h ...................................252",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   20.20. vpx_decoder.h ..........................................263\n   20.21. vpx_decoder_compat.h ...................................271\n   20.22. vpx_image.c ............................................285\n   20.23. vpx_image.h ............................................291\n   20.24. vpx_integer.h ..........................................298\n   20.25. AUTHORS File ...........................................299\n   20.26. LICENSE ................................................301\n   20.27. PATENTS ................................................302\n21. Security Considerations ......................................302\n22. References ...................................................303\n   22.1. Normative Reference .....................................303\n   22.2. Informative References ..................................303",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the VP8 compressed video data format, together with a discussion of the decoding procedure for the format. It is intended to be used in conjunction with, and as a guide to, the reference decoder source code provided in Attachment One (Section 20). If there are any conflicts between this narrative and the reference source code, the reference source code should be considered correct. The bitstream is defined by the reference source code and not this narrative.",
      "ja": "このドキュメントでは、VP8圧縮ビデオデータ形式と、形式のデコード手順の説明について説明します。これは、添付ファイル1（セクション20）で提供される参照デコーダーソースコードと連携して、およびガイドとして使用することを目的としています。この物語と参照ソースコードの間に競合がある場合、参照ソースコードを正しいと見なす必要があります。ビットストリームは、この物語ではなく、参照ソースコードによって定義されます。"
    },
    {
      "indent": 3,
      "text": "Like many modern video compression schemes, VP8 is based on decomposition of frames into square subblocks of pixels, prediction of such subblocks using previously constructed blocks, and adjustment of such predictions (as well as synthesis of unpredicted blocks) using a discrete cosine transform (hereafter abbreviated as DCT). In one special case, however, VP8 uses a Walsh-Hadamard transform (hereafter abbreviated as WHT) instead of a DCT.",
      "ja": "多くの最新のビデオ圧縮スキームと同様に、VP8は、ピクセルの四角いサブブロックへのフレームの分解、以前に構築されたブロックを使用したそのようなサブブロックの予測、およびそのような予測の調整（および予測されていないブロックの合成）に基づいています。DCTとして略された）。ただし、1つの特別なケースでは、VP8はDCTの代わりにWalsh-Hadamard Transform（以下WHTとして略された）を使用します。"
    },
    {
      "indent": 3,
      "text": "Roughly speaking, such systems reduce datarate by exploiting the temporal and spatial coherence of most video signals. It is more efficient to specify the location of a visually similar portion of a prior frame than it is to specify pixel values. The frequency segregation provided by the DCT and WHT facilitates the exploitation of both spatial coherence in the original signal and the tolerance of the human visual system to moderate losses of fidelity in the reconstituted signal.",
      "ja": "大まかに言えば、このようなシステムは、ほとんどのビデオ信号の時間的および空間的な一貫性を活用することにより、データレー酸塩を減らします。ピクセル値を指定するよりも、以前のフレームの視覚的に類似した部分の位置を指定する方が効率的です。DCTによって提供される周波数分離とWHTは、元の信号における空間的コヒーレンスの両方の搾取と、再構成された信号の忠実度の緩和の緩和に対するヒトの視覚システムの耐性の両方を促進します。"
    },
    {
      "indent": 3,
      "text": "VP8 augments these basic concepts with, among other things, sophisticated usage of contextual probabilities. The result is a significant reduction in datarate at a given quality.",
      "ja": "VP8は、これらの基本的な概念を、とりわけ、コンテキスト確率の洗練された使用法で拡張します。その結果、特定の品質でデータレートが大幅に減少します。"
    },
    {
      "indent": 3,
      "text": "Unlike some similar schemes (the older MPEG formats, for example), VP8 specifies exact values for reconstructed pixels. Specifically, the specification for the DCT and WHT portions of the reconstruction does not allow for any \"drift\" caused by truncation of fractions. Rather, the algorithm is specified using fixed-precision integer operations exclusively. This greatly facilitates the verification of the correctness of a decoder implementation and also avoids difficult-to-predict visual incongruities between such implementations.",
      "ja": "いくつかの同様のスキーム（古いMPEG形式など）とは異なり、VP8は再構築されたピクセルの正確な値を指定します。具体的には、再構築のDCTおよびWHT部分の仕様では、画分の切り捨てによって引き起こされる「ドリフト」は許可されていません。むしろ、アルゴリズムは、固定精度の整数操作のみを使用して指定されます。これにより、デコーダーの実装の正確性の検証が大幅に促進され、このような実装間の予測が困難な視覚的不一致を回避します。"
    },
    {
      "indent": 3,
      "text": "It should be remarked that, in a complete video playback system, the displayed frames may or may not be identical to the reconstructed frames. Many systems apply a final level of filtering (commonly referred to as postprocessing) to the reconstructed frames prior to viewing. Such postprocessing has no effect on the decoding and reconstruction of subsequent frames (which are predicted using the completely specified reconstructed frames) and is beyond the scope of this document. In practice, the nature and extent of this sort of postprocessing is dependent on both the taste of the user and on the computational facilities of the playback environment.",
      "ja": "完全なビデオ再生システムでは、表示されているフレームが再構築されたフレームと同一である場合と同一でない場合がある場合があることに注意する必要があります。多くのシステムは、視聴前に再構築されたフレームに最終レベルのフィルタリング（一般にポストプロセッシングと呼ばれる）を適用します。このような後処理は、後続のフレーム（完全に指定された再構築されたフレームを使用して予測される）のデコードと再構築に影響を与えず、このドキュメントの範囲を超えています。実際には、この種のポストプロセスの性質と範囲は、ユーザーの味と再生環境の計算施設の両方に依存しています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Format Overview",
      "section_title": true,
      "ja": "2. フォーマットの概要"
    },
    {
      "indent": 3,
      "text": "VP8 works exclusively with an 8-bit YUV 4:2:0 image format. In this format, each 8-bit pixel in the two chroma planes (U and V) corresponds positionally to a 2x2 block of 8-bit luma pixels in the Y plane; coordinates of the upper left corner of the Y block are of course exactly twice the coordinates of the corresponding chroma pixels. When we refer to pixels or pixel distances without specifying a plane, we are implicitly referring to the Y plane or to the complete image, both of which have the same (full) resolution.",
      "ja": "VP8は、8ビットYUV 4：2：0の画像形式でのみ機能します。この形式では、2つのクロマ平面（UとV）の各8ビットピクセルは、Y平面の8ビットLUMAピクセルの2x2ブロックに位置的に対応します。Yブロックの左上隅の座標は、もちろん、対応するクロマピクセルの座標の正確な2倍です。平面を指定せずにピクセルまたはピクセル距離を参照する場合、Y平面または完全な画像を暗黙的に参照します。どちらも同じ（完全な）解像度を持っています。"
    },
    {
      "indent": 3,
      "text": "As is usually the case, the pixels are simply a large array of bytes stored in rows from top to bottom, each row being stored from left to right. This \"left to right\" then \"top to bottom\" raster-scan order is reflected in the layout of the compressed data as well.",
      "ja": "通常のように、ピクセルは単に上から下まで行に保存されたバイトの大きな配列であり、各列は左から右に保存されます。この「左から右」、次に「上から下」ラスタースキャンの順序は、圧縮データのレイアウトにも反映されます。"
    },
    {
      "indent": 3,
      "text": "Provision has been made in the VP8 bitstream header for the support of a secondary YUV color format, in the form of a reserved bit.",
      "ja": "予約ビットの形で、二次YUVカラー形式のサポートのために、VP8ビットストリームヘッダーで提供されています。"
    },
    {
      "indent": 3,
      "text": "Occasionally, at very low datarates, a compression system may decide to reduce the resolution of the input signal to facilitate efficient compression. The VP8 data format supports this via optional upscaling of its internal reconstruction buffer prior to output (this",
      "ja": "時折、非常に低いデータレートで、圧縮システムは、効率的な圧縮を容易にするために入力信号の解像度を減らすことを決定する場合があります。VP8データ形式は、出力前に内部再構成バッファーのオプションのアップスケーリングを介してこれをサポートしています（これ"
    },
    {
      "indent": 3,
      "text": "is completely distinct from the optional postprocessing discussed earlier, which has nothing to do with decoding per se). This upsampling restores the video frames to their original resolution. In other words, the compression/decompression system can be viewed as a \"black box\", where the input and output are always at a given resolution. The compressor might decide to \"cheat\" and process the signal at a lower resolution. In that case, the decompressor needs the ability to restore the signal to its original resolution.",
      "ja": "前述のオプションのポストプロセスとは完全に異なりますが、それ自体を解読することとは関係ありません）。このアップサンプリングにより、ビデオフレームが元の解像度に復元されます。言い換えれば、圧縮/減圧システムは「ブラックボックス」と見なすことができ、入力と出力は常に特定の解像度にあります。コンプレッサーは、低解像度で「チート」して信号を処理することを決定する場合があります。その場合、減圧装置は、信号を元の解像度に復元する機能を必要とします。"
    },
    {
      "indent": 3,
      "text": "Internally, VP8 decomposes each output frame into an array of macroblocks. A macroblock is a square array of pixels whose Y dimensions are 16x16 and whose U and V dimensions are 8x8. Macroblock-level data in a compressed frame occurs (and must be processed) in a raster order similar to that of the pixels comprising the frame.",
      "ja": "内部的には、VP8は各出力フレームをマクロブロックの配列に分解します。マクロブロックは、y寸法が16x16であり、uおよびv寸法が8x8であるピクセルの正方形の配列です。圧縮フレームのマクロブロックレベルのデータは、フレームを構成するピクセルと同様のラスター順序で発生します（および処理する必要があります）。"
    },
    {
      "indent": 3,
      "text": "Macroblocks are further decomposed into 4x4 subblocks. Every macroblock has 16 Y subblocks, 4 U subblocks, and 4 V subblocks. Any subblock-level data (and processing of such data) again occurs in raster order, this time in raster order within the containing macroblock.",
      "ja": "マクロブロックは、さらに4x4サブブロックに分解されます。すべてのマクロブロックには、16のサブブロック、4つのUサブブロック、4つのVサブブロックがあります。サブブロックレベルのデータ（およびそのようなデータの処理）は、再びラスター順序で発生します。今回は、マクロブロックを含むラスター順序で発生します。"
    },
    {
      "indent": 3,
      "text": "As discussed in further detail below, data can be specified at the levels of both macroblocks and their subblocks.",
      "ja": "以下でさらに詳しく説明するように、データはマクロブロックとそのサブブロックの両方のレベルで指定できます。"
    },
    {
      "indent": 3,
      "text": "Pixels are always treated, at a minimum, at the level of subblocks, which may be thought of as the \"atoms\" of the VP8 algorithm. In particular, the 2x2 chroma blocks corresponding to 4x4 Y subblocks are never treated explicitly in the data format or in the algorithm specification.",
      "ja": "ピクセルは常に、少なくともサブブロックのレベルで処理されます。これは、VP8アルゴリズムの「原子」と考えられる可能性があります。特に、4x4 Yサブブロックに対応する2x2クロマブロックは、データ形式またはアルゴリズム仕様で明示的に扱われることはありません。"
    },
    {
      "indent": 3,
      "text": "The DCT and WHT always operate at a 4x4 resolution. The DCT is used for the 16Y, 4U, and 4V subblocks. The WHT is used (with some but not all prediction modes) to encode a 4x4 array comprising the average intensities of the 16 Y subblocks of a macroblock. These average intensities are, up to a constant normalization factor, nothing more than the 0th DCT coefficients of the Y subblocks. This \"higher-level\" WHT is a substitute for the explicit specification of those coefficients, in exactly the same way as the DCT of a subblock substitutes for the specification of the pixel values comprising the subblock. We consider this 4x4 array as a second-order subblock called Y2, and think of a macroblock as containing 24 \"real\" subblocks and, sometimes, a 25th \"virtual\" subblock. This is dealt with further in Section 13.",
      "ja": "DCTとWHTは常に4x4解像度で動作します。DCTは、16Y、4U、および4Vサブブロックに使用されます。WHTは（すべてではないが一部ではないが一部ではありませんが）使用され、マクロブロックの16Yサブブロックの平均強度を含む4x4アレイをエンコードします。これらの平均強度は、一定の正規化係数まで、Yサブブロックの0番目のDCT係数にすぎません。この「高レベルの」WHTは、サブブロックを含むピクセル値の仕様のサブブロックのDCTとまったく同じ方法で、これらの係数の明示的な仕様の代替品です。この4x4アレイはY2と呼ばれる2次サブブロックと見なし、マクロブロックを24の「本物の」サブブロックを含むと考えています。これは、セクション13でさらに扱われます。"
    },
    {
      "indent": 3,
      "text": "The frame layout used by the reference decoder may be found in the file vpx_image.h (Section 20.23).",
      "ja": "参照デコーダーで使用されるフレームレイアウトは、ファイルvpx_image.h（セクション20.23）に記載されている場合があります。"
    },
    {
      "indent": 0,
      "text": "3. Compressed Frame Types",
      "section_title": true,
      "ja": "3. 圧縮フレームタイプ"
    },
    {
      "indent": 3,
      "text": "There are only two types of frames in VP8.",
      "ja": "VP8にはフレームには2種類しかありません。"
    },
    {
      "indent": 3,
      "text": "Intraframes (also called key frames and, in MPEG terminology, I-frames) are decoded without reference to any other frame in a sequence; that is, the decompressor reconstructs such frames beginning from its \"default\" state. Key frames provide random access (or seeking) points in a video stream.",
      "ja": "イントラフレーム（キーフレームとも呼ばれ、MPEG用語ではIフレームとも呼ばれます）は、シーケンス内の他のフレームを参照せずにデコードされます。つまり、減圧器は「デフォルト」状態から始まるそのようなフレームを再構築します。キーフレームは、ビデオストリームでランダムアクセス（またはシーク）ポイントを提供します。"
    },
    {
      "indent": 3,
      "text": "Interframes (also called prediction frames and, in MPEG terminology, P-frames) are encoded with reference to prior frames, specifically all prior frames up to and including the most recent key frame. Generally speaking, the correct decoding of an interframe depends on the correct decoding of the most recent key frame and all ensuing frames. Consequently, the decoding algorithm is not tolerant of dropped frames: In an environment in which frames may be dropped or corrupted, correct decoding will not be possible until a key frame is correctly received.",
      "ja": "インターフレーム（予測フレームとも呼ばれ、MPEG用語ではPフレームとも呼ばれます）は、以前のフレーム、特に最新のキーフレームまでのすべての以前のフレームを参照してエンコードされます。一般的に言えば、インターフレームの正しいデコードは、最新のキーフレームとその後のすべてのフレームの正しいデコードに依存します。その結果、デコードアルゴリズムはドロップされたフレームに対して耐性がありません。フレームをドロップまたは破損する環境では、キーフレームが正しく受信されるまで正しいデコードは不可能です。"
    },
    {
      "indent": 3,
      "text": "In contrast to MPEG, there is no use of bidirectional prediction. No frame is predicted using frames temporally subsequent to it; there is no analog to an MPEG B-frame.",
      "ja": "MPEGとは対照的に、双方向の予測には使用されていません。フレームは、それに続いて一時的にフレームを使用して予測されることはありません。MPEG Bフレームのアナログはありません。"
    },
    {
      "indent": 3,
      "text": "Secondly, VP8 augments these notions with that of alternate prediction frames, called golden frames and altref frames (alternative reference frames). Blocks in an interframe may be predicted using blocks in the immediately previous frame as well as the most recent golden frame or altref frame. Every key frame is automatically golden and altref, and any interframe may optionally replace the most recent golden or altref frame.",
      "ja": "第二に、VP8はこれらの概念を、ゴールデンフレームとアルトレフフレーム（代替参照フレーム）と呼ばれる代替予測フレームの概念を補強します。インターフレーム内のブロックは、最新のフレームと最新のゴールデンフレームまたはアルトレフフレームのブロックを使用して予測できます。すべてのキーフレームは自動的に黄金色とアルトレフであり、任意のインターフレームはオプションで最新のゴールデンまたはアルトレフフレームを置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "Golden frames and altref frames may also be used to partially overcome the intolerance to dropped frames discussed above: If a compressor is configured to code golden frames only with reference to the prior golden frame (and key frame), then the \"substream\" of key and golden frames may be decoded regardless of loss of other interframes. Roughly speaking, the implementation requires (on the compressor side) that golden frames subsume and recode any context updates effected by the intervening interframes. A typical application of this approach is video conferencing, in which retransmission of a prior golden frame and/or a delay in playback until receipt of the next golden frame is preferable to a larger retransmit and/or delay until the next key frame.",
      "ja": "ゴールデンフレームとアルトレフフレームは、上記のドロップフレームへの不寛容を部分的に克服するためにも使用できます。コンプレッサーが以前のゴールデンフレーム（およびキーフレーム）、次にキーの「サブストリーム」を参照してゴールデンフレームをコードするように構成されている場合また、他のインターフレームの損失に関係なく、ゴールデンフレームはデコードされる場合があります。大まかに言えば、実装では（コンプレッサー側）、ゴールデンフレームが介入するインターフレームによって行われたコンテキストの更新を補充して再コーディングする必要があります。このアプローチの典型的なアプリケーションは、ビデオ会議です。これは、以前のゴールデンフレームの再送信および/または次のゴールデンフレームの受領が次のキーフレームまで大きな再送信および/または遅延よりも好ましいです。"
    },
    {
      "indent": 0,
      "text": "4. Overview of Compressed Data Format",
      "section_title": true,
      "ja": "4. 圧縮データ形式の概要"
    },
    {
      "indent": 3,
      "text": "The input to a VP8 decoder is a sequence of compressed frames whose order matches their order in time. Issues such as the duration of frames, the corresponding audio, and synchronization are generally provided by the playback environment and are irrelevant to the decoding process itself; however, to aid in fast seeking, a start code is included in the header of each key frame.",
      "ja": "VP8デコーダーへの入力は、順序が時間内に順序と一致する圧縮フレームのシーケンスです。フレームの期間、対応するオーディオ、同期などの問題は、一般に再生環境によって提供され、デコードプロセス自体とは無関係です。ただし、高速探索を支援するために、各キーフレームのヘッダーに開始コードが含まれています。"
    },
    {
      "indent": 3,
      "text": "The decoder is simply presented with a sequence of compressed frames and produces a sequence of decompressed (reconstructed) YUV frames corresponding to the input sequence. As stated in the Introduction, the exact pixel values in the reconstructed frame are part of VP8's specification. This document specifies the layout of the compressed frames and gives unambiguous algorithms for the correct production of reconstructed frames.",
      "ja": "デコーダーは、圧縮フレームのシーケンスで単純に表示され、入力シーケンスに対応する減圧（再構築された）YUVフレームのシーケンスを生成します。導入部で述べたように、再構築されたフレームの正確なピクセル値はVP8の仕様の一部です。このドキュメントは、圧縮フレームのレイアウトを指定し、再構築されたフレームの正しい生産のための明確なアルゴリズムを提供します。"
    },
    {
      "indent": 3,
      "text": "The first frame presented to the decompressor is of course a key frame. This may be followed by any number of interframes; the correct reconstruction of each frame depends on all prior frames up to the key frame. The next key frame restarts this process: The decompressor resets to its default initial condition upon reception of a key frame, and the decoding of a key frame (and its ensuing interframes) is completely independent of any prior decoding.",
      "ja": "減圧器に提示された最初のフレームは、もちろん重要なフレームです。これに続いて、任意の数のインターフレームが続く場合があります。各フレームの正しい再構築は、キーフレームまでのすべての以前のフレームに依存します。次のキーフレームはこのプロセスを再起動します。減圧器は、キーフレームを受信するとデフォルトの初期条件にリセットされ、キーフレーム（およびその後のインターフレーム）のデコードは、以前のデコードとは完全に独立しています。"
    },
    {
      "indent": 3,
      "text": "At the highest level, every compressed frame has three or more pieces. It begins with an uncompressed data chunk comprising 10 bytes in the case of key frames and 3 bytes for interframes. This is followed by two or more blocks of compressed data (called partitions). These compressed data partitions begin and end on byte boundaries.",
      "ja": "最高レベルでは、すべての圧縮フレームには3つ以上のピースがあります。キーフレームの場合は10バイト、インターフレームの3バイトで構成される非圧縮データチャンクから始まります。これに続いて、圧縮データの2つ以上のブロック（パーティションと呼ばれます）が続きます。これらの圧縮データパーティションは、バイト境界で開始および終了します。"
    },
    {
      "indent": 3,
      "text": "The first compressed partition has two subsections:",
      "ja": "最初の圧縮パーティションには2つのサブセクションがあります。"
    },
    {
      "indent": 3,
      "text": "1. Header information that applies to the frame as a whole.",
      "ja": "1. フレーム全体に適用されるヘッダー情報。"
    },
    {
      "indent": 3,
      "text": "2. Per-macroblock information specifying how each macroblock is predicted from the already-reconstructed data that is available to the decompressor.",
      "ja": "2. マクロブロックごとの情報は、減圧器が利用できる既に再構築されたデータから各マクロブロックがどのように予測されるかを指定します。"
    },
    {
      "indent": 3,
      "text": "As stated above, the macroblock-level information occurs in raster-scan order.",
      "ja": "上記のように、マクロブロックレベルの情報はラスタースキャンの順序で発生します。"
    },
    {
      "indent": 3,
      "text": "The rest of the partitions contain, for each block, the DCT/WHT coefficients (quantized and logically compressed) of the residue signal to be added to the predicted block values. It typically accounts for roughly 70% of the overall datarate. VP8 supports packing the compressed DCT/WHT coefficients' data from macroblock",
      "ja": "パーティションの残りの部分には、各ブロックに対して、予測ブロック値に追加される残基信号のDCT/WHT係数（量子化および論理的に圧縮）が含まれています。通常、全体的なデータレートの約70％を占めています。VP8は、マクロブロックからの圧縮DCT/WHT係数のデータの梱包をサポートしています"
    },
    {
      "indent": 3,
      "text": "rows into separate partitions. If there is more than one partition for these coefficients, the sizes of the partitions -- except the last partition -- in bytes are also present in the bitstream right after the above first partition. Each of the sizes is a 3-byte data item written in little endian format. These sizes provide the decoder direct access to all DCT/WHT coefficient partitions, which enables parallel processing of the coefficients in a decoder.",
      "ja": "別々のパーティションに列。これらの係数に複数のパーティションがある場合、最後のパーティションを除くパーティションのサイズは、上記の最初のパーティションの直後にビットストリームにも存在します。各サイズは、リトルエンド形式で記述された3バイトのデータ項目です。これらのサイズは、すべてのDCT/WHT係数パーティションへのデコーダー直接アクセスを提供します。これにより、デコーダー内の係数の並列処理が可能になります。"
    },
    {
      "indent": 3,
      "text": "The separate partitioning of the prediction data and coefficient data also allows flexibility in the implementation of a decompressor: An implementation may decode and store the prediction information for the whole frame and then decode, transform, and add the residue signal to the entire frame, or it may simultaneously decode both partitions, calculating prediction information and adding in the residue signal for each block in order. The length field in the frame tag, which allows decoding of the second partition to begin before the first partition has been completely decoded, is necessary for the second \"block-at-a-time\" decoder implementation.",
      "ja": "予測データと係数データの個別のパーティション化により、減圧装置の実装に柔軟性が可能になります。実装は、フレーム全体の予測情報をデコードして保存し、フレーム全体に残基信号をデコード、変換、追加することができます。両方のパーティションをデコードし、予測情報を計算し、各ブロックの残基信号を順に追加することができます。2番目のパーティションが完全にデコードされる前に2番目のパーティションのデコードを開始できるフレームタグ内の長さフィールドは、2番目の「ブロックAT-A-A-AT-A-A-AT-A」デコーダー実装に必要です。"
    },
    {
      "indent": 3,
      "text": "All partitions are decoded using separate instances of the boolean entropy decoder described in Section 7. Although some of the data represented within the partitions is conceptually \"flat\" (a bit is just a bit with no probabilistic expectation one way or the other), because of the way such coders work, there is never a direct correspondence between a \"conceptual bit\" and an actual physical bit in the compressed data partitions. Only in the 3- or 10-byte uncompressed chunk described above is there such a physical correspondence.",
      "ja": "すべてのパーティションは、セクション7で説明されているブールエントロピーデコーダーの個別のインスタンスを使用してデコードされます。パーティション内で表されるデータの一部は概念的に「フラット」です（ほんの少しだけ確率的な期待がない場合は少しだけです）。そのようなコーダーの仕組みについては、「概念的なビット」と圧縮データパーティションの実際の物理的ビットとの間に直接的な対応がありません。上記の3バイトまたは10バイトの非圧縮チャンクでのみ、そのような物理的対応があります。"
    },
    {
      "indent": 3,
      "text": "A related matter is that seeking within a partition is not supported. The data must be decompressed and processed (or at least stored) in the order in which it occurs in the partition.",
      "ja": "関連する問題は、パーティション内を探すことがサポートされていないことです。データは、パーティションで発生する順序で解凍および処理（または少なくとも保存）する必要があります。"
    },
    {
      "indent": 3,
      "text": "While this document specifies the ordering of the partition data correctly, the details and semantics of this data are discussed in a more logical fashion to facilitate comprehension. For example, the frame header contains updates to many probability tables used in decoding per-macroblock data. The per-macroblock data is often described before the layouts of the probabilities and their updates, even though this is the opposite of their order in the bitstream.",
      "ja": "このドキュメントはパーティションデータの順序付けを正しく指定していますが、このデータの詳細とセマンティクスは、理解を促進するために、より論理的な方法で説明されています。たとえば、フレームヘッダーには、マクロブロックごとのデータのデコードに使用される多くの確率テーブルへの更新が含まれています。マクロブロックごとのデータは、ビットストリームでの注文の反対であるにもかかわらず、確率とその更新のレイアウトの前にしばしば説明されます。"
    },
    {
      "indent": 0,
      "text": "5. Overview of the Decoding Process",
      "section_title": true,
      "ja": "5. デコードプロセスの概要"
    },
    {
      "indent": 3,
      "text": "A VP8 decoder needs to maintain four YUV frame buffers whose resolutions are at least equal to that of the encoded image. These buffers hold the current frame being reconstructed, the immediately previous reconstructed frame, the most recent golden frame, and the most recent altref frame.",
      "ja": "VP8デコーダーは、エンコードされた画像の解像度と少なくとも等しい4つのYUVフレームバッファーを維持する必要があります。これらのバッファーは、再構築されている現在のフレーム、前回の再構築されたフレーム、最新のゴールデンフレーム、および最新のAltrefフレームを保持します。"
    },
    {
      "indent": 3,
      "text": "Most implementations will wish to \"pad\" these buffers with \"invisible\" pixels that extend a moderate number of pixels beyond all four edges of the visible image. This simplifies interframe prediction by allowing all (or most) prediction blocks -- which are not guaranteed to lie within the visible area of a prior frame -- to address usable image data.",
      "ja": "ほとんどの実装では、これらのバッファーを「目に見えない」ピクセルで「パッド」し、可視画像の4つのエッジすべてを超える中程度のピクセルを伸ばします。これにより、使用可能な画像データに対処するために、以前のフレームの可視領域内にあるすべての（またはほとんどの）予測ブロックを許可することにより、フレーム間予測が簡素化されます。"
    },
    {
      "indent": 3,
      "text": "Regardless of the amount of padding chosen, the invisible rows above (or below) the image are filled with copies of the top (or bottom) row of the image; the invisible columns to the left (or right) of the image are filled with copies of the leftmost (or rightmost) visible row; and the four invisible corners are filled with copies of the corresponding visible corner pixels. The use of these prediction buffers (and suggested sizes for the halo) will be elaborated on in the discussion of motion vectors, interframe prediction, and sub-pixel interpolation later in this document.",
      "ja": "選択したパディングの量に関係なく、画像の上（または下）の目に見えない行は、画像の上部（または下部）行のコピーで満たされています。画像の左（または右）の目に見えない列には、左端（または右端）の目に見える行のコピーが入っています。そして、4つの目に見えないコーナーには、対応する可視コーナーピクセルのコピーが入っています。これらの予測バッファーの使用（およびHALOの推奨サイズ）は、このドキュメントの後半でモーションベクトル、インターフレーム予測、およびサブピクセルの補間の議論で詳しく説明されます。"
    },
    {
      "indent": 3,
      "text": "As will be seen in the description of the frame header, the image dimensions are specified (and can change) with every key frame. These buffers (and any other data structures whose size depends on the size of the image) should be allocated (or re-allocated) immediately after the dimensions are decoded.",
      "ja": "フレームヘッダーの説明に見られるように、すべてのキーフレームで画像の寸法が指定されています（および変更される可能性があります）。これらのバッファー（およびサイズが画像のサイズに依存する他のデータ構造）は、寸法が解読された直後に割り当て（または再割り当て）する必要があります。"
    },
    {
      "indent": 3,
      "text": "Leaving most of the details for later elaboration, the following is an outline of the decoding process.",
      "ja": "詳細のほとんどを後の詳細のために残して、以下はデコードプロセスの概要です。"
    },
    {
      "indent": 3,
      "text": "First, the frame header (the beginning of the first data partition) is decoded. Altering or augmenting the maintained state of the decoder, this provides the context in which the per-macroblock data can be interpreted.",
      "ja": "まず、フレームヘッダー（最初のデータパーティションの開始）がデコードされます。デコーダーの維持状態を変更または増強すると、これにより、マクロブロックごとのデータを解釈できるコンテキストが提供されます。"
    },
    {
      "indent": 3,
      "text": "The macroblock data occurs (and must be processed) in raster-scan order. This data comes in two or more parts. The first (prediction or mode) part comes in the remainder of the first data partition. The other parts comprise the data partition(s) for the DCT/WHT coefficients of the residue signal. For each macroblock, the prediction data must be processed before the residue.",
      "ja": "マクロブロックデータは、ラスタースキャン順序で発生します（および処理する必要があります）。このデータには2つ以上の部分があります。最初の（予測またはモード）部分は、最初のデータパーティションの残りの部分にあります。他の部分は、残基信号のDCT/WHT係数のデータパーティションを構成します。各マクロブロックについて、予測データは残基の前に処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each macroblock is predicted using one (and only one) of four possible frames. All macroblocks in a key frame, and all intra-coded macroblocks in an interframe, are predicted using the already-decoded macroblocks in the current frame. Macroblocks in an interframe may also be predicted using the previous frame, the golden frame, or the altref frame. Such macroblocks are said to be inter-coded.",
      "ja": "各マクロブロックは、4つの可能なフレームのうち1つ（および1つだけ）を使用して予測されます。キーフレーム内のすべてのマクロブロック、およびインターフレーム内のすべてのコード化されたマクロブロックは、現在のフレームの既にゼロのマクロブロックを使用して予測されます。インターフレーム内のマクロブロックは、以前のフレーム、ゴールデンフレーム、またはaltRefフレームを使用して予測することもできます。このようなマクロブロックは、インターコード化されていると言われています。"
    },
    {
      "indent": 3,
      "text": "The purpose of prediction is to use already-constructed image data to approximate the portion of the original image being reconstructed. The effect of any of the prediction modes is then to write a macroblock-sized prediction buffer containing this approximation.",
      "ja": "予測の目的は、すでに構成されている画像データを使用して、再構築されている元の画像の部分を近似することです。予測モードのいずれかの効果は、この近似を含むマクロブロックサイズの予測バッファーを記述することです。"
    },
    {
      "indent": 3,
      "text": "Regardless of the prediction method, the residue DCT signal is decoded, dequantized, reverse-transformed, and added to the prediction buffer to produce the (almost final) reconstruction value of the macroblock, which is stored in the correct position of the current frame buffer.",
      "ja": "予測方法に関係なく、残基DCT信号はデコード、非定量化、逆変換、および予測バッファーに追加され、現在のフレームバッファーの正しい位置に保存されているマクロブロックの（ほぼ最終的な）再構成値を生成します。。"
    },
    {
      "indent": 3,
      "text": "The residue signal consists of 24 (sixteen Y, four U, and four V) 4x4 quantized and losslessly compressed DCT transforms approximating the difference between the original macroblock in the uncompressed source and the prediction buffer. For most prediction modes, the 0th coefficients of the sixteen Y subblocks are expressed via a 25th WHT of the second-order virtual Y2 subblock discussed above.",
      "ja": "残基信号は、24（16 Y、4 U、および4つのV）4x4の量子化されていない圧縮されたDCT変換で構成され、非圧縮ソースの元のマクロブロックと予測バッファーの差に近似します。ほとんどの予測モードでは、16のYサブブロックの0番目の係数は、上記の2次仮想Y2サブブロックの25番目のWHTで表されます。"
    },
    {
      "indent": 3,
      "text": "Intra-prediction exploits the spatial coherence of frames. The 16x16 luma (Y) and 8x8 chroma (UV) components are predicted independently of each other using one of four simple means of pixel propagation, starting from the already-reconstructed (16-pixel-long luma, 8-pixel-long chroma) row above, and column to the left of, the current macroblock. The four methods are:",
      "ja": "予測内は、フレームの空間的一貫性を悪用します。16x16 Luma（y）および8x8 Chroma（UV）コンポーネントは、既に再構築された（16ピクセルの長さのLuma、8ピクセル長クロマ）から始まるピクセル伝播の4つの単純な手段のいずれかを使用して、互いに独立して予測されます。上の列、左側の列、現在のマクロブロック。4つの方法は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Copying the row from above throughout the prediction buffer.",
      "ja": "1. 予測バッファー全体で上から行をコピーします。"
    },
    {
      "indent": 3,
      "text": "2. Copying the column from the left throughout the prediction buffer.",
      "ja": "2. 予測バッファー全体で左から列をコピーします。"
    },
    {
      "indent": 3,
      "text": "3. Copying the average value of the row and column throughout the prediction buffer.",
      "ja": "3. 予測バッファー全体で行と列の平均値をコピーします。"
    },
    {
      "indent": 3,
      "text": "4. Extrapolation from the row and column using the (fixed) second difference (horizontal and vertical) from the upper left corner.",
      "ja": "4. 左上隅から（固定）2番目の差（水平および垂直）を使用して、行と列からの外挿。"
    },
    {
      "indent": 3,
      "text": "Additionally, the sixteen Y subblocks may be predicted independently of each other using one of ten different modes, four of which are 4x4 analogs of those described above, augmented with six \"diagonal\" prediction methods. There are two types of predictions, one intra and one prediction (among all the modes), for which the residue signal does not use the Y2 block to encode the DC portion of the sixteen 4x4 Y subblock DCTs. This \"independent Y subblock\" mode has no effect on the 8x8 chroma prediction.",
      "ja": "さらに、16のYサブブロックは、10の異なるモードのいずれかを使用して互いに独立して予測される場合があります。そのうち4つは上記の4x4アナログで、6つの「対角線」予測方法で補強されています。予測には、1つの予測と1つの予測（すべてのモードの間）の2つのタイプがあり、残基信号はY2ブロックを使用して16の4x4 YサブブロックDCTのDC部分をエンコードしません。この「独立したYサブブロック」モードは、8x8クロマ予測に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "Inter-prediction exploits the temporal coherence between nearby frames. Except for the choice of the prediction frame itself, there is no difference between inter-prediction based on the previous frame and that based on the golden frame or altref frame.",
      "ja": "相互投与は、近くのフレーム間の時間的一貫性を悪用します。予測フレーム自体の選択を除いて、前のフレームに基づいた相互予測とゴールデンフレームまたはアルトレフフレームに基づく違いはありません。"
    },
    {
      "indent": 3,
      "text": "Inter-prediction is conceptually very simple. While, for reasons of efficiency, there are several methods of encoding the relationship between the current macroblock and corresponding sections of the prediction frame, ultimately each of the sixteen Y subblocks is related to a 4x4 subblock of the prediction frame, whose position in that frame differs from the current subblock position by a (usually small) displacement. These two-dimensional displacements are called motion vectors.",
      "ja": "相互投影は概念的に非常に単純です。効率の理由から、現在のマクロブロックと予測フレームの対応するセクションとの間に関係をエンコードする方法がいくつかありますが、最終的には16のYサブブロックのそれぞれが、そのフレームの位置の4x4サブブロックの4x4サブブロックに関連しています。現在のサブブロック位置とは、（通常は小さな）変位によって異なります。これらの2次元変位は、モーションベクトルと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The motion vectors used by VP8 have quarter-pixel precision. Prediction of a subblock using a motion vector that happens to have integer (whole number) components is very easy: The 4x4 block of pixels from the displaced block in the previous, golden, or altref frame is simply copied into the correct position of the current macroblock's prediction buffer.",
      "ja": "VP8が使用するモーションベクトルには、クォーターピクセル精度があります。整数（整数）コンポーネントを持つモーションベクトルを使用したサブブロックの予測は非常に簡単です。前の、金色、またはAltRefフレームの変位ブロックからのピクセルの4x4ブロックは、電流の正しい位置にコピーされますマクロブロックの予測バッファー。"
    },
    {
      "indent": 3,
      "text": "Fractional displacements are conceptually and implementationally more complex. They require the inference (or synthesis) of sample values that, strictly speaking, do not exist. This is one of the most basic problems in signal processing, and readers conversant with that subject will see that the approach taken by VP8 provides a good balance of robustness, accuracy, and efficiency.",
      "ja": "分数変位は、概念的および実装的により複雑です。厳密に言えば、存在しないサンプル値の推論（または合成）が必要です。これは信号処理における最も基本的な問題の1つであり、その主題に精通している読者は、VP8が取るアプローチが堅牢性、精度、効率の良いバランスを提供することを確認するでしょう。"
    },
    {
      "indent": 3,
      "text": "Leaving the details for the implementation discussion below, the pixel interpolation is calculated by applying a kernel filter (using reasonable-precision integer math) three pixels on either side, both horizontally and vertically, of the pixel to be synthesized. The resulting 4x4 block of synthetic pixels is then copied into position exactly as in the case of integer displacements.",
      "ja": "以下の実装ディスカッションの詳細を残して、ピクセル補間は、合成されるピクセルの水平および垂直方向の両方の側に3ピクセルのカーネルフィルター（合理的な整数数学を使用）を適用することにより計算されます。結果の合成ピクセルの4x4ブロックは、整数変位の場合とまったく同じ位置にコピーされます。"
    },
    {
      "indent": 3,
      "text": "Each of the eight chroma subblocks is handled similarly. Their motion vectors are never specified explicitly; instead, the motion vector for each chroma subblock is calculated by averaging the vectors of the four Y subblocks that occupy the same area of the frame. Since chroma pixels have twice the diameter (and four times the area) of luma pixels, the calculated chroma motion vectors have 1/8-pixel resolution, but the procedure for copying or generating pixels for each subblock is essentially identical to that done in the luma plane.",
      "ja": "8つのクロマサブブロックのそれぞれは、同様に処理されます。それらのモーションベクトルは、明示的に指定されることはありません。代わりに、各クロマサブブロックのモーションベクトルは、フレームの同じ領域を占める4つのyサブブロックのベクトルを平均することによって計算されます。クロマピクセルはルーマピクセルの直径（および面積の4倍）の2倍のため、計算されたクロマモーションベクトルは1/8ピクセルの解像度を持っていますが、各サブブロックのピクセルをコピーまたは生成する手順は、本質的に同一に同一ですルマ平面。"
    },
    {
      "indent": 3,
      "text": "After all the macroblocks have been generated (predicted and corrected with the DCT/WHT residue), a filtering step (the loop filter) is applied to the entire frame. The purpose of the loop filter is to reduce blocking artifacts at the boundaries between macroblocks and between subblocks of the macroblocks. The term \"loop filter\" is used because this filter is part of the \"coding loop\"; that is, it affects the reconstructed frame buffers that are used to predict ensuing frames. This is distinguished from the postprocessing filters discussed earlier, which affect only the viewed video and do not \"feed into\" subsequent frames.",
      "ja": "すべてのマクロブロックが生成された後（DCT/WHT残基で予測および修正）、フィルタリングステップ（ループフィルター）がフレーム全体に適用されます。ループフィルターの目的は、マクロブロック間とマクロブロックのサブブロック間の境界でのブロッキングアーティファクトを減らすことです。このフィルターは「コーディングループ」の一部であるため、「ループフィルター」という用語が使用されます。つまり、次のフレームを予測するために使用される再構築されたフレームバッファーに影響します。これは、前述のポストプロセスフィルターとは区別されます。これは、視聴されたビデオのみに影響を与え、後続のフレームに「フィード」しません。"
    },
    {
      "indent": 3,
      "text": "Next, if signaled in the data, the current frame may replace the golden frame prediction buffer and/or the altref frame buffer.",
      "ja": "次に、データで信号がある場合、電流フレームはゴールデンフレーム予測バッファーおよび/またはAltRefフレームバッファを置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "The halos of the frame buffers are next filled as specified above. Finally, at least as far as decoding is concerned, the (references to) the \"current\" and \"last\" frame buffers should be exchanged in preparation for the next frame.",
      "ja": "フレームバッファーのハローは、上記で指定されているように次に満たされます。最後に、少なくともデコードに関する限り、「電流」と「最後の」フレームバッファー（次のフレームの準備）を交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Various processes may be required (or desired) before viewing the generated frame. As discussed in the frame dimension information below, truncation and/or upscaling of the frame may be required. Some playback systems may require a different frame format (RGB, YUY2, etc.). Finally, as mentioned in the Introduction, further postprocessing or filtering of the image prior to viewing may be desired. Since the primary purpose of this document is a decoding specification, the postprocessing is not specified in this document.",
      "ja": "生成されたフレームを表示する前に、さまざまなプロセスが必要になる（または目的）。以下のフレーム寸法情報で説明したように、フレームの切り捨ておよび/またはアップスケーリングが必要になる場合があります。一部の再生システムには、異なるフレーム形式（RGB、YUY2など）が必要になる場合があります。最後に、導入部で述べたように、表示する前に画像をさらに後処理またはフィルタリングすることが望ましい場合があります。このドキュメントの主な目的はデコード仕様であるため、このドキュメントではポストプロセスが指定されていません。"
    },
    {
      "indent": 3,
      "text": "While the basic ideas of prediction and correction used by VP8 are straightforward, many of the details are quite complex. The management of probabilities is particularly elaborate. Not only do the various modes of intra-prediction and motion vector specification have associated probabilities, but they, together with the coding of DCT coefficients and motion vectors, often base these probabilities on a variety of contextual information (calculated from what has been decoded so far), as well as on explicit modification via the frame header.",
      "ja": "VP8が使用する予測と修正の基本的なアイデアは簡単ですが、詳細の多くは非常に複雑です。確率の管理は特に精巧です。予測内および運動ベクター仕様のさまざまなモードには関連確率が関連付けられているだけでなく、DCT係数と運動ベクトルのコーディングとともに、これらの確率がさまざまなコンテキスト情報に基づいていることがよくあります（デコードされたものから計算されたものFAR）、およびフレームヘッダーを介した明示的な変更時。"
    },
    {
      "indent": 3,
      "text": "The \"top-level\" of decoding and frame reconstruction is implemented in the reference decoder file dixie.c (Section 20.4).",
      "ja": "デコードとフレームの再構築の「トップレベル」は、参照デコーダーファイルdixie.c（セクション20.4）に実装されています。"
    },
    {
      "indent": 3,
      "text": "This concludes our summary of decoding and reconstruction; we continue by discussing the individual aspects in more depth.",
      "ja": "これで、デコードと再構築の概要を締めくくります。私たちは、個々の側面についてもっと深く話し合うことによって続けます。"
    },
    {
      "indent": 3,
      "text": "A reasonable \"divide and conquer\" approach to implementation of a decoder is to begin by decoding streams composed exclusively of key frames. After that works reliably, interframe handling can be added more easily than if complete functionality were attempted",
      "ja": "デコーダーの実装に対する合理的な「分割と征服」アプローチは、キーフレームのみで構成されるストリームをデコードすることから始めることです。その後、確実に機能した後、完全な機能が試行された場合よりも、インターフレームの取り扱いを簡単に追加できます"
    },
    {
      "indent": 3,
      "text": "immediately. In accordance with this, we first discuss components needed to decode key frames (most of which are also used in the decoding of interframes) and conclude with topics exclusive to interframes.",
      "ja": "すぐに。これに従って、最初にキーフレームをデコードするために必要なコンポーネント（そのほとんどはインターフレームのデコードでも使用されています）について説明し、インターフレーム専用のトピックで締めくくります。"
    },
    {
      "indent": 0,
      "text": "6. Description of Algorithms",
      "section_title": true,
      "ja": "6. アルゴリズムの説明"
    },
    {
      "indent": 3,
      "text": "As the intent of this document, together with the reference decoder source code, is to specify a platform-independent procedure for the decoding and reconstruction of a VP8 video stream, many (small) algorithms must be described exactly.",
      "ja": "このドキュメントの意図は、参照デコーダーソースコードとともに、VP8ビデオストリームのデコードと再構築のためのプラットフォームに依存しない手順を指定することであるため、多くの（小さな）アルゴリズムを正確に説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "Due to its near-universality, terseness, ability to easily describe calculation at specific precisions, and the fact that On2's reference VP8 decoder is written in C, these algorithm fragments are written using the C programming language, augmented with a few simple definitions below.",
      "ja": "近くの大学、界面活性、特定の精度で計算を簡単に説明する能力、およびOn2の参照VP8デコーダーがCで記述されているという事実により、これらのアルゴリズムフラグメントは、以下のいくつかの簡単な定義で補強されたCプログラミング言語を使用して記述されます。"
    },
    {
      "indent": 3,
      "text": "The standard (and best) reference for C is [Kernighan].",
      "ja": "Cの標準（および最良の）参照は[Kernighan]です。"
    },
    {
      "indent": 3,
      "text": "Many code fragments will be presented in this document. Some will be nearly identical to corresponding sections of the reference decoder; others will differ. Roughly speaking, there are three reasons for such differences:",
      "ja": "このドキュメントでは、多くのコードフラグメントが表示されます。一部は、参照デコーダーの対応するセクションとほぼ同じです。他の人は異なります。大事に言えば、そのような違いには3つの理由があります。"
    },
    {
      "indent": 3,
      "text": "1. For reasons of efficiency, the reference decoder version may be less obvious.",
      "ja": "1. 効率の理由から、参照デコーダーバージョンの明白なものはそれほど明白ではない場合があります。"
    },
    {
      "indent": 3,
      "text": "2. The reference decoder often uses large data structures to maintain context that need not be described or used here.",
      "ja": "2. 参照デコーダーは、多くの場合、大きなデータ構造を使用して、ここで説明または使用する必要がないコンテキストを維持します。"
    },
    {
      "indent": 3,
      "text": "3. The authors of this document felt that a different expression of the same algorithm might facilitate exposition.",
      "ja": "3. この文書の著者は、同じアルゴリズムの異なる式が博覧会を促進する可能性があると感じました。"
    },
    {
      "indent": 3,
      "text": "Regardless of the chosen presentation, the calculation effected by any of the algorithms described here is identical to that effected by the corresponding portion of the reference decoder.",
      "ja": "選択したプレゼンテーションに関係なく、ここで説明するアルゴリズムのいずれかによって影響される計算は、参照デコーダーの対応する部分によって影響されるものと同一です。"
    },
    {
      "indent": 3,
      "text": "All VP8 decoding algorithms use integer math. To facilitate specification of arithmetic precision, we define the following types.",
      "ja": "すべてのVP8デコードアルゴリズムは整数数学を使用します。算術精度の仕様を容易にするために、次のタイプを定義します。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef   signed char  int8; /* signed int exactly 8 bits wide */\ntypedef unsigned char uint8; /* unsigned \"\" */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef short int16;         /* signed int exactly 16 bits wide */\ntypedef unsigned int16 uint16; /* unsigned \"\" */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* int32 is a signed integer type at least 32 bits wide */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef long int32; /* guaranteed to work on all systems */\ntypedef int  int32; /* will be more efficient on some systems */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef unsigned int32 uint32;",
      "ja": "typedef unsigned int32 uint32;"
    },
    {
      "indent": 3,
      "text": "/* unsigned integer type, at least 16 bits wide, whose exact size\n   is most convenient to whatever processor we are using */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef unsigned int uint;",
      "ja": "typedef unsigned int uint;"
    },
    {
      "indent": 3,
      "text": "/* While pixels themselves are 8-bit unsigned integers,\n   pixel arithmetic often occurs at 16- or 32-bit precision and\n   the results need to be \"saturated\" or clamped to an 8-bit\n   range. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef uint8 Pixel;",
      "ja": "typedef uint8 pixel;"
    },
    {
      "indent": 3,
      "text": "Pixel clamp255(int32 v) { return v < 0? 0 : (v < 255? v : 255);}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*  As is elaborated in the discussion of the bool_decoder below,\n    VP8 represents probabilities as unsigned 8-bit numbers. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef uint8 Prob;",
      "ja": "typedef uint8 prob;"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We occasionally need to discuss mathematical functions involving honest-to-goodness \"infinite precision\" real numbers. The DCT is first described via the cosine function cos; the ratio of the lengths of the circumference and diameter of a circle is denoted pi; at one point, we take a (base 1/2) logarithm, denoted log; and pow(x, y) denotes x raised to the power y. If x = 2 and y is a small non-negative integer, pow(2, y) may be expressed in C as 1 << y.",
      "ja": "時折、誠実さの「無限の精度」の実数を含む数学的機能について議論する必要があります。DCTは、COSINE関数COSを介して最初に説明されています。円周囲の長さと円の直径の比は、Piと表されます。ある時点で、（ベース1/2）の対数を撮影します。Pow（x、y）は、xをパワーyに上げたxを示します。x = 2およびyが小さな非陰性整数である場合、c（2、y）はcで1 << yとして発現できます。"
    },
    {
      "indent": 3,
      "text": "Finally, we sometimes need to divide signed integers by powers of two; that is, we occasionally right-shift signed numbers. The behavior of such shifts (i.e., the propagation of the sign bit) is, perhaps surprisingly, not defined by the C language itself and is left up to individual compilers. Because of the utility of this frequently needed operation, it is at least arguable that it should be defined by the language (to naturally propagate the sign bit) and, at a minimum, should be correctly implemented by any reasonable compiler. In the interest of strict portability, we attempt to call attention to these shifts when they arise.",
      "ja": "最後に、署名された整数を2つのパワーで分割する必要がある場合があります。つまり、時々右に署名された数字です。そのようなシフトの動作（つまり、サインビットの伝播）は、おそらく驚くべきことに、C言語自体によって定義されておらず、個々のコンパイラに任されています。この頻繁に必要な操作の有用性のため、言語によって定義する必要があることは少なくとも議論の余地があります（サインビットを自然に伝播するために）、少なくとも合理的なコンパイラによって正しく実装される必要があります。厳格な携帯性のために、これらのシフトが発生したときに注意を喚起しようとします。"
    },
    {
      "indent": 0,
      "text": "7. Boolean Entropy Decoder",
      "section_title": true,
      "ja": "7. ブールエントロピーデコーダー"
    },
    {
      "indent": 3,
      "text": "As discussed in the overview above, essentially the entire VP8 data stream is encoded using a boolean entropy coder.",
      "ja": "上記の概要で説明したように、基本的にVP8データストリーム全体がブールエントロピーコーダーを使用してエンコードされます。"
    },
    {
      "indent": 3,
      "text": "An understanding of the bool_decoder is critical to the implementation of a VP8 decompressor, so we discuss the bool_decoder in detail. It is easier to comprehend the bool_decoder in conjunction with the bool_encoder used by the compressor to write the compressed data partitions.",
      "ja": "BOOL_DECODERの理解は、VP8減圧器の実装にとって重要であるため、BOOL_DECODERについて詳しく説明します。圧縮データパーティションを書き込むためにコンプレッサーが使用するbool_encoderと組み合わせてbool_decoderを理解する方が簡単です。"
    },
    {
      "indent": 3,
      "text": "The bool_encoder encodes (and the bool_decoder decodes) one bool (zero-or-one boolean value) at a time. Its purpose is to losslessly compress a sequence of bools for which the probability of their being zero or one can be well-estimated (via constant or previously coded information) at the time they are written, using identical corresponding probabilities at the time they are read.",
      "ja": "bool_encoderは、一度に1つのブール（ゼロまたは1つのブール値）をエンコードします（およびbool_decoderデコード）。その目的は、ゼロまたは1つが書かれている時点で（一定または以前にコード化された情報を介して）ゼロまたは1つを保護することができる一連のブールを損なうことです。。"
    },
    {
      "indent": 3,
      "text": "As the reader is probably aware, if a bool is much more likely to be zero than one (for instance), it can, on average, be faithfully encoded using much less than one bit per value. The bool_encoder exploits this.",
      "ja": "読者はおそらく認識しているように、ブールが（たとえば）（たとえば）よりもはるかにゼロである可能性がはるかに高い場合、平均して、値ごとに1ビット未満を使用して忠実にエンコードできます。bool_encoderはこれを悪用します。"
    },
    {
      "indent": 3,
      "text": "In the 1940s, [Shannon] proved that there is a lower bound for the average datarate of a faithful encoding of a sequence of bools (whose probability distributions are known and are independent of each other) and also that there are encoding algorithms that approximate this lower bound as closely as one wishes.",
      "ja": "1940年代に、[シャノン]は、一連のブールの忠実なエンコードの平均データの平均データ（確率分布が既知であり、互いに独立している）の下限があることを証明し、またこれに近似するエンコードアルゴリズムがあることも証明しました。希望するほど密接に下限。"
    },
    {
      "indent": 3,
      "text": "If we encode a sequence of bools whose probability of being zero is p (and whose probability of being 1 is 1-p), the lowest possible datarate per value is",
      "ja": "ゼロである確率がpである（および1である確率が1-p）ブールのシーケンスをエンコードすると、値ごとの最低のデータレー酸塩は値です。"
    },
    {
      "indent": 3,
      "text": "plog(p) + (1-p)log(1-p);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "taking the logarithms to the base 1/2 expresses the datarate in bits/ value.",
      "ja": "対数をベース1/2に使用すると、データレートがビット/値で表されます。"
    },
    {
      "indent": 3,
      "text": "We give two simple examples. At one extreme, if p = 1/2, then log(p) = log(1-p) = 1, and the lowest possible datarate per bool is 1/2 + 1/2 = 1; that is, we cannot do any better than simply literally writing out bits. At another extreme, if p is very small, say p = 1/1024, then log(p)=10, log(1-p) is roughly .0014, and the lowest possible datarate is approximately 10/1024 + .0014, roughly 1/100 of a bit per bool.",
      "ja": "2つの簡単な例を示します。1つの極端で、p = 1/2の場合、log（p）= log（1-p）= 1、およびブールあたりの可能な最低のデータレートは1/2 1/2 = 1です。つまり、単に文字通りビットを書き出すよりも良いことはできません。別の極端では、pが非常に小さい場合、たとえばp = 1/1024、log（p）= 10、log（1-p）は約.0014であり、可能な限り低いデータラートは約10/1024 .0014で、おおよそ約10/1024 .0014です。ブールごとに1/100。"
    },
    {
      "indent": 3,
      "text": "Because most of the bools in the VP8 datastream have zero-probabilities nowhere near 1/2, the compression provided by the bool_encoder is critical to the performance of VP8.",
      "ja": "VP8 DataStreamのブールのほとんどは、1/2近くにゼロプロビリティを持っているため、bool_encoderによって提供される圧縮はVP8のパフォーマンスにとって重要です。"
    },
    {
      "indent": 3,
      "text": "The boolean coder used by VP8 is a variant of an arithmetic coder. An excellent discussion of arithmetic coding (and other lossless compression techniques) can be found in [Bell].",
      "ja": "VP8が使用するブールコーダーは、算術コーダーのバリアントです。算術コーディング（およびその他のロスレス圧縮技術）の優れた議論は、[ベル]にあります。"
    },
    {
      "indent": 0,
      "text": "7.1. Underlying Theory of Coding",
      "section_title": true,
      "ja": "7.1. コーディングの根底にある理論"
    },
    {
      "indent": 3,
      "text": "The basic idea used by the boolean coder is to consider the entire data stream (either of the partitions in our case) as the binary expansion of a single number x with 0 <= x < 1. The bits (or bytes) in x are of course written from high to low order, and if b[j] (B[j]) is the j^(th) bit (byte) in the partition, the value x is simply the sum (starting with j = 1) of pow(2, -j) * b[j] or pow(256, -j) * B[j].",
      "ja": "ブールコーダーが使用する基本的なアイデアは、データストリーム全体（私たちの場合のパーティションのいずれか）を0 <= x <1の単一の数値xのバイナリ拡張と見なすことです。xのビット（またはバイト）はです。もちろん、高度から低いものから低いもの、そしてb [j]（b [j]）がパーティションのj^（th）ビット（byte）である場合、値xは単に合計です（j = 1で始まる）Pow（2、-J） * B [J]またはPOW（256、-J） * B [J]。"
    },
    {
      "indent": 3,
      "text": "Before the first bool is coded, all values of x are possible.",
      "ja": "最初のブールがコーディングされる前に、xのすべての値が可能です。"
    },
    {
      "indent": 3,
      "text": "The coding of each bool restricts the possible values of x in proportion to the probability of what is coded. If p1 is the probability of the first bool being zero and a zero is coded, the range of possible values of x is restricted to 0 <= x < p1. If a one is coded, the range becomes p1 <= x < 1.",
      "ja": "各ブールのコーディングは、コード化されたものの確率に比例してxの可能な値を制限します。P1が最初のブールがゼロであり、ゼロがコード化される確率である場合、xの可能な値の範囲は0 <= x <p1に制限されます。1つがコーディングされている場合、範囲はp1 <= x <1になります。"
    },
    {
      "indent": 3,
      "text": "The coding continues by repeating the same idea. At every stage, there is an interval a <= x < b of possible values of x. If p is the probability of a zero being coded at this stage and a zero is coded, the interval becomes a <= x < a + (p(b-a)). If a one is coded, the possible values of x are restricted to a + (p(b-a)) <= x < b.",
      "ja": "コーディングは、同じアイデアを繰り返すことで継続します。すべての段階で、xの可能な値の間隔A <= x <bがあります。pがこの段階でゼロがコーディングされ、ゼロがコーディングされる確率である場合、間隔はa <= x <a（p（b-a））になります。1がコーディングされている場合、xの可能な値はa（p（b-a））<= x <bに制限されます。"
    },
    {
      "indent": 3,
      "text": "Assuming that only finitely many values are to be coded, after the encoder has received the last bool, it can write as its output any value x that lies in the final interval. VP8 simply writes the left endpoint of the final interval. Consequently, the output it would make if encoding were to stop at any time either increases or stays the same as each bool is encoded.",
      "ja": "エンコーダーが最後のブールを受信した後、有限数の値のみがコーディングされると仮定すると、最終間隔にある値xを出力すると書き込むことができます。VP8は、最終間隔の左のエンドポイントを単純に書き込むだけです。したがって、エンコードがいつでも停止する場合、各ブールがエンコードされるのと同じように停止する場合、それが行う出力が生じます。"
    },
    {
      "indent": 3,
      "text": "Decoding parallels encoding. The decoder is presented with the number x, which has only the initial restriction 0 <= x < 1. To decode the first bool, the decoder is given the first probability p1. If x < p1, a zero is decoded; if x >= p1, a one is decoded. In either case, the new restriction on x -- that is, the interval of possible values of x -- is remembered.",
      "ja": "デコードはエンコードに似ています。デコーダーには、最初の制限0 <= x <1のみがある数値xで表示されます。最初のブールをデコードするには、デコーダーに最初の確率p1が与えられます。x <p1の場合、ゼロがデコードされます。x> = p1の場合、1つはデコードされます。どちらの場合でも、xの新しい制限、つまりxの可能な値の間隔 - が記憶されています。"
    },
    {
      "indent": 3,
      "text": "Decoding continues in exactly the same way: If a <= x < b is the current interval and we are to decode a bool with zero-probability p, we return a zero if a <= x < a + (p(b-a)) and a one if a + (p(b-a)) <= x < b. In either case, the new restriction is remembered in preparation for decoding the next bool.",
      "ja": "デコードはまったく同じ方法で継続します。A<= x <bが現在の間隔であり、ゼロパロビーズ性pでブールをデコードする場合、a <= x <a（p（b-a））とゼロを返し、a（p（b-a））<= x <bの場合どちらの場合でも、次のブールのデコードに備えて新しい制限が記憶されています。"
    },
    {
      "indent": 3,
      "text": "The process outlined above uses real numbers of infinite precision to express the probabilities and ranges. It is true that, if one could actualize this process and coded a large number of bools whose supplied probabilities matched their value distributions, the datarate achieved would approach the theoretical minimum as the number of bools encoded increased.",
      "ja": "上記のプロセスでは、実数の無限の精度を使用して、確率と範囲を表現します。このプロセスを実現し、付属の確率が価値分布と一致する多数のブールをコーディングできれば、達成されたデータは、エンコードされたブールの数が増加するにつれて理論的最小に近づくでしょう。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, computers operate at finite precision, and an approximation to the theoretically perfect process described above is necessary. Such approximation increases the datarate but, at quite moderate precision and for a wide variety of data sets, this increase is negligible.",
      "ja": "残念ながら、コンピューターは有限精度で動作し、上記の理論的に完全なプロセスに近似することが必要です。このような近似はデータレートを増加させますが、非常に中程度の精度で、さまざまなデータセットの場合、この増加は無視できます。"
    },
    {
      "indent": 3,
      "text": "The only conceptual limitations are, first, that coder probabilities must be expressed at finite precision and, second, that the decoder be able to detect each individual modification to the value interval via examination of a fixed amount of input. As a practical matter, many of the implementation details stem from the fact that the coder can function using only a small \"window\" to incrementally read or write the arbitrarily precise number x.",
      "ja": "唯一の概念的な制限は、第一に、コーダーの確率を有限精度で表現する必要があり、次に、デコーダーが固定量の入力を調べて各個々の変更を値間隔に検出できることです。実用的な問題として、実装の詳細の多くは、コーダーが小さな「ウィンドウ」のみを使用して機能して、任意の正確な数字xを段階的に読み書きできるという事実に由来しています。"
    },
    {
      "indent": 0,
      "text": "7.2. Practical Algorithm Description",
      "section_title": true,
      "ja": "7.2. 実用的なアルゴリズムの説明"
    },
    {
      "indent": 3,
      "text": "VP8's boolean coder works with 8-bit probabilities p. The range of such p is 0 <= p <= 255; the actual probability represented by p is p/256. Also, the coder is designed so that decoding of a bool requires no more than an 8-bit comparison, and so that the state of both the encoder and decoder can be easily represented using a small number of unsigned 16-bit integers.",
      "ja": "VP8のブールコーダーは、8ビット確率で動作します。そのようなpの範囲は0 <= p <= 255です。pで表される実際の確率はp/256です。また、コーダーは、ブールのデコードに8ビットの比較を必要とするように設計されているため、エンコーダーとデコーダーの両方の状態を少数の署名されていない16ビット整数を使用して簡単に表現できます。"
    },
    {
      "indent": 3,
      "text": "The details are most easily understood if we first describe the algorithm using bit-at-a-time input and output. Aside from the ability to maintain a position in this bitstream and write/read bits, the encoder also needs the ability to add 1 to the bits already output; after writing n bits, adding 1 to the existing output is the same thing as adding pow(2, -n) to x.",
      "ja": "詳細は、最初に時間の入力と出力を使用してアルゴリズムを説明する場合に最も簡単に理解できます。このビットストリームでの位置を維持し、ビットを書き込み/読み取る機能は別として、エンコーダーは、すでに出力をビットに追加する機能も必要です。nビットを書き込んだ後、既存の出力に1を追加することは、pow（2、-n）をxに追加することと同じです。"
    },
    {
      "indent": 3,
      "text": "Together with the bit position, the encoder must maintain two unsigned 8-bit numbers, which we call \"bottom\" and \"range\". Writing w for the n bits already written and S = pow(2, - n - 8) for the scale of the current bit position one byte out, we have the following constraint on all future values v of w (including the final value v = x):",
      "ja": "ビット位置とともに、エンコーダーは「ボトム」と「範囲」と呼ばれる2つの署名されていない8ビット番号を維持する必要があります。既に書かれたnビットとs = pow（2、-n -8）のwを書き込む現在のビット位置1バイトのスケールについては、wのすべての将来の値v（最終値vを含むすべての将来の値vに次の制約があります= x）："
    },
    {
      "indent": 3,
      "text": "w + ( S * bottom ) <= v < w + ( S * ( bottom + range ) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Thus, appending bottom to the already-written bits w gives the left endpoint of the interval of possible values, appending bottom + range gives the right endpoint, and range itself (scaled to the current output position) is the length of the interval.",
      "ja": "したがって、既に書かれたビットwに底部を追加すると、可能な値の間隔の左のエンドポイントが得られ、底部の範囲が右のエンドポイントを与え、範囲自体（現在の出力位置にスケーリング）が間隔の長さです。"
    },
    {
      "indent": 3,
      "text": "So that our probabilistic encodings are reasonably accurate, we do not let range vary by more than a factor of two: It stays within the bounds 128 <= range <= 255.",
      "ja": "確率的エンコーディングが合理的に正確になるように、範囲を2倍以上変化させることはありません。"
    },
    {
      "indent": 3,
      "text": "The process for encoding a boolean value val whose probability of being zero is prob / 256 -- and whose probability of being one is ( 256 - prob ) / 256 -- with 1 <= prob <= 255 is as follows.",
      "ja": "ゼロである確率がprob / 256であり、1つである確率が（256 -prob） / 256であるというブール値Valをエンコードするプロセスは、1 <= prob <= 255で次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Using an unsigned 16-bit multiply followed by an unsigned right shift, we calculate an unsigned 8-bit split value:",
      "ja": "符号なしの16ビット乗算に続いて署名されていない右シフトを使用して、署名されていない8ビットスプリット値を計算します。"
    },
    {
      "indent": 3,
      "text": "split = 1 + (((range - 1) * probability)]] >> 8)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "split is approximately ( prob / 256 ) * range and lies within the bounds 1 <= split <= range - 1. These bounds ensure the correctness of the decoding procedure described below.",
      "ja": "スプリットは約（prob / 256） *範囲であり、境界1 <= split <=範囲-1。これらの境界は、以下で説明するデコード手順の正確性を保証します。"
    },
    {
      "indent": 3,
      "text": "If the incoming boolean val to be encoded is false, we leave the left interval endpoint bottom alone and reduce range, replacing it by split. If the incoming val is true, we move up the left endpoint to bottom + split, propagating any carry to the already-written value w (this is where we need the ability to add 1 to w), and reduce range to range - split.",
      "ja": "エンコードされる入っているブールバルがfalseである場合、左の間隔エンドポイントの底部のみを残して範囲を減らして、分割に置き換えます。着信バルが真の場合、左のエンドポイントを上に移動して、キャリーを既に書かれた値wに伝播します（これは1からwを追加する機能が必要です）。"
    },
    {
      "indent": 3,
      "text": "Regardless of the value encoded, range has been reduced and now has the bounds 1 <= range <= 254. If range < 128, the encoder doubles it and shifts the high-order bit out of bottom to the output as it also doubles bottom, repeating this process one bit at a time until 128 <= range <= 255. Once this is completed, the encoder is ready to accept another bool, maintaining the constraints described above.",
      "ja": "エンコードされた値に関係なく、範囲は削減され、現在は範囲1 <=範囲<= 254になりました。、このプロセスを一度に1つずつ繰り返し、128 <=範囲<= 255になります。これが完了すると、エンコーダは別のブールを受け入れる準備ができており、上記の制約を維持します。"
    },
    {
      "indent": 3,
      "text": "After encoding the last bool, the partition may be completed by appending bottom to the bitstream.",
      "ja": "最後のブールをエンコードした後、パーティションはビットストリームに底部を追加することで完了することができます。"
    },
    {
      "indent": 3,
      "text": "The decoder mimics the state of the encoder. It maintains, together with an input bit position, two unsigned 8-bit numbers, a range identical to that maintained by the encoder and a value. Decoding one bool at a time, the decoder (in effect) tracks the same left interval endpoint as does the encoder and subtracts it from the remaining input. Appending the unread portion of the bitstream to the 8-bit value gives the difference between the actual value encoded and the known left endpoint.",
      "ja": "デコーダーはエンコーダーの状態を模倣します。入力ビット位置とともに、2つの署名されていない8ビット数字が維持されます。これは、エンコーダーと値によって維持される範囲と同じ範囲です。一度に1つのブールを解読すると、デコーダー（効果的）は、エンコーダと同じ左の間隔エンドポイントを追跡し、残りの入力から減算します。ビットストリームの未読部分を8ビット値に追加すると、実際の値エンコードされた値と既知の左端ポイントの差が得られます。"
    },
    {
      "indent": 3,
      "text": "The decoder is initialized by setting range = 255 and reading the first 16 input bits into value. The decoder maintains range and calculates split in exactly the same way as does the encoder.",
      "ja": "デコーダーは、範囲= 255を設定し、最初の16の入力ビットを値に読み取ることによって初期化されます。デコーダーは範囲を維持し、エンコーダーとまったく同じ方法で分割されます。"
    },
    {
      "indent": 3,
      "text": "To decode a bool, it compares value to split; if value < split, the bool is zero, and range is replaced with split. If value >= split, the bool is one, range is replaced with range - split, and value is replaced with value - split.",
      "ja": "ブールをデコードすると、値を分割と比較します。値<分割の場合、ブールはゼロであり、範囲は分割に置き換えられます。値> =分割の場合、ブールは1、範囲は範囲に置き換えられ、値は値 - 分割に置き換えられます。"
    },
    {
      "indent": 3,
      "text": "Again, range is doubled one bit at a time until it is at least 128. The value is doubled in parallel, shifting a new input bit into the bottom each time.",
      "ja": "繰り返しますが、範囲は少なくとも128になるまで一度に1つずつ2倍になります。値は並行して2倍になり、毎回新しい入力ビットが底にシフトされます。"
    },
    {
      "indent": 3,
      "text": "Writing Value for value together with the unread input bits and Range for range extended indefinitely on the right by zeros, the condition Value < Range is maintained at all times by the decoder. In particular, the bits shifted out of value as it is doubled are always zero.",
      "ja": "値の書き込み値と未読の入力ビットと範囲の範囲の書き込みゼロは、ゼロによって無期限に拡張され、条件値<範囲は常にデコーダーによって維持されます。特に、2倍になっているため、ビットは常にゼロになっています。"
    },
    {
      "indent": 0,
      "text": "7.3. Actual Implementation",
      "section_title": true,
      "ja": "7.3. 実際の実装"
    },
    {
      "indent": 3,
      "text": "The C code below gives complete implementations of the encoder and decoder described above. While they are logically identical to the \"bit-at-a-time\" versions, they internally buffer a couple of extra bytes of the bitstream. This allows I/O to be done (more practically) a byte at a time and drastically reduces the number of carries the encoder has to propagate into the already-written data.",
      "ja": "以下のCコードは、上記のエンコーダーとデコーダーの完全な実装を示しています。それらは論理的に「一時的な」バージョンと同一ですが、ビットストリームのいくつかの追加バイトを内部的にバッファリングします。これにより、I/Oを（より実際に）一度にバイトを実行することができ、エンコーダーが既に書かれたデータに伝播するキャリーの数を大幅に削減できます。"
    },
    {
      "indent": 3,
      "text": "Another (logically equivalent) implementation may be found in the reference decoder file bool_decoder.h (Section 20.2).",
      "ja": "別の（論理的に同等の）実装は、参照デコーダーファイルbool_decoder.h（セクション20.2）に記載されています。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Encoder first */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef struct {\n  uint8 *output;  /* ptr to next byte to be written */\n  uint32 range;   /* 128 <= range <= 255 */\n  uint32 bottom;  /* minimum value of remaining output */\n  int bit_count;  /* # of shifts before an output byte\n                     is available */\n} bool_encoder;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Must set initial state of encoder before writing any bools. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void init_bool_encoder(bool_encoder *e, uint8 *start_partition)\n{\n  e->output = start_partition;\n  e->range = 255;\n  e->bottom = 0;\n  e->bit_count = 24;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Encoding very rarely produces a carry that must be propagated\n   to the already-written output.  The arithmetic guarantees that\n   the propagation will never go beyond the beginning of the\n   output.  Put another way, the encoded value x is always less\n   than one. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void add_one_to_output(uint8 *q)\n{\n  while (*--q == 255)\n    *q = 0;\n  ++*q;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Main function writes a bool_value whose probability of being\n   zero is (expected to be) prob/256. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void write_bool(bool_encoder *e, Prob prob, int bool_value)\n{\n  /* split is approximately (range * prob) / 256 and,\n     crucially, is strictly bigger than zero and strictly\n     smaller than range */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "uint32 split = 1 + (((e->range - 1) * prob) >> 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "if (bool_value) {\n  e->bottom += split; /* move up bottom of interval */\n  e->range -= split;  /* with corresponding decrease in range */\n} else\n  e->range = split;   /* decrease range, leaving bottom alone */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "while (e->range < 128)\n{\n  e->range <<= 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (e->bottom & (1 << 31))  /* detect carry */\n  add_one_to_output(e->output);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "e->bottom <<= 1;        /* before shifting bottom */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!--e->bit_count) {  /* write out high byte of bottom ... */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "*e->output++ = (uint8) (e->bottom >> 24);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "e->bottom &= (1 << 24) - 1;  /* ... keeping low 3 bytes */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "      e->bit_count = 8;            /* 8 shifts until next output */\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Call this function (exactly once) after encoding the last\n   bool value for the partition being written */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void flush_bool_encoder(bool_encoder *e)\n{\n  int c = e->bit_count;\n  uint32 v = e->bottom;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  if (v & (1 << (32 - c)))   /* propagate (unlikely) carry */\n    add_one_to_output(e->output);\n  v <<= c & 7;               /* before shifting remaining output */\n  c >>= 3;                   /* to top of internal buffer */\n  while (--c >= 0)\n    v <<= 8;\n  c = 4;\n  while (--c >= 0) {    /* write remaining data, possibly padded */\n    *e->output++ = (uint8) (v >> 24);\n    v <<= 8;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Decoder state exactly parallels that of the encoder.\n   \"value\", together with the remaining input, equals the\n   complete encoded number x less the left endpoint of the\n   current coding interval. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef struct {\n  uint8   *input;     /* pointer to next compressed data byte */\n  uint32  range;      /* always identical to encoder's range */\n  uint32  value;      /* contains at least 8 significant bits */\n  int     bit_count;  /* # of bits shifted out of\n                         value, at most 7 */\n} bool_decoder;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Call this function before reading any bools from the\n   partition. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void init_bool_decoder(bool_decoder *d, uint8 *start_partition)\n{\n  {\n    int i = 0;\n    d->value = 0;           /* value = first 2 input bytes */\n    while (++i <= 2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    d->value = (d->value << 8)  |  *start_partition++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  d->input = start_partition;  /* ptr to next byte to be read */\n  d->range = 255;           /* initial range is full */\n  d->bit_count = 0;         /* have not yet shifted out any bits */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Main function reads a bool encoded at probability prob/256,\n   which of course must agree with the probability used when the\n   bool was written. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int read_bool(bool_decoder *d, Prob prob)\n{\n  /* range and split are identical to the corresponding values\n     used by the encoder when this bool was written */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "uint32  split = 1 + (((d->range - 1) * prob) >> 8);\nuint32  SPLIT = split << 8;\nint     retval;           /* will be 0 or 1 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "if (d->value >= SPLIT) {  /* encoded a one */\n  retval = 1;\n  d->range -= split;  /* reduce range */\n  d->value -= SPLIT;  /* subtract off left endpoint of interval */\n} else {              /* encoded a zero */\n  retval = 0;\n  d->range = split;  /* reduce range, no change in left endpoint */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  while (d->range < 128) {  /* shift out irrelevant value bits */\n    d->value <<= 1;\n    d->range <<= 1;\n    if (++d->bit_count == 8) {  /* shift in new bits 8 at a time */\n      d->bit_count = 0;\n      d->value |= *d->input++;\n    }\n  }\n  return retval;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Convenience function reads a \"literal\", that is, a \"num_bits\"-\n   wide unsigned value whose bits come high- to low-order, with\n   each bit encoded at probability 128 (i.e., 1/2). */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uint32 read_literal(bool_decoder *d, int num_bits)\n{\n  uint32 v = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  while (num_bits--)\n    v = (v << 1) + read_bool(d, 128);\n  return v;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Variant reads a signed number */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int32 read_signed_literal(bool_decoder *d, int num_bits)\n{\n  int32 v = 0;\n  if (!num_bits)\n    return 0;\n  if (read_bool(d, 128))\n    v = -1;\n  while (--num_bits)\n    v = (v << 1) + read_bool(d, 128);\n  return v;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8. Compressed Data Components",
      "section_title": true,
      "ja": "8. 圧縮データコンポーネント"
    },
    {
      "indent": 3,
      "text": "At the lowest level, VP8's compressed data is simply a sequence of probabilistically encoded bools. Most of this data is composed of (slightly) larger semantic units fashioned from bools, which we describe here.",
      "ja": "最低レベルでは、VP8の圧縮データは、単に確率的にエンコードされたブールのシーケンスです。このデータのほとんどは、ここで説明するブールから作られた（わずかに）大きなセマンティックユニットで構成されています。"
    },
    {
      "indent": 3,
      "text": "We sometimes use these descriptions in C expressions within data format specifications. In this context, they refer to the return value of a call to an appropriate bool_decoder d, reading (as always) from its current reference point.",
      "ja": "これらの説明は、データ形式の仕様内でC式でc式で使用することがあります。この文脈では、適切なbool_decoder Dへの呼び出しの返品値を参照し、現在の基準点から（いつものように）読み取ります。"
    },
    {
      "indent": 3,
      "text": "+--------------+-------+--------------------------------------------+\n| Call         | Alt.  | Return                                     |\n+--------------+-------+--------------------------------------------+\n| Bool(p)      | B(p)  | Bool with probability p/256 of being 0.    |\n|              |       | Return value of read_bool(d, p).           |\n|              |       |                                            |\n| Flag         | F     | A one-bit flag (same thing as a B(128) or  |\n|              |       | an L(1)).  Abbreviated F.  Return value of |\n|              |       | read_bool(d, 128).                         |\n|              |       |                                            |\n| Lit(n)       | L(n)  | Unsigned n-bit number encoded as n flags   |\n|              |       | (a \"literal\").  Abbreviated L(n).  The     |\n|              |       | bits are read from high to low order.      |\n|              |       | Return value of read_literal(d, n).        |\n|              |       |                                            |\n| SignedLit(n) |       | Signed n-bit number encoded similarly to   |\n|              |       | an L(n).  Return value of                  |\n|              |       | read_signed_literal(d, n).  These are      |\n|              |       | rare.                                      |\n|              |       |                                            |\n| P(8)         |       | An 8-bit probability.  No different from   |\n|              |       | an L(8), but we sometimes use this         |\n|              |       | notation to emphasize that a probability   |\n|              |       | is being coded.                            |\n|              |       |                                            |\n| P(7)         |       | A 7-bit specification of an 8-bit          |\n|              |       | probability.  Coded as an L(7) number x;   |\n|              |       | the resulting 8-bit probability is x ? x   |\n|              |       | << 1 : 1.                                  |\n|              |       |                                            |\n| F?  X        |       | A flag that, if true, is followed by a     |\n|              |       | piece of data X.                           |\n|              |       |                                            |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "| F?  X:Y      |       | A flag that, if true, is followed by X     |\n|              |       | and, if false, is followed by Y.  Also     |\n|              |       | used to express a value where Y is an      |\n|              |       | implicit default (not encoded in the data  |\n|              |       | stream), as in F?  P(8):255, which         |\n|              |       | expresses an optional probability: If the  |\n|              |       | flag is true, the probability is specified |\n|              |       | as an 8-bit literal, while if the flag is  |\n|              |       | false, the probability defaults to 255.    |\n|              |       |                                            |\n| B(p)?  X     | B(p)? | Variants of the above using a boolean      |\n|              | X:Y   | indicator whose probability is not         |\n|              |       | necessarily 128.                           |\n|              |       |                                            |\n| T            |       | Tree-encoded value from small alphabet.    |\n+--------------+-------+--------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The last type requires elaboration. We often wish to encode something whose value is restricted to a small number of possibilities (the alphabet).",
      "ja": "最後のタイプでは、詳細が必要です。多くの場合、価値が少数の可能性（アルファベット）に限定されているものをエンコードしたいと考えています。"
    },
    {
      "indent": 3,
      "text": "This is done by representing the alphabet as the leaves of a small binary tree. The (non-leaf) nodes of the tree have associated probabilities p and correspond to calls to read_bool(d, p). We think of a zero as choosing the left branch below the node and a one as choosing the right branch.",
      "ja": "これは、アルファベットを小さなバイナリツリーの葉として表すことによって行われます。ツリーの（葉以外の）ノードは、関連する確率pを持ち、read_bool（d、p）への呼び出しに対応しています。ゼロは、ノードの下の左のブランチを選択し、右のブランチを選択するものとして考えています。"
    },
    {
      "indent": 3,
      "text": "Thus, every value (leaf) whose tree depth is x is decoded after exactly x calls to read_bool.",
      "ja": "したがって、Xがxがxであるすべての値（葉）は、read_boolを正確にx呼び出した後にデコードされます。"
    },
    {
      "indent": 3,
      "text": "A tree representing an encoding of an alphabet of n possible values always contains n-1 non-leaf nodes, regardless of its shape (this is easily seen by induction on n).",
      "ja": "n可能な値のアルファベットのエンコードを表すツリーには、その形状に関係なく、常にn-1非葉のノードが含まれます（これはnの誘導によって簡単に見られます）。"
    },
    {
      "indent": 3,
      "text": "There are many ways that a given alphabet can be so represented. The choice of tree has little impact on datarate but does affect decoder performance. The trees used by VP8 are chosen to (on average) minimize the number of calls to read_bool. This amounts to shaping the tree so that values that are more probable have smaller tree depth than do values that are less probable.",
      "ja": "特定のアルファベットをそのように表現できる多くの方法があります。ツリーの選択はデータの影響はほとんどありませんが、デコーダーの性能に影響します。VP8が使用するツリーは、（平均して）read_boolへの呼び出しの数を最小限に抑えるように選択されます。これは、ツリーを形作ることになり、より可能性の高い値が、それほど低い値よりも木の深さが小さくなります。"
    },
    {
      "indent": 3,
      "text": "Readers familiar with Huffman coding will notice that, given an alphabet together with probabilities for each value, the associated Huffman tree minimizes the expected number of calls to read_bool.",
      "ja": "Huffman Codingに精通している読者は、各値の確率とアルファベットを考えると、関連するHuffman Treeがread_boolへの呼び出し数を最小限に抑えることに気付くでしょう。"
    },
    {
      "indent": 3,
      "text": "Such readers will also realize that the coding method described here never results in higher datarates than does the Huffman method and, indeed, often results in much lower datarates. Huffman coding is, in fact, nothing more than a special case of this method in which each node probability is fixed at 128 (i.e., 1/2).",
      "ja": "このような読者はまた、ここで説明するコーディング方法は、Huffmanメソッドよりも高いデータレートを得ることはないことを認識し、実際にはしばしばはるかに低いデータレートをもたらすことになります。実際、ハフマンコーディングは、各ノードの確率が128（つまり1/2）に固定されているこの方法の特別なケースにすぎません。"
    },
    {
      "indent": 0,
      "text": "8.1. Tree Coding Implementation",
      "section_title": true,
      "ja": "8.1. ツリーコーディングの実装"
    },
    {
      "indent": 3,
      "text": "We give a suggested implementation of a tree data structure followed by a couple of actual examples of its usage by VP8.",
      "ja": "ツリーデータ構造の提案された実装に続いて、VP8による使用の実際の例がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "It is most convenient to represent the values using small positive integers, typically an enum counting up from zero. The largest alphabet (used to code DCT coefficients, described in Section 13) that is tree-coded by VP8 has only 12 values. The tree for this alphabet adds 11 interior nodes and so has a total of 23 positions. Thus, an 8-bit number easily accommodates both a tree position and a return value.",
      "ja": "小さな正の整数を使用して値を表すことが最も便利です。通常、ゼロからカウントアップする列挙です。VP8によってツリーコード化された最大のアルファベット（セクション13で説明されているDCT係数をコードするために使用）には、12の値しかありません。このアルファベットのツリーには、11の内部ノードが追加されているため、合計23のポジションがあります。したがって、8ビット番号は、ツリーの位置と戻り値の両方に簡単に対応できます。"
    },
    {
      "indent": 3,
      "text": "A tree may then be compactly represented as an array of (pairs of) 8-bit integers. Each (even) array index corresponds to an interior node of the tree; the 0th index of course corresponds to the root of the tree. The array entries come in pairs corresponding to the left (0) and right (1) branches of the subtree below the interior node. We use the convention that a positive (even) branch entry is the index of a deeper interior node, while a nonpositive entry v corresponds to a leaf whose value is -v.",
      "ja": "ツリーは、8ビット整数の（ペアの）配列としてコンパクトに表される場合があります。各（均一な）配列インデックスは、ツリーの内部ノードに対応します。コースの0番目のインデックスは、ツリーのルートに対応します。配列エントリは、内部ノードの下のサブツリーの左（0）と右（1）の分岐に対応するペアで提供されます。正の（均一な）ブランチエントリがより深い内部ノードのインデックスであるという規則を使用しますが、非陽性エントリvは値が-vの葉に対応します。"
    },
    {
      "indent": 3,
      "text": "The node probabilities associated to a tree-coded value are stored in an array whose indices are half the indices of the corresponding tree positions. The length of the probability array is one less than the size of the alphabet.",
      "ja": "ツリーコードされた値に関連付けられたノード確率は、対応するツリー位置のインデックスの半分のインデックスがある配列に保存されます。確率アレイの長さは、アルファベットのサイズよりも1つ少ないです。"
    },
    {
      "indent": 3,
      "text": "Here is C code implementing the foregoing. The advantages of our data structure should be noted. Aside from the smallness of the structure itself, the tree-directed reading algorithm is essentially a single line of code.",
      "ja": "以下は、前述を実装するCコードです。データ構造の利点に注意する必要があります。構造自体の小ささは別として、ツリー指向の読み取りアルゴリズムは、本質的にコードの単一行です。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* A tree specification is simply an array of 8-bit integers. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef int8 tree_index; typedef const tree_index Tree[];",
      "ja": "typedef int8 tree_index;typedef const tree_indexツリー[];"
    },
    {
      "indent": 3,
      "text": "/* Read and return a tree-coded value at the current decoder\n   position. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int treed_read(\n  bool_decoder * const d, /* bool_decoder always returns a 0 or 1 */\n  Tree t,                 /* tree specification */\n  const Prob p[]     /* corresponding interior node probabilities */\n) {\n  register tree_index i = 0;   /* begin at root */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/* Descend tree until leaf is reached */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "while ((i = t[ i + read_bool(d, p[i>>1])]) > 0) {}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  return -i;     /* return value is negation of nonpositive index */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tree-based decoding is implemented in the reference decoder file bool_decoder.h (Section 20.2).",
      "ja": "ツリーベースのデコードは、参照デコーダーファイルbool_decoder.h（セクション20.2）に実装されています。"
    },
    {
      "indent": 0,
      "text": "8.2. Tree Coding Example",
      "section_title": true,
      "ja": "8.2. ツリーコーディングの例"
    },
    {
      "indent": 3,
      "text": "As a multi-part example, without getting too far into the semantics of macroblock decoding (which is of course taken up below), we look at the \"mode\" coding for intra-predicted macroblocks.",
      "ja": "マルチパートの例として、マクロブロックデコードのセマンティクス（もちろん以下で取り上げられています）に行き過ぎずに、予測されているマクロブロックの「モード」コーディングを調べます。"
    },
    {
      "indent": 3,
      "text": "It so happens that, because of a difference in statistics, the Y (or luma) mode encoding uses two different trees: one for key frames and another for interframes. This is the only instance in VP8 of the same dataset being coded by different trees under different circumstances. The UV (or chroma) modes are a proper subset of the Y modes and, as such, have their own decoding tree.",
      "ja": "統計の違いのために、Y（またはLUMA）モードをエンコードすると、2つの異なるツリーが使用されます。1つはキーフレーム用、もう1つはインターフレーム用です。これは、異なる状況下で異なるツリーによってコーディングされている同じデータセットのVP8の唯一のインスタンスです。UV（またはChroma）モードはYモードの適切なサブセットであり、そのため独自のデコードツリーがあります。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef enum\n{\n    DC_PRED, /* predict DC using row above and column to the left */\n    V_PRED,  /* predict rows using row above */\n    H_PRED,  /* predict columns using column to the left */\n    TM_PRED, /* propagate second differences a la \"True Motion\" */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "B_PRED,  /* each Y subblock is independently predicted */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    num_uv_modes = B_PRED,  /* first four modes apply to chroma */\n    num_ymodes   /* all modes apply to luma */\n}\nintra_mbmode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* The aforementioned trees together with the implied codings as\n   comments.\n   Actual (i.e., positive) indices are always even.\n   Value (i.e., nonpositive) indices are arbitrary. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index ymode_tree [2 * (num_ymodes - 1)] =\n{\n -DC_PRED, 2,        /* root: DC_PRED = \"0\", \"1\" subtree */\n  4, 6,              /* \"1\" subtree has 2 descendant subtrees */\n   -V_PRED, -H_PRED, /* \"10\" subtree: V_PRED = \"100\",\n                        H_PRED = \"101\" */\n   -TM_PRED, -B_PRED /* \"11\" subtree: TM_PRED = \"110\",\n                        B_PRED = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index kf_ymode_tree [2 * (num_ymodes - 1)] =\n{\n -B_PRED, 2,            /* root: B_PRED = \"0\", \"1\" subtree */\n  4, 6,                 /* \"1\" subtree has 2 descendant subtrees */\n   -DC_PRED, -V_PRED,   /* \"10\" subtree: DC_PRED = \"100\",\n                           V_PRED = \"101\" */\n   -H_PRED, -TM_PRED    /* \"11\" subtree: H_PRED = \"110\",\n                           TM_PRED = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index uv_mode_tree [2 * (num_uv_modes - 1)] =\n{\n -DC_PRED, 2,          /* root: DC_PRED = \"0\", \"1\" subtree */\n  -V_PRED, 4,          /* \"1\" subtree:  V_PRED = \"10\",\n                          \"11\" subtree */\n   -H_PRED, -TM_PRED   /* \"11\" subtree: H_PRED = \"110\",\n                          TM_PRED = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Given a bool_decoder d, a Y mode might be decoded as follows. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob pretend_its_huffman [num_ymodes - 1] =\n  { 128, 128, 128, 128};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ymode = (intra_mbmode) treed_read(d, ymode_tree,\n  pretend_its_huffman);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Since it greatly facilitates re-use of reference code, and since there is no real reason to do otherwise, it is strongly suggested that any decoder implementation use exactly the same enumeration values and probability table layouts as those described in this document (and in the reference code) for all tree-coded data in VP8.",
      "ja": "参照コードの再利用を大幅に促進するため、そうしないとする本当の理由はないため、デコーダーの実装は、このドキュメントで説明したものとまったく同じ列挙値と確率テーブルレイアウトを使用することを強くお勧めします（および参照コード）VP8のすべてのツリーコーディングデータの。"
    },
    {
      "indent": 0,
      "text": "9. Frame Header",
      "section_title": true,
      "ja": "9. フレームヘッダー"
    },
    {
      "indent": 3,
      "text": "The uncompressed data chunk at the start of each frame and at the first part of the first data partition contains information pertaining to the frame as a whole. We list the fields in the order of occurrence. Most of the header decoding occurs in the reference decoder file dixie.c (Section 20.4).",
      "ja": "各フレームの開始時と最初のデータパーティションの最初の部分で、圧縮されていないデータチャンクには、フレーム全体に関連する情報が含まれています。発生順にフィールドをリストします。ヘッダーデコードのほとんどは、参照デコーダーファイルdixie.c（セクション20.4）で発生します。"
    },
    {
      "indent": 0,
      "text": "9.1. Uncompressed Data Chunk",
      "section_title": true,
      "ja": "9.1. 非圧縮データチャンク"
    },
    {
      "indent": 3,
      "text": "The uncompressed data chunk comprises a common (for key frames and interframes) 3-byte frame tag that contains four fields, as follows:",
      "ja": "非圧縮データチャンクは、次のように、4つのフィールドを含む共通（キーフレームとインターフレームの場合）3バイトフレームタグで構成されています。"
    },
    {
      "indent": 3,
      "text": "1. A 1-bit frame type (0 for key frames, 1 for interframes).",
      "ja": "1. 1ビットフレームタイプ（キーフレームの場合は0、インターフレームの場合は1）。"
    },
    {
      "indent": 3,
      "text": "2. A 3-bit version number (0 - 3 are defined as four different profiles with different decoding complexity; other values may be defined for future variants of the VP8 data format).",
      "ja": "2. 3ビットバージョン番号（0-3は、異なるデコードの複雑さを持つ4つの異なるプロファイルとして定義されます。VP8データ形式の将来のバリアントに対して他の値が定義される場合があります）。"
    },
    {
      "indent": 3,
      "text": "3. A 1-bit show_frame flag (0 when current frame is not for display, 1 when current frame is for display).",
      "ja": "3. 1ビットshow_frameフラグ（0のフレームが表示されない場合は0、現在のフレームが表示される場合は1）。"
    },
    {
      "indent": 3,
      "text": "4. A 19-bit field containing the size of the first data partition in bytes.",
      "ja": "4. バイト内の最初のデータパーティションのサイズを含む19ビットフィールド。"
    },
    {
      "indent": 3,
      "text": "The version number setting enables or disables certain features in the bitstream, as follows:",
      "ja": "次のように、バージョン番号設定では、ビットストリーム内の特定の機能を有効または無効にします。"
    },
    {
      "indent": 12,
      "text": "+---------+-------------------------+-------------+\n| Version | Reconstruction Filter   | Loop Filter |\n+---------+-------------------------+-------------+\n| 0       | Bicubic                 | Normal      |\n|         |                         |             |\n| 1       | Bilinear                | Simple      |\n|         |                         |             |\n| 2       | Bilinear                | None        |\n|         |                         |             |\n| 3       | None                    | None        |\n|         |                         |             |\n| Other   | Reserved for future use |             |\n+---------+-------------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The reference software also adjusts the loop filter based on version number, as per the table above. Version number 1 implies a \"simple\" loop filter, and version numbers 2 and 3 imply no loop filter. However, the \"simple\" filter setting in this context has no effect whatsoever on the decoding process, and the \"no loop filter\" setting only forces the reference encoder to set filter level equal to 0. Neither affect the decoding process. In decoding, the only loop filter settings that matter are those in the frame header.",
      "ja": "参照ソフトウェアは、上記の表に従って、バージョン番号に基づいてループフィルターも調整します。バージョン番号1は、「シンプルな」ループフィルターを意味し、バージョン番号2と3はループフィルターがないことを意味します。ただし、このコンテキストでの「シンプルな」フィルター設定は、デコードプロセスにまったく効果がなく、「No Loop Filter」設定は、参照エンコーダーのみを0に等しく設定します。どちらもデコードプロセスに影響しません。デコードでは、重要なループフィルター設定のみがフレームヘッダーの設定です。"
    },
    {
      "indent": 3,
      "text": "For key frames, the frame tag is followed by a further 7 bytes of uncompressed data, as follows:",
      "ja": "キーフレームの場合、フレームタグの後に、次のように、さらに7バイトの非圧縮データが続きます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Start code byte 0 0x9d Start code byte 1 0x01 Start code byte 2 0x2a",
      "ja": "開始コードバイト0 0x9d開始コードバイト1 0x01開始コードバイト2 0x2a"
    },
    {
      "indent": 3,
      "text": "16 bits      :     (2 bits Horizontal Scale << 14) | Width (14 bits)\n16 bits      :     (2 bits Vertical Scale << 14) | Height (14 bits)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following source code segment illustrates validation of the start code and reading the width, height, and scale factors for a key frame.",
      "ja": "次のソースコードセグメントは、開始コードの検証と、キーフレームの幅、高さ、およびスケール係数の読み取りを示しています。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "unsigned char *c = pbi->source+3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// vet via sync code\nif (c[0]!=0x9d||c[1]!=0x01||c[2]!=0x2a)\n    return -1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where pbi->source points to the beginning of the frame.",
      "ja": "ここで、pbi->ソースはフレームの始まりを指します。"
    },
    {
      "indent": 3,
      "text": "The following code reads the image dimension from the bitstream:",
      "ja": "次のコードは、ビットストリームの画像次元を読み取ります。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pc->Width      = swap2(*(unsigned short*)(c+3))&0x3fff;\npc->horiz_scale = swap2(*(unsigned short*)(c+3))>>14;\npc->Height     = swap2(*(unsigned short*)(c+5))&0x3fff;\npc->vert_scale  = swap2(*(unsigned short*)(c+5))>>14;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where the swap2 macro takes care of the endian on a different platform:",
      "ja": "SWAP2 Macroが別のプラットフォームでEndianの世話をする場合："
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#if defined(__ppc__) || defined(__ppc64__)\n# define swap2(d)  \\\n  ((d&0x000000ff)<<8) |  \\\n  ((d&0x0000ff00)>>8)\n#else\n  # define swap2(d) d\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "While each frame is encoded as a raster scan of 16x16 macroblocks, the frame dimensions are not necessarily evenly divisible by 16. In this case, write ew = 16 - (width & 15) and eh = 16 - (height & 15) for the excess width and height, respectively. Although they are",
      "ja": "各フレームは16x16マクロブロックのラスタースキャンとしてエンコードされていますが、フレームの寸法は必ずしも16で均等に分割できません。それぞれ過剰な幅と高さ。彼らはそうですが"
    },
    {
      "indent": 3,
      "text": "encoded, the last ew columns and eh rows are not actually part of the image and should be discarded before final output. However, these \"excess pixels\" should be maintained in the internal reconstruction buffer used to predict ensuing frames.",
      "ja": "エンコードされた最後のEW列とEH行は、実際には画像の一部ではなく、最終出力の前に破棄する必要があります。ただし、これらの「過剰ピクセル」は、次のフレームを予測するために使用される内部再構成バッファーで維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "The scaling specifications for each dimension are encoded as follows.",
      "ja": "各ディメンションのスケーリング仕様は、次のようにエンコードされます。"
    },
    {
      "indent": 13,
      "text": "+-------+--------------------------------------+\n| Value | Scaling                              |\n+-------+--------------------------------------+\n| 0     | No upscaling (the most common case). |\n|       |                                      |\n| 1     | Upscale by 5/4.                      |\n|       |                                      |\n| 2     | Upscale by 5/3.                      |\n|       |                                      |\n| 3     | Upscale by 2.                        |\n+-------+--------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Upscaling does not affect the reconstruction buffer, which should be maintained at the encoded resolution. Any reasonable method of upsampling (including any that may be supported by video hardware in the playback environment) may be used. Since scaling has no effect on decoding, we do not discuss it any further.",
      "ja": "アップスケーリングは、エンコードされた解像度で維持する必要がある再構築バッファーに影響しません。アップサンプリングの合理的な方法（再生環境でビデオハードウェアによってサポートされる可能性があるものを含む）が使用される場合があります。スケーリングはデコードに影響を与えないため、これ以上議論しません。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 5, allocation (or re-allocation) of data structures (such as the reconstruction buffer) whose size depends on dimension will be triggered here.",
      "ja": "セクション5で説明したように、サイズが次元に依存するデータ構造（または再構成バッファなど）の割り当て（または再配分）がここでトリガーされます。"
    },
    {
      "indent": 0,
      "text": "9.2. Color Space and Pixel Type (Key Frames Only)",
      "section_title": true,
      "ja": "9.2. カラースペースとピクセルタイプ（キーフレームのみ）"
    },
    {
      "indent": 11,
      "text": "+-------+------------------------------------------+\n| Field | Value                                    |\n+-------+------------------------------------------+\n| L(1)  | 1-bit color space type specification     |\n|       |                                          |\n| L(1)  | 1-bit pixel value clamping specification |\n+-------+------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The color space type bit is encoded as follows:",
      "ja": "カラースペースタイプビットは次のようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "o 0 - YUV color space similar to the YCrCb color space defined in [ITU-R_BT.601]",
      "ja": "o 0 -[itu -r_bt.601]で定義されているycrcbカラースペースに似たyuvカラースペース"
    },
    {
      "indent": 3,
      "text": "o 1 - Reserved for future use",
      "ja": "o 1-将来の使用のために予約されています"
    },
    {
      "indent": 3,
      "text": "The pixel value clamping type bit is encoded as follows:",
      "ja": "ピクセル値クランプタイプビットは、次のようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "o 0 - Decoders are required to clamp the reconstructed pixel values to between 0 and 255 (inclusive).",
      "ja": "o 0-再構築されたピクセル値を0〜255（包括的）にクランプするには、デコーダーが必要です。"
    },
    {
      "indent": 3,
      "text": "o 1 - Reconstructed pixel values are guaranteed to be between 0 and 255; no clamping is necessary.",
      "ja": "o 1-再構築されたピクセル値は、0〜255の間で保証されています。クランプは必要ありません。"
    },
    {
      "indent": 3,
      "text": "Information in this subsection does not appear in interframes.",
      "ja": "このサブセクションの情報は、インターフレームには表示されません。"
    },
    {
      "indent": 0,
      "text": "9.3. Segment-Based Adjustments",
      "section_title": true,
      "ja": "9.3. セグメントベースの調整"
    },
    {
      "indent": 3,
      "text": "This subsection contains probability and value information for implementing segment adaptive adjustments to default decoder behavior. The data in this subsection is used in the decoding of the ensuing per-segment information and applies to the entire frame. When segment adaptive adjustments are enabled, each macroblock will be assigned a segment ID. Macroblocks with the same segment ID belong to the same segment and have the same adaptive adjustments over default baseline values for the frame. The adjustments can be quantizer level or loop filter strength.",
      "ja": "このサブセクションには、デフォルトのデコーダー動作にセグメント適応調整を実装するための確率と値情報が含まれています。このサブセクションのデータは、その後のセグメントごとの情報のデコードで使用され、フレーム全体に適用されます。セグメント適応調整が有効になると、各マクロブロックにセグメントIDが割り当てられます。同じセグメントIDを持つマクロブロックは、同じセグメントに属し、フレームのデフォルトのベースライン値よりも同じ適応調整を行います。調整は、量子化レベルまたはループフィルター強度です。"
    },
    {
      "indent": 3,
      "text": "The context for decoding this feature at the macroblock level is provided by a subsection in the frame header, which contains:",
      "ja": "マクロブロックレベルでこの機能をデコードするためのコンテキストは、以下を含むフレームヘッダーのサブセクションによって提供されます。"
    },
    {
      "indent": 3,
      "text": "1. A segmentation_enabled flag that enables the feature for this frame if set to 1, and disables it if set to 0. The following fields occur if the feature is enabled.",
      "ja": "1. このフレームの機能を1に設定すると、0に設定されている場合は無効にするセグメンテーション_エンブルフラグ。機能が有効になっている場合に次のフィールドが発生します。"
    },
    {
      "indent": 3,
      "text": "2. L(1) indicates if the segment map is updated for the current frame (update_mb_segmentation_map).",
      "ja": "2. L（1）は、現在のフレーム（update_mb_segmentation_map）に対してセグメントマップが更新されているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "3. L(1) indicates if the segment feature data items are updated for the current frame (update_segment_feature_data).",
      "ja": "3. L（1）は、セグメント機能データ項目が現在のフレーム（update_segment_feature_data）に対して更新されているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "4. If Item 3 above (update_segment_feature_data) is 1, the following fields occur:",
      "ja": "4. 上記の項目3（update_segment_feature_data）が1の場合、次のフィールドが発生します。"
    },
    {
      "indent": 7,
      "text": "a. L(1), the mode of segment feature data (segment_feature_mode), can be absolute-value mode (0) or delta value mode (1).",
      "ja": "a. l（1）、セグメント特徴データ（segment_feature_mode）のモードは、絶対値モード（0）またはデルタ値モード（1）です。"
    },
    {
      "indent": 7,
      "text": "b. Segment feature data items are decoded segment by segment for each segment feature. For every data item, a one-bit flag indicates whether the item is 0, or a non-zero value to be decoded. If the value is non-zero, then the value is decoded as a magnitude L(n), followed by a one-bit sign (L(1) -- 0 for positive and 1 for negative). The length n can be looked up from a pre-defined length table for all feature data.",
      "ja": "b. セグメント機能データ項目は、各セグメント機能のセグメントごとにデコードされたセグメントです。すべてのデータ項目について、1ビットフラグは、アイテムが0であるか、非ゼロ値がデコードされるかを示します。値がゼロ以外の場合、値はマグニチュードL（n）としてデコードされ、その後に1ビットの符号が続きます（陽性の場合はl（1）、ネガの場合は1）。長さnは、すべての機能データの事前定義された長さテーブルから調べることができます。"
    },
    {
      "indent": 3,
      "text": "5. If the L(1) flag as noted in Item 2 above is set to 1, the probabilities of the decoding tree for the segment map are decoded from the bitstream. Each probability is decoded with a one-bit flag indicating whether the probability is the default value of 255 (flag is set to 0), or an 8-bit value, L(8), from the bitstream.",
      "ja": "5. 上記の項目2に記載されているL（1）フラグが1に設定されている場合、セグメントマップのデコードツリーの確率はビットストリームからデコードされます。各確率は、ビットストリームからの確率がデフォルト値（フラグが0に設定されている）、または8ビット値L（8）であるかどうかを示す1ビットフラグでデコードされます。"
    },
    {
      "indent": 3,
      "text": "The layout and semantics supporting this feature at the macroblock level are described in Section 10.",
      "ja": "マクロブロックレベルでこの機能をサポートするレイアウトとセマンティクスは、セクション10で説明されています。"
    },
    {
      "indent": 0,
      "text": "9.4. Loop Filter Type and Levels",
      "section_title": true,
      "ja": "9.4. ループフィルターの種類とレベル"
    },
    {
      "indent": 3,
      "text": "VP8 supports two types of loop filters having different computational complexity. The following bits occur in the header to support the selection of the baseline type, strength, and sharpness behavior of the loop filter used for the current frame.",
      "ja": "VP8は、異なる計算の複雑さを持つ2種類のループフィルターをサポートします。次のビットは、現在のフレームに使用されるループフィルターのベースラインタイプ、強度、およびシャープネス動作の選択をサポートするために、ヘッダーで発生します。"
    },
    {
      "indent": 23,
      "text": "+-------+-------------------+\n| Index | Description       |\n+-------+-------------------+\n| L(1)  | filter_type       |\n|       |                   |\n| L(6)  | loop_filter_level |\n|       |                   |\n| L(3)  | sharpness_level   |\n+-------+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The meaning of these numbers will be further explained in Section 15.",
      "ja": "これらの数値の意味については、セクション15でさらに説明します。"
    },
    {
      "indent": 3,
      "text": "VP8 has a feature in the bitstream that enables adjustment of the loop filter level based on a macroblock's prediction mode and reference frame. The per-macroblock adjustment is done through delta values against the default loop filter level for the current frame. This subsection contains flag and value information for implementing per-macroblock loop filter level adjustment to default decoder behavior. The data in this section is used in the decoding of the ensuing per-macroblock information and applies to the entire frame.",
      "ja": "VP8には、マクロブロックの予測モードと参照フレームに基づいてループフィルターレベルの調整を可能にするビットストリームに機能があります。マクロブロックごとの調整は、現在のフレームのデフォルトループフィルターレベルに対するデルタ値を通じて行われます。このサブセクションには、デフォルトのデコーダー動作にマクロブロックごとのループフィルターレベル調整を実装するためのフラグと値情報が含まれています。このセクションのデータは、その後のマクロブロックごとの情報のデコードで使用され、フレーム全体に適用されます。"
    },
    {
      "indent": 3,
      "text": "L(1) is a one-bit flag indicating if the macroblock loop filter adjustment is on for the current frame. 0 means that such a feature is not supported in the current frame, and 1 means this feature is enabled for the current frame.",
      "ja": "L（1）は、現在のフレームに対してマクロブロックループフィルターの調整がオンかどうかを示す1ビットフラグです。0は、このような機能が現在のフレームではサポートされていないことを意味し、1つはこの機能が現在のフレームで有効になっていることを意味します。"
    },
    {
      "indent": 3,
      "text": "Whether the adjustment is based on a reference frame or encoding mode, the adjustment of the loop filter level is done via a delta value against a baseline loop filter value. The delta values are updated for the current frame if an L(1) bit, mode_ref_lf_delta_update, takes the value 1. There are two groups of delta values: One group of delta values is for reference frame-based adjustments, and the other group is for mode-based adjustments. The number of delta values in the two groups is MAX_REF_LF_DELTAS and MAX_MODE_LF_DELTAS, respectively. For every value within the two groups, there is a one-bit L(1) to indicate if the particular value is updated. When one is updated (1), it is transmitted as a six-bit-magnitude L(6) followed by a one-bit sign flag (L(1) -- 0 for positive and 1 for negative).",
      "ja": "調整が参照フレームまたはエンコードモードに基づいているかどうかにかかわらず、ループフィルターレベルの調整は、ベースラインループフィルター値に対するデルタ値を介して行われます。l（1）ビット、mode_ref_lf_delta_updateの場合、デルタ値は現在のフレームで更新されます。値1を取得します。モードベースの調整用。2つのグループのデルタ値の数は、それぞれMAX_REF_LF_DELTASとMAX_MODE_LF_DELTASです。2つのグループ内のすべての値について、特定の値が更新されているかどうかを示す1ビットL（1）があります。1つが更新されると（1）、6ビットマグニチュードL（6）として送信され、その後に1ビットサインフラグが続きます（l（1）-0陽性、ネガの場合は1）。"
    },
    {
      "indent": 0,
      "text": "9.5. Token Partition and Partition Data Offsets",
      "section_title": true,
      "ja": "9.5. トークンパーティションおよびパーティションデータオフセット"
    },
    {
      "indent": 3,
      "text": "VP8 allows DCT coefficients to be packed into multiple partitions, besides the first partition with header and per-macroblock prediction information, so the decoder can perform parallel decoding in an efficient manner. A two-bit L(2) is used to indicate the number of coefficient data partitions within a compressed frame. The two bits are defined in the following table:",
      "ja": "VP8を使用すると、DCT係数を複数のパーティションに詰め込むことができ、ヘッダーとマクロブロックごとの予測情報を備えた最初のパーティションに加えて、デコーダーは効率的な方法で並列デコードを実行できます。2ビットL（2）を使用して、圧縮フレーム内の係数データパーティションの数を示します。2つのビットは、次の表に定義されています。"
    },
    {
      "indent": 17,
      "text": "+-------+-------+----------------------+\n| Bit 1 | Bit 0 | Number of Partitions |\n+-------+-------+----------------------+\n| 0     | 0     | 1                    |\n|       |       |                      |\n| 0     | 1     | 2                    |\n|       |       |                      |\n| 1     | 0     | 4                    |\n|       |       |                      |\n| 1     | 1     | 8                    |\n+-------+-------+----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Offsets are embedded in the bitstream to provide the decoder direct access to token partitions. If the number of data partitions is greater than 1, the size of each partition (except the last) is written in 3 bytes (24 bits). The size of the last partition is the remainder of the data not used by any of the previous partitions.",
      "ja": "オフセットは、トークンパーティションへのデコーダー直接アクセスを提供するためにビットストリームに埋め込まれています。データパーティションの数が1を超える場合、各パーティションのサイズ（最後を除く）は3バイト（24ビット）で記述されます。最後のパーティションのサイズは、以前のパーティションのいずれでも使用されないデータの残りです。"
    },
    {
      "indent": 3,
      "text": "The partitioned data are consecutive in the bitstream, so the size can also be used to calculate the offset of each partition. The following pseudocode illustrates how the size/offset is defined by the three bytes in the bitstream.",
      "ja": "パーティション化されたデータはビットストリームで連続しているため、サイズを使用して各パーティションのオフセットを計算することもできます。次の擬似コードは、ビットストリームの3バイトによってサイズ/オフセットがどのように定義されるかを示しています。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Offset/size  =  (uint32)(byte0) + ((uint32)(byte1)<<8)\n  + ((uint32)(byte2)<<16);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.6. Dequantization Indices",
      "section_title": true,
      "ja": "9.6. 脱量化インデックス"
    },
    {
      "indent": 3,
      "text": "All residue signals are specified via a quantized 4x4 DCT applied to the Y, U, V, or Y2 subblocks of a macroblock. As detailed in Section 14, before inverting the transform, each decoded coefficient is multiplied by one of six dequantization factors, the choice of which depends on the plane (Y, chroma = U or V, Y2) and coefficient position (DC = coefficient 0, AC = coefficients 1-15). The six values are specified using 7-bit indices into six corresponding fixed tables (the tables are given in Section 14).",
      "ja": "すべての残基シグナルは、マクロブロックのY、U、V、またはY2サブブロックに適用される量子化された4x4 DCTを介して指定されます。セクション14で詳述されているように、変換を反転させる前に、デコードされた各係数に6つの非定量化係数のいずれかを掛けます。、AC =係数1-15）。6つの値は、7ビットインデックスを使用して6つの対応する固定テーブルに指定されています（テーブルはセクション14に記載されています）。"
    },
    {
      "indent": 3,
      "text": "The first 7-bit index gives the dequantization table index for Y-plane AC coefficients, called yac_qi. It is always coded and acts as a baseline for the other 5 quantization indices, each of which is represented by a delta from this baseline index. Pseudocode for reading the indices follows:",
      "ja": "最初の7ビットインデックスは、YAC_QIと呼ばれるYプレーンAC係数の不安定化テーブルインデックスを提供します。これは常にコーディングされており、他の5つの量子化インデックスのベースラインとして機能し、それぞれがこのベースラインインデックスのデルタで表されます。インデックスを読むための擬似コードは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "yac_qi     = L(7);           /* Y ac index always specified */\nydc_delta  = F? delta(): 0;  /* Y dc delta specified if\n                                flag is true */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "y2dc_delta = F? delta(): 0;  /* Y2 dc delta specified if\n                                flag is true */\ny2ac_delta = F? delta(): 0;  /* Y2 ac delta specified if\n                                flag is true */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uvdc_delta = F? delta(): 0;  /* chroma dc delta specified\n                                if flag is true */\nuvac_delta = F? delta(): 0;  /* chroma ac delta specified\n                                if flag is true */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where delta() is the process to read 5 bits from the bitstream to determine a signed delta value:",
      "ja": "ここで、delta（）は、署名されたデルタ値を決定するためにビットストリームから5ビットを読み取るプロセスです。"
    },
    {
      "indent": 7,
      "text": "+-------+--------------------------------------------------+\n| Index | Description                                      |\n+-------+--------------------------------------------------+\n| L(4)  | Magnitude of delta                               |\n|       |                                                  |\n| L(1)  | Sign of delta, 0 for positive and 1 for negative |\n+-------+--------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.7. Refresh Golden Frame and Altref Frame",
      "section_title": true,
      "ja": "9.7. ゴールデンフレームとアルトレフフレームを更新します"
    },
    {
      "indent": 3,
      "text": "For key frames, both the golden frame and the altref frame are refreshed/ replaced by the current reconstructed frame, by default. For non-key frames, VP8 uses two bits to indicate whether the two frame buffers are refreshed, using the reconstructed current frame:",
      "ja": "キーフレームの場合、ゴールデンフレームとアルトレフフレームの両方が、デフォルトで現在の再構築されたフレームに更新/置き換えられます。非キーフレームの場合、VP8は2つのビットを使用して、再構築された電流フレームを使用して、2つのフレームバッファーが更新されているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "+-------+----------------------------------------------------------+\n| Index | Description                                              |\n+-------+----------------------------------------------------------+\n| L(1)  | Whether golden frame is refreshed (0 for no, 1 for yes). |\n|       |                                                          |\n| L(1)  | Whether altref frame is refreshed (0 for no, 1 for yes). |\n+-------+----------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When the flag for the golden frame is 0, VP8 uses 2 more bits in the bitstream to indicate whether the buffer (and which buffer) is copied to the golden frame, or if no buffer is copied:",
      "ja": "ゴールデンフレームのフラグが0の場合、VP8はビットストリームでさらに2ビットを使用して、バッファー（およびバッファー）がゴールデンフレームにコピーされるか、バッファーがコピーされないかどうかを示します。"
    },
    {
      "indent": 11,
      "text": "+-------+------------------------------------------+\n| Index | Description                              |\n+-------+------------------------------------------+\n| L(2)  | Buffer copy flag for golden frame buffer |\n+-------+------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where:",
      "ja": "ただし："
    },
    {
      "indent": 3,
      "text": "o 0 means no buffer is copied to the golden frame",
      "ja": "o 0は、バッファーがゴールデンフレームにコピーされないことを意味します"
    },
    {
      "indent": 3,
      "text": "o 1 means last_frame is copied to the golden frame",
      "ja": "o 1は、last_frameがゴールデンフレームにコピーされることを意味します"
    },
    {
      "indent": 3,
      "text": "o 2 means alt_ref_frame is copied to the golden frame",
      "ja": "o 2は、alt_ref_frameがゴールデンフレームにコピーされることを意味します"
    },
    {
      "indent": 3,
      "text": "Similarly, when the flag for altref is 0, VP8 uses 2 bits in the bitstream to indicate which buffer is copied to alt_ref_frame.",
      "ja": "同様に、Altrefのフラグが0の場合、VP8はビットストリームで2ビットを使用して、どのバッファーがalt_ref_frameにコピーされているかを示します。"
    },
    {
      "indent": 11,
      "text": "+-------+------------------------------------------+\n| Index | Description                              |\n+-------+------------------------------------------+\n| L(2)  | Buffer copy flag for altref frame buffer |\n+-------+------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where:",
      "ja": "ただし："
    },
    {
      "indent": 3,
      "text": "o 0 means no buffer is copied to the altref frame",
      "ja": "o 0は、バッファーがaltRefフレームにコピーされないことを意味します"
    },
    {
      "indent": 3,
      "text": "o 1 means last_frame is copied to the altref frame",
      "ja": "o 1は、last_frameがaltRefフレームにコピーされることを意味します"
    },
    {
      "indent": 3,
      "text": "o 2 means golden_frame is copied to the altref frame",
      "ja": "o 2は、Golden_FrameがAltRefフレームにコピーされることを意味します"
    },
    {
      "indent": 3,
      "text": "Two bits are transmitted for ref_frame_sign_bias for golden_frame and alt_ref_frame, respectively.",
      "ja": "Golden_FrameとAlt_Ref_FrameのREF_FRAME_SIGN_BIAS用に2つのビットが送信されます。"
    },
    {
      "indent": 16,
      "text": "+-------+---------------------------------+\n| Index | Description                     |\n+-------+---------------------------------+\n| L(1)  | Sign bias flag for golden frame |\n|       |                                 |\n| L(1)  | Sign bias flag for altref frame |\n+-------+---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These values are used to control the sign of the motion vectors when a golden frame or an altref frame is used as the reference frame for a macroblock.",
      "ja": "これらの値は、ゴールデンフレームまたはアルトレフフレームがマクロブロックの参照フレームとして使用される場合のモーションベクトルの記号を制御するために使用されます。"
    },
    {
      "indent": 0,
      "text": "9.8. Refresh Last Frame Buffer",
      "section_title": true,
      "ja": "9.8. 最後のフレームバッファを更新します"
    },
    {
      "indent": 3,
      "text": "VP8 uses one bit, L(1), to indicate if the last frame reference buffer is refreshed using the constructed current frame. On a key frame, this bit is overridden, and the last frame buffer is always refreshed.",
      "ja": "VP8は、構築された電流フレームを使用して最後のフレーム参照バッファーが更新されているかどうかを示すために、1ビットL（1）を使用します。キーフレームでは、このビットはオーバーライドされ、最後のフレームバッファーは常に更新されます。"
    },
    {
      "indent": 0,
      "text": "9.9. DCT Coefficient Probability Update",
      "section_title": true,
      "ja": "9.9. DCT係数確率アップデート"
    },
    {
      "indent": 3,
      "text": "This field contains updates to the probability tables used to decode DCT coefficients. For each of the probabilities in the tables, there is an L(1) flag indicating if the probability is updated for the current frame, and if the L(1) flag is set to 1, there follows an additional 8-bit value representing the new probability value. These tables are maintained across interframes but are of course replaced with their defaults at the beginning of every key frame.",
      "ja": "このフィールドには、DCT係数をデコードするために使用される確率テーブルの更新が含まれています。テーブル内の各確率について、現在のフレームの確率が更新されているかどうかを示すL（1）フラグがあり、L（1）フラグが1に設定されている場合、追加の8ビット値を表す追加の8ビット値が続きます。新しい確率値。これらのテーブルはインターフレーム全体に維持されていますが、もちろん、すべてのキーフレームの先頭にデフォルトに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "The layout and semantics of this field will be taken up in Section 13.",
      "ja": "このフィールドのレイアウトとセマンティクスは、セクション13で取り上げられます。"
    },
    {
      "indent": 0,
      "text": "9.10. Remaining Frame Header Data (Non-Key Frame)",
      "section_title": true,
      "ja": "9.10. 残りのフレームヘッダーデータ（キーフレーム以外）"
    },
    {
      "indent": 3,
      "text": "+-------+-----------------------------------------------------------+\n| Index | Description                                               |\n+-------+-----------------------------------------------------------+\n| L(1)  | mb_no_skip_coeff.  This flag indicates at the frame level |\n|       | if skipping of macroblocks with no non-zero coefficients  |\n|       | is enabled.  If it is set to 0, then prob_skip_false is   |\n|       | not read and mb_skip_coeff is forced to 0 for all         |\n|       | macroblocks (see Sections 11.1 and 12.1).                 |\n|       |                                                           |\n| L(8)  | prob_skip_false = probability used for decoding a         |\n|       | macroblock-level flag, which indicates if a macroblock    |\n|       | has any non-zero coefficients.  Only read if              |\n|       | mb_no_skip_coeff is 1.                                    |\n|       |                                                           |\n| L(8)  | prob_intra = probability that a macroblock is \"intra\"     |\n|       | predicted (that is, predicted from the already-encoded    |\n|       | portions of the current frame), as opposed to \"inter\"     |\n|       | predicted (that is, predicted from the contents of a      |\n|       | prior frame).                                             |\n|       |                                                           |\n| L(8)  | prob_last = probability that an inter-predicted           |\n|       | macroblock is predicted from the immediately previous     |\n|       | frame, as opposed to the most recent golden frame or      |\n|       | altref frame.                                             |\n|       |                                                           |\n| L(8)  | prob_gf = probability that an inter-predicted macroblock  |\n|       | is predicted from the most recent golden frame, as        |\n|       | opposed to the altref frame.                              |\n|       |                                                           |\n| F     | If true, followed by four L(8)s updating the              |\n|       | probabilities for the different types of intra-prediction |\n|       | for the Y plane.  These probabilities correspond to the   |\n|       | four interior nodes of the decoding tree for intra-Y      |\n|       | modes in an interframe, that is, the even positions in    |\n|       | the ymode_tree array given above.                         |\n|       |                                                           |\n| F     | If true, followed by three L(8)s updating the             |\n|       | probabilities for the different types of intra-prediction |\n|       | for the chroma planes.  These probabilities correspond to |\n|       | the even positions in the uv_mode_tree array given above. |\n|       |                                                           |\n| X     | Motion vector probability update.  Details are given in   |\n|       | Section 17.2, \"Probability Updates\".                      |\n+-------+-----------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding of this portion of the frame header is handled in the reference decoder file dixie.c (Section 20.4).",
      "ja": "フレームヘッダーのこの部分のデコードは、参照デコーダーファイルdixie.c（セクション20.4）で処理されます。"
    },
    {
      "indent": 0,
      "text": "9.11. Remaining Frame Header Data (Key Frame)",
      "section_title": true,
      "ja": "9.11. 残りのフレームヘッダーデータ（キーフレーム）"
    },
    {
      "indent": 3,
      "text": "+-------+-----------------------------------------------------------+\n| Index | Description                                               |\n+-------+-----------------------------------------------------------+\n| L(1)  | mb_no_skip_coeff.  This flag indicates at the frame level |\n|       | if skipping of macroblocks with no non-zero coefficients  |\n|       | is enabled.  If it is set to 0, then prob_skip_false is   |\n|       | not read and mb_skip_coeff is forced to 0 for all         |\n|       | macroblocks (see Sections 11.1 and 12.1).                 |\n|       |                                                           |\n| L(8)  | prob_skip_false = Probability used for decoding a         |\n|       | macroblock-level flag, which indicates if a macroblock    |\n|       | has any non-zero coefficients.  Only read if              |\n|       | mb_no_skip_coeff is 1.                                    |\n+-------+-----------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding of this portion of the frame header is handled in the reference decoder file modemv.c (Section 20.11).",
      "ja": "フレームヘッダーのこの部分のデコードは、参照デコーダーファイルmodemv.c（セクション20.11）で処理されます。"
    },
    {
      "indent": 3,
      "text": "This completes the layout of the frame header. The remainder of the first data partition consists of macroblock-level prediction data.",
      "ja": "これにより、フレームヘッダーのレイアウトが完了します。最初のデータパーティションの残りは、マクロブロックレベルの予測データで構成されています。"
    },
    {
      "indent": 3,
      "text": "After the frame header is processed, all probabilities needed to decode the prediction and residue data are known and will not change until the next frame.",
      "ja": "フレームヘッダーが処理された後、予測のデコードに必要なすべての確率と残基データが既知であり、次のフレームまで変更されません。"
    },
    {
      "indent": 0,
      "text": "10. Segment-Based Feature Adjustments",
      "section_title": true,
      "ja": "10. セグメントベースの機能調整"
    },
    {
      "indent": 3,
      "text": "Every macroblock may optionally override some of the default behaviors of the decoder. Specifically, VP8 uses segment-based adjustments to support changing quantizer level and loop filter level for a macroblock. When the segment-based adjustment feature is enabled for a frame, each macroblock within the frame is coded with a segment_id. This effectively segments all the macroblocks in the current frame into a number of different segments. Macroblocks within the same segment behave exactly the same for quantizer and loop filter level adjustments.",
      "ja": "すべてのマクロブロックは、オプションでデコーダーのデフォルト動作の一部をオーバーライドする場合があります。具体的には、VP8はセグメントベースの調整を使用して、マクロブロックの変化する量子化レベルとループフィルターレベルをサポートします。フレームに対してセグメントベースの調整機能が有効になっている場合、フレーム内の各マクロブロックはsegment_idでコーディングされます。これにより、現在のフレーム内のすべてのマクロブロックが多くの異なるセグメントに効果的にセグリングされます。同じセグメント内のマクロブロックは、量子化器とループフィルターレベルの調整に対してまったく同じように動作します。"
    },
    {
      "indent": 3,
      "text": "If both the segmentation_enabled and update_mb_segmentation_map flags in subsection B of the frame header take a value of 1, the prediction data for each (intra- or inter-coded) macroblock begins with a specification of segment_id for the current macroblock. It is decoded using this simple tree ...",
      "ja": "FrameヘッダーのサブセクションBのSegmentation_Enabledとupdate_mb_segmentation_mapフラグの両方が1の値を取得する場合、各マクロブロックの各マクロブロックの予測データは、現在のマクロブロックのSEGAME_IDの仕様から始まります。この単純な木を使用してデコードされています..."
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index mb_segment_tree [2 * (4-1)] =\n  {\n    2,  4,     /* root: \"0\", \"1\" subtrees */\n    -0, -1,    /* \"00\" = 0th value, \"01\" = 1st value */\n     -2, -3    /* \"10\" = 2nd value, \"11\" = 3rd value */\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "... combined with a 3-entry probability table, mb_segment_tree_probs[3]. The macroblock's segment_id is used later in the decoding process to look into the segment_feature_data table and determine how the quantizer and loop filter levels are adjusted.",
      "ja": "... 3エントリ確率表、MB_Segment_tree_Probs [3]と組み合わせる。Macroblockのsegment_idは、デコードプロセスの後半で使用され、segment_feature_dataテーブルを調べ、量子化器とループフィルターのレベルの調整方法を決定します。"
    },
    {
      "indent": 3,
      "text": "The decoding of segment_id, together with the parsing of intra-prediction modes (which is taken up next), is implemented in the reference decoder file modemv.c.",
      "ja": "SEGAGE_IDのデコードは、予測内モード（次に取り上げられる）の解析とともに、参照デコーダーファイルmodemv.cに実装されています。"
    },
    {
      "indent": 0,
      "text": "11. Key Frame Macroblock Prediction Records",
      "section_title": true,
      "ja": "11. キーフレームマクロブロック予測記録"
    },
    {
      "indent": 3,
      "text": "After specifying the features described above, the macroblock prediction record next specifies the prediction mode used for the macroblock.",
      "ja": "上記の機能を指定した後、マクロブロック予測レコードは次に、マクロブロックに使用される予測モードを指定します。"
    },
    {
      "indent": 0,
      "text": "11.1. mb_skip_coeff",
      "section_title": true,
      "ja": "11.1. MB_SKIP_COEFF"
    },
    {
      "indent": 3,
      "text": "The single bool flag is decoded using prob_skip_false if and only if mb_no_skip_coeff is set to 1 (see Sections 9.10 and 9.11). If mb_no_skip_coeff is set to 0, then this value defaults to 0.",
      "ja": "単一のブールフラグは、mb_no_skip_coeffが1に設定されている場合にのみ、prob_skip_falseを使用してデコードされます（セクション9.10および9.11を参照）。MB_NO_SKIP_COEFFが0に設定されている場合、この値はデフォルト0になります。"
    },
    {
      "indent": 0,
      "text": "11.2. Luma Modes",
      "section_title": true,
      "ja": "11.2. ルマモード"
    },
    {
      "indent": 3,
      "text": "First comes the luma specification of type intra_mbmode, coded using the kf_ymode_tree, as described in Section 8 and repeated here for convenience:",
      "ja": "最初に、セクション8で説明されているように、kf_ymode_treeを使用してコード化された型intra_mbmodeのluma仕様が登場し、ここで繰り返されます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef enum\n{\n    DC_PRED, /* predict DC using row above and column to the left */\n    V_PRED,  /* predict rows using row above */\n    H_PRED,  /* predict columns using column to the left */\n    TM_PRED, /* propagate second differences a la \"True Motion\" */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "B_PRED,  /* each Y subblock is independently predicted */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    num_uv_modes = B_PRED,  /* first four modes apply to chroma */\n    num_ymodes   /* all modes apply to luma */\n}\nintra_mbmode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index kf_ymode_tree [2 * (num_ymodes - 1)] =\n{\n -B_PRED, 2,            /* root: B_PRED = \"0\", \"1\" subtree */\n  4, 6,                 /* \"1\" subtree has 2 descendant subtrees */\n   -DC_PRED, -V_PRED,   /* \"10\" subtree: DC_PRED = \"100\",\n                           V_PRED = \"101\" */\n   -H_PRED, -TM_PRED    /* \"11\" subtree: H_PRED = \"110\",\n                           TM_PRED = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For key frames, the Y mode is decoded using a fixed probability array as follows:",
      "ja": "キーフレームの場合、yモードは、次のように固定確率配列を使用してデコードされます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob kf_ymode_prob [num_ymodes - 1] = { 145, 156, 163, 128};\nYmode = (intra_mbmode) treed_read(d, kf_ymode_tree, kf_ymode_prob);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "d is of course the bool_decoder being used to read the first data partition.",
      "ja": "Dはもちろん、最初のデータパーティションを読み取るために使用されているbool_decoderです。"
    },
    {
      "indent": 3,
      "text": "If the Ymode is B_PRED, it is followed by a (tree-coded) mode for each of the 16 Y subblocks. The 10 subblock modes and their coding tree are as follows:",
      "ja": "YModeのB_PREDの場合、16Yサブブロックのそれぞれに対して（ツリーコーディング）モードが続きます。10のサブブロックモードとそのコーディングツリーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef enum\n{\n    B_DC_PRED,  /* predict DC using row above and column\n                   to the left */\n    B_TM_PRED,  /* propagate second differences a la\n                   \"True Motion\" */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "B_VE_PRED,  /* predict rows using row above */\nB_HE_PRED,  /* predict columns using column to the left */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "B_LD_PRED,  /* southwest (left and down) 45 degree diagonal\n               prediction */\nB_RD_PRED,  /* southeast (right and down) \"\" */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "B_VR_PRED,  /* SSE (vertical right) diagonal prediction */\nB_VL_PRED,  /* SSW (vertical left) \"\" */\nB_HD_PRED,  /* ESE (horizontal down) \"\" */\nB_HU_PRED,  /* ENE (horizontal up) \"\" */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " num_intra_bmodes } intra_bmode;",
      "ja": "num_intra_bmodes} intra_bmode;"
    },
    {
      "indent": 3,
      "text": "/* Coding tree for the above, with implied codings as comments */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index bmode_tree [2 * (num_intra_bmodes - 1)] =\n{\n -B_DC_PRED, 2,                   /* B_DC_PRED = \"0\" */\n  -B_TM_PRED, 4,                  /* B_TM_PRED = \"10\" */\n   -B_VE_PRED, 6,                 /* B_VE_PRED = \"110\" */\n    8, 12,\n     -B_HE_PRED, 10,              /* B_HE_PRED = \"11100\" */\n      -B_RD_PRED, -B_VR_PRED,     /* B_RD_PRED = \"111010\",\n                                     B_VR_PRED = \"111011\" */\n     -B_LD_PRED, 14,              /* B_LD_PRED = \"111110\" */\n       -B_VL_PRED, 16,            /* B_VL_PRED = \"1111110\" */\n         -B_HD_PRED, -B_HU_PRED   /* HD = \"11111110\",\n                                     HU = \"11111111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first four modes are smaller versions of the similarly named 16x16 modes above, albeit with slightly different numbering. The last six \"diagonal\" modes are unique to luma subblocks.",
      "ja": "最初の4つのモードは、わずかに異なる番号が付いているにもかかわらず、上記の16x16モードと同様に名前が付けられた小さなバージョンです。最後の6つの「対角線」モードは、Lumaサブブロックに固有のものです。"
    },
    {
      "indent": 0,
      "text": "11.3. Subblock Mode Contexts",
      "section_title": true,
      "ja": "11.3. サブブロックモードのコンテキスト"
    },
    {
      "indent": 3,
      "text": "The coding of subblock modes in key frames uses the modes already coded for the subblocks to the left of and above the subblock to select a probability array for decoding the current subblock mode. This is our first instance of contextual prediction, and there are several caveats associated with it:",
      "ja": "キーフレームでのサブブロックモードのコーディングは、サブブロックの左以降のサブブロックに対して既にコーディングされているモードを使用して、現在のサブブロックモードをデコードするための確率配列を選択します。これは、コンテキスト予測の最初のインスタンスであり、それに関連するいくつかの注意事項があります。"
    },
    {
      "indent": 3,
      "text": "1. The adjacency relationships between subblocks are based on the normal default raster placement of the subblocks.",
      "ja": "1. サブブロック間の隣接関係は、サブブロックの通常のデフォルトラスター配置に基づいています。"
    },
    {
      "indent": 3,
      "text": "2. The adjacent subblocks need not lie in the current macroblock. The subblocks to the left of the left-edge subblocks 0, 4, 8, and 12 are the right-edge subblocks 3, 7, 11, and 15, respectively, of the (already coded) macroblock immediately to the left. Similarly, the subblocks above the top-edge subblocks 0, 1, 2, and 3 are the bottom-edge subblocks 12, 13, 14, and 15 of the already-coded macroblock immediately above us.",
      "ja": "2. 隣接するサブブロックは、現在のマクロブロックにある必要はありません。左端のサブブロック0、4、8、および12の左側のサブブロックは、それぞれ右端のサブブロック3、7、11、および15です。同様に、トップエッジサブブロック0、1、2、および3の上のサブブロックは、私たちのすぐ上の既にコードされたマクロブロックのボトムエッジサブブロック12、13、14、および15です。"
    },
    {
      "indent": 3,
      "text": "3. For macroblocks on the top row or left edge of the image, some of the predictors will be non-existent. Such predictors are taken to have had the value B_DC_PRED, which, perhaps conveniently, takes the value 0 in the enumeration above. A simple management scheme for these contexts might maintain a row of above predictors and four left predictors. Before decoding the frame, the entire row is initialized to B_DC_PRED; before decoding each row of macroblocks, the four left predictors are also set to B_DC_PRED. After decoding a macroblock, the bottom four subblock modes are copied into the row predictor (at the current position, which then advances to be above the next macroblock), and the right four subblock modes are copied into the left predictor.",
      "ja": "3. 画像の一番上の行または左端のマクロブロックの場合、予測因子の一部は存在しません。このような予測因子は、値B_DC_PREDを持っていたと見なされます。これは、おそらく上記の列挙で値0を取得します。これらのコンテキストの単純な管理スキームは、上記の予測因子と4つの左予測因子の行を維持する場合があります。フレームをデコードする前に、行全体がB_DC_PREDに初期化されます。マクロブロックの各行をデコードする前に、4つの左予測子もB_DC_PREDに設定されます。マクロブロックをデコードした後、下の4つのサブブロックモードが行予測子にコピーされ（現在の位置で、次のマクロブロックの上に進む）、右の4つのサブブロックモードが左予測子にコピーされます。"
    },
    {
      "indent": 3,
      "text": "4. Many macroblocks will of course be coded using a 16x16 luma prediction mode. For the purpose of predicting ensuing subblock modes (only), such macroblocks derive a subblock mode, constant throughout the macroblock, from the 16x16 luma mode as follows: DC_PRED uses B_DC_PRED, V_PRED uses B_VE_PRED, H_PRED uses B_HE_PRED, and TM_PRED uses B_TM_PRED.",
      "ja": "4. もちろん、多くのマクロブロックは、16x16 LUMA予測モードを使用してコーディングされます。次のサブブロックモード（のみ）を予測するために、このようなマクロブロックは、次のように16x16 LUMAモードからマクロブロック全体で一定のサブブロックモードを導き出します。DC_PREDはB_DC_PREDを使用します。"
    },
    {
      "indent": 3,
      "text": "5. Although we discuss interframe modes in Section 16, we remark here that, while interframes do use all the intra-coding modes described here and below, the subblock modes in an interframe are coded using a single constant probability array that does not depend on any context.",
      "ja": "5. セクション16のインターフレームモードについては説明しますが、ここでは、インターフレームはここで説明するすべてのコードモードを使用しますが、インターフレームのサブブロックモードは、コンテキストに依存しない単一の定数確率配列を使用してコーディングされていることに注意してください。。"
    },
    {
      "indent": 3,
      "text": "The dependence of subblock mode probability on the nearby subblock mode context is most easily handled using a three-dimensional constant array:",
      "ja": "近くのサブブロックモードコンテキストに対するサブブロックモードの確率の依存性は、3次元定数配列を使用して最も簡単に処理されます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes] [num_intra_bmodes-1];",
      "ja": "const prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes] [num_intra_bmodes-1];"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The outer two dimensions of this array are indexed by the already-coded subblock modes above and to the left of the current block, respectively. The inner dimension is a typical tree probability list whose indices correspond to the even indices of the bmode_tree above. The mode for the j^(th) luma subblock is then",
      "ja": "この配列の外側の2つの寸法は、現在のブロックの上と左側の既にコードされたサブブロックモードによってインデックス付けされます。内側の寸法は、上記のbmode_treeの均等なインデックスにインデックスが対応する典型的なツリー確率リストです。j^（th）lumaサブブロックのモードは"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bmode = (intra_bmode) treed_read(d, bmode_tree, kf_bmode_prob\n  [A] [L]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where the 4x4 Y subblock index j varies from 0 to 15 in raster order, and A and L are the modes used above and to the left of the j^(th) subblock.",
      "ja": "4x4 YサブブロックインデックスJはラスター順序で0から15まで変化し、AとLはj^（th）サブブロックの上と左側に使用されるモードです。"
    },
    {
      "indent": 3,
      "text": "The contents of the kf_bmode_prob array are given at the end of this section.",
      "ja": "kf_bmode_prob配列の内容は、このセクションの最後に示されています。"
    },
    {
      "indent": 0,
      "text": "11.4. Chroma Modes",
      "section_title": true,
      "ja": "11.4. クロマモード"
    },
    {
      "indent": 3,
      "text": "After the Y mode (and optional subblock mode) specification comes the chroma mode. The chroma modes are a subset of the Y modes and are coded using the uv_mode_tree, as described in Section 8 and repeated here for convenience:",
      "ja": "Yモード（およびオプションのサブブロックモード）の仕様がクロマモードになります。クロマモードはYモードのサブセットであり、セクション8で説明されているように、UV_Mode_treeを使用してコード化され、ここでは便利なために繰り返されます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index uv_mode_tree [2 * (num_uv_modes - 1)] =\n{\n -DC_PRED, 2,           /* root: DC_PRED = \"0\", \"1\" subtree */\n  -V_PRED, 4,           /* \"1\" subtree:  V_PRED = \"10\",\n                           \"11\" subtree */\n   -H_PRED, -TM_PRED    /* \"11\" subtree: H_PRED = \"110\",\n                           TM_PRED = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As for the Y modes (in a key frame), the chroma modes are coded using a fixed, contextless probability table:",
      "ja": "Yモード（キーフレーム内）に関しては、クロマモードは、固定されたコンテキストレス確率表を使用してコーディングされます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob kf_uv_mode_prob [num_uv_modes - 1] = { 142, 114, 183};\nuv_mode = (intra_mbmode) treed_read(d, uv_mode_tree,\n  kf_uv_mode_prob);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This completes the description of macroblock prediction coding for key frames. As will be discussed in Section 16, the coding of intra modes within interframes is similar, but not identical, to that described here (and in the reference code) for prediction modes and, indeed, for all tree-coded data in VP8.",
      "ja": "これにより、キーフレームのマクロブロック予測コーディングの説明が完成します。セクション16で説明するように、インターフレーム内のイントラモードのコーディングは、予測モードについて、そして実際にはVP8のすべてのツリーコーディングデータについて、ここ（および参照コード）と類似していますが、同一ではありません。"
    },
    {
      "indent": 0,
      "text": "11.5. Subblock Mode Probability Table",
      "section_title": true,
      "ja": "11.5. サブブロックモード確率テーブル"
    },
    {
      "indent": 3,
      "text": "Finally, here is the fixed probability table used to decode subblock modes in key frames.",
      "ja": "最後に、キーフレームのサブブロックモードをデコードするために使用される固定確率テーブルを次に示します。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes]\n  [num_intra_bmodes-1] =\n{\n  {\n    { 231, 120,  48,  89, 115, 113, 120, 152, 112},\n    { 152, 179,  64, 126, 170, 118,  46,  70,  95},\n    { 175,  69, 143,  80,  85,  82,  72, 155, 103},\n    {  56,  58,  10, 171, 218, 189,  17,  13, 152},\n    { 144,  71,  10,  38, 171, 213, 144,  34,  26},\n    { 114,  26,  17, 163,  44, 195,  21,  10, 173},\n    { 121,  24,  80, 195,  26,  62,  44,  64,  85},\n    { 170,  46,  55,  19, 136, 160,  33, 206,  71},\n    {  63,  20,   8, 114, 114, 208,  12,   9, 226},\n    {  81,  40,  11,  96, 182,  84,  29,  16,  36}\n  },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "{\n  { 134, 183,  89, 137,  98, 101, 106, 165, 148},\n  {  72, 187, 100, 130, 157, 111,  32,  75,  80},\n  {  66, 102, 167,  99,  74,  62,  40, 234, 128},\n  {  41,  53,   9, 178, 241, 141,  26,   8, 107},\n  { 104,  79,  12,  27, 217, 255,  87,  17,   7},\n  {  74,  43,  26, 146,  73, 166,  49,  23, 157},\n  {  65,  38, 105, 160,  51,  52,  31, 115, 128},\n  {  87,  68,  71,  44, 114,  51,  15, 186,  23},\n  {  47,  41,  14, 110, 182, 183,  21,  17, 194},\n  {  66,  45,  25, 102, 197, 189,  23,  18,  22}\n},\n{\n  {  88,  88, 147, 150,  42,  46,  45, 196, 205},\n  {  43,  97, 183, 117,  85,  38,  35, 179,  61},\n  {  39,  53, 200,  87,  26,  21,  43, 232, 171},\n  {  56,  34,  51, 104, 114, 102,  29,  93,  77},\n  { 107,  54,  32,  26,  51,   1,  81,  43,  31},\n  {  39,  28,  85, 171,  58, 165,  90,  98,  64},\n  {  34,  22, 116, 206,  23,  34,  43, 166,  73},\n  {  68,  25, 106,  22,  64, 171,  36, 225, 114},\n  {  34,  19,  21, 102, 132, 188,  16,  76, 124},\n  {  62,  18,  78,  95,  85,  57,  50,  48,  51}\n},\n{\n  { 193, 101,  35, 159, 215, 111,  89,  46, 111},\n  {  60, 148,  31, 172, 219, 228,  21,  18, 111},\n  { 112, 113,  77,  85, 179, 255,  38, 120, 114},\n  {  40,  42,   1, 196, 245, 209,  10,  25, 109},\n  { 100,  80,   8,  43, 154,   1,  51,  26,  71},\n  {  88,  43,  29, 140, 166, 213,  37,  43, 154},\n  {  61,  63,  30, 155,  67,  45,  68,   1, 209},\n  { 142,  78,  78,  16, 255, 128,  34, 197, 171},\n  {  41,  40,   5, 102, 211, 183,   4,   1, 221},\n  {  51,  50,  17, 168, 209, 192,  23,  25,  82}\n},\n{\n  { 125,  98,  42,  88, 104,  85, 117, 175,  82},\n  {  95,  84,  53,  89, 128, 100, 113, 101,  45},\n  {  75,  79, 123,  47,  51, 128,  81, 171,   1},\n  {  57,  17,   5,  71, 102,  57,  53,  41,  49},\n  { 115,  21,   2,  10, 102, 255, 166,  23,   6},\n  {  38,  33,  13, 121,  57,  73,  26,   1,  85},\n  {  41,  10,  67, 138,  77, 110,  90,  47, 114},\n  { 101,  29,  16,  10,  85, 128, 101, 196,  26},\n  {  57,  18,  10, 102, 102, 213,  34,  20,  43},\n  { 117,  20,  15,  36, 163, 128,  68,   1,  26}\n},",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "{\n  { 138,  31,  36, 171,  27, 166,  38,  44, 229},\n  {  67,  87,  58, 169,  82, 115,  26,  59, 179},\n  {  63,  59,  90, 180,  59, 166,  93,  73, 154},\n  {  40,  40,  21, 116, 143, 209,  34,  39, 175},\n  {  57,  46,  22,  24, 128,   1,  54,  17,  37},\n  {  47,  15,  16, 183,  34, 223,  49,  45, 183},\n  {  46,  17,  33, 183,   6,  98,  15,  32, 183},\n  {  65,  32,  73, 115,  28, 128,  23, 128, 205},\n  {  40,   3,   9, 115,  51, 192,  18,   6, 223},\n  {  87,  37,   9, 115,  59,  77,  64,  21,  47}\n},\n{\n  { 104,  55,  44, 218,   9,  54,  53, 130, 226},\n  {  64,  90,  70, 205,  40,  41,  23,  26,  57},\n  {  54,  57, 112, 184,   5,  41,  38, 166, 213},\n  {  30,  34,  26, 133, 152, 116,  10,  32, 134},\n  {  75,  32,  12,  51, 192, 255, 160,  43,  51},\n  {  39,  19,  53, 221,  26, 114,  32,  73, 255},\n  {  31,   9,  65, 234,   2,  15,   1, 118,  73},\n  {  88,  31,  35,  67, 102,  85,  55, 186,  85},\n  {  56,  21,  23, 111,  59, 205,  45,  37, 192},\n  {  55,  38,  70, 124,  73, 102,   1,  34,  98}\n},\n{\n  { 102,  61,  71,  37,  34,  53,  31, 243, 192},\n  {  69,  60,  71,  38,  73, 119,  28, 222,  37},\n  {  68,  45, 128,  34,   1,  47,  11, 245, 171},\n  {  62,  17,  19,  70, 146,  85,  55,  62,  70},\n  {  75,  15,   9,   9,  64, 255, 184, 119,  16},\n  {  37,  43,  37, 154, 100, 163,  85, 160,   1},\n  {  63,   9,  92, 136,  28,  64,  32, 201,  85},\n  {  86,   6,  28,   5,  64, 255,  25, 248,   1},\n  {  56,   8,  17, 132, 137, 255,  55, 116, 128},\n  {  58,  15,  20,  82, 135,  57,  26, 121,  40}\n},\n{\n  { 164,  50,  31, 137, 154, 133,  25,  35, 218},\n  {  51, 103,  44, 131, 131, 123,  31,   6, 158},\n  {  86,  40,  64, 135, 148, 224,  45, 183, 128},\n  {  22,  26,  17, 131, 240, 154,  14,   1, 209},\n  {  83,  12,  13,  54, 192, 255,  68,  47,  28},\n  {  45,  16,  21,  91,  64, 222,   7,   1, 197},\n  {  56,  21,  39, 155,  60, 138,  23, 102, 213},\n  {  85,  26,  85,  85, 128, 128,  32, 146, 171},\n  {  18,  11,   7,  63, 144, 171,   4,   4, 246},\n  {  35,  27,  10, 146, 174, 171,  12,  26, 128}\n},",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  {\n    { 190,  80,  35,  99, 180,  80, 126,  54,  45},\n    {  85, 126,  47,  87, 176,  51,  41,  20,  32},\n    { 101,  75, 128, 139, 118, 146, 116, 128,  85},\n    {  56,  41,  15, 176, 236,  85,  37,   9,  62},\n    { 146,  36,  19,  30, 171, 255,  97,  27,  20},\n    {  71,  30,  17, 119, 118, 255,  17,  18, 138},\n    { 101,  38,  60, 138,  55,  70,  43,  26, 142},\n    { 138,  45,  61,  62, 219,   1,  81, 188,  64},\n    {  32,  41,  20, 117, 151, 142,  20,  21, 163},\n    { 112,  19,  12,  61, 195, 128,  48,   4,  24}\n  }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12. Intraframe Prediction",
      "section_title": true,
      "ja": "12. フレーム内予測"
    },
    {
      "indent": 3,
      "text": "Intraframe prediction uses already-coded macroblocks within the current frame to approximate the contents of the current macroblock. It applies to intra-coded macroblocks in an interframe and to all macroblocks in a key frame.",
      "ja": "内部フレーム予測では、現在のマクロブロックの内容を近似するために、現在のフレーム内の既にコードされたマクロブロックを使用します。インターフレーム内のコード中のマクロブロックと、キーフレームのすべてのマクロブロックに適用されます。"
    },
    {
      "indent": 3,
      "text": "Relative to the current macroblock \"M\", the already-coded macroblocks include all macroblocks above M together with the macroblocks on the same row as, and to the left of, M, though at most four of these macroblocks are actually used: the block \"A\" directly above M, the blocks immediately to the left and right of A, and the block immediately to the left of M.",
      "ja": "現在のマクロブロック「M」と比較して、すでにコーディングされたマクロブロックには、Mを超えるすべてのマクロブロックと、Mのマクロブロックと同じ行と同じマクロブロックが含まれます。「A」の真上の「A」、Aの左右にすぐにブロックが、すぐにMの左側にブロックがブロックされます。"
    },
    {
      "indent": 3,
      "text": "Each of the prediction modes (i.e., means of extrapolation from already-calculated values) uses fairly simple arithmetic on pixel values whose positions, relative to the current position, are defined by the mode.",
      "ja": "各予測モード（つまり、すでに計算された値からの外挿）は、現在の位置と比較して位置がモードによって定義されるピクセル値でかなり単純な算術を使用します。"
    },
    {
      "indent": 3,
      "text": "The chroma (U and V) and luma (Y) predictions are independent of each other.",
      "ja": "クロマ（uとv）とルーマ（y）の予測は互いに独立しています。"
    },
    {
      "indent": 3,
      "text": "The relative addressing of pixels applied to macroblocks on the upper row or left column of the frame will sometimes cause pixels outside the visible frame to be referenced. Usually such out-of-bounds pixels have an assumed value of 129 for pixels to the left of the leftmost column of the visible frame and 127 for pixels above the top row of the visible frame (including the special case of the pixel above and to the left of the top-left pixel in the visible frame). Exceptions to this (associated to certain modes) will be noted below.",
      "ja": "フレームの上の列または左列のマクロブロックに適用されるピクセルの相対的なアドレス指定により、目に見えるフレームの外側のピクセルが参照されることがあります。通常、このような境界外のピクセルは、可視フレームの左端の列の左側のピクセルで129の値、可視フレームの上列の上のピクセルで127の値を持っています（上のピクセルの特殊なケースを含む可視フレームの左上ピクセルの左側）。これの例外（特定のモードに関連付けられています）を以下に示します。"
    },
    {
      "indent": 3,
      "text": "The already-coded macroblocks referenced by intra-prediction have been \"reconstructed\", that is, have been predicted and residue-adjusted (as described in Section 14), but have not been loop-filtered. While it does process the edges between individual macroblocks and individual subblocks, loop filtering (described in Section 15) is applied to the frame as a whole, after all of the macroblocks have been reconstructed.",
      "ja": "予測内で参照されているすでにコードされたマクロブロックは「再構築」されています。つまり、予測され、残留調整が（セクション14で説明されているように）が、ループフィルタリングされていません。個々のマクロブロックと個々のサブブロック間のエッジを処理しますが、すべてのマクロブロックが再構築された後、ループフィルタリング（セクション15で説明）がフレーム全体に適用されます。"
    },
    {
      "indent": 0,
      "text": "12.1. mb_skip_coeff",
      "section_title": true,
      "ja": "12.1. MB_SKIP_COEFF"
    },
    {
      "indent": 3,
      "text": "The single bool flag is decoded using prob_skip_false if and only if mb_no_skip_coeff is set to 1 (see Sections 9.10 and 9.11). If mb_no_skip_coeff is set to 0, then this value defaults to 0.",
      "ja": "単一のブールフラグは、mb_no_skip_coeffが1に設定されている場合にのみ、prob_skip_falseを使用してデコードされます（セクション9.10および9.11を参照）。MB_NO_SKIP_COEFFが0に設定されている場合、この値はデフォルト0になります。"
    },
    {
      "indent": 0,
      "text": "12.2. Chroma Prediction",
      "section_title": true,
      "ja": "12.2. クロマ予測"
    },
    {
      "indent": 3,
      "text": "The chroma prediction is a little simpler than the luma prediction, so we treat it first. Each of the chroma modes treats U and V identically; that is, the U and V prediction values are calculated in parallel, using the same relative addressing and arithmetic in each of the two planes.",
      "ja": "クロマの予測は、LUMA予測よりも少し簡単ですので、最初に扱います。各クロマモードはuとvを同じように処理します。つまり、UおよびV予測値は、2つの平面のそれぞれで同じ相対アドレス指定と算術を使用して並行して計算されます。"
    },
    {
      "indent": 3,
      "text": "The modes extrapolate prediction values using the 8-pixel row \"A\" lying immediately above the block (that is, the bottom chroma row of the macroblock immediately above the current macroblock) and the 8-pixel column \"L\" immediately to the left of the block (that is, the rightmost chroma column of the macroblock immediately to the left of the current macroblock).",
      "ja": "モードは、ブロックのすぐ上にある8ピクセルの行「A」（つまり、現在のマクロブロックのすぐ上のマクロブロックの下部クロマ行）と8ピクセルの列「L」をすぐに左側の左側に使用して予測値を推定します。ブロック（つまり、現在のマクロブロックの左側にあるマクロブロックの右端のクロマ列）。"
    },
    {
      "indent": 3,
      "text": "Vertical prediction (chroma mode V_PRED) simply fills each 8-pixel row of the 8x8 chroma block with a copy of the \"above\" row (A). If the current macroblock lies on the top row of the frame, all 8 of the pixel values in A are assigned the value 127.",
      "ja": "垂直予測（Chroma Mode V_Pred）は、8x8 Chromaブロックの各8ピクセルの行を「上」行（a）のコピーに単純に埋めるだけです。現在のマクロブロックがフレームの一番上の行にある場合、Aのピクセル値の8つすべてが値127に割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Similarly, horizontal prediction (H_PRED) fills each 8-pixel column of the 8x8 chroma block with a copy of the \"left\" column (L). If the current macroblock is in the left column of the frame, all 8 pixel values in L are assigned the value 129.",
      "ja": "同様に、水平予測（H_PRED）は、8x8 Chromaブロックの各8ピクセル列に「左」列（L）のコピーを埋めます。現在のマクロブロックがフレームの左列にある場合、Lの8つのピクセル値はすべて値129に割り当てられます。"
    },
    {
      "indent": 3,
      "text": "DC prediction (DC_PRED) fills the 8x8 chroma block with a single value. In the generic case of a macroblock lying below the top row and right of the leftmost column of the frame, this value is the average of the 16 (genuinely visible) pixels in the (union of the) above row A and left column L.",
      "ja": "DC予測（DC_PRED）は、8x8クロマブロックに単一の値で埋められます。フレームの左端の列の一番上の行と右下にあるマクロブロックの一般的なケースでは、この値は、上の列Aおよび左列Lの（結合）の（真に見える）ピクセルの平均です。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the current macroblock lies on the top row of the frame, the average of the 8 pixels in L is used; if it lies in the left column of the frame, the average of the 8 pixels in A is used.",
      "ja": "それ以外の場合、現在のマクロブロックがフレームの一番上の行にある場合、Lの8ピクセルの平均が使用されます。フレームの左列にある場合、Aの8ピクセルの平均が使用されます。"
    },
    {
      "indent": 3,
      "text": "Note that the averages used in these exceptional cases are not the same as those that would be arrived at by using the out-of-bounds A and L values defined for V_PRED and H_PRED. In the case of the leftmost macroblock on the top row of the frame, the 8x8 block is simply filled with the constant value 128.",
      "ja": "これらの例外的なケースで使用されている平均は、V_PREDおよびH_PREDで定義されているバウンドAおよびL値を使用して到達するものと同じではないことに注意してください。フレームの一番上の行にある左端のマクロブロックの場合、8x8ブロックは単に定数128で満たされています。"
    },
    {
      "indent": 3,
      "text": "For DC_PRED, apart from the exceptional case of the top-left macroblock, we are averaging either 16 or 8 pixel values to get a single prediction value that fills the 8x8 block. The rounding is done as follows:",
      "ja": "DC_PREDの場合、左上マクロブロックの例外的なケースとは別に、16ピクセル値または8ピクセル値のいずれかを平均して、8x8ブロックを埋める単一の予測値を取得しています。丸めは次のように行われます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int sum;  /* sum of 8 or 16 pixels at (at least) 16-bit precision */\nint shf;  /* base 2 logarithm of the number of pixels (3 or 4) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pixel DCvalue = (sum + (1 << (shf-1))) >> shf;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Because the summands are all valid pixels, no \"clamp\" is necessary in the calculation of DCvalue.",
      "ja": "summandsはすべて有効なピクセルであるため、dcvalueの計算では「クランプ」は必要ありません。"
    },
    {
      "indent": 3,
      "text": "The remaining \"True Motion\" (TM_PRED) chroma mode gets its name from an older technique of video compression used by On2 Technologies, to which it bears some relation. In addition to the row \"A\" and column \"L\", TM_PRED uses the pixel \"P\" above and to the left of the chroma block.",
      "ja": "残りの「True Motion」（TM_PRED）Chromaモードは、On2テクノロジーが使用する古いビデオ圧縮のテクニックからその名前を取得し、その関係にあります。行「A」と列「L」に加えて、TM_PREDはクロマブロックの上と左側にピクセル \"P\"を使用します。"
    },
    {
      "indent": 3,
      "text": "The following figure gives an example of how TM_PRED works:",
      "ja": "次の図は、TM_PREDがどのように機能するかの例を示しています。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| P   | A0  | A1  | A2  | A3  | A4  | A5  | A6  | A7  |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| L0  | X00 | X01 | X02 | X03 | X04 | X05 | X06 | X07 |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| L1  | X10 | X11 | X12 | X13 | X14 | X15 | X16 | X17 |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| L2  | X20 | X21 | X22 | X23 | X24 | X25 | X26 | X27 |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| L3  | X30 | X31 | X32 | X33 | X34 | X35 | X36 | X37 |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| L4  | X40 | X41 | X42 | X43 | X44 | X45 | X46 | X47 |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| L5  | X50 | X51 | X52 | X53 | X54 | X55 | X56 | X57 |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| L6  | X60 | X61 | X62 | X63 | X64 | X65 | X66 | X67 |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| L7  | X70 | X71 | X72 | X73 | X74 | X75 | X76 | X77 |\n|-----|-----|-----|-----|-----|-----|-----|-----|-----|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where P, As, and Ls represent reconstructed pixel values from previously coded blocks, and X00 through X77 represent predicted values for the current block. TM_PRED uses the following equation to calculate X_ij:",
      "ja": "ここで、P、AS、およびLSは、以前にコード化されたブロックからの再構築されたピクセル値を表し、X00からX77は現在のブロックの予測値を表します。TM_PREDは、次の方程式を使用してX_IJを計算します。"
    },
    {
      "indent": 3,
      "text": "X_ij = L_i + A_j - P (i, j=0, 1, 2, 3)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The exact algorithm is as follows:",
      "ja": "正確なアルゴリズムは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void TMpred(\n    Pixel b[8][8],      /* chroma (U or V) prediction block */\n    const Pixel A[8],   /* row of already-constructed pixels\n                           above block */\n    const Pixel L[8],   /* column of \"\" just to the left of\n                           block */\n    const Pixel P       /* pixel just to the left of A and\n                           above L*/\n) {\n    int r = 0;          /* row */\n    do {\n        int c = 0;      /* column */\n        do {\n            b[r][c] = clamp255(L[r]+ A[c] - P);\n        } while (++c < 8);\n    } while (++r < 8);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the process could equivalently be described as propagating the vertical differences between pixels in L (starting from P), using the pixels from A to start each column.",
      "ja": "このプロセスは、Aからピクセルを使用して各列のピクセルを使用して、L（Pから開始）のピクセル間の垂直の違いを伝播するものとして同等に説明できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "An implementation of chroma intra-prediction may be found in the reference decoder file predict.c (Section 20.14).",
      "ja": "Chroma Intraの予測の実装は、参照デコーダーファイルPredict.c（セクション20.14）に記載されている場合があります。"
    },
    {
      "indent": 3,
      "text": "Unlike DC_PRED, for macroblocks on the top row or left edge, TM_PRED does use the out-of-bounds values of 127 and 129 (respectively) defined for V_PRED and H_PRED.",
      "ja": "DC_PREDとは異なり、一番上の行または左端のマクロブロックの場合、TM_PREDは、V_PREDおよびH_PREDに対して定義された127および129（それぞれ）のアウトオブバウンド値を使用します。"
    },
    {
      "indent": 0,
      "text": "12.3. Luma Prediction",
      "section_title": true,
      "ja": "12.3. LUMA予測"
    },
    {
      "indent": 3,
      "text": "The prediction processes for the first four 16x16 luma modes (DC_PRED, V_PRED, H_PRED, and TM_PRED) are essentially identical to the corresponding chroma prediction processes described above, the only difference being that we are predicting a single 16x16 luma block instead of two 8x8 chroma blocks.",
      "ja": "最初の4つの16x16 LUMAモード（DC_PRED、V_PRED、H_PRED、およびTM_PRED）の予測プロセスは、上記の対応するクロマ予測プロセスと本質的に同一です。ブロック。"
    },
    {
      "indent": 3,
      "text": "Thus, the row \"A\" and column \"L\" here contain 16 pixels, the DC prediction is calculated using 16 or 32 pixels (and shf is 4 or 5), and we of course fill the entire prediction buffer, that is, 16 rows (or columns) containing 16 pixels each. The reference implementation of 16x16 luma prediction is also in predict.c.",
      "ja": "したがって、ここでは行「A」と列「L」には16ピクセルが含まれ、DC予測には16ピクセルまたは32ピクセル（およびSHFは4または5）を使用して計算され、もちろん予測バッファー全体、つまり16を埋めます。それぞれ16ピクセルを含む行（または列）。16x16 LUMA予測の参照実装もPredict.cにあります。"
    },
    {
      "indent": 3,
      "text": "In the remaining luma mode (B_PRED), each 4x4 Y subblock is independently predicted using one of ten modes (listed, along with their encodings, in Section 11).",
      "ja": "残りのLUMAモード（B_PRED）では、各4x4 Yサブブロックは、10個のモードのいずれかを使用して独立して予測されます（セクション11のエンコーディングとともにリストされています）。"
    },
    {
      "indent": 3,
      "text": "Also, unlike the full-macroblock modes already described, some of the subblock modes use prediction pixels above and to the right of the current subblock. In detail, each 4x4 subblock \"B\" is predicted using (at most) the 4-pixel column \"L\" immediately to the left of B and the 8-pixel row \"A\" immediately above B, consisting of the 4 pixels above B followed by the 4 adjacent pixels above and to the right of B, together with the single pixel \"P\" immediately to the left of A (and immediately above L).",
      "ja": "また、すでに説明されているフルマクロブロックモードとは異なり、一部のサブブロックモードでは、現在のサブブロックの右側と右側に予測ピクセルを使用しています。詳細には、各4x4サブブロック「B」は、（せいぜい）4ピクセル列「L」をBの左側にすぐに使用して予測され、8ピクセルの行「A」はBのすぐ上にあり、Bの上の4ピクセルの上の4ピクセルで構成されています。続いて、Bの上と右側の4つの隣接するピクセルと、Aの左側（およびLのすぐ上）の単一ピクセル「P」とともに続きます。"
    },
    {
      "indent": 3,
      "text": "For the purpose of subblock intra-prediction, the pixels immediately to the left and right of a pixel in a subblock are the same as the pixels immediately to the left and right of the corresponding pixel in the frame buffer \"F\". Vertical offsets behave similarly: The above row A lies immediately above B in F, and the adjacent pixels in the left column L are separated by a single row in F.",
      "ja": "サブブロック内予測の目的のために、サブブロックのピクセルの左右のピクセルは、フレームバッファー「F」の対応するピクセルの左右のピクセルと同じです。垂直オフセットも同様に動作します。上記の行AはFのBのすぐ上にあり、左列Lの隣接するピクセルはFの単一行で分離されます。"
    },
    {
      "indent": 3,
      "text": "Because entire macroblocks (as opposed to their constituent subblocks) are reconstructed in raster-scan order, for subblocks lying along the right edge (and not along the top row) of the current macroblock, the four \"extra\" prediction pixels in A above and to the right of B have not yet actually been constructed.",
      "ja": "マクロブロック全体（構成要素のサブブロックとは対照的に）は、現在のマクロブロックの右端に沿って（そして一番上の列に沿ってではない）サブブロックのために、ラスタースキャンの順序で再構築されているため、上の4つの「エクストラ」予測ピクセルとBの右側にはまだ実際には構築されていません。"
    },
    {
      "indent": 3,
      "text": "Subblocks 7, 11, and 15 are affected. All three of these subblocks use the same extra pixels as does subblock 3 (at the upper right corner of the macroblock), namely the 4 pixels immediately above and to the right of subblock 3. Writing (R,C) for a frame buffer position offset from the upper left corner of the current macroblock by R rows and C columns, the extra pixels for all the right-edge subblocks (3, 7, 11, and 15) are at positions (-1,16), (-1,17), (-1,18), and (-1,19). For the rightmost macroblock in each macroblock row except the top row, the extra pixels shall use the same value as the pixel at position (-1,15), which is the rightmost visible pixel on the line immediately above the macroblock row. For the top macroblock row, all the extra pixels assume a value of 127.",
      "ja": "サブブロック7、11、および15は影響を受けます。これらの3つのサブブロックはすべて、サブブロック3（マクロブロックの右上隅）と同じ追加ピクセルを使用します。現在のマクロブロックの左上隅からrowsとc列によってオフセットされ、すべての右端のサブブロック（3、7、11、および15の追加ピクセルが位置（-1,16）にあります（-1、17）、（-1,18）、および（-1,19）。各マクロブロック行の右端のマクロブロックの場合、上の行を除くマクロブロックの行は、エキストラピクセルが位置のピクセルと同じ値（-1,15）と同じ値を使用します。トップマクロブロック行の場合、すべての追加ピクセルは127の値を想定しています。"
    },
    {
      "indent": 3,
      "text": "The details of the prediction modes are most easily described in code.",
      "ja": "予測モードの詳細は、コードで最も簡単に説明されています。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Result pixels are often averages of two or three predictor\n   pixels.  The following subroutines are used to calculate\n   these averages.  Because the arguments are valid pixels, no\n   clamping is necessary.  An actual implementation would\n   probably use inline functions or macros. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Compute weighted average centered at y w/adjacent x, z */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pixel avg3(Pixel x, Pixel y, Pixel z) {\n  return (x + y + y + z + 2) >> 2;}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Weighted average of 3 adjacent pixels centered at p */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pixel avg3p(const Pixel *p) { return avg3(p[-1], p[0], p[1]);}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Simple average of x and y */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pixel avg2(Pixel x, Pixel y) { return (x + y + 1) >> 1;}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Average of p[0] and p[1] may be considered to be a synthetic\n   pixel lying between the two, that is, one half-step past p. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pixel avg2p(const Pixel *p) { return avg2(p[0], p[1]);}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void subblock_intra_predict(\n    Pixel B[4][4],     /* Y subblock prediction buffer */\n    const Pixel *A,    /* A[0]...A[7] = above row, A[-1] = P */\n    const Pixel *L,    /* L[0]...L[3] = left column, L[-1] = P */\n    intra_bmode mode   /* enum is in Section 11.2 */\n) {\n    Pixel E[9];        /* 9 already-constructed edge pixels */\n    E[0] = L[3];  E[1] = L[2];  E[2] = L[1];  E[3] = L[0];\n    E[4] = A[-1];      /* == L[-1] == P */\n    E[5] = A[0];  E[6] = A[1];  E[7] = A[2];  E[8] = A[3];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "switch(mode) {\n  /* First four modes are similar to corresponding\n     full-block modes. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_DC_PRED:\n{\n    int v = 4;      /* DC sum/avg, 4 is rounding adjustment */\n    int i = 0;  do { v += A[i] + L[i];}  while (++i < 4);\n    v >>= 3;        /* averaging 8 pixels */\n    i = 0;  do {    /* fill prediction buffer with constant DC\n                       value */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        int j = 0;  do { B[i][j] = v;}  while (++j < 4);\n    } while (++i < 4);\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_TM_PRED: /* just like 16x16 TM_PRED */\n{\n    int r = 0;  do {\n        int c = 0;  do {\n            B[r][c] = clamp255(L[r] + A[c] - A[-1]);\n        } while (++c < 4);\n    } while (++r < 4);\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_VE_PRED: /* like 16x16 V_PRED except using averages */\n{\n    int c = 0;  do { /* all 4 rows = smoothed top row */\n        B[0][c] = B[1][c] = B[2][c] = B[3][c] = avg3p(A + c);\n    } while (++c < 4);\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_HE_PRED: /* like 16x16 H_PRED except using averages */\n{\n    /* Bottom row is exceptional because L[4] does not exist */\n    int v = avg3(L[2], L[3], L[3]);\n    int r = 3;  while (1) {  /* all 4 columns = smoothed left\n                                column */\n        B[r][0] = B[r][1] = B[r][2] = B[r][3] = v;\n        if (--r < 0)\n            break;\n        v = avg3p(L + r);  /* upper 3 rows use average of\n                               3 pixels */\n    }\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* The remaining six \"diagonal\" modes subdivide the\n   prediction buffer into diagonal lines.  All the pixels\n   on each line are assigned the same value; this value is\n   (a smoothed or synthetic version of) an\n   already-constructed predictor value lying on the same\n   line.  For clarity, in the comments, we express the\n   positions of these predictor pixels relative to the\n   upper left corner of the destination array B.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "These modes are unique to subblock prediction and have\nno full-block analogs.  The first two use lines at\n+|- 45 degrees from horizontal (or, equivalently,\nvertical), that is, lines whose slopes are +|- 1. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_LD_PRED:    /* southwest (left and down) step =\n                      (-1, 1) or (1,-1) */\n    /* avg3p(A + j) is the \"smoothed\" pixel at (-1,j) */\n    B[0][0] = avg3p(A + 1);\n    B[0][1] = B[1][0] = avg3p(A + 2);\n    B[0][2] = B[1][1] = B[2][0] = avg3p(A + 3);\n    B[0][3] = B[1][2] = B[2][1] = B[3][0] = avg3p(A + 4);\n    B[1][3] = B[2][2] = B[3][1] = avg3p(A + 5);\n    B[2][3] = B[3][2] = avg3p(A + 6);\n    B[3][3] = avg3(A[6], A[7], A[7]); /* A[8] does not exist */\n    break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_RD_PRED: /* southeast (right and down) step =\n                   (1,1) or (-1,-1) */\n    B[3][0] = avg3p(E + 1);  /* predictor is from (2, -1) */\n    B[3][1] = B[2][0] = avg3p(E + 2);  /* (1, -1) */\n    B[3][2] = B[2][1] = B[1][0] = avg3p(E + 3);  /* (0, -1) */\n    B[3][3] = B[2][2] = B[1][1] = B[0][0] =\n      avg3p(E + 4);  /* (-1, -1) */\n    B[2][3] = B[1][2] = B[0][1] = avg3p(E + 5);  /* (-1, 0) */\n    B[1][3] = B[0][2] = avg3p(E + 6);  /* (-1, 1) */\n    B[0][3] = avg3p(E + 7);  /* (-1, 2) */\n    break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* The remaining 4 diagonal modes use lines whose slopes are\n   +|- 2 and +|- 1/2.  The angles of these lines are roughly\n   +|- 27 degrees from horizontal or vertical.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Unlike the 45 degree diagonals, here we often need to\n\"synthesize\" predictor pixels midway between two actual\npredictors using avg2p(p), which we think of as returning\nthe pixel \"at\" p[1/2]. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_VR_PRED:    /* SSE (vertical right) step =\n                      (2,1) or (-2,-1) */\n    B[3][0] = avg3p(E + 2);  /* predictor is from (1, -1) */\n    B[2][0] = avg3p(E + 3);  /* (0, -1) */\n    B[3][1] = B[1][0] = avg3p(E + 4);  /* (-1,   -1) */\n    B[2][1] = B[0][0] = avg2p(E + 4);  /* (-1, -1/2) */\n    B[3][2] = B[1][1] = avg3p(E + 5);  /* (-1,    0) */\n    B[2][2] = B[0][1] = avg2p(E + 5);  /* (-1,  1/2) */\n    B[3][3] = B[1][2] = avg3p(E + 6);  /* (-1,    1) */\n    B[2][3] = B[0][2] = avg2p(E + 6);  /* (-1,  3/2) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "B[1][3] = avg3p(E + 7);  /* (-1, 2) */\nB[0][3] = avg2p(E + 7);  /* (-1, 5/2) */\nbreak;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_VL_PRED:    /* SSW (vertical left) step =\n                      (2,-1) or (-2,1) */\n    B[0][0] = avg2p(A);  /* predictor is from (-1, 1/2) */\n    B[1][0] = avg3p(A + 1);  /* (-1, 1) */\n    B[2][0] = B[0][1] = avg2p(A + 1);  /* (-1, 3/2) */\n    B[1][1] = B[3][0] = avg3p(A + 2);  /* (-1,   2) */\n    B[2][1] = B[0][2] = avg2p(A + 2);  /* (-1, 5/2) */\n    B[3][1] = B[1][2] = avg3p(A + 3);  /* (-1,   3) */\n    B[2][2] = B[0][3] = avg2p(A + 3);  /* (-1, 7/2) */\n    B[3][2] = B[1][3] = avg3p(A + 4);  /* (-1,   4) */\n    /* Last two values do not strictly follow the pattern. */\n    B[2][3] = avg3p(A + 5);  /* (-1, 5) [avg2p(A + 4) =\n                                 (-1,9/2)] */\n    B[3][3] = avg3p(A + 6);  /* (-1, 6) [avg3p(A + 5) =\n                                 (-1,5)] */\n    break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_HD_PRED:    /* ESE (horizontal down) step =\n                      (1,2) or (-1,-2) */\n    B[3][0] = avg2p(E);  /* predictor is from (5/2, -1) */\n    B[3][1] = avg3p(E + 1);  /* (2, -1) */\n    B[2][0] = B[3][2] = svg2p(E + 1);  /* ( 3/2, -1) */\n    B[2][1] = B[3][3] = avg3p(E + 2);  /* (   1, -1) */\n    B[2][2] = B[1][0] = avg2p(E + 2);  /* ( 1/2, -1) */\n    B[2][3] = B[1][1] = avg3p(E + 3);  /* (   0, -1) */\n    B[1][2] = B[0][0] = avg2p(E + 3);  /* (-1/2, -1) */\n    B[1][3] = B[0][1] = avg3p(E + 4);  /* (  -1, -1) */\n    B[0][2] = avg3p(E + 5);  /* (-1, 0) */\n    B[0][3] = avg3p(E + 6);  /* (-1, 1) */\n    break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "case B_HU_PRED:    /* ENE (horizontal up) step = (1,-2)\n                      or (-1,2) */\n    B[0][0] = avg2p(L);  /* predictor is from (1/2, -1) */\n    B[0][1] = avg3p(L + 1);  /* (1, -1) */\n    B[0][2] = B[1][0] = avg2p(L + 1);  /* (3/2, -1) */\n    B[0][3] = B[1][1] = avg3p(L + 2);  /* (  2, -1) */\n    B[1][2] = B[2][0] = avg2p(L + 2);  /* (5/2, -1) */\n    B[1][3] = B[2][1] = avg3(L[2], L[3], L[3]);  /* (3, -1) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        /* Not possible to follow pattern for much of the bottom\n           row because no (nearby) already-constructed pixels lie\n           on the diagonals in question. */\n        B[2][2] = B[2][3] = B[3][0] = B[3][1] = B[3][2] = B[3][3]\n          = L[3];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The reference decoder implementation of subblock intra-prediction may be found in predict.c (Section 20.14).",
      "ja": "サブブロック内予測の参照デコーダー実装は、Predict.C（セクション20.14）に記載されている場合があります。"
    },
    {
      "indent": 0,
      "text": "13. DCT Coefficient Decoding",
      "section_title": true,
      "ja": "13. DCT係数デコード"
    },
    {
      "indent": 3,
      "text": "The second data partition consists of an encoding of the quantized DCT (and WHT) coefficients of the residue signal. As discussed in the format overview (Section 2), for each macroblock, the residue is added to the (intra- or inter-generated) prediction buffer to produce the final (except for loop filtering) reconstructed macroblock.",
      "ja": "2番目のデータパーティションは、残基信号の量子化されたDCT（およびWHT）係数のエンコードで構成されています。フォーマットの概要（セクション2）で説明したように、各マクロブロックについて、残基は（ループフィルタリングを除く）再構築されたマクロブロックを生成するために（生成または相互に生成された）予測バッファーに追加されます。"
    },
    {
      "indent": 3,
      "text": "VP8 works exclusively with 4x4 DCTs and WHTs, applied to the 24 (or 25 with the Y2 subblock) 4x4 subblocks of a macroblock. The ordering of macroblocks within any of the \"residue\" partitions in general follows the same raster scan as used in the first \"prediction\" partition.",
      "ja": "VP8は、マクロブロックの4x4サブブロック24（またはY2サブブロックで25）に適用される4x4 DCTおよびWHTSのみで機能します。一般に、「残基」パーティションのいずれか内でのマクロブロックの順序は、最初の「予測」パーティションで使用されたのと同じラスタースキャンに従います。"
    },
    {
      "indent": 3,
      "text": "For all intra- and inter-prediction modes apart from B_PRED (intra: whose Y subblocks are independently predicted) and SPLITMV (inter), each macroblock's residue record begins with the Y2 component of the residue, coded using a WHT. B_PRED and SPLITMV coded macroblocks omit this WHT and specify the 0th DCT coefficient in each of the 16 Y subblocks.",
      "ja": "B_PRED（Yサブブロックが独立して予測されている）とSplitMV（Inter）を除いて、すべての予測および相間モードについて、各マクロブロックの残基レコードは、WHTを使用してコード化された残基のY2成分から始まります。B_PREDおよびSPLITMVコード化されたマクロブロックは、このWHTを省略し、16 Yの各サブブロックで0番目のDCT係数を指定します。"
    },
    {
      "indent": 3,
      "text": "After the optional Y2 block, the residue record continues with 16 DCTs for the Y subblocks, followed by 4 DCTs for the U subblocks, ending with 4 DCTs for the V subblocks. The subblocks occur in the usual order.",
      "ja": "オプションのY2ブロックの後、残差記録はYサブブロックの16 DCTで続き、続いてUサブブロックに4 dCTが続き、Vサブブロックの4つのDCTで終了します。サブブロックは通常の順序で発生します。"
    },
    {
      "indent": 3,
      "text": "The DCTs and WHT are tree-coded using a 12-element alphabet whose members we call \"tokens\". Except for the end-of-block token (which sets the remaining subblock coefficients to zero and is followed by the next block), each token (sometimes augmented with data immediately following the token) specifies the value of the single coefficient at the current (implicit) position and is followed by a token applying to the next (implicit) position.",
      "ja": "DCTとWHTは、メンバーが「トークン」と呼ぶ12要素のアルファベットを使用してツリーコードされています。ブロック終了トークン（残りのサブブロック係数をゼロに設定し、次のブロックが続く）を除き、各トークン（トークンの直後のデータで拡張されることもあります）は、電流の単一係数の値を指定します（暗黙的）位置に続いて、次の（暗黙の）位置に適用されるトークンが続きます。"
    },
    {
      "indent": 3,
      "text": "For all the Y and chroma subblocks, the ordering of the coefficients follows a so-called zig-zag order. DCTs begin at coefficient 1 if Y2 is present, and begin at coefficient 0 if Y2 is absent. The WHT for a Y2 subblock always begins at coefficient 0.",
      "ja": "すべてのYおよびChromaサブブロックについて、係数の順序は、いわゆるジグザグ順序に従います。dctsは、y2が存在する場合は係数1で始まり、y2が存在しない場合は係数0で開始します。Y2サブブロックのWHTは常に係数0で始まります。"
    },
    {
      "indent": 0,
      "text": "13.1. Macroblock without Non-Zero Coefficient Values",
      "section_title": true,
      "ja": "13.1. 非ゼロ係数値のないマクロブロック"
    },
    {
      "indent": 3,
      "text": "If the flag within macroblock (MB) MODE_INFO indicates that a macroblock does not have any non-zero coefficients, the decoding process of DCT coefficients is skipped for the macroblock.",
      "ja": "Macroblock（MB）Mode_Info内のフラグがマクロブロックにゼロ係数がないことを示している場合、DCT係数のデコードプロセスがマクロブロック用にスキップされます。"
    },
    {
      "indent": 0,
      "text": "13.2. Coding of Individual Coefficient Values",
      "section_title": true,
      "ja": "13.2. 個々の係数値のコーディング"
    },
    {
      "indent": 3,
      "text": "The coding of coefficient tokens is the same for the DCT and WHT, and for the remainder of this section \"DCT\" should be taken to mean either DCT or WHT.",
      "ja": "係数トークンのコーディングはDCTおよびWHTで同じであり、このセクションの残りの部分では、「DCT」はDCTまたはWHTのいずれかを意味すると考えられる必要があります。"
    },
    {
      "indent": 3,
      "text": "All tokens (except end-of-block) specify either a single unsigned value or a range of unsigned values (immediately) followed by a simple probabilistic encoding of the offset of the value from the base of that range.",
      "ja": "すべてのトークン（ブロックの終了を除く）は、単一の符号なしの値または符号なしの値の範囲（すぐに）のいずれかを指定し、その後、その範囲のベースからの値のオフセットの単純な確率エンコードが続きます。"
    },
    {
      "indent": 3,
      "text": "Non-zero values (of either type) are then followed by a flag indicating the sign of the coded value (negative if 1, positive if 0).",
      "ja": "次に、非ゼロ値（いずれかのタイプの）に続いて、コード化された値の符号を示すフラグが続きます（負の場合は負、0の場合は正です）。"
    },
    {
      "indent": 3,
      "text": "Below are the tokens and decoding tree.",
      "ja": "以下は、トークンとデコードツリーです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef enum\n{\n    DCT_0,      /* value 0 */\n    DCT_1,      /* 1 */\n    DCT_2,      /* 2 */\n    DCT_3,      /* 3 */\n    DCT_4,      /* 4 */\n    dct_cat1,   /* range 5 - 6  (size 2) */\n    dct_cat2,   /* 7 - 10   (4) */\n    dct_cat3,   /* 11 - 18  (8) */\n    dct_cat4,   /* 19 - 34  (16) */\n    dct_cat5,   /* 35 - 66  (32) */\n    dct_cat6,   /* 67 - 2048  (1982) */\n    dct_eob,    /* end of block */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    num_dct_tokens   /* 12 */\n}\ndct_token;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index coeff_tree [2 * (num_dct_tokens - 1)] =\n{\n -dct_eob, 2,               /* eob = \"0\"   */\n  -DCT_0, 4,                /* 0   = \"10\"  */\n   -DCT_1, 6,               /* 1   = \"110\" */\n    8, 12,\n     -DCT_2, 10,            /* 2   = \"11100\" */\n      -DCT_3, -DCT_4,       /* 3   = \"111010\", 4 = \"111011\" */\n     14, 16,\n      -dct_cat1, -dct_cat2, /* cat1 =  \"111100\",\n                               cat2 = \"111101\" */\n     18, 20,\n      -dct_cat3, -dct_cat4, /* cat3 = \"1111100\",\n                               cat4 = \"1111101\" */\n      -dct_cat5, -dct_cat6  /* cat4 = \"1111110\",\n                               cat4 = \"1111111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In general, all DCT coefficients are decoded using the same tree. However, if the preceding coefficient is a DCT_0, decoding will skip the first branch, since it is not possible for dct_eob to follow a DCT_0.",
      "ja": "一般に、すべてのDCT係数は同じツリーを使用してデコードされます。ただし、前述の係数がDCT_0の場合、DCT_EOBがDCT_0に従うことは不可能なため、デコードは最初のブランチをスキップします。"
    },
    {
      "indent": 3,
      "text": "The tokens dct_cat1 ... dct_cat6 specify ranges of unsigned values, the value within the range being formed by adding an unsigned offset (whose width is 1, 2, 3, 4, 5, or 11 bits, respectively) to the base of the range, using the following algorithm and fixed probability tables.",
      "ja": "トークンDCT_CAT1 ... DCT_CAT6は、署名されていない値の範囲を指定します。範囲内の値は、署名されていないオフセット（幅がそれぞれ1、2、3、4、5、または11ビット）を追加することで形成されます。範囲、次のアルゴリズムと固定確率表を使用します。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uint DCTextra(bool_decoder *d, const Prob *p)\n{\n    uint v = 0;\n    do { v += v + read_bool(d, *p);}  while (*++p);\n    return v;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob Pcat1[] = { 159, 0};\nconst Prob Pcat2[] = { 165, 145, 0};\nconst Prob Pcat3[] = { 173, 148, 140, 0};\nconst Prob Pcat4[] = { 176, 155, 140, 135, 0};\nconst Prob Pcat5[] = { 180, 157, 141, 134, 130, 0};\nconst Prob Pcat6[] =\n    { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If v -- the unsigned value decoded using the coefficient tree, possibly augmented by the process above -- is non-zero, its sign is set by simply reading a flag:",
      "ja": "v-上記のプロセスによって増強される可能性がある係数ツリーを使用してデコードされていない符号の値がゼロではなく、その標識はフラグを読み取るだけで設定されます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "if (read_bool(d, 128))\n    v = -v;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "13.3. Token Probabilities",
      "section_title": true,
      "ja": "13.3. トークン確率"
    },
    {
      "indent": 3,
      "text": "The probability specification for the token tree (unlike that for the \"extra bits\" described above) is rather involved. It uses three pieces of context to index a large probability table, the contents of which may be incrementally modified in the frame header. The full (non-constant) probability table is laid out as follows.",
      "ja": "トークンツリーの確率仕様（上記の「余分なビット」とは異なり）はかなり関与しています。3つのコンテキストを使用して、大きな確率表にインデックスを付けます。その内容は、フレームヘッダーで徐々に変更される場合があります。完全な（非対照）確率表は次のようにレイアウトされています。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Prob coeff_probs [4] [8] [3] [num_dct_tokens-1];",
      "ja": "prob coeff_probs [4] [8] [3] [num_dct_tokens-1];"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Working from the outside in, the outermost dimension is indexed by the type of plane being decoded:",
      "ja": "外側から作業すると、最も外側の寸法は、デコードされる平面のタイプによってインデックス付けされます。"
    },
    {
      "indent": 3,
      "text": "o 0 - Y beginning at coefficient 1 (i.e., Y after Y2)",
      "ja": "o 0 -y係数1から始まる（つまり、y2の後のy）"
    },
    {
      "indent": 3,
      "text": "o 1 - Y2",
      "ja": "o 1 -Y2"
    },
    {
      "indent": 3,
      "text": "o 2 - U or V",
      "ja": "o 2 -uまたはv"
    },
    {
      "indent": 3,
      "text": "o 3 - Y beginning at coefficient 0 (i.e., Y in the absence of Y2).",
      "ja": "o 3 -Y係数0（つまり、y2の非存在下でy）から始まります。"
    },
    {
      "indent": 3,
      "text": "The next dimension is selected by the position of the coefficient being decoded. That position, c, steps by ones up to 15, starting from zero for block types 1, 2, or 3 and starting from one for block type 0. The second array index is then",
      "ja": "次の寸法は、デコードされている係数の位置によって選択されます。その位置cは、ブロックタイプ1、2、または3のゼロから始まり、ブロックタイプ0の1から始まる最大15までのステップで、2番目の配列インデックスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "coeff_bands [c]",
      "ja": "coeff_bands [c]"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where:",
      "ja": "ただし："
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const int coeff_bands [16] = {\n     0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "is a fixed mapping of position to \"band\".",
      "ja": "「バンド」への位置の固定マッピングです。"
    },
    {
      "indent": 3,
      "text": "The third dimension is the trickiest. Roughly speaking, it measures the \"local complexity\" or extent to which nearby coefficients are non-zero.",
      "ja": "3番目の次元が最もトリッキーです。大まかに言えば、それは「局所的な複雑さ」または近くの係数がゼロではない程度を測定します。"
    },
    {
      "indent": 3,
      "text": "For the first coefficient (DC, unless the block type is 0), we consider the (already encoded) blocks within the same plane (Y2, Y, U, or V) above and to the left of the current block. The context index is then the number (0, 1, or 2) of these blocks that had at least one non-zero coefficient in their residue record. Specifically for Y2, because macroblocks above and to the left may or may not have a Y2 block, the block above is determined by the most recent macroblock in the same column that has a Y2 block, and the block to the left is determined by the most recent macroblock in the same row that has a Y2 block.",
      "ja": "最初の係数（DC、ブロックタイプが0でない限り）の場合、現在のブロックの上および左側の同じ平面（Y2、Y、U、またはV）内の（既にエンコードされた）ブロックを検討します。コンテキストインデックスは、残基レコードに少なくとも1つの非ゼロ係数があるこれらのブロックの数（0、1、または2）です。特にY2の場合、マクロブロックの上と左にはY2ブロックがある場合とそうでない場合があるため、上記のブロックは、Y2ブロックを持つ同じ列の最新のマクロブロックによって決定され、左からブロックが決定されます。Y2ブロックを備えた同じ行に最新のマクロブロック。"
    },
    {
      "indent": 3,
      "text": "Beyond the first coefficient, the context index is determined by the absolute value of the most recently decoded coefficient (necessarily within the current block) and is 0 if the last coefficient was a zero, 1 if it was plus or minus one, and 2 if its absolute value exceeded one.",
      "ja": "最初の係数を超えて、コンテキストインデックスは、直近のデコードされた係数の絶対値（必然的に現在のブロック内）によって決定され、最後の係数がゼロの場合は0、プラスまたはマイナスの場合は1、2その絶対値は1を超えました。"
    },
    {
      "indent": 3,
      "text": "Note that the intuitive meaning of this measure changes as coefficients are decoded. For example, prior to the first token, a zero means that the neighbors are empty, suggesting that the current block may also be empty. After the first token, because an end-of-block token must have at least one non-zero value before it, a zero means that we just decoded a zero and hence guarantees that a non-zero coefficient will appear later in this block. However, this shift in meaning is perfectly okay because the complete context depends also on the coefficient band (and since band 0 is occupied exclusively by position 0).",
      "ja": "係数がデコードされると、このメジャーの直感的な意味が変化することに注意してください。たとえば、最初のトークンの前に、ゼロは隣人が空であることを意味し、現在のブロックも空である可能性があることを示唆しています。最初のトークンの後、ブロックの終わりのトークンは少なくとも1つの非ゼロ値を持っている必要があるため、ゼロはゼロを解読しただけであるため、このブロックで非ゼロ係数が後で表示されることを保証します。ただし、完全なコンテキストは係数帯域にも依存するため、この意味の変化は完全に問題ありません（およびバンド0は位置0でのみ占有されているため）。"
    },
    {
      "indent": 3,
      "text": "As with other contexts used by VP8, the \"neighboring block\" context described here needs a special definition for subblocks lying along the top row or left edge of the frame. These \"non-existent\" predictors above and to the left of the image are simply taken to be empty -- that is, taken to contain no non-zero coefficients.",
      "ja": "VP8が使用する他のコンテキストと同様に、ここで説明する「隣接するブロック」コンテキストには、フレームの一番上の行または左端に沿って横たわっているサブブロックの特別な定義が必要です。これらの「存在しない」画像の左側と左側は、単に空であると見なされます。つまり、ゼロ以外の係数が含まれていないと考えられています。"
    },
    {
      "indent": 3,
      "text": "The residue decoding of each macroblock then requires, in each of two directions (above and to the left), an aggregate coefficient predictor consisting of a single Y2 predictor, two predictors for each of U and V, and four predictors for Y. In accordance with the scan-ordering of macroblocks, a decoder needs to maintain a single \"left\" aggregate predictor and a row of \"above\" aggregate predictors.",
      "ja": "各マクロブロックの残留デコードには、2つの方向（上および左側）のそれぞれに、単一のY2予測子、uとvのそれぞれの2つの予測因子、およびyの4つの予測因子で構成される凝集係数予測子が必要です。マクロブロックのスキャン順序により、デコーダーは単一の「左」の集約予測子と「上」集約予測子の行を維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "Before decoding any residue, these maintained predictors may simply be cleared, in compliance with the definition of \"non-existent\" prediction. After each block is decoded, the two predictors referenced by the block are replaced with the (empty or non-empty) state of the block, in preparation for the later decoding of the blocks below and to the right of the block just decoded.",
      "ja": "残留物を解読する前に、これらの維持された予測因子は、「存在しない」予測の定義に準拠して、単にクリアされる可能性があります。各ブロックがデコードされた後、ブロックによって参照される2つの予測因子は、ブロックの（空のまたは空の非）状態に置き換えられます。"
    },
    {
      "indent": 3,
      "text": "The fourth, and final, dimension of the token probability array is of course indexed by (half) the position in the token tree structure, as are all tree probability arrays.",
      "ja": "トークン確率アレイの4番目の最終的な寸法は、もちろん、すべてのツリー確率アレイと同様に、トークンツリー構造の位置（半分）によってインデックス付けされます。"
    },
    {
      "indent": 3,
      "text": "The pseudocode below illustrates the decoding process. Note that criteria, functions, etc. delimited with ** are either dependent on decoder architecture or are elaborated on elsewhere in this document.",
      "ja": "以下の擬似コードは、デコードプロセスを示しています。**で区切られた基準、関数などは、デコーダーアーキテクチャに依存するか、このドキュメントの他の場所で詳しく説明されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int block[16] = { 0 }; /* current 4x4 block coeffs */\nint firstCoeff = 0;\nint plane;\nint ctx2;\nint ctx3 = 0; /* the 3rd context referred to in above description */\nProb *probTable;\nint token;\nint sign;\nint absValue;\nint extraBits;\nbool prevCoeffWasZero = false;\nbool currentBlockHasCoeffs = false;\n/* base coeff abs values per each category, elem #0 is\n   DCT_VAL_CATEGORY1, * #1 is DCT_VAL_CATEGORY2, etc. */\nint categoryBase[6] = { 5, 7, 11, 19, 35, 67 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Determine plane to use */\nif ( **current_block_is_Y2_block** )       plane = 0;\nelse if ( **current_block_is_chroma** )   plane = 2;\nelse if ( **current_macroblock_has_Y2** ) plane = 1;\nelse                                      plane = 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* For luma blocks of a \"Y2 macroblock\" we skip coeff index #0 */\nif ( plane == 1 )\n    firstCoeff++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Determine whether neighbor 4x4 blocks have coefficients.\n   This is dependent on the plane we are currently decoding;\n   i.e., we check only coefficients from the same plane as the\n   current block. */\nif ( **left_neighbor_block_has_coefficients(plane)** )\n    ctx3++;\nif ( **above_neighbor_block_has_coefficients(plane)** )\n    ctx3++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "for( i = firstCoeff; i < 16; ++i )\n{\n    ctx2 = coeff_bands[i];\n    probTable = coeff_probs[plane][ctx2][ctx3];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* skip first code (dct_eob) if previous token was DCT_0 */\nif ( prevCoeffWasZero )\n    token = treed_read ( d, **coeff_tree_without_eob**,\n      probTable );\nelse\n    token = treed_read ( d, coeff_tree, probTable );",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if ( token == dct_eob ) break;",
      "ja": "if（token == dct_eob）break;"
    },
    {
      "indent": 5,
      "text": "  if ( token != DCT_0 )\n  {\n      currentBlockHasCoeffs = true;\nif ( **token_has_extra_bits(token)** )\n{\n    extraBits = DCTextra( token );\n    absValue =\n        categoryBase[**token_to_cat_index(token)**] +\n  extraBits;\n}\nelse\n{\n    absValue = **token_to_abs_value(token)**;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "sign = read_bool(d, 128);\n      block[i] = sign ? -absValue : absValue;\n  }\n  else\n  {\n      absValue = 0;\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /* Set contexts and stuff for next coeff */\n    if ( absValue == 0 )         ctx3 = 0;\n    else if ( absValue == 1 )   ctx3 = 1;\n    else                        ctx3 = 2;\n    prevCoeffWasZero = true;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Store current block status to decoder internals */\n**block_has_coefficients[currentMb][currentBlock]** =\n  currentBlockHasCoeffs;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "While we have in fact completely described the coefficient decoding procedure, the reader will probably find it helpful to consult the reference implementation, which can be found in the file tokens.c (Section 20.16).",
      "ja": "実際、係数デコード手順については完全に説明しましたが、読者はおそらく、ファイルtokens.c（セクション20.16）にある参照実装を参照することが役立つでしょう。"
    },
    {
      "indent": 0,
      "text": "13.4. Token Probability Updates",
      "section_title": true,
      "ja": "13.4. トークン確率の更新"
    },
    {
      "indent": 3,
      "text": "As mentioned above, the token-decoding probabilities may change from frame to frame. After detection of a key frame, they are of course set to their defaults as shown in Section 13.5; this must occur before decoding the remainder of the header, as both key frames and interframes may adjust these probabilities.",
      "ja": "上記のように、トークンゼコードの確率はフレームからフレームに変化する場合があります。キーフレームを検出した後、セクション13.5に示すように、それらはもちろんデフォルトに設定されます。これは、キーフレームとインターフレームの両方がこれらの確率を調整する可能性があるため、ヘッダーの残りをデコードする前に発生する必要があります。"
    },
    {
      "indent": 3,
      "text": "The layout and semantics of the coefficient probability update record (Section I of the frame header) are straightforward. For each position in the coeff_probs array there occurs a fixed-probability bool indicating whether or not the corresponding probability should be updated. If the bool is true, there follows a P(8) replacing that probability. Note that updates are cumulative; that is, a probability updated on one frame is in effect for all ensuing frames until the next key frame, or until the probability is explicitly updated by another frame.",
      "ja": "係数確率アップデートレコード（フレームヘッダーのセクションI）のレイアウトとセマンティクスは簡単です。Coeff_Probsアレイの各位置について、対応する確率を更新するかどうかを示す固定能力ブールが発生します。ブールが真の場合、その確率を置き換えるp（8）が続きます。更新は累積的であることに注意してください。つまり、次のキーフレームまで、または別のフレームによって確率が明示的に更新されるまで、1つのフレームで更新される確率が有効です。"
    },
    {
      "indent": 3,
      "text": "The algorithm to effect the foregoing is simple:",
      "ja": "前述のアルゴリズムは簡単です。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int i = 0;  do {\n int j = 0;  do {\n  int k = 0;  do {\n   int t = 0;  do {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (read_bool(d, coeff_update_probs [i] [j] [k] [t]))\n    coeff_probs [i] [j] [k] [t] = read_literal(d, 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   } while (++t < num_dct_tokens - 1);\n  } while (++k < 3);\n } while (++j < 8);\n} while (++i < 4);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The (constant) update probabilities are as follows:",
      "ja": "（定数）更新確率は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob coeff_update_probs [4] [8] [3] [num_dct_tokens-1] =\n{\n {\n  {\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},\n   { 250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},\n   { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n  }\n },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "{\n {\n  { 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},\n  { 234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255}\n },\n {\n  { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n }\n},\n{\n {\n  { 186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255},\n  { 251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255}\n },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": " {\n  { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n }\n},\n{\n {\n  { 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255},\n  { 248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255}\n },\n {\n  { 255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n  { 252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255}\n },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  {\n   { 255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n  },\n  {\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n   { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n  }\n }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "13.5. Default Token Probability Table",
      "section_title": true,
      "ja": "13.5. デフォルトのトークン確率テーブル"
    },
    {
      "indent": 3,
      "text": "The default token probabilities are as follows.",
      "ja": "デフォルトのトークン確率は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob default_coeff_probs [4] [8] [3] [num_dct_tokens - 1] =\n{\n {\n  {\n   { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},\n   { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},\n   { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}\n  },\n  {\n   { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},\n   { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},\n   { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128}\n  },\n  {\n   {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},\n   { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},\n   {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128}\n  },\n  {\n   {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},\n   { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},\n   {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128}\n  },\n  {\n   {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},\n   { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},\n   {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128}\n  },\n  {\n   {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},\n   { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},\n   { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128}\n  },\n  {\n   {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},\n   { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},\n   {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128}\n  },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": " {\n  {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n  { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n  { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}\n }\n},\n{\n {\n  { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},\n  { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},\n  {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128}\n },\n {\n  {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},\n  { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},\n  {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128}\n },\n {\n  {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},\n  {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},\n  {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128}\n },\n {\n  {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},\n  { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},\n  {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128}\n },\n {\n  {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},\n  {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},\n  {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128}\n },\n {\n  {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},\n  { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},\n  {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128}\n },\n {\n  {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},\n  { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},\n  {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128}\n },\n {\n  {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},\n  { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},\n  { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128}\n }\n},",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "{\n {\n  { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},\n  { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},\n  {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128}\n },\n {\n  {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},\n  { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},\n  { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128}\n },\n {\n  {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},\n  { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},\n  {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128}\n },\n {\n  {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},\n  { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},\n  { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128}\n },\n {\n  {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},\n  { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},\n  { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}\n },\n {\n  {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n  { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n  { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128}\n },\n {\n  {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},\n  { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},\n  {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128}\n },\n {\n  { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},\n  { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},\n  { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}\n }\n},\n{\n {\n  { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},\n  { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},\n  {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128}\n },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  {\n   {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},\n   { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},\n   {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128}\n  },\n  {\n   {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},\n   { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},\n   {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128}\n  },\n  {\n   {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},\n   { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},\n   {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128}\n  },\n  {\n   {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},\n   { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},\n   {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128}\n  },\n  {\n   {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},\n   { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},\n   {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128}\n  },\n  {\n   {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},\n   { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},\n   {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128}\n  },\n  {\n   {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n   { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n   { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}\n  }\n }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14. DCT and WHT Inversion and Macroblock Reconstruction",
      "section_title": true,
      "ja": "14. DCTおよびWHTの反転およびマクロブロックの再構築"
    },
    {
      "indent": 0,
      "text": "14.1. Dequantization",
      "section_title": true,
      "ja": "14.1. 不安定化"
    },
    {
      "indent": 3,
      "text": "After decoding the DCTs/WHTs as described above, each (quantized) coefficient in each subblock is multiplied by one of six dequantization factors, the choice of factor depending on the plane (Y2, Y, or chroma) and position (DC = coefficient zero, AC = any",
      "ja": "上記のDCTS/WHTをデコードした後、各サブブロックの各（量子化された）係数に6つの非定量化係数のいずれかを掛けます。平面（Y2、Y、またはChroma）と位置（DC =係数ゼロに依存する因子の選択、ac = any"
    },
    {
      "indent": 3,
      "text": "other coefficient). If the current macroblock has overridden the quantizer level (as described in Section 10), then the six factors are looked up from two dequantization tables with appropriate scaling and clamping using the single index supplied by the override. Otherwise, the frame-level dequantization factors (as described in Section 9.6) are used. In either case, the multiplies are computed and stored using 16-bit signed integers.",
      "ja": "その他の係数）。現在のマクロブロックが量子化器レベルをオーバーライドしている場合（セクション10で説明されているように）、6つの要因は、オーバーライドによって提供された単一のインデックスを使用して、適切なスケーリングとクランプを使用して、2つのデコンティングテーブルから調べられます。それ以外の場合、フレームレベルの定量化係数（セクション9.6で説明されている）が使用されます。どちらの場合でも、マルチプリは計算され、16ビットの署名された整数を使用して保存されます。"
    },
    {
      "indent": 3,
      "text": "The two dequantization tables, which may also be found in the reference decoder file dequant_data.h (Section 20.3), are as follows.",
      "ja": "参照デコーダーファイルdequant_data.h（セクション20.3）にも見られる2つのデコンティゼーションテーブルは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const int dc_qlookup[QINDEX_RANGE] = { 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157, };",
      "ja": "static const int dc_qlookup [qindex_range] = {4、5、6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、20、21、21、22、22、23、23、24、25、25、26、27、28、29、30、31、32、33、34、35、36、37、37、38、39、40、41、42、43、44、45、46、46、47、48、49、50、51、52、53、54、55、56、57、58、59、60、61、62、63、64、64、65、66、67、68、69、70、71、72、73、74、75、76、76、77、78、79、80、81、82、83、84、85、86、87、87、88、89、91、93、95、96、98、100、101、102、104、106、108、110、112、114、116、118、122、124、126、128、130、132、134、136、138、140、143、145、148、151、154、157、};"
    },
    {
      "indent": 3,
      "text": "static const int ac_qlookup[QINDEX_RANGE] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284, };",
      "ja": "static const int ac_qlookup [qindex_range] = {4、5、6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、21、22、23、24、25、26、27、28、29、30、31、32、33、34、35、36、37、38、39、40、41、42、43、44、45、46、47、48、49、50、51、52、53、54、55、56、57、58、60、62、64、66、68、70、72、74、76、78、80、82、84、86、88、90、92、94、96、98、100、102、104、106、108、110、112、114、116、119、122、125、128、131、134、137、140、143、146、149、152、149、152、155、158、161、164、167、170、173、177、181、185、189、193、197、201、205、209、213、217、221、225、229、234、239、245、249、249、249、249、254、259、264、269、274、279、284、};"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Lookup values from the above two tables are directly used in the DC and AC coefficients in Y1, respectively. For Y2 and chroma, values from the above tables undergo either scaling or clamping before the multiplies. Details regarding these scaling and clamping processes can be found in related lookup functions in dixie.c (Section 20.4).",
      "ja": "上記の2つのテーブルのルックアップ値は、それぞれY1のDCおよびAC係数で直接使用されます。Y2とChromaの場合、上記のテーブルの値は、マルチプレゼントの前にスケーリングまたはクランプのいずれかを受けます。これらのスケーリングおよびクランププロセスに関する詳細は、dixie.c（セクション20.4）の関連するルックアップ関数に記載されています。"
    },
    {
      "indent": 0,
      "text": "14.2. Inverse Transforms",
      "section_title": true,
      "ja": "14.2. 逆変換"
    },
    {
      "indent": 3,
      "text": "If the Y2 residue block exists (i.e., the macroblock luma mode is not SPLITMV or B_PRED), it is inverted first (using the inverse WHT) and the element of the result at row i, column j is used as the 0th coefficient of the Y subblock at position (i, j), that is, the Y subblock whose index is (i * 4) + j. As discussed in Section 13, if the luma mode is B_PRED or SPLITMV, the 0th Y coefficients are part of the residue signal for the subblocks themselves.",
      "ja": "Y2残基ブロックが存在する場合（つまり、マクロブロックLUMAモードがsplitMVまたはB_PREDではない場合）、最初に反転し（逆WHTを使用）、行Iで結果の要素が列jが使用されます。y位置（i、j）のyサブブロック、つまり、インデックスが（i * 4）jのyサブブロック。セクション13で説明したように、LUMAモードがB_PREDまたはSplitMVの場合、0番目のY係数はサブブロック自体の残基信号の一部です。"
    },
    {
      "indent": 3,
      "text": "In either case, the inverse transforms for the sixteen Y subblocks and eight chroma subblocks are computed next. All 24 of these inversions are independent of each other; their results may (at least conceptually) be stored in 24 separate 4x4 arrays.",
      "ja": "どちらの場合でも、16 Yのサブブロックと8つのクロマサブブロックの逆変換が次に計算されます。これらの反転の24はすべて互いに独立しています。それらの結果は（少なくとも概念的に）24個の別々の4x4アレイに保存される場合があります。"
    },
    {
      "indent": 3,
      "text": "As is done by the reference decoder, an implementation may wish to represent the prediction and residue buffers as macroblock-sized arrays (that is, a 16x16 Y buffer and two 8x8 chroma buffers). Regarding the inverse DCT implementation given below, this requires a simple adjustment to the address calculation for the resulting residue pixels.",
      "ja": "参照デコーダーによって行われるように、実装は、予測と残基バッファーをマクロブロックサイズのアレイ（つまり16x16 Yバッファーと2つの8x8クロマバッファー）として表すことを望む場合があります。以下に示す逆DCTの実装に関して、これには、結果の残基ピクセルのアドレス計算を簡単に調整する必要があります。"
    },
    {
      "indent": 0,
      "text": "14.3. Implementation of the WHT Inversion",
      "section_title": true,
      "ja": "14.3. WHT反転の実装"
    },
    {
      "indent": 3,
      "text": "As previously discussed (see Sections 2 and 13), for macroblocks encoded using prediction modes other than B_PRED and SPLITMV, the DC values derived from the DCT transform on the 16 Y blocks are collected to construct a 25th block of a macroblock (16 Y, 4 U, 4 V constitute the 24 blocks). This 25th block is transformed using a Walsh-Hadamard transform (WHT).",
      "ja": "以前に説明したように（セクション2および13を参照）、B_PREDおよびSplitMV以外の予測モードを使用してエンコードされたマクロブロックについては、16 YブロックのDCT変換から派生したDC値が収集され、マクロブロックの25番目のブロックを構築します（16 Y、4 u、4 vは24ブロックを構成します）。この25番目のブロックは、Walsh-Hadamard Transform（WHT）を使用して変換されます。"
    },
    {
      "indent": 3,
      "text": "The inputs to the inverse WHT (that is, the dequantized coefficients), the intermediate \"horizontally detransformed\" signal, and the completely detransformed residue signal are all stored as arrays of 16-bit signed integers.",
      "ja": "逆WHT（つまり、不安定化係数）への入力、中間の「水平に変形した」信号、および完全に変形した残基信号はすべて、16ビットの署名整数のアレイとして保存されます。"
    },
    {
      "indent": 3,
      "text": "Following the tradition of specifying bitstream format using the decoding process, we specify the inverse WHT in the decoding process using the following C-style source code:",
      "ja": "デコードプロセスを使用してBitStream形式を指定する伝統に従って、次のCスタイルのソースコードを使用して、デコードプロセスの逆WHTを指定します。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_short_inv_walsh4x4_c(short *input, short *output)\n{\n  int i;\n  int a1, b1, c1, d1;\n  int a2, b2, c2, d2;\n  short *ip = input;\n  short *op = output;\n  int temp1, temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "for(i=0;i<4;i++)\n{\n  a1 = ip[0] + ip[12];\n  b1 = ip[4] + ip[8];\n  c1 = ip[4] - ip[8];\n  d1 = ip[0] - ip[12];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  op[0] = a1 + b1;\n  op[4] = c1 + d1;\n  op[8] = a1 - b1;\n  op[12]= d1 - c1;\n  ip++;\n  op++;\n}\nip = output;\nop = output;\nfor(i=0;i<4;i++)\n{\n  a1 = ip[0] + ip[3];\n  b1 = ip[1] + ip[2];\n  c1 = ip[1] - ip[2];\n  d1 = ip[0] - ip[3];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "a2 = a1 + b1;\nb2 = c1 + d1;\nc2 = a1 - b1;\nd2 = d1 - c1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "op[0] = (a2+3)>>3;\nop[1] = (b2+3)>>3;\nop[2] = (c2+3)>>3;\nop[3] = (d2+3)>>3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    ip+=4;\n    op+=4;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the case that there is only one non-zero DC value in input, the inverse transform can be simplified to the following:",
      "ja": "入力にゼロ以外のDC値が1つしかない場合、逆変換は次のように簡素化できます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_short_inv_walsh4x4_1_c(short *input, short *output)\n{\n  int i;\n  int a1;\n  short *op=output;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "a1 = ((input[0] + 3)>>3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  for(i=0;i<4;i++)\n  {\n    op[0] = a1;\n    op[1] = a1;\n    op[2] = a1;\n    op[3] = a1;\n    op+=4;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It should be noted that a conforming decoder should implement the inverse transform using exactly the same rounding to achieve bit-wise matching output to the output of the process specified by the above C source code.",
      "ja": "適合デコーダーは、上記のCソースコードで指定されたプロセスの出力に少し一致する出力を実現するために、まったく同じ丸めを使用して逆変換を実装する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The reference decoder WHT inversion may be found in the file idct_add.c (Section 20.8).",
      "ja": "参照デコーダーWHT反転は、ファイルIDCT_ADD.C（セクション20.8）に記載されている場合があります。"
    },
    {
      "indent": 0,
      "text": "14.4. Implementation of the DCT Inversion",
      "section_title": true,
      "ja": "14.4. DCT反転の実装"
    },
    {
      "indent": 3,
      "text": "All of the DCT inversions are computed in exactly the same way. In principle, VP8 uses a classical 2-D inverse discrete cosine transform, implemented as two passes of 1-D inverse DCT. The 1-D inverse DCT was calculated using a similar algorithm to what was described in [Loeffler]. However, the paper only provided the 8-point and 16-point version of the algorithms, which was adapted by On2 to perform the 4-point 1-D DCT.",
      "ja": "すべてのDCT反転は、まったく同じ方法で計算されます。原則として、VP8は、1次元DCTの2つのパスとして実装された古典的な2-D逆離散コサイン変換を使用します。1-D逆DCTは、[Loeffler]で説明されているものと同様のアルゴリズムを使用して計算されました。ただし、このペーパーは、4ポイント1-D DCTを実行するためにON2によって適合された8ポイントと16ポイントのアルゴリズムのみを提供しました。"
    },
    {
      "indent": 3,
      "text": "Accurate calculation of 1-D DCT of the above algorithm requires infinite precision. VP8 of course can use only a finite-precision approximation. Also, the inverse DCT used by VP8 takes care of normalization of the standard unitary transform; that is, every dequantized coefficient has roughly double the size of the corresponding unitary coefficient. However, at all but the highest datarates, the discrepancy between transmitted and ideal coefficients is due almost entirely to (lossy) compression and not to errors induced by finite-precision arithmetic.",
      "ja": "上記のアルゴリズムの1-D DCTの正確な計算には、無限の精度が必要です。もちろん、VP8は有限前の近似のみを使用できます。また、VP8が使用する逆DCTは、標準的な単一変換の正規化を処理します。つまり、すべての不安定な係数は、対応する単一係数のサイズの約2倍です。ただし、最高のデータレートを除いて、送信係数と理想係数との矛盾は、ほぼ完全に（損失のある）圧縮によるものであり、有限精度算術によって誘発されるエラーではありません。"
    },
    {
      "indent": 3,
      "text": "The inputs to the inverse DCT (that is, the dequantized coefficients), the intermediate \"horizontally detransformed\" signal, and the completely detransformed residue signal are all stored as arrays of 16-bit signed integers. The details of the computation are as follows.",
      "ja": "逆DCT（つまり、不安定化係数）への入力、中間の「水平に変形した」信号、および完全に変形した残基信号はすべて、16ビットの署名整数のアレイとして保存されます。計算の詳細は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "It should also be noted that this implementation makes use of the 16-bit fixed-point version of two multiplication constants:",
      "ja": "また、この実装では、2つの乗算定数の16ビット固定点バージョンを使用していることにも注意してください。"
    },
    {
      "indent": 3,
      "text": "sqrt(2) * cos (pi/8)",
      "ja": "sqrt（2） * cos（pi/8）"
    },
    {
      "indent": 3,
      "text": "sqrt(2) * sin (pi/8)",
      "ja": "sqrt（2） * sin（pi/8）"
    },
    {
      "indent": 3,
      "text": "Because the first constant is bigger than 1, to maintain the same 16-bit fixed-point precision as the second one, we make use of the fact that",
      "ja": "最初の定数は1より大きいため、2番目の定数と同じ16ビット固定点精度を維持するため、私たちはという事実を利用します。"
    },
    {
      "indent": 3,
      "text": "x * a = x + x*(a-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "therefore",
      "ja": "したがって"
    },
    {
      "indent": 3,
      "text": "x * sqrt(2) * cos (pi/8) = x + x * (sqrt(2) * cos(pi/8)-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* IDCT implementation */\nstatic const int cospi8sqrt2minus1=20091;\nstatic const int sinpi8sqrt2      =35468;\nvoid short_idct4x4llm_c(short *input, short *output, int pitch)\n{\n  int i;\n  int a1, b1, c1, d1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "short *ip=input;\nshort *op=output;\nint temp1, temp2;\nint shortpitch = pitch>>1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "for(i=0;i<4;i++)\n{\n  a1 = ip[0]+ip[8];\n  b1 = ip[0]-ip[8];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "temp1 = (ip[4] * sinpi8sqrt2)>>16;\ntemp2 = ip[12]+((ip[12] * cospi8sqrt2minus1)>>16);\nc1 = temp1 - temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "temp1 = ip[4] + ((ip[4] * cospi8sqrt2minus1)>>16);\ntemp2 = (ip[12] * sinpi8sqrt2)>>16;\nd1 = temp1 + temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "op[shortpitch*0] = a1+d1;\nop[shortpitch*3] = a1-d1;\nop[shortpitch*1] = b1+c1;\nop[shortpitch*2] = b1-c1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  ip++;\n  op++;\n}\nip = output;\nop = output;\nfor(i=0;i<4;i++)\n{\n  a1 = ip[0]+ip[2];\n  b1 = ip[0]-ip[2];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "temp1 = (ip[1] * sinpi8sqrt2)>>16;\ntemp2 = ip[3]+((ip[3] * cospi8sqrt2minus1)>>16);\nc1 = temp1 - temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "temp1 = ip[1] + ((ip[1] * cospi8sqrt2minus1)>>16);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "temp2 = (ip[3] * sinpi8sqrt2)>>16;\nd1 = temp1 + temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "op[0] = (a1+d1+4)>>3;\nop[3] = (a1-d1+4)>>3;\nop[1] = (b1+c1+4)>>3;\nop[2] = (b1-c1+4)>>3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    ip+=shortpitch;\n    op+=shortpitch;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The reference decoder DCT inversion may be found in the file idct_add.c (Section 20.8).",
      "ja": "参照デコーダーDCTの反転は、ファイルIDCT_ADD.C（セクション20.8）に記載されている場合があります。"
    },
    {
      "indent": 0,
      "text": "14.5. Summation of Predictor and Residue",
      "section_title": true,
      "ja": "14.5. 予測因子と残基の合計"
    },
    {
      "indent": 3,
      "text": "Finally, the prediction and residue signals are summed to form the reconstructed macroblock, which, except for loop filtering (taken up next), completes the decoding process.",
      "ja": "最後に、予測と残基シグナルは合計されて再構築されたマクロブロックを形成します。これは、ループフィルタリング（次に撮影）を除き、デコードプロセスを完了します。"
    },
    {
      "indent": 3,
      "text": "The summing procedure is fairly straightforward, having only a couple of details. The prediction and residue buffers are both arrays of 16-bit signed integers. Each individual (Y, U, and V pixel) result is calculated first as a 32-bit sum of the prediction and residue, and is then saturated to 8-bit unsigned range (using, say, the clamp255 function defined above) before being stored as an 8-bit unsigned pixel value.",
      "ja": "合計手順はかなり簡単で、詳細は2つしかありません。予測バッファと残基バッファーは、どちらも16ビットの署名された整数の配列です。各個々の個々（y、u、およびvピクセル）の結果は、最初に予測と残基の32ビット合計として計算され、次に8ビットの符号なし範囲に飽和します（たとえば、上記で定義されたclamp255関数を使用）8ビットの符号なしピクセル値として保存されます。"
    },
    {
      "indent": 3,
      "text": "VP8 also supports a mode where the encoding of a bitstream guarantees all reconstructed pixel values between 0 and 255; compliant bitstreams of such requirements have the clamp_type bit in the frame header set to 1. In such a case, the clamp255 function is no longer required.",
      "ja": "VP8は、ビットストリームのエンコードが0〜255の間にすべての再構築されたピクセル値を保証するモードもサポートしています。このような要件の準拠のビットストリームには、フレームヘッダーが1に設定されたCLAMP_TYPEビットがあります。そのような場合、CLAMP255関数は不要になります。"
    },
    {
      "indent": 3,
      "text": "The summation process is the same, regardless of the (intra or inter) mode of prediction in effect for the macroblock. The reference decoder implementation of reconstruction may be found in the file idct_add.c.",
      "ja": "マクロブロックの（イントラまたはインター）予測モードに関係なく、合計プロセスは同じです。再構成の参照デコーダー実装は、ファイルIDCT_ADD.Cに記載されている場合があります。"
    },
    {
      "indent": 0,
      "text": "15. Loop Filter",
      "section_title": true,
      "ja": "15. ループフィルター"
    },
    {
      "indent": 3,
      "text": "Loop filtering is the last stage of frame reconstruction and the next-to-last stage of the decoding process. The loop filter is applied to the entire frame after the summation of predictor and residue signals, as described in Section 14.",
      "ja": "ループフィルタリングは、フレーム再構築の最後の段階であり、デコードプロセスの次の段階です。セクション14で説明されているように、ループフィルターは、予測因子と残基シグナルの合計後にフレーム全体に適用されます。"
    },
    {
      "indent": 3,
      "text": "The purpose of the loop filter is to eliminate (or at least reduce) visually objectionable artifacts associated with the semi-independence of the coding of macroblocks and their constituent subblocks.",
      "ja": "ループフィルターの目的は、マクロブロックとその構成要素のサブブロックのコーディングの半独立に関連する視覚的に好ましくないアーティファクトを排除（または少なくとも削減する）ことです。"
    },
    {
      "indent": 3,
      "text": "As was discussed in Section 5, the loop filter is \"integral\" to decoding, in that the results of loop filtering are used in the prediction of subsequent frames. Consequently, a functional decoder implementation must perform loop filtering exactly as described here. This is distinct from any postprocessing that may be applied only to the image immediately before display; such postprocessing is entirely at the option of the implementor (and/or user) and has no effect on decoding per se.",
      "ja": "セクション5で説明したように、ループフィルターはデコードに「積分」しています。これは、ループフィルタリングの結果が後続のフレームの予測で使用されているからです。したがって、機能的なデコーダーの実装は、ここで説明するように正確にループフィルタリングを実行する必要があります。これは、ディスプレイの直前に画像にのみ適用される可能性のあるポストプロセスとは異なります。このような後処理は、実装者（および/またはユーザー）のオプションに完全に存在し、それ自体のデコードに影響を与えません。"
    },
    {
      "indent": 3,
      "text": "The baseline frame-level parameters controlling the loop filter are defined in the frame header (Section 9.4) along with a mechanism for adjustment based on a macroblock's prediction mode and/or reference frame. The first is a flag (filter_type) selecting the type of filter (normal or simple); the other two are numbers (loop_filter_level and sharpness_level) that adjust the strength or sensitivity of the filter. As described in Sections 9.3 and 10, loop_filter_level may also be overridden on a per-macroblock basis using segmentation.",
      "ja": "ループフィルターを制御するベースラインフレームレベルのパラメーターは、マクロブロックの予測モードおよび/または参照フレームに基づく調整のメカニズムとともに、フレームヘッダー（セクション9.4）で定義されています。1つ目は、フィルターのタイプを選択するフラグ（filter_type）です（通常または単純）。他の2つは、フィルターの強度または感度を調整する数字（loop_filter_levelとsharpness_level）です。セクション9.3および10で説明されているように、loop_filter_levelは、セグメンテーションを使用してマクロブロックごとにオーバーライドされる場合があります。"
    },
    {
      "indent": 3,
      "text": "Loop filtering is one of the more computationally intensive aspects of VP8 decoding. This is the reason for the existence of the optional, less-demanding simple filter type.",
      "ja": "ループフィルタリングは、VP8デコードのより計算的に集中的な側面の1つです。これが、オプションの、それほど強くない単純なフィルタータイプが存在する理由です。"
    },
    {
      "indent": 3,
      "text": "Note carefully that loop filtering must be skipped entirely if loop_filter_level at either the frame header level or macroblock override level is 0. In no case should the loop filter be run with a value of 0; it should instead be skipped.",
      "ja": "フレームヘッダーレベルまたはマクロブロックオーバーライドレベルのいずれかでloop_filter_levelが0である場合、ループフィルタリングを完全にスキップする必要があることに注意してください。代わりにスキップする必要があります。"
    },
    {
      "indent": 3,
      "text": "We begin by discussing the aspects of loop filtering that are independent of the controlling parameters and type of filter chosen.",
      "ja": "まず、制御パラメーターと選択したフィルターの種類に依存しないループフィルタリングの側面について説明することから始めます。"
    },
    {
      "indent": 0,
      "text": "15.1. Filter Geometry and Overall Procedure",
      "section_title": true,
      "ja": "15.1. ジオメトリと全体的な手順をフィルターします"
    },
    {
      "indent": 3,
      "text": "The Y, U, and V planes are processed independently and identically.",
      "ja": "y、u、およびV平面は、独立して同一に処理されます。"
    },
    {
      "indent": 3,
      "text": "The loop filter acts on the edges between adjacent macroblocks and on the edges between adjacent subblocks of a macroblock. All such edges are horizontal or vertical. For each pixel position on an edge, a small number (two or three) of pixels adjacent to either side of the position are examined and possibly modified. The displacements of these pixels are at a right angle to the edge orientation; that is, for a horizontal edge, we treat the pixels immediately above and below the edge position, and for a vertical edge, we treat the pixels immediately to the left and right of the edge.",
      "ja": "ループフィルターは、隣接するマクロブロック間のエッジと、マクロブロックの隣接するサブブロック間のエッジに作用します。そのようなエッジはすべて水平または垂直です。エッジ上の各ピクセル位置について、位置の両側に隣接するピクセルの少数（2つまたは3つ）が調べられ、おそらく変更されます。これらのピクセルの変位は、エッジの向きに対して直角です。つまり、水平方向のエッジの場合、エッジの位置のすぐ上と下のピクセルを扱い、垂直方向のエッジでは、ピクセルをすぐにエッジの左右に扱います。"
    },
    {
      "indent": 3,
      "text": "We call this collection of pixels associated to an edge position a segment; the length of a segment is 2, 4, 6, or 8. Excepting that the normal filter uses slightly different algorithms for, and either filter may apply different control parameters to, the edges between macroblocks and those between subblocks, the treatment of edges is quite uniform: All segments straddling an edge are treated identically; there is no distinction between the treatment of horizontal and vertical edges, whether between macroblocks or between subblocks.",
      "ja": "エッジ位置に関連付けられたピクセルのこのコレクションをセグメントと呼びます。セグメントの長さは2、4、6、または8です。通常のフィルターがわずかに異なるアルゴリズムを使用することを除いて、マクロブロックとサブブロックの間のエッジのエッジには、エッジの処理が異なる制御パラメーターを適用する場合があります。非常に均一：エッジにまたがるすべてのセグメントは同じように扱われます。マクロブロック間またはサブブロック間であろうと、水平エッジと垂直エッジの処理には区別はありません。"
    },
    {
      "indent": 3,
      "text": "As a consequence, adjacent subblock edges within a macroblock may be concatenated and processed in their entirety. There is a single 8-pixel-long vertical edge horizontally centered in each of the U and V blocks (the concatenation of upper and lower 4-pixel edges between chroma subblocks), and three 16-pixel-long vertical edges at horizontal positions 1/4, 1/2, and 3/4 the width of the luma macroblock, each representing the concatenation of four 4-pixel sub-edges between pairs of Y subblocks.",
      "ja": "結果として、マクロブロック内の隣接するサブブロックエッジを連結して処理することができます。各UおよびVブロック（クロマサブブロック間の上限と下部4ピクセルのエッジの連結）と、水平位置1に3つの16ピクセル長垂直エッジ1にある1つの8ピクセル長垂直エッジが水平に中心にあります1/4、1/2、および3/4 Lumaマクロブロックの幅は、それぞれがyサブブロックのペア間の4つの4ピクセルサブエッジの連結を表しています。"
    },
    {
      "indent": 3,
      "text": "The macroblocks comprising the frame are processed in the usual raster-scan order. Each macroblock is \"responsible for\" the inter-macroblock edges immediately above and to the left of it (but not the edges below and to the right of it), as well as the edges between its subblocks.",
      "ja": "フレームを含むマクロブロックは、通常のラスタースキャン順序で処理されます。各マクロブロックは、そのサブブロック間のエッジだけでなく、そのすぐ上と左側と左側と左側（ただし右側と右側ではなく）の間、マクロブロック間のエッジを「責任」します。"
    },
    {
      "indent": 3,
      "text": "For each macroblock M, there are four filtering steps, which are, (almost) in order:",
      "ja": "各マクロブロックMには、4つのフィルタリングステップがあります。これは（ほぼ）順番です。"
    },
    {
      "indent": 3,
      "text": "1. If M is not on the leftmost column of macroblocks, filter across the left (vertical) inter-macroblock edge of M.",
      "ja": "1. mがマクロブロックの左端の列にない場合は、Mの左（垂直）間マクロブロックエッジを除去します。"
    },
    {
      "indent": 3,
      "text": "2. Filter across the vertical subblock edges within M.",
      "ja": "2. M内の垂直サブブロックエッジを横切ってフィルタリングします"
    },
    {
      "indent": 3,
      "text": "3. If M is not on the topmost row of macroblocks, filter across the top (horizontal) inter-macroblock edge of M.",
      "ja": "3. Mがマクロブロックの最上列にない場合は、Mの上部（水平）間マクロブロックエッジを除去します。"
    },
    {
      "indent": 3,
      "text": "4. Filter across the horizontal subblock edges within M.",
      "ja": "4. M内の水平サブブロックエッジを横切ってフィルタリングします"
    },
    {
      "indent": 3,
      "text": "We write MY, MU, and MV for the planar constituents of M, that is, the 16x16 luma block, 8x8 U block, and 8x8 V block comprising M.",
      "ja": "Mの平面成分、つまり16x16 Lumaブロック、8x8 Uブロック、およびMで構成される8x8 Vブロックのために、私、MU、およびMVを書きます。"
    },
    {
      "indent": 3,
      "text": "In step 1, for each of the three blocks MY, MU, and MV, we filter each of the (16 luma or 8 chroma) segments straddling the column separating the block from the block immediately to the left of it, using the inter-macroblock filter and controls associated to the loop_filter_level and sharpness_level.",
      "ja": "ステップ1では、3つのブロックのそれぞれについて、MY、MU、およびMVで、ブロックをすぐに左に分離する列を囲む列にまたがる各（16ルーマまたは8クロマ）セグメントのそれぞれをフィルタリングします。loop_filter_levelとsharpness_levelに関連付けられたマクロブロックフィルターとコントロール。"
    },
    {
      "indent": 3,
      "text": "In step 4, we filter across the (three luma and one each for U and V) vertical subblock edges described above, this time using the inter-subblock filter and controls.",
      "ja": "ステップ4では、上記の垂直サブブロックエッジ（3つのLUMAと1つのLUMAと1つ）を上にフィルタリングします。今回は、サブブロック間フィルターとコントロールを使用します。"
    },
    {
      "indent": 3,
      "text": "Steps 2 and 4 are skipped for macroblocks that satisfy both of the following two conditions:",
      "ja": "ステップ2と4は、次の2つの条件の両方を満たすマクロブロックのためにスキップされています。"
    },
    {
      "indent": 3,
      "text": "1. Macroblock coding mode is neither B_PRED nor SPLITMV; and",
      "ja": "1. マクロブロックコーディングモードは、b_predでもsplitmvでもありません。と"
    },
    {
      "indent": 3,
      "text": "2. There is no DCT coefficient coded for the whole macroblock.",
      "ja": "2. マクロブロック全体にコード化されたDCT係数はありません。"
    },
    {
      "indent": 3,
      "text": "For these macroblocks, loop filtering for edges between subblocks internal to a macroblock is effectively skipped. This skip strategy significantly reduces VP8 loop-filtering complexity.",
      "ja": "これらのマクロブロックの場合、マクロブロックの内部のサブブロック間のエッジのループフィルタリングが効果的にスキップされます。このスキップ戦略により、VP8ループフィルタリングの複雑さが大幅に削減されます。"
    },
    {
      "indent": 3,
      "text": "Edges between macroblocks and those between subblocks are treated with different control parameters (and, in the case of the normal filter, with different algorithms). Except for pixel addressing, there is no distinction between the treatment of vertical and horizontal edges. Luma edges are always 16 pixels long, chroma edges are always 8 pixels long, and the segments straddling an edge are treated identically; this of course facilitates vector processing.",
      "ja": "マクロブロックとサブブロック間のエッジは、異なる制御パラメーターで処理されます（そして、通常のフィルターの場合、異なるアルゴリズムで）。ピクセルのアドレス指定を除き、垂直と水平のエッジの処理には区別はありません。Lumaのエッジは常に16ピクセルの長さで、クロマのエッジは常に8ピクセルの長さであり、エッジにまたがるセグメントは同じように扱われます。もちろん、これはベクトル処理を容易にします。"
    },
    {
      "indent": 3,
      "text": "Because many pixels belong to segments straddling two or more edges, and so will be filtered more than once, the order in which edges are processed given above must be respected by any implementation. Within a single edge, however, the segments straddling that edge are disjoint, and the order in which these segments are processed is immaterial.",
      "ja": "多くのピクセルが2つ以上のエッジにまたがるセグメントに属しているため、複数回フィルタリングされるため、上記のエッジが処理される順序は、実装によって尊重されなければなりません。ただし、単一のエッジ内では、そのエッジが際立っているセグメントはばらばらであり、これらのセグメントが処理される順序は重要ではありません。"
    },
    {
      "indent": 3,
      "text": "Before taking up the filtering algorithms themselves, we should emphasize a point already made: Even though the pixel segments associated to a macroblock are antecedent to the macroblock (that is, lie within the macroblock or in already-constructed macroblocks), a",
      "ja": "フィルタリングアルゴリズム自体を取り上げる前に、すでに作成されたポイントを強調する必要があります。マクロブロックに関連付けられたピクセルセグメントがマクロブロック（つまり、マクロブロック内またはすでに構成されているマクロブロック内にあります）に先行していますが、"
    },
    {
      "indent": 3,
      "text": "macroblock must not be filtered immediately after its \"reconstruction\" (described in Section 14). Rather, the loop filter applies after all the macroblocks have been \"reconstructed\" (i.e., had their predictor summed with their residue); correct decoding is predicated on the fact that already-constructed portions of the current frame referenced via intra-prediction (described in Section 12) are not yet filtered.",
      "ja": "マクロブロックは、その「再構築」の直後にフィルタリングしてはなりません（セクション14で説明）。むしろ、ループフィルターは、すべてのマクロブロックが「再構築」された後に適用されます（つまり、予測因子が残留物で合計されていました）。正しいデコードは、予測内（セクション12で説明）を介して参照されている現在のフレームのすでに構成されている部分がまだフィルタリングされていないという事実に基づいています。"
    },
    {
      "indent": 0,
      "text": "15.2. Simple Filter",
      "section_title": true,
      "ja": "15.2. 単純なフィルター"
    },
    {
      "indent": 3,
      "text": "Having described the overall procedure of, and pixels affected by, the loop filter, we turn our attention to the treatment of individual segments straddling edges. We begin by describing the simple filter, which, as the reader might guess, is somewhat simpler than the normal filter.",
      "ja": "ループフィルターの全体的な手順とピクセルを説明した後、エッジにまたがる個々のセグメントの処理に注意を向けます。まず、読者が推測するように、通常のフィルターよりもやや単純な単純なフィルターを説明することから始めます。"
    },
    {
      "indent": 3,
      "text": "Note that the simple filter only applies to luma edges. Chroma edges are left unfiltered.",
      "ja": "単純なフィルターは、Lumaエッジにのみ適用されることに注意してください。クロマのエッジはフィルタリングされていません。"
    },
    {
      "indent": 3,
      "text": "Roughly speaking, the idea of loop filtering is, within limits, to reduce the difference between pixels straddling an edge. Differences in excess of a threshold (associated to the loop_filter_level) are assumed to be \"natural\" and are unmodified; differences below the threshold are assumed to be artifacts of quantization and the (partially) separate coding of blocks, and are reduced via the procedures described below. While the loop_filter_level is in principle arbitrary, the levels chosen by a VP8 compressor tend to be correlated to quantizer levels.",
      "ja": "大まかに言えば、ループフィルタリングのアイデアは、制限内で、エッジにまたがるピクセルの違いを減らすことです。しきい値の過剰（loop_filter_levelに関連付けられている）の違いは、「自然」であると想定されており、変更されていません。しきい値以下の違いは、量子化のアーティファクトであり、（部分的に）ブロックの個別のコーディングであると想定されており、以下の手順を介して減少します。loop_filter_levelは原則としてarbitrary意的ですが、VP8コンプレッサーによって選択されたレベルは、量子化レベルと相関する傾向があります。"
    },
    {
      "indent": 3,
      "text": "Most of the filtering arithmetic is done using 8-bit signed operands (having a range of -128 to +127, inclusive), supplemented by 16-bit temporaries holding results of multiplies.",
      "ja": "フィルタリング算術のほとんどは、8ビットの署名されたオペランド（範囲の-128〜127、包括的）を使用して行われます。"
    },
    {
      "indent": 3,
      "text": "Sums and other temporaries need to be \"clamped\" to a valid signed 8-bit range:",
      "ja": "合計およびその他の一時的なものは、有効な署名された8ビット範囲に「クランプ」する必要があります。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int8 c(int v)\n{\n    return (int8) (v < -128 ? -128 : (v < 128 ? v : 127));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Since pixel values themselves are unsigned 8-bit numbers, we need to convert between signed and unsigned values:",
      "ja": "ピクセル値自体は署名されていない8ビット番号であるため、署名された値と符号なしの値を変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Convert pixel value (0 <= v <= 255) to an 8-bit signed\n   number. */\nint8 u2s(Pixel v) { return (int8) (v - 128);}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Clamp, then convert signed number back to pixel value. */\nPixel s2u(int v) { return (Pixel) (c(v) + 128);}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Filtering is often predicated on absolute-value thresholds. The following function is the equivalent of the standard library function abs, whose prototype is found in the standard header file stdlib.h. For us, the argument v is always the difference between two pixels and lies in the range -255 <= v <= +255.",
      "ja": "フィルタリングは、多くの場合、絶対値のしきい値に基づいています。次の関数は、標準のライブラリ関数ABSに相当し、そのプロトタイプは標準ヘッダーファイルstdlib.hにあります。私たちにとって、引数Vは常に2つのピクセルの違いであり、範囲-255 <= v <= 255の範囲です。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int abs(int v) { return v < 0?  -v : v;}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An actual implementation would of course use inline functions or macros to accomplish these trivial procedures (which are used by both the normal and simple loop filters). An optimal implementation would probably express them in machine language, perhaps using single instruction, multiple data (SIMD) vector instructions. On many SIMD processors, the saturation accomplished by the above clamping function is often folded into the arithmetic instructions themselves, obviating the explicit step taken here.",
      "ja": "実際の実装では、もちろんインライン関数またはマクロを使用して、これらの些細な手順（通常のループフィルターと単純なループフィルターの両方で使用されます）を達成します。最適な実装は、おそらく単一命令、複数のデータ（SIMD）ベクトル命令を使用して、おそらく機械言語でそれらを表現するでしょう。多くのSIMDプロセッサでは、上記のクランプ関数によって達成される飽和は、しばしば算術命令自体に折りたたまれ、ここで取られた明示的なステップを取り除きます。"
    },
    {
      "indent": 3,
      "text": "To simplify the specification of relative pixel positions, we use the word \"before\" to mean \"immediately above\" (for a vertical segment straddling a horizontal edge) or \"immediately to the left of\" (for a horizontal segment straddling a vertical edge), and the word \"after\" to mean \"immediately below\" or \"immediately to the right of\".",
      "ja": "相対ピクセルの位置の仕様を簡素化するために、「前」を意味する「前」を意味する（垂直セグメントの場合）または「左の左側にある」（垂直エッジにまたがる水平セグメントの場合）を意味するように「」という単語を使用します。、および「後の」という言葉は、「すぐ下」または「右側の右側」を意味します。"
    },
    {
      "indent": 3,
      "text": "Given an edge, a segment, and a limit value, the simple loop filter computes a value based on the four pixels that straddle the edge (two either side). If that value is below a supplied limit, then, very roughly speaking, the two pixel values are brought closer to each other, \"shaving off\" something like a quarter of the difference. The",
      "ja": "エッジ、セグメント、および制限値が与えられた場合、シンプルループフィルターは、エッジにまたがる4つのピクセル（2つの側面）に基づいて値を計算します。その値が供給された制限を下回っている場合、非常に大まかに言えば、2つのピクセル値は互いに近づき、違いの4分の1のようなものを「シェービング」します。"
    },
    {
      "indent": 3,
      "text": "same procedure is used for all segments straddling any type of edge, regardless of the nature (inter-macroblock, inter-subblock, luma, or chroma) of the edge; only the limit value depends on the edge type.",
      "ja": "エッジの性質（マクロブロック間、サブブロック間、ルーマ、またはクロマ）に関係なく、あらゆるタイプのエッジにまたがるすべてのセグメントに同じ手順が使用されます。制限値のみがエッジタイプによって異なります。"
    },
    {
      "indent": 3,
      "text": "The exact procedure (for a single segment) is as follows; the subroutine common_adjust is used by both the simple filter presented here and the normal filters discussed in Section 15.3.",
      "ja": "正確な手順（単一セグメントの場合）は次のとおりです。Subroutine common_adjustは、ここに示されている単純なフィルターとセクション15.3で説明した通常のフィルターの両方で使用されます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int8 common_adjust(\n    int use_outer_taps,   /* filter is 2 or 4 taps wide */\n    const Pixel *P1,    /* pixel before P0 */\n    Pixel *P0,          /* pixel before edge */\n    Pixel *Q0,          /* pixel after edge */\n    const Pixel *Q1     /* pixel after Q0 */\n) {\n    cint8 p1 = u2s(*P1);   /* retrieve and convert all 4 pixels */\n    cint8 p0 = u2s(*P0);\n    cint8 q0 = u2s(*Q0);\n    cint8 q1 = u2s(*Q1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Disregarding clamping, when \"use_outer_taps\" is false,\n   \"a\" is 3*(q0-p0).  Since we are about to divide \"a\" by\n   8, in this case we end up multiplying the edge\n   difference by 5/8.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "When \"use_outer_taps\" is true (as for the simple filter),\n\"a\" is p1 - 3*p0 + 3*q0 - q1, which can be thought of as\na refinement of 2*(q0 - p0), and the adjustment is\nsomething like (q0 - p0)/4. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "int8 a = c((use_outer_taps? c(p1 - q1) : 0) + 3*(q0 - p0));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* b is used to balance the rounding of a/8 in the case where\n   the \"fractional\" part \"f\" of a/8 is exactly 1/2. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "cint8 b = (c(a + 3)) >> 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Divide a by 8, rounding up when f >= 1/2.\n   Although not strictly part of the C language,\n   the right shift is assumed to propagate the sign bit. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "a = c(a + 4) >> 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Subtract \"a\" from q0, \"bringing it closer\" to p0. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "*Q0 = s2u(q0 - a);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Add \"a\" (with adjustment \"b\") to p0, \"bringing it closer\"\n   to q0.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "The clamp of \"a+b\", while present in the reference decoder,\nis superfluous; we have -16 <= a <= 15 at this point. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "*P0 = s2u(p0 + b);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return a; }",
      "ja": "aを返します。}"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void simple_segment(\n    uint8 edge_limit,   /* do nothing if edge difference\n                           exceeds limit */\n    const Pixel *P1,    /* pixel before P0 */\n    Pixel *P0,          /* pixel before edge */\n    Pixel *Q0,          /* pixel after edge */\n    const Pixel *Q1     /* pixel after Q0 */\n) {\n    if ((abs(*P0 - *Q0)*2 + abs(*P1 - *Q1)/2) <= edge_limit))\n        common_adjust(1, P1, P0, Q0, Q1);   /* use outer taps */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We make a couple of remarks about the rounding procedure above. When b is zero (that is, when the \"fractional part\" of a is not 1/2), we are (except for clamping) adding the same number to p0 as we are subtracting from q0. This preserves the average value of p0 and q0, but the resulting difference between p0 and q0 is always even; in particular, the smallest non-zero gradation +-1 is not possible here.",
      "ja": "上記の丸め手順についていくつかの発言をします。Bの場合（つまり、Aの「分数部分」が1/2ではない場合）、Q0から減算しているのと同じ数をP0に追加しています（クランプを除く）。これにより、P0とQ0の平均値が保持されますが、P0とQ0の結果の違いは常に均一です。特に、ここでは最小の非ゼログラデーション-1は不可能です。"
    },
    {
      "indent": 3,
      "text": "When b is one, the value we add to p0 (again except for clamping) is one less than the value we are subtracting from q0. In this case, the resulting difference is always odd (and the small gradation +-1 is possible), but the average value is reduced by 1/2, yielding, for instance, a very slight darkening in the luma plane. (In the very unlikely event of appreciable darkening after a large number of interframes, a compressor would of course eventually compensate for this in the selection of predictor and/or residue.)",
      "ja": "Bが1の場合、P0に追加する値（再びクランプを除く）は、Q0から差し引く値よりも1つ低くなります。この場合、結果の違いは常に奇妙です（そして小さなグラデーション-1は可能です）が、平均値は1/2に減少し、例えばLuma平面では非常にわずかに暗くなります。（多数のインターフレームの後に非常にありそうもない暗くなるイベントでは、コンプレッサーはもちろん、最終的には予測因子および/または残基の選択でこれを補償します。）"
    },
    {
      "indent": 3,
      "text": "The derivation of the edge_limit value used above, which depends on the loop_filter_level and sharpness_level, as well as the type of edge being processed, will be taken up after we describe the normal loop filtering algorithm below.",
      "ja": "上記で使用されているedge_limit値の導出は、loop_filter_levelとsharpness_levelに依存し、処理されるエッジのタイプは、以下の通常のループフィルタリングアルゴリズムを説明した後に取り上げられます。"
    },
    {
      "indent": 0,
      "text": "15.3. Normal Filter",
      "section_title": true,
      "ja": "15.3. 通常のフィルター"
    },
    {
      "indent": 3,
      "text": "The normal loop filter is a refinement of the simple loop filter; all of the general discussion above applies here as well. In particular, the functions c, u2s, s2u, abs, and common_adjust are used by both the normal and simple filters.",
      "ja": "通常のループフィルターは、単純なループフィルターの改良です。上記の一般的な議論はすべてここにも当てはまります。特に、関数c、u2s、s2u、abs、およびcommon_adjustは、通常と単純なフィルターの両方で使用されます。"
    },
    {
      "indent": 3,
      "text": "As mentioned above, the normal algorithms for inter-macroblock and inter-subblock edges differ. Nonetheless, they have a great deal in common: They use similar threshold algorithms to disable the filter and to detect high internal edge variance (which influences the filtering algorithm). Both algorithms also use, at least conditionally, the simple filter adjustment procedure described above.",
      "ja": "上記のように、マクロブロック間およびサブブロック間エッジの通常のアルゴリズムは異なります。それにもかかわらず、それらは非常に共通点があります。同様のしきい値アルゴリズムを使用してフィルターを無効にし、高い内部エッジ分散を検出します（フィルタリングアルゴリズムに影響します）。両方のアルゴリズムは、少なくとも条件付きでは、上記の単純なフィルター調整手順も使用します。"
    },
    {
      "indent": 3,
      "text": "The common thresholding algorithms are as follows.",
      "ja": "一般的なしきい値アルゴリズムは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* All functions take (among other things) a segment (of length\n   at most 4 + 4 = 8) symmetrically straddling an edge.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "The pixel values (or pointers) are always given in order,\nfrom the \"beforemost\" to the \"aftermost\".  So, for a\nhorizontal edge (written \"|\"), an 8-pixel segment would be\nordered p3 p2 p1 p0 | q0 q1 q2 q3. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Filtering is disabled if the difference between any two\n   adjacent \"interior\" pixels in the 8-pixel segment exceeds\n   the relevant threshold (I).  A more complex thresholding\n   calculation is done for the group of four pixels that\n   straddle the edge, in line with the calculation in\n   simple_segment() above. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int filter_yes(\n    uint8 I,        /* limit on interior differences */\n    uint8 E,        /* limit at the edge */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    cint8 p3, cint8 p2, cint8 p1, cint8 p0, /* pixels before\n                                               edge */\n    cint8 q0, cint8 q1, cint8 q2, cint8 q3  /* pixels after\n                                               edge */\n) {\n    return  (abs(p0 - q0)*2 + abs(p1 - q1)/2) <= E\n        &&  abs(p3 - p2) <= I  &&  abs(p2 - p1) <= I  &&\n          abs(p1 - p0) <= I\n        &&  abs(q3 - q2) <= I  &&  abs(q2 - q1) <= I  &&\n          abs(q1 - q0) <= I;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Filtering is altered if (at least) one of the differences\n   on either side of the edge exceeds a threshold (we have\n   \"high edge variance\"). */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int hev(\n    uint8 threshold,\n    cint8 p1, cint8 p0, /* pixels before edge */\n    cint8 q0, cint8 q1  /* pixels after edge */\n) {\n    return abs(p1 - p0) > threshold  ||  abs(q1 - q0) > threshold;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The subblock filter is a variant of the simple filter. In fact, if we have high edge variance, the adjustment is exactly as for the simple filter. Otherwise, the simple adjustment (without outer taps) is applied, and the two pixels one step in from the edge pixels are adjusted by roughly half the amount by which the two edge pixels are adjusted; since the edge adjustment here is essentially 3/8 the edge difference, the inner adjustment is approximately 3/16 the edge difference.",
      "ja": "サブブロックフィルターは、単純なフィルターのバリアントです。実際、エッジの分散が高い場合、調整は単純なフィルターとまったく同じです。それ以外の場合、単純な調整（外側のタップなし）が適用され、エッジピクセルからの2つのピクセルの1つのステップは、2つのエッジピクセルが調整される約半分の量で調整されます。ここのエッジ調整は本質的に3/8であるため、エッジの差は約3/16のエッジ差です。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void subblock_filter(\n    uint8 hev_threshold,     /* detect high edge variance */\n    uint8 interior_limit,    /* possibly disable filter */\n    uint8 edge_limit,\n    cint8 *P3, cint8 *P2, int8 *P1, int8 *P0,   /* pixels before\n                                                   edge */\n    int8 *Q0, int8 *Q1, cint8 *Q2, cint8 *Q3    /* pixels after\n                                                   edge */\n) {\n    cint8 p3 = u2s(*P3), p2 = u2s(*P2), p1 = u2s(*P1),\n      p0 = u2s(*P0);\n    cint8 q0 = u2s(*Q0), q1 = u2s(*Q1), q2 = u2s(*Q2),\n      q3 = u2s(*Q3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (filter_yes(interior_limit, edge_limit, q3, q2, q1, q0, p0, p1, p2, p3)) { const int hv = hev(hev_threshold, p1, p0, q0, q1);",
      "ja": "if（filter_yes（interior_limit、edge_limit、q3、q2、q1、q0、p0、p1、p2、p3））{const int hv = hev（hev_threshold、p1、p0、q0、q1）;"
    },
    {
      "indent": 11,
      "text": "cint8 a = (common_adjust(hv, P1, P0, Q0, Q1) + 1) >> 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if (!hv) {\n            *Q1 = s2u(q1 - a);\n            *P1 = s2u(p1 + a);\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The inter-macroblock filter has potentially wider scope. If the edge variance is high, it performs the simple adjustment (using the outer taps, just like the simple filter and the corresponding case of the normal subblock filter). If the edge variance is low, we begin with the same basic filter calculation and apply multiples of it to pixel pairs symmetric about the edge; the magnitude of adjustment decays as we move away from the edge and six of the pixels in the segment are affected.",
      "ja": "マクロブロック間フィルターは、潜在的に広いスコープを持っています。エッジの分散が高い場合、単純な調整を実行します（単純なフィルターや通常のサブブロックフィルターの対応するケースと同様に、外側のタップを使用します）。エッジの分散が低い場合、同じ基本的なフィルター計算から始めて、それの倍数をエッジを対称するピクセルペアに適用します。エッジから離れると、調整の大きさが減衰し、セグメント内の6つのピクセルが影響を受けます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void MBfilter(\n    uint8 hev_threshold,     /* detect high edge variance */\n    uint8 interior_limit,    /* possibly disable filter */\n    uint8 edge_limit,\n    cint8 *P3, int8 *P2, int8 *P1, int8 *P0,  /* pixels before\n                                                 edge */\n    int8 *Q0, int8 *Q1, int8 *Q2, cint8 *Q3   /* pixels after\n                                                 edge */\n) {\n    cint8 p3 = u2s(*P3), p2 = u2s(*P2), p1 = u2s(*P1),\n      p0 = u2s(*P0);\n    cint8 q0 = u2s(*Q0), q1 = u2s(*Q1), q2 = u2s(*Q2),\n      q3 = u2s(*Q3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (filter_yes(interior_limit, edge_limit, q3, q2, q1, q0,\n  p0, p1, p2, p3))\n{\n    if (!hev(hev_threshold, p1, p0, q0, q1))\n    {\n        /* Same as the initial calculation in \"common_adjust\",\n           w is something like twice the edge difference */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "const int8 w = c(c(p1 - q1) + 3*(q0 - p0));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* 9/64 is approximately 9/63 = 1/7, and 1<<7 = 128 =\n   2*64.  So this a, used to adjust the pixels adjacent\n   to the edge, is something like 3/7 the edge\n   difference. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "int8 a = c((27*w + 63) >> 7);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "*Q0 = s2u(q0 - a);  *P0 = s2u(p0 + a);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* Next two are adjusted by 2/7 the edge difference */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "a = c((18*w + 63) >> 7);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "*Q1 = s2u(q1 - a);  *P1 = s2u(p1 + a);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* Last two are adjusted by 1/7 the edge difference */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "a = c((9*w + 63) >> 7);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "*Q2 = s2u(q2 - a);  *P2 = s2u(p2 + a);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        } else                      /* if hev, do simple filter */\n            common_adjust(1, P1, P0, Q0, Q1);   /* using outer\n                                                    taps */\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "15.4. Calculation of Control Parameters",
      "section_title": true,
      "ja": "15.4. 制御パラメーターの計算"
    },
    {
      "indent": 3,
      "text": "We conclude the discussion of loop filtering by showing how the thresholds supplied to the procedures above are derived from the two control parameters sharpness_level (an unsigned 3-bit number having maximum value 7) and loop_filter_level (an unsigned 6-bit number having maximum value 63).",
      "ja": "上記の手順に提供されたしきい値が、2つの制御パラメーターSharpness_Level（最大値7を持つ符号なし3ビット数）とloop_filter_level（最大値63を持つ符号なし6ビット数値63を持つ2つの制御パラメーターからどのように導出されるかを示すことにより、ループフィルタリングの議論を締めくくります。）。"
    },
    {
      "indent": 3,
      "text": "While the sharpness_level is constant over the frame, individual macroblocks may override the loop_filter_level with one of four possibilities supplied in the frame header (as described in Section 10).",
      "ja": "Sharpness_Levelはフレーム上で一定ですが、個々のマクロブロックは、フレームヘッダーで提供される4つの可能性のいずれかを使用してLOOP_FILTER_LEVELをオーバーライドする場合があります（セクション10で説明されています）。"
    },
    {
      "indent": 3,
      "text": "Both the simple and normal filters disable filtering if a value derived from the four pixels that straddle the edge (2 either side) exceeds a threshold / limit value.",
      "ja": "単純なフィルターと通常のフィルターの両方が、エッジにまたがる4つのピクセルから派生した値（2つの側）がしきい値 /制限値を超える場合、フィルタリングを無効にします。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Luma and Chroma use the same inter-macroblock edge limit */\nuint8 mbedge_limit = ((loop_filter_level + 2) * 2) +\n  interior_limit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Luma and Chroma use the same inter-subblock edge limit */\nuint8 sub_bedge_limit = (loop_filter_level * 2) + interior_limit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The remaining thresholds are used only by the normal filters. The filter-disabling interior difference limit is the same for all edges (luma, chroma, inter-subblock, inter-macroblock) and is given by the following.",
      "ja": "残りのしきい値は、通常のフィルターでのみ使用されます。フィルターダイバーの内部差の制限は、すべてのエッジ（Luma、Chroma、Inter-Subblock、Inter-Macroblock）で同じであり、以下で与えられます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uint8 interior_limit = loop_filter_level;",
      "ja": "uint8 interior_limit = loop_filter_level;"
    },
    {
      "indent": 3,
      "text": "if (sharpness_level)\n{\n    interior_limit  >>=  sharpness_level > 4 ?  2 : 1;\n    if (interior_limit > 9 - sharpness_level)\n        interior_limit = 9 - sharpness_level;\n}\nif (!interior_limit)\n    interior_limit = 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Finally, we give the derivation of the high edge-variance threshold, which is also the same for all edge types.",
      "ja": "最後に、すべてのエッジタイプでも同じエッジ分散しきい値の導出を与えます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uint8 hev_threshold = 0;",
      "ja": "uint8 hev_threshold = 0;"
    },
    {
      "indent": 3,
      "text": "if (we_are_decoding_akey_frame)   /* current frame is a key frame */\n{\n    if (loop_filter_level >= 40)\n        hev_threshold = 2;\n    else if (loop_filter_level >= 15)\n        hev_threshold = 1;\n}\nelse                            /* current frame is an interframe */\n{\n    if (loop_filter_level >= 40)\n        hev_threshold = 3;\n    else if (loop_filter_level >= 20)\n        hev_threshold = 2;\n    else if (loop_filter_level >= 15)\n        hev_threshold = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "16. Interframe Macroblock Prediction Records",
      "section_title": true,
      "ja": "16. インターフレームマクロブロック予測記録"
    },
    {
      "indent": 3,
      "text": "We describe the layout and semantics of the prediction records for macroblocks in an interframe.",
      "ja": "インターフレームでのマクロブロックの予測記録のレイアウトとセマンティクスについて説明します。"
    },
    {
      "indent": 3,
      "text": "After the feature specification (which is described in Section 10 and is identical for intraframes and interframes), there comes a Bool(prob_intra), which indicates inter-prediction (i.e., prediction from prior frames) when true and intra-prediction (i.e., prediction from already-coded portions of the current frame) when false. The zero-probability prob_intra is set by field J of the frame header.",
      "ja": "機能仕様の後（セクション10で説明されており、フレーム内とインターフレームと同一）、ブール（prob_intra）があります。falseの場合、現在のフレームの既にコードされた部分からの予測。Zero Probability Prob_Intraは、フレームヘッダーのフィールドJによって設定されます。"
    },
    {
      "indent": 0,
      "text": "16.1. Intra-Predicted Macroblocks",
      "section_title": true,
      "ja": "16.1. 予測内マクロブロック"
    },
    {
      "indent": 3,
      "text": "For intra-prediction, the layout of the prediction data is essentially the same as the layout for key frames, although the contexts used by the decoding process are slightly different.",
      "ja": "予測内では、予測データのレイアウトは本質的にキーフレームのレイアウトと同じですが、デコードプロセスで使用されるコンテキストはわずかに異なります。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 8, the \"outer\" Y mode here uses a different tree from that used in key frames, repeated here for convenience.",
      "ja": "セクション8で説明したように、ここでの「外側」Yモードは、キーフレームで使用されているものとは異なるツリーを使用しており、ここで繰り返して便利にします。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index ymode_tree [2 * (num_ymodes - 1)] =\n{\n -DC_PRED, 2,           /* root: DC_PRED = \"0\", \"1\" subtree */\n  4, 6,                 /* \"1\" subtree has 2 descendant subtrees */\n   -V_PRED, -H_PRED,    /* \"10\" subtree:  V_PRED = \"100\",\n                           H_PRED = \"101\" */\n   -TM_PRED, -B_PRED    /* \"11\" subtree:  TM_PRED = \"110\",\n                           B_PRED = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The probability table used to decode this tree is variable. As described in Section 11, it (along with the similarly treated UV table) can be updated by field J of the frame header. Similar to the coefficient-decoding probabilities, such updates are cumulative and affect all ensuing frames until the next key frame or explicit update. The default probabilities for the Y and UV tables are:",
      "ja": "このツリーをデコードするために使用される確率テーブルは可変です。セクション11で説明されているように、それは（同様に処理されたUVテーブルとともに）フレームヘッダーのフィールドJによって更新できます。係数を解決する確率と同様に、このような更新は累積的であり、次のキーフレームまたは明示的な更新まで、すべての次のフレームに影響します。YおよびUVテーブルのデフォルトの確率は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Prob ymode_prob [num_ymodes - 1] = { 112, 86, 140, 37};\nProb uv_mode_prob [num_uv_modes - 1] = { 162, 101, 204};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These defaults must be restored after detection of a key frame.",
      "ja": "これらのデフォルトは、キーフレームの検出後に復元する必要があります。"
    },
    {
      "indent": 3,
      "text": "Just as for key frames, if the Y mode is B_PRED, there next comes an encoding of the intra_bpred mode used by each of the sixteen Y subblocks. These encodings use the same tree as does that for key frames but, in place of the contexts used in key frames, these encodings use the single fixed probability table.",
      "ja": "キーフレームと同様に、YモードがB_PREDの場合、次に、16のYサブブロックのそれぞれが使用するIntra_BPREDモードのエンコードがあります。これらのエンコーディングは、キーフレームの場合と同じツリーを使用しますが、キーフレームで使用されるコンテキストの代わりに、これらのエンコードは単一の固定確率テーブルを使用します。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob bmode_prob [num_intra_bmodes - 1] = {\n    120, 90, 79, 133, 87, 85, 80, 111, 151\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Last comes the chroma mode, again coded using the same tree as that used for key frames, this time using the dynamic uv_mode_prob table described above.",
      "ja": "最後に、キーフレームに使用されたものと同じツリーを使用して再びコード化されたChromaモードがあります。今回は、上記の動的uv_mode_probテーブルを使用します。"
    },
    {
      "indent": 3,
      "text": "The calculation of the intra-prediction buffer is identical to that described for key frames in Section 12.",
      "ja": "予測内バッファーの計算は、セクション12のキーフレームについて説明したものと同じです。"
    },
    {
      "indent": 0,
      "text": "16.2. Inter-Predicted Macroblocks",
      "section_title": true,
      "ja": "16.2. 相互に予測されたマクロブロック"
    },
    {
      "indent": 3,
      "text": "Otherwise (when the above bool is true), we are using inter-prediction (which of course only happens for interframes), to which we now restrict our attention.",
      "ja": "それ以外の場合は（上記のブールが真である場合）、私たちは相互否認（もちろん、インターフレームでのみ発生する）を使用しており、今では注意を制限しています。"
    },
    {
      "indent": 3,
      "text": "The next datum is then another bool, B(prob_last), selecting the reference frame. If 0, the reference frame is the previous frame (the last frame); if 1, another bool (prob_gf) selects the reference frame between the golden frame (0) and the altref frame (1). The probabilities prob_last and prob_gf are set in field J of the frame header.",
      "ja": "次のデータムは、参照フレームを選択する別のブールb（prob_last）です。0の場合、参照フレームは前のフレーム（最後のフレーム）です。1の場合、別のブール（prob_gf）は、ゴールデンフレーム（0）とアルトレフフレーム（1）の間の参照フレームを選択します。確率fictives_lastとprob_gfは、フレームヘッダーのフィールドJに設定されています。"
    },
    {
      "indent": 3,
      "text": "Together with setting the reference frame, the purpose of inter-mode decoding is to set a motion vector for each of the sixteen Y subblocks of the current macroblock. These settings then define the calculation of the inter-prediction buffer (detailed in Section 18). While the net effect of inter-mode decoding is straightforward, the implementation is somewhat complex; the (lossless) compression achieved by this method justifies the complexity.",
      "ja": "参照フレームの設定とともに、インターモードデコードの目的は、現在のマクロブロックの16 Yサブブロックのそれぞれにモーションベクトルを設定することです。これらの設定は、予測間バッファーの計算を定義します（セクション18で詳細）。インターモードデコードの正味の効果は簡単ですが、実装はやや複雑です。この方法によって達成される（ロスレス）圧縮は、複雑さを正当化します。"
    },
    {
      "indent": 3,
      "text": "After the reference frame selector comes the mode (or motion vector reference) applied to the macroblock as a whole, coded using the following enumeration and tree. Setting mv_nearest = num_ymodes is a convenience that allows a single variable to unambiguously hold an inter- or intra-prediction mode.",
      "ja": "参照フレームセレクターには、マクロブロック全体に適用されるモード（またはモーションベクトル参照）があり、次の列挙とツリーを使用してコード化されます。MV_NEARest = num_ymodesの設定は、単一の変数が予測内または内容モードを明確に保持できるようにする便利さです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef enum\n{\n    mv_nearest = num_ymodes, /* use \"nearest\" motion vector\n                                for entire MB */\n    mv_near,                 /* use \"next nearest\" \"\" */\n    mv_zero,                 /* use zero \"\" */\n    mv_new,                  /* use explicit offset from\n                                implicit \"\" */\n    mv_split,                /* use multiple motion vectors */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    num_mv_refs = mv_split + 1 - mv_nearest\n}\nmv_ref;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index mv_ref_tree [2 * (num_mv_refs - 1)] =\n{\n -mv_zero, 2,                /* zero = \"0\" */\n  -mv_nearest, 4,            /* nearest = \"10\" */\n   -mv_near, 6,              /* near = \"110\" */\n     -mv_new, -mv_split      /* new = \"1110\", split = \"1111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "16.3. Mode and Motion Vector Contexts",
      "section_title": true,
      "ja": "16.3. モードとモーションベクトルのコンテキスト"
    },
    {
      "indent": 3,
      "text": "The probability table used to decode the mv_ref, along with three reference motion vectors used by the selected mode, is calculated via a survey of the already-decoded motion vectors in (up to) 3 nearby macroblocks.",
      "ja": "選択したモードで使用される3つの参照モーションベクトルとともに、MV_REFをデコードするために使用される確率表は、（最大）3つのマクロブロックの既にゼロのモーションベクトルの調査を介して計算されます。"
    },
    {
      "indent": 3,
      "text": "The algorithm generates a sorted list of distinct motion vectors adjacent to the search site. The best_mv is the vector with the highest score. The mv_nearest is the non-zero vector with the highest score. The mv_near is the non-zero vector with the next highest score. The number of motion vectors coded using the SPLITMV mode is scored using the same weighting and is returned with the scores of the best, nearest, and near vectors.",
      "ja": "アルゴリズムは、検索サイトに隣接する個別のモーションベクトルのソート付きリストを生成します。Best_MVは、最高スコアのベクトルです。MV_NEARESTは、最高スコアを持つ非ゼロベクトルです。MV_NEARは、次に最高のスコアを持つ非ゼロベクトルです。SplitMVモードを使用してコード化されたモーションベクトルの数は、同じ重み付けを使用してスコアリングされ、ベクターに近いベクターのスコアで返されます。"
    },
    {
      "indent": 3,
      "text": "The three adjacent macroblocks above, left, and above-left are considered in order. If the macroblock is intra-coded, no action is taken. Otherwise, the motion vector is compared to other previously found motion vectors to determine if it has been seen before, and if so contributes its weight to that vector; otherwise, it enters a new vector in the list. The above and left vectors have twice the weight of the above-left vector.",
      "ja": "上の3つの隣接するマクロブロック、左、および左以上のマクロブロックが順番に考慮されます。マクロブロックがコード内にある場合、アクションは実行されません。それ以外の場合、モーションベクトルは、以前に見つかった他のモーションベクトルと比較され、以前に見られたかどうか、およびそのベクトルにその重量を寄付するかどうかを判断します。それ以外の場合は、リスト内の新しいベクトルに入ります。上記のベクトルと左ベクトルには、左上のベクトルの2倍の重量があります。"
    },
    {
      "indent": 3,
      "text": "As is the case with many contexts used by VP8, it is possible for macroblocks near the top or left edges of the image to reference blocks that are outside the visible image. VP8 provides a border of 1 macroblock filled with 0x0 motion vectors left of the left edge, and a border filled with 0,0 motion vectors of 1 macroblocks above the top edge.",
      "ja": "VP8で使用されている多くのコンテキストがある場合と同様に、画像の上部または左エッジの近くにマクロブロックが表示され、可視画像の外側にあるブロックを参照する可能性があります。VP8は、左端の左左の0x0モーションベクトルで満たされた1つのマクロブロックの境界線と、上端の1つのマクロブロックの0,0モーションベクトルで満たされた境界線を提供します。"
    },
    {
      "indent": 3,
      "text": "Much of the process is more easily described in C than in English. The reference code for this can be found in modemv.c (Section 20.11). The calculation of reference vectors, probability table, and, finally, the inter-prediction mode itself is implemented as follows.",
      "ja": "プロセスの多くは、英語よりもCで簡単に説明されています。このための参照コードは、modemv.c（セクション20.11）にあります。参照ベクトル、確率表、および最後に、予測間モード自体の計算は、次のように実装されます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef union\n{\n    unsigned int as_int;\n    MV           as_mv;\n} int_mv;        /* facilitates rapid equality tests */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void mv_bias(MODE_INFO *x,int refframe, int_mv *mvp,\n  int * ref_frame_sign_bias)\n{\n    MV xmv;\n    xmv = x->mbmi.mv.as_mv;\n    if ( ref_frame_sign_bias[x->mbmi.ref_frame] !=\n      ref_frame_sign_bias[refframe] )\n    {\n        xmv.row*=-1;\n        xmv.col*=-1;\n    }\n    mvp->as_mv = xmv;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_clamp_mv(MV *mv, const MACROBLOCKD *xd)\n{\n    if ( mv->col < (xd->mb_to_left_edge - LEFT_TOP_MARGIN) )\n        mv->col = xd->mb_to_left_edge - LEFT_TOP_MARGIN;\n    else if ( mv->col > xd->mb_to_right_edge + RIGHT_BOTTOM_MARGIN )\n        mv->col = xd->mb_to_right_edge + RIGHT_BOTTOM_MARGIN;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if ( mv->row < (xd->mb_to_top_edge - LEFT_TOP_MARGIN) )\n        mv->row = xd->mb_to_top_edge - LEFT_TOP_MARGIN;\n    else if ( mv->row > xd->mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN )\n        mv->row = xd->mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the function vp8_find_near_mvs(), the vectors \"nearest\" and \"near\" are used by the corresponding modes.",
      "ja": "関数vp8_find_near_mvs（）では、ベクトル「最も近い」および「近く」が対応するモードで使用されます。"
    },
    {
      "indent": 3,
      "text": "The vector best_mv is used as a base for explicitly coded motion vectors.",
      "ja": "Vector Best_MVは、明示的にコーディングされたモーションベクトルのベースとして使用されます。"
    },
    {
      "indent": 3,
      "text": "The first three entries in the return value cnt are (in order) weighted census values for \"zero\", \"nearest\", and \"near\" vectors. The final value indicates the extent to which SPLITMV was used by the neighboring macroblocks. The largest possible \"weight\" value in each case is 5.",
      "ja": "戻り値CNTの最初の3つのエントリは、「ゼロ」、「最も近い」、および「近く」ベクトルの（順に）加重された国勢調査値です。最終的な値は、隣接するマクロブロックによってsplitMVが使用された程度を示します。それぞれの場合に可能な最大の「重量」値は5です。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_find_near_mvs ( MACROBLOCKD *xd, const MODE_INFO *here, MV *nearest, MV *near, MV *best_mv, int cnt[4], int refframe, int * ref_frame_sign_bias )",
      "ja": "void vp8_find_near_mvs（macroblockd *xd、const mode_info *here、mv *最も近い、mv *近く、mv *best_mv、int cnt [4]、int refframe、int *ref_frame_sign_bias）"
    },
    {
      "indent": 3,
      "text": "{\n    const MODE_INFO *above = here - xd->mode_info_stride;\n    const MODE_INFO *left = here - 1;\n    const MODE_INFO *aboveleft = above - 1;\n    int_mv            near_mvs[4];\n    int_mv           *mv = near_mvs;\n    int             *cntx = cnt;\n    enum {CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Zero accumulators */\nmv[0].as_int = mv[1].as_int = mv[2].as_int = 0;\ncnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Process above */\nif (above->mbmi.ref_frame != INTRA_FRAME) {\n    if (above->mbmi.mv.as_int) {\n        (++mv)->as_int = above->mbmi.mv.as_int;\n        mv_bias(above, refframe, mv, ref_frame_sign_bias);\n        ++cntx;\n    }\n    *cntx += 2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Process left */\nif (left->mbmi.ref_frame != INTRA_FRAME) {\n    if (left->mbmi.mv.as_int) {\n        int_mv this_mv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "this_mv.as_int = left->mbmi.mv.as_int;\nmv_bias(left, refframe, &this_mv, ref_frame_sign_bias);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        if (this_mv.as_int != mv->as_int) {\n            (++mv)->as_int = this_mv.as_int;\n            ++cntx;\n        }\n        *cntx += 2;\n    } else\n        cnt[CNT_ZERO] += 2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Process above left */\nif (aboveleft->mbmi.ref_frame != INTRA_FRAME) {\n    if (aboveleft->mbmi.mv.as_int) {\n        int_mv this_mv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "this_mv.as_int = aboveleft->mbmi.mv.as_int;\nmv_bias(aboveleft, refframe, &this_mv,\n  ref_frame_sign_bias);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        if (this_mv.as_int != mv->as_int) {\n            (++mv)->as_int = this_mv.as_int;\n            ++cntx;\n        }\n        *cntx += 1;\n    } else\n        cnt[CNT_ZERO] += 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* If we have three distinct MVs ... */\nif (cnt[CNT_SPLITMV]) {\n    /* See if above-left MV can be merged with NEAREST */\n    if (mv->as_int == near_mvs[CNT_NEAREST].as_int)\n        cnt[CNT_NEAREST] += 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "cnt[CNT_SPLITMV] = ((above->mbmi.mode == SPLITMV)\n                     + (left->mbmi.mode == SPLITMV)) * 2\n                    + (aboveleft->mbmi.mode == SPLITMV);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Swap near and nearest if necessary */\nif (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n    int tmp;\n    tmp = cnt[CNT_NEAREST];\n    cnt[CNT_NEAREST] = cnt[CNT_NEAR];\n    cnt[CNT_NEAR] = tmp;\n    tmp = near_mvs[CNT_NEAREST].as_int;\n    near_mvs[CNT_NEAREST].as_int = near_mvs[CNT_NEAR].as_int;\n    near_mvs[CNT_NEAR].as_int = tmp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Use near_mvs[0] to store the \"best\" MV */\nif (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])\n    near_mvs[CNT_ZERO] = near_mvs[CNT_NEAREST];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Set up return values */\n*best_mv = near_mvs[0].as_mv;\n*nearest = near_mvs[CNT_NEAREST].as_mv;\n*near = near_mvs[CNT_NEAR].as_mv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    vp8_clamp_mv(nearest, xd);\n    vp8_clamp_mv(near, xd);\n    vp8_clamp_mv(best_mv, xd); //TODO: Move this up before\n                                 the copy\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The mv_ref probability table (mv_ref_p) is then derived from the census as follows.",
      "ja": "MV_REF確率表（MV_REF_P）は、次のように国勢調査から派生します。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const int vp8_mode_contexts[6][4] =\n{\n  {   7,     1,     1,   143,   },\n  {  14,    18,    14,   107,   },\n  { 135,    64,    57,    68,   },\n  {  60,    56,   128,    65,   },\n  { 159,   134,   128,    34,   },\n  { 234,   188,   128,    28,   },\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "vp8_prob *vp8_mv_ref_probs(vp8_prob mv_ref_p[VP8_MVREFS-1],\n  int cnt[4])\n{\n    mv_ref_p[0] = vp8_mode_contexts [cnt[0]] [0];\n    mv_ref_p[1] = vp8_mode_contexts [cnt[1]] [1];\n    mv_ref_p[2] = vp8_mode_contexts [cnt[2]] [2];\n    mv_ref_p[3] = vp8_mode_contexts [cnt[3]] [3];\n    return p;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Once mv_ref_p is established, the mv_ref is decoded as usual.",
      "ja": "MV_REF_Pが確立されると、MV_REFは通常どおりデコードされます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "mvr = (mv_ref) treed_read(d, mv_ref_tree, mv_ref_p);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For the first four inter-coding modes, the same motion vector is used for all the Y subblocks. The first three modes use an implicit motion vector.",
      "ja": "最初の4つのインターコードモードでは、すべてのYサブブロックに同じモーションベクトルが使用されます。最初の3つのモードでは、暗黙の動きベクトルを使用します。"
    },
    {
      "indent": 3,
      "text": "+------------+------------------------------------------------------+\n| Mode       | Instruction                                          |\n+------------+------------------------------------------------------+\n| mv_nearest | Use the nearest vector returned by                   |\n|            | vp8_find_near_mvs.                                   |\n|            |                                                      |\n| mv_near    | Use the near vector returned by vp8_find_near_mvs.   |\n|            |                                                      |\n| mv_zero    | Use a zero vector; that is, predict the current      |\n|            | macroblock from the corresponding macroblock in the  |\n|            | prediction frame.                                    |\n|            |                                                      |\n| NEWMV      | This mode is followed by an explicitly coded motion  |\n|            | vector (the format of which is described in the next |\n|            | section) that is added (component-wise) to the       |\n|            | best_mv reference vector returned by find_near_mvs   |\n|            | and applied to all 16 subblocks.                     |\n+------------+------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "16.4. Split Prediction",
      "section_title": true,
      "ja": "16.4. 分割予測"
    },
    {
      "indent": 3,
      "text": "The remaining mode (SPLITMV) causes multiple vectors to be applied to the Y subblocks. It is immediately followed by a partition specification that determines how many vectors will be specified and how they will be assigned to the subblocks. The possible partitions, with indicated subdivisions and coding tree, are as follows.",
      "ja": "残りのモード（splitMV）により、複数のベクトルがyサブブロックに適用されます。すぐに、指定されるベクトルの数とサブブロックにどのように割り当てられるかを決定するパーティション仕様が続きます。示された下位区分とコーディングツリーを備えた可能性のあるパーティションは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef enum\n{\n    mv_top_bottom,   /* two pieces {0...7} and {8...15} */\n    mv_left_right,   /* {0,1,4,5,8,9,12,13} and\n                        {2,3,6,7,10,11,14,15} */\n    mv_quarters,    /* {0,1,4,5}, {2,3,6,7}, {8,9,12,13},\n                       {10,11,14,15} */\n    MV_16,          /* every subblock gets its own vector\n                       {0} ... {15} */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " mv_num_partitions } MVpartition;",
      "ja": "MV_NUM_PARTITIONS} MVPartition;"
    },
    {
      "indent": 3,
      "text": "const tree_index mvpartition_tree [2 * (mvnum_partition - 1)] =\n{\n -MV_16, 2,                         /* MV_16 = \"0\" */\n  -mv_quarters, 4,                  /* mv_quarters = \"10\" */\n   -mv_top_bottom, -mv_left_right   /* top_bottom = \"110\",\n                                       left_right = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The partition is decoded using a fixed, constant probability table:",
      "ja": "パーティションは、固定された一定の確率表を使用してデコードされます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob mvpartition_probs [mvnum_partition - 1] =\n  { 110, 111, 150};\npart = (MVpartition) treed_read(d, mvpartition_tree,\n  mvpartition_probs);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "After the partition come two (for mv_top_bottom or mv_left_right), four (for mv_quarters), or sixteen (for MV_16) subblock inter-prediction modes. These modes occur in the order indicated by the partition layouts (given as comments to the MVpartition enum) and are coded as follows. (As was done for the macroblock-level modes, we offset the mode enumeration so that a single variable may unambiguously hold either an intra- or inter-subblock mode.)",
      "ja": "パーティションが2つ（MV_TOP_BOTTOMまたはMV_LEFT_RIGHTの場合）、4つ（MV_QUARTERSの場合）、または16（MV_16の場合）サブブロック相間モードになります。これらのモードは、パーティションレイアウトで示された順序で発生します（MVPARTITION列挙へのコメントとして与えられます）、次のようにコーディングされます。（マクロブロックレベルのモードで行われたように、単一の変数がイントラブロックモードまたはインターサブブロックモードのいずれかを明確に保持できるようにモード列挙を相殺します。）"
    },
    {
      "indent": 3,
      "text": "Prior to decoding each subblock, a decoding tree context is chosen as illustrated in the code snippet below. The context is based on the immediate left and above subblock neighbors, and whether they are equal, are zero, or a combination of those.",
      "ja": "各サブブロックをデコードする前に、以下のコードスニペットに示されているように、デコードツリーコンテキストが選択されます。コンテキストは、左の左以降のサブブロックネイバーに基づいており、それらが等しいかどうかはゼロ、またはそれらの組み合わせです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef enum\n{\n    LEFT4x4 = num_intra_bmodes,   /* use already-coded MV to\n                                     my left */\n    ABOVE4x4,             /* use already-coded MV above me */\n    ZERO4x4,              /* use zero MV */\n    NEW4x4,               /* explicit offset from \"best\" */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " num_sub_mv_ref }; sub_mv_ref;",
      "ja": "num_sub_mv_ref};sub_mv_ref;"
    },
    {
      "indent": 3,
      "text": "const tree_index sub_mv_ref_tree [2 * (num_sub_mv_ref - 1)] =\n{\n -LEFT4X4, 2,           /* LEFT = \"0\" */\n  -ABOVE4X4, 4,         /* ABOVE = \"10\" */\n   -ZERO4X4, -NEW4X4    /* ZERO = \"110\", NEW = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Choose correct decoding tree context\n * Function parameters are left subblock neighbor MV and above\n * subblock neighbor MV */\nint vp8_mvCont(MV *l, MV*a)\n{\n    int lez = (l->row == 0 && l->col == 0);   /* left neighbor\n                                                 is zero */\n    int aez = (a->row == 0 && a->col == 0);   /* above neighbor\n                                                 is zero */\n    int lea = (l->row == a->row && l->col == a->col);  /* left\n                             neighbor equals above neighbor */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (lea && lez)\n    return SUBMVREF_LEFT_ABOVE_ZED; /* =4 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (lea)\n    return SUBMVREF_LEFT_ABOVE_SAME; /* =3 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (aez)\n    return SUBMVREF_ABOVE_ZED; /* =2 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (lez)\n    return SUBMVREF_LEFT_ZED; /* =1*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return SUBMVREF_NORMAL; /* =0 */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Constant probabilities and decoding procedure. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const Prob sub_mv_ref_prob [5][num_sub_mv_ref - 1] = {\n    { 147,136,18 },\n    { 106,145,1  },\n    { 179,121,1  },\n    { 223,1  ,34 },\n    { 208,1  ,1  }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "sub_ref = (sub_mv_ref) treed_read(d, sub_mv_ref_tree,\n  sub_mv_ref_prob[context]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first two sub-prediction modes simply copy the already-coded motion vectors used by the blocks above and to the left of the subblock at the upper left corner of the current subset (i.e., collection of subblocks being predicted). These prediction blocks need not lie in the current macroblock and, if the current subset lies at the top or left edges of the frame, need not lie in the frame. In this latter case, their motion vectors are taken to be zero, as are subblock motion vectors within an intra-predicted macroblock. Also, to ensure the correctness of prediction within this macroblock, all subblocks lying in an already-decoded subset of the current macroblock must have their motion vectors set.",
      "ja": "最初の2つのサブ予測モードは、現在のサブセットの左上隅にあるサブブロックの左側と左側のブロック（つまり、予測されるサブブロックのコレクション）で使用される既にコードされたモーションベクトルを単純にコピーします。これらの予測ブロックは、現在のマクロブロックにある必要はなく、現在のサブセットがフレームの上部または左のエッジにある場合、フレームにある必要はありません。この後者の場合、彼らのモーションベクトルは、予測内マクロブロック内のサブブロックモーションベクトルと同様に、ゼロと見なされます。また、このマクロブロック内の予測の正確性を確保するには、現在のマクロブロックの既に説明されているサブセットにあるすべてのサブブロックがモーションベクトルを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "ZERO4x4 uses a zero motion vector and predicts the current subset using the corresponding subset from the prediction frame.",
      "ja": "zero4x4はゼロモーションベクトルを使用し、予測フレームから対応するサブセットを使用して現在のサブセットを予測します。"
    },
    {
      "indent": 3,
      "text": "NEW4x4 is exactly like NEWMV except that NEW4x4 is applied only to the current subset. It is followed by a two-dimensional motion vector offset (described in the next section) that is added to the best vector returned by the earlier call to find_near_mvs to form the motion vector in effect for the subset.",
      "ja": "New4x4は、New4x4が現在のサブセットにのみ適用されることを除いて、まったくnewMVとまったく同じです。その後、2次元のモーションベクトルオフセット（次のセクションで説明）が続き、FIND_NEAR_MVSの以前の呼び出しによって返された最高のベクトルに追加され、サブセットのモーションベクトルを形成します。"
    },
    {
      "indent": 3,
      "text": "Parsing of both inter-prediction modes and motion vectors (described next) can be found in the reference decoder file modemv.c (Section 20.11).",
      "ja": "予測間モードとモーションベクトルの両方の解析（次に説明）は、参照デコーダーファイルmodemv.c（セクション20.11）に記載されています。"
    },
    {
      "indent": 0,
      "text": "17. Motion Vector Decoding",
      "section_title": true,
      "ja": "17. モーションベクトルデコード"
    },
    {
      "indent": 3,
      "text": "As discussed above, motion vectors appear in two places in the VP8 datastream: applied to whole macroblocks in NEWMV mode and applied to subsets of macroblocks in NEW4x4 mode. The format of the vectors is identical in both cases.",
      "ja": "上記で説明したように、モーションベクトルはVP8 DataStreamの2つの場所に表示されます。NewMVモードでマクロブロック全体に適用され、New4X4モードのマクロブロックのサブセットに適用されます。ベクトルの形式は、どちらの場合も同一です。"
    },
    {
      "indent": 3,
      "text": "Each vector has two pieces: a vertical component (row) followed by a horizontal component (column). The row and column use separate coding probabilities but are otherwise represented identically.",
      "ja": "各ベクトルには、垂直コンポーネント（行）に続いて水平成分（列）が2つあります。行と列は個別のコーディング確率を使用しますが、それ以外の場合は同じように表されます。"
    },
    {
      "indent": 0,
      "text": "17.1. Coding of Each Component",
      "section_title": true,
      "ja": "17.1. 各コンポーネントのコーディング"
    },
    {
      "indent": 3,
      "text": "Each component is a signed integer V representing a vertical or horizontal luma displacement of V quarter-pixels (and a chroma displacement of V eighth-pixels). The absolute value of V, if non-zero, is followed by a boolean sign. V may take any value between -1023 and +1023, inclusive.",
      "ja": "各コンポーネントは、V四半期ピクセルの垂直または水平ルマの変位（およびV 8番目のピクセルのクロマ変位）を表す署名された整数Vです。Vの絶対値は、非ゼロの場合、ブールサインが続きます。vは、-1023から1023の間の任意の値を包括的にすることができます。"
    },
    {
      "indent": 3,
      "text": "The absolute value A is coded in one of two different ways according to its size. For 0 <= A <= 7, A is tree-coded, and for 8 <= A <= 1023, the bits in the binary expansion of A are coded using independent boolean probabilities. The coding of A begins with a bool specifying which range is in effect.",
      "ja": "絶対値Aは、そのサイズに応じて2つの異なる方法のいずれかでコーディングされます。0 <= a <= 7の場合、aはツリーコードされ、8 <= a <= 1023の場合、aのバイナリ拡張のビットは独立したブールの確率を使用してコード化されます。Aのコーディングは、どの範囲が有効であるかを指定するブールから始まります。"
    },
    {
      "indent": 3,
      "text": "Decoding a motion vector component then requires a 19-position probability table, whose offsets, along with the procedure used to decode components, are as follows:",
      "ja": "モーションベクトルコンポーネントをデコードするには、コンポーネントをデコードするために使用される手順とともに、オフセットが次のように、19位の確率テーブルが必要です。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef enum\n{\n    mvpis_short,         /* short (<= 7) vs long (>= 8) */\n    MVPsign,             /* sign for non-zero */\n    MVPshort,            /* 8 short values = 7-position tree */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "MVPbits = MVPshort + 7,      /* 8 long value bits\n                                w/independent probs */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    MVPcount = MVPbits + 10      /* 19 probabilities in total */\n}\nMVPindices;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef Prob MV_CONTEXT [MVPcount];    /* Decoding spec for\n                                          a single component */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Tree used for small absolute values (has expected\n   correspondence). */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const tree_index small_mvtree [2 * (8 - 1)] =\n{\n 2, 8,          /* \"0\" subtree, \"1\" subtree */\n  4, 6,         /* \"00\" subtree, \"01\" subtree */\n   -0, -1,      /* 0 = \"000\", 1 = \"001\" */\n   -2, -3,      /* 2 = \"010\", 3 = \"011\" */\n  10, 12,       /* \"10\" subtree, \"11\" subtree */\n   -4, -5,      /* 4 = \"100\", 5 = \"101\" */\n   -6, -7       /* 6 = \"110\", 7 = \"111\" */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Read MV component at current decoder position, using\n   supplied probs. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int read_mvcomponent(bool_decoder *d, const MV_CONTEXT *mvc)\n{\n    const Prob * const p = (const Prob *) mvc;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "int A = 0;",
      "ja": "int a = 0;"
    },
    {
      "indent": 7,
      "text": "if (read_bool(d, p [mvpis_short]))    /* 8 <= A <= 1023 */\n{\n    /* Read bits 0, 1, 2 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "int i = 0;\ndo { A += read_bool(d, p [MVPbits + i]) << i;}\n  while (++i < 3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Read bits 9, 8, 7, 6, 5, 4 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "i = 9;\ndo { A += read_bool(d, p [MVPbits + i]) << i;}\n  while (--i > 3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* We know that A >= 8 because it is coded long,\n   so if A <= 15, bit 3 is one and is not\n   explicitly coded. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (!(A & 0xfff0)  ||  read_bool(d, p [MVPbits + 3]))\n        A += 8;\n}\nelse    /* 0 <= A <= 7 */\n    A = treed_read(d, small_mvtree, p + MVPshort);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return A && read_bool(r, p [MVPsign]) ?  -A : A;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "17.2. Probability Updates",
      "section_title": true,
      "ja": "17.2. 確率の更新"
    },
    {
      "indent": 3,
      "text": "The decoder should maintain an array of two MV_CONTEXTs for decoding row and column components, respectively. These MV_CONTEXTs should be set to their defaults every key frame. Each individual probability may be updated every interframe (by field J of the frame header) using a constant table of update probabilities. Each optional update is of the form B? P(7), that is, a bool followed by a 7-bit probability specification if true.",
      "ja": "デコーダーは、それぞれ行と列コンポーネントをデコードするために、2つのMV_Contextsの配列を維持する必要があります。これらのMV_Contextは、すべてのキーフレームのデフォルトに設定する必要があります。個々の確率は、更新確率の定数テーブルを使用して、すべてのインターフレーム（フレームヘッダーのフィールドJによって）を更新できます。各オプションの更新はフォームBのものですか？p（7）、つまり、ブールに続いて7ビット確率仕様がtrueの場合。"
    },
    {
      "indent": 3,
      "text": "As with other dynamic probabilities used by VP8, the updates remain in effect until the next key frame or until replaced via another update.",
      "ja": "VP8が使用する他の動的確率と同様に、更新は次のキーフレームまで、または別の更新を介して置き換えるまで有効です。"
    },
    {
      "indent": 3,
      "text": "In detail, the probabilities should then be managed as follows.",
      "ja": "詳細には、確率を次のように管理する必要があります。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Never-changing table of update probabilities for each\n   individual probability used in decoding motion vectors. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const MV_CONTEXT vp8_mv_update_probs[2] =\n{\n  {\n    237,\n    246,\n    253, 253, 254, 254, 254, 254, 254,\n    254, 254, 254, 254, 254, 250, 250, 252, 254, 254\n  },\n  {\n    231,\n    243,\n    245, 253, 254, 254, 254, 254, 254,\n    254, 254, 254, 254, 254, 251, 251, 254, 254, 254\n  }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Default MV decoding probabilities. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const MV_CONTEXT default_mv_context[2] = { { // row 162, // is short 128, // sign 225, 146, 172, 147, 214, 39, 156, // short tree 128, 129, 132, 75, 145, 178, 206, 239, 254, 254 // long bits },",
      "ja": "const mv_context default_mv_context [2] = {{// row 162、// is short 128、// sign 225、146、172、147、214、39、156、//短いツリー128、129、132、75、145、178、206、239、254、254 //ロングビット}、"
    },
    {
      "indent": 5,
      "text": "{ // same for column 164, // is short 128, 204, 170, 119, 235, 140, 230, 228, 128, 130, 130, 74, 148, 180, 203, 236, 254, 254 // long bits",
      "ja": "{//列164、//は短い128、204、170、119、235、140、230、228、128、130、130、74、148、180、203、236、254、254 //長い//ビット"
    },
    {
      "indent": 3,
      "text": " } };",
      "ja": "}};"
    },
    {
      "indent": 3,
      "text": "/* Current MV decoding probabilities, set to above defaults\n   every key frame. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MV_CONTEXT mvc [2];     /* always row, then column */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Procedure for decoding a complete motion vector. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef struct { int16 row, col;}  MV;  /* as in previous section */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MV read_mv(bool_decoder *d)\n{\n    MV v;\n    v.row = (int16) read_mvcomponent(d, mvc);\n    v.col = (int16) read_mvcomponent(d, mvc + 1);\n    return v;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Procedure for updating MV decoding probabilities, called\n   every interframe with \"d\" at the appropriate position in\n   the frame header. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void update_mvcontexts(bool_decoder *d)\n{\n    int i = 0;\n    do {                      /* component = row, then column */\n        const Prob *up = mv_update_probs[i];    /* update probs\n                                                   for component */\n        Prob *p = mvc[i];                  /* start decode tbl \"\" */\n        Prob * const pstop = p + MVPcount; /* end decode tbl \"\" */\n        do {\n            if (read_bool(d, *up++))     /* update this position */\n            {\n                const Prob x = read_literal(d, 7);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                *p = x? x<<1 : 1;\n            }\n        } while (++p < pstop);              /* next position */\n    } while (++i < 2);                      /* next component */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This completes the description of the motion-vector decoding procedure and, with it, the procedure for decoding interframe macroblock prediction records.",
      "ja": "これにより、モーションベクトルデコード手順の説明と、それに伴い、インターフレームマクロブロック予測記録をデコードする手順が記入されます。"
    },
    {
      "indent": 0,
      "text": "18. Interframe Prediction",
      "section_title": true,
      "ja": "18. インターフレーム予測"
    },
    {
      "indent": 3,
      "text": "Given an inter-prediction specification for the current macroblock, that is, a reference frame together with a motion vector for each of the sixteen Y subblocks, we describe the calculation of the prediction buffer for the macroblock. Frame reconstruction is then completed via the previously described processes of residue summation (Section 14) and loop filtering (Section 15).",
      "ja": "現在のマクロブロックの予測間仕様、つまり16 Yの各サブブロックのモーションベクトルと一緒に参照フレームが与えられている場合、マクロブロックの予測バッファーの計算について説明します。その後、フレームの再構築は、以前に記載された残基合計（セクション14）およびループフィルタリング（セクション15）のプロセスを介して完了します。"
    },
    {
      "indent": 3,
      "text": "The management of inter-predicted subblocks and sub-pixel interpolation may be found in the reference decoder file predict.c (Section 20.14).",
      "ja": "相互予測されたサブブロックとサブピクセル補間の管理は、参照デコーダーファイルPredict.C（セクション20.14）に記載されている場合があります。"
    },
    {
      "indent": 0,
      "text": "18.1. Bounds on, and Adjustment of, Motion Vectors",
      "section_title": true,
      "ja": "18.1. モーションベクトルの境界および調整"
    },
    {
      "indent": 3,
      "text": "Since each motion vector is differentially encoded from a neighboring block or macroblock and the only clamp is to ensure that the referenced motion vector represents a valid location inside a reference frame buffer, it is technically possible within the VP8 format for a block or macroblock to have arbitrarily large motion vectors, up to the size of the input image plus the extended border areas. For practical reasons, VP8 imposes a motion vector size range limit of -4096 to 4095 full pixels, regardless of image size (VP8 defines 14 raw bits for width and height; 16383x16383 is the maximum possible image size). Bitstream-compliant encoders and decoders shall enforce this limit.",
      "ja": "各モーションベクトルは隣接するブロックまたはマクロブロックから差次的にエンコードされており、唯一のクランプは参照される動きベクトルが参照フレームバッファ内の有効な位置を表すことを確認することです。ブロックまたはマクロブロックのVP8形式内で技術的に可能です入力画像のサイズと拡張ボーダーエリアまでの任意の大きなモーションベクトル。実際的な理由で、VP8は、画像サイズに関係なく、動きベクトルサイズ範囲の-4096〜4095フルピクセルを課します（VP8は幅と高さの14個の生ビットを定義します; 16383X16383は可能な限り最大の画像サイズです）。BitStreamに準拠したエンコーダーとデコーダーは、この制限を実施するものとします。"
    },
    {
      "indent": 3,
      "text": "Because the motion vectors applied to the chroma subblocks have 1/8-pixel resolution, the synthetic pixel calculation, outlined in Section 5 and detailed below, uses this resolution for the luma subblocks as well. In accordance, the stored luma motion vectors are all doubled, each component of each luma vector becoming an even integer in the range -2046 to +2046, inclusive.",
      "ja": "クロマサブブロックに適用される動きベクターは1/8ピクセルの解像度を持っているため、セクション5で概説され、以下に詳細に概説されている合成ピクセル計算では、LUMAサブブロックにもこの解像度を使用しています。それに応じて、保存されたLumaモーションベクトルはすべて2倍になり、各Lumaベクターの各コンポーネントは、2046〜2046の範囲の均一な整数になります。"
    },
    {
      "indent": 3,
      "text": "The vector applied to each chroma subblock is calculated by averaging the vectors for the 4 luma subblocks occupying the same visible area as the chroma subblock in the usual correspondence; that is, the vector for U and V block 0 is the average of the vectors for the Y subblocks { 0, 1, 4, 5}, chroma block 1 corresponds to Y blocks { 2, 3, 6, 7}, chroma block 2 to Y blocks { 8, 9, 12, 13}, and chroma block 3 to Y blocks { 10, 11, 14, 15}.",
      "ja": "各クロマサブブロックに適用されるベクトルは、通常の対応でクロマサブブロックと同じ可視領域を占める4つのLUMAサブブロックのベクトルを平均化することによって計算されます。つまり、uとvブロック0のベクトルは、yサブブロックのベクトルの平均{0、1、4、5}、クロマブロック1はyブロック{2、3、6、7}、クロマブロックに対応します。2からYブロック{8、9、12、13}、およびChromaブロック3からYブロック{10、11、14、15}。"
    },
    {
      "indent": 3,
      "text": "In detail, each of the two components of the vectors for each of the chroma subblocks is calculated from the corresponding luma vector components as follows:",
      "ja": "詳細には、各クロマサブブロックのベクトルの2つのコンポーネントのそれぞれは、次のように対応するLUMAベクターコンポーネントから計算されます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int avg(int c1, int c2, int c3, int c4)\n{\n    int s = c1 + c2 + c3 + c4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* The shift divides by 8 (not 4) because chroma pixels\n   have twice the diameter of luma pixels.  The handling\n   of negative motion vector components is slightly\n   cumbersome because, strictly speaking, right shifts\n   of negative numbers are not well-defined in C. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return s >= 0 ?  (s + 4) >> 3 : -((-s + 4) >> 3);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Furthermore, if the version number in the frame tag specifies only full-pel chroma motion vectors, then the fractional parts of both components of the vector are truncated to zero, as illustrated in the following pseudocode (assuming 3 bits of fraction for both luma and chroma vectors):",
      "ja": "さらに、フレームタグのバージョン番号がフルペルクロマモーションベクトルのみを指定した場合、次の擬似コードに示されているように、ベクターの両方のコンポーネントの分数部分がゼロに切り捨てられます（Lumaと両方の分数で3ビットの分数を想定しています。クロマベクター）："
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "x = x & (~7);\ny = y & (~7);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Earlier in this document we described the vp8_clamp_mv() function to limit \"nearest\" and \"near\" motion vector predictors inside specified margins within the frame boundaries. Additional clamping is performed for NEWMV macroblocks, for which the final motion vector is clamped again after combining the \"best\" predictor and the differential vector decoded from the stream.",
      "ja": "このドキュメントの早い段階で、VP8_CLAMP_MV（）関数について説明し、フレーム境界内の指定されたマージン内の「最も近い」および「近く」モーションベクトル予測子を制限しました。NewMVマクロブロックに対して追加のクランプが実行されます。このクランプは、「最良の」予測因子とストリームからデコードされた微分ベクトルを組み合わせた後、再び最終運動ベクトルが再びクランプされます。"
    },
    {
      "indent": 3,
      "text": "However, the secondary clamping is not performed for SPLITMV macroblocks, meaning that any subblock's motion vector within the SPLITMV macroblock may point outside the clamping zone. These non-clamped vectors are also used when determining the decoding tree context for subsequent subblocks' modes in the vp8_mvCont() function.",
      "ja": "ただし、SplitMVマクロブロックではセカンダリクランプは実行されません。つまり、SplitMVマクロブロック内のサブブロックのモーションベクトルは、クランプゾーンの外側を指している可能性があります。これらの非クランプベクトルは、VP8_MVCONT（）関数の後続のサブブロックのモードのデコードツリーコンテキストを決定するときにも使用されます。"
    },
    {
      "indent": 0,
      "text": "18.2. Prediction Subblocks",
      "section_title": true,
      "ja": "18.2. 予測サブブロック"
    },
    {
      "indent": 3,
      "text": "The prediction calculation for each subblock is then as follows. Temporarily disregarding the fractional part of the motion vector (that is, rounding \"up\" or \"left\" by right-shifting each component 3 bits with sign propagation) and adding the origin (upper left position) of the (16x16 luma or 8x8 chroma) current macroblock gives us an origin in the Y, U, or V plane of the predictor frame (either the golden frame or previous frame).",
      "ja": "各サブブロックの予測計算は次のとおりです。モーションベクトルの分数部分を一時的に無視します（つまり、各コンポーネント3ビットを標識伝播で右シフトすることで「上」または「左」を丸めます）。）現在のマクロブロックは、予測因子フレームのy、u、またはV平面（ゴールデンフレームまたは以前のフレーム）の起源を提供します。"
    },
    {
      "indent": 3,
      "text": "Considering that origin to be the upper left corner of a (luma or chroma) macroblock, we need to specify the relative positions of the pixels associated to that subblock, that is, any pixels that might be involved in the sub-pixel interpolation processes for the subblock.",
      "ja": "その原点が（lumaまたはchroma）マクロブロックの左上隅であることを考慮すると、そのサブブロックに関連するピクセルの相対位置、つまりサブピクセル補間プロセスに関与する可能性のあるピクセルを指定する必要があります。サブブロック。"
    },
    {
      "indent": 0,
      "text": "18.3. Sub-Pixel Interpolation",
      "section_title": true,
      "ja": "18.3. サブピクセル補間"
    },
    {
      "indent": 3,
      "text": "The sub-pixel interpolation is effected via two one-dimensional convolutions. These convolutions may be thought of as operating on a two-dimensional array of pixels whose origin is the subblock origin, that is the origin of the prediction macroblock described above plus the offset to the subblock. Because motion vectors are arbitrary, so are these \"prediction subblock origins\".",
      "ja": "サブピクセルの補間は、2つの1次元畳み込みを介して行われます。これらの畳み込みは、原点がサブブロックの起源であるピクセルの2次元配列、つまり上記の予測マクロブロックの起源とサブブロックへのオフセットの起源で動作すると考えられるかもしれません。モーションベクトルは任意であるため、これらの「予測サブブロックの起源」も任意です。"
    },
    {
      "indent": 3,
      "text": "The integer part of the motion vector is subsumed in the origin of the prediction subblock; the 16 (synthetic) pixels we need to construct are given by 16 offsets from the origin. The integer part of each of these offsets is the offset of the corresponding pixel from the subblock origin (using the vertical stride). To these integer parts is added a constant fractional part, which is simply the difference between the actual motion vector and its integer truncation used to calculate the origins of the prediction macroblock and subblock. Each component of this fractional part is an integer between 0 and 7, representing a forward displacement in eighths of a pixel.",
      "ja": "モーションベクトルの整数部分は、予測サブブロックの原点に包まれています。構築する必要がある16（合成）ピクセルは、原点から16のオフセットによって与えられます。これらの各オフセットの整数部分は、サブブロック起点からの対応するピクセルのオフセットです（垂直ストライドを使用）。これらの整数部品に一定の分数部分が追加されます。これは、実際の動きベクトルと、予測マクロブロックとサブブロックの起源を計算するために使用される整数切り捨ての違いです。この分数部分の各コンポーネントは0〜7の間の整数であり、ピクセルの8分の1の前方変位を表します。"
    },
    {
      "indent": 3,
      "text": "It is these fractional displacements that determine the filtering process. If they both happen to be zero (that is, we had a \"whole pixel\" motion vector), the prediction subblock is simply copied into the corresponding piece of the current macroblock's prediction buffer. As discussed in Section 14, the layout of the macroblock's prediction buffer can depend on the specifics of the reconstruction implementation chosen. Of course, the vertical displacement between lines of the prediction subblock is given by the stride, as are all vertical displacements used here.",
      "ja": "フィルタリングプロセスを決定するのは、これらの部分的変位です。どちらもゼロ（つまり、「全体のピクセル」モーションベクトルがありました）である場合、予測サブブロックは、現在のマクロブロックの予測バッファーの対応する部分に単純にコピーされます。セクション14で説明したように、マクロブロックの予測バッファーのレイアウトは、選択した再構成実装の詳細に依存する可能性があります。もちろん、予測サブブロックの線間の垂直変位は、ここで使用されているすべての垂直変位と同様に、ストライドによって与えられます。"
    },
    {
      "indent": 3,
      "text": "Otherwise, at least one of the fractional displacements is non-zero. We then synthesize the missing pixels via a horizontal, followed by a vertical, one-dimensional interpolation.",
      "ja": "それ以外の場合、分数変位の少なくとも1つはゼロではありません。次に、水平を介して欠落しているピクセルを合成し、その後に垂直的で1次元補間を続けます。"
    },
    {
      "indent": 3,
      "text": "The two interpolations are essentially identical. Each uses a (at most) six-tap filter (the choice of which of course depends on the one-dimensional offset). Thus, every calculated pixel references at most three pixels before (above or to the left of) it and at most three pixels after (below or to the right of) it. The horizontal interpolation must calculate two extra rows above and three extra rows below the 4x4 block, to provide enough samples for the vertical interpolation to proceed.",
      "ja": "2つの補間は本質的に同一です。それぞれが（せいぜい）6タップフィルターを使用します（もちろん、1次元オフセットに依存する選択）。したがって、計算されたすべてのピクセル参照は、最大3ピクセル前（上または左の上または左側）で、最大3ピクセル後（下または右側）。水平方向の補間では、4x4ブロックの上に2つの余分な行と3つの追加行を計算して、垂直補間が進むのに十分なサンプルを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Depending on the reconstruction filter type given in the version number field in the frame tag, either a bicubic or a bilinear tap set is used.",
      "ja": "フレームタグのバージョン番号フィールドで指定された再構成フィルタータイプに応じて、二頭筋または双線形タップセットのいずれかが使用されます。"
    },
    {
      "indent": 3,
      "text": "The exact implementation of subsampling is as follows.",
      "ja": "サブサンプリングの正確な実装は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Filter taps taken to 7-bit precision.\n   Because DC is always passed, taps always sum to 128. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const int BilinearFilters[8][6] =\n{\n    { 0, 0, 128,   0, 0, 0 },\n    { 0, 0, 112,  16, 0, 0 },\n    { 0, 0,  96,  32, 0, 0 },\n    { 0, 0,  80,  48, 0, 0 },\n    { 0, 0,  64,  64, 0, 0 },\n    { 0, 0,  48,  80, 0, 0 },\n    { 0, 0,  32,  96, 0, 0 },\n    { 0, 0,  16, 112, 0, 0 }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const int filters [8] [6] = {        /* indexed by displacement */\n    { 0,  0,  128,    0,   0,  0 },  /* degenerate whole-pixel */\n    { 0, -6,  123,   12,  -1,  0 },  /* 1/8 */\n    { 2, -11, 108,   36,  -8,  1 },  /* 1/4 */\n    { 0, -9,   93,   50,  -6,  0 },  /* 3/8 */\n    { 3, -16,  77,   77, -16,  3 },  /* 1/2 is symmetric */\n    { 0, -6,   50,   93,  -9,  0 },  /* 5/8 = reverse of 3/8 */\n    { 1, -8,   36,  108, -11,  2 },  /* 3/4 = reverse of 1/4 */\n    { 0, -1,   12,  123,  -6,  0 }   /* 7/8 = reverse of 1/8 */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* One-dimensional synthesis of a single sample.\n   Filter is determined by fractional displacement */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pixel interp(\n    const int fil[6],   /* filter to apply */\n    const Pixel *p,     /* origin (rounded \"before\") in\n                           prediction area */\n    const int s         /* size of one forward step \"\" */\n) {\n    int32 a = 0;\n    int i = 0;\n    p -= s + s;         /* move back two positions */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "do {\n    a += *p * fil[i];\n    p += s;\n}  while (++i < 6);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return clamp255((a + 64) >> 7);    /* round to nearest\n                                           8-bit value */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* First do horizontal interpolation, producing intermediate\n   buffer. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void Hinterp(\n    Pixel temp[9][4],   /* 9 rows of 4 (intermediate)\n                           destination values */\n    const Pixel *p,     /* subblock origin in prediction\n                           frame */\n    int s,              /* vertical stride to be used in\n                           prediction frame */\n    uint hfrac,         /* 0 <= horizontal displacement <= 7 */\n    uint bicubic        /* 1=bicubic filter, 0=bilinear */\n) {\n    const int * const fil = bicubic ? filters [hfrac] :\n      BilinearFilters[hfrac];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "int r = 0;  do              /* for each row */\n{\n    int c = 0;  do          /* for each destination sample */\n    {\n        /* Pixel separation = one horizontal step = 1 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    temp[r][c] = interp(fil, p + c, 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        while (++c < 4);\n    }\n    while (p += s, ++r < 9);    /* advance p to next row */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Finish with vertical interpolation, producing final results.\n   Input array \"temp\" is of course that computed above. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void Vinterp(\n    Pixel final[4][4],  /* 4 rows of 4 (final) destination values */\n    const Pixel temp[9][4],\n    uint vfrac,         /* 0 <= vertical displacement <= 7 */\n    uint bicubic        /* 1=bicubic filter, 0=bilinear */\n) {\n    const int * const fil = bicubic ? filters [vfrac] :\n      BilinearFilters[vfrac];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "int r = 0;  do              /* for each row */\n{\n    int c = 0;  do          /* for each destination sample */\n    {\n        /* Pixel separation = one vertical step = width\n           of array = 4 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "            final[r][c] = interp(fil, temp[r] + c, 4);\n        }\n        while (++c < 4);\n    }\n    while (++r < 4);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.4. Filter Properties",
      "section_title": true,
      "ja": "18.4. フィルタープロパティ"
    },
    {
      "indent": 3,
      "text": "We discuss briefly the rationale behind the choice of filters. Our approach is necessarily cursory; a genuinely accurate discussion would require a couple of books. Readers unfamiliar with signal processing may or may not wish to skip this.",
      "ja": "フィルターの選択の背後にある理論的根拠について簡単に説明します。私たちのアプローチは必然的に大まかです。本当に正確な議論には数冊の本が必要です。信号処理に不慣れな読者は、これをスキップしたい場合と望まない場合があります。"
    },
    {
      "indent": 3,
      "text": "All digital signals are of course sampled in some fashion. The case where the inter-sample spacing (say in time for audio samples, or space for pixels) is uniform, that is, the same at all positions, is particularly common and amenable to analysis. Many aspects of the treatment of such signals are best-understood in the frequency domain via Fourier Analysis, particularly those aspects of the signal that are not changed by shifts in position, especially when those positional shifts are not given by a whole number of samples.",
      "ja": "もちろん、すべてのデジタル信号は何らかの形でサンプリングされます。サンプル間間隔（オーディオサンプルに間に合うように、またはピクセルのスペースなど）が均一である場合、つまり、すべての位置で同じである場合、特に一般的で分析に適しています。そのようなシグナルの処理の多くの側面は、フーリエ分析、特に位置のシフトによって変更されない信号の側面、特にそれらの位置シフトが多数のサンプルによって与えられない場合、信号の側面に最もよく理解されています。"
    },
    {
      "indent": 3,
      "text": "Non-integral translates of a sampled signal are a textbook example of the foregoing. In our case of non-integral motion vectors, we wish to say what the underlying image \"really is\" at these pixels; although we don't have values for them, we feel that it makes sense to talk about them. The correctness of this feeling is predicated on the underlying signal being band-limited, that is, not containing any energy in spatial frequencies that cannot be faithfully rendered at the pixel resolution at our disposal. In one dimension, this range of \"OK\" frequencies is called the Nyquist band; in our two-dimensional case of integer-grid samples, this range might be termed a Nyquist rectangle. The finer the grid, the more we know about the image, and the wider the Nyquist rectangle.",
      "ja": "サンプリングされた信号の非統合翻訳は、前述の教科書の例です。非統合運動ベクトルの場合、これらのピクセルで根底にあるイメージが「本当に」ということを言いたいと思います。私たちは彼らの価値を持っていませんが、私たちは彼らについて話すのは理にかなっていると感じています。この感情の正しさは、基礎となる信号がバンド制限されていること、つまり、ピクセル解像度で忠実にレンダリングできない空間周波数にエネルギーを含めていないことに基づいています。1つの次元では、この「OK」周波数の範囲はナイキストバンドと呼ばれます。整数グリッドサンプルの2次元の場合、この範囲はナイキスト長方形と呼ばれる可能性があります。グリッドが細かくなればなるほど、画像について知り合い、ナイキストの長方形が広くなります。"
    },
    {
      "indent": 3,
      "text": "It turns out that, for such band-limited signals, there is indeed an exact mathematical formula to produce the correct sample value at an arbitrary point. Unfortunately, this calculation requires the consideration of every single sample in the image, as well as needing to operate at infinite precision. Also, strictly speaking, all band-limited signals have infinite spatial (or temporal) extent, so everything we are discussing is really some sort of approximation.",
      "ja": "このようなバンド制限された信号については、任意のポイントで正しいサンプル値を生成するための正確な数学的式が実際にあることがわかります。残念ながら、この計算には、画像内のすべてのサンプルを考慮し、無限の精度で動作する必要があります。また、厳密に言えば、すべてのバンド制限された信号には無限の空間的（または時間的）範囲があるため、私たちが議論しているものはすべて、何らかの近似です。"
    },
    {
      "indent": 3,
      "text": "It is true that the theoretically correct subsampling procedure, as well as any approximation thereof, is always given by a translation-invariant weighted sum (or filter) similar to that used by VP8. It is also true that the reconstruction error made by such a filter can be simply represented as a multiplier in the frequency domain; that is, such filters simply multiply the Fourier transform of any signal to which they are applied by a fixed function associated to the filter. This fixed function is usually called the frequency response (or transfer function); the ideal subsampling filter has a frequency response equal to one in the Nyquist rectangle and zero everywhere else.",
      "ja": "理論的に正しいサブサンプリング手順、およびその近似は、VP8が使用したものと同様の翻訳不変の加重和（またはフィルター）によって常に与えられることは事実です。また、このようなフィルターによって作成された再構成エラーが、周波数ドメインの乗数として単純に表現できることも事実です。つまり、そのようなフィルターは、フィルターに関連付けられた固定関数によって適用される信号のフーリエ変換を単純に掛けるだけです。この固定関数は通常、周波数応答（または転送関数）と呼ばれます。理想的なサブサンプリングフィルターには、ナイキストの長方形の1つに等しい周波数応答があり、他のどこでもゼロです。"
    },
    {
      "indent": 3,
      "text": "Another basic fact about approximations to \"truly correct\" subsampling is that the wider the subrectangle (within the Nyquist rectangle) of spatial frequencies one wishes to \"pass\" (that is, correctly render) or, put more accurately, the closer one wishes to approximate the ideal transfer function, the more samples of the original signal must be considered by the subsampling, and the wider the calculation precision necessitated.",
      "ja": "「真に正しい」サブサンプリングの近似に関する別の基本的な事実は、空間周波数のサブレクタング（ナイキストの長方形内）が「通過」したい（つまり、正しくレンダリング）、またはより正確に置くことを望むほど、より正確に配置することを望むということです。理想的な伝達関数に近いほど、サブサンプリングによって元の信号のサンプルをより多く考慮する必要があり、計算精度がより広く必要とする必要があります。"
    },
    {
      "indent": 3,
      "text": "The filters chosen by VP8 were chosen, within the constraints of 4 or 6 taps and 7-bit precision, to do the best possible job of handling the low spatial frequencies near the 0th DC frequency along with introducing no resonances (places where the absolute value of the frequency response exceeds one).",
      "ja": "VP8によって選択されたフィルターは、4または6タップと7ビット精度の制約内で選択され、0番目のDC周波数の近くで低空間周波数を処理するための最良の仕事を行うことと、共鳴なし（絶対値がある場所の場所）周波数応答の1を超えます）。"
    },
    {
      "indent": 3,
      "text": "The justification for the foregoing has two parts. First, resonances can produce extremely objectionable visible artifacts when, as often happens in actual compressed video streams, filters are applied repeatedly. Second, the vast majority of energy in real-world images lies near DC and not at the high end.",
      "ja": "前述の正当化には2つの部分があります。第一に、共鳴は、実際の圧縮ビデオストリームで頻繁に発生するように、フィルターが繰り返し塗布されると、非常に好ましくない可視アーティファクトを生成する可能性があります。第二に、実際の画像のエネルギーの大部分はDCの近くにあり、ハイエンドではありません。"
    },
    {
      "indent": 3,
      "text": "To get slightly more specific, the filters chosen by VP8 are the best resonance-free 4- or 6-tap filters possible, where \"best\" describes the frequency response near the origin: The response at 0 is required to be 1, and the graph of the response at 0 is as flat as possible.",
      "ja": "わずかに具体的に取得するために、VP8によって選択されたフィルターは、可能な限り最高の共鳴フリー4または6タップフィルターです。ここで、「最適」は原点近くの周波数応答を記述します。0での応答は1であり、0での応答のグラフは、できるだけフラットです。"
    },
    {
      "indent": 3,
      "text": "To provide an intuitively more obvious point of reference, the \"best\" 2-tap filter is given by simple linear interpolation between the surrounding actual pixels.",
      "ja": "直感的により明白な参照ポイントを提供するために、「最良の」2タップフィルターは、周囲の実際のピクセル間の単純な線形補間によって与えられます。"
    },
    {
      "indent": 3,
      "text": "Finally, it should be noted that, because of the way motion vectors are calculated, the (shorter) 4-tap filters (used for odd fractional displacements) are applied in the chroma plane only. Human color perception is notoriously poor, especially where higher spatial frequencies are involved. The shorter filters are easier to understand mathematically, and the difference between them and a theoretically slightly better 6-tap filter is negligible where chroma is concerned.",
      "ja": "最後に、モーションベクトルの計算方法のために、（より短い）4タップフィルター（奇数分数変位に使用）がクロマ平面にのみ適用されることに注意してください。人間の色の知覚は、特により高い空間周波数が関与している場合、悪名高いことで有名です。短いフィルターは数学的に理解しやすく、それらと理論的にわずかに優れた6タップフィルターの違いは、Chromaが関係する場合は無視できます。"
    },
    {
      "indent": 0,
      "text": "19. Annex A: Bitstream Syntax",
      "section_title": true,
      "ja": "19. 付録A：BitStream構文"
    },
    {
      "indent": 3,
      "text": "This annex presents the bitstream syntax in a tabular form. All the information elements have been introduced and explained in the previous sections but are collected here for a quick reference. Each syntax element is briefly described after the tabular representation along with a reference to the corresponding paragraph in the main document. The meaning of each syntax element value is not repeated here.",
      "ja": "この付属書は、BitStreamの構文を表形式の構文を示します。すべての情報要素は、前のセクションで導入および説明されていますが、ここでは迅速な参照のために収集されます。各構文要素は、主なドキュメントの対応する段落への参照とともに、表形式の表現の後に簡単に説明されています。各構文要素値の意味は、ここでは繰り返されません。"
    },
    {
      "indent": 3,
      "text": "The top-level hierarchy of the bitstream is introduced in Section 4.",
      "ja": "ビットストリームのトップレベルの階層は、セクション4で紹介されています。"
    },
    {
      "indent": 3,
      "text": "Definition of syntax element coding types can be found in Section 8. The types used in the representation in this annex are:",
      "ja": "構文要素コーディングタイプの定義は、セクション8にあります。この付録の表現で使用されるタイプは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o f(n), n-bit value from stream (n successive bits, not boolean encoded)",
      "ja": "o f（n）、ストリームからのnビット値（n連続したビット、ブールエンコードされていない）"
    },
    {
      "indent": 3,
      "text": "o L(n), n-bit number encoded as n booleans (with equal probability of being 0 or 1)",
      "ja": "o l（n）、n buleansとしてエンコードされたnビット数（0または1である可能性が等しい）"
    },
    {
      "indent": 3,
      "text": "o B(p), bool with probability p of being 0",
      "ja": "o b（p）、0の確率pを持つブール"
    },
    {
      "indent": 3,
      "text": "o T, tree-encoded value",
      "ja": "o t、ツリーエンコード値"
    },
    {
      "indent": 0,
      "text": "19.1. Uncompressed Data Chunk",
      "section_title": true,
      "ja": "19.1. 非圧縮データチャンク"
    },
    {
      "indent": 3,
      "text": "| Frame Tag                                         | Type  |\n| ------------------------------------------------- | ----- |\n| frame_tag                                         | f(24) |\n| if (key_frame) {                                  |       |\n|     start_code                                    | f(24) |\n|     horizontal_size_code                          | f(16) |\n|     vertical_size_code                            | f(16) |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The 3-byte frame tag can be parsed as follows:",
      "ja": "3バイトのフレームタグは、次のように解析できます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "unsigned char *c = pbi->source;\nunsigned int tmp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tmp = (c[2] << 16) | (c[1] << 8) | c[0];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "key_frame = tmp & 0x1;\nversion = (tmp >> 1) & 0x7;\nshow_frame = (tmp >> 4) & 0x1;\nfirst_part_size = (tmp >> 5) & 0x7FFFF;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where:",
      "ja": "ただし："
    },
    {
      "indent": 3,
      "text": "o key_frame indicates whether the current frame is a key frame or not.",
      "ja": "o key_frameは、現在のフレームがキーフレームであるかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "o version determines the bitstream version.",
      "ja": "o バージョンは、BitStreamバージョンを決定します。"
    },
    {
      "indent": 3,
      "text": "o show_frame indicates whether the current frame is meant to be displayed or not.",
      "ja": "o show_frameは、現在のフレームが表示されるかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "o first_part_size determines the size of the first partition (control partition), excluding the uncompressed data chunk.",
      "ja": "o first_part_size最初のパーティション（制御パーティション）のサイズを決定し、非圧縮データチャンクを除く。"
    },
    {
      "indent": 3,
      "text": "The start_code is a constant 3-byte pattern having value 0x9d012a. The latter part of the uncompressed chunk (after the start_code) can be parsed as follows:",
      "ja": "start_codeは、値0x9d012aを持つ一定の3バイトパターンです。非圧縮チャンクの後半（start_codeの後）は次のように解析できます。"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "unsigned char *c = pbi->source + 6;\nunsigned int tmp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tmp = (c[1] << 8) | c[0];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "width = tmp & 0x3FFF;\nhorizontal_scale = tmp >> 14;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tmp = (c[3] << 8) | c[2];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "height = tmp & 0x3FFF;\nvertical_scale = tmp >> 14;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "19.2. Frame Header",
      "section_title": true,
      "ja": "19.2. フレームヘッダー"
    },
    {
      "indent": 3,
      "text": "| Frame Header                                      | Type  |\n| ------------------------------------------------- | ----- |\n| if (key_frame) {                                  |       |\n|   color_space                                     | L(1)  |\n|   clamping_type                                   | L(1)  |\n| }                                                 |       |\n| segmentation_enabled                              | L(1)  |\n| if (segmentation_enabled)                         |       |\n|   update_segmentation()                           |       |\n| filter_type                                       | L(1)  |\n| loop_filter_level                                 | L(6)  |\n| sharpness_level                                   | L(3)  |\n| mb_lf_adjustments()                               |       |\n| log2_nbr_of_dct_partitions                        | L(2)  |\n| quant_indices()                                   |       |\n| if (key_frame)                                    |       |\n|   refresh_entropy_probs                           | L(1)  |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "| else {                                            |       |\n|   refresh_golden_frame                            | L(1)  |\n|   refresh_alternate_frame                         | L(1)  |\n|   if (!refresh_golden_frame)                      |       |\n|     copy_buffer_to_golden                         | L(2)  |\n|   if (!refresh_alternate_frame)                   |       |\n|     copy_buffer_to_alternate                      | L(2)  |\n|   sign_bias_golden                                | L(1)  |\n|   sign_bias_alternate                             | L(1)  |\n|   refresh_entropy_probs                           | L(1)  |\n|   refresh_last                                    | L(1)  |\n| }                                                 |       |\n| token_prob_update()                               |       |\n| mb_no_skip_coeff                                  | L(1)  |\n| if (mb_no_skip_coeff)                             |       |\n|   prob_skip_false                                 | L(8)  |\n| if (!key_frame) {                                 |       |\n|   prob_intra                                      | L(8)  |\n|   prob_last                                       | L(8)  |\n|   prob_gf                                         | L(8)  |\n|   intra_16x16_prob_update_flag                    | L(1)  |\n|   if (intra_16x16_prob_update_flag) {             |       |\n|     for (i = 0; i < 4; i++)                       |       |\n|       intra_16x16_prob                            | L(8)  |\n|   }                                               |       |\n|   intra_chroma prob_update_flag                   | L(1)  |\n|   if (intra_chroma_prob_update_flag) {            |       |\n|     for (i = 0; i < 3; i++)                       |       |\n|       intra_chroma_prob                           | L(8)  |\n|   }                                               |       |\n|   mv_prob_update()                                |       |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o color_space defines the YUV color space of the sequence (Section 9.2)",
      "ja": "o Color_spaceは、シーケンスのYUVカラー空間を定義します（セクション9.2）"
    },
    {
      "indent": 3,
      "text": "o clamping_type specifies if the decoder is required to clamp the reconstructed pixel values (Section 9.2)",
      "ja": "o clamping_type再構成されたピクセル値をクランプするためにデコーダーが必要な場合（セクション9.2）"
    },
    {
      "indent": 3,
      "text": "o segmentation_enabled enables the segmentation feature for the current frame (Section 9.3)",
      "ja": "o segmentation_enabled現在のフレームのセグメンテーション機能を有効にします（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o filter_type determines whether the normal or the simple loop filter is used (Sections 9.4, 15)",
      "ja": "o filter_typeは、通常のループフィルターか単純なループフィルターが使用されるかどうかを決定します（セクション9.4、15）"
    },
    {
      "indent": 3,
      "text": "o loop_filter_level controls the deblocking filter (Sections 9.4, 15)",
      "ja": "o loop_filter_levelはデブロッキングフィルターを制御します（セクション9.4、15）"
    },
    {
      "indent": 3,
      "text": "o sharpness_level controls the deblocking filter (Sections 9.4, 15)",
      "ja": "o Sharpness_Levelはデブロッキングフィルターを制御します（セクション9.4、15）"
    },
    {
      "indent": 3,
      "text": "o log2_nbr_of_dct_partitions determines the number of separate partitions containing the DCT coefficients of the macroblocks (Section 9.5)",
      "ja": "o log2_nbr_of_of_dct_partitionsマクロブロックのDCT係数を含む個別のパーティションの数を決定します（セクション9.5）"
    },
    {
      "indent": 3,
      "text": "o refresh_entropy_probs determines whether updated token probabilities are used only for this frame or until further update",
      "ja": "o refresh_entropy_probsは、更新されたトークン確率がこのフレームにのみ使用されるのか、さらに更新されるまで使用されるかどうかを決定します"
    },
    {
      "indent": 3,
      "text": "o refresh_golden_frame determines if the current decoded frame refreshes the golden frame (Section 9.7)",
      "ja": "o refresh_golden_frameの現在のデコードされたフレームがゴールデンフレームを再表示するかどうかを決定します（セクション9.7）"
    },
    {
      "indent": 3,
      "text": "o refresh_alternate_frame determines if the current decoded frame refreshes the alternate reference frame (Section 9.7)",
      "ja": "o refresh_alternate_frameの現在のデコードされたフレームが代替参照フレームを再表示するかどうかを決定します（セクション9.7）"
    },
    {
      "indent": 3,
      "text": "o copy_buffer_to_golden determines if the golden reference is replaced by another reference (Section 9.7)",
      "ja": "o copy_buffer_to_goldenは、ゴールデン参照が別の参照に置き換えられているかどうかを決定します（セクション9.7）"
    },
    {
      "indent": 3,
      "text": "o copy_buffer_to_alternate determines if the alternate reference is replaced by another reference (Section 9.7)",
      "ja": "o copy_buffer_to_alternateは、代替参照が別の参照に置き換えられているかどうかを決定します（セクション9.7）"
    },
    {
      "indent": 3,
      "text": "o sign_bias_golden controls the sign of motion vectors when the golden frame is referenced (Section 9.7)",
      "ja": "o sign_bias_goldenゴールデンフレームが参照されるときにモーションベクトルの符号を制御します（セクション9.7）"
    },
    {
      "indent": 3,
      "text": "o sign_bias_alternate controls the sign of motion vectors when the alternate frame is referenced (Section 9.7)",
      "ja": "o sign_bias_alternate代替フレームが参照されている場合、モーションベクトルの符号を制御します（セクション9.7）"
    },
    {
      "indent": 3,
      "text": "o refresh_last determines if the current decoded frame refreshes the last frame reference buffer (Section 9.8)",
      "ja": "o refresh_last電流デコードされたフレームが最後のフレーム参照バッファーを再表示するかどうかを判断します（セクション9.8）"
    },
    {
      "indent": 3,
      "text": "o mb_no_skip_coeff enables or disables the skipping of macroblocks containing no non-zero coefficients (Section 9.10)",
      "ja": "o MB_NO_SKIP_COEFFは、ゼロ以外の係数を含むマクロブロックのスキップを有効または無効にします（セクション9.10）"
    },
    {
      "indent": 3,
      "text": "o prob_skip_false indicates the probability that the macroblock is not skipped (flag indicating skipped macroblock is false) (Section 9.10)",
      "ja": "o prob_skip_falseは、マクロブロックがスキップされない確率を示します（スキップされたマクロブロックが偽であることを示すフラグ）（セクション9.10）"
    },
    {
      "indent": 3,
      "text": "o prob_intra indicates the probability of an intra macroblock (Section 9.10)",
      "ja": "o prob_intraは、マクロブロック内の確率を示します（セクション9.10）"
    },
    {
      "indent": 3,
      "text": "o prob_last indicates the probability that the last reference frame is used for inter-prediction (Section 9.10)",
      "ja": "o prob_lastは、最後の参照フレームが予測間で使用される確率を示します（セクション9.10）"
    },
    {
      "indent": 3,
      "text": "o prob_gf indicates the probability that the golden reference frame is used for inter-prediction (Section 9.10)",
      "ja": "o prob_gfは、ゴールデン参照フレームが予測間で使用される確率を示します（セクション9.10）"
    },
    {
      "indent": 3,
      "text": "o intra_16x16_prob_update_flag indicates if the branch probabilities used in the decoding of the luma intra-prediction mode are updated (Section 9.10)",
      "ja": "o intra_16x16_prob_update_flagは、ルーマ内予測モードのデコードで使用されるブランチ確率が更新されているかどうかを示します（セクション9.10）"
    },
    {
      "indent": 3,
      "text": "o intra_16x16_prob indicates the branch probabilities of the luma intra-prediction mode decoding tree",
      "ja": "o intra_16x16_probは、LUMAの予測モードデコードツリーのブランチ確率を示します"
    },
    {
      "indent": 3,
      "text": "o intra_chroma_prob_update_flag indicates if the branch probabilities used in the decoding of the chroma intra-prediction mode are updated (Section 9.10)",
      "ja": "o intra_chroma_prob_update_flagは、クロマの予測モードのデコードで使用されるブランチ確率が更新されているかどうかを示します（セクション9.10）"
    },
    {
      "indent": 3,
      "text": "o intra_chroma_prob indicates the branch probabilities of the chroma intra-prediction mode decoding tree",
      "ja": "o intra_chroma_probは、クロマの予測モードデコードツリーのブランチ確率を示します"
    },
    {
      "indent": 3,
      "text": "| update_segmentation()                             | Type  |\n| ------------------------------------------------- | ----- |\n| update_mb_segmentation_map                        | L(1)  |\n| update_segment_feature_data                       | L(1)  |\n| if (update_segment_feature_data) {                |       |\n|   segment_feature_mode                            | L(1)  |\n|   for (i = 0; i < 4; i++) {                       |       |\n|     quantizer_update                              | L(1)  |\n|     if (quantizer_update) {                       |       |\n|       quantizer_update_value                      | L(7)  |\n|       quantizer_update_sign                       | L(1)  |\n|     }                                             |       |\n|   }                                               |       |\n|   for (i = 0; i < 4; i++) {                       |       |\n|     loop_filter_update                            | L(1)  |\n|     if (loop_filter_update) {                     |       |\n|       lf_update_value                             | L(6)  |\n|       lf_update_sign                              | L(1)  |\n|     }                                             |       |\n|   }                                               |       |\n| }                                                 |       |\n| if (update_mb_segmentation_map) {                 |       |\n|   for (i = 0; i < 3; i++) {                       |       |\n|     segment_prob_update                           | L(1)  |\n|     if (segment_prob_update)                      |       |\n|       segment_prob                                | L(8)  |\n|   }                                               |       |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o update_mb_segmentation_map determines if the MB segmentation map is updated in the current frame (Section 9.3)",
      "ja": "o update_mb_segmentation_mapは、MBセグメンテーションマップが現在のフレームで更新されているかどうかを決定します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o update_segment_feature_data indicates if the segment feature data is updated in the current frame (Section 9.3)",
      "ja": "o update_segment_feature_dataは、セグメント機能データが現在のフレームで更新されているかどうかを示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o segment_feature_mode indicates the feature data update mode, 0 for delta and 1 for the absolute value (Section 9.3)",
      "ja": "o segment_feature_mode機能データの更新モード、デルタの場合は0、絶対値の場合は1を示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o quantizer_update indicates if the quantizer value is updated for the i^(th) segment (Section 9.3)",
      "ja": "o Quantizer_Updateは、i^（th）セグメントの量子化値が更新されているかどうかを示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o quantizer_update_value indicates the update value for the segment quantizer (Section 9.3)",
      "ja": "o Quantizer_update_Valueは、セグメントの量子化器の更新値を示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o quantizer_update_sign indicates the update sign for the segment quantizer (Section 9.3)",
      "ja": "o Quantizer_update_Signセグメント量子化器の更新サインを示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o loop_filter_update indicates if the loop filter level value is updated for the i^(th) segment (Section 9.3)",
      "ja": "o loop_filter_updateは、i^（th）セグメントのループフィルターレベル値が更新されているかどうかを示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o lf_update_value indicates the update value for the loop filter level (Section 9.3)",
      "ja": "o lf_update_valueは、ループフィルターレベルの更新値を示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o lf_update_sign indicates the update sign for the loop filter level (Section 9.3)",
      "ja": "o lf_update_signループフィルターレベルの更新符号を示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "o segment_prob_update indicates whether the branch probabilities used to decode the segment_id in the MB header are decoded from the stream or use the default value of 255 (Section 9.3)",
      "ja": "o segment_prob_update MBヘッダーのsegment_idをデコードするために使用されるブランチ確率がストリームからデコードされるか、デフォルト値255（セクション9.3）を使用しているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "o segment_prob indicates the branch probabilities of the segment_id decoding tree (Section 9.3)",
      "ja": "o segment_probは、segment_idデコードツリーの分岐確率を示します（セクション9.3）"
    },
    {
      "indent": 3,
      "text": "| mb_lf_adjustments()                               | Type  |\n| ------------------------------------------------- | ----- |\n| loop_filter_adj_enable                            | L(1)  |\n| if (loop_filter_adj_enable) {                     |       |\n|   mode_ref_lf_delta_update                        | L(1)  |\n|   if (mode_ref_lf_delta_update) {                 |       |\n|     for (i = 0; i < 4; i++) {                     |       |\n|       ref_frame_delta_update_flag                 | L(1)  |\n|       if (ref_frame_delta_update_flag) {          |       |\n|         delta_magnitude                           | L(6)  |\n|         delta_sign                                | L(1)  |\n|       }                                           |       |\n|     }                                             |       |\n|     for (i = 0; i < 4; i++) {                     |       |\n|       mb_mode_delta_update_flag                   | L(1)  |\n|       if (mb_mode_delta_update_flag) {            |       |\n|         delta_magnitude                           | L(6)  |\n|         delta_sign                                | L(1)  |\n|       }                                           |       |\n|     }                                             |       |\n|   }                                               |       |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o loop_filter_adj_enable indicates if the MB-level loop filter adjustment (based on the used reference frame and coding mode) is on for the current frame (Section 9.4)",
      "ja": "o LOOP_FILTER_ADJ_ENABLEは、現在のフレーム（セクション9.4）に対して、MBレベルループフィルター調整（使用されている参照フレームとコーディングモードに基づく）がオンになっているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "o mode_ref_lf_delta_update indicates if the delta values used in an adjustment are updated in the current frame (Section 9.4)",
      "ja": "o MODE_REF_LF_DELTA_UPDATEは、調整で使用されているデルタ値が現在のフレームで更新されているかどうかを示します（セクション9.4）"
    },
    {
      "indent": 3,
      "text": "o ref_frame_delta_update_flag indicates if the adjustment delta value corresponding to a certain used reference frame is updated (Section 9.4)",
      "ja": "o ref_frame_delta_update_flagは、特定の使用されている参照フレームに対応する調整デルタ値が更新されているかどうかを示します（セクション9.4）"
    },
    {
      "indent": 3,
      "text": "o delta_magnitude is the absolute value of the delta value",
      "ja": "o Delta_magnitudeは、Delta値の絶対値です"
    },
    {
      "indent": 3,
      "text": "o delta_sign is the sign of the delta value",
      "ja": "o Delta_SignはDelta値の兆候です"
    },
    {
      "indent": 3,
      "text": "o mb_mode_delta_update_flag indicates if the adjustment delta value corresponding to a certain MB prediction mode is updated (Section 9.4)",
      "ja": "o MB_MODE_DELTA_UPDATE_FLAGは、特定のMB予測モードに対応する調整デルタ値が更新されているかどうかを示します（セクション9.4）"
    },
    {
      "indent": 3,
      "text": "| quant_indices()                                   | Type  |\n| ------------------------------------------------- | ----- |\n| y_ac_qi                                           | L(7)  |\n| y_dc_delta_present                                | L(1)  |\n| if (y_dc_delta_present) {                         |       |\n|   y_dc_delta_magnitude                            | L(4)  |\n|   y_dc_delta_sign                                 | L(1)  |\n| }                                                 |       |\n| y2_dc_delta_present                               | L(1)  |\n| if (y2_dc_delta_present) {                        |       |\n|   y2_dc_delta_magnitude                           | L(4)  |\n|   y2_dc_delta_sign                                | L(1)  |\n| }                                                 |       |\n| y2_ac_delta_present                               | L(1)  |\n| if (y2_ac_delta_present) {                        |       |\n|   y2_ac_delta_magnitude                           | L(4)  |\n|   y2_ac_delta_sign                                | L(1)  |\n| }                                                 |       |\n| uv_dc_delta_present                               | L(1)  |\n| if (uv_dc_delta_present) {                        |       |\n|   uv_dc_delta_magnitude                           | L(4)  |\n|   uv_dc_delta_sign                                | L(1)  |\n| }                                                 |       |\n| uv_ac_delta_present                               | L(1)  |\n| if (uv_ac_delta_present) {                        |       |\n|   uv_ac_delta_magnitude                           | L(4)  |\n|   uv_ac_delta_sign                                | L(1)  |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o y_ac_qi is the dequantization table index used for the luma AC coefficients (and other coefficient groups if no delta value is present) (Section 9.6)",
      "ja": "o Y_AC_QIは、LUMA AC係数（およびデルタ値が存在しない場合、その他の係数グループ）に使用される不安定化テーブルインデックスです（セクション9.6）"
    },
    {
      "indent": 3,
      "text": "o y_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the luma DC coefficient dequantization index (Section 9.6)",
      "ja": "o Y_DC_DELTA_PRESENTストリームにベースラインインデックスに追加されるデルタ値が含まれているかどうかを示して、LUMA DC係数脱量化インデックス（セクション9.6）を取得します"
    },
    {
      "indent": 3,
      "text": "o y_dc_delta_magnitude is the magnitude of the delta value (Section 9.6)",
      "ja": "o y_dc_delta_magnitudeはデルタ値の大きさです（セクション9.6）"
    },
    {
      "indent": 3,
      "text": "o y_dc_delta_sign is the sign of the delta value (Section 9.6)",
      "ja": "o y_dc_delta_signはデルタ値の兆候です（セクション9.6）"
    },
    {
      "indent": 3,
      "text": "o y2_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the Y2 block DC coefficient dequantization index (Section 9.6)",
      "ja": "o Y2_DC_DELTA_PRESENTストリームにベースラインインデックスに追加されるデルタ値が含まれているかどうかを示して、Y2ブロックDC係数デコンゼーションインデックス（セクション9.6）を取得します"
    },
    {
      "indent": 3,
      "text": "o y2_ac_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the Y2 block AC coefficient dequantization index (Section 9.6)",
      "ja": "o Y2_AC_DELTA_PRESENTストリームにベースラインインデックスに追加されるデルタ値が含まれているかどうかを示して、Y2ブロックAC係数デコンティ化インデックス（セクション9.6）を取得します"
    },
    {
      "indent": 3,
      "text": "o uv_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the chroma DC coefficient dequantization index (Section 9.6)",
      "ja": "o UV_DC_DELTA_PRESENTストリームにベースラインインデックスに追加されるデルタ値が含まれているかどうかを示して、Chroma DC係数デコンティゼーションインデックス（セクション9.6）を取得します"
    },
    {
      "indent": 3,
      "text": "o uv_ac_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the chroma AC coefficient dequantization index (Section 9.6)",
      "ja": "o UV_AC_DELTA_PRESENTストリームにベースラインインデックスに追加されるデルタ値が含まれているかどうかを示して、Chroma AC係数デコンティ化インデックス（セクション9.6）を取得します"
    },
    {
      "indent": 3,
      "text": "| token_prob_update()                               | Type  |\n| ------------------------------------------------- | ----- |\n| for (i = 0; i < 4; i++) {                         |       |\n|   for (j = 0; j < 8; j++) {                       |       |\n|     for (k = 0; k < 3; k++) {                     |       |\n|       for (l = 0; l < 11; l++) {                  |       |\n|         coeff_prob_update_flag                    | L(1)  |\n|         if (coeff_prob_update_flag)               |       |\n|           coeff_prob                              | L(8)  |\n|       }                                           |       |\n|     }                                             |       |\n|   }                                               |       |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o coeff_prob_update_flag indicates if the corresponding branch probability is updated in the current frame (Section 13.4)",
      "ja": "o coeff_prob_update_flagは、対応するブランチの確率が現在のフレームで更新されているかどうかを示します（セクション13.4）"
    },
    {
      "indent": 3,
      "text": "o coeff_prob is the new branch probability (Section 13.4)",
      "ja": "o coeff_probは新しいブランチの確率です（セクション13.4）"
    },
    {
      "indent": 3,
      "text": "| mv_prob_update()                                  | Type  |\n| ------------------------------------------------- | ----- |\n| for (i = 0; i < 2; i++) {                         |       |\n|   for (j = 0; j < 19; j++) {                      |       |\n|     mv_prob_update_flag                           | L(1)  |\n|     if (mv_prob_update_flag)                      |       |\n|       prob                                        | L(7)  |\n|   }                                               |       |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o mv_prob_update_flag indicates if the corresponding MV decoding probability is updated in the current frame (Section 17.2)",
      "ja": "o MV_PROB_UPDATE_FLAGは、対応するMVデコード確率が現在のフレームで更新されているかどうかを示します（セクション17.2）"
    },
    {
      "indent": 3,
      "text": "o prob is the updated probability (Section 17.2)",
      "ja": "o probは更新された確率（セクション17.2）です"
    },
    {
      "indent": 0,
      "text": "19.3. Macroblock Data",
      "section_title": true,
      "ja": "19.3. マクロブロックデータ"
    },
    {
      "indent": 3,
      "text": "| Macroblock Data                                   | Type  |\n| ------------------------------------------------- | ----- |\n| macroblock_header()                               |       |\n| residual_data()                                   |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "| macroblock_header()                               | Type  |\n| ------------------------------------------------- | ----- |\n| if (update_mb_segmentation_map)                   |       |\n|   segment_id                                      | T     |\n| if (mb_no_skip_coeff)                             |       |\n|   mb_skip_coeff                                   | B(p)  |\n| if (!key_frame)                                   |       |\n|   is_inter_mb                                     | B(p)  |\n| if (is_inter_mb) {                                |       |\n|   mb_ref_frame_sel1                               | B(p)  |\n|   if (mb_ref_frame_sel1)                          |       |\n|     mb_ref_frame_sel2                             | B(p)  |\n|   mv_mode                                         | T     |\n|   if (mv_mode == SPLITMV) {                       |       |\n|     mv_split_mode                                 | T     |\n|     for (i = 0; i < numMvs; i++) {                |       |\n|       sub_mv_mode                                 | T     |\n|       if (sub_mv_mode == NEWMV4x4) {              |       |\n|         read_mvcomponent()                        |       |\n|         read_mvcomponent()                        |       |\n|       }                                           |       |\n|     }                                             |       |\n|   } else if (mv_mode == NEWMV) {                  |       |\n|     read_mvcomponent()                            |       |\n|     read_mvcomponent()                            |       |\n|   }                                               |       |\n| } else { /* intra mb */                           |       |\n|   intra_y_mode                                    | T     |\n|   if (intra_y_mode == B_PRED) {                   |       |\n|     for (i = 0; i < 16; i++)                      |       |\n|       intra_b_mode                                | T     |\n|   }                                               |       |\n|   intra_uv_mode                                   | T     |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o segment_id indicates to which segment the macroblock belongs (Section 10)",
      "ja": "o segment_idは、マクロブロックがどのセグメントに属しているかを示します（セクション10）"
    },
    {
      "indent": 3,
      "text": "o mb_skip_coeff indicates whether the macroblock contains any coded coefficients or not (Section 11.1)",
      "ja": "o MB_SKIP_COEFFは、マクロブロックにコード化された係数が含まれているかどうかを示します（セクション11.1）"
    },
    {
      "indent": 3,
      "text": "o is_inter_mb indicates whether the macroblock is intra- or inter-coded (Section 16)",
      "ja": "o IS_INTER_MBは、マクロブロックがイントラコードまたはインターコード化されているかどうかを示します（セクション16）"
    },
    {
      "indent": 3,
      "text": "o mb_ref_frame_sel1 selects the reference frame to be used; last frame (0), golden/alternate (1) (Section 16.2)",
      "ja": "o MB_REF_FRAME_SEL1使用する参照フレームを選択します。最後のフレーム（0）、ゴールデン/代替（1）（セクション16.2）"
    },
    {
      "indent": 3,
      "text": "o mb_ref_frame_sel2 selects whether the golden (0) or alternate reference frame (1) is used (Section 16.2)",
      "ja": "o MB_REF_FRAME_SEL2ゴールデン（0）または代替参照フレーム（1）が使用されるかどうかを選択します（セクション16.2）"
    },
    {
      "indent": 3,
      "text": "o mv_mode determines the macroblock motion vector mode (Section 16.2)",
      "ja": "o MV_MODEマクロブロックモーションベクトルモード（セクション16.2）を決定します"
    },
    {
      "indent": 3,
      "text": "o mv_split_mode gives the macroblock partitioning specification and determines the number of motion vectors used (numMvs) (Section 16.2)",
      "ja": "o MV_SPLIT_MODEはマクロブロックパーティション仕様を提供し、使用するモーションベクトルの数（NUMMVS）の数を決定します（セクション16.2）"
    },
    {
      "indent": 3,
      "text": "o sub_mv_mode determines the sub-macroblock motion vector mode for macroblocks coded using the SPLITMV motion vector mode (Section 16.2)",
      "ja": "o sub_mv_mode splitMVモーションベクトルモード（セクション16.2）を使用してコード化されたマクロブロックのサブマクロブロックモーションベクトルモードを決定します"
    },
    {
      "indent": 3,
      "text": "o intra_y_mode selects the luminance intra-prediction mode (Section 16.1)",
      "ja": "o intra_y_mode輝度イントラ予測モード（セクション16.1）を選択します"
    },
    {
      "indent": 3,
      "text": "o intra_b_mode selects the sub-macroblock luminance prediction mode for macroblocks coded using B_PRED mode (Section 16.1)",
      "ja": "o intra_b_mode b_predモードを使用してコード化されたマクロブロックのサブマクロブロック輝度予測モードを選択します（セクション16.1）"
    },
    {
      "indent": 3,
      "text": "o intra_uv_mode selects the chrominance intra-prediction mode (Section 16.1)",
      "ja": "o intra_uv_modeクロミナンス内容モードを選択します（セクション16.1）"
    },
    {
      "indent": 3,
      "text": "| residual_data()                                   | Type  |\n| ------------------------------------------------- | ----- |\n| if (!mb_skip_coeff) {                             |       |\n|   if ( (is_inter_mb && mv_mode != SPLITMV) ||     |       |\n|        (!is_inter_mb && intra_y_mode != B_PRED) ) |       |\n|     residual_block() /* Y2 */                     |       |\n|   for (i = 0; i < 24; i++)                        |       |\n|     residual_block() /* 16 Y, 4 U, 4 V */         |       |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "| residual_block()                                  | Type  |\n| ------------------------------------------------- | ----- |\n| for (i = firstCoeff; i < 16; i++) {               |       |\n|   token                                           | T     |\n|   if (token == EOB) break;                        |       |\n|   if (token_has_extra_bits)                       |       |\n|     extra_bits                                    | L(n)  |\n|   if (coefficient != 0)                           |       |\n|     sign                                          | L(1)  |\n| }                                                 |       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o firstCoeff is 1 for luma blocks of macroblocks containing Y2 subblock; otherwise 0",
      "ja": "o FirstCoeffは、Y2サブブロックを含むマクロブロックのLUMAブロックの1です。それ以外の場合は0"
    },
    {
      "indent": 3,
      "text": "o token defines the value of the coefficient, the value range of the coefficient, or the end of block (Section 13.2)",
      "ja": "o トークンは、係数の値、係数の値範囲、またはブロックの終わりを定義します（セクション13.2）"
    },
    {
      "indent": 3,
      "text": "o extra_bits determines the value of the coefficient within the value range defined by the token (Section 13.2)",
      "ja": "o Extra_bitsは、トークンで定義された値範囲内の係数の値を決定します（セクション13.2）"
    },
    {
      "indent": 3,
      "text": "o sign indicates the sign of the coefficient (Section 13.2)",
      "ja": "o 記号は係数の符号を示します（セクション13.2）"
    },
    {
      "indent": 0,
      "text": "20. Attachment One: Reference Decoder Source Code",
      "section_title": true,
      "ja": "20. 添付ファイル1：リファレンスデコーダーソースコード"
    },
    {
      "indent": 0,
      "text": "20.1. bit_ops.h",
      "section_title": true,
      "ja": "20.1. bit_ops.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef BIT_OPS_H\n#define BIT_OPS_H",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Evaluates to a mask with n bits set */\n#define BITS_MASK(n) ((1<<(n))-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Returns len bits, with the LSB at position bit */\n#define BITS_GET(val, bit, len) (((val)>>(bit))&BITS_MASK(len))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.2. bool_decoder.h",
      "section_title": true,
      "ja": "20.2. bool_decoder.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef BOOL_DECODER_H\n#define BOOL_DECODER_H\n#include <stddef.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct bool_decoder\n{\n    const unsigned char *input;      /* next compressed data byte */\n    size_t               input_len;  /* length of the input buffer */\n    unsigned int         range;      /* identical to encoder's\n                                      * range */\n    unsigned int         value;      /* contains at least 8\n                                      * significant bits */\n    int                  bit_count;  /* # of bits shifted out of\n                                      * value, max 7 */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\ninit_bool_decoder(struct bool_decoder *d,\n                  const unsigned char *start_partition,\n                  size_t               sz)\n{\n    if (sz >= 2)\n    {\n        d->value = (start_partition[0] << 8) /* first 2 input\n                                              * bytes */\n                   | start_partition[1];\n        d->input = start_partition + 2;      /* ptr to next byte */\n        d->input_len = sz - 2;\n    }\n    else\n    {\n        d->value = 0;\n        d->input = NULL;\n        d->input_len = 0;\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    d->range = 255;    /* initial range is full */\n    d->bit_count = 0;  /* have not yet shifted out any bits */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int bool_get(struct bool_decoder *d, int probability)\n{\n    /* range and split are identical to the corresponding values\n       used by the encoder when this bool was written */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "unsigned int  split = 1 + (((d->range - 1) * probability) >> 8);\nunsigned int  SPLIT = split << 8;\nint           retval;           /* will be 0 or 1 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (d->value >= SPLIT)    /* encoded a one */\n{\n    retval = 1;\n    d->range -= split;  /* reduce range */\n    d->value -= SPLIT;  /* subtract off left endpoint of\n                         * interval */\n}\nelse                  /* encoded a zero */\n{\n    retval = 0;\n    d->range = split; /* reduce range, no change in left\n                       * endpoint */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "while (d->range < 128)    /* shift out irrelevant value bits */\n{\n    d->value <<= 1;\n    d->range <<= 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (++d->bit_count == 8)  /* shift in new bits 8 at a time */\n{\n    d->bit_count = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        if (d->input_len)\n        {\n            d->value |= *d->input++;\n            d->input_len--;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return retval; }",
      "ja": "返品retval;}"
    },
    {
      "indent": 3,
      "text": "static int bool_get_bit(struct bool_decoder *br)\n{\n    return bool_get(br, 128);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int bool_get_uint(struct bool_decoder *br, int bits)\n{\n    int z = 0;\n    int bit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (bit = bits - 1; bit >= 0; bit--)\n{\n    z |= (bool_get_bit(br) << bit);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return z; }",
      "ja": "zを返します。}"
    },
    {
      "indent": 3,
      "text": "static int bool_get_int(struct bool_decoder *br, int bits)\n{\n    int z = 0;\n    int bit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (bit = bits - 1; bit >= 0; bit--)\n{\n    z |= (bool_get_bit(br) << bit);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return bool_get_bit(br) ? -z : z;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int bool_maybe_get_int(struct bool_decoder *br, int bits)\n{\n    return bool_get_bit(br) ? bool_get_int(br, bits) : 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int bool_read_tree(struct bool_decoder *bool, const int *t, const unsigned char *p) { int i = 0;",
      "ja": "static int bool_read_tree（struct bool_decoder *bool、const int *t、const unsigned char *p）{int i = 0;"
    },
    {
      "indent": 7,
      "text": "while ((i = t[ i + bool_get(bool, p[i>>1])]) > 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return -i; } #endif",
      "ja": "return -i;} #endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.3. dequant_data.h",
      "section_title": true,
      "ja": "20.3. dequant_data.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const int dc_q_lookup[128] = { 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157 };",
      "ja": "static const int dc_q_lookup [128] = {4、5、6、7、8、9、10、11、12、13、14、15、16、17、17、18、19、20、20、21、21、22、22、23、23、24、25、25、26、27、28、29、30、31、32、33、34、35、36、37、37、38、39、40、41、42、43、44、45、46、46、47、48、49、50、51、52、53、54、55、56、57、58、59、60、61、62、63、64、64、65、66、67、68、69、70、71、72、73、74、75、76、76、77、78、79、80、81、82、83、84、85、86、87、87、88、89、91、93、95、96、98、100、101、102、104、106、108、110、112、114、116、118、122、124、126、128、130、132、134、136、138、140、143、145、148、151、154、157};"
    },
    {
      "indent": 3,
      "text": "static const int ac_q_lookup[128] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152,",
      "ja": "static const int ac_q_lookup [128] = {4、5、6、7、8、9、10、11、12、13、14、16、17、18、19、20、21、22、23、24、25、26、27、28、29、30、31、32、33、34、35、36、37、38、39、40、41、42、43、44、45、46、47、48、49、50、51、52、53、54、55、56、57、58、60、62、64、66、68、70、72、74、76、78、80、82、84、86、88、90、92、94、96、98、100、102、104、106、108、110、112、114、116、119、122、125、128、131、134、137、140、143、146、149、152、149、152、"
    },
    {
      "indent": 3,
      "text": " 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284 };",
      "ja": "155、158、161、164、167、170、173、177、181、185、189、193、197、201、205、209、213、217、221、225、229、234、239、245、245、249、249、254、259、264、269、274、279、284};"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.4. dixie.c",
      "section_title": true,
      "ja": "20.4. dixie.c"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#include \"vpx_codec_internal.h\"\n#include \"bit_ops.h\"\n#include \"dixie.h\"\n#include \"vp8_prob_data.h\"\n#include \"dequant_data.h\"\n#include \"modemv.h\"\n#include \"tokens.h\"\n#include \"predict.h\"\n#include \"dixie_loopfilter.h\"\n#include <string.h>\n#include <assert.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { FRAME_HEADER_SZ = 3, KEYFRAME_HEADER_SZ = 7 };",
      "ja": "enum {frame_header_sz = 3、keyframe_header_sz = 7};"
    },
    {
      "indent": 3,
      "text": "#define ARRAY_COPY(a,b) {\\\n    assert(sizeof(a)==sizeof(b));memcpy(a,b,sizeof(a));}\nstatic void\ndecode_entropy_header(struct vp8_decoder_ctx    *ctx,\n                      struct bool_decoder       *bool,\n                      struct vp8_entropy_hdr    *hdr)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{ int i, j, k, l;",
      "ja": "{int i、j、k、l;"
    },
    {
      "indent": 7,
      "text": "/* Read coefficient probability updates */\nfor (i = 0; i < BLOCK_TYPES; i++)\n    for (j = 0; j < COEFF_BANDS; j++)\n        for (k = 0; k < PREV_COEFF_CONTEXTS; k++)\n            for (l = 0; l < ENTROPY_NODES; l++)\n                if (bool_get(bool,\n                             k_coeff_entropy_update_probs\n                                 [i][j][k][l]))\n                    hdr->coeff_probs[i][j][k][l] =\n                        bool_get_uint(bool, 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Read coefficient skip mode probability */\nhdr->coeff_skip_enabled = bool_get_bit(bool);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (hdr->coeff_skip_enabled)\n    hdr->coeff_skip_prob = bool_get_uint(bool, 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Parse interframe probability updates */\nif (!ctx->frame_hdr.is_keyframe)\n{\n    hdr->prob_inter = bool_get_uint(bool, 8);\n    hdr->prob_last  = bool_get_uint(bool, 8);\n    hdr->prob_gf    = bool_get_uint(bool, 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (bool_get_bit(bool))\n    for (i = 0; i < 4; i++)\n        hdr->y_mode_probs[i] = bool_get_uint(bool, 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (bool_get_bit(bool))\n    for (i = 0; i < 3; i++)\n        hdr->uv_mode_probs[i] = bool_get_uint(bool, 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        for (i = 0; i < 2; i++)\n            for (j = 0; j < MV_PROB_CNT; j++)\n                if (bool_get(bool, k_mv_entropy_update_probs[i][j]))\n                {\n                    int x = bool_get_uint(bool, 7);\n                    hdr->mv_probs[i][j] = x ? x << 1 : 1;\n                }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\ndecode_reference_header(struct vp8_decoder_ctx    *ctx,\n                        struct bool_decoder       *bool,\n                        struct vp8_reference_hdr  *hdr)\n{\n    unsigned int key = ctx->frame_hdr.is_keyframe;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    hdr->refresh_gf    = key ? 1 : bool_get_bit(bool);\n    hdr->refresh_arf   = key ? 1 : bool_get_bit(bool);\n    hdr->copy_gf       = key ? 0 : !hdr->refresh_gf\n                         ? bool_get_uint(bool, 2) : 0;\n    hdr->copy_arf      = key ? 0 : !hdr->refresh_arf\n                         ? bool_get_uint(bool, 2) : 0;\n    hdr->sign_bias[GOLDEN_FRAME] = key ? 0 : bool_get_bit(bool);\n    hdr->sign_bias[ALTREF_FRAME] = key ? 0 : bool_get_bit(bool);\n    hdr->refresh_entropy = bool_get_bit(bool);\n    hdr->refresh_last  = key ? 1 : bool_get_bit(bool);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\ndecode_quantizer_header(struct vp8_decoder_ctx    *ctx,\n                        struct bool_decoder       *bool,\n                        struct vp8_quant_hdr      *hdr)\n{\n    int update;\n    int last_q = hdr->q_index;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    hdr->q_index = bool_get_uint(bool, 7);\n    update = last_q != hdr->q_index;\n    update |= (hdr->y1_dc_delta_q = bool_maybe_get_int(bool, 4));\n    update |= (hdr->y2_dc_delta_q = bool_maybe_get_int(bool, 4));\n    update |= (hdr->y2_ac_delta_q = bool_maybe_get_int(bool, 4));\n    update |= (hdr->uv_dc_delta_q = bool_maybe_get_int(bool, 4));\n    update |= (hdr->uv_ac_delta_q = bool_maybe_get_int(bool, 4));\n    hdr->delta_update = update;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void decode_and_init_token_partitions(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, const unsigned char *data, unsigned int sz, struct vp8_token_hdr *hdr)",
      "ja": "static void decode_and_init_token_partitions（struct vp8_decoder_ctx *ctx、struct bool_decoder *bool、const unsigned char *data、unsigned int sz、struct vp8_token_hdr *hdr）"
    },
    {
      "indent": 3,
      "text": "{ int i;",
      "ja": "{int i;"
    },
    {
      "indent": 7,
      "text": "hdr->partitions = 1 << bool_get_uint(bool, 2);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (sz < 3 *(hdr->partitions - 1))\n    vpx_internal_error(&ctx->error, VPX_CODEC_CORRUPT_FRAME,\n                       \"Truncated packet found parsing partition\"\n                       \" lengths.\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "sz -= 3 * (hdr->partitions - 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < hdr->partitions; i++)\n{\n    if (i < hdr->partitions - 1)\n    {\n        hdr->partition_sz[i] = (data[2] << 16)\n                               | (data[1] << 8) | data[0];\n        data += 3;\n    }\n    else\n        hdr->partition_sz[i] = sz;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (sz < hdr->partition_sz[i])\n    vpx_internal_error(&ctx->error, VPX_CODEC_CORRUPT_FRAME,\n                       \"Truncated partition %d\", i);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    sz -= hdr->partition_sz[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i < ctx->token_hdr.partitions; i++)\n    {\n        init_bool_decoder(&ctx->tokens[i].bool, data,\n                          ctx->token_hdr.partition_sz[i]);\n        data += ctx->token_hdr.partition_sz[i];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void decode_loopfilter_header(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, struct vp8_loopfilter_hdr *hdr)",
      "ja": "static void decode_loopfilter_header（struct vp8_decoder_ctx *ctx、struct bool_decoder *bool、struct vp8_loopfilter_hdr *hdr）"
    },
    {
      "indent": 3,
      "text": "{\n    if (ctx->frame_hdr.is_keyframe)\n        memset(hdr, 0, sizeof(*hdr));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "hdr->use_simple    = bool_get_bit(bool);\nhdr->level         = bool_get_uint(bool, 6);\nhdr->sharpness     = bool_get_uint(bool, 3);\nhdr->delta_enabled = bool_get_bit(bool);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (hdr->delta_enabled && bool_get_bit(bool)) { int i;",
      "ja": "if（hdr-> delta_enabled && bool_get_bit（bool））{int i;"
    },
    {
      "indent": 11,
      "text": "for (i = 0; i < BLOCK_CONTEXTS; i++)\n    hdr->ref_delta[i] = bool_maybe_get_int(bool, 6);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        for (i = 0; i < BLOCK_CONTEXTS; i++)\n            hdr->mode_delta[i] = bool_maybe_get_int(bool, 6);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\ndecode_segmentation_header(struct vp8_decoder_ctx *ctx,\n                           struct bool_decoder    *bool,\n                           struct vp8_segment_hdr *hdr)\n{\n    if (ctx->frame_hdr.is_keyframe)\n        memset(hdr, 0, sizeof(*hdr));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "hdr->enabled = bool_get_bit(bool);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (hdr->enabled) { int i;",
      "ja": "if（hdr-> enabled）{int i;"
    },
    {
      "indent": 11,
      "text": "hdr->update_map = bool_get_bit(bool);\nhdr->update_data = bool_get_bit(bool);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (hdr->update_data)\n{\n    hdr->abs = bool_get_bit(bool);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "for (i = 0; i < MAX_MB_SEGMENTS; i++)\n    hdr->quant_idx[i] = bool_maybe_get_int(bool, 7);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    for (i = 0; i < MAX_MB_SEGMENTS; i++)\n        hdr->lf_level[i] = bool_maybe_get_int(bool, 6);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if (hdr->update_map)\n        {\n            for (i = 0; i < MB_FEATURE_TREE_PROBS; i++)\n                hdr->tree_probs[i] = bool_get_bit(bool)\n                                     ? bool_get_uint(bool, 8)\n                                     : 255;\n        }\n    }\n    else\n    {\n        hdr->update_map = 0;\n        hdr->update_data = 0;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void dequant_global_init(struct dequant_factors dqf[MAX_MB_SEGMENTS]) { int i;",
      "ja": "static void dequant_global_init（struct dequant_factors dqf [max_mb_segments]）{int i;"
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i < MAX_MB_SEGMENTS; i++)\n        dqf[i].quant_idx = -1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int clamp_q(int q) { if (q < 0) return 0; else if (q > 127) return 127;",
      "ja": "static int clamp_q（int q）{if（q <0）return 0;else if（q> 127）127を返します。"
    },
    {
      "indent": 3,
      "text": " return q; }",
      "ja": "q;を返します。}"
    },
    {
      "indent": 3,
      "text": "static int\ndc_q(int q)\n{\n    return dc_q_lookup[clamp_q(q)];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int\nac_q(int q)\n{\n    return ac_q_lookup[clamp_q(q)];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void dequant_init(struct dequant_factors factors[MAX_MB_SEGMENTS], const struct vp8_segment_hdr *seg, const struct vp8_quant_hdr *quant_hdr) { int i, q; struct dequant_factors *dqf = factors;",
      "ja": "static void dequant_init（struct dequant_factors factors [max_mb_segments]、const struct vp8_segment_hdr *seg、const struct vp8_quant_hdr *quant_hdr）{int i、q;struct dequant_factors *dqf = factors;"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < (seg->enabled ? MAX_MB_SEGMENTS : 1); i++)\n{\n    q = quant_hdr->q_index;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (seg->enabled)\n    q = (!seg->abs) ? q + seg->quant_idx[i]\n                    : seg->quant_idx[i];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (dqf->quant_idx != q || quant_hdr->delta_update)\n{\n    dqf->factor[TOKEN_BLOCK_Y1][0] =\n        dc_q(q + quant_hdr->y1_dc_delta_q);\n    dqf->factor[TOKEN_BLOCK_Y1][1] =\n        ac_q(q);\n    dqf->factor[TOKEN_BLOCK_UV][0] =\n        dc_q(q + quant_hdr->uv_dc_delta_q);\n    dqf->factor[TOKEN_BLOCK_UV][1] =\n        ac_q(q + quant_hdr->uv_ac_delta_q);\n    dqf->factor[TOKEN_BLOCK_Y2][0] =\n        dc_q(q + quant_hdr->y2_dc_delta_q) * 2;\n    dqf->factor[TOKEN_BLOCK_Y2][1] =\n        ac_q(q + quant_hdr->y2_ac_delta_q) * 155 / 100;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (dqf->factor[TOKEN_BLOCK_Y2][1] < 8)\n    dqf->factor[TOKEN_BLOCK_Y2][1] = 8;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (dqf->factor[TOKEN_BLOCK_UV][0] > 132)\n    dqf->factor[TOKEN_BLOCK_UV][0] = 132;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    dqf->quant_idx = q;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        dqf++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\ndecode_frame(struct vp8_decoder_ctx *ctx,\n             const unsigned char    *data,\n             unsigned int            sz)\n{\n    vpx_codec_err_t  res;\n    struct bool_decoder  bool;\n    int                  i, row, partition;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ctx->saved_entropy_valid = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if ((res = vp8_parse_frame_header(data, sz, &ctx->frame_hdr)))\n    vpx_internal_error(&ctx->error, res,\n                       \"Failed to parse frame header\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->frame_hdr.is_experimental) vpx_internal_error(&ctx->error, VPX_CODEC_UNSUP_BITSTREAM, \"Experimental bitstreams not supported.\");",
      "ja": "if（ctx-> frame_hdr.is_experimental）vpx_internal_error（＆ctx-> error、vpx_codec_unsup_bitstream、 \"実験的なbitstreamsがサポートされていない。\"）;"
    },
    {
      "indent": 7,
      "text": "data += FRAME_HEADER_SZ;\nsz -= FRAME_HEADER_SZ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->frame_hdr.is_keyframe)\n{\n    data += KEYFRAME_HEADER_SZ;\n    sz -= KEYFRAME_HEADER_SZ;\n    ctx->mb_cols = (ctx->frame_hdr.kf.w + 15) / 16;\n    ctx->mb_rows = (ctx->frame_hdr.kf.h + 15) / 16;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Start the bitreader for the header/entropy partition */\ninit_bool_decoder(&bool, data, ctx->frame_hdr.part0_sz);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Skip the colorspace and clamping bits */\nif (ctx->frame_hdr.is_keyframe)\n    if (bool_get_uint(&bool, 2))\n        vpx_internal_error(\n            &ctx->error, VPX_CODEC_UNSUP_BITSTREAM,\n            \"Reserved bits not supported.\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "decode_segmentation_header(ctx, &bool, &ctx->segment_hdr);\ndecode_loopfilter_header(ctx, &bool, &ctx->loopfilter_hdr);\ndecode_and_init_token_partitions(ctx,\n                                 &bool,\n                                 data + ctx->frame_hdr.part0_sz,\n                                 sz - ctx->frame_hdr.part0_sz,\n                                 &ctx->token_hdr);\ndecode_quantizer_header(ctx, &bool, &ctx->quant_hdr);\ndecode_reference_header(ctx, &bool, &ctx->reference_hdr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Set keyframe entropy defaults.  These get updated on keyframes\n * regardless of the refresh_entropy setting.\n */\nif (ctx->frame_hdr.is_keyframe)\n{\n    ARRAY_COPY(ctx->entropy_hdr.coeff_probs,\n               k_default_coeff_probs);\n    ARRAY_COPY(ctx->entropy_hdr.mv_probs,\n               k_default_mv_probs);\n    ARRAY_COPY(ctx->entropy_hdr.y_mode_probs,\n               k_default_y_mode_probs);\n    ARRAY_COPY(ctx->entropy_hdr.uv_mode_probs,\n               k_default_uv_mode_probs);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!ctx->reference_hdr.refresh_entropy)\n{\n    ctx->saved_entropy = ctx->entropy_hdr;\n    ctx->saved_entropy_valid = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "decode_entropy_header(ctx, &bool, &ctx->entropy_hdr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "vp8_dixie_modemv_init(ctx);\nvp8_dixie_tokens_init(ctx);\nvp8_dixie_predict_init(ctx);\ndequant_init(ctx->dequant_factors, &ctx->segment_hdr,\n             &ctx->quant_hdr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (row = 0, partition = 0; row < ctx->mb_rows; row++)\n{\n    vp8_dixie_modemv_process_row(\n        ctx, &bool, row, 0, ctx->mb_cols);\n    vp8_dixie_tokens_process_row(ctx, partition, row, 0,\n                                 ctx->mb_cols);\n    vp8_dixie_predict_process_row(ctx, row, 0, ctx->mb_cols);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (ctx->loopfilter_hdr.level && row)\n    vp8_dixie_loopfilter_process_row(ctx, row - 1, 0,\n                                     ctx->mb_cols);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (++partition == ctx->token_hdr.partitions)\n        partition = 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->loopfilter_hdr.level)\n    vp8_dixie_loopfilter_process_row(\n        ctx, row - 1, 0, ctx->mb_cols);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ctx->frame_cnt++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!ctx->reference_hdr.refresh_entropy)\n{\n    ctx->entropy_hdr = ctx->saved_entropy;\n    ctx->saved_entropy_valid = 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Handle reference frame updates */\nif (ctx->reference_hdr.copy_arf == 1)\n{\n    vp8_dixie_release_ref_frame(ctx->ref_frames[ALTREF_FRAME]);\n    ctx->ref_frames[ALTREF_FRAME] =\n        vp8_dixie_ref_frame(ctx->ref_frames[LAST_FRAME]);\n}\nelse if (ctx->reference_hdr.copy_arf == 2)\n{\n    vp8_dixie_release_ref_frame(ctx->ref_frames[ALTREF_FRAME]);\n    ctx->ref_frames[ALTREF_FRAME] =\n        vp8_dixie_ref_frame(ctx->ref_frames[GOLDEN_FRAME]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->reference_hdr.copy_gf == 1)\n{\n    vp8_dixie_release_ref_frame(ctx->ref_frames[GOLDEN_FRAME]);\n    ctx->ref_frames[GOLDEN_FRAME] =\n        vp8_dixie_ref_frame(ctx->ref_frames[LAST_FRAME]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "else if (ctx->reference_hdr.copy_gf == 2)\n{\n    vp8_dixie_release_ref_frame(ctx->ref_frames[GOLDEN_FRAME]);\n    ctx->ref_frames[GOLDEN_FRAME] =\n        vp8_dixie_ref_frame(ctx->ref_frames[ALTREF_FRAME]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->reference_hdr.refresh_gf)\n{\n    vp8_dixie_release_ref_frame(ctx->ref_frames[GOLDEN_FRAME]);\n    ctx->ref_frames[GOLDEN_FRAME] =\n        vp8_dixie_ref_frame(ctx->ref_frames[CURRENT_FRAME]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->reference_hdr.refresh_arf)\n{\n    vp8_dixie_release_ref_frame(ctx->ref_frames[ALTREF_FRAME]);\n    ctx->ref_frames[ALTREF_FRAME] =\n        vp8_dixie_ref_frame(ctx->ref_frames[CURRENT_FRAME]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->reference_hdr.refresh_last)\n{\n    vp8_dixie_release_ref_frame(ctx->ref_frames[LAST_FRAME]);\n    ctx->ref_frames[LAST_FRAME] =\n        vp8_dixie_ref_frame(ctx->ref_frames[CURRENT_FRAME]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_decode_init(struct vp8_decoder_ctx *ctx)\n{\n    dequant_global_init(ctx->dequant_factors);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define CHECK_FOR_UPDATE(lval,rval,update_flag) do {\\\n        unsigned int old = lval; \\\n        update_flag |= (old != (lval = rval)); \\\n    } while (0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "vpx_codec_err_t vp8_parse_frame_header(const unsigned char *data, unsigned int sz, struct vp8_frame_hdr *hdr) { unsigned long raw;",
      "ja": "vpx_codec_err_t vp8_parse_frame_header（const unsigned char *data、unsigned int sz、struct vp8_frame_hdr *hdr）{unsigned long raw;"
    },
    {
      "indent": 7,
      "text": "if (sz < 10) return VPX_CODEC_CORRUPT_FRAME;",
      "ja": "if（sz <10）vpx_codec_corrupt_frameを返します。"
    },
    {
      "indent": 7,
      "text": "/* The frame header is defined as a three-byte little endian\n * value\n */\nraw = data[0] | (data[1] << 8) | (data[2] << 16);\nhdr->is_keyframe     = !BITS_GET(raw, 0, 1);\nhdr->version         = BITS_GET(raw, 1, 2);\nhdr->is_experimental = BITS_GET(raw, 3, 1);\nhdr->is_shown        = BITS_GET(raw, 4, 1);\nhdr->part0_sz        = BITS_GET(raw, 5, 19);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (sz <= hdr->part0_sz + (hdr->is_keyframe ? 10 : 3))\n    return VPX_CODEC_CORRUPT_FRAME;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "hdr->frame_size_updated = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (hdr->is_keyframe) { unsigned int update = 0;",
      "ja": "if（hdr-> is_keyframe）{unsigned int update = 0;"
    },
    {
      "indent": 11,
      "text": "/* Keyframe header consists of a three-byte sync code\n * followed by the width and height and associated scaling\n * factors.\n */\nif (data[3] != 0x9d || data[4] != 0x01 || data[5] != 0x2a)\n    return VPX_CODEC_UNSUP_BITSTREAM;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "raw = data[6] | (data[7] << 8)\n      | (data[8] << 16) | (data[9] << 24);\nCHECK_FOR_UPDATE(hdr->kf.w,       BITS_GET(raw,  0, 14),\n                 update);\nCHECK_FOR_UPDATE(hdr->kf.scale_w, BITS_GET(raw, 14,  2),\n                 update);\nCHECK_FOR_UPDATE(hdr->kf.h,       BITS_GET(raw, 16, 14),\n                 update);\nCHECK_FOR_UPDATE(hdr->kf.scale_h, BITS_GET(raw, 30,  2),\n                 update);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "hdr->frame_size_updated = update;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (!hdr->kf.w || !hdr->kf.h)\n        return VPX_CODEC_UNSUP_BITSTREAM;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return VPX_CODEC_OK; }",
      "ja": "vpx_codec_okを返します。}"
    },
    {
      "indent": 3,
      "text": "vpx_codec_err_t vp8_dixie_decode_frame(struct vp8_decoder_ctx *ctx, const unsigned char *data, unsigned int sz) { volatile struct vp8_decoder_ctx *ctx_ = ctx;",
      "ja": "vpx_codec_err_t vp8_dixie_decode_frame（struct vp8_decoder_ctx *ctx、const unsigned char *data、unsigned int sz）{volatile struct vp8_decoder_ctx *ctx_ = ctx;"
    },
    {
      "indent": 7,
      "text": "ctx->error.error_code = VPX_CODEC_OK;\nctx->error.has_detail = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!setjmp(ctx->error.jmp))\n    decode_frame(ctx, data, sz);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return ctx_->error.error_code; }",
      "ja": "ctx _-> error.error_codeを返します。}"
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_decode_destroy(struct vp8_decoder_ctx *ctx)\n{\n    vp8_dixie_predict_destroy(ctx);\n    vp8_dixie_tokens_destroy(ctx);\n    vp8_dixie_modemv_destroy(ctx);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.5. dixie.h",
      "section_title": true,
      "ja": "20.5. dixie.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef DIXIE_H\n#define DIXIE_H\n#include \"vpx_codec_internal.h\"\n#include \"bool_decoder.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct vp8_frame_hdr\n{\n    unsigned int is_keyframe;      /* Frame is a keyframe */\n    unsigned int is_experimental;  /* Frame is a keyframe */\n    unsigned int version;          /* Bitstream version */\n    unsigned int is_shown;         /* Frame is to be displayed. */\n    unsigned int part0_sz;         /* Partition 0 length, in bytes */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct vp8_kf_hdr\n{\n    unsigned int w;        /* Width */\n    unsigned int h;        /* Height */\n    unsigned int scale_w;  /* Scaling factor, Width */\n    unsigned int scale_h;  /* Scaling factor, Height */\n} kf;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    unsigned int frame_size_updated; /* Flag to indicate a resolution\n                                      * update.\n                                      */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { MB_FEATURE_TREE_PROBS = 3, MAX_MB_SEGMENTS = 4 };",
      "ja": "enum {mb_feature_tree_probs = 3、max_mb_segments = 4};"
    },
    {
      "indent": 3,
      "text": "struct vp8_segment_hdr\n{\n    unsigned int         enabled;\n    unsigned int         update_data;\n    unsigned int         update_map;\n    unsigned int         abs;    /* 0=deltas, 1=absolute values */\n    unsigned int         tree_probs[MB_FEATURE_TREE_PROBS];\n    int                  lf_level[MAX_MB_SEGMENTS];\n    int                  quant_idx[MAX_MB_SEGMENTS];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "};",
      "ja": "};"
    },
    {
      "indent": 3,
      "text": "enum { BLOCK_CONTEXTS = 4 };",
      "ja": "enum {block_contexts = 4};"
    },
    {
      "indent": 3,
      "text": "struct vp8_loopfilter_hdr\n{\n    unsigned int         use_simple;\n    unsigned int         level;\n    unsigned int         sharpness;\n    unsigned int         delta_enabled;\n    int                  ref_delta[BLOCK_CONTEXTS];\n    int                  mode_delta[BLOCK_CONTEXTS];\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { MAX_PARTITIONS = 8 };",
      "ja": "enum {max_partitions = 8};"
    },
    {
      "indent": 3,
      "text": "struct vp8_token_hdr\n{\n    unsigned int        partitions;\n    unsigned int        partition_sz[MAX_PARTITIONS];\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct vp8_quant_hdr\n{\n    unsigned int       q_index;\n    int                delta_update;\n    int                y1_dc_delta_q;\n    int                y2_dc_delta_q;\n    int                y2_ac_delta_q;\n    int                uv_dc_delta_q;\n    int                uv_ac_delta_q;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct vp8_reference_hdr\n{\n    unsigned int refresh_last;\n    unsigned int refresh_gf;\n    unsigned int refresh_arf;\n    unsigned int copy_gf;\n    unsigned int copy_arf;\n    unsigned int sign_bias[4];\n    unsigned int refresh_entropy;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { BLOCK_TYPES = 4, PREV_COEFF_CONTEXTS = 3, COEFF_BANDS = 8, ENTROPY_NODES = 11, }; typedef unsigned char coeff_probs_table_t[BLOCK_TYPES][COEFF_BANDS] [PREV_COEFF_CONTEXTS] [ENTROPY_NODES];",
      "ja": "enum {block_types = 4、prev_coeff_contexts = 3、coeff_bands = 8、entropy_nodes = 11、};typedef unsigned char coeff_probs_table_t [block_types] [coeff_bands] [prev_coeff_contexts] [entropy_nodes];"
    },
    {
      "indent": 3,
      "text": "enum\n{\n    MV_PROB_CNT = 2 + 8 - 1 + 10 /* from entropymv.h */\n};\ntypedef unsigned char mv_component_probs_t[MV_PROB_CNT];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct vp8_entropy_hdr\n{\n    coeff_probs_table_t   coeff_probs;\n    mv_component_probs_t  mv_probs[2];\n    unsigned int          coeff_skip_enabled;\n    unsigned char         coeff_skip_prob;\n    unsigned char         y_mode_probs[4];\n    unsigned char         uv_mode_probs[3];\n    unsigned char         prob_inter;\n    unsigned char         prob_last;\n    unsigned char         prob_gf;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum reference_frame { CURRENT_FRAME, LAST_FRAME, GOLDEN_FRAME, ALTREF_FRAME, NUM_REF_FRAMES };",
      "ja": "enum reference_frame {current_frame、last_frame、golden_frame、altref_frame、num_ref_frames};"
    },
    {
      "indent": 3,
      "text": "enum prediction_mode\n{\n    /* 16x16 intra modes */\n    DC_PRED, V_PRED, H_PRED, TM_PRED, B_PRED,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* 16x16 inter modes */\nNEARESTMV, NEARMV, ZEROMV, NEWMV, SPLITMV,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "MB_MODE_COUNT,",
      "ja": "mb_mode_count、"
    },
    {
      "indent": 7,
      "text": "/* 4x4 intra modes */\nB_DC_PRED = 0, B_TM_PRED, B_VE_PRED, B_HE_PRED, B_LD_PRED,\nB_RD_PRED, B_VR_PRED, B_VL_PRED, B_HD_PRED, B_HU_PRED,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* 4x4 inter modes */\nLEFT4X4, ABOVE4X4, ZERO4X4, NEW4X4,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " B_MODE_COUNT };",
      "ja": "b_mode_count};"
    },
    {
      "indent": 3,
      "text": "enum splitmv_partitioning { SPLITMV_16X8, SPLITMV_8X16, SPLITMV_8X8, SPLITMV_4X4 };",
      "ja": "enum splitmv_partitioning {splitmv_16x8、splitmv_8x16、splitmv_8x8、splitmv_4x4};"
    },
    {
      "indent": 3,
      "text": "typedef short filter_t[6];",
      "ja": "typedef short filter_t [6];"
    },
    {
      "indent": 3,
      "text": "typedef union mv\n{\n    struct\n    {\n        int16_t x, y;\n    }  d;\n    uint32_t               raw;\n} mv_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct mb_base_info\n{\n    unsigned char y_mode     : 4;\n    unsigned char uv_mode    : 4;\n    unsigned char segment_id : 2;\n    unsigned char ref_frame  : 2;\n    unsigned char skip_coeff : 1;\n    unsigned char need_mc_border : 1;\n    enum splitmv_partitioning  partitioning : 2;\n    union mv      mv;\n    unsigned int  eob_mask;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct mb_info\n{\n    struct mb_base_info base;\n    union\n    {\n        union mv              mvs[16];\n        enum prediction_mode  modes[16];\n    } split;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* A \"token entropy context\" has 4 Y values, 2 U, 2 V, and 1 Y2 */\ntypedef int token_entropy_ctx_t[4 + 2 + 2 + 1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct token_decoder\n{\n    struct bool_decoder  bool;\n    token_entropy_ctx_t  left_token_entropy_ctx;\n    short               *coeffs;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum token_block_type { TOKEN_BLOCK_Y1, TOKEN_BLOCK_UV, TOKEN_BLOCK_Y2, TOKEN_BLOCK_TYPES, };",
      "ja": "enum token_block_type {token_block_y1、token_block_uv、token_block_y2、token_block_types、};"
    },
    {
      "indent": 3,
      "text": "struct dequant_factors\n{\n    int   quant_idx;\n    short factor[TOKEN_BLOCK_TYPES][2]; /* [ Y1, UV, Y2 ]\n                                         * [ DC, AC ] */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct ref_cnt_img\n{\n    vpx_image_t  img;\n    unsigned int ref_cnt;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct vp8_decoder_ctx { struct vpx_internal_error_info error; unsigned int frame_cnt;",
      "ja": "struct vp8_decoder_ctx {struct vpx_internal_error_infoエラー;unsigned int frame_cnt;"
    },
    {
      "indent": 7,
      "text": "struct vp8_frame_hdr            frame_hdr;\nstruct vp8_segment_hdr          segment_hdr;\nstruct vp8_loopfilter_hdr       loopfilter_hdr;\nstruct vp8_token_hdr            token_hdr;\nstruct vp8_quant_hdr            quant_hdr;\nstruct vp8_reference_hdr        reference_hdr;\nstruct vp8_entropy_hdr          entropy_hdr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct vp8_entropy_hdr          saved_entropy;\nunsigned int                    saved_entropy_valid;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "unsigned int                    mb_rows;\nunsigned int                    mb_cols;\nstruct mb_info                 *mb_info_storage;\nstruct mb_info                **mb_info_rows_storage;\nstruct mb_info                **mb_info_rows;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "token_entropy_ctx_t            *above_token_entropy_ctx;\nstruct token_decoder            tokens[MAX_PARTITIONS];\nstruct dequant_factors          dequant_factors[MAX_MB_SEGMENTS];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct ref_cnt_img              frame_strg[NUM_REF_FRAMES];\nstruct ref_cnt_img             *ref_frames[NUM_REF_FRAMES];\nptrdiff_t                       ref_frame_offsets[4];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    const filter_t                 *subpixel_filters;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_decode_init(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_decode_init（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_decode_destroy(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_decode_destroy（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "vpx_codec_err_t vp8_parse_frame_header(const unsigned char *data, unsigned int sz, struct vp8_frame_hdr *hdr);",
      "ja": "VPX_CODEC_ERR_T VP8_PARSE_FRAME_HEADER（const unsigned char *data、unsigned int sz、struct vp8_frame_hdr *hdr）;"
    },
    {
      "indent": 3,
      "text": "vpx_codec_err_t vp8_dixie_decode_frame(struct vp8_decoder_ctx *ctx, const unsigned char *data, unsigned int sz);",
      "ja": "vpx_codec_err_t vp8_dixie_decode_frame（struct vp8_decoder_ctx *ctx、const unsigned char *data、unsigned int sz）;"
    },
    {
      "indent": 3,
      "text": "#define CLAMP_255(x) ((x)<0?0:((x)>255?255:(x)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.6. dixie_loopfilter.c",
      "section_title": true,
      "ja": "20.6. dixie_loopfilter.c"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#include \"dixie.h\"\n#include \"dixie_loopfilter.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define ABS(x) ((x) >= 0 ? (x) : -(x))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define p3 pixels[-4*stride]\n#define p2 pixels[-3*stride]\n#define p1 pixels[-2*stride]\n#define p0 pixels[-1*stride]\n#define q0 pixels[ 0*stride]\n#define q1 pixels[ 1*stride]\n#define q2 pixels[ 2*stride]\n#define q3 pixels[ 3*stride]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define static static int",
      "ja": "#define static static int"
    },
    {
      "indent": 3,
      "text": "saturate_int8(int x)\n{\n    if (x < -128)\n        return -128;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (x > 127) return 127;",
      "ja": "if（x> 127）127を返します。"
    },
    {
      "indent": 3,
      "text": " return x; }",
      "ja": "xを返します。}"
    },
    {
      "indent": 3,
      "text": "static int saturate_uint8(int x) { if (x < 0) return 0;",
      "ja": "static int atatrate_uint8（int x）{if（x <0）return 0;"
    },
    {
      "indent": 7,
      "text": "if (x > 255) return 255;",
      "ja": "if（x> 255）255を返します。"
    },
    {
      "indent": 3,
      "text": " return x; }",
      "ja": "xを返します。}"
    },
    {
      "indent": 3,
      "text": "static int\nhigh_edge_variance(unsigned char *pixels,\n                   int            stride,\n                   int            hev_threshold)\n{\n    return ABS(p1 - p0) > hev_threshold ||\n           ABS(q1 - q0) > hev_threshold;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int\nsimple_threshold(unsigned char *pixels,\n                 int            stride,\n                 int            filter_limit)\n{\n    return (ABS(p0 - q0) * 2 + (ABS(p1 - q1) >> 1)) <= filter_limit;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int\nnormal_threshold(unsigned char *pixels,\n                 int            stride,\n                 int            edge_limit,\n                 int            interior_limit)\n{\n    int E = edge_limit;\n    int I = interior_limit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return simple_threshold(pixels, stride, 2 * E + I)\n           && ABS(p3 - p2) <= I && ABS(p2 - p1) <= I\n           && ABS(p1 - p0) <= I && ABS(q3 - q2) <= I\n           && ABS(q2 - q1) <= I && ABS(q1 - q0) <= I;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_common(unsigned char *pixels,\n              int            stride,\n              int            use_outer_taps)\n{\n    int a, f1, f2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "a = 3 * (q0 - p0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (use_outer_taps)\n    a += saturate_int8(p1 - q1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "a = saturate_int8(a);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "f1 = ((a + 4 > 127) ? 127 : a + 4) >> 3;\nf2 = ((a + 3 > 127) ? 127 : a + 3) >> 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "p0 = saturate_uint8(p0 + f2);\nq0 = saturate_uint8(q0 - f1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (!use_outer_taps)\n    {\n        /* This handles the case of subblock_filter()\n         * (from the bitstream guide.\n         */\n        a = (f1 + 1) >> 1;\n        p1 = saturate_uint8(p1 + a);\n        q1 = saturate_uint8(q1 - a);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void filter_mb_edge(unsigned char *pixels, int stride) { int w, a;",
      "ja": "static void filter_mb_edge（unsigned char *pixels、int stride）{int w、a;"
    },
    {
      "indent": 7,
      "text": "w = saturate_int8(saturate_int8(p1 - q1) + 3 * (q0 - p0));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "a = (27 * w + 63) >> 7;\np0 = saturate_uint8(p0 + a);\nq0 = saturate_uint8(q0 - a);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "a = (18 * w + 63) >> 7;\np1 = saturate_uint8(p1 + a);\nq1 = saturate_uint8(q1 - a);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    a = (9 * w + 63) >> 7;\n    p2 = saturate_uint8(p2 + a);\n    q2 = saturate_uint8(q2 - a);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_mb_v_edge(unsigned char *src,\n                 int            stride,\n                 int            edge_limit,\n                 int            interior_limit,\n                 int            hev_threshold,\n                 int            size)\n{\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 8 * size; i++)\n{\n    if (normal_threshold(src, 1, edge_limit, interior_limit))\n    {\n        if (high_edge_variance(src, 1, hev_threshold))\n            filter_common(src, 1, 1);\n        else\n            filter_mb_edge(src, 1);\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        src += stride;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_subblock_v_edge(unsigned char *src,\n                       int            stride,\n                       int            edge_limit,\n                       int            interior_limit,\n                       int            hev_threshold,\n                       int            size)\n{\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 8 * size; i++)\n{\n    if (normal_threshold(src, 1, edge_limit, interior_limit))\n        filter_common(src, 1,\n                      high_edge_variance(src, 1, hev_threshold));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        src += stride;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_mb_h_edge(unsigned char *src,\n                 int            stride,\n                 int            edge_limit,\n                 int            interior_limit,\n                 int            hev_threshold,\n                 int            size)\n{\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 8 * size; i++)\n{\n    if (normal_threshold(src, stride, edge_limit,\n                         interior_limit))\n    {\n        if (high_edge_variance(src, stride, hev_threshold))\n            filter_common(src, stride, 1);\n        else\n            filter_mb_edge(src, stride);\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        src += 1;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_subblock_h_edge(unsigned char *src,\n                       int            stride,\n                       int            edge_limit,\n                       int            interior_limit,\n                       int            hev_threshold,\n                       int            size)\n{\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 8 * size; i++)\n{\n    if (normal_threshold(src, stride, edge_limit,\n                         interior_limit))\n        filter_common(src, stride,\n                      high_edge_variance(src, stride,\n                                         hev_threshold));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        src += 1;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_v_edge_simple(unsigned char *src,\n                     int            stride,\n                     int            filter_limit)\n{\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 16; i++)\n{\n    if (simple_threshold(src, 1, filter_limit))\n        filter_common(src, 1, 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        src += stride;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_h_edge_simple(unsigned char *src,\n                     int            stride,\n                     int            filter_limit)\n{\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 16; i++)\n{\n    if (simple_threshold(src, stride, filter_limit))\n        filter_common(src, stride, 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        src += 1;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void calculate_filter_parameters(struct vp8_decoder_ctx *ctx, struct mb_info *mbi, int *edge_limit_, int *interior_limit_, int *hev_threshold_) { int filter_level, interior_limit, hev_threshold;",
      "ja": "static void calculate_filter_parameters（struct vp8_decoder_ctx *ctx、struct mb_info *mbi、int *edge_limit_、int *interior_limit_、int *hev_threshold_）{int filter_level、interior_limit、hev_threshold;"
    },
    {
      "indent": 7,
      "text": "/* Reference code/spec seems to conflate filter_level and\n * edge_limit\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "filter_level = ctx->loopfilter_hdr.level;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->segment_hdr.enabled)\n{\n    if (!ctx->segment_hdr.abs)\n        filter_level +=\n            ctx->segment_hdr.lf_level[mbi->base.segment_id];\n    else\n        filter_level =\n            ctx->segment_hdr.lf_level[mbi->base.segment_id];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (filter_level > 63)\n    filter_level = 63;\nelse if (filter_level < 0)\n    filter_level = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->loopfilter_hdr.delta_enabled)\n{\n    filter_level +=\n        ctx->loopfilter_hdr.ref_delta[mbi->base.ref_frame];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (mbi->base.ref_frame == CURRENT_FRAME)\n    {\n        if (mbi->base.y_mode == B_PRED)\n            filter_level += ctx->loopfilter_hdr.mode_delta[0];\n    }\n    else if (mbi->base.y_mode == ZEROMV)\n        filter_level += ctx->loopfilter_hdr.mode_delta[1];\n    else if (mbi->base.y_mode == SPLITMV)\n        filter_level += ctx->loopfilter_hdr.mode_delta[3];\n    else\n        filter_level += ctx->loopfilter_hdr.mode_delta[2];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (filter_level > 63)\n    filter_level = 63;\nelse if (filter_level < 0)\n    filter_level = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "interior_limit = filter_level;",
      "ja": "Interior_limit = filter_level;"
    },
    {
      "indent": 7,
      "text": "if (ctx->loopfilter_hdr.sharpness)\n{\n    interior_limit >>= ctx->loopfilter_hdr.sharpness > 4 ? 2 : 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (interior_limit > 9 - ctx->loopfilter_hdr.sharpness)\n        interior_limit = 9 - ctx->loopfilter_hdr.sharpness;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (interior_limit < 1) interior_limit = 1;",
      "ja": "if（interior_limit <1）interior_limit = 1;"
    },
    {
      "indent": 7,
      "text": "hev_threshold = (filter_level >= 15);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (filter_level >= 40)\n    hev_threshold++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (filter_level >= 20 && !ctx->frame_hdr.is_keyframe)\n    hev_threshold++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    *edge_limit_ = filter_level;\n    *interior_limit_ = interior_limit;\n    *hev_threshold_ = hev_threshold;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_row_normal(struct vp8_decoder_ctx *ctx,\n                  unsigned int            row,\n                  unsigned int            start_col,\n                  unsigned int            num_cols)\n{\n    unsigned char  *y, *u, *v;\n    int             stride, uv_stride;\n    struct mb_info *mbi;\n    unsigned int    col;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Adjust pointers based on row, start_col */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "stride    = ctx->ref_frames[CURRENT_FRAME]->img.stride[PLANE_Y];\nuv_stride = ctx->ref_frames[CURRENT_FRAME]->img.stride[PLANE_U];\ny = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_Y];\nu = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_U];\nv = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_V];\ny += (stride * row + start_col) * 16;\nu += (uv_stride * row + start_col) * 8;\nv += (uv_stride * row + start_col) * 8;\nmbi = ctx->mb_info_rows[row] + start_col;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (col = start_col; col < start_col + num_cols; col++)\n{\n    int edge_limit, interior_limit, hev_threshold;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* TODO: Only need to recalculate every MB if segmentation is\n * enabled.\n */\ncalculate_filter_parameters(ctx, mbi, &edge_limit,\n                            &interior_limit, &hev_threshold);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (edge_limit)\n{\n    if (col)\n    {\n        filter_mb_v_edge(y, stride, edge_limit + 2,\n                         interior_limit, hev_threshold, 2);\n        filter_mb_v_edge(u, uv_stride, edge_limit + 2,\n                         interior_limit, hev_threshold, 1);\n        filter_mb_v_edge(v, uv_stride, edge_limit + 2,\n                         interior_limit, hev_threshold, 1);\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* NOTE: This conditional is actually dependent on the\n * number of coefficients decoded, not the skip flag as\n * coded in the bitstream.  The tokens task is expected\n * to set 31 if there is *any* non-zero data.\n */\nif (mbi->base.eob_mask\n    || mbi->base.y_mode == SPLITMV\n    || mbi->base.y_mode == B_PRED)\n{\n    filter_subblock_v_edge(y + 4, stride, edge_limit,\n                           interior_limit, hev_threshold,\n                           2);\n    filter_subblock_v_edge(y + 8, stride, edge_limit,\n                           interior_limit, hev_threshold,\n                           2);\n    filter_subblock_v_edge(y + 12, stride, edge_limit,\n                           interior_limit, hev_threshold,\n                           2);\n    filter_subblock_v_edge(u + 4, uv_stride, edge_limit,\n                           interior_limit, hev_threshold,\n                           1);\n    filter_subblock_v_edge(v + 4, uv_stride, edge_limit,\n                           interior_limit, hev_threshold,\n                           1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (row)\n{\n    filter_mb_h_edge(y, stride, edge_limit + 2,\n                     interior_limit, hev_threshold, 2);\n    filter_mb_h_edge(u, uv_stride, edge_limit + 2,\n                     interior_limit, hev_threshold, 1);\n    filter_mb_h_edge(v, uv_stride, edge_limit + 2,\n                     interior_limit, hev_threshold, 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (mbi->base.eob_mask\n        || mbi->base.y_mode == SPLITMV\n        || mbi->base.y_mode == B_PRED)\n    {\n        filter_subblock_h_edge(y + 4 * stride, stride,\n                               edge_limit, interior_limit,\n                               hev_threshold, 2);\n        filter_subblock_h_edge(y + 8 * stride, stride,\n                               edge_limit, interior_limit,\n                               hev_threshold, 2);\n        filter_subblock_h_edge(y + 12 * stride, stride,\n                               edge_limit, interior_limit,\n                               hev_threshold, 2);\n        filter_subblock_h_edge(u + 4 * uv_stride, uv_stride,\n                               edge_limit, interior_limit,\n                               hev_threshold, 1);\n        filter_subblock_h_edge(v + 4 * uv_stride, uv_stride,\n                               edge_limit, interior_limit,\n                               hev_threshold, 1);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        y += 16;\n        u += 8;\n        v += 8;\n        mbi++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfilter_row_simple(struct vp8_decoder_ctx *ctx,\n                  unsigned int            row,\n                  unsigned int            start_col,\n                  unsigned int            num_cols)\n{\n    unsigned char  *y;\n    int             stride;\n    struct mb_info *mbi;\n    unsigned int    col;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Adjust pointers based on row, start_col */\nstride    = ctx->ref_frames[CURRENT_FRAME]->img.stride[PLANE_Y];\ny = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_Y];\ny += (stride * row + start_col) * 16;\nmbi = ctx->mb_info_rows[row] + start_col;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (col = start_col; col < start_col + num_cols; col++)\n{\n    int edge_limit, interior_limit, hev_threshold;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* TODO: Only need to recalculate every MB if segmentation is\n * enabled.\n */\ncalculate_filter_parameters(ctx, mbi, &edge_limit,\n                            &interior_limit, &hev_threshold);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (edge_limit) {",
      "ja": "if（edge_limit）{"
    },
    {
      "indent": 15,
      "text": "/* NOTE: This conditional is actually dependent on the\n * number of coefficients decoded, not the skip flag as\n * coded in the bitstream.  The tokens task is expected\n * to set 31 if there is *any* non-zero data.\n */\nint filter_subblocks = (mbi->base.eob_mask\n                        || mbi->base.y_mode == SPLITMV\n                        || mbi->base.y_mode == B_PRED);\nint mb_limit = (edge_limit + 2) * 2 + interior_limit;\nint b_limit = edge_limit * 2 + interior_limit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (col) filter_v_edge_simple(y, stride, mb_limit);",
      "ja": "if（col）filter_v_edge_simple（y、stride、mb_limit）;"
    },
    {
      "indent": 15,
      "text": "if (filter_subblocks)\n{\n    filter_v_edge_simple(y + 4, stride, b_limit);\n    filter_v_edge_simple(y + 8, stride, b_limit);\n    filter_v_edge_simple(y + 12, stride, b_limit);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (row) filter_h_edge_simple(y, stride, mb_limit);",
      "ja": "if（row）filter_h_edge_simple（y、stride、mb_limit）;"
    },
    {
      "indent": 11,
      "text": "    if (filter_subblocks)\n    {\n        filter_h_edge_simple(y + 4 * stride, stride,\n                             b_limit);\n        filter_h_edge_simple(y + 8 * stride, stride,\n                             b_limit);\n        filter_h_edge_simple(y + 12 * stride, stride,\n                             b_limit);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        y += 16;\n        mbi++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_loopfilter_process_row(struct vp8_decoder_ctx *ctx,\n                                 unsigned int            row,\n                                 unsigned int            start_col,\n                                 unsigned int            num_cols)\n{\n    if (ctx->loopfilter_hdr.use_simple)\n        filter_row_simple(ctx, row, start_col, num_cols);\n    else\n        filter_row_normal(ctx, row, start_col, num_cols);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.7. dixie_loopfilter.h",
      "section_title": true,
      "ja": "20.7. dixie_loopfilter.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef DIXIE_LOOPFILTER_H\n#define DIXIE_LOOPFILTER_H",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_loopfilter_process_row(struct vp8_decoder_ctx *ctx,\n                                 unsigned int            row,\n                                 unsigned int            start_col,\n                                 unsigned int            num_cols);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.8. idct_add.c",
      "section_title": true,
      "ja": "20.8. idct_add.c"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#include \"dixie.h\"\n#include \"idct_add.h\"\n#include <assert.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_walsh(const short *input, short *output)\n{\n    int i;\n    int a1, b1, c1, d1;\n    int a2, b2, c2, d2;\n    const short *ip = input;\n    short *op = output;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 4; i++)\n{\n    a1 = ip[0] + ip[12];\n    b1 = ip[4] + ip[8];\n    c1 = ip[4] - ip[8];\n    d1 = ip[0] - ip[12];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    op[0] = a1 + b1;\n    op[4] = c1 + d1;\n    op[8] = a1 - b1;\n    op[12] = d1 - c1;\n    ip++;\n    op++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ip = output;\nop = output;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 4; i++)\n{\n    a1 = ip[0] + ip[3];\n    b1 = ip[1] + ip[2];\n    c1 = ip[1] - ip[2];\n    d1 = ip[0] - ip[3];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "a2 = a1 + b1;\nb2 = c1 + d1;\nc2 = a1 - b1;\nd2 = d1 - c1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "op[0] = (a2 + 3) >> 3;\nop[1] = (b2 + 3) >> 3;\nop[2] = (c2 + 3) >> 3;\nop[3] = (d2 + 3) >> 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        ip += 4;\n        op += 4;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define cospi8sqrt2minus1 20091 #define sinpi8sqrt2 35468 #define rounding 0 static void idct_columns(const short *input, short *output) { int i; int a1, b1, c1, d1;",
      "ja": "#define cospi8sqrt2minus1 20091 #define sinpi8sqrt2 35468 #defineラウンド0 static void idct_columns（const short *input、short *output）{int i; int i;INT A1、B1、C1、D1;"
    },
    {
      "indent": 7,
      "text": "const short *ip = input;\nshort *op = output;\nint temp1, temp2;\nint shortpitch = 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 4; i++)\n{\n    a1 = ip[0] + ip[8];\n    b1 = ip[0] - ip[8];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "temp1 = (ip[4] * sinpi8sqrt2 + rounding) >> 16;\ntemp2 = ip[12] +\n    ((ip[12] * cospi8sqrt2minus1 + rounding) >> 16);\nc1 = temp1 - temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "temp1 = ip[4] +\n    ((ip[4] * cospi8sqrt2minus1 + rounding) >> 16);\ntemp2 = (ip[12] * sinpi8sqrt2 + rounding) >> 16;\nd1 = temp1 + temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "op[shortpitch*0] = a1 + d1;\nop[shortpitch*3] = a1 - d1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "op[shortpitch*1] = b1 + c1;\nop[shortpitch*2] = b1 - c1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        ip++;\n        op++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_idct_add(unsigned char        *recon,\n                   const unsigned char  *predict,\n                   int                   stride,\n                   const short          *coeffs)\n{\n    int i;\n    int a1, b1, c1, d1, temp1, temp2;\n    short tmp[16];\n    idct_columns(coeffs, tmp);\n    coeffs = tmp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 4; i++)\n{\n    a1 = coeffs[0] + coeffs[2];\n    b1 = coeffs[0] - coeffs[2];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "temp1 = (coeffs[1] * sinpi8sqrt2 + rounding) >> 16;\ntemp2 = coeffs[3] +\n    ((coeffs[3] * cospi8sqrt2minus1 + rounding) >> 16);\nc1 = temp1 - temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "temp1 = coeffs[1] +\n    ((coeffs[1] * cospi8sqrt2minus1 + rounding) >> 16);\ntemp2 = (coeffs[3] * sinpi8sqrt2 + rounding) >> 16;\nd1 = temp1 + temp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "recon[0] = CLAMP_255(predict[0] + ((a1 + d1 + 4) >> 3));\nrecon[3] = CLAMP_255(predict[3] + ((a1 - d1 + 4) >> 3));\nrecon[1] = CLAMP_255(predict[1] + ((b1 + c1 + 4) >> 3));\nrecon[2] = CLAMP_255(predict[2] + ((b1 - c1 + 4) >> 3));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        coeffs += 4;\n        recon += stride;\n        predict += stride;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.9. idct_add.h",
      "section_title": true,
      "ja": "20.9. idct_add.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef IDCT_ADD_H\n#define IDCT_ADD_H",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_idct_add_init(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_idct_add_init（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_idct_add(unsigned char *recon, const unsigned char *predict, int stride, const short *coeffs);",
      "ja": "void vp8_dixie_idct_add（unsigned char *recon、const unsigned char *predict、int stride、const short *coffs）;"
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_walsh(const short *in, short *out);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_idct_add_process_row(struct vp8_decoder_ctx *ctx,\n                               short                  *coeffs,\n                               unsigned int            row,\n                               unsigned int            start_col,\n                               unsigned int            num_cols);\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.10. mem.h",
      "section_title": true,
      "ja": "20.10. mem.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef VPX_PORTS_MEM_H\n#define VPX_PORTS_MEM_H\n#include \"vpx_config.h\"\n#include \"vpx_integer.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#if defined(__GNUC__) && __GNUC__\n#define DECLARE_ALIGNED(n,typ,val)  typ val __attribute__ \\\n    ((aligned (n)))\n#elif defined(_MSC_VER)\n#define DECLARE_ALIGNED(n,typ,val)  __declspec(align(n)) typ val\n#else\n#warning No alignment directives known for this compiler.\n#define DECLARE_ALIGNED(n,typ,val)  typ val\n#endif\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Declare an aligned array on the stack, for situations where the\n * stack pointer may not have the alignment we expect.  Creates an\n * array with a modified name, then defines val to be a pointer, and\n * aligns that pointer within the array.\n */\n#define DECLARE_ALIGNED_ARRAY(a,typ,val,n)\\\ntyp val##_[(n)+(a)/sizeof(typ)+1];\\\ntyp *val = (typ*)((((intptr_t)val##_)+(a)-1)&((intptr_t)-(a)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Indicates that the usage of the specified variable has been\n * audited to assure that it's safe to use uninitialized.  Silences\n * 'may be used uninitialized' warnings on gcc.\n */\n#if defined(__GNUC__) && __GNUC__\n#define UNINITIALIZED_IS_SAFE(x) x=x\n#else\n#define UNINITIALIZED_IS_SAFE(x) x\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.11. modemv.c",
      "section_title": true,
      "ja": "20.11. modemv.c"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#include \"dixie.h\"\n#include \"modemv_data.h\"\n#include <stdlib.h>\n#include <assert.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct mv_clamp_rect { int to_left, to_right, to_top, to_bottom; };",
      "ja": "struct mv_clamp_rect {int to_left、to_right、to_top、to_bottom;};"
    },
    {
      "indent": 3,
      "text": "static union mv clamp_mv(union mv raw, const struct mv_clamp_rect *bounds) { union mv newmv;",
      "ja": "Static Union MV CLAMP_MV（Union MV RAW、const struct MV_CLAMP_RECT *BOUNDS）{UNION MV NEWMV;"
    },
    {
      "indent": 3,
      "text": "    newmv.d.x = (raw.d.x < bounds->to_left)\n                ? bounds->to_left : raw.d.x;\n    newmv.d.x = (raw.d.x > bounds->to_right)\n                ? bounds->to_right : newmv.d.x;\n    newmv.d.y = (raw.d.y < bounds->to_top)\n                ? bounds->to_top : raw.d.y;\n    newmv.d.y = (raw.d.y > bounds->to_bottom)\n                ? bounds->to_bottom : newmv.d.y;\n    return newmv;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int\nread_segment_id(struct bool_decoder *bool,\n                struct vp8_segment_hdr *seg)\n{\n    return bool_get(bool, seg->tree_probs[0])\n           ? 2 + bool_get(bool, seg->tree_probs[2])\n           : bool_get(bool, seg->tree_probs[1]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static enum prediction_mode\nabove_block_mode(const struct mb_info *this,\n                 const struct mb_info *above,\n                 unsigned int b)\n{\n    if (b < 4)\n    {\n        switch (above->base.y_mode)\n        {\n        case DC_PRED:\n            return B_DC_PRED;\n        case V_PRED:\n            return B_VE_PRED;\n        case H_PRED:\n            return B_HE_PRED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    case TM_PRED:\n        return B_TM_PRED;\n    case B_PRED:\n        return above->split.modes[b+12];\n    default:\n        assert(0);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return this->split.modes[b-4]; }",
      "ja": "これを返します - > split.modes [b-4];}"
    },
    {
      "indent": 3,
      "text": "static enum prediction_mode\nleft_block_mode(const struct mb_info *this,\n                const struct mb_info *left,\n                unsigned int b)\n{\n    if (!(b & 3))\n    {\n        switch (left->base.y_mode)\n        {\n        case DC_PRED:\n            return B_DC_PRED;\n        case V_PRED:\n            return B_VE_PRED;\n        case H_PRED:\n            return B_HE_PRED;\n        case TM_PRED:\n            return B_TM_PRED;\n        case B_PRED:\n            return left->split.modes[b+3];\n        default:\n            assert(0);\n        }\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return this->split.modes[b-1]; }",
      "ja": "これを返します - > split.modes [b-1];}"
    },
    {
      "indent": 3,
      "text": "static void decode_kf_mb_mode(struct mb_info *this, struct mb_info *left, struct mb_info *above, struct bool_decoder *bool) { int y_mode, uv_mode;",
      "ja": "static void decode_kf_mb_mode（struct mb_info *this、struct mb_info *left、struct mb_info *上記、struct bool_decoder *bool）{int y_mode、uv_mode;"
    },
    {
      "indent": 7,
      "text": "y_mode = bool_read_tree(bool, kf_y_mode_tree, kf_y_mode_probs);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (y_mode == B_PRED) { unsigned int i;",
      "ja": "if（y_mode == b_pred）{unsigned int i;"
    },
    {
      "indent": 11,
      "text": "for (i = 0; i < 16; i++)\n{\n    enum prediction_mode a = above_block_mode(this, above,\n                                              i);\n    enum prediction_mode l = left_block_mode(this, left, i);\n    enum prediction_mode b;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        b = bool_read_tree(bool, b_mode_tree,\n                           kf_b_mode_probs[a][l]);\n        this->split.modes[i] = b;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "uv_mode = bool_read_tree(bool, uv_mode_tree, kf_uv_mode_probs);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    this->base.y_mode = y_mode;\n    this->base.uv_mode = uv_mode;\n    this->base.mv.raw = 0;\n    this->base.ref_frame = 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\ndecode_intra_mb_mode(struct mb_info         *this,\n                     struct vp8_entropy_hdr *hdr,\n                     struct bool_decoder    *bool)\n{\n    /* Like decode_kf_mb_mode, but with probabilities transmitted in\n     * the bitstream and no context on the above/left block mode.\n     */\n    int y_mode, uv_mode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "y_mode = bool_read_tree(bool, y_mode_tree, hdr->y_mode_probs);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (y_mode == B_PRED) { unsigned int i;",
      "ja": "if（y_mode == b_pred）{unsigned int i;"
    },
    {
      "indent": 11,
      "text": "for (i = 0; i < 16; i++)\n{\n    enum prediction_mode b;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        b = bool_read_tree(bool, b_mode_tree,\n                           default_b_mode_probs);\n        this->split.modes[i] = b;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "uv_mode = bool_read_tree(bool, uv_mode_tree, hdr->uv_mode_probs);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    this->base.y_mode = y_mode;\n    this->base.uv_mode = uv_mode;\n    this->base.mv.raw = 0;\n    this->base.ref_frame = CURRENT_FRAME;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int\nread_mv_component(struct bool_decoder *bool,\n                  const unsigned char  mvc[MV_PROB_CNT])\n{\n    enum {IS_SHORT, SIGN, SHORT, BITS = SHORT + 8 - 1,\n          LONG_WIDTH = 10};\n    int x = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (bool_get(bool, mvc[IS_SHORT])) /* Large */\n{\n    int i = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (i = 0; i < 3; i++)\n    x += bool_get(bool, mvc[BITS + i]) << i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Skip bit 3, which is sometimes implicit */\nfor (i = LONG_WIDTH - 1; i > 3; i--)\n    x += bool_get(bool, mvc[BITS + i]) << i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (!(x & 0xFFF0)  ||  bool_get(bool, mvc[BITS + 3]))\n        x += 8;\n}\nelse   /* small */\n    x = bool_read_tree(bool, small_mv_tree, mvc + SHORT);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (x && bool_get(bool, mvc[SIGN]))\n    x = -x;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return x << 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static mv_t\nabove_block_mv(const struct mb_info *this,\n               const struct mb_info *above,\n               unsigned int          b)\n{\n    if (b < 4)\n    {\n        if (above->base.y_mode == SPLITMV)\n            return above->split.mvs[b+12];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " return above->base.mv; }",
      "ja": "上記のbase.mvを返します。}"
    },
    {
      "indent": 3,
      "text": " return this->split.mvs[b-4]; }",
      "ja": "これを返します - > split.mvs [b-4];}"
    },
    {
      "indent": 3,
      "text": "static mv_t\nleft_block_mv(const struct mb_info *this,\n              const struct mb_info *left,\n              unsigned int          b)\n{\n    if (!(b & 3))\n    {\n        if (left->base.y_mode == SPLITMV)\n            return left->split.mvs[b+3];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " return left->base.mv; }",
      "ja": "左> base.mvを返します。}"
    },
    {
      "indent": 3,
      "text": " return this->split.mvs[b-1]; }",
      "ja": "これを返します - > split.mvs [b-1];}"
    },
    {
      "indent": 3,
      "text": "static enum prediction_mode\nsubmv_ref(struct bool_decoder *bool, union mv l, union mv a)\n{\n    enum subblock_mv_ref\n    {\n        SUBMVREF_NORMAL,\n        SUBMVREF_LEFT_ZED,\n        SUBMVREF_ABOVE_ZED,\n        SUBMVREF_LEFT_ABOVE_SAME,\n        SUBMVREF_LEFT_ABOVE_ZED\n    };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "int lez = !(l.raw);\nint aez = !(a.raw);\nint lea = l.raw == a.raw;\nenum subblock_mv_ref ctx = SUBMVREF_NORMAL;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (lea && lez)\n    ctx = SUBMVREF_LEFT_ABOVE_ZED;\nelse if (lea)\n    ctx = SUBMVREF_LEFT_ABOVE_SAME;\nelse if (aez)\n    ctx = SUBMVREF_ABOVE_ZED;\nelse if (lez)\n    ctx = SUBMVREF_LEFT_ZED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return bool_read_tree(bool, submv_ref_tree, submv_ref_probs2[ctx]); }",
      "ja": "return bool_read_tree（bool、submv_ref_tree、submv_ref_probs2 [ctx]）;}"
    },
    {
      "indent": 3,
      "text": "static void\nread_mv(struct bool_decoder  *bool,\n        union mv             *mv,\n        mv_component_probs_t  mvc[2])\n{\n    mv->d.y = read_mv_component(bool, mvc[0]);\n    mv->d.x = read_mv_component(bool, mvc[1]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nmv_bias(const struct mb_info *mb,\n        const unsigned int   sign_bias[3],\n        enum reference_frame ref_frame,\n        union mv             *mv)\n{\n    if (sign_bias[mb->base.ref_frame] ^ sign_bias[ref_frame])\n    {\n        mv->d.x *= -1;\n        mv->d.y *= -1;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum near_mv_v { CNT_BEST = 0, CNT_ZEROZERO = 0, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };",
      "ja": "enum near_mv_v {cnt_best = 0、cnt_zerozero = 0、cnt_nearest、cnt_near、cnt_splitmv};"
    },
    {
      "indent": 3,
      "text": "static void\nfind_near_mvs(const struct mb_info   *this,\n              const struct mb_info   *left,\n              const struct mb_info   *above,\n              const unsigned int      sign_bias[3],\n              union  mv               near_mvs[4],\n              int                     cnt[4])\n{\n    const struct mb_info *aboveleft = above - 1;\n    union  mv             *mv = near_mvs;\n    int                   *cntx = cnt;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Zero accumulators */\nmv[0].raw = mv[1].raw = mv[2].raw = 0;\ncnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Process above */\nif (above->base.ref_frame != CURRENT_FRAME)\n{\n    if (above->base.mv.raw)\n    {\n        (++mv)->raw = above->base.mv.raw;\n        mv_bias(above, sign_bias, this->base.ref_frame, mv);\n        ++cntx;\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    *cntx += 2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Process left */\nif (left->base.ref_frame != CURRENT_FRAME)\n{\n    if (left->base.mv.raw)\n    {\n        union mv this_mv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "this_mv.raw = left->base.mv.raw;\nmv_bias(left, sign_bias, this->base.ref_frame, &this_mv);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (this_mv.raw != mv->raw)\n{\n    (++mv)->raw = this_mv.raw;\n    ++cntx;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        *cntx += 2;\n    }\n    else\n        cnt[CNT_ZEROZERO] += 2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Process above left */\nif (aboveleft->base.ref_frame != CURRENT_FRAME)\n{\n    if (aboveleft->base.mv.raw)\n    {\n        union mv this_mv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "this_mv.raw = aboveleft->base.mv.raw;\nmv_bias(aboveleft, sign_bias, this->base.ref_frame,\n        &this_mv);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (this_mv.raw != mv->raw)\n{\n    (++mv)->raw = this_mv.raw;\n    ++cntx;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        *cntx += 1;\n    }\n    else\n        cnt[CNT_ZEROZERO] += 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* If we have three distinct MVs ... */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (cnt[CNT_SPLITMV])\n{\n    /* See if above-left MV can be merged with NEAREST */\n    if (mv->raw == near_mvs[CNT_NEAREST].raw)\n        cnt[CNT_NEAREST] += 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "cnt[CNT_SPLITMV] = ((above->base.y_mode == SPLITMV)\n                    + (left->base.y_mode == SPLITMV)) * 2\n                   + (aboveleft->base.y_mode == SPLITMV);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Swap near and nearest if necessary */\nif (cnt[CNT_NEAR] > cnt[CNT_NEAREST])\n{\n    int tmp;\n    tmp = cnt[CNT_NEAREST];\n    cnt[CNT_NEAREST] = cnt[CNT_NEAR];\n    cnt[CNT_NEAR] = tmp;\n    tmp = near_mvs[CNT_NEAREST].raw;\n    near_mvs[CNT_NEAREST].raw = near_mvs[CNT_NEAR].raw;\n    near_mvs[CNT_NEAR].raw = tmp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /* Use near_mvs[CNT_BEST] to store the \"best\" MV.  Note that this\n     * storage shares the same address as near_mvs[CNT_ZEROZERO].\n     */\n    if (cnt[CNT_NEAREST] >= cnt[CNT_BEST])\n        near_mvs[CNT_BEST] = near_mvs[CNT_NEAREST];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void decode_split_mv(struct mb_info *this, const struct mb_info *left, const struct mb_info *above, struct vp8_entropy_hdr *hdr, union mv *best_mv, struct bool_decoder *bool) { const int *partition; int j, k, mask, partition_id;",
      "ja": "static void decode_split_mv（struct mb_info *this、const struct mb_info *left、const struct mb_info *上記、struct vp8_entropy_hdr *hdr、union mv *best_mv、struct bool_decoder *bool）{const int *partition;Int J、K、Mask、partition_id;"
    },
    {
      "indent": 7,
      "text": "partition_id = bool_read_tree(bool, split_mv_tree,\n                              split_mv_probs);\npartition = mv_partitions[partition_id];\nthis->base.partitioning = partition_id;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (j = 0, mask = 0; mask < 65535; j++)\n{\n    union mv mv, left_mv, above_mv;\n    enum prediction_mode subblock_mode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Find the first subblock in this partition. */\nfor (k = 0; j != partition[k]; k++);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Decode the next MV */\nleft_mv = left_block_mv(this, left, k);\nabove_mv = above_block_mv(this, above, k);\nsubblock_mode = submv_ref(bool, left_mv,  above_mv);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "switch (subblock_mode)\n{\ncase LEFT4X4:\n    mv = left_mv;\n    break;\ncase ABOVE4X4:\n    mv = above_mv;\n    break;\ncase ZERO4X4:\n    mv.raw = 0;\n    break;\ncase NEW4X4:\n    read_mv(bool, &mv, hdr->mv_probs);\n    mv.d.x += best_mv->d.x;\n    mv.d.y += best_mv->d.y;\n    break;\ndefault:\n    assert(0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        /* Fill the MVs for this partition */\n        for (; k < 16; k++)\n            if (j == partition[k])\n            {\n                this->split.mvs[k] = mv;\n                mask |= 1 << k;\n            }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int need_mc_border(union mv mv, int l, int t, int b_w, int w, int h) { int b, r;",
      "ja": "static int need_mc_border（Union MV MV、int l、int t、int b_w、int w、int h）{int b、r;"
    },
    {
      "indent": 7,
      "text": "/* Get distance to edge for top-left pixel */\nl += (mv.d.x >> 3);\nt += (mv.d.y >> 3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Get distance to edge for bottom-right pixel */\nr = w - (l + b_w);\nb = h - (t + b_w);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return (l >> 1 < 2 || r >> 1 < 3 || t >> 1 < 2 || b >> 1 < 3);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\ndecode_mvs(struct vp8_decoder_ctx       *ctx,\n           struct mb_info               *this,\n           const struct mb_info         *left,\n           const struct mb_info         *above,\n           const struct mv_clamp_rect   *bounds,\n           struct bool_decoder          *bool)\n{\n    struct vp8_entropy_hdr *hdr = &ctx->entropy_hdr;\n    union mv          near_mvs[4];\n    union mv          clamped_best_mv;\n    int               mv_cnts[4];\n    unsigned char     probs[4];\n    enum {BEST, NEAREST, NEAR};\n    int x, y, w, h, b;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "this->base.ref_frame = bool_get(bool, hdr->prob_last)\n                       ? 2 + bool_get(bool, hdr->prob_gf)\n                       : 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "find_near_mvs(this, this - 1, above,\n              ctx->reference_hdr.sign_bias, near_mvs, mv_cnts);\nprobs[0] = mv_counts_to_probs[mv_cnts[0]][0];\nprobs[1] = mv_counts_to_probs[mv_cnts[1]][1];\nprobs[2] = mv_counts_to_probs[mv_cnts[2]][2];\nprobs[3] = mv_counts_to_probs[mv_cnts[3]][3];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "this->base.y_mode = bool_read_tree(bool, mv_ref_tree, probs);\nthis->base.uv_mode = this->base.y_mode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "this->base.need_mc_border = 0;\nx = (-bounds->to_left - 128) >> 3;\ny = (-bounds->to_top - 128) >> 3;\nw = ctx->mb_cols * 16;\nh = ctx->mb_rows * 16;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "switch (this->base.y_mode)\n{\ncase NEARESTMV:\n    this->base.mv = clamp_mv(near_mvs[NEAREST], bounds);\n    break;\ncase NEARMV:\n    this->base.mv = clamp_mv(near_mvs[NEAR], bounds);\n    break;\ncase ZEROMV:\n    this->base.mv.raw = 0;\n    return; //skip need_mc_border check\ncase NEWMV:\n    clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);\n    read_mv(bool, &this->base.mv, hdr->mv_probs);\n    this->base.mv.d.x += clamped_best_mv.d.x;\n    this->base.mv.d.y += clamped_best_mv.d.y;\n    break;\ncase SPLITMV:\n{\n    union mv          chroma_mv[4] = {{{0}}};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);\ndecode_split_mv(this, left, above, hdr, &clamped_best_mv,\n                bool);\nthis->base.mv = this->split.mvs[15];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (b = 0; b < 16; b++)\n{\n    chroma_mv[(b>>1&1) + (b>>2&2)].d.x +=\n        this->split.mvs[b].d.x;\n    chroma_mv[(b>>1&1) + (b>>2&2)].d.y +=\n        this->split.mvs[b].d.y;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (need_mc_border(this->split.mvs[b],\n    x + (b & 3) * 4, y + (b & ~3), 4, w, h))\n    {\n        this->base.need_mc_border = 1;\n        break;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (b = 0; b < 4; b++)\n{\n    chroma_mv[b].d.x += 4 + 8 * (chroma_mv[b].d.x >> 31);\n    chroma_mv[b].d.y += 4 + 8 * (chroma_mv[b].d.y >> 31);\n    chroma_mv[b].d.x /= 4;\n    chroma_mv[b].d.y /= 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "//note we're passing in non-subsampled coordinates",
      "ja": "//ノンサブサンプル座標を通過することに注意してください"
    },
    {
      "indent": 11,
      "text": "    if (need_mc_border(chroma_mv[b],\n    x + (b & 1) * 8, y + (b >> 1) * 8, 16, w, h))\n    {\n        this->base.need_mc_border = 1;\n        break;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    return; //skip need_mc_border check\n}\ndefault:\n    assert(0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (need_mc_border(this->base.mv, x, y, 16, w, h))\n        this->base.need_mc_border = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_modemv_process_row(struct vp8_decoder_ctx *ctx,\nstruct bool_decoder    *bool,\nint                     row,\nint                     start_col,\nint                     num_cols)\n{\n    struct mb_info       *above, *this;\n    unsigned int          col;\n    struct mv_clamp_rect  bounds;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "this = ctx->mb_info_rows[row] + start_col;\nabove = ctx->mb_info_rows[row - 1] + start_col;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Calculate the eighth-pel MV bounds using a 1 MB border. */\nbounds.to_left   = -((start_col + 1) << 7);\nbounds.to_right  = (ctx->mb_cols - start_col) << 7;\nbounds.to_top    = -((row + 1) << 7);\nbounds.to_bottom = (ctx->mb_rows - row) << 7;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (col = start_col; col < start_col + num_cols; col++)\n{\n    if (ctx->segment_hdr.update_map)\n        this->base.segment_id = read_segment_id(bool,\n        &ctx->segment_hdr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (ctx->entropy_hdr.coeff_skip_enabled)\n    this->base.skip_coeff = bool_get(bool,\n    ctx->entropy_hdr.coeff_skip_prob);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (ctx->frame_hdr.is_keyframe)\n{\n    if (!ctx->segment_hdr.update_map)\n        this->base.segment_id = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    decode_kf_mb_mode(this, this - 1, above, bool);\n}\nelse\n{\n    if (bool_get(bool, ctx->entropy_hdr.prob_inter))\n        decode_mvs(ctx, this, this - 1, above, &bounds,\n                   bool);\n    else\n        decode_intra_mb_mode(this, &ctx->entropy_hdr, bool);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    bounds.to_left -= 16 << 3;\n    bounds.to_right -= 16 << 3;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        /* Advance to next mb */\n        this++;\n        above++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_modemv_init(struct vp8_decoder_ctx *ctx) { unsigned int mbi_w, mbi_h, i; struct mb_info *mbi;",
      "ja": "void vp8_dixie_modemv_init（struct vp8_decoder_ctx *ctx）{unsigned int mbi_w、mbi_h、i;struct mb_info *mbi;"
    },
    {
      "indent": 7,
      "text": "mbi_w = ctx->mb_cols + 1; /* For left border col */\nmbi_h = ctx->mb_rows + 1; /* For above border row */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->frame_hdr.frame_size_updated)\n{\n    free(ctx->mb_info_storage);\n    ctx->mb_info_storage = NULL;\n    free(ctx->mb_info_rows_storage);\n    ctx->mb_info_rows_storage = NULL;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!ctx->mb_info_storage)\n    ctx->mb_info_storage = calloc(mbi_w * mbi_h,\n    sizeof(*ctx->mb_info_storage));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!ctx->mb_info_rows_storage)",
      "ja": "if（！ctx-> mb_info_rows_storage）"
    },
    {
      "indent": 11,
      "text": "ctx->mb_info_rows_storage = calloc(mbi_h,\nsizeof(*ctx->mb_info_rows_storage));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Set up row pointers */\nmbi = ctx->mb_info_storage + 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < mbi_h; i++)\n{\n    ctx->mb_info_rows_storage[i] = mbi;\n    mbi += mbi_w;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    ctx->mb_info_rows = ctx->mb_info_rows_storage + 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_modemv_destroy(struct vp8_decoder_ctx *ctx)\n{\n    free(ctx->mb_info_storage);\n    ctx->mb_info_storage = NULL;\n    free(ctx->mb_info_rows_storage);\n    ctx->mb_info_rows_storage = NULL;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.12. modemv.h",
      "section_title": true,
      "ja": "20.12. modemv.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef MODEMV_H\n#define MODEMV_H",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_modemv_init(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_modemv_init（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_modemv_destroy(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_modemv_destroy（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_modemv_process_row(struct vp8_decoder_ctx *ctx,\n                             struct bool_decoder    *bool,\n                             int                     row,\n                             int                     start_col,\n                             int                     num_cols);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.13. modemv_data.h",
      "section_title": true,
      "ja": "20.13. modemv_data.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const unsigned char kf_y_mode_probs[] = { 145, 156, 163, 128};\nstatic const unsigned char kf_uv_mode_probs[] = { 142, 114, 183};\nstatic const unsigned char kf_b_mode_probs[10][10][9] =\n{\n  { /* above mode 0 */\n    { /* left mode 0 */ 231, 120,  48,  89, 115, 113, 120, 152, 112},\n    { /* left mode 1 */ 152, 179,  64, 126, 170, 118,  46,  70,  95},\n    { /* left mode 2 */ 175,  69, 143,  80,  85,  82,  72, 155, 103},\n    { /* left mode 3 */  56,  58,  10, 171, 218, 189,  17,  13, 152},\n    { /* left mode 4 */ 144,  71,  10,  38, 171, 213, 144,  34,  26},\n    { /* left mode 5 */ 114,  26,  17, 163,  44, 195,  21,  10, 173},\n    { /* left mode 6 */ 121,  24,  80, 195,  26,  62,  44,  64,  85},\n    { /* left mode 7 */ 170,  46,  55,  19, 136, 160,  33, 206,  71},\n    { /* left mode 8 */  63,  20,   8, 114, 114, 208,  12,   9, 226},\n    { /* left mode 9 */  81,  40,  11,  96, 182,  84,  29,  16,  36}\n  },\n  { /* above mode 1 */\n    { /* left mode 0 */ 134, 183,  89, 137,  98, 101, 106, 165, 148},\n    { /* left mode 1 */  72, 187, 100, 130, 157, 111,  32,  75,  80},\n    { /* left mode 2 */  66, 102, 167,  99,  74,  62,  40, 234, 128},\n    { /* left mode 3 */  41,  53,   9, 178, 241, 141,  26,   8, 107},\n    { /* left mode 4 */ 104,  79,  12,  27, 217, 255,  87,  17,   7},\n    { /* left mode 5 */  74,  43,  26, 146,  73, 166,  49,  23, 157},\n    { /* left mode 6 */  65,  38, 105, 160,  51,  52,  31, 115, 128},\n    { /* left mode 7 */  87,  68,  71,  44, 114,  51,  15, 186,  23},\n    { /* left mode 8 */  47,  41,  14, 110, 182, 183,  21,  17, 194},\n    { /* left mode 9 */  66,  45,  25, 102, 197, 189,  23,  18,  22}\n  },\n  { /* above mode 2 */\n    { /* left mode 0 */  88,  88, 147, 150,  42,  46,  45, 196, 205},\n    { /* left mode 1 */  43,  97, 183, 117,  85,  38,  35, 179,  61},\n    { /* left mode 2 */  39,  53, 200,  87,  26,  21,  43, 232, 171},\n    { /* left mode 3 */  56,  34,  51, 104, 114, 102,  29,  93,  77},\n    { /* left mode 4 */ 107,  54,  32,  26,  51,   1,  81,  43,  31},",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  { /* left mode 5 */  39,  28,  85, 171,  58, 165,  90,  98,  64},\n  { /* left mode 6 */  34,  22, 116, 206,  23,  34,  43, 166,  73},\n  { /* left mode 7 */  68,  25, 106,  22,  64, 171,  36, 225, 114},\n  { /* left mode 8 */  34,  19,  21, 102, 132, 188,  16,  76, 124},\n  { /* left mode 9 */  62,  18,  78,  95,  85,  57,  50,  48,  51}\n},\n{ /* above mode 3 */\n  { /* left mode 0 */ 193, 101,  35, 159, 215, 111,  89,  46, 111},\n  { /* left mode 1 */  60, 148,  31, 172, 219, 228,  21,  18, 111},\n  { /* left mode 2 */ 112, 113,  77,  85, 179, 255,  38, 120, 114},\n  { /* left mode 3 */  40,  42,   1, 196, 245, 209,  10,  25, 109},\n  { /* left mode 4 */ 100,  80,   8,  43, 154,   1,  51,  26,  71},\n  { /* left mode 5 */  88,  43,  29, 140, 166, 213,  37,  43, 154},\n  { /* left mode 6 */  61,  63,  30, 155,  67,  45,  68,   1, 209},\n  { /* left mode 7 */ 142,  78,  78,  16, 255, 128,  34, 197, 171},\n  { /* left mode 8 */  41,  40,   5, 102, 211, 183,   4,   1, 221},\n  { /* left mode 9 */  51,  50,  17, 168, 209, 192,  23,  25,  82}\n},\n{ /* above mode 4 */\n  { /* left mode 0 */ 125,  98,  42,  88, 104,  85, 117, 175,  82},\n  { /* left mode 1 */  95,  84,  53,  89, 128, 100, 113, 101,  45},\n  { /* left mode 2 */  75,  79, 123,  47,  51, 128,  81, 171,   1},\n  { /* left mode 3 */  57,  17,   5,  71, 102,  57,  53,  41,  49},\n  { /* left mode 4 */ 115,  21,   2,  10, 102, 255, 166,  23,   6},\n  { /* left mode 5 */  38,  33,  13, 121,  57,  73,  26,   1,  85},\n  { /* left mode 6 */  41,  10,  67, 138,  77, 110,  90,  47, 114},\n  { /* left mode 7 */ 101,  29,  16,  10,  85, 128, 101, 196,  26},\n  { /* left mode 8 */  57,  18,  10, 102, 102, 213,  34,  20,  43},\n  { /* left mode 9 */ 117,  20,  15,  36, 163, 128,  68,   1,  26}\n},\n{ /* above mode 5 */\n  { /* left mode 0 */ 138,  31,  36, 171,  27, 166,  38,  44, 229},\n  { /* left mode 1 */  67,  87,  58, 169,  82, 115,  26,  59, 179},\n  { /* left mode 2 */  63,  59,  90, 180,  59, 166,  93,  73, 154},\n  { /* left mode 3 */  40,  40,  21, 116, 143, 209,  34,  39, 175},\n  { /* left mode 4 */  57,  46,  22,  24, 128,   1,  54,  17,  37},\n  { /* left mode 5 */  47,  15,  16, 183,  34, 223,  49,  45, 183},\n  { /* left mode 6 */  46,  17,  33, 183,   6,  98,  15,  32, 183},\n  { /* left mode 7 */  65,  32,  73, 115,  28, 128,  23, 128, 205},\n  { /* left mode 8 */  40,   3,   9, 115,  51, 192,  18,   6, 223},\n  { /* left mode 9 */  87,  37,   9, 115,  59,  77,  64,  21,  47}\n},\n{ /* above mode 6 */\n  { /* left mode 0 */ 104,  55,  44, 218,   9,  54,  53, 130, 226},\n  { /* left mode 1 */  64,  90,  70, 205,  40,  41,  23,  26,  57},\n  { /* left mode 2 */  54,  57, 112, 184,   5,  41,  38, 166, 213},\n  { /* left mode 3 */  30,  34,  26, 133, 152, 116,  10,  32, 134},\n  { /* left mode 4 */  75,  32,  12,  51, 192, 255, 160,  43,  51},",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    { /* left mode 5 */  39,  19,  53, 221,  26, 114,  32,  73, 255},\n    { /* left mode 6 */  31,   9,  65, 234,   2,  15,   1, 118,  73},\n    { /* left mode 7 */  88,  31,  35,  67, 102,  85,  55, 186,  85},\n    { /* left mode 8 */  56,  21,  23, 111,  59, 205,  45,  37, 192},\n    { /* left mode 9 */  55,  38,  70, 124,  73, 102,   1,  34,  98}\n  },\n  { /* above mode 7 */\n    { /* left mode 0 */ 102,  61,  71,  37,  34,  53,  31, 243, 192},\n    { /* left mode 1 */  69,  60,  71,  38,  73, 119,  28, 222,  37},\n    { /* left mode 2 */  68,  45, 128,  34,   1,  47,  11, 245, 171},\n    { /* left mode 3 */  62,  17,  19,  70, 146,  85,  55,  62,  70},\n    { /* left mode 4 */  75,  15,   9,   9,  64, 255, 184, 119,  16},\n    { /* left mode 5 */  37,  43,  37, 154, 100, 163,  85, 160,   1},\n    { /* left mode 6 */  63,   9,  92, 136,  28,  64,  32, 201,  85},\n    { /* left mode 7 */  86,   6,  28,   5,  64, 255,  25, 248,   1},\n    { /* left mode 8 */  56,   8,  17, 132, 137, 255,  55, 116, 128},\n    { /* left mode 9 */  58,  15,  20,  82, 135,  57,  26, 121,  40}\n  },\n  { /* above mode 8 */\n    { /* left mode 0 */ 164,  50,  31, 137, 154, 133,  25,  35, 218},\n    { /* left mode 1 */  51, 103,  44, 131, 131, 123,  31,   6, 158},\n    { /* left mode 2 */  86,  40,  64, 135, 148, 224,  45, 183, 128},\n    { /* left mode 3 */  22,  26,  17, 131, 240, 154,  14,   1, 209},\n    { /* left mode 4 */  83,  12,  13,  54, 192, 255,  68,  47,  28},\n    { /* left mode 5 */  45,  16,  21,  91,  64, 222,   7,   1, 197},\n    { /* left mode 6 */  56,  21,  39, 155,  60, 138,  23, 102, 213},\n    { /* left mode 7 */  85,  26,  85,  85, 128, 128,  32, 146, 171},\n    { /* left mode 8 */  18,  11,   7,  63, 144, 171,   4,   4, 246},\n    { /* left mode 9 */  35,  27,  10, 146, 174, 171,  12,  26, 128}\n  },\n  { /* above mode 9 */\n    { /* left mode 0 */ 190,  80,  35,  99, 180,  80, 126,  54,  45},\n    { /* left mode 1 */  85, 126,  47,  87, 176,  51,  41,  20,  32},\n    { /* left mode 2 */ 101,  75, 128, 139, 118, 146, 116, 128,  85},\n    { /* left mode 3 */  56,  41,  15, 176, 236,  85,  37,   9,  62},\n    { /* left mode 4 */ 146,  36,  19,  30, 171, 255,  97,  27,  20},\n    { /* left mode 5 */  71,  30,  17, 119, 118, 255,  17,  18, 138},\n    { /* left mode 6 */ 101,  38,  60, 138,  55,  70,  43,  26, 142},\n    { /* left mode 7 */ 138,  45,  61,  62, 219,   1,  81, 188,  64},\n    { /* left mode 8 */  32,  41,  20, 117, 151, 142,  20,  21, 163},\n    { /* left mode 9 */ 112,  19,  12,  61, 195, 128,  48,   4,  24}\n  }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const int kf_y_mode_tree[] =\n{\n  -B_PRED, 2,\n  4, 6,\n  -DC_PRED, -V_PRED,\n  -H_PRED, -TM_PRED\n};\nstatic const int y_mode_tree[] =\n{\n  -DC_PRED, 2,\n  4, 6,\n  -V_PRED, -H_PRED,\n  -TM_PRED, -B_PRED\n};\nstatic const int uv_mode_tree[6] =\n{\n  -DC_PRED, 2,\n  -V_PRED, 4,\n  -H_PRED, -TM_PRED\n};\nstatic const int b_mode_tree[18] =\n{\n  -B_DC_PRED, 2,               /* 0 = DC_NODE */\n  -B_TM_PRED, 4,               /* 1 = TM_NODE */\n  -B_VE_PRED, 6,               /* 2 = VE_NODE */\n  8, 12,                       /* 3 = COM_NODE */\n  -B_HE_PRED, 10,              /* 4 = HE_NODE */\n  -B_RD_PRED, -B_VR_PRED,      /* 5 = RD_NODE */\n  -B_LD_PRED, 14,              /* 6 = LD_NODE */\n  -B_VL_PRED, 16,              /* 7 = VL_NODE */\n  -B_HD_PRED, -B_HU_PRED       /* 8 = HD_NODE */\n};\nstatic const int small_mv_tree[14] =\n{\n  2, 8,\n  4, 6,\n  -0, -1,\n  -2, -3,\n  10, 12,\n  -4, -5,\n  -6, -7\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const int mv_ref_tree[8] =\n{\n  -ZEROMV, 2,\n  -NEARESTMV, 4,\n  -NEARMV, 6,\n  -NEWMV, -SPLITMV\n};\nstatic const int submv_ref_tree[6] =\n{\n  -LEFT4X4, 2,\n  -ABOVE4X4, 4,\n  -ZERO4X4, -NEW4X4\n};\nstatic const int split_mv_tree[6] =\n{\n  -3, 2,\n  -2, 4,\n  -0, -1\n};\nstatic const unsigned char default_b_mode_probs[] =\n{ 120,  90,  79, 133,  87,  85,  80, 111, 151};\nstatic const unsigned char mv_counts_to_probs[6][4] =\n{\n  {   7,   1,   1, 143 },\n  {  14,  18,  14, 107 },\n  { 135,  64,  57,  68 },\n  {  60,  56, 128,  65 },\n  { 159, 134, 128,  34 },\n  { 234, 188, 128,  28 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "};\nstatic const unsigned char split_mv_probs[3] =\n{ 110, 111, 150};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const unsigned char submv_ref_probs2[5][3] =\n{\n  { 147, 136, 18 },\n  { 106, 145,  1 },\n  { 179, 121,  1 },\n  { 223,   1, 34 },\n  { 208,   1,  1 }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const static int mv_partitions[4][16] =\n{\n  {0, 0, 0, 0, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1 },\n  {0, 0, 1, 1, 0, 0, 1, 1, 0, 0,  1,  1,  0,  0,  1,  1 },\n  {0, 0, 1, 1, 0, 0, 1, 1, 2, 2,  3,  3,  2,  2,  3,  3 },\n  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.14. predict.c",
      "section_title": true,
      "ja": "20.14. Predict.c"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#include \"dixie.h\"\n#include \"predict.h\"\n#include \"idct_add.h\"\n#include \"mem.h\"\n#include <assert.h>\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { BORDER_PIXELS = 16, };",
      "ja": "enum {border_pixels = 16、};"
    },
    {
      "indent": 3,
      "text": "static const filter_t sixtap_filters[8] =\n{\n    { 0,   0, 128,    0,   0,  0 },\n    { 0,  -6, 123,   12,  -1,  0 },\n    { 2, -11, 108,   36,  -8,  1 },\n    { 0,  -9,  93,   50,  -6,  0 },\n    { 3, -16,  77,   77, -16,  3 },\n    { 0,  -6,  50,   93,  -9,  0 },\n    { 1,  -8,  36,  108, -11,  2 },\n    { 0,  -1,  12,  123,  -6,  0 }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const filter_t bilinear_filters[8] =\n{\n    { 0,  0,  128,    0,   0,  0 },\n    { 0,  0,  112,   16,   0,  0 },\n    { 0,  0,   96,   32,   0,  0 },\n    { 0,  0,   80,   48,   0,  0 },\n    { 0,  0,   64,   64,   0,  0 },\n    { 0,  0,   48,   80,   0,  0 },\n    { 0,  0,   32,   96,   0,  0 },\n    { 0,  0,   16,  112,   0,  0 }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_h_nxn(unsigned char *predict,\n              int            stride,\n              int            n)\n{\n    unsigned char *left = predict - 1;\n    int            i, j;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i < n; i++)\n        for (j = 0; j < n; j++)\n            predict[i *stride + j] = left[i * stride];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_v_nxn(unsigned char *predict,\n              int            stride,\n              int            n)\n{\n    unsigned char *above = predict - stride;\n    int            i, j;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i < n; i++)\n        for (j = 0; j < n; j++)\n            predict[i *stride + j] = above[j];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_tm_nxn(unsigned char *predict,\n               int            stride,\n               int            n)\n{\n    /* Transposes the left column to the top row for later\n     * consumption by the idct/recon stage\n     */\n    unsigned char *left = predict - 1;\n    unsigned char *above = predict - stride;\n    unsigned char  p = above[-1];\n    int            i, j;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (j = 0; j < n; j++)\n{\n    for (i = 0; i < n; i++)\n        predict[i] = CLAMP_255(*left + above[i] - p);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        predict += stride;\n        left += stride;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_dc_nxn(unsigned char *predict,\n               int            stride,\n               int            n)\n{\n    unsigned char *left = predict - 1;\n    unsigned char *above = predict - stride;\n    int            i, j, dc = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < n; i++)\n{\n    dc += *left + above[i];\n    left += stride;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "switch (n)\n{\ncase 16:\n    dc = (dc + 16) >> 5;\n    break;\ncase  8:\n    dc = (dc + 8) >> 4;\n    break;\ncase  4:\n    dc = (dc + 4) >> 3;\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i < n; i++)\n        for (j = 0; j < n; j++)\n            predict[i *stride + j] = dc;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_ve_4x4(unsigned char *predict,\n               int            stride)\n{\n    unsigned char *above = predict - stride;\n    int            i, j;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = (above[-1] + 2 * above[0] + above[1] + 2) >> 2;\npredict[1] = (above[ 0] + 2 * above[1] + above[2] + 2) >> 2;\npredict[2] = (above[ 1] + 2 * above[2] + above[3] + 2) >> 2;\npredict[3] = (above[ 2] + 2 * above[3] + above[4] + 2) >> 2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i = 1; i < 4; i++)\n        for (j = 0; j < 4; j++)\n            predict[i *stride + j] = predict[j];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_he_4x4(unsigned char *predict,\n               int            stride)\n{\n    unsigned char *left = predict - 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] =\npredict[1] =\npredict[2] =\npredict[3] = (left[-stride] + 2 * left[0] +\n              left[stride] + 2) >> 2;\npredict += stride;\nleft += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] =\npredict[1] =\npredict[2] =\npredict[3] = (left[-stride] + 2 * left[0] +\n              left[stride] + 2) >> 2;\npredict += stride;\nleft += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] =\npredict[1] =\npredict[2] =\npredict[3] = (left[-stride] + 2 * left[0] +\n              left[stride] + 2) >> 2;\npredict += stride;\nleft += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict[0] =\n    predict[1] =\n    predict[2] =\n    predict[3] = (left[-stride] + 2 * left[0] + left[0] + 2) >> 2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_ld_4x4(unsigned char *predict,\n               int            stride)\n{\n    unsigned char *above = predict - stride;\n    int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred0 = (above[0] + 2 * above[1] +\n                      above[2] + 2) >> 2;\npredict[1] = pred1 = (above[1] + 2 * above[2] +\n                      above[3] + 2) >> 2;\npredict[2] = pred2 = (above[2] + 2 * above[3] +\n                      above[4] + 2) >> 2;\npredict[3] = pred3 = (above[3] + 2 * above[4] +\n                      above[5] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred1;\npredict[1] = pred2;\npredict[2] = pred3;\npredict[3] = pred4 = (above[4] + 2 * above[5] +\n                      above[6] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred2;\npredict[1] = pred3;\npredict[2] = pred4;\npredict[3] = pred5 = (above[5] + 2 * above[6] +\n                      above[7] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict[0] = pred3;\n    predict[1] = pred4;\n    predict[2] = pred5;\n    predict[3] = pred6 = (above[6] + 2 * above[7] +\n                          above[7] + 2) >> 2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_rd_4x4(unsigned char *predict,\n               int            stride)\n{\n    unsigned char *left = predict - 1;\n    unsigned char *above = predict - stride;\n    int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred0 =\n    (left[ 0] + 2 * above[-1] + above[0] + 2) >> 2;\npredict[1] = pred1 =\n    (above[-1] + 2 * above[ 0] + above[1] + 2) >> 2;\npredict[2] = pred2 =\n    (above[ 0] + 2 * above[ 1] + above[2] + 2) >> 2;\npredict[3] = pred3 =\n    (above[ 1] + 2 * above[ 2] + above[3] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred4 =\n    (left[stride] + 2 * left[0] + above[-1] + 2) >> 2;\npredict[1] = pred0;\npredict[2] = pred1;\npredict[3] = pred2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred5 =\n    (left[stride*2] + 2 * left[stride] + left[0] + 2) >> 2;\npredict[1] = pred4;\npredict[2] = pred0;\npredict[3] = pred1;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict[0] = pred6 = (left[stride*3] + 2 * left[stride*2] +\n                          left[stride] + 2) >> 2;\n    predict[1] = pred5;\n    predict[2] = pred4;\n    predict[3] = pred0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_vr_4x4(unsigned char *predict,\n               int            stride)\n{\n    unsigned char *left = predict - 1;\n    unsigned char *above = predict - stride;\n    int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,\n                   pred7, pred8, pred9;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred0 = (above[-1] + above[0] + 1) >> 1;\npredict[1] = pred1 = (above[ 0] + above[1] + 1) >> 1;\npredict[2] = pred2 = (above[ 1] + above[2] + 1) >> 1;\npredict[3] = pred3 = (above[ 2] + above[3] + 1) >> 1;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred4 = (left[ 0] + 2 * above[-1] +\n                      above[0] + 2) >> 2;\npredict[1] = pred5 = (above[-1] + 2 * above[ 0] +\n                      above[1] + 2) >> 2;\npredict[2] = pred6 = (above[ 0] + 2 * above[ 1] +\n                      above[2] + 2) >> 2;\npredict[3] = pred7 = (above[ 1] + 2 * above[ 2] +\n                      above[3] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred8 =\n    (left[stride] + 2 * left[0] + above[-1] + 2) >> 2;\npredict[1] = pred0;\npredict[2] = pred1;\npredict[3] = pred2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict[0] = pred9 =\n        (left[stride*2] + 2 * left[stride] + left[0] + 2) >> 2;\n    predict[1] = pred4;\n    predict[2] = pred5;\n    predict[3] = pred6;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_vl_4x4(unsigned char *predict,\n               int            stride)\n{\n    unsigned char *above = predict - stride;\n    int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,\n                   pred7, pred8, pred9;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred0 = (above[0] + above[1] + 1) >> 1;\npredict[1] = pred1 = (above[1] + above[2] + 1) >> 1;\npredict[2] = pred2 = (above[2] + above[3] + 1) >> 1;\npredict[3] = pred3 = (above[3] + above[4] + 1) >> 1;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred4 = (above[0] + 2 * above[1] +\n                      above[2] + 2) >> 2;\npredict[1] = pred5 = (above[1] + 2 * above[2] +\n                      above[3] + 2) >> 2;\npredict[2] = pred6 = (above[2] + 2 * above[3] +\n                      above[4] + 2) >> 2;\npredict[3] = pred7 = (above[3] + 2 * above[4] +\n                      above[5] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred1;\npredict[1] = pred2;\npredict[2] = pred3;\npredict[3] = pred8 = (above[4] + 2 * above[5] +\n                      above[6] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict[0] = pred5;\n    predict[1] = pred6;\n    predict[2] = pred7;\n    predict[3] = pred9 = (above[5] + 2 * above[6] +\n                          above[7] + 2) >> 2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_hd_4x4(unsigned char *predict,\n               int            stride)\n{\n    unsigned char *left = predict - 1;\n    unsigned char *above = predict - stride;\n    int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,\n                   pred7, pred8, pred9;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred0 = (left[ 0] + above[-1] + 1) >> 1;\npredict[1] = pred1 = (left[ 0] + 2 * above[-1] +\n                      above[0] + 2) >> 2;\npredict[2] = pred2 = (above[-1] + 2 * above[ 0] +\n                      above[1] + 2) >> 2;\npredict[3] = pred3 = (above[ 0] + 2 * above[ 1] +\n                      above[2] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred4 = (left[stride] + left[0] + 1) >> 1;\npredict[1] = pred5 = (left[stride] + 2 * left[0] +\n                      above[-1] + 2) >> 2;\npredict[2] = pred0;\npredict[3] = pred1;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred6 = (left[stride*2] + left[stride] + 1) >> 1;\npredict[1] = pred7 = (left[stride*2] + 2 * left[stride] +\n                      left[0] + 2) >> 2;\npredict[2] = pred4;\npredict[3] = pred5;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict[0] = pred8 = (left[stride*3] + left[stride*2] + 1) >> 1;\n    predict[1] = pred9 = (left[stride*3] + 2 * left[stride*2] +\n                          left[stride] + 2) >> 2;\n    predict[2] = pred6;\n    predict[3] = pred7;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_hu_4x4(unsigned char *predict,\n               int            stride)\n{\n    unsigned char *left = predict - 1;\n    int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred0 = (left[stride*0] +\n                      left[stride*1] + 1) >> 1;\npredict[1] = pred1 = (left[stride*0] + 2 * left[stride*1] +\n                      left[stride*2] + 2) >> 2;\npredict[2] = pred2 = (left[stride*1] + left[stride*2] + 1) >> 1;\npredict[3] = pred3 = (left[stride*1] + 2 * left[stride*2] +\n                      left[stride*3] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred2;\npredict[1] = pred3;\npredict[2] = pred4 = (left[stride*2] + left[stride*3] + 1) >> 1;\npredict[3] = pred5 = (left[stride*2] + 2 * left[stride*3] +\n                      left[stride*3] + 2) >> 2;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "predict[0] = pred4;\npredict[1] = pred5;\npredict[2] = pred6 = left[stride*3];\npredict[3] = pred6;\npredict += stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict[0] = pred6;\n    predict[1] = pred6;\n    predict[2] = pred6;\n    predict[3] = pred6;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_h_16x16(unsigned char *predict, int stride)\n{\n    predict_h_nxn(predict, stride, 16);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_v_16x16(unsigned char *predict, int stride)\n{\n    predict_v_nxn(predict, stride, 16);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_tm_16x16(unsigned char *predict, int stride)\n{\n    predict_tm_nxn(predict, stride, 16);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_h_8x8(unsigned char *predict, int stride)\n{\n    predict_h_nxn(predict, stride, 8);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_v_8x8(unsigned char *predict, int stride)\n{\n    predict_v_nxn(predict, stride, 8);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_tm_8x8(unsigned char *predict, int stride)\n{\n    predict_tm_nxn(predict, stride, 8);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_tm_4x4(unsigned char *predict, int stride)\n{\n    predict_tm_nxn(predict, stride, 4);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\ncopy_down(unsigned char           *recon,\n          int                      stride)\n{\n    /* Copy the four pixels above-right of subblock 3 to\n     * above-right of subblocks 7, 11, and 15\n     */\n    uint32_t tmp, *copy = (void *)(recon + 16 - stride);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    stride = stride / sizeof(unsigned int);\n    tmp = *copy;\n    copy += stride * 4;\n    *copy = tmp;\n    copy += stride * 4;\n    *copy = tmp;\n    copy += stride * 4;\n    *copy = tmp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void b_pred(unsigned char *predict, int stride, struct mb_info *mbi, short *coeffs) { int i;",
      "ja": "static void b_pred（unsigned char *predict、int stride、struct mb_info *mbi、short *coffs）{int i;"
    },
    {
      "indent": 7,
      "text": "copy_down(predict, stride);",
      "ja": "copy_down（Predict、Stride）;"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 16; i++)\n{\n    unsigned char *b_predict = predict + (i & 3) * 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "switch (mbi->split.modes[i])\n{\ncase B_DC_PRED:\n    predict_dc_nxn(b_predict, stride, 4);\n    break;\ncase B_TM_PRED:\n    predict_tm_4x4(b_predict, stride);\n    break;\ncase B_VE_PRED:\n    predict_ve_4x4(b_predict, stride);\n    break;\ncase B_HE_PRED:\n    predict_he_4x4(b_predict, stride);\n    break;\ncase B_LD_PRED:\n    predict_ld_4x4(b_predict, stride);\n    break;\ncase B_RD_PRED:\n    predict_rd_4x4(b_predict, stride);\n    break;\ncase B_VR_PRED:\n    predict_vr_4x4(b_predict, stride);\n    break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "case B_VL_PRED:\n    predict_vl_4x4(b_predict, stride);\n    break;\ncase B_HD_PRED:\n    predict_hd_4x4(b_predict, stride);\n    break;\ncase B_HU_PRED:\n    predict_hu_4x4(b_predict, stride);\n    break;\ndefault:\n    assert(0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "vp8_dixie_idct_add(b_predict, b_predict, stride, coeffs);\ncoeffs += 16;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if ((i & 3) == 3)\n        {\n            predict += stride * 4;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void",
      "ja": "静的ボイド"
    },
    {
      "indent": 3,
      "text": "fixup_dc_coeffs(struct mb_info *mbi, short *coeffs) { short y2[16]; int i;",
      "ja": "fixup_dc_coeffs（struct mb_info *mbi、short *coffs）{short y2 [16];int i;"
    },
    {
      "indent": 7,
      "text": "vp8_dixie_walsh(coeffs + 24 * 16, y2);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i < 16; i++)\n        coeffs[i*16] = y2[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void predict_intra_luma(unsigned char *predict, int stride, struct mb_info *mbi, short *coeffs) { if (mbi->base.y_mode == B_PRED) b_pred(predict, stride, mbi, coeffs); else",
      "ja": "static void predict_intra_luma（unsigned char *predict、int stride、struct mb_info *mbi、short *coffs）{if（mbi-> base.y_mode == b_pred）b_pred（予測、ストライド、MBI、係数）;そうしないと"
    },
    {
      "indent": 7,
      "text": "{ int i;",
      "ja": "{int i;"
    },
    {
      "indent": 11,
      "text": "switch (mbi->base.y_mode)\n{\ncase DC_PRED:\n    predict_dc_nxn(predict, stride, 16);\n    break;\ncase V_PRED:\n    predict_v_16x16(predict, stride);\n    break;\ncase H_PRED:\n    predict_h_16x16(predict, stride);\n    break;\ncase TM_PRED:\n    predict_tm_16x16(predict, stride);\n    break;\ndefault:\n    assert(0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "fixup_dc_coeffs(mbi, coeffs);",
      "ja": "fixup_dc_coeffs（MBI、coffs）;"
    },
    {
      "indent": 11,
      "text": "for (i = 0; i < 16; i++)\n{\n    vp8_dixie_idct_add(predict, predict, stride, coeffs);\n    coeffs += 16;\n    predict += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "            if ((i & 3) == 3)\n                predict += stride * 4 - 16;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void predict_intra_chroma(unsigned char *predict_u, unsigned char *predict_v, int stride, struct mb_info *mbi, short *coeffs) { int i;",
      "ja": "static void predict_intra_chroma（unsigned char *predict_u、unsigned char *predict_v、int stride、struct mb_info *mbi、short *coffs）{int i;"
    },
    {
      "indent": 7,
      "text": "switch (mbi->base.uv_mode)\n{\ncase DC_PRED:\n    predict_dc_nxn(predict_u, stride, 8);\n    predict_dc_nxn(predict_v, stride, 8);\n    break;\ncase V_PRED:\n    predict_v_8x8(predict_u, stride);\n    predict_v_8x8(predict_v, stride);\n    break;\ncase H_PRED:\n    predict_h_8x8(predict_u, stride);\n    predict_h_8x8(predict_v, stride);\n    break;\ncase TM_PRED:\n    predict_tm_8x8(predict_u, stride);\n    predict_tm_8x8(predict_v, stride);\n    break;\ndefault:\n    assert(0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "coeffs += 16 * 16;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 16; i < 20; i++)\n{\n    vp8_dixie_idct_add(predict_u, predict_u, stride, coeffs);\n    coeffs += 16;\n    predict_u += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (i & 1)\n        predict_u += stride * 4 - 8;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 20; i < 24; i++)\n{\n    vp8_dixie_idct_add(predict_v, predict_v, stride, coeffs);\n    coeffs += 16;\n    predict_v += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if (i & 1)\n            predict_v += stride * 4 - 8;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nsixtap_horiz(unsigned char       *output,\n             int                  output_stride,\n             const unsigned char *reference,\n             int                  reference_stride,\n             int                  cols,\n             int                  rows,\n             const filter_t       filter\n            )\n{\n    int r, c, temp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (r = 0; r < rows; r++)\n{\n    for (c = 0; c < cols; c++)\n    {\n        temp = (reference[-2] * filter[0]) +\n               (reference[-1] * filter[1]) +\n               (reference[ 0] * filter[2]) +\n               (reference[ 1] * filter[3]) +\n               (reference[ 2] * filter[4]) +\n               (reference[ 3] * filter[5]) +\n               64;\n        temp >>= 7;\n        output[c] = CLAMP_255(temp);\n        reference++;\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        reference += reference_stride - cols;\n        output += output_stride;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nsixtap_vert(unsigned char       *output,\n            int                  output_stride,\n            const unsigned char *reference,\n            int                  reference_stride,\n            int                  cols,\n            int                  rows,\n            const filter_t       filter\n           )\n{\n    int r, c, temp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (r = 0; r < rows; r++)\n{",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (c = 0; c < cols; c++)\n{\n    temp = (reference[-2*reference_stride] * filter[0]) +\n           (reference[-1*reference_stride] * filter[1]) +\n           (reference[ 0*reference_stride] * filter[2]) +\n           (reference[ 1*reference_stride] * filter[3]) +\n           (reference[ 2*reference_stride] * filter[4]) +\n           (reference[ 3*reference_stride] * filter[5]) +\n           64;\n    temp >>= 7;\n    output[c] = CLAMP_255(temp);\n    reference++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        reference += reference_stride - cols;\n        output += output_stride;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nsixtap_2d(unsigned char       *output,\n          int                  output_stride,\n          const unsigned char *reference,\n          int                  reference_stride,\n          int                  cols,\n          int                  rows,\n          int                  mx,\n          int                  my,\n          const filter_t       filters[8]\n         )\n{\n    DECLARE_ALIGNED(16, unsigned char, temp[16*(16+5)]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    sixtap_horiz(temp, 16,\n                 reference - 2 * reference_stride, reference_stride,\n                 cols, rows + 5, filters[mx]);\n    sixtap_vert(output, output_stride,\n                temp + 2 * 16, 16,\n                cols, rows, filters[my]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct img_index\n{\n    unsigned char *y, *u, *v;\n    int            stride, uv_stride;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const unsigned char * filter_block(unsigned char *output, const unsigned char *reference, int stride, const union mv *mv, const filter_t filters[8]) { int mx, my;",
      "ja": "static const unsigned char *filter_block（unsigned char *output、const unsigned char *reference、int stride、const Union mv *mv、const filter_t filters [8]）{int mx、my;"
    },
    {
      "indent": 7,
      "text": "/* Handle 0,0 as a special case.  TODO: Does this make it any\n * faster?\n */\nif (!mv->raw)\n    return reference;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "mx = mv->d.x & 7;\nmy = mv->d.y & 7;\nreference += ((mv->d.y >> 3) * stride) + (mv->d.x >> 3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (mx | my)\n{\n    sixtap_2d(output, stride, reference, stride, 4, 4, mx, my,\n              filters);\n    reference = output;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return reference; }",
      "ja": "リファレンスを返す;}"
    },
    {
      "indent": 3,
      "text": "static void\nrecon_1_block(unsigned char        *output,\n              const unsigned char  *reference,\n              int                   stride,\n              const union mv       *mv,\n              const filter_t        filters[8],\n              short                *coeffs,\n              struct mb_info       *mbi,\n              int                   b\n             )\n{\n    const unsigned char *predict;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict = filter_block(output, reference, stride, mv, filters);\n    vp8_dixie_idct_add(output, predict, stride, coeffs + 16 * b);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static mv_t\ncalculate_chroma_splitmv(struct mb_info *mbi,\n                         int             b,\n                         int             full_pixel)\n{\n    int temp;\n    union mv mv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "temp = mbi->split.mvs[b].d.x +\n       mbi->split.mvs[b+1].d.x +\n       mbi->split.mvs[b+4].d.x +\n       mbi->split.mvs[b+5].d.x;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (temp < 0)\n    temp -= 4;\nelse\n    temp += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "mv.d.x = temp / 8;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "temp = mbi->split.mvs[b].d.y +\n       mbi->split.mvs[b+1].d.y +\n       mbi->split.mvs[b+4].d.y +\n       mbi->split.mvs[b+5].d.y;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (temp < 0)\n    temp -= 4;\nelse\n    temp += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "mv.d.y = temp / 8;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (full_pixel)\n{\n    mv.d.x &= ~7;\n    mv.d.y &= ~7;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return mv; }",
      "ja": "MVを返します。}"
    },
    {
      "indent": 3,
      "text": "/* Note: We rely on the reconstructed border having the same stride\n * as the reference buffer because the filter_block can't adjust the\n * stride with its return value, only the reference pointer.\n */\nstatic void\nbuild_mc_border(unsigned char       *dst,\n                const unsigned char *src,\n                int                  stride,\n                int                  x,\n                int                  y,\n                int                  b_w,\n                int                  b_h,\n                int                  w,\n                int                  h\n               )\n{\n    const unsigned char *ref_row;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Get a pointer to the start of the real data for this row */\nref_row = src - x - y * stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (y >= h)\n    ref_row += (h - 1) * stride;\nelse if (y > 0)\n    ref_row += y * stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "do { int left, right = 0, copy;",
      "ja": "{int左、右= 0、copy;"
    },
    {
      "indent": 11,
      "text": "left = x < 0 ? -x : 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (left > b_w) left = b_w;",
      "ja": "if（left> b_w）left = b_w;"
    },
    {
      "indent": 11,
      "text": "if (x + b_w > w)\n    right = x + b_w - w;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (right > b_w) right = b_w;",
      "ja": "if（right> b_w）right = b_w;"
    },
    {
      "indent": 11,
      "text": "copy = b_w - left - right;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (left) memset(dst, ref_row[0], left);",
      "ja": "if（左）memset（dst、ref_row [0]、左）;"
    },
    {
      "indent": 11,
      "text": "if (copy)\n    memcpy(dst + left, ref_row + x + left, copy);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (right)\n    memset(dst + left + copy, ref_row[w-1], right);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "dst += stride;\ny++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if (y < h && y > 0)\n            ref_row += stride;\n    }\n    while (--b_h);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nrecon_1_edge_block(unsigned char        *output,\n                   unsigned char        *emul_block,\n                   const unsigned char  *reference,\n                   int                   stride,\n                   const union mv       *mv,\n                   const filter_t        filters[8],\n                   short                *coeffs,\n                   struct mb_info       *mbi,\n                   int                   x,\n                   int                   y,\n                   int                   w,\n                   int                   h,\n                   int                   start_b\n                  )\n{\n    const unsigned char *predict;\n    int                  b = start_b;\n    const int            b_w = 4;\n    const int            b_h = 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "x += mv->d.x >> 3;\ny += mv->d.y >> 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Need two pixels left/above, 3 right/below for 6-tap */\nif (x < 2 || x + b_w - 1 + 3 >= w || y < 2 ||\n    y + b_h - 1 + 3 >= h)\n{\n    reference += (mv->d.x >> 3) + (mv->d.y >> 3) * stride;\n    build_mc_border(emul_block,\n                    reference - 2 - 2 * stride, stride,\n                    x - 2, y - 2, b_w + 5, b_h + 5, w, h);\n    reference = emul_block + 2 * stride + 2;\n    reference -= (mv->d.x >> 3) + (mv->d.y >> 3) * stride;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    predict = filter_block(output, reference, stride, mv, filters);\n    vp8_dixie_idct_add(output, predict, stride, coeffs + 16 * b);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\npredict_inter_emulated_edge(struct vp8_decoder_ctx  *ctx,\n                            struct img_index        *img,\n                            short                   *coeffs,\n                            struct mb_info          *mbi,\n                            int                      mb_col,\n                            int                      mb_row)\n{\n    /* TODO: Move this into its own buffer.  This only works because\n     * we still have a border allocated.\n     */\n    unsigned char *emul_block = ctx->frame_strg[0].img.img_data;\n    unsigned char *reference;\n    unsigned char *output;\n    ptrdiff_t      reference_offset;\n    int            w, h, x, y, b;\n    union mv       chroma_mv[4];\n    unsigned char *u = img->u, *v = img->v;\n    int            full_pixel = ctx->frame_hdr.version == 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "x = mb_col * 16;\ny = mb_row * 16;\nw = ctx->mb_cols * 16;\nh = ctx->mb_rows * 16;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "output = img->y;\nreference_offset = ctx->ref_frame_offsets[mbi->base.ref_frame];\nreference = output + reference_offset;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (mbi->base.y_mode != SPLITMV)\n{\n    union mv uvmv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "uvmv = mbi->base.mv;\nuvmv.d.x = (uvmv.d.x + 1 + (uvmv.d.x >> 31) * 2) / 2;\nuvmv.d.y = (uvmv.d.y + 1 + (uvmv.d.y >> 31) * 2) / 2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (full_pixel)\n{\n    uvmv.d.x &= ~7;\n    uvmv.d.y &= ~7;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    chroma_mv[0] = uvmv;\n    chroma_mv[1] = uvmv;\n    chroma_mv[2] = uvmv;\n    chroma_mv[3] = uvmv;\n}\nelse\n{\n    chroma_mv[0] = calculate_chroma_splitmv(mbi,  0, full_pixel);\n    chroma_mv[1] = calculate_chroma_splitmv(mbi,  2, full_pixel);\n    chroma_mv[2] = calculate_chroma_splitmv(mbi,  8, full_pixel);\n    chroma_mv[3] = calculate_chroma_splitmv(mbi, 10, full_pixel);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Luma */\nfor (b = 0; b < 16; b++)\n{\n    union mv *ymv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (mbi->base.y_mode != SPLITMV)\n    ymv = &mbi->base.mv;\nelse\n    ymv = mbi->split.mvs + b;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "recon_1_edge_block(output, emul_block, reference, img->stride, ymv, ctx->subpixel_filters, coeffs, mbi, x, y, w, h, b);",
      "ja": "Recon_1_edge_block（output、emul_block、reference、img-> stride、ymv、ctx-> subpixel_filters、coeffs、mbi、x、y、w、h、b）;"
    },
    {
      "indent": 11,
      "text": "x += 4;\noutput += 4;\nreference += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if ((b & 3) == 3)\n    {\n        x -= 16;\n        y += 4;\n        output += 4 * img->stride - 16;\n        reference += 4 * img->stride - 16;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "x = mb_col * 16;\ny = mb_row * 16;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Chroma */\nx >>= 1;\ny >>= 1;\nw >>= 1;\nh >>= 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (b = 0; b < 4; b++)\n{\n    recon_1_edge_block(u, emul_block, u + reference_offset,\n                       img->uv_stride,\n                       &chroma_mv[b], ctx->subpixel_filters,\n                       coeffs, mbi, x, y, w, h, b + 16);\n    recon_1_edge_block(v, emul_block, v + reference_offset,\n                       img->uv_stride,\n                       &chroma_mv[b], ctx->subpixel_filters,\n                       coeffs, mbi, x, y, w, h, b + 20);\n    u += 4;\n    v += 4;\n    x += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (b & 1)\n    {\n        x -= 8;\n        y += 4;\n        u += 4 * img->uv_stride - 8;\n        v += 4 * img->uv_stride - 8;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "static void predict_inter(struct vp8_decoder_ctx *ctx, struct img_index *img, short *coeffs, struct mb_info *mbi)",
      "ja": "static void predict_inter（struct vp8_decoder_ctx *ctx、struct img_index *img、short *coffs、struct mb_info *mbi）"
    },
    {
      "indent": 3,
      "text": "{\n    unsigned char *y = img->y;\n    unsigned char *u = img->u;\n    unsigned char *v = img->v;\n    ptrdiff_t      reference_offset;\n    union mv       chroma_mv[4];\n    int            full_pixel = ctx->frame_hdr.version == 3;\n    int b;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (mbi->base.y_mode != SPLITMV)\n{\n    union mv             uvmv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "uvmv = mbi->base.mv;\nuvmv.d.x = (uvmv.d.x + 1 + (uvmv.d.x >> 31) * 2) / 2;\nuvmv.d.y = (uvmv.d.y + 1 + (uvmv.d.y >> 31) * 2) / 2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (full_pixel)\n{\n    uvmv.d.x &= ~7;\n    uvmv.d.y &= ~7;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    chroma_mv[0] =\n        chroma_mv[1] =\n            chroma_mv[2] =\n                chroma_mv[3] = uvmv;\n}\nelse\n{\n    chroma_mv[0] = calculate_chroma_splitmv(mbi,  0, full_pixel);\n    chroma_mv[1] = calculate_chroma_splitmv(mbi,  2, full_pixel);\n    chroma_mv[2] = calculate_chroma_splitmv(mbi,  8, full_pixel);\n    chroma_mv[3] = calculate_chroma_splitmv(mbi, 10, full_pixel);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "reference_offset = ctx->ref_frame_offsets[mbi->base.ref_frame];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (b = 0; b < 16; b++)\n{\n    union mv *ymv;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (mbi->base.y_mode != SPLITMV)\n    ymv = &mbi->base.mv;\nelse\n    ymv = mbi->split.mvs + b;\nrecon_1_block(y, y + reference_offset, img->stride,\n              ymv, ctx->subpixel_filters, coeffs, mbi, b);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "y += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if ((b & 3) == 3)\n        y += 4 * img->stride - 16;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (b = 0; b < 4; b++)\n{\n    recon_1_block(u, u + reference_offset,\n                  img->uv_stride, &chroma_mv[b],\n                  ctx->subpixel_filters, coeffs, mbi, b + 16);\n    recon_1_block(v, v + reference_offset,\n                  img->uv_stride, &chroma_mv[b],\n                  ctx->subpixel_filters, coeffs, mbi, b + 20);\n    u += 4;\n    v += 4;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if (b & 1)\n        {\n            u += 4 * img->uv_stride - 8;\n            v += 4 * img->uv_stride - 8;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_release_ref_frame(struct ref_cnt_img *rcimg)\n{\n    if (rcimg)\n    {\n        assert(rcimg->ref_cnt);\n        rcimg->ref_cnt--;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct ref_cnt_img *\nvp8_dixie_ref_frame(struct ref_cnt_img *rcimg)\n{\n    rcimg->ref_cnt++;\n    return rcimg;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct ref_cnt_img * vp8_dixie_find_free_ref_frame(struct ref_cnt_img *frames) { int i;",
      "ja": "struct ref_cnt_img * vp8_dixie_find_free_ref_frame（struct ref_cnt_img * frames）{int i;"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < NUM_REF_FRAMES; i++)\n    if (frames[i].ref_cnt == 0)\n    {\n        frames[i].ref_cnt = 1;\n        return &frames[i];\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " assert(0); return NULL; }",
      "ja": "assert（0）;nullを返します。}"
    },
    {
      "indent": 3,
      "text": "static void\nfixup_left(unsigned char        *predict,\n           int                   width,\n           int                   stride,\n           unsigned int          row,\n           enum prediction_mode  mode)\n{\n    /* The left column of out-of-frame pixels is taken to be 129,\n     * unless we're doing DC_PRED, in which case we duplicate the\n     * above row, unless this is also row 0, in which case we use\n     * 129.\n     */\n    unsigned char *left = predict - 1;\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (mode == DC_PRED && row)\n{\n    unsigned char *above = predict - stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    for (i = 0; i < width; i++)\n    {\n        *left = above[i];\n        left += stride;\n    }\n}\nelse\n{\n    /* Need to re-set the above row, in case the above MB was\n     * DC_PRED.\n     */\n    left -= stride;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        for (i = -1; i < width; i++)\n        {\n            *left = 129;\n            left += stride;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nfixup_above(unsigned char        *predict,\n            int                   width,\n            int                   stride,\n            unsigned int          col,\n            enum prediction_mode  mode)\n{\n    /* The above row of out-of-frame pixels is taken to be 127,\n     * unless we're doing DC_PRED, in which case we duplicate the\n     * left col, unless this is also col 0, in which case we use\n     * 127.\n     */\n    unsigned char *above = predict - stride;\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (mode == DC_PRED && col)\n{\n    unsigned char *left = predict - 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    for (i = 0; i < width; i++)\n    {\n        above[i] = *left;\n        left += stride;\n    }\n}\nelse\n    /* Need to re-set the left col, in case the last MB was\n     * DC_PRED.\n     */\n    memset(above - 1, 127, width + 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    memset(above + width, 127, 4); // for above-right subblock modes\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_predict_init(struct vp8_decoder_ctx *ctx) {",
      "ja": "void vp8_dixie_predict_init（struct vp8_decoder_ctx *ctx）{"
    },
    {
      "indent": 7,
      "text": "int i; unsigned char *this_frame_base;",
      "ja": "int i;unsigned char *this_frame_base;"
    },
    {
      "indent": 7,
      "text": "if (ctx->frame_hdr.frame_size_updated)\n{\n    for (i = 0; i < NUM_REF_FRAMES; i++)\n    {\n        unsigned int w = ctx->mb_cols * 16 + BORDER_PIXELS * 2;\n        unsigned int h = ctx->mb_rows * 16 + BORDER_PIXELS * 2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "vpx_img_free(&ctx->frame_strg[i].img);\nctx->frame_strg[i].ref_cnt = 0;\nctx->ref_frames[i] = NULL;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (!vpx_img_alloc(&ctx->frame_strg[i].img, IMG_FMT_I420, w, h, 16)) vpx_internal_error(&ctx->error, VPX_CODEC_MEM_ERROR, \"Failed to allocate %dx%d\" \" framebuffer\", w, h);",
      "ja": "if（！vpx_img_alloc（＆ctx-> frame_strg [i] .img、img_fmt_i420、w、h、16））vpx_internal_error（＆ctx->エラー、vpx_codec_mem_error、 \";"
    },
    {
      "indent": 15,
      "text": "vpx_img_set_rect(&ctx->frame_strg[i].img, BORDER_PIXELS,\n    BORDER_PIXELS, ctx->frame_hdr.kf.w,\n    ctx->frame_hdr.kf.h);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "    if (ctx->frame_hdr.version)\n        ctx->subpixel_filters = bilinear_filters;\n    else\n        ctx->subpixel_filters = sixtap_filters;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Find a free framebuffer to predict into */\nif (ctx->ref_frames[CURRENT_FRAME])\n    vp8_dixie_release_ref_frame(ctx->ref_frames[CURRENT_FRAME]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ctx->ref_frames[CURRENT_FRAME] =\n    vp8_dixie_find_free_ref_frame(ctx->frame_strg);\nthis_frame_base = ctx->ref_frames[CURRENT_FRAME]->img.img_data;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Calculate offsets to the other reference frames */\nfor (i = 0; i < NUM_REF_FRAMES; i++)\n{\n    struct ref_cnt_img  *ref = ctx->ref_frames[i];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    ctx->ref_frame_offsets[i] =\n        ref ? ref->img.img_data - this_frame_base : 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /* TODO: No need to do this on every frame... */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_predict_destroy(struct vp8_decoder_ctx *ctx) { int i;",
      "ja": "void vp8_dixie_predict_destroy（struct vp8_decoder_ctx *ctx）{int i;"
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i < NUM_REF_FRAMES; i++)\n    {\n        vpx_img_free(&ctx->frame_strg[i].img);\n        ctx->frame_strg[i].ref_cnt = 0;\n        ctx->ref_frames[i] = NULL;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_predict_process_row(struct vp8_decoder_ctx *ctx,\n                              unsigned int            row,\n                              unsigned int            start_col,\n                              unsigned int            num_cols)\n{\n    struct img_index img;\n    struct mb_info *mbi;\n    unsigned int    col;\n    short          *coeffs;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Adjust pointers based on row, start_col */\nimg.stride =\n    ctx->ref_frames[CURRENT_FRAME]->img.stride[PLANE_Y];\nimg.uv_stride =\n    ctx->ref_frames[CURRENT_FRAME]->img.stride[PLANE_U];\nimg.y = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_Y];\nimg.u = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_U];\nimg.v = ctx->ref_frames[CURRENT_FRAME]->img.planes[PLANE_V];\nimg.y += (img.stride * row + start_col) * 16;\nimg.u += (img.uv_stride * row + start_col) * 8;\nimg.v += (img.uv_stride * row + start_col) * 8;\nmbi = ctx->mb_info_rows[row] + start_col;\ncoeffs = ctx->tokens[row &\n    (ctx->token_hdr.partitions - 1)].coeffs +\n    25 * 16 * start_col;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Fix up the out-of-frame pixels */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (start_col == 0)\n{\n    fixup_left(img.y, 16, img.stride, row, mbi->base.y_mode);\n    fixup_left(img.u, 8, img.uv_stride, row, mbi->base.uv_mode);\n    fixup_left(img.v, 8, img.uv_stride, row, mbi->base.uv_mode);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (row == 0)\n        *(img.y - img.stride - 1) = 127;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (col = start_col; col < start_col + num_cols; col++)\n{\n    if (row == 0)\n    {\n        fixup_above(img.y, 16, img.stride, col,\n                    mbi->base.y_mode);\n        fixup_above(img.u, 8, img.uv_stride, col,\n                    mbi->base.uv_mode);\n        fixup_above(img.v, 8, img.uv_stride, col,\n                    mbi->base.uv_mode);\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (mbi->base.y_mode <= B_PRED)\n{\n    predict_intra_luma(img.y, img.stride, mbi, coeffs);\n    predict_intra_chroma(img.u, img.v, img.uv_stride, mbi,\n                         coeffs);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "else\n{\n    if (mbi->base.y_mode != SPLITMV) // && != BPRED\n        fixup_dc_coeffs(mbi, coeffs);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": " if (mbi->base.need_mc_border) predict_inter_emulated_edge(ctx, &img, coeffs, mbi, col, row); else predict_inter(ctx, &img, coeffs, mbi); }",
      "ja": "if（mbi-> base.need_mc_border）preprid_inter_emulated_edge（ctx、＆img、coeffs、mbi、col、row）;else_inter（ctx、＆img、coeffs、mbi）;}"
    },
    {
      "indent": 7,
      "text": "    /* Advance to the next macroblock */\n    mbi++;\n    img.y += 16;\n    img.u += 8;\n    img.v += 8;\n    coeffs += 25 * 16;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (col == ctx->mb_cols)\n    {\n        /* Extend the last row by four pixels for intra-prediction.\n         * This will be propagated later by copy_down.\n         */\n        uint32_t *extend = (uint32_t *)(img.y + 15 * img.stride);\n        uint32_t  val = 0x01010101 * img.y[-1 + 15 * img.stride];\n        *extend = val;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.15. predict.h",
      "section_title": true,
      "ja": "20.15. Predict.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef PREDICT_H\n#define PREDICT_H",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_predict_init(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_predict_init（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_predict_destroy(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_predict_destroy（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_predict_process_row(struct vp8_decoder_ctx *ctx,\n                              unsigned int            row,\n                              unsigned int            start_col,\n                              unsigned int            num_cols);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_release_ref_frame(struct ref_cnt_img *rcimg);",
      "ja": "void vp8_dixie_release_ref_frame（struct ref_cnt_img *rcimg）;"
    },
    {
      "indent": 3,
      "text": "struct ref_cnt_img *\nvp8_dixie_ref_frame(struct ref_cnt_img *rcimg);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct ref_cnt_img *\nvp8_dixie_find_free_ref_frame(struct ref_cnt_img *frames);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.16. tokens.c",
      "section_title": true,
      "ja": "20.16. tokens.C"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#include \"vpx_codec_internal.h\"\n#include \"dixie.h\"\n#include \"tokens.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <malloc.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum\n{\n    EOB_CONTEXT_NODE,\n    ZERO_CONTEXT_NODE,\n    ONE_CONTEXT_NODE,\n    LOW_VAL_CONTEXT_NODE,\n    TWO_CONTEXT_NODE,\n    THREE_CONTEXT_NODE,\n    HIGH_LOW_CONTEXT_NODE,\n    CAT_ONE_CONTEXT_NODE,\n    CAT_THREEFOUR_CONTEXT_NODE,\n    CAT_THREE_CONTEXT_NODE,\n    CAT_FIVE_CONTEXT_NODE\n};\nenum\n{\n    ZERO_TOKEN,\n    ONE_TOKEN,\n    TWO_TOKEN,\n    THREE_TOKEN,\n    FOUR_TOKEN,\n    DCT_VAL_CATEGORY1,\n    DCT_VAL_CATEGORY2,\n    DCT_VAL_CATEGORY3,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    DCT_VAL_CATEGORY4,\n    DCT_VAL_CATEGORY5,\n    DCT_VAL_CATEGORY6,\n    DCT_EOB_TOKEN,\n    MAX_ENTROPY_TOKENS\n};\nstruct extrabits\n{\n    short         min_val;\n    short         length;\n    unsigned char probs[12];\n};\nstatic const unsigned int left_context_index[25] =\n{\n    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,\n    4, 4, 5, 5, 6, 6, 7, 7, 8\n};\nstatic const unsigned int above_context_index[25] =\n{\n    0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,\n    4, 5, 4, 5, 6, 7, 6, 7, 8\n};\n#define X(n) ((n) * PREV_COEFF_CONTEXTS * ENTROPY_NODES)\nstatic const unsigned int bands_x[16] =\n{\n    X(0), X(1), X(2), X(3), X(6), X(4), X(5), X(6),\n    X(6), X(6), X(6), X(6), X(6), X(6), X(6), X(7)\n};\n#undef X\nstatic const struct extrabits extrabits[MAX_ENTROPY_TOKENS] =\n{\n    { 0, -1, {  0,   0,   0,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //ZERO_TOKEN\n    { 1, 0,  {  0,   0,   0,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //ONE_TOKEN\n    { 2, 0,  {  0,   0,   0,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //TWO_TOKEN\n    { 3, 0,  {  0,   0,   0,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //THREE_TOKEN\n    { 4, 0,  {  0,   0,   0,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //FOUR_TOKEN\n    { 5, 0,  {159,   0,   0,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY1\n    { 7, 1,  {145, 165,   0,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY2\n    {11, 2,  {140, 148, 173,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    {19, 3,  {135, 140, 155, 176,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY4\n    {35, 4,  {130, 134, 141, 157, 180,   0,\n                0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY5\n    {67, 10, {129, 130, 133, 140, 153, 177,\n              196, 230, 243, 254, 254,   0 } }, //DCT_VAL_CATEGORY6\n    { 0, -1, {  0,   0,   0,   0,   0,   0,\n                0,   0,   0,   0,   0,   0 } }, // EOB TOKEN\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const unsigned int zigzag[16] = { 0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15 };",
      "ja": "static const unsigned int zigzag [16] = {0、1、4、8、5、2、3、6、9、12、13、10、7、11、14、15};"
    },
    {
      "indent": 3,
      "text": "#define DECODE_AND_APPLYSIGN(value_to_sign) \\\n    v = (bool_get_bit(bool) ? -value_to_sign \\\n                            : value_to_sign) * dqf[!!c];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define DECODE_AND_BRANCH_IF_ZERO(probability,branch) \\\n    if (!bool_get(bool, probability)) goto branch;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define DECODE_AND_LOOP_IF_ZERO(probability,branch) \\\n    if (!bool_get(bool, probability)) \\\n    { \\\n        prob = type_probs; \\\n        if (c<15) {\\\n            ++c; \\\n            prob += bands_x[c]; \\\n            goto branch; \\\n        }\\\n        else \\\n            goto BLOCK_FINISHED; /* for malformed input */\\\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val) \\\n    DECODE_AND_APPLYSIGN(val) \\\n    prob = type_probs + (ENTROPY_NODES*2); \\\n    if (c < 15){\\\n        b_tokens[zigzag[c]] = v; \\\n        ++c; \\\n        goto DO_WHILE; }\\\n    b_tokens[zigzag[15]] = v; \\\n    goto BLOCK_FINISHED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define DECODE_EXTRABIT_AND_ADJUST_VAL(t,bits_count)\\\n    val += bool_get(bool, extrabits[t].probs[bits_count]) << \\\n    bits_count;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static int\ndecode_mb_tokens(struct bool_decoder  *bool,\n                 token_entropy_ctx_t   left,\n                 token_entropy_ctx_t   above,\n                 short                *tokens,\n                 enum prediction_mode  mode,\n                 coeff_probs_table_t   probs,\n                 short                 factor[TOKEN_BLOCK_TYPES][2])\n{\n    int            i, stop, type;\n    int            c, t, v;\n    int            val, bits_count;\n    int            eob_mask;\n    short         *b_tokens;   // tokens for this block\n    unsigned char *type_probs; // probabilities for this block type\n    unsigned char *prob;\n    short         *dqf;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "eob_mask = 0;",
      "ja": "EOB_MASK = 0;"
    },
    {
      "indent": 7,
      "text": "if (mode != B_PRED && mode != SPLITMV)\n{\n    i = 24;\n    stop = 24;\n    type = 1;\n    b_tokens = tokens + 24 * 16;\n    dqf = factor[TOKEN_BLOCK_Y2];\n}\nelse\n{\n    i = 0;\n    stop = 16;\n    type = 3;\n    b_tokens = tokens;\n    dqf = factor[TOKEN_BLOCK_Y1];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Save a pointer to the coefficient probs for the current type.\n * Need to repeat this whenever type changes.\n */\ntype_probs = probs[type][0][0];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "BLOCK_LOOP:\n    t = left[left_context_index[i]] + above[above_context_index[i]];\n    c = !type; /* all blocks start at 0 except type 0, which starts\n                * at 1. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "prob = type_probs;\nprob += t * ENTROPY_NODES;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DO_WHILE:\n    prob += bands_x[c];\n    DECODE_AND_BRANCH_IF_ZERO(prob[EOB_CONTEXT_NODE],\n      BLOCK_FINISHED);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CHECK_0_:\n    DECODE_AND_LOOP_IF_ZERO(prob[ZERO_CONTEXT_NODE], CHECK_0_);\n    DECODE_AND_BRANCH_IF_ZERO(prob[ONE_CONTEXT_NODE],\n                              ONE_CONTEXT_NODE_0_);\n    DECODE_AND_BRANCH_IF_ZERO(prob[LOW_VAL_CONTEXT_NODE],\n                              LOW_VAL_CONTEXT_NODE_0_);\n    DECODE_AND_BRANCH_IF_ZERO(prob[HIGH_LOW_CONTEXT_NODE],\n                              HIGH_LOW_CONTEXT_NODE_0_);\n    DECODE_AND_BRANCH_IF_ZERO(prob[CAT_THREEFOUR_CONTEXT_NODE],\n                              CAT_THREEFOUR_CONTEXT_NODE_0_);\n    DECODE_AND_BRANCH_IF_ZERO(prob[CAT_FIVE_CONTEXT_NODE],\n                              CAT_FIVE_CONTEXT_NODE_0_);\n    val = extrabits[DCT_VAL_CATEGORY6].min_val;\n    bits_count = extrabits[DCT_VAL_CATEGORY6].length;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "do\n{\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY6,\n      bits_count);\n    bits_count --;\n}\nwhile (bits_count >= 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);",
      "ja": "decode_sign_write_coeff_and_check_exit（val）;"
    },
    {
      "indent": 3,
      "text": "CAT_FIVE_CONTEXT_NODE_0_:\n    val = extrabits[DCT_VAL_CATEGORY5].min_val;\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 4);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 3);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 2);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 1);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 0);\n    DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CAT_THREEFOUR_CONTEXT_NODE_0_:\n    DECODE_AND_BRANCH_IF_ZERO(prob[CAT_THREE_CONTEXT_NODE],\n                              CAT_THREE_CONTEXT_NODE_0_);\n    val = extrabits[DCT_VAL_CATEGORY4].min_val;\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 3);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 2);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 1);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 0);\n    DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CAT_THREE_CONTEXT_NODE_0_:\n    val = extrabits[DCT_VAL_CATEGORY3].min_val;\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 2);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 1);\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 0);\n    DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HIGH_LOW_CONTEXT_NODE_0_: DECODE_AND_BRANCH_IF_ZERO(prob[CAT_ONE_CONTEXT_NODE], CAT_ONE_CONTEXT_NODE_0_);",
      "ja": "high_low_context_node_0_：decode_and_branch_if_zero（prob [cat_one_context_node]、cat_one_context_node_0_）;"
    },
    {
      "indent": 7,
      "text": "val = extrabits[DCT_VAL_CATEGORY2].min_val;\nDECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY2, 1);\nDECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY2, 0);\nDECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CAT_ONE_CONTEXT_NODE_0_:\n    val = extrabits[DCT_VAL_CATEGORY1].min_val;\n    DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY1, 0);\n    DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LOW_VAL_CONTEXT_NODE_0_:\n    DECODE_AND_BRANCH_IF_ZERO(prob[TWO_CONTEXT_NODE],\n                              TWO_CONTEXT_NODE_0_);\n    DECODE_AND_BRANCH_IF_ZERO(prob[THREE_CONTEXT_NODE],\n                              THREE_CONTEXT_NODE_0_);\n    DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(4);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "THREE_CONTEXT_NODE_0_: DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(3);",
      "ja": "Three_context_node_0_：decode_sign_write_coeff_and_check_exit（3）;"
    },
    {
      "indent": 3,
      "text": "TWO_CONTEXT_NODE_0_: DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(2);",
      "ja": "Two_context_node_0_：decode_sign_write_coeff_and_check_exit（2）;"
    },
    {
      "indent": 3,
      "text": "ONE_CONTEXT_NODE_0_:\n    DECODE_AND_APPLYSIGN(1);\n    prob = type_probs + ENTROPY_NODES;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (c < 15)\n{\n    b_tokens[zigzag[c]] = v;\n    ++c;\n    goto DO_WHILE;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    b_tokens[zigzag[15]] = v;\nBLOCK_FINISHED:\n    eob_mask |= (c > 1) << i;\n    t = (c != !type);   // any non-zero data?\n    eob_mask |= t << 31;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "left[left_context_index[i]] = above[above_context_index[i]] = t;\nb_tokens += 16;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "i++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (i < stop) goto BLOCK_LOOP;",
      "ja": "if（i <stop）goto block_loop;"
    },
    {
      "indent": 7,
      "text": "if (i == 25)\n{\n    type = 0;\n    i = 0;\n    stop = 16;\n    type_probs = probs[type][0][0];\n    b_tokens = tokens;\n    dqf = factor[TOKEN_BLOCK_Y1];\n    goto BLOCK_LOOP;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (i == 16)\n{\n    type = 2;\n    type_probs = probs[type][0][0];\n    stop = 24;\n    dqf = factor[TOKEN_BLOCK_UV];\n    goto BLOCK_LOOP;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return eob_mask; }",
      "ja": "eob_maskを返します。}"
    },
    {
      "indent": 3,
      "text": "static void\nreset_row_context(token_entropy_ctx_t *left)\n{\n    memset(left, 0, sizeof(*left));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nreset_above_context(token_entropy_ctx_t *above, unsigned int cols)\n{\n    memset(above, 0, cols * sizeof(*above));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void\nreset_mb_context(token_entropy_ctx_t  *left,\n                 token_entropy_ctx_t  *above,\n                 enum prediction_mode  mode)\n{\n    /* Reset the macroblock context on the left and right.  We have\n     * to preserve the context of the second order block if this mode\n     * would not have updated it.\n     */\n    memset(left, 0, sizeof((*left)[0]) * 8);\n    memset(above, 0, sizeof((*above)[0]) * 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (mode != B_PRED && mode != SPLITMV)\n    {\n        (*left)[8] = 0;\n        (*above)[8] = 0;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,\n                             unsigned int            partition,\n                             unsigned int            row,\n                             unsigned int            start_col,\n                             unsigned int            num_cols)\n{\n    struct token_decoder *tokens = &ctx->tokens[partition];\n    short              coeffs = tokens->coeffs + 25 * 16 * start_col;\n    unsigned int       col;\n    token_entropy_ctx_t  *above = ctx->above_token_entropy_ctx\n                                  + start_col;\n    token_entropy_ctx_t  *left = &tokens->left_token_entropy_ctx;\n    struct mb_info       *mbi = ctx->mb_info_rows[row] + start_col;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (row == 0)\n    reset_above_context(above, num_cols);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (start_col == 0)\n    reset_row_context(left);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (col = start_col; col < start_col + num_cols; col++)\n{\n    memset(coeffs, 0, 25 * 16 * sizeof(short));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (mbi->base.skip_coeff)\n{\n    reset_mb_context(left, above, mbi->base.y_mode);\n    mbi->base.eob_mask = 0;\n}\nelse\n{\n    struct dequant_factors *dqf;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    dqf = ctx->dequant_factors  + mbi->base.segment_id;\n    mbi->base.eob_mask =\n        decode_mb_tokens(&tokens->bool,\n                         *left, *above,\n                         coeffs,\n                         mbi->base.y_mode,\n                         ctx->entropy_hdr.coeff_probs,\n                         dqf->factor);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        above++;\n        mbi++;\n        coeffs += 25 * 16;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_tokens_init(struct vp8_decoder_ctx *ctx)\n{\n    unsigned int  partitions = ctx->token_hdr.partitions;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (ctx->frame_hdr.frame_size_updated)\n{\n    unsigned int i;\n    unsigned int coeff_row_sz =\n        ctx->mb_cols * 25 * 16 * sizeof(short);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (i = 0; i < partitions; i++)\n{\n    free(ctx->tokens[i].coeffs);\n    ctx->tokens[i].coeffs = memalign(16, coeff_row_sz);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (!ctx->tokens[i].coeffs)\n        vpx_internal_error(&ctx->error, VPX_CODEC_MEM_ERROR,\n                           NULL);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "free(ctx->above_token_entropy_ctx);\nctx->above_token_entropy_ctx =\n    calloc(ctx->mb_cols,\n    sizeof(*ctx->above_token_entropy_ctx));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if (!ctx->above_token_entropy_ctx)\n            vpx_internal_error(&ctx->error,\n            VPX_CODEC_MEM_ERROR, NULL);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_tokens_destroy(struct vp8_decoder_ctx *ctx) { int i;",
      "ja": "void vp8_dixie_tokens_destroy（struct vp8_decoder_ctx *ctx）{int i;"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < MAX_PARTITIONS; i++)\n    free(ctx->tokens[i].coeffs);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    free(ctx->above_token_entropy_ctx);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.17. tokens.h",
      "section_title": true,
      "ja": "20.17. tokens.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */\n#ifndef TOKENS_H\n#define TOKENS_H",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_tokens_init(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_tokens_init（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "void vp8_dixie_tokens_destroy(struct vp8_decoder_ctx *ctx);",
      "ja": "void vp8_dixie_tokens_destroy（struct vp8_decoder_ctx *ctx）;"
    },
    {
      "indent": 3,
      "text": "void\nvp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,\n                             unsigned int            partition,\n                             unsigned int            row,\n                             unsigned int            start_col,\n                             unsigned int            num_cols);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.18. vp8_prob_data.h",
      "section_title": true,
      "ja": "20.18. VP8_PROB_DATA.H"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const\nunsigned char k_coeff_entropy_update_probs[BLOCK_TYPES][COEFF_BANDS]\n[PREV_COEFF_CONTEXTS]\n[ENTROPY_NODES] =\n{\n    {\n        {\n            {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n            {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n            {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        },\n        {\n            {176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n            {223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255},\n            {249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n        },\n        {\n            {255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255},\n            {234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n            {253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        },\n        {\n            {255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n            {239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n            {254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        },\n        {\n            {255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n            {251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n            {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    {\n        {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},\n        {250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},\n        {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n},\n{\n    {\n        {217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},\n        {234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255},\n    },\n    {\n        {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    {\n        {255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n        {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n},\n{\n    {\n        {186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255},\n        {234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255},\n        {251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255},\n    },\n    {\n        {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    {\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n},\n{\n    {\n        {248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255},\n        {248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n        {246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n        {252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255},\n        {248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n        {253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n        {252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},\n    },\n    {\n        {255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255},\n        {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n    },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        {\n            {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n            {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n            {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},\n        },\n    },\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const unsigned char k_default_y_mode_probs [] = { 112, 86, 140, 37};",
      "ja": "static const unsigned char k_default_y_mode_probs [] = {112、86、140、37};"
    },
    {
      "indent": 3,
      "text": "static const unsigned char k_default_uv_mode_probs [] = { 162, 101, 204};",
      "ja": "static const unsigned char k_default_uv_mode_probs [] = {162、101、204};"
    },
    {
      "indent": 3,
      "text": "static const\nunsigned char k_default_coeff_probs [BLOCK_TYPES][COEFF_BANDS]\n[PREV_COEFF_CONTEXTS][ENTROPY_NODES] =\n{\n    { /* block type 0 */\n        { /* coeff band 0 */\n            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},\n            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},\n            { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}\n        },\n        { /* coeff band 1 */\n            { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},\n            { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},\n            { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128}\n        },\n        { /* coeff band 2 */\n            {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},\n            { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},\n            {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128}\n        },\n        { /* coeff band 3 */\n            {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},\n            { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},\n            {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128}\n        },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    { /* coeff band 4 */\n        {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},\n        { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},\n        {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128}\n    },\n    { /* coeff band 5 */\n        {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},\n        { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},\n        { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128}\n    },\n    { /* coeff band 6 */\n        {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},\n        { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},\n        {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128}\n    },\n    { /* coeff band 7 */\n        {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n        { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n        { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}\n    }\n},\n{ /* block type 1 */\n    { /* coeff band 0 */\n        { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},\n        { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},\n        {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128}\n    },\n    { /* coeff band 1 */\n        {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},\n        { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},\n        {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128}\n    },\n    { /* coeff band 2 */\n        {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},\n        {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},\n        {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128}\n    },\n    { /* coeff band 3 */\n        {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},\n        { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},\n        {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128}\n    },\n    { /* coeff band 4 */\n        {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},\n        {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},\n        {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128}\n    },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    { /* coeff band 5 */\n        {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},\n        { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},\n        {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128}\n    },\n    { /* coeff band 6 */\n        {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},\n        { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},\n        {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128}\n    },\n    { /* coeff band 7 */\n        {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},\n        { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},\n        { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128}\n    }\n},\n{ /* block type 2 */\n    { /* coeff band 0 */\n        { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},\n        { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},\n        {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128}\n    },\n    { /* coeff band 1 */\n        {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},\n        { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},\n        { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128}\n    },\n    { /* coeff band 2 */\n        {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},\n        { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},\n        {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128}\n    },\n    { /* coeff band 3 */\n        {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},\n        { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},\n        { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128}\n    },\n    { /* coeff band 4 */\n        {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},\n        { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},\n        { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}\n    },\n    { /* coeff band 5 */\n        {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n        { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n        { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128}\n    },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    { /* coeff band 6 */\n        {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},\n        { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},\n        {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128}\n    },\n    { /* coeff band 7 */\n        { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},\n        { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},\n        { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}\n    }\n},\n{ /* block type 3 */\n    { /* coeff band 0 */\n        { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},\n        { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},\n        {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128}\n    },\n    { /* coeff band 1 */\n        {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},\n        { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},\n        {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128}\n    },\n    { /* coeff band 2 */\n        {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},\n        { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},\n        {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128}\n    },\n    { /* coeff band 3 */\n        {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},\n        { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},\n        {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128}\n    },\n    { /* coeff band 4 */\n        {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},\n        { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},\n        {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128}\n    },\n    { /* coeff band 5 */\n        {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},\n        { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},\n        {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128}\n    },\n    { /* coeff band 6 */\n        {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},\n        { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},\n        {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128}\n    },",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        { /* coeff band 7 */\n            {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n            { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},\n            { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}\n        }\n    }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const\nunsigned char k_mv_entropy_update_probs[2][MV_PROB_CNT] =\n{\n    {\n        237,\n        246,\n        253, 253, 254, 254, 254, 254, 254,\n        254, 254, 254, 254, 254, 250, 250, 252, 254, 254\n    },\n    {\n        231,\n        243,\n        245, 253, 254, 254, 254, 254, 254,\n        254, 254, 254, 254, 254, 251, 251, 254, 254, 254\n    }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static const\nunsigned char k_default_mv_probs[2][MV_PROB_CNT] =\n{\n    {                                                  // row\n        162,                                           // is short\n        128,                                           // sign\n        225, 146, 172, 147, 214,  39, 156,             // short tree\n        128, 129, 132,  75, 145, 178, 206, 239, 254, 254 // long bits\n    },\n    {\n        164,\n        128,\n        204, 170, 119, 235, 140, 230, 228,\n        128, 130, 130,  74, 148, 180, 203, 236, 254, 254",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " } };",
      "ja": "}};"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.19. vpx_codec_internal.h",
      "section_title": true,
      "ja": "20.19. vpx_codec_internal.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\file vpx_codec_internal.h\n * \\brief Describes the decoder algorithm interface for algorithm\n *        implementations.\n *\n * This file defines the private structures and data types that are\n * only relevant to implementing an algorithm, as opposed to using\n * it.\n *\n * To create a decoder algorithm class, an interface structure is put\n * into the global namespace:\n *     <pre>\n *     my_codec.c:\n *       vpx_codec_iface_t my_codec = {\n *           \"My Codec v1.0\",\n *           VPX_CODEC_ALG_ABI_VERSION,\n *           ...\n *       };\n *     </pre>\n *\n * An application instantiates a specific decoder instance by using\n * vpx_codec_init() and a pointer to the algorithm's interface\n * structure:\n *     <pre>\n *     my_app.c:\n *       extern vpx_codec_iface_t my_codec;\n *       {\n *           vpx_codec_ctx_t algo;\n *           res = vpx_codec_init(&algo, &my_codec);\n *       }\n *     </pre>\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " * Once initialized, the instance is managed using other functions\n * from the vpx_codec_* family.\n */\n#ifndef VPX_CODEC_INTERNAL_H\n#define VPX_CODEC_INTERNAL_H\n#include \"vpx_decoder.h\"\n#include <stdarg.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief Current ABI version number\n *\n * \\internal\n * If this file is altered in any way that changes the Application\n * Binary Interface (ABI), this value must be bumped.  Examples\n * include, but are not limited to, changing types, removing or\n * reassigning enums, adding/removing/rearranging fields to\n * structures.\n */\n#define VPX_CODEC_INTERNAL_ABI_VERSION (3)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef struct vpx_codec_alg_priv vpx_codec_alg_priv_t;",
      "ja": "typedef struct vpx_codec_alg_priv vpx_codec_alg_priv_t;"
    },
    {
      "indent": 3,
      "text": "/*!\\brief init function pointer prototype\n *\n * Performs algorithm-specific initialization of the decoder context.\n * This function is called by the generic vpx_codec_init() wrapper\n * function, so plugins implementing this interface may trust the\n * input parameters to be properly initialized.\n *\n * \\param[in] ctx   Pointer to this instance's context\n * \\retval #VPX_CODEC_OK\n *     The input stream was recognized and decoder initialized.\n * \\retval #VPX_CODEC_MEM_ERROR\n *     Memory operation failed.\n */\ntypedef vpx_codec_err_t (*vpx_codec_init_fn_t)(vpx_codec_ctx_t *ctx);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief destroy function pointer prototype\n *\n * Performs algorithm-specific destruction of the decoder context.\n * This function is called by the generic vpx_codec_destroy() wrapper\n * function, so plugins implementing this interface may trust the\n * input parameters to be properly initialized.\n *\n * \\param[in] ctx   Pointer to this instance's context\n * \\retval #VPX_CODEC_OK\n *     The input stream was recognized and decoder initialized.\n * \\retval #VPX_CODEC_MEM_ERROR\n *     Memory operation failed.\n */\ntypedef vpx_codec_err_t (*vpx_codec_destroy_fn_t)(\n    vpx_codec_alg_priv_t *ctx);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief parse stream info function pointer prototype\n *\n * Performs high level parsing of the bitstream.  This function is\n * called by the generic vpx_codec_parse_stream() wrapper function,\n * so plugins implementing this interface may trust the input\n * parameters to be properly initialized.\n *\n * \\param[in]      data    Pointer to a block of data to parse\n * \\param[in]      data_sz Size of the data buffer\n * \\param[in,out]  si      Pointer to stream info to update.  The\n *                         size member \\ref MUST be properly\n *                         initialized, but \\ref MAY be clobbered by\n *                         the algorithm.  This parameter \\ref MAY\n *                         be NULL.\n *\n * \\retval #VPX_CODEC_OK\n *     Bitstream is parsable and stream information updated\n */\ntypedef vpx_codec_err_t (*vpx_codec_peek_si_fn_t)(\n    const uint8_t         *data,\n    unsigned int           data_sz,\n    vpx_codec_stream_info_t *si);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief Return information about the current stream.\n *\n * Returns information about the stream that has been parsed during\n * decoding.\n *\n * \\param[in]      ctx     Pointer to this instance's context\n * \\param[in,out]  si      Pointer to stream info to update.  The\n *                         size member \\ref MUST be properly\n *                         initialized, but \\ref MAY be clobbered by\n *                         the algorithm.  This parameter \\ref MAY\n *                         be NULL.\n *\n * \\retval #VPX_CODEC_OK\n *     Bitstream is parsable and stream information updated\n */\ntypedef vpx_codec_err_t (*vpx_codec_get_si_fn_t)(\n    vpx_codec_alg_priv_t    *ctx,\n    vpx_codec_stream_info_t *si);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief control function pointer prototype\n *\n * This function is used to exchange algorithm-specific data with the\n * decoder instance.  This can be used to implement features specific\n * to a particular algorithm.\n *\n * This function is called by the generic vpx_codec_control() wrapper\n * function, so plugins implementing this interface may trust the\n * input parameters to be properly initialized.  However, this\n * interface does not provide type safety for the exchanged data or\n * assign meanings to the control codes.  Those details should be\n * specified in the algorithm's header file.  In particular, the\n * ctrl_id parameter is guaranteed to exist in the algorithm's\n * control mapping table, and the data parameter may be NULL.\n *\n *\n * \\param[in]     ctx       Pointer to this instance's context\n * \\param[in]     ctrl_id   Algorithm-specific control identifier\n * \\param[in,out] data      Data to exchange with algorithm instance.\n *\n * \\retval #VPX_CODEC_OK\n *     The internal state data was deserialized.\n */\ntypedef vpx_codec_err_t (*vpx_codec_control_fn_t)(\n    vpx_codec_alg_priv_t  *ctx,\n    int                   ctrl_id,\n    va_list               ap);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief control function pointer mapping\n *\n * This structure stores the mapping between control identifiers and\n * implementing functions.  Each algorithm provides a list of these\n * mappings.  This list is searched by the vpx_codec_control()\n * wrapper function to determine which function to invoke.  The\n * special value {0, NULL} is used to indicate end-of-list, and must\n * be present.  The special value {0, <non-null>} can be used as a\n * catch-all mapping.  This implies that ctrl_id values chosen by the\n * algorithm \\ref MUST be non-zero.\n */\ntypedef const struct\n{\n    int                    ctrl_id;\n    vpx_codec_control_fn_t   fn;\n} vpx_codec_ctrl_fn_map_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief decode data function pointer prototype\n *\n * Processes a buffer of coded data.  If the processing results in a\n * new decoded frame becoming available, #VPX_CODEC_CB_PUT_SLICE and\n * #VPX_CODEC_CB_PUT_FRAME events are generated as appropriate.\n * This function is called by the generic vpx_codec_decode() wrapper\n * function, so plugins implementing this interface may trust the\n * input parameters to be properly initialized.\n *\n * \\param[in] ctx         Pointer to this instance's context\n * \\param[in] data        Pointer to this block of new coded data.\n *                        If NULL, a #VPX_CODEC_CB_PUT_FRAME event is\n *                        posted for the previously decoded frame.\n * \\param[in] data_sz     Size of the coded data, in bytes.\n *\n * \\return Returns #VPX_CODEC_OK if the coded data was processed\n *         completely and future pictures can be decoded without\n *         error.  Otherwise, see the descriptions of the other error\n *         codes in ::vpx_codec_err_t for recoverability\n *         capabilities.\n */\ntypedef vpx_codec_err_t (*vpx_codec_decode_fn_t)(\n    vpx_codec_alg_priv_t  *ctx,\n    const uint8_t         *data,\n    unsigned int     data_sz,\n    void        *user_priv,\n    long         deadline);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief Decoded frames iterator\n *\n * Iterates over a list of the frames available for display.  The\n * iterator storage should be initialized to NULL to start the\n * iteration.  Iteration is complete when this function returns NULL.\n *\n * The list of available frames becomes valid upon completion of the\n * vpx_codec_decode call, and remains valid until the next call to\n * vpx_codec_decode.\n *\n * \\param[in]     ctx      Pointer to this instance's context\n * \\param[in out] iter     Iterator storage, initialized to NULL\n *\n * \\return Returns a pointer to an image, if one is ready for\n *         display.  Frames produced will always be in PTS\n *         (presentation time stamp) order.\n */\ntypedef vpx_image_t*(*vpx_codec_get_frame_fn_t)(\n    vpx_codec_alg_priv_t *ctx,\n    vpx_codec_iter_t     *iter);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\\brief External Memory Allocation memory map get iterator\n *\n * Iterates over a list of the memory maps requested by the decoder.\n * The iterator storage should be initialized to NULL to start the\n * iteration.  Iteration is complete when this function returns NULL.\n *\n * \\param[in out] iter     Iterator storage, initialized to NULL\n *\n * \\return Returns a pointer to a memory segment descriptor, or NULL\n *         to indicate end-of-list.\n */\ntypedef vpx_codec_err_t (*vpx_codec_get_mmap_fn_t)(\n    const vpx_codec_ctx_t      *ctx,\n    vpx_codec_mmap_t           *mmap,\n    vpx_codec_iter_t           *iter);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\\brief External Memory Allocation memory map set iterator\n *\n * Sets a memory descriptor inside the decoder instance.\n *\n * \\param[in] ctx      Pointer to this instance's context\n * \\param[in] mmap     Memory map to store.\n *\n * \\retval #VPX_CODEC_OK\n *     The memory map was accepted and stored.\n * \\retval #VPX_CODEC_MEM_ERROR\n *     The memory map was rejected.\n */\ntypedef vpx_codec_err_t (*vpx_codec_set_mmap_fn_t)(\n    vpx_codec_ctx_t         *ctx,\n    const vpx_codec_mmap_t  *mmap);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef vpx_codec_err_t (*vpx_codec_encode_fn_t)(\n    vpx_codec_alg_priv_t  *ctx,\n    const vpx_image_t     *img,\n    vpx_codec_pts_t        pts,\n    unsigned long          duration,\n    vpx_enc_frame_flags_t  flags,\n    unsigned long          deadline);\ntypedef const vpx_codec_cx_pkt_t*(*vpx_codec_get_cx_data_fn_t)(\n    vpx_codec_alg_priv_t *ctx,\n    vpx_codec_iter_t     *iter);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef vpx_codec_err_t\n(*vpx_codec_enc_config_set_fn_t)(\n    vpx_codec_alg_priv_t       *ctx,\n    const vpx_codec_enc_cfg_t  *cfg);\ntypedef vpx_fixed_buf_t *\n(*vpx_codec_get_global_headers_fn_t)(vpx_codec_alg_priv_t   *ctx);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "typedef vpx_image_t *\n(*vpx_codec_get_preview_frame_fn_t)(vpx_codec_alg_priv_t   *ctx);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief usage configuration mapping\n *\n * This structure stores the mapping between usage identifiers and\n * configuration structures.  Each algorithm provides a list of these\n * mappings.  This list is searched by the\n * vpx_codec_enc_config_default() wrapper function to determine which",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " * config to return.  The special value {-1, {0}} is used to indicate\n * end-of-list, and must be present.  At least one mapping must be\n * present, in addition to the end-of-list.\n *\n */\ntypedef const struct\n{\n    int                 usage;\n    vpx_codec_enc_cfg_t cfg;\n} vpx_codec_enc_cfg_map_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define NOT_IMPLEMENTED 0",
      "ja": "#define not_implemented 0"
    },
    {
      "indent": 3,
      "text": "/*!\\brief Decoder algorithm interface\n *\n * All decoders \\ref MUST expose a variable of this type.\n */\nstruct vpx_codec_iface\n{\n    const char               *name;\n    int                       abi_version;\n    vpx_codec_caps_t          caps;\n    vpx_codec_init_fn_t       init;\n    vpx_codec_destroy_fn_t    destroy;\n    vpx_codec_ctrl_fn_map_t  *ctrl_maps;\n    vpx_codec_get_mmap_fn_t   get_mmap;\n    vpx_codec_set_mmap_fn_t   set_mmap;\n    struct\n    {\n        vpx_codec_peek_si_fn_t    peek_si;\n        vpx_codec_get_si_fn_t     get_si;\n        vpx_codec_decode_fn_t     decode;\n        vpx_codec_get_frame_fn_t  get_frame;\n    } dec;\n    struct\n    {\n        vpx_codec_enc_cfg_map_t           *cfg_maps;\n        vpx_codec_encode_fn_t              encode;\n        vpx_codec_get_cx_data_fn_t         get_cx_data;\n        vpx_codec_enc_config_set_fn_t      cfg_set;\n        vpx_codec_get_global_headers_fn_t  get_glob_hdrs;\n        vpx_codec_get_preview_frame_fn_t   get_preview;\n    } enc;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief Callback function pointer / user data pair storage */\ntypedef struct vpx_codec_priv_cb_pair\n{\n    union\n    {\n        vpx_codec_put_frame_cb_fn_t    put_frame;\n        vpx_codec_put_slice_cb_fn_t    put_slice;\n    };\n    void                            *user_priv;\n} vpx_codec_priv_cb_pair_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\brief Instance private storage\n *\n * This structure is allocated by the algorithm's init function.  It\n * can be extended in one of two ways.  First, a second, algorithm\n * specific structure can be allocated and the priv member pointed to\n * it.  Alternatively, this structure can be made the first member of\n * the algorithm-specific structure, and the pointer casted to the\n * proper type.\n */\nstruct vpx_codec_priv\n{\n    unsigned int                    sz;\n    vpx_codec_iface_t              *iface;\n    struct vpx_codec_alg_priv      *alg_priv;\n    const char                     *err_detail;\n    vpx_codec_flags_t               init_flags;\n    struct\n    {\n        vpx_codec_priv_cb_pair_t    put_frame_cb;\n        vpx_codec_priv_cb_pair_t    put_slice_cb;\n    } dec;\n    struct\n    {\n        struct vpx_fixed_buf        cx_data_dst_buf;\n        unsigned int                cx_data_pad_before;\n        unsigned int                cx_data_pad_after;\n        vpx_codec_cx_pkt_t          cx_data_pkt;\n    } enc;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#undef VPX_CTRL_USE_TYPE\n#define VPX_CTRL_USE_TYPE(id, typ) \\\n    static typ id##__value(va_list args) \\\n    {return va_arg(args, typ);} \\\n    static typ id##__convert(void *x)\\\n    {\\",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    union\\\n    {\\\n        void *x;\\\n        typ   d;\\\n    } u;\\\n    u.x = x;\\\n    return u.d;\\\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#undef VPX_CTRL_USE_TYPE_DEPRECATED\n#define VPX_CTRL_USE_TYPE_DEPRECATED(id, typ) \\\n    static typ id##__value(va_list args) \\\n    {return va_arg(args, typ);} \\\n    static typ id##__convert(void *x)\\\n    {\\\n        union\\\n        {\\\n            void *x;\\\n            typ   d;\\\n        } u;\\\n        u.x = x;\\\n        return u.d;\\\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define CAST(id, arg) id##__value(arg)\n#define RECAST(id, x) id##__convert(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Internal Utility Functions\n *\n * The following functions are intended to be used inside algorithms\n * as utilities for manipulating vpx_codec_* data structures.\n */\nstruct vpx_codec_pkt_list\n{\n    unsigned int            cnt;\n    unsigned int            max;\n    struct vpx_codec_cx_pkt pkts[1];\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define vpx_codec_pkt_list_decl(n)\\\n    union {struct vpx_codec_pkt_list head;\\\n        struct {struct vpx_codec_pkt_list head;\\\n            struct vpx_codec_cx_pkt    pkts[n];} alloc;}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define vpx_codec_pkt_list_init(m)\\\n    (m)->alloc.head.cnt = 0,\\\n    (m)->alloc.head.max = \\\n    sizeof((m)->alloc.pkts) / sizeof((m)->alloc.pkts[0])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int vpx_codec_pkt_list_add(struct vpx_codec_pkt_list *, const struct vpx_codec_cx_pkt *);",
      "ja": "int vpx_codec_pkt_list_add（struct vpx_codec_pkt_list *、const struct vpx_codec_cx_pkt *）;"
    },
    {
      "indent": 3,
      "text": "const vpx_codec_cx_pkt_t*\nvpx_codec_pkt_list_get(struct vpx_codec_pkt_list *list,\n                       vpx_codec_iter_t           *iter);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <stdio.h>\n#include <setjmp.h>\nstruct vpx_internal_error_info\n{\n    vpx_codec_err_t  error_code;\n    int              has_detail;\n    char             detail[80];\n    int              setjmp;\n    jmp_buf          jmp;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static void vpx_internal_error(struct vpx_internal_error_info *info, vpx_codec_err_t error, const char *fmt, ...) { va_list ap;",
      "ja": "static void vpx_internal_error（struct vpx_internal_error_info *info、vpx_codec_err_tエラー、const char *fmt、...）{va_list ap;"
    },
    {
      "indent": 7,
      "text": "info->error_code = error;\ninfo->has_detail = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (fmt)\n{\n    size_t  sz = sizeof(info->detail);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    info->has_detail = 1;\n    va_start(ap, fmt);\n    vsnprintf(info->detail, sz - 1, fmt, ap);\n    va_end(ap);\n    info->detail[sz-1] = '\\0';\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (info->setjmp)\n        longjmp(info->jmp, info->error_code);\n}\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.20. vpx_decoder.h",
      "section_title": true,
      "ja": "20.20. vpx_decoder.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\defgroup decoder Decoder Algorithm Interface\n * \\ingroup codec\n * This abstraction allows applications using this decoder to easily\n * support multiple video formats with minimal code duplication.\n * This section describes the interface common to all decoders.\n * @{\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\file vpx_decoder.h\n * \\brief Describes the decoder algorithm interface to applications.\n *\n * This file describes the interface between an application and a\n * video decoder algorithm.\n *\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#ifndef VPX_DECODER_H\n#define VPX_DECODER_H\n#include \"vpx_codec.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*!\\brief Current ABI version number\n     *\n     * \\internal\n     * If this file is altered in any way that changes the ABI, this\n     * value must be bumped.  Examples include, but are not limited\n     * to, changing types, removing or reassigning enums,\n     * adding/removing/rearranging fields to structures\n     */\n#define VPX_DECODER_ABI_VERSION (2 + VPX_CODEC_ABI_VERSION)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*! \\brief Decoder capabilities bitfield\n     *\n     *  Each decoder advertises the capabilities it supports as part\n     *  of its ::vpx_codec_iface_t interface structure.  Capabilities\n     *  are extra interfaces or functionality, and are not required\n     *  to be supported by a decoder.\n     *\n     *  The available flags are specified by VPX_CODEC_CAP_* defines.\n     */\n#define VPX_CODEC_CAP_PUT_SLICE  0x10000 /**< Will issue put_slice\n    callbacks */\n#define VPX_CODEC_CAP_PUT_FRAME  0x20000 /**< Will issue put_frame\n    callbacks */\n#define VPX_CODEC_CAP_POSTPROC   0x40000 /**< Can postprocess decoded\n    frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*! \\brief Initialization-time Feature Enabling\n     *\n     *  Certain codec features must be known at initialization time,\n     *  to allow for proper memory allocation.\n     *\n     *  The available flags are specified by VPX_CODEC_USE_* defines.\n     */\n#define VPX_CODEC_USE_POSTPROC   0x10000 /**< Postprocess decoded\n    frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Stream properties\n *\n * This structure is used to query or set properties of the\n * decoded stream.  Algorithms may extend this structure with\n * data specific to their bitstream by setting the sz member\n * appropriately.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "typedef struct vpx_codec_stream_info\n{\n    unsigned int sz;    /**< Size of this structure */\n    unsigned int w;     /**< Width (or 0 for unknown/default) */\n    unsigned int h;     /**< Height (or 0 for unknown/default) */\n    unsigned int is_kf; /**< Current frame is a keyframe */\n} vpx_codec_stream_info_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* REQUIRED FUNCTIONS\n *\n * The following functions are required to be implemented for all\n * decoders.  They represent the base case functionality expected\n * of all decoders.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Initialization Configurations\n *\n * This structure is used to pass init time configuration options\n * to the decoder.\n */\ntypedef struct vpx_codec_dec_cfg\n{\n    unsigned int threads; /**< Maximum number of threads to use,\n        default 1 */\n    unsigned int w;      /**< Width */\n    unsigned int h;      /**< Height */\n} vpx_codec_dec_cfg_t; /**< alias for struct vpx_codec_dec_cfg */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Initialize a decoder instance\n *\n * Initializes a decoder context using the given interface.\n * Applications should call the vpx_codec_dec_init convenience\n * macro instead of this function directly, to ensure that the\n * ABI version number parameter is properly initialized.\n *\n * In XMA mode (activated by setting VPX_CODEC_USE_XMA in the\n * flags parameter), the storage pointed to by the cfg parameter\n * must be kept readable and stable until all memory maps have\n * been set.\n *\n * \\param[in]    ctx     Pointer to this instance's context.\n * \\param[in]    iface   Pointer to the algorithm interface to\n *                       use.\n * \\param[in]    cfg     Configuration to use, if known.  May be\n *                       NULL.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " * \\param[in]    flags   Bitfield of VPX_CODEC_USE_* flags\n * \\param[in]    ver     ABI version number.  Must be set to\n *                       VPX_DECODER_ABI_VERSION\n * \\retval #VPX_CODEC_OK\n *     The decoder algorithm initialized.\n * \\retval #VPX_CODEC_MEM_ERROR\n *     Memory allocation failed.\n */\nvpx_codec_err_t vpx_codec_dec_init_ver(\n    vpx_codec_ctx_t      *ctx,\n    vpx_codec_iface_t    *iface,\n    vpx_codec_dec_cfg_t  *cfg,\n    vpx_codec_flags_t     flags,\n    int                   ver);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*!\\brief Convenience macro for vpx_codec_dec_init_ver()\n     *\n     * Ensures the ABI version parameter is properly set.\n     */\n#define vpx_codec_dec_init(ctx, iface, cfg, flags) \\\n    vpx_codec_dec_init_ver(ctx, iface, cfg, flags, \\\n    VPX_DECODER_ABI_VERSION)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Parse stream info from a buffer\n *\n * Performs high level parsing of the bitstream.  Construction of\n * a decoder context is not necessary.  Can be used to determine\n * if the bitstream is of the proper format, and to extract\n * information from the stream.\n *\n * \\param[in]      iface   Pointer to the algorithm interface\n * \\param[in]      data    Pointer to a block of data to parse\n * \\param[in]      data_sz Size of the data buffer\n * \\param[in,out]  si      Pointer to stream info to update.  The\n *                         size member\n *                         \\ref MUST be properly initialized, but\n *                         \\ref MAY be clobbered by the\n *                         algorithm.  This parameter \\ref MAY be\n *                         NULL.\n *\n * \\retval #VPX_CODEC_OK\n *     Bitstream is parsable and stream information updated\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "vpx_codec_err_t vpx_codec_peek_stream_info( vpx_codec_iface_t *iface, const uint8_t *data, unsigned int data_sz, vpx_codec_stream_info_t *si);",
      "ja": "vpx_codec_err_t vpx_codec_peek_stream_info（vpx_codec_iface_t *iface、const uint8_t *data、unsigned int data_sz、vpx_codec_stream_info_t *si）;"
    },
    {
      "indent": 7,
      "text": "/*!\\brief Return information about the current stream.\n *\n * Returns information about the stream that has been parsed\n * during decoding.\n *\n * \\param[in]      ctx     Pointer to this instance's context\n * \\param[in,out]  si      Pointer to stream info to update.  The\n *                         size member \\ref MUST be properly\n *                         initialized, but \\ref MAY be clobbered\n *                         by the algorithm.  This parameter \\ref\n *                         MAY be NULL.\n *\n * \\retval #VPX_CODEC_OK\n *     Bitstream is parsable and stream information updated\n */\nvpx_codec_err_t vpx_codec_get_stream_info(\n    vpx_codec_ctx_t         *ctx,\n    vpx_codec_stream_info_t *si);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Decode data\n *\n * Processes a buffer of coded data.  If the processing results\n * in a new decoded frame becoming available, PUT_SLICE and\n * PUT_FRAME events may be generated, as appropriate.  Encoded\n * data \\ref MUST be passed in DTS (decode time stamp) order.\n * Frames produced will always be in PTS (presentation time\n * stamp) order.\n *\n * \\param[in] ctx          Pointer to this instance's context\n * \\param[in] data         Pointer to this block of new coded\n *                         data.  If NULL, a\n *                         VPX_CODEC_CB_PUT_FRAME event is posted\n *                         for the previously decoded frame.\n * \\param[in] data_sz      Size of the coded data, in bytes.\n * \\param[in] user_priv    Application-specific data to associate\n *                         with this frame.\n * \\param[in] deadline     Soft deadline the decoder should\n *                         attempt to meet, in us.  Set to zero\n *                         for unlimited.\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " * \\return Returns #VPX_CODEC_OK if the coded data was processed\n *         completely and future pictures can be decoded without\n *         error.  Otherwise, see the descriptions of the other\n *         error codes in ::vpx_codec_err_t for recoverability\n *         capabilities.\n */\nvpx_codec_err_t vpx_codec_decode(vpx_codec_ctx_t    *ctx,\n                                 const uint8_t        *data,\n                                 unsigned int            data_sz,\n                                 void               *user_priv,\n                                 long                deadline);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Decoded frames iterator\n *\n * Iterates over a list of the frames available for display.  The\n * iterator storage should be initialized to NULL to start the\n * iteration.  Iteration is complete when this function returns\n * NULL.\n *\n * The list of available frames becomes valid upon completion of\n * the vpx_codec_decode call, and remains valid until the next\n * call to vpx_codec_decode.\n *\n * \\param[in]     ctx      Pointer to this instance's context\n * \\param[in,out] iter     Iterator storage, initialized to NULL\n *\n * \\return Returns a pointer to an image, if one is ready for\n *         display.  Frames produced will always be in PTS\n *         (presentation time stamp) order.\n */\nvpx_image_t *vpx_codec_get_frame(vpx_codec_ctx_t  *ctx,\n                                 vpx_codec_iter_t *iter);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\defgroup cap_put_frame Frame-Based Decoding Functions\n *\n * The following functions are required to be implemented for all\n * decoders that advertise the VPX_CODEC_CAP_PUT_FRAME\n * capability.  Calling these functions for codecs that don't\n * advertise this capability will result in an error code being\n * returned, usually VPX_CODEC_ERROR\n * @{\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief put frame callback prototype\n *\n * This callback is invoked by the decoder to notify the\n * application of the availability of decoded image data.\n */\ntypedef void (*vpx_codec_put_frame_cb_fn_t)(\n    void        *user_priv,\n    const vpx_image_t *img);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Register for notification of frame completion.\n *\n * Registers a given function to be called when a decoded frame\n * is available.\n *\n * \\param[in] ctx          Pointer to this instance's context\n * \\param[in] cb           Pointer to the callback function\n * \\param[in] user_priv    User's private data\n *\n * \\retval #VPX_CODEC_OK\n *     Callback successfully registered.\n * \\retval #VPX_CODEC_ERROR\n *     Decoder context not initialized, or algorithm not capable\n *     of posting slice completion.\n */\nvpx_codec_err_t vpx_codec_register_put_frame_cb(\n    vpx_codec_ctx_t             *ctx,\n    vpx_codec_put_frame_cb_fn_t  cb,\n    void                        *user_priv);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!@} - end defgroup cap_put_frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\defgroup cap_put_slice Slice-Based Decoding Functions\n *\n * The following functions are required to be implemented for all\n * decoders that advertise the VPX_CODEC_CAP_PUT_SLICE\n * capability.  Calling these functions for codecs that don't\n * advertise this capability will result in an error code being\n * returned, usually VPX_CODEC_ERROR\n * @{\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief put slice callback prototype\n *\n * This callback is invoked by the decoder to notify the\n * application of the availability of partially decoded image\n * data.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "typedef void (*vpx_codec_put_slice_cb_fn_t)(\n    void         *user_priv,\n    const vpx_image_t      *img,\n    const vpx_image_rect_t *valid,\n    const vpx_image_rect_t *update);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Register for notification of slice completion.\n *\n * Registers a given function to be called when a decoded slice\n * is available.\n *\n * \\param[in] ctx          Pointer to this instance's context\n * \\param[in] cb           Pointer to the callback function\n * \\param[in] user_priv    User's private data\n *\n * \\retval #VPX_CODEC_OK\n *     Callback successfully registered.\n * \\retval #VPX_CODEC_ERROR\n *     Decoder context not initialized, or algorithm not capable\n *     of posting slice completion.\n */\nvpx_codec_err_t vpx_codec_register_put_slice_cb(\n    vpx_codec_ctx_t             *ctx,\n    vpx_codec_put_slice_cb_fn_t  cb,\n    void                        *user_priv);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!@} - end defgroup cap_put_slice*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!@} - end defgroup decoder*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "#ifdef __cplusplus } #endif",
      "ja": "#ifdef __cplusplus} #endif"
    },
    {
      "indent": 3,
      "text": "#if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT\n#include \"vpx_decoder_compat.h\"\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.21. vpx_decoder_compat.h",
      "section_title": true,
      "ja": "20.21. vpx_decoder_compat.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n * Use of this source code is governed by a BSD-style license\n * that can be found in the LICENSE file in the root of the source\n * tree.  An additional intellectual property rights grant can be\n * found in the file PATENTS.  All contributing project authors may\n * be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\defgroup decoder Common Decoder Algorithm Interface\n * This abstraction allows applications using this decoder to easily\n * support multiple video formats with minimal code duplication.\n * This section describes the interface common to all codecs.\n * @{\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\file\n * \\brief Provides a compatibility layer between version 1 and 2 of\n * this API.\n *\n * This interface has been deprecated.  Only existing code should\n * make use of this interface, and therefore, it is only thinly\n * documented.  Existing code should be ported to the vpx_codec_*\n * API.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef VPX_DECODER_COMPAT_H #define VPX_DECODER_COMPAT_H",
      "ja": "#ifndef vpx_decoder_compat_h #define vpx_decoder_compat_h"
    },
    {
      "indent": 7,
      "text": "/*!\\brief Decoder algorithm return codes */\ntypedef enum {\n    /*!\\brief Operation completed without error */\n    VPX_DEC_OK = VPX_CODEC_OK,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*!\\brief Unspecified error */\nVPX_DEC_ERROR = VPX_CODEC_ERROR,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*!\\brief Memory operation failed */\nVPX_DEC_MEM_ERROR = VPX_CODEC_MEM_ERROR,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*!\\brief ABI version mismatch */\nVPX_DEC_ABI_MISMATCH = VPX_CODEC_ABI_MISMATCH,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*!\\brief The given bitstream is not supported.\n *\n * The bitstream was unable to be parsed at the highest\n * level.  The decoder is unable to proceed.  This error \\ref\n * SHOULD be treated as fatal to the stream.\n */\nVPX_DEC_UNSUP_BITSTREAM = VPX_CODEC_UNSUP_BITSTREAM,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*!\\brief Encoded bitstream uses an unsupported feature\n *\n * The decoder does not implement a feature required by the\n * encoder.  This return code should only be used for\n * features that prevent future pictures from being properly\n * decoded.  This error \\ref MAY be treated as fatal to the\n * stream or \\ref MAY be treated as fatal to the current\n * Group of Pictures (GOP).\n */\nVPX_DEC_UNSUP_FEATURE = VPX_CODEC_UNSUP_FEATURE,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*!\\brief The coded data for this stream is corrupt or\n * incomplete\n *\n * There was a problem decoding the current frame.  This\n * return code should only be used for failures that prevent\n * future pictures from being properly decoded.  This error\n * \\ref MAY be treated as fatal to the stream or \\ref MAY be\n * treated as fatal to the current GOP.  If decoding is\n * continued for the current GOP, artifacts may be present.\n */\nVPX_DEC_CORRUPT_FRAME = VPX_CODEC_CORRUPT_FRAME,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*!\\brief An application-supplied parameter is not valid.\n *\n */\nVPX_DEC_INVALID_PARAM = VPX_CODEC_INVALID_PARAM,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/*!\\brief An iterator reached the end of list.\n *\n */\nVPX_DEC_LIST_END = VPX_CODEC_LIST_END",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "} vpx_dec_err_t;",
      "ja": "} vpx_dec_err_t;"
    },
    {
      "indent": 3,
      "text": "    /*! \\brief Decoder capabilities bitfield\n     *\n     *  Each decoder advertises the capabilities it supports as part\n     *  of its ::vpx_dec_iface_t interface structure.  Capabilities\n     *  are extra interfaces or functionality, and are not required\n     *  to be supported by a decoder.\n     *\n     *  The available flags are specified by VPX_DEC_CAP_* defines.\n     */\n    typedef int vpx_dec_caps_t;\n#define VPX_DEC_CAP_PUT_SLICE  0x0001 /**< Will issue put_slice\n                                         callbacks */\n#define VPX_DEC_CAP_PUT_FRAME  0x0002 /**< Will issue put_frame\n                                         callbacks */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define VPX_DEC_CAP_XMA        0x0004 /**< Supports External Memory\n                                         Allocation */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*!\\brief Stream properties\n     *\n     * This structure is used to query or set properties of the\n     * decoded stream.  Algorithms may extend this structure with\n     * data specific to their bitstream by setting the sz member\n     * appropriately.\n     */\n#if 1\n    typedef vpx_codec_stream_info_t vpx_dec_stream_info_t;\n#else\n    typedef struct\n    {\n        unsigned int sz;    /**< Size of this structure */\n        unsigned int w;     /**< Width (or 0 for unknown/default) */\n        unsigned int h;     /**< Height (or 0 for unknown/default) */\n        unsigned int is_kf; /**< Current frame is a keyframe */\n    } vpx_dec_stream_info_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 7,
      "text": "/*!\\brief Decoder interface structure.\n *\n * Contains function pointers and other data private to the\n * decoder implementation.  This structure is opaque to the\n * application.\n */\ntypedef const struct vpx_codec_iface vpx_dec_iface_t;\ntypedef       struct vpx_codec_priv  vpx_dec_priv_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Iterator\n *\n * Opaque storage used for iterating over lists.\n */\ntypedef vpx_codec_iter_t vpx_dec_iter_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*!\\brief Decoder context structure\n     *\n     * All decoders \\ref MUST support this context structure fully.\n     * In general, this data should be considered private to the\n     * decoder algorithm, and not be manipulated or examined by the\n     * calling application.  Applications may reference the 'name'\n     * member to get a printable description of the algorithm.\n     */\n#if 1\n    typedef vpx_codec_ctx_t vpx_dec_ctx_t;\n#else\n    typedef struct\n    {\n        const char          *name;  /**< Printable interface name */\n        vpx_dec_iface_t     *iface; /**< Interface pointers */\n        vpx_dec_err_t        err;   /**< Last returned error */\n        vpx_dec_priv_t      *priv;  /**< Algorithm private storage */\n    } vpx_dec_ctx_t;\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Return the build configuration\n *\n * Returns a printable string containing an encoded version of\n * the build configuration.  This may be useful to vpx support.\n *\n */\nconst char *vpx_dec_build_config(void) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Return the name for a given interface\n *\n * Returns a human readable string for name of the given decoder\n * interface.\n *\n * \\param[in]    iface     Interface pointer\n *\n */\nconst char *vpx_dec_iface_name(\n    vpx_dec_iface_t *iface) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Convert error number to printable string\n *\n * Returns a human readable string for the last error returned\n * by the algorithm.  The returned error will be one line and\n * will not contain any newline characters.\n *\n *\n * \\param[in]    err     Error number.\n *\n */\nconst char *vpx_dec_err_to_string(vpx_dec_err_t  err) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Retrieve error synopsis for decoder context\n *\n * Returns a human readable string for the last error returned by\n * the algorithm.  The returned error will be one line and will\n * not contain any newline characters.\n *\n *\n * \\param[in]    ctx     Pointer to this instance's context.\n *\n */\nconst char *vpx_dec_error(vpx_dec_ctx_t  *ctx) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Retrieve detailed error information for decoder context\n *\n * Returns a human readable string providing detailed information\n * about the last error.\n *\n * \\param[in]    ctx     Pointer to this instance's context.\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " * \\retval NULL\n *     No detailed information is available.\n */\nconst char *vpx_dec_error_detail(vpx_dec_ctx_t  *ctx) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* REQUIRED FUNCTIONS\n *\n * The following functions are required to be implemented for all\n * decoders.  They represent the base case functionality expected\n * of all decoders.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Initialize a decoder instance\n *\n * Initializes a decoder context using the given interface.\n * Applications should call the vpx_dec_init convenience macro\n * instead of this function directly, to ensure that the ABI\n * version number parameter is properly initialized.\n *\n * \\param[in]   ctx    Pointer to this instance's context.\n * \\param[in]   iface  Pointer to the algorithm interface to use.\n * \\param[in]   ver    ABI version number.  Must be set to\n *                       VPX_DECODER_ABI_VERSION\n * \\retval #VPX_DEC_OK\n *     The decoder algorithm initialized.\n * \\retval #VPX_DEC_MEM_ERROR\n *     Memory allocation failed.\n */\nvpx_dec_err_t vpx_dec_init_ver(\n    vpx_dec_ctx_t    *ctx,\n    vpx_dec_iface_t  *iface,\n    int               ver) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define vpx_dec_init(ctx, iface) \\ vpx_dec_init_ver(ctx, iface, VPX_DECODER_ABI_VERSION)",
      "ja": "#define vpx_dec_init（ctx、iface）\\ vpx_dec_init_ver（ctx、iface、vpx_decoder_abi_version）"
    },
    {
      "indent": 7,
      "text": "/*!\\brief Destroy a decoder instance\n *\n * Destroys a decoder context, freeing any associated memory\n * buffers.\n *\n * \\param[in] ctx   Pointer to this instance's context\n *\n * \\retval #VPX_DEC_OK\n *     The decoder algorithm initialized.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " * \\retval #VPX_DEC_MEM_ERROR\n *     Memory allocation failed.\n */\nvpx_dec_err_t vpx_dec_destroy(vpx_dec_ctx_t *ctx) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Get the capabilities of an algorithm.\n *\n * Retrieves the capabilities bitfield from the algorithm's\n * interface.\n *\n * \\param[in] iface   Pointer to the algorithm interface\n *\n */\nvpx_dec_caps_t vpx_dec_get_caps(\n    vpx_dec_iface_t *iface) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Parse stream info from a buffer\n *\n * Performs high level parsing of the bitstream.  Construction of\n * a decoder context is not necessary.  Can be used to determine\n * if the bitstream is of the proper format, and to extract\n * information from the stream.\n *\n * \\param[in]      iface   Pointer to the algorithm interface\n * \\param[in]      data    Pointer to a block of data to parse\n * \\param[in]      data_sz Size of the data buffer\n * \\param[in,out]  si      Pointer to stream info to update.  The\n *                         size member \\ref MUST be properly\n *                         initialized, but \\ref MAY be\n *                         clobbered by the algorithm.  This\n *                         parameter \\ref MAY be NULL.\n *\n * \\retval #VPX_DEC_OK\n *     Bitstream is parsable and stream information updated\n */\nvpx_dec_err_t vpx_dec_peek_stream_info(\n                         vpx_dec_iface_t       *iface,\n                         const uint8_t         *data,\n                         unsigned int           data_sz,\n                         vpx_dec_stream_info_t *si) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Return information about the current stream.\n *\n * Returns information about the stream that has been parsed\n * during decoding.\n *\n * \\param[in]      ctx     Pointer to this instance's context\n * \\param[in,out]  si      Pointer to stream info to update.\n *                         The size member \\ref MUST be properly\n *                         initialized, but \\ref MAY be clobbered\n *                         by the algorithm.  This parameter \\ref\n *                         MAY be NULL.\n *\n * \\retval #VPX_DEC_OK\n *     Bitstream is parsable and stream information updated\n */\nvpx_dec_err_t vpx_dec_get_stream_info(\n    vpx_dec_ctx_t         *ctx,\n    vpx_dec_stream_info_t *si) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Control algorithm\n *\n * This function is used to exchange algorithm-specific data with\n * the decoder instance.  This can be used to implement features\n * specific to a particular algorithm.\n *\n * This wrapper function dispatches the request to the helper\n * function associated with the given ctrl_id.  It tries to call\n * this function transparently, but will return #VPX_DEC_ERROR if\n * the request could not be dispatched.\n *\n * \\param[in]     ctx          Pointer to this instance's context\n * \\param[in]     ctrl_id      Algorithm-specific control\n *                             identifier\n * \\param[in,out] data         Data to exchange with algorithm\n *                             instance.\n *\n * \\retval #VPX_DEC_OK\n *     The control request was processed.\n * \\retval #VPX_DEC_ERROR\n *     The control request was not processed.\n * \\retval #VPX_DEC_INVALID_PARAM\n *     The data was not valid.\n */\nvpx_dec_err_t vpx_dec_control(vpx_dec_ctx_t  *ctx,\n                              int             ctrl_id,\n                              void           *data) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Decode data\n *\n * Processes a buffer of coded data.  If the processing results\n * in a new decoded frame becoming available,\n * #VPX_DEC_CB_PUT_SLICE and #VPX_DEC_CB_PUT_FRAME events may be\n * generated, as appropriate.  Encoded data \\ref MUST be passed\n * in DTS (decode time stamp) order.  Frames produced will always\n * be in PTS (presentation time stamp) order.\n *\n * \\param[in] ctx          Pointer to this instance's context\n * \\param[in] data         Pointer to this block of new coded\n *                         data.  If NULL, a VPX_DEC_CB_PUT_FRAME\n *                         event is posted for the previously\n *                         decoded frame.\n * \\param[in] data_sz      Size of the coded data, in bytes.\n * \\param[in] user_priv    Application-specific data to associate\n *                         with this frame.\n * \\param[in] rel_pts      PTS relative to the previous frame, in\n *                         us.  If unknown or unavailable, set to\n *                         zero.\n *\n * \\return Returns #VPX_DEC_OK if the coded data was processed\n *         completely and future pictures can be decoded without\n *         error.  Otherwise, see the descriptions of the other\n *         error codes in ::vpx_dec_err_t for recoverability\n *         capabilities.\n */\nvpx_dec_err_t vpx_dec_decode(\n    vpx_dec_ctx_t  *ctx,\n    uint8_t        *data,\n    unsigned int    data_sz,\n    void           *user_priv,\n    int             rel_pts) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Decoded frames iterator\n *\n * Iterates over a list of the frames available for display.  The\n * iterator storage should be initialized to NULL to start the\n * iteration.  Iteration is complete when this function returns\n * NULL.\n *\n * The list of available frames becomes valid upon completion of\n * the vpx_dec_decode call, and remains valid until the next call\n * to vpx_dec_decode.\n *\n * \\param[in]     ctx      Pointer to this instance's context\n * \\param[in out] iter     Iterator storage, initialized to NULL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " *\n * \\return Returns a pointer to an image, if one is ready for\n *         display.  Frames produced will always be in PTS\n *         (presentation time stamp) order.\n */\nvpx_image_t *vpx_dec_get_frame(vpx_dec_ctx_t  *ctx,\n                               vpx_dec_iter_t *iter) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\defgroup cap_put_frame Frame-Based Decoding Functions\n *\n * The following functions are required to be implemented for all\n * decoders that advertise the VPX_DEC_CAP_PUT_FRAME capability.\n * Calling these functions for codecs that don't advertise this\n * capability will result in an error code being returned,\n * usually VPX_DEC_ERROR @{\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief put frame callback prototype\n *\n * This callback is invoked by the decoder to notify the\n * application of the availability of decoded image data.\n */\ntypedef void (*vpx_dec_put_frame_cb_fn_t)(\n        void          *user_priv,\n        const vpx_image_t *img);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Register for notification of frame completion.\n *\n * Registers a given function to be called when a decoded frame\n * is available.\n *\n * \\param[in] ctx          Pointer to this instance's context\n * \\param[in] cb           Pointer to the callback function\n * \\param[in] user_priv    User's private data\n *\n * \\retval #VPX_DEC_OK\n *     Callback successfully registered.\n * \\retval #VPX_DEC_ERROR\n *     Decoder context not initialized, or algorithm not capable\n *     of posting slice completion.\n */\nvpx_dec_err_t vpx_dec_register_put_frame_cb(\n        vpx_dec_ctx_t             *ctx,\n        vpx_dec_put_frame_cb_fn_t  cb,\n        void                      *user_priv) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!@} - end defgroup cap_put_frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\defgroup cap_put_slice Slice-Based Decoding Functions\n *\n * The following functions are required to be implemented for all\n * decoders that advertise the VPX_DEC_CAP_PUT_SLICE capability.\n * Calling these functions for codecs that don't advertise this\n * capability will result in an error code being returned,\n * usually VPX_DEC_ERROR\n * @{\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief put slice callback prototype\n *\n * This callback is invoked by the decoder to notify the\n * application of the availability of partially decoded image\n * data.\n */\ntypedef void (*vpx_dec_put_slice_cb_fn_t)(void        *user_priv,\n        const vpx_image_t      *img,\n        const vpx_image_rect_t *valid,\n        const vpx_image_rect_t *update);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Register for notification of slice completion.\n *\n * Registers a given function to be called when a decoded slice\n * is available.\n *\n * \\param[in] ctx          Pointer to this instance's context\n * \\param[in] cb           Pointer to the callback function\n * \\param[in] user_priv    User's private data\n *\n * \\retval #VPX_DEC_OK\n *     Callback successfully registered.\n * \\retval #VPX_DEC_ERROR\n *     Decoder context not initialized, or algorithm not capable\n *     of posting slice completion.\n */\nvpx_dec_err_t vpx_dec_register_put_slice_cb(vpx_dec_ctx_t   *ctx,\n        vpx_dec_put_slice_cb_fn_t  cb,\n        void                      *user_priv) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!@} - end defgroup cap_put_slice*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\defgroup cap_xma External Memory Allocation Functions\n *\n * The following functions are required to be implemented for all\n * decoders that advertise the VPX_DEC_CAP_XMA capability.\n * Calling these functions for codecs that don't advertise this\n * capability will result in an error code being returned,\n * usually VPX_DEC_ERROR\n * @{\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*!\\brief Memory Map Entry\n     *\n     * This structure is used to contain the properties of a memory\n     * segment.  It is populated by the decoder in the request phase,\n     * and by the calling application once the requested allocation\n     * has been performed.\n     */\n#if 1\n#define VPX_DEC_MEM_ZERO     0x1  /**< Segment must be zeroed by\n                                       allocation */\n#define VPX_DEC_MEM_WRONLY   0x2  /**< Segment need not be\n                                       readable */\n#define VPX_DEC_MEM_FAST     0x4  /**< Place in fast memory, if\n                                       available */\n    typedef struct vpx_codec_mmap vpx_dec_mmap_t;\n#else\n    typedef struct vpx_dec_mmap\n    {\n        /*\n         * The following members are set by the codec when requesting\n         * a segment\n         */\n        unsigned int   id;     /**< identifier for the segment's\n                                    contents */\n        unsigned long  sz;     /**< size of the segment, in bytes */\n        unsigned int   align;  /**< required alignment of the\n                                    segment, in bytes */\n        unsigned int   flags;  /**< bitfield containing segment\n                                    properties */\n#define VPX_DEC_MEM_ZERO     0x1  /**< Segment must be zeroed by\n                                       allocation */\n#define VPX_DEC_MEM_WRONLY   0x2  /**< Segment need not be\n                                       readable */\n#define VPX_DEC_MEM_FAST     0x4  /**< Place in fast memory, if\n                                       available */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        /* The following members are to be filled in by the\n         * allocation function */\n        void          *base;   /**< pointer to the allocated\n                                    segment */\n        void (*dtor)(struct vpx_dec_mmap *map);  /**< destructor to\n                                                      call */\n        void          *priv;   /**< allocator private storage */\n    } vpx_dec_mmap_t;\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*!\\brief Initialize a decoder instance in external allocation\n     * mode\n     *\n     * Initializes a decoder context using the given interface.\n     * Applications should call the vpx_dec_xma_init convenience\n     * macro instead of this function directly, to ensure that the\n     * ABI version number parameter is properly initialized.\n     *\n     * \\param[in]    ctx     Pointer to this instance's context.\n     * \\param[in]    iface   Pointer to the algorithm interface to\n     *                       use.\n     * \\param[in]    ver     ABI version number.  Must be set to\n     *                       VPX_DECODER_ABI_VERSION\n     * \\retval #VPX_DEC_OK\n     *     The decoder algorithm initialized.\n     * \\retval #VPX_DEC_ERROR\n     *     Decoder does not support XMA mode.\n     */\n    vpx_dec_err_t vpx_dec_xma_init_ver(vpx_dec_ctx_t    *ctx,\n                                       vpx_dec_iface_t  *iface,\n                                       int           ver) DEPRECATED;\n#define vpx_dec_xma_init(ctx, iface) \\\n    vpx_dec_xma_init_ver(ctx, iface, VPX_DECODER_ABI_VERSION)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Iterate over the list of segments to allocate.\n *\n * Iterates over a list of the segments to allocate.  The\n * iterator storage should be initialized to NULL to start the\n * iteration.  Iteration is complete when this function returns\n * VPX_DEC_LIST_END.  The amount of memory needed to allocate is\n * dependent upon the size of the encoded stream.  This means\n * that the stream info structure must be known at allocation\n * time.  It can be populated with the vpx_dec_peek_stream_info()\n * function.  In cases where the stream to be decoded is not\n * available at allocation time, a fixed size must be requested.\n * The decoder will not be able to decode streams larger than the\n * size used at allocation time.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " *\n * \\param[in]      ctx     Pointer to this instance's context.\n * \\param[out]     mmap    Pointer to the memory map entry to\n *                         populate.\n * \\param[in]      si      Pointer to the stream info.\n * \\param[in out]  iter    Iterator storage, initialized to NULL\n *\n * \\retval #VPX_DEC_OK\n *     The memory map entry was populated.\n * \\retval #VPX_DEC_ERROR\n *     Decoder does not support XMA mode.\n * \\retval #VPX_DEC_MEM_ERROR\n *     Unable to determine segment size from stream info.\n */\nvpx_dec_err_t vpx_dec_get_mem_map(\n    vpx_dec_ctx_t                *ctx,\n    vpx_dec_mmap_t               *mmap,\n    const vpx_dec_stream_info_t  *si,\n    vpx_dec_iter_t               *iter) DEPRECATED;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Identify allocated segments to decoder instance\n *\n * Stores a list of allocated segments in the decoder.  Segments\n * \\ref MUST be passed in the order they are read from\n * vpx_dec_get_mem_map(), but may be passed in groups of any\n * size.  Segments \\ref MUST be set only once.  The allocation\n * function \\ref MUST ensure that the vpx_dec_mmap_t::base member\n * is non-NULL.  If the segment requires cleanup handling (e.g.,\n * calling free() or close()) then the vpx_dec_mmap_t::dtor\n * member \\ref MUST be populated.\n *\n * \\param[in]      ctx       Pointer to this instance's context.\n * \\param[in]      mmaps     Pointer to the first memory map\n *                           entry in the list.\n * \\param[in]      num_maps  Number of entries being set at this\n *                           time\n *\n * \\retval #VPX_DEC_OK\n *     The segment was stored in the decoder context.\n * \\retval #VPX_DEC_ERROR\n *     Decoder does not support XMA mode.\n * \\retval #VPX_DEC_MEM_ERROR\n *     Segment base address was not set, or segment was already\n * stored.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "*/",
      "ja": "*/"
    },
    {
      "indent": 7,
      "text": "vpx_dec_err_t vpx_dec_set_mem_map( vpx_dec_ctx_t *ctx, vpx_dec_mmap_t *mmaps, unsigned int num_maps) DEPRECATED;",
      "ja": "vpx_dec_err_t vpx_dec_set_mem_map（vpx_dec_ctx_t *ctx、vpx_dec_map_t *mmaps、unsigned int num_maps）Deprecated;"
    },
    {
      "indent": 7,
      "text": "/*!@} - end defgroup cap_xma*/\n/*!@} - end defgroup decoder*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif #ifdef __cplusplus } #endif",
      "ja": "#endif #ifdef __cplusplus} #endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.22. vpx_image.c",
      "section_title": true,
      "ja": "20.22. vpx_image.c"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n * Use of this source code is governed by a BSD-style license\n * that can be found in the LICENSE file in the root of the source\n * tree.  An additional intellectual property rights grant can be\n * found in the file PATENTS.  All contributing project authors may\n * be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <stdlib.h>\n#include <string.h>\n#include \"vpx/vpx_image.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static vpx_image_t *img_alloc_helper(vpx_image_t *img, vpx_img_fmt_t fmt, unsigned int d_w, unsigned int d_h, unsigned int stride_align, unsigned char *img_data) {",
      "ja": "static vpx_image_t *img_alloc_helper（vpx_image_t *img、vpx_img_fmt_t fmt、unsigned int d_w、unsigned int d_h、unsigned int stride_align、unsigned char *img_data）{"
    },
    {
      "indent": 7,
      "text": "unsigned int h, w, s, xcs, ycs, bps; int align;",
      "ja": "符号なしのint h、w、s、xcs、ycs、bps;int align;"
    },
    {
      "indent": 7,
      "text": "/* Treat align==0 like align==1 */\nif (!stride_align)\n    stride_align = 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Validate alignment (must be power of 2) */\nif (stride_align & (stride_align - 1))\n    goto fail;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Get sample size for this format */\nswitch (fmt)\n{\ncase VPX_IMG_FMT_RGB32:\ncase VPX_IMG_FMT_RGB32_LE:\ncase VPX_IMG_FMT_ARGB:\ncase VPX_IMG_FMT_ARGB_LE:\n    bps = 32;\n    break;\ncase VPX_IMG_FMT_RGB24:\ncase VPX_IMG_FMT_BGR24:\n    bps = 24;\n    break;\ncase VPX_IMG_FMT_RGB565:\ncase VPX_IMG_FMT_RGB565_LE:\ncase VPX_IMG_FMT_RGB555:\ncase VPX_IMG_FMT_RGB555_LE:\ncase VPX_IMG_FMT_UYVY:\ncase VPX_IMG_FMT_YUY2:\ncase VPX_IMG_FMT_YVYU:\n    bps = 16;\n    break;\ncase VPX_IMG_FMT_I420:\ncase VPX_IMG_FMT_YV12:\ncase VPX_IMG_FMT_VPXI420:\ncase VPX_IMG_FMT_VPXYV12:\n    bps = 12;\n    break;\ndefault:\n    bps = 16;\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Get chroma shift values for this format */\nswitch (fmt)\n{\ncase VPX_IMG_FMT_I420:\ncase VPX_IMG_FMT_YV12:\ncase VPX_IMG_FMT_VPXI420:\ncase VPX_IMG_FMT_VPXYV12:\n    xcs = 1;\n    break;\ndefault:\n    xcs = 0;\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "switch (fmt)\n{\ncase VPX_IMG_FMT_I420:\ncase VPX_IMG_FMT_YV12:\ncase VPX_IMG_FMT_VPXI420:\ncase VPX_IMG_FMT_VPXYV12:\n    ycs = 1;\n    break;\ndefault:\n    ycs = 0;\n    break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Calculate storage sizes given the chroma subsampling */\nalign = (1 << xcs) - 1;\nw = (d_w + align) & ~align;\nalign = (1 << ycs) - 1;\nh = (d_h + align) & ~align;\ns = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;\ns = (s + stride_align - 1) & ~(stride_align - 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Allocate the new image */\nif (!img)\n{\n    img = (vpx_image_t *)calloc(1, sizeof(vpx_image_t));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (!img) goto fail;",
      "ja": "if（！img）goto fail;"
    },
    {
      "indent": 7,
      "text": "    img->self_allocd = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "else\n{\n    memset(img, 0, sizeof(vpx_image_t));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "img->img_data = img_data;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!img_data)\n{\n    img->img_data = malloc((fmt & VPX_IMG_FMT_PLANAR) ?\n      h * w * bps / 8 : h * s);\n    img->img_data_owner = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!img->img_data) goto fail;",
      "ja": "if（！img-> img_data）goto fail;"
    },
    {
      "indent": 7,
      "text": "img->fmt = fmt;\nimg->w = w;\nimg->h = h;\nimg->x_chroma_shift = xcs;\nimg->y_chroma_shift = ycs;\nimg->bps = bps;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Calculate strides */\nimg->stride[VPX_PLANE_Y] = img->stride[VPX_PLANE_ALPHA] = s;\nimg->stride[VPX_PLANE_U] = img->stride[VPX_PLANE_V] = s >> xcs;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Default viewport to entire image */\nif (!vpx_img_set_rect(img, 0, 0, d_w, d_h))\n    return img;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "fail: vpx_img_free(img); return NULL; }",
      "ja": "失敗：vpx_img_free（img）;nullを返します。}"
    },
    {
      "indent": 3,
      "text": "vpx_image_t *vpx_img_alloc(vpx_image_t  *img,\n                           vpx_img_fmt_t fmt,\n                           unsigned int  d_w,\n                           unsigned int  d_h,\n                           unsigned int  stride_align)\n{\n    return img_alloc_helper(img, fmt, d_w, d_h, stride_align, NULL);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "vpx_image_t *vpx_img_wrap(vpx_image_t  *img,\n                          vpx_img_fmt_t fmt,\n                          unsigned int  d_w,\n                          unsigned int  d_h,\n                          unsigned int  stride_align,\n                          unsigned char       *img_data)\n{\n    return img_alloc_helper(img, fmt, d_w, d_h, stride_align,\n      img_data);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int vpx_img_set_rect(vpx_image_t *img, unsigned int x, unsigned int y, unsigned int w, unsigned int h) { unsigned char *data;",
      "ja": "int vpx_img_set_rect（vpx_image_t *img、unsigned int x、unsigned int y、unsigned int w、unsigned int h）{unsigned char *data;"
    },
    {
      "indent": 7,
      "text": "if (x + w <= img->w && y + h <= img->h)\n{\n    img->d_w = w;\n    img->d_h = h;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Calculate plane pointers */\nif (!(img->fmt & VPX_IMG_FMT_PLANAR))\n{\n    img->planes[VPX_PLANE_PACKED] =\n        img->img_data + x * img->bps / 8 + y *\n          img->stride[VPX_PLANE_PACKED];\n}\nelse\n{\n    data = img->img_data;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (img->fmt & VPX_IMG_FMT_HAS_ALPHA)\n{\n    img->planes[VPX_PLANE_ALPHA] =\n        data + x + y * img->stride[VPX_PLANE_ALPHA];\n    data += img->h * img->stride[VPX_PLANE_ALPHA];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "img->planes[VPX_PLANE_Y] =\n  data + x + y * img->stride[VPX_PLANE_Y];\ndata += img->h * img->stride[VPX_PLANE_Y];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (!(img->fmt & VPX_IMG_FMT_UV_FLIP))\n    {\n        img->planes[VPX_PLANE_U] = data\n                               + (x >> img->x_chroma_shift)\n                               + (y >> img->y_chroma_shift) *\n                                 img->stride[VPX_PLANE_U];\n        data += (img->h >> img->y_chroma_shift) *\n                                 img->stride[VPX_PLANE_U];\n        img->planes[VPX_PLANE_V] = data\n                               + (x >> img->x_chroma_shift)\n                               + (y >> img->y_chroma_shift) *\n                                 img->stride[VPX_PLANE_V];\n    }\n    else\n    {\n        img->planes[VPX_PLANE_V] = data\n                               + (x >> img->x_chroma_shift)\n                               + (y >> img->y_chroma_shift) *\n                                 img->stride[VPX_PLANE_V];\n        data += (img->h >> img->y_chroma_shift) *\n                                 img->stride[VPX_PLANE_V];\n        img->planes[VPX_PLANE_U] = data\n                               + (x >> img->x_chroma_shift)\n                               + (y >> img->y_chroma_shift) *\n                                 img->stride[VPX_PLANE_U];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " return 0; }",
      "ja": "0を返します。}"
    },
    {
      "indent": 3,
      "text": " return -1; }",
      "ja": "return -1;}"
    },
    {
      "indent": 3,
      "text": "void vpx_img_flip(vpx_image_t *img)\n{\n    /* Note: In the calculation pointer adjustment calculation, we\n     * want the rhs to be promoted to a signed type.  Section 6.3.1.8\n     * of the ISO C99 standard [ISO-C99] indicates that if the\n     * adjustment parameter is unsigned, the stride parameter will be\n     * promoted to unsigned, causing errors when the lhs is a larger\n     * type than the rhs.\n     */\n    img->planes[VPX_PLANE_Y] += (signed)\n      (img->d_h - 1) * img->stride[VPX_PLANE_Y];\n    img->stride[VPX_PLANE_Y] = -img->stride[VPX_PLANE_Y];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "img->planes[VPX_PLANE_U] += (signed)\n  ((img->d_h >> img->y_chroma_shift) - 1)\n                        * img->stride[VPX_PLANE_U];\nimg->stride[VPX_PLANE_U] = -img->stride[VPX_PLANE_U];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "img->planes[VPX_PLANE_V] += (signed)\n                        ((img->d_h >> img->y_chroma_shift) - 1) *\n                        img->stride[VPX_PLANE_V];\nimg->stride[VPX_PLANE_V] = -img->stride[VPX_PLANE_V];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    img->planes[VPX_PLANE_ALPHA] += (signed)\n      (img->d_h - 1) * img->stride[VPX_PLANE_ALPHA];\n    img->stride[VPX_PLANE_ALPHA] = -img->stride[VPX_PLANE_ALPHA];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vpx_img_free(vpx_image_t *img)\n{\n    if (img)\n    {\n        if (img->img_data && img->img_data_owner)\n            free(img->img_data);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if (img->self_allocd)\n            free(img);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.23. vpx_image.h",
      "section_title": true,
      "ja": "20.23. vpx_image.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n * Use of this source code is governed by a BSD-style license\n * that can be found in the LICENSE file in the root of the source\n * tree.  An additional intellectual property rights grant can be\n * found in the file PATENTS.  All contributing project authors may\n * be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*!\\file\n * \\brief Describes the vpx image descriptor and associated\n * operations\n *\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifdef __cplusplus extern \"C\" { #endif",
      "ja": "#ifdef __cplusplus extern \"c\" {#endif"
    },
    {
      "indent": 3,
      "text": "#ifndef VPX_IMAGE_H #define VPX_IMAGE_H",
      "ja": "#ifndef vpx_image_h #define vpx_image_h"
    },
    {
      "indent": 3,
      "text": "    /*!\\brief Current ABI version number\n     *\n     * \\internal\n     * If this file is altered in any way that changes the ABI, this\n     * value must be bumped.  Examples include, but are not limited\n     * to, changing types, removing or reassigning enums,\n     * adding/removing/rearranging fields to structures\n     */\n#define VPX_IMAGE_ABI_VERSION (1) /**<\\hideinitializer*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define VPX_IMG_FMT_PLANAR     0x100  /**< Image is a planar\n                                           format */\n#define VPX_IMG_FMT_UV_FLIP    0x200  /**< V plane precedes U plane\n                                           in memory */\n#define VPX_IMG_FMT_HAS_ALPHA  0x400  /**< Image has an alpha channel\n                                           component */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief List of supported image formats */\ntypedef enum vpx_img_fmt {\n    VPX_IMG_FMT_NONE,\n    VPX_IMG_FMT_RGB24,      /**< 24 bit per pixel packed RGB */\n    VPX_IMG_FMT_RGB32,      /**< 32 bit per pixel packed 0RGB */\n    VPX_IMG_FMT_RGB565,     /**< 16 bit per pixel, 565 */\n    VPX_IMGFMT_RGB555,      /**< 16 bit per pixel, 555 */\n    VPX_IMG_FMT_UYVY,       /**< UYVY packed YUV */\n    VPX_IMG_FMT_YUY2,       /**< YUYV packed YUV */\n    VPX_IMG_FMT_YVYU,       /**< YVYU packed YUV */\n    VPX_IMG_FMT_BGR24,      /**< 24 bit per pixel packed BGR */\n    VPX_IMG_FMT_RGB32_LE,   /**< 32 bit packed BGR0 */\n    VPX_IMG_FMT_ARGB,       /**< 32 bit packed ARGB, alpha=255 */\n    VPX_IMG_FMT_ARGB_LE,    /**< 32 bit packed BGRA, alpha=255 */\n    VPX_IMG_FMT_RGB565_LE,  /**< 16 bit per pixel,\n                                 gggbbbbb rrrrrggg */\n    VPX_IMG_FMT_RGB555_LE,  /**< 16 bit per pixel,\n                                 gggbbbbb 0rrrrrgg */\n    VPX_IMG_FMT_YV12    = VPX_IMG_FMT_PLANAR |\n      VPX_IMG_FMT_UV_FLIP | 1, /**< planar YVU */\n    VPX_IMG_FMT_I420    = VPX_IMG_FMT_PLANAR | 2,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    VPX_IMG_FMT_VPXYV12 = VPX_IMG_FMT_PLANAR |\n      VPX_IMG_FMT_UV_FLIP | 3, /** < planar 4:2:0 format with\n                                     vpx color space */\n    VPX_IMG_FMT_VPXI420 = VPX_IMG_FMT_PLANAR | 4   /** < planar\n      4:2:0 format with vpx color space */\n}\nvpx_img_fmt_t; /**< alias for enum vpx_img_fmt */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT\n/** \\deprecated Use #VPX_IMG_FMT_PLANAR */\n#define IMG_FMT_PLANAR         VPX_IMG_FMT_PLANAR\n/** \\deprecated Use #VPX_IMG_FMT_UV_FLIP */\n#define IMG_FMT_UV_FLIP        VPX_IMG_FMT_UV_FLIP\n/** \\deprecated Use #VPX_IMG_FMT_HAS_ALPHA */\n#define IMG_FMT_HAS_ALPHA      VPX_IMG_FMT_HAS_ALPHA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /*!\\brief Deprecated list of supported image formats\n     * \\deprecated New code should use #vpx_img_fmt\n     */\n#define img_fmt   vpx_img_fmt\n    /*!\\brief alias for enum img_fmt.\n     * \\deprecated New code should use #vpx_img_fmt_t\n     */\n#define img_fmt_t vpx_img_fmt_t",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/** \\deprecated Use #VPX_IMG_FMT_NONE */\n#define IMG_FMT_NONE       VPX_IMG_FMT_NONE\n/** \\deprecated Use #VPX_IMG_FMT_RGB24 */\n#define IMG_FMT_RGB24      VPX_IMG_FMT_RGB24\n/** \\deprecated Use #VPX_IMG_FMT_RGB32 */\n#define IMG_FMT_RGB32      VPX_IMG_FMT_RGB32\n/** \\deprecated Use #VPX_IMG_FMT_RGB565 */\n#define IMG_FMT_RGB565     VPX_IMG_FMT_RGB565\n/** \\deprecated Use #VPX_IMG_FMT_RGB555 */\n#define IMG_FMT_RGB555     VPX_IMG_FMT_RGB555\n/** \\deprecated Use #VPX_IMG_FMT_UYVY */\n#define IMG_FMT_UYVY       VPX_IMG_FMT_UYVY\n/** \\deprecated Use #VPX_IMG_FMT_YUY2 */\n#define IMG_FMT_YUY2       VPX_IMG_FMT_YUY2\n/** \\deprecated Use #VPX_IMG_FMT_YVYU */\n#define IMG_FMT_YVYU       VPX_IMG_FMT_YVYU\n/** \\deprecated Use #VPX_IMG_FMT_BGR24 */\n#define IMG_FMT_BGR24      VPX_IMG_FMT_BGR24\n/**< \\deprecated Use #VPX_IMG_FMT_RGB32_LE */\n#define IMG_FMT_RGB32_LE   VPX_IMG_FMT_RGB32_LE\n/** \\deprecated Use #VPX_IMG_FMT_ARGB */\n#define IMG_FMT_ARGB       VPX_IMG_FMT_ARGB",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/** \\deprecated Use #VPX_IMG_FMT_ARGB_LE */\n#define IMG_FMT_ARGB_LE    VPX_IMG_FMT_ARGB_LE\n/** \\deprecated Use #VPX_IMG_FMT_RGB565_LE */\n#define IMG_FMT_RGB565_LE  VPX_IMG_FMT_RGB565_LE\n/** \\deprecated Use #VPX_IMG_FMT_RGB555_LE */\n#define IMG_FMT_RGB555_LE  VPX_IMG_FMT_RGB555_LE\n/** \\deprecated Use #VPX_IMG_FMT_YV12 */\n#define IMG_FMT_YV12       VPX_IMG_FMT_YV12\n/** \\deprecated Use #VPX_IMG_FMT_I420 */\n#define IMG_FMT_I420       VPX_IMG_FMT_I420\n/** \\deprecated Use #VPX_IMG_FMT_VPXYV12 */\n#define IMG_FMT_VPXYV12    VPX_IMG_FMT_VPXYV12\n/** \\deprecated Use #VPX_IMG_FMT_VPXI420 */\n#define IMG_FMT_VPXI420    VPX_IMG_FMT_VPXI420\n#endif /* VPX_CODEC_DISABLE_COMPAT */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\\brief Image Descriptor */\ntypedef struct vpx_image\n{\n    vpx_img_fmt_t fmt; /**< Image Format */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Image storage dimensions */\nunsigned int  w;   /**< Stored image width */\nunsigned int  h;   /**< Stored image height */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Image display dimensions */\nunsigned int  d_w;   /**< Displayed image width */\nunsigned int  d_h;   /**< Displayed image height */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Chroma subsampling info */\nunsigned int  x_chroma_shift;   /**< subsampling order, X */\nunsigned int  y_chroma_shift;   /**< subsampling order, Y */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        /* Image data pointers. */\n#define VPX_PLANE_PACKED 0  /**< To be used for all packed formats */\n#define VPX_PLANE_Y      0  /**< Y (Luminance) plane */\n#define VPX_PLANE_U      1  /**< U (Chroma) plane */\n#define VPX_PLANE_V      2  /**< V (Chroma) plane */\n#define VPX_PLANE_ALPHA  3  /**< A (Transparency) plane */\n#if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT\n#define PLANE_PACKED     VPX_PLANE_PACKED\n#define PLANE_Y          VPX_PLANE_Y\n#define PLANE_U          VPX_PLANE_U\n#define PLANE_V          VPX_PLANE_V\n#define PLANE_ALPHA      VPX_PLANE_ALPHA\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "unsigned char *planes[4];  /**< pointer to the top-left pixel\nq                               for each plane */\nint    stride[4];  /**< stride between rows for each plane */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "int    bps; /**< bits per sample (for packed formats) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* The following member may be set by the application to\n * associate data with this image.\n */\nvoid   *user_priv; /**< may be set by the application to\n                         associate data with this image. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    /* The following members should be treated as private. */\n    unsigned char *img_data;       /**< private */\n    int      img_data_owner; /**< private */\n    int      self_allocd;    /**< private */\n} vpx_image_t; /**< alias for struct vpx_image */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\\brief Representation of a rectangle on a surface */\ntypedef struct vpx_image_rect\n{\n    unsigned int x; /**< leftmost column */\n    unsigned int y; /**< topmost row */\n    unsigned int w; /**< width */\n    unsigned int h; /**< height */\n} vpx_image_rect_t; /**< alias for struct vpx_image_rect */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Open a descriptor, allocating storage for the\n * underlying image\n *\n * Returns a descriptor for storing an image of the given format.\n * The storage for the descriptor is allocated on the heap.\n *\n * \\param[in]    img       Pointer to storage for descriptor.\n *                         If this parameter is NULL, the storage\n *                         for the descriptor will be allocated\n *                         on the heap.\n * \\param[in]    fmt       Format for the image\n * \\param[in]    d_w       Width of the image\n * \\param[in]    d_h       Height of the image\n * \\param[in]    align     Alignment, in bytes, of each row in\n *                         the image.\n *\n * \\return Returns a pointer to the initialized image descriptor.\n *         If the img parameter is non-null, the value of the img\n *         parameter will be returned.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "vpx_image_t *vpx_img_alloc(vpx_image_t *img, vpx_img_fmt_t fmt, unsigned int d_w, unsigned int d_h, unsigned int align);",
      "ja": "vpx_image_t *vpx_img_alloc（vpx_image_t *img、vpx_img_fmt_t fmt、unsigned int d_w、unsigned int d_h、unsigned int align）;"
    },
    {
      "indent": 7,
      "text": "/*!\\brief Open a descriptor, using existing storage for the\n * underlying image\n *\n * Returns a descriptor for storing an image of the given format.\n * The storage for descriptor has been allocated elsewhere, and a\n * descriptor is desired to \"wrap\" that storage.\n *\n * \\param[in]    img       Pointer to storage for descriptor.\n *                         If this parameter is NULL, the storage\n *                         for the descriptor will be\n *                         allocated on the heap.\n * \\param[in]    fmt       Format for the image\n * \\param[in]    d_w       Width of the image\n * \\param[in]    d_h       Height of the image\n * \\param[in]    align     Alignment, in bytes, of each row in\n *                         the image.\n * \\param[in]    img_data  Storage to use for the image\n *\n * \\return Returns a pointer to the initialized image descriptor.\n *         If the img parameter is non-null, the value of the img\n *         parameter will be returned.\n */\nvpx_image_t *vpx_img_wrap(vpx_image_t  *img,\n                          vpx_img_fmt_t fmt,\n                          unsigned int d_w,\n                          unsigned int d_h,\n                          unsigned int align,\n                          unsigned char      *img_data);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Set the rectangle identifying the displayed portion of\n * the image\n *\n * Updates the displayed rectangle (aka viewport) on the image\n * surface to match the specified coordinates and size.\n *\n * \\param[in]    img       Image descriptor\n * \\param[in]    x         leftmost column\n * \\param[in]    y         topmost row\n * \\param[in]    w         width\n * \\param[in]    h         height\n *",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " * \\return 0 if the requested rectangle is valid, non-zero * otherwise. */ int vpx_img_set_rect(vpx_image_t *img, unsigned int x, unsigned int y, unsigned int w, unsigned int h);",
      "ja": "* \\ return 0要求された長方形が有効である場合、それ以外の場合は非ゼロ *。*/ int vpx_img_set_rect（vpx_image_t *img、unsigned int x、unsigned int y、unsigned int w、unsigned int h）;"
    },
    {
      "indent": 7,
      "text": "/*!\\brief Flip the image vertically (top for bottom)\n *\n * Adjusts the image descriptor's pointers and strides to make\n * the image be referenced upside-down.\n *\n * \\param[in]    img       Image descriptor\n */\nvoid vpx_img_flip(vpx_image_t *img);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*!\\brief Close an image descriptor\n *\n * Frees all allocated storage associated with an image\n * descriptor.\n *\n * \\param[in]    img       Image descriptor\n */\nvoid vpx_img_free(vpx_image_t *img);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif #ifdef __cplusplus } #endif",
      "ja": "#endif #ifdef __cplusplus} #endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.24. vpx_integer.h",
      "section_title": true,
      "ja": "20.24. vpx_integer.h"
    },
    {
      "indent": 3,
      "text": "---- Begin code block --------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.  An additional intellectual property rights grant can be\n *  found in the file PATENTS.  All contributing project authors may\n *  be found in the AUTHORS file in the root of the source tree.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef VPX_INTEGER_H #define VPX_INTEGER_H",
      "ja": "#ifndef vpx_integer_h #define vpx_integer_h"
    },
    {
      "indent": 3,
      "text": "/* get ptrdiff_t, size_t, wchar_t, NULL */\n#include <stddef.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#if defined(_MSC_VER) || defined(VPX_EMULATE_INTTYPES)\ntypedef signed char  int8_t;\ntypedef signed short int16_t;\ntypedef signed int   int32_t;\ntypedef unsigned char  uint8_t;\ntypedef unsigned short uint16_t;\ntypedef unsigned int   uint32_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#if defined(_MSC_VER) typedef signed __int64 int64_t; typedef unsigned __int64 uint64_t; #define PRId64 \"I64d\" #endif",
      "ja": "#if defined（_msc_ver）typedef署名__int64 int64_t;typedef unsigned __int64 uint64_t;#define prid64 \"i64d\" #endif"
    },
    {
      "indent": 3,
      "text": "#ifdef HAVE_ARMV6\ntypedef unsigned int int_fast16_t;\n#else\ntypedef signed short int_fast16_t;\n#endif\ntypedef signed char int_fast8_t;\ntypedef unsigned char uint_fast8_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef _UINTPTR_T_DEFINED typedef unsigned int uintptr_t; #endif",
      "ja": "#ifndef _uintptr_t_defined typedef unsigned int uintptr_t;#endif"
    },
    {
      "indent": 3,
      "text": "#else",
      "ja": "＃そうしないと"
    },
    {
      "indent": 3,
      "text": "/* Most platforms have the C99 standard integer types. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#if defined(__cplusplus) && !defined(__STDC_FORMAT_MACROS)\n#define __STDC_FORMAT_MACROS\n#endif\n#include <stdint.h>\n#include <inttypes.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "---- End code block ----------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "20.25. AUTHORS File",
      "section_title": true,
      "ja": "20.25. 著者ファイル"
    },
    {
      "indent": 3,
      "text": "Aaron Watry <awatry@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Adrian Grange <agrange@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Alex Converse <alex.converse@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Andoni Morales Alastruey <ylatuya@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Andres Mejia <mcitadel@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Attila Nagy <attilanagy@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Fabio Pedretti <fabio.ped@libero.it>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Frank Galligan <fgalligan@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Fredrik Soederquist <fs@opera.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Fritz Koenig <frkoenig@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Gaute Strokkenes <gaute.strokkenes@broadcom.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Giuseppe Scrivano <gscrivano@gnu.org>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Guillermo Ballester Valor <gbvalor@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Henrik Lundin <hlundin@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "James Berry <jamesberry@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "James Zern <jzern@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jan Kratochvil <jan.kratochvil@redhat.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jeff Muizelaar <jmuizelaar@mozilla.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jim Bankoski <jimbankoski@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Johann Koenig <johannkoenig@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "John Koleszar <jkoleszar@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Justin Clift <justin@salasaga.org>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Justin Lebar <justin.lebar@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Luca Barbato <lu_zero@gentoo.org>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Makoto Kato <makoto.kt@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Martin Ettl <ettl.martin78@googlemail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Michael Kohler <michaelkohler@live.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mikhal Shemer <mikhal@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pascal Massimino <pascal.massimino@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Patrik Westin <patrik.westin@gmail.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Paul Wilkins <paulwilkins@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pavol Rusnak <stick@gk2.sk>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Philip Jaegenstedt <philipj@opera.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Scott LaVarnway <slavarnway@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tero Rintaluoma <teror@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Timothy B. Terriberry <tterribe@xiph.org>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tom Finegan <tomfinegan@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Yaowu Xu <yaowu@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Yunqing Wang <yunqingwang@google.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Google Inc.",
      "ja": "Google Inc."
    },
    {
      "indent": 3,
      "text": "The Mozilla Foundation",
      "ja": "モジラ財団"
    },
    {
      "indent": 3,
      "text": "The Xiph.Org Foundation",
      "ja": "Xiph.org Foundation"
    },
    {
      "indent": 0,
      "text": "20.26. LICENSE",
      "section_title": true,
      "ja": "20.26. ライセンス"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010, 2011, Google Inc. All rights reserved.",
      "ja": "Copyright（c）2010、2011、Google Inc. All Rights Reserved。"
    },
    {
      "indent": 3,
      "text": "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:",
      "ja": "次の条件が満たされていれば、変更を加えた、または修正なしの有無にかかわらず、ソースおよびバイナリ形式での再配布と使用が許可されます。"
    },
    {
      "indent": 3,
      "text": "o Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.",
      "ja": "o ソースコードの再配布は、上記の著作権通知、この条件リスト、および次の免責事項を保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.",
      "ja": "o バイナリ形式の再配布は、上記の著作権通知、この条件リスト、および分布に提供されたドキュメントおよび/またはその他の資料の次の免責事項を再現する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Neither the name of Google nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.",
      "ja": "o Googleの名前もその貢献者の名前も、特定の事前の書面による許可なしにこのソフトウェアから派生した製品を支持または宣伝するために使用することはできません。"
    },
    {
      "indent": 3,
      "text": "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
      "ja": "このソフトウェアは、「現状のまま」の著作権所有者と貢献者によって提供され、特定の目的に対する商品性と適合性の暗黙の保証を含むがこれらに限定されない明示的または黙示的な保証が否認されます。いかなる場合でも、著作権所有者または貢献者は、直接的、間接的、偶発的、特別な、模範的、または結果的な損害賠償（代替品またはサービスの調達、使用の損失、データ、または利益）に対して責任を負いません。ただし、契約、厳格責任、または不法行為（過失などを含む）であろうと、このソフトウェアの使用から何らかの形で発生するかどうかにかかわらず、責任の理論に起因します。"
    },
    {
      "indent": 0,
      "text": "20.27. PATENTS",
      "section_title": true,
      "ja": "20.27. 特許"
    },
    {
      "indent": 3,
      "text": "Additional IP Rights Grant (Patents)",
      "ja": "追加のIP権利助成金（特許）"
    },
    {
      "indent": 3,
      "text": "\"This implementation\" means the copyrightable works distributed by Google as part of the WebM Project.",
      "ja": "「この実装」とは、WebMプロジェクトの一部としてGoogleが配布した著作権で保護可能な作品を意味します。"
    },
    {
      "indent": 3,
      "text": "Google hereby grants to you a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, transfer, and otherwise run, modify and propagate the contents of this implementation of VP8, where such license applies only to those patent claims, both currently owned by Google and acquired in the future, licensable by Google that are necessarily infringed by this implementation of VP8. This grant does not include claims that would be infringed only as a consequence of further modification of this implementation. If you or your agent or exclusive licensee institute or order or agree to the institution of patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that this implementation of VP8 or any code incorporated within this implementation of VP8 constitutes direct or contributory patent infringement, or inducement of patent infringement, then any patent rights granted to you under this License for this implementation of VP8 shall terminate as of the date such litigation is filed.",
      "ja": "Googleは、ここにあなたにあなたに与えます、世界的な、世界的な、非独占的、充電なし、ロイヤリティフリー、取り返しのつかない（このセクションに記載されている場合を除く）特許ライセンスを作成、使用、使用、販売、販売、輸入、譲渡、その他の方法では、このVP8が現在所有しており、将来取得している特許請求にのみ適用されるVP8の実装の内容を実行、変更、伝播します。この助成金には、この実装のさらなる変更の結果としてのみ侵害される請求は含まれていません。あなたまたはあなたのエージェントまたは排他的ライセンシー研究所または命令または命令または同意するか、VP8またはVP8の実施に組み込まれたこのコードの実施が構成されていると主張する事業体に対する特許訴訟の機関（訴訟の相互訴訟または反訴を含む）に同意する場合直接的または拠出的な特許侵害、または特許侵害の誘因、このVP8の実施のためにこの免許に基づいてお客様に付与された特許権は、そのような訴訟が提出される日付の時点で終了するものとします。"
    },
    {
      "indent": 0,
      "text": "21. Security Considerations",
      "section_title": true,
      "ja": "21. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A VP8 decoder should take appropriate security considerations into account, as outlined in [RFC4732] and [RFC3552]. It is extremely important that a decoder be robust against malicious payloads. Malicious payloads must not cause the decoder to overrun its allocated memory or to consume inordinate resources. Although encoder issues are typically rarer, the same applies to an encoder. Malicious stream data must not cause the encoder to misbehave, as this might allow an attacker access to transcoding gateways.",
      "ja": "VP8デコーダーは、[RFC4732]および[RFC3552]で概説されているように、適切なセキュリティに関する考慮事項を考慮に入れる必要があります。デコーダーが悪意のあるペイロードに対して堅牢であることが非常に重要です。悪意のあるペイロードにより、デコーダーが割り当てられたメモリをオーバーランさせたり、過度のリソースを消費したりしてはなりません。通常、エンコーダーの問題はまれですが、エンコーダーにも同じことが当てはまります。悪意のあるストリームデータは、攻撃者がトランスコーディングゲートウェイへのアクセスを可能にする可能性があるため、エンコーダーを不正にしてはなりません。"
    },
    {
      "indent": 0,
      "text": "22. References",
      "section_title": true,
      "ja": "22. 参考文献"
    },
    {
      "indent": 0,
      "text": "22.1. Normative Reference",
      "section_title": true,
      "ja": "22.1. 規範的な参照"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "22.2. Informative References",
      "section_title": true,
      "ja": "22.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Bell] Bell, T., Cleary, J., and I. Witten, \"Text Compression\", 1990.",
      "ja": "[ベル]ベル、T。、クリアリー、J。、およびI.ウィッテン、「テキスト圧縮」、1990。"
    },
    {
      "indent": 3,
      "text": "[ISO-C99] International Organization for Standardization, \"Information technology -- Programming languages -- C\", ISO/IEC 9899:1999, 1999.",
      "ja": "[ISO-C99]国際標準化機関、「情報技術 - プログラミング言語-C」、ISO/IEC 9899：1999、1999。"
    },
    {
      "indent": 3,
      "text": "[ITU-R_BT.601] International Telecommunication Union, \"ITU BT.601-7: Studio encoding parameters of digital television for standard 4:3 and wide screen 16:9 aspect ratios\", March 2011.",
      "ja": "[ITU-R_BT.601] International Telecommunication Union、「ITU BT.601-7：2011年3月、標準4：3およびワイドスクリーン16：9のアスペクト比のためのデジタルテレビのパラメーターをエンコードするスタジオ」。"
    },
    {
      "indent": 3,
      "text": "[Kernighan] Kernighan, B. and D. Ritchie, \"The C Programming Language (2nd edition)\", April 1988.",
      "ja": "[Kernighan] Kernighan、B。およびD. Ritchie、「The Cプログラミング言語（第2版）」、1988年4月。"
    },
    {
      "indent": 3,
      "text": "[Loeffler] Loeffler, C., Ligtenberg , A., and G. Moschytz, \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\", May 1989.",
      "ja": "[Loeffler] Loeffler、C.、Ligtenberg、A。、およびG. Moschytz、「11乗を伴う実用的な高速1-D DCTアルゴリズム」、1989年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3552] Rescorla, E. and B. Korver, \"Guidelines for Writing RFC Text on Security Considerations\", BCP 72, RFC 3552, July 2003.",
      "ja": "[RFC3552] Rescorla、E。およびB. Korver、「セキュリティに関する考慮事項に関するRFCテキストを書くためのガイドライン」、BCP 72、RFC 3552、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4732] Handley, M., Ed., Rescorla, E., Ed., and IAB, \"Internet Denial-of-Service Considerations\", RFC 4732, December 2006.",
      "ja": "[RFC4732] Handley、M.、Ed。、Rescorla、E.、ed。、およびIAB、「インターネット拒否に関する考慮事項」、RFC 4732、2006年12月。"
    },
    {
      "indent": 3,
      "text": "[Shannon] Shannon, C., \"A Mathematical Theory of Communication\", Bell System Technical Journal Vol. 27, pp. 379-423 and 623-656, July and October 1948.",
      "ja": "[シャノン]シャノン、C。、「コミュニケーションの数学理論」、Bell System Technical Journal Vol。27、pp。379-423および623-656、1948年7月と10月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "James Bankoski Google Inc.",
      "ja": "James Bankoski Google Inc."
    },
    {
      "indent": 3,
      "text": "EMail: jimbankoski@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "John Koleszar Google Inc.",
      "ja": "John Koleszar Google Inc."
    },
    {
      "indent": 3,
      "text": "EMail: jkoleszar@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Lou Quillio Google Inc.",
      "ja": "Lou Quillio Google Inc."
    },
    {
      "indent": 3,
      "text": "EMail: louquillio@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Janne Salonen Google Inc.",
      "ja": "Janne Salonen Google Inc."
    },
    {
      "indent": 3,
      "text": "EMail: jsalonen@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Paul Wilkins Google Inc.",
      "ja": "Paul Wilkins Google Inc."
    },
    {
      "indent": 3,
      "text": "EMail: paulwilkins@google.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Yaowu Xu Google Inc.",
      "ja": "Yaowu Xu Google Inc."
    },
    {
      "indent": 3,
      "text": "EMail: yaowu@google.com",
      "raw": true,
      "ja": ""
    }
  ]
}