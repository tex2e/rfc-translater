{
  "title": {
    "text": "RFC 7664 - Dragonfly Key Exchange",
    "ja": "RFC 7664 - Dragonfly 鍵交換"
  },
  "number": 7664,
  "created_at": "2020-08-30 11:23:26.387382+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                      D. Harkins, Ed.\nRequest for Comments: 7664                                Aruba Networks\nCategory: Informational                                    November 2015\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Dragonfly Key Exchange",
      "ja": "Dragonfly 鍵交換"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a key exchange using discrete logarithm cryptography that is authenticated using a password or passphrase. It is resistant to active attack, passive attack, and offline dictionary attack. This document is a product of the Crypto Forum Research Group (CFRG).",
      "ja": "このドキュメントでは、パスワードまたはパスフレーズを使用して認証される離散対数暗号を使用する鍵交換を指定します。能動的攻撃、受動的攻撃、オフライン辞書攻撃に耐性があります。このドキュメントは、Crypto Forum Research Group（CFRG）の成果物です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the individual opinion(s) of one or more members of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、Internet Research Task Force（IRTF）の成果物です。 IRTFは、インターネット関連の研究開発活動の結果を公開しています。これらの結果は、展開に適さない可能性があります。このRFCは、インターネットリサーチタスクフォース（IRTF）のCrypto Forum Research Group（CFRG）の1人以上のメンバーの個々の意見を表します。 IRSGによる公開が承認されたドキュメントは、どのレベルのインターネット標準の候補にもなりません。 RFC 5741のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7664.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、http://www.rfc-editor.org/info/rfc7664で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2015 IETF Trustおよびドキュメントの著者として特定された者。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、BCP 78および、この文書の発行日において有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   2\n  1.2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   3\n    1.2.1.  Notations . . . . . . . . . . . . . . . . . . . . . .   3\n    1.2.2.  Resistance to Dictionary Attack . . . . . . . . . . .   3\n2.  Discrete Logarithm Cryptography . . . . . . . . . . . . . . .   4\n  2.1.  Elliptic Curve Cryptography . . . . . . . . . . . . . . .   4\n  2.2.  Finite Field Cryptography . . . . . . . . . . . . . . . .   5\n3.  The Dragonfly Key Exchange  . . . . . . . . . . . . . . . . .   6\n  3.1.  Assumptions . . . . . . . . . . . . . . . . . . . . . . .   7\n  3.2.  Derivation of the Password Element  . . . . . . . . . . .   8\n    3.2.1.  Hunting and Pecking with ECC Groups . . . . . . . . .  10\n    3.2.2.  Hunting and Pecking with MODP Groups  . . . . . . . .  12\n  3.3.  The Commit Exchange . . . . . . . . . . . . . . . . . . .  13\n  3.4.  The Confirm Exchange  . . . . . . . . . . . . . . . . . .  14\n4.  Security Considerations . . . . . . . . . . . . . . . . . . .  15\n5.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  5.1.  Normative References  . . . . . . . . . . . . . . . . . .  16\n  5.2.  Informative References  . . . . . . . . . . . . . . . . .  16\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  18\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  18",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Passwords and passphrases are the predominant way of doing authentication in the Internet today. Many protocols that use passwords and passphrases for authentication exchange password-derived data as a proof-of-knowledge of the password (for example, [RFC7296] and [RFC5433]). This opens the exchange up to an offline dictionary attack where the attacker gleans enough knowledge from either an active or passive attack on the protocol to run through a pool of potential passwords and compute verifiers until it is able to match the password-derived data.",
      "ja": "今日のインターネットでは、パスワードとパスフレーズが主な認証方法です。認証にパスワードとパスフレーズを使用する多くのプロトコルは、パスワードから得られたデータをパスワードの知識の証明として交換します（たとえば、[RFC7296]と[RFC5433]）。これにより、交換がオフライン辞書攻撃にさらされることになります。攻撃者は、プロトコルに対する能動的または受動的な攻撃から十分な知識を収集し、潜在的なパスワードのプールを総当たりして、パスワードから派生したデータと一致するまで検証子を計算します。"
    },
    {
      "indent": 3,
      "text": "This protocol employs discrete logarithm cryptography to perform an efficient exchange in a way that performs mutual authentication using a password that is provably resistant to an offline dictionary attack. Consensus of the CFRG for this document was rough.",
      "ja": "このプロトコルは、離散対数暗号を採用して、オフライン辞書攻撃に耐性があることが証明されているパスワードを使用して相互認証を実行する方法で効率的な交換を実行します。このドキュメントに対するCFRGのコンセンサスはラフコンセンサスでした。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Definitions",
      "section_title": true,
      "ja": "1.2. 定義"
    },
    {
      "indent": 0,
      "text": "1.2.1. Notations",
      "section_title": true,
      "ja": "1.2.1. 記法"
    },
    {
      "indent": 3,
      "text": "The following notations are used in this memo.",
      "ja": "このメモでは、次の表記が使用されています。"
    },
    {
      "indent": 3,
      "text": "password A shared, secret, and potentially low-entropy word, phrase, code, or key used as a credential to mutually authenticate the peers. It is not restricted to characters in a human language.",
      "ja": "password（パスワード） ピアを相互認証するための資格情報として使用される、共有された、秘密の、潜在的に低エントロピーの単語、フレーズ、コード、またはキー。人間の言語の文字に限定されません。"
    },
    {
      "indent": 3,
      "text": "a | b denotes concatenation of bit string \"a\" with bit string \"b\".",
      "ja": "a | bは、ビット文字列 \"a\" とビット文字列 \"b\" の連結を示します。"
    },
    {
      "indent": 3,
      "text": "len(a) indicates the length in bits of the bit string \"a\".",
      "ja": "len（a）は、ビット文字列 \"a\" のビット長を示します。"
    },
    {
      "indent": 3,
      "text": "lsb(a) returns the least-significant bit of the bit string \"a\".",
      "ja": "lsb（a）は、ビット文字列 \"a\" の最下位ビットを返します。"
    },
    {
      "indent": 3,
      "text": "lgr(a,b) takes \"a\" and a prime, \"b\", and returns the Legendre symbol (a/b).",
      "ja": "lgr（a、b）は \"a\" と素数 \"b\" を取り、ルジャンドル記号（a / b）を返します。"
    },
    {
      "indent": 3,
      "text": "min(a,b) returns the lexicographical minimum of strings \"a\" and \"b\", or zero (0) if \"a\" equals \"b\".",
      "ja": "min（a、b）は、文字列 \"a\"と \"b\" の辞書式最小値を返します。 \"a\" が \"b\"と等しい場合はゼロ（0）を返します。"
    },
    {
      "indent": 3,
      "text": "max(a,b) returns the lexicographical maximum of strings \"a\" and \"b\", or zero (0) if \"a\" equals \"b\".",
      "ja": "max（a、b）は、文字列 \"a\" と \"b\" の辞書式の最大値、または \"a\" が \"b\" と等しい場合はゼロ（0）を返します。"
    },
    {
      "indent": 3,
      "text": "The convention for this memo is to represent an element in a finite cyclic group with an uppercase letter or acronym, while a scalar is indicated with a lowercase letter or acronym. An element that represents a point on an elliptic curve has an implied composite nature -- i.e., it has both an x- and y-coordinate.",
      "ja": "このメモの規約では、有限巡回群の要素を大文字または頭字語で表し、スカラーを小文字または頭字語で示します。楕円曲線上の点を表す要素は、暗黙的に複合的な性質を持っています。つまり、x座標とy座標の両方を持っています。"
    },
    {
      "indent": 0,
      "text": "1.2.2. Resistance to Dictionary Attack",
      "section_title": true,
      "ja": "1.2.2. 辞書攻撃への耐性"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attack means that any advantage an adversary can gain must be directly related to the number of interactions she makes with an honest protocol participant and not through computation. The adversary will not be able to obtain any information about the password except whether a single guess from a protocol run is correct or incorrect.",
      "ja": "辞書攻撃への耐性とは、攻撃者が得ることができる利点は、計算ではなく、正直なプロトコル参加者とのやり取りの数に直接関係する必要があることを意味します。攻撃者は、プロトコル実行からの単一の推測が正しいか正しくないかを除いて、パスワードに関する情報を取得できません。"
    },
    {
      "indent": 0,
      "text": "2. Discrete Logarithm Cryptography",
      "section_title": true,
      "ja": "2. 離散対数暗号"
    },
    {
      "indent": 3,
      "text": "Dragonfly uses discrete logarithm cryptography to achieve authentication and key agreement (see [SP800-56A]). Each party to the exchange derives ephemeral keys with respect to a particular set of domain parameters (referred to here as a \"group\"). A group can be based on Finite Field Cryptography (FFC) or Elliptic Curve Cryptography (ECC).",
      "ja": "Dragonflyは、離散対数暗号を使用して認証と鍵の合意を実現します（[SP800-56A]を参照）。交換の各当事者は、ドメインパラメータの特定のセット（ここでは「グループ」と呼ばれます）に関する一時キーを導出します。グループは、有限体暗号（FFC）または楕円曲線暗号（ECC）に基づくことができます。"
    },
    {
      "indent": 3,
      "text": "Three operations are defined for both types of groups:",
      "ja": "両方のタイプのグループに対して3つの操作が定義されています。"
    },
    {
      "indent": 3,
      "text": "o \"scalar operation\" -- takes a scalar and an element in the group to produce another element -- Z = scalar-op(x, Y).",
      "ja": "o 「スカラー演算」- グループ内のスカラーと要素を取り、別の要素を生成します-Z = scalar-op（x、Y）。"
    },
    {
      "indent": 3,
      "text": "o \"element operation\" -- takes two elements in the group to produce a third -- Z = element-op(X, Y).",
      "ja": "o 「要素演算」- グループ内の2つの要素を使用して、3番目の要素を生成します-Z = element-op（X、Y）。"
    },
    {
      "indent": 3,
      "text": "o \"inverse operation\" -- takes an element and returns another element such that the element operation on the two produces the identity element of the group -- Y = inverse(X).",
      "ja": "o 「逆演算」- 要素を受け取り、2つの要素の演算がグループの単位要素を生成するように別の要素を返します-Y = inverse（X）。"
    },
    {
      "indent": 0,
      "text": "2.1. Elliptic Curve Cryptography",
      "section_title": true,
      "ja": "2.1. 楕円曲線暗号"
    },
    {
      "indent": 3,
      "text": "Domain parameters for the ECC groups used by Dragonfly are:",
      "ja": "Dragonflyが使用するECCグループのドメインパラメータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p). The cryptographic group will be a subgroup of the full elliptic curve group that consists of points on an elliptic curve -- elements from GF(p) that satisfy the curve's equation -- together with the \"point at infinity\" that serves as the identity element. The group operation for ECC groups is addition of points on the elliptic curve.",
      "ja": "o 素数pは、素体GF（p）を決定します。暗号グループは、楕円曲線上の点（曲線の方程式を満たすGF（p）の要素）と、単位元として機能する「無限遠点」で構成される完全な楕円曲線グループの部分群になります。ECCグループのグループ演算は、楕円曲線上の点の加算です。"
    },
    {
      "indent": 3,
      "text": "o Elements a and b from GF(p) that define the curve's equation. The point (x, y) in GF(p) x GF(p) is on the elliptic curve if and only if (y^2 - x^3 - a*x - b) mod p equals zero (0).",
      "ja": "o 曲線の方程式を定義するGF（p）の要素aおよびb。 （y ^ 2-x ^ 3-a * x-b）mod pがゼロ（0）に等しい場合に限り、GF（p）x GF（p）の点（x、y）は楕円曲線上にあります。"
    },
    {
      "indent": 3,
      "text": "o A point, G, on the elliptic curve, which serves as a generator for the ECC group. G is chosen such that its order, with respect to elliptic curve addition, is a sufficiently large prime.",
      "ja": "o ECCグループの生成元として機能する楕円曲線上の点G。 Gは、楕円曲線加算に関して、その位数が十分に大きな素数になるように選択されます。"
    },
    {
      "indent": 3,
      "text": "o A prime, q, which is the order of G, and thus is also the size of the cryptographic subgroup that is generated by G.",
      "ja": "o Gの位数である素数qは、Gによって生成される暗号部分群のサイズでもあります。"
    },
    {
      "indent": 0,
      "text": " An (x,y) pair is a valid ECC element if: 1) the x- and y-coordinates are both greater than zero (0) and less than the prime defining the underlying field; and, 2) the x- and y-coordinates satisfy the equation for the curve and produce a valid point on the curve that is not the point at infinity. If either one of those conditions do not hold, the (x,y) pair is not a valid element.",
      "ja": "（x、y）ペアは、次の場合に有効なECC要素です。1）x座標とy座標の両方がゼロ（0）より大きく、基礎となるフィールドを定義する素数よりも小さい。 2）x座標とy座標は曲線の方程式を満たし、無限遠点ではない有効な曲線上の点を生成します。これらの条件のいずれかが満たされない場合、（x、y）のペアは有効な要素ではありません。"
    },
    {
      "indent": 3,
      "text": "The scalar operation is addition of a point on the curve with itself a number of times. The point Y is multiplied x times to produce another point Z:",
      "ja": "スカラー演算は、曲線上の点をそれ自体に複数回加算することです。点Yをx倍して、別の点Zを生成します。"
    },
    {
      "indent": 6,
      "text": "Z = scalar-op(x, Y) = x*Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The element operation is addition of two points on the curve. Points X and Y are summed to produce another point Z:",
      "ja": "要素演算は、曲線上の2点の加算です。点Xと点Yを加算して、別の点Zを生成します。"
    },
    {
      "indent": 6,
      "text": "Z = element-op(X, Y) = X + Y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The inverse function is defined such that the sum of an element and its inverse is \"0\", the point at infinity of an elliptic curve group:",
      "ja": "逆演算は、要素とその逆元の和が楕円曲線グループの無限遠点である「0」になるように定義されます。"
    },
    {
      "indent": 6,
      "text": "R + inverse(R) = \"0\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Elliptic curve groups require a mapping function, q = F(Q), to convert a group element to an integer. The mapping function used in this memo returns the x-coordinate of the point it is passed.",
      "ja": "楕円曲線グループには、グループ要素を整数に変換するためのマッピング関数q = F（Q）が必要です。このメモで使用されているマッピング関数は、渡された点のx座標を返します。"
    },
    {
      "indent": 3,
      "text": "scalar-op(x, Y) can be viewed as x iterations of element-op() by defining:",
      "ja": "scalar-op（x、Y）は、以下を定義することにより、element-op()のx回の反復と見なすことができます。"
    },
    {
      "indent": 6,
      "text": "Y = scalar-op(1, Y)",
      "ja": "Y = scalar-op(1, Y)"
    },
    {
      "indent": 6,
      "text": "Y = scalar-op(x, Y) = element-op(Y, scalar-op(x-1, Y)), for x > 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A definition of how to add two points on an elliptic curve (i.e., element-op(X, Y)) can be found in [RFC6090].",
      "ja": "楕円曲線上の2つの点を加算する方法の定義（つまり、element-op（X、Y））は、[RFC6090]にあります。"
    },
    {
      "indent": 3,
      "text": "Note: There is another elliptic curve domain parameter, a cofactor, h, that is defined by the requirement that the size of the full elliptic curve group (including \"0\") be the product of h and q. Elliptic curve groups used with Dragonfly authentication MUST have a cofactor of one (1).",
      "ja": "注：別の楕円曲線ドメインパラメータである補因子hがあります。これは、完全な楕円曲線グループ（「0」を含む）のサイズがhとqの積であるという要件によって定義されます。 Dragonfly認証で使用される楕円曲線グループは、補因子が1でなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Finite Field Cryptography",
      "section_title": true,
      "ja": "2.2. 有限体暗号"
    },
    {
      "indent": 3,
      "text": "Domain parameters for the FFC groups used in Dragonfly are:",
      "ja": "Dragonflyで使用されるFFCグループのドメインパラメータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p), the integers modulo p. The FFC group will be a subgroup of GF(p)*, the multiplicative group of non-zero elements in GF(p). The group operation for FFC groups is multiplication modulo p.",
      "ja": "o 素数p。これは素体GF(p)（pを法とする整数）を決定します。FFCグループは、GF(p)の非ゼロ要素の乗法群であるGF(p)*の部分群となります。FFCグループのグループ演算は、pを法とする乗算です。"
    },
    {
      "indent": 3,
      "text": "o An element, G, in GF(p)* which serves as a generator for the FFC group. G is chosen such that its multiplicative order is a sufficiently large prime divisor of ((p-1)/2).",
      "ja": "o FFCグループの生成元として機能するGF（p）*の要素G。 Gは、その乗法位数が（（p-1）/ 2）の十分に大きな素因数になるように選択されます。"
    },
    {
      "indent": 3,
      "text": "o A prime, q, which is the multiplicative order of G, and thus also the size of the cryptographic subgroup of GF(p)* that is generated by G.",
      "ja": "o Gの乗法位数である素数q。これは、Gによって生成されるGF(p)*の暗号部分群のサイズでもあります。"
    },
    {
      "indent": 3,
      "text": "A number is a valid element in an FFC group if: 1) it is between one (1) and one (1) less than the prime, p, exclusive (i.e., 1 < element < p-1); and, 2) if modular exponentiation of the element by the group order, q, equals one (1). If either one of those conditions do not hold, the number is not a valid element.",
      "ja": "次の場合、数値はFFCグループ内の有効な要素です。1）1より大きく、かつ素数 p より 1 小さい値未満である（つまり、1 < element < p-1）。そして、2）要素をグループ位数qでモジュラべき乗した結果が1に等しい場合。これらの条件のいずれかが満たされない場合、数値は有効な要素ではありません。"
    },
    {
      "indent": 3,
      "text": "The scalar operation is exponentiation of a generator modulo a prime. An element Y is taken to the x-th power modulo the prime returning another element, Z:",
      "ja": "スカラー演算は、素数を法とする生成元のべき乗です。要素Yは、素数を法としてx乗され、別の要素Zになります。"
    },
    {
      "indent": 6,
      "text": "Z = scalar-op(x, Y) = Y^x mod p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The element operation is modular multiplication. Two elements, X and Y, are multiplied modulo the prime returning another element, Z:",
      "ja": "要素演算はモジュラー乗算です。 2つの要素XとYは、素数を法として乗算され、別の要素Zを返します。"
    },
    {
      "indent": 6,
      "text": "Z = element-op(X, Y) = (X * Y) mod p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The inverse function for a MODP group is defined such that the product of an element and its inverse modulo the group prime equals one (1). In other words,",
      "ja": "MODPグループの逆関数は、要素と、グループの素数を法とするその逆元との積が1になるように定義されています。言い換えると、"
    },
    {
      "indent": 6,
      "text": "(R * inverse(R)) mod p = 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. The Dragonfly Key Exchange",
      "section_title": true,
      "ja": "3. Dragonfly 鍵交換"
    },
    {
      "indent": 3,
      "text": "There are two parties to the Dragonfly exchange named, for convenience and by convention, Alice and Bob. The two parties have a shared password that was established in an out-of-band mechanism, and they both agree to use a particular domain parameter set (either ECC or FFC). In the Dragonfly exchange, both Alice and Bob share an identical view of the shared password -- i.e., it is not \"augmented\", where one side holds a password and the other side holds a non-invertible verifier. This allows Dragonfly to be used in traditional client-server protocols and also in peer-to-peer applications in which there are not fixed roles and either party may initiate the exchange (and both parties may implement it simultaneously).",
      "ja": "便宜上および慣例により、Dragonfly交換にはアリスとボブという名前の2つの当事者が存在します。 2つのパーティは、アウトオブバンドメカニズムで確立された共有パスワードを持ち、両者は特定のドメインパラメータセット（ECCまたはFFC）を使用することに同意します。 Dragonfly交換では、アリスとボブの両方が共有パスワードの同一のビューを共有します。つまり、一方がパスワードを保持し、もう一方が非可逆的な検証子を保持する「拡張」されていません。これにより、Dragonflyを従来のクライアントサーバープロトコルで使用したり、固定の役割がなく、いずれかの当事者が交換を開始したりできる（両方の当事者が同時に実装する可能性がある）ピアツーピアアプリケーションでも使用できます。"
    },
    {
      "indent": 0,
      "text": " Prior to beginning the Dragonfly exchange, the two peers MUST derive a secret element in the chosen domain parameter set. Two \"hunting-and-pecking\" techniques to determine a secret element, one for ECC and one for FFC, are described in Section 3.2, but any secure, deterministic method that is agreed upon can be used. For instance, the technique described in [hash2ec] can be used for ECC groups.",
      "ja": "Dragonfly交換を開始する前に、2つのピアは、選択されたドメインパラメータセットの秘密要素を導出する必要があります。 1つはECC、もう1つはFFCの秘密要素を決定するための2つの「ハンティングアンドペッキング」手法については、セクション3.2で説明していますが、合意された安全で確定的な方法を使用できます。たとえば、[hash2ec]で説明されている手法は、ECCグループに使用できます。"
    },
    {
      "indent": 3,
      "text": "The Dragonfly exchange consists of two message exchanges, a \"Commit Exchange\" in which both sides commit to a single guess of the password, and a \"Confirm Exchange\" in which both sides confirm knowledge of the password. A side effect of running the Dragonfly exchange is an authenticated, shared, and secret key whose cryptographic strength is set by the agreed-upon group.",
      "ja": "Dragonfly交換は、2つのメッセージ交換で構成されます。「コミット交換」では、両側がパスワードの単一の推測にコミットします。「確認交換」では、両側がパスワードの知識を確認します。 Dragonfly交換を実行した結果として、合意されたグループによって暗号強度が設定された、認証された共有秘密鍵が得られます。"
    },
    {
      "indent": 3,
      "text": "Dragonfly uses a random function, H(), a mapping function, F(), and a key derivation function, KDF().",
      "ja": "Dragonflyは、ランダム関数H()、マッピング関数F()、およびキー導出関数KDF()を使用します。"
    },
    {
      "indent": 0,
      "text": "3.1. Assumptions",
      "section_title": true,
      "ja": "3.1. 仮定"
    },
    {
      "indent": 3,
      "text": "In order to avoid attacks on the Dragonfly protocol, some basic assumptions are made:",
      "ja": "Dragonflyプロトコルへの攻撃を回避するために、いくつかの基本的な仮定が行われます。"
    },
    {
      "indent": 3,
      "text": "1. Function H is a \"random oracle\" (see [RANDOR]) that maps a binary string of indeterminate length onto a fixed binary string that is x bits in length.",
      "ja": "1. 関数Hは、長さが不定のバイナリ文字列を長さがxビットの固定バイナリ文字列にマッピングする「ランダムオラクル」（[RANDOR]を参照）です。"
    },
    {
      "indent": 10,
      "text": "H: {0,1}^* --> {0,1}^x",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "2. Function F is a mapping function that takes an element in a group and returns an integer. For ECC groups, function F() returns the x-coordinate of the element (which is a point on the elliptic curve); for FFC groups, function F() is the identity function (since all elements in an FFC group are already integers less than the prime).",
      "ja": "2. 関数Fは、グループ内の要素を取り、整数を返すマッピング関数です。 ECCグループの場合、関数F()は要素（楕円曲線上の点）のx座標を返します。 FFCグループの場合、関数F()は恒等関数です（FFCグループのすべての要素は素数よりも小さい整数になっているため）。"
    },
    {
      "indent": 10,
      "text": "ECC: x = F(P), where P=(x,y)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "FFC: x = F(x)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3. Function KDF is a key derivation function (see, for instance, [SP800-108]) that takes a key to stretch, k, a label to bind to the key, label, and an indication of the desired output, n:",
      "ja": "3. 関数KDFは、キー導出関数（たとえば、[SP800-108]を参照）で、ストレッチするキーk、キーにバインドするlabel（ラベル）、および希望する出力の長さの指示 nを受け取ります。"
    },
    {
      "indent": 10,
      "text": "stretch = KDF-n(k, label)",
      "ja": "ストレッチ= KDF-n（k、ラベル）"
    },
    {
      "indent": 7,
      "text": "so that len(stretch) equals n.",
      "ja": "len（stretch）がnと等しくなるようにします。"
    },
    {
      "indent": 3,
      "text": "4. The discrete logarithm problem for the chosen group is hard. That is, given G, P, and Y = G^x mod p, it is computationally infeasible to determine x. Similarly, for an ECC group given the curve definition, a generator G, and Y = x * G, it is computationally infeasible to determine x.",
      "ja": "4. 選択したグループの離散対数問題は困難です。つまり、G、P、およびY = G ^ x mod pの場合、xを決定することは計算量的に困難です。同様に、曲線の定義が与えられたECCグループ、ジェネレーターG、およびY = x * Gの場合、xを決定することは計算量的に困難です。"
    },
    {
      "indent": 3,
      "text": "5. There exists a pool of passwords from which the password shared by the two peers is drawn. This pool can consist of words from a dictionary, for example. Each password in this pool has an equal probability of being the shared password. All potential attackers have access to this pool of passwords.",
      "ja": "5. 2つのピアが共有するパスワードを引き出すパスワードのプールが存在します。このプールは、たとえば、辞書の単語で構成できます。このプール内の各パスワードは、共有パスワードである確率が同じです。すべての潜在的な攻撃者は、このパスワードのプールにアクセスできます。"
    },
    {
      "indent": 3,
      "text": "6. The peers have the ability to produce quality random numbers.",
      "ja": "6. ピアは、高品質の乱数を生成することができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Derivation of the Password Element",
      "section_title": true,
      "ja": "3.2. パスワード要素の導出"
    },
    {
      "indent": 3,
      "text": "Prior to beginning the exchange of information, the peers MUST derive a secret element, called the Password Element (PE), in the group defined by the chosen domain parameter set. From the point of view of an attacker who does not know the password, the PE will be a random element in the negotiated group. Two examples are described here for completeness, but any method of deterministically mapping a secret string into an element in a selected group can be used -- for instance, the technique in [hash2ec] for ECC groups. If a different technique than the ones described here is used, the secret string SHOULD include the identities of the peers.",
      "ja": "情報の交換を開始する前に、ピアは、選択されたドメインパラメータセットによって定義されたグループ内で、パスワード要素（PE）と呼ばれる秘密要素を導出する必要があります。パスワードを知らない攻撃者の観点から見ると、PEはネゴシエートされたグループのランダムな要素になります。完全を期すために2つの例をここで説明しますが、秘密の文字列を選択したグループの要素に決定論的にマッピングする方法を使用できます。たとえば、ECCグループの[hash2ec]の手法です。ここで説明されているものとは異なる手法を使用する場合、秘密の文字列にはピアのIDを含める必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "To fix the PE, both peers MUST have a common view of the password. If there is any password processing necessary (for example, to support internationalization), the processed password is then used as the shared credential. If either side wants to store a hashed version of the password (hashing the password with random data called a \"salt\"), it will be necessary to convey the salt to the other side prior to commencing the exchange, and the hashed password is then used as the shared credential.",
      "ja": "PEを確定するには、両方のピアがパスワードの共通のビューを持っている必要があります。 （たとえば、国際化をサポートするために）パスワード処理が必要な場合は、処理されたパスワードが共有資格情報として使用されます。どちらかの側がハッシュされたバージョンのパスワード（「ソルト」と呼ばれるランダムなデータでパスワードをハッシュ化）を保存する場合、交換を開始する前にソルトをもう一方の側に伝達する必要があります。ハッシュされたパスワードは共有資格情報として使用されます。"
    },
    {
      "indent": 3,
      "text": "Note: Only one party would be able to maintain a salted password, and this would require that the Dragonfly key exchange be used in a protocol that has strict roles for client (that always initiates) and server (that always responds). Due to the symmetric nature of Dragonfly, salting passwords does not prevent an impersonation attack after compromise of a database of salted passwords.",
      "ja": "注：ソルト化されたパスワードを維持できるのは1つのパーティだけであり、クライアント（常に開始する）とサーバー（常に応答する）に厳密な役割を持つプロトコルでDragonfly鍵交換を使用する必要があります。 Dragonflyは対称的な性質を持つため、パスワードをソルトしても、ソルトされたパスワードのデータベースが侵害された後のなりすまし攻撃を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "The deterministic process to select the PE begins with choosing a secret seed and then performing a group-specific hunting-and-pecking technique -- one for FFC groups and another for ECC groups.",
      "ja": "PEを選択する決定論的なプロセスは、シークレットシードを選択してから、グループ固有のハンティングアンドペッキング技術を実行することから始まります。1つはFFCグループ用、もう1つはECCグループ用です。"
    },
    {
      "indent": 3,
      "text": "To thwart side-channel attacks that attempt to determine the number of iterations of the hunting-and-pecking loop used to find the PE for a given password, a security parameter, k, is used that ensures that at least k iterations are always performed. The probability that one requires more than n iterations of the hunting-and-pecking loop to find an ECC PE is roughly (q/2p)^n and to find an FFC PE is roughly (q/p)^n, both of which rapidly approach zero (0) as n increases. The security parameter, k, SHOULD be set sufficiently large such that the probability that finding the PE would take more than k iterations is sufficiently small (see Section 4).",
      "ja": "特定のパスワードのPEを見つけるために使用されるハンティングアンドペッキングループの反復数を決定しようとするサイドチャネル攻撃を阻止するために、セキュリティパラメータkを使用して、少なくともk回の反復が常に実行されるようにします。 ECC PEを見つけるためにハンティングアンドペッキングループをn回以上繰り返す必要がある確率はおよそ (q/2p)^nであり、FFC PEを見つける確率はおよそ (q/p)^nです。 nが増加するにつれて、急速にゼロ（0）に近づきます。セキュリティパラメータkは、PEを見つけるのにk回以上の反復を要する確率が十分に小さくなるように、十分に大きく設定する必要があります（セクション4を参照）。"
    },
    {
      "indent": 3,
      "text": "First, an 8-bit counter is set to one (1), and a secret base is computed using the negotiated one-way function with the identities of the two participants, Alice and Bob, the secret password, and the counter:",
      "ja": "最初に、8ビットのカウンターが1に設定され、2つの参加者、アリスとボブのID、秘密のパスワード、およびカウンターを使用してネゴシエートされた一方向関数を使用して、秘密のベースが計算されます。"
    },
    {
      "indent": 3,
      "text": "base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The identities are passed to the max() and min() functions to provide the necessary ordering of the inputs to H() while still allowing for a peer-to-peer exchange where both Alice and Bob each view themselves as the \"initiator\" of the exchange.",
      "ja": "IDはmax()関数とmin()関数に渡され、H()への入力に必要な順序を提供しながら、アリスとボブの両方がそれぞれ自分自身を交換の「開始者」と見なすことができるピアツーピア交換を可能にします。"
    },
    {
      "indent": 3,
      "text": "The base is then stretched using the technique from Section B.5.1 of [FIPS186-4]. The key derivation function, KDF, is used to produce a bitstream whose length is equal to the length of the prime from the group's domain parameter set plus the constant sixty-four (64) to derive a temporary value, and the temporary value is modularly reduced to produce a seed:",
      "ja": "次に、[FIPS186-4]のセクションB.5.1の手法を使用してベースを伸長します。キー導出関数KDFを使用して、グループのドメインパラメーターセットからの素数の長さに定数64を加えた長さに等しいビットストリームを生成し、一時値を導出します。この一時値はモジュラー簡約され、シードが生成されます。"
    },
    {
      "indent": 3,
      "text": "n = len(p) + 64",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "temp = KDF-n(base, \"Dragonfly Hunting and Pecking\")",
      "ja": "temp = KDF-n（base、 \"Dragonfly Hunting and Pecking\"）"
    },
    {
      "indent": 3,
      "text": "seed = (temp mod (p - 1)) + 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The string bound to the derived temporary value is for illustrative purposes only. Implementations of the Dragonfly key exchange SHOULD use a usage-specific label with the KDF.",
      "ja": "派生した一時的な値にバインドされた文字列は、説明のみを目的としています。 Dragonfly鍵交換の実装では、KDFで用途固有のラベルを使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Note: The base is stretched to 64 more bits than are needed so that the bias from the modular reduction is not so apparent.",
      "ja": "注：ベースは必要以上に64ビットに拡張されているため、モジュラー簡約によるバイアスはそれほど明白ではありません。"
    },
    {
      "indent": 3,
      "text": "The seed is then passed to the group-specific hunting-and-pecking technique.",
      "ja": "次に、シードはグループ固有のハンティングアンドペッキング技術に渡されます。"
    },
    {
      "indent": 3,
      "text": "If the protocol performing the Dragonfly exchange has the ability to exchange random nonces, those SHOULD be added to the computation of the base to ensure that each run of the protocol produces a different PE.",
      "ja": "Dragonfly交換を実行するプロトコルがランダムなナンスを交換する機能を持っている場合、それらのナンスをベースの計算に追加して、プロトコルの実行ごとに異なるPEが生成されるようにする必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Hunting and Pecking with ECC Groups",
      "section_title": true,
      "ja": "3.2.1. ECCグループを使用したハンティングとペッキング"
    },
    {
      "indent": 3,
      "text": "The ECC-specific hunting-and-pecking technique entails looping until a valid point on the elliptic curve has been found. The seed is used as an x-coordinate with the equation of the curve to check whether x^3 + a*x + b is a quadratic residue modulo p. If it is not, then the counter is incremented, a new base and new seed are generated, and the hunting and pecking continues. If it is a quadratic residue modulo p, then the x-coordinate is assigned the value of seed and the current base is stored. When the hunting-and-pecking loop terminates, the x-coordinate is used with the equation of the curve to solve for a y-coordinate. An ambiguity exists since two values for the y-coordinate would be valid, and the low-order bit of the stored base is used to unambiguously determine the correct y-coordinate. The resulting (x,y) pair becomes the Password Element, PE.",
      "ja": "ECC固有のハンティングアンドペッキング技術では、楕円曲線上の有効な点が見つかるまでループが必要です。シードは、曲線の方程式のx座標として使用され、x ^ 3 + a * x + bがpを法とする平方剰余であるかどうかを確認します。そうでない場合は、カウンターがインクリメントされ、新しいベースと新しいシードが生成され、ハンティングとペッキングが続行されます。 pを法とする平方剰余の場合、x座標にはシードの値が割り当てられ、現在のベースが格納されます。ハンティングアンドペッキングループが終了すると、x座標と曲線の方程式が使用され、y座標が求められます。 y座標の2つの値が有効であるため、あいまいさが存在し、格納されているベースの下位ビットを使用して、正しいy座標を明確に決定します。結果の（x、y）ペアは、パスワード要素、PEになります。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的には、プロセスは次のようになります。"
    },
    {
      "indent": 8,
      "text": "found = 0\ncounter = 1\nn = len(p) + 64\ndo {\n  base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)\n  temp = KDF-n(base, \"Dragonfly Hunting And Pecking\")\n  seed = (temp mod (p - 1)) + 1\n  if ( (seed^3 + a*seed + b) is a quadratic residue mod p)\n  then\n    if ( found == 0 )\n    then\n      x = seed\n      save = base\n      found = 1\n    fi\n  fi\n  counter = counter + 1\n} while ((found == 0) || (counter <= k))\ny = sqrt(x^3 + ax + b)\nif ( lsb(y) == lsb(save) )\nthen\n  PE = (x,y)\nelse\n  PE = (x,p-y)\nfi",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 1: Fixing PE for ECC Groups",
      "ja": "図1：ECCグループのPEの確定"
    },
    {
      "indent": 3,
      "text": "Checking whether a value is a quadratic residue modulo a prime can leak information about that value in a side-channel attack. Therefore, it is RECOMMENDED that the technique used to determine if the value is a quadratic residue modulo p blind the value with a random number so that the blinded value can take on all numbers between 1 and p-1 with equal probability while not changing its quadratic residuosity. Determining the quadratic residue in a fashion that resists leakage of information is handled by flipping a coin and multiplying the blinded value by either a random quadratic residue or a random quadratic nonresidue and checking whether the multiplied value is a quadratic residue (qr) or a quadratic nonresidue (qnr) modulo p, respectively. The random residue and nonresidue can be calculated prior to hunting and pecking by calculating the Legendre symbol on random values until they are found:",
      "ja": "値が素数を法とする平方剰余であるかどうかをチェックすると、サイドチャネル攻撃でその値に関する情報が漏洩する可能性があります。したがって、値がpを法とする平方剰余であるかどうかを決定するために使用される手法は、値を乱数でブラインド（隠蔽）し、その平方剰余性を変えることなく、ブラインドされた値が1からp-1の間のすべての数値を等しい確率で取り得るようにすることを推奨します（RECOMMENDED）。情報の漏出に抵抗する方法で平方剰余を決定するには、コインを投げて、ブラインド値にランダムな平方剰余またはランダムな平方非剰余のいずれかを乗算し、乗算された値がそれぞれpを法とする平方剰余（qr）か平方非剰余（qnr）かを確認します。ランダムな剰余と非剰余は、それらが見つかるまでランダムな値でルジャンドル記号を計算することにより、ハンティングとペッキングの前に計算できます。"
    },
    {
      "indent": 6,
      "text": "do {\n  qr = random() mod p\n} while ( lgr(qr, p) != 1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "do {\n  qnr = random() mod p\n} while ( lgr(qnr, p) != -1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Algorithmically, the masking technique to find out whether or not a value is a quadratic residue looks like this:",
      "ja": "アルゴリズム的に、値が平方剰余であるかどうかを調べるマスキングテクニックは次のようになります。"
    },
    {
      "indent": 6,
      "text": "is_quadratic_residue (val, p) {\n    r = (random() mod (p - 1)) + 1\n    num = (val * r * r) mod p\n    if ( lsb(r) == 1 )\n       num = (num * qr) mod p\n       if ( lgr(num, p) == 1)\n       then\n          return TRUE\n       fi\n    else\n       num = (num * qnr) mod p\n       if ( lgr(num, p) == -1)\n       then\n          return TRUE\n       fi\n    fi\n    return FALSE\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.2. Hunting and Pecking with MODP Groups",
      "section_title": true,
      "ja": "3.2.2. MODPグループでのハンティングとペッキング"
    },
    {
      "indent": 3,
      "text": "The MODP-specific hunting-and-pecking technique entails finding a random element which, when used as a generator, will create a group with the same order as the group created by the generator from the domain parameter set. The secret generator is found by exponentiating the seed to the value ((p-1)/q), where p is the prime and q is the order from the domain parameter set. If that value is greater than one (1), it becomes the PE; otherwise, the counter is incremented, a new base and seed are generated, and the hunting and pecking continues.",
      "ja": "MODP固有のハンティングアンドペッキングテクニックでは、ジェネレーターとして使用すると、ドメインパラメーターセットからジェネレーターによって作成されたグループと同じ位数を持つグループを作成するランダム要素を見つける必要があります。シークレットジェネレーターは、シードを値（（p-1）/ q）にべき乗することで見つかります。ここで、pは素数、qはドメインパラメーターセットからの位数です。その値が1より大きい場合は、PEになります。それ以外の場合は、カウンターがインクリメントされ、新しいベースとシードが生成され、ハンティングとペッキングが続行されます。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的には、プロセスは次のようになります。"
    },
    {
      "indent": 6,
      "text": "found = 0\ncounter = 1\nn = len(p) + 64\ndo {\n  base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)\n  temp = KDF-n(seed, \"Dragonfly Hunting And Pecking\")\n  seed = (temp mod (p - 1)) + 1\n  temp = seed ^ ((p-1)/q) mod p\n  if (temp > 1)\n  then\n    if (not found)\n      PE = temp\n      found = 1\n    fi\n  fi\n  counter = counter + 1\n} while ((found == 0) || (counter <= k))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 2: Fixing PE for MODP Groups",
      "ja": "図2：MODPグループのPEの確定"
    },
    {
      "indent": 0,
      "text": "3.3. The Commit Exchange",
      "section_title": true,
      "ja": "3.3. コミット交換"
    },
    {
      "indent": 3,
      "text": "In the Commit Exchange, both sides commit to a single guess of the password. The peers generate a scalar and an element, exchange them with each other, and process the other's scalar and element to generate a common and shared secret.",
      "ja": "コミット交換では、両側がパスワードの単一の推測にコミットします。ピアは、スカラーと要素を生成し、それらを相互に交換し、他のスカラーと要素を処理して、共通の共有秘密を生成します。"
    },
    {
      "indent": 3,
      "text": "First, each peer generates two random numbers, private and mask that are each greater than one (1) and less than the order from the selected domain parameter set:",
      "ja": "最初に、各ピアは2つの乱数、privateとmaskを生成します。これらはそれぞれ1より大きく、選択したドメインパラメータセットの位数よりも小さいです。"
    },
    {
      "indent": 6,
      "text": "1 < private < q\n1 < mask < q",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These two secrets and the Password Element are then used to construct the scalar and element:",
      "ja": "次に、これらの2つのシークレットとパスワード要素を使用して、スカラーと要素を作成します。"
    },
    {
      "indent": 9,
      "text": "scalar = (private + mask) modulo q\nElement = inverse(scalar-op(mask, PE))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the scalar is less than two (2), the private and mask MUST be thrown away and new values generated. Once a valid scalar and Element are generated, the mask is no longer needed and MUST be irretrievably destroyed.",
      "ja": "スカラーが2未満の場合は、プライベートとマスクを破棄し、新しい値を生成する必要があります。有効なスカラーと要素が生成されると、マスクは不要になり、回復不能に破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "The peers exchange their scalar and Element and check the peer's scalar and Element, deemed peer-scalar and Peer-Element. If the peer has sent an identical scalar and Element -- i.e., if scalar equals peer-scalar and Element equals Peer-Element -- it is sign of a reflection attack, and the exchange MUST be aborted. If the values differ, peer-scalar and Peer-Element must be validated. For the peer-scalar to be valid, it MUST be between 1 and q exclusive. Validation of the Peer-Element depends on the type of cryptosystem -- validation of an (x,y) pair as an ECC element is specified in Section 2.1, and validation of a number as an FFC element is specified in Section 2.2. If either the peer-scalar or Peer-Element fail validation, then the exchange MUST be terminated and authentication fails. If both the peer-scalar and Peer-Element are valid, they are used with the Password Element to derive a shared secret, ss:",
      "ja": "ピアは、スカラーと要素を交換し、ピアのスカラーと要素をチェックします。これらは、peer-scalarおよびPeer-Elementと見なされます。ピアが同じスカラーとエレメントを送信した場合（つまり、スカラーがピアスカラーに等しく、エレメントがピアエレメントに等しい場合）、これはリフレクション攻撃の兆候であり、交換を中止する必要があります。値が異なる場合は、peer-scalarおよびPeer-Elementを検証する必要があります。ピアスカラーが有効であるためには、1より大きくqより小さくなければなりません。ピアエレメントの検証は、暗号システムのタイプによって異なります。ECCエレメントとしての（x、y）ペアの検証はセクション2.1で指定され、FFCエレメントとしての数値の検証はセクション2.2で指定されます。ピアスカラーまたはピア要素のいずれかが検証に失敗した場合、交換を終了する必要があり、認証は失敗します。 peer-scalarとPeer-Elementの両方が有効な場合、それらはPassword Elementと共に使用され、共有秘密ssを導出します。"
    },
    {
      "indent": 12,
      "text": "ss = F(scalar-op(private,\n                 element-op(peer-Element,\n                            scalar-op(peer-scalar, PE))))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To enforce key separation and cryptographic hygiene, the shared secret is stretched into two subkeys -- a key confirmation key, kck, and a master key, mk. Each of the subkeys SHOULD be at least the length of the prime used in the selected group.",
      "ja": "鍵の分離と暗号の衛生を強化するために、共有シークレットは2つのサブ鍵（鍵確認鍵（kck）とマスター鍵（mk））に伸長されます。各サブキーは、少なくとも選択されたグループで使用される素数の長さである必要があります（SHOULD）。"
    },
    {
      "indent": 9,
      "text": "kck | mk = KDF-n(ss, \"Dragonfly Key Derivation\")",
      "ja": "kck | mk = KDF-n（ss、 \"Dragonfly Key Derivation\"）"
    },
    {
      "indent": 3,
      "text": "where n = len(p)*2.",
      "ja": "ここで、n = len（p）* 2です。"
    },
    {
      "indent": 0,
      "text": "3.4. The Confirm Exchange",
      "section_title": true,
      "ja": "3.4. 確認交換"
    },
    {
      "indent": 3,
      "text": "In the Confirm Exchange, both sides confirm that they derived the same secret, and therefore, are in possession of the same password.",
      "ja": "確認交換では、双方が同じ秘密を導出したことを確認し、したがって、同じパスワードを所有していることを確認します。"
    },
    {
      "indent": 3,
      "text": "The Commit Exchange consists of an exchange of data that is the output of the random function, H(), the key confirmation key, and the two scalars and two elements exchanged in the Commit Exchange. The order of the scalars and elements are: scalars before elements, and sender's value before recipient's value. So from each peer's perspective, it would generate:",
      "ja": "確認交換は、ランダム関数H()の出力であるデータの交換、キー確認キー、およびコミット交換で交換される2つのスカラーと2つの要素で構成されます。スカラーと要素の順序は、要素の前にスカラー、受信者の値の前に送信者の値となります。したがって、各ピアの観点からは、次のものが生成されます。"
    },
    {
      "indent": 16,
      "text": "confirm = H(kck | scalar | peer-scalar |\n            Element | Peer-Element | <sender-id>)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where <sender-id> is the identity of the sender of the confirm message. This identity SHALL be that contributed by the sender of the confirm message in generation of the base in Section 3.2.",
      "ja": "ここで、<sender-id>は確認メッセージの送信者のIDです。このアイデンティティは、セクション3.2のベースの生成で確認メッセージの送信者によって提供されたものである必要があります。"
    },
    {
      "indent": 3,
      "text": "The two peers exchange these confirmations and verify the correctness of the other peer's confirmation that they receive. If the other peer's confirmation is valid, authentication succeeds; if the other peer's confirmation is not valid, authentication fails.",
      "ja": "2つのピアはこれらの確認を交換し、受信した他のピアの確認が正しいことを確認します。他のピアの確認が有効な場合、認証は成功します。他のピアの確認が有効でない場合、認証は失敗します。"
    },
    {
      "indent": 3,
      "text": "If authentication fails, all ephemeral state created as part of the particular run of the Dragonfly exchange MUST be irretrievably destroyed. If authentication does not fail, mk can be exported as an authenticated and secret key that can be used by another protocol, for instance IPsec, to protect other data.",
      "ja": "認証が失敗した場合、Dragonfly交換の特定の実行の一部として作成されたすべての一時的な状態は、回復不能に破棄する必要があります。認証が失敗しない場合は、mkを認証済みの秘密鍵としてエクスポートし、IPsecなどの別のプロトコルで使用して、他のデータを保護できます。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The Dragonfly exchange requires both participants to have an identical representation of the password. Salting of the password merely generates a new credential -- the salted password -- that must be identically represented on both sides. If an adversary is able to gain access to the database of salted passwords, she would be able to impersonate one side to the other, even if she was unable to determine the underlying, unsalted password.",
      "ja": "Dragonfly交換では、両方の参加者が同一のパスワード表現を持つ必要があります。パスワードのソルト化は、新しいクレデンシャル（ソルトされたパスワード）を生成するだけです。これは、両側で同じように表現する必要があります。攻撃者がソルトパスワードのデータベースにアクセスできる場合、攻撃者は基礎となるソルトなしのパスワードを特定できなかったとしても、一方の当事者になりすまして他方と通信することができます。"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attack means that an adversary must launch an active attack to make a single guess at the password. If the size of the dictionary from which the password was extracted was d, and each password in the dictionary has an equal probability of being chosen, then the probability of success after a single guess is 1/d. After x guesses, and removal of failed guesses from the pool of possible passwords, the probability becomes 1/(d-x). As x grows, so does the probability of success. Therefore, it is possible for an adversary to determine the password through repeated brute-force, active, guessing attacks. Users of the Dragonfly key exchange SHOULD ensure that the size of the pool from which the password was drawn, d, is sufficiently large to make this attack preventable. Implementations of Dragonfly SHOULD support countermeasures to deal with this attack -- for instance, by refusing authentication attempts for a certain amount of time, after the number of failed authentication attempts reaches a certain threshold. No such threshold or amount of time is recommended in this memo.",
      "ja": "辞書攻撃への耐性とは、攻撃者がパスワードを1回推測するために能動的攻撃を開始する必要があることを意味します。パスワードが抽出されたディクショナリのサイズがdで、ディクショナリ内の各パスワードが選択される確率が等しい場合、1回の推測で成功する確率は1 / dです。 x回推測し、失敗した推測を可能なパスワードのプールから削除すると、確率は1 /（d-x）になります。 xが大きくなると、成功の確率も大きくなります。したがって、攻撃者がブルートフォース攻撃、推測攻撃を繰り返し行うことでパスワードを決定する可能性があります。 Dragonfly鍵交換のユーザーは、パスワードの取得元のプールのサイズdが、この攻撃を防止できるように十分に大きいことを確認する必要があります（SHOULD）。 Dragonflyの実装は、この攻撃に対処するための対策をサポートする必要があります（SHOULD）。たとえば、失敗した認証試行の回数が特定のしきい値に達した後、特定の時間、認証試行を拒否することによって。このメモでは、そのようなしきい値や時間量は推奨されていません。"
    },
    {
      "indent": 3,
      "text": "Due to the problems with using groups that contain a small subgroup, it is RECOMMENDED that implementations of Dragonfly not allow for the specification of a group's complete domain parameter to be sent in-line, but instead use a common repository and pass an identifier to a domain parameter set whose strength has been rigorously proven and that does not have small subgroups. If a group's complete domain parameter set is passed in-line, it SHOULD NOT be used with Dragonfly unless it directly matches a known good group.",
      "ja": "小さな部分群を含むグループの使用に問題があるため、Dragonflyの実装では、グループの完全なドメインパラメータの指定をインラインで送信することを許可せず、代わりに共通リポジトリを使用して、強度が厳密に証明されており小さな部分群を持たないドメインパラメータセットへの識別子を渡すことを推奨します（RECOMMENDED）。グループの完全なドメインパラメータセットがインラインで渡される場合、既知の適切なグループと直接一致しない限り、Dragonflyで使用しないでください。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that an implementation set the security parameter, k, to a value of at least forty (40) which will put the probability that more than forty iterations are needed in the order of one in one trillion (1:1,000,000,000,000).",
      "ja": "実装では、セキュリティパラメータkを少なくとも40の値に設定することを推奨します（RECOMMENDED）。これにより、40回以上の反復が必要となる確率が1兆分の1（1：1,000,000,000,000）のオーダーになります。"
    },
    {
      "indent": 3,
      "text": "The technique used to obtain the Password Element in Section 3.2.1 addresses side-channel attacks in a manner deemed controversial by some reviewers in the CFRG. An alternate method, such as the one defined in [hash2ec], can be used to alleviate concerns.",
      "ja": "セクション3.2.1でパスワード要素を取得するために使用される手法は、CFRGの一部のレビュアーによって論争の的と見なされる方法でサイドチャネル攻撃に対処します。 [hash2ec]で定義されているような別の方法を使用して、問題を軽減できます。"
    },
    {
      "indent": 3,
      "text": "This key exchange protocol has received cryptanalysis in [clarkehao]. [lanskro] provides a security proof of Dragonfly in the random oracle model when both identities are included in the data sent in the Confirm Exchange (see Section 3.4).",
      "ja": "この鍵交換プロトコルは[clarkehao]で解析されました。 [lanskro]は、確認交換（セクション3.4を参照）で送信されるデータに両方のIDが含まれている場合、ランダムオラクルモデルでDragonflyのセキュリティ証明を提供します。"
    },
    {
      "indent": 0,
      "text": "5. References",
      "section_title": true,
      "ja": "5. 参考文献"
    },
    {
      "indent": 0,
      "text": "5.1. Normative References",
      "section_title": true,
      "ja": "5.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 0,
      "text": "5.2. Informative References",
      "section_title": true,
      "ja": "5.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[clarkehao] Clarke, D. and F. Hao, \"Cryptanalysis of the Dragonfly Key Exchange Protocol\", IET Information Security, Volume 8, Issue 6, DOI 10.1049/iet-ifs.2013.0081, November 2014.",
      "ja": "[clarkehao] Clarke、D。およびF. Hao、「Dragonfly Key Exchange Protocolの暗号解析」、IET情報セキュリティ、第8巻、第6号、DOI 10.1049 / iet-ifs.2013.0081、2014年11月。"
    },
    {
      "indent": 3,
      "text": "[FIPS186-4] NIST, \"Digital Signature Standard (DSS)\", Federal Information Processing Standard (FIPS) 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013.",
      "ja": "[FIPS186-4] NIST、「デジタル署名標準（DSS）」、連邦情報処理標準（FIPS）186-4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月。"
    },
    {
      "indent": 3,
      "text": "[hash2ec] Brier, E., Coron, J-S., Icart, T., Madore, D., Randriam, H., and M. Tibouchi, \"Efficient Indifferentiable Hashing into Ordinary Elliptic Curves\", Cryptology ePrint Archive Report 2009/340, 2009.",
      "ja": "[hash2ec]ブライア、E。、コロン、JS、イカート、T。、マドール、D。、ランドリアム、H、およびM.ティボウチ、「通常の楕円曲線への効率的な微分不能ハッシュ」、暗号学ePrintアーカイブレポート2009/340 、2009。"
    },
    {
      "indent": 3,
      "text": "[lanskro] Lancrenon, J. and M. Skrobot, \"On the Provable Security of the Dragonfly Protocol\", Proceedings of 18th International Information Security Conference (ISC 2015), pp 244-261, DOI 10.1007/978-3-319-23318-5_14, September 2015.",
      "ja": "[lanskro] Lancrenon、J。およびM. Skrobot、「トンボプロトコルの証明可能なセキュリティについて」、第18回国際情報セキュリティ会議の議事録（ISC 2015）、pp 244-261、DOI 10.1007 / 978-3-319-23318 -5_14、2015年9月。"
    },
    {
      "indent": 3,
      "text": "[RANDOR] Bellare, M. and P. Rogaway, \"Random Oracles are Practical: A Paradigm for Designing Efficient Protocols\", Proceedings of the 1st ACM Conference on Computer and Communication Security, ACM Press, DOI 10.1145/168588.168596, 1993.",
      "ja": "[RANDOR] Bellare、M。、およびP. Rogaway、「ランダムなオラクルは実用的：効率的なプロトコルを設計するためのパラダイム」、第1回コンピュータおよび通信セキュリティに関するACM会議の議事録、ACM Press、DOI 10.1145 / 168588.168596、1993。"
    },
    {
      "indent": 3,
      "text": "[RFC5433] Clancy, T. and H. Tschofenig, \"Extensible Authentication Protocol - Generalized Pre-Shared Key (EAP-GPSK) Method\", RFC 5433, DOI 10.17487/RFC5433, February 2009, <http://www.rfc-editor.org/info/rfc5433>.",
      "ja": "[RFC5433] Clancy、T。およびH. Tschofenig、「Extensible Authentication Protocol-Generalized Pre-Shared Key（EAP-GPSK）Method」、RFC 5433、DOI 10.17487 / RFC5433、2009年2月、<http://www.rfc-editor.org/info/rfc5433>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <http://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090] McGrew、D.、Igoe、K。、およびM. Salter、「Fundamental Elliptic Curve Cryptography Algorithms」、RFC 6090、DOI 10.17487 / RFC6090、2011年2月、<http://www.rfc-editor.org/info/rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, <http://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296] Kaufman、C.、Hoffman、P.、Nir、Y.、Eronen、P。、およびT. Kivinen、「Internet Key Exchange Protocol Version 2（IKEv2）」、STD 79、RFC 7296、DOI 10.17487 / RFC7296 、2014年10月、<http://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[SP800-108] Chen, L., \"Recommendation for Key Derivation Using Pseudorandom Functions\", NIST Special Publication 800-108, October 2009.",
      "ja": "[SP800-108]チェンL.、「擬似ランダム関数を使用した鍵導出の推奨」、NIST特別刊行物800-108、2009年10月。"
    },
    {
      "indent": 3,
      "text": "[SP800-56A] Barker, E., Johnson, D., and M. Smid, \"Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography (Revised)\", NIST Special Publication 800-56A, March 2007.",
      "ja": "[SP800-56A] Barker、E.、Johnson、D。、およびM. Smid、「離散対数暗号を使用したペアワイズキー確立スキームの推奨（改訂）」、NIST特別刊行物800-56A、2007年3月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Kevin Igoe and David McGrew, chairmen of the Crypto Forum Research Group (CFRG) for agreeing to accept this memo as a CFRG work item. Additional thanks go to Scott Fluhrer and Hideyuki Suzuki for discovering attacks against earlier versions of this key exchange and suggesting fixes to address them. Lily Chen provided helpful discussions on hashing into an elliptic curve. Rich Davis suggested the validation steps used on received elements to prevent a small subgroup attack. Dylan Clarke and Feng Hao discovered a dictionary attack against Dragonfly if those checks are not made and a group with a small subgroup is used. And finally, a very heartfelt thanks to Jean Lancrenon and Marjan Skrobot for developing a proof of the security of Dragonfly.",
      "ja": "著者は、このメモをCFRG作業項目として受け入れることに同意してくれた、Crypto Forum Research Group（CFRG）の議長であるKevin IgoeとDavid McGrewに感謝します。この鍵交換の以前のバージョンに対する攻撃を発見し、それらに対処するための修正を提案してくれたScott FluhrerとHideyuki Suzukiにさらに感謝します。 Lily Chenは、楕円曲線へのハッシュに関する有益な議論を行いました。 Rich Davisは、小さなサブグループ攻撃を防ぐために、受信した要素で使用する検証手順を提案しました。 Dylan ClarkeとFeng Haoは、これらのチェックが行われず、小さなサブグループを持つグループが使用されている場合、Dragonflyに対する辞書攻撃を発見しました。そして最後に、Dragonflyのセキュリティの証明を開発してくれたJean LancrenonとMarjan Skrobotに心から感謝します。"
    },
    {
      "indent": 3,
      "text": "The blinding scheme to prevent side-channel attacks when determining whether a value is a quadratic residue modulo a prime was suggested by Scott Fluhrer. Kevin Igoe suggested addition of the security parameter k to hide the amount of time taken hunting and pecking for the password element.",
      "ja": "値が素数を法とする平方剰余であるかどうかを決定するときにサイドチャネル攻撃を防ぐためのブラインドスキームは、Scott Fluhrerによって提案されました。 Kevin Igoeは、セキュリティパラメータkを追加して、パスワード要素のハンティングとペッキングにかかる時間を隠すことを提案しました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Dan Harkins (editor) Aruba Networks 1322 Crossman Avenue Sunnyvale, CA 94089-1113 United States",
      "ja": "Dan Harkins（編集者）Aruba Networks 1322 Crossman Avenue Sunnyvale、CA 94089-1113アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: dharkins@arubanetworks.com",
      "raw": true,
      "ja": ""
    }
  ]
}