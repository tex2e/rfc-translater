{
  "title": {
    "text": "RFC 7914 - The scrypt Password-Based Key Derivation Function",
    "ja": "RFC 7914 - scryptパスワードベースの鍵導出関数"
  },
  "number": 7914,
  "created_at": "2020-08-29 12:53:30.246335+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       C. Percival\nRequest for Comments: 7914                                       Tarsnap\nCategory: Informational                                     S. Josefsson\nISSN: 2070-1721                                                   SJD AB\n                                                             August 2016",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "The scrypt Password-Based Key Derivation Function",
      "ja": "scryptパスワードベースの鍵導出関数"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies the password-based key derivation function scrypt. The function derives one or more secret keys from a secret string. It is based on memory-hard functions, which offer added protection against attacks using custom hardware. The document also provides an ASN.1 schema.",
      "ja": "このドキュメントでは、パスワードベースの鍵導出関数scryptを規定します。この関数は、秘密文字列から1つ以上の秘密鍵を導出します。これは、カスタムハードウェアを使用した攻撃に対する保護を強化するメモリハード関数に基づいています。このドキュメントでは、ASN.1スキーマも提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の成果物です。これは、IETFコミュニティの合意を表しています。パブリックレビューを経て、Internet Engineering Steering Group（IESG）による公開が承認されました。IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7914.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http://www.rfc-editor.org/info/rfc7914で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright (c) 2016 IETF Trustおよびドキュメントの著者として特定された者。All rights reserved."
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n2.  scrypt Parameters . . . . . . . . . . . . . . . . . . . . . .   3\n3.  The Salsa20/8 Core Function . . . . . . . . . . . . . . . . .   4\n4.  The scryptBlockMix Algorithm  . . . . . . . . . . . . . . . .   5\n5.  The scryptROMix Algorithm . . . . . . . . . . . . . . . . . .   6\n6.  The scrypt Algorithm  . . . . . . . . . . . . . . . . . . . .   7\n7.  ASN.1 Syntax  . . . . . . . . . . . . . . . . . . . . . . . .   8\n  7.1.  ASN.1 Module  . . . . . . . . . . . . . . . . . . . . . .   9\n8.  Test Vectors for Salsa20/8 Core . . . . . . . . . . . . . . .   9\n9.  Test Vectors for scryptBlockMix . . . . . . . . . . . . . . .  10\n10. Test Vectors for scryptROMix  . . . . . . . . . . . . . . . .  11\n11. Test Vectors for PBKDF2 with HMAC-SHA-256 . . . . . . . . . .  12\n12. Test Vectors for scrypt . . . . . . . . . . . . . . . . . . .  13\n13. Test Vectors for PKCS#8 . . . . . . . . . . . . . . . . . . .  14\n14. Security Considerations . . . . . . . . . . . . . . . . . . .  14\n15. References  . . . . . . . . . . . . . . . . . . . . . . . . .  15\n  15.1.  Normative References . . . . . . . . . . . . . . . . . .  15\n  15.2.  Informative References . . . . . . . . . . . . . . . . .  15\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  16\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  16",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Password-based key derivation functions are used in cryptography and security protocols for deriving one or more secret keys from a secret value. Over the years, several password-based key derivation functions have been used, including the original DES-based UNIX Crypt-function, FreeBSD MD5 crypt, Public-Key Cryptography Standards#5 (PKCS#5) PBKDF2 [RFC2898] (typically used with SHA-1), GNU SHA-256/512 crypt [SHA2CRYPT], Windows NT LAN Manager (NTLM) [NTLM] hash, and the Blowfish-based bcrypt [BCRYPT]. These algorithms are all based on a cryptographic primitive combined with salting and/or iteration. The iteration count is used to slow down the computation, and the salt is used to make pre-computation costlier.",
      "ja": "パスワードベースの鍵導出関数は、暗号およびセキュリティプロトコルで、秘密値から1つ以上の秘密鍵を導出するために使用されます。長年にわたって、元のDESベースのUNIX暗号化関数、FreeBSD MD5 crypt、公開鍵暗号化標準#5（PKCS #5）PBKDF2 [RFC2898]（通常、SHA-1と共に使用）、GNU SHA-256/512 crypt [SHA2CRYPT]、Windows NT LAN Manager（NTLM）[NTLM]ハッシュ、およびBlowfishベースのbcrypt [BCRYPT]など、いくつかのパスワードベースの鍵導出関数が使用されてきました。これらのアルゴリズムはすべて、ソルティングや反復と組み合わせた暗号プリミティブに基づいています。反復回数は計算を遅くするために使用され、ソルトは事前計算をより高コストにするために使用されます。"
    },
    {
      "indent": 0,
      "text": " All password-based key derivation functions mentioned above share the same weakness against powerful attackers. Provided that the number of iterations used is increased as computer systems get faster, this allows legitimate users to spend a constant amount of time on key derivation without losing ground to attackers' ever-increasing computing power -- as long as attackers are limited to the same software implementations as legitimate users. While parallelized hardware implementations may not change the number of operations performed compared to software implementations, this does not prevent them from dramatically changing the asymptotic cost, since in many contexts -- including the embarrassingly parallel task of performing a brute-force search for a passphrase -- dollar-seconds are the most appropriate units for measuring the cost of a computation. As semiconductor technology develops, circuits do not merely become faster; they also become smaller, allowing for a larger amount of parallelism at the same cost.",
      "ja": "上記のすべてのパスワードベースの鍵導出関数は、強力な攻撃者に対して同じ弱点を共有しています。コンピュータシステムが高速化するにつれて使用される反復回数が増加する場合、攻撃者が正当なユーザーと同じソフトウェア実装に限定されている限り、正当なユーザーは、攻撃者の絶えず増大する計算能力に遅れをとることなく、鍵の導出に一定の時間を費やすことができます。並列化されたハードウェア実装は、ソフトウェア実装と比較して実行される操作の数を変えないかもしれませんが、パスフレーズのブルートフォース検索を実行するという、極めて並列化が容易なタスクを含む多くのコンテキストにおいて、漸近的なコストを劇的に変化させることを防ぐものではありません。ここでは、計算コストを測定するための最も適切な単位はドル秒です。半導体技術が発展するにつれて、回路は単に高速になるだけでなく、小型化し、同じコストでより多くの並列処理が可能になります。"
    },
    {
      "indent": 3,
      "text": "Consequently, with existing key derivation algorithms, even when the iteration count is increased so that the time taken to verify a password remains constant, the cost of finding a password by using a brute-force attack implemented in hardware drops each year.",
      "ja": "その結果、既存の鍵導出アルゴリズムでは、パスワードの検証にかかる時間が一定になるように反復回数を増やしても、ハードウェアに実装されたブルートフォース攻撃を使用してパスワードを見つけるコストは毎年低下します。"
    },
    {
      "indent": 3,
      "text": "The scrypt function aims to reduce the advantage that attackers can gain by using custom-designed parallel circuits for breaking password-based key derivation functions.",
      "ja": "scrypt関数は、カスタム設計の並列回路を使用してパスワードベースの鍵導出関数を破ることにより、攻撃者が得る利点を減らすことを目的としています。"
    },
    {
      "indent": 3,
      "text": "This document does not introduce scrypt for the first time. The original scrypt paper [SCRYPT] was published as a peer-reviewed scientific paper and contains further background and discussions.",
      "ja": "このドキュメントは、scryptを初めて紹介するものではありません。オリジナルのscrypt論文[SCRYPT]は、査読済みの科学論文として公開され、さらなる背景と議論が含まれています。"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to serve as a stable reference for documents making use of scrypt. The rest of this document is divided into sections that each describe parameter choices and algorithm steps needed for the final \"scrypt\" algorithm.",
      "ja": "このドキュメントの目的は、scryptを使用するドキュメントの安定したリファレンスとして機能することです。このドキュメントの残りの部分は、最終的な「scrypt」アルゴリズムに必要なパラメーターの選択とアルゴリズムの手順を説明するセクションに分かれています。"
    },
    {
      "indent": 0,
      "text": "2. scrypt Parameters",
      "section_title": true,
      "ja": "2. scryptパラメータ"
    },
    {
      "indent": 3,
      "text": "The scrypt function takes several parameters. The passphrase P is typically a human-chosen password. The salt is normally uniquely and randomly generated [RFC4086]. The parameter r (\"blockSize\") specifies the block size. The CPU/Memory cost parameter N (\"costParameter\") must be larger than 1, a power of 2, and less than 2^(128 * r / 8). The parallelization parameter p (\"parallelizationParameter\") is a positive integer less than or equal to ((2^32-1) * 32) / (128 * r). The intended output length dkLen is the length in octets of the key to be derived (\"keyLength\"); it is a positive integer less than or equal to (2^32 - 1) * 32.",
      "ja": "scrypt関数はいくつかのパラメーターを取ります。パスフレーズPは、通常、人間が選択したパスワードです。ソルトは通常、一意的かつランダムに生成されます[RFC4086]。パラメータr（\"blockSize\"）はブロックサイズを指定します。CPU/メモリコストパラメータN（\"costParameter\"）は、1より大きく、2の累乗で、2^(128 * r / 8)未満である必要があります。並列化パラメーターp（\"parallelizationParameter\"）は、((2^32-1) * 32) / (128 * r)以下の正の整数です。目的の出力長dkLenは、導出される鍵（\"keyLength\"）のオクテット単位の長さです。(2^32 - 1) * 32以下の正の整数です。"
    },
    {
      "indent": 0,
      "text": " Users of scrypt can tune the parameters N, r, and p according to the amount of memory and computing power available, the latency-bandwidth product of the memory subsystem, and the amount of parallelism desired. At the current time, r=8 and p=1 appears to yield good results, but as memory latency and CPU parallelism increase, it is likely that the optimum values for both r and p will increase. Note also that since the computations of SMix are independent, a large value of p can be used to increase the computational cost of scrypt without increasing the memory usage; so we can expect scrypt to remain useful even if the growth rates of CPU power and memory capacity diverge.",
      "ja": "scryptのユーザーは、使用可能なメモリの量と計算能力、メモリサブシステムの待ち時間帯域幅積、および必要な並列処理の量に応じて、パラメーターN、r、およびpを調整できます。現時点では、r = 8とp = 1で良好な結果が得られるようですが、メモリレイテンシとCPUの並列処理が増加すると、rとpの両方の最適値が増加する可能性があります。また、SMixの計算は独立しているため、pの値を大きくすると、メモリ使用量を増やすことなくscryptの計算コストを増やすことができます。したがって、CPUパワーとメモリ容量の増加率が乖離しても、scryptは引き続き有用であると期待できます。"
    },
    {
      "indent": 0,
      "text": "3. The Salsa20/8 Core Function",
      "section_title": true,
      "ja": "3. Salsa20/8コア関数"
    },
    {
      "indent": 3,
      "text": "Salsa20/8 Core is a round-reduced variant of the Salsa20 Core. It is a hash function from 64-octet strings to 64-octet strings. Note that Salsa20/8 Core is not a cryptographic hash function since it is not collision resistant. See Section 8 of [SALSA20SPEC] for its specification and [SALSA20CORE] for more information. The algorithm description, in C language, is included below as a stable reference, without endianness conversion and alignment.",
      "ja": "Salsa20/8コアは、Salsa20コアのラウンド削減版です。 64オクテット文字列から64オクテット文字列へのハッシュ関数です。 Salsa20/8コアは衝突耐性がないため、暗号学的ハッシュ関数ではないことに注意してください。仕様については[SALSA20SPEC]のセクション8を、詳細については[SALSA20CORE]を参照してください。 C言語でのアルゴリズムの説明は、エンディアン変換およびアライメントなしの安定した参照として以下に含まれています。"
    },
    {
      "indent": 3,
      "text": "#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\nvoid salsa20_word_specification(uint32 out[16],uint32 in[16])\n{\n  int i;\n  uint32 x[16];\n  for (i = 0;i < 16;++i) x[i] = in[i];\n  for (i = 8;i > 0;i -= 2) {\n    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);\n    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);\n    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);\n    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);\n    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);\n    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);\n    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);\n    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);\n    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);\n    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);\n    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);\n    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);\n    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);\n    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);\n    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);\n    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);\n  }\n  for (i = 0;i < 16;++i) out[i] = x[i] + in[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. The scryptBlockMix Algorithm",
      "section_title": true,
      "ja": "4. scryptBlockMixアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The scryptBlockMix algorithm is the same as the BlockMix algorithm described in [SCRYPT] but with Salsa20/8 Core used as the hash function H. Below, Salsa(T) corresponds to the Salsa20/8 Core function applied to the octet vector T.",
      "ja": "scryptBlockMixアルゴリズムは[SCRYPT]で説明されているBlockMixアルゴリズムと同じですが、ハッシュ関数HとしてSalsa20/8コアが使用されます。以下では、Salsa(T)はオクテットベクトルTに適用されるSalsa20/8コア関数に対応します。"
    },
    {
      "indent": 3,
      "text": "Algorithm scryptBlockMix",
      "ja": "アルゴリズムscryptBlockMix"
    },
    {
      "indent": 3,
      "text": "Parameters: r Block size parameter.",
      "ja": "パラメーター：rブロックサイズパラメーター。"
    },
    {
      "indent": 3,
      "text": "Input: B[0] || B[1] || ... || B[2 * r - 1] Input octet string (of size 128 * r octets), treated as 2 * r 64-octet blocks, where each element in B is a 64-octet block.",
      "ja": "入力：B[0] || B[1] || ... || B[2 * r - 1]入力オクテット文字列（サイズ128 * rオクテット）、2 * r個の64オクテットブロックとして扱われ、Bの各要素は64オクテットブロックです。"
    },
    {
      "indent": 3,
      "text": "Output: B'[0] || B'[1] || ... || B'[2 * r - 1] Output octet string.",
      "ja": "出力：B'[0] || B'[1] || ... || B'[2 * r - 1]出力オクテット文字列。"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 5,
      "text": "1. X = B[2 * r - 1]",
      "ja": "1. X = B[2 * r - 1]"
    },
    {
      "indent": 5,
      "text": "2. for i = 0 to 2 * r - 1 do T = X xor B[i] X = Salsa (T) Y[i] = X end for",
      "ja": "2. for i = 0 to 2 * r - 1 do T = X xor B[i] X = Salsa(T) Y[i] = X end for"
    },
    {
      "indent": 5,
      "text": "3. B' = (Y[0], Y[2], ..., Y[2 * r - 2], Y[1], Y[3], ..., Y[2 * r - 1])",
      "ja": "3. B' = (Y[0], Y[2], ..., Y[2 * r - 2], Y[1], Y[3], ..., Y[2 * r - 1])"
    },
    {
      "indent": 0,
      "text": "5. The scryptROMix Algorithm",
      "section_title": true,
      "ja": "5. scryptROMixアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The scryptROMix algorithm is the same as the ROMix algorithm described in [SCRYPT] but with scryptBlockMix used as the hash function H and the Integerify function explained inline.",
      "ja": "scryptROMixアルゴリズムは、[SCRYPT]で説明されているROMixアルゴリズムと同じですが、scryptBlockMixがハッシュ関数Hとして使用され、Integerify関数がインラインで説明されています。"
    },
    {
      "indent": 3,
      "text": "Algorithm scryptROMix",
      "ja": "アルゴリズムscryptROMix"
    },
    {
      "indent": 3,
      "text": "Input: r Block size parameter. B Input octet vector of length 128 * r octets. N CPU/Memory cost parameter, must be larger than 1, a power of 2, and less than 2^(128 * r / 8).",
      "ja": "入力：rブロックサイズパラメーター。 B長さ128 * rオクテットの入力オクテットベクトル。 N CPU/メモリコストパラメータ。1より大きく、2の累乗で、2^(128 * r / 8)未満である必要があります。"
    },
    {
      "indent": 3,
      "text": "Output: B' Output octet vector of length 128 * r octets.",
      "ja": "出力：B' 長さ128 * rオクテットの出力オクテットベクトル。"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 5,
      "text": "1. X = B",
      "ja": "1. X = B"
    },
    {
      "indent": 5,
      "text": "2. for i = 0 to N - 1 do V[i] = X X = scryptBlockMix (X) end for",
      "ja": "2. for i = 0 to N - 1 do V[i] = X X = scryptBlockMix(X) end for"
    },
    {
      "indent": 5,
      "text": "3. for i = 0 to N - 1 do j = Integerify (X) mod N where Integerify (B[0] ... B[2 * r - 1]) is defined as the result of interpreting B[2 * r - 1] as a little-endian integer. T = X xor V[j] X = scryptBlockMix (T) end for",
      "ja": "3. for i = 0 to N - 1 do j = Integerify(X) mod Nここで、Integerify(B[0] ... B[2 * r - 1])は、B[2 * r - 1]をリトルエンディアン整数として解釈した結果として定義されます。 T = X xor V[j] X = scryptBlockMix(T) end for"
    },
    {
      "indent": 5,
      "text": "4. B' = X",
      "ja": "4. B' = X"
    },
    {
      "indent": 0,
      "text": "6. The scrypt Algorithm",
      "section_title": true,
      "ja": "6. scryptアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The PBKDF2-HMAC-SHA-256 function used below denotes the PBKDF2 algorithm [RFC2898] used with HMAC-SHA-256 [RFC6234] as the Pseudorandom Function (PRF). The HMAC-SHA-256 function generates 32-octet outputs.",
      "ja": "以下で使用されるPBKDF2-HMAC-SHA-256関数は、疑似ランダム関数（PRF）としてHMAC-SHA-256 [RFC6234]と共に使用されるPBKDF2アルゴリズム[RFC2898]を示します。 HMAC-SHA-256関数は、32オクテット出力を生成します。"
    },
    {
      "indent": 3,
      "text": "Algorithm scrypt",
      "ja": "アルゴリズムscrypt"
    },
    {
      "indent": 3,
      "text": "Input: P Passphrase, an octet string. S Salt, an octet string. N CPU/Memory cost parameter, must be larger than 1, a power of 2, and less than 2^(128 * r / 8). r Block size parameter. p Parallelization parameter, a positive integer less than or equal to ((2^32-1) * hLen) / MFLen where hLen is 32 and MFlen is 128 * r. dkLen Intended output length in octets of the derived key; a positive integer less than or equal to (2^32 - 1) * hLen where hLen is 32.",
      "ja": "入力：Pパスフレーズ、オクテット文字列。 Sソルト、オクテット文字列。 N CPU/メモリコストパラメータ。1より大きく、2の累乗で、2^(128 * r / 8)未満である必要があります。 rブロックサイズパラメータ。 p並列化パラメーター、((2^32-1) * hLen) / MFLen以下の正の整数（hLenは32、MFlenは128 * r）。 dkLen導出鍵のオクテット単位の目的の出力長。 (2^32 - 1) * hLen以下の正の整数（hLenは32）"
    },
    {
      "indent": 3,
      "text": "Output: DK Derived key, of length dkLen octets.",
      "ja": "出力：DK導出鍵、長さdkLenオクテット。"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 4,
      "text": "1. Initialize an array B consisting of p blocks of 128 * r octets each: B[0] || B[1] || ... || B[p - 1] = PBKDF2-HMAC-SHA256 (P, S, 1, p * 128 * r)",
      "ja": "1. それぞれ128 * rオクテットのpブロックで構成される配列Bを初期化します。B[0] || B[1] || ... || B[p - 1] = PBKDF2-HMAC-SHA256(P, S, 1, p * 128 * r)"
    },
    {
      "indent": 4,
      "text": "2. for i = 0 to p - 1 do B[i] = scryptROMix (r, B[i], N) end for",
      "ja": "2. for i = 0 to p - 1 do B[i] = scryptROMix(r, B[i], N) end for"
    },
    {
      "indent": 4,
      "text": "3. DK = PBKDF2-HMAC-SHA256 (P, B[0] || B[1] || ... || B[p - 1], 1, dkLen)",
      "ja": "3. DK = PBKDF2-HMAC-SHA256(P, B[0] || B[1] || ... || B[p - 1], 1, dkLen)"
    },
    {
      "indent": 0,
      "text": "7. ASN.1 Syntax",
      "section_title": true,
      "ja": "7. ASN.1構文"
    },
    {
      "indent": 3,
      "text": "This section defines ASN.1 syntax for the scrypt key derivation function (KDF). This is intended to operate on the same abstraction level as PKCS#5's PBKDF2. The OID id-scrypt below can be used where id-PBKDF2 is used, with scrypt-params corresponding to PBKDF2-params. The intended application of these definitions includes PKCS #8 and other syntax for key management.",
      "ja": "このセクションでは、scrypt鍵導出関数（KDF）のASN.1構文を定義します。これは、PKCS＃5のPBKDF2と同じ抽象化レベルで動作することを目的としています。以下のOID id-scryptは、id-PBKDF2が使用されている場所で使用でき、scrypt-paramsはPBKDF2-paramsに対応しています。これらの定義の想定される用途には、PKCS＃8およびキー管理のための他の構文が含まれます。"
    },
    {
      "indent": 3,
      "text": "The object identifier id-scrypt identifies the scrypt key derivation function.",
      "ja": "オブジェクト識別子id-scryptは、scrypt鍵導出関数を識別します。"
    },
    {
      "indent": 3,
      "text": "id-scrypt OBJECT IDENTIFIER ::= {1 3 6 1 4 1 11591 4 11}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The parameters field associated with this OID in an AlgorithmIdentifier shall have type scrypt-params:",
      "ja": "AlgorithmIdentifierでこのOIDに関連付けられているパラメーターフィールドは、タイプscrypt-paramsを持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "scrypt-params ::= SEQUENCE {\n       salt OCTET STRING,\n       costParameter INTEGER (1..MAX),\n       blockSize INTEGER (1..MAX),\n       parallelizationParameter INTEGER (1..MAX),\n       keyLength INTEGER (1..MAX) OPTIONAL }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields of type scrypt-params have the following meanings:",
      "ja": "タイプscrypt-paramsのフィールドには次の意味があります。"
    },
    {
      "indent": 3,
      "text": "- salt specifies the salt value. It shall be an octet string.",
      "ja": "- saltはソルト値を指定します。これはオクテット文字列である必要があります。"
    },
    {
      "indent": 3,
      "text": "- costParameter specifies the CPU/Memory cost parameter N.",
      "ja": "- costParameterは、CPU/メモリコストパラメータNを指定します。"
    },
    {
      "indent": 3,
      "text": "- blockSize specifies the block size parameter r.",
      "ja": "- blockSizeは、ブロックサイズパラメータrを指定します。"
    },
    {
      "indent": 3,
      "text": "- parallelizationParameter specifies the parallelization parameter.",
      "ja": "- parallelizationParameterは、並列化パラメーターを指定します。"
    },
    {
      "indent": 3,
      "text": "- keyLength, an optional field, is the length in octets of the derived key. The maximum key length allowed depends on the implementation; it is expected that implementation profiles may further constrain the bounds. This field only provides convenience; the key length is not cryptographically protected.",
      "ja": "- オプションのフィールドであるkeyLengthは、導出鍵のオクテット単位の長さです。許可されるキーの最大長は実装によって異なります。実装プロファイルは境界をさらに制約することが予想されます。このフィールドは利便性を提供するだけです。キーの長さは暗号学的に保護されていません。"
    },
    {
      "indent": 3,
      "text": "To be usable in PKCS#8 [RFC5208] and Asymmetric Key Packages [RFC5958], the following extension of the PBES2-KDFs type is needed:",
      "ja": "PKCS #8 [RFC5208]および非対称鍵パッケージ[RFC5958]で使用できるようにするには、PBES2-KDFsタイプの次の拡張が必要です。"
    },
    {
      "indent": 6,
      "text": "PBES2-KDFs ALGORITHM-IDENTIFIER ::=\n    { {scrypt-params IDENTIFIED BY id-scrypt}, ... }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.1. ASN.1 Module",
      "section_title": true,
      "ja": "7.1. ASN.1モジュール"
    },
    {
      "indent": 3,
      "text": "For reference purposes, the ASN.1 syntax is presented as an ASN.1 module here.",
      "ja": "参考のために、ここではASN.1構文をASN.1モジュールとして示しています。"
    },
    {
      "indent": 3,
      "text": "-- scrypt ASN.1 Module",
      "ja": "-- scrypt ASN.1モジュール"
    },
    {
      "indent": 3,
      "text": "scrypt-0 {1 3 6 1 4 1 11591 4 10}",
      "ja": "scrypt-0 {1 3 6 1 4 1 11591 4 10}"
    },
    {
      "indent": 3,
      "text": "DEFINITIONS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "id-scrypt OBJECT IDENTIFIER ::= {1 3 6 1 4 1 11591 4 11}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "scrypt-params ::= SEQUENCE {\n    salt OCTET STRING,\n    costParameter INTEGER (1..MAX),\n    blockSize INTEGER (1..MAX),\n    parallelizationParameter INTEGER (1..MAX),\n    keyLength INTEGER (1..MAX) OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PBES2-KDFs ALGORITHM-IDENTIFIER ::=\n       { {scrypt-params IDENTIFIED BY id-scrypt}, ... }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "END",
      "ja": "END"
    },
    {
      "indent": 0,
      "text": "8. Test Vectors for Salsa20/8 Core",
      "section_title": true,
      "ja": "8. Salsa20/8コアのテストベクトル"
    },
    {
      "indent": 3,
      "text": "Below is a sequence of octets that illustrate input and output values for the Salsa20/8 Core. The octets are hex encoded and whitespace is inserted for readability. The value corresponds to the first input and output pair generated by the first scrypt test vector below.",
      "ja": "以下は、Salsa20/8コアの入力値と出力値を示すオクテットのシーケンスです。オクテットは16進数でエンコードされ、読みやすくするために空白が挿入されます。値は、以下の最初のscryptテストベクトルによって生成される最初の入力と出力のペアに対応します。"
    },
    {
      "indent": 3,
      "text": "INPUT: 7e 87 9a 21 4f 3e c9 86 7c a9 40 e6 41 71 8f 26 ba ee 55 5b 8c 61 c1 b5 0d f8 46 11 6d cd 3b 1d ee 24 f3 19 df 9b 3d 85 14 12 1e 4b 5a c5 aa 32 76 02 1d 29 09 c7 48 29 ed eb c6 8d b8 b8 c2 5e",
      "ja": "入力：7e 87 9a 21 4f 3e c9 86 7c a9 40 e6 41 71 8f 26 ba ee 55 5b 8c 61 c1 b5 0d f8 46 11 6d cd 3b 1d ee 24 f3 19 df 9b 3d 85 14 12 1e 4b 5a c5 aa 32 76 02 1d 29 09 c7 48 29 ed eb c6 8d b8 b8 c2 5e"
    },
    {
      "indent": 3,
      "text": "OUTPUT: a4 1f 85 9c 66 08 cc 99 3b 81 ca cb 02 0c ef 05 04 4b 21 81 a2 fd 33 7d fd 7b 1c 63 96 68 2f 29 b4 39 31 68 e3 c9 e6 bc fe 6b c5 b7 a0 6d 96 ba e4 24 cc 10 2c 91 74 5c 24 ad 67 3d c7 61 8f 81",
      "ja": "出力：a4 1f 85 9c 66 08 cc 99 3b 81 ca cb 02 0c ef 05 04 4b 21 81 a2 fd 33 7d fd 7b 1c 63 96 68 2f 29 b4 39 31 68 e3 c9 e6 bc fe 6b c5 b7 a0 6d 96 ba e4 24 cc 10 2c 91 74 5c 24 ad 67 3d c7 61 8f 81"
    },
    {
      "indent": 0,
      "text": "9. Test Vectors for scryptBlockMix",
      "section_title": true,
      "ja": "9. scryptBlockMixのテストベクトル"
    },
    {
      "indent": 3,
      "text": "Below is a sequence of octets that illustrate input and output values for scryptBlockMix. The test vector uses an r value of 1. The octets are hex encoded and whitespace is inserted for readability. The value corresponds to the first input and output pair generated by the first scrypt test vector below.",
      "ja": "以下は、scryptBlockMixの入力値と出力値を示すオクテットのシーケンスです。テストベクトルはr=1の値を使用します。オクテットは16進エンコードされ、読みやすくするために空白が挿入されます。値は、以下の最初のscryptテストベクトルによって生成される最初の入力と出力のペアに対応します。"
    },
    {
      "indent": 3,
      "text": "INPUT B[0] = f7 ce 0b 65 3d 2d 72 a4 10 8c f5 ab e9 12 ff dd 77 76 16 db bb 27 a7 0e 82 04 f3 ae 2d 0f 6f ad 89 f6 8f 48 11 d1 e8 7b cc 3b d7 40 0a 9f fd 29 09 4f 01 84 63 95 74 f3 9a e5 a1 31 52 17 bc d7",
      "ja": "入力B[0] = f7 ce 0b 65 3d 2d 72 a4 10 8c f5 ab e9 12 ff dd 77 76 16 db bb 27 a7 0e 82 04 f3 ae 2d 0f 6f ad 89 f6 8f 48 11 d1 e8 7b cc 3b d7 40 0a 9f fd 29 09 4f 01 84 63 95 74 f3 9a e5 a1 31 52 17 bc d7"
    },
    {
      "indent": 3,
      "text": "B[1] = 89 49 91 44 72 13 bb 22 6c 25 b5 4d a8 63 70 fb cd 98 43 80 37 46 66 bb 8f fc b5 bf 40 c2 54 b0 67 d2 7c 51 ce 4a d5 fe d8 29 c9 0b 50 5a 57 1b 7f 4d 1c ad 6a 52 3c da 77 0e 67 bc ea af 7e 89",
      "ja": "B[1] = 89 49 91 44 72 13 bb 22 6c 25 b5 4d a8 63 70 fb cd 98 43 80 37 46 66 bb 8f fc b5 bf 40 c2 54 b0 67 d2 7c 51 ce 4a d5 fe d8 29 c9 0b 50 5a 57 1b 7f 4d 1c ad 6a 52 3c da 77 0e 67 bc ea af 7e 89"
    },
    {
      "indent": 3,
      "text": "OUTPUT B'[0] = a4 1f 85 9c 66 08 cc 99 3b 81 ca cb 02 0c ef 05 04 4b 21 81 a2 fd 33 7d fd 7b 1c 63 96 68 2f 29 b4 39 31 68 e3 c9 e6 bc fe 6b c5 b7 a0 6d 96 ba e4 24 cc 10 2c 91 74 5c 24 ad 67 3d c7 61 8f 81",
      "ja": "出力B'[0] = a4 1f 85 9c 66 08 cc 99 3b 81 ca cb 02 0c ef 05 04 4b 21 81 a2 fd 33 7d fd 7b 1c 63 96 68 2f 29 b4 39 31 68 e3 c9 e6 bc fe 6b c5 b7 a0 6d 96 ba e4 24 cc 10 2c 91 74 5c 24 ad 67 3d c7 61 8f 81"
    },
    {
      "indent": 3,
      "text": "B'[1] = 20 ed c9 75 32 38 81 a8 05 40 f6 4c 16 2d cd 3c 21 07 7c fe 5f 8d 5f e2 b1 a4 16 8f 95 36 78 b7 7d 3b 3d 80 3b 60 e4 ab 92 09 96 e5 9b 4d 53 b6 5d 2a 22 58 77 d5 ed f5 84 2c b9 f1 4e ef e4 25",
      "ja": "B'[1] = 20 ed c9 75 32 38 81 a8 05 40 f6 4c 16 2d cd 3c 21 07 7c fe 5f 8d 5f e2 b1 a4 16 8f 95 36 78 b7 7d 3b 3d 80 3b 60 e4 ab 92 09 96 e5 9b 4d 53 b6 5d 2a 22 58 77 d5 ed f5 84 2c b9 f1 4e ef e4 25"
    },
    {
      "indent": 0,
      "text": "10. Test Vectors for scryptROMix",
      "section_title": true,
      "ja": "10. scryptROMixのテストベクトル"
    },
    {
      "indent": 3,
      "text": "Below is a sequence of octets that illustrate input and output values for scryptROMix. The test vector uses an r value of 1 and an N value of 16. The octets are hex encoded and whitespace is inserted for readability. The value corresponds to the first input and output pair generated by the first scrypt test vector below.",
      "ja": "以下は、scryptROMixの入力値と出力値を示すオクテットのシーケンスです。テストベクトルはr=1およびN=16の値を使用します。オクテットは16進エンコードされ、読みやすくするために空白が挿入されます。値は、以下の最初のscryptテストベクトルによって生成される最初の入力と出力のペアに対応します。"
    },
    {
      "indent": 3,
      "text": "INPUT: B = f7 ce 0b 65 3d 2d 72 a4 10 8c f5 ab e9 12 ff dd 77 76 16 db bb 27 a7 0e 82 04 f3 ae 2d 0f 6f ad 89 f6 8f 48 11 d1 e8 7b cc 3b d7 40 0a 9f fd 29 09 4f 01 84 63 95 74 f3 9a e5 a1 31 52 17 bc d7 89 49 91 44 72 13 bb 22 6c 25 b5 4d a8 63 70 fb cd 98 43 80 37 46 66 bb 8f fc b5 bf 40 c2 54 b0 67 d2 7c 51 ce 4a d5 fe d8 29 c9 0b 50 5a 57 1b 7f 4d 1c ad 6a 52 3c da 77 0e 67 bc ea af 7e 89",
      "ja": "入力：B = f7 ce 0b 65 3d 2d 72 a4 10 8c f5 ab e9 12 ff dd 77 76 16 db bb 27 a7 0e 82 04 f3 ae 2d 0f 6f ad 89 f6 8f 48 11 d1 e8 7b cc 3b d7 40 0a 9f fd 29 09 4f 01 84 63 95 74 f3 9a e5 a1 31 52 17 bc d7 89 49 91 44 72 13 bb 22 6c 25 b5 4d a8 63 70 fb cd 98 43 80 37 46 66 bb 8f fc b5 bf 40 c2 54 b0 67 d2 7c 51 ce 4a d5 fe d8 29 c9 0b 50 5a 57 1b 7f 4d 1c ad 6a 52 3c da 77 0e 67 bc ea af 7e 89"
    },
    {
      "indent": 3,
      "text": "OUTPUT: B = 79 cc c1 93 62 9d eb ca 04 7f 0b 70 60 4b f6 b6 2c e3 dd 4a 96 26 e3 55 fa fc 61 98 e6 ea 2b 46 d5 84 13 67 3b 99 b0 29 d6 65 c3 57 60 1f b4 26 a0 b2 f4 bb a2 00 ee 9f 0a 43 d1 9b 57 1a 9c 71 ef 11 42 e6 5d 5a 26 6f dd ca 83 2c e5 9f aa 7c ac 0b 9c f1 be 2b ff ca 30 0d 01 ee 38 76 19 c4 ae 12 fd 44 38 f2 03 a0 e4 e1 c4 7e c3 14 86 1f 4e 90 87 cb 33 39 6a 68 73 e8 f9 d2 53 9a 4b 8e",
      "ja": "出力：B = 79 cc c1 93 62 9d eb ca 04 7f 0b 70 60 4b f6 b6 2c e3 dd 4a 96 26 e3 55 fa fc 61 98 e6 ea 2b 46 d5 84 13 67 3b 99 b0 29 d6 65 c3 57 60 1f b4 26 a0 b2 f4 bb a2 00 ee 9f 0a 43 d1 9b 57 1a 9c 71 ef 11 42 e6 5d 5a 26 6f dd ca 83 2c e5 9f aa 7c ac 0b 9c f1 be 2b ff ca 30 0d 01 ee 38 76 19 c4 ae 12 fd 44 38 f2 03 a0 e4 e1 c4 7e c3 14 86 1f 4e 90 87 cb 33 39 6a 68 73 e8 f9 d2 53 9a 4b 8e"
    },
    {
      "indent": 0,
      "text": "11. Test Vectors for PBKDF2 with HMAC-SHA-256",
      "section_title": true,
      "ja": "11. HMAC-SHA-256を使用したPBKDF2のテストベクトル"
    },
    {
      "indent": 3,
      "text": "Below is a sequence of octets that illustrate input and output values for PBKDF2-HMAC-SHA-256. The octets are hex encoded and whitespace is inserted for readability. The test vectors below can be used to verify the PBKDF2-HMAC-SHA-256 [RFC2898] function. The password and salt strings are passed as sequences of ASCII [RFC20] octets.",
      "ja": "以下は、PBKDF2-HMAC-SHA-256の入力値と出力値を示すオクテットのシーケンスです。オクテットは16進数でエンコードされ、読みやすくするために空白が挿入されます。以下のテストベクトルを使用して、PBKDF2-HMAC-SHA-256 [RFC2898]関数を検証できます。パスワードとソルト文字列は、ASCII [RFC20]オクテットのシーケンスとして渡されます。"
    },
    {
      "indent": 3,
      "text": "PBKDF2-HMAC-SHA-256 (P=\"passwd\", S=\"salt\", c=1, dkLen=64) = 55 ac 04 6e 56 e3 08 9f ec 16 91 c2 25 44 b6 05 f9 41 85 21 6d de 04 65 e6 8b 9d 57 c2 0d ac bc 49 ca 9c cc f1 79 b6 45 99 16 64 b3 9d 77 ef 31 7c 71 b8 45 b1 e3 0b d5 09 11 20 41 d3 a1 97 83",
      "ja": "PBKDF2-HMAC-SHA-256(P=\"passwd\", S=\"salt\", c=1, dkLen=64) = 55 ac 04 6e 56 e3 08 9f ec 16 91 c2 25 44 b6 05 f9 41 85 21 6d de 04 65 e6 8b 9d 57 c2 0d ac bc 49 ca 9c cc f1 79 b6 45 99 16 64 b3 9d 77 ef 31 7c 71 b8 45 b1 e3 0b d5 09 11 20 41 d3 a1 97 83"
    },
    {
      "indent": 3,
      "text": "PBKDF2-HMAC-SHA-256 (P=\"Password\", S=\"NaCl\", c=80000, dkLen=64) = 4d dc d8 f6 0b 98 be 21 83 0c ee 5e f2 27 01 f9 64 1a 44 18 d0 4c 04 14 ae ff 08 87 6b 34 ab 56 a1 d4 25 a1 22 58 33 54 9a db 84 1b 51 c9 b3 17 6a 27 2b de bb a1 d0 78 47 8f 62 b3 97 f3 3c 8d",
      "ja": "PBKDF2-HMAC-SHA-256(P=\"Password\", S=\"NaCl\", c=80000, dkLen=64) = 4d dc d8 f6 0b 98 be 21 83 0c ee 5e f2 27 01 f9 64 1a 44 18 d0 4c 04 14 ae ff 08 87 6b 34 ab 56 a1 d4 25 a1 22 58 33 54 9a db 84 1b 51 c9 b3 17 6a 27 2b de bb a1 d0 78 47 8f 62 b3 97 f3 3c 8d"
    },
    {
      "indent": 0,
      "text": "12. Test Vectors for scrypt",
      "section_title": true,
      "ja": "12. scryptのテストベクトル"
    },
    {
      "indent": 3,
      "text": "For reference purposes, we provide the following test vectors for scrypt, where the password and salt strings are passed as sequences of ASCII [RFC20] octets.",
      "ja": "参考のために、パスワードとソルト文字列がASCII [RFC20]オクテットのシーケンスとして渡されるscryptの次のテストベクトルを提供します。"
    },
    {
      "indent": 3,
      "text": "The parameters to the scrypt function below are, in order, the password P (octet string), the salt S (octet string), the CPU/Memory cost parameter N, the block size parameter r, the parallelization parameter p, and the output size dkLen. The output is hex encoded and whitespace is inserted for readability.",
      "ja": "以下のscrypt関数のパラメーターは、パスワードP（オクテット文字列）、ソルトS（オクテット文字列）、CPU/メモリコストパラメータN、ブロックサイズパラメーターr、並列化パラメーターp、出力サイズdkLenです。出力は16進エンコードされ、読みやすくするために空白が挿入されます。"
    },
    {
      "indent": 3,
      "text": "scrypt (P=\"\", S=\"\", N=16, r=1, p=1, dklen=64) = 77 d6 57 62 38 65 7b 20 3b 19 ca 42 c1 8a 04 97 f1 6b 48 44 e3 07 4a e8 df df fa 3f ed e2 14 42 fc d0 06 9d ed 09 48 f8 32 6a 75 3a 0f c8 1f 17 e8 d3 e0 fb 2e 0d 36 28 cf 35 e2 0c 38 d1 89 06",
      "ja": "scrypt(P=\"\", S=\"\", N=16, r=1, p=1, dklen=64) = 77 d6 57 62 38 65 7b 20 3b 19 ca 42 c1 8a 04 97 f1 6b 48 44 e3 07 4a e8 df df fa 3f ed e2 14 42 fc d0 06 9d ed 09 48 f8 32 6a 75 3a 0f c8 1f 17 e8 d3 e0 fb 2e 0d 36 28 cf 35 e2 0c 38 d1 89 06"
    },
    {
      "indent": 3,
      "text": "scrypt (P=\"password\", S=\"NaCl\", N=1024, r=8, p=16, dkLen=64) = fd ba be 1c 9d 34 72 00 78 56 e7 19 0d 01 e9 fe 7c 6a d7 cb c8 23 78 30 e7 73 76 63 4b 37 31 62 2e af 30 d9 2e 22 a3 88 6f f1 09 27 9d 98 30 da c7 27 af b9 4a 83 ee 6d 83 60 cb df a2 cc 06 40",
      "ja": "scrypt(P=\"password\", S=\"NaCl\", N=1024, r=8, p=16, dkLen=64) = fd ba be 1c 9d 34 72 00 78 56 e7 19 0d 01 e9 fe 7c 6a d7 cb c8 23 78 30 e7 73 76 63 4b 37 31 62 2e af 30 d9 2e 22 a3 88 6f f1 09 27 9d 98 30 da c7 27 af b9 4a 83 ee 6d 83 60 cb df a2 cc 06 40"
    },
    {
      "indent": 3,
      "text": "scrypt (P=\"pleaseletmein\", S=\"SodiumChloride\", N=16384, r=8, p=1, dkLen=64) = 70 23 bd cb 3a fd 73 48 46 1c 06 cd 81 fd 38 eb fd a8 fb ba 90 4f 8e 3e a9 b5 43 f6 54 5d a1 f2 d5 43 29 55 61 3f 0f cf 62 d4 97 05 24 2a 9a f9 e6 1e 85 dc 0d 65 1e 40 df cf 01 7b 45 57 58 87",
      "ja": "scrypt(P=\"pleaseletmein\", S=\"SodiumChloride\", N=16384, r=8, p=1, dkLen=64) = 70 23 bd cb 3a fd 73 48 46 1c 06 cd 81 fd 38 eb fd a8 fb ba 90 4f 8e 3e a9 b5 43 f6 54 5d a1 f2 d5 43 29 55 61 3f 0f cf 62 d4 97 05 24 2a 9a f9 e6 1e 85 dc 0d 65 1e 40 df cf 01 7b 45 57 58 87"
    },
    {
      "indent": 3,
      "text": "scrypt (P=\"pleaseletmein\", S=\"SodiumChloride\", N=1048576, r=8, p=1, dkLen=64) = 21 01 cb 9b 6a 51 1a ae ad db be 09 cf 70 f8 81 ec 56 8d 57 4a 2f fd 4d ab e5 ee 98 20 ad aa 47 8e 56 fd 8f 4b a5 d0 9f fa 1c 6d 92 7c 40 f4 c3 37 30 40 49 e8 a9 52 fb cb f4 5c 6f a7 7a 41 a4",
      "ja": "scrypt(P=\"pleaseletmein\", S=\"SodiumChloride\", N=1048576, r=8, p=1, dkLen=64) = 21 01 cb 9b 6a 51 1a ae ad db be 09 cf 70 f8 81 ec 56 8d 57 4a 2f fd 4d ab e5 ee 98 20 ad aa 47 8e 56 fd 8f 4b a5 d0 9f fa 1c 6d 92 7c 40 f4 c3 37 30 40 49 e8 a9 52 fb cb f4 5c 6f a7 7a 41 a4"
    },
    {
      "indent": 0,
      "text": "13. Test Vectors for PKCS#8",
      "section_title": true,
      "ja": "13. PKCS #8のテストベクトル"
    },
    {
      "indent": 3,
      "text": "PKCS#8 [RFC5208] and Asymmetric Key Packages [RFC5958] encode encrypted private-keys. Using PBES2 with scrypt as the KDF, the following illustrates an example of a PKCS#8-encoded private-key. The password is \"Rabbit\" (without the quotes) with N=1048576, r=8, and p=1. The salt is \"Mouse\" and the encryption algorithm used is aes256-CBC. The derived key is: E2 77 EA 2C AC B2 3E DA-FC 03 9D 22 9B 79 DC 13 EC ED B6 01 D9 9B 18 2A-9F ED BA 1E 2B FB 4F 58.",
      "ja": "PKCS #8 [RFC5208]および非対称鍵パッケージ[RFC5958]は、暗号化された秘密鍵をエンコードします。 KDFとしてscryptを使用してPBES2を使用すると、以下はPKCS #8でエンコードされた秘密鍵の例を示します。パスワードは \"Rabbit\"（引用符なし）で、N = 1048576、r = 8、p = 1です。ソルトは \"Mouse\" で、使用される暗号化アルゴリズムはaes256-CBCです。導出鍵は次のとおりです。E2 77 EA 2C AC B2 3E DA-FC 03 9D 22 9B 79 DC 13 EC ED B6 01 D9 9B 18 2A-9F ED BA 1E 2B FB 4F 58。"
    },
    {
      "indent": 3,
      "text": "-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIHiME0GCSqGSIb3DQEFDTBAMB8GCSsGAQQB2kcECzASBAVNb3VzZQIDEAAAAgEI\nAgEBMB0GCWCGSAFlAwQBKgQQyYmguHMsOwzGMPoyObk/JgSBkJb47EWd5iAqJlyy\n+ni5ftd6gZgOPaLQClL7mEZc2KQay0VhjZm/7MbBUNbqOAXNM6OGebXxVp6sHUAL\niBGY/Dls7B1TsWeGObE0sS1MXEpuREuloZjcsNVcNXWPlLdZtkSH6uwWzR0PyG/Z\n+ZXfNodZtd/voKlvLOw5B3opGIFaLkbtLZQwMiGtl42AS89lZg==\n-----END ENCRYPTED PRIVATE KEY-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14. Security Considerations",
      "section_title": true,
      "ja": "14. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document specifies a cryptographic algorithm, and there is always a risk that someone will find a weakness in it. By following the cryptographic research area, you may learn of publications relevant to scrypt.",
      "ja": "このドキュメントは暗号アルゴリズムを規定しており、誰かがそれの弱点を見つける危険が常にあります。暗号の研究分野を追うことで、scryptに関連する出版物を知ることができます。"
    },
    {
      "indent": 3,
      "text": "ROMix has been proven sequential memory-hard under the random oracle model for the hash function. The security of scrypt relies on the assumption that BlockMix with Salsa20/8 Core does not exhibit any \"shortcuts\" that would allow it to be iterated more easily than a random oracle. For other claims about the security properties, see [SCRYPT].",
      "ja": "ROMixは、ハッシュ関数のランダムオラクルモデルの下でシーケンシャルメモリハードであることが証明されています。 scryptのセキュリティは、Salsa20/8コアを備えたBlockMixが、ランダムオラクルよりも簡単に反復できるようにする「ショートカット」を示さないという前提に依存しています。セキュリティプロパティに関するその他の主張については、[SCRYPT]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Passwords and other sensitive data, such as intermediate values, may continue to be stored in memory, core dumps, swap areas, etc., for a long time after the implementation has processed them. This makes attacks on the implementation easier. Thus, implementation should consider storing sensitive data in protected memory areas. How to achieve this is system dependent.",
      "ja": "パスワードや中間値などのその他の機密データは、実装で処理された後も、長期間にわたってメモリ、コアダンプ、スワップ領域などに格納され続ける可能性があります。これにより、実装への攻撃が容易になります。したがって、実装では、機密データを保護されたメモリ領域に格納することを検討する必要があります。これを達成する方法はシステムに依存します。"
    },
    {
      "indent": 3,
      "text": "By nature and depending on parameters, running the scrypt algorithm may require large amounts of memory. Systems should protect against a denial-of-service attack resulting from attackers presenting unreasonably large parameters.",
      "ja": "性質上、パラメータによっては、scryptアルゴリズムを実行するには大量のメモリが必要になる場合があります。システムは、攻撃者が不当に大きなパラメータを提示することによるサービス拒否攻撃から保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "Poor parameter choices can be harmful for security; for example, if you tune the parameters so that memory use is reduced to small amounts that will affect the properties of the algorithm.",
      "ja": "パラメータの選択が適切でないと、セキュリティが低下する可能性があります。たとえば、メモリ使用量がアルゴリズムの特性に影響を与える少量に削減されるようにパラメータを調整する場合。"
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15. 参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2898] Kaliski, B., \"PKCS #5: Password-Based Cryptography Specification Version 2.0\", RFC 2898, DOI 10.17487/RFC2898, September 2000, <http://www.rfc-editor.org/info/rfc2898>.",
      "ja": "[RFC2898] Kaliski、B。、「PKCS＃5：Password-Based Cryptography Specification Version 2.0」、RFC 2898、DOI 10.17487 / RFC2898、2000年9月、<http://www.rfc-editor.org/info/rfc2898> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234] Eastlake 3rd、D。およびT. Hansen、「US Secure Hash Algorithms（SHA and SHA-based HMAC and HKDF）」、RFC 6234、DOI 10.17487/RFC6234、2011年5月、<http://www.rfc-editor.org/info/rfc6234>。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BCRYPT] Provos, N. and D. Mazieres, \"A Future-Adaptable Password Scheme\", USENIX 1999, June 1999, <https://www.usenix.org/legacy/event/usenix99/provos/ provos.pdf>.",
      "ja": "[BCRYPT] Provos、N。およびD. Mazieres、「A Future-Adaptable Password Scheme」、USENIX 1999、June 1999、<https://www.usenix.org/legacy/event/usenix99/provos/ provos.pdf> 。"
    },
    {
      "indent": 3,
      "text": "[NTLM] Microsoft, \"[MS-NLMP]: NT LAN Manager (NTLM) Authentication Protocol\", 2015, <https://msdn.microsoft.com/en-us/library/cc236621.aspx>.",
      "ja": "[NTLM] Microsoft、「[MS-NLMP]：NT LAN Manager（NTLM）Authentication Protocol」、2015、<https://msdn.microsoft.com/en-us/library/cc236621.aspx>。"
    },
    {
      "indent": 3,
      "text": "[RFC20] Cerf, V., \"ASCII format for network interchange\", STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969, <http://www.rfc-editor.org/info/rfc20>.",
      "ja": "[RFC20] Cerf、V。、「ネットワーク交換用のASCII形式」、STD 80、RFC 20、DOI 10.17487 / RFC0020、1969年10月、<http://www.rfc-editor.org/info/rfc20>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] Eastlake 3rd、D.、Schiller、J.、and S. Crocker、 \"Randomness Requirements for Security\"、BCP 106、RFC 4086、DOI 10.17487/RFC4086、June 2005、<http://www.rfc-editor.org/info/rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC5208] Kaliski, B., \"Public-Key Cryptography Standards (PKCS) #8: Private-Key Information Syntax Specification Version 1.2\", RFC 5208, DOI 10.17487/RFC5208, May 2008, <http://www.rfc-editor.org/info/rfc5208>.",
      "ja": "[RFC5208] Kaliski、B。、「Public-Key Cryptography Standards（PKCS）＃8：Private-Key Information Syntax Specification Version 1.2」、RFC 5208、DOI 10.17487 / RFC5208、2008年5月、<http：//www.rfc- editor.org/info/rfc5208>。"
    },
    {
      "indent": 3,
      "text": "[RFC5958] Turner, S., \"Asymmetric Key Packages\", RFC 5958, DOI 10.17487/RFC5958, August 2010, <http://www.rfc-editor.org/info/rfc5958>.",
      "ja": "[RFC5958]ターナー、S。、「非対称鍵パッケージ」、RFC 5958、DOI 10.17487 / RFC5958、2010年8月、<http://www.rfc-editor.org/info/rfc5958>。"
    },
    {
      "indent": 3,
      "text": "[SALSA20CORE] Bernstein, D., \"The Salsa20 Core\", March 2005, <http://cr.yp.to/salsa20.html>.",
      "ja": "[SALSA20CORE] Bernstein、D。、「The Salsa20 Core」、2005年3月、<http://cr.yp.to/salsa20.html>。"
    },
    {
      "indent": 3,
      "text": "[SALSA20SPEC] Bernstein, D., \"Salsa20 specification\", April 2005, <http://cr.yp.to/snuffle/spec.pdf>.",
      "ja": "[SALSA20SPEC] Bernstein、D。、「Salsa20仕様」、2005年4月、<http://cr.yp.to/snuffle/spec.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SCRYPT] Percival, C., \"STRONGER KEY DERIVATION VIA SEQUENTIAL MEMORY-HARD FUNCTIONS\", BSDCan'09, May 2009, <http://www.tarsnap.com/scrypt/scrypt.pdf>.",
      "ja": "[SCRYPT] Percival、C。、「シーケンシャルメモリハード関数による強力な鍵導出」、BSDCan'09、2009年5月、<http://www.tarsnap.com/scrypt/scrypt.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SHA2CRYPT] Drepper, U., \"Unix crypt using SHA-256 and SHA-512\", April 2008, <http://www.akkadia.org/drepper/SHA-crypt.txt>.",
      "ja": "[SHA2CRYPT] Drepper、U。、「Unix crypt using SHA-256 and SHA-512」、2008年4月、<http://www.akkadia.org/drepper/SHA-crypt.txt>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Text in this document was borrowed from [SCRYPT] and [RFC2898]. The PKCS#8 test vector was provided by Stephen N. Henson.",
      "ja": "このドキュメントのテキストは、[SCRYPT]および[RFC2898]から借用したものです。 PKCS #8テストベクトルは、Stephen N. Hensonから提供されました。"
    },
    {
      "indent": 3,
      "text": "Feedback on this document was received from Dmitry Chestnykh, Alexander Klink, Rob Kendrick, Royce Williams, Ted Rolle, Jr., Eitan Adler, Stephen Farrel, Nikos Mavrogiannopoulos, and Paul Kyzivat.",
      "ja": "このドキュメントに関するフィードバックは、Dmitry Chestnykh、Alexander Klink、Rob Kendrick、Royce Williams、Ted Rolle、Jr.、Eitan Adler、Stephen Farrel、Nikos Mavrogiannopoulos、およびPaul Kyzivatから受け取りました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Colin Percival Tarsnap",
      "ja": "Colin Percival Tarsnap"
    },
    {
      "indent": 3,
      "text": "Email: cperciva@tarsnap.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simon Josefsson SJD AB",
      "ja": "Simon Josefsson SJD AB"
    },
    {
      "indent": 3,
      "text": "Email: simon@josefsson.org\nURI:   http://josefsson.org/",
      "raw": true,
      "ja": ""
    }
  ]
}