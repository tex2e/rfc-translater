{
  "title": {
    "text": "RFC 8032 - Edwards-Curve Digital Signature Algorithm (EdDSA)",
    "ja": "RFC 8032 - Edwards-Curveデジタル署名アルゴリズム（EdDSA）"
  },
  "number": 8032,
  "created_at": "2020-08-29 09:30:08.730851+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                         S. Josefsson\nRequest for Comments: 8032                                        SJD AB\nCategory: Informational                                     I. Liusvaara\nISSN: 2070-1721                                              Independent\n                                                            January 2017",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Edwards-Curve Digital Signature Algorithm (EdDSA)",
      "ja": "Edwards-Curveデジタル署名アルゴリズム（EdDSA）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA). The algorithm is instantiated with recommended parameters for the edwards25519 and edwards448 curves. An example implementation and test vectors are provided.",
      "ja": "このドキュメントでは、楕円曲線署名方式のエドワーズ曲線デジタル署名アルゴリズム（EdDSA）について説明します。アルゴリズムは、edwards25519およびedwards448曲線の推奨パラメーターを使用してインスタンス化されます。実装例とテストベクタが提供されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはInternet Standards Trackの仕様ではありません。情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、Internet Research Task Force（IRTF）の製品です。 IRTFは、インターネット関連の研究開発活動の結果を公開しています。これらの結果は、展開に適さない可能性があります。このRFCは、インターネット研究タスクフォース（IRTF）の暗号フォーラム研究グループの合意を表します。 IRSGによる公開が承認されたドキュメントは、どのレベルのインターネット標準の候補にもなりません。 RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8032.",
      "ja": "このドキュメントの現在の状態、正誤表、およびフィードバックの提供方法に関する情報は、http://www.rfc-editor.org/info/rfc8032で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Notation and Conventions  . . . . . . . . . . . . . . . . . .   4\n3.  EdDSA Algorithm . . . . . . . . . . . . . . . . . . . . . . .   5\n  3.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . . . .   7\n  3.2.  Keys  . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  3.3.  Sign  . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n  3.4.  Verify  . . . . . . . . . . . . . . . . . . . . . . . . .   8\n4.  PureEdDSA, HashEdDSA, and Naming  . . . . . . . . . . . . . .   8\n5.  EdDSA Instances . . . . . . . . . . . . . . . . . . . . . . .   9\n  5.1.  Ed25519ph, Ed25519ctx, and Ed25519  . . . . . . . . . . .   9\n    5.1.1.  Modular Arithmetic  . . . . . . . . . . . . . . . . .  10\n    5.1.2.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  10\n    5.1.3.  Decoding  . . . . . . . . . . . . . . . . . . . . . .  11\n    5.1.4.  Point Addition  . . . . . . . . . . . . . . . . . . .  11\n    5.1.5.  Key Generation  . . . . . . . . . . . . . . . . . . .  13\n    5.1.6.  Sign  . . . . . . . . . . . . . . . . . . . . . . . .  13\n    5.1.7.  Verify  . . . . . . . . . . . . . . . . . . . . . . .  14\n  5.2.  Ed448ph and Ed448 . . . . . . . . . . . . . . . . . . . .  15\n    5.2.1.  Modular Arithmetic  . . . . . . . . . . . . . . . . .  16\n    5.2.2.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  16\n    5.2.3.  Decoding  . . . . . . . . . . . . . . . . . . . . . .  16\n    5.2.4.  Point Addition  . . . . . . . . . . . . . . . . . . .  17\n    5.2.5.  Key Generation  . . . . . . . . . . . . . . . . . . .  18\n    5.2.6.  Sign  . . . . . . . . . . . . . . . . . . . . . . . .  19\n    5.2.7.  Verify  . . . . . . . . . . . . . . . . . . . . . . .  19\n6.  Ed25519 Python Illustration . . . . . . . . . . . . . . . . .  20\n7.  Test Vectors  . . . . . . . . . . . . . . . . . . . . . . . .  23\n  7.1.  Test Vectors for Ed25519  . . . . . . . . . . . . . . . .  24\n  7.2.  Test Vectors for Ed25519ctx . . . . . . . . . . . . . . .  27\n  7.3.  Test Vectors for Ed25519ph  . . . . . . . . . . . . . . .  30\n  7.4.  Test Vectors for Ed448  . . . . . . . . . . . . . . . . .  30\n  7.5.  Test Vectors for Ed448ph  . . . . . . . . . . . . . . . .  38\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  40\n  8.1.  Side-Channel Leaks  . . . . . . . . . . . . . . . . . . .  40\n  8.2.  Randomness Considerations . . . . . . . . . . . . . . . .  40\n  8.3.  Use of Contexts . . . . . . . . . . . . . . . . . . . . .  41\n  8.4.  Signature Malleability  . . . . . . . . . . . . . . . . .  41\n  8.5.  Choice of Signature Primitive . . . . . . . . . . . . . .  41\n  8.6.  Mixing Different Prehashes  . . . . . . . . . . . . . . .  42\n  8.7.  Signing Large Amounts of Data at Once . . . . . . . . . .  42\n  8.8.  Multiplication by Cofactor in Verification  . . . . . . .  43\n  8.9.  Use of SHAKE256 as a Hash Function  . . . . . . . . . . .  43\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  43\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  43\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  44",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Appendix A.  Ed25519/Ed448 Python Library . . . . . . . . . . . .  46\nAppendix B.  Library Driver . . . . . . . . . . . . . . . . . . .  58\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  60\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  60",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Edwards-curve Digital Signature Algorithm (EdDSA) is a variant of Schnorr's signature system with (possibly twisted) Edwards curves. EdDSA needs to be instantiated with certain parameters, and this document describes some recommended variants.",
      "ja": "エドワーズ曲線デジタル署名アルゴリズム（EdDSA）は、（おそらくねじれた）エドワーズ曲線を備えたシュノーの署名システムの変形です。 EdDSAは特定のパラメーターでインスタンス化する必要があり、このドキュメントではいくつかの推奨されるバリアントについて説明します。"
    },
    {
      "indent": 3,
      "text": "To facilitate adoption of EdDSA in the Internet community, this document describes the signature scheme in an implementation-oriented way and provides sample code and test vectors.",
      "ja": "このドキュメントでは、インターネットコミュニティでのEdDSAの採用を容易にするために、実装指向の方法で署名方式を説明し、サンプルコードとテストベクトルを提供します。"
    },
    {
      "indent": 3,
      "text": "The advantages with EdDSA are as follows:",
      "ja": "EdDSAの利点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. EdDSA provides high performance on a variety of platforms;",
      "ja": "1. EdDSAは、さまざまなプラットフォームで高いパフォーマンスを提供します。"
    },
    {
      "indent": 3,
      "text": "2. The use of a unique random number for each signature is not required;",
      "ja": "2. 各署名に一意の乱数を使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "3. It is more resilient to side-channel attacks;",
      "ja": "3. サイドチャネル攻撃に対してより耐性があります。"
    },
    {
      "indent": 3,
      "text": "4. EdDSA uses small public keys (32 or 57 bytes) and signatures (64 or 114 bytes) for Ed25519 and Ed448, respectively;",
      "ja": "4. EdDSAは、Ed25519とEd448にそれぞれ小さな公開鍵（32または57バイト）と署名（64または114バイト）を使用します。"
    },
    {
      "indent": 3,
      "text": "5. The formulas are \"complete\", i.e., they are valid for all points on the curve, with no exceptions. This obviates the need for EdDSA to perform expensive point validation on untrusted public values; and",
      "ja": "5. 数式は「完全」です。つまり、例外はなく、曲線上のすべての点で有効です。これにより、EdDSAが信頼できないパブリックバリューに対してコストのかかるポイント検証を実行する必要がなくなります。そして"
    },
    {
      "indent": 3,
      "text": "6. EdDSA provides collision resilience, meaning that hash-function collisions do not break this system (only holds for PureEdDSA).",
      "ja": "6. EdDSAは衝突回復力を提供します。つまり、ハッシュ関数の衝突によってこのシステムが破壊されることはありません（PureEdDSAにのみ当てはまります）。"
    },
    {
      "indent": 3,
      "text": "The original EdDSA paper [EDDSA] and the generalized version described in \"EdDSA for more curves\" [EDDSA2] provide further background. RFC 7748 [RFC7748] discusses specific curves, including Curve25519 [CURVE25519] and Ed448-Goldilocks [ED448].",
      "ja": "オリジナルのEdDSAペーパー[EDDSA]と「その他の曲線用のEdDSA」[EDDSA2]で説明されている一般化されたバージョンは、さらに背景を提供します。 RFC 7748 [RFC7748]は、Curve25519 [CURVE25519]およびEd448-Goldilocks [ED448]を含む特定の曲線について説明しています。"
    },
    {
      "indent": 3,
      "text": "Ed25519 is intended to operate at around the 128-bit security level and Ed448 at around the 224-bit security level. A sufficiently large quantum computer would be able to break both. Reasonable projections of the abilities of classical computers conclude that Ed25519 is perfectly safe. Ed448 is provided for those applications with relaxed performance requirements and where there is a desire to hedge against analytical attacks on elliptic curves.",
      "ja": "Ed25519は約128ビットのセキュリティレベルで動作し、Ed448は約224ビットのセキュリティレベルで動作するように設計されています。十分に大きな量子コンピューターは、両方を破ることができます。古典的なコンピュータの能力の合理的な予測では、Ed25519は完全に安全であると結論付けています。 Ed448は、パフォーマンス要件が緩和され、楕円曲線に対する分析的攻撃を回避したいアプリケーション向けに提供されています。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Conventions",
      "section_title": true,
      "ja": "2. 表記と表記法"
    },
    {
      "indent": 3,
      "text": "The following notation is used throughout the document:",
      "ja": "ドキュメント全体で次の表記が使用されています。"
    },
    {
      "indent": 3,
      "text": "p : Denotes the prime number defining the underlying field",
      "ja": "p : 基礎となる体を定義する素数を表します"
    },
    {
      "indent": 3,
      "text": "GF(p) : Finite field with p elements",
      "ja": "GF(p) : p個の元を持つ有限体です"
    },
    {
      "indent": 3,
      "text": "x^y : x multiplied by itself y times",
      "ja": "x^y : xをy回掛け合わせます"
    },
    {
      "indent": 3,
      "text": "B : Generator of the group or subgroup of interest",
      "ja": "B : 対象の群または部分群の生成元です"
    },
    {
      "indent": 3,
      "text": "[n]X : X added to itself n times",
      "ja": "[n]X : Xをn回加算したものです"
    },
    {
      "indent": 3,
      "text": "h[i] : The i'th octet of octet string",
      "ja": "h[i] : オクテット文字列のi番目のオクテットです"
    },
    {
      "indent": 3,
      "text": "h_i : The i'th bit of h",
      "ja": "h_i : hのi番目のビットです"
    },
    {
      "indent": 3,
      "text": "a || b : (bit-)string a concatenated with (bit-)string b",
      "ja": "a || b :（ビット）文字列aと（ビット）文字列bを連結したものです"
    },
    {
      "indent": 3,
      "text": "a <= b : a is less than or equal to b",
      "ja": "a <= b : aはb以下です"
    },
    {
      "indent": 3,
      "text": "a >= b : a is greater than or equal to b",
      "ja": "a >= b : aはb以上です"
    },
    {
      "indent": 3,
      "text": "i+j : Sum of i and j",
      "ja": "i + j : iとjの和です"
    },
    {
      "indent": 3,
      "text": "i*j : Multiplication of i and j",
      "ja": "i * j : iとjの積です"
    },
    {
      "indent": 3,
      "text": "i-j : Subtraction of j from i",
      "ja": "i-j : iからjを引いた差です"
    },
    {
      "indent": 3,
      "text": "i/j : Division of i by j",
      "ja": "i/j : iをjで割った商です"
    },
    {
      "indent": 3,
      "text": "i x j : Cartesian product of i and j",
      "ja": "i x j : iとjのデカルト積です"
    },
    {
      "indent": 3,
      "text": "(u,v) : Elliptic curve point with x-coordinate u and y-coordinate v",
      "ja": "(u,v) : x座標がu、y座標がvの楕円曲線上の点です"
    },
    {
      "indent": 3,
      "text": "SHAKE256(x, y) : The y first octets of SHAKE256 [FIPS202] output for input x",
      "ja": "SHAKE256(x, y) : 入力xに対するSHAKE256 [FIPS202]出力の最初のyオクテットです"
    },
    {
      "indent": 3,
      "text": "OCTET(x) : The octet with value x",
      "ja": "OCTET(x) : 値がxのオクテットです"
    },
    {
      "indent": 3,
      "text": "OLEN(x) : The number of octets in string x",
      "ja": "OLEN（x）: 文字列xのオクテット数です"
    },
      {
      "indent": 3,
      "text": "dom2(x, y) : The blank octet string when signing or verifying Ed25519. Otherwise, the octet string: \"SigEd25519 no Ed25519 collisions\" || octet(x) || octet(OLEN(y)) || y, where x is in range 0-255 and y is an octet string of at most 255 octets. \"SigEd25519 no Ed25519 collisions\" is in ASCII (32 octets).",
      "ja": "dom2(x, y) : Ed25519の署名または検証時は空のオクテット文字列です。それ以外の場合、オクテット文字列は「\"SigEd25519 no Ed25519 collisions\" || octet(x) || octet(OLEN(y)) || y」（xは0～255の範囲、yは最大255オクテットのオクテット文字列）となります。\"SigEd25519 no Ed25519 collisions\"はASCII（32オクテット）です。"
    },
    {
      "indent": 3,
      "text": "dom4(x, y) : The octet string \"SigEd448\" || octet(x) || octet(OLEN(y)) || y, where x is in range 0-255 and y is an octet string of at most 255 octets. \"SigEd448\" is in ASCII (8 octets).",
      "ja": "dom4(x, y) : オクテット文字列 \"SigEd448\" || octet(x) || octet(OLEN(y)) || y です。ここで、xは0〜255の範囲、yは最大255オクテットのオクテット文字列です。\"SigEd448\"はASCII（8オクテット）です。"
    },
    {
      "indent": 3,
      "text": "Parentheses (i.e., '(' and ')') are used to group expressions, in order to avoid having the description depend on a binding order between operators.",
      "ja": "括弧（つまり '(' と ')'）は、演算子間の結合順序に依存する記述を避けるために、式をグループ化するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Bit strings are converted to octet strings by taking bits from left to right, packing those from the least significant bit of each octet to the most significant bit, and moving to the next octet when each octet fills up. The conversion from octet string to bit string is the reverse of this process; for example, the 16-bit bit string",
      "ja": "ビット文字列は、ビットを左から右に取り、各オクテットの最下位ビットから最上位ビットにパッキングし、各オクテットがいっぱいになると次のオクテットに移動することにより、オクテット文字列に変換されます。オクテット文字列からビット文字列への変換は、このプロセスの逆です。たとえば、16ビットのビット文字列"
    },
    {
      "indent": 13,
      "text": "b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "is converted into two octets x0 and x1 (in this order) as",
      "ja": "2つのオクテットx0とx1に（この順序で）次のように変換されます。"
    },
    {
      "indent": 13,
      "text": "x0 = b7*128+b6*64+b5*32+b4*16+b3*8+b2*4+b1*2+b0\nx1 = b15*128+b14*64+b13*32+b12*16+b11*8+b10*4+b9*2+b8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Little-endian encoding into bits places bits from left to right and from least significant to most significant. If combined with bit-string-to-octet-string conversion defined above, this results in little-endian encoding into octets (if length is not a multiple of 8, the most significant bits of the last octet remain unused).",
      "ja": "ビットへのリトルエンディアンエンコードでは、ビットが左から右に、最下位から最上位に配置されます。上記で定義されたビット文字列からオクテット文字列への変換と組み合わせる場合、これはオクテットへのリトルエンディアンエンコーディングになります（長さが8の倍数でない場合、最後のオクテットの最上位ビットは未使用のままです）。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. EdDSA Algorithm",
      "section_title": true,
      "ja": "3. EdDSAアルゴリズム"
    },
    {
      "indent": 3,
      "text": "EdDSA is a digital signature system with 11 parameters.",
      "ja": "EdDSAは、11個のパラメーターを持つデジタル署名システムです。"
    },
    {
      "indent": 0,
      "text": " The generic EdDSA digital signature system with its 11 input parameters is not intended to be implemented directly. Choosing parameters is critical for secure and efficient operation. Instead, you would implement a particular parameter choice for EdDSA (such as Ed25519 or Ed448), sometimes slightly generalized to achieve code reuse to cover Ed25519 and Ed448.",
      "ja": "11個の入力パラメーターを持つ一般的なEdDSAデジタル署名システムは、直接実装することを意図していません。安全で効率的な操作には、パラメータの選択が重要です。代わりに、EdDSAの特定のパラメーター選択（Ed25519やEd448など）を実装します。時には、Ed25519とEd448をカバーするコードの再利用を実現するために少し一般化されています。"
    },
    {
      "indent": 3,
      "text": "Therefore, a precise explanation of the generic EdDSA is thus not particularly useful for implementers. For background and completeness, a succinct description of the generic EdDSA algorithm is given here.",
      "ja": "したがって、一般的なEdDSAの正確な説明は、実装者にとって特に有用ではありません。背景と完全性のために、一般的なEdDSAアルゴリズムの簡潔な説明をここに示します。"
    },
    {
      "indent": 3,
      "text": "The definition of some parameters, such as n and c, may help to explain some steps of the algorithm that are not intuitive.",
      "ja": "nやcなどのいくつかのパラメーターの定義は、直感的でないアルゴリズムのいくつかのステップを説明するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "This description closely follows [EDDSA2].",
      "ja": "この説明は[EDDSA2]に密接に従っています。"
    },
    {
      "indent": 3,
      "text": "EdDSA has 11 parameters:",
      "ja": "EdDSAには11のパラメーターがあります。"
    },
    {
      "indent": 3,
      "text": "1. An odd prime power p. EdDSA uses an elliptic curve over the finite field GF(p).",
      "ja": "1. 奇素数べき乗 p。EdDSA は有限体 GF(p) 上の楕円曲線を使用します。"
    },
    {
      "indent": 3,
      "text": "2. An integer b with 2^(b-1) > p. EdDSA public keys have exactly b bits, and EdDSA signatures have exactly 2*b bits. b is recommended to be a multiple of 8, so public key and signature lengths are an integral number of octets.",
      "ja": "2. 2^(b-1) > p となる整数 b。EdDSA 公開鍵は正確に b ビット、EdDSA 署名は正確に 2*b ビットです。b は 8 の倍数にすることが推奨されるため、公開鍵と署名の長さはオクテットの整数倍になります。"
    },
    {
      "indent": 3,
      "text": "3. A (b-1)-bit encoding of elements of the finite field GF(p).",
      "ja": "3. 有限体GF(p)の元の(b-1)ビット符号化です。"
    },
    {
      "indent": 3,
      "text": "4. A cryptographic hash function H producing 2*b-bit output. Conservative hash functions (i.e., hash functions where it is infeasible to create collisions) are recommended and do not have much impact on the total cost of EdDSA.",
      "ja": "4. 2*bビットの出力を生成する暗号ハッシュ関数H。衝突が発生しにくいハッシュ関数（保守的なハッシュ関数）が推奨されており、EdDSAの総コストに大きな影響を与えません。"
    },
    {
      "indent": 3,
      "text": "5. An integer c that is 2 or 3. Secret EdDSA scalars are multiples of 2^c. The integer c is the base-2 logarithm of the so-called cofactor.",
      "ja": "5. 2または3の整数c。秘密EdDSAスカラーは2^cの倍数です。整数cは、いわゆるコファクターの2を底とする対数です。"
    },
    {
      "indent": 3,
      "text": "6. An integer n with c <= n < b. Secret EdDSA scalars have exactly n + 1 bits, with the top bit (the 2^n position) always set and the bottom c bits always cleared.",
      "ja": "6. c <= n < b を満たす整数 n。秘密 EdDSA スカラーは n + 1 ビットで構成され、最上位ビット (2^n の位置) は常に設定され、下位 c ビットは常にクリアされます。"
    },
    {
      "indent": 3,
      "text": "7. A non-square element d of GF(p). The usual recommendation is to take it as the value nearest to zero that gives an acceptable curve.",
      "ja": "7. GF(p)の非正方元d。通常は、許容可能な曲線を与えるゼロに最も近い値を取ることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "8. A non-zero square element a of GF(p). The usual recommendation for best performance is a = -1 if p mod 4 = 1, and a = 1 if p mod 4 = 3.",
      "ja": "8. GF(p)の非ゼロの正方元a。最良のパフォーマンスを得るための一般的な推奨値は、p mod 4 = 1の場合はa = -1、p mod 4 = 3の場合はa = 1です。"
    },
    {
      "indent": 3,
      "text": "9. An element B != (0,1) of the set E = { (x,y) is a member of GF(p) x GF(p) such that a * x^2 + y^2 = 1 + d * x^2 * y^2 }.",
      "ja": "9. 集合 E = { (x,y) は GF(p) x GF(p) の元であり、a * x^2 + y^2 = 1 + d * x^2 * y^2 を満たす } の元 B != (0,1) です。"
    },
    {
      "indent": 3,
      "text": "10. An odd prime L such that [L]B = 0 and 2^c * L = #E. The number #E (the number of points on the curve) is part of the standard data provided for an elliptic curve E, or it can be computed as cofactor * order.",
      "ja": "10. [L]B = 0 かつ 2^c * L = #E となる奇素数 L です。#E（曲線上の点の数）は、楕円曲線 E に提供される標準データの一部であり、または余因子 * 位数として計算することもできます。"
    },
    {
      "indent": 3,
      "text": "11. A \"prehash\" function PH. PureEdDSA means EdDSA where PH is the identity function, i.e., PH(M) = M. HashEdDSA means EdDSA where PH generates a short output, no matter how long the message is; for example, PH(M) = SHA-512(M).",
      "ja": "11. \"prehash\"関数 PH。PureEdDSA は、PH が恒等関数である EdDSA (つまり、PH(M) = M) を意味します。HashEdDSA は、メッセージの長さに関係なく、PH が短い出力を生成する EdDSA (たとえば、PH(M) = SHA-512(M)) を意味します。"
    },
    {
      "indent": 3,
      "text": "Points on the curve form a group under addition, (x3, y3) = (x1, y1) + (x2, y2), with the formulas",
      "ja": "曲線上の点は、加法 (x3, y3) = (x1, y1) + (x2, y2) のもとで群を形成し、次の式が成り立ちます。"
    },
    {
      "indent": 3,
      "text": "          x1 * y2 + x2 * y1                y1 * y2 - a * x1 * x2\nx3 = --------------------------,   y3 = ---------------------------\n      1 + d * x1 * x2 * y1 * y2          1 - d * x1 * x2 * y1 * y2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The neutral element in the group is (0,1).",
      "ja": "群の単位元は (0,1) です。"
    },
    {
      "indent": 3,
      "text": "Unlike many other curves used for cryptographic applications, these formulas are \"complete\"; they are valid for all points on the curve, with no exceptions. In particular, the denominators are non-zero for all input points.",
      "ja": "暗号化アプリケーションに使用される他の多くの曲線とは異なり、これらの式は「完全」です。これらは、例外なく、曲線上のすべての点に対して有効です。特に、分母はすべての入力点においてゼロではありません。"
    },
    {
      "indent": 3,
      "text": "There are more efficient formulas, which are still complete, that use homogeneous coordinates to avoid the expensive modulo p inversions. See [Faster-ECC] and [Edwards-revisited].",
      "ja": "高価なモジュロpの逆元計算を回避するために同次座標を使用する、より効率的な式（これらも完全です）があります。[Faster-ECC]および[Edwards-revisited]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1. Encoding",
      "section_title": true,
      "ja": "3.1. エンコーディング"
    },
    {
      "indent": 3,
      "text": "An integer 0 < S < L - 1 is encoded in little-endian form as a b-bit string ENC(S).",
      "ja": "整数0 < S < L-1は、リトルエンディアン形式でbビット文字列ENC（S）としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "An element (x,y) of E is encoded as a b-bit string called ENC(x,y), which is the (b-1)-bit encoding of y concatenated with one bit that is 1 if x is negative and 0 if x is not negative.",
      "ja": "Eの要素（x、y）は、ENC（x、y）と呼ばれるbビット文字列としてエンコードされます。これは、xが負の場合は1、xが負でない場合は0となる1ビットと連結された、yの（b-1）ビットエンコードです。"
    },
    {
      "indent": 3,
      "text": "The encoding of GF(p) is used to define \"negative\" elements of GF(p): specifically, x is negative if the (b-1)-bit encoding of x is lexicographically larger than the (b-1)-bit encoding of -x.",
      "ja": "GF(p) のエンコーディングは、GF(p) の「負の」要素を定義するために使用されます。具体的には、x の (b-1) ビットエンコーディングが -x の (b-1) ビットエンコーディングよりも辞書順で大きい場合、x は負です。"
    },
    {
      "indent": 0,
      "text": "3.2. Keys",
      "section_title": true,
      "ja": "3.2. キー"
    },
    {
      "indent": 3,
      "text": "An EdDSA private key is a b-bit string k.  Let the hash H(k) = (h_0, h_1, ..., h_(2b-1)) determine an integer s, which is 2^n plus the sum of m = 2^i * h_i for all integer i, c <= i < n.  Let s determine the multiple A = [s]B.  The EdDSA public key is ENC(A). The bits h_b, ..., h_(2b-1) are used below during signing.",
      "ja": "EdDSA 秘密鍵は b ビットの文字列 k です。ハッシュ H(k) = (h_0, h_1, ..., h_(2b-1)) によって整数 s が決定されます。これは、2^n に、c <= i < n となるすべての整数 i について m = 2^i * h_i の合計を加えたものです。s によって倍数 A = [s]B が決定されます。EdDSA 公開鍵は ENC(A) です。ビット h_b, ..., h_(2b-1) は、以下の署名時に使用されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Sign",
      "section_title": true,
      "ja": "3.3. 符号"
    },
    {
      "indent": 3,
      "text": "The EdDSA signature of a message M under a private key k is defined as the PureEdDSA signature of PH(M). In other words, EdDSA simply uses PureEdDSA to sign PH(M).",
      "ja": "秘密鍵 k によるメッセージ M の EdDSA 署名は、PH(M) の PureEdDSA 署名として定義されます。つまり、EdDSA は単に PureEdDSA を使用して PH(M) に署名します。"
    },
    {
      "indent": 3,
      "text": "The PureEdDSA signature of a message M under a private key k is the 2*b-bit string ENC(R) || ENC(S).  R and S are derived as follows. First define r = H(h_b || ... || h_(2b-1) || M) interpreting 2*b-bit strings in little-endian form as integers in {0, 1, ..., 2^(2*b) - 1}.  Let R = [r]B and S = (r + H(ENC(R) || ENC(A) || PH(M)) * s) mod L.  The s used here is from the previous section.",
      "ja": "秘密鍵 k によるメッセージ M の PureEdDSA 署名は、2*b ビット文字列 ENC(R) || ENC(S) です。R と S は以下のように導出されます。まず、リトルエンディアン形式の 2*b ビット文字列を {0, 1, ..., 2^(2*b) - 1} の整数として解釈し、r = H(h_b || ... || h_(2b-1) || M) と定義します。R = [r]B、S = (r + H(ENC(R) || ENC(A) || PH(M)) * s) mod L とします。ここで使用される s は前のセクションのものです。"
    },
    {
      "indent": 0,
      "text": "3.4. Verify",
      "section_title": true,
      "ja": "3.4. 確認"
    },
    {
      "indent": 3,
      "text": "To verify a PureEdDSA signature ENC(R) || ENC(S) on a message M under a public key ENC(A), proceed as follows. Parse the inputs so that A and R are elements of E, and S is a member of the set {0, 1, ..., L-1}. Compute h = H(ENC(R) || ENC(A) || M), and check the group equation [2^c * S] B = 2^c * R + [2^c * h] A in E. The signature is rejected if parsing fails (including S being out of range) or if the group equation does not hold.",
      "ja": "公開鍵 ENC(A) によるメッセージ M の PureEdDSA 署名 ENC(R) || ENC(S) を検証するには、次のように処理します。A と R が E の要素であり、S が集合 {0, 1, ..., L-1} の要素になるように入力を解析します。h = H(ENC(R) || ENC(A) || M) を計算し、E における群の方程式 [2^c * S] B = 2^c * R + [2^c * h] A を確認します。解析が失敗した場合（S が範囲外であることを含む）、または群の方程式が成立しない場合、署名は拒否されます。"
    },
    {
      "indent": 3,
      "text": "EdDSA verification for a message M is defined as PureEdDSA verification for PH(M).",
      "ja": "メッセージ M の EdDSA 検証は、PH(M) の PureEdDSA 検証として定義されます。"
    },
    {
      "indent": 0,
      "text": "4. PureEdDSA, HashEdDSA, and Naming",
      "section_title": true,
      "ja": "4. PureEdDSA、HashEdDSA、およびネーミング"
    },
    {
      "indent": 3,
      "text": "One of the parameters of the EdDSA algorithm is the \"prehash\" function. This may be the identity function, resulting in an algorithm called PureEdDSA, or a collision-resistant hash function such as SHA-512, resulting in an algorithm called HashEdDSA.",
      "ja": "EdDSA アルゴリズムのパラメーターの 1 つは、「プリハッシュ」関数です。これは、PureEdDSA と呼ばれるアルゴリズムになる恒等関数、または HashEdDSA と呼ばれるアルゴリズムになる SHA-512 などの衝突耐性ハッシュ関数の可能性があります。"
    },
    {
      "indent": 3,
      "text": "Choosing which variant to use depends on which property is deemed to be more important between 1) collision resilience and 2) a single-pass interface for creating signatures. The collision resilience property means EdDSA is secure even if it is feasible to compute collisions for the hash function. The single-pass interface property means that only one pass over the input message is required to create a signature. PureEdDSA requires two passes over the input. Many existing APIs, protocols, and environments assume digital signature algorithms only need one pass over the input and may have API or bandwidth concerns supporting anything else.",
      "ja": "使用するバリアントの選択は、1）衝突耐性と 2）署名を作成するためのシングルパスインターフェイスの間で、どちらの特性がより重要であると考えられるかによって異なります。衝突耐性特性は、ハッシュ関数の衝突を計算することが可能であっても EdDSA が安全であることを意味します。シングルパスインターフェイス特性は、署名を作成するために入力メッセージを 1 回だけ通過すればよいことを意味します。PureEdDSA では、入力に対して 2 回のパスが必要です。多くの既存の API、プロトコル、および環境は、デジタル署名アルゴリズムが入力を 1 回だけ通過すればよいことを想定しており、それ以外をサポートすることに API や帯域幅の懸念がある可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that single-pass verification is not possible with most uses of signatures, no matter which signature algorithm is chosen. This is because most of the time, one can't process the message until the signature is validated, which needs a pass on the entire message.",
      "ja": "どの署名アルゴリズムを選択しても、署名のほとんどの使用法ではシングルパス検証は不可能であることに注意してください。これは、ほとんどの場合、署名が検証されるまでメッセージを処理できず、検証にはメッセージ全体のパス（走査）が必要になるためです。"
    },
    {
      "indent": 3,
      "text": "This document specifies parameters resulting in the HashEdDSA variants Ed25519ph and Ed448ph and the PureEdDSA variants Ed25519 and Ed448.",
      "ja": "このドキュメントでは、HashEdDSAバリアントEd25519phとEd448ph、およびPureEdDSAバリアントEd25519とEd448になるパラメーターを指定します。"
    },
    {
      "indent": 0,
      "text": "5. EdDSA Instances",
      "section_title": true,
      "ja": "5. EdDSAインスタンス"
    },
    {
      "indent": 3,
      "text": "This section instantiates the general EdDSA algorithm for the edwards25519 and edwards448 curves, each for the PureEdDSA and HashEdDSA variants (plus a contextualized extension of the Ed25519 scheme). Thus, five different parameter sets are described.",
      "ja": "このセクションでは、edwards25519 および edwards448 曲線の一般的な EdDSA アルゴリズムを、それぞれ PureEdDSA および HashEdDSA バリアント（および Ed25519 スキームのコンテキスト化された拡張）についてインスタンス化します。したがって、5 つの異なるパラメーターセットについて説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Ed25519ph, Ed25519ctx, and Ed25519",
      "section_title": true,
      "ja": "5.1. Ed25519ph、Ed25519ctx、およびEd25519"
    },
    {
      "indent": 3,
      "text": "Ed25519 is EdDSA instantiated with:",
      "ja": "Ed25519は、次のようにインスタンス化されたEdDSAです。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------------------------------------------------------+\n| Parameter | Value                                                 |\n+-----------+-------------------------------------------------------+\n|     p     | p of edwards25519 in [RFC7748] (i.e., 2^255 - 19)     |\n|     b     | 256                                                   |\n|  encoding | 255-bit little-endian encoding of {0, 1, ..., p-1}    |\n|  of GF(p) |                                                       |\n|    H(x)   | SHA-512(dom2(phflag,context)||x) [RFC6234]            |\n|     c     | base 2 logarithm of cofactor of edwards25519 in       |\n|           | [RFC7748] (i.e., 3)                                   |\n|     n     | 254                                                   |\n|     d     | d of edwards25519 in [RFC7748] (i.e., -121665/121666  |\n|           | = 370957059346694393431380835087545651895421138798432 |\n|           | 19016388785533085940283555)                           |\n|     a     | -1                                                    |\n|     B     | (X(P),Y(P)) of edwards25519 in [RFC7748] (i.e., (1511 |\n|           | 22213495354007725011514095885315114540126930418572060 |\n|           | 46113283949847762202, 4631683569492647816942839400347 |\n|           | 5163141307993866256225615783033603165251855960))      |\n|     L     | order of edwards25519 in [RFC7748] (i.e.,             |\n|           | 2^252+27742317777372353535851937790883648493).        |\n|   PH(x)   | x (i.e., the identity function)                       |\n+-----------+-------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 1: Parameters of Ed25519",
      "ja": "表1：Ed25519のパラメーター"
    },
    {
      "indent": 3,
      "text": "For Ed25519, dom2(f,c) is the empty string. The phflag value is irrelevant. The context (if present at all) MUST be empty. This causes the scheme to be one and the same with the Ed25519 scheme published earlier.",
      "ja": "Ed25519の場合、dom2（f、c）は空の文字列です。 phflag値は無関係です。コンテキスト（存在する場合）は空である必要があります。これにより、スキームは以前に公開されたEd25519スキームと同じになります。"
    },
    {
      "indent": 3,
      "text": "For Ed25519ctx, phflag=0. The context input SHOULD NOT be empty.",
      "ja": "Ed25519ctxの場合、phflag = 0です。コンテキスト入力は空であってはなりません。"
    },
    {
      "indent": 3,
      "text": "For Ed25519ph, phflag=1 and PH is SHA512 instead. That is, the input is hashed using SHA-512 before signing with Ed25519.",
      "ja": "Ed25519phの場合、phflag = 1で、代わりにPHはSHA512です。つまり、入力はEd25519で署名する前にSHA-512を使用してハッシュされます。"
    },
    {
      "indent": 3,
      "text": "Value of context is set by the signer and verifier (maximum of 255 octets; the default is empty string, except for Ed25519, which can't have context) and has to match octet by octet for verification to be successful.",
      "ja": "コンテキストの値は、署名者と検証者によって設定され（最大255オクテット。デフォルトは、コンテキストを持たないEd25519を除いて、空の文字列です）、検証を成功させるには、オクテットごとにオクテットを一致させる必要があります。"
    },
    {
      "indent": 3,
      "text": "The curve used is equivalent to Curve25519 [CURVE25519], under a change of coordinates, which means that the difficulty of the discrete logarithm problem is the same as for Curve25519.",
      "ja": "使用される曲線は、座標が変更された場合のCurve25519 [CURVE25519]と同等です。つまり、離散対数問題の難易度はCurve25519の場合と同じです。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Modular Arithmetic",
      "section_title": true,
      "ja": "5.1.1. モジュラー演算"
    },
    {
      "indent": 3,
      "text": "For advice on how to implement arithmetic modulo p = 2^255 - 19 efficiently and securely, see Curve25519 [CURVE25519]. For inversion modulo p, it is recommended to use the identity x^-1 = x^(p-2) (mod p). Inverting zero should never happen, as it would require invalid input, which would have been detected before, or would be a calculation error.",
      "ja": "p = 2^255 - 19 を法とする演算を効率的かつ安全に実装する方法については、Curve25519 [CURVE25519] を参照してください。p を法とする逆元については、恒等式 x^-1 = x^(p-2) (mod p) を使用することをお勧めします。ゼロの逆元計算は発生しないはずです。なぜなら、それは無効な入力を必要とし（これは事前に検出されているはずです）、あるいは計算エラーになるからです。"
    },
    {
      "indent": 3,
      "text": "For point decoding or \"decompression\", square roots modulo p are needed. They can be computed using the Tonelli-Shanks algorithm or the special case for p = 5 (mod 8). To find a square root of a, first compute the candidate root x = a^((p+3)/8) (mod p). Then there are three cases:",
      "ja": "点のデコードまたは「解凍」では、p を法とする平方根が必要です。これらは、Tonelli-Shanks アルゴリズムまたは p = 5 (mod 8) の特殊なケースを使用して計算できます。a の平方根を見つけるには、まず候補となる根 x = a^((p+3)/8) (mod p) を計算します。次に、3 つのケースがあります。"
    },
    {
      "indent": 6,
      "text": "x^2 = a (mod p). Then x is a square root.",
      "ja": "x^2 = a (mod p)。この場合、x は平方根です。"
    },
    {
      "indent": 6,
      "text": "x^2 = -a (mod p). Then 2^((p-1)/4) * x is a square root.",
      "ja": "x^2 = -a (mod p)。この場合、2^((p-1)/4) * x は平方根です。"
    },
    {
      "indent": 6,
      "text": "a is not a square modulo p.",
      "ja": "a は p を法とする平方剰余ではありません。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Encoding",
      "section_title": true,
      "ja": "5.1.2. エンコーディング"
    },
    {
      "indent": 3,
      "text": "All values are coded as octet strings, and integers are coded using little-endian convention, i.e., a 32-octet string h h[0],...h[31] represents the integer h[0] + 2^8 * h[1] + ... + 2^248 * h[31].",
      "ja": "すべての値はオクテット文字列としてコード化され、整数はリトルエンディアン規則を使用してコード化されます。つまり、32オクテット文字列 h h[0],...h[31] は整数 h[0] + 2^8 * h[1] + ... + 2^248 * h[31] を表します。"
    },
    {
      "indent": 3,
      "text": "A curve point (x,y), with coordinates in the range 0 <= x,y < p, is coded as follows. First, encode the y-coordinate as a little-endian string of 32 octets. The most significant bit of the final octet is always zero. To form the encoding of the point, copy the least significant bit of the x-coordinate to the most significant bit of the final octet.",
      "ja": "座標が 0 <= x,y < p の範囲にある曲線上の点 (x,y) は、次のようにコード化されます。まず、y 座標を 32 オクテットのリトルエンディアン文字列としてエンコードします。最後のオクテットの最上位ビットは常にゼロです。点のエンコーディングを形成するには、x 座標の最下位ビットを最後のオクテットの最上位ビットにコピーします。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Decoding",
      "section_title": true,
      "ja": "5.1.3. 解読"
    },
    {
      "indent": 3,
      "text": "Decoding a point, given as a 32-octet string, is a little more complicated.",
      "ja": "32 オクテット文字列として与えられた点のデコードは、もう少し複雑です。"
    },
    {
      "indent": 3,
      "text": "1. First, interpret the string as an integer in little-endian representation. Bit 255 of this number is the least significant bit of the x-coordinate and denote this value x_0. The y-coordinate is recovered simply by clearing this bit. If the resulting value is >= p, decoding fails.",
      "ja": "1. まず、文字列をリトルエンディアン表現の整数として解釈します。この数値のビット 255 は x 座標の最下位ビットであり、この値を x_0 とします。y 座標は、このビットをクリアするだけで復元されます。結果の値が >= p の場合、デコードは失敗します。"
    },
    {
      "indent": 3,
      "text": "2. To recover the x-coordinate, the curve equation implies x^2 = (y^2 - 1) / (d y^2 + 1) (mod p). The denominator is always non-zero mod p. Let u = y^2 - 1 and v = d y^2 + 1. To compute the square root of (u/v), the first step is to compute the candidate root x = (u/v)^((p+3)/8). This can be done with the following trick, using a single modular powering for both the inversion of v and the square root:",
      "ja": "2. x 座標を復元するには、曲線方程式から x^2 = (y^2 - 1) / (d y^2 + 1) (mod p) が成り立ちます。分母は常に mod p で非ゼロです。u = y^2 - 1、v = d y^2 + 1 とします。(u/v) の平方根を計算するには、まず候補となる根 x = (u/v)^((p+3)/8) を計算します。これは、v の逆関数と平方根の両方に単一のモジュラー累乗法を使用するという、次のトリックで行うことができます。"
    },
    {
      "indent": 17,
      "text": "         (p+3)/8      3        (p-5)/8\nx = (u/v)        = u v  (u v^7)         (mod p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3. Again, there are three cases:",
      "ja": "3. この場合も、3つのケースがあります。"
    },
    {
      "indent": 7,
      "text": "1. If v x^2 = u (mod p), x is a square root.",
      "ja": "1. v x ^ 2 = u（mod p）の場合、xは平方根です。"
    },
    {
      "indent": 7,
      "text": "2. If v x^2 = -u (mod p), set x <-- x * 2^((p-1)/4), which is a square root.",
      "ja": "2. v x^2 = -u (mod p) の場合、x <-- x * 2^((p-1)/4) に設定し、これは平方根になります。"
    },
    {
      "indent": 7,
      "text": "3. Otherwise, no square root exists for modulo p, and decoding fails.",
      "ja": "3. そうでない場合、pを法とする平方根は存在せず、デコードは失敗します。"
    },
    {
      "indent": 3,
      "text": "4. Finally, use the x_0 bit to select the right square root. If x = 0, and x_0 = 1, decoding fails. Otherwise, if x_0 != x mod 2, set x <-- p - x. Return the decoded point (x,y).",
      "ja": "4. 最後に、x_0 ビットを使用して、正しい平方根を選択します。x = 0 かつ x_0 = 1 の場合、デコードは失敗します。それ以外の場合、x_0 != x mod 2 であれば、x <-- p - x と設定します。デコードされた点 (x,y) を返します。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Point Addition",
      "section_title": true,
      "ja": "5.1.4. ポイント加算"
    },
    {
      "indent": 3,
      "text": "For point addition, the following method is recommended. A point (x,y) is represented in extended homogeneous coordinates (X, Y, Z, T), with x = X/Z, y = Y/Z, x * y = T/Z.",
      "ja": "点の加算には、次の方法が推奨されます。点 (x,y) は、拡張同次座標 (X, Y, Z, T) で表され、x = X/Z、y = Y/Z、x * y = T/Z となります。"
    },
    {
      "indent": 3,
      "text": "The neutral point is (0,1), or equivalently in extended homogeneous coordinates (0, Z, Z, 0) for any non-zero Z.",
      "ja": "中立点は (0,1) です。または、任意の非ゼロ Z に対して、拡張同次座標では (0, Z, Z, 0) と同等です。"
    },
    {
      "indent": 3,
      "text": "The following formulas for adding two points, (x3,y3) = (x1,y1)+(x2,y2), on twisted Edwards curves with a=-1, square a, and non-square d are described in Section 3.1 of [Edwards-revisited] and in [EFD-TWISTED-ADD]. They are complete, i.e., they work for any pair of valid input points.",
      "ja": "a=-1、a が平方剰余、d が非平方剰余であるねじれエドワーズ曲線上の 2 点の加算 (x3,y3) = (x1,y1)+(x2,y2) のための以下の式は、[Edwards-revisited] のセクション 3.1 および [EFD-TWISTED-ADD] で説明されています。これらは完全です。つまり、有効な入力点の任意のペアに対して機能します。"
    },
    {
      "indent": 17,
      "text": "A = (Y1-X1)*(Y2-X2)\nB = (Y1+X1)*(Y2+X2)\nC = T1*2*d*T2\nD = Z1*2*Z2\nE = B-A\nF = D-C\nG = D+C\nH = B+A\nX3 = E*F\nY3 = G*H\nT3 = E*H\nZ3 = F*G",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For point doubling, (x3,y3) = (x1,y1)+(x1,y1), one could just substitute equal points in the above (because of completeness, such substitution is valid) and observe that four multiplications turn into squares. However, using the formulas described in Section 3.2 of [Edwards-revisited] and in [EFD-TWISTED-DBL] saves a few smaller operations.",
      "ja": "点の 2 倍算 (x3,y3) = (x1,y1)+(x1,y1) については、上記の式に等しい点を単に代入するだけで済みます（完全性のため、このような代入は有効です）。こうすることで、4 回の乗算が 2 乗になることが分かります。しかし、[Edwards-revisited] のセクション 3.2 および [EFD-TWISTED-DBL] で説明されている式を使用すると、いくつかの小さな演算を節約できます。"
    },
    {
      "indent": 17,
      "text": "A = X1^2\nB = Y1^2\nC = 2*Z1^2\nH = A+B\nE = H-(X1+Y1)^2\nG = A-B\nF = C+G\nX3 = E*F\nY3 = G*H\nT3 = E*H\nZ3 = F*G",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.1.5. Key Generation",
      "section_title": true,
      "ja": "5.1.5. 鍵の生成"
    },
    {
      "indent": 3,
      "text": "The private key is 32 octets (256 bits, corresponding to b) of cryptographically secure random data. See [RFC4086] for a discussion about randomness.",
      "ja": "秘密鍵は、32 オクテット（256 ビット、b に対応）の暗号論的に安全なランダムデータです。ランダム性についての議論は [RFC4086] を参照してください。"
    },
    {
      "indent": 3,
      "text": "The 32-byte public key is generated by the following steps.",
      "ja": "32バイトの公開鍵は、次の手順で生成されます。"
    },
    {
      "indent": 3,
      "text": "1. Hash the 32-byte private key using SHA-512, storing the digest in a 64-octet large buffer, denoted h. Only the lower 32 bytes are used for generating the public key.",
      "ja": "1. SHA-512を使用して32バイトの秘密鍵をハッシュし、hで示される64オクテットの大きなバッファーにダイジェストを格納します。公開鍵の生成には、下位32バイトのみが使用されます。"
    },
    {
      "indent": 3,
      "text": "2. Prune the buffer: The lowest three bits of the first octet are cleared, the highest bit of the last octet is cleared, and the second highest bit of the last octet is set.",
      "ja": "2. バッファのプルーニング：最初のオクテットの最下位3ビットがクリアされ、最後のオクテットの最上位ビットがクリアされ、最後のオクテットの2番目に上位のビットが設定されます。"
    },
    {
      "indent": 3,
      "text": "3. Interpret the buffer as the little-endian integer, forming a secret scalar s. Perform a fixed-base scalar multiplication [s]B.",
      "ja": "3. バッファーをリトルエンディアン整数として解釈し、秘密のスカラー s を形成します。固定基点のスカラー倍算 [s]B を実行します。"
    },
    {
      "indent": 3,
      "text": "4. The public key A is the encoding of the point [s]B. First, encode the y-coordinate (in the range 0 <= y < p) as a little-endian string of 32 octets. The most significant bit of the final octet is always zero. To form the encoding of the point [s]B, copy the least significant bit of the x coordinate to the most significant bit of the final octet. The result is the public key.",
      "ja": "4. 公開鍵 A は、点 [s]B のエンコーディングです。まず、y 座標（0 <= y < p の範囲）を 32 オクテットのリトルエンディアン文字列としてエンコードします。最後のオクテットの最上位ビットは常にゼロです。点 [s]B のエンコーディングを形成するには、x 座標の最下位ビットを最後のオクテットの最上位ビットにコピーします。結果は公開鍵です。"
    },
    {
      "indent": 0,
      "text": "5.1.6. Sign",
      "section_title": true,
      "ja": "5.1.6. 符号"
    },
    {
      "indent": 3,
      "text": "The inputs to the signing procedure is the private key, a 32-octet string, and a message M of arbitrary size. For Ed25519ctx and Ed25519ph, there is additionally a context C of at most 255 octets and a flag F, 0 for Ed25519ctx and 1 for Ed25519ph.",
      "ja": "署名手順への入力は、秘密鍵（32 オクテット文字列）、および任意のサイズのメッセージ M です。Ed25519ctx と Ed25519ph の場合、さらに最大 255 オクテットのコンテキスト C と、Ed25519ctx の場合は 0、Ed25519ph の場合は 1 となるフラグ F があります。"
    },
    {
      "indent": 3,
      "text": "1. Hash the private key, 32 octets, using SHA-512. Let h denote the resulting digest. Construct the secret scalar s from the first half of the digest, and the corresponding public key A, as described in the previous section. Let prefix denote the second half of the hash digest, h[32],...,h[63].",
      "ja": "1. SHA-512 を使用して、32 オクテットの秘密鍵をハッシュします。結果のダイジェストを h とします。前のセクションで説明したように、ダイジェストの前半から秘密スカラー s と対応する公開鍵 A を作成します。prefix をハッシュダイジェストの後半 h[32],...,h[63] とします。"
    },
    {
      "indent": 3,
      "text": "2. Compute SHA-512(dom2(F, C) || prefix || PH(M)), where M is the message to be signed. Interpret the 64-octet digest as a little-endian integer r.",
      "ja": "2. SHA-512(dom2(F, C) || prefix || PH(M)) を計算します。ここで、M は署名されるメッセージです。64 オクテットのダイジェストをリトルエンディアン整数 r として解釈します。"
    },
    {
      "indent": 3,
      "text": "3. Compute the point [r]B. For efficiency, do this by first reducing r modulo L, the group order of B. Let the string R be the encoding of this point.",
      "ja": "3. 点 [r]B を計算します。効率を上げるために、まず B の群の位数である L を法として r を簡約することでこれを行います。文字列 R をこの点のエンコーディングとします。"
    },
    {
      "indent": 3,
      "text": "4. Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the 64-octet digest as a little-endian integer k.",
      "ja": "4. SHA512(dom2(F, C) || R || A || PH(M)) を計算し、64 オクテットダイジェストをリトルエンディアン整数 k として解釈します。"
    },
    {
      "indent": 3,
      "text": "5. Compute S = (r + k * s) mod L. For efficiency, again reduce k modulo L first.",
      "ja": "5. S = (r + k * s) mod L を計算します。効率を上げるために、ここでも L を法として k を最初に簡約します。"
    },
    {
      "indent": 3,
      "text": "6. Form the signature of the concatenation of R (32 octets) and the little-endian encoding of S (32 octets; the three most significant bits of the final octet are always zero).",
      "ja": "6. R（32 オクテット）と S のリトルエンディアンエンコーディング（32 オクテット。最後のオクテットの最上位 3 ビットは常にゼロ）を連結して署名を形成します。"
    },
    {
      "indent": 0,
      "text": "5.1.7. Verify",
      "section_title": true,
      "ja": "5.1.7. 確認"
    },
    {
      "indent": 3,
      "text": "1. To verify a signature on a message M using public key A, with F being 0 for Ed25519ctx, 1 for Ed25519ph, and if Ed25519ctx or Ed25519ph is being used, C being the context, first split the signature into two 32-octet halves. Decode the first half as a point R, and the second half as an integer S, in the range 0 <= s < L. Decode the public key A as point A'. If any of the decodings fail (including S being out of range), the signature is invalid.",
      "ja": "1. 公開鍵 A を使用してメッセージ M の署名を検証するには（F は Ed25519ctx の場合は 0、Ed25519ph の場合は 1、Ed25519ctx または Ed25519ph が使用されている場合は C がコンテキスト）、まず署名を 2 つの 32 オクテットの半分に分割します。前半を点 R として、後半を整数 S として、0 <= s < L の範囲でデコードします。公開鍵 A を点 A' としてデコードします。デコードのいずれかが失敗した場合（S が範囲外であることを含む）、署名は無効です。"
    },
    {
      "indent": 3,
      "text": "2. Compute SHA512(dom2(F, C) || R || A || PH(M)), and interpret the 64-octet digest as a little-endian integer k.",
      "ja": "2. SHA512(dom2(F, C) || R || A || PH(M)) を計算し、64 オクテットダイジェストをリトルエンディアン整数 k として解釈します。"
    },
    {
      "indent": 3,
      "text": "3. Check the group equation [8][S]B = [8]R + [8][k]A'. It's sufficient, but not required, to instead check [S]B = R + [k]A'.",
      "ja": "3. 群の方程式 [8][S]B = [8]R + [8][k]A' を確認します。代わりに [S]B = R + [k]A' を確認するだけでも十分ですが、必須ではありません。"
    },
    {
      "indent": 0,
      "text": "5.2. Ed448ph and Ed448",
      "section_title": true,
      "ja": "5.2. Ed448phおよびEd448"
    },
    {
      "indent": 3,
      "text": "Ed448 is EdDSA instantiated with:",
      "ja": "Ed448は、次のようにインスタンス化されたEdDSAです。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------------------------------------------------------+\n| Parameter | Value                                                 |\n+-----------+-------------------------------------------------------+\n|     p     | p of edwards448 in [RFC7748] (i.e., 2^448 - 2^224 -   |\n|           | 1)                                                    |\n|     b     | 456                                                   |\n|  encoding | 455-bit little-endian encoding of {0, 1, ..., p-1}    |\n|  of GF(p) |                                                       |\n|    H(x)   | SHAKE256(dom4(phflag,context)||x, 114)                |\n|   phflag  | 0                                                     |\n|     c     | base 2 logarithm of cofactor of edwards448 in         |\n|           | [RFC7748] (i.e., 2)                                   |\n|     n     | 447                                                   |\n|     d     | d of edwards448 in [RFC7748] (i.e., -39081)           |\n|     a     | 1                                                     |\n|     B     | (X(P),Y(P)) of edwards448 in [RFC7748] (i.e., (224580 |\n|           | 04029592430018760433409989603624678964163256413424612 |\n|           | 54616869504154674060329090291928693579532825780320751 |\n|           | 46446173674602635247710, 2988192100784814926760179304 |\n|           | 43930673437544040154080242095928241372331506189835876 |\n|           | 00353687865541878473398230323350346250053154506283266 |\n|           | 0))                                                   |\n|     L     | order of edwards448 in [RFC7748] (i.e., 2^446 - 13818 |\n|           | 06680989511535200738674851542688033669247488217860989 |\n|           | 4547503885).                                          |\n|   PH(x)   | x (i.e., the identity function)                       |\n+-----------+-------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 2: Parameters of Ed448",
      "ja": "表2：Ed448のパラメーター"
    },
    {
      "indent": 3,
      "text": "Ed448ph is the same but with PH being SHAKE256(x, 64) and phflag being 1, i.e., the input is hashed before signing with Ed448 with a hash constant modified.",
      "ja": "Ed448phは同じですが、PHはSHAKE256（x、64）で、phflagは1です。つまり、入力はハッシュ定数を変更してEd448で署名する前にハッシュされます。"
    },
    {
      "indent": 3,
      "text": "Value of context is set by signer and verifier (maximum of 255 octets; the default is empty string) and has to match octet by octet for verification to be successful.",
      "ja": "コンテキストの値は署名者と検証者によって設定され（最大255オクテット、デフォルトは空の文字列）、検証を成功させるにはオクテットごとにオクテットを一致させる必要があります。"
    },
    {
      "indent": 3,
      "text": "The curve is equivalent to Ed448-Goldilocks under change of the basepoint, which preserves difficulty of the discrete logarithm.",
      "ja": "曲線は、基点が変更されたときのEd448-Goldilocksと同等であり、離散対数の難易度が保持されます。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Modular Arithmetic",
      "section_title": true,
      "ja": "5.2.1. モジュラー演算"
    },
    {
      "indent": 3,
      "text": "For advice on how to implement arithmetic modulo p = 2^448 - 2^224 - 1 efficiently and securely, see [ED448]. For inversion modulo p, it is recommended to use the identity x^-1 = x^(p-2) (mod p). Inverting zero should never happen, as it would require invalid input, which would have been detected before, or would be a calculation error.",
      "ja": "p = 2^448 - 2^224 - 1 を法とする演算を効率的かつ安全に実装する方法のアドバイスについては、[ED448] を参照してください。p を法とする逆元については、恒等式 x^-1 = x^(p-2) (mod p) を使用することをお勧めします。ゼロの逆元計算は発生しないはずです。なぜなら、それは無効な入力を必要とし（これは事前に検出されているはずです）、あるいは計算エラーになるからです。"
    },
    {
      "indent": 3,
      "text": "For point decoding or \"decompression\", square roots modulo p are needed. They can be computed by first computing candidate root x = a ^ (p+1)/4 (mod p) and then checking if x^2 = a. If it is, then x is the square root of a; if it isn't, then a does not have a square root.",
      "ja": "点のデコードまたは「解凍」では、p を法とする平方根が必要です。それらは、まず候補となる根 x = a^(p+1)/4 (mod p) を計算し、次に x^2 = a かどうかをチェックすることで計算できます。そうである場合、x は a の平方根です。そうでない場合、a には平方根がありません。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Encoding",
      "section_title": true,
      "ja": "5.2.2. エンコーディング"
    },
    {
      "indent": 3,
      "text": "All values are coded as octet strings, and integers are coded using little-endian convention, i.e., a 57-octet string h h[0],...h[56] represents the integer h[0] + 2^8 * h[1] + ... + 2^448 * h[56].",
      "ja": "すべての値はオクテット文字列としてコード化され、整数はリトルエンディアン規則を使用してコード化されます。つまり、57 オクテット文字列 h h[0],...h[56] は整数 h[0] + 2^8 * h[1] + ... + 2^448 * h[56] を表します。"
    },
    {
      "indent": 3,
      "text": "A curve point (x,y), with coordinates in the range 0 <= x,y < p, is coded as follows. First, encode the y-coordinate as a little-endian string of 57 octets. The final octet is always zero. To form the encoding of the point, copy the least significant bit of the x-coordinate to the most significant bit of the final octet.",
      "ja": "座標が 0 <= x,y < p の範囲にある曲線上の点 (x,y) は、次のようにコード化されます。まず、y 座標を 57 オクテットのリトルエンディアン文字列としてエンコードします。最後のオクテットは常にゼロです。点のエンコーディングを形成するには、x 座標の最下位ビットを最後のオクテットの最上位ビットにコピーします。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Decoding",
      "section_title": true,
      "ja": "5.2.3. 解読"
    },
    {
      "indent": 3,
      "text": "Decoding a point, given as a 57-octet string, is a little more complicated.",
      "ja": "57 オクテットの文字列として与えられる点のデコードは、もう少し複雑です。"
    },
    {
      "indent": 3,
      "text": "1. First, interpret the string as an integer in little-endian representation. Bit 455 of this number is the least significant bit of the x-coordinate, and denote this value x_0. The y-coordinate is recovered simply by clearing this bit. If the resulting value is >= p, decoding fails.",
      "ja": "1. まず、文字列をリトルエンディアン表現の整数として解釈します。この数値のビット 455 は x 座標の最下位ビットであり、この値を x_0 とします。y 座標は、このビットをクリアするだけで復元されます。結果の値が >= p の場合、デコードは失敗します。"
    },
    {
      "indent": 3,
      "text": "2. To recover the x-coordinate, the curve equation implies x^2 = (y^2 - 1) / (d y^2 - 1) (mod p). The denominator is always non-zero mod p. Let u = y^2 - 1 and v = d y^2 - 1. To compute the square root of (u/v), the first step is to compute the candidate root x = (u/v)^((p+1)/4). This can be done using the following trick, to use a single modular powering for both the inversion of v and the square root:",
      "ja": "2. x座標を復元するには、曲線方程式から x^2 = (y^2 - 1) / (d y^2 - 1) (mod p) が成り立ちます。分母は常に mod p で非ゼロです。u = y^2 - 1、v = d y^2 - 1 とします。(u/v) の平方根を計算するには、まず候補となる根 x = (u/v)^((p+1)/4) を計算します。これは、v の逆関数と平方根の両方に単一のモジュラー累乗法を使用するという、次のトリックで行うことができます。"
    },
    {
      "indent": 17,
      "text": "         (p+1)/4    3            (p-3)/4\nx = (u/v)        = u  v (u^5 v^3)         (mod p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3. If v * x^2 = u, the recovered x-coordinate is x. Otherwise, no square root exists, and the decoding fails.",
      "ja": "3. v * x^2 = u の場合、復元された x 座標は x です。そうでない場合、平方根は存在せず、デコードは失敗します。"
    },
    {
      "indent": 3,
      "text": "4. Finally, use the x_0 bit to select the right square root. If x = 0, and x_0 = 1, decoding fails. Otherwise, if x_0 != x mod 2, set x <-- p - x. Return the decoded point (x,y).",
      "ja": "4. 最後に、x_0 ビットを使用して、正しい平方根を選択します。x = 0 かつ x_0 = 1 の場合、デコードは失敗します。それ以外の場合、x_0 != x mod 2 であれば、x <-- p - x と設定します。デコードされた点 (x,y) を返します。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Point Addition",
      "section_title": true,
      "ja": "5.2.4. ポイント加算"
    },
    {
      "indent": 3,
      "text": "For point addition, the following method is recommended. A point (x,y) is represented in projective coordinates (X, Y, Z), with x = X/Z, y = Y/Z.",
      "ja": "点の加算には、次の方法が推奨されます。点 (x,y) は、x = X/Z、y = Y/Z となる射影座標 (X, Y, Z) で表されます。"
    },
    {
      "indent": 3,
      "text": "The neutral point is (0,1), or equivalently in projective coordinates (0, Z, Z) for any non-zero Z.",
      "ja": "中立点は (0,1) です。または、任意の非ゼロ Z に対して、射影座標では (0, Z, Z) と同等です。"
    },
    {
      "indent": 3,
      "text": "The following formulas for adding two points, (x3,y3) = (x1,y1)+(x2,y2) on untwisted Edwards curve (i.e., a=1) with non-square d, are described in Section 4 of [Faster-ECC] and in [EFD-ADD]. They are complete, i.e., they work for any pair of valid input points.",
      "ja": "非平方剰余 d を持つねじれのないエドワーズ曲線（つまり、a=1）上の 2 点の加算 (x3,y3) = (x1,y1)+(x2,y2) のための以下の式は、[Faster-ECC] のセクション 4 および [EFD-ADD] で説明されています。これらは完全です。つまり、有効な入力点の任意のペアに対して機能します。"
    },
    {
      "indent": 17,
      "text": "A = Z1*Z2\nB = A^2\nC = X1*X2\nD = Y1*Y2\nE = d*C*D\nF = B-E\nG = B+E\nH = (X1+Y1)*(X2+Y2)\nX3 = A*F*(H-C-D)\nY3 = A*G*(D-C)\nZ3 = F*G",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Again, similar to the other curve, doubling formulas can be obtained by substituting equal points, turning four multiplications into squares. However, this is not even nearly optimal; the following formulas described in Section 4 of [Faster-ECC] and in [EFD-DBL] save multiple multiplications.",
      "ja": "繰り返しになりますが、他の曲線と同様に、2 倍算の式は、等しい点を代入して 4 つの乗算を 2 乗に変換することで得られます。ただし、これは最適とは程遠いものです。[Faster-ECC] のセクション 4 および [EFD-DBL] で説明されている次の式を使用すると、複数の乗算を節約できます。"
    },
    {
      "indent": 17,
      "text": "B = (X1+Y1)^2\nC = X1^2\nD = Y1^2\nE = C+D\nH = Z1^2\nJ = E-2*H\nX3 = (B-E)*J\nY3 = E*(C-D)\nZ3 = E*J",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2.5. Key Generation",
      "section_title": true,
      "ja": "5.2.5. 鍵の生成"
    },
    {
      "indent": 3,
      "text": "The private key is 57 octets (456 bits, corresponding to b) of cryptographically secure random data. See [RFC4086] for a discussion about randomness.",
      "ja": "秘密鍵は、57 オクテット（456 ビット、b に対応）の暗号論的に安全なランダムデータです。ランダム性についての議論は [RFC4086] を参照してください。"
    },
    {
      "indent": 3,
      "text": "The 57-byte public key is generated by the following steps:",
      "ja": "57バイトの公開鍵は、次の手順で生成されます。"
    },
    {
      "indent": 3,
      "text": "1. Hash the 57-byte private key using SHAKE256(x, 114), storing the digest in a 114-octet large buffer, denoted h. Only the lower 57 bytes are used for generating the public key.",
      "ja": "1. SHAKE256(x, 114) を使用して 57 バイトの秘密鍵をハッシュし、h で示される 114 オクテットの大きなバッファーにダイジェストを格納します。公開鍵の生成には、下位 57 バイトのみが使用されます。"
    },
    {
      "indent": 3,
      "text": "2. Prune the buffer: The two least significant bits of the first octet are cleared, all eight bits the last octet are cleared, and the highest bit of the second to last octet is set.",
      "ja": "2. バッファのプルーニング：最初のオクテットの最下位2ビットがクリアされ、最後のオクテットの8ビットがすべてクリアされ、最後から2番目のオクテットの最上位ビットが設定されます。"
    },
    {
      "indent": 3,
      "text": "3. Interpret the buffer as the little-endian integer, forming a secret scalar s. Perform a known-base-point scalar multiplication [s]B.",
      "ja": "3. バッファーをリトルエンディアン整数として解釈し、秘密のスカラー s を形成します。既知の基点のスカラー倍算 [s]B を実行します。"
    },
    {
      "indent": 3,
      "text": "4. The public key A is the encoding of the point [s]B. First encode the y-coordinate (in the range 0 <= y < p) as a little-endian string of 57 octets. The most significant bit of the final octet is always zero. To form the encoding of the point [s]B, copy the least significant bit of the x coordinate to the most significant bit of the final octet. The result is the public key.",
      "ja": "4. 公開鍵 A は、点 [s]B のエンコーディングです。まず、y 座標（0 <= y < p の範囲）を 57 オクテットのリトルエンディアン文字列としてエンコードします。最後のオクテットの最上位ビットは常にゼロです。点 [s]B のエンコーディングを形成するには、x 座標の最下位ビットを最後のオクテットの最上位ビットにコピーします。結果は公開鍵です。"
    },
    {
      "indent": 0,
      "text": "5.2.6. Sign",
      "section_title": true,
      "ja": "5.2.6. 符号"
    },
    {
      "indent": 3,
      "text": "The inputs to the signing procedure is the private key, a 57-octet string, a flag F, which is 0 for Ed448, 1 for Ed448ph, context C of at most 255 octets, and a message M of arbitrary size.",
      "ja": "署名手順への入力は、秘密鍵（57 オクテット文字列）、Ed448 の場合は 0、Ed448ph の場合は 1 となるフラグ F、最大 255 オクテットのコンテキスト C、および任意のサイズのメッセージ M です。"
    },
    {
      "indent": 3,
      "text": "1. Hash the private key, 57 octets, using SHAKE256(x, 114). Let h denote the resulting digest. Construct the secret scalar s from the first half of the digest, and the corresponding public key A, as described in the previous section. Let prefix denote the second half of the hash digest, h[57],...,h[113].",
      "ja": "1. SHAKE256(x, 114) を使用して、57 オクテットの秘密鍵をハッシュします。結果のダイジェストを h とします。前のセクションで説明したように、ダイジェストの前半から秘密スカラー s と対応する公開鍵 A を作成します。prefix をハッシュダイジェストの後半 h[57],...,h[113] とします。"
    },
    {
      "indent": 3,
      "text": "2. Compute SHAKE256(dom4(F, C) || prefix || PH(M), 114), where M is the message to be signed, F is 1 for Ed448ph, 0 for Ed448, and C is the context to use. Interpret the 114-octet digest as a little-endian integer r.",
      "ja": "2. SHAKE256(dom4(F, C) || prefix || PH(M), 114) を計算します。ここで、M は署名されるメッセージ、F は Ed448ph の場合は 1、Ed448 の場合は 0、C は使用するコンテキストです。114 オクテットのダイジェストをリトルエンディアン整数 r として解釈します。"
    },
    {
      "indent": 3,
      "text": "3. Compute the point [r]B. For efficiency, do this by first reducing r modulo L, the group order of B. Let the string R be the encoding of this point.",
      "ja": "3. 点 [r]B を計算します。効率を上げるために、まず B の群の位数である L を法として r を簡約することでこれを行います。文字列 R をこの点のエンコーディングとします。"
    },
    {
      "indent": 3,
      "text": "4. Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114), and interpret the 114-octet digest as a little-endian integer k.",
      "ja": "4. SHAKE256(dom4(F, C) || R || A || PH(M), 114) を計算し、114 オクテットのダイジェストをリトルエンディアン整数 k として解釈します。"
    },
    {
      "indent": 3,
      "text": "5. Compute S = (r + k * s) mod L. For efficiency, again reduce k modulo L first.",
      "ja": "5. S = (r + k * s) mod L を計算します。効率を上げるために、ここでも L を法として k を最初に簡約します。"
    },
    {
      "indent": 3,
      "text": "6. Form the signature of the concatenation of R (57 octets) and the little-endian encoding of S (57 octets; the ten most significant bits of the final octets are always zero).",
      "ja": "6. R（57 オクテット）と S のリトルエンディアンエンコーディング（57 オクテット。最後のオクテットの最上位 10 ビットは常にゼロ）を連結して署名を形成します。"
    },
    {
      "indent": 0,
      "text": "5.2.7. Verify",
      "section_title": true,
      "ja": "5.2.7. 確認"
    },
    {
      "indent": 3,
      "text": "1. To verify a signature on a message M using context C and public key A, with F being 0 for Ed448 and 1 for Ed448ph, first split the signature into two 57-octet halves. Decode the first half as a point R, and the second half as an integer S, in the range 0 <= s < L. Decode the public key A as point A'. If any of the decodings fail (including S being out of range), the signature is invalid.",
      "ja": "1. コンテキスト C と公開鍵 A を使用してメッセージ M の署名を検証するには（F は Ed448 の場合は 0、Ed448ph の場合は 1）、まず署名を 2 つの 57 オクテットの半分に分割します。前半を点 R として、後半を整数 S として、0 <= s < L の範囲でデコードします。公開鍵 A を点 A' としてデコードします。デコードのいずれかが失敗した場合（S が範囲外であることを含む）、署名は無効です。"
    },
    {
      "indent": 3,
      "text": "2. Compute SHAKE256(dom4(F, C) || R || A || PH(M), 114), and interpret the 114-octet digest as a little-endian integer k.",
      "ja": "2. SHAKE256(dom4(F, C) || R || A || PH(M), 114) を計算し、114 オクテットのダイジェストをリトルエンディアン整数 k として解釈します。"
    },
    {
      "indent": 3,
      "text": "3. Check the group equation [4][S]B = [4]R + [4][k]A'. It's sufficient, but not required, to instead check [S]B = R + [k]A'.",
      "ja": "3. 群の方程式 [4][S]B = [4]R + [4][k]A' を確認します。代わりに [S]B = R + [k]A' を確認するだけでも十分ですが、必須ではありません。"
    },
    {
      "indent": 0,
      "text": "6. Ed25519 Python Illustration",
      "section_title": true,
      "ja": "6. Ed25519 Pythonイラスト"
    },
    {
      "indent": 3,
      "text": "The rest of this section describes how Ed25519 can be implemented in Python (version 3.2 or later) for illustration. See Appendix A for the complete implementation and Appendix B for a test-driver to run it through some test vectors.",
      "ja": "このセクションの残りの部分では、説明のために Python（バージョン 3.2 以降）で Ed25519 を実装する方法について説明します。完全な実装については付録 A を、いくつかのテストベクトルを実行するテストドライバーについては付録 B を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that this code is not intended for production as it is not proven to be correct for all inputs, nor does it protect against side-channel attacks. The purpose is to illustrate the algorithm to help implementers with their own implementation.",
      "ja": "このコードはすべての入力に対して正しいことが証明されておらず、サイドチャネル攻撃から保護されていないため、本番用ではありません。目的は、実装者が独自の実装を行うのを支援するためにアルゴリズムを説明することです。"
    },
    {
      "indent": 0,
      "text": "## First, some preliminaries that will be needed.",
      "ja": "## 最初に、必要になるいくつかの予備知識です。"
    },
    {
      "indent": 0,
      "text": "import hashlib",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def sha512(s):\n    return hashlib.sha512(s).digest()",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "# Base field Z_p\np = 2**255 - 19",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def modp_inv(x):\n    return pow(x, p-2, p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "# Curve constant\nd = -121665 * modp_inv(121666) % p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "# Group order\nq = 2**252 + 27742317777372353535851937790883648493",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def sha512_modq(s):\n    return int.from_bytes(sha512(s), \"little\") % q",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "## Then follows functions to perform point operations.",
      "ja": "## 次に、点演算を実行する関数が続きます。"
    },
    {
      "indent": 0,
      "text": "# Points are represented as tuples (X, Y, Z, T) of extended\n# coordinates, with x = X/Z, y = Y/Z, x*y = T/Z",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def point_add(P, Q):\n    A, B = (P[1]-P[0]) * (Q[1]-Q[0]) % p, (P[1]+P[0]) * (Q[1]+Q[0]) % p;\n    C, D = 2 * P[3] * Q[3] * d % p, 2 * P[2] * Q[2] % p;\n    E, F, G, H = B-A, D-C, D+C, B+A;\n    return (E*F, G*H, F*G, E*H);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "# Computes Q = s * Q\ndef point_mul(s, P):\n    Q = (0, 1, 1, 0)  # Neutral element\n    while s > 0:\n        if s & 1:\n            Q = point_add(Q, P)\n        P = point_add(P, P)\n        s >>= 1\n    return Q",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def point_equal(P, Q):\n    # x1 / z1 == x2 / z2  <==>  x1 * z2 == x2 * z1\n    if (P[0] * Q[2] - Q[0] * P[2]) % p != 0:\n        return False\n    if (P[1] * Q[2] - Q[1] * P[2]) % p != 0:\n        return False\n    return True",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "## Now follows functions for point compression.",
      "ja": "## 次に、点圧縮の関数が続きます。"
    },
    {
      "indent": 0,
      "text": "# Square root of -1\nmodp_sqrt_m1 = pow(2, (p-1) // 4, p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "# Compute corresponding x-coordinate, with low bit corresponding to\n# sign, or return None on failure\ndef recover_x(y, sign):\n    if y >= p:\n        return None\n    x2 = (y*y-1) * modp_inv(d*y*y+1)\n    if x2 == 0:\n        if sign:\n            return None\n        else:\n            return 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "# Compute square root of x2\nx = pow(x2, (p+3) // 8, p)\nif (x*x - x2) % p != 0:\n    x = x * modp_sqrt_m1 % p\nif (x*x - x2) % p != 0:\n    return None",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "if (x & 1) != sign:\n    x = p - x\nreturn x",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "# Base point\ng_y = 4 * modp_inv(5) % p\ng_x = recover_x(g_y, 0)\nG = (g_x, g_y, 1, g_x * g_y % p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def point_compress(P):\n    zinv = modp_inv(P[2])\n    x = P[0] * zinv % p\n    y = P[1] * zinv % p\n    return int.to_bytes(y | ((x & 1) << 255), 32, \"little\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def point_decompress(s):\n    if len(s) != 32:\n        raise Exception(\"Invalid input length for decompression\")\n    y = int.from_bytes(s, \"little\")\n    sign = y >> 255\n    y &= (1 << 255) - 1\n    \n    x = recover_x(y, sign)\n    if x is None:\n        return None\n    else:\n        return (x, y, 1, x*y % p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "## These are functions for manipulating the private key.",
      "ja": "## 秘密鍵を操作するための関数です。"
    },
    {
      "indent": 0,
      "text": "def secret_expand(secret):\n    if len(secret) != 32:\n        raise Exception(\"Bad size of private key\")\n    h = sha512(secret)\n    a = int.from_bytes(h[:32], \"little\")\n    a &= (1 << 254) - 8\n    a |= (1 << 254)\n    return (a, h[32:])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def secret_to_public(secret):\n    (a, dummy) = secret_expand(secret)\n    return point_compress(point_mul(a, G))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "## The signature function works as below.",
      "ja": "## 署名関数は以下のように機能します。"
    },
    {
      "indent": 0,
      "text": "def sign(secret, msg):\n    a, prefix = secret_expand(secret)\n    A = point_compress(point_mul(a, G))\n    r = sha512_modq(prefix + msg)\n    R = point_mul(r, G)\n    Rs = point_compress(R)\n    h = sha512_modq(Rs + A + msg)\n    s = (r + h * a) % q\n    return Rs + int.to_bytes(s, 32, \"little\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "## And finally the verification function.",
      "ja": "## そして最後に検証関数です。"
    },
    {
      "indent": 0,
      "text": "def verify(public, msg, signature):\n    if len(public) != 32:\n        raise Exception(\"Bad public key length\")\n    if len(signature) != 64:\n        Exception(\"Bad signature length\")\n    A = point_decompress(public)\n    if not A:\n        return False\n    Rs = signature[:32]\n    R = point_decompress(Rs)\n    if not R:\n        return False\n    s = int.from_bytes(signature[32:], \"little\")\n    if s >= q: return False\n    h = sha512_modq(Rs + public + msg)\n    sB = point_mul(s, G)\n    hA = point_mul(h, A)\n    return point_equal(sB, point_add(R, hA))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7. Test Vectors",
      "section_title": true,
      "ja": "7. テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section contains test vectors for Ed25519ph, Ed25519ctx, Ed448ph, Ed25519, and Ed448.",
      "ja": "このセクションには、Ed25519ph、Ed25519ctx、Ed448ph、Ed25519、およびEd448のテストベクタが含まれています。"
    },
    {
      "indent": 3,
      "text": "Each section contains a sequence of test vectors. The octets are hex encoded, and whitespace is inserted for readability. Ed25519, Ed25519ctx, and Ed25519ph private and public keys are 32 octets; signatures are 64 octets. Ed448 and Ed448ph private and public keys are 57 octets; signatures are 114 octets. Messages are of arbitrary length. If the context is non-empty, it is given as 1-255 octets.",
      "ja": "各セクションには、一連のテストベクトルが含まれています。オクテットは 16 進数でエンコードされ、読みやすくするために空白が挿入されます。Ed25519、Ed25519ctx、および Ed25519ph の秘密鍵と公開鍵は 32 オクテット、署名は 64 オクテットです。Ed448 および Ed448ph の秘密鍵と公開鍵は 57 オクテット、署名は 114 オクテットです。メッセージは任意の長さです。コンテキストが空でない場合、1〜255 オクテットとして指定されます。"
    },
    {
      "indent": 0,
      "text": "7.1. Test Vectors for Ed25519",
      "section_title": true,
      "ja": "7.1. Ed25519のテストベクトル"
    },
    {
      "indent": 3,
      "text": "These test vectors are taken from [ED25519-TEST-VECTORS] (but we removed the public key as a suffix of the private key and removed the message from the signature) and [ED25519-LIBGCRYPT-TEST-VECTORS].",
      "ja": "これらのテストベクトルは [ED25519-TEST-VECTORS]（ただし、秘密鍵のサフィックスとしての公開鍵を削除し、署名からメッセージを削除しました）および [ED25519-LIBGCRYPT-TEST-VECTORS] から取得したものです。"
    },
    {
      "indent": 3,
      "text": "-----TEST 1\n\nALGORITHM:\nEd25519\n\nSECRET KEY:\n9d61b19deffd5a60ba844af492ec2cc4\n4449c5697b326919703bac031cae7f60\n\nPUBLIC KEY:\nd75a980182b10ab7d54bfed3c964073a\n0ee172f3daa62325af021a68f707511a\n\nMESSAGE (length 0 bytes):\n\nSIGNATURE:\ne5564300c360ac729086e2cc806e828a\n84877f1eb8e5d974d873e06522490155\n5fb8821590a33bacc61e39701cf9b46b\nd25bf5f0595bbe24655141438e7a100b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----TEST 2\n\nALGORITHM:\nEd25519\n\nSECRET KEY:\n4ccd089b28ff96da9db6c346ec114e0f\n5b8a319f35aba624da8cf6ed4fb8a6fb\n\nPUBLIC KEY:\n3d4017c3e843895a92b70aa74d1b7ebc\n9c982ccf2ec4968cc0cd55f12af4660c\n\nMESSAGE (length 1 byte):\n72\n\nSIGNATURE:\n92a009a9f0d4cab8720e820b5f642540\na2b27b5416503f8fb3762223ebdb69da\n085ac1e43e15996e458f3613d0f11d8c\n387b2eaeb4302aeeb00d291612bb0c00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----TEST 3\n\nALGORITHM:\nEd25519\n\nSECRET KEY:\nc5aa8df43f9f837bedb7442f31dcb7b1\n66d38535076f094b85ce3a2e0b4458f7\n\nPUBLIC KEY:\nfc51cd8e6218a1a38da47ed00230f058\n0816ed13ba3303ac5deb911548908025\n\nMESSAGE (length 2 bytes):\naf82\n\nSIGNATURE:\n6291d657deec24024827e69c3abe01a3\n0ce548a284743a445e3680d7db5ac3ac\n18ff9b538d16f290ae67f760984dc659\n4a7c15e9716ed28dc027beceea1ec40a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----TEST 1024\n\nALGORITHM:\nEd25519\n\nSECRET KEY:\nf5e5767cf153319517630f226876b86c\n8160cc583bc013744c6bf255f5cc0ee5\n\nPUBLIC KEY:\n278117fc144c72340f67d0f2316e8386\nceffbf2b2428c9c51fef7c597f1d426e\n\nMESSAGE (length 1023 bytes):\n08b8b2b733424243760fe426a4b54908\n632110a66c2f6591eabd3345e3e4eb98\nfa6e264bf09efe12ee50f8f54e9f77b1\ne355f6c50544e23fb1433ddf73be84d8\n79de7c0046dc4996d9e773f4bc9efe57\n38829adb26c81b37c93a1b270b20329d\n658675fc6ea534e0810a4432826bf58c\n941efb65d57a338bbd2e26640f89ffbc\n1a858efcb8550ee3a5e1998bd177e93a\n7363c344fe6b199ee5d02e82d522c4fe\nba15452f80288a821a579116ec6dad2b\n3b310da903401aa62100ab5d1a36553e\n06203b33890cc9b832f79ef80560ccb9\na39ce767967ed628c6ad573cb116dbef\nefd75499da96bd68a8a97b928a8bbc10\n3b6621fcde2beca1231d206be6cd9ec7\naff6f6c94fcd7204ed3455c68c83f4a4\n1da4af2b74ef5c53f1d8ac70bdcb7ed1\n85ce81bd84359d44254d95629e9855a9\n4a7c1958d1f8ada5d0532ed8a5aa3fb2\nd17ba70eb6248e594e1a2297acbbb39d\n502f1a8c6eb6f1ce22b3de1a1f40cc24\n554119a831a9aad6079cad88425de6bd\ne1a9187ebb6092cf67bf2b13fd65f270\n88d78b7e883c8759d2c4f5c65adb7553\n878ad575f9fad878e80a0c9ba63bcbcc\n2732e69485bbc9c90bfbd62481d9089b\neccf80cfe2df16a2cf65bd92dd597b07\n07e0917af48bbb75fed413d238f5555a\n7a569d80c3414a8d0859dc65a46128ba\nb27af87a71314f318c782b23ebfe808b\n82b0ce26401d2e22f04d83d1255dc51a\nddd3b75a2b1ae0784504df543af8969b\ne3ea7082ff7fc9888c144da2af58429e\nc96031dbcad3dad9af0dcbaaaf268cb8\nfcffead94f3c7ca495e056a9b47acdb7\n51fb73e666c6c655ade8297297d07ad1\nba5e43f1bca32301651339e22904cc8c\n42f58c30c04aafdb038dda0847dd988d\ncda6f3bfd15c4b4c4525004aa06eeff8\nca61783aacec57fb3d1f92b0fe2fd1a8\n5f6724517b65e614ad6808d6f6ee34df\nf7310fdc82aebfd904b01e1dc54b2927\n094b2db68d6f903b68401adebf5a7e08\nd78ff4ef5d63653a65040cf9bfd4aca7\n984a74d37145986780fc0b16ac451649\nde6188a7dbdf191f64b5fc5e2ab47b57\nf7f7276cd419c17a3ca8e1b939ae49e4\n88acba6b965610b5480109c8b17b80e1\nb7b750dfc7598d5d5011fd2dcc5600a3\n2ef5b52a1ecc820e308aa342721aac09\n43bf6686b64b2579376504ccc493d97e\n6aed3fb0f9cd71a43dd497f01f17c0e2\ncb3797aa2a2f256656168e6c496afc5f\nb93246f6b1116398a346f1a641f3b041\ne989f7914f90cc2c7fff357876e506b5\n0d334ba77c225bc307ba537152f3f161\n0e4eafe595f6d9d90d11faa933a15ef1\n369546868a7f3a45a96768d40fd9d034\n12c091c6315cf4fde7cb68606937380d\nb2eaaa707b4c4185c32eddcdd306705e\n4dc1ffc872eeee475a64dfac86aba41c\n0618983f8741c5ef68d3a101e8a3b8ca\nc60c905c15fc910840b94c00a0b9d0\n\nSIGNATURE:\n0aab4c900501b3e24d7cdf4663326a3a\n87df5e4843b2cbdb67cbf6e460fec350\naa5371b1508f9f4528ecea23c436d94b\n5e8fcd4f681e30a6ac00a9704a188a03",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----TEST SHA(abc)\n\nALGORITHM:\nEd25519\n\nSECRET KEY:\n833fe62409237b9d62ec77587520911e\n9a759cec1d19755b7da901b96dca3d42\n\nPUBLIC KEY:\nec172b93ad5e563bf4932c70e1245034\nc35467ef2efd4d64ebf819683467e2bf\n\nMESSAGE (length 64 bytes):\nddaf35a193617abacc417349ae204131\n12e6fa4e89a97ea20a9eeee64b55d39a\n2192992a274fc1a836ba3c23a3feebbd\n454d4423643ce80e2a9ac94fa54ca49f\n\nSIGNATURE:\ndc2a4459e7369633a52b1bf277839a00\n201009a3efbf3ecb69bea2186c26b589\n09351fc9ac90b3ecfdfbc7c66431e030\n3dca179c138ac17ad9bef1177331a704\n-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2. Test Vectors for Ed25519ctx",
      "section_title": true,
      "ja": "7.2. Ed25519ctxのテストベクトル"
    },
    {
      "indent": 3,
      "text": "-----foo\n\nALGORITHM:\nEd25519ctx\n\nSECRET KEY:\n0305334e381af78f141cb666f6199f57\nbc3495335a256a95bd2a55bf546663f6\n\nPUBLIC KEY:\ndfc9425e4f968f7f0c29f0259cf5f9ae\nd6851c2bb4ad8bfb860cfee0ab248292\n\nMESSAGE (length 16 bytes):\nf726936d19c800494e3fdaff20b276a8\n\nCONTEXT:\n666f6f\n\nSIGNATURE:\n55a4cc2f70a54e04288c5f4cd1e45a7b\nb520b36292911876cada7323198dd87a\n8b36950b95130022907a7fb7c4e9b2d5\nf6cca685a587b4b21f4b888e4e7edb0d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----bar\n\nALGORITHM:\nEd25519ctx\n\nSECRET KEY:\n0305334e381af78f141cb666f6199f57\nbc3495335a256a95bd2a55bf546663f6\n\nPUBLIC KEY:\ndfc9425e4f968f7f0c29f0259cf5f9ae\nd6851c2bb4ad8bfb860cfee0ab248292\n\nMESSAGE (length 16 bytes):\nf726936d19c800494e3fdaff20b276a8\n\nCONTEXT:\n626172\n\nSIGNATURE:\nfc60d5872fc46b3aa69f8b5b4351d580\n8f92bcc044606db097abab6dbcb1aee3\n216c48e8b3b66431b5b186d1d28f8ee1\n5a5ca2df6668346291c2043d4eb3e90d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----foo2\n\nALGORITHM:\nEd25519ctx\n\nSECRET KEY:\n0305334e381af78f141cb666f6199f57\nbc3495335a256a95bd2a55bf546663f6\n\nPUBLIC KEY:\ndfc9425e4f968f7f0c29f0259cf5f9ae\nd6851c2bb4ad8bfb860cfee0ab248292\n\nMESSAGE (length 16 bytes):\n508e9e6882b979fea900f62adceaca35\n\nCONTEXT:\n666f6f\n\nSIGNATURE:\n8b70c1cc8310e1de20ac53ce28ae6e72\n07f33c3295e03bb5c0732a1d20dc6490\n8922a8b052cf99b7c4fe107a5abb5b2c\n4085ae75890d02df26269d8945f84b0b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----foo3\n\nALGORITHM:\nEd25519ctx\n\nSECRET KEY:\nab9c2853ce297ddab85c993b3ae14bca\nd39b2c682beabc27d6d4eb20711d6560\n\nPUBLIC KEY:\n0f1d1274943b91415889152e893d80e9\n3275a1fc0b65fd71b4b0dda10ad7d772\n\nMESSAGE (length 16 bytes):\nf726936d19c800494e3fdaff20b276a8\n\nCONTEXT:\n666f6f\n\nSIGNATURE:\n21655b5f1aa965996b3f97b3c849eafb\na922a0a62992f73b3d1b73106a84ad85\ne9b86a7b6005ea868337ff2d20a7f5fb\nd4cd10b0be49a68da2b2e0dc0ad8960f\n-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.3. Test Vectors for Ed25519ph",
      "section_title": true,
      "ja": "7.3. Ed25519phのテストベクトル"
    },
    {
      "indent": 3,
      "text": "-----TEST abc\n\nALGORITHM:\nEd25519ph\n\nSECRET KEY:\n833fe62409237b9d62ec77587520911e\n9a759cec1d19755b7da901b96dca3d42\n\nPUBLIC KEY:\nec172b93ad5e563bf4932c70e1245034\nc35467ef2efd4d64ebf819683467e2bf\n\nMESSAGE (length 3 bytes):\n616263\n\nSIGNATURE:\n98a70222f0b8121aa9d30f813d683f80\n9e462b469c7ff87639499bb94e6dae41\n31f85042463c2a355a2003d062adf5aa\na10b8c61e636062aaad11c2a26083406\n-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4. Test Vectors for Ed448",
      "section_title": true,
      "ja": "7.4. Ed448のテストベクトル"
    },
    {
      "indent": 3,
      "text": "-----Blank\n\nALGORITHM:\nEd448\n\nSECRET KEY:\n6c82a562cb808d10d632be89c8513ebf\n6c929f34ddfa8c9f63c9960ef6e348a3\n528c8a3fcc2f044e39a3fc5b94492f8f\n032e7549a20098f95b\n\nPUBLIC KEY:\n5fd7449b59b461fd2ce787ec616ad46a\n1da1342485a70e1f8a0ea75d80e96778\nedf124769b46c7061bd6783df1e50f6c\nd1fa1abeafe8256180\n\nMESSAGE (length 0 bytes):\n\nSIGNATURE:\n533a37f6bbe457251f023c0d88f976ae\n2dfb504a843e34d2074fd823d41a591f\n2b233f034f628281f2fd7a22ddd47d78\n28c59bd0a21bfd3980ff0d2028d4b18a\n9df63e006c5d1c2d345b925d8dc00b41\n04852db99ac5c7cdda8530a113a0f4db\nb61149f05a7363268c71d95808ff2e65\n2600",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----1 octet\n\nALGORITHM:\nEd448\n\nSECRET KEY:\nc4eab05d357007c632f3dbb48489924d\n552b08fe0c353a0d4a1f00acda2c463a\nfbea67c5e8d2877c5e3bc397a659949e\nf8021e954e0a12274e\n\nPUBLIC KEY:\n43ba28f430cdff456ae531545f7ecd0a\nc834a55d9358c0372bfa0c6c6798c086\n6aea01eb00742802b8438ea4cb82169c\n235160627b4c3a9480\n\nMESSAGE (length 1 byte):\n03\n\nSIGNATURE:\n26b8f91727bd62897af15e41eb43c377\nefb9c610d48f2335cb0bd0087810f435\n2541b143c4b981b7e18f62de8ccdf633\nfc1bf037ab7cd779805e0dbcc0aae1cb\ncee1afb2e027df36bc04dcecbf154336\nc19f0af7e0a6472905e799f1953d2a0f\nf3348ab21aa4adafd1d234441cf807c0\n3a00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----1 octet (with context)\n\nALGORITHM:\nEd448\n\nSECRET KEY:\nc4eab05d357007c632f3dbb48489924d\n552b08fe0c353a0d4a1f00acda2c463a\nfbea67c5e8d2877c5e3bc397a659949e\nf8021e954e0a12274e\n\nPUBLIC KEY:\n43ba28f430cdff456ae531545f7ecd0a\nc834a55d9358c0372bfa0c6c6798c086\n6aea01eb00742802b8438ea4cb82169c\n235160627b4c3a9480\n\nMESSAGE (length 1 byte):\n03\n\nCONTEXT:\n666f6f\n\nSIGNATURE:\nd4f8f6131770dd46f40867d6fd5d5055\nde43541f8c5e35abbcd001b32a89f7d2\n151f7647f11d8ca2ae279fb842d60721\n7fce6e042f6815ea000c85741de5c8da\n1144a6a1aba7f96de42505d7a7298524\nfda538fccbbb754f578c1cad10d54d0d\n5428407e85dcbc98a49155c13764e66c\n3c00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----11 octets\n\nALGORITHM:\nEd448\n\nSECRET KEY:\ncd23d24f714274e744343237b93290f5\n11f6425f98e64459ff203e8985083ffd\nf60500553abc0e05cd02184bdb89c4cc\nd67e187951267eb328\n\nPUBLIC KEY:\ndcea9e78f35a1bf3499a831b10b86c90\naac01cd84b67a0109b55a36e9328b1e3\n65fce161d71ce7131a543ea4cb5f7e9f\n1d8b00696447001400\n\nMESSAGE (length 11 bytes):\n0c3e544074ec63b0265e0c\n\nSIGNATURE:\n1f0a8888ce25e8d458a21130879b840a\n9089d999aaba039eaf3e3afa090a09d3\n89dba82c4ff2ae8ac5cdfb7c55e94d5d\n961a29fe0109941e00b8dbdeea6d3b05\n1068df7254c0cdc129cbe62db2dc957d\nbb47b51fd3f213fb8698f064774250a5\n028961c9bf8ffd973fe5d5c206492b14\n0e00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----12 octets\n\nALGORITHM:\nEd448\n\nSECRET KEY:\n258cdd4ada32ed9c9ff54e63756ae582\nfb8fab2ac721f2c8e676a72768513d93\n9f63dddb55609133f29adf86ec9929dc\ncb52c1c5fd2ff7e21b\n\nPUBLIC KEY:\n3ba16da0c6f2cc1f30187740756f5e79\n8d6bc5fc015d7c63cc9510ee3fd44adc\n24d8e968b6e46e6f94d19b945361726b\nd75e149ef09817f580\n\nMESSAGE (length 12 bytes):\n64a65f3cdedcdd66811e2915\n\nSIGNATURE:\n7eeeab7c4e50fb799b418ee5e3197ff6\nbf15d43a14c34389b59dd1a7b1b85b4a\ne90438aca634bea45e3a2695f1270f07\nfdcdf7c62b8efeaf00b45c2c96ba457e\nb1a8bf075a3db28e5c24f6b923ed4ad7\n47c3c9e03c7079efb87cb110d3a99861\ne72003cbae6d6b8b827e4e6c143064ff\n3c00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----13 octets\n\nALGORITHM:\nEd448\n\nSECRET KEY:\n7ef4e84544236752fbb56b8f31a23a10\ne42814f5f55ca037cdcc11c64c9a3b29\n49c1bb60700314611732a6c2fea98eeb\nc0266a11a93970100e\n\nPUBLIC KEY:\nb3da079b0aa493a5772029f0467baebe\ne5a8112d9d3a22532361da294f7bb381\n5c5dc59e176b4d9f381ca0938e13c6c0\n7b174be65dfa578e80\n\nMESSAGE (length 13 bytes):\n64a65f3cdedcdd66811e2915e7\n\nSIGNATURE:\n6a12066f55331b6c22acd5d5bfc5d712\n28fbda80ae8dec26bdd306743c5027cb\n4890810c162c027468675ecf645a8317\n6c0d7323a2ccde2d80efe5a1268e8aca\n1d6fbc194d3f77c44986eb4ab4177919\nad8bec33eb47bbb5fc6e28196fd1caf5\n6b4e7e0ba5519234d047155ac727a105\n3100",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----64 octets\n\nALGORITHM:\nEd448\n\nSECRET KEY:\nd65df341ad13e008567688baedda8e9d\ncdc17dc024974ea5b4227b6530e339bf\nf21f99e68ca6968f3cca6dfe0fb9f4fa\nb4fa135d5542ea3f01\n\nPUBLIC KEY:\ndf9705f58edbab802c7f8363cfe5560a\nb1c6132c20a9f1dd163483a26f8ac53a\n39d6808bf4a1dfbd261b099bb03b3fb5\n0906cb28bd8a081f00\n\nMESSAGE (length 64 bytes):\nbd0f6a3747cd561bdddf4640a332461a\n4a30a12a434cd0bf40d766d9c6d458e5\n512204a30c17d1f50b5079631f64eb31\n12182da3005835461113718d1a5ef944\n\nSIGNATURE:\n554bc2480860b49eab8532d2a533b7d5\n78ef473eeb58c98bb2d0e1ce488a98b1\n8dfde9b9b90775e67f47d4a1c3482058\nefc9f40d2ca033a0801b63d45b3b722e\nf552bad3b4ccb667da350192b61c508c\nf7b6b5adadc2c8d9a446ef003fb05cba\n5f30e88e36ec2703b349ca229c267083\n3900",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----256 octets\n\nALGORITHM:\nEd448\n\nSECRET KEY:\n2ec5fe3c17045abdb136a5e6a913e32a\nb75ae68b53d2fc149b77e504132d3756\n9b7e766ba74a19bd6162343a21c8590a\na9cebca9014c636df5\n\nPUBLIC KEY:\n79756f014dcfe2079f5dd9e718be4171\ne2ef2486a08f25186f6bff43a9936b9b\nfe12402b08ae65798a3d81e22e9ec80e\n7690862ef3d4ed3a00\n\nMESSAGE (length 256 bytes):\n15777532b0bdd0d1389f636c5f6b9ba7\n34c90af572877e2d272dd078aa1e567c\nfa80e12928bb542330e8409f31745041\n07ecd5efac61ae7504dabe2a602ede89\ne5cca6257a7c77e27a702b3ae39fc769\nfc54f2395ae6a1178cab4738e543072f\nc1c177fe71e92e25bf03e4ecb72f47b6\n4d0465aaea4c7fad372536c8ba516a60\n39c3c2a39f0e4d832be432dfa9a706a6\ne5c7e19f397964ca4258002f7c0541b5\n90316dbc5622b6b2a6fe7a4abffd9610\n5eca76ea7b98816af0748c10df048ce0\n12d901015a51f189f3888145c03650aa\n23ce894c3bd889e030d565071c59f409\na9981b51878fd6fc110624dcbcde0bf7\na69ccce38fabdf86f3bef6044819de11\n\nSIGNATURE:\nc650ddbb0601c19ca11439e1640dd931\nf43c518ea5bea70d3dcde5f4191fe53f\n00cf966546b72bcc7d58be2b9badef28\n743954e3a44a23f880e8d4f1cfce2d7a\n61452d26da05896f0a50da66a239a8a1\n88b6d825b3305ad77b73fbac0836ecc6\n0987fd08527c1a8e80d5823e65cafe2a\n3d00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----1023 octets\n\nALGORITHM:\nEd448\n\nSECRET KEY:\n872d093780f5d3730df7c212664b37b8\na0f24f56810daa8382cd4fa3f77634ec\n44dc54f1c2ed9bea86fafb7632d8be19\n9ea165f5ad55dd9ce8\n\nPUBLIC KEY:\na81b2e8a70a5ac94ffdbcc9badfc3feb\n0801f258578bb114ad44ece1ec0e799d\na08effb81c5d685c0c56f64eecaef8cd\nf11cc38737838cf400",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   MESSAGE (length 1023 bytes):\n   6ddf802e1aae4986935f7f981ba3f035\n   1d6273c0a0c22c9c0e8339168e675412\n   a3debfaf435ed651558007db4384b650\n   fcc07e3b586a27a4f7a00ac8a6fec2cd\n   86ae4bf1570c41e6a40c931db27b2faa\n   15a8cedd52cff7362c4e6e23daec0fbc\n   3a79b6806e316efcc7b68119bf46bc76\n   a26067a53f296dafdbdc11c77f7777e9\n   72660cf4b6a9b369a6665f02e0cc9b6e\n   dfad136b4fabe723d2813db3136cfde9\n   b6d044322fee2947952e031b73ab5c60\n   3349b307bdc27bc6cb8b8bbd7bd32321\n   9b8033a581b59eadebb09b3c4f3d2277\n   d4f0343624acc817804728b25ab79717\n   2b4c5c21a22f9c7839d64300232eb66e\n   53f31c723fa37fe387c7d3e50bdf9813\n   a30e5bb12cf4cd930c40cfb4e1fc6225\n   92a49588794494d56d24ea4b40c89fc0\n   596cc9ebb961c8cb10adde976a5d602b\n   1c3f85b9b9a001ed3c6a4d3b1437f520\n   96cd1956d042a597d561a596ecd3d173\n   5a8d570ea0ec27225a2c4aaff26306d1\n   526c1af3ca6d9cf5a2c98f47e1c46db9\n   a33234cfd4d81f2c98538a09ebe76998\n   d0d8fd25997c7d255c6d66ece6fa56f1\n   1144950f027795e653008f4bd7ca2dee\n   85d8e90f3dc315130ce2a00375a318c7\n   c3d97be2c8ce5b6db41a6254ff264fa6\n   155baee3b0773c0f497c573f19bb4f42\n   40281f0b1f4f7be857a4e59d416c06b4\n   c50fa09e1810ddc6b1467baeac5a3668\n   d11b6ecaa901440016f389f80acc4db9\n   77025e7f5924388c7e340a732e554440\n   e76570f8dd71b7d640b3450d1fd5f041\n   0a18f9a3494f707c717b79b4bf75c984\n   00b096b21653b5d217cf3565c9597456\n   f70703497a078763829bc01bb1cbc8fa\n   04eadc9a6e3f6699587a9e75c94e5bab\n   0036e0b2e711392cff0047d0d6b05bd2\n   a588bc109718954259f1d86678a579a3\n   120f19cfb2963f177aeb70f2d4844826\n   262e51b80271272068ef5b3856fa8535\n   aa2a88b2d41f2a0e2fda7624c2850272\n   ac4a2f561f8f2f7a318bfd5caf969614\n   9e4ac824ad3460538fdc25421beec2cc\n   6818162d06bbed0c40a387192349db67\n   a118bada6cd5ab0140ee273204f628aa\n   d1c135f770279a651e24d8c14d75a605\n   9d76b96a6fd857def5e0b354b27ab937\n   a5815d16b5fae407ff18222c6d1ed263\n   be68c95f32d908bd895cd76207ae7264\n   87567f9a67dad79abec316f683b17f2d\n   02bf07e0ac8b5bc6162cf94697b3c27c\n   d1fea49b27f23ba2901871962506520c\n   392da8b6ad0d99f7013fbc06c2c17a56\n   9500c8a7696481c1cd33e9b14e40b82e\n   79a5f5db82571ba97bae3ad3e0479515\n   bb0e2b0f3bfcd1fd33034efc6245eddd\n   7ee2086ddae2600d8ca73e214e8c2b0b\n   db2b047c6a464a562ed77b73d2d841c4\n   b34973551257713b753632efba348169\n   abc90a68f42611a40126d7cb21b58695\n   568186f7e569d2ff0f9e745d0487dd2e\n   b997cafc5abf9dd102e62ff66cba87\n\n   SIGNATURE:\n   e301345a41a39a4d72fff8df69c98075\n   a0cc082b802fc9b2b6bc503f926b65bd\n   df7f4c8f1cb49f6396afc8a70abe6d8a\n   ef0db478d4c6b2970076c6a0484fe76d\n   76b3a97625d79f1ce240e7c576750d29\n   5528286f719b413de9ada3e8eb78ed57\n   3603ce30d8bb761785dc30dbc320869e\n   1a00\n   -----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----TEST abc\n\nALGORITHM:\nEd448ph\n\nSECRET KEY:\n833fe62409237b9d62ec77587520911e\n9a759cec1d19755b7da901b96dca3d42\nef7822e0d5104127dc05d6dbefde69e3\nab2cec7c867c6e2c49\n\nPUBLIC KEY:\n259b71c19f83ef77a7abd26524cbdb31\n61b590a48f7d17de3ee0ba9c52beb743\nc09428a131d6b1b57303d90d8132c276\nd5ed3d5d01c0f53880\n\nMESSAGE (length 3 bytes):\n616263\n\nSIGNATURE:\n822f6901f7480f3d5f562c592994d969\n3602875614483256505600bbc281ae38\n1f54d6bce2ea911574932f52a4e6cadd\n78769375ec3ffd1b801a0d9b3f4030cd\n433964b6457ea39476511214f97469b5\n7dd32dbc560a9a94d00bff07620464a3\nad203df7dc7ce360c3cd3696d9d9fab9\n0f00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----TEST abc (with context)\n\nALGORITHM:\nEd448ph\n\nSECRET KEY:\n833fe62409237b9d62ec77587520911e\n9a759cec1d19755b7da901b96dca3d42\nef7822e0d5104127dc05d6dbefde69e3\nab2cec7c867c6e2c49\n\nPUBLIC KEY:\n259b71c19f83ef77a7abd26524cbdb31\n61b590a48f7d17de3ee0ba9c52beb743\nc09428a131d6b1b57303d90d8132c276\nd5ed3d5d01c0f53880\n\nMESSAGE (length 3 bytes):\n616263\n\nCONTEXT:\n666f6f\n\nSIGNATURE:\nc32299d46ec8ff02b54540982814dce9\na05812f81962b649d528095916a2aa48\n1065b1580423ef927ecf0af5888f90da\n0f6a9a85ad5dc3f280d91224ba9911a3\n653d00e484e2ce232521481c8658df30\n4bb7745a73514cdb9bf3e15784ab7128\n4f8d0704a608c54a6b62d97beb511d13\n2100\n-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Side-Channel Leaks",
      "section_title": true,
      "ja": "8.1. サイドチャネルリーク"
    },
    {
      "indent": 3,
      "text": "For implementations performing signatures, secrecy of the private key is fundamental. It is possible to protect against some side-channel attacks by ensuring that the implementation executes exactly the same sequence of instructions and performs exactly the same memory accesses, for any value of the private key.",
      "ja": "署名を実行する実装にとって、秘密鍵の機密性は基本です。秘密鍵の任意の値に対して、実装がまったく同じ命令シーケンスを実行し、まったく同じメモリアクセスを実行することを保証することで、一部のサイドチャネル攻撃から保護することが可能です。"
    },
    {
      "indent": 3,
      "text": "To make an implementation side-channel silent in this way, the modulo p arithmetic must not use any data-dependent branches, e.g., related to carry propagation. Side-channel silent point addition is straightforward, thanks to the unified formulas.",
      "ja": "この方法で実装をサイドチャネルに対してサイレントにするには、p を法とする演算で、たとえばキャリー伝播に関連するデータ依存の分岐を使用してはなりません。統一された式のおかげで、サイドチャネルに対してサイレントな点の加算は簡単です。"
    },
    {
      "indent": 3,
      "text": "Scalar multiplication, multiplying a point by an integer, needs some additional effort to implement in a side-channel silent manner. One simple approach is to implement a side-channel silent conditional assignment, and use it together with the binary algorithm to examine one bit of the integer at a time.",
      "ja": "点を整数で乗算するスカラー倍算は、サイドチャネルに対してサイレントな方法で実装するために追加の作業が必要です。簡単なアプローチの 1 つは、サイドチャネルに対してサイレントな条件付き代入を実装し、それをバイナリアルゴリズムと共に使用して、整数の 1 ビットを一度に調べることです。"
    },
    {
      "indent": 3,
      "text": "Compared to other signature schemes, avoiding data-dependent branches is easier due to side-channel silent modulo p arithmetic being easier (with recommended curves) and having complete addition formulas instead of having a number of special cases.",
      "ja": "他の署名方式と比較して、サイドチャネルに対してサイレントなモジュロ p 演算が（推奨曲線を使用して）容易であり、多数の特殊なケースの代わりに完全な加算式があるため、データ依存の分岐を回避することがより容易になります。"
    },
    {
      "indent": 3,
      "text": "Note that the example implementations in this document do not attempt to be side-channel silent.",
      "ja": "このドキュメントの実装例は、サイドチャネルに対してサイレントであることを意図していないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "8.2. Randomness Considerations",
      "section_title": true,
      "ja": "8.2. ランダム性に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "EdDSA signatures are deterministic. This protects against attacks arising from signing with bad randomness; the effects of which can, depending on the algorithm, range up to full private key compromise. It can be surprisingly hard to ensure good-quality random numbers, and there have been numerous security failures relating to this.",
      "ja": "EdDSA 署名は決定的です。これにより、不適切なランダム性による署名に起因する攻撃から保護されます。その影響は、アルゴリズムによっては、完全な秘密鍵の漏洩にまで及ぶ可能性があります。高品質の乱数を保証することは驚くほど難しい場合があり、これに関連して多くのセキュリティ障害が発生しています。"
    },
    {
      "indent": 3,
      "text": "Obviously, private key generation requires randomness, but due to the fact that the private key is hashed before use, a few missing bits of entropy doesn't constitute a disaster.",
      "ja": "明らかに、秘密鍵の生成にはランダム性が必要ですが、秘密鍵は使用前にハッシュされるため、エントロピーが数ビット欠落していても致命的な問題にはなりません。"
    },
    {
      "indent": 3,
      "text": "The basic signature verification is also deterministic. However, some speedups by verifying multiple signatures at once do require random numbers.",
      "ja": "基本的な署名の検証も決定的です。ただし、一度に複数の署名を検証することによる高速化には、乱数が必要です。"
    },
    {
      "indent": 0,
      "text": "8.3. Use of Contexts",
      "section_title": true,
      "ja": "8.3. Use of Contexts"
    },
    {
      "indent": 3,
      "text": "Contexts can be used to separate uses of the protocol between different protocols (which is very hard to reliably do otherwise) and between different uses within the same protocol. However, the following SHOULD be kept in mind when using this facility:",
      "ja": "コンテキストを使用して、プロトコルの使用を異なるプロトコル間（他の方法で確実に行うのは非常に難しい）と、同じプロトコル内の異なる使用間で分離できます。ただし、この機能を使用するときは、次のことに注意してください。"
    },
    {
      "indent": 6,
      "text": "The context SHOULD be a constant string specified by the protocol using it. It SHOULD NOT incorporate variable elements from the message itself.",
      "ja": "コンテキストは、それを使用するプロトコルで指定された定数文字列である必要があります（SHOULD）。メッセージ自体からの可変要素を組み込むべきではありません。"
    },
    {
      "indent": 6,
      "text": "Contexts SHOULD NOT be used opportunistically, as that kind of use is very error prone. If contexts are used, one SHOULD require all signature schemes available for use in that purpose support contexts.",
      "ja": "そのような使用は非常にエラーが発生しやすいため、コンテキストは日和見的に使用すべきではありません。コンテキストを使用する場合は、その目的で使用可能なすべての署名方式がコンテキストをサポートすることを要求すべきです。"
    },
    {
      "indent": 6,
      "text": "Contexts are an extra input, which percolate out of APIs; as such, even if the signature scheme supports contexts, those may not be available for use. This problem is compounded by the fact that many times the application is not invoking the signing and verification functions directly but via some other protocol.",
      "ja": "コンテキストは追加の入力であり、APIから浸透します。そのため、署名スキームがコンテキストをサポートしていても、それらは使用できない場合があります。この問題は、多くの場合、アプリケーションが署名および検証機能を直接呼び出すのではなく、他のプロトコルを介して呼び出すという事実によってさらに悪化します。"
    },
    {
      "indent": 0,
      "text": "8.4. Signature Malleability",
      "section_title": true,
      "ja": "8.4. Signature Malleability"
    },
    {
      "indent": 3,
      "text": "Some systems assume signatures are not malleable: that is, given a valid signature for some message under some key, the attacker can't produce another valid signature for the same message and key.",
      "ja": "一部のシステムでは、署名は順応性がないと見なされます。つまり、あるキーの下にあるメッセージの有効な署名がある場合、攻撃者は同じメッセージとキーに別の有効な署名を作成できません。"
    },
    {
      "indent": 3,
      "text": "Ed25519 and Ed448 signatures are not malleable due to the verification check that decoded S is smaller than l. Without this check, one can add a multiple of l into a scalar part and still pass signature verification, resulting in malleable signatures.",
      "ja": "Ed25519とEd448の署名は、デコードされたSがlより小さいことの検証チェックのため、展性がありません。このチェックがなければ、lの倍数をスカラー部分に追加しても、署名の検証に合格し、その結果、展性のある署名になります。"
    },
    {
      "indent": 0,
      "text": "8.5. Choice of Signature Primitive",
      "section_title": true,
      "ja": "8.5. 署名プリミティブの選択"
    },
    {
      "indent": 3,
      "text": "Ed25519 and Ed25519ph have a nominal strength of 128 bits, whereas Ed448 and Ed448ph have the strength of 224. While the lower strength is sufficient for the foreseeable future, the higher level brings some defense against possible future cryptographic advances. Both are demolished by quantum computers just about the same.",
      "ja": "Ed25519とEd25519phの公称強度は128ビットですが、Ed448とEd448phの強度は224ビットです。低い方の強度でも予測可能な将来には十分ですが、高い方のレベルは、将来の暗号化技術の進歩に対するある程度の防御になります。どちらも量子コンピューターによってほぼ同様に破られます。"
    },
    {
      "indent": 0,
      "text": " The Ed25519ph and Ed448ph variants are prehashed. This is mainly useful for interoperation with legacy APIs, since in most of the cases, either the amount of data signed is not large or the protocol is in the position to do digesting in ways better than just prehashing (e.g., tree hashing or splitting the data). The prehashing also makes the functions greatly more vulnerable to weaknesses in hash functions used. These variants SHOULD NOT be used.",
      "ja": "Ed25519phおよびEd448phバリアントはプリハッシュを使用します。これは主に、レガシーAPIとの相互運用に役立ちます。ほとんどの場合、署名されるデータの量が大きくないか、プロトコルが単なるプリハッシュよりも優れた方法でダイジェストを行うことができるためです（たとえば、ツリーハッシュやデータの分割）。また、プリハッシュは、使用されるハッシュ関数の弱点に対して関数を非常に脆弱にします。これらのバリアントは使用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Ed25519ctx and Ed448 have contexts. However, this is balanced by the problems noted in Section 8.3 about contexts.",
      "ja": "Ed25519ctxとEd448にはコンテキストがあります。しかし、これは8.3節で指摘したコンテキストに関する問題とバランスが取れています。"
    },
    {
      "indent": 3,
      "text": "On the implementation front, Ed25519 is widely implemented and has many high-quality implementations. The others have much worse support.",
      "ja": "実装面では、Ed25519は広く実装されており、高品質な実装が多数あります。一方、その他のバージョンはサポートがはるかに劣っています。"
    },
    {
      "indent": 3,
      "text": "In summary, if a high 128-bit security level is enough, use of Ed25519 is RECOMMENDED; otherwise, Ed448 is RECOMMENDED.",
      "ja": "要約すると、高い128ビットセキュリティレベルで十分な場合は、Ed25519の使用をお勧めします。それ以外の場合は、Ed448をお勧めします。"
    },
    {
      "indent": 0,
      "text": "8.6. Mixing Different Prehashes",
      "section_title": true,
      "ja": "8.6. Mixing Different Prehashes"
    },
    {
      "indent": 3,
      "text": "The schemes described in this document are designed to be resistant to mixing prehashes. That is, it is infeasible to find a message that verifies using the same signature under another scheme, even if the original signed message was chosen. Thus, one can use the same key pair for Ed25519, Ed25519ctx, and Ed25519ph and correspondingly with Ed448 and Ed448ph.",
      "ja": "このドキュメントで説明されているスキームは、プリハッシュの混合に耐性があるように設計されています。つまり、元の署名付きメッセージが選択された場合でも、別のスキームで同じ署名を使用して検証するメッセージを見つけることは不可能です。したがって、Ed25519、Ed25519ctx、およびEd25519phに同じキーペアを使用でき、Ed448およびEd448phにも対応できます。"
    },
    {
      "indent": 3,
      "text": "The \"SigEd25519 no Ed25519 collisions\" constant is chosen to be a textual string such that it does not decode as a point. Because the inner hash input in the Ed25519 signature always starts with a valid point, there is no way trivial collision can be constructed. In the case of seed hash, trivial collisions are so unlikely, even with an attacker choosing all inputs, that it is much more probable that something else goes catastrophically wrong.",
      "ja": "「SigEd25519 no Ed25519 collisions」定数は、点としてデコードされないテキスト文字列として選択されます。Ed25519署名の内部ハッシュ入力は常に有効な点から始まるため、自明な衝突が発生する可能性はありません。シードハッシュの場合、たとえ攻撃者がすべての入力を選択したとしても、自明な衝突が発生する可能性は非常に低いため、何か他の重大な問題が発生する可能性の方がはるかに高くなります。"
    },
    {
      "indent": 0,
      "text": "8.7. Signing Large Amounts of Data at Once",
      "section_title": true,
      "ja": "8.7. 一度に大量のデータに署名する"
    },
    {
      "indent": 3,
      "text": "Avoid signing large amounts of data at once (where \"large\" depends on the expected verifier). In particular, unless the underlying protocol does not require it, the receiver MUST buffer the entire message (or enough information to reconstruct it, e.g., compressed or encrypted version) to be verified.",
      "ja": "大量のデータに一度に署名することは避けてください（「大きな」は予期される検証に依存します）。特に、基礎となるプロトコルがそれを必要としない限り、受信者は検証するためにメッセージ全体（またはメッセージを再構築するのに十分な情報、たとえば圧縮または暗号化されたバージョン）をバッファリングする必要があります。"
    },
    {
      "indent": 3,
      "text": "This is needed because most of the time, it is unsafe to process unverified data, and verifying the signature makes a pass through the whole message, causing ultimately at least two passes through.",
      "ja": "これが必要なのは、ほとんどの場合、未検証のデータを処理することは危険であり、署名の検証にはメッセージ全体の走査が必要となるため、最終的には少なくとも2回の走査が発生することになるからです。"
    },
    {
      "indent": 3,
      "text": "As an API consideration, this means that any Initialize Update Finalize (IFU) verification interface is prone to misuse.",
      "ja": "APIの考慮事項として、これは、初期化、更新、ファイナライズ（IFU）検証インターフェースが誤用されやすいことを意味します。"
    },
    {
      "indent": 3,
      "text": "It is a bad idea to modify Ed25519 or Ed448 signing to be able to create valid Ed25519/Ed448 signatures using an IUF interface with only constant buffering. Pretty much any error in such would cause catastrophic security failure.",
      "ja": "定数バッファリングのみのIUFインターフェイスを使用して有効なEd25519/Ed448署名を作成できるようにEd25519またはEd448署名を変更することは悪い考えです。そのような変更におけるエラーのほとんどは、致命的なセキュリティ障害を引き起こします。"
    },
    {
      "indent": 0,
      "text": "8.8. Multiplication by Cofactor in Verification",
      "section_title": true,
      "ja": "8.8. 検証における補因子による乗算"
    },
    {
      "indent": 3,
      "text": "The given verification formulas for both Ed25519 and Ed448 multiply points by the cofactor. While this is not strictly necessary for security (in fact, any signature that meets the non-multiplied equation will satisfy the multiplied one), in some applications it is undesirable for implementations to disagree about the exact set of valid signatures. Such disagreements could open up, e.g., fingerprinting attacks.",
      "ja": "Ed25519とEd448の両方に指定された検証式は、点に余因子を乗算します。これはセキュリティのために厳密に必要なわけではありませんが（実際、乗算されていない式を満たす署名はすべて、乗算された式を満たします）、一部のアプリケーションでは、有効な署名の正確なセットについて実装間で不一致が生じることは望ましくありません。そのような不一致は、たとえば、フィンガープリント攻撃を引き起こす可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.9. Use of SHAKE256 as a Hash Function",
      "section_title": true,
      "ja": "8.9. Use of SHAKE256 as a Hash Function"
    },
    {
      "indent": 3,
      "text": "Ed448 uses SHAKE256 as a hash function, even if SHAKE256 is specifically defined not to be a hash function.",
      "ja": "Ed448は、SHAKE256がハッシュ関数ではないと明確に定義されている場合でも、SHAKE256をハッシュ関数として使用します。"
    },
    {
      "indent": 3,
      "text": "The first potentially troublesome property is that shorter outputs are prefixes of longer ones. This is acceptable because output lengths are fixed.",
      "ja": "最初の潜在的に厄介な特性は、短い出力が長い出力の接頭辞になるということです。出力の長さが固定されているため、これは許容範囲です。"
    },
    {
      "indent": 3,
      "text": "The second potentially troublesome property is failing to meet standard hash security notions (especially with preimages). However, the estimated 256-bit security level against collisions and preimages is sufficient to pair with a 224-bit level elliptic curve.",
      "ja": "2つ目の潜在的に厄介な特性は、標準のハッシュセキュリティの概念（特に原像の場合）を満たしていないことです。ただし、衝突および原像に対する推定256ビットのセキュリティレベルは、224ビットレベルの楕円曲線と組み合わせるのに十分です。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[FIPS202] National Institute of Standards and Technology, \"SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions\", FIPS PUB 202, August 2015, <http://dx.doi.org/10.6028/NIST.FIPS.202>.",
      "ja": "[FIPS202]米国国立標準技術研究所、「SHA-3標準：順列ベースのハッシュおよび拡張可能な出力関数」、FIPS PUB 202、2015年8月、<http://dx.doi.org/10.6028/NIST.FIPS .202>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>."
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234] Eastlake 3rd、D。およびT. Hansen、「US Secure Hash Algorithms（SHA and SHA-based HMAC and HKDF）」、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<http://www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7748] Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves for Security\", RFC 7748, DOI 10.17487/RFC7748, January 2016, <http://www.rfc-editor.org/info/rfc7748>.",
      "ja": "[RFC7748]ラングレー、A。、ハンブルク、M。、およびS.ターナー、「セキュリティのための楕円曲線」、RFC 7748、DOI 10.17487 / RFC7748、2016年1月、<http://www.rfc-editor.org/info / rfc7748>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CURVE25519] Bernstein, D., \"Curve25519: new Diffie-Hellman speed records\", DOI 10.1007/11745853_14, February 2006, <http://cr.yp.to/ecdh.html>.",
      "ja": "[CURVE25519] Bernstein、D。、「Curve25519：new Diffie-Hellman speed records」、DOI 10.1007 / 11745853_14、2006年2月、<http://cr.yp.to/ecdh.html>。"
    },
    {
      "indent": 3,
      "text": "[ED25519-LIBGCRYPT-TEST-VECTORS] Koch, W., \"Ed25519 Libgcrypt test vectors\", July 2014, <http://git.gnupg.org/cgi-bin/ gitweb.cgi?p=libgcrypt.git;a=blob;f=tests/t-ed25519.inp; h=e13566f826321eece65e02c593bc7d885b3dbe23;hb=refs/ heads/master>.",
      "ja": "[ED25519-LIBGCRYPT-TEST-VECTORS] Koch、W。、「Ed25519 Libgcrypt test vectors」、2014年7月、<http://git.gnupg.org/cgi-bin/ gitweb.cgi？p = libgcrypt.git; a = blob; f = tests / t-ed25519.inp; h = e13566f826321eece65e02c593bc7d885b3dbe23; hb = refs / heads / master>。"
    },
    {
      "indent": 3,
      "text": "[ED25519-TEST-VECTORS] Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B. Yang, \"Ed25519 test vectors\", July 2011, <http://ed25519.cr.yp.to/python/sign.input>.",
      "ja": "[ED25519-TEST-VECTORS] Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B. Yang, \"Ed25519 test vectors\", July 2011, <http://ed25519.cr.yp.to/python/sign.input>."
    },
    {
      "indent": 3,
      "text": "[ED448] Hamburg, M., \"Ed448-Goldilocks, a new elliptic curve\", June 2015, <http://eprint.iacr.org/2015/625>.",
      "ja": "[ED448] Hamburg, M., \"Ed448-Goldilocks, a new elliptic curve\", June 2015, <http://eprint.iacr.org/2015/625>."
    },
    {
      "indent": 3,
      "text": "[EDDSA] Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B. Yang, \"High-speed high-security signatures\", DOI 10.1007/978-3-642-23951-9_9, September 2011, <http://ed25519.cr.yp.to/ed25519-20110926.pdf>.",
      "ja": "[EDDSA] Bernstein、D.、Duif、N.、Lange、T.、Schwabe、P。、およびB. Yang、「高速高セキュリティ署名」、DOI 10.1007 / 978-3-642-23951-9_9 、2011年9月、<http://ed25519.cr.yp.to/ed25519-20110926.pdf>。"
    },
    {
      "indent": 3,
      "text": "[EDDSA2] Bernstein, D., Josefsson, S., Lange, T., Schwabe, P., and B. Yang, \"EdDSA for more curves\", July 2015, <http://ed25519.cr.yp.to/eddsa-20150704.pdf>.",
      "ja": "[EDDSA2] Bernstein、D.、Josefsson、S.、Lange、T.、Schwabe、P。、およびB. Yang、「EdDSA for more curve」、2015年7月、<http://ed25519.cr.yp.to /eddsa-20150704.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Edwards-revisited] Hisil, H., Wong, K., Carter, G., and E. Dawson, \"Twisted Edwards Curves Revisited\", DOI 10.1007/978-3-540-89255-7_20, December 2008, <http://eprint.iacr.org/2008/522>.",
      "ja": "[Edwards-revisited] Hisil, H., Wong, K., Carter, G., and E. Dawson, \"Twisted Edwards Curves Revisited\", DOI 10.1007/978-3-540-89255-7_20, December 2008, <http://eprint.iacr.org/2008/522>."
    },
    {
      "indent": 3,
      "text": "[EFD-ADD] Bernstein, D. and T. Lange, \"Projective coordinates for Edwards curves\", The 'add-2007-bl' addition formulas, 2007, <http://www.hyperelliptic.org/EFD/g1p/ auto-edwards-projective.html#addition-add-2007-bl>.",
      "ja": "[EFD-ADD] Bernstein、D.およびT. Lange、「エドワーズ曲線の射影座標」、「add-2007-bl」加算式、2007年、<http://www.hyperelliptic.org/EFD/g1p/ auto-edwards-projective.html＃addition-add-2007-bl>。"
    },
    {
      "indent": 3,
      "text": "[EFD-DBL] Bernstein, D. and T. Lange, \"Projective coordinates for Edwards curves\", The 'dbl-2007-bl' doubling formulas, 2007, <http://www.hyperelliptic.org/EFD/g1p/ auto-edwards-projective.html#doubling-dbl-2007-bl>.",
      "ja": "[EFD-DBL]バーンスタインD.およびT.ランゲ、「エドワーズ曲線の射影座標」、「dbl-2007-bl」ダブリング式、2007年、<http://www.hyperelliptic.org/EFD/g1p/ auto-edwards-projective.html＃doubling-dbl-2007-bl>。"
    },
    {
      "indent": 3,
      "text": "[EFD-TWISTED-ADD] Hisil, H., Wong, K., Carter, G., and E. Dawson, \"Extended coordinates with a=-1 for twisted Edwards curves\", The 'add-2008-hwcd-3' addition formulas, December 2008, <http://www.hyperelliptic.org/EFD/g1p/ auto-twisted-extended-1.html#addition-add-2008-hwcd-3>.",
      "ja": "[EFD-TWISTED-ADD] Hisil、H.、Wong、K.、Carter、G。、およびE. Dawson、「ねじれたエドワーズ曲線の場合、a = -1の拡張座標」、「add-2008-hwcd-3 '追加式、2008年12月、<http://www.hyperelliptic.org/EFD/g1p/ auto-twisted-extended-1.html＃addition-add-2008-hwcd-3>。"
    },
    {
      "indent": 3,
      "text": "[EFD-TWISTED-DBL] Hisil, H., Wong, K., Carter, G., and E. Dawson, \"Extended coordinates with a=-1 for twisted Edwards curves\", The 'dbl-2008-hwcd' doubling formulas, December 2008, <http://www.hyperelliptic.org/EFD/g1p/ auto-twisted-extended-1.html#doubling-dbl-2008-hwcd>.",
      "ja": "[EFD-TWISTED-DBL] Hisil、H.、Wong、K.、Carter、G。、およびE. Dawson、「ねじれたエドワーズ曲線の場合、a = -1の拡張座標」、「dbl-2008-hwcd」の倍増式、2008年12月、<http://www.hyperelliptic.org/EFD/g1p/ auto-twisted-extended-1.html＃doubling-dbl-2008-hwcd>。"
    },
    {
      "indent": 3,
      "text": "[Faster-ECC] Bernstein, D. and T. Lange, \"Faster addition and doubling on elliptic curves\", DOI 10.1007/978-3-540-76900-2_3, July 2007, <http://eprint.iacr.org/2007/286>.",
      "ja": "[Faster-ECC] Bernstein、D.とT. Lange、「楕円曲線でのFaster加算と倍加」、DOI 10.1007 / 978-3-540-76900-2_3、2007年7月、<http://eprint.iacr.org / 2007/286>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] Eastlake 3rd、D.、Schiller、J.、and S. Crocker、 \"Randomness Requirements for Security\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、June 2005、<http://www.rfc-editor .org / info / rfc4086>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Ed25519/Ed448 Python Library",
      "section_title": true,
      "ja": "Appendix A. Ed25519/Ed448 Pythonライブラリ"
    },
    {
      "indent": 3,
      "text": "Below is an example implementation of Ed25519/Ed448 written in Python; version 3.2 or higher is required.",
      "ja": "以下はPythonで書かれたEd25519 / Ed448の実装例です。バージョン3.2以降が必要です。"
    },
    {
      "indent": 3,
      "text": "Note: This code is not intended for production. Although it should produce correct results for every input, it is slow and makes no attempt to avoid side-channel attacks.",
      "ja": "注：このコードは実稼働用ではありません。すべての入力に対して正しい結果を生成するはずですが、速度が遅く、サイドチャネル攻撃を回避しようとはしません。"
    },
    {
      "indent": 0,
      "text": "import hashlib;\nimport os;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Compute candidate square root of x modulo p, with p = 3 (mod 4).\ndef sqrt4k3(x,p): return pow(x,(p + 1)//4,p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Compute candidate square root of x modulo p, with p = 5 (mod 8).\ndef sqrt8k5(x,p):\n    y = pow(x,(p+3)//8,p)\n    #If the square root exists, it is either y or y*2^(p-1)/4.\n    if (y * y) % p == x % p: return y\n    else:\n        z = pow(2,(p - 1)//4,p)\n        return (y * z) % p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Decode a hexadecimal string representation of the integer.\ndef hexi(s): return int.from_bytes(bytes.fromhex(s),byteorder=\"big\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Rotate a word x by b places to the left.\ndef rol(x,b): return ((x << b) | (x >> (64 - b))) & (2**64-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#From little endian.\ndef from_le(s): return int.from_bytes(s, byteorder=\"little\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Do the SHA-3 state transform on state s.\ndef sha3_transform(s):\n    ROTATIONS = [0,1,62,28,27,36,44,6,55,20,3,10,43,25,39,41,45,15,\\\n                 21,8,18,2,61,56,14]\n    PERMUTATION = [1,6,9,22,14,20,2,12,13,19,23,15,4,24,21,8,16,5,3,\\\n                   18,17,11,7,10]\n    RC = [0x0000000000000001,0x0000000000008082,0x800000000000808a,\\\n          0x8000000080008000,0x000000000000808b,0x0000000080000001,\\\n          0x8000000080008081,0x8000000000008009,0x000000000000008a,\\\n          0x0000000000000088,0x0000000080008009,0x000000008000000a,\\\n          0x000000008000808b,0x800000000000008b,0x8000000000008089,\\\n          0x8000000000008003,0x8000000000008002,0x8000000000000080,\\\n          0x000000000000800a,0x800000008000000a,0x8000000080008081,\\\n          0x8000000000008080,0x0000000080000001,0x8000000080008008]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "for rnd in range(0,24):\n    #AddColumnParity (Theta)\n    c = [0]*5;\n    d = [0]*5;\n    for i in range(0,25): c[i%5]^=s[i]\n    for i in range(0,5): d[i]=c[(i+4)%5]^rol(c[(i+1)%5],1)\n    for i in range(0,25): s[i]^=d[i%5]\n    #RotateWords (Rho)\n    for i in range(0,25): s[i]=rol(s[i],ROTATIONS[i])\n    #PermuteWords (Pi)\n    t = s[PERMUTATION[0]]\n    for i in range(0,len(PERMUTATION)-1):\n        s[PERMUTATION[i]]=s[PERMUTATION[i+1]]\n    s[PERMUTATION[-1]]=t;\n    #NonlinearMixRows (Chi)\n    for i in range(0,25,5):\n        t=[s[i],s[i+1],s[i+2],s[i+3],s[i+4],s[i],s[i+1]]\n        for j in range(0,5): s[i+j]=t[j]^((~t[j+1])&(t[j+2]))\n    #AddRoundConstant (Iota)\n    s[0]^=RC[rnd]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Reinterpret octet array b to word array and XOR it to state s.\ndef reinterpret_to_words_and_xor(s,b):\n    for j in range(0,len(b)//8):\n        s[j]^=from_le(b[8*j:][:8])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Reinterpret word array w to octet array and return it.\ndef reinterpret_to_octets(w):\n    mp=bytearray()\n    for j in range(0,len(w)):\n        mp+=w[j].to_bytes(8,byteorder=\"little\")\n    return mp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#(semi-)generic SHA-3 implementation\ndef sha3_raw(msg,r_w,o_p,e_b):\n    r_b=8*r_w\n    s=[0]*25\n    #Handle whole blocks.\n    idx=0\n    blocks=len(msg)//r_b\n    for i in range(0,blocks):\n        reinterpret_to_words_and_xor(s,msg[idx:][:r_b])\n        idx+=r_b\n        sha3_transform(s)\n    #Handle last block padding.\n    m=bytearray(msg[idx:])\n    m.append(o_p)\n    while len(m) < r_b: m.append(0)\n    m[len(m)-1]|=128\n    #Handle padded last block.\n    reinterpret_to_words_and_xor(s,m)\n    sha3_transform(s)\n    #Output.\n    out = bytearray()\n    while len(out)<e_b:\n        out+=reinterpret_to_octets(s[:r_w])\n        sha3_transform(s)\n    return out[:e_b]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Implementation of SHAKE256 functions.\ndef shake256(msg,olen): return sha3_raw(msg,17,31,olen)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#A (prime) field element.\nclass Field:\n    #Construct number x (mod p).\n    def __init__(self,x,p):\n        self.__x=x%p\n        self.__p=p\n    #Check that fields of self and y are the same.\n    def __check_fields(self,y):\n        if type(y) is not Field or self.__p!=y.__p:\n            raise ValueError(\"Fields don't match\")\n    #Field addition.  The fields must match.\n    def __add__(self,y):\n        self.__check_fields(y)\n        return Field(self.__x+y.__x,self.__p)\n    #Field subtraction.  The fields must match.\n    def __sub__(self,y):\n        self.__check_fields(y)\n        return Field(self.__p+self.__x-y.__x,self.__p)\n    #Field negation.\n    def __neg__(self):\n        return Field(self.__p-self.__x,self.__p)\n    #Field multiplication.  The fields must match.\n    def __mul__(self,y):\n        self.__check_fields(y)\n        return Field(self.__x*y.__x,self.__p)\n    #Field division.  The fields must match.\n    def __truediv__(self,y):\n        return self*y.inv()\n    #Field inverse (inverse of 0 is 0).\n    def inv(self):\n        return Field(pow(self.__x,self.__p-2,self.__p),self.__p)\n    #Field square root.  Returns none if square root does not exist.\n    #Note: not presently implemented for p mod 8 = 1 case.\n    def sqrt(self):\n        #Compute candidate square root.\n        if self.__p%4==3: y=sqrt4k3(self.__x,self.__p)\n        elif self.__p%8==5: y=sqrt8k5(self.__x,self.__p)\n        else: raise NotImplementedError(\"sqrt(_,8k+1)\")\n        _y=Field(y,self.__p);\n        #Check square root candidate valid.\n        return _y if _y*_y==self else None\n    #Make the field element with the same field as this, but\n    #with a different value.\n    def make(self,ival): return Field(ival,self.__p)\n    #Is the field element the additive identity?\n    def iszero(self): return self.__x==0\n    #Are field elements equal?\n    def __eq__(self,y): return self.__x==y.__x and self.__p==y.__p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "#Are field elements not equal?\ndef __ne__(self,y): return not (self==y)\n#Serialize number to b-1 bits.\ndef tobytes(self,b):\n    return self.__x.to_bytes(b//8,byteorder=\"little\")\n#Unserialize number from bits.\ndef frombytes(self,x,b):\n    rv=from_le(x)%(2**(b-1))\n    return Field(rv,self.__p) if rv<self.__p else None\n#Compute sign of number, 0 or 1.  The sign function\n#has the following property:\n#sign(x) = 1 - sign(-x) if x != 0.\ndef sign(self): return self.__x%2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#A point on (twisted) Edwards curve.\nclass EdwardsPoint:\n    #base_field = None\n    #x = None\n    #y = None\n    #z = None\n    def initpoint(self, x, y):\n        self.x=x\n        self.y=y\n        self.z=self.base_field.make(1)\n    def decode_base(self,s,b):\n        #Check that point encoding is the correct length.\n        if len(s)!=b//8: return (None,None)\n        #Extract signbit.\n        xs=s[(b-1)//8]>>((b-1)&7)\n        #Decode y.  If this fails, fail.\n        y = self.base_field.frombytes(s,b)\n        if y is None: return (None,None)\n        #Try to recover x.  If it does not exist, or if zero and xs\n        #are wrong, fail.\n        x=self.solve_x2(y).sqrt()\n        if x is None or (x.iszero() and xs!=x.sign()):\n            return (None,None)\n        #If sign of x isn't correct, flip it.\n        if x.sign()!=xs: x=-x\n        # Return the constructed point.\n        return (x,y)\n    def encode_base(self,b):\n        xp,yp=self.x/self.z,self.y/self.z\n        #Encode y.\n        s=bytearray(yp.tobytes(b))\n        #Add sign bit of x to encoding.\n        if xp.sign()!=0: s[(b-1)//8]|=1<<(b-1)%8\n        return s",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "def __mul__(self,x):\n    r=self.zero_elem()\n    s=self\n    while x > 0:\n        if (x%2)>0:\n            r=r+s\n        s=s.double()\n        x=x//2\n    return r\n#Check that two points are equal.\ndef __eq__(self,y):\n    #Need to check x1/z1 == x2/z2 and similarly for y, so cross\n    #multiply to eliminate divisions.\n    xn1=self.x*y.z\n    xn2=y.x*self.z\n    yn1=self.y*y.z\n    yn2=y.y*self.z\n    return xn1==xn2 and yn1==yn2\n#Check if two points are not equal.\ndef __ne__(self,y): return not (self==y)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#A point on Edwards25519.\nclass Edwards25519Point(EdwardsPoint):\n    #Create a new point on the curve.\n    base_field=Field(1,2**255-19)\n    d=-base_field.make(121665)/base_field.make(121666)\n    f0=base_field.make(0)\n    f1=base_field.make(1)\n    xb=base_field.make(hexi(\"216936D3CD6E53FEC0A4E231FDD6DC5C692CC76\"+\\\n        \"09525A7B2C9562D608F25D51A\"))\n    yb=base_field.make(hexi(\"666666666666666666666666666666666666666\"+\\\n        \"6666666666666666666666658\"))\n    #The standard base point.\n    @staticmethod\n    def stdbase():\n        return Edwards25519Point(Edwards25519Point.xb,\\\n            Edwards25519Point.yb)\n    def __init__(self,x,y):\n        #Check the point is actually on the curve.\n        if y*y-x*x!=self.f1+self.d*x*x*y*y:\n            raise ValueError(\"Invalid point\")\n        self.initpoint(x, y)\n        self.t=x*y\n    #Decode a point representation.\n    def decode(self,s):\n        x,y=self.decode_base(s,256);\n        return Edwards25519Point(x, y) if x is not None else None",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "#Encode a point representation.\ndef encode(self):\n    return self.encode_base(256)\n#Construct a neutral point on this curve.\ndef zero_elem(self):\n    return Edwards25519Point(self.f0,self.f1)\n#Solve for x^2.\ndef solve_x2(self,y):\n    return ((y*y-self.f1)/(self.d*y*y+self.f1))\n#Point addition.\ndef __add__(self,y):\n    #The formulas are from EFD.\n    tmp=self.zero_elem()\n    zcp=self.z*y.z\n    A=(self.y-self.x)*(y.y-y.x)\n    B=(self.y+self.x)*(y.y+y.x)\n    C=(self.d+self.d)*self.t*y.t\n    D=zcp+zcp\n    E,H=B-A,B+A\n    F,G=D-C,D+C\n    tmp.x,tmp.y,tmp.z,tmp.t=E*F,G*H,F*G,E*H\n    return tmp\n#Point doubling.\ndef double(self):\n    #The formulas are from EFD (with assumption a=-1 propagated).\n    tmp=self.zero_elem()\n    A=self.x*self.x\n    B=self.y*self.y\n    Ch=self.z*self.z\n    C=Ch+Ch\n    H=A+B\n    xys=self.x+self.y\n    E=H-xys*xys\n    G=A-B\n    F=C+G\n    tmp.x,tmp.y,tmp.z,tmp.t=E*F,G*H,F*G,E*H\n    return tmp\n#Order of basepoint.\ndef l(self):\n    return hexi(\"1000000000000000000000000000000014def9dea2f79cd\"+\\\n        \"65812631a5cf5d3ed\")\n#The logarithm of cofactor.\ndef c(self): return 3\n#The highest set bit\ndef n(self): return 254\n#The coding length\ndef b(self): return 256",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "#Validity check (for debugging)\ndef is_valid_point(self):\n    x,y,z,t=self.x,self.y,self.z,self.t\n    x2=x*x\n    y2=y*y\n    z2=z*z\n    lhs=(y2-x2)*z2\n    rhs=z2*z2+self.d*x2*y2\n    assert(lhs == rhs)\n    assert(t*z == x*y)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#A point on Edwards448.\nclass Edwards448Point(EdwardsPoint):\n    #Create a new point on the curve.\n    base_field=Field(1,2**448-2**224-1)\n    d=base_field.make(-39081)\n    f0=base_field.make(0)\n    f1=base_field.make(1)\n    xb=base_field.make(hexi(\"4F1970C66BED0DED221D15A622BF36DA9E14657\"+\\\n        \"0470F1767EA6DE324A3D3A46412AE1AF72AB66511433B80E18B00938E26\"+\\\n        \"26A82BC70CC05E\"))\n    yb=base_field.make(hexi(\"693F46716EB6BC248876203756C9C7624BEA737\"+\\\n        \"36CA3984087789C1E05A0C2D73AD3FF1CE67C39C4FDBD132C4ED7C8AD98\"+\\\n        \"08795BF230FA14\"))\n    #The standard base point.\n    @staticmethod\n    def stdbase():\n        return Edwards448Point(Edwards448Point.xb,Edwards448Point.yb)\n    def __init__(self,x,y):\n        #Check that the point is actually on the curve.\n        if y*y+x*x!=self.f1+self.d*x*x*y*y:\n            raise ValueError(\"Invalid point\")\n        self.initpoint(x, y)\n    #Decode a point representation.\n    def decode(self,s):\n        x,y=self.decode_base(s,456);\n        return Edwards448Point(x, y) if x is not None else None\n    #Encode a point representation.\n    def encode(self):\n        return self.encode_base(456)\n    #Construct a neutral point on this curve.\n    def zero_elem(self):\n        return Edwards448Point(self.f0,self.f1)\n    #Solve for x^2.\n    def solve_x2(self,y):\n        return ((y*y-self.f1)/(self.d*y*y-self.f1))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "#Point addition.\ndef __add__(self,y):\n    #The formulas are from EFD.\n    tmp=self.zero_elem()\n    xcp,ycp,zcp=self.x*y.x,self.y*y.y,self.z*y.z\n    B=zcp*zcp\n    E=self.d*xcp*ycp\n    F,G=B-E,B+E\n    tmp.x=zcp*F*((self.x+self.y)*(y.x+y.y)-xcp-ycp)\n    tmp.y,tmp.z=zcp*G*(ycp-xcp),F*G\n    return tmp\n#Point doubling.\ndef double(self):\n    #The formulas are from EFD.\n    tmp=self.zero_elem()\n    x1s,y1s,z1s=self.x*self.x,self.y*self.y,self.z*self.z\n    xys=self.x+self.y\n    F=x1s+y1s\n    J=F-(z1s+z1s)\n    tmp.x,tmp.y,tmp.z=(xys*xys-x1s-y1s)*J,F*(x1s-y1s),F*J\n    return tmp\n#Order of basepoint.\ndef l(self):\n    return hexi(\"3ffffffffffffffffffffffffffffffffffffffffffffff\"+\\\n        \"fffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c2\"+\\\n        \"92ab5844f3\")\n#The logarithm of cofactor.\ndef c(self): return 2\n#The highest set bit.\ndef n(self): return 447\n#The coding length.\ndef b(self): return 456\n#Validity check (for debugging).\ndef is_valid_point(self):\n    x,y,z=self.x,self.y,self.z\n    x2=x*x\n    y2=y*y\n    z2=z*z\n    lhs=(x2+y2)*z2\n    rhs=z2*z2+self.d*x2*y2\n    assert(lhs == rhs)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Simple self-check.\ndef curve_self_check(point):\n    p=point\n    q=point.zero_elem()\n    z=q\n    l=p.l()+1\n    p.is_valid_point()\n    q.is_valid_point()\n    for i in range(0,point.b()):\n        if (l>>i)&1 != 0:\n            q=q+p\n            q.is_valid_point()\n        p=p.double()\n        p.is_valid_point()\n    assert q.encode() == point.encode()\n    assert q.encode() != p.encode()\n    assert q.encode() != z.encode()",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Simple self-check.\ndef self_check_curves():\n    curve_self_check(Edwards25519Point.stdbase())\n    curve_self_check(Edwards448Point.stdbase())",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#PureEdDSA scheme.\n#Limitation: only b mod 8 = 0 is handled.\nclass PureEdDSA:\n    #Create a new object.\n    def __init__(self,properties):\n        self.B=properties[\"B\"]\n        self.H=properties[\"H\"]\n        self.l=self.B.l()\n        self.n=self.B.n()\n        self.b=self.B.b()\n        self.c=self.B.c()\n    #Clamp a private scalar.\n    def __clamp(self,a):\n        _a = bytearray(a)\n        for i in range(0,self.c): _a[i//8]&=~(1<<(i%8))\n        _a[self.n//8]|=1<<(self.n%8)\n        for i in range(self.n+1,self.b): _a[i//8]&=~(1<<(i%8))\n        return _a\n    #Generate a key.  If privkey is None, a random one is generated.\n    #In any case, the (privkey, pubkey) pair is returned.\n    def keygen(self,privkey):\n        #If no private key data is given, generate random.\n        if privkey is None: privkey=os.urandom(self.b//8)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "    #Expand key.\n    khash=self.H(privkey,None,None)\n    a=from_le(self.__clamp(khash[:self.b//8]))\n    #Return the key pair (public key is A=Enc(aB).\n    return privkey,(self.B*a).encode()\n#Sign with key pair.\ndef sign(self,privkey,pubkey,msg,ctx,hflag):\n    #Expand key.\n    khash=self.H(privkey,None,None)\n    a=from_le(self.__clamp(khash[:self.b//8]))\n    seed=khash[self.b//8:]\n    #Calculate r and R (R only used in encoded form).\n    r=from_le(self.H(seed+msg,ctx,hflag))%self.l\n    R=(self.B*r).encode()\n    #Calculate h.\n    h=from_le(self.H(R+pubkey+msg,ctx,hflag))%self.l\n    #Calculate s.\n    S=((r+h*a)%self.l).to_bytes(self.b//8,byteorder=\"little\")\n    #The final signature is a concatenation of R and S.\n    return R+S\n#Verify signature with public key.\ndef verify(self,pubkey,msg,sig,ctx,hflag):\n    #Sanity-check sizes.\n    if len(sig)!=self.b//4: return False\n    if len(pubkey)!=self.b//8: return False\n    #Split signature into R and S, and parse.\n    Rraw,Sraw=sig[:self.b//8],sig[self.b//8:]\n    R,S=self.B.decode(Rraw),from_le(Sraw)\n    #Parse public key.\n    A=self.B.decode(pubkey)\n    #Check parse results.\n    if (R is None) or (A is None) or S>=self.l: return False\n    #Calculate h.\n    h=from_le(self.H(Rraw+pubkey+msg,ctx,hflag))%self.l\n    #Calculate left and right sides of check eq.\n    rhs=R+(A*h)\n    lhs=self.B*S\n    for i in range(0, self.c):\n        lhs = lhs.double()\n        rhs = rhs.double()\n    #Check eq. holds?\n    return lhs==rhs",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def Ed25519_inthash(data,ctx,hflag):\n    if (ctx is not None and len(ctx) > 0) or hflag:\n        raise ValueError(\"Contexts/hashes not supported\")\n    return hashlib.sha512(data).digest()",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#The base PureEdDSA schemes.\npEd25519=PureEdDSA({\\\n    \"B\":Edwards25519Point.stdbase(),\\\n    \"H\":Ed25519_inthash\\\n})",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def Ed25519ctx_inthash(data,ctx,hflag):\n    dompfx = b\"\"\n    PREFIX=b\"SigEd25519 no Ed25519 collisions\"\n    if ctx is not None:\n        if len(ctx) > 255: raise ValueError(\"Context too big\")\n        dompfx=PREFIX+bytes([1 if hflag else 0,len(ctx)])+ctx\n    return hashlib.sha512(dompfx+data).digest()",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pEd25519ctx=PureEdDSA({\\\n    \"B\":Edwards25519Point.stdbase(),\\\n    \"H\":Ed25519ctx_inthash\\\n})",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def Ed448_inthash(data,ctx,hflag):\n    dompfx = b\"\"\n    if ctx is not None:\n        if len(ctx) > 255: raise ValueError(\"Context too big\")\n        dompfx=b\"SigEd448\"+bytes([1 if hflag else 0,len(ctx)])+ctx\n    return shake256(dompfx+data,114)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pEd448 = PureEdDSA({\\\n    \"B\":Edwards448Point.stdbase(),\\\n    \"H\":Ed448_inthash\\\n})",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#EdDSA scheme.\nclass EdDSA:\n    #Create a new scheme object, with the specified PureEdDSA base\n    #scheme and specified prehash.\n    def __init__(self,pure_scheme,prehash):\n        self.__pflag = True\n        self.__pure=pure_scheme\n        self.__prehash=prehash\n        if self.__prehash is None:\n            self.__prehash = lambda x,y:x\n            self.__pflag = False\n    # Generate a key.  If privkey is none, it generates a random\n    # privkey key, otherwise it uses a specified private key.\n    # Returns pair (privkey, pubkey).\n    def keygen(self,privkey): return self.__pure.keygen(privkey)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "# Sign message msg using specified key pair.\ndef sign(self,privkey,pubkey,msg,ctx=None):\n    if ctx is None: ctx=b\"\";\n    return self.__pure.sign(privkey,pubkey,self.__prehash(msg,ctx),\\\n        ctx,self.__pflag)\n# Verify signature sig on message msg using public key pubkey.\ndef verify(self,pubkey,msg,sig,ctx=None):\n    if ctx is None: ctx=b\"\";\n    return self.__pure.verify(pubkey,self.__prehash(msg,ctx),sig,\\\n        ctx,self.__pflag)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def Ed448ph_prehash(data,ctx):\n    return shake256(data,64)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#Our signature schemes.\nEd25519 = EdDSA(pEd25519,None)\nEd25519ctx = EdDSA(pEd25519ctx,None)\nEd25519ph = EdDSA(pEd25519ctx,lambda x,y:hashlib.sha512(x).digest())\nEd448 = EdDSA(pEd448,None)\nEd448ph = EdDSA(pEd448,Ed448ph_prehash)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def eddsa_obj(name):\n    if name == \"Ed25519\": return Ed25519\n    if name == \"Ed25519ctx\": return Ed25519ctx\n    if name == \"Ed25519ph\": return Ed25519ph\n    if name == \"Ed448\": return Ed448\n    if name == \"Ed448ph\": return Ed448ph\n    raise NotImplementedError(\"Algorithm not implemented\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Library Driver",
      "section_title": true,
      "ja": "Appendix B. Library Driver"
    },
    {
      "indent": 3,
      "text": "Below is a command-line tool that uses the library above to perform computations for interactive use or for self-checking.",
      "ja": "以下は、上記のライブラリを使用して、インタラクティブな使用またはセルフチェックのための計算を実行するコマンドラインツールです。"
    },
    {
      "indent": 0,
      "text": "import sys\nimport binascii\n\nfrom eddsa2 import Ed25519",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "def munge_string(s, pos, change):\n    return (s[:pos] +\n            int.to_bytes(s[pos] ^ change, 1, \"little\") +\n            s[pos+1:])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "# Read a file in the format of\n# http://ed25519.cr.yp.to/python/sign.input\nlineno = 0\nwhile True:\n    line = sys.stdin.readline()\n    if not line:\n        break\n    lineno = lineno + 1\n    print(lineno)\n    fields = line.split(\":\")\n    secret = (binascii.unhexlify(fields[0]))[:32]\n    public = binascii.unhexlify(fields[1])\n    msg = binascii.unhexlify(fields[2])\n    signature = binascii.unhexlify(fields[3])[:64]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "privkey,pubkey = Ed25519.keygen(secret)\nassert public == pubkey\nassert signature == Ed25519.sign(privkey, pubkey, msg)\nassert Ed25519.verify(public, msg, signature)\nif len(msg) == 0:\n    bad_msg = b\"x\"\nelse:\n    bad_msg = munge_string(msg, len(msg) // 3, 4)\nassert not Ed25519.verify(public,bad_msg,signature)\nassert not Ed25519.verify(public, msg, munge_string(signature,20,8))\nassert not Ed25519.verify(public,msg,munge_string(signature,40,16))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "EdDSA and Ed25519 were initially described in a paper due to Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. The Ed448 curve is due to Mike Hamburg.",
      "ja": "EdDSAとEd25519は、Daniel J. Bernstein、Niels Duif、Tanja Lange、Peter Schwabe、およびBo-Yin Yangによる論文で最初に説明されました。Ed448曲線はMike Hamburgによるものです。"
    },
    {
      "indent": 3,
      "text": "An earlier draft version of this document was coauthored by Niels Moeller.",
      "ja": "このドキュメントの以前のドラフト版は、Niels Moellerとの共著でした。"
    },
    {
      "indent": 3,
      "text": "Feedback on this document was received from Werner Koch, Damien Miller, Bob Bradley, Franck Rondepierre, Alexey Melnikov, Kenny Paterson, and Robert Edmonds.",
      "ja": "このドキュメントに関するフィードバックは、Werner Koch、Damien Miller、Bob Bradley、Franck Rondepierre、Alexey Melnikov、Kenny Paterson、およびRobert Edmondsから受け取りました。"
    },
    {
      "indent": 3,
      "text": "The Ed25519 test vectors were double checked by Bob Bradley using three separate implementations (one based on TweetNaCl and two different implementations based on code from SUPERCOP).",
      "ja": "Ed25519テストベクトルは、3つの個別の実装（1つはTweetNaClに基づく実装、2つはSUPERCOPのコードに基づく2つの異なる実装）を使用してボブブラッドリーによりダブルチェックされました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Simon Josefsson SJD AB",
      "ja": "サイモン・ジョセフソンSJD AB"
    },
    {
      "indent": 3,
      "text": "Email: simon@josefsson.org\nURI:   http://josefsson.org/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ilari Liusvaara Independent",
      "ja": "Ilari Liusvaara独立"
    },
    {
      "indent": 3,
      "text": "Email: ilariliusvaara@welho.com",
      "raw": true,
      "ja": ""
    }
  ]
}