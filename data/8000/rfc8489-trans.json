{
  "title": {
    "text": "RFC 8489 - Session Traversal Utilities for NAT (STUN)",
    "ja": "RFC 8489 - NAT用セッショントラバーサルユーティリティ（STUN）"
  },
  "number": 8489,
  "created_at": "2021-02-27 12:59:58.752595+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                 M. Petit-Huguenin\nRequest for Comments: 8489                            Impedance Mismatch\nObsoletes: 5389                                             G. Salgueiro\nCategory: Standards Track                                          Cisco\nISSN: 2070-1721                                             J. Rosenberg\n                                                                   Five9\n                                                                 D. Wing\n                                                                  Citrix\n                                                                 R. Mahy\n                                                            Unaffiliated\n                                                             P. Matthews\n                                                                   Nokia\n                                                           February 2020",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Session Traversal Utilities for NAT (STUN)",
      "ja": "NAT用セッショントラバーサルユーティリティ（STUN）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Session Traversal Utilities for NAT (STUN) is a protocol that serves as a tool for other protocols in dealing with NAT traversal. It can be used by an endpoint to determine the IP address and port allocated to it by a NAT. It can also be used to check connectivity between two endpoints and as a keep-alive protocol to maintain NAT bindings. STUN works with many existing NATs and does not require any special behavior from them.",
      "ja": "NAT用セッショントラバーサルユーティリティ（STUN）は、NATトラバーサルを処理する他のプロトコルのツールとして機能するプロトコルです。エンドポイントがNATによって割り当てられたIPアドレスとポートを決定するために使用できます。また、2つのエンドポイント間の接続を確認したり、NATバインディングを維持するためのキープアライブプロトコルとして使用したりすることもできます。STUNは多くの既存のNATで動作し、それらからの特別な動作を必要としません。"
    },
    {
      "indent": 3,
      "text": "STUN is not a NAT traversal solution by itself. Rather, it is a tool to be used in the context of a NAT traversal solution.",
      "ja": "STUNは、それ自体がNATトラバーサルソリューションではありません。むしろ、NATトラバーサルソリューションのコンテキストで使用されるツールです。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 5389.",
      "ja": "このドキュメントはRFC5389を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネット技術特別調査委員会（IETF）の製品です。これは、IETFコミュニティのコンセンサスを表しています。パブリックレビューを受け、Internet Engineering Steering Group（IESG）による公開が承認されました。インターネット標準の詳細については、RFC7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8489.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https://www.rfc-editor.org/info/rfc8489で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2020 IETF Trustおよびドキュメントの作成者として特定された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限について説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eで説明されているSimplified BSD Licenseテキストが含まれている必要があり、Simplified BSD Licenseで説明されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. Overview of Operation ...........................................5\n3. Terminology .....................................................7\n4. Definitions .....................................................7\n5. STUN Message Structure ..........................................9\n6. Base Protocol Procedures .......................................11\n   6.1. Forming a Request or an Indication ........................11\n   6.2. Sending the Request or Indication .........................12\n        6.2.1. Sending over UDP or DTLS-over-UDP ..................13\n        6.2.2. Sending over TCP or TLS-over-TCP ...................14\n        6.2.3. Sending over TLS-over-TCP or DTLS-over-UDP .........15\n   6.3. Receiving a STUN Message ..................................16\n        6.3.1. Processing a Request ...............................17\n               6.3.1.1. Forming a Success or Error Response .......17\n               6.3.1.2. Sending the Success or Error Response .....18\n        6.3.2. Processing an Indication ...........................18\n        6.3.3. Processing a Success Response ......................19\n        6.3.4. Processing an Error Response .......................19\n7. FINGERPRINT Mechanism ..........................................20\n8. DNS Discovery of a Server ......................................20\n   8.1. STUN URI Scheme Semantics .................................21\n9. Authentication and Message-Integrity Mechanisms ................22\n   9.1. Short-Term Credential Mechanism ...........................23\n        9.1.1. HMAC Key ...........................................23\n        9.1.2. Forming a Request or Indication ....................23\n        9.1.3. Receiving a Request or Indication ..................23\n        9.1.4. Receiving a Response ...............................25\n        9.1.5. Sending Subsequent Requests ........................25\n   9.2. Long-Term Credential Mechanism ............................26\n        9.2.1. Bid-Down Attack Prevention .........................27\n        9.2.2. HMAC Key ...........................................27",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        9.2.3. Forming a Request ..................................28\n               9.2.3.1. First Request .............................28\n               9.2.3.2. Subsequent Requests .......................29\n        9.2.4. Receiving a Request ................................29\n        9.2.5. Receiving a Response ...............................31\n10. ALTERNATE-SERVER Mechanism ....................................33\n11. Backwards Compatibility with RFC 3489 .........................34\n12. Basic Server Behavior .........................................34\n13. STUN Usages ...................................................35\n14. STUN Attributes ...............................................36\n   14.1. MAPPED-ADDRESS ...........................................37\n   14.2. XOR-MAPPED-ADDRESS .......................................38\n   14.3. USERNAME .................................................39\n   14.4. USERHASH .................................................40\n   14.5. MESSAGE-INTEGRITY ........................................40\n   14.6. MESSAGE-INTEGRITY-SHA256 .................................41\n   14.7. FINGERPRINT ..............................................41\n   14.8. ERROR-CODE ...............................................42\n   14.9. REALM ....................................................44\n   14.10. NONCE ...................................................44\n   14.11. PASSWORD-ALGORITHMS .....................................44\n   14.12. PASSWORD-ALGORITHM ......................................45\n   14.13. UNKNOWN-ATTRIBUTES ......................................45\n   14.14. SOFTWARE ................................................46\n   14.15. ALTERNATE-SERVER ........................................46\n   14.16. ALTERNATE-DOMAIN ........................................46\n15. Operational Considerations ....................................47\n16. Security Considerations .......................................47\n   16.1. Attacks against the Protocol .............................47\n        16.1.1. Outside Attacks ...................................47\n        16.1.2. Inside Attacks ....................................48\n        16.1.3. Bid-Down Attacks ..................................48\n   16.2. Attacks Affecting the Usage ..............................50\n        16.2.1. Attack I: Distributed DoS (DDoS) against a\n                Target ............................................51\n        16.2.2. Attack II: Silencing a Client .....................51\n        16.2.3. Attack III: Assuming the Identity of a Client .....52\n        16.2.4. Attack IV: Eavesdropping ..........................52\n   16.3. Hash Agility Plan ........................................52\n17. IAB Considerations ............................................53\n18. IANA Considerations ...........................................53\n   18.1. STUN Security Features Registry ..........................53\n   18.2. STUN Methods Registry ....................................54\n   18.3. STUN Attributes Registry .................................54\n        18.3.1. Updated Attributes ................................55\n        18.3.2. New Attributes ....................................55\n   18.4. STUN Error Codes Registry ................................56\n   18.5. STUN Password Algorithms Registry ........................56",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        18.5.1. Password Algorithms ...............................57\n               18.5.1.1. MD5 ......................................57\n               18.5.1.2. SHA-256 ..................................57\n   18.6. STUN UDP and TCP Port Numbers ............................57\n19. Changes since RFC 5389 ........................................57\n20. References ....................................................58\n   20.1. Normative References .....................................58\n   20.2. Informative References ...................................61\nAppendix A.  C Snippet to Determine STUN Message Types ............64\nAppendix B.  Test Vectors .........................................64\n  B.1.  Sample Request with Long-Term Authentication with\n        MESSAGE-INTEGRITY-SHA256 and USERHASH .....................65\nAcknowledgements ..................................................66\nContributors ......................................................66\nAuthors' Addresses ................................................67",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The protocol defined in this specification, Session Traversal Utilities for NAT (STUN), provides a tool for dealing with Network Address Translators (NATs). It provides a means for an endpoint to determine the IP address and port allocated by a NAT that corresponds to its private IP address and port. It also provides a way for an endpoint to keep a NAT binding alive. With some extensions, the protocol can be used to do connectivity checks between two endpoints [RFC8445] or to relay packets between two endpoints [RFC5766].",
      "ja": "この仕様で定義されているプロトコルであるNAT用セッショントラバーサルユーティリティ（STUN）は、ネットワークアドレス変換器（NAT）を処理するためのツールを提供します。エンドポイントが、プライベートIPアドレスとポートに対応するNATによって割り当てられたIPアドレスとポートを決定する手段を提供します。また、エンドポイントがNATバインディングを存続させる方法も提供します。一部の拡張機能では、プロトコルを使用して2つのエンドポイント間の接続チェックを実行したり[RFC8445]、2つのエンドポイント間でパケットを中継したりできます[RFC5766]。"
    },
    {
      "indent": 3,
      "text": "In keeping with its tool nature, this specification defines an extensible packet format, defines operation over several transport protocols, and provides for two forms of authentication.",
      "ja": "この仕様は、ツールの性質に合わせて、拡張可能なパケット形式を定義し、複数のトランスポートプロトコルでの動作を定義し、2つの形式の認証を提供します。"
    },
    {
      "indent": 3,
      "text": "STUN is intended to be used in the context of one or more NAT traversal solutions. These solutions are known as \"STUN Usages\". Each usage describes how STUN is utilized to achieve the NAT traversal solution. Typically, a usage indicates when STUN messages get sent, which optional attributes to include, what server is used, and what authentication mechanism is to be used. Interactive Connectivity Establishment (ICE) [RFC8445] is one usage of STUN. SIP Outbound [RFC5626] is another usage of STUN. In some cases, a usage will require extensions to STUN. A STUN extension can be in the form of new methods, attributes, or error response codes. More information on STUN Usages can be found in Section 13.",
      "ja": "STUNは、1つ以上のNATトラバーサルソリューションのコンテキストで使用することを目的としています。これらのソリューションは「STUN Usages」として知られています。それぞれの使用法は、NATトラバーサルソリューションを実現するためにSTUNがどのように利用されるかを説明しています。通常、使用法は、STUNメッセージが送信されるタイミング、含めるオプションの属性、使用されるサーバー、および使用される認証メカニズムを示します。Interactive Connectivity Establishment（ICE）[RFC8445]は、STUNの使用法の1つです。SIPアウトバウンド[RFC5626]は、STUNのもう1つの使用法です。場合によっては、使用法にSTUNの拡張が必要になります。STUN拡張機能は、新しいメソッド、属性、またはエラー応答コードの形式にすることができます。STUNの使用法の詳細については、セクション13を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Overview of Operation",
      "section_title": true,
      "ja": "2. 操作の概要"
    },
    {
      "indent": 3,
      "text": "This section is descriptive only.",
      "ja": "このセクションは説明のみです。"
    },
    {
      "indent": 24,
      "text": "   /-----\\\n // STUN  \\\\\n|   Server  |\n \\\\       //\n   \\-----/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "                +--------------+             Public Internet\n................|     NAT 2    |.......................\n                +--------------+",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "                +--------------+             Private Network 2\n................|     NAT 1    |.......................\n                +--------------+",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "   /-----\\\n // STUN  \\\\\n|   Client  |\n \\\\       //               Private Network 1\n   \\-----/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 1: One Possible STUN Configuration",
      "ja": "図1：1つの可能なSTUN構成"
    },
    {
      "indent": 3,
      "text": "One possible STUN configuration is shown in Figure 1. In this configuration, there are two entities (called STUN agents) that implement the STUN protocol. The lower agent in the figure is the client, which is connected to private network 1. This network connects to private network 2 through NAT 1. Private network 2 connects to the public Internet through NAT 2. The upper agent in the figure is the server, which resides on the public Internet.",
      "ja": "考えられるSTUN構成の1つを図1に示します。この構成には、STUNプロトコルを実装する2つのエンティティ（STUNエージェントと呼ばれる）があります。図の下のエージェントは、プライベートネットワーク1に接続されているクライアントです。このネットワークは、NAT 1を介してプライベートネットワーク2に接続します。プライベートネットワーク2は、NAT2を介してパブリックインターネットに接続します。図の上のエージェントはサーバーであり、パブリックインターネット上にあります。"
    },
    {
      "indent": 0,
      "text": " STUN is a client-server protocol. It supports two types of transactions. One is a request/response transaction in which a client sends a request to a server, and the server returns a response. The second is an indication transaction in which either agent -- client or server -- sends an indication that generates no response. Both types of transactions include a transaction ID, which is a randomly selected 96-bit number. For request/response transactions, this transaction ID allows the client to associate the response with the request that generated it; for indications, the transaction ID serves as a debugging aid.",
      "ja": "STUNはクライアントサーバープロトコルです。2種類のトランザクションをサポートします。1つは、クライアントがサーバーに要求を送信し、サーバーが応答を返す要求/応答トランザクションです。2つ目は、エージェント（クライアントまたはサーバー）のいずれかが応答を生成しない指示を送信する指示トランザクションです。どちらのタイプのトランザクションにも、ランダムに選択された96ビットの数値であるトランザクションIDが含まれています。要求/応答トランザクションの場合、このトランザクションIDにより、クライアントは応答をそれを生成した要求に関連付けることができます。目安として、トランザクションIDはデバッグの補助として機能します。"
    },
    {
      "indent": 3,
      "text": "All STUN messages start with a fixed header that includes a method, a class, and the transaction ID. The method indicates which of the various requests or indications this is; this specification defines just one method, Binding, but other methods are expected to be defined in other documents. The class indicates whether this is a request, a success response, an error response, or an indication. Following the fixed header comes zero or more attributes, which are Type-Length-Value extensions that convey additional information for the specific message.",
      "ja": "すべてのSTUNメッセージは、メソッド、クラス、およびトランザクションIDを含む固定ヘッダーで始まります。このメソッドは、これがさまざまな要求または指示のどれであるかを示します。この仕様では、Bindingという1つのメソッドのみを定義していますが、他のメソッドは他のドキュメントで定義されていると予想されます。このクラスは、これが要求、成功応答、エラー応答、または指示のいずれであるかを示します。固定ヘッダーの後には、特定のメッセージの追加情報を伝達するType-Length-Value拡張機能である0個以上の属性が続きます。"
    },
    {
      "indent": 3,
      "text": "This document defines a single method called \"Binding\". The Binding method can be used either in request/response transactions or in indication transactions. When used in request/response transactions, the Binding method can be used to determine the particular binding a NAT has allocated to a STUN client. When used in either request/ response or in indication transactions, the Binding method can also be used to keep these bindings alive.",
      "ja": "このドキュメントでは、「バインディング」と呼ばれる単一のメソッドを定義しています。Bindingメソッドは、要求/応答トランザクションまたは指示トランザクションのいずれかで使用できます。要求/応答トランザクションで使用する場合、Bindingメソッドを使用して、NATがSTUNクライアントに割り当てた特定のバインディングを判別できます。要求/応答または指示トランザクションのいずれかで使用される場合、Bindingメソッドを使用してこれらのバインディングを存続させることもできます。"
    },
    {
      "indent": 3,
      "text": "In the Binding request/response transaction, a Binding request is sent from a STUN client to a STUN server. When the Binding request arrives at the STUN server, it may have passed through one or more NATs between the STUN client and the STUN server (in Figure 1, there are two such NATs). As the Binding request message passes through a NAT, the NAT will modify the source transport address (that is, the source IP address and the source port) of the packet. As a result, the source transport address of the request received by the server will be the public IP address and port created by the NAT closest to the server. This is called a \"reflexive transport address\". The STUN server copies that source transport address into an XOR-MAPPED-ADDRESS attribute in the STUN Binding response and sends the Binding response back to the STUN client. As this packet passes back through a NAT, the NAT will modify the destination transport address in the IP header, but the transport address in the XOR-MAPPED-ADDRESS attribute within the body of the STUN response will remain untouched. In this way, the client can learn its reflexive transport address allocated by the outermost NAT with respect to the STUN server.",
      "ja": "バインディング要求/応答トランザクションでは、バインディング要求がSTUNクライアントからSTUNサーバーに送信されます。バインディングリクエストがSTUNサーバーに到着すると、STUNクライアントとSTUNサーバーの間で1つ以上のNATを通過した可能性があります（図1では、そのようなNATが2つあります）。バインディング要求メッセージがNATを通過すると、NATはパケットの送信元トランスポートアドレス（つまり、送信元IPアドレスと送信元ポート）を変更します。その結果、サーバーが受信する要求の送信元トランスポートアドレスは、サーバーに最も近いNATによって作成されたパブリックIPアドレスとポートになります。これは「反射トランスポートアドレス」と呼ばれます。 STUNサーバーは、その送信元トランスポートアドレスをSTUNバインディング応答のXOR-MAPPED-ADDRESS属性にコピーし、バインディング応答をSTUNクライアントに送り返します。このパケットがNATを通過すると、NATはIPヘッダーの宛先トランスポートアドレスを変更しますが、STUN応答の本文内のXOR-MAPPED-ADDRESS属性のトランスポートアドレスは変更されません。このようにして、クライアントは、STUNサーバーに関して最も外側のNATによって割り当てられた反射トランスポートアドレスを学習できます。"
    },
    {
      "indent": 0,
      "text": " In some usages, STUN must be multiplexed with other protocols (e.g., [RFC8445] and [RFC5626]). In these usages, there must be a way to inspect a packet and determine if it is a STUN packet or not. STUN provides three fields in the STUN header with fixed values that can be used for this purpose. If this is not sufficient, then STUN packets can also contain a FINGERPRINT value, which can further be used to distinguish the packets.",
      "ja": "一部の使用法では、STUNを他のプロトコル（[RFC8445]や[RFC5626]など）と多重化する必要があります。これらの使用法では、パケットを検査して、それがSTUNパケットであるかどうかを判断する方法が必要です。STUNは、この目的に使用できる固定値を持つSTUNヘッダーの3つのフィールドを提供します。これが十分でない場合は、STUNパケットにFINGERPRINT値を含めることもできます。この値を使用して、パケットをさらに区別することができます。"
    },
    {
      "indent": 3,
      "text": "STUN defines a set of optional procedures that a usage can decide to use, called \"mechanisms\". These mechanisms include DNS discovery, a redirection technique to an alternate server, a fingerprint attribute for demultiplexing, and two authentication and message-integrity exchanges. The authentication mechanisms revolve around the use of a username, password, and message-integrity value. Two authentication mechanisms, the long-term credential mechanism and the short-term credential mechanism, are defined in this specification. Each usage specifies the mechanisms allowed with that usage.",
      "ja": "STUNは、「メカニズム」と呼ばれる、使用法が使用を決定できるオプションの手順のセットを定義します。これらのメカニズムには、DNS検出、代替サーバーへのリダイレクト技術、逆多重化のためのフィンガープリント属性、および2つの認証とメッセージ整合性の交換が含まれます。認証メカニズムは、ユーザー名、パスワード、およびメッセージ整合性値の使用を中心に展開されます。この仕様では、長期認証メカニズムと短期認証メカニズムの2つの認証メカニズムが定義されています。各使用法は、その使用法で許可されるメカニズムを指定します。"
    },
    {
      "indent": 3,
      "text": "In the long-term credential mechanism, the client and server share a pre-provisioned username and password and perform a digest challenge/ response exchange inspired by the one defined for HTTP [RFC7616] but differing in details. In the short-term credential mechanism, the client and the server exchange a username and password through some out-of-band method prior to the STUN exchange. For example, in the ICE usage [RFC8445], the two endpoints use out-of-band signaling to exchange a username and password. These are used to integrity protect and authenticate the request and response. There is no challenge or nonce used.",
      "ja": "長期的な資格情報メカニズムでは、クライアントとサーバーは事前にプロビジョニングされたユーザー名とパスワードを共有し、HTTP [RFC7616]で定義されているものに触発された、詳細が異なるダイジェストチャレンジ/レスポンス交換を実行します。短期的な資格情報メカニズムでは、クライアントとサーバーは、STUN交換の前に、帯域外の方法でユーザー名とパスワードを交換します。たとえば、ICEの使用法[RFC8445]では、2つのエンドポイントが帯域外信号方式を使用してユーザー名とパスワードを交換します。これらは、要求と応答の完全性を保護し、認証するために使用されます。チャレンジやナンスは使用されていません。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すように、すべて大文字で表示される場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "4. Definitions",
      "section_title": true,
      "ja": "4. 定義"
    },
    {
      "indent": 3,
      "text": "STUN Agent: A STUN agent is an entity that implements the STUN protocol. The entity can be either a STUN client or a STUN server.",
      "ja": "STUNエージェント：STUNエージェントは、STUNプロトコルを実装するエンティティです。エンティティは、STUNクライアントまたはSTUNサーバーのいずれかです。"
    },
    {
      "indent": 3,
      "text": "STUN Client: A STUN client is an entity that sends STUN requests and receives STUN responses and STUN indications. A STUN client can also send indications. In this specification, the terms \"STUN client\" and \"client\" are synonymous.",
      "ja": "STUNクライアント：STUNクライアントは、STUN要求を送信し、STUN応答とSTUN指示を受信するエンティティです。STUNクライアントは表示を送信することもできます。この仕様では、「STUNクライアント」と「クライアント」という用語は同義語です。"
    },
    {
      "indent": 3,
      "text": "STUN Server: A STUN server is an entity that receives STUN requests and STUN indications and that sends STUN responses. A STUN server can also send indications. In this specification, the terms \"STUN server\" and \"server\" are synonymous.",
      "ja": "STUNサーバー：STUNサーバーは、STUN要求とSTUN指示を受信し、STUN応答を送信するエンティティです。STUNサーバーは表示を送信することもできます。この仕様では、「STUNサーバー」と「サーバー」という用語は同義語です。"
    },
    {
      "indent": 3,
      "text": "Transport Address: The combination of an IP address and port number (such as a UDP or TCP port number).",
      "ja": "トランスポートアドレス：IPアドレスとポート番号（UDPまたはTCPポート番号など）の組み合わせ。"
    },
    {
      "indent": 3,
      "text": "Reflexive Transport Address: A transport address learned by a client that identifies that client as seen by another host on an IP network, typically a STUN server. When there is an intervening NAT between the client and the other host, the reflexive transport address represents the mapped address allocated to the client on the public side of the NAT. Reflexive transport addresses are learned from the mapped address attribute (MAPPED-ADDRESS or XOR-MAPPED-ADDRESS) in STUN responses.",
      "ja": "反射トランスポートアドレス：IPネットワーク上の別のホスト（通常はSTUNサーバー）から見たクライアントを識別する、クライアントによって学習されたトランスポートアドレス。クライアントと他のホストの間にNATが介在している場合、反射トランスポートアドレスは、NATのパブリック側でクライアントに割り当てられたマップアドレスを表します。反射トランスポートアドレスは、STUN応答のマップされたアドレス属性（MAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS）から学習されます。"
    },
    {
      "indent": 3,
      "text": "Mapped Address: Same meaning as reflexive address. This term is retained only for historic reasons and due to the naming of the MAPPED-ADDRESS and XOR-MAPPED-ADDRESS attributes.",
      "ja": "マップされたアドレス：反射アドレスと同じ意味です。この用語は、歴史的な理由と、MAPPED-ADDRESS属性およびXOR-MAPPED-ADDRESS属性の命名のためにのみ保持されます。"
    },
    {
      "indent": 3,
      "text": "Long-Term Credential: A username and associated password that represent a shared secret between client and server. Long-term credentials are generally granted to the client when a subscriber enrolls in a service and persist until the subscriber leaves the service or explicitly changes the credential.",
      "ja": "長期資格情報：クライアントとサーバー間の共有シークレットを表すユーザー名と関連するパスワード。長期的な資格情報は通常、サブスクライバーがサービスに登録するときにクライアントに付与され、サブスクライバーがサービスを終了するか、資格情報を明示的に変更するまで存続します。"
    },
    {
      "indent": 3,
      "text": "Long-Term Password: The password from a long-term credential.",
      "ja": "長期パスワード：長期資格情報からのパスワード。"
    },
    {
      "indent": 3,
      "text": "Short-Term Credential: A temporary username and associated password that represent a shared secret between client and server. Short-term credentials are obtained through some kind of protocol mechanism between the client and server, preceding the STUN exchange. A short-term credential has an explicit temporal scope, which may be based on a specific amount of time (such as 5 minutes) or on an event (such as termination of a Session Initiation Protocol (SIP) [RFC3261] dialog). The specific scope of a short-term credential is defined by the application usage.",
      "ja": "短期資格情報：クライアントとサーバー間の共有シークレットを表す一時的なユーザー名と関連するパスワード。短期間の資格情報は、STUN交換に先立って、クライアントとサーバー間のある種のプロトコルメカニズムを通じて取得されます。短期資格情報には明示的な時間範囲があり、特定の時間（5分など）またはイベント（Session Initiation Protocol（SIP）[RFC3261]ダイアログの終了など）に基づく場合があります。短期資格の特定の範囲は、アプリケーションの使用法によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Short-Term Password: The password component of a short-term credential.",
      "ja": "短期パスワード：短期資格情報のパスワードコンポーネント。"
    },
    {
      "indent": 3,
      "text": "STUN Indication: A STUN message that does not receive a response.",
      "ja": "STUNインジケーション：応答を受信しないSTUNメッセージ。"
    },
    {
      "indent": 3,
      "text": "Attribute: The STUN term for a Type-Length-Value (TLV) object that can be added to a STUN message. Attributes are divided into two types: comprehension-required and comprehension-optional. STUN agents can safely ignore comprehension-optional attributes they don't understand but cannot successfully process a message if it contains comprehension-required attributes that are not understood.",
      "ja": "属性：STUNメッセージに追加できるType-Length-Value（TLV）オブジェクトのSTUN用語。属性は、理解必須と理解オプションの2つのタイプに分けられます。STUNエージェントは、理解できないオプションの属性を安全に無視できますが、理解が必要な属性が理解されていない場合、メッセージを正常に処理できません。"
    },
    {
      "indent": 3,
      "text": "RTO: Retransmission TimeOut, which defines the initial period of time between transmission of a request and the first retransmit of that request.",
      "ja": "RTO：再送信タイムアウト。要求の送信からその要求の最初の再送信までの初期期間を定義します。"
    },
    {
      "indent": 0,
      "text": "5. STUN Message Structure",
      "section_title": true,
      "ja": "5. STUNメッセージ構造"
    },
    {
      "indent": 3,
      "text": "STUN messages are encoded in binary using network-oriented format (most significant byte or octet first, also commonly known as big-endian). The transmission order is described in detail in Appendix B of [RFC0791]. Unless otherwise noted, numeric constants are in decimal (base 10).",
      "ja": "STUNメッセージは、ネットワーク指向の形式（最上位バイトまたはオクテットが最初、一般にビッグエンディアンとも呼ばれます）を使用してバイナリでエンコードされます。送信順序については、[RFC0791]の付録Bで詳しく説明されています。特に明記されていない限り、数値定数は10進数（基数10）です。"
    },
    {
      "indent": 3,
      "text": "All STUN messages comprise a 20-byte header followed by zero or more attributes. The STUN header contains a STUN message type, message length, magic cookie, and transaction ID.",
      "ja": "すべてのSTUNメッセージは、20バイトのヘッダーとそれに続く0個以上の属性で構成されます。STUNヘッダーには、STUNメッセージタイプ、メッセージ長、マジックCookie、およびトランザクションIDが含まれています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0|     STUN Message Type     |         Message Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Magic Cookie                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                     Transaction ID (96 bits)                  |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 2: Format of STUN Message Header",
      "ja": "図2：STUNメッセージヘッダーの形式"
    },
    {
      "indent": 3,
      "text": "The most significant 2 bits of every STUN message MUST be zeroes. This can be used to differentiate STUN packets from other protocols when STUN is multiplexed with other protocols on the same port.",
      "ja": "すべてのSTUNメッセージの最上位2ビットはゼロでなければなりません。これは、STUNが同じポートで他のプロトコルと多重化されている場合に、STUNパケットを他のプロトコルと区別するために使用できます。"
    },
    {
      "indent": 3,
      "text": "The message type defines the message class (request, success response, error response, or indication) and the message method (the primary function) of the STUN message. Although there are four message classes, there are only two types of transactions in STUN: request/response transactions (which consist of a request message and a response message) and indication transactions (which consist of a single indication message). Response classes are split into error and success responses to aid in quickly processing the STUN message.",
      "ja": "メッセージタイプは、STUNメッセージのメッセージクラス（要求、成功応答、エラー応答、または指示）とメッセージメソッド（主な機能）を定義します。メッセージクラスは4つありますが、STUNには、要求/応答トランザクション（要求メッセージと応答メッセージで構成される）と指示トランザクション（単一の指示メッセージで構成される）の2種類のトランザクションしかありません。応答クラスは、STUNメッセージの迅速な処理を支援するために、エラー応答と成功応答に分割されます。"
    },
    {
      "indent": 3,
      "text": "The STUN Message Type field is decomposed further into the following structure:",
      "ja": "STUNメッセージタイプフィールドは、さらに次の構造に分解されます。"
    },
    {
      "indent": 22,
      "text": " 0                 1\n 2  3  4 5 6 7 8 9 0 1 2 3 4 5\n+--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n|M |M |M|M|M|C|M|M|M|C|M|M|M|M|\n|11|10|9|8|7|1|6|5|4|0|3|2|1|0|\n+--+--+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 3: Format of STUN Message Type Field",
      "ja": "図3：STUNメッセージタイプフィールドのフォーマット"
    },
    {
      "indent": 3,
      "text": "Here the bits in the STUN Message Type field are shown as most significant (M11) through least significant (M0). M11 through M0 represent a 12-bit encoding of the method. C1 and C0 represent a 2-bit encoding of the class. A class of 0b00 is a request, a class of 0b01 is an indication, a class of 0b10 is a success response, and a class of 0b11 is an error response. This specification defines a single method, Binding. The method and class are orthogonal, so that for each method, a request, success response, error response, and indication are possible for that method. Extensions defining new methods MUST indicate which classes are permitted for that method.",
      "ja": "ここでは、STUNメッセージタイプフィールドのビットが最上位（M11）から最下位（M0）として表示されます。M11からM0は、メソッドの12ビットエンコーディングを表します。C1とC0は、クラスの2ビットエンコーディングを表します。0b00のクラスは要求、0b01のクラスは指示、0b10のクラスは成功応答、0b11のクラスはエラー応答です。この仕様では、Bindingという単一のメソッドを定義しています。メソッドとクラスは直交しているため、メソッドごとに、そのメソッドの要求、成功応答、エラー応答、および指示が可能です。新しいメソッドを定義する拡張機能は、そのメソッドで許可されるクラスを示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, a Binding request has class=0b00 (request) and method=0b000000000001 (Binding) and is encoded into the first 16 bits as 0x0001. A Binding response has class=0b10 (success response) and method=0b000000000001 and is encoded into the first 16 bits as 0x0101.",
      "ja": "たとえば、バインディングリクエストにはclass = 0b00（リクエスト）とmethod = 0b000000000001（バインディング）があり、最初の16ビットに0x0001としてエンコードされます。バインディング応答には、class = 0b10（成功応答）とmethod = 0b000000000001があり、最初の16ビットに0x0101としてエンコードされます。"
    },
    {
      "indent": 6,
      "text": "Note: This unfortunate encoding is due to assignment of values in [RFC3489] that did not consider encoding indication messages, success responses, and errors responses using bit fields.",
      "ja": "注：この不幸なエンコードは、ビットフィールドを使用したインジケーションメッセージ、成功応答、およびエラー応答のエンコードを考慮しなかった[RFC3489]の値の割り当てによるものです。"
    },
    {
      "indent": 3,
      "text": "The Magic Cookie field MUST contain the fixed value 0x2112A442 in network byte order. In [RFC3489], the 32 bits comprising the Magic Cookie field were part of the transaction ID; placing the magic cookie in this location allows a server to detect if the client will understand certain attributes that were added to STUN by [RFC5389]. In addition, it aids in distinguishing STUN packets from packets of other protocols when STUN is multiplexed with those other protocols on the same port.",
      "ja": "マジッククッキーフィールドには、ネットワークバイトオーダーの固定値0x2112A442が含まれている必要があります。[RFC3489]では、MagicCookieフィールドを構成する32ビットがトランザクションIDの一部でした。マジッククッキーをこの場所に配置すると、サーバーは、クライアントが[RFC5389]によってSTUNに追加された特定の属性を理解するかどうかを検出できます。さらに、STUNが同じポートで他のプロトコルと多重化されている場合、STUNパケットを他のプロトコルのパケットと区別するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": " The transaction ID is a 96-bit identifier, used to uniquely identify STUN transactions. For request/response transactions, the transaction ID is chosen by the STUN client for the request and echoed by the server in the response. For indications, it is chosen by the agent sending the indication. It primarily serves to correlate requests with responses, though it also plays a small role in helping to prevent certain types of attacks. The server also uses the transaction ID as a key to identify each transaction uniquely across all clients. As such, the transaction ID MUST be uniformly and randomly chosen from the interval 0 .. 2**96-1 and MUST be cryptographically random. Resends of the same request reuse the same transaction ID, but the client MUST choose a new transaction ID for new transactions unless the new request is bit-wise identical to the previous request and sent from the same transport address to the same IP address. Success and error responses MUST carry the same transaction ID as their corresponding request. When an agent is acting as a STUN server and STUN client on the same port, the transaction IDs in requests sent by the agent have no relationship to the transaction IDs in requests received by the agent.",
      "ja": "トランザクションIDは96ビットの識別子であり、STUNトランザクションを一意に識別するために使用されます。要求/応答トランザクションの場合、トランザクションIDは、要求に対してSTUNクライアントによって選択され、サーバーによって応答でエコーされます。インジケーションについては、インジケーションを送信するエージェントによって選択されます。これは主に要求と応答を関連付けるのに役立ちますが、特定の種類の攻撃を防ぐのに役立つ小さな役割も果たします。サーバーはまた、トランザクションIDをキーとして使用して、すべてのクライアント間で各トランザクションを一意に識別します。そのため、トランザクションIDは、間隔0 .. 2 ** 96-1から均一かつランダムに選択する必要があり、暗号的にランダムである必要があります。同じリクエストの再送信は同じトランザクションIDを再利用しますが、新しいリクエストが前のリクエストとビット単位で同一であり、同じトランスポートアドレスから同じIPアドレスに送信されない限り、クライアントは新しいトランザクションに対して新しいトランザクションIDを選択する必要があります。成功とエラーの応答は、対応する要求と同じトランザクションIDを持っている必要があります。エージェントが同じポートでSTUNサーバーとSTUNクライアントとして機能している場合、エージェントによって送信された要求のトランザクションIDは、エージェントによって受信された要求のトランザクションIDとは関係がありません。"
    },
    {
      "indent": 3,
      "text": "The message length MUST contain the size of the message in bytes, not including the 20-byte STUN header. Since all STUN attributes are padded to a multiple of 4 bytes, the last 2 bits of this field are always zero. This provides another way to distinguish STUN packets from packets of other protocols.",
      "ja": "メッセージの長さには、20バイトのSTUNヘッダーを含まない、バイト単位のメッセージのサイズが含まれている必要があります。すべてのSTUN属性は4バイトの倍数に埋め込まれるため、このフィールドの最後の2ビットは常にゼロです。これは、STUNパケットを他のプロトコルのパケットから区別する別の方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Following the STUN fixed portion of the header are zero or more attributes. Each attribute is TLV (Type-Length-Value) encoded. Details of the encoding and the attributes themselves are given in Section 14.",
      "ja": "ヘッダーのSTUN固定部分に続くのは、0個以上の属性です。各属性はTLV（Type-Length-Value）でエンコードされています。エンコーディングと属性自体の詳細はセクション14に記載されています。"
    },
    {
      "indent": 0,
      "text": "6. Base Protocol Procedures",
      "section_title": true,
      "ja": "6. 基本プロトコル手順"
    },
    {
      "indent": 3,
      "text": "This section defines the base procedures of the STUN protocol. It describes how messages are formed, how they are sent, and how they are processed when they are received. It also defines the detailed processing of the Binding method. Other sections in this document describe optional procedures that a usage may elect to use in certain situations. Other documents may define other extensions to STUN, by adding new methods, new attributes, or new error response codes.",
      "ja": "このセクションでは、STUNプロトコルの基本手順を定義します。メッセージの形成方法、送信方法、および受信時の処理方法について説明します。また、Bindingメソッドの詳細な処理も定義します。このドキュメントの他のセクションでは、特定の状況で使用法が使用することを選択できるオプションの手順について説明します。他のドキュメントでは、新しいメソッド、新しい属性、または新しいエラー応答コードを追加することにより、STUNに他の拡張機能を定義できます。"
    },
    {
      "indent": 0,
      "text": "6.1. Forming a Request or an Indication",
      "section_title": true,
      "ja": "6.1. 要求または表示の形成"
    },
    {
      "indent": 3,
      "text": "When formulating a request or indication message, the agent MUST follow the rules in Section 5 when creating the header. In addition, the message class MUST be either \"Request\" or \"Indication\" (as appropriate), and the method must be either Binding or some method defined in another document.",
      "ja": "要求または指示メッセージを作成する場合、エージェントはヘッダーを作成するときにセクション5の規則に従わなければなりません。さらに、メッセージクラスは「Request」または「Indication」（必要に応じて）のいずれかである必要があり、メソッドはBindingまたは別のドキュメントで定義されているメソッドのいずれかである必要があります。"
    },
    {
      "indent": 3,
      "text": "The agent then adds any attributes specified by the method or the usage. For example, some usages may specify that the agent use an authentication method (Section 9) or the FINGERPRINT attribute (Section 7).",
      "ja": "次に、エージェントは、メソッドまたは使用法で指定された属性を追加します。たとえば、一部の使用法では、エージェントが認証方法（セクション9）またはFINGERPRINT属性（セクション7）を使用するように指定する場合があります。"
    },
    {
      "indent": 3,
      "text": "If the agent is sending a request, it SHOULD add a SOFTWARE attribute to the request. Agents MAY include a SOFTWARE attribute in indications, depending on the method. Extensions to STUN should discuss whether SOFTWARE is useful in new indications. Note that the inclusion of a SOFTWARE attribute may have security implications; see Section 16.1.2 for details.",
      "ja": "エージェントがリクエストを送信している場合は、リクエストにSOFTWARE属性を追加する必要があります。エージェントは、方法に応じて、インジケーションにSOFTWARE属性を含めることができます。STUNの拡張機能では、ソフトウェアが新しいインジケーションに役立つかどうかについて話し合う必要があります。SOFTWARE属性を含めると、セキュリティに影響する可能性があることに注意してください。詳細については、セクション16.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "For the Binding method with no authentication, no attributes are required unless the usage specifies otherwise.",
      "ja": "認証のないBindingメソッドの場合、使用法で特に指定されていない限り、属性は必要ありません。"
    },
    {
      "indent": 3,
      "text": "All STUN messages sent over UDP or DTLS-over-UDP [RFC6347] SHOULD be less than the path MTU, if known.",
      "ja": "UDPまたはDTLS-over-UDP [RFC6347]を介して送信されるすべてのSTUNメッセージは、既知の場合、パスMTUよりも小さい必要があります。"
    },
    {
      "indent": 3,
      "text": "If the path MTU is unknown for UDP, messages SHOULD be the smaller of 576 bytes and the first-hop MTU for IPv4 [RFC1122] and 1280 bytes for IPv6 [RFC8200]. This value corresponds to the overall size of the IP packet. Consequently, for IPv4, the actual STUN message would need to be less than 548 bytes (576 minus 20-byte IP header, minus 8-byte UDP header, assuming no IP options are used).",
      "ja": "UDPのパスMTUが不明な場合、メッセージは、IPv4 [RFC1122]の場合は576バイトとファーストホップMTUの小さい方、IPv6 [RFC8200]の場合は1280バイトである必要があります。この値は、IPパケットの全体的なサイズに対応します。したがって、IPv4の場合、実際のSTUNメッセージは548バイト未満である必要があります（IPオプションが使用されていない場合、576から20バイトのIPヘッダー、8バイトのUDPヘッダーを引いたもの）。"
    },
    {
      "indent": 3,
      "text": "If the path MTU is unknown for DTLS-over-UDP, the rules described in the previous paragraph need to be adjusted to take into account the size of the (13-byte) DTLS Record header, the Message Authentication Code (MAC) size, and the padding size.",
      "ja": "DTLS-over-UDPのパスMTUが不明な場合は、前の段落で説明したルールを調整して、（13バイトの）DTLSレコードヘッダーのサイズ、メッセージ認証コード（MAC）のサイズ、およびパディングサイズを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "STUN provides no ability to handle the case where the request is smaller than the MTU but the response is larger than the MTU. It is not envisioned that this limitation will be an issue for STUN. The MTU limitation is a SHOULD, not a MUST, to account for cases where STUN itself is being used to probe for MTU characteristics [RFC5780]. See also [STUN-PMTUD] for a framework that uses STUN to add Path MTU Discovery to protocols that lack such a mechanism. Outside of this or similar applications, the MTU constraint MUST be followed.",
      "ja": "STUNは、要求がMTUよりも小さいが、応答がMTUよりも大きい場合を処理する機能を提供しません。この制限がSTUNの問題になるとは想定されていません。MTUの制限は、STUN自体がMTU特性のプローブに使用されている場合を説明するために必須ではなくSHOULDです[RFC5780]。STUNを使用して、このようなメカニズムがないプロトコルにPath MTU Discoveryを追加するフレームワークについては、[STUN-PMTUD]も参照してください。このアプリケーションまたは同様のアプリケーション以外では、MTU制約に従う必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Sending the Request or Indication",
      "section_title": true,
      "ja": "6.2. リクエストまたは表示の送信"
    },
    {
      "indent": 3,
      "text": "The agent then sends the request or indication. This document specifies how to send STUN messages over UDP, TCP, TLS-over-TCP, or DTLS-over-UDP; other transport protocols may be added in the future. The STUN Usage must specify which transport protocol is used and how the agent determines the IP address and port of the recipient. Section 8 describes a DNS-based method of determining the IP address and port of a server that a usage may elect to use.",
      "ja": "次に、エージェントは要求または指示を送信します。このドキュメントでは、UDP、TCP、TLS-over-TCP、またはDTLS-over-UDPを介してSTUNメッセージを送信する方法を指定します。将来、他のトランスポートプロトコルが追加される可能性があります。STUNの使用法では、使用するトランスポートプロトコルと、エージェントが受信者のIPアドレスとポートを決定する方法を指定する必要があります。セクション8では、使用法が使用することを選択できるサーバーのIPアドレスとポートを決定するDNSベースの方法について説明します。"
    },
    {
      "indent": 0,
      "text": " At any time, a client MAY have multiple outstanding STUN requests with the same STUN server (that is, multiple transactions in progress, with different transaction IDs). Absent other limits to the rate of new transactions (such as those specified by ICE for connectivity checks or when STUN is run over TCP), a client SHOULD limit itself to ten outstanding transactions to the same server.",
      "ja": "クライアントはいつでも、同じSTUNサーバーで複数の未処理のSTUN要求を持っている可能性があります（つまり、異なるトランザクションIDで進行中の複数のトランザクション）。新しいトランザクションのレートに他の制限がない場合（接続チェックのためにICEによって指定されたものや、STUNがTCPで実行される場合など）、クライアントは同じサーバーへの未処理のトランザクションを10個に制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Sending over UDP or DTLS-over-UDP",
      "section_title": true,
      "ja": "6.2.1. UDPまたはDTLS-over-UDPを介した送信"
    },
    {
      "indent": 3,
      "text": "When running STUN over UDP or STUN over DTLS-over-UDP [RFC7350], it is possible that the STUN message might be dropped by the network. Reliability of STUN request/response transactions is accomplished through retransmissions of the request message by the client application itself. STUN indications are not retransmitted; thus, indication transactions over UDP or DTLS-over-UDP are not reliable.",
      "ja": "STUN overUDPまたはSTUNover DTLS-over-UDP [RFC7350]を実行している場合、STUNメッセージがネットワークによってドロップされる可能性があります。STUN要求/応答トランザクションの信頼性は、クライアントアプリケーション自体による要求メッセージの再送信によって実現されます。STUNインジケーションは再送信されません。したがって、UDPまたはDTLS-over-UDPを介したインジケーショントランザクションは信頼できません。"
    },
    {
      "indent": 3,
      "text": "A client SHOULD retransmit a STUN request message starting with an interval of RTO (\"Retransmission TimeOut\"), doubling after each retransmission. The RTO is an estimate of the round-trip time (RTT) and is computed as described in [RFC6298], with two exceptions. First, the initial value for RTO SHOULD be greater than or equal to 500 ms. The exception cases for this \"SHOULD\" are when other mechanisms are used to derive congestion thresholds (such as the ones defined in ICE for fixed-rate streams) or when STUN is used in non-Internet environments with known network capacities. In fixed-line access links, a value of 500 ms is RECOMMENDED. Second, the value of RTO SHOULD NOT be rounded up to the nearest second. Rather, a 1 ms accuracy SHOULD be maintained. As with TCP, the usage of Karn's algorithm is RECOMMENDED [KARN87]. When applied to STUN, it means that RTT estimates SHOULD NOT be computed from STUN transactions that result in the retransmission of a request.",
      "ja": "クライアントは、RTOの間隔（「再送信タイムアウト」）で始まるSTUN要求メッセージを再送信する必要があり、再送信のたびに2倍になります。RTOは、ラウンドトリップ時間（RTT）の見積もりであり、2つの例外を除いて、[RFC6298]で説明されているように計算されます。まず、RTOの初期値は500ミリ秒以上である必要があります。この「SHOULD」の例外的なケースは、他のメカニズムを使用して輻輳しきい値を導出する場合（固定レートストリームのICEで定義されているメカニズムなど）、または既知のネットワーク容量を持つ非インターネット環境でSTUNを使用する場合です。固定回線アクセスリンクでは、500ミリ秒の値をお勧めします。次に、RTOの値を最も近い秒に切り上げるべきではありません。むしろ、1ミリ秒の精度を維持する必要があります。TCPと同様に、カーンのアルゴリズムの使用が推奨されます[KARN87]。STUNに適用される場合、RTT見積もりは、要求の再送信をもたらすSTUNトランザクションから計算されるべきではないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The value for RTO SHOULD be cached by a client after the completion of the transaction and used as the starting value for RTO for the next transaction to the same server (based on equality of IP address). The value SHOULD be considered stale and discarded if no transactions have occurred to the same server in the last 10 minutes.",
      "ja": "RTOの値は、トランザクションの完了後にクライアントによってキャッシュされ、同じサーバーへの次のトランザクションのRTOの開始値として使用される必要があります（IPアドレスの同等性に基づく）。過去10分間に同じサーバーに対してトランザクションが発生しなかった場合、値は古くなったと見なされ、破棄される必要があります。"
    },
    {
      "indent": 3,
      "text": "Retransmissions continue until a response is received or until a total of Rc requests have been sent. Rc SHOULD be configurable and SHOULD have a default of 7. If, after the last request, a duration equal to Rm times the RTO has passed without a response (providing ample time to get a response if only this final request actually succeeds), the client SHOULD consider the transaction to have failed. Rm SHOULD be configurable and SHOULD have a default of 16. A STUN transaction over UDP or DTLS-over-UDP is also considered failed if there has been a hard ICMP error [RFC1122]. For example, assuming an RTO of 500 ms, requests would be sent at times 0 ms, 500 ms, 1500 ms, 3500 ms, 7500 ms, 15500 ms, and 31500 ms. If the client has not received a response after 39500 ms, the client will consider the transaction to have timed out.",
      "ja": "再送信は、応答が受信されるまで、または合計Rc要求が送信されるまで続きます。Rcは構成可能である必要があり、デフォルトは7である必要があります。最後の要求の後、Rm × RTO に等しい期間が応答なしで経過した場合（この最後の要求のみが実際に成功した場合に応答を取得するための十分な時間を提供する）、クライアントは、トランザクションが失敗したと見なす必要があります。Rmは構成可能である必要があり、デフォルトは16である必要があります。ハードICMPエラーが発生した場合、UDPまたはDTLS-over-UDPを介したSTUNトランザクションも失敗したと見なされます[RFC1122]。たとえば、RTOが500ミリ秒であると仮定すると、要求は0ミリ秒、500ミリ秒、1500ミリ秒、3500ミリ秒、7500ミリ秒、15500ミリ秒、および31500ミリ秒の時間に送信されます。クライアントが39500ミリ秒後に応答を受信しなかった場合、クライアントはトランザクションがタイムアウトしたと見なします。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Sending over TCP or TLS-over-TCP",
      "section_title": true,
      "ja": "6.2.2. TCPまたはTLS-over-TCPを介した送信"
    },
    {
      "indent": 3,
      "text": "For TCP and TLS-over-TCP [RFC8446], the client opens a TCP connection to the server.",
      "ja": "TCPおよびTLS-over-TCP [RFC8446]の場合、クライアントはサーバーへのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "In some usages of STUN, STUN is the only protocol over the TCP connection. In this case, it can be sent without the aid of any additional framing or demultiplexing. In other usages, or with other extensions, it may be multiplexed with other data over a TCP connection. In that case, STUN MUST be run on top of some kind of framing protocol, specified by the usage or extension, which allows for the agent to extract complete STUN messages and complete application-layer messages. The STUN service running on the well-known port or ports discovered through the DNS procedures in Section 8 is for STUN alone, and not for STUN multiplexed with other data. Consequently, no framing protocols are used in connections to those servers. When additional framing is utilized, the usage will specify how the client knows to apply it and what port to connect to. For example, in the case of ICE connectivity checks, this information is learned through out-of-band negotiation between client and server.",
      "ja": "STUNの一部の使用法では、STUNがTCP接続を介した唯一のプロトコルです。この場合、追加のフレーミングや逆多重化を使用せずに送信できます。他の使用法では、または他の拡張機能を使用すると、TCP接続を介して他のデータと多重化される場合があります。その場合、STUNは、使用法または拡張機能によって指定された、ある種のフレーミングプロトコル上で実行する必要があります。これにより、エージェントは完全なSTUNメッセージと完全なアプリケーション層メッセージを抽出できます。セクション8のDNS手順で検出された1つまたは複数の既知のポートで実行されているSTUNサービスは、STUNのみを対象としており、他のデータと多重化されたSTUNを対象としていません。したがって、これらのサーバーへの接続にはフレーミングプロトコルは使用されません。追加のフレーミングを使用する場合、使用法は、クライアントがそれを適用する方法と接続するポートを指定します。たとえば、ICE接続チェックの場合、この情報はクライアントとサーバー間の帯域外ネゴシエーションを通じて学習されます。"
    },
    {
      "indent": 3,
      "text": "Reliability of STUN over TCP and TLS-over-TCP is handled by TCP itself, and there are no retransmissions at the STUN protocol level. However, for a request/response transaction, if the client has not received a response by Ti seconds after it sent the request message, it considers the transaction to have timed out. Ti SHOULD be configurable and SHOULD have a default of 39.5 s. This value has been chosen to equalize the TCP and UDP timeouts for the default initial RTO.",
      "ja": "STUN over TCPおよびTLS-over-TCPの信頼性は、TCP自体によって処理され、STUNプロトコルレベルでの再送信はありません。ただし、要求/応答トランザクションの場合、クライアントが要求メッセージを送信してからTi秒以内に応答を受信しなかった場合、クライアントはトランザクションがタイムアウトしたと見なします。Tiは構成可能である必要があり、デフォルトは39.5秒である必要があります。この値は、デフォルトの初期RTOのTCPタイムアウトとUDPタイムアウトを等しくするために選択されています。"
    },
    {
      "indent": 3,
      "text": "In addition, if the client is unable to establish the TCP connection, or the TCP connection is reset or fails before a response is received, any request/response transaction in progress is considered to have failed.",
      "ja": "さらに、クライアントがTCP接続を確立できない場合、またはTCP接続がリセットされるか、応答を受信する前に失敗した場合、進行中の要求/応答トランザクションは失敗したと見なされます。"
    },
    {
      "indent": 3,
      "text": "The client MAY send multiple transactions over a single TCP (or TLS-over-TCP) connection, and it MAY send another request before receiving a response to the previous request. The client SHOULD keep the connection open until it:",
      "ja": "クライアントは、単一のTCP（またはTLS-over-TCP）接続を介して複数のトランザクションを送信できます。また、前の要求への応答を受信する前に、別の要求を送信できます。クライアントは、次の状態になるまで接続を開いたままにしておく必要があります。"
    },
    {
      "indent": 3,
      "text": "o has no further STUN requests or indications to send over that connection,",
      "ja": "o その接続を介して送信するSTUN要求または指示はこれ以上ありません。"
    },
    {
      "indent": 3,
      "text": "o has no plans to use any resources (such as a mapped address (MAPPED-ADDRESS or XOR-MAPPED-ADDRESS) or relayed address [RFC5766]) that were learned though STUN requests sent over that connection,",
      "ja": "o その接続を介して送信されたSTUN要求を通じて学習されたリソース（マップされたアドレス（MAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS）またはリレーされたアドレス[RFC5766]など）を使用する予定はありません。"
    },
    {
      "indent": 3,
      "text": "o if multiplexing other application protocols over that port, has finished using those other protocols,",
      "ja": "o そのポートを介して他のアプリケーションプロトコルを多重化する場合、それらの他のプロトコルの使用を終了し、"
    },
    {
      "indent": 3,
      "text": "o if using that learned port with a remote peer, has established communications with that remote peer, as is required by some TCP NAT traversal techniques (e.g., [RFC6544]).",
      "ja": "o 学習したポートをリモートピアで使用している場合、一部のTCP NATトラバーサル技術（[RFC6544]など）で必要とされるように、そのリモートピアとの通信を確立しています。"
    },
    {
      "indent": 3,
      "text": "The details of an eventual keep-alive mechanism are left to each STUN Usage. In any case, if a transaction fails because an idle TCP connection doesn't work anymore, the client SHOULD send a RST and try to open a new TCP connection.",
      "ja": "最終的なキープアライブメカニズムの詳細は、各STUNの使用法に任されています。いずれにせよ、アイドル状態のTCP接続が機能しなくなったためにトランザクションが失敗した場合、クライアントはRSTを送信して、新しいTCP接続を開こうとする必要があります。"
    },
    {
      "indent": 3,
      "text": "At the server end, the server SHOULD keep the connection open and let the client close it, unless the server has determined that the connection has timed out (for example, due to the client disconnecting from the network). Bindings learned by the client will remain valid in intervening NATs only while the connection remains open. Only the client knows how long it needs the binding. The server SHOULD NOT close a connection if a request was received over that connection for which a response was not sent. A server MUST NOT ever open a connection back towards the client in order to send a response. Servers SHOULD follow best practices regarding connection management in cases of overload.",
      "ja": "サーバー側では、接続がタイムアウトしたとサーバーが判断しない限り（たとえば、クライアントがネットワークから切断されたため）、サーバーは接続を開いたままにして、クライアントに閉じさせる必要があります。クライアントによって学習されたバインディングは、接続が開いたままである間のみ、介在するNATで有効なままになります。バインディングが必要な期間を知っているのはクライアントだけです。応答が送信されなかった接続を介して要求が受信された場合、サーバーは接続を閉じてはなりません（SHOULDNOT）。サーバーは、応答を送信するためにクライアントへの接続を開いてはなりません。サーバーは、過負荷の場合の接続管理に関するベストプラクティスに従う必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Sending over TLS-over-TCP or DTLS-over-UDP",
      "section_title": true,
      "ja": "6.2.3. TLS-over-TCPまたはDTLS-over-UDPを介した送信"
    },
    {
      "indent": 3,
      "text": "When STUN is run by itself over TLS-over-TCP or DTLS-over-UDP, the TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 and TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ciphersuites MUST be implemented (for compatibility with older versions of this protocol), except if deprecated by rules of a specific STUN usage. Other ciphersuites MAY be implemented. Note that STUN clients and servers that implement TLS version 1.3 [RFC8446] or subsequent versions are also required to implement mandatory ciphersuites from those specifications and SHOULD disable usage of deprecated ciphersuites when they detect support for those specifications. Perfect Forward Secrecy (PFS) ciphersuites MUST be preferred over non-PFS ciphersuites. Ciphersuites with known weaknesses, such as those based on (single) DES and RC4, MUST NOT be used. Implementations MUST disable TLS-level compression.",
      "ja": "STUNがTLS-over-TCPまたはDTLS-over-UDPを介して単独で実行される場合、TLS_DHE_RSA_WITH_AES_128_GCM_SHA256およびTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256暗号スイートを実装する必要があります（このプロトコルの古いバージョンとの互換性のため）。他の暗号スイートが実装される場合があります。TLSバージョン1.3 [RFC8446]以降のバージョンを実装するSTUNクライアントおよびサーバーも、これらの仕様から必須の暗号スイートを実装する必要があり、これらの仕様のサポートを検出した場合は、非推奨の暗号スイートの使用を無効にする必要があります。Perfect Forward Secrecy（PFS）暗号スイートは、非PFS暗号スイートよりも優先されなければなりません（MUST）。（単一の）DESやRC4に基づくものなど、既知の弱点がある暗号スイートは使用しないでください。実装はTLSレベルの圧縮を無効にしなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "These recommendations are just a part of the recommendations in [BCP195] that implementations and deployments of a STUN Usage using TLS or DTLS MUST follow.",
      "ja": "これらの推奨事項は、TLSまたはDTLSを使用したSTUN使用法の実装と展開が従わなければならない[BCP195]の推奨事項のほんの一部です。"
    },
    {
      "indent": 0,
      "text": " When it receives the TLS Certificate message, the client MUST verify the certificate and inspect the site identified by the certificate. If the certificate is invalid or revoked, or if it does not identify the appropriate party, the client MUST NOT send the STUN message or otherwise proceed with the STUN transaction. The client MUST verify the identity of the server. To do that, it follows the identification procedures defined in [RFC6125], with a certificate containing an identifier of type DNS-ID or CN-ID, optionally with a wildcard character as the leftmost label, but not of type SRV-ID or URI-ID.",
      "ja": "TLS証明書メッセージを受信すると、クライアントは証明書を検証し、証明書によって識別されるサイトを検査する必要があります。証明書が無効または取り消されている場合、または適切な関係者を識別していない場合、クライアントはSTUNメッセージを送信したり、STUNトランザクションを続行したりしてはなりません。クライアントはサーバーのIDを確認する必要があります。これを行うには、[RFC6125]で定義されている識別手順に従い、DNS-IDまたはCN-IDタイプの識別子を含む証明書を使用します。オプションで、左端のラベルとしてワイルドカード文字を使用しますが、SRV-IDまたはURI-IDタイプは使用しません。"
    },
    {
      "indent": 3,
      "text": "When STUN is run multiplexed with other protocols over a TLS-over-TCP connection or a DTLS-over-UDP association, the mandatory ciphersuites and TLS handling procedures operate as defined by those protocols.",
      "ja": "STUNがTLS-over-TCP接続またはDTLS-over-UDPアソシエーションを介して他のプロトコルと多重化されて実行される場合、必須の暗号スイートとTLS処理手順はそれらのプロトコルで定義されているように動作します。"
    },
    {
      "indent": 0,
      "text": "6.3. Receiving a STUN Message",
      "section_title": true,
      "ja": "6.3. STUNメッセージを受信する"
    },
    {
      "indent": 3,
      "text": "This section specifies the processing of a STUN message. The processing specified here is for STUN messages as defined in this specification; additional rules for backwards compatibility are defined in Section 11. Those additional procedures are optional, and usages can elect to utilize them. First, a set of processing operations is applied that is independent of the class. This is followed by class-specific processing, described in the subsections that follow.",
      "ja": "このセクションでは、STUNメッセージの処理を指定します。ここで指定されている処理は、この仕様で定義されているSTUNメッセージ用です。下位互換性に関する追加のルールはセクション11で定義されています。これらの追加の手順はオプションであり、使用法はそれらを利用することを選択できます。最初に、クラスに依存しない一連の処理操作が適用されます。これに続いて、次のサブセクションで説明するクラス固有の処理が行われます。"
    },
    {
      "indent": 3,
      "text": "When a STUN agent receives a STUN message, it first checks that the message obeys the rules of Section 5. It checks that the first two bits are 0, that the Magic Cookie field has the correct value, that the message length is sensible, and that the method value is a supported method. It checks that the message class is allowed for the particular method. If the message class is \"Success Response\" or \"Error Response\", the agent checks that the transaction ID matches a transaction that is still in progress. If the FINGERPRINT extension is being used, the agent checks that the FINGERPRINT attribute is present and contains the correct value. If any errors are detected, the message is silently discarded. In the case when STUN is being multiplexed with another protocol, an error may indicate that this is not really a STUN message; in this case, the agent should try to parse the message as a different protocol.",
      "ja": "STUNエージェントはSTUNメッセージを受信すると、最初にメッセージがセクション5のルールに従っていることを確認します。最初の2ビットが0であること、Magic Cookieフィールドの値が正しいこと、メッセージの長さが適切であること、およびメソッド値がサポートされているメソッドであること。メッセージクラスが特定のメソッドで許可されていることを確認します。メッセージクラスが「SuccessResponse」または「ErrorResponse」の場合、エージェントはトランザクションIDがまだ進行中のトランザクションと一致することを確認します。FINGERPRINT拡張機能が使用されている場合、エージェントはFINGERPRINT属性が存在し、正しい値が含まれていることを確認します。エラーが検出された場合、メッセージはサイレントに破棄されます。STUNが別のプロトコルと多重化されている場合、エラーはこれが実際にはSTUNメッセージではないことを示している可能性があります。この場合、エージェントはメッセージを別のプロトコルとして解析しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "The STUN agent then does any checks that are required by a authentication mechanism that the usage has specified (see Section 9).",
      "ja": "次に、STUNエージェントは、使用法で指定された認証メカニズムに必要なチェックを実行します（セクション9を参照）。"
    },
    {
      "indent": 3,
      "text": "Once the authentication checks are done, the STUN agent checks for unknown attributes and known-but-unexpected attributes in the message. Unknown comprehension-optional attributes MUST be ignored by the agent. Known-but-unexpected attributes SHOULD be ignored by the agent. Unknown comprehension-required attributes cause processing that depends on the message class and is described below.",
      "ja": "認証チェックが完了すると、STUNエージェントは、メッセージ内の不明な属性と既知であるが予期しない属性をチェックします。不明な理解オプション属性は、エージェントが無視する必要があります。既知であるが予期しない属性は、エージェントによって無視されるべきです（SHOULD）。不明な理解必須属性は、メッセージクラスに依存する処理を引き起こします。これについては以下で説明します。"
    },
    {
      "indent": 3,
      "text": "At this point, further processing depends on the message class of the request.",
      "ja": "この時点で、以降の処理は要求のメッセージクラスによって異なります。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Processing a Request",
      "section_title": true,
      "ja": "6.3.1. リクエストの処理"
    },
    {
      "indent": 3,
      "text": "If the request contains one or more unknown comprehension-required attributes, the server replies with an error response with an error code of 420 (Unknown Attribute) and includes an UNKNOWN-ATTRIBUTES attribute in the response that lists the unknown comprehension-required attributes.",
      "ja": "要求に1つ以上の不明な理解必須属性が含まれている場合、サーバーはエラーコード420（不明な属性）のエラー応答で応答し、不明な理解必須属性をリストする応答にUNKNOWN-ATTRIBUTES属性を含めます。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the server then does any additional checking that the method or the specific usage requires. If all the checks succeed, the server formulates a success response as described below.",
      "ja": "それ以外の場合、サーバーは、メソッドまたは特定の使用法に必要な追加のチェックを実行します。すべてのチェックが成功すると、サーバーは以下に説明するように成功応答を作成します。"
    },
    {
      "indent": 3,
      "text": "When run over UDP or DTLS-over-UDP, a request received by the server could be the first request of a transaction or could be a retransmission. The server MUST respond to retransmissions such that the following property is preserved: if the client receives the response to the retransmission and not the response that was sent to the original request, the overall state on the client and server is identical to the case where only the response to the original retransmission is received or where both responses are received (in which case the client will use the first). The easiest way to meet this requirement is for the server to remember all transaction IDs received over UDP or DTLS-over-UDP and their corresponding responses in the last 40 seconds. However, this requires the server to hold state and is inappropriate for any requests that are not authenticated. Another way is to reprocess the request and recompute the response. The latter technique MUST only be applied to requests that are idempotent (a request is considered idempotent when the same request can be safely repeated without impacting the overall state of the system) and result in the same success response for the same request. The Binding method is considered to be idempotent. Note that there are certain rare network events that could cause the reflexive transport address value to change, resulting in a different mapped address in different success responses. Extensions to STUN MUST discuss the implications of request retransmissions on servers that do not store transaction state.",
      "ja": "UDPまたはDTLS-over-UDPを介して実行される場合、サーバーが受信した要求は、トランザクションの最初の要求であるか、再送信である可能性があります。サーバーは、次のプロパティが保持されるように再送信に応答する必要があります。クライアントが元の要求に送信された応答ではなく再送信への応答を受信した場合、クライアントとサーバーの全体的な状態は、次の場合のみと同じです。元の再送信への応答が受信されるか、両方の応答が受信される場所（この場合、クライアントは最初の応答を使用します）。この要件を満たす最も簡単な方法は、サーバーがUDPまたはDTLS-over-UDPを介して受信したすべてのトランザクションIDと、過去40秒間に対応する応答を記憶することです。ただし、これにはサーバーが状態を保持する必要があり、認証されていない要求には不適切です。もう1つの方法は、要求を再処理して応答を再計算することです。後者の手法は、べき等である要求にのみ適用する必要があり（システムの全体的な状態に影響を与えることなく同じ要求を安全に繰り返すことができる場合、要求はべき等と見なされます）、同じ要求に対して同じ成功応答が得られます。 Bindingメソッドはべき等であると見なされます。再帰トランスポートアドレス値が変更され、異なる成功応答で異なるマップアドレスが発生する可能性がある、特定のまれなネットワークイベントがあることに注意してください。 STUNの拡張機能では、トランザクション状態を格納しないサーバーでの要求の再送信の影響について説明する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.1.1. Forming a Success or Error Response",
      "section_title": true,
      "ja": "6.3.1.1. 成功またはエラー応答の形成"
    },
    {
      "indent": 3,
      "text": "When forming the response (success or error), the server follows the rules of Section 6. The method of the response is the same as that of the request, and the message class is either \"Success Response\" or \"Error Response\".",
      "ja": "応答（成功またはエラー）を形成するとき、サーバーはセクション6の規則に従います。応答の方法は要求の方法と同じであり、メッセージクラスは「成功応答」または「エラー応答」のいずれかです。"
    },
    {
      "indent": 3,
      "text": "For an error response, the server MUST add an ERROR-CODE attribute containing the error code specified in the processing above. The reason phrase is not fixed but SHOULD be something suitable for the error code. For certain errors, additional attributes are added to the message. These attributes are spelled out in the description where the error code is specified. For example, for an error code of 420 (Unknown Attribute), the server MUST include an UNKNOWN-ATTRIBUTES attribute. Certain authentication errors also cause attributes to be added (see Section 9). Extensions may define other errors and/or additional attributes to add in error cases.",
      "ja": "エラー応答の場合、サーバーは上記の処理で指定されたエラーコードを含むERROR-CODE属性を追加する必要があります。理由句は修正されていませんが、エラーコードに適したものである必要があります。特定のエラーについては、追加の属性がメッセージに追加されます。これらの属性は、エラーコードが指定されている説明に詳しく説明されています。たとえば、エラーコード420（不明な属性）の場合、サーバーにはUNKNOWN-ATTRIBUTES属性を含める必要があります。特定の認証エラーにより、属性も追加されます（セクション9を参照）。拡張機能は、エラーの場合に追加する他のエラーや追加の属性を定義する場合があります。"
    },
    {
      "indent": 3,
      "text": "If the server authenticated the request using an authentication mechanism, then the server SHOULD add the appropriate authentication attributes to the response (see Section 9).",
      "ja": "サーバーが認証メカニズムを使用して要求を認証した場合、サーバーは適切な認証属性を応答に追加する必要があります（セクション9を参照）。"
    },
    {
      "indent": 3,
      "text": "The server also adds any attributes required by the specific method or usage. In addition, the server SHOULD add a SOFTWARE attribute to the message.",
      "ja": "サーバーは、特定の方法または使用法に必要な属性も追加します。さらに、サーバーはメッセージにSOFTWARE属性を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the Binding method, no additional checking is required unless the usage specifies otherwise. When forming the success response, the server adds an XOR-MAPPED-ADDRESS attribute to the response; this attribute contains the source transport address of the request message. For UDP or DTLS-over-UDP, this is the source IP address and source UDP port of the request message. For TCP and TLS-over-TCP, this is the source IP address and source TCP port of the TCP connection as seen by the server.",
      "ja": "Bindingメソッドの場合、使用法で特に指定されていない限り、追加のチェックは必要ありません。成功応答を形成するとき、サーバーはXOR-MAPPED-ADDRESS属性を応答に追加します。この属性には、要求メッセージの送信元トランスポートアドレスが含まれます。UDPまたはDTLS-over-UDPの場合、これは要求メッセージの送信元IPアドレスと送信元UDPポートです。TCPおよびTLS-over-TCPの場合、これはサーバーから見たTCP接続の送信元IPアドレスと送信元TCPポートです。"
    },
    {
      "indent": 0,
      "text": "6.3.1.2. Sending the Success or Error Response",
      "section_title": true,
      "ja": "6.3.1.2. 成功またはエラー応答の送信"
    },
    {
      "indent": 3,
      "text": "The response (success or error) is sent over the same transport as the request was received on. If the request was received over UDP or DTLS-over-UDP, the destination IP address and port of the response are the source IP address and port of the received request message, and the source IP address and port of the response are equal to the destination IP address and port of the received request message. If the request was received over TCP or TLS-over-TCP, the response is sent back on the same TCP connection as the request was received on.",
      "ja": "応答（成功またはエラー）は、要求が受信されたのと同じトランスポートを介して送信されます。要求がUDPまたはDTLS-over-UDPを介して受信された場合、応答の宛先IPアドレスとポートは、受信した要求メッセージの送信元IPアドレスとポートであり、応答の送信元IPアドレスとポートは受信したリクエストメッセージの宛先IPアドレスとポート。要求がTCPまたはTLS-over-TCPを介して受信された場合、応答は、要求が受信されたのと同じTCP接続で返送されます。"
    },
    {
      "indent": 3,
      "text": "The server is allowed to send responses in a different order than it received the requests.",
      "ja": "サーバーは、要求を受信したのとは異なる順序で応答を送信できます。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Processing an Indication",
      "section_title": true,
      "ja": "6.3.2. インジケーションの処理"
    },
    {
      "indent": 3,
      "text": "If the indication contains unknown comprehension-required attributes, the indication is discarded and processing ceases.",
      "ja": "インジケーションに不明な理解必須属性が含まれている場合、インジケーションは破棄され、処理が停止します。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the agent then does any additional checking that the method or the specific usage requires. If all the checks succeed, the agent then processes the indication. No response is generated for an indication.",
      "ja": "それ以外の場合、エージェントは、メソッドまたは特定の使用法に必要な追加のチェックを実行します。すべてのチェックが成功すると、エージェントはインジケーションを処理します。インジケーションに対する応答は生成されません。"
    },
    {
      "indent": 3,
      "text": "For the Binding method, no additional checking or processing is required, unless the usage specifies otherwise. The mere receipt of the message by the agent has refreshed the bindings in the intervening NATs.",
      "ja": "Bindingメソッドの場合、使用法で特に指定されていない限り、追加のチェックや処理は必要ありません。エージェントがメッセージを受信しただけで、介在するNATのバインディングが更新されました。"
    },
    {
      "indent": 3,
      "text": "Since indications are not re-transmitted over UDP or DTLS-over-UDP (unlike requests), there is no need to handle re-transmissions of indications at the sending agent.",
      "ja": "指示はUDPまたはDTLS-over-UDPを介して再送信されないため（要求とは異なり）、送信エージェントで指示の再送信を処理する必要はありません。"
    },
    {
      "indent": 0,
      "text": "6.3.3. Processing a Success Response",
      "section_title": true,
      "ja": "6.3.3. 成功応答の処理"
    },
    {
      "indent": 3,
      "text": "If the success response contains unknown comprehension-required attributes, the response is discarded and the transaction is considered to have failed.",
      "ja": "成功応答に不明な理解必須属性が含まれている場合、応答は破棄され、トランザクションは失敗したと見なされます。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the client then does any additional checking that the method or the specific usage requires. If all the checks succeed, the client then processes the success response.",
      "ja": "それ以外の場合、クライアントは、メソッドまたは特定の使用法に必要な追加のチェックを実行します。すべてのチェックが成功すると、クライアントは成功応答を処理します。"
    },
    {
      "indent": 3,
      "text": "For the Binding method, the client checks that the XOR-MAPPED-ADDRESS attribute is present in the response. The client checks the address family specified. If it is an unsupported address family, the attribute SHOULD be ignored. If it is an unexpected but supported address family (for example, the Binding transaction was sent over IPv4, but the address family specified is IPv6), then the client MAY accept and use the value.",
      "ja": "Bindingメソッドの場合、クライアントはXOR-MAPPED-ADDRESS属性が応答に存在することを確認します。クライアントは、指定されたアドレスファミリをチェックします。サポートされていないアドレスファミリの場合、属性は無視する必要があります。予期しないがサポートされているアドレスファミリである場合（たとえば、バインディングトランザクションがIPv4を介して送信されたが、指定されたアドレスファミリがIPv6である場合）、クライアントはその値を受け入れて使用できます（MAY）。"
    },
    {
      "indent": 0,
      "text": "6.3.4. Processing an Error Response",
      "section_title": true,
      "ja": "6.3.4. エラー応答の処理"
    },
    {
      "indent": 3,
      "text": "If the error response contains unknown comprehension-required attributes, or if the error response does not contain an ERROR-CODE attribute, then the transaction is simply considered to have failed.",
      "ja": "エラー応答に不明な理解必須属性が含まれている場合、またはエラー応答にERROR-CODE属性が含まれていない場合、トランザクションは単に失敗したと見なされます。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the client then does any processing specified by the authentication mechanism (see Section 9). This may result in a new transaction attempt.",
      "ja": "それ以外の場合、クライアントは認証メカニズムで指定された処理を実行します（セクション9を参照）。これにより、新しいトランザクションが試行される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The processing at this point depends on the error code, the method, and the usage; the following are the default rules:",
      "ja": "この時点での処理は、エラーコード、方法、および使用法によって異なります。デフォルトのルールは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the error code is 300 through 399, the client SHOULD consider the transaction as failed unless the ALTERNATE-SERVER extension (Section 10) is being used.",
      "ja": "o エラーコードが300から399の場合、ALTERNATE-SERVER拡張機能（セクション10）が使用されていない限り、クライアントはトランザクションが失敗したと見なす必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the error code is 400 through 499, the client declares the transaction failed; in the case of 420 (Unknown Attribute), the response should contain a UNKNOWN-ATTRIBUTES attribute that gives additional information.",
      "ja": "o エラーコードが400から499の場合、クライアントはトランザクションが失敗したと宣言します。420（不明な属性）の場合、応答には追加情報を提供するUNKNOWN-ATTRIBUTES属性が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the error code is 500 through 599, the client MAY resend the request; clients that do so MUST limit the number of times they do this. Unless a specific error code specifies a different value, the number of retransmissions SHOULD be limited to 4.",
      "ja": "o エラーコードが500から599の場合、クライアントはリクエストを再送信できます。そうするクライアントは、これを行う回数を制限しなければなりません。特定のエラーコードで別の値が指定されていない限り、再送信の回数は4回に制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "Any other error code causes the client to consider the transaction failed.",
      "ja": "その他のエラーコードがあると、クライアントはトランザクションが失敗したと見なします。"
    },
    {
      "indent": 0,
      "text": "7. FINGERPRINT Mechanism",
      "section_title": true,
      "ja": "7. 指紋メカニズム"
    },
    {
      "indent": 3,
      "text": "This section describes an optional mechanism for STUN that aids in distinguishing STUN messages from packets of other protocols when the two are multiplexed on the same transport address. This mechanism is optional, and a STUN Usage must describe if and when it is used. The FINGERPRINT mechanism is not backwards compatible with RFC 3489 and cannot be used in environments where such compatibility is required.",
      "ja": "このセクションでは、2つが同じトランスポートアドレスで多重化されている場合に、STUNメッセージを他のプロトコルのパケットから区別するのに役立つSTUNのオプションのメカニズムについて説明します。このメカニズムはオプションであり、STUNの使用法では、使用するかどうか、いつ使用するかを説明する必要があります。FINGERPRINTメカニズムはRFC3489との下位互換性がなく、そのような互換性が必要な環境では使用できません。"
    },
    {
      "indent": 3,
      "text": "In some usages, STUN messages are multiplexed on the same transport address as other protocols, such as the Real-Time Transport Protocol (RTP). In order to apply the processing described in Section 6, STUN messages must first be separated from the application packets.",
      "ja": "一部の使用法では、STUNメッセージは、Real-Time Transport Protocol（RTP）などの他のプロトコルと同じトランスポートアドレスで多重化されます。セクション6で説明されている処理を適用するには、最初にSTUNメッセージをアプリケーションパケットから分離する必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 5 describes three fixed fields in the STUN header that can be used for this purpose. However, in some cases, these three fixed fields may not be sufficient.",
      "ja": "セクション5では、この目的に使用できるSTUNヘッダーの3つの固定フィールドについて説明します。ただし、場合によっては、これら3つの固定フィールドでは不十分なことがあります。"
    },
    {
      "indent": 3,
      "text": "When the FINGERPRINT extension is used, an agent includes the FINGERPRINT attribute in messages it sends to another agent. Section 14.7 describes the placement and value of this attribute.",
      "ja": "FINGERPRINT拡張機能が使用されている場合、エージェントは別のエージェントに送信するメッセージにFINGERPRINT属性を含めます。セクション14.7では、この属性の配置と値について説明します。"
    },
    {
      "indent": 3,
      "text": "When the agent receives what it believes is a STUN message, then, in addition to other basic checks, the agent also checks that the message contains a FINGERPRINT attribute and that the attribute contains the correct value. Section 6.3 describes when in the overall processing of a STUN message the FINGERPRINT check is performed. This additional check helps the agent detect messages of other protocols that might otherwise seem to be STUN messages.",
      "ja": "エージェントがSTUNメッセージであると信じているものを受信すると、他の基本的なチェックに加えて、エージェントはメッセージにFINGERPRINT属性が含まれていること、および属性に正しい値が含まれていることもチェックします。セクション6.3では、STUNメッセージの全体的な処理で、FINGERPRINTチェックがいつ実行されるかについて説明します。この追加のチェックは、エージェントが他のプロトコルのメッセージを検出するのに役立ちます。そうでなければ、STUNメッセージのように見える可能性があります。"
    },
    {
      "indent": 0,
      "text": "8. DNS Discovery of a Server",
      "section_title": true,
      "ja": "8. サーバーのDNS検出"
    },
    {
      "indent": 0,
      "text": " This section describes an optional procedure for STUN that allows a client to use DNS to determine the IP address and port of a server. A STUN Usage must describe if and when this extension is used. To use this procedure, the client must know a STUN URI [RFC7064]; the usage must also describe how the client obtains this URI. Hard-coding a STUN URI into software is NOT RECOMMENDED in case the domain name is lost or needs to change for legal or other reasons.",
      "ja": "このセクションでは、クライアントがDNSを使用してサーバーのIPアドレスとポートを判別できるようにするSTUNのオプションの手順について説明します。STUNの使用法では、この拡張機能を使用するかどうか、いつ使用するかを説明する必要があります。この手順を使用するには、クライアントはSTUN URI [RFC7064]を知っている必要があります。使用法では、クライアントがこのURIを取得する方法も説明する必要があります。ドメイン名が失われた場合、または法的な理由やその他の理由で変更する必要がある場合に備えて、STUNURIをソフトウェアにハードコーディングすることはお勧めしません。"
    },
    {
      "indent": 3,
      "text": "When a client wishes to locate a STUN server on the public Internet that accepts Binding request/response transactions, the STUN URI scheme is \"stun\". When it wishes to locate a STUN server that accepts Binding request/response transactions over a TLS or DTLS session, the URI scheme is \"stuns\".",
      "ja": "クライアントがバインディング要求/応答トランザクションを受け入れるパブリックインターネット上のSTUNサーバーを見つけたい場合、STUN URIスキームは「stun」です。TLSまたはDTLSセッションを介したバインディング要求/応答トランザクションを受け入れるSTUNサーバーを見つけたい場合、URIスキームは「stuns」です。"
    },
    {
      "indent": 3,
      "text": "The syntax of the \"stun\" and \"stuns\" URIs is defined in Section 3.1 of [RFC7064]. STUN Usages MAY define additional URI schemes.",
      "ja": "「stun」および「stuns」URIの構文は、[RFC7064]のセクション3.1で定義されています。STUNの使用法は、追加のURIスキームを定義する場合があります。"
    },
    {
      "indent": 0,
      "text": "8.1. STUN URI Scheme Semantics",
      "section_title": true,
      "ja": "8.1. STUNURIスキームセマンティクス"
    },
    {
      "indent": 3,
      "text": "If the <host> part of a \"stun\" URI contains an IP address, then this IP address is used directly to contact the server. A \"stuns\" URI containing an IP address MUST be rejected. A future STUN extension or usage may relax this requirement, provided it demonstrates how to authenticate the STUN server and prevent man-in-the-middle attacks.",
      "ja": "「stun」URIの<host>部分にIPアドレスが含まれている場合、このIPアドレスはサーバーへの接続に直接使用されます。IPアドレスを含む「stuns」URIは拒否されなければなりません（MUST）。将来のSTUN拡張または使用法は、STUNサーバーを認証し、man-in-the-middle攻撃を防ぐ方法を示している場合、この要件を緩和する可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the URI does not contain an IP address, the domain name contained in the <host> part is resolved to a transport address using the SRV procedures specified in [RFC2782]. The DNS SRV service name is the content of the <scheme> part. The protocol in the SRV lookup is the transport protocol the client will run STUN over: \"udp\" for UDP and \"tcp\" for TCP.",
      "ja": "URIにIPアドレスが含まれていない場合、<host>部分に含まれるドメイン名は、[RFC2782]で指定されているSRV手順を使用してトランスポートアドレスに解決されます。DNS SRVサービス名は、<scheme>部分のコンテンツです。SRVルックアップのプロトコルは、クライアントがSTUNを実行するトランスポートプロトコルです。UDPの場合は「udp」、TCPの場合は「tcp」です。"
    },
    {
      "indent": 3,
      "text": "The procedures of RFC 2782 are followed to determine the server to contact. RFC 2782 spells out the details of how a set of SRV records is sorted and then tried. However, RFC 2782 only states that the client should \"try to connect to the (protocol, address, service)\" without giving any details on what happens in the event of failure. When following these procedures, if the STUN transaction times out without receipt of a response, the client SHOULD retry the request to the next server in the order defined by RFC 2782. Such a retry is only possible for request/response transmissions, since indication transactions generate no response or timeout.",
      "ja": "RFC 2782の手順に従って、接続するサーバーを決定します。RFC 2782は、SRVレコードのセットがどのようにソートされてから試行されるかについての詳細を詳しく説明しています。ただし、RFC 2782は、クライアントが「（プロトコル、アドレス、サービス）への接続を試行する」必要があると述べているだけで、障害が発生した場合の詳細は示されていません。これらの手順に従うと、STUNトランザクションが応答を受信せずにタイムアウトした場合、クライアントはRFC 2782で定義された順序で次のサーバーへの要求を再試行する必要があります。このような再試行は、指示トランザクションのため、要求/応答の送信でのみ可能です。応答またはタイムアウトを生成しません。"
    },
    {
      "indent": 3,
      "text": "In addition, instead of querying either the A or the AAAA resource records for a domain name, a dual-stack IPv4/IPv6 client MUST query both and try the requests with all the IP addresses received, as specified in [RFC8305].",
      "ja": "さらに、AまたはAAAAリソースレコードのいずれかでドメイン名を照会する代わりに、デュアルスタックIPv4 / IPv6クライアントは両方を照会し、[RFC8305]で指定されているように、受信したすべてのIPアドレスで要求を試行する必要があります。"
    },
    {
      "indent": 0,
      "text": " The default port for STUN requests is 3478, for both TCP and UDP. The default port for STUN over TLS and STUN over DTLS requests is 5349. Servers can run STUN over DTLS on the same port as STUN over UDP if the server software supports determining whether the initial message is a DTLS or STUN message. Servers can run STUN over TLS on the same port as STUN over TCP if the server software supports determining whether the initial message is a TLS or STUN message.",
      "ja": "STUN要求のデフォルトのポートは、TCPとUDPの両方で3478です。STUN overTLSおよびSTUNover DTLS要求のデフォルトポートは5349です。サーバーソフトウェアが初期メッセージがDTLSまたはSTUNメッセージであるかどうかの判別をサポートしている場合、サーバーはSTUN overUDPと同じポートでSTUNoverDTLSを実行できます。サーバーソフトウェアが最初のメッセージがTLSまたはSTUNメッセージであるかどうかの判別をサポートしている場合、サーバーはSTUN overTCPと同じポートでSTUNoverTLSを実行できます。"
    },
    {
      "indent": 3,
      "text": "Administrators of STUN servers SHOULD use these ports in their SRV records for UDP and TCP. In all cases, the port in DNS MUST reflect the one on which the server is listening.",
      "ja": "STUNサーバーの管理者は、UDPおよびTCPのSRVレコードでこれらのポートを使用する必要があります。すべての場合において、DNSのポートは、サーバーがリッスンしているポートを反映している必要があります。"
    },
    {
      "indent": 3,
      "text": "If no SRV records are found, the client performs both an A and AAAA record lookup of the domain name, as described in [RFC8305]. The result will be a list of IP addresses, each of which can be simultaneously contacted at the default port using UDP or TCP, independent of the STUN Usage. For usages that require TLS, the client connects to the IP addresses using the default STUN over TLS port. For usages that require DTLS, the client connects to the IP addresses using the default STUN over DTLS port.",
      "ja": "SRVレコードが見つからない場合、クライアントは、[RFC8305]で説明されているように、ドメイン名のAレコードルックアップとAAAAレコードルックアップの両方を実行します。結果はIPアドレスのリストになり、STUNの使用法に関係なく、UDPまたはTCPを使用してデフォルトのポートでそれぞれに同時に接続できます。TLSを必要とする使用法の場合、クライアントはデフォルトのSTUN overTLSポートを使用してIPアドレスに接続します。DTLSを必要とする使用法の場合、クライアントはデフォルトのSTUN overDTLSポートを使用してIPアドレスに接続します。"
    },
    {
      "indent": 0,
      "text": "9. Authentication and Message-Integrity Mechanisms",
      "section_title": true,
      "ja": "9. 認証とメッセージの整合性メカニズム"
    },
    {
      "indent": 3,
      "text": "This section defines two mechanisms for STUN that a client and server can use to provide authentication and message integrity; these two mechanisms are known as the short-term credential mechanism and the long-term credential mechanism. These two mechanisms are optional, and each usage must specify if and when these mechanisms are used. Consequently, both clients and servers will know which mechanism (if any) to follow based on knowledge of which usage applies. For example, a STUN server on the public Internet supporting ICE would have no authentication, whereas the STUN server functionality in an agent supporting connectivity checks would utilize short-term credentials. An overview of these two mechanisms is given in Section 2.",
      "ja": "このセクションでは、クライアントとサーバーが認証とメッセージの整合性を提供するために使用できるSTUNの2つのメカニズムを定義します。これらの2つのメカニズムは、短期の資格情報メカニズムと長期の資格情報メカニズムとして知られています。これらの2つのメカニズムはオプションであり、各使用法では、これらのメカニズムを使用するかどうか、いつ使用するかを指定する必要があります。その結果、クライアントとサーバーの両方が、適用される使用法の知識に基づいて、従うべきメカニズム（存在する場合）を認識します。たとえば、ICEをサポートするパブリックインターネット上のSTUNサーバーには認証がありませんが、接続チェックをサポートするエージェントのSTUNサーバー機能は短期間の資格情報を利用します。これら2つのメカニズムの概要は、セクション2に記載されています。"
    },
    {
      "indent": 3,
      "text": "Each mechanism specifies the additional processing required to use that mechanism, extending the processing specified in Section 6. The additional processing occurs in three different places: when forming a message, when receiving a message immediately after the basic checks have been performed, and when doing the detailed processing of error responses.",
      "ja": "各メカニズムは、そのメカニズムを使用するために必要な追加処理を指定し、セクション6で指定された処理を拡張します。追加処理は、メッセージの形成時、基本チェックの実行直後のメッセージの受信時、および実行時の3つの異なる場所で発生します。エラー応答の詳細な処理。"
    },
    {
      "indent": 3,
      "text": "Note that agents MUST ignore all attributes that follow MESSAGE-INTEGRITY, with the exception of the MESSAGE-INTEGRITY-SHA256 and FINGERPRINT attributes. Similarly, agents MUST ignore all attributes that follow the MESSAGE-INTEGRITY-SHA256 attribute if the MESSAGE-INTEGRITY attribute is not present, with the exception of the FINGERPRINT attribute.",
      "ja": "エージェントは、MESSAGE-INTEGRITY-SHA256属性とFINGERPRINT属性を除いて、MESSAGE-INTEGRITYに続くすべての属性を無視する必要があることに注意してください。同様に、エージェントは、FINGERPRINT属性を除いて、MESSAGE-INTEGRITY属性が存在しない場合、MESSAGE-INTEGRITY-SHA256属性に続くすべての属性を無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.1. Short-Term Credential Mechanism",
      "section_title": true,
      "ja": "9.1. 短期資格情報メカニズム"
    },
    {
      "indent": 3,
      "text": "The short-term credential mechanism assumes that, prior to the STUN transaction, the client and server have used some other protocol to exchange a credential in the form of a username and password. This credential is time-limited. The time limit is defined by the usage. As an example, in the ICE usage [RFC8445], the two endpoints use out-of-band signaling to agree on a username and password, and this username and password are applicable for the duration of the media session.",
      "ja": "短期的な資格情報メカニズムは、STUNトランザクションの前に、クライアントとサーバーが他のプロトコルを使用して、ユーザー名とパスワードの形式で資格情報を交換したことを前提としています。この資格情報には期限があります。制限時間は使用法によって定義されます。例として、ICEの使用法[RFC8445]では、2つのエンドポイントが帯域外信号方式を使用してユーザー名とパスワードについて合意し、このユーザー名とパスワードはメディアセッションの期間中に適用されます。"
    },
    {
      "indent": 3,
      "text": "This credential is used to form a message-integrity check in each request and in many responses. There is no challenge and response as in the long-term mechanism; consequently, replay is limited by virtue of the time-limited nature of the credential.",
      "ja": "この資格情報は、各要求および多くの応答でメッセージの整合性チェックを形成するために使用されます。長期的なメカニズムのようにチャレンジとレスポンスはありません。その結果、資格情報の時間制限の性質により、再生が制限されます。"
    },
    {
      "indent": 0,
      "text": "9.1.1. HMAC Key",
      "section_title": true,
      "ja": "9.1.1. HMACキー"
    },
    {
      "indent": 3,
      "text": "For short-term credentials, the Hash-Based Message Authentication Code (HMAC) key is defined as follow:",
      "ja": "短期間の資格情報の場合、ハッシュベースのメッセージ認証コード（HMAC）キーは次のように定義されます。"
    },
    {
      "indent": 23,
      "text": "key = OpaqueString(password)",
      "ja": "キー= OpaqueString（パスワード）"
    },
    {
      "indent": 3,
      "text": "where the OpaqueString profile is defined in [RFC8265]. The encoding used is UTF-8 [RFC3629].",
      "ja": "ここで、OpaqueStringプロファイルは[RFC8265]で定義されています。使用されるエンコーディングはUTF-8 [RFC3629]です。"
    },
    {
      "indent": 0,
      "text": "9.1.2. Forming a Request or Indication",
      "section_title": true,
      "ja": "9.1.2. 要求または表示の形成"
    },
    {
      "indent": 3,
      "text": "For a request or indication message, the agent MUST include the USERNAME, MESSAGE-INTEGRITY-SHA256, and MESSAGE-INTEGRITY attributes in the message unless the agent knows from an external mechanism which message integrity algorithm is supported by both agents. In this case, either MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 MUST be included in addition to USERNAME. The HMAC for the MESSAGE-INTEGRITY attribute is computed as described in Section 14.5, and the HMAC for the MESSAGE-INTEGRITY-SHA256 attributes is computed as described in Section 14.6. Note that the password is never included in the request or indication.",
      "ja": "要求または指示メッセージの場合、エージェントは、外部メカニズムからどちらのメッセージ整合性アルゴリズムが両方のエージェントでサポートされているかを知らない限り、メッセージにUSERNAME、MESSAGE-INTEGRITY-SHA256、およびMESSAGE-INTEGRITY属性を含める必要があります。この場合、USERNAMEに加えて、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256のいずれかを含める必要があります。MESSAGE-INTEGRITY属性のHMACは、セクション14.5の説明に従って計算され、MESSAGE-INTEGRITY-SHA256属性のHMACは、セクション14.6の説明に従って計算されます。パスワードがリクエストまたは表示に含まれることは決してないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "9.1.3. Receiving a Request or Indication",
      "section_title": true,
      "ja": "9.1.3. リクエストまたは表示の受信"
    },
    {
      "indent": 3,
      "text": "After the agent has done the basic processing of a message, the agent performs the checks listed below in the order specified:",
      "ja": "エージェントがメッセージの基本的な処理を行った後、エージェントは以下にリストされているチェックを指定された順序で実行します。"
    },
    {
      "indent": 3,
      "text": "o If the message does not contain 1) a MESSAGE-INTEGRITY or a MESSAGE-INTEGRITY-SHA256 attribute and 2) a USERNAME attribute:",
      "ja": "o メッセージに1）MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性と2）USERNAME属性が含まれていない場合："
    },
    {
      "indent": 6,
      "text": "* If the message is a request, the server MUST reject the request with an error response. This response MUST use an error code of 400 (Bad Request).",
      "ja": "* メッセージが要求である場合、サーバーはエラー応答で要求を拒否しなければなりません（MUST）。この応答は、400のエラーコード（不正な要求）を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the message is an indication, the agent MUST silently discard the indication.",
      "ja": "* メッセージがインジケーションである場合、エージェントはそのインジケーションを黙って破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the USERNAME does not contain a username value currently valid within the server:",
      "ja": "o USERNAMEに、サーバー内で現在有効なユーザー名値が含まれていない場合："
    },
    {
      "indent": 6,
      "text": "* If the message is a request, the server MUST reject the request with an error response. This response MUST use an error code of 401 (Unauthenticated).",
      "ja": "* メッセージが要求である場合、サーバーはエラー応答で要求を拒否しなければなりません（MUST）。この応答は、401（未認証）のエラーコードを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the message is an indication, the agent MUST silently discard the indication.",
      "ja": "* メッセージがインジケーションである場合、エージェントはそのインジケーションを黙って破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the MESSAGE-INTEGRITY-SHA256 attribute is present, compute the value for the message integrity as described in Section 14.6, using the password associated with the username. If the MESSAGE-INTEGRITY-SHA256 attribute is not present, then use the same password to compute the value for the message integrity as described in Section 14.5. If the resulting value does not match the contents of the corresponding attribute (MESSAGE-INTEGRITY-SHA256 or MESSAGE-INTEGRITY):",
      "ja": "o MESSAGE-INTEGRITY-SHA256属性が存在する場合は、ユーザー名に関連付けられたパスワードを使用して、セクション14.6の説明に従ってメッセージの整合性の値を計算します。MESSAGE-INTEGRITY-SHA256属性が存在しない場合は、セクション14.5で説明されているように、同じパスワードを使用してメッセージの整合性の値を計算します。結果の値が対応する属性（MESSAGE-INTEGRITY-SHA256またはMESSAGE-INTEGRITY）の内容と一致しない場合："
    },
    {
      "indent": 6,
      "text": "* If the message is a request, the server MUST reject the request with an error response. This response MUST use an error code of 401 (Unauthenticated).",
      "ja": "* メッセージが要求である場合、サーバーはエラー応答で要求を拒否しなければなりません（MUST）。この応答は、401（未認証）のエラーコードを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the message is an indication, the agent MUST silently discard the indication.",
      "ja": "* メッセージがインジケーションである場合、エージェントはそのインジケーションを黙って破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If these checks pass, the agent continues to process the request or indication. Any response generated by a server to a request that contains a MESSAGE-INTEGRITY-SHA256 attribute MUST include the MESSAGE-INTEGRITY-SHA256 attribute, computed using the password utilized to authenticate the request. Any response generated by a server to a request that contains only a MESSAGE-INTEGRITY attribute MUST include the MESSAGE-INTEGRITY attribute, computed using the password utilized to authenticate the request. This means that only one of these attributes can appear in a response. The response MUST NOT contain the USERNAME attribute.",
      "ja": "これらのチェックに合格すると、エージェントは引き続き要求または指示を処理します。MESSAGE-INTEGRITY-SHA256属性を含む要求に対してサーバーによって生成される応答には、要求の認証に使用されるパスワードを使用して計算されたMESSAGE-INTEGRITY-SHA256属性を含める必要があります。MESSAGE-INTEGRITY属性のみを含む要求に対してサーバーによって生成される応答には、要求の認証に使用されるパスワードを使用して計算されたMESSAGE-INTEGRITY属性を含める必要があります。これは、これらの属性の1つだけが応答に表示できることを意味します。応答にはUSERNAME属性を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "If any of the checks fail, a server MUST NOT include a MESSAGE-INTEGRITY-SHA256, MESSAGE-INTEGRITY, or USERNAME attribute in the error response. This is because, in these failure cases, the server cannot determine the shared secret necessary to compute the MESSAGE-INTEGRITY-SHA256 or MESSAGE-INTEGRITY attributes.",
      "ja": "いずれかのチェックが失敗した場合、サーバーはエラー応答にMESSAGE-INTEGRITY-SHA256、MESSAGE-INTEGRITY、またはUSERNAME属性を含めてはなりません（MUSTNOT）。これは、これらの障害の場合、サーバーがMESSAGE-INTEGRITY-SHA256またはMESSAGE-INTEGRITY属性の計算に必要な共有シークレットを判別できないためです。"
    },
    {
      "indent": 0,
      "text": "9.1.4. Receiving a Response",
      "section_title": true,
      "ja": "9.1.4. 応答の受信"
    },
    {
      "indent": 3,
      "text": "The client looks for the MESSAGE-INTEGRITY or the MESSAGE-INTEGRITY-SHA256 attribute in the response. If present and if the client only sent one of the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attributes in the request (because of the external indication in Section 9.1.2 or because this is a subsequent request as defined in Section 9.1.5), the algorithm in the response has to match; otherwise, the response MUST be discarded.",
      "ja": "クライアントは、応答でMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を探します。存在し、クライアントがリクエストでMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性の1つのみを送信した場合（セクション9.1.2の外部表示のため、またはセクション9.1.5で定義されている後続のリクエストであるため）、応答のアルゴリズムは一致する必要があります。それ以外の場合、応答は破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client then computes the message integrity over the response as defined in Section 14.5 for the MESSAGE-INTEGRITY attribute or Section 14.6 for the MESSAGE-INTEGRITY-SHA256 attribute, using the same password it utilized for the request. If the resulting value matches the contents of the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute, respectively, the response is considered authenticated. If the value does not match, or if both MESSAGE-INTEGRITY and MESSAGE-INTEGRITY-SHA256 are absent, the processing depends on whether the request was sent over a reliable or an unreliable transport.",
      "ja": "次に、クライアントは、要求に使用したのと同じパスワードを使用して、MESSAGE-INTEGRITY属性のセクション14.5またはMESSAGE-INTEGRITY-SHA256属性のセクション14.6で定義されているように、応答に対するメッセージの整合性を計算します。結果の値がそれぞれMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性の内容と一致する場合、応答は認証済みと見なされます。値が一致しない場合、またはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方が存在しない場合、処理は、要求が信頼できるトランスポートで送信されたか、信頼できないトランスポートで送信されたかによって異なります。"
    },
    {
      "indent": 3,
      "text": "If the request was sent over an unreliable transport, the response MUST be discarded, as if it had never been received. This means that retransmits, if applicable, will continue. If all the responses received are discarded, then instead of signaling a timeout after ending the transaction, the layer MUST signal that the integrity protection was violated.",
      "ja": "要求が信頼性の低いトランスポートを介して送信された場合、応答は受信されたことがないかのように破棄する必要があります。これは、該当する場合、再送信が続行されることを意味します。受信したすべての応答が破棄された場合、トランザクションの終了後にタイムアウトを通知する代わりに、レイヤーは整合性保護に違反したことを通知する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the request was sent over a reliable transport, the response MUST be discarded, and the layer MUST immediately end the transaction and signal that the integrity protection was violated.",
      "ja": "要求が信頼できるトランスポートを介して送信された場合、応答は破棄されなければならず、レイヤーはトランザクションを直ちに終了し、整合性保護に違反したことを通知しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.1.5. Sending Subsequent Requests",
      "section_title": true,
      "ja": "9.1.5. 後続のリクエストの送信"
    },
    {
      "indent": 3,
      "text": "A client sending subsequent requests to the same server MUST send only the MESSAGE-INTEGRITY-SHA256 or the MESSAGE-INTEGRITY attribute that matches the attribute that was received in the response to the initial request. Here, \"same server\" means same IP address and port number, not just the same URI or SRV lookup result.",
      "ja": "同じサーバーに後続のリクエストを送信するクライアントは、最初のリクエストへの応答で受信した属性と一致するMESSAGE-INTEGRITY-SHA256またはMESSAGE-INTEGRITY属性のみを送信する必要があります。ここで、「同じサーバー」とは、同じURIまたはSRVルックアップ結果だけでなく、同じIPアドレスとポート番号を意味します。"
    },
    {
      "indent": 0,
      "text": "9.2. Long-Term Credential Mechanism",
      "section_title": true,
      "ja": "9.2. 長期的な資格情報メカニズム"
    },
    {
      "indent": 3,
      "text": "The long-term credential mechanism relies on a long-term credential, in the form of a username and password that are shared between client and server. The credential is considered long-term since it is assumed that it is provisioned for a user and remains in effect until the user is no longer a subscriber of the system or until it is changed. This is basically a traditional \"log-in\" username and password given to users.",
      "ja": "長期資格情報メカニズムは、クライアントとサーバー間で共有されるユーザー名とパスワードの形式の長期資格情報に依存しています。資格情報は、ユーザーにプロビジョニングされ、ユーザーがシステムのサブスクライバーでなくなるか、システムが変更されるまで有効であると想定されるため、長期と見なされます。これは基本的に、ユーザーに与えられる従来の「ログイン」ユーザー名とパスワードです。"
    },
    {
      "indent": 3,
      "text": "Because these usernames and passwords are expected to be valid for extended periods of time, replay prevention is provided in the form of a digest challenge. In this mechanism, the client initially sends a request, without offering any credentials or any integrity checks. The server rejects this request, providing the user a realm (used to guide the user or agent in selection of a username and password) and a nonce. The nonce provides a limited replay protection. It is a cookie, selected by the server and encoded in such a way as to indicate a duration of validity or client identity from which it is valid. Only the server needs to know about the internal structure of the cookie. The client retries the request, this time including its username and the realm and echoing the nonce provided by the server. The client also includes one of the message-integrity attributes defined in this document, which provides an HMAC over the entire request, including the nonce. The server validates the nonce and checks the message integrity. If they match, the request is authenticated. If the nonce is no longer valid, it is considered \"stale\", and the server rejects the request, providing a new nonce.",
      "ja": "これらのユーザー名とパスワードは長期間有効であることが期待されるため、リプレイ防止はダイジェストチャレンジの形で提供されます。このメカニズムでは、クライアントは最初に、資格情報や整合性チェックを提供せずに要求を送信します。サーバーはこの要求を拒否し、ユーザーにレルム（ユーザー名とパスワードの選択においてユーザーまたはエージェントをガイドするために使用）とナンスを提供します。ナンスは限定的なリプレイ保護を提供します。これはCookieであり、サーバーによって選択され、有効期間または有効なクライアントIDを示すようにエンコードされます。サーバーだけがCookieの内部構造について知る必要があります。クライアントはリクエストを再試行します。今回はユーザー名とレルムを含め、サーバーから提供されたナンスをエコーします。クライアントには、このドキュメントで定義されているメッセージ整合性属性の1つも含まれています。これは、ナンスを含む要求全体に対してHMACを提供します。サーバーはナンスを検証し、メッセージの整合性をチェックします。それらが一致する場合、要求は認証されます。ナンスが無効になった場合、それは「古い」と見なされ、サーバーは要求を拒否して、新しいナンスを提供します。"
    },
    {
      "indent": 3,
      "text": "In subsequent requests to the same server, the client reuses the nonce, username, realm, and password it used previously. In this way, subsequent requests are not rejected until the nonce becomes invalid by the server, in which case the rejection provides a new nonce to the client.",
      "ja": "同じサーバーへの後続の要求では、クライアントは以前に使用したナンス、ユーザー名、レルム、およびパスワードを再利用します。このように、後続の要求は、ナンスがサーバーによって無効になるまで拒否されません。無効になると、拒否によってクライアントに新しいナンスが提供されます。"
    },
    {
      "indent": 3,
      "text": "Note that the long-term credential mechanism cannot be used to protect indications, since indications cannot be challenged. Usages utilizing indications must either use a short-term credential or omit authentication and message integrity for them.",
      "ja": "インジケーションはチャレンジを受けることができないため、長期的な資格情報メカニズムを使用してインジケーションを保護することはできないことに注意してください。インジケーションを利用する使用法では、短期の資格情報を使用するか、それらの認証とメッセージの整合性を省略する必要があります。"
    },
    {
      "indent": 0,
      "text": "To indicate that it supports this specification, a server MUST prepend the NONCE attribute value with the character string composed of \"obMatJos2\" concatenated with the (4-character) base64 [RFC4648] encoding of the 24-bit STUN Security Features as defined in Section 18.1. The 24-bit Security Feature set is encoded as 3 bytes, with bit 0 as the most significant bit of the first byte and bit 23 as the least significant bit of the third byte. If no security features are used, then a byte array with all 24 bits set to zero MUST be encoded instead. For the remainder of this document, the term \"nonce cookie\" will refer to the complete 13-character string prepended to the NONCE attribute value.",
      "ja": "この仕様をサポートしていることを示すために、サーバーは、セクション18.1で定義されている24ビットSTUNセキュリティ機能の（4文字）base64 [RFC4648]エンコーディングと連結された「obMatJos2」で構成される文字列をNONCE属性値の前に追加する必要があります（MUST）。24ビットのセキュリティ機能セットは3バイトとしてエンコードされ、ビット0が最初のバイトの最上位ビット、ビット23が3番目のバイトの最下位ビットです。セキュリティ機能を使用しない場合は、24ビットすべてをゼロに設定したバイト配列を代わりにエンコードする必要があります。このドキュメントの残りの部分では、「nonce cookie」という用語は、NONCE属性値の前に付加された完全な13文字の文字列を指します。"
    },
    {
      "indent": 3,
      "text": "Since the long-term credential mechanism is susceptible to offline dictionary attacks, deployments SHOULD utilize passwords that are difficult to guess. In cases where the credentials are not entered by the user, but are rather placed on a client device during device provisioning, the password SHOULD have at least 128 bits of randomness. In cases where the credentials are entered by the user, they should follow best current practices around password structure.",
      "ja": "長期的な資格情報メカニズムはオフライン辞書攻撃の影響を受けやすいため、展開では推測が難しいパスワードを使用する必要があります。資格情報がユーザーによって入力されず、デバイスのプロビジョニング中にクライアントデバイスに配置される場合、パスワードには少なくとも128ビットのランダム性が必要です（SHOULD）。ユーザーが資格情報を入力する場合は、パスワード構造に関する現在のベストプラクティスに従う必要があります。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Bid-Down Attack Prevention",
      "section_title": true,
      "ja": "9.2.1. ビッドダウンアタック防止"
    },
    {
      "indent": 3,
      "text": "This document introduces two new security features that provide the ability to choose the algorithm used for password protection as well as the ability to use an anonymous username. Both of these capabilities are optional in order to remain backwards compatible with previous versions of the STUN protocol.",
      "ja": "このドキュメントでは、パスワード保護に使用するアルゴリズムを選択する機能と、匿名のユーザー名を使用する機能を提供する2つの新しいセキュリティ機能を紹介します。これらの機能は両方とも、以前のバージョンのSTUNプロトコルとの下位互換性を維持するためにオプションです。"
    },
    {
      "indent": 3,
      "text": "These new capabilities are subject to bid-down attacks whereby an attacker in the message path can remove these capabilities and force weaker security properties. To prevent these kinds of attacks from going undetected, the nonce is enhanced with additional information.",
      "ja": "これらの新機能はビッドダウン攻撃の対象となり、メッセージパス内の攻撃者がこれらの機能を削除して、より弱いセキュリティプロパティを強制する可能性があります。これらの種類の攻撃が検出されなくなるのを防ぐために、ナンスは追加情報で強化されています。"
    },
    {
      "indent": 3,
      "text": "The value of the \"nonce cookie\" will vary based on the specific STUN Security Feature bits selected. When this document makes reference to the \"nonce cookie\" in a section discussing a specific STUN Security Feature it is understood that the corresponding STUN Security Feature bit in the \"nonce cookie\" is set to 1.",
      "ja": "「noncecookie」の値は、選択した特定のSTUNセキュリティ機能ビットによって異なります。このドキュメントが特定のSTUNセキュリティ機能について説明しているセクションで「noncecookie」を参照している場合、「noncecookie」の対応するSTUNセキュリティ機能ビットが1に設定されていることがわかります。"
    },
    {
      "indent": 3,
      "text": "For example, when the PASSWORD-ALGORITHMS security feature (defined in Section 9.2.4) is used, the corresponding \"Password algorithms\" bit (defined in Section 18.1) is set to 1 in the \"nonce cookie\".",
      "ja": "たとえば、PASSWORD-ALGORITHMSセキュリティ機能（セクション9.2.4で定義）が使用されている場合、対応する「パスワードアルゴリズム」ビット（セクション18.1で定義）は「ノンスCookie」で1に設定されます。"
    },
    {
      "indent": 0,
      "text": "9.2.2. HMAC Key",
      "section_title": true,
      "ja": "9.2.2. HMACキー"
    },
    {
      "indent": 3,
      "text": "For long-term credentials that do not use a different algorithm, as specified by the PASSWORD-ALGORITHM attribute, the key is 16 bytes:",
      "ja": "PASSWORD-ALGORITHM属性で指定されているように、別のアルゴリズムを使用しない長期資格情報の場合、キーは16バイトです。"
    },
    {
      "indent": 16,
      "text": "key = MD5(username \":\" OpaqueString(realm)\n  \":\" OpaqueString(password))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where MD5 is defined in [RFC1321] and [RFC6151], and the OpaqueString profile is defined in [RFC8265]. The encoding used is UTF-8 [RFC3629].",
      "ja": "MD5は[RFC1321]と[RFC6151]で定義されており、OpaqueStringプロファイルは[RFC8265]で定義されています。使用されるエンコーディングはUTF-8 [RFC3629]です。"
    },
    {
      "indent": 3,
      "text": "The 16-byte key is formed by taking the MD5 hash of the result of concatenating the following five fields: (1) the username, with any quotes and trailing nulls removed, as taken from the USERNAME attribute (in which case OpaqueString has already been applied); (2) a single colon; (3) the realm, with any quotes and trailing nulls removed and after processing using OpaqueString; (4) a single colon; and (5) the password, with any trailing nulls removed and after processing using OpaqueString. For example, if the username is 'user', the realm is 'realm', and the password is 'pass', then the 16-byte HMAC key would be the result of performing an MD5 hash on the string 'user:realm:pass', the resulting hash being 0x8493fbc53ba582fb4c044c456bdc40eb.",
      "ja": "16バイトのキーは、次の5つのフィールドを連結した結果のMD5ハッシュを取得することによって形成されます。（1）USERNAME属性から取得した、引用符と末尾のnullを削除したユーザー名（この場合、OpaqueStringはすでに適用）;（2）単一のコロン。（3）引用符と末尾のヌルが削除され、OpaqueStringを使用して処理された後のレルム。（4）単一のコロン。（5）末尾のヌルが削除され、OpaqueStringを使用して処理された後のパスワード。たとえば、ユーザー名が「user」、レルムが「realm」、パスワードが「pass」の場合、16バイトのHMACキーは、文字列「user:realm:pass」に対してMD5ハッシュを実行した結果になります。結果のハッシュは0x8493fbc53ba582fb4c044c456bdc40ebです。"
    },
    {
      "indent": 3,
      "text": "The structure of the key when used with long-term credentials facilitates deployment in systems that also utilize SIP [RFC3261]. Typically, SIP systems utilizing SIP's digest authentication mechanism do not actually store the password in the database. Rather, they store a value called \"H(A1)\", which is equal to the key defined above. For example, this mechanism can be used with the authentication extensions defined in [RFC5090].",
      "ja": "長期的な資格情報とともに使用される場合のキーの構造は、SIP [RFC3261]も利用するシステムでの展開を容易にします。通常、SIPのダイジェスト認証メカニズムを利用するSIPシステムは、実際にはパスワードをデータベースに保存しません。むしろ、上記で定義されたキーと等しい「H（A1）」と呼ばれる値を格納します。たとえば、このメカニズムは、[RFC5090]で定義されている認証拡張機能で使用できます。"
    },
    {
      "indent": 3,
      "text": "When a PASSWORD-ALGORITHM is used, the key length and algorithm to use are described in Section 18.5.1.",
      "ja": "PASSWORD-ALGORITHMを使用する場合、使用するキーの長さとアルゴリズムはセクション18.5.1で説明されています。"
    },
    {
      "indent": 0,
      "text": "9.2.3. Forming a Request",
      "section_title": true,
      "ja": "9.2.3. リクエストの作成"
    },
    {
      "indent": 3,
      "text": "The first request from the client to the server (as identified by hostname if the DNS procedures of Section 8 are used and by IP address if not) is handled according to the rules in Section 9.2.3.1. When the client initiates a subsequent request once a previous request/response transaction has completed successfully, it follows the rules in Section 9.2.3.2. Forming a request as a consequence of a 401 (Unauthenticated) or 438 (Stale Nonce) error response is covered in Section 9.2.5 and is not considered a \"subsequent request\" and thus does not utilize the rules described in Section 9.2.3.2. Each of these types of requests have a different mandatory attributes.",
      "ja": "クライアントからサーバーへの最初の要求（セクション8のDNS手順が使用されている場合はホスト名で識別され、使用されていない場合はIPアドレスで識別される）は、セクション9.2.3.1のルールに従って処理されます。前の要求/応答トランザクションが正常に完了した後でクライアントが後続の要求を開始すると、クライアントはセクション9.2.3.2のルールに従います。401（未認証）または438（Stale Nonce）エラー応答の結果として要求を形成することは、セクション9.2.5でカバーされており、「後続の要求」とは見なされないため、セクション9.2.3.2で説明されているルールを利用しません。これらのタイプのリクエストにはそれぞれ、異なる必須属性があります。"
    },
    {
      "indent": 0,
      "text": "9.2.3.1. First Request",
      "section_title": true,
      "ja": "9.2.3.1. 最初のリクエスト"
    },
    {
      "indent": 3,
      "text": "If the client has not completed a successful request/response transaction with the server, it MUST omit the USERNAME, USERHASH, MESSAGE-INTEGRITY, MESSAGE-INTEGRITY-SHA256, REALM, NONCE, PASSWORD-ALGORITHMS, and PASSWORD-ALGORITHM attributes. In other words, the first request is sent as if there were no authentication or message integrity applied.",
      "ja": "クライアントがサーバーとの要求/応答トランザクションを正常に完了していない場合は、USERNAME、USERHASH、MESSAGE-INTEGRITY、MESSAGE-INTEGRITY-SHA256、REALM、NONCE、PASSWORD-ALGORITHMS、およびPASSWORD-ALGORITHM属性を省略しなければなりません。つまり、最初の要求は、認証またはメッセージの整合性が適用されていないかのように送信されます。"
    },
    {
      "indent": 0,
      "text": "9.2.3.2. Subsequent Requests",
      "section_title": true,
      "ja": "9.2.3.2. 後続のリクエスト"
    },
    {
      "indent": 3,
      "text": "Once a request/response transaction has completed, the client will have been presented a realm and nonce by the server and selected a username and password with which it authenticated. The client SHOULD cache the username, password, realm, and nonce for subsequent communications with the server. When the client sends a subsequent request, it MUST include either the USERNAME or USERHASH, REALM, NONCE, and PASSWORD-ALGORITHM attributes with these cached values. It MUST include a MESSAGE-INTEGRITY attribute or a MESSAGE-INTEGRITY-SHA256 attribute, computed as described in Sections 14.5 and 14.6 using the cached password. The choice between the two attributes depends on the attribute received in the response to the first request.",
      "ja": "要求/応答トランザクションが完了すると、クライアントはサーバーからレルムとナンスを提示され、認証に使用するユーザー名とパスワードを選択します。クライアントは、サーバーとのその後の通信のために、ユーザー名、パスワード、レルム、およびナンスをキャッシュする必要があります。クライアントが後続のリクエストを送信するとき、これらのキャッシュされた値とともにUSERNAMEまたはUSERHASH、REALM、NONCE、およびPASSWORD-ALGORITHM属性のいずれかを含める必要があります。キャッシュされたパスワードを使用してセクション14.5および14.6で説明されているように計算された、MESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性を含める必要があります。2つの属性のどちらを選択するかは、最初の要求への応答で受信した属性によって異なります。"
    },
    {
      "indent": 0,
      "text": "9.2.4. Receiving a Request",
      "section_title": true,
      "ja": "9.2.4. リクエストの受信"
    },
    {
      "indent": 3,
      "text": "After the server has done the basic processing of a request, it performs the checks listed below in the order specified. Note that it is RECOMMENDED that the REALM value be the domain name of the provider of the STUN server:",
      "ja": "サーバーはリクエストの基本的な処理を行った後、指定された順序で以下のチェックを実行します。REALM値はSTUNサーバーのプロバイダーのドメイン名であることが推奨されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o If the message does not contain a MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute, the server MUST generate an error response with an error code of 401 (Unauthenticated). This response MUST include a REALM value. The response MUST include a NONCE, selected by the server. The server MUST NOT choose the same NONCE for two requests unless they have the same source IP address and port. The server MAY support alternate password algorithms, in which case it can list them in preferential order in a PASSWORD-ALGORITHMS attribute. If the server adds a PASSWORD-ALGORITHMS attribute, it MUST set the STUN Security Feature \"Password algorithms\" bit to 1. The server MAY support anonymous username, in which case it MUST set the STUN Security Feature \"Username anonymity\" bit set to 1. The response SHOULD NOT contain a USERNAME, USERHASH, MESSAGE-INTEGRITY, or MESSAGE-INTEGRITY-SHA256 attribute.",
      "ja": "o メッセージにMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれていない場合、サーバーはエラーコード401（未認証）のエラー応答を生成する必要があります。この応答にはREALM値を含める必要があります。応答には、サーバーによって選択されたNONCEが含まれている必要があります。サーバーは、送信元IPアドレスとポートが同じでない限り、2つの要求に対して同じNONCEを選択してはなりません（MUSTNOT）。サーバーは代替パスワードアルゴリズムをサポートする場合があります。その場合、サーバーはそれらをPASSWORD-ALGORITHMS属性に優先順にリストできます。サーバーがPASSWORD-ALGORITHMS属性を追加する場合、STUNセキュリティ機能の「パスワードアルゴリズム」ビットを1に設定する必要があります。サーバーは匿名ユーザー名をサポートできます。その場合、サーバーはSTUNセキュリティ機能の「ユーザー名匿名性」ビットを1に設定する必要があります。応答には、USERNAME、USERHASH、MESSAGE-INTEGRITY、またはMESSAGE-INTEGRITY-SHA256属性を含めるべきではありません。"
    },
    {
      "indent": 6,
      "text": "Note: Reusing a NONCE for different source IP addresses or ports was not explicitly forbidden in [RFC5389].",
      "ja": "注：[RFC5389]では、異なる送信元IPアドレスまたはポートにNONCEを再利用することは明示的に禁止されていませんでした。"
    },
    {
      "indent": 0,
      "text": " o If the message contains a MESSAGE-INTEGRITY or a MESSAGE-INTEGRITY-SHA256 attribute, but is missing either the USERNAME or USERHASH, REALM, or NONCE attribute, the server MUST generate an error response with an error code of 400 (Bad Request). This response SHOULD NOT include a USERNAME, USERHASH, NONCE, or REALM attribute. The response cannot contain a MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute, as the attributes required to generate them are missing.",
      "ja": "o メッセージにMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれているが、USERNAMEまたはUSERHASH、REALM、またはNONCE属性のいずれかが欠落している場合、サーバーはエラーコード400（不正な要求）でエラー応答を生成する必要があります。この応答には、USERNAME、USERHASH、NONCE、またはREALM属性を含めるべきではありません。応答には、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を含めることはできません。これらを生成するために必要な属性が欠落しているためです。"
    },
    {
      "indent": 3,
      "text": "o If the NONCE attribute starts with the \"nonce cookie\" with the STUN Security Feature \"Password algorithms\" bit set to 1, the server performs these checks in the order specified:",
      "ja": "o NONCE属性がSTUNセキュリティ機能の「パスワードアルゴリズム」ビットが1に設定された「noncecookie」で始まる場合、サーバーは指定された順序でこれらのチェックを実行します。"
    },
    {
      "indent": 6,
      "text": "* If the request contains neither the PASSWORD-ALGORITHMS nor the PASSWORD-ALGORITHM algorithm, then the request is processed as though PASSWORD-ALGORITHM were MD5.",
      "ja": "* リクエストにPASSWORD-ALGORITHMSアルゴリズムもPASSWORD-ALGORITHMアルゴリズムも含まれていない場合、リクエストはPASSWORD-ALGORITHMがMD5であるかのように処理されます。"
    },
    {
      "indent": 6,
      "text": "* Otherwise, unless (1) PASSWORD-ALGORITHM and PASSWORD-ALGORITHMS are both present, (2) PASSWORD-ALGORITHMS matches the value sent in the response that sent this NONCE, and (3) PASSWORD-ALGORITHM matches one of the entries in PASSWORD-ALGORITHMS, the server MUST generate an error response with an error code of 400 (Bad Request).",
      "ja": "* それ以外の場合、（1）PASSWORD-ALGORITHMとPASSWORD-ALGORITHMSの両方が存在しない限り、（2）PASSWORD-ALGORITHMSは、このNONCEを送信した応答で送信された値と一致し、（3）PASSWORD-ALGORITHMはPASSWORD-のエントリの1つと一致します。アルゴリズム、サーバーはエラーコード400（不正な要求）でエラー応答を生成しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "o If the value of the USERNAME or USERHASH attribute is not valid, the server MUST generate an error response with an error code of 401 (Unauthenticated). This response MUST include a REALM value. The response MUST include a NONCE, selected by the server. The response MUST include a PASSWORD-ALGORITHMS attribute. The response SHOULD NOT contain a USERNAME or USERHASH attribute. The response MAY include a MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute, using the previous key to calculate it.",
      "ja": "o USERNAMEまたはUSERHASH属性の値が有効でない場合、サーバーはエラーコード401（認証されていない）でエラー応答を生成する必要があります。この応答にはREALM値を含める必要があります。応答には、サーバーによって選択されたNONCEが含まれている必要があります。応答には、PASSWORD-ALGORITHMS属性を含める必要があります。応答には、USERNAMEまたはUSERHASH属性を含めるべきではありません（SHOULDNOT）。応答には、前のキーを使用して計算するMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "o If the MESSAGE-INTEGRITY-SHA256 attribute is present, compute the value for the message integrity as described in Section 14.6, using the password associated with the username. Otherwise, using the same password, compute the value for the MESSAGE-INTEGRITY attribute as described in Section 14.5. If the resulting value does not match the contents of the MESSAGE-INTEGRITY attribute or the MESSAGE-INTEGRITY-SHA256 attribute, the server MUST reject the request with an error response. This response MUST use an error code of 401 (Unauthenticated). It MUST include the REALM and NONCE attributes and SHOULD NOT include the USERNAME, USERHASH, MESSAGE-INTEGRITY, or MESSAGE-INTEGRITY-SHA256 attribute.",
      "ja": "o MESSAGE-INTEGRITY-SHA256属性が存在する場合は、ユーザー名に関連付けられたパスワードを使用して、セクション14.6の説明に従ってメッセージの整合性の値を計算します。それ以外の場合は、同じパスワードを使用して、セクション14.5の説明に従ってMESSAGE-INTEGRITY属性の値を計算します。結果の値がMESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性の内容と一致しない場合、サーバーはエラー応答で要求を拒否する必要があります。この応答は、401（未認証）のエラーコードを使用する必要があります。REALM属性とNONCE属性を含める必要があり、USERNAME、USERHASH、MESSAGE-INTEGRITY、またはMESSAGE-INTEGRITY-SHA256属性を含めるべきではありません。"
    },
    {
      "indent": 0,
      "text": " o If the NONCE is no longer valid, the server MUST generate an error response with an error code of 438 (Stale Nonce). This response MUST include NONCE, REALM, and PASSWORD-ALGORITHMS attributes and SHOULD NOT include the USERNAME and USERHASH attributes. The NONCE attribute value MUST be valid. The response MAY include a MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute, using the previous NONCE to calculate it. Servers can revoke nonces in order to provide additional security. See Section 5.4 of [RFC7616] for guidelines.",
      "ja": "o NONCEが無効になった場合、サーバーはエラーコード438（Stale Nonce）のエラー応答を生成する必要があります。この応答には、NONCE、REALM、およびPASSWORD-ALGORITHMS属性を含める必要があり、USERNAME属性とUSERHASH属性を含めるべきではありません。NONCE属性値は有効でなければなりません。応答には、前のNONCEを使用して計算するMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれる場合があります。サーバーは、追加のセキュリティを提供するためにナンスを取り消すことができます。ガイドラインについては、[RFC7616]のセクション5.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "If these checks pass, the server continues to process the request. Any response generated by the server MUST include the MESSAGE-INTEGRITY-SHA256 attribute, computed using the username and password utilized to authenticate the request, unless the request was processed as though PASSWORD-ALGORITHM was MD5 (because the request contained neither PASSWORD-ALGORITHMS nor PASSWORD-ALGORITHM). In that case, the MESSAGE-INTEGRITY attribute MUST be used instead of the MESSAGE-INTEGRITY-SHA256 attribute, and the REALM, NONCE, USERNAME, and USERHASH attributes SHOULD NOT be included.",
      "ja": "これらのチェックに合格すると、サーバーは引き続き要求を処理します。PASSWORD-ALGORITHMがMD5であるかのように要求が処理された場合を除き、サーバーによって生成される応答には、要求の認証に使用されるユーザー名とパスワードを使用して計算されたMESSAGE-INTEGRITY-SHA256属性を含める必要があります（要求にPASSWORD-ALGORITHMSもPASSWORD-ALGORITHMも含まれていないため）。その場合、MESSAGE-INTEGRITY-SHA256属性の代わりにMESSAGE-INTEGRITY属性を使用する必要があり、REALM、NONCE、USERNAME、およびUSERHASH属性を含めるべきではありません。"
    },
    {
      "indent": 0,
      "text": "9.2.5. Receiving a Response",
      "section_title": true,
      "ja": "9.2.5. 応答の受信"
    },
    {
      "indent": 3,
      "text": "If the response is an error response with an error code of 401 (Unauthenticated) or 438 (Stale Nonce), the client MUST test if the NONCE attribute value starts with the \"nonce cookie\". If so and the \"nonce cookie\" has the STUN Security Feature \"Password algorithms\" bit set to 1 but no PASSWORD-ALGORITHMS attribute is present, then the client MUST NOT retry the request with a new transaction.",
      "ja": "応答がエラーコード401（認証されていない）または438（古いNonce）のエラー応答である場合、クライアントはNONCE属性値が「noncecookie」で始まるかどうかをテストする必要があります。その場合、「noncecookie」のSTUNセキュリティ機能の「Passwordalgorithms」ビットが1に設定されているが、PASSWORD-ALGORITHMS属性が存在しない場合、クライアントは新しいトランザクションで要求を再試行してはなりません（MUSTNOT）。"
    },
    {
      "indent": 3,
      "text": "If the response is an error response with an error code of 401 (Unauthenticated), the client SHOULD retry the request with a new transaction. This request MUST contain a USERNAME or a USERHASH, determined by the client as the appropriate username for the REALM from the error response. If the \"nonce cookie\" is present and has the STUN Security Feature \"Username anonymity\" bit set to 1, then the USERHASH attribute MUST be used; else, the USERNAME attribute MUST be used. The request MUST contain the REALM, copied from the error response. The request MUST contain the NONCE, copied from the error response. If the response contains a PASSWORD-ALGORITHMS attribute, the request MUST contain the PASSWORD-ALGORITHMS attribute with the same content. If the response contains a PASSWORD-ALGORITHMS attribute, and this attribute contains at least one algorithm that is supported by the client, then the request MUST contain a PASSWORD-ALGORITHM attribute with the first algorithm supported on the list. If the response contains a PASSWORD-ALGORITHMS attribute, and this attribute does not contain any algorithm that is supported by the client, then the client MUST NOT retry the request with a new transaction. The client MUST NOT perform this retry if it is not changing the USERNAME, USERHASH, REALM, or its associated password from the previous attempt.",
      "ja": "応答がエラーコード401（認証されていない）のエラー応答である場合、クライアントは新しいトランザクションで要求を再試行する必要があります。この要求には、エラー応答からREALMの適切なユーザー名としてクライアントによって決定されたUSERNAMEまたはUSERHASHが含まれている必要があります。 「noncecookie」が存在し、STUNセキュリティ機能の「Usernameanonymity」ビットが1に設定されている場合は、USERHASH属性を使用する必要があります。それ以外の場合は、USERNAME属性を使用する必要があります。要求には、エラー応答からコピーされたREALMが含まれている必要があります。要求には、エラー応答からコピーされたNONCEが含まれている必要があります。応答にPASSWORD-ALGORITHMS属性が含まれている場合、要求には同じ内容のPASSWORD-ALGORITHMS属性が含まれている必要があります。応答にPASSWORD-ALGORITHMS属性が含まれ、この属性にクライアントでサポートされているアルゴリズムが少なくとも1つ含まれている場合、要求には、リストでサポートされている最初のアルゴリズムを持つPASSWORD-ALGORITHM属性が含まれている必要があります。応答にPASSWORD-ALGORITHMS属性が含まれ、この属性にクライアントがサポートするアルゴリズムが含まれていない場合、クライアントは新しいトランザクションで要求を再試行してはなりません（MUSTNOT）。クライアントは、前回の試行からUSERNAME、USERHASH、REALM、またはそれに関連するパスワードを変更していない場合、この再試行を実行してはなりません（MUSTNOT）。"
    },
    {
      "indent": 3,
      "text": "If the response is an error response with an error code of 438 (Stale Nonce), the client MUST retry the request, using the new NONCE attribute supplied in the 438 (Stale Nonce) response. This retry MUST also include either the USERNAME or USERHASH, the REALM, and either the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute.",
      "ja": "応答がエラーコード438（Stale Nonce）のエラー応答である場合、クライアントは438（Stale Nonce）応答で提供される新しいNONCE属性を使用して、要求を再試行する必要があります。この再試行には、USERNAMEまたはUSERHASH、REALM、およびMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性のいずれかを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "For all other responses, if the NONCE attribute starts with the \"nonce cookie\" with the STUN Security Feature \"Password algorithms\" bit set to 1 but PASSWORD-ALGORITHMS is not present, the response MUST be ignored.",
      "ja": "他のすべての応答では、NONCE属性がSTUNセキュリティ機能の「パスワードアルゴリズム」ビットが1に設定された「noncecookie」で始まるが、PASSWORD-ALGORITHMSが存在しない場合、応答は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the response is an error response with an error code of 400 (Bad Request) and does not contain either the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute, then the response MUST be discarded, as if it were never received. This means that retransmits, if applicable, will continue.",
      "ja": "応答がエラーコード400（Bad Request）のエラー応答であり、MESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性のいずれも含まれていない場合、応答は受信されなかったかのように破棄する必要があります。これは、該当する場合、再送信が続行されることを意味します。"
    },
    {
      "indent": 6,
      "text": "Note: In this case, the 400 response will never reach the application, resulting in a timeout.",
      "ja": "注：この場合、400応答がアプリケーションに到達することはなく、タイムアウトが発生します。"
    },
    {
      "indent": 3,
      "text": "The client looks for the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute in the response (either success or failure). If present, the client computes the message integrity over the response as defined in Sections 14.5 or 14.6, using the same password it utilized for the request. If the resulting value matches the contents of the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute, the response is considered authenticated. If the value does not match, or if both MESSAGE-INTEGRITY and MESSAGE-INTEGRITY-SHA256 are absent, the processing depends on the request being sent over a reliable or an unreliable transport.",
      "ja": "クライアントは、応答（成功または失敗）でMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を探します。存在する場合、クライアントは、セクション14.5または14.6で定義されているように、要求に使用したのと同じパスワードを使用して、応答に対するメッセージの整合性を計算します。結果の値がMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性の内容と一致する場合、応答は認証済みと見なされます。値が一致しない場合、またはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方が存在しない場合、処理は、信頼できるトランスポートまたは信頼できないトランスポートを介して送信される要求に依存します。"
    },
    {
      "indent": 3,
      "text": "If the request was sent over an unreliable transport, the response MUST be discarded, as if it had never been received. This means that retransmits, if applicable, will continue. If all the responses received are discarded, then instead of signaling a timeout after ending the transaction, the layer MUST signal that the integrity protection was violated.",
      "ja": "要求が信頼性の低いトランスポートを介して送信された場合、応答は受信されたことがないかのように破棄する必要があります。これは、該当する場合、再送信が続行されることを意味します。受信したすべての応答が破棄された場合、トランザクションの終了後にタイムアウトを通知する代わりに、レイヤーは整合性保護に違反したことを通知する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the request was sent over a reliable transport, the response MUST be discarded, and the layer MUST immediately end the transaction and signal that the integrity protection was violated.",
      "ja": "要求が信頼できるトランスポートを介して送信された場合、応答は破棄されなければならず、レイヤーはトランザクションを直ちに終了し、整合性保護に違反したことを通知しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the response contains a PASSWORD-ALGORITHMS attribute, all the subsequent requests MUST be authenticated using MESSAGE-INTEGRITY-SHA256 only.",
      "ja": "応答にPASSWORD-ALGORITHMS属性が含まれている場合、後続のすべての要求は、MESSAGE-INTEGRITY-SHA256のみを使用して認証される必要があります。"
    },
    {
      "indent": 0,
      "text": "10. ALTERNATE-SERVER Mechanism",
      "section_title": true,
      "ja": "10. ALTERNATE-SERVERメカニズム"
    },
    {
      "indent": 3,
      "text": "This section describes a mechanism in STUN that allows a server to redirect a client to another server. This extension is optional, and a usage must define if and when this extension is used. The ALTERNATE-SERVER attribute carries an IP address.",
      "ja": "このセクションでは、サーバーがクライアントを別のサーバーにリダイレクトできるようにするSTUNのメカニズムについて説明します。この拡張機能はオプションであり、使用法では、この拡張機能を使用するかどうか、いつ使用するかを定義する必要があります。ALTERNATE-SERVER属性はIPアドレスを伝達します。"
    },
    {
      "indent": 3,
      "text": "A server using this extension redirects a client to another server by replying to a request message with an error response message with an error code of 300 (Try Alternate). The server MUST include at least one ALTERNATE-SERVER attribute in the error response, which MUST contain an IP address of the same address family as the source IP address of the request message. The server SHOULD include an additional ALTERNATE-SERVER attribute, after the mandatory one, that contains an IP address of the address family other than the source IP address of the request message. The error response message MAY be authenticated; however, there are use cases for ALTERNATE-SERVER where authentication of the response is not possible or practical. If the transaction uses TLS or DTLS, if the transaction is authenticated by a MESSAGE-INTEGRITY-SHA256 attribute, and if the server wants to redirect to a server that uses a different certificate, then it MUST include an ALTERNATE-DOMAIN attribute containing the name inside the subjectAltName of that certificate. This series of conditions on the MESSAGE-INTEGRITY-SHA256 attribute indicates that the transaction is authenticated and that the client implements this specification and therefore can process the ALTERNATE-DOMAIN attribute.",
      "ja": "この拡張機能を使用するサーバーは、エラーコード300（代替を試す）のエラー応答メッセージを含む要求メッセージに応答することにより、クライアントを別のサーバーにリダイレクトします。サーバーは、エラー応答に少なくとも1つのALTERNATE-SERVER属性を含める必要があります。この属性には、要求メッセージの送信元IPアドレスと同じアドレスファミリのIPアドレスを含める必要があります。サーバーは、必須の属性の後に、要求メッセージの送信元IPアドレス以外のアドレスファミリーのIPアドレスを含む追加のALTERNATE-SERVER属性を含める必要があります。エラー応答メッセージは認証される場合があります。ただし、ALTERNATE-SERVERの使用例では、応答の認証が不可能または実用的ではありません。トランザクションがTLSまたはDTLSを使用し、トランザクションがMESSAGE-INTEGRITY-SHA256属性によって認証され、サーバーが別の証明書を使用するサーバーにリダイレクトする場合は、その証明書のsubjectAltName内の名前を含むALTERNATE-DOMAIN属性を含める必要があります。MESSAGE-INTEGRITY-SHA256属性に関するこの一連の条件は、トランザクションが認証されており、クライアントがこの仕様を実装しているため、ALTERNATE-DOMAIN属性を処理できることを示しています。"
    },
    {
      "indent": 3,
      "text": "A client using this extension handles a 300 (Try Alternate) error code as follows. The client looks for an ALTERNATE-SERVER attribute in the error response. If one is found, then the client considers the current transaction as failed and reattempts the request with the server specified in the attribute, using the same transport protocol used for the previous request. That request, if authenticated, MUST utilize the same credentials that the client would have used in the request to the server that performed the redirection. If the transport protocol uses TLS or DTLS, then the client looks for an ALTERNATE-DOMAIN attribute. If the attribute is found, the domain MUST be used to validate the certificate using the recommendations in [RFC6125]. The certificate MUST contain an identifier of type DNS-ID or CN-ID (eventually with wildcards) but not of type SRV-ID or URI-ID. If the attribute is not found, the same domain that was used for the original request MUST be used to validate the certificate. If the client has been redirected to a server to which it has already sent this request within the last five minutes, it MUST ignore the redirection and consider the transaction to have failed. This prevents infinite ping-ponging between servers in case of redirection loops.",
      "ja": "この拡張機能を使用するクライアントは、300（代替を試す）エラーコードを次のように処理します。クライアントは、エラー応答でALTERNATE-SERVER属性を探します。見つかった場合、クライアントは現在のトランザクションが失敗したと見なし、前の要求に使用されたのと同じトランスポートプロトコルを使用して、属性で指定されたサーバーで要求を再試行します。その要求は、認証された場合、リダイレクトを実行したサーバーへの要求でクライアントが使用したのと同じ資格情報を利用する必要があります。トランスポートプロトコルがTLSまたはDTLSを使用する場合、クライアントはALTERNATE-DOMAIN属性を探します。属性が見つかった場合は、ドメインを使用して、[RFC6125]の推奨事項を使用して証明書を検証する必要があります。証明書には、タイプDNS-IDまたはCN-ID（最終的にはワイルドカードを含む）の識別子が含まれている必要がありますが、タイプSRV-IDまたはURI-IDは含まれていません。属性が見つからない場合は、元の要求に使用されたのと同じドメインを使用して証明書を検証する必要があります。クライアントが過去5分以内にこの要求を送信したサーバーにリダイレクトされた場合、クライアントはリダイレクトを無視し、トランザクションが失敗したと見なす必要があります。これにより、リダイレクトループが発生した場合にサーバー間で無限にpingが実行されるのを防ぎます。"
    },
    {
      "indent": 0,
      "text": "11. Backwards Compatibility with RFC 3489",
      "section_title": true,
      "ja": "11. RFC3489との下位互換性"
    },
    {
      "indent": 3,
      "text": "In addition to the backward compatibility already described in Section 12 of [RFC5389], DTLS MUST NOT be used with [RFC3489] (referred to as \"classic STUN\"). Any STUN request or indication without the magic cookie (see Section 6 of [RFC5389]) over DTLS MUST be considered invalid: all requests MUST generate a 500 (Server Error) error response, and indications MUST be ignored.",
      "ja": "[RFC5389]のセクション12ですでに説明されている下位互換性に加えて、DTLSを[RFC3489]（「クラシックSTUN」と呼ばれる）と一緒に使用してはなりません（MUSTNOT）。DTLSを介したマジッククッキー（[RFC5389]のセクション6を参照）のないSTUNリクエストまたは表示は無効と見なす必要があります。すべてのリクエストは500（サーバーエラー）エラー応答を生成する必要があり、表示は無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "12. Basic Server Behavior",
      "section_title": true,
      "ja": "12. サーバーの基本的な動作"
    },
    {
      "indent": 3,
      "text": "This section defines the behavior of a basic, stand-alone STUN server.",
      "ja": "このセクションでは、基本的なスタンドアロンのSTUNサーバーの動作を定義します。"
    },
    {
      "indent": 3,
      "text": "Historically, \"classic STUN\" [RFC3489] only defined the behavior of a server that was providing clients with server reflexive transport addresses by receiving and replying to STUN Binding requests. [RFC5389] redefined the protocol as an extensible framework, and the server functionality became the sole STUN Usage defined in that document. This STUN Usage is also known as \"Basic STUN Server\".",
      "ja": "歴史的に、「クラシックSTUN」[RFC3489]は、STUNバインディング要求を受信して応答することにより、クライアントにサーバー再帰トランスポートアドレスを提供していたサーバーの動作のみを定義していました。[RFC5389]は、プロトコルを拡張可能なフレームワークとして再定義し、サーバー機能は、そのドキュメントで定義されている唯一のSTUN使用法になりました。このSTUNの使用法は、「基本的なSTUNサーバー」とも呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The STUN server MUST support the Binding method. It SHOULD NOT utilize the short-term or long-term credential mechanism. This is because the work involved in authenticating the request is more than the work in simply processing it. It SHOULD NOT utilize the ALTERNATE-SERVER mechanism for the same reason. It MUST support UDP and TCP. It MAY support STUN over TCP/TLS or STUN over UDP/DTLS; however, DTLS and TLS provide minimal security benefits in this basic mode of operation. It does not require a keep-alive mechanism because a TCP or TLS-over-TCP connection is closed after the end of the Binding transaction. It MAY utilize the FINGERPRINT mechanism but MUST NOT require it. Since the stand-alone server only runs STUN, FINGERPRINT provides no benefit. Requiring it would break compatibility with RFC 3489, and such compatibility is desirable in a stand-alone server. Stand-alone STUN servers SHOULD support backwards compatibility with clients using [RFC3489], as described in Section 11.",
      "ja": "STUNサーバーはBindingメソッドをサポートしなければなりません（MUST）。短期または長期の資格情報メカニズムを利用するべきではありません。これは、リクエストの認証に関連する作業が、単にリクエストを処理する作業以上のものであるためです。同じ理由で、ALTERNATE-SERVERメカニズムを利用すべきではありません。UDPとTCPをサポートする必要があります。STUN over TCP / TLSまたはSTUNover UDP / DTLSをサポートする場合があります。ただし、DTLSとTLSは、この基本的な操作モードで最小限のセキュリティ上の利点を提供します。バインディングトランザクションの終了後にTCPまたはTLS-over-TCP接続が閉じられるため、キープアライブメカニズムは必要ありません。FINGERPRINTメカニズムを利用できますが、必須ではありません。スタンドアロンサーバーはSTUNのみを実行するため、FINGERPRINTにはメリットがありません。それを要求するとRFC3489との互換性が失われ、そのような互換性はスタンドアロンサーバーで望ましいものです。スタンドアロンのSTUNサーバーは、セクション11で説明されているように、[RFC3489]を使用するクライアントとの下位互換性をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that administrators of STUN servers provide DNS entries for those servers as described in Section 8. If both A and AAAA resource records are returned, then the client can simultaneously send STUN Binding requests to the IPv4 and IPv6 addresses (as specified in [RFC8305]), as the Binding request is idempotent. Note that the MAPPED-ADDRESS or XOR-MAPPED-ADDRESS attributes that are returned will not necessarily match the address family of the server address used.",
      "ja": "セクション8で説明されているように、STUNサーバーの管理者がそれらのサーバーにDNSエントリを提供することをお勧めします。AリソースレコードとAAAAリソースレコードの両方が返された場合、クライアントはIPv4アドレスとIPv6アドレスにSTUNバインディング要求を同時に送信できます（[RFC8305]）、バインディング要求は同一であるため。返されるMAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS属性は、使用されるサーバーアドレスのアドレスファミリと必ずしも一致しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "A basic STUN server is not a solution for NAT traversal by itself. However, it can be utilized as part of a solution through STUN Usages. This is discussed further in Section 13.",
      "ja": "基本的なSTUNサーバーは、それ自体ではNATトラバーサルのソリューションではありません。ただし、STUNUsageを介してソリューションの一部として利用できます。これについては、セクション13で詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "13. STUN Usages",
      "section_title": true,
      "ja": "13. スタンの使用法"
    },
    {
      "indent": 3,
      "text": "STUN by itself is not a solution to the NAT traversal problem. Rather, STUN defines a tool that can be used inside a larger solution. The term \"STUN Usage\" is used for any solution that uses STUN as a component.",
      "ja": "STUN自体は、NATトラバーサル問題の解決策ではありません。むしろ、STUNは、より大きなソリューション内で使用できるツールを定義します。「STUN Usages」という用語は、STUNをコンポーネントとして使用するすべてのソリューションに使用されます。"
    },
    {
      "indent": 3,
      "text": "A STUN Usage defines how STUN is actually utilized -- when to send requests, what to do with the responses, and which optional procedures defined here (or in an extension to STUN) are to be used. A usage also defines:",
      "ja": "STUNの使用法は、STUNが実際にどのように使用されるかを定義します。つまり、要求を送信するタイミング、応答を処理する方法、およびここで（またはSTUNの拡張で）定義されたオプションの手順を使用します。使用法はまた定義します："
    },
    {
      "indent": 3,
      "text": "o Which STUN methods are used.",
      "ja": "o どのSTUNメソッドが使用されますか。"
    },
    {
      "indent": 3,
      "text": "o What transports are used. If DTLS-over-UDP is used, then implementing the denial-of-service countermeasure described in Section 4.2.1 of [RFC6347] is mandatory.",
      "ja": "o 使用されるトランスポート。DTLS-over-UDPを使用する場合は、[RFC6347]のセクション4.2.1で説明されているサービス拒否対策の実装が必須です。"
    },
    {
      "indent": 3,
      "text": "o What authentication and message-integrity mechanisms are used.",
      "ja": "o どの認証およびメッセージ整合性メカニズムが使用されているか。"
    },
    {
      "indent": 3,
      "text": "o The considerations around manual vs. automatic key derivation for the integrity mechanism, as discussed in [RFC4107].",
      "ja": "o [RFC4107]で説明されているように、整合性メカニズムの手動キー導出と自動キー導出に関する考慮事項。"
    },
    {
      "indent": 3,
      "text": "o What mechanisms are used to distinguish STUN messages from other messages. When STUN is run over TCP or TLS-over-TCP, a framing mechanism may be required.",
      "ja": "o STUNメッセージを他のメッセージと区別するために使用されるメカニズム。STUNがTCPまたはTLS-over-TCPで実行される場合、フレーミングメカニズムが必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "o How a STUN client determines the IP address and port of the STUN server.",
      "ja": "o STUNクライアントがSTUNサーバーのIPアドレスとポートを決定する方法。"
    },
    {
      "indent": 3,
      "text": "o How simultaneous use of IPv4 and IPv6 addresses (Happy Eyeballs [RFC8305]) works with non-idempotent transactions when both address families are found for the STUN server.",
      "ja": "o STUNサーバーで両方のアドレスファミリが見つかった場合に、IPv4アドレスとIPv6アドレス（Happy Eyeballs [RFC8305]）の同時使用が非べき等トランザクションでどのように機能するか。"
    },
    {
      "indent": 3,
      "text": "o Whether backwards compatibility to RFC 3489 is required.",
      "ja": "o RFC3489への下位互換性が必要かどうか。"
    },
    {
      "indent": 3,
      "text": "o What optional attributes defined here (such as FINGERPRINT and ALTERNATE-SERVER) or in other extensions are required.",
      "ja": "o ここで定義されているオプションの属性（FINGERPRINTやALTERNATE-SERVERなど）または他の拡張機能が必要です。"
    },
    {
      "indent": 3,
      "text": "o If MESSAGE-INTEGRITY-SHA256 truncation is permitted, and the limits permitted for truncation.",
      "ja": "o MESSAGE-INTEGRITY-SHA256の切り捨てが許可され、制限が切り捨てが許可されている場合。"
    },
    {
      "indent": 3,
      "text": "o The keep-alive mechanism if STUN is run over TCP or TLS-over-TCP.",
      "ja": "o STUNがTCPまたはTLS-over-TCPで実行されている場合のキープアライブメカニズム。"
    },
    {
      "indent": 3,
      "text": "o If anycast addresses can be used for the server in case 1) TCP or TLS-over-TCP or 2) authentication is used.",
      "ja": "o 1）TCPまたはTLS-over-TCP、または2）認証が使用されている場合に、サーバーにエニーキャストアドレスを使用できる場合。"
    },
    {
      "indent": 3,
      "text": "In addition, any STUN Usage must consider the security implications of using STUN in that usage. A number of attacks against STUN are known (see the Security Considerations section in this document), and any usage must consider how these attacks can be thwarted or mitigated.",
      "ja": "さらに、STUNの使用法では、その使用法でSTUNを使用することによるセキュリティへの影響を考慮する必要があります。STUNに対する多くの攻撃が知られており（このドキュメントの「セキュリティに関する考慮事項」セクションを参照）、どのような使用法でも、これらの攻撃をどのように阻止または軽減できるかを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, a usage must consider whether its usage of STUN is an example of the Unilateral Self-Address Fixing approach to NAT traversal and, if so, address the questions raised in RFC 3424 [RFC3424].",
      "ja": "最後に、使用法では、STUNの使用法がNATトラバーサルに対する一方的な自己アドレス修正アプローチの例であるかどうかを検討し、そうである場合は、RFC 3424 [RFC3424]で提起された質問に対処する必要があります。"
    },
    {
      "indent": 0,
      "text": "14. STUN Attributes",
      "section_title": true,
      "ja": "14. STUN属性"
    },
    {
      "indent": 3,
      "text": "After the STUN header are zero or more attributes. Each attribute MUST be TLV encoded, with a 16-bit type, 16-bit length, and value. Each STUN attribute MUST end on a 32-bit boundary. As mentioned above, all fields in an attribute are transmitted most significant bit first.",
      "ja": "STUNヘッダーの後は、0個以上の属性です。各属性は、16ビットタイプ、16ビット長、および値でTLVエンコードする必要があります。各STUN属性は、32ビット境界で終了する必要があります。上記のように、属性内のすべてのフィールドは最上位ビットから最初に送信されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Type                  |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Value (variable)                ....\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 4: Format of STUN Attributes",
      "ja": "図4：STUN属性のフォーマット"
    },
    {
      "indent": 3,
      "text": "The value in the Length field MUST contain the length of the Value part of the attribute, prior to padding, measured in bytes. Since STUN aligns attributes on 32-bit boundaries, attributes whose content is not a multiple of 4 bytes are padded with 1, 2, or 3 bytes of padding so that its value contains a multiple of 4 bytes. The padding bits MUST be set to zero on sending and MUST be ignored by the receiver.",
      "ja": "長さフィールドの値には、パディング前の属性の値部分の長さがバイト単位で含まれている必要があります。STUNは属性を32ビット境界に揃えるため、内容が4バイトの倍数ではない属性には、1、2、または3バイトのパディングが埋め込まれ、その値には4バイトの倍数が含まれます。パディングビットは、送信時にゼロに設定する必要があり、受信者は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Any attribute type MAY appear more than once in a STUN message. Unless specified otherwise, the order of appearance is significant: only the first occurrence needs to be processed by a receiver, and any duplicates MAY be ignored by a receiver.",
      "ja": "すべての属性タイプは、STUNメッセージに複数回表示される場合があります。特に明記されていない限り、出現の順序は重要です。最初の出現のみを受信者が処理する必要があり、重複は受信者によって無視される場合があります。"
    },
    {
      "indent": 0,
      "text": " To allow future revisions of this specification to add new attributes if needed, the attribute space is divided into two ranges. Attributes with type values between 0x0000 and 0x7FFF are comprehension-required attributes, which means that the STUN agent cannot successfully process the message unless it understands the attribute. Attributes with type values between 0x8000 and 0xFFFF are comprehension-optional attributes, which means that those attributes can be ignored by the STUN agent if it does not understand them.",
      "ja": "この仕様の将来の改訂で必要に応じて新しい属性を追加できるようにするために、属性スペースは2つの範囲に分割されています。タイプ値が0x0000〜0x7FFFの属性は、理解が必要な属性です。つまり、STUNエージェントは、属性を理解しない限り、メッセージを正常に処理できません。タイプ値が0x8000〜0xFFFFの属性は、理解オプションの属性です。つまり、STUNエージェントがそれらを理解しない場合、これらの属性は無視できます。"
    },
    {
      "indent": 3,
      "text": "The set of STUN attribute types is maintained by IANA. The initial set defined by this specification is found in Section 18.3.",
      "ja": "STUN属性タイプのセットはIANAによって維持されます。この仕様で定義されている初期セットは、セクション18.3にあります。"
    },
    {
      "indent": 3,
      "text": "The rest of this section describes the format of the various attributes defined in this specification.",
      "ja": "このセクションの残りの部分では、この仕様で定義されているさまざまな属性の形式について説明します。"
    },
    {
      "indent": 0,
      "text": "14.1. MAPPED-ADDRESS",
      "section_title": true,
      "ja": "14.1. マップされたアドレス"
    },
    {
      "indent": 3,
      "text": "The MAPPED-ADDRESS attribute indicates a reflexive transport address of the client. It consists of an 8-bit address family and a 16-bit port, followed by a fixed-length value representing the IP address. If the address family is IPv4, the address MUST be 32 bits. If the address family is IPv6, the address MUST be 128 bits. All fields must be in network byte order.",
      "ja": "MAPPED-ADDRESS属性は、クライアントの反射トランスポートアドレスを示します。これは、8ビットアドレスファミリと16ビットポートで構成され、その後にIPアドレスを表す固定長の値が続きます。アドレスファミリがIPv4の場合、アドレスは32ビットである必要があります。アドレスファミリがIPv6の場合、アドレスは128ビットである必要があります。すべてのフィールドはネットワークバイトオーダーである必要があります。"
    },
    {
      "indent": 3,
      "text": "The format of the MAPPED-ADDRESS attribute is:",
      "ja": "MAPPED-ADDRESS属性の形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0|    Family     |           Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 Address (32 bits or 128 bits)                 |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 5: Format of MAPPED-ADDRESS Attribute",
      "ja": "図5：MAPPED-ADDRESS属性のフォーマット"
    },
    {
      "indent": 3,
      "text": "The address family can take on the following values:",
      "ja": "アドレスファミリは、次の値を取ることができます。"
    },
    {
      "indent": 3,
      "text": "0x01:IPv4 0x02:IPv6",
      "ja": "0x01：IPv4 0x02：IPv6"
    },
    {
      "indent": 3,
      "text": "The first 8 bits of the MAPPED-ADDRESS MUST be set to 0 and MUST be ignored by receivers. These bits are present for aligning parameters on natural 32-bit boundaries.",
      "ja": "MAPPED-ADDRESSの最初の8ビットは0に設定する必要があり、レシーバーは無視する必要があります。これらのビットは、自然な32ビット境界でパラメーターを整列させるために存在します。"
    },
    {
      "indent": 3,
      "text": "This attribute is used only by servers for achieving backwards compatibility with [RFC3489] clients.",
      "ja": "この属性は、[RFC3489]クライアントとの下位互換性を実現するためにサーバーによってのみ使用されます。"
    },
    {
      "indent": 0,
      "text": "14.2. XOR-MAPPED-ADDRESS",
      "section_title": true,
      "ja": "14.2. XOR-MAPPED-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The XOR-MAPPED-ADDRESS attribute is identical to the MAPPED-ADDRESS attribute, except that the reflexive transport address is obfuscated through the XOR function.",
      "ja": "XOR-MAPPED-ADDRESS属性は、反射トランスポートアドレスがXOR関数によって難読化されることを除いて、MAPPED-ADDRESS属性と同じです。"
    },
    {
      "indent": 3,
      "text": "The format of the XOR-MAPPED-ADDRESS is:",
      "ja": "XOR-MAPPED-ADDRESSの形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0|    Family     |         X-Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                X-Address (Variable)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 6: Format of XOR-MAPPED-ADDRESS Attribute",
      "ja": "図6：XOR-MAPPED-ADDRESS属性のフォーマット"
    },
    {
      "indent": 3,
      "text": "The Family field represents the IP address family and is encoded identically to the Family field in MAPPED-ADDRESS.",
      "ja": "ファミリフィールドはIPアドレスファミリを表し、MAPPED-ADDRESSのファミリフィールドと同じようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "X-Port is computed by XOR'ing the mapped port with the most significant 16 bits of the magic cookie. If the IP address family is IPv4, X-Address is computed by XOR'ing the mapped IP address with the magic cookie. If the IP address family is IPv6, X-Address is computed by XOR'ing the mapped IP address with the concatenation of the magic cookie and the 96-bit transaction ID. In all cases, the XOR operation works on its inputs in network byte order (that is, the order they will be encoded in the message).",
      "ja": "X-Portは、マップされたポートをマジッククッキーの最上位16ビットとXORすることによって計算されます。IPアドレスファミリがIPv4の場合、Xアドレスは、マップされたIPアドレスをマジッククッキーとXORすることによって計算されます。IPアドレスファミリがIPv6の場合、Xアドレスは、マップされたIPアドレスをマジックCookieと96ビットトランザクションIDを連結してXORすることによって計算されます。すべての場合において、XOR演算は、ネットワークバイトオーダー（つまり、メッセージにエンコードされるオーダー）で入力に対して機能します。"
    },
    {
      "indent": 3,
      "text": "The rules for encoding and processing the first 8 bits of the attribute's value, the rules for handling multiple occurrences of the attribute, and the rules for processing address families are the same as for MAPPED-ADDRESS.",
      "ja": "属性の値の最初の8ビットをエンコードおよび処理するための規則、属性の複数の出現を処理するための規則、およびアドレスファミリを処理するための規則は、MAPPED-ADDRESSの場合と同じです。"
    },
    {
      "indent": 3,
      "text": "Note: XOR-MAPPED-ADDRESS and MAPPED-ADDRESS differ only in their encoding of the transport address. The former encodes the transport address by XOR'ing it with the magic cookie. The latter encodes it directly in binary. RFC 3489 originally specified only MAPPED-ADDRESS. However, deployment experience found that some NATs rewrite the 32-bit binary payloads containing the NAT's public IP address, such as STUN's MAPPED-ADDRESS attribute, in the well-meaning but misguided attempt to provide a generic Application Layer Gateway (ALG) function. Such behavior interferes with the operation of STUN and also causes failure of STUN's message-integrity checking.",
      "ja": "注：XOR-MAPPED-ADDRESSとMAPPED-ADDRESSは、トランスポートアドレスのエンコードのみが異なります。前者は、マジッククッキーとXORすることによってトランスポートアドレスをエンコードします。後者はそれをバイナリで直接エンコードします。RFC 3489は、もともとMAPPED-ADDRESSのみを指定していました。ただし、展開の経験から、一部のNATは、STUNのMAPPED-ADDRESS属性などのNATのパブリックIPアドレスを含む32ビットのバイナリペイロードを、一般的なアプリケーション層ゲートウェイ（ALG）機能を提供するための善意のある誤った試みで書き換えることがわかりました。このような動作はSTUNの動作を妨害し、STUNのメッセージ整合性チェックの失敗も引き起こします。"
    },
    {
      "indent": 0,
      "text": "14.3. USERNAME",
      "section_title": true,
      "ja": "14.3. ユーザー名"
    },
    {
      "indent": 3,
      "text": "The USERNAME attribute is used for message integrity. It identifies the username and password combination used in the message-integrity check.",
      "ja": "USERNAME属性は、メッセージの整合性のために使用されます。メッセージ整合性チェックで使用されるユーザー名とパスワードの組み合わせを識別します。"
    },
    {
      "indent": 3,
      "text": "The value of USERNAME is a variable-length value containing the authentication username. It MUST contain a UTF-8-encoded [RFC3629] sequence of fewer than 509 bytes and MUST have been processed using the OpaqueString profile [RFC8265]. A compliant implementation MUST be able to parse a UTF-8-encoded sequence of 763 or fewer octets to be compatible with [RFC5389].",
      "ja": "USERNAMEの値は、認証ユーザー名を含む可変長の値です。509バイト未満のUTF-8エンコード[RFC3629]シーケンスが含まれている必要があり、OpaqueStringプロファイル[RFC8265]を使用して処理されている必要があります。準拠した実装は、[RFC5389]と互換性を持たせるために、763オクテット以下のUTF-8エンコードシーケンスを解析できなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: [RFC5389] mistakenly referenced the definition of UTF-8 in [RFC2279]. [RFC2279] assumed up to 6 octets per characters encoded. [RFC2279] was replaced by [RFC3629], which allows only 4 octets per character encoded, consistent with changes made in Unicode 2.0 and ISO/IEC 10646.",
      "ja": "注：[RFC5389]は、[RFC2279]のUTF-8の定義を誤って参照していました。[RFC2279]は、エンコードされた文字ごとに最大6オクテットを想定しています。[RFC2279]は[RFC3629]に置き換えられました。これは、Unicode2.0およびISO / IEC 10646で行われた変更と一致して、エンコードされた文字ごとに4オクテットのみを許可します。"
    },
    {
      "indent": 6,
      "text": "Note: This specification uses the OpaqueString profile instead of the UsernameCasePreserved profile for username string processing in order to improve compatibility with deployed password stores. Many password databases used for HTTP and SIP Digest authentication store the MD5 hash of username:realm:password instead of storing a plain text password. In [RFC3489], STUN authentication was designed to be compatible with these existing databases to the extent possible, which like SIP and HTTP performed no pre-processing of usernames and passwords other than prohibiting non-space ASCII control characters. The next revision of the STUN specification, [RFC5389], used the SASLprep [RFC4013] stringprep [RFC3454] profile to pre-process usernames and passwords. SASLprep uses Unicode Normalization Form KC (Compatibility Decomposition, followed by Canonical Composition) [UAX15] and prohibits various control, space, and non-text, deprecated, or inappropriate codepoints. The PRECIS framework [RFC8264] obsoletes stringprep. PRECIS handling of usernames and passwords [RFC8265] uses Unicode Normalization Form C (Canonical Decomposition, followed by Canonical Composition). While there are specific cases where different username strings under HTTP Digest could be mapped to a single STUN username processed with OpaqueString, these cases are extremely unlikely and easy to detect and correct. With a UsernameCasePreserved profile, it would be more likely that valid usernames under HTTP Digest would not match their processed forms (specifically usernames containing bidirectional text and compatibility forms). Operators are free to further restrict the allowed codepoints in usernames to avoid problematic characters.",
      "ja": "注：この仕様では、デプロイされたパスワードストアとの互換性を向上させるために、ユーザー名文字列の処理にUsernameCasePreservedプロファイルの代わりにOpaqueStringプロファイルを使用します。 HTTPおよびSIPダイジェスト認証に使用される多くのパスワードデータベースは、プレーンテキストのパスワードを保存する代わりに、username：realm：passwordのMD5ハッシュを保存します。 [RFC3489]では、STUN認証は、これらの既存のデータベースと可能な限り互換性があるように設計されており、SIPやHTTPと同様に、スペース以外のASCII制御文字を禁止する以外にユーザー名とパスワードの前処理を実行しませんでした。 STUN仕様の次のリビジョンである[RFC5389]は、SASLprep [RFC4013] stringprep [RFC3454]プロファイルを使用してユーザー名とパスワードを前処理しました。 SASLprepは、Unicode Normalization Form KC（Compatibility Decomposition、続いてCanonical Composition）[UAX15]を使用し、さまざまな制御、スペース、および非テキスト、非推奨、または不適切なコードポイントを禁止します。 PRECISフレームワーク[RFC8264]はstringprepを廃止します。ユーザー名とパスワードのPRECIS処理[RFC8265]は、Unicode正規化フォームC（Canonical Decomposition、続いてCanonicalComposition）を使用します。 HTTPダイジェストの下の異なるユーザー名文字列がOpaqueStringで処理される単一のSTUNユーザー名にマップされる可能性がある特定のケースがありますが、これらのケースは非常にまれであり、検出および修正が容易です。 UsernameCasePreservedプロファイルを使用すると、HTTPダイジェストでの有効なユーザー名が、処理されたフォーム（具体的には双方向テキストと互換性フォームを含むユーザー名）と一致しない可能性が高くなります。オペレーターは、問題のある文字を回避するために、ユーザー名で許可されるコードポイントをさらに自由に制限できます。"
    },
    {
      "indent": 0,
      "text": "14.4. USERHASH",
      "section_title": true,
      "ja": "14.4. USERHASH"
    },
    {
      "indent": 3,
      "text": "The USERHASH attribute is used as a replacement for the USERNAME attribute when username anonymity is supported.",
      "ja": "ユーザー名の匿名性がサポートされている場合、USERHASH属性はUSERNAME属性の代わりに使用されます。"
    },
    {
      "indent": 3,
      "text": "The value of USERHASH has a fixed length of 32 bytes. The username MUST have been processed using the OpaqueString profile [RFC8265], and the realm MUST have been processed using the OpaqueString profile [RFC8265] before hashing.",
      "ja": "USERHASHの値は、32バイトの固定長です。ユーザー名はOpaqueStringプロファイル[RFC8265]を使用して処理されている必要があり、レルムはハッシュの前にOpaqueStringプロファイル[RFC8265]を使用して処理されている必要があります。"
    },
    {
      "indent": 3,
      "text": "The following is the operation that the client will perform to hash the username:",
      "ja": "以下は、クライアントがユーザー名をハッシュするために実行する操作です。"
    },
    {
      "indent": 3,
      "text": "userhash = SHA-256(OpaqueString(username) \":\" OpaqueString(realm))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14.5. MESSAGE-INTEGRITY",
      "section_title": true,
      "ja": "14.5. メッセージ-誠実さ"
    },
    {
      "indent": 3,
      "text": "The MESSAGE-INTEGRITY attribute contains an HMAC-SHA1 [RFC2104] of the STUN message. The MESSAGE-INTEGRITY attribute can be present in any STUN message type. Since it uses the SHA-1 hash, the HMAC will be 20 bytes.",
      "ja": "MESSAGE-INTEGRITY属性には、STUNメッセージのHMAC-SHA1 [RFC2104]が含まれています。MESSAGE-INTEGRITY属性は、任意のSTUNメッセージタイプに存在できます。SHA-1ハッシュを使用するため、HMACは20バイトになります。"
    },
    {
      "indent": 3,
      "text": "The key for the HMAC depends on which credential mechanism is in use. Section 9.1.1 defines the key for the short-term credential mechanism, and Section 9.2.2 defines the key for the long-term credential mechanism. Other credential mechanisms MUST define the key that is used for the HMAC.",
      "ja": "HMACのキーは、使用されている資格情報メカニズムによって異なります。セクション9.1.1は、短期の資格情報メカニズムのキーを定義し、セクション9.2.2は、長期の資格情報メカニズムのキーを定義します。他の資格情報メカニズムは、HMACに使用されるキーを定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "The text used as input to HMAC is the STUN message, up to and including the attribute preceding the MESSAGE-INTEGRITY attribute. The Length field of the STUN message header is adjusted to point to the end of the MESSAGE-INTEGRITY attribute. The value of the MESSAGE-INTEGRITY attribute is set to a dummy value.",
      "ja": "HMACへの入力として使用されるテキストは、MESSAGE-INTEGRITY属性の前の属性までのSTUNメッセージです。STUNメッセージヘッダーの長さフィールドは、MESSAGE-INTEGRITY属性の終わりを指すように調整されます。MESSAGE-INTEGRITY属性の値はダミー値に設定されています。"
    },
    {
      "indent": 3,
      "text": "Once the computation is performed, the value of the MESSAGE-INTEGRITY attribute is filled in, and the value of the length in the STUN header is set to its correct value -- the length of the entire message. Similarly, when validating the MESSAGE-INTEGRITY, the Length field in the STUN header must be adjusted to point to the end of the MESSAGE-INTEGRITY attribute prior to calculating the HMAC over the STUN message, up to and including the attribute preceding the MESSAGE-INTEGRITY attribute. Such adjustment is necessary when attributes, such as FINGERPRINT and MESSAGE-INTEGRITY-SHA256, appear after MESSAGE-INTEGRITY. See also [RFC5769] for examples of such calculations.",
      "ja": "計算が実行されると、MESSAGE-INTEGRITY属性の値が入力され、STUNヘッダーの長さの値が正しい値（メッセージ全体の長さ）に設定されます。同様に、MESSAGE-INTEGRITYを検証する場合、STUNヘッダーのLengthフィールドは、MESSAGE-INTEGRITY属性の前の属性までのSTUNメッセージに対するHMACを計算する前に、MESSAGE-INTEGRITY属性の終わりを指すように調整する必要があります。このような調整は、FINGERPRINTやMESSAGE-INTEGRITY-SHA256などの属性がMESSAGE-INTEGRITYの後に表示される場合に必要です。このような計算の例については、[RFC5769]も参照してください。"
    },
    {
      "indent": 0,
      "text": "14.6. MESSAGE-INTEGRITY-SHA256",
      "section_title": true,
      "ja": "14.6. メッセージ-整合性-SHA256"
    },
    {
      "indent": 3,
      "text": "The MESSAGE-INTEGRITY-SHA256 attribute contains an HMAC-SHA256 [RFC2104] of the STUN message. The MESSAGE-INTEGRITY-SHA256 attribute can be present in any STUN message type. The MESSAGE-INTEGRITY-SHA256 attribute contains an initial portion of the HMAC-SHA-256 [RFC2104] of the STUN message. The value will be at most 32 bytes, but it MUST be at least 16 bytes and MUST be a multiple of 4 bytes. The value must be the full 32 bytes unless the STUN Usage explicitly specifies that truncation is allowed. STUN Usages may specify a minimum length longer than 16 bytes.",
      "ja": "MESSAGE-INTEGRITY-SHA256属性には、STUNメッセージのHMAC-SHA256 [RFC2104]が含まれています。MESSAGE-INTEGRITY-SHA256属性は、任意のSTUNメッセージタイプに存在できます。MESSAGE-INTEGRITY-SHA256属性には、STUNメッセージのHMAC-SHA-256 [RFC2104]の最初の部分が含まれています。値は最大32バイトですが、少なくとも16バイトである必要があり、4バイトの倍数である必要があります。STUNの使用法で切り捨てが許可されることが明示的に指定されていない限り、値は完全な32バイトである必要があります。STUNの使用法では、16バイトより長い最小長を指定できます。"
    },
    {
      "indent": 3,
      "text": "The key for the HMAC depends on which credential mechanism is in use. Section 9.1.1 defines the key for the short-term credential mechanism, and Section 9.2.2 defines the key for the long-term credential mechanism. Other credential mechanism MUST define the key that is used for the HMAC.",
      "ja": "HMACのキーは、使用されている資格情報メカニズムによって異なります。セクション9.1.1は、短期の資格情報メカニズムのキーを定義し、セクション9.2.2は、長期の資格情報メカニズムのキーを定義します。他の資格情報メカニズムは、HMACに使用されるキーを定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "The text used as input to HMAC is the STUN message, up to and including the attribute preceding the MESSAGE-INTEGRITY-SHA256 attribute. The Length field of the STUN message header is adjusted to point to the end of the MESSAGE-INTEGRITY-SHA256 attribute. The value of the MESSAGE-INTEGRITY-SHA256 attribute is set to a dummy value.",
      "ja": "HMACへの入力として使用されるテキストは、MESSAGE-INTEGRITY-SHA256属性の前の属性までのSTUNメッセージです。STUNメッセージヘッダーの長さフィールドは、MESSAGE-INTEGRITY-SHA256属性の終わりを指すように調整されます。MESSAGE-INTEGRITY-SHA256属性の値がダミー値に設定されています。"
    },
    {
      "indent": 3,
      "text": "Once the computation is performed, the value of the MESSAGE-INTEGRITY-SHA256 attribute is filled in, and the value of the length in the STUN header is set to its correct value -- the length of the entire message. Similarly, when validating the MESSAGE-INTEGRITY-SHA256, the Length field in the STUN header must be adjusted to point to the end of the MESSAGE-INTEGRITY-SHA256 attribute prior to calculating the HMAC over the STUN message, up to and including the attribute preceding the MESSAGE-INTEGRITY-SHA256 attribute. Such adjustment is necessary when attributes, such as FINGERPRINT, appear after MESSAGE-INTEGRITY-SHA256. See also Appendix B.1 for examples of such calculations.",
      "ja": "計算が実行されると、MESSAGE-INTEGRITY-SHA256属性の値が入力され、STUNヘッダーの長さの値が正しい値（メッセージ全体の長さ）に設定されます。同様に、MESSAGE-INTEGRITY-SHA256を検証する場合、STUNヘッダーの長さフィールドは、MESSAGE-INTEGRITY-SHA256属性の前の属性までのSTUNメッセージに対するHMACを計算する前に、MESSAGE-INTEGRITY-SHA256属性の終わりを指すように調整する必要があります。このような調整は、FINGERPRINTなどの属性がMESSAGE-INTEGRITY-SHA256の後に表示される場合に必要です。このような計算の例については、付録B.1も参照してください。"
    },
    {
      "indent": 0,
      "text": "14.7. FINGERPRINT",
      "section_title": true,
      "ja": "14.7. 指紋"
    },
    {
      "indent": 3,
      "text": "The FINGERPRINT attribute MAY be present in all STUN messages.",
      "ja": "FINGERPRINT属性は、すべてのSTUNメッセージに存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "The value of the attribute is computed as the CRC-32 of the STUN message up to (but excluding) the FINGERPRINT attribute itself, XOR'ed with the 32-bit value 0x5354554e. (The XOR operation ensures that the FINGERPRINT test will not report a false positive on a packet containing a CRC-32 generated by an application protocol.) The 32-bit CRC is the one defined in ITU V.42 [ITU.V42.2002], which",
      "ja": "属性の値は、FINGERPRINT属性自体までのSTUNメッセージのCRC-32として計算され、32ビット値0x5354554eとXORされます。（XOR演算により、アプリケーションプロトコルによって生成されたCRC-32を含むパケットでFINGERPRINTテストが誤検知を報告しないことが保証されます。）32ビットCRCは、ITU V.42 [ITU.V42.2002]で定義されているものであり、"
    },
    {
      "indent": 3,
      "text": "has a generator polynomial of x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1. See the sample code for the CRC-32 in Section 8 of [RFC1952].",
      "ja": "x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1の生成多項式があります。[RFC1952]のセクション8にあるCRC-32のサンプルコードを参照してください。"
    },
    {
      "indent": 3,
      "text": "When present, the FINGERPRINT attribute MUST be the last attribute in the message and thus will appear after MESSAGE-INTEGRITY and MESSAGE-INTEGRITY-SHA256.",
      "ja": "存在する場合、FINGERPRINT属性はメッセージの最後の属性である必要があり、したがってMESSAGE-INTEGRITYおよびMESSAGE-INTEGRITY-SHA256の後に表示されます。"
    },
    {
      "indent": 3,
      "text": "The FINGERPRINT attribute can aid in distinguishing STUN packets from packets of other protocols. See Section 7.",
      "ja": "FINGERPRINT属性は、STUNパケットを他のプロトコルのパケットから区別するのに役立ちます。セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "As with MESSAGE-INTEGRITY and MESSAGE-INTEGRITY-SHA256, the CRC used in the FINGERPRINT attribute covers the Length field from the STUN message header. Therefore, prior to computation of the CRC, this value must be correct and include the CRC attribute as part of the message length. When using the FINGERPRINT attribute in a message, the attribute is first placed into the message with a dummy value; then, the CRC is computed, and the value of the attribute is updated. If the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute is also present, then it must be present with the correct message-integrity value before the CRC is computed, since the CRC is done over the value of the MESSAGE-INTEGRITY and MESSAGE-INTEGRITY-SHA256 attributes as well.",
      "ja": "MESSAGE-INTEGRITYおよびMESSAGE-INTEGRITY-SHA256と同様に、FINGERPRINT属性で使用されるCRCは、STUNメッセージヘッダーの長さフィールドをカバーします。したがって、CRCを計算する前に、この値が正しく、メッセージ長の一部としてCRC属性が含まれている必要があります。メッセージでFINGERPRINT属性を使用する場合、属性は最初にダミー値を使用してメッセージに配置されます。次に、CRCが計算され、属性の値が更新されます。MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性も存在する場合、CRCはMESSAGE-INTEGRITYおよびMESSAGE-の値に対して実行されるため、CRCが計算される前に、正しいメッセージ整合性値とともに存在する必要があります。INTEGRITY-SHA256属性も同様です。"
    },
    {
      "indent": 0,
      "text": "14.8. ERROR-CODE",
      "section_title": true,
      "ja": "14.8. エラーコード"
    },
    {
      "indent": 3,
      "text": "The ERROR-CODE attribute is used in error response messages. It contains a numeric error code value in the range of 300 to 699 plus a textual reason phrase encoded in UTF-8 [RFC3629]; it is also consistent in its code assignments and semantics with SIP [RFC3261] and HTTP [RFC7231]. The reason phrase is meant for diagnostic purposes and can be anything appropriate for the error code. Recommended reason phrases for the defined error codes are included in the IANA registry for error codes. The reason phrase MUST be a UTF-8-encoded [RFC3629] sequence of fewer than 128 characters (which can be as long as 509 bytes when encoding them or 763 bytes when decoding them).",
      "ja": "ERROR-CODE属性は、エラー応答メッセージで使用されます。300〜699の範囲の数値エラーコード値と、UTF-8 [RFC3629]でエンコードされたテキストの理由フレーズが含まれています。また、SIP [RFC3261]およびHTTP [RFC7231]とのコード割り当ておよびセマンティクスにも一貫性があります。理由句は診断を目的としたものであり、エラーコードに適したものであれば何でもかまいません。定義されたエラーコードの推奨される理由フレーズは、エラーコードのIANAレジストリに含まれています。理由句は、128文字未満のUTF-8エンコード[RFC3629]シーケンスである必要があります（エンコードの場合は509バイト、デコードの場合は763バイトになります）。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Reserved, should be 0         |Class|     Number    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Reason Phrase (variable)                                ..\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 7: Format of ERROR-CODE Attribute",
      "ja": "図7：ERROR-CODE属性の形式"
    },
    {
      "indent": 3,
      "text": "To facilitate processing, the class of the error code (the hundreds digit) is encoded separately from the rest of the code, as shown in Figure 7.",
      "ja": "処理を容易にするために、図7に示すように、エラーコードのクラス（数百桁）は残りのコードとは別にエンコードされます。"
    },
    {
      "indent": 3,
      "text": "The Reserved bits SHOULD be 0 and are for alignment on 32-bit boundaries. Receivers MUST ignore these bits. The Class represents the hundreds digit of the error code. The value MUST be between 3 and 6. The Number represents the binary encoding of the error code modulo 100, and its value MUST be between 0 and 99.",
      "ja": "予約ビットは0である必要があり、32ビット境界での位置合わせ用です。受信者はこれらのビットを無視しなければなりません（MUST）。クラスは、エラーコードの数百桁を表します。値は3から6の間でなければなりません。数値は100を法とするエラーコードのバイナリエンコーディングを表し、その値は0から99の間でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following error codes, along with their recommended reason phrases, are defined:",
      "ja": "次のエラーコードと、推奨される理由フレーズが定義されています。"
    },
    {
      "indent": 3,
      "text": "300 Try Alternate: The client should contact an alternate server for this request. This error response MUST only be sent if the request included either a USERNAME or USERHASH attribute and a valid MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute; otherwise, it MUST NOT be sent and error code 400 (Bad Request) is suggested. This error response MUST be protected with the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute, and receivers MUST validate the MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 of this response before redirecting themselves to an alternate server.",
      "ja": "300代替を試す：クライアントは、この要求について代替サーバーに接続する必要があります。このエラー応答は、リクエストにUSERNAMEまたはUSERHASH属性と、有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれている場合にのみ送信する必要があります。それ以外の場合は、送信してはならず、エラーコード400（不正な要求）が提案されます。このエラー応答は、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性で保護する必要があり、受信者は、代替サーバーにリダイレクトする前に、この応答のMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256を検証する必要があります。"
    },
    {
      "indent": 8,
      "text": "Note: Failure to generate and validate message integrity for a 300 response allows an on-path attacker to falsify a 300 response thus causing subsequent STUN messages to be sent to a victim.",
      "ja": "注：300応答のメッセージ整合性の生成と検証に失敗すると、パス上の攻撃者が300応答を改ざんして、後続のSTUNメッセージを被害者に送信する可能性があります。"
    },
    {
      "indent": 3,
      "text": "400 Bad Request: The request was malformed. The client SHOULD NOT retry the request without modification from the previous attempt. The server may not be able to generate a valid MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 for this error, so the client MUST NOT expect a valid MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute on this response.",
      "ja": "400不正なリクエスト：リクエストの形式が正しくありませんでした。クライアントは、前回の試行から変更せずに要求を再試行するべきではありません（SHOULDNOT）。サーバーは、このエラーに対して有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256を生成できない可能性があるため、クライアントは、この応答で有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を期待してはなりません。"
    },
    {
      "indent": 3,
      "text": "401 Unauthenticated: The request did not contain the correct credentials to proceed. The client should retry the request with proper credentials.",
      "ja": "401未認証：要求に続行するための正しい資格情報が含まれていませんでした。クライアントは、適切な資格情報を使用して要求を再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "420 Unknown Attribute: The server received a STUN packet containing a comprehension-required attribute that it did not understand. The server MUST put this unknown attribute in the UNKNOWN-ATTRIBUTE attribute of its error response.",
      "ja": "420不明な属性：サーバーは、理解できない理解が必要な属性を含むSTUNパケットを受信しました。サーバーは、この不明な属性をエラー応答のUNKNOWN-ATTRIBUTE属性に配置する必要があります。"
    },
    {
      "indent": 3,
      "text": "438 Stale Nonce: The NONCE used by the client was no longer valid. The client should retry, using the NONCE provided in the response.",
      "ja": "438 Stale Nonce：クライアントが使用するNONCEは無効になりました。クライアントは、応答で提供されたNONCEを使用して再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "500 Server Error: The server has suffered a temporary error. The client should try again.",
      "ja": "500サーバーエラー：サーバーで一時的なエラーが発生しました。クライアントは再試行する必要があります。"
    },
    {
      "indent": 0,
      "text": "14.9. REALM",
      "section_title": true,
      "ja": "14.9. REALM"
    },
    {
      "indent": 3,
      "text": "The REALM attribute may be present in requests and responses. It contains text that meets the grammar for \"realm-value\" as described in [RFC3261] but without the double quotes and their surrounding whitespace. That is, it is an unquoted realm-value (and is therefore a sequence of qdtext or quoted-pair). It MUST be a UTF-8-encoded [RFC3629] sequence of fewer than 128 characters (which can be as long as 509 bytes when encoding them and as long as 763 bytes when decoding them) and MUST have been processed using the OpaqueString profile [RFC8265].",
      "ja": "REALM属性は、要求と応答に存在する場合があります。[RFC3261]で説明されている「レルム値」の文法を満たすテキストが含まれていますが、二重引用符とその周囲の空白は含まれていません。つまり、引用符で囲まれていないレルム値です（したがって、qdtextまたは引用符で囲まれたペアのシーケンスです）。これは、128文字未満（エンコード時は509バイト、デコード時は763バイト）のUTF-8エンコード[RFC3629]シーケンスである必要があり、OpaqueStringプロファイルを使用して処理されている必要があります[RFC8265]。"
    },
    {
      "indent": 3,
      "text": "Presence of the REALM attribute in a request indicates that long-term credentials are being used for authentication. Presence in certain error responses indicates that the server wishes the client to use a long-term credential in that realm for authentication.",
      "ja": "リクエストにREALM属性が含まれている場合は、認証に長期の認証情報が使用されていることを示しています。特定のエラー応答の存在は、サーバーがクライアントが認証のためにそのレルムで長期の資格情報を使用することを望んでいることを示します。"
    },
    {
      "indent": 0,
      "text": "14.10. NONCE",
      "section_title": true,
      "ja": "14.10. ノンス"
    },
    {
      "indent": 3,
      "text": "The NONCE attribute may be present in requests and responses. It contains a sequence of qdtext or quoted-pair, which are defined in [RFC3261]. Note that this means that the NONCE attribute will not contain the actual surrounding quote characters. The NONCE attribute MUST be fewer than 128 characters (which can be as long as 509 bytes when encoding them and a long as 763 bytes when decoding them). See Section 5.4 of [RFC7616] for guidance on selection of nonce values in a server.",
      "ja": "NONCE属性は、要求と応答に存在する場合があります。これには、[RFC3261]で定義されているqdtextまたはquoted-pairのシーケンスが含まれています。これは、NONCE属性に実際の周囲の引用符が含まれないことを意味することに注意してください。NONCE属性は128文字未満である必要があります（エンコードする場合は509バイト、デコードする場合は763バイトにすることができます）。サーバーでのナンス値の選択に関するガイダンスについては、[RFC7616]のセクション5.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "14.11. PASSWORD-ALGORITHMS",
      "section_title": true,
      "ja": "14.11. パスワード-アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The PASSWORD-ALGORITHMS attribute may be present in requests and responses. It contains the list of algorithms that the server can use to derive the long-term password.",
      "ja": "PASSWORD-ALGORITHMS属性は、要求と応答に存在する場合があります。これには、サーバーが長期パスワードを導出するために使用できるアルゴリズムのリストが含まれています。"
    },
    {
      "indent": 3,
      "text": "The set of known algorithms is maintained by IANA. The initial set defined by this specification is found in Section 18.5.",
      "ja": "既知のアルゴリズムのセットはIANAによって維持されています。この仕様で定義されている初期セットは、セクション18.5にあります。"
    },
    {
      "indent": 3,
      "text": "The attribute contains a list of algorithm numbers and variable length parameters. The algorithm number is a 16-bit value as defined in Section 18.5. The parameters start with the length (prior to padding) of the parameters as a 16-bit value, followed by the parameters that are specific to each algorithm. The parameters are padded to a 32-bit boundary, in the same manner as an attribute.",
      "ja": "この属性には、アルゴリズム番号と可変長パラメーターのリストが含まれています。アルゴリズム番号は、セクション18.5で定義されている16ビット値です。パラメーターは、16ビット値としてのパラメーターの長さ（パディング前）で始まり、各アルゴリズムに固有のパラメーターが続きます。パラメータは、属性と同じ方法で32ビット境界に埋め込まれます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Algorithm 1           | Algorithm 1 Parameters Length |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Algorithm 1 Parameters (variable)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Algorithm 2           | Algorithm 2 Parameters Length |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Algorithm 2 Parameters (variable)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                             ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 8: Format of PASSWORD-ALGORITHMS Attribute",
      "ja": "図8：PASSWORD-ALGORITHMS属性の形式"
    },
    {
      "indent": 0,
      "text": "14.12. PASSWORD-ALGORITHM",
      "section_title": true,
      "ja": "14.12. パスワード-アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The PASSWORD-ALGORITHM attribute is present only in requests. It contains the algorithm that the server must use to derive a key from the long-term password.",
      "ja": "PASSWORD-ALGORITHM属性は、リクエストにのみ存在します。これには、サーバーが長期パスワードからキーを取得するために使用する必要のあるアルゴリズムが含まれています。"
    },
    {
      "indent": 3,
      "text": "The set of known algorithms is maintained by IANA. The initial set defined by this specification is found in Section 18.5.",
      "ja": "既知のアルゴリズムのセットはIANAによって維持されています。この仕様で定義されている初期セットは、セクション18.5にあります。"
    },
    {
      "indent": 3,
      "text": "The attribute contains an algorithm number and variable length parameters. The algorithm number is a 16-bit value as defined in Section 18.5. The parameters starts with the length (prior to padding) of the parameters as a 16-bit value, followed by the parameters that are specific to the algorithm. The parameters are padded to a 32-bit boundary, in the same manner as an attribute. Similarly, the padding bits MUST be set to zero on sending and MUST be ignored by the receiver.",
      "ja": "この属性には、アルゴリズム番号と可変長パラメーターが含まれています。アルゴリズム番号は、セクション18.5で定義されている16ビット値です。パラメーターは、16ビット値としてのパラメーターの長さ（パディング前）で始まり、その後にアルゴリズムに固有のパラメーターが続きます。パラメータは、属性と同じ方法で32ビット境界に埋め込まれます。同様に、パディングビットは送信時にゼロに設定する必要があり、受信者は無視する必要があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Algorithm           |  Algorithm Parameters Length   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Algorithm Parameters (variable)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 9: Format of PASSWORD-ALGORITHM Attribute",
      "ja": "図9：PASSWORD-ALGORITHM属性の形式"
    },
    {
      "indent": 0,
      "text": "14.13. UNKNOWN-ATTRIBUTES",
      "section_title": true,
      "ja": "14.13. UNKNOWN-ATTRIBUTES"
    },
    {
      "indent": 3,
      "text": "The UNKNOWN-ATTRIBUTES attribute is present only in an error response when the response code in the ERROR-CODE attribute is 420 (Unknown Attribute).",
      "ja": "UNKNOWN-ATTRIBUTES属性は、ERROR-CODE属性の応答コードが420（不明な属性）の場合にのみエラー応答に存在します。"
    },
    {
      "indent": 3,
      "text": "The attribute contains a list of 16-bit values, each of which represents an attribute type that was not understood by the server.",
      "ja": "属性には16ビット値のリストが含まれ、各値はサーバーによって理解されなかった属性タイプを表します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Attribute 1 Type         |       Attribute 2 Type        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Attribute 3 Type         |       Attribute 4 Type    ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 10: Format of UNKNOWN-ATTRIBUTES Attribute",
      "ja": "図10：UNKNOWN-ATTRIBUTES属性のフォーマット"
    },
    {
      "indent": 6,
      "text": "Note: In [RFC3489], this field was padded to 32 by duplicating the last attribute. In this version of the specification, the normal padding rules for attributes are used instead.",
      "ja": "注：[RFC3489]では、最後の属性を複製することにより、このフィールドが32に埋め込まれていました。このバージョンの仕様では、代わりに属性の通常のパディングルールが使用されます。"
    },
    {
      "indent": 0,
      "text": "14.14. SOFTWARE",
      "section_title": true,
      "ja": "14.14. SOFTWARE"
    },
    {
      "indent": 3,
      "text": "The SOFTWARE attribute contains a textual description of the software being used by the agent sending the message. It is used by clients and servers. Its value SHOULD include manufacturer and version number. The attribute has no impact on operation of the protocol and serves only as a tool for diagnostic and debugging purposes. The value of SOFTWARE is variable length. It MUST be a UTF-8-encoded [RFC3629] sequence of fewer than 128 characters (which can be as long as 509 when encoding them and as long as 763 bytes when decoding them).",
      "ja": "SOFTWARE属性には、メッセージを送信するエージェントが使用しているソフトウェアのテキストによる説明が含まれています。クライアントとサーバーによって使用されます。その値には、メーカーとバージョン番号を含める必要があります。この属性はプロトコルの動作に影響を与えず、診断およびデバッグの目的でのみツールとして機能します。SOFTWAREの値は可変長です。これは、128文字未満のUTF-8エンコード[RFC3629]シーケンスである必要があります（エンコード時は509バイト、デコード時は763バイトまで可能です）。"
    },
    {
      "indent": 0,
      "text": "14.15. ALTERNATE-SERVER",
      "section_title": true,
      "ja": "14.15. ALTERNATE-SERVER"
    },
    {
      "indent": 3,
      "text": "The alternate server represents an alternate transport address identifying a different STUN server that the STUN client should try.",
      "ja": "代替サーバーは、STUNクライアントが試行する必要のある別のSTUNサーバーを識別する代替トランスポートアドレスを表します。"
    },
    {
      "indent": 3,
      "text": "It is encoded in the same way as MAPPED-ADDRESS and thus refers to a single server by IP address.",
      "ja": "MAPPED-ADDRESSと同じ方法でエンコードされるため、IPアドレスで単一のサーバーを参照します。"
    },
    {
      "indent": 0,
      "text": "14.16. ALTERNATE-DOMAIN",
      "section_title": true,
      "ja": "14.16. ALTERNATE-DOMAIN"
    },
    {
      "indent": 3,
      "text": "The alternate domain represents the domain name that is used to verify the IP address in the ALTERNATE-SERVER attribute when the transport protocol uses TLS or DTLS.",
      "ja": "代替ドメインは、トランスポートプロトコルがTLSまたはDTLSを使用する場合にALTERNATE-SERVER属性のIPアドレスを確認するために使用されるドメイン名を表します。"
    },
    {
      "indent": 3,
      "text": "The value of ALTERNATE-DOMAIN is variable length. It MUST be a valid DNS name [RFC1123] (including A-labels [RFC5890]) of 255 or fewer ASCII characters.",
      "ja": "ALTERNATE-DOMAINの値は可変長です。これは、255以下のASCII文字の有効なDNS名[RFC1123]（Aラベル[RFC5890]を含む）である必要があります。"
    },
    {
      "indent": 0,
      "text": "15. Operational Considerations",
      "section_title": true,
      "ja": "15. 運用上の考慮事項"
    },
    {
      "indent": 3,
      "text": "STUN MAY be used with anycast addresses, but only with UDP and in STUN Usages where authentication is not used.",
      "ja": "STUNはエニーキャストアドレスで使用できますが、UDPおよび認証が使用されないSTUNの使用法でのみ使用できます。"
    },
    {
      "indent": 0,
      "text": "16. Security Considerations",
      "section_title": true,
      "ja": "16. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Implementations and deployments of a STUN Usage using TLS or DTLS MUST follow the recommendations in [BCP195].",
      "ja": "TLSまたはDTLSを使用したSTUN使用法の実装と展開は、[BCP195]の推奨事項に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Implementations and deployments of a STUN Usage using the long-term credential mechanism (Section 9.2) MUST follow the recommendations in Section 5 of [RFC7616].",
      "ja": "長期認証メカニズム（セクション9.2）を使用したSTUN使用法の実装と展開は、[RFC7616]のセクション5の推奨事項に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "16.1. Attacks against the Protocol",
      "section_title": true,
      "ja": "16.1. プロトコルに対する攻撃"
    },
    {
      "indent": 0,
      "text": "16.1.1. Outside Attacks",
      "section_title": true,
      "ja": "16.1.1. 外部からの攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker can try to modify STUN messages in transit, in order to cause a failure in STUN operation. These attacks are detected for both requests and responses through the message-integrity mechanism, using either a short-term or long-term credential. Of course, once detected, the manipulated packets will be dropped, causing the STUN transaction to effectively fail. This attack is possible only by an on-path attacker.",
      "ja": "攻撃者は、STUN操作で失敗を引き起こすために、転送中のSTUNメッセージを変更しようとする可能性があります。これらの攻撃は、短期または長期の資格情報を使用して、メッセージ整合性メカニズムを介して要求と応答の両方で検出されます。もちろん、検出されると、操作されたパケットはドロップされ、STUNトランザクションは事実上失敗します。この攻撃は、パス上の攻撃者によってのみ可能です。"
    },
    {
      "indent": 3,
      "text": "An attacker that can observe, but not modify, STUN messages in-transit (for example, an attacker present on a shared access medium, such as Wi-Fi) can see a STUN request and then immediately send a STUN response, typically an error response, in order to disrupt STUN processing. This attack is also prevented for messages that utilize MESSAGE-INTEGRITY. However, some error responses, those related to authentication in particular, cannot be protected by MESSAGE-INTEGRITY. When STUN itself is run over a secure transport protocol (e.g., TLS), these attacks are completely mitigated.",
      "ja": "転送中のSTUNメッセージを監視できるが変更できない攻撃者（たとえば、Wi-Fiなどの共有アクセスメディアに存在する攻撃者）は、STUN要求を確認し、すぐにSTUN応答（通常はエラー）を送信できます。STUN処理を中断するための応答。この攻撃は、MESSAGE-INTEGRITYを利用するメッセージでも防止されます。ただし、一部のエラー応答、特に認証に関連するものは、MESSAGE-INTEGRITYで保護できません。STUN自体が安全なトランスポートプロトコル（TLSなど）で実行されると、これらの攻撃は完全に軽減されます。"
    },
    {
      "indent": 3,
      "text": "Depending on the STUN Usage, these attacks may be of minimal consequence and thus do not require message integrity to mitigate. For example, when STUN is used to a basic STUN server to discover a server reflexive candidate for usage with ICE, authentication and message integrity are not required since these attacks are detected during the connectivity check phase. The connectivity checks themselves, however, require protection for proper operation of ICE overall. As described in Section 13, STUN Usages describe when authentication and message integrity are needed.",
      "ja": "STUNの使用法によっては、これらの攻撃の影響が最小限である可能性があるため、軽減するためにメッセージの整合性は必要ありません。たとえば、STUNを基本的なSTUNサーバーに使用して、ICEで使用するサーバー反射候補を検出する場合、これらの攻撃は接続チェックフェーズで検出されるため、認証とメッセージの整合性は必要ありません。ただし、接続チェック自体には、ICE全体を適切に動作させるための保護が必要です。セクション13で説明されているように、STUNの使用法では、認証とメッセージの整合性が必要な場合について説明します。"
    },
    {
      "indent": 3,
      "text": "Since STUN uses the HMAC of a shared secret for authentication and integrity protection, it is subject to offline dictionary attacks. When authentication is utilized, it SHOULD be with a strong password that is not readily subject to offline dictionary attacks. Protection of the channel itself, using TLS or DTLS, mitigates these attacks.",
      "ja": "STUNは、認証と整合性保護のために共有シークレットのHMACを使用するため、オフライン辞書攻撃の対象になります。認証を利用する場合は、オフライン辞書攻撃を受けにくい強力なパスワードを使用する必要があります。TLSまたはDTLSを使用してチャネル自体を保護すると、これらの攻撃が軽減されます。"
    },
    {
      "indent": 3,
      "text": "STUN supports both MESSAGE-INTEGRITY and MESSAGE-INTEGRITY-SHA256, which makes STUN subject to bid-down attacks by an on-path attacker. An attacker could strip the MESSAGE-INTEGRITY-SHA256 attribute, leaving only the MESSAGE-INTEGRITY attribute and thus exploiting a potential vulnerability. Protection of the channel itself, using TLS or DTLS, mitigates these attacks. Timely removal of the support of MESSAGE-INTEGRITY in a future version of STUN is necessary.",
      "ja": "STUNは、MESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方をサポートします。これにより、STUNはオンパス攻撃者によるビッドダウン攻撃の対象になります。攻撃者は、MESSAGE-INTEGRITY-SHA256属性を削除し、MESSAGE-INTEGRITY属性のみを残して、潜在的な脆弱性を悪用する可能性があります。TLSまたはDTLSを使用してチャネル自体を保護すると、これらの攻撃が軽減されます。STUNの将来のバージョンでは、MESSAGE-INTEGRITYのサポートをタイムリーに削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The use of SHA-256 for password hashing does not meet modern standards, which are aimed at slowing down exhaustive password searches by providing a relatively slow minimum time to compute the hash. Although better algorithms such as Argon2 [Argon2] are available, SHA-256 was chosen for consistency with [RFC7616].",
      "ja": "注：パスワードハッシュにSHA-256を使用することは、ハッシュを計算するための比較的遅い最小時間を提供することによって徹底的なパスワード検索を遅くすることを目的とした最新の標準を満たしていません。Argon2 [Argon2]などのより優れたアルゴリズムが利用可能ですが、[RFC7616]との整合性のためにSHA-256が選択されました。"
    },
    {
      "indent": 0,
      "text": "16.1.2. Inside Attacks",
      "section_title": true,
      "ja": "16.1.2. 内部攻撃"
    },
    {
      "indent": 3,
      "text": "A rogue client may try to launch a DoS attack against a server by sending it a large number of STUN requests. Fortunately, STUN requests can be processed statelessly by a server, making such attacks hard to launch effectively.",
      "ja": "不正なクライアントは、サーバーに多数のSTUN要求を送信することにより、サーバーに対してDoS攻撃を仕掛けようとする可能性があります。幸い、STUNリクエストはサーバーによってステートレスに処理される可能性があるため、このような攻撃を効果的に開始することは困難です。"
    },
    {
      "indent": 3,
      "text": "A rogue client may use a STUN server as a reflector, sending it requests with a falsified source IP address and port. In such a case, the response would be delivered to that source IP and port. There is no amplification of the number of packets with this attack (the STUN server sends one packet for each packet sent by the client), though there is a small increase in the amount of data, since STUN responses are typically larger than requests. This attack is mitigated by ingress source address filtering.",
      "ja": "不正なクライアントは、STUNサーバーをリフレクターとして使用し、偽造された送信元IPアドレスとポートを使用して要求を送信する可能性があります。このような場合、応答はその送信元IPとポートに配信されます。STUNの応答は通常、要求よりも大きいため、データ量はわずかに増加しますが、この攻撃ではパケット数の増幅はありません（STUNサーバーはクライアントから送信されるパケットごとに1つのパケットを送信します）。この攻撃は、入力送信元アドレスのフィルタリングによって軽減されます。"
    },
    {
      "indent": 3,
      "text": "Revealing the specific software version of the agent through the SOFTWARE attribute might allow them to become more vulnerable to attacks against software that is known to contain security holes. Implementers SHOULD make usage of the SOFTWARE attribute a configurable option.",
      "ja": "SOFTWARE属性を介してエージェントの特定のソフトウェアバージョンを明らかにすると、セキュリティホールが含まれていることがわかっているソフトウェアに対する攻撃に対してエージェントがより脆弱になる可能性があります。実装者は、SOFTWARE属性の使用を構成可能なオプションにする必要があります。"
    },
    {
      "indent": 0,
      "text": "16.1.3. Bid-Down Attacks",
      "section_title": true,
      "ja": "16.1.3. ビッドダウン攻撃"
    },
    {
      "indent": 0,
      "text": " This document adds the possibility of selecting different algorithms to protect the confidentiality of the passwords stored on the server side when using the long-term credential mechanism while still ensuring compatibility with MD5, which was the algorithm used in [RFC5389]. This selection works by having the server send to the client the list of algorithms supported in a PASSWORD-ALGORITHMS attribute and having the client send back a PASSWORD-ALGORITHM attribute containing the algorithm selected.",
      "ja": "このドキュメントでは、[RFC5389]で使用されているアルゴリズムであるMD5との互換性を確保しながら、長期的な資格情報メカニズムを使用するときにサーバー側に保存されているパスワードの機密性を保護するためにさまざまなアルゴリズムを選択する可能性を追加します。この選択は、サーバーにPASSWORD-ALGORITHMS属性でサポートされているアルゴリズムのリストをクライアントに送信させ、クライアントに選択されたアルゴリズムを含むPASSWORD-ALGORITHM属性を返送させることによって機能します。"
    },
    {
      "indent": 3,
      "text": "Because the PASSWORD-ALGORITHMS attribute has to be sent in an unauthenticated response, an on-path attacker wanting to exploit an eventual vulnerability in MD5 can just strip the PASSWORD-ALGORITHMS attribute from the unprotected response, thus making the server subsequently act as if the client was implementing the version of this protocol defined in [RFC5389].",
      "ja": "PASSWORD-ALGORITHMS属性は認証されていない応答で送信する必要があるため、MD5の最終的な脆弱性を悪用したいオンパス攻撃者は、保護されていない応答からPASSWORD-ALGORITHMS属性を取り除くだけで、サーバーはその後、クライアントは、[RFC5389]で定義されているこのプロトコルのバージョンを実装していました。"
    },
    {
      "indent": 3,
      "text": "To protect against this attack and other similar bid-down attacks, the nonce is enriched with a set of security bits that indicates which security features are in use. In the case of the selection of the password algorithm, the matching bit is set in the nonce returned by the server in the same response that contains the PASSWORD-ALGORITHMS attribute. Because the nonce used in subsequent authenticated transactions is verified by the server to be identical to what was originally sent, it cannot be modified by an on-path attacker. Additionally, the client is mandated to copy the received PASSWORD-ALGORITHMS attribute in the next authenticated transaction to that server.",
      "ja": "この攻撃や他の同様のビッドダウン攻撃から保護するために、ナンスには、使用されているセキュリティ機能を示す一連のセキュリティビットが追加されています。パスワードアルゴリズムを選択した場合、一致するビットは、PASSWORD-ALGORITHMS属性を含む同じ応答でサーバーから返されるナンスに設定されます。後続の認証済みトランザクションで使用されるナンスは、サーバーによって最初に送信されたものと同一であることが確認されるため、パス上の攻撃者が変更することはできません。さらに、クライアントは、次の認証済みトランザクションで受信したPASSWORD-ALGORITHMS属性をそのサーバーにコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "An on-path attack that removes the PASSWORD-ALGORITHMS will be detected because the client will not be able to send it back to the server in the next authenticated transaction. The client will detect that attack because the security bit is set but the matching attribute is missing; this will end the session. A client using an older version of this protocol will not send the PASSWORD-ALGORITHMS back but can only use MD5 anyway, so the attack is inconsequential.",
      "ja": "PASSWORD-ALGORITHMSを削除するオンパス攻撃は、クライアントが次の認証されたトランザクションでサーバーに送り返すことができないため、検出されます。セキュリティビットが設定されているが、一致する属性がないため、クライアントはその攻撃を検出します。これでセッションが終了します。このプロトコルの古いバージョンを使用しているクライアントは、PASSWORD-ALGORITHMSを送り返しませんが、とにかくMD5しか使用できないため、攻撃は重要ではありません。"
    },
    {
      "indent": 3,
      "text": "The on-path attack may also try to remove the security bit together with the PASSWORD-ALGORITHMS attribute, but the server will discover that when the next authenticated transaction contains an invalid nonce.",
      "ja": "オンパス攻撃は、PASSWORD-ALGORITHMS属性とともにセキュリティビットを削除しようとする場合もありますが、サーバーは、次の認証されたトランザクションに無効なナンスが含まれていることを検出します。"
    },
    {
      "indent": 3,
      "text": "An on-path attack that removes some algorithms from the PASSWORD-ALGORITHMS attribute will be equally defeated because that attribute will be different from the original one when the server verifies it in the subsequent authenticated transaction.",
      "ja": "PASSWORD-ALGORITHMS属性から一部のアルゴリズムを削除するオンパス攻撃は、サーバーが後続の認証済みトランザクションで検証するときに元の属性とは異なるため、同様に無効になります。"
    },
    {
      "indent": 3,
      "text": "Note that the bid-down protection mechanism introduced in this document is inherently limited by the fact that it is not possible to detect an attack until the server receives the second request after the 401 (Unauthenticated) response.",
      "ja": "このドキュメントで紹介されているビッドダウン保護メカニズムは、401（認証されていない）応答の後にサーバーが2番目の要求を受信するまで攻撃を検出できないという事実によって、本質的に制限されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "SHA-256 was chosen as the new default for password hashing for its compatibility with [RFC7616], but because SHA-256 (like MD5) is a comparatively fast algorithm, it does little to deter brute-force attacks. Specifically, this means that if the user has a weak password, an attacker that captures a single exchange can use a brute-force attack to learn the user's password and then potentially impersonate the user to the server and to other servers where the same password was used. Note that such an attacker can impersonate the user to the server itself without any brute-force attack.",
      "ja": "[RFC7616]との互換性のため、パスワードハッシュの新しいデフォルトとしてSHA-256が選択されましたが、SHA-256（MD5など）は比較的高速なアルゴリズムであるため、ブルートフォース攻撃を阻止することはほとんどありません。具体的には、これは、ユーザーのパスワードが弱い場合、単一の交換をキャプチャする攻撃者がブルートフォース攻撃を使用してユーザーのパスワードを学習し、同じパスワードが存在するサーバーや他のサーバーにユーザーを偽装する可能性があることを意味します。中古。このような攻撃者は、ブルートフォース攻撃なしにユーザーをサーバー自体に偽装できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A stronger (which is to say, slower) algorithm, like Argon2 [Argon2], would help both of these cases; however, in the first case, it would only help after the database entry for this user is updated to exclusively use that stronger mechanism.",
      "ja": "Argon2 [Argon2]のようなより強力な（つまり、より遅い）アルゴリズムは、これらの両方の場合に役立ちます。ただし、最初のケースでは、このユーザーのデータベースエントリが更新されて、その強力なメカニズムのみを使用するようになった後でのみ役立ちます。"
    },
    {
      "indent": 3,
      "text": "The bid-down defenses in this protocol prevent an attacker from forcing the client and server to complete a handshake using weaker algorithms than they jointly support, but only if the weakest joint algorithm is strong enough that it cannot be compromised by a brute-force attack. However, this does not defend against many attacks on those algorithms; specifically, an on-path attacker might perform a bid-down attack on a client that supports both Argon2 [Argon2] and SHA-256 for password hashing and use that to collect a MESSAGE-INTEGRITY-SHA256 value that it can then use for an offline brute-force attack. This would be detected when the server receives the second request, but that does not prevent the attacker from obtaining the MESSAGE-INTEGRITY-SHA256 value.",
      "ja": "このプロトコルのビッドダウン防御は、攻撃者がクライアントとサーバーに、共同でサポートするよりも弱いアルゴリズムを使用してハンドシェイクを完了するように強制することを防ぎますが、最も弱い共同アルゴリズムがブルートフォース攻撃によって危険にさらされないほど強力である場合に限ります。。ただし、これはこれらのアルゴリズムに対する多くの攻撃を防御するものではありません。具体的には、パス上の攻撃者は、パスワードハッシュにArgon2 [Argon2]とSHA-256の両方をサポートするクライアントに対してビッドダウン攻撃を実行し、それを使用してMESSAGE-INTEGRITY-SHA256値を収集します。オフラインブルートフォース攻撃。これは、サーバーが2番目の要求を受信したときに検出されますが、攻撃者がMESSAGE-INTEGRITY-SHA256値を取得することを妨げるものではありません。"
    },
    {
      "indent": 3,
      "text": "Similarly, an attack against the USERHASH mechanism will not succeed in establishing a session as the server will detect that the feature was discarded on path, but the client would still have been convinced to send its username in the clear in the USERNAME attribute, thus disclosing it to the attacker.",
      "ja": "同様に、USERHASHメカニズムに対する攻撃は、機能がパス上で破棄されたことをサーバーが検出するため、セッションの確立に成功しませんが、クライアントは、USERNAME属性で平文でユーザー名を送信することを確信しているため、攻撃者にそれを開示することになります。"
    },
    {
      "indent": 3,
      "text": "Finally, when the bid-down protection mechanism is employed for a future upgrade of the HMAC algorithm used to protect messages, it will offer only a limited protection if the current HMAC algorithm is already compromised.",
      "ja": "最後に、メッセージの保護に使用されるHMACアルゴリズムの将来のアップグレードにビッドダウン保護メカニズムが採用された場合、現在のHMACアルゴリズムがすでに侵害されている場合は、限定的な保護しか提供されません。"
    },
    {
      "indent": 0,
      "text": "16.2. Attacks Affecting the Usage",
      "section_title": true,
      "ja": "16.2. 使用法に影響を与える攻撃"
    },
    {
      "indent": 3,
      "text": "This section lists attacks that might be launched against a usage of STUN. Each STUN Usage must consider whether these attacks are applicable to it and, if so, discuss countermeasures.",
      "ja": "このセクションでは、STUNの使用に対して開始される可能性のある攻撃をリストします。各STUNの使用法では、これらの攻撃が適用可能かどうかを検討し、適用できる場合は対策について話し合う必要があります。"
    },
    {
      "indent": 0,
      "text": " Most of the attacks in this section revolve around an attacker modifying the reflexive address learned by a STUN client through a Binding request/response transaction. Since the usage of the reflexive address is a function of the usage, the applicability and remediation of these attacks are usage-specific. In common situations, modification of the reflexive address by an on-path attacker is easy to do. Consider, for example, the common situation where STUN is run directly over UDP. In this case, an on-path attacker can modify the source IP address of the Binding request before it arrives at the STUN server. The STUN server will then return this IP address in the XOR-MAPPED-ADDRESS attribute to the client and send the response back to that (falsified) IP address and port. If the attacker can also intercept this response, it can direct it back towards the client. Protecting against this attack by using a message-integrity check is impossible, since a message-integrity value cannot cover the source IP address and the intervening NAT must be able to modify this value. Instead, one solution to prevent the attacks listed below is for the client to verify the reflexive address learned, as is done in ICE [RFC8445].",
      "ja": "このセクションの攻撃のほとんどは、攻撃者がバインディング要求/応答トランザクションを通じてSTUNクライアントによって学習された反射アドレスを変更することを中心に展開されます。反射アドレスの使用法は使用法の関数であるため、これらの攻撃の適用性と修復は使用法に固有です。一般的な状況では、パス上の攻撃者による反射アドレスの変更は簡単に実行できます。たとえば、STUNがUDP上で直接実行される一般的な状況を考えてみます。この場合、パス上の攻撃者は、バインディング要求がSTUNサーバーに到着する前に送信元IPアドレスを変更できます。次に、STUNサーバーはXOR-MAPPED-ADDRESS属性でこのIPアドレスをクライアントに返し、その（偽造された）IPアドレスとポートに応答を送り返します。攻撃者がこの応答も傍受できる場合は、クライアントに向けて戻すことができます。メッセージ整合性値は送信元IPアドレスをカバーできず、介在するNATがこの値を変更できる必要があるため、メッセージ整合性チェックを使用してこの攻撃から保護することは不可能です。代わりに、以下にリストされている攻撃を防ぐための1つの解決策は、ICE [RFC8445]で行われているように、クライアントが学習した反射アドレスを検証することです。"
    },
    {
      "indent": 3,
      "text": "Other usages may use other means to prevent these attacks.",
      "ja": "他の使用法では、これらの攻撃を防ぐために他の手段を使用する場合があります。"
    },
    {
      "indent": 0,
      "text": "16.2.1. Attack I: Distributed DoS (DDoS) against a Target",
      "section_title": true,
      "ja": "16.2.1. 攻撃I：ターゲットに対する分散型DoS（DDoS）"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker provides one or more clients with the same faked reflexive address that points to the intended target. This will trick the STUN clients into thinking that their reflexive addresses are equal to that of the target. If the clients hand out that reflexive address in order to receive traffic on it (for example, in SIP messages), the traffic will instead be sent to the target. This attack can provide substantial amplification, especially when used with clients that are using STUN to enable multimedia applications. However, it can only be launched against targets for which packets from the STUN server to the target pass through the attacker, limiting the cases in which it is possible.",
      "ja": "この攻撃では、攻撃者は1つ以上のクライアントに、目的のターゲットを指す同じ偽の反射アドレスを提供します。これにより、STUNクライアントをだまして、反射アドレスがターゲットのアドレスと等しいと思い込ませます。クライアントがトラフィックを受信するためにその反射アドレスを配布した場合（たとえば、SIPメッセージで）、トラフィックは代わりにターゲットに送信されます。この攻撃は、特にSTUNを使用してマルチメディアアプリケーションを有効にしているクライアントで使用した場合に、大幅な増幅をもたらす可能性があります。ただし、STUNサーバーからターゲットへのパケットが攻撃者を通過するターゲットに対してのみ起動できるため、可能な場合が制限されます。"
    },
    {
      "indent": 0,
      "text": "16.2.2. Attack II: Silencing a Client",
      "section_title": true,
      "ja": "16.2.2. 攻撃II：クライアントのサイレンシング"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker provides a STUN client with a faked reflexive address. The reflexive address it provides is a transport address that routes to nowhere. As a result, the client won't receive any of the packets it expects to receive when it hands out the reflexive address. This exploitation is not very interesting for the attacker. It impacts a single client, which is frequently not the desired target. Moreover, any attacker that can mount the attack could also deny service to the client by other means, such as preventing the client from receiving any response from the STUN server, or even a DHCP server. As with the attack described in Section 16.2.1, this attack is only possible when the attacker is on path for packets sent from the STUN server towards this unused IP address.",
      "ja": "この攻撃では、攻撃者はSTUNクライアントに偽の反射アドレスを提供します。それが提供する反射アドレスは、どこにもルーティングされないトランスポートアドレスです。その結果、クライアントは、反射アドレスを渡すときに受信する予定のパケットを受信しません。この悪用は、攻撃者にとってあまり興味深いものではありません。これは単一のクライアントに影響を与えますが、これは多くの場合、望ましいターゲットではありません。さらに、攻撃を仕掛けることができる攻撃者は、クライアントがSTUNサーバー、さらにはDHCPサーバーからの応答を受信できないようにするなど、他の手段によってクライアントへのサービスを拒否する可能性もあります。セクション16.2.1で説明されている攻撃と同様に、この攻撃は、攻撃者がSTUNサーバーからこの未使用のIPアドレスに送信されるパケットのパス上にいる場合にのみ可能です。"
    },
    {
      "indent": 0,
      "text": "16.2.3. Attack III: Assuming the Identity of a Client",
      "section_title": true,
      "ja": "16.2.3. 攻撃III：クライアントの身元を想定する"
    },
    {
      "indent": 3,
      "text": "This attack is similar to attack II. However, the faked reflexive address points to the attacker itself. This allows the attacker to receive traffic that was destined for the client.",
      "ja": "この攻撃は攻撃IIに似ています。ただし、偽の反射アドレスは攻撃者自身を指しています。これにより、攻撃者はクライアント宛てのトラフィックを受信できます。"
    },
    {
      "indent": 0,
      "text": "16.2.4. Attack IV: Eavesdropping",
      "section_title": true,
      "ja": "16.2.4. 攻撃IV：盗聴"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker forces the client to use a reflexive address that routes to itself. It then forwards any packets it receives to the client. This attack allows the attacker to observe all packets sent to the client. However, in order to launch the attack, the attacker must have already been able to observe packets from the client to the STUN server. In most cases (such as when the attack is launched from an access network), this means that the attacker could already observe packets sent to the client. This attack is, as a result, only useful for observing traffic by attackers on the path from the client to the STUN server, but not generally on the path of packets being routed towards the client.",
      "ja": "この攻撃では、攻撃者はクライアントに自分自身にルーティングする反射アドレスを使用するように強制します。次に、受信したパケットをクライアントに転送します。この攻撃により、攻撃者はクライアントに送信されたすべてのパケットを監視できます。ただし、攻撃を開始するには、攻撃者はクライアントからSTUNサーバーへのパケットをすでに監視できている必要があります。ほとんどの場合（攻撃がアクセスネットワークから開始された場合など）、これは攻撃者がクライアントに送信されたパケットをすでに監視している可能性があることを意味します。その結果、この攻撃は、クライアントからSTUNサーバーへのパス上の攻撃者によるトラフィックを監視する場合にのみ役立ちますが、通常、クライアントに向けてルーティングされるパケットのパス上では役に立ちません。"
    },
    {
      "indent": 3,
      "text": "Note that this attack can be trivially launched by the STUN server itself, so users of STUN servers should have the same level of trust in the users of STUN servers as any other node that can insert itself into the communication flow.",
      "ja": "この攻撃はSTUNサーバー自体によって簡単に開始される可能性があるため、STUNサーバーのユーザーは、通信フローに自分自身を挿入できる他のノードと同じレベルの信頼をSTUNサーバーのユーザーに持たせる必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "16.3. Hash Agility Plan",
      "section_title": true,
      "ja": "16.3. ハッシュアジリティプラン"
    },
    {
      "indent": 3,
      "text": "This specification uses HMAC-SHA256 for computation of the message integrity, sometimes in combination with HMAC-SHA1. If, at a later time, HMAC-SHA256 is found to be compromised, the following remedy should be applied:",
      "ja": "この仕様では、メッセージの整合性の計算にHMAC-SHA256を使用し、場合によってはHMAC-SHA1と組み合わせて使用します。後でHMAC-SHA256が危険にさらされていることが判明した場合は、次の救済策を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Both a new message-integrity attribute and a new STUN Security Feature bit will be allocated in a Standards Track document. The new message-integrity attribute will have its value computed using a new hash. The STUN Security Feature bit will be used to simultaneously 1) signal to a STUN client using the long-term credential mechanism that this server supports this new hash algorithm and 2) prevent bid-down attacks on the new message-integrity attribute.",
      "ja": "o 新しいメッセージ整合性属性と新しいSTUNセキュリティ機能ビットの両方が標準化過程文書に割り当てられます。新しいmessage-integrity属性の値は、新しいハッシュを使用して計算されます。STUNセキュリティ機能ビットは、1）このサーバーがこの新しいハッシュアルゴリズムをサポートしているという長期的な資格情報メカニズムを使用してSTUNクライアントに信号を送り、2）新しいメッセージ整合性属性に対するビッドダウン攻撃を防ぐために使用されます。"
    },
    {
      "indent": 3,
      "text": "o STUN clients and servers using the short-term credential mechanism will need to update the external mechanism that they use to signal what message-integrity attributes are in use.",
      "ja": "o 短期の資格情報メカニズムを使用するSTUNクライアントとサーバーは、使用されているメッセージ整合性属性を通知するために使用する外部メカニズムを更新する必要があります。"
    },
    {
      "indent": 0,
      "text": " The bid-down protection mechanism described in this document is new and thus cannot currently protect against a bid-down attack that lowers the strength of the hash algorithm to HMAC-SHA1. This is why, after a transition period, a new document updating this one will assign a new STUN Security Feature bit for deprecating HMAC-SHA1. When used, this bit will signal that HMAC-SHA1 is deprecated and should no longer be used.",
      "ja": "このドキュメントで説明されているビッドダウン保護メカニズムは新しいため、現在、ハッシュアルゴリズムの強度をHMAC-SHA1に低下させるビッドダウン攻撃から保護することはできません。これが、移行期間の後、これを更新する新しいドキュメントが、HMAC-SHA1を非推奨にするための新しいSTUNセキュリティ機能ビットを割り当てる理由です。このビットを使用すると、HMAC-SHA1が非推奨になり、使用しないようになったことを通知します。"
    },
    {
      "indent": 3,
      "text": "Similarly, if HMAC-SHA256 is found to be compromised, a new userhash attribute and a new STUN Security Feature bit will be allocated in a Standards Track document. The new userhash attribute will have its value computed using a new hash. The STUN Security Feature bit will be used to simultaneously 1) signal to a STUN client using the long-term credential mechanism that this server supports this new hash algorithm for the userhash attribute and 2) prevent bid-down attacks on the new userhash attribute.",
      "ja": "同様に、HMAC-SHA256が危険にさらされていることが判明した場合、新しいuserhash属性と新しいSTUNセキュリティ機能ビットが標準化過程文書に割り当てられます。新しいuserhash属性の値は、新しいハッシュを使用して計算されます。STUNセキュリティ機能ビットは、1）このサーバーがuserhash属性のこの新しいハッシュアルゴリズムをサポートしていることを長期的な資格情報メカニズムを使用してSTUNクライアントに通知し、2）新しいuserhash属性に対するビッドダウン攻撃を防ぐために同時に使用されます。"
    },
    {
      "indent": 0,
      "text": "17. IAB Considerations",
      "section_title": true,
      "ja": "17. IABの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IAB has studied the problem of Unilateral Self-Address Fixing (UNSAF), which is the general process by which a client attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism [RFC3424]. STUN can be used to perform this function using a Binding request/ response transaction if one agent is behind a NAT and the other is on the public side of the NAT.",
      "ja": "IABは、片側自己アドレス修正（UNSAF）の問題を研究しました。これは、クライアントが協調プロトコルリフレクションメカニズム[RFC3424]を介してNATの反対側にある別のレルムでアドレスを決定しようとする一般的なプロセスです。一方のエージェントがNATの背後にあり、もう一方がNATのパブリック側にある場合、STUNを使用して、バインディング要求/応答トランザクションを使用してこの機能を実行できます。"
    },
    {
      "indent": 3,
      "text": "The IAB has suggested that protocols developed for this purpose document a specific set of considerations. Because some STUN Usages provide UNSAF functions (such as ICE [RFC8445]) and others do not (such as SIP Outbound [RFC5626]), answers to these considerations need to be addressed by the usages themselves.",
      "ja": "IABは、この目的のために開発されたプロトコルが特定の考慮事項を文書化することを提案しています。一部のSTUN使用法はUNSAF機能（ICE [RFC8445]など）を提供し、他の使用法は提供しない（SIPアウトバウンド[RFC5626]など）ため、これらの考慮事項への回答は使用法自体で対処する必要があります。"
    },
    {
      "indent": 0,
      "text": "18. IANA Considerations",
      "section_title": true,
      "ja": "18. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "18.1. STUN Security Features Registry",
      "section_title": true,
      "ja": "18.1. STUNセキュリティ機能レジストリ"
    },
    {
      "indent": 3,
      "text": "A STUN Security Feature set defines 24 bits as flags.",
      "ja": "STUNセキュリティ機能セットは、24ビットをフラグとして定義します。"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry containing the STUN Security Features that are protected by the bid-down attack prevention mechanism described in Section 9.2.1.",
      "ja": "IANAは、セクション9.2.1で説明されているビッドダウン攻撃防止メカニズムによって保護されるSTUNセキュリティ機能を含む新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "The initial STUN Security Features are:",
      "ja": "初期のSTUNセキュリティ機能は次のとおりです。"
    },
    {
      "indent": 0,
      "text": " Bit 0: Password algorithms Bit 1: Username anonymity Bit 2-23: Unassigned Bits are assigned starting from the most significant side of the bit set, so Bit 0 is the leftmost bit and Bit 23 is the rightmost bit.",
      "ja": "ビット0：パスワードアルゴリズムビット1：ユーザー名の匿名性ビット2-23：未割り当てビットはビットセットの最上位側から割り当てられるため、ビット0が左端のビット、ビット23が右端のビットです。"
    },
    {
      "indent": 3,
      "text": "New Security Features are assigned by Standards Action [RFC8126].",
      "ja": "新しいセキュリティ機能は、標準アクション[RFC8126]によって割り当てられます。"
    },
    {
      "indent": 0,
      "text": "18.2. STUN Methods Registry",
      "section_title": true,
      "ja": "18.2. STUNメソッドレジストリ"
    },
    {
      "indent": 3,
      "text": "A STUN method is a hex number in the range 0x000-0x0FF. The encoding of a STUN method into a STUN message is described in Section 5.",
      "ja": "STUNメソッドは、0x000〜0x0FFの範囲の16進数です。STUNメソッドのSTUNメッセージへのエンコードについては、セクション5で説明します。"
    },
    {
      "indent": 3,
      "text": "STUN methods in the range 0x000-0x07F are assigned by IETF Review [RFC8126]. STUN methods in the range 0x080-0x0FF are assigned by Expert Review [RFC8126]. The responsibility of the expert is to verify that the selected codepoint(s) is not in use and that the request is not for an abnormally large number of codepoints. Technical review of the extension itself is outside the scope of the designated expert responsibility.",
      "ja": "0x000〜0x07Fの範囲のSTUNメソッドは、IETFレビュー[RFC8126]によって割り当てられます。0x080-0x0FFの範囲のSTUNメソッドは、Expert Review [RFC8126]によって割り当てられます。専門家の責任は、選択したコードポイントが使用されていないこと、および要求が異常に多数のコードポイントに対するものではないことを確認することです。拡張機能自体の技術的レビューは、指定された専門家の責任の範囲外です。"
    },
    {
      "indent": 3,
      "text": "IANA has updated the name for method 0x002 as described below as well as updated the reference from RFC 5389 to RFC 8489 for the following STUN methods:",
      "ja": "IANAは、以下に説明するようにメソッド0x002の名前を更新し、次のSTUNメソッドの参照をRFC5389からRFC8489に更新しました。"
    },
    {
      "indent": 3,
      "text": "0x000: Reserved\n0x001: Binding\n0x002: Reserved; was SharedSecret prior to [RFC5389]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.3. STUN Attributes Registry",
      "section_title": true,
      "ja": "18.3. STUN属性レジストリ"
    },
    {
      "indent": 3,
      "text": "A STUN attribute type is a hex number in the range 0x0000-0xFFFF. STUN attribute types in the range 0x0000-0x7FFF are considered comprehension-required; STUN attribute types in the range 0x8000-0xFFFF are considered comprehension-optional. A STUN agent handles unknown comprehension-required and comprehension-optional attributes differently.",
      "ja": "STUN属性タイプは、0x0000〜0xFFFFの範囲の16進数です。0x0000〜0x7FFFの範囲のSTUN属性タイプは、理解必須であると見なされます。0x8000-0xFFFFの範囲のSTUN属性タイプは、理解オプションと見なされます。STUNエージェントは、不明な理解必須属性と理解オプション属性を異なる方法で処理します。"
    },
    {
      "indent": 3,
      "text": "STUN attribute types in the first half of the comprehension-required range (0x0000-0x3FFF) and in the first half of the comprehension-optional range (0x8000-0xBFFF) are assigned by IETF Review [RFC8126]. STUN attribute types in the second half of the comprehension-required range (0x4000-0x7FFF) and in the second half of the comprehension-optional range (0xC000-0xFFFF) are assigned by Expert Review [RFC8126]. The responsibility of the expert is to verify that the selected codepoint(s) are not in use and that the request is not for an abnormally large number of codepoints. Technical review of the extension itself is outside the scope of the designated expert responsibility.",
      "ja": "理解が必要な範囲の前半（0x0000-0x3FFF）と理解が必要な範囲の前半（0x8000-0xBFFF）のSTUN属性タイプは、IETFレビュー[RFC8126]によって割り当てられます。理解が必要な範囲の後半（0x4000-0x7FFF）と理解が必要な範囲の後半（0xC000-0xFFFF）のSTUN属性タイプは、Expert Review [RFC8126]によって割り当てられます。専門家の責任は、選択したコードポイントが使用されていないこと、および要求が異常に多数のコードポイントに対するものではないことを確認することです。拡張機能自体の技術的レビューは、指定された専門家の責任の範囲外です。"
    },
    {
      "indent": 0,
      "text": "18.3.1. Updated Attributes",
      "section_title": true,
      "ja": "18.3.1. 更新された属性"
    },
    {
      "indent": 3,
      "text": "IANA has updated the names for attributes 0x0002, 0x0004, 0x0005, 0x0007, and 0x000B as well as updated the reference from RFC 5389 to RFC 8489 for each the following STUN methods.",
      "ja": "IANAは、属性0x0002、0x0004、0x0005、0x0007、および0x000Bの名前を更新し、次の各STUNメソッドの参照をRFC5389からRFC8489に更新しました。"
    },
    {
      "indent": 3,
      "text": "In addition, [RFC5389] introduced a mistake in the name of attribute 0x0003; [RFC5389] called it CHANGE-ADDRESS when it was actually previously called CHANGE-REQUEST. Thus, IANA has updated the description for 0x0003 to read \"Reserved; was CHANGE-REQUEST prior to [RFC5389]\".",
      "ja": "さらに、[RFC5389]は属性0x0003の名前に誤りを導入しました。[RFC5389]は、以前は実際にCHANGE-REQUESTと呼ばれていたときに、それをCHANGE-ADDRESSと呼んでいました。したがって、IANAは0x0003の説明を更新して、「予約済み。[RFC5389]より前はCHANGE-REQUESTでした」と読み替えました。"
    },
    {
      "indent": 3,
      "text": "Comprehension-required range (0x0000-0x7FFF):\n0x0000: Reserved\n0x0001: MAPPED-ADDRESS\n0x0002: Reserved; was RESPONSE-ADDRESS prior to [RFC5389]\n0x0003: Reserved; was CHANGE-REQUEST prior to [RFC5389]\n0x0004: Reserved; was SOURCE-ADDRESS prior to [RFC5389]\n0x0005: Reserved; was CHANGED-ADDRESS prior to [RFC5389]\n0x0006: USERNAME\n0x0007: Reserved; was PASSWORD prior to [RFC5389]\n0x0008: MESSAGE-INTEGRITY\n0x0009: ERROR-CODE\n0x000A: UNKNOWN-ATTRIBUTES\n0x000B: Reserved; was REFLECTED-FROM prior to [RFC5389]\n0x0014: REALM\n0x0015: NONCE\n0x0020: XOR-MAPPED-ADDRESS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Comprehension-optional range (0x8000-0xFFFF)\n0x8022: SOFTWARE\n0x8023: ALTERNATE-SERVER\n0x8028: FINGERPRINT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.3.2. New Attributes",
      "section_title": true,
      "ja": "18.3.2. 新しい属性"
    },
    {
      "indent": 3,
      "text": "IANA has added the following attribute to the \"STUN Attributes\" registry:",
      "ja": "IANAは、「STUN属性」レジストリに次の属性を追加しました。"
    },
    {
      "indent": 3,
      "text": "Comprehension-required range (0x0000-0x7FFF):\n0x001C: MESSAGE-INTEGRITY-SHA256\n0x001D: PASSWORD-ALGORITHM\n0x001E: USERHASH\n\nComprehension-optional range (0x8000-0xFFFF)\n0x8002: PASSWORD-ALGORITHMS\n0x8003: ALTERNATE-DOMAIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.4. STUN Error Codes Registry",
      "section_title": true,
      "ja": "18.4. STUNエラーコードレジストリ"
    },
    {
      "indent": 3,
      "text": "A STUN error code is a number in the range 0-699. STUN error codes are accompanied by a textual reason phrase in UTF-8 [RFC3629] that is intended only for human consumption and can be anything appropriate; this document proposes only suggested values.",
      "ja": "STUNエラーコードは、0〜699の範囲の数値です。STUNエラーコードには、UTF-8 [RFC3629]のテキストによる理由フレーズが付随しています。これは、人間による消費のみを目的としており、適切なものであれば何でもかまいません。このドキュメントでは、推奨値のみを提案しています。"
    },
    {
      "indent": 3,
      "text": "STUN error codes are consistent in codepoint assignments and semantics with SIP [RFC3261] and HTTP [RFC7231].",
      "ja": "STUNエラーコードは、SIP [RFC3261]およびHTTP [RFC7231]とのコードポイント割り当ておよびセマンティクスで一貫しています。"
    },
    {
      "indent": 3,
      "text": "New STUN error codes are assigned based on IETF Review [RFC8126]. The specification must carefully consider how clients that do not understand this error code will process it before granting the request. See the rules in Section 6.3.4.",
      "ja": "新しいSTUNエラーコードは、IETFレビュー[RFC8126]に基づいて割り当てられます。仕様では、このエラーコードを理解していないクライアントが、要求を許可する前にエラーコードを処理する方法を慎重に検討する必要があります。セクション6.3.4のルールを参照してください。"
    },
    {
      "indent": 3,
      "text": "IANA has updated the reference from RFC 5389 to RFC 8489 for the error codes defined in Section 14.8.",
      "ja": "IANAは、セクション14.8で定義されているエラーコードのリファレンスをRFC5389からRFC8489に更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has changed the name of the 401 error code from \"Unauthorized\" to \"Unauthenticated\".",
      "ja": "IANAは、401エラーコードの名前を「Unauthorized」から「Unauthenticated」に変更しました。"
    },
    {
      "indent": 0,
      "text": "18.5. STUN Password Algorithms Registry",
      "section_title": true,
      "ja": "18.5. STUNパスワードアルゴリズムレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry titled \"STUN Password Algorithms\".",
      "ja": "IANAは、「STUNPasswordAlgorithms」というタイトルの新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "A password algorithm is a hex number in the range 0x0000-0xFFFF.",
      "ja": "パスワードアルゴリズムは、0x0000〜0xFFFFの範囲の16進数です。"
    },
    {
      "indent": 3,
      "text": "The initial contents of the \"Password Algorithm\" registry are as follows:",
      "ja": "「パスワードアルゴリズム」レジストリの初期内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000: Reserved\n0x0001: MD5\n0x0002: SHA-256\n0x0003-0xFFFF: Unassigned",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Password algorithms in the first half of the range (0x0000-0x7FFF) are assigned by IETF Review [RFC8126]. Password algorithms in the second half of the range (0x8000-0xFFFF) are assigned by Expert Review [RFC8126].",
      "ja": "範囲の前半（0x0000-0x7FFF）のパスワードアルゴリズムは、IETFレビュー[RFC8126]によって割り当てられます。範囲の後半（0x8000-0xFFFF）のパスワードアルゴリズムは、Expert Review [RFC8126]によって割り当てられます。"
    },
    {
      "indent": 0,
      "text": "18.5.1. Password Algorithms",
      "section_title": true,
      "ja": "18.5.1. パスワードアルゴリズム"
    },
    {
      "indent": 0,
      "text": "18.5.1.1. MD5",
      "section_title": true,
      "ja": "18.5.1.1. MD5"
    },
    {
      "indent": 3,
      "text": "This password algorithm is taken from [RFC1321].",
      "ja": "このパスワードアルゴリズムは[RFC1321]から取得されます。"
    },
    {
      "indent": 3,
      "text": "The key length is 16 bytes, and the parameters value is empty.",
      "ja": "キーの長さは16バイトで、パラメーター値は空です。"
    },
    {
      "indent": 6,
      "text": "Note: This algorithm MUST only be used for compatibility with legacy systems.",
      "ja": "注：このアルゴリズムは、レガシーシステムとの互換性のためにのみ使用する必要があります。"
    },
    {
      "indent": 16,
      "text": "key = MD5(username \":\" OpaqueString(realm)\n  \":\" OpaqueString(password))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.5.1.2. SHA-256",
      "section_title": true,
      "ja": "18.5.1.2. SHA-256"
    },
    {
      "indent": 3,
      "text": "This password algorithm is taken from [RFC7616].",
      "ja": "このパスワードアルゴリズムは[RFC7616]から取得されます。"
    },
    {
      "indent": 3,
      "text": "The key length is 32 bytes, and the parameters value is empty.",
      "ja": "キーの長さは32バイトで、パラメーター値は空です。"
    },
    {
      "indent": 14,
      "text": "key = SHA-256(username \":\" OpaqueString(realm)\n  \":\" OpaqueString(password))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "18.6. STUN UDP and TCP Port Numbers",
      "section_title": true,
      "ja": "18.6. STUN UDPおよびTCPポート番号"
    },
    {
      "indent": 3,
      "text": "IANA has updated the reference from RFC 5389 to RFC 8489 for the following ports in the \"Service Name and Transport Protocol Port Number Registry\".",
      "ja": "IANAは、「サービス名およびトランスポートプロトコルポート番号レジストリ」の次のポートの参照をRFC5389からRFC8489に更新しました。"
    },
    {
      "indent": 3,
      "text": "stun   3478/tcp   Session Traversal Utilities for NAT (STUN) port\nstun   3478/udp   Session Traversal Utilities for NAT (STUN) port\nstuns  5349/tcp   Session Traversal Utilities for NAT (STUN) port",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "19. Changes since RFC 5389",
      "section_title": true,
      "ja": "19. RFC5389以降の変更"
    },
    {
      "indent": 3,
      "text": "This specification obsoletes [RFC5389]. This specification differs from RFC 5389 in the following ways:",
      "ja": "この仕様は廃止されました[RFC5389]。この仕様は、次の点でRFC5389と異なります。"
    },
    {
      "indent": 3,
      "text": "o Added support for DTLS-over-UDP [RFC6347].",
      "ja": "o DTLS-over-UDP [RFC6347]のサポートが追加されました。"
    },
    {
      "indent": 3,
      "text": "o Made clear that the RTO is considered stale if there are no transactions with the server.",
      "ja": "o サーバーとのトランザクションがない場合、RTOは失効していると見なされることを明確にしました。"
    },
    {
      "indent": 3,
      "text": "o Aligned the RTO calculation with [RFC6298].",
      "ja": "o RTO計算を[RFC6298]に合わせました。"
    },
    {
      "indent": 3,
      "text": "o Updated the ciphersuites for TLS.",
      "ja": "o TLSの暗号スイートを更新しました。"
    },
    {
      "indent": 3,
      "text": "o Added support for STUN URI [RFC7064].",
      "ja": "o STUN URI [RFC7064]のサポートが追加されました。"
    },
    {
      "indent": 3,
      "text": "o Added support for SHA256 message integrity.",
      "ja": "o SHA256メッセージの整合性のサポートが追加されました。"
    },
    {
      "indent": 3,
      "text": "o Updated the Preparation, Enforcement, and Comparison of Internationalized Strings (PRECIS) support to [RFC8265].",
      "ja": "o Internationalized Strings（PRECIS）の準備、施行、比較のサポートを[RFC8265]に更新しました。"
    },
    {
      "indent": 3,
      "text": "o Added protocol and registry to choose the password encryption algorithm.",
      "ja": "o パスワード暗号化アルゴリズムを選択するためのプロトコルとレジストリを追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added support for anonymous username.",
      "ja": "o 匿名ユーザー名のサポートが追加されました。"
    },
    {
      "indent": 3,
      "text": "o Added protocol and registry for preventing bid-down attacks.",
      "ja": "o ビッドダウン攻撃を防ぐためのプロトコルとレジストリを追加しました。"
    },
    {
      "indent": 3,
      "text": "o Specified that sharing a NONCE is no longer permitted.",
      "ja": "o NONCEの共有は許可されなくなったことを指定しました。"
    },
    {
      "indent": 3,
      "text": "o Added the possibility of using a domain name in the alternate server mechanism.",
      "ja": "o 代替サーバーメカニズムでドメイン名を使用する可能性を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added more C snippets.",
      "ja": "o さらにCスニペットを追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added test vector.",
      "ja": "o テストベクトルを追加しました。"
    },
    {
      "indent": 0,
      "text": "20. References",
      "section_title": true,
      "ja": "20. 参考文献"
    },
    {
      "indent": 0,
      "text": "20.1. Normative References",
      "section_title": true,
      "ja": "20.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ITU.V42.2002] International Telecommunication Union, \"Error-correcting procedures for DCEs using asynchronous-to-synchronous conversion\", ITU-T Recommendation V.42, March 2002.",
      "ja": "[ITU.V42.2002] International Telecommunication Union、「非同期から同期への変換を使用したDCEのエラー訂正手順」、ITU-T勧告V.42、2002年3月。"
    },
    {
      "indent": 3,
      "text": "[KARN87] Karn, P. and C. Partridge, \"Improving Round-Trip Time Estimates in Reliable Transport Protocols\", SIGCOMM '87, Proceedings of the ACM workshop on Frontiers in computer communications technology, Pages 2-7, DOI 10.1145/55483.55484, August 1987.",
      "ja": "[KARN87] Karn、P。and C. Partridge、 \"Improving Round-Trip Time Estimates in Reliable Transport Protocols\"、SIGCOMM '87、Proceedings of the ACM Workshop on Frontiers in Computer Communications Technology、Pages 2-7、DOI 10.1145 / 55483.55484、1987年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, DOI 10.17487/RFC0791, September 1981, <https://www.rfc-editor.org/info/rfc791>.",
      "ja": "[RFC0791] Postel、J。、「Internet Protocol」、STD 5、RFC 791、DOI 10.17487 / RFC0791、1981年9月、<https://www.rfc-editor.org/info/rfc791>。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <https://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122] Braden、R.、Ed。、 \"Requirements for Internet Hosts-Communication Layers\"、STD 3、RFC 1122、DOI 10.17487 / RFC1122、October 1989、<https://www.rfc-editor.org/info/rfc1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC1123] Braden, R., Ed., \"Requirements for Internet Hosts - Application and Support\", STD 3, RFC 1123, DOI 10.17487/RFC1123, October 1989, <https://www.rfc-editor.org/info/rfc1123>.",
      "ja": "[RFC1123] Braden、R.、Ed。、 \"Requirements for Internet Hosts-Application and Support\"、STD 3、RFC 1123、DOI 10.17487 / RFC1123、October 1989、<https://www.rfc-editor.org/info/ rfc1123>。"
    },
    {
      "indent": 3,
      "text": "[RFC1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, DOI 10.17487/RFC1321, April 1992, <https://www.rfc-editor.org/info/rfc1321>.",
      "ja": "[RFC1321] Rivest、R。、「MD5メッセージダイジェストアルゴリズム」、RFC 1321、DOI 10.17487 / RFC1321、1992年4月、<https://www.rfc-editor.org/info/rfc1321>。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<https：//www.rfc-editor.org / info / rfc2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, DOI 10.17487/RFC2782, February 2000, <https://www.rfc-editor.org/info/rfc2782>.",
      "ja": "[RFC2782] Gulbrandsen、A.、Vixie、P。、およびL. Esibov、「サービスの場所を指定するためのDNS RR（DNS SRV）」、RFC 2782、DOI 10.17487 / RFC2782、2000年2月、<https：//www.rfc-editor.org/info/rfc2782>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換形式」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https://www.rfc-editor.org/info/rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64 Data Encodings」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<https://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5890] Klensin, J., \"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework\", RFC 5890, DOI 10.17487/RFC5890, August 2010, <https://www.rfc-editor.org/info/rfc5890>.",
      "ja": "[RFC5890] Klensin、J。、「Internationalized Domain Names for Applications（IDNA）：Definitions and Document Framework」、RFC 5890、DOI 10.17487 / RFC5890、2010年8月、<https://www.rfc-editor.org/info/rfc5890>。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <https://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125] Saint-Andre、P。およびJ. Hodges、「トランスポート層セキュリティ（TLS）のコンテキストでX.509（PKIX）証明書を使用したインターネット公開鍵インフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<https://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6151] Turner, S. and L. Chen, \"Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms\", RFC 6151, DOI 10.17487/RFC6151, March 2011, <https://www.rfc-editor.org/info/rfc6151>.",
      "ja": "[RFC6151] Turner、S。およびL. Chen、「MD5メッセージダイジェストおよびHMAC-MD5アルゴリズムのセキュリティに関する考慮事項の更新」、RFC 6151、DOI 10.17487 / RFC6151、2011年3月、<https：//www.rfc-editor.org/info/rfc6151>。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, DOI 10.17487/RFC6298, June 2011, <https://www.rfc-editor.org/info/rfc6298>.",
      "ja": "[RFC6298] Paxson、V.、Allman、M.、Chu、J。、およびM. Sargent、「Computing TCP's Retransmission Timer」、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、<https：//www.rfc-editor.org/info/rfc6298>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <https://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC7064] Nandakumar, S., Salgueiro, G., Jones, P., and M. Petit-Huguenin, \"URI Scheme for the Session Traversal Utilities for NAT (STUN) Protocol\", RFC 7064, DOI 10.17487/RFC7064, November 2013, <https://www.rfc-editor.org/info/rfc7064>.",
      "ja": "[RFC7064] Nandakumar、S.、Salgueiro、G.、Jones、P。、およびM. Petit-Huguenin、「NAT（STUN）プロトコルのセッショントラバーサルユーティリティのURIスキーム」、RFC 7064、DOI 10.17487 / RFC7064、11月2013、<https://www.rfc-editor.org/info/rfc7064>。"
    },
    {
      "indent": 3,
      "text": "[RFC7350] Petit-Huguenin, M. and G. Salgueiro, \"Datagram Transport Layer Security (DTLS) as Transport for Session Traversal Utilities for NAT (STUN)\", RFC 7350, DOI 10.17487/RFC7350, August 2014, <https://www.rfc-editor.org/info/rfc7350>.",
      "ja": "[RFC7350] Petit-Huguenin、M。and G. Salgueiro、 \"Datagram Transport Layer Security（DTLS）as Transport for Session Traversal Utilities for NAT（STUN）\"、RFC 7350、DOI 10.17487 / RFC7350、2014年8月、<https：//www.rfc-editor.org/info/rfc7350>。"
    },
    {
      "indent": 3,
      "text": "[RFC7616] Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, \"HTTP Digest Access Authentication\", RFC 7616, DOI 10.17487/RFC7616, September 2015, <https://www.rfc-editor.org/info/rfc7616>.",
      "ja": "[RFC7616] Shekh-Yusef、R.、Ed。、Ahrens、D.、and S. Bremer、 \"HTTP Digest Access Authentication\"、RFC 7616、DOI 10.17487 / RFC7616、September 2015、<https：//www.rfc-editor.org/info/rfc7616>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードにおける大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8200] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <https://www.rfc-editor.org/info/rfc8200>.",
      "ja": "[RFC8200] Deering、S。and R. Hinden、 \"Internet Protocol、Version 6（IPv6）Specification\"、STD 86、RFC 8200、DOI 10.17487 / RFC8200、July 2017、<https://www.rfc-editor.org/ info / rfc8200>。"
    },
    {
      "indent": 3,
      "text": "[RFC8265] Saint-Andre, P. and A. Melnikov, \"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords\", RFC 8265, DOI 10.17487/RFC8265, October 2017, <https://www.rfc-editor.org/info/rfc8265>.",
      "ja": "[RFC8265] Saint-Andre、P。およびA. Melnikov、「ユーザー名とパスワードを表す国際化された文字列の準備、実施、および比較」、RFC 8265、DOI 10.17487 / RFC8265、2017年10月、<https：//www.rfc-editor.org/info/rfc8265>。"
    },
    {
      "indent": 3,
      "text": "[RFC8305] Schinazi, D. and T. Pauly, \"Happy Eyeballs Version 2: Better Connectivity Using Concurrency\", RFC 8305, DOI 10.17487/RFC8305, December 2017, <https://www.rfc-editor.org/info/rfc8305>.",
      "ja": "[RFC8305] Schinazi、D。およびT. Pauly、「Happy Eyeballs Version 2：Better Connectivity Using Concurrency」、RFC 8305、DOI 10.17487 / RFC8305、2017年12月、<https://www.rfc-editor.org/info/rfc8305>。"
    },
    {
      "indent": 0,
      "text": "20.2. Informative References",
      "section_title": true,
      "ja": "20.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Argon2] Biryukov, A., Dinu, D., Khovratovich, D., and S. Josefsson, \"The memory-hard Argon2 password hash and proof-of-work function\", Work in Progress, draft-irtf-cfrg-argon2-09, November 2019.",
      "ja": "[Argon2] Biryukov、A.、Dinu、D.、Khovratovich、D。、およびS. Josefsson、「メモリハードなArgon2パスワードハッシュとプルーフオブワーク関数」、進行中の作業、draft-irtf-cfrg-アルゴン2-09、2019年11月。"
    },
    {
      "indent": 3,
      "text": "[BCP195] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, May 2015, <https://www.rfc-editor.org/info/bcp195>.",
      "ja": "[BCP195] Sheffer、Y.、Holz、R。、およびP. Saint-Andre、「トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、2015年5月、<https://www.rfc-editor.org/info/bcp195>。"
    },
    {
      "indent": 3,
      "text": "[RFC1952] Deutsch, P., \"GZIP file format specification version 4.3\", RFC 1952, DOI 10.17487/RFC1952, May 1996, <https://www.rfc-editor.org/info/rfc1952>.",
      "ja": "[RFC1952] Deutsch、P。、「GZIPファイル形式仕様バージョン4.3」、RFC 1952、DOI 10.17487 / RFC1952、1996年5月、<https://www.rfc-editor.org/info/rfc1952>。"
    },
    {
      "indent": 3,
      "text": "[RFC2279] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, DOI 10.17487/RFC2279, January 1998, <https://www.rfc-editor.org/info/rfc2279>.",
      "ja": "[RFC2279] Yergeau、F。、「UTF-8、ISO 10646の変換形式」、RFC 2279、DOI 10.17487 / RFC2279、1998年1月、<https://www.rfc-editor.org/info/rfc2279>。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, DOI 10.17487/RFC3261, June 2002, <https://www.rfc-editor.org/info/rfc3261>.",
      "ja": "[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M。、およびE. Schooler、「SIP：SessionInitiationProtocol」、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>。"
    },
    {
      "indent": 3,
      "text": "[RFC3424] Daigle, L., Ed. and IAB, \"IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation\", RFC 3424, DOI 10.17487/RFC3424, November 2002, <https://www.rfc-editor.org/info/rfc3424>.",
      "ja": "[RFC3424] Daigle、L.、Ed。およびIAB、「ネットワークアドレス変換全体でのUNilateral Self-Address Fixing（UNSAF）に関するIABの考慮事項」、RFC 3424、DOI 10.17487 / RFC3424、2002年11月、<https://www.rfc-editor.org/info/rfc3424>。"
    },
    {
      "indent": 3,
      "text": "[RFC3454] Hoffman, P. and M. Blanchet, \"Preparation of Internationalized Strings (\"stringprep\")\", RFC 3454, DOI 10.17487/RFC3454, December 2002, <https://www.rfc-editor.org/info/rfc3454>.",
      "ja": "[RFC3454] Hoffman、P。and M. Blanchet、 \"Preparation of Internationalized Strings（\" stringprep \"）\"、RFC 3454、DOI 10.17487 / RFC3454、2002年12月、<https://www.rfc-editor.org/info/rfc3454>。"
    },
    {
      "indent": 3,
      "text": "[RFC3489] Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, \"STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)\", RFC 3489, DOI 10.17487/RFC3489, March 2003, <https://www.rfc-editor.org/info/rfc3489>.",
      "ja": "[RFC3489] Rosenberg、J.、Weinberger、J.、Huitema、C。、およびR. Mahy、「STUN-ネットワークアドレス変換器（NAT）を介したユーザーデータグラムプロトコル（UDP）の単純なトラバーサル」、RFC 3489、DOI 10.17487 /RFC3489、2003年3月、<https://www.rfc-editor.org/info/rfc3489>。"
    },
    {
      "indent": 3,
      "text": "[RFC4013] Zeilenga, K., \"SASLprep: Stringprep Profile for User Names and Passwords\", RFC 4013, DOI 10.17487/RFC4013, February 2005, <https://www.rfc-editor.org/info/rfc4013>.",
      "ja": "[RFC4013] Zeilenga、K。、「SASLprep：Stringprep Profile for User Names and Passwords」、RFC 4013、DOI 10.17487 / RFC4013、2005年2月、<https://www.rfc-editor.org/info/rfc4013>。"
    },
    {
      "indent": 3,
      "text": "[RFC4107] Bellovin, S. and R. Housley, \"Guidelines for Cryptographic Key Management\", BCP 107, RFC 4107, DOI 10.17487/RFC4107, June 2005, <https://www.rfc-editor.org/info/rfc4107>.",
      "ja": "[RFC4107] Bellovin、S。and R. Housley、 \"Guidelines for Cryptographic Key Management\"、BCP 107、RFC 4107、DOI 10.17487 / RFC4107、June 2005、<https://www.rfc-editor.org/info/rfc4107>。"
    },
    {
      "indent": 3,
      "text": "[RFC5090] Sterman, B., Sadolevsky, D., Schwartz, D., Williams, D., and W. Beck, \"RADIUS Extension for Digest Authentication\", RFC 5090, DOI 10.17487/RFC5090, February 2008, <https://www.rfc-editor.org/info/rfc5090>.",
      "ja": "[RFC5090] Sterman、B.、Sadolevsky、D.、Schwartz、D.、Williams、D。、およびW. Beck、「RADIUS Extension for Digest Authentication」、RFC 5090、DOI 10.17487 / RFC5090、2008年2月、<https：//www.rfc-editor.org/info/rfc5090>。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, DOI 10.17487/RFC5389, October 2008, <https://www.rfc-editor.org/info/rfc5389>.",
      "ja": "[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P。、およびD. Wing、「Session Traversal Utilities for NAT（STUN）」、RFC 5389、DOI 10.17487 / RFC5389、2008年10月、<https：//www.rfc-editor.org/info/rfc5389>。"
    },
    {
      "indent": 3,
      "text": "[RFC5626] Jennings, C., Ed., Mahy, R., Ed., and F. Audet, Ed., \"Managing Client-Initiated Connections in the Session Initiation Protocol (SIP)\", RFC 5626, DOI 10.17487/RFC5626, October 2009, <https://www.rfc-editor.org/info/rfc5626>.",
      "ja": "[RFC5626] Jennings、C.、Ed。、Mahy、R.、Ed。、and F. Audet、Ed。、 \"Managing Client-Initiated Connections in the Session Initiation Protocol（SIP）\"、RFC 5626、DOI 10.17487 / RFC5626、2009年10月、<https://www.rfc-editor.org/info/rfc5626>。"
    },
    {
      "indent": 3,
      "text": "[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)\", RFC 5766, DOI 10.17487/RFC5766, April 2010, <https://www.rfc-editor.org/info/rfc5766>.",
      "ja": "[RFC5766] Mahy、R.、Matthews、P。、およびJ. Rosenberg、「NAT周辺のリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）」、RFC 5766、DOI 10.17487 / RFC5766、4月2010、<https://www.rfc-editor.org/info/rfc5766>。"
    },
    {
      "indent": 3,
      "text": "[RFC5769] Denis-Courmont, R., \"Test Vectors for Session Traversal Utilities for NAT (STUN)\", RFC 5769, DOI 10.17487/RFC5769, April 2010, <https://www.rfc-editor.org/info/rfc5769>.",
      "ja": "[RFC5769] Denis-Courmont、R。、「NAT（STUN）のセッショントラバーサルユーティリティのテストベクトル」、RFC 5769、DOI 10.17487 / RFC5769、2010年4月、<https://www.rfc-editor.org/info/rfc5769>。"
    },
    {
      "indent": 3,
      "text": "[RFC5780] MacDonald, D. and B. Lowekamp, \"NAT Behavior Discovery Using Session Traversal Utilities for NAT (STUN)\", RFC 5780, DOI 10.17487/RFC5780, May 2010, <https://www.rfc-editor.org/info/rfc5780>.",
      "ja": "[RFC5780] MacDonald、D。and B. Lowekamp、 \"NAT Behavior Discovery Using Session Traversal Utilities for NAT（STUN）\"、RFC 5780、DOI 10.17487 / RFC5780、2010年5月、<https://www.rfc-editor.org/ info / rfc5780>。"
    },
    {
      "indent": 3,
      "text": "[RFC6544] Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach, \"TCP Candidates with Interactive Connectivity Establishment (ICE)\", RFC 6544, DOI 10.17487/RFC6544, March 2012, <https://www.rfc-editor.org/info/rfc6544>.",
      "ja": "[RFC6544] Rosenberg、J.、Keranen、A.、Lowekamp、B。、およびA. Roach、「Interactive Connectivity Establishment（ICE）を使用したTCP候補」、RFC 6544、DOI 10.17487 / RFC6544、2012年3月、<https：//www.rfc-editor.org/info/rfc6544>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <https://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R。、エド。およびJ.Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Semantics and Content」、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<https://www.rfc-editor.org/info/rfc7231>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCでIANA考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www.rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8264] Saint-Andre, P. and M. Blanchet, \"PRECIS Framework: Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols\", RFC 8264, DOI 10.17487/RFC8264, October 2017, <https://www.rfc-editor.org/info/rfc8264>.",
      "ja": "[RFC8264] Saint-Andre、P。およびM. Blanchet、「PRECIS Framework：Preparation、Enforcement、and Comparison of Internationalized Strings in Application Protocols」、RFC 8264、DOI 10.17487 / RFC8264、2017年10月、<https：// www。rfc-editor.org/info/rfc8264>。"
    },
    {
      "indent": 3,
      "text": "[RFC8445] Keranen, A., Holmberg, C., and J. Rosenberg, \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal\", RFC 8445, DOI 10.17487/RFC8445, July 2018, <https://www.rfc-editor.org/info/rfc8445>.",
      "ja": "[RFC8445] Keranen、A.、Holmberg、C。、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、<https://www.rfc-editor.org/info/rfc8445>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「The Transport Layer Security（TLS）Protocol Version 1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[STUN-PMTUD] Petit-Huguenin, M., Salgueiro, G., and F. Garrido, \"Packetization Layer Path MTU Discovery (PLMTUD) For UDP Transports Using Session Traversal Utilities for NAT (STUN)\", Work in Progress, draft-ietf-tram-stun-pmtud-15, December 2019.",
      "ja": "[STUN-PMTUD] Petit-Huguenin、M.、Salgueiro、G。、およびF. Garrido、「NAT（STUN）のセッショントラバーサルユーティリティを使用したUDPトランスポートのパケット化レイヤーパスMTUディスカバリー（PLMTUD）」、進行中の作業、ドラフト-ietf-tram-stun-pmtud-15、2019年12月。"
    },
    {
      "indent": 3,
      "text": "[UAX15] Unicode Standard Annex #15, \"Unicode Normalization Forms\", edited by Mark Davis and Ken Whistler. An integral part of The Unicode Standard, <http://unicode.org/reports/tr15/>.",
      "ja": "[UAX15]マーク・デイビスとケン・ウィスラーが編集したUnicode標準付属書＃15「Unicode正規化フォーム」。Unicode標準の不可欠な部分である<http://unicode.org/reports/tr15/>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. C Snippet to Determine STUN Message Types",
      "section_title": true,
      "ja": "付録A.STUNメッセージタイプを決定するためのCスニペット"
    },
    {
      "indent": 3,
      "text": "Given a 16-bit STUN message type value in host byte order in msg_type parameter, below are C macros to determine the STUN message types:",
      "ja": "msg_typeパラメーターにホストバイト順の16ビットSTUNメッセージタイプ値が与えられた場合、以下はSTUNメッセージタイプを決定するためのCマクロです。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\n#define IS_REQUEST(msg_type)       (((msg_type) & 0x0110) == 0x0000)\n#define IS_INDICATION(msg_type)    (((msg_type) & 0x0110) == 0x0010)\n#define IS_SUCCESS_RESP(msg_type)  (((msg_type) & 0x0110) == 0x0100)\n#define IS_ERR_RESP(msg_type)      (((msg_type) & 0x0110) == 0x0110)\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A function to convert method and class into a message type:",
      "ja": "メソッドとクラスをメッセージタイプに変換する関数："
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nint type(int method, int cls) {\n  return (method & 0x1F80) << 2 | (method & 0x0070) << 1\n    | (method & 0x000F) | (cls & 0x0002) << 7\n    | (cls & 0x0001) << 4;\n  }\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A function to extract the method from the message type:",
      "ja": "メッセージタイプからメソッドを抽出する関数："
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nint method(int type) {\n  return (type & 0x3E00) >> 2 | (type & 0x00E0) >> 1\n    | (type & 0x000F);\n  }\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A function to extract the class from the message type:",
      "ja": "メッセージタイプからクラスを抽出する関数："
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nint cls(int type) {\n  return (type & 0x0100) >> 7 | (type & 0x0010) >> 4;\n  }\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Test Vectors",
      "section_title": true,
      "ja": "付録B.テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section augments the list of test vectors defined in [RFC5769] with MESSAGE-INTEGRITY-SHA256. All the formats and definitions listed in Section 2 of [RFC5769] apply here.",
      "ja": "このセクションでは、[RFC5769]で定義されているテストベクトルのリストをMESSAGE-INTEGRITY-SHA256で補強します。[RFC5769]のセクション2に記載されているすべての形式と定義がここに適用されます。"
    },
    {
      "indent": 0,
      "text": "B.1. Sample Request with Long-Term Authentication with MESSAGE-INTEGRITY-SHA256 and USERHASH",
      "ja": "B.1. MESSAGE-INTEGRITY-SHA256とUSERHASHを使用した長期認証を使用したサンプルリクエスト"
    },
    {
      "indent": 3,
      "text": "This request uses the following parameters:",
      "ja": "このリクエストは次のパラメータを使用します。"
    },
    {
      "indent": 3,
      "text": "Username: \"<U+30DE><U+30C8><U+30EA><U+30C3><U+30AF><U+30B9>\" (without\nquotes) unaffected by OpaqueString [RFC8265] processing",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Password: \"The<U+00AD>M<U+00AA>tr<U+2168>\" and \"TheMatrIX\" (without\nquotes) respectively before and after OpaqueString [RFC8265]\nprocessing",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nonce: \"obMatJos2AAACf//499k954d6OL34oL9FSTvy64sA\" (without quotes)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Realm: \"example.org\" (without quotes)",
      "ja": "レルム： \"example.org\"（引用符なし）"
    },
    {
      "indent": 0,
      "text": "        00 01 00 9c      Request type and message length\n        21 12 a4 42      Magic cookie\n        78 ad 34 33   }\n        c6 ad 72 c0   }  Transaction ID\n        29 da 41 2e   }\n        00 1e 00 20      USERHASH attribute header\n        4a 3c f3 8f   }\n        ef 69 92 bd   }\n        a9 52 c6 78   }\n        04 17 da 0f   }  Userhash value (32 bytes)\n        24 81 94 15   }\n        56 9e 60 b2   }\n        05 c4 6e 41   }\n        40 7f 17 04   }\n        00 15 00 29      NONCE attribute header\n        6f 62 4d 61   }\n        74 4a 6f 73   }\n        32 41 41 41   }\n        43 66 2f 2f   }\n        34 39 39 6b   }  Nonce value and padding (3 bytes)\n        39 35 34 64   }\n        36 4f 4c 33   }\n        34 6f 4c 39   }\n        46 53 54 76   }\n        79 36 34 73   }\n        41 00 00 00   }\n        00 14 00 0b      REALM attribute header\n        65 78 61 6d   }\n        70 6c 65 2e   }  Realm value (11 bytes) and padding (1 byte)\n        6f 72 67 00   }\n        00 1c 00 20      MESSAGE-INTEGRITY-SHA256 attribute header\n        e4 68 6c 8f   }\n        0e de b5 90   }\n        13 e0 70 90   }\n        01 0a 93 ef   }  HMAC-SHA256 value\n        cc bc cc 54   }\n        4c 0a 45 d9   }\n        f8 30 aa 6d   }\n        6f 73 5a 01   }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Michael Tuexen, Tirumaleswar Reddy, Oleg Moskalenko, Simon Perreault, Benjamin Schwartz, Rifaat Shekh-Yusef, Alan Johnston, Jonathan Lennox, Brandon Williams, Olle Johansson, Martin Thomson, Mihaly Meszaros, Tolga Asveren, Noriyuki Torii, Spencer Dawkins, Dale Worley, Matthew Miller, Peter Saint-Andre, Julien Elie, Mirja Kuehlewind, Eric Rescorla, Ben Campbell, Adam Roach, Alexey Melnikov, and Benjamin Kaduk for the comments, suggestions, and questions that helped improve this document.",
      "ja": "Michael Tuexen、Tirumaleswar Reddy、Oleg Moskalenko、Simon Perreault、Benjamin Schwartz、Rifaat Shekh-Yusef、Alan Johnston、Jonathan Lennox、Brandon Williams、Olle Johansson、Martin Thomson、Mihaly Meszaros、Tolga Asveren、Noriyuki Torii、Spencer Dawkins、Dale Worley、Matthew Miller、Peter Saint-Andre、Julien Elie、Mirja Kuehlewind、Eric Rescorla、Ben Campbell、Adam Roach、Alexey Melnikov、Benjamin Kadukが、このドキュメントの改善に役立ったコメント、提案、質問を寄せてくれました。"
    },
    {
      "indent": 3,
      "text": "The Acknowledgements section of RFC 5389 appeared as follows:",
      "ja": "RFC5389の謝辞セクションは次のように表示されました。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Cedric Aoun, Pete Cordell, Cullen Jennings, Bob Penfield, Xavier Marjou, Magnus Westerlund, Miguel Garcia, Bruce Lowekamp, and Chris Sullivan for their comments, and Baruch Sterman and Alan Hawrylyshen for initial implementations. Thanks for Leslie Daigle, Allison Mankin, Eric Rescorla, and Henning Schulzrinne for IESG and IAB input on this work.",
      "ja": "著者は、Cedric Aoun、Pete Cordell、Cullen Jennings、Bob Penfield、Xavier Marjou、Magnus Westerlund、Miguel Garcia、Bruce Lowekamp、Chris Sullivanのコメントに感謝し、BaruchStermanとAlanHawrylyshenの初期実装に感謝します。この作業に関するIESGおよびIABの入力について、Leslie Daigle、Allison Mankin、Eric Rescorla、およびHenningSchulzrinneに感謝します。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "Christian Huitema and Joel Weinberger were original coauthors of RFC 3489.",
      "ja": "ChristianHuitemaとJoelWeinbergerは、RFC3489の最初の共著者でした。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Marc Petit-Huguenin Impedance Mismatch",
      "ja": "マークプチ-フゲニンインピーダンスミスマッチ"
    },
    {
      "indent": 3,
      "text": "Email: marc@petit-huguenin.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Gonzalo Salgueiro Cisco 7200-12 Kit Creek Road Research Triangle Park, NC 27709 United States of America",
      "ja": "Gonzalo Salgueiro Cisco 7200-12 Kit Creek Road Research Triangle Park、NC27709アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: gsalguei@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg Five9 Edison, NJ United States of America",
      "ja": "ジョナサンローゼンバーグファイブ9エジソン、ニュージャージー州アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: jdrosen@jdrosen.net\nURI:   http://www.jdrosen.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dan Wing Citrix Systems, Inc. United States of America",
      "ja": "Dan Wing Citrix Systems、Inc。アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: dwing-ietf@fuggles.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Rohan Mahy Unaffiliated",
      "ja": "RohanMahy非提携"
    },
    {
      "indent": 3,
      "text": "Email: rohan.ietf@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Philip Matthews Nokia 600 March Road Ottawa, Ontario K2K 2T6 Canada",
      "ja": "フィリップマシューズノキア600マーチロードオンタリオ州オタワK2K2T6カナダ"
    },
    {
      "indent": 3,
      "text": "Phone: 613-784-3139 Email: philip_matthews@magma.ca",
      "ja": "電話：613-784-3139電子メール：philip_matthews@magma.ca"
    }
  ]
}