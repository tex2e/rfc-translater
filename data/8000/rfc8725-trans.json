{
  "title": {
    "text": "RFC 8725 - JSON Web Token Best Current Practices",
    "ja": "RFC 8725 - JSON Web Tokenの現在のベストプラクティス"
  },
  "number": 8725,
  "created_at": "2020-08-15 21:26:47.322075+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        Y. Sheffer\nRequest for Comments: 8725                                        Intuit\nBCP: 225                                                        D. Hardt\nUpdates: 7519\nCategory: Best Current Practice                                 M. Jones\nISSN: 2070-1721                                                Microsoft\n                                                           February 2020",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "JSON Web Token Best Current Practices",
      "ja": "JSON Web Tokenの現在のベストプラクティス"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "JSON Web Tokens, also known as JWTs, are URL-safe JSON-based security tokens that contain a set of claims that can be signed and/or encrypted. JWTs are being widely used and deployed as a simple security token format in numerous protocols and applications, both in the area of digital identity and in other application areas. This Best Current Practices document updates RFC 7519 to provide actionable guidance leading to secure implementation and deployment of JWTs.",
      "ja": "JSON Webトークンは、JWTとも呼ばれ、署名や暗号化が可能な一連のクレームを含むURLセーフのJSONベースのセキュリティトークンです。 JWTは、デジタルIDの領域と他のアプリケーション領域の両方で、多数のプロトコルとアプリケーションで単純なセキュリティトークン形式として広く使用および展開されています。このBest Current Practicesドキュメントは、RFC 7519を更新して、JWTの安全な実装とデプロイメントにつながる実用的なガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This memo documents an Internet Best Current Practice.",
      "ja": "このメモは、インターネットの現在のベストプラクティスを文書化したものです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on BCPs is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 BCPの詳細については、RFC 7841のセクション2をご覧ください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8725.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8725で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2020 IETFトラストおよびドキュメントの作成者として識別された人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Target Audience\n  1.2.  Conventions Used in this Document\n2.  Threats and Vulnerabilities\n  2.1.  Weak Signatures and Insufficient Signature Validation\n  2.2.  Weak Symmetric Keys\n  2.3.  Incorrect Composition of Encryption and Signature\n  2.4.  Plaintext Leakage through Analysis of Ciphertext Length\n  2.5.  Insecure Use of Elliptic Curve Encryption\n  2.6.  Multiplicity of JSON Encodings\n  2.7.  Substitution Attacks\n  2.8.  Cross-JWT Confusion\n  2.9.  Indirect Attacks on the Server\n3.  Best Practices\n  3.1.  Perform Algorithm Verification\n  3.2.  Use Appropriate Algorithms\n  3.3.  Validate All Cryptographic Operations\n  3.4.  Validate Cryptographic Inputs\n  3.5.  Ensure Cryptographic Keys Have Sufficient Entropy\n  3.6.  Avoid Compression of Encryption Inputs\n  3.7.  Use UTF-8\n  3.8.  Validate Issuer and Subject\n  3.9.  Use and Validate Audience\n  3.10. Do Not Trust Received Claims\n  3.11. Use Explicit Typing\n  3.12. Use Mutually Exclusive Validation Rules for Different Kinds\n         of JWTs\n4.  Security Considerations\n5.  IANA Considerations\n6.  References\n  6.1.  Normative References\n  6.2.  Informative References\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "JSON Web Tokens, also known as JWTs [RFC7519], are URL-safe JSON-based security tokens that contain a set of claims that can be signed and/or encrypted. The JWT specification has seen rapid adoption because it encapsulates security-relevant information in one easy-to-protect location, and because it is easy to implement using widely available tools. One application area in which JWTs are commonly used is representing digital identity information, such as OpenID Connect ID Tokens [OpenID.Core] and OAuth 2.0 [RFC6749] access tokens and refresh tokens, the details of which are deployment-specific.",
      "ja": "JSON Webトークンは、JWT [RFC7519]とも呼ばれ、署名や暗号化が可能な一連のクレームを含むURLセーフのJSONベースのセキュリティトークンです。 JWT仕様は、セキュリティ関連の情報を1つの保護しやすい場所にカプセル化し、広く利用可能なツールを使用して簡単に実装できるため、急速に採用されています。 JWTが一般的に使用される1つのアプリケーション領域は、OpenID Connect IDトークン[OpenID.Core]やOAuth 2.0 [RFC6749]アクセストークンや更新トークンなどのデジタルID情報を表すことです。これらの詳細はデプロイメント固有です。"
    },
    {
      "indent": 3,
      "text": "Since the JWT specification was published, there have been several widely published attacks on implementations and deployments. Such attacks are the result of under-specified security mechanisms, as well as incomplete implementations and incorrect usage by applications.",
      "ja": "JWT仕様が公開されてから、実装とデプロイメントに対するいくつかの広く公開された攻撃がありました。このような攻撃は、指定が不十分なセキュリティメカニズム、不完全な実装、およびアプリケーションによる不正な使用の結果です。"
    },
    {
      "indent": 3,
      "text": "The goal of this document is to facilitate secure implementation and deployment of JWTs. Many of the recommendations in this document are about implementation and use of the cryptographic mechanisms underlying JWTs that are defined by JSON Web Signature (JWS) [RFC7515], JSON Web Encryption (JWE) [RFC7516], and JSON Web Algorithms (JWA) [RFC7518]. Others are about use of the JWT claims themselves.",
      "ja": "このドキュメントの目的は、JWTの安全な実装と配備を容易にすることです。このドキュメントの推奨事項の多くは、JSON Web Signature（JWS）[RFC7515]、JSON Web Encryption（JWE）[RFC7516]、およびJSON Web Algorithms（JWA）で定義されているJWTの基礎となる暗号化メカニズムの実装と使用に関するものです。 RFC7518]。その他は、JWTクレーム自体の使用に関するものです。"
    },
    {
      "indent": 3,
      "text": "These are intended to be minimum recommendations for the use of JWTs in the vast majority of implementation and deployment scenarios. Other specifications that reference this document can have stricter requirements related to one or more aspects of the format, based on their particular circumstances; when that is the case, implementers are advised to adhere to those stricter requirements. Furthermore, this document provides a floor, not a ceiling, so stronger options are always allowed (e.g., depending on differing evaluations of the importance of cryptographic strength vs. computational load).",
      "ja": "これらは、実装および展開シナリオの大部分でJWTを使用するための最小限の推奨事項となることを目的としています。このドキュメントを参照する他の仕様には、特定の状況に基づいて、フォーマットの1つ以上の側面に関連するより厳しい要件がある場合があります。その場合、実装者はこれらのより厳しい要件に準拠することをお勧めします。さらに、このドキュメントは上限ではなく下限を提供するため、より強力なオプションが常に許可されます（たとえば、暗号強度と計算負荷の重要性の異なる評価に応じて）。"
    },
    {
      "indent": 3,
      "text": "Community knowledge about the strength of various algorithms and feasible attacks can change quickly, and experience shows that a Best Current Practice (BCP) document about security is a point-in-time statement. Readers are advised to seek out any errata or updates that apply to this document.",
      "ja": "さまざまなアルゴリズムと実行可能な攻撃の強さに関するコミュニティの知識は急速に変化する可能性があり、経験から、セキュリティに関するベストカレントプラクティス（BCP）ドキュメントは特定時点のステートメントであることがわかっています。読者は、このドキュメントに適用される正誤表または更新を探すことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "1.1. Target Audience",
      "section_title": true,
      "ja": "1.1. 対象読者"
    },
    {
      "indent": 3,
      "text": "The intended audiences of this document are:",
      "ja": "このドキュメントの対象読者は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Implementers of JWT libraries (and the JWS and JWE libraries used by those libraries),",
      "ja": "* JWTライブラリ（およびこれらのライブラリで使用されるJWSおよびJWEライブラリ）の実装者"
    },
    {
      "indent": 3,
      "text": "* Implementers of code that uses such libraries (to the extent that some mechanisms may not be provided by libraries, or until they are), and",
      "ja": "* そのようなライブラリを使用するコードの実装者（一部のメカニズムがライブラリによって提供されない可能性がある範囲まで、または提供されるまで）、および"
    },
    {
      "indent": 3,
      "text": "* Developers of specifications that rely on JWTs, both inside and outside the IETF.",
      "ja": "* IETFの内部と外部の両方でJWTに依存する仕様の開発者。"
    },
    {
      "indent": 0,
      "text": "1.2. Conventions Used in this Document",
      "section_title": true,
      "ja": "1.2. このドキュメントで使用される規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Threats and Vulnerabilities",
      "section_title": true,
      "ja": "2. 脅威と脆弱性"
    },
    {
      "indent": 3,
      "text": "This section lists some known and possible problems with JWT implementations and deployments. Each problem description is followed by references to one or more mitigations to those problems.",
      "ja": "このセクションでは、JWTの実装とデプロイメントに関するいくつかの既知の問題と考えられる問題をリストします。各問題の説明の後に、それらの問題に対する1つ以上の軽減策への参照が続きます。"
    },
    {
      "indent": 0,
      "text": "2.1. Weak Signatures and Insufficient Signature Validation",
      "section_title": true,
      "ja": "2.1. 弱い署名と不十分な署名検証"
    },
    {
      "indent": 3,
      "text": "Signed JSON Web Tokens carry an explicit indication of the signing algorithm, in the form of the \"alg\" Header Parameter, to facilitate cryptographic agility. This, in conjunction with design flaws in some libraries and applications, has led to several attacks:",
      "ja": "署名済みのJSON Web Tokenは、「alg」ヘッダーパラメータの形式で、署名アルゴリズムの明示を示し、暗号化の俊敏性を促進します。これは、一部のライブラリおよびアプリケーションの設計上の欠陥と相まって、いくつかの攻撃につながりました。"
    },
    {
      "indent": 3,
      "text": "* The algorithm can be changed to \"none\" by an attacker, and some libraries would trust this value and \"validate\" the JWT without checking any signature.",
      "ja": "* アルゴリズムは攻撃者によって「なし」に変更される可能性があり、一部のライブラリはこの値を信頼し、署名をチェックせずにJWTを「検証」します。"
    },
    {
      "indent": 3,
      "text": "* An \"RS256\" (RSA, 2048 bit) parameter value can be changed into \"HS256\" (HMAC, SHA-256), and some libraries would try to validate the signature using HMAC-SHA256 and using the RSA public key as the HMAC shared secret (see [McLean] and [CVE-2015-9235]).",
      "ja": "* 「RS256」（RSA、2048ビット）パラメータ値は「HS256」（HMAC、SHA-256）に変更でき、一部のライブラリはHMAC-SHA256を使用し、RSA公開鍵をHMAC共有として使用して署名を検証しようとしますシークレット（[McLean]および[CVE-2015-9235]を参照）。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Sections 3.1 and 3.2.",
      "ja": "緩和策については、セクション3.1および3.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.2. Weak Symmetric Keys",
      "section_title": true,
      "ja": "2.2. 弱い対称鍵"
    },
    {
      "indent": 3,
      "text": "In addition, some applications use a keyed Message Authentication Code (MAC) algorithm, such as \"HS256\", to sign tokens but supply a weak symmetric key with insufficient entropy (such as a human-memorable password). Such keys are vulnerable to offline brute-force or dictionary attacks once an attacker gets hold of such a token [Langkemper].",
      "ja": "さらに、一部のアプリケーションは、「HS256」などのキー付きメッセージ認証コード（MAC）アルゴリズムを使用してトークンに署名しますが、エントロピーが不十分な弱い対称キー（人間が記憶できるパスワードなど）を提供します。このようなキーは、攻撃者がそのようなトークンを手に入れたら、オフラインのブルートフォース攻撃や辞書攻撃に対して脆弱です[Langkemper]。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Section 3.5.",
      "ja": "緩和策については、セクション3.5を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.3. Incorrect Composition of Encryption and Signature",
      "section_title": true,
      "ja": "2.3. 暗号化と署名の誤った構成"
    },
    {
      "indent": 3,
      "text": "Some libraries that decrypt a JWE-encrypted JWT to obtain a JWS-signed object do not always validate the internal signature.",
      "ja": "JWEで暗号化されたJWTを復号化してJWS署名付きオブジェクトを取得する一部のライブラリは、内部署名を常に検証するとは限りません。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Section 3.3.",
      "ja": "緩和策については、セクション3.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4. Plaintext Leakage through Analysis of Ciphertext Length",
      "section_title": true,
      "ja": "2.4. 暗号文の長さの分析による平文漏洩"
    },
    {
      "indent": 3,
      "text": "Many encryption algorithms leak information about the length of the plaintext, with a varying amount of leakage depending on the algorithm and mode of operation. This problem is exacerbated when the plaintext is initially compressed, because the length of the compressed plaintext and, thus, the ciphertext depends not only on the length of the original plaintext but also on its content. Compression attacks are particularly powerful when there is attacker-controlled data in the same compression space as secret data, which is the case for some attacks on HTTPS.",
      "ja": "多くの暗号化アルゴリズムは、平文の長さに関する情報をリークしますが、アルゴリズムと操作モードによってリーク量は異なります。この問題は、平文が最初に圧縮されるときに悪化します。圧縮された平文の長さ、したがって暗号文は、元の平文の長さだけでなく、その内容にも依存するためです。圧縮攻撃は、秘密データと同じ圧縮スペースに攻撃者が制御するデータがある場合に特に強力です。これは、HTTPSに対する一部の攻撃の場合です。"
    },
    {
      "indent": 3,
      "text": "See [Kelsey] for general background on compression and encryption and [Alawatugoda] for a specific example of attacks on HTTP cookies.",
      "ja": "圧縮と暗号化の一般的な背景については[Kelsey]を、HTTP Cookieに対する攻撃の具体例については[Alawatugoda]を参照してください。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Section 3.6.",
      "ja": "緩和策については、セクション3.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.5. Insecure Use of Elliptic Curve Encryption",
      "section_title": true,
      "ja": "2.5. 楕円曲線暗号化の安全でない使用"
    },
    {
      "indent": 3,
      "text": "Per [Sanso], several Javascript Object Signing and Encryption (JOSE) libraries fail to validate their inputs correctly when performing elliptic curve key agreement (the \"ECDH-ES\" algorithm). An attacker that is able to send JWEs of its choosing that use invalid curve points and observe the cleartext outputs resulting from decryption with the invalid curve points can use this vulnerability to recover the recipient's private key.",
      "ja": "[Sanso]によると、いくつかのJavaScript Object Signing and Encryption（JOSE）ライブラリは、楕円曲線鍵合意（「ECDH-ES」アルゴリズム）を実行するときに、入力を正しく検証できません。無効な曲線ポイントを使用する選択したJWEを送信し、無効な曲線ポイントを使用した復号化からのクリアテキスト出力を観察できる攻撃者は、この脆弱点を使用して受信者の秘密鍵を回復できます。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Section 3.4.",
      "ja": "緩和策については、セクション3.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.6. Multiplicity of JSON Encodings",
      "section_title": true,
      "ja": "2.6. JSONエンコーディングの多様性"
    },
    {
      "indent": 3,
      "text": "Previous versions of the JSON format, such as the obsoleted [RFC7159], allowed several different character encodings: UTF-8, UTF-16, and UTF-32. This is not the case anymore, with the latest standard [RFC8259] only allowing UTF-8 except for internal use within a \"closed ecosystem\". This ambiguity, where older implementations and those used within closed environments may generate non-standard encodings, may result in the JWT being misinterpreted by its recipient. This, in turn, could be used by a malicious sender to bypass the recipient's validation checks.",
      "ja": "廃止された[RFC7159]など、JSON形式の以前のバージョンでは、UTF-8、UTF-16、UTF-32など、いくつかの異なる文字エンコーディングが許可されていました。これはもう当てはまりません。最新の標準[RFC8259]では、「クローズドエコシステム」内での内部使用を除いて、UTF-8のみが許可されています。このあいまいさにより、古い実装やクローズド環境で使用される実装が非標準のエンコーディングを生成する可能性があるため、JWTが受信者によって誤って解釈される可能性があります。悪意のある送信者がこれを使用して、受信者の検証チェックをバイパスする可能性があります。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Section 3.7.",
      "ja": "緩和策については、3.7項を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.7. Substitution Attacks",
      "section_title": true,
      "ja": "2.7. 代替攻撃"
    },
    {
      "indent": 3,
      "text": "There are attacks in which one recipient will be given a JWT that was intended for it and will attempt to use it at a different recipient for which that JWT was not intended. For instance, if an OAuth 2.0 [RFC6749] access token is legitimately presented to an OAuth 2.0 protected resource for which it is intended, that protected resource might then present that same access token to a different protected resource for which the access token is not intended, in an attempt to gain access. If such situations are not caught, this can result in the attacker gaining access to resources that it is not entitled to access.",
      "ja": "ある受信者に、それを意図したJWTが与えられ、そのJWTが意図していない別の受信者でそれを使用しようとする攻撃があります。たとえば、OAuth 2.0 [RFC6749]アクセストークンが意図されているOAuth 2.0保護リソースに正当に提示された場合、その保護リソースは、同じアクセストークンを、アクセストークンが意図されていない別の保護リソースに提示する可能性があります。 、アクセスを得ようとして。このような状況が検出されない場合、攻撃者がアクセスする資格のないリソースにアクセスできる可能性があります。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Sections 3.8 and 3.9.",
      "ja": "緩和策については、セクション3.8および3.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.8. Cross-JWT Confusion",
      "section_title": true,
      "ja": "2.8. JWT間の混乱"
    },
    {
      "indent": 3,
      "text": "As JWTs are being used by more different protocols in diverse application areas, it becomes increasingly important to prevent cases of JWT tokens that have been issued for one purpose being subverted and used for another. Note that this is a specific type of substitution attack. If the JWT could be used in an application context in which it could be confused with other kinds of JWTs, then mitigations MUST be employed to prevent these substitution attacks.",
      "ja": "JWTはさまざまなアプリケーション領域でより多くの異なるプロトコルによって使用されているため、ある目的で発行されたJWTトークンが破壊されて別の目的で使用されるのを防ぐことがますます重要になります。これは特定のタイプの代替攻撃であることに注意してください。他の種類のJWTと混同される可能性があるアプリケーションコンテキストでJWTを使用できる場合は、これらの置換攻撃を防ぐために緩和策を採用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Sections 3.8, 3.9, 3.11, and 3.12.",
      "ja": "緩和策については、セクション3.8、3.9、3.11、および3.12を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.9. Indirect Attacks on the Server",
      "section_title": true,
      "ja": "2.9. サーバーへの間接攻撃"
    },
    {
      "indent": 3,
      "text": "Various JWT claims are used by the recipient to perform lookup operations, such as database and Lightweight Directory Access Protocol (LDAP) searches. Others include URLs that are similarly looked up by the server. Any of these claims can be used by an attacker as vectors for injection attacks or server-side request forgery (SSRF) attacks.",
      "ja": "受信者はさまざまなJWTクレームを使用して、データベースやLDAP（Lightweight Directory Access Protocol）検索などのルックアップ操作を実行します。その他には、サーバーによって同様に検索されるURLが含まれます。攻撃者はこれらのクレームをインジェクション攻撃またはサーバー側リクエストフォージェリ（SSRF）攻撃のベクターとして使用できます。"
    },
    {
      "indent": 3,
      "text": "For mitigations, see Section 3.10.",
      "ja": "緩和策については、セクション3.10を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Best Practices",
      "section_title": true,
      "ja": "3. ベストプラクティス"
    },
    {
      "indent": 3,
      "text": "The best practices listed below should be applied by practitioners to mitigate the threats listed in the preceding section.",
      "ja": "下記のベストプラクティスを実践者が適用して、前のセクションに記載された脅威を軽減する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Perform Algorithm Verification",
      "section_title": true,
      "ja": "3.1. アルゴリズム検証を実行する"
    },
    {
      "indent": 3,
      "text": "Libraries MUST enable the caller to specify a supported set of algorithms and MUST NOT use any other algorithms when performing cryptographic operations. The library MUST ensure that the \"alg\" or \"enc\" header specifies the same algorithm that is used for the cryptographic operation. Moreover, each key MUST be used with exactly one algorithm, and this MUST be checked when the cryptographic operation is performed.",
      "ja": "ライブラリは、呼び出し元がサポートされているアルゴリズムのセットを指定できるようにする必要があり、暗号化操作を実行するときに他のアルゴリズムを使用してはなりません（MUST NOT）。ライブラリは、「alg」または「enc」ヘッダーが暗号化操作に使用されるのと同じアルゴリズムを指定していることを確認する必要があります。さらに、各キーは1つのアルゴリズムでのみ使用する必要があり、暗号化操作を実行するときにこれを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Use Appropriate Algorithms",
      "section_title": true,
      "ja": "3.2. 適切なアルゴリズムを使用する"
    },
    {
      "indent": 3,
      "text": "As Section 5.2 of [RFC7515] says, \"it is an application decision which algorithms may be used in a given context. Even if a JWS can be successfully validated, unless the algorithm(s) used in the JWS are acceptable to the application, it SHOULD consider the JWS to be invalid.\"",
      "ja": "[RFC7515]のセクション5.2にあるように、「特定のコンテキストで使用できるアルゴリズムはアプリケーションの決定です。JWSを正常に検証できたとしても、JWSで使用されているアルゴリズムがアプリケーションに受け入れられない限り、 JWSは無効であると考える必要があります。」"
    },
    {
      "indent": 3,
      "text": "Therefore, applications MUST only allow the use of cryptographically current algorithms that meet the security requirements of the application. This set will vary over time as new algorithms are introduced and existing algorithms are deprecated due to discovered cryptographic weaknesses. Applications MUST therefore be designed to enable cryptographic agility.",
      "ja": "したがって、アプリケーションは、アプリケーションのセキュリティ要件を満たす暗号的に最新のアルゴリズムの使用のみを許可する必要があります。新しいアルゴリズムが導入され、既存のアルゴリズムは暗号の弱点が発見されたため廃止されたため、このセットは時間とともに変化します。したがって、アプリケーションは暗号化の俊敏性を実現するように設計する必要があります。"
    },
    {
      "indent": 3,
      "text": "That said, if a JWT is cryptographically protected end-to-end by a transport layer, such as TLS using cryptographically current algorithms, there may be no need to apply another layer of cryptographic protections to the JWT. In such cases, the use of the \"none\" algorithm can be perfectly acceptable. The \"none\" algorithm should only be used when the JWT is cryptographically protected by other means. JWTs using \"none\" are often used in application contexts in which the content is optionally signed; then, the URL-safe claims representation and processing can be the same in both the signed and unsigned cases. JWT libraries SHOULD NOT generate JWTs using \"none\" unless explicitly requested to do so by the caller. Similarly, JWT libraries SHOULD NOT consume JWTs using \"none\" unless explicitly requested by the caller.",
      "ja": "とはいえ、JWTがトランスポート層によってエンドツーエンドで暗号的に保護されている場合（TLSのように暗号的に最新のアルゴリズムを使用）、暗号保護の別の層をJWTに適用する必要がない場合があります。そのような場合、「なし」アルゴリズムの使用は完全に許容できます。 「none」アルゴリズムは、JWTが他の方法で暗号的に保護されている場合にのみ使用してください。 「none」を使用するJWTは、コンテンツがオプションで署名されているアプリケーションコンテキストでよく使用されます。次に、URLセーフなクレームの表現と処理は、署名された場合と署名されていない場合の両方で同じにすることができます。 JWTライブラリは、呼び出し元から明示的に要求されない限り、「none」を使用してJWTを生成するべきではありません（SHOULD NOT）。同様に、JWTライブラリは、呼び出し元から明示的に要求されない限り、「none」を使用してJWTを消費してはなりません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "Applications SHOULD follow these algorithm-specific recommendations:",
      "ja": "アプリケーションは、次のアルゴリズム固有の推奨事項に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "* Avoid all RSA-PKCS1 v1.5 encryption algorithms ([RFC8017], Section 7.2), preferring RSAES-OAEP ([RFC8017], Section 7.1).",
      "ja": "* すべてのRSA-PKCS1 v1.5暗号化アルゴリズム（[RFC8017]、セクション7.2）を避け、RSAES-OAEP（[RFC8017]、セクション7.1）を優先します。"
    },
    {
      "indent": 3,
      "text": "* Elliptic Curve Digital Signature Algorithm (ECDSA) signatures [ANSI-X962-2005] require a unique random value for every message that is signed. If even just a few bits of the random value are predictable across multiple messages, then the security of the signature scheme may be compromised. In the worst case, the private key may be recoverable by an attacker. To counter these attacks, JWT libraries SHOULD implement ECDSA using the deterministic approach defined in [RFC6979]. This approach is completely compatible with existing ECDSA verifiers and so can be implemented without new algorithm identifiers being required.",
      "ja": "* 楕円曲線デジタル署名アルゴリズム（ECDSA）署名[ANSI-X962-2005]では、署名されるすべてのメッセージに一意のランダム値が必要です。ランダム値のほんの数ビットでさえ、複数のメッセージにわたって予測可能である場合、署名スキームのセキュリティが危険にさらされる可能性があります。最悪の場合、秘密キーは攻撃者によって復元される可能性があります。これらの攻撃に対抗するために、JWTライブラリは[RFC6979]で定義された決定論的アプローチを使用してECDSAを実装する必要があります（SHOULD）。このアプローチは既存のECDSAベリファイアと完全に互換性があるため、新しいアルゴリズム識別子を必要とせずに実装できます。"
    },
    {
      "indent": 0,
      "text": "3.3. Validate All Cryptographic Operations",
      "section_title": true,
      "ja": "3.3. すべての暗号化操作を検証する"
    },
    {
      "indent": 3,
      "text": "All cryptographic operations used in the JWT MUST be validated and the entire JWT MUST be rejected if any of them fail to validate. This is true not only of JWTs with a single set of Header Parameters but also for Nested JWTs in which both outer and inner operations MUST be validated using the keys and algorithms supplied by the application.",
      "ja": "JWTで使用されるすべての暗号化操作を検証する必要があり、JWTのいずれかが検証に失敗した場合、JWT全体を拒否する必要があります。これは、単一のヘッダーパラメータセットを持つJWTだけでなく、アプリケーションによって提供されるキーとアルゴリズムを使用して外部と内部の両方の操作を検証する必要があるネストされたJWTにも当てはまります。"
    },
    {
      "indent": 0,
      "text": "3.4. Validate Cryptographic Inputs",
      "section_title": true,
      "ja": "3.4. 暗号入力の検証"
    },
    {
      "indent": 3,
      "text": "Some cryptographic operations, such as Elliptic Curve Diffie-Hellman key agreement (\"ECDH-ES\"), take inputs that may contain invalid values. This includes points not on the specified elliptic curve or other invalid points (e.g., [Valenta], Section 7.1). The JWS/JWE library itself must validate these inputs before using them, or it must use underlying cryptographic libraries that do so (or both!).",
      "ja": "Elliptic Curve Diffie-Hellman鍵合意（「ECDH-ES」）などの一部の暗号化操作は、無効な値を含む可能性のある入力を受け取ります。これには、指定された楕円曲線上にないポイントやその他の無効なポイントが含まれます（[Valenta]、セクション7.1など）。 JWS / JWEライブラリ自体は、これらの入力を使用する前に検証する必要があります。または、検証を行う基盤となる暗号ライブラリ（またはその両方）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Elliptic Curve Diffie-Hellman Ephemeral Static (ECDH-ES) ephemeral public key (epk) inputs should be validated according to the recipient's chosen elliptic curve. For the NIST prime-order curves P-256, P-384, and P-521, validation MUST be performed according to Section 5.6.2.3.4 (ECC Partial Public-Key Validation Routine) of \"Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography\" [nist-sp-800-56a-r3]. If the \"X25519\" or \"X448\" [RFC8037] algorithms are used, then the security considerations in [RFC8037] apply.",
      "ja": "楕円曲線Diffie-Hellman Ephemeral Static（ECDH-ES）短命公開鍵（epk）入力は、受信者が選択した楕円曲線に従って検証する必要があります。 NISTプライムオーダーカーブP-256、P-384、およびP-521の場合、「ペアワイズキーの推奨事項」のセクション5.6.2.3.4（ECC部分公開キー検証ルーチン）に従って検証を実行する必要があります。離散対数暗号を使用した確立スキーム」[nist-sp-800-56a-r3]。 「X25519」または「X448」[RFC8037]アルゴリズムが使用される場合、[RFC8037]のセキュリティに関する考慮事項が適用されます。"
    },
    {
      "indent": 0,
      "text": "3.5. Ensure Cryptographic Keys Have Sufficient Entropy",
      "section_title": true,
      "ja": "3.5. 暗号化キーに十分なエントロピーがあることを確認する"
    },
    {
      "indent": 3,
      "text": "The Key Entropy and Random Values advice in Section 10.1 of [RFC7515] and the Password Considerations in Section 8.8 of [RFC7518] MUST be followed. In particular, human-memorizable passwords MUST NOT be directly used as the key to a keyed-MAC algorithm such as \"HS256\". Moreover, passwords should only be used to perform key encryption, rather than content encryption, as described in Section 4.8 of [RFC7518]. Note that even when used for key encryption, password-based encryption is still subject to brute-force attacks.",
      "ja": "[RFC7515]のセクション10.1のキーエントロピーとランダム値のアドバイス、および[RFC7518]のセクション8.8のパスワードに関する考慮事項に従う必要があります。特に、人間が記憶できるパスワードは、「HS256」などのキー付きMACアルゴリズムのキーとして直接使用してはなりません（MUST NOT）。さらに、パスワードは、[RFC7518]のセクション4.8で説明されているように、コンテンツの暗号化ではなく、キーの暗号化の実行にのみ使用する必要があります。鍵の暗号化に使用した場合でも、パスワードベースの暗号化は依然としてブルートフォース攻撃の影響を受けることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.6. Avoid Compression of Encryption Inputs",
      "section_title": true,
      "ja": "3.6. 暗号化入力の圧縮を回避する"
    },
    {
      "indent": 3,
      "text": "Compression of data SHOULD NOT be done before encryption, because such compressed data often reveals information about the plaintext.",
      "ja": "データの圧縮は暗号化の前に行うべきではありません。そのような圧縮されたデータはしばしば平文に関する情報を明らかにするからです。"
    },
    {
      "indent": 0,
      "text": "3.7. Use UTF-8",
      "section_title": true,
      "ja": "3.7. UTF-8を使用"
    },
    {
      "indent": 3,
      "text": "[RFC7515], [RFC7516], and [RFC7519] all specify that UTF-8 be used for encoding and decoding JSON used in Header Parameters and JWT Claims Sets. This is also in line with the latest JSON specification [RFC8259]. Implementations and applications MUST do this and not use or admit the use of other Unicode encodings for these purposes.",
      "ja": "[RFC7515]、[RFC7516]、および[RFC7519]はすべて、ヘッダーパラメータとJWTクレームセットで使用されるJSONのエンコードとデコードにUTF-8を使用することを指定しています。これは、最新のJSON仕様[RFC8259]にも準拠しています。実装とアプリケーションはこれを行わなければならず、これらの目的で他のUnicodeエンコーディングを使用または許可してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.8. Validate Issuer and Subject",
      "section_title": true,
      "ja": "3.8. 発行者と件名の検証"
    },
    {
      "indent": 3,
      "text": "When a JWT contains an \"iss\" (issuer) claim, the application MUST validate that the cryptographic keys used for the cryptographic operations in the JWT belong to the issuer. If they do not, the application MUST reject the JWT.",
      "ja": "JWTに「iss」（発行者）クレームが含まれている場合、アプリケーションは、JWTの暗号化操作に使用される暗号化キーが発行者に属していることを検証する必要があります。そうでない場合、アプリケーションはJWTを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "The means of determining the keys owned by an issuer is application-specific. As one example, OpenID Connect [OpenID.Core] issuer values are \"https\" URLs that reference a JSON metadata document that contains a \"jwks_uri\" value that is an \"https\" URL from which the issuer's keys are retrieved as a JWK Set [RFC7517]. This same mechanism is used by [RFC8414]. Other applications may use different means of binding keys to issuers.",
      "ja": "発行者が所有するキーを判別する方法は、アプリケーション固有です。一例として、OpenID Connect [OpenID.Core]発行者値は、発行者のキーがJWKセットとして取得される「https」URLである「jwks_uri」値を含むJSONメタデータドキュメントを参照する「https」URLです[ RFC7517]。これと同じメカニズムが[RFC8414]によって使用されます。他のアプリケーションは、発行者にキーをバインドする別の手段を使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, when the JWT contains a \"sub\" (subject) claim, the application MUST validate that the subject value corresponds to a valid subject and/or issuer-subject pair at the application. This may include confirming that the issuer is trusted by the application. If the issuer, subject, or the pair are invalid, the application MUST reject the JWT.",
      "ja": "同様に、JWTに「sub」（サブジェクト）クレームが含まれている場合、アプリケーションは、サブジェクト値がアプリケーションで有効なサブジェクトまたは発行者とサブジェクトのペアに対応していることを検証する必要があります。これには、発行者がアプリケーションによって信頼されていることの確認が含まれる場合があります。発行者、件名、またはペアが無効な場合、アプリケーションはJWTを拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.9. Use and Validate Audience",
      "section_title": true,
      "ja": "3.9. オーディエンスの使用と検証"
    },
    {
      "indent": 3,
      "text": "If the same issuer can issue JWTs that are intended for use by more than one relying party or application, the JWT MUST contain an \"aud\" (audience) claim that can be used to determine whether the JWT is being used by an intended party or was substituted by an attacker at an unintended party.",
      "ja": "同じ発行者が複数の証明書利用者またはアプリケーションによる使用を目的としたJWTを発行できる場合、JWTは、JWTが目的のパーティによって使用されているか、または意図しないパーティーで攻撃者に置き換えられた。"
    },
    {
      "indent": 3,
      "text": "In such cases, the relying party or application MUST validate the audience value, and if the audience value is not present or not associated with the recipient, it MUST reject the JWT.",
      "ja": "このような場合、依存パーティまたはアプリケーションはオーディエンス値を検証する必要があり、オーディエンス値が存在しないか、受信者に関連付けられていない場合は、JWTを拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.10. Do Not Trust Received Claims",
      "section_title": true,
      "ja": "3.10. 受け取ったクレームを信頼しない"
    },
    {
      "indent": 3,
      "text": "The \"kid\" (key ID) header is used by the relying application to perform key lookup. Applications should ensure that this does not create SQL or LDAP injection vulnerabilities by validating and/or sanitizing the received value.",
      "ja": "「子供」（キーID）ヘッダーは、依存アプリケーションによってキー検索を実行するために使用されます。アプリケーションは、受信した値を検証またはサニタイズすることにより、SQLまたはLDAPインジェクションの脆弱性が発生しないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, blindly following a \"jku\" (JWK set URL) or \"x5u\" (X.509 URL) header, which may contain an arbitrary URL, could result in server-side request forgery (SSRF) attacks. Applications SHOULD protect against such attacks, e.g., by matching the URL to a whitelist of allowed locations and ensuring no cookies are sent in the GET request.",
      "ja": "同様に、「jku」（JWKセットURL）または「x5u」（X.509 URL）ヘッダーに盲目的に続くと、任意のURLが含まれる可能性があり、サーバー側のリクエストフォージェリ（SSRF）攻撃を引き起こす可能性があります。アプリケーションは、URLを許可された場所のホワイトリストと照合し、GETリクエストでCookieが送信されないようにするなどして、このような攻撃から保護する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "3.11. Use Explicit Typing",
      "section_title": true,
      "ja": "3.11. 明示的なタイピングを使用する"
    },
    {
      "indent": 3,
      "text": "Sometimes, one kind of JWT can be confused for another. If a particular kind of JWT is subject to such confusion, that JWT can include an explicit JWT type value, and the validation rules can specify checking the type. This mechanism can prevent such confusion. Explicit JWT typing is accomplished by using the \"typ\" Header Parameter. For instance, the [RFC8417] specification uses the \"application/secevent+jwt\" media type to perform explicit typing of Security Event Tokens (SETs).",
      "ja": "ある種類のJWTが別の種類のJWTと混同される場合があります。特定の種類のJWTがそのような混乱の影響を受ける場合、そのJWTには明示的なJWTタイプ値を含めることができ、検証ルールはタイプのチェックを指定できます。このメカニズムにより、このような混乱を防ぐことができます。明示的なJWTタイピングは、「typ」ヘッダーパラメーターを使用して行われます。たとえば、[RFC8417]仕様では、「application / secevent + jwt」メディアタイプを使用して、セキュリティイベントトークン（SET）の明示的なタイピングを実行しています。"
    },
    {
      "indent": 3,
      "text": "Per the definition of \"typ\" in Section 4.1.9 of [RFC7515], it is RECOMMENDED that the \"application/\" prefix be omitted from the \"typ\" value. Therefore, for example, the \"typ\" value used to explicitly include a type for a SET SHOULD be \"secevent+jwt\". When explicit typing is employed for a JWT, it is RECOMMENDED that a media type name of the format \"application/example+jwt\" be used, where \"example\" is replaced by the identifier for the specific kind of JWT.",
      "ja": "[RFC7515]のセクション4.1.9の「typ」の定義によれば、「application /」接頭辞を「typ」の値から削除することをお勧めします。したがって、たとえば、SETのタイプを明示的に含めるために使用される「typ」値は「secevent + jwt」である必要があります。 JWTに明示的なタイピングが採用されている場合、「application / example + jwt」という形式のメディアタイプ名を使用することをお勧めします。「example」は特定の種類のJWTの識別子に置き換えられます。"
    },
    {
      "indent": 3,
      "text": "When applying explicit typing to a Nested JWT, the \"typ\" Header Parameter containing the explicit type value MUST be present in the inner JWT of the Nested JWT (the JWT whose payload is the JWT Claims Set). In some cases, the same \"typ\" Header Parameter value will be present in the outer JWT as well, to explicitly type the entire Nested JWT.",
      "ja": "ネストされたJWTに明示的な型指定を適用する場合、明示的な型の値を含む「typ」ヘッダーパラメーターは、ネストされたJWT（ペイロードがJWTクレームセットであるJWT）の内部JWTに存在する必要があります。場合によっては、ネストされたJWT全体を明示的に入力するために、同じ「typ」ヘッダーパラメータ値が外部JWTにも存在します。"
    },
    {
      "indent": 3,
      "text": "Note that the use of explicit typing may not achieve disambiguation from existing kinds of JWTs, as the validation rules for existing kinds of JWTs often do not use the \"typ\" Header Parameter value. Explicit typing is RECOMMENDED for new uses of JWTs.",
      "ja": "既存の種類のJWTの検証ルールは「typ」ヘッダーパラメーター値を使用しないことが多いため、明示的な型指定を使用しても、既存の種類のJWTから明確化できない場合があることに注意してください。 JWTを新たに使用する場合は、明示的な型指定をお勧めします。"
    },
    {
      "indent": 0,
      "text": "3.12. Use Mutually Exclusive Validation Rules for Different Kinds of JWTs",
      "ja": "3.12. さまざまな種類のJWTに対して相互に排他的な検証ルールを使用する"
    },
    {
      "indent": 3,
      "text": "Each application of JWTs defines a profile specifying the required and optional JWT claims and the validation rules associated with them. If more than one kind of JWT can be issued by the same issuer, the validation rules for those JWTs MUST be written such that they are mutually exclusive, rejecting JWTs of the wrong kind. To prevent substitution of JWTs from one context into another, application developers may employ a number of strategies:",
      "ja": "JWTの各アプリケーションは、必須およびオプションのJWTクレームとそれらに関連付けられた検証ルールを指定するプロファイルを定義します。同じ発行者が複数の種類のJWTを発行できる場合、それらのJWTの検証ルールは、相互に排他的で、間違った種類のJWTを拒否するように記述する必要があります。あるコンテキストから別のコンテキストへのJWTの置換を防ぐために、アプリケーション開発者はいくつかの戦略を採用できます。"
    },
    {
      "indent": 3,
      "text": "* Use explicit typing for different kinds of JWTs. Then the distinct \"typ\" values can be used to differentiate between the different kinds of JWTs.",
      "ja": "* さまざまな種類のJWTに明示的な型指定を使用します。次に、異なる「typ」値を使用して、さまざまな種類のJWTを区別できます。"
    },
    {
      "indent": 3,
      "text": "* Use different sets of required claims or different required claim values. Then the validation rules for one kind of JWT will reject those with different claims or values.",
      "ja": "* 必須のクレームの異なるセットまたは異なる必須のクレーム値を使用します。次に、ある種類のJWTの検証ルールは、クレームまたは値が異なるものを拒否します。"
    },
    {
      "indent": 3,
      "text": "* Use different sets of required Header Parameters or different required Header Parameter values. Then the validation rules for one kind of JWT will reject those with different Header Parameters or values.",
      "ja": "* 必要なヘッダーパラメータの異なるセットまたは異なる必須のヘッダーパラメータ値を使用します。次に、1種類のJWTの検証ルールは、異なるヘッダーパラメータまたは値を持つものを拒否します。"
    },
    {
      "indent": 3,
      "text": "* Use different keys for different kinds of JWTs. Then the keys used to validate one kind of JWT will fail to validate other kinds of JWTs.",
      "ja": "* 異なる種類のJWTには異なるキーを使用します。次に、ある種類のJWTの検証に使用されるキーは、他の種類のJWTの検証に失敗します。"
    },
    {
      "indent": 3,
      "text": "* Use different \"aud\" values for different uses of JWTs from the same issuer. Then audience validation will reject JWTs substituted into inappropriate contexts.",
      "ja": "* 同じ発行者からのJWTの異なる使用には、異なる「aud」値を使用してください。次に、オーディエンス検証は、不適切なコンテキストに置き換えられたJWTを拒否します。"
    },
    {
      "indent": 3,
      "text": "* Use different issuers for different kinds of JWTs. Then the distinct \"iss\" values can be used to segregate the different kinds of JWTs.",
      "ja": "* さまざまな種類のJWTにさまざまな発行者を使用します。次に、異なる「iss」値を使用して、さまざまな種類のJWTを分離できます。"
    },
    {
      "indent": 3,
      "text": "Given the broad diversity of JWT usage and applications, the best combination of types, required claims, values, Header Parameters, key usages, and issuers to differentiate among different kinds of JWTs will, in general, be application-specific. As discussed in Section 3.11, for new JWT applications, the use of explicit typing is RECOMMENDED.",
      "ja": "JWTの使用法とアプリケーションは多種多様であるため、異なる種類のJWTを区別するためのタイプ、必要なクレーム、値、ヘッダーパラメーター、キーの使用法、発行者の最適な組み合わせは、通常、アプリケーション固有です。セクション3.11で説明したように、新しいJWTアプリケーションでは、明示的な型指定を使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This entire document is about security considerations when implementing and deploying JSON Web Tokens.",
      "ja": "このドキュメント全体は、JSON Webトークンを実装およびデプロイする際のセキュリティに関する考慮事項についてです。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションはありません。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[nist-sp-800-56a-r3] Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R. Davis, \"Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography\", NIST Special Publication 800-56A Revision 3, DOI 10.6028/NIST.SP.800-56Ar3, April 2018, <https://doi.org/10.6028/NIST.SP.800-56Ar3>.",
      "ja": "[nist-sp-800-56a-r3] Barker、E.、Chen、L.、Roginsky、A.、Vassilev、A。、およびR. Davis、「離散対数暗号を使用したペアワイズのキー確立スキームの推奨事項\"、NIST Special Publication 800-56A Revision 3、DOI 10.6028 / NIST.SP.800-56Ar3、April 2018、<https://doi.org/10.6028/NIST.SP.800-56Ar3>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6979] Pornin, T., \"Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)\", RFC 6979, DOI 10.17487/RFC6979, August 2013, <https://www.rfc-editor.org/info/rfc6979>.",
      "ja": "[RFC6979]ポルノ、T。、「デジタル署名アルゴリズム（DSA）と楕円曲線デジタル署名アルゴリズム（ECDSA）の決定論的使用法」、RFC 6979、DOI 10.17487 / RFC6979、2013年8月、<https：//www.rfc- editor.org/info/rfc6979>。"
    },
    {
      "indent": 3,
      "text": "[RFC7515] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May 2015, <https://www.rfc-editor.org/info/rfc7515>.",
      "ja": "[RFC7515]ジョーンズ、M。、ブラッドリー、J。、およびN.崎村、「JSON Web Signature（JWS）」、RFC 7515、DOI 10.17487 / RFC7515、2015年5月、<https://www.rfc-editor.org / info / rfc7515>。"
    },
    {
      "indent": 3,
      "text": "[RFC7516] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", RFC 7516, DOI 10.17487/RFC7516, May 2015, <https://www.rfc-editor.org/info/rfc7516>.",
      "ja": "[RFC7516]ジョーンズ、M。およびJ.ヒルデブランド、「JSON Web Encryption（JWE）」、RFC 7516、DOI 10.17487 / RFC7516、2015年5月、<https://www.rfc-editor.org/info/rfc7516>。"
    },
    {
      "indent": 3,
      "text": "[RFC7518] Jones, M., \"JSON Web Algorithms (JWA)\", RFC 7518, DOI 10.17487/RFC7518, May 2015, <https://www.rfc-editor.org/info/rfc7518>.",
      "ja": "[RFC7518]ジョーンズ、M。、「JSON Web Algorithms（JWA）」、RFC 7518、DOI 10.17487 / RFC7518、2015年5月、<https://www.rfc-editor.org/info/rfc7518>。"
    },
    {
      "indent": 3,
      "text": "[RFC7519] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", RFC 7519, DOI 10.17487/RFC7519, May 2015, <https://www.rfc-editor.org/info/rfc7519>.",
      "ja": "[RFC7519]ジョーンズ、M。、ブラッドリー、J.、N。崎村、「JSON Web Token（JWT）」、RFC 7519、DOI 10.17487 / RFC7519、2015年5月、<https://www.rfc-editor.org / info / rfc7519>。"
    },
    {
      "indent": 3,
      "text": "[RFC8017] Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch, \"PKCS #1: RSA Cryptography Specifications Version 2.2\", RFC 8017, DOI 10.17487/RFC8017, November 2016, <https://www.rfc-editor.org/info/rfc8017>.",
      "ja": "[RFC8017] Moriarty、K.、Ed。、Kaliski、B.、Jonsson、J。、およびA. Rusch、「PKCS＃1：RSA Cryptography Specifications Version 2.2」、RFC 8017、DOI 10.17487 / RFC8017、2016年11月、< https://www.rfc-editor.org/info/rfc8017>。"
    },
    {
      "indent": 3,
      "text": "[RFC8037] Liusvaara, I., \"CFRG Elliptic Curve Diffie-Hellman (ECDH) and Signatures in JSON Object Signing and Encryption (JOSE)\", RFC 8037, DOI 10.17487/RFC8037, January 2017, <https://www.rfc-editor.org/info/rfc8037>.",
      "ja": "[RFC8037] Liusvaara、I。、「CFRG Elliptic Curve Diffie-Hellman（ECDH）and Signatures in JSON Object Signing and Encryption（JOSE）」、RFC 8037、DOI 10.17487 / RFC8037、2017年1月、<https：//www.rfc -editor.org/info/rfc8037>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8259] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017, <https://www.rfc-editor.org/info/rfc8259>.",
      "ja": "[RFC8259]ブレイ、T。、編、「JavaScript Object Notation（JSON）データ交換フォーマット」、STD 90、RFC 8259、DOI 10.17487 / RFC8259、2017年12月、<https://www.rfc-editor.org / info / rfc8259>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Alawatugoda] Alawatugoda, J., Stebila, D., and C. Boyd, \"Protecting Encrypted Cookies from Compression Side-Channel Attacks\", Financial Cryptography and Data Security, pp. 86-106, DOI 10.1007/978-3-662-47854-7_6, July 2015, <https://doi.org/10.1007/978-3-662-47854-7_6>.",
      "ja": "[アラワトゴダ]アラワトゴダ、J。、ステビラ、D。、およびC.ボイド、「圧縮サイドチャネル攻撃からの暗号化されたCookieの保護」、金融暗号化およびデータセキュリティ、pp。86-106、DOI 10.1007 / 978-3-662 -47854-7_6、2015年7月、<https://doi.org/10.1007/978-3-662-47854-7_6>。"
    },
    {
      "indent": 3,
      "text": "[ANSI-X962-2005] American National Standards Institute, \"Public Key Cryptography for the Financial Services Industry: the Elliptic Curve Digital Signature Algorithm (ECDSA)\", ANSI X9.62-2005, November 2005.",
      "ja": "[ANSI-X962-2005] American National Standards Institute、「金融サービス業界の公開鍵暗号化：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANSI X9.62-2005、2005年11月。"
    },
    {
      "indent": 3,
      "text": "[CVE-2015-9235] NIST, \"CVE-2015-9235 Detail\", National Vulnerability Database, May 2018, <https://nvd.nist.gov/vuln/detail/CVE-2015-9235>.",
      "ja": "[CVE-2015-9235] NIST、「CVE-2015-9235 Detail」、National Vulnerability Database、2018年5月、<https://nvd.nist.gov/vuln/detail/CVE-2015-9235>。"
    },
    {
      "indent": 3,
      "text": "[Kelsey] Kelsey, J., \"Compression and Information Leakage of Plaintext\", Fast Software Encryption, pp. 263-276, DOI 10.1007/3-540-45661-9_21, July 2002, <https://doi.org/10.1007/3-540-45661-9_21>.",
      "ja": "[Kelsey] Kelsey、J.、「圧縮とプレーンテキストの情報漏えい」、Fast Software Encryption、pp。263-276、DOI 10.1007 / 3-540-45661-9_21、2002年7月、<https://doi.org/ 10.1007 / 3-540-45661-9_21>。"
    },
    {
      "indent": 3,
      "text": "[Langkemper] Langkemper, S., \"Attacking JWT authentication\", September 2016, <https://www.sjoerdlangkemper.nl/2016/09/28/ attacking-jwt-authentication/>.",
      "ja": "[Langkemper] Langkemper、S。、「Attacking JWT authentication」、2016年9月、<https://www.sjoerdlangkemper.nl/2016/09/28/ attacking-jwt-authentication />。"
    },
    {
      "indent": 3,
      "text": "[McLean] McLean, T., \"Critical vulnerabilities in JSON Web Token libraries\", March 2015, <https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/>.",
      "ja": "[McLean] McLean、T。、「JSON Web Tokenライブラリの重大な脆弱性」、2015年3月、<https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/>。"
    },
    {
      "indent": 3,
      "text": "[OpenID.Core] Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, \"OpenID Connect Core 1.0 incorporating errata set 1\", November 2014, <https://openid.net/specs/openid-connect-core-1_0.html>.",
      "ja": "[OpenID.Core] Sakimura N.、Bradley、J.、Jones、M.、de Medeiros、B。、およびC. Mortimore、「OpenID Connect Core 1.0組み込んだエラッタセット1」、2014年11月、<https：// openid.net/specs/openid-connect-core-1_0.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <https://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749] Hardt、D。、編、「The OAuth 2.0 Authorization Framework」、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<https://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March 2014, <https://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159]ブレイ、T。、編、「JavaScriptオブジェクト表記（JSON）データ交換形式」、RFC 7159、DOI 10.17487 / RFC7159、2014年3月、<https://www.rfc-editor.org/info/ rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7517] Jones, M., \"JSON Web Key (JWK)\", RFC 7517, DOI 10.17487/RFC7517, May 2015, <https://www.rfc-editor.org/info/rfc7517>.",
      "ja": "[RFC7517]ジョーンズ、M。、「JSON Web Key（JWK）」、RFC 7517、DOI 10.17487 / RFC7517、2015年5月、<https://www.rfc-editor.org/info/rfc7517>。"
    },
    {
      "indent": 3,
      "text": "[RFC8414] Jones, M., Sakimura, N., and J. Bradley, \"OAuth 2.0 Authorization Server Metadata\", RFC 8414, DOI 10.17487/RFC8414, June 2018, <https://www.rfc-editor.org/info/rfc8414>.",
      "ja": "[RFC8414] Jones、M.、Sakimura、N.、J。Bradley、「OAuth 2.0 Authorization Server Metadata」、RFC 8414、DOI 10.17487 / RFC8414、2018年6月、<https://www.rfc-editor.org/ info / rfc8414>。"
    },
    {
      "indent": 3,
      "text": "[RFC8417] Hunt, P., Ed., Jones, M., Denniss, W., and M. Ansari, \"Security Event Token (SET)\", RFC 8417, DOI 10.17487/RFC8417, July 2018, <https://www.rfc-editor.org/info/rfc8417>.",
      "ja": "[RFC8417] Hunt、P.、Ed。、Jones、M.、Denniss、W.、and M. Ansari、 \"Security Event Token（SET）\"、RFC 8417、DOI 10.17487 / RFC8417、July 2018、<https：/ /www.rfc-editor.org/info/rfc8417>。"
    },
    {
      "indent": 3,
      "text": "[Sanso] Sanso, A., \"Critical Vulnerability Uncovered in JSON Encryption\", March 2017, <https://blogs.adobe.com/security/2017/03/critical-vulnerability-uncovered-in-json-encryption.html>.",
      "ja": "[Sanso] Sanso、A。、「JSON暗号化で発見された重大な脆弱性」、2017年3月、<https://blogs.adobe.com/security/2017/03/critical-vulnerability-uncovered-in-json-encryption.html >。"
    },
    {
      "indent": 3,
      "text": "[Valenta] Valenta, L., Sullivan, N., Sanso, A., and N. Heninger, \"In search of CurveSwap: Measuring elliptic curve implementations in the wild\", March 2018, <https://ia.cr/2018/298>.",
      "ja": "[Valenta] Valenta、L.、Sullivan、N.、Sanso、A。、およびN. Heninger、「In CurveSwap：In searching elliptic curve implementations in the wild」、2018年3月、<https://ia.cr/ 2018/298>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Antonio Sanso for bringing the \"ECDH-ES\" invalid point attack to the attention of JWE and JWT implementers. Tim McLean published the RSA/HMAC confusion attack [McLean]. Thanks to Nat Sakimura for advocating the use of explicit typing. Thanks to Neil Madden for his numerous comments, and to Carsten Bormann, Brian Campbell, Brian Carpenter, Alissa Cooper, Roman Danyliw, Ben Kaduk, Mirja Kühlewind, Barry Leiba, Eric Rescorla, Adam Roach, Martin Vigoureux, and Éric Vyncke for their reviews.",
      "ja": "\"ECDH-ES\"無効ポイント攻撃をJWEとJWTの実装者に知らせてくれたAntonio Sansoに感謝します。 Tim McLeanがRSA / HMAC混同攻撃[McLean]を公開しました。明示的な型指定の使用を提唱してくれたNatsakimuraに感謝します。多数のコメントを提供してくれたニールマッデン、およびレビューを提供してくれたカーステンボルマン、ブライアンキャンベル、ブライアンカーペンター、アリッサクーパー、ローマンダニーリュー、ベンカドゥック、ミルヤキュールウィンド、バリーレイバ、エリックレスコーラ、アダムローチ、マーティンヴィグールー、エリックヴィンケに感謝します。 。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Yaron Sheffer Intuit",
      "ja": "Yaron Sheffer Intuit"
    },
    {
      "indent": 3,
      "text": "Email: yaronf.ietf@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dick Hardt",
      "ja": "ディック・ハート"
    },
    {
      "indent": 3,
      "text": "Email: dick.hardt@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Michael B. Jones Microsoft",
      "ja": "マイケルB.ジョーンズマイクロソフト"
    },
    {
      "indent": 3,
      "text": "Email: mbj@microsoft.com\nURI:   https://self-issued.info/",
      "raw": true,
      "ja": ""
    }
  ]
}