{
  "title": {
    "text": "RFC 8949 - Concise Binary Object Representation (CBOR)",
    "ja": "RFC 8949 - 簡潔なバイナリオブジェクト表現（CBOR）"
  },
  "number": 8949,
  "created_at": "2021-04-14 05:59:05.393556+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        C. Bormann\nRequest for Comments: 8949                        Universität Bremen TZI\nSTD: 94                                                       P. Hoffman\nObsoletes: 7049                                                    ICANN\nCategory: Standards Track                                  December 2020\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Concise Binary Object Representation (CBOR)",
      "ja": "簡潔なバイナリオブジェクト表現（CBOR）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.",
      "ja": "簡潔バイナリオブジェクト表現（CBOR）は、極めて小さなコードサイズ、比較的小さなメッセージサイズ、そしてバージョンネゴシエーションを必要としない拡張性を実現することを設計目標としたデータ形式です。これらの設計目標により、CBORはASN.1やMessagePackといった従来のバイナリシリアル化とは一線を画しています。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.",
      "ja": "この文書はRFC 7049を廃止し、RFC 7049の交換フォーマットとの完全な互換性を保ちながら、編集上の改善、新規の詳細、およびエラータ修正を提供します。新しいバージョンのフォーマットは作成されません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット規格のトラック文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それは公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。インターネット規格に関する詳細情報は、RFC 7841のセクション2で利用できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8949.",
      "ja": "この文書の現在のステータス、エラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/rfc8949で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（C）2020 IETFの信頼と文書著者として識別された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Objectives\n  1.2.  Terminology\n2.  CBOR Data Models\n  2.1.  Extended Generic Data Models\n  2.2.  Specific Data Models\n3.  Specification of the CBOR Encoding\n  3.1.  Major Types\n  3.2.  Indefinite Lengths for Some Major Types\n    3.2.1.  The \"break\" Stop Code\n    3.2.2.  Indefinite-Length Arrays and Maps\n    3.2.3.  Indefinite-Length Byte Strings and Text Strings\n    3.2.4.  Summary of Indefinite-Length Use of Major Types\n  3.3.  Floating-Point Numbers and Values with No Content\n  3.4.  Tagging of Items\n    3.4.1.  Standard Date/Time String\n    3.4.2.  Epoch-Based Date/Time\n    3.4.3.  Bignums\n    3.4.4.  Decimal Fractions and Bigfloats\n    3.4.5.  Content Hints\n      3.4.5.1.  Encoded CBOR Data Item\n      3.4.5.2.  Expected Later Encoding for CBOR-to-JSON Converters\n      3.4.5.3.  Encoded Text\n    3.4.6.  Self-Described CBOR\n4.  Serialization Considerations\n  4.1.  Preferred Serialization\n  4.2.  Deterministically Encoded CBOR\n    4.2.1.  Core Deterministic Encoding Requirements\n    4.2.2.  Additional Deterministic Encoding Considerations\n    4.2.3.  Length-First Map Key Ordering\n5.  Creating CBOR-Based Protocols\n  5.1.  CBOR in Streaming Applications\n  5.2.  Generic Encoders and Decoders\n  5.3.  Validity of Items\n    5.3.1.  Basic validity\n    5.3.2.  Tag validity\n  5.4.  Validity and Evolution\n  5.5.  Numbers\n  5.6.  Specifying Keys for Maps\n    5.6.1.  Equivalence of Keys\n  5.7.  Undefined Values\n6.  Converting Data between CBOR and JSON\n  6.1.  Converting from CBOR to JSON\n  6.2.  Converting from JSON to CBOR\n7.  Future Evolution of CBOR\n  7.1.  Extension Points\n  7.2.  Curating the Additional Information Space\n8.  Diagnostic Notation\n  8.1.  Encoding Indicators\n9.  IANA Considerations\n  9.1.  CBOR Simple Values Registry\n  9.2.  CBOR Tags Registry\n  9.3.  Media Types Registry\n  9.4.  CoAP Content-Format Registry\n  9.5.  Structured Syntax Suffix Registry\n10. Security Considerations\n11. References\n  11.1.  Normative References\n  11.2.  Informative References\nAppendix A.  Examples of Encoded CBOR Data Items\nAppendix B.  Jump Table for Initial Byte\nAppendix C.  Pseudocode\nAppendix D.  Half-Precision\nAppendix E.  Comparison of Other Binary Formats to CBOR's Design\n        Objectives\n  E.1.  ASN.1 DER, BER, and PER\n  E.2.  MessagePack\n  E.3.  BSON\n  E.4.  MSDTP: RFC 713\n  E.5.  Conciseness on the Wire\nAppendix F.  Well-Formedness Errors and Examples\n  F.1.  Examples of CBOR Data Items That Are Not Well-Formed\nAppendix G.  Changes from RFC 7049\n  G.1.  Errata Processing and Clerical Changes\n  G.2.  Changes in IANA Considerations\n  G.3.  Changes in Suggestions and Other Informational Components\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "There are hundreds of standardized formats for binary representation of structured data (also known as binary serialization formats). Of those, some are for specific domains of information, while others are generalized for arbitrary data. In the IETF, probably the best-known formats in the latter category are ASN.1's BER and DER [ASN.1].",
      "ja": "構造化データのバイナリ表現（バイナリシリアル化形式とも呼ばれる）には、数百もの標準化された形式があります。これらの形式の中には、特定の情報領域向けのものもあれば、任意のデータに汎用化されたものもあります。IETFでは、後者のカテゴリで最もよく知られている形式は、おそらくASN.1のBERとDER [ASN.1]でしょう。"
    },
    {
      "indent": 3,
      "text": "The format defined here follows some specific design goals that are not well met by current formats. The underlying data model is an extended version of the JSON data model [RFC8259]. It is important to note that this is not a proposal that the grammar in RFC 8259 be extended in general, since doing so would cause a significant backwards incompatibility with already deployed JSON documents. Instead, this document simply defines its own data model that starts from JSON.",
      "ja": "ここで定義するフォーマットは、現在のフォーマットでは十分に満たされていない特定の設計目標に従っています。基盤となるデータモデルは、JSONデータモデル[RFC8259]の拡張版です。これはRFC 8259の文法を全般的に拡張する提案ではないことに留意してください。拡張すると、既に導入されているJSONドキュメントとの重大な後方互換性が失われるからです。本ドキュメントでは、JSONをベースとした独自のデータモデルを定義するだけです。"
    },
    {
      "indent": 3,
      "text": "Appendix E lists some existing binary formats and discusses how well they do or do not fit the design objectives of the Concise Binary Object Representation (CBOR).",
      "ja": "付録Eはいくつかの既存のバイナリ形式をリストし、それらが簡潔なバイナリオブジェクト表現（CBOR）の設計目標をどの程度うまくやらないかについて説明します。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC7049], providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.",
      "ja": "この文書は [RFC7049] を廃止するもので、RFC 7049 の交換形式との完全な互換性を保ちながら、編集上の改善、新しい詳細、およびエラッタの修正を提供します。形式の新しいバージョンを作成するものではありません。"
    },
    {
      "indent": 0,
      "text": "1.1. Objectives",
      "section_title": true,
      "ja": "1.1. 目的"
    },
    {
      "indent": 3,
      "text": "The objectives of CBOR, roughly in decreasing order of importance, are:",
      "ja": "CBORの目的は、大まかに重要な順序を短くすると、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The representation must be able to unambiguously encode most common data formats used in Internet standards.",
      "ja": "1. 表現は、インターネット規格で使用されるほとんどの一般的なデータフォーマットを明確に符号化できる必要があります。"
    },
    {
      "indent": 7,
      "text": "* It must represent a reasonable set of basic data types and structures using binary encoding. \"Reasonable\" here is largely influenced by the capabilities of JSON, with the major addition of binary byte strings. The structures supported are limited to arrays and trees; loops and lattice-style graphs are not supported.",
      "ja": "* バイナリエンコードを使用して、基本データ型の合理的なセットと構造を表す必要があります。ここで「合理的」は、バイナリバイト文字列の主な追加で、JSONの能力の影響を主に受けます。サポートされている構造は、アレイと木に限られています。ループとラティススタイルのグラフはサポートされていません。"
    },
    {
      "indent": 7,
      "text": "* There is no requirement that all data formats be uniquely encoded; that is, it is acceptable that the number \"7\" might be encoded in multiple different ways.",
      "ja": "* すべてのデータフォーマットを一意にエンコードする必要はありません。つまり、数値「7」が複数の異なる方法で符号化されている可能性があることが許容される。"
    },
    {
      "indent": 3,
      "text": "2. The code for an encoder or decoder must be able to be compact in order to support systems with very limited memory, processor power, and instruction sets.",
      "ja": "2. エンコーダまたはデコーダのコードは、非常に限られたメモリ、プロセッサの電源、および命令セットを持つシステムをサポートするためにコンパクトになる必要があります。"
    },
    {
      "indent": 7,
      "text": "* An encoder and a decoder need to be implementable in a very small amount of code (for example, in class 1 constrained nodes as defined in [RFC7228]).",
      "ja": "* エンコーダおよびデコーダは、非常に少量のコード（例えば、[RFC7228]で定義されているクラス1の制約ノード内）で実装可能である必要がある。"
    },
    {
      "indent": 7,
      "text": "* The format should use contemporary machine representations of data (for example, not requiring binary-to-decimal conversion).",
      "ja": "* このフォーマットは、データの現代的な機械表現を使用する必要があります（たとえば、2進数から10進数への変換を必要としません）。"
    },
    {
      "indent": 3,
      "text": "3. Data must be able to be decoded without a schema description.",
      "ja": "3. データの説明なしでデータを復号化できなければなりません。"
    },
    {
      "indent": 7,
      "text": "* Similar to JSON, encoded data should be self-describing so that a generic decoder can be written.",
      "ja": "* JSONと同様に、符号化データは自己記述されているので、一般的なデコーダを書き込むことができる。"
    },
    {
      "indent": 3,
      "text": "4. The serialization must be reasonably compact, but data compactness is secondary to code compactness for the encoder and decoder.",
      "ja": "4. シリアル化は合理的にコンパクトでなければなりませんが、データのコンパクトさはエンコーダとデコーダのコンパクトさを復元することです。"
    },
    {
      "indent": 7,
      "text": "* \"Reasonable\" here is bounded by JSON as an upper bound in size and by the implementation complexity, which limits the amount of effort that can go into achieving that compactness. Using either general compression schemes or extensive bit-fiddling violates the complexity goals.",
      "ja": "* ここでの「合理的」は、JSONがサイズの上限として、そして実装の複雑さによって、そのコンパクトさを達成する可能性がある努力の量を制限する。一般的な圧縮方式や広範囲のビットフィドリングのいずれかを使用すると、複雑さの目標が違反します。"
    },
    {
      "indent": 3,
      "text": "5. The format must be applicable to both constrained nodes and high-volume applications.",
      "ja": "5. フォーマットは、制約付きノードと大量のアプリケーションの両方に適用できます。"
    },
    {
      "indent": 7,
      "text": "* This means it must be reasonably frugal in CPU usage for both encoding and decoding. This is relevant both for constrained nodes and for potential usage in applications with a very high volume of data.",
      "ja": "* これは、符号化と復号化の両方のためにCPU使用率で合理的にフルガルでなければならないことを意味します。これは、制約されたノードの両方、および非常に大量のデータを持つアプリケーションにおける潜在的な使用方法の両方です。"
    },
    {
      "indent": 3,
      "text": "6. The format must support all JSON data types for conversion to and from JSON.",
      "ja": "6. 形式は、JSONへの変換のためのすべてのJSONデータ型をサポートしなければなりません。"
    },
    {
      "indent": 7,
      "text": "* It must support a reasonable level of conversion as long as the data represented is within the capabilities of JSON. It must be possible to define a unidirectional mapping towards JSON for all types of data.",
      "ja": "* 表されるデータがJSONの機能内にある限り、合理的な変換レベルをサポートする必要があります。あらゆる種類のデータについてJSONに向かって一方向マッピングを定義することは可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "7. The format must be extensible, and the extended data must be decodable by earlier decoders.",
      "ja": "7. フォーマットは拡張可能でなければならず、拡張データは以前のデコーダで復号可能でなければなりません。"
    },
    {
      "indent": 7,
      "text": "* The format is designed for decades of use.",
      "ja": "* フォーマットは数十年の使用のために設計されています。"
    },
    {
      "indent": 7,
      "text": "* The format must support a form of extensibility that allows fallback so that a decoder that does not understand an extension can still decode the message.",
      "ja": "* フォーマットは、拡張機能を理解しないデコーダがメッセージを復号することができるように、フォールバックを許可する拡張性の形式をサポートしている必要があります。"
    },
    {
      "indent": 7,
      "text": "* The format must be able to be extended in the future by later IETF standards.",
      "ja": "* フォーマットは後のIETF規格によって将来拡張できなければなりません。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "The term \"byte\" is used in its now-customary sense as a synonym for \"octet\". All multi-byte values are encoded in network byte order (that is, most significant byte first, also known as \"big-endian\").",
      "ja": "「バイト」という用語は、「オクテット」の同義語として、現在慣習的な意味で使用されています。すべてのマルチバイト値は、ネットワークバイト順（つまり、「Big-Endian」としても知られている）でネットワークバイト順にエンコードされています。"
    },
    {
      "indent": 3,
      "text": "This specification makes use of the following terminology:",
      "ja": "この仕様は次の用語を利用しています。"
    },
    {
      "indent": 3,
      "text": "Data item: A single piece of CBOR data. The structure of a data item may contain zero, one, or more nested data items. The term is used both for the data item in representation format and for the abstract idea that can be derived from that by a decoder; the former can be addressed specifically by using the term \"encoded data item\".",
      "ja": "データ項目：1枚のCBORデータ。データ項目の構造は、ゼロ、1つ、またはより多くのネストされたデータ項目を含み得る。この用語は、表現形式のデータ項目の両方で、デコーダによるそれから導出できる抽象的な考えについて使用されます。前者は、「符号化データ項目」という用語を用いて具体的に対処することができる。"
    },
    {
      "indent": 3,
      "text": "Decoder: A process that decodes a well-formed encoded CBOR data item and makes it available to an application. Formally speaking, a decoder contains a parser to break up the input using the syntax rules of CBOR, as well as a semantic processor to prepare the data in a form suitable to the application.",
      "ja": "デコーダ：整形式の符号化されたCBOBORデータ項目を復号化し、それをアプリケーションで利用可能にするプロセス。正式に言えば、デコーダには、CBORの構文規則を使用して入力を分割するためのパーサーと、データをアプリケーションに適した形式で準備するためのセマンティックプロセッサが含まれています。"
    },
    {
      "indent": 3,
      "text": "Encoder: A process that generates the (well-formed) representation format of a CBOR data item from application information.",
      "ja": "エンコーダ：アプリケーション情報からCBORデータ項目の（整形式）表現形式を生成するプロセス。"
    },
    {
      "indent": 3,
      "text": "Data Stream: A sequence of zero or more data items, not further assembled into a larger containing data item (see [RFC8742] for one application). The independent data items that make up a data stream are sometimes also referred to as \"top-level data items\".",
      "ja": "データストリーム：0個以上のデータ項目のシーケンスは、さらに大きなデータ項目にさらに組み立てられていません（1つのアプリケーションの[RFC8742]を参照）。データストリームを構成する独立したデータ項目は、「最上位データ項目」とも呼ばれることがあります。"
    },
    {
      "indent": 3,
      "text": "Well-formed: A data item that follows the syntactic structure of CBOR. A well-formed data item uses the initial bytes and the byte strings and/or data items that are implied by their values as defined in CBOR and does not include following extraneous data. CBOR decoders by definition only return contents from well-formed data items.",
      "ja": "整形式：CBORの構文構造に続くデータ項目。整形式のデータ項目は、CBORで定義されているように、初期バイトとバイト文字列やその値によって暗示されているデータ項目を使用し、以下の外部データを含まない。定義によるCBORデコーダは、整形式のデータ項目からの内容のみを返す。"
    },
    {
      "indent": 3,
      "text": "Valid: A data item that is well-formed and also follows the semantic restrictions that apply to CBOR data items (Section 5.3).",
      "ja": "有効：整形式のデータ項目にも、CBORデータ項目に適用される意味上の制限にも従うことがあります（セクション5.3）。"
    },
    {
      "indent": 3,
      "text": "Expected: Besides its normal English meaning, the term \"expected\" is used to describe requirements beyond CBOR validity that an application has on its input data. Well-formed (processable at all), valid (checked by a validity-checking generic decoder), and expected (checked by the application) form a hierarchy of layers of acceptability.",
      "ja": "予想される：通常の英語の意味の他に、アプリケーションがその入力データに持っているCBORの妥当性を超えた要件を説明するために「予想される」という用語が使用されます。有効（有効性検査汎用デコーダによってチェックされている）、予想される（アプリケーションによってチェックされている）、許容可能性の層の階層を形成する。"
    },
    {
      "indent": 3,
      "text": "Stream decoder: A process that decodes a data stream and makes each of the data items in the sequence available to an application as they are received.",
      "ja": "ストリームデコーダ：データストリームをデコードし、それらの各データ項目を受信時に利用可能な順序で各データ項目にするプロセス。"
    },
    {
      "indent": 3,
      "text": "Terms and concepts for floating-point values such as Infinity, NaN (not a number), negative zero, and subnormal are defined in [IEEE754].",
      "ja": "無限大、NaN（非数）、負のゼロ、非正規化数などの浮動小数点値の用語と概念は、[IEEE754]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Where bit arithmetic or data types are explained, this document uses the notation familiar from the programming language C [C], except that \"..\" denotes a range that includes both ends given, and superscript notation denotes exponentiation. For example, 2 to the power of 64 is notated: 2^(64). In the plain-text version of this specification, superscript notation is not available and therefore is rendered by a surrogate notation. That notation is not optimized for this RFC; it is unfortunately ambiguous with C's exclusive-or (which is only used in the appendices, which in turn do not use exponentiation) and requires circumspection from the reader of the plain-text version.",
      "ja": "ビット演算やデータ型の説明では、本文書ではプログラミング言語C [C]で一般的に用いられている表記法を用いています。ただし、\"..\" は両端を含む範囲を表し、上付き文字は指数を表します。例えば、2の64乗は2^(64)と表記されます。本仕様のプレーンテキスト版では上付き文字は使用できないため、代替表記法で表されます。この表記法は本RFC向けに最適化されていません。残念ながら、Cの排他的論理和（付録でのみ使用され、付録では指数は使用されません）と曖昧なため、プレーンテキスト版を読む際には注意が必要です。"
    },
    {
      "indent": 3,
      "text": "Examples and pseudocode assume that signed integers use two's complement representation and that right shifts of signed integers perform sign extension; these assumptions are also specified in Sections 6.8.1 (basic.fundamental) and 7.6.7 (expr.shift) of the 2020 version of C++ (currently available as a final draft, [Cplusplus20]).",
      "ja": "例と疑似コードは、符号付き整数が2の補数表現を使用し、符号付き整数の右シフトが符号拡張を実行すると仮定します。これらの仮定は、2020バージョンのCのセクション6.8.1（Basic.Fundamental）および7.6.7（expr.Shift）でも指定されています（現在、最終ドラフト、[CPLUSPLUS20]）。"
    },
    {
      "indent": 3,
      "text": "Similar to the \"0x\" notation for hexadecimal numbers, numbers in binary notation are prefixed with \"0b\". Underscores can be added to a number solely for readability, so 0b00100001 (0x21) might be written 0b001_00001 to emphasize the desired interpretation of the bits in the byte; in this case, it is split into three bits and five bits. Encoded CBOR data items are sometimes given in the \"0x\" or \"0b\" notation; these values are first interpreted as numbers as in C and are then interpreted as byte strings in network byte order, including any leading zero bytes expressed in the notation.",
      "ja": "16進数の「0x」表記と同様に、2進表記の数値には「0b」という接頭辞が付きます。数値の後ろにアンダースコアを付ける場合もありますが、これは読みやすさのためだけのものです。例えば、0b00100001 (0x21) は、バイト内のビットの解釈を強調するために「0b001_00001」と表記されることがあります。この場合、バイトは3ビットと5ビットに分割されます。エンコードされたCBORデータ項目は、「0x」または「0b」表記で表される場合があります。これらの値は、まずC言語と同様に数値として解釈され、次に表記法で表現される先頭のゼロバイトを含め、ネットワークバイトオーダーのバイト文字列として解釈されます。"
    },
    {
      "indent": 3,
      "text": "Words may be _italicized_ for emphasis; in the plain text form of this specification, this is indicated by surrounding words with underscore characters. Verbatim text (e.g., names from a programming language) may be set in \"monospace\" type; in plain text, this is approximated somewhat ambiguously by surrounding the text in double quotes (which also retain their usual meaning).",
      "ja": "強調のため、単語は斜体で表記される場合があります。この仕様のプレーンテキスト形式では、単語をアンダースコアで囲むことで斜体で表記されます。逐語的なテキスト（例：プログラミング言語の名前）は「等幅」で表記される場合があります。プレーンテキストでは、テキストを二重引用符で囲むことで、やや曖昧な表現となりますが、二重引用符は通常の意味を保持します。"
    },
    {
      "indent": 0,
      "text": "2. CBOR Data Models",
      "section_title": true,
      "ja": "2. CBORデータモデル"
    },
    {
      "indent": 3,
      "text": "CBOR is explicit about its generic data model, which defines the set of all data items that can be represented in CBOR. Its basic generic data model is extensible by the registration of \"simple values\" and tags. Applications can then create a subset of the resulting extended generic data model to build their specific data models.",
      "ja": "CBORはその一般的なデータモデルについて明示的で、CBORで表現できるすべてのデータ項目のセットを定義しています。その基本的な一般的なデータモデルは、「単純な値」とタグの登録によって拡張可能です。その後、アプリケーションはその結果の拡張総称データモデルのサブセットを作成して、それらの特定のデータモデルを構築できます。"
    },
    {
      "indent": 3,
      "text": "Within environments that can represent the data items in the generic data model, generic CBOR encoders and decoders can be implemented (which usually involves defining additional implementation data types for those data items that do not already have a natural representation in the environment). The ability to provide generic encoders and decoders is an explicit design goal of CBOR; however, many applications will provide their own application-specific encoders and/or decoders.",
      "ja": "汎用データモデルでデータ項目を表すことができる環境内では、一般的なCBORエンコーダとデコーダを実装することができます（通常は環境内の自然表現をまだ持っていないデータ項目の追加の実装データ型の定義を含みます）。一般的なエンコーダとデコーダを提供する能力は、CBORの明白な設計目標です。ただし、多くのアプリケーションは独自のアプリケーション固有のエンコーダおよび/またはデコーダを提供します。"
    },
    {
      "indent": 3,
      "text": "In the basic (unextended) generic data model defined in Section 3, a data item is one of the following:",
      "ja": "セクション3で定義されている基本（非拡張内容）一般データモデルでは、データ項目は次のいずれかです。"
    },
    {
      "indent": 3,
      "text": "* an integer in the range -2^(64)..2^(64)-1 inclusive",
      "ja": "* -2^(64)...2^(64)-1の範囲の整数"
    },
    {
      "indent": 3,
      "text": "* a simple value, identified by a number between 0 and 255, but distinct from that number itself",
      "ja": "* 0から255の間の数字によって識別される単純な値、しかしその数自体とは異なります"
    },
    {
      "indent": 3,
      "text": "* a floating-point value, distinct from an integer, out of the set representable by IEEE 754 binary64 (including non-finites) [IEEE754]",
      "ja": "* IEEE 754 Binary 64（非有限部を含む）によって表現可能なセットのうち整数とは異なる浮動小数点値。[IEEE754]"
    },
    {
      "indent": 3,
      "text": "* a sequence of zero or more bytes (\"byte string\")",
      "ja": "* 0バイト以上のシーケンス（ \"バイト文字列\"）"
    },
    {
      "indent": 3,
      "text": "* a sequence of zero or more Unicode code points (\"text string\")",
      "ja": "* 一連の0個以上のUnicodeコードポイント（「テキスト文字列」）"
    },
    {
      "indent": 3,
      "text": "* a sequence of zero or more data items (\"array\")",
      "ja": "* 一連の0個以上のデータ項目（「配列」）"
    },
    {
      "indent": 3,
      "text": "* a mapping (mathematical function) from zero or more data items (\"keys\") each to a data item (\"values\"), (\"map\")",
      "ja": "* 0個以上のデータ項目（「キー」）からデータ項目（「値」）までのマッピング（数学関数）、（「値」）"
    },
    {
      "indent": 3,
      "text": "* a tagged data item (\"tag\"), comprising a tag number (an integer in the range 0..2^(64)-1) and the tag content (a data item)",
      "ja": "* タグ番号（0..2^(64)-1の範囲の整数）とタグの内容（データ項目）で構成されるタグ付きデータ項目（「タグ」）"
    },
    {
      "indent": 3,
      "text": "Note that integer and floating-point values are distinct in this model, even if they have the same numeric value.",
      "ja": "同じ数値を持つ場合でも、整数値と浮動小数点値はこのモデルで異なります。"
    },
    {
      "indent": 3,
      "text": "Also note that serialization variants are not visible at the generic data model level. This deliberate absence of visibility includes the number of bytes of the encoded floating-point value. It also includes the choice of encoding for an \"argument\" (see Section 3) such as the encoding for an integer, the encoding for the length of a text or byte string, the encoding for the number of elements in an array or pairs in a map, or the encoding for a tag number.",
      "ja": "シリアライゼーションのバリエーションは一般的なデータモデルレベルでは見えないことにも注意してください。この視認性の欠如は、符号化された浮動小数点値のバイト数を含む。それはまた、整数のエンコーディング、テキストまたはバイト文字列の長さのエンコーディングなどの「引数」（セクション3を参照）の選択を含み、アレイまたはペアの要素数のエンコーディングマップ、またはタグ番号のエンコーディング。"
    },
    {
      "indent": 0,
      "text": "2.1. Extended Generic Data Models",
      "section_title": true,
      "ja": "2.1. 汎用データモデル"
    },
    {
      "indent": 3,
      "text": "This basic generic data model has been extended in this document by the registration of a number of simple values and tag numbers, such as:",
      "ja": "この基本的な一般データモデルは、この文書では、次のような数の単純な値とタグ番号を登録することによって拡張されています。"
    },
    {
      "indent": 3,
      "text": "* \"false\", \"true\", \"null\", and \"undefined\" (simple values identified by 20..23, Section 3.3)",
      "ja": "* \"false\"、 \"true\"、 \"null\"、 \"undefined\"（20.23で識別された単純な値、3.3）"
    },
    {
      "indent": 3,
      "text": "* integer and floating-point values with a larger range and precision than the above (tag numbers 2 to 5, Section 3.4)",
      "ja": "* 上記よりも大きい範囲と精度の整数と浮動小数点値（タグ番号2から5、セクション3.4）"
    },
    {
      "indent": 3,
      "text": "* application data types such as a point in time or date/time string defined in RFC 3339 (tag numbers 1 and 0, Section 3.4)",
      "ja": "* RFC 3339で定義されている時刻または日付/時刻文字列などのアプリケーションデータ型（タグ番号1と0、セクション3.4）"
    },
    {
      "indent": 3,
      "text": "Additional elements of the extended generic data model can be (and have been) defined via the IANA registries created for CBOR. Even if such an extension is unknown to a generic encoder or decoder, data items using that extension can be passed to or from the application by representing them at the application interface within the basic generic data model, i.e., as generic simple values or generic tags.",
      "ja": "拡張汎用データモデルの追加の要素は、CBOR用に作成されたIANAレジストリを介して定義されている可能性があります。そのような拡張子が一般的なエンコーダまたはデコーダに知られていなくても、その拡張子を使用するデータ項目は、基本的な一般データモデル内のアプリケーションインタフェース、すなわち一般的な単純な値または一般的なタグとして表現することによってアプリケーションから渡すことができる。。"
    },
    {
      "indent": 3,
      "text": "In other words, the basic generic data model is stable as defined in this document, while the extended generic data model expands by the registration of new simple values or tag numbers, but never shrinks.",
      "ja": "言い換えれば、基本的な一般データモデルはこの文書で定義されているように安定していますが、拡張汎用データモデルは新しい単純な値やタグ番号の登録によって拡大されますが、縮小することはありません。"
    },
    {
      "indent": 3,
      "text": "While there is a strong expectation that generic encoders and decoders can represent \"false\", \"true\", and \"null\" (\"undefined\" is intentionally omitted) in the form appropriate for their programming environment, the implementation of the data model extensions created by tags is truly optional and a matter of implementation quality.",
      "ja": "一般的なエンコーダとデコーダが「false」、「true」、および「null」（「未定義」は意図的に省略されています）がプログラミング環境に適した形式で、作成された環境では、作成された期待があります。タグによって、本当にオプションであり、実装品質の問題です。"
    },
    {
      "indent": 0,
      "text": "2.2. Specific Data Models",
      "section_title": true,
      "ja": "2.2. 特定のデータモデル"
    },
    {
      "indent": 3,
      "text": "The specific data model for a CBOR-based protocol usually takes a subset of the extended generic data model and assigns application semantics to the data items within this subset and its components. When documenting such specific data models and specifying the types of data items, it is preferable to identify the types by their generic data model names (\"negative integer\", \"array\") instead of referring to aspects of their CBOR representation (\"major type 1\", \"major type 4\").",
      "ja": "CBORベースのプロトコルの特定のデータモデルは、通常、拡張された汎用データモデルのサブセットを採用し、このサブセット内のデータ項目とそのコンポーネントにアプリケーションセマンティクスを割り当てます。このような特定のデータモデルを文書化し、データ項目の型を指定する場合、CBOR表現の側面（「メジャータイプ1」、「メジャータイプ4」）を参照するのではなく、汎用データモデル名（「負の整数」、「配列」）で型を識別することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Specific data models can also specify value equivalency (including values of different types) for the purposes of map keys and encoder freedom. For example, in the generic data model, a valid map MAY have both \"0\" and \"0.0\" as keys, and an encoder MUST NOT encode \"0.0\" as an integer (major type 0, Section 3.1). However, if a specific data model declares that floating-point and integer representations of integral values are equivalent, using both map keys \"0\" and \"0.0\" in a single map would be considered duplicates, even while encoded as different major types, and so invalid; and an encoder could encode integral-valued floats as integers or vice versa, perhaps to save encoded bytes.",
      "ja": "特定のデータモデルでは、マップキーとエンコーダの自由度のために、値の等価性（異なる型の値を含む）を指定することもできます。たとえば、汎用データモデルでは、有効なマップはキーとして「0」と「0.0」の両方を持つことができ、「0.0」を整数（メジャータイプ0、セクション3.1）としてエンコードしてはなりません。ただし、特定のデータモデルで整数値の浮動小数点数と整数表現が同等であると宣言されている場合、単一のマップでマップキー「0」と「0.0」の両方を使用することは、異なるメジャータイプとしてエンコードされている場合でも重複と見なされ、無効になります。エンコーダは、エンコードされたバイト数を節約するために、整数値の浮動小数点数を整数としてエンコードしたり、その逆を行ったりすることができます。"
    },
    {
      "indent": 0,
      "text": "3. Specification of the CBOR Encoding",
      "section_title": true,
      "ja": "3. CBOR符号化の指定"
    },
    {
      "indent": 3,
      "text": "A CBOR data item (Section 2) is encoded to or decoded from a byte string carrying a well-formed encoded data item as described in this section. The encoding is summarized in Table 7 in Appendix B, indexed by the initial byte. An encoder MUST produce only well-formed encoded data items. A decoder MUST NOT return a decoded data item when it encounters input that is not a well-formed encoded CBOR data item (this does not detract from the usefulness of diagnostic and recovery tools that might make available some information from a damaged encoded CBOR data item).",
      "ja": "CBORデータ項目（セクション2）は、本セクションで説明する整形式のエンコードされたデータ項目を含むバイト文字列にエンコードまたはデコードされます。エンコードは付録Bの表7にまとめられており、先頭バイトでインデックス付けされています。エンコーダは整形式のエンコードされたデータ項目のみを生成しなければなりません。デコーダは、整形式のエンコードされたCBORデータ項目ではない入力に遭遇した場合、デコードされたデータ項目を返してはなりません（ただし、破損したエンコードされたCBORデータ項目から何らかの情報を取得できる診断ツールや回復ツールの有用性を損なうものではありません）。"
    },
    {
      "indent": 3,
      "text": "The initial byte of each encoded data item contains both information about the major type (the high-order 3 bits, described in Section 3.1) and additional information (the low-order 5 bits). With a few exceptions, the additional information's value describes how to load an unsigned integer \"argument\":",
      "ja": "各エンコードされたデータ項目の初期バイトには、メジャータイプ（3.1項で説明されている上位3ビット）と追加情報（下位5ビット）に関する両方の情報が含まれています。いくつかの例外を除いて、追加情報の値は、符号なし整数 \"引数\"をロードする方法を表します。"
    },
    {
      "indent": 3,
      "text": "Less than 24: The argument's value is the value of the additional information.",
      "ja": "24未満：引数の値は追加情報の値です。"
    },
    {
      "indent": 3,
      "text": "24, 25, 26, or 27: The argument's value is held in the following 1, 2, 4, or 8 bytes, respectively, in network byte order. For major type 7 and additional information value 25, 26, 27, these bytes are not used as an integer argument, but as a floating-point value (see Section 3.3).",
      "ja": "24,25,26,27：引数の値は、ネットワークバイト順で、それぞれ次の1,2,4、または8バイトに保持されます。メジャータイプ7と追加情報値25,26,27の場合、これらのバイトは整数引数としては使用されませんが、浮動小数点値としては使用されません（セクション3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "28, 29, 30: These values are reserved for future additions to the CBOR format. In the present version of CBOR, the encoded item is not well-formed.",
      "ja": "28,29,30：これらの値は将来のCBOR形式の追加のために予約されています。現在のバージョンのCBORでは、符号化されたアイテムは緊密に形成されていません。"
    },
    {
      "indent": 3,
      "text": "31: No argument value is derived. If the major type is 0, 1, or 6, the encoded item is not well-formed. For major types 2 to 5, the item's length is indefinite, and for major type 7, the byte does not constitute a data item at all but terminates an indefinite-length item; all are described in Section 3.2.",
      "ja": "31：引数値が派生しません。メジャータイプが0,1、または6の場合、符号化された項目は十分に形成されていません。メジャータイプ2から5の場合、アイテムの長さは不定であり、主要タイプ7では、バイトはデータ項目を全く構成されていませんが、不定長さ項目を終端します。すべてセクション3.2で説明されています。"
    },
    {
      "indent": 3,
      "text": "The initial byte and any additional bytes consumed to construct the argument are collectively referred to as the _head_ of the data item.",
      "ja": "引数を構築するために消費された初期バイトと任意の追加バイト数は、まとめてデータ項目の_HEAD_と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The meaning of this argument depends on the major type. For example, in major type 0, the argument is the value of the data item itself (and in major type 1, the value of the data item is computed from the argument); in major type 2 and 3, it gives the length of the string data in bytes that follow; and in major types 4 and 5, it is used to determine the number of data items enclosed.",
      "ja": "この引数の意味はメジャー型によって異なります。たとえば、メジャータイプ0では、引数はデータ項目自体の値です（そしてメジャータイプ1では、データ項目の値は引数から計算されます）。メジャータイプ2および3では、文字列データの長さをその後のバイト単位で与えます。そして、メジャータイプ4および5では、囲まれたデータ項目の数を決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If the encoded sequence of bytes ends before the end of a data item, that item is not well-formed. If the encoded sequence of bytes still has bytes remaining after the outermost encoded item is decoded, that encoding is not a single well-formed CBOR item. Depending on the application, the decoder may either treat the encoding as not well-formed or just identify the start of the remaining bytes to the application.",
      "ja": "符号化されたバイトのシーケンスがデータ項目の終わりの前に終了すると、その項目は十分に形成されていません。最も外側の符号化された項目が復号された後に符号化されたシーケンスが依然として残っているバイトが依然として残っている場合、その符号化は単一のよく形成されたCBOBOBOR項目ではない。アプリケーションに応じて、デコーダは、符号化を整形ではなく扱うか、または残りのバイトの開始をアプリケーションに識別するだけでよい。"
    },
    {
      "indent": 3,
      "text": "A CBOR decoder implementation can be based on a jump table with all 256 defined values for the initial byte (Table 7). A decoder in a constrained implementation can instead use the structure of the initial byte and following bytes for more compact code (see Appendix C for a rough impression of how this could look).",
      "ja": "CBOORデコーダの実装は、初期バイトの256個の定義値のすべてのジャンプテーブルに基づくことができます（表7）。制約された実装内のデコーダは、代わりに初期バイトの構造とよりコンパクトなコードのためにバイトの構造を使用することができます（これがどのように見えるかについての大まかな印象のために付録Cを参照）。"
    },
    {
      "indent": 0,
      "text": "3.1. Major Types",
      "section_title": true,
      "ja": "3.1. メジャータイプ"
    },
    {
      "indent": 3,
      "text": "The following lists the major types and the additional information and other bytes associated with the type.",
      "ja": "以下は、メジャータイプと追加情報、およびそのタイプに関連付けられているその他のバイトをリストします。"
    },
    {
      "indent": 3,
      "text": "Major type 0: An unsigned integer in the range 0..2^(64)-1 inclusive. The value of the encoded item is the argument itself. For example, the integer 10 is denoted as the one byte 0b000_01010 (major type 0, additional information 10). The integer 500 would be 0b000_11001 (major type 0, additional information 25) followed by the two bytes 0x01f4, which is 500 in decimal.",
      "ja": "メジャータイプ0: 0..2^(64)-1（両端を含む）の範囲の符号なし整数。エンコードされた項目の値は引数そのものとなります。例えば、整数10は1バイトの0b000_01010（メジャータイプ0、追加情報10）で表されます。整数500は0b000_11001（メジャータイプ0、追加情報25）に2バイトの0x01f4が続き、10進数では500となります。"
    },
    {
      "indent": 3,
      "text": "Major type 1: A negative integer in the range -2^(64)..-1 inclusive. The value of the item is -1 minus the argument. For example, the integer -500 would be 0b001_11001 (major type 1, additional information 25) followed by the two bytes 0x01f3, which is 499 in decimal.",
      "ja": "メジャータイプ1: -2^(64)…-1の範囲の負の整数。項目の値は-1から引数値を引いた値です。例えば、整数-500は0b001_11001（メジャータイプ1、追加情報25）に2バイトの0x01f3が続き、10進数では499になります。"
    },
    {
      "indent": 3,
      "text": "Major type 2: A byte string. The number of bytes in the string is equal to the argument. For example, a byte string whose length is 5 would have an initial byte of 0b010_00101 (major type 2, additional information 5 for the length), followed by 5 bytes of binary content. A byte string whose length is 500 would have 3 initial bytes of 0b010_11001 (major type 2, additional information 25 to indicate a two-byte length) followed by the two bytes 0x01f4 for a length of 500, followed by 500 bytes of binary content.",
      "ja": "メジャータイプ 2: バイト文字列。文字列のバイト数は引数と同じになります。例えば、長さが5のバイト文字列は、最初のバイトが0b010_00101（メジャータイプ 2、長さを示す追加情報 5）で、その後に5バイトのバイナリコンテンツが続きます。長さが500のバイト文字列は、最初の3バイトが0b010_11001（メジャータイプ 2、長さを示す追加情報 25）で、その後に長さ500を表す2バイト0x01f4が続き、その後に500バイトのバイナリコンテンツが続きます。"
    },
    {
      "indent": 3,
      "text": "Major type 3: A text string (Section 2) encoded as UTF-8 [RFC3629]. The number of bytes in the string is equal to the argument. A string containing an invalid UTF-8 sequence is well-formed but invalid (Section 1.2). This type is provided for systems that need to interpret or display human-readable text, and allows the differentiation between unstructured bytes and text that has a specified repertoire (that of Unicode) and encoding (UTF-8). In contrast to formats such as JSON, the Unicode characters in this type are never escaped. Thus, a newline character (U+000A) is always represented in a string as the byte 0x0a, and never as the bytes 0x5c6e (the characters \"\\\" and \"n\") nor as 0x5c7530303061 (the characters \"\\\", \"u\", \"0\", \"0\", \"0\", and \"a\").",
      "ja": "メジャータイプ3: UTF-8 [RFC3629] でエンコードされたテキスト文字列（セクション2）。文字列のバイト数は引数と等しくなります。無効なUTF-8シーケンスを含む文字列は、整形式ですが無効です（セクション1.2）。このタイプは、人間が読めるテキストを解釈または表示する必要があるシステム向けに提供されており、構造化されていないバイトと、指定されたレパートリー（Unicode）およびエンコーディング（UTF-8）を持つテキストを区別できます。JSONなどの形式とは異なり、このタイプのUnicode文字はエスケープされません。したがって、改行文字 (U+000A) は、文字列内では常にバイト 0x0a として表され、バイト 0x5c6e (文字 \"\\\" および \"n\") や 0x5c7530303061 (文字 \"\\\"、\"u\"、\"0\"、\"0\"、\"0\"、および \"a\") として表されることはありません。"
    },
    {
      "indent": 3,
      "text": "Major type 4: An array of data items. In other formats, arrays are also called lists, sequences, or tuples (a \"CBOR sequence\" is something slightly different, though [RFC8742]). The argument is the number of data items in the array. Items in an array do not need to all be of the same type. For example, an array that contains 10 items of any type would have an initial byte of 0b100_01010 (major type 4, additional information 10 for the length) followed by the 10 remaining items.",
      "ja": "メジャータイプ4：データ項目の配列。他の形式では、配列はリスト、シーケンス、またはタプルとも呼ばれます（ただし、「CBORシーケンス」は[RFC8742]とは少し異なります）。引数は配列内のデータ項目の数です。配列内の項目はすべて同じ型である必要はありません。例えば、任意の型の項目が10個含まれる配列の場合、最初のバイトは0b100_01010（メジャータイプ4、長さを示す追加情報10）となり、その後に残りの10個の項目が続きます。"
    },
    {
      "indent": 3,
      "text": "Major type 5: A map of pairs of data items. Maps are also called tables, dictionaries, hashes, or objects (in JSON). A map is comprised of pairs of data items, each pair consisting of a key that is immediately followed by a value. The argument is the number of _pairs_ of data items in the map. For example, a map that contains 9 pairs would have an initial byte of 0b101_01001 (major type 5, additional information 9 for the number of pairs) followed by the 18 remaining items. The first item is the first key, the second item is the first value, the third item is the second key, and so on. Because items in a map come in pairs, their total number is always even: a map that contains an odd number of items (no value data present after the last key data item) is not well-formed. A map that has duplicate keys may be well-formed, but it is not valid, and thus it causes indeterminate decoding; see also Section 5.6.",
      "ja": "メジャー タイプ 5: データ項目のペアのマップ。マップは、テーブル、辞書、ハッシュ、またはオブジェクト (JSON では) とも呼ばれます。マップはデータ項目のペアで構成され、各ペアはキーとその直後の値で構成されます。引数は、マップ内のデータ項目の _ペア_ の数です。たとえば、9 ペアを含むマップの場合、最初のバイトは 0b101_01001 (メジャー タイプ 5、ペアの数の追加情報 9) で、その後に残りの 18 個の項目が続きます。最初の項目は最初のキー、2 番目の項目は最初の値、3 番目の項目は 2 番目のキー、というようになります。マップ内の項目はペアになっているため、その合計数は常に偶数です。つまり、奇数の項目を含むマップ (最後のキー データ項目の後に値データが存在しない) は整形式ではありません。重複するキーを持つマップは整形式である可能性がありますが、有効ではないため、不確定なデコードが発生します。セクション5.6も参照してください。"
    },
    {
      "indent": 3,
      "text": "Major type 6: A tagged data item (\"tag\") whose tag number, an integer in the range 0..2^(64)-1 inclusive, is the argument and whose enclosed data item (_tag content_) is the single encoded data item that follows the head. See Section 3.4.",
      "ja": "メジャータイプ6: タグ付きデータ項目（「タグ」）で、タグ番号（0..2^(64)-1の範囲の整数）が引数となり、その囲まれたデータ項目（タグコンテンツ）がヘッドに続く単一のエンコードされたデータ項目となります。セクション3.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Major type 7: Floating-point numbers and simple values, as well as the \"break\" stop code. See Section 3.3.",
      "ja": "メジャータイプ7: 浮動小数点数と単純な値、および「break」停止コード。セクション3.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "These eight major types lead to a simple table showing which of the 256 possible values for the initial byte of a data item are used (Table 7).",
      "ja": "これら8つのメジャータイプは、データ項目の初期バイトの256個の可能な値のどれを使用するかを示す単純なテーブルをもたらします（表7）。"
    },
    {
      "indent": 3,
      "text": "In major types 6 and 7, many of the possible values are reserved for future specification. See Section 9 for more information on these values.",
      "ja": "主なタイプ6および7では、可能な値の多くは将来の仕様のために予約されています。これらの値の詳細についてはセクション9を参照してください。"
    },
    {
      "indent": 3,
      "text": "Table 1 summarizes the major types defined by CBOR, ignoring Section 3.2 for now. The number N in this table stands for the argument.",
      "ja": "表1は、CBORによって定義された主要な型をまとめており、今のともにセクション3.2を無視します。このテーブルの数nは引数を表します。"
    },
    {
      "indent": 5,
      "text": "+============+=======================+=========================+\n| Major Type | Meaning               | Content                 |\n+============+=======================+=========================+\n| 0          | unsigned integer N    | -                       |\n+------------+-----------------------+-------------------------+\n| 1          | negative integer -1-N | -                       |\n+------------+-----------------------+-------------------------+\n| 2          | byte string           | N bytes                 |\n+------------+-----------------------+-------------------------+\n| 3          | text string           | N bytes (UTF-8 text)    |\n+------------+-----------------------+-------------------------+\n| 4          | array                 | N data items (elements) |\n+------------+-----------------------+-------------------------+\n| 5          | map                   | 2N data items (key/     |\n|            |                       | value pairs)            |\n+------------+-----------------------+-------------------------+\n| 6          | tag of number N       | 1 data item             |\n+------------+-----------------------+-------------------------+\n| 7          | simple/float          | -                       |\n+------------+-----------------------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Table 1: Overview over the Definite-Length Use of CBOR Major Types (N = Argument)",
      "ja": "表1：CBORメジャータイプの明確な長さの使用上の概要（n =引数）"
    },
    {
      "indent": 0,
      "text": "3.2. Indefinite Lengths for Some Major Types",
      "section_title": true,
      "ja": "3.2. いくつかの主要な型のための不定長"
    },
    {
      "indent": 3,
      "text": "Four CBOR items (arrays, maps, byte strings, and text strings) can be encoded with an indefinite length using additional information value 31. This is useful if the encoding of the item needs to begin before the number of items inside the array or map, or the total length of the string, is known. (The ability to start sending a data item before all of it is known is often referred to as \"streaming\" within that data item.)",
      "ja": "4つのCBOR項目（アレイ、マップ、バイト文字列、テキスト文字列）は、追加情報値31を使用して不定長でエンコードできます。、または文字列の全長が知られています。（データ項目の送信を開始する機能は、そのデータ項目内の「ストリーミング」と呼ばれることがよくあります。）"
    },
    {
      "indent": 3,
      "text": "Indefinite-length arrays and maps are dealt with differently than indefinite-length strings (byte strings and text strings).",
      "ja": "無期限の長さの配列とマップは、不定数の文字列（バイト文字列とテキスト文字列）とは異なる方法で扱われます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. The \"break\" Stop Code",
      "section_title": true,
      "ja": "3.2.1. 「ブレーク」の停止コードを停止します"
    },
    {
      "indent": 3,
      "text": "The \"break\" stop code is encoded with major type 7 and additional information value 31 (0b111_11111). It is not itself a data item: it is just a syntactic feature to close an indefinite-length item.",
      "ja": "「ブレーク」停止コードは、メジャータイプ7と追加情報値31（0b111_11111）でエンコードされています。それ自体ではありませんデータ項目：それは無期限の項目を閉じるための構文的な機能です。"
    },
    {
      "indent": 3,
      "text": "If the \"break\" stop code appears where a data item is expected, other than directly inside an indefinite-length string, array, or map -- for example, directly inside a definite-length array or map -- the enclosing item is not well-formed.",
      "ja": "データ項目が予想される「ブレーク」の停止コードが表示されている場合、データ項目が不定の長さの文字列、配列、またはマップの内側には、直接指定された長さのアレイまたはマップの中にある - 囲みアイテムはそうではありません。よく形成された。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Indefinite-Length Arrays and Maps",
      "section_title": true,
      "ja": "3.2.2. 無期限の配列とマップ"
    },
    {
      "indent": 3,
      "text": "Indefinite-length arrays and maps are represented using their major type with the additional information value of 31, followed by an arbitrary-length sequence of zero or more items for an array or key/ value pairs for a map, followed by the \"break\" stop code (Section 3.2.1). In other words, indefinite-length arrays and maps look identical to other arrays and maps except for beginning with the additional information value of 31 and ending with the \"break\" stop code.",
      "ja": "無期限の配列およびマップは、それらの主要なタイプを使用して、31の追加情報値31を使用して表現され、続いてマップのためのアレイまたはキー/値のペアの任意の長さの順序が続いて、その後に「ブレーク」が続きます。停止コード（セクション3.2.1）。言い換えれば、不定長の配列とマップは、31の追加情報値31から始まり「ブレーク」停止コードで終わることを除いて、他の配列とマップと同じように見えます。"
    },
    {
      "indent": 3,
      "text": "If the \"break\" stop code appears after a key in a map, in place of that key's value, the map is not well-formed.",
      "ja": "マップ内のキーの後に「ブレーク」の停止コードが表示された場合、そのキーの値の代わりにマップは整形式ではありません。"
    },
    {
      "indent": 3,
      "text": "There is no restriction against nesting indefinite-length array or map items. A \"break\" only terminates a single item, so nested indefinite-length items need exactly as many \"break\" stop codes as there are type bytes starting an indefinite-length item.",
      "ja": "不定長の配列やマップ項目のネストに制限はありません。「ブレーク」は単一の項目のみを終了するため、定義長さの項目を開始するタイプバイトがあるため、ネストされた不定長さの項目は正確に「ブレーク」の停止コードを必要とします。"
    },
    {
      "indent": 3,
      "text": "For example, assume an encoder wants to represent the abstract array [1, [2, 3], [4, 5]]. The definite-length encoding would be 0x8301820203820405:",
      "ja": "例えば、エンコーダが抽象配列[1, [2, 3], [4, 5]]を表現したいとします。固定長エンコードは0x8301820203820405となります。"
    },
    {
      "indent": 0,
      "text": "83        -- Array of length 3\n   01     -- 1\n   82     -- Array of length 2\n      02  -- 2\n      03  -- 3\n   82     -- Array of length 2\n      04  -- 4\n      05  -- 5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Indefinite-length encoding could be applied independently to each of the three arrays encoded in this data item, as required, leading to representations such as:",
      "ja": "不定長エンコーディングは、必要に応じて、このデータ項目にエンコードされた 3 つの配列のそれぞれに個別に適用でき、次のような表現になります。"
    },
    {
      "indent": 0,
      "text": "0x9f018202039f0405ffff\n9F        -- Start indefinite-length array\n   01     -- 1\n   82     -- Array of length 2\n      02  -- 2\n      03  -- 3\n   9F     -- Start indefinite-length array\n      04  -- 4\n      05  -- 5\n      FF  -- \"break\" (inner array)\n   FF     -- \"break\" (outer array)\n0x9f01820203820405ff\n9F        -- Start indefinite-length array\n   01     -- 1\n   82     -- Array of length 2\n      02  -- 2\n      03  -- 3\n   82     -- Array of length 2\n      04  -- 4\n      05  -- 5\n   FF     -- \"break\"\n0x83018202039f0405ff\n83        -- Array of length 3\n   01     -- 1\n   82     -- Array of length 2\n      02  -- 2\n      03  -- 3\n   9F     -- Start indefinite-length array\n      04  -- 4\n      05  -- 5\n      FF  -- \"break\"\n0x83019f0203ff820405\n83        -- Array of length 3\n   01     -- 1\n   9F     -- Start indefinite-length array\n      02  -- 2\n      03  -- 3\n      FF  -- \"break\"\n   82     -- Array of length 2\n      04  -- 4\n      05  -- 5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An example of an indefinite-length map (that happens to have two key/ value pairs) might be:",
      "ja": "無期限の長さのマップの例（それは2つのキー/値のペアを持つことが起こる）かもしれません："
    },
    {
      "indent": 0,
      "text": "0xbf6346756ef563416d7421ff\nBF           -- Start indefinite-length map\n   63        -- First key, UTF-8 string length 3\n      46756e --   \"Fun\"\n   F5        -- First value, true\n   63        -- Second key, UTF-8 string length 3\n      416d74 --   \"Amt\"\n   21        -- Second value, -2\n   FF        -- \"break\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.3. Indefinite-Length Byte Strings and Text Strings",
      "section_title": true,
      "ja": "3.2.3. 無期限長バイト文字列とテキスト文字列"
    },
    {
      "indent": 3,
      "text": "Indefinite-length strings are represented by a byte containing the major type for byte string or text string with an additional information value of 31, followed by a series of zero or more strings of the specified type (\"chunks\") that have definite lengths, and finished by the \"break\" stop code (Section 3.2.1). The data item represented by the indefinite-length string is the concatenation of the chunks. If no chunks are present, the data item is an empty string of the specified type. Zero-length chunks, while not particularly useful, are permitted.",
      "ja": "無期限の長さの文字列は、追加の情報値31を持つバイト文字列またはテキスト文字列のメジャータイプを含むバイトによって表され、その後に明確な長さを持つ指定されたタイプの一連の0個以上の文字列（ \"Chunks\"）が続きます。そして「ブレーク」の停止コード（セクション3.2.1）によって終了しました。不定長文字列で表されるデータ項目は、チャンクの連結です。チャンクが存在しない場合、データ項目は指定されたタイプの空の文字列です。長さゼロのチャンクは、特に有用ではないが許可されています。"
    },
    {
      "indent": 3,
      "text": "If any item between the indefinite-length string indicator (0b010_11111 or 0b011_11111) and the \"break\" stop code is not a definite-length string item of the same major type, the string is not well-formed.",
      "ja": "不定長文字列インジケータ（0B010_111111または0B011_1111）と「ブレーク」停止コードの間の項目が同じメジャータイプの明確な長さの文字列項目ではない場合、文字列は適切に形成されません。"
    },
    {
      "indent": 3,
      "text": "The design does not allow nesting indefinite-length strings as chunks into indefinite-length strings. If it were allowed, it would require decoder implementations to keep a stack, or at least a count, of nesting levels. It is unnecessary on the encoder side because the inner indefinite-length string would consist of chunks, and these could instead be put directly into the outer indefinite-length string.",
      "ja": "デザインは、不定長の文字列をチャンクとして不定長の文字列にネストすることはできません。許可されている場合は、スターン、または少なくともカウントをネスティングレベルに保つためにデコーダ実装が必要になります。エンコーダ側には不要です。"
    },
    {
      "indent": 3,
      "text": "If any definite-length text string inside an indefinite-length text string is invalid, the indefinite-length text string is invalid. Note that this implies that the UTF-8 bytes of a single Unicode code point (scalar value) cannot be spread between chunks: a new chunk of a text string can only be started at a code point boundary.",
      "ja": "無定限のテキスト文字列内の明確な長さのテキスト文字列が無効な場合は、不定長テキスト文字列が無効です。これは、単一のUnicodeコードポイント（スカラー値）のUTF-8バイトをチャンク間で拡散できないことを意味します。テキスト文字列の新しいチャンクは、コードポイント境界でのみ開始できます。"
    },
    {
      "indent": 3,
      "text": "For example, assume an encoded data item consisting of the bytes:",
      "ja": "たとえば、バイトからなるエンコードされたデータ項目を仮定します。"
    },
    {
      "indent": 0,
      "text": "0b010_11111 0b010_00100 0xaabbccdd 0b010_00011 0xeeff99 0b111_11111\n5F              -- Start indefinite-length byte string\n   44           -- Byte string of length 4\n      aabbccdd  -- Bytes content\n   43           -- Byte string of length 3\n      eeff99    -- Bytes content\n   FF           -- \"break\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "After decoding, this results in a single byte string with seven bytes: 0xaabbccddeeff99.",
      "ja": "デコード後、これにより7バイトの1バイト文字列が発生します.0xaabbccdeeff99。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Summary of Indefinite-Length Use of Major Types",
      "section_title": true,
      "ja": "3.2.4. 大型タイプの長さの概要"
    },
    {
      "indent": 3,
      "text": "Table 2 summarizes the major types defined by CBOR as used for indefinite-length encoding (with additional information set to 31).",
      "ja": "表2は、不定長の符号化に使用されるCBORによって定義された主要な型（追加情報を31に設定されている）を要約しています。"
    },
    {
      "indent": 3,
      "text": "+============+===================+==================================+\n| Major Type | Meaning           | Enclosed up to \"break\" Stop Code |\n+============+===================+==================================+\n| 0          | (not well-        | -                                |\n|            | formed)           |                                  |\n+------------+-------------------+----------------------------------+\n| 1          | (not well-        | -                                |\n|            | formed)           |                                  |\n+------------+-------------------+----------------------------------+\n| 2          | byte string       | definite-length byte strings     |\n+------------+-------------------+----------------------------------+\n| 3          | text string       | definite-length text strings     |\n+------------+-------------------+----------------------------------+\n| 4          | array             | data items (elements)            |\n+------------+-------------------+----------------------------------+\n| 5          | map               | data items (key/value pairs)     |\n+------------+-------------------+----------------------------------+\n| 6          | (not well-        | -                                |\n|            | formed)           |                                  |\n+------------+-------------------+----------------------------------+\n| 7          | \"break\" stop      | -                                |\n|            | code              |                                  |\n+------------+-------------------+----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Table 2: Overview of the Indefinite-Length Use of CBOR Major Types (Additional Information = 31)",
      "ja": "表2：CBORの長さの長さの使用の概要（追加情報= 31）"
    },
    {
      "indent": 0,
      "text": "3.3. Floating-Point Numbers and Values with No Content",
      "section_title": true,
      "ja": "3.3. 浮動小数点数とコンテンツなしの値"
    },
    {
      "indent": 3,
      "text": "Major type 7 is for two types of data: floating-point numbers and \"simple values\" that do not need any content. Each value of the 5-bit additional information in the initial byte has its own separate meaning, as defined in Table 3. Like the major types for integers, items of this major type do not carry content data; all the information is in the initial bytes (the head).",
      "ja": "メジャータイプ7は、浮動小数点数と「単純な値」を必要としない2種類のデータです。初期バイト内の5ビット付加情報の各値には、表3で定義されているように、独自の個別の意味があります。整数のメジャータイプと同様に、このメジャータイプの項目はコンテンツデータを搬送しません。すべての情報は初期バイト（頭）にあります。"
    },
    {
      "indent": 4,
      "text": "+=============+===================================================+\n| 5-Bit Value | Semantics                                         |\n+=============+===================================================+\n| 0..23       | Simple value (value 0..23)                        |\n+-------------+---------------------------------------------------+\n| 24          | Simple value (value 32..255 in following byte)    |\n+-------------+---------------------------------------------------+\n| 25          | IEEE 754 Half-Precision Float (16 bits follow)    |\n+-------------+---------------------------------------------------+\n| 26          | IEEE 754 Single-Precision Float (32 bits follow)  |\n+-------------+---------------------------------------------------+\n| 27          | IEEE 754 Double-Precision Float (64 bits follow)  |\n+-------------+---------------------------------------------------+\n| 28-30       | Reserved, not well-formed in the present document |\n+-------------+---------------------------------------------------+\n| 31          | \"break\" stop code for indefinite-length items     |\n|             | (Section 3.2.1)                                   |\n+-------------+---------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Table 3: Values for Additional Information in Major Type 7",
      "ja": "表3：メジャータイプ7の追加情報の値"
    },
    {
      "indent": 3,
      "text": "As with all other major types, the 5-bit value 24 signifies a single-byte extension: it is followed by an additional byte to represent the simple value. (To minimize confusion, only the values 32 to 255 are used.) This maintains the structure of the initial bytes: as for the other major types, the length of these always depends on the additional information in the first byte. Table 4 lists the numeric values assigned and available for simple values.",
      "ja": "他のすべてのメジャータイプと同様に、5ビット値24は1バイトの拡張子を意味します。単純な値を表すために追加のバイトが続きます。（混乱を最小限に抑えるために、値32~255のみが使用されます。）これは初期バイトの構造を維持します。他のメジャータイプに関しては、これらの長さは常に最初のバイト内の追加情報に依存します。表4に、単純な値に割り当てられ、使用可能な数値値を示します。"
    },
    {
      "indent": 24,
      "text": "+=========+==============+\n| Value   | Semantics    |\n+=========+==============+\n| 0..19   | (unassigned) |\n+---------+--------------+\n| 20      | false        |\n+---------+--------------+\n| 21      | true         |\n+---------+--------------+\n| 22      | null         |\n+---------+--------------+\n| 23      | undefined    |\n+---------+--------------+\n| 24..31  | (reserved)   |\n+---------+--------------+\n| 32..255 | (unassigned) |\n+---------+--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Table 4: Simple Values",
      "ja": "表4：単純な値"
    },
    {
      "indent": 3,
      "text": "An encoder MUST NOT issue two-byte sequences that start with 0xf8 (major type 7, additional information 24) and continue with a byte less than 0x20 (32 decimal). Such sequences are not well-formed. (This implies that an encoder cannot encode \"false\", \"true\", \"null\", or \"undefined\" in two-byte sequences and that only the one-byte variants of these are well-formed; more generally speaking, each simple value only has a single representation variant).",
      "ja": "エンコーダは、0xF8（メジャータイプ7、追加情報24）で始まり、0x20（10進数32）未満のバイトを続行する2バイトのシーケンスを発行してはなりません。そのような配列は十分に形成されていない。（これは、エンコーダが2バイトシーケンスで \"false\"、 \"true\"、 \"null\"、または \"undefined\"をエンコードできず、これらの1バイトのバリエーションのみが整形式です。一般的に言えば、それぞれの単純値は単一の表現バリアントのみを持ちます）。"
    },
    {
      "indent": 3,
      "text": "The 5-bit values of 25, 26, and 27 are for 16-bit, 32-bit, and 64-bit IEEE 754 binary floating-point values [IEEE754]. These floating-point values are encoded in the additional bytes of the appropriate size. (See Appendix D for some information about 16-bit floating-point numbers.)",
      "ja": "25,26、および27の5ビット値は、16ビット、32ビット、および64ビットIEEE 754バイナリ浮動小数点値[IEEE754]です。これらの浮動小数点値は、適切なサイズの追加バイトに符号化されています。（16ビット浮動小数点数に関する情報については、付録Dを参照してください。）"
    },
    {
      "indent": 0,
      "text": "3.4. Tagging of Items",
      "section_title": true,
      "ja": "3.4. アイテムのタグ付け"
    },
    {
      "indent": 3,
      "text": "In CBOR, a data item can be enclosed by a tag to give it some additional semantics, as uniquely identified by a _tag number_. The tag is major type 6, its argument (Section 3) indicates the tag number, and it contains a single enclosed data item, the _tag content_. (If a tag requires further structure to its content, this structure is provided by the enclosed data item.) We use the term _tag_ for the entire data item consisting of both a tag number and the tag content: the tag content is the data item that is being tagged.",
      "ja": "CBORでは、データ項目をタグで囲むことができ、_tag number_によって一意に識別されているように、追加のセマンティクスを与えることができます。タグはメジャータイプ6で、その引数（セクション3）はタグ番号を示し、単一の囲まれたデータ項目、_tag content_を含みます。（タグがその内容にさらなる構造を必要とする場合、この構造は囲まれたデータ項目によって提供されます。）タグ番号とタグの内容の両方からなる全データ項目について_tag_という用語を使用します。タグの内容はデータ項目です。それはタグ付けされています。"
    },
    {
      "indent": 3,
      "text": "For example, assume that a byte string of length 12 is marked with a tag of number 2 to indicate it is an unsigned _bignum_ (Section 3.4.3). The encoded data item would start with a byte 0b110_00010 (major type 6, additional information 2 for the tag number) followed by the encoded tag content: 0b010_01100 (major type 2, additional information 12 for the length) followed by the 12 bytes of the bignum.",
      "ja": "たとえば、長さ12のバイト文字列には、それが符号なし_bignum_であることを示すための番号2のタグでマークされているとします（セクション3.4.3）。エンコードされたデータ項目は、バイト0B110_00010（メジャータイプ6、タグ番号の追加情報2）から始まり、その後にエンコードされたタグの内容が続き、次のような符号化タグの内容が続きます。ビグナム。"
    },
    {
      "indent": 3,
      "text": "In the extended generic data model, a tag number's definition describes the additional semantics conveyed with the tag number. These semantics may include equivalence of some tagged data items with other data items, including some that can be represented in the basic generic data model. For instance, 0xc24101, a bignum the tag content of which is the byte string with the single byte 0x01, is equivalent to an integer 1, which could also be encoded as 0x01, 0x1801, or 0x190001. The tag definition may specify a preferred serialization (Section 4.1) that is recommended for generic encoders; this may prefer basic generic data model representations over ones that employ a tag.",
      "ja": "拡張汎用データモデルでは、タグ番号の定義は、タグ番号で伝達された追加のセマンティクスを記述します。これらのセマンティクスは、基本的な一般データモデルで表すことができるものを含む、他のデータ項目を含むタグ付きデータ項目の等価性を含み得る。たとえば、0xC24101は、1バイト0x01を持つバイト文字列であるBignumが整数1と同じです。これは、0x01、0x1801、または0x190001として符号化することもできます。タグ定義は、一般的なエンコーダに推奨される優先シリアル化（セクション4.1）を指定できます。これは、タグを使用するものよりも基本的な一般的なデータモデル表現を望むかもしれません。"
    },
    {
      "indent": 3,
      "text": "The tag definition usually defines which nested data items are valid for such tags. Tag definitions may restrict their content to a very specific syntactic structure, as the tags defined in this document do, or they may define their content more semantically. An example for the latter is how tags 40 and 1040 accept multiple ways to represent arrays [RFC8746].",
      "ja": "タグ定義は通常、どのネストされたデータ項目がそのようなタグに対して有効であるかを定義します。タグ定義は、このドキュメントで定義されているタグが実行されているため、そのコンテンツをより意味的に定義することができるため、そのコンテンツを非常に特定の構文構造に制限することができます。後者の例は、タグ40と1040が配列を表すための複数の方法をどのように受け入れるかです[RFC8746]。"
    },
    {
      "indent": 3,
      "text": "As a matter of convention, many tags do not accept \"null\" or \"undefined\" values as tag content; instead, the expectation is that a \"null\" or \"undefined\" value can be used in place of the entire tag; Section 3.4.2 provides some further considerations for one specific tag about the handling of this convention in application protocols and in mapping to platform types.",
      "ja": "慣例の問題として、多くのタグはタグ内容として「NULL」または「未定義」の値を受け入れない。代わりに、予想はタグ全体の代わりに「NULL」または「未定義」の値を使用できることです。セクション3.4.2は、アプリケーションプロトコルのこの規約の処理とプラットフォームタイプへのマッピングに関する1つの特定のタグについて、さらに考慮しています。"
    },
    {
      "indent": 3,
      "text": "Decoders do not need to understand tags of every tag number, and tags may be of little value in applications where the implementation creating a particular CBOR data item and the implementation decoding that stream know the semantic meaning of each item in the data flow. The primary purpose of tags in this specification is to define common data types such as dates. A secondary purpose is to provide conversion hints when it is foreseen that the CBOR data item needs to be translated into a different format, requiring hints about the content of items. Understanding the semantics of tags is optional for a decoder; it can simply present both the tag number and the tag content to the application, without interpreting the additional semantics of the tag.",
      "ja": "デコーダはすべてのタグ番号のタグを理解する必要はなく、タグは実装が特定のCBORデータ項目を作成するアプリケーションとデータフローの各項目の意味的意味を知っている実装を復号するアプリケーションでは小さい場合があります。本明細書のタグの主な目的は、日付などの共通のデータ型を定義することです。セカンダリの目的は、CBORデータ項目が異なるフォーマットに変換される必要があると予測しているときに変換ヒントを提供することで、アイテムの内容に関するヒントが必要です。タグのセマンティクスを理解することは、デコーダのオプションです。タグの追加のセマンティクスを解釈することなく、タグ番号とタグの内容の両方をアプリケーションに提示できます。"
    },
    {
      "indent": 3,
      "text": "A tag applies semantics to the data item it encloses. Tags can nest: if tag A encloses tag B, which encloses data item C, tag A applies to the result of applying tag B on data item C.",
      "ja": "タグはそれが囲むデータ項目に意味論を適用します。タグはネストすることができます：タグAがデータ項目Cを囲むタグBを囲む場合、タグAはデータ項目C上でタグBを適用した結果に適用される。"
    },
    {
      "indent": 3,
      "text": "IANA maintains a registry of tag numbers as described in Section 9.2. Table 5 provides a list of tag numbers that were defined in [RFC7049] with definitions in the rest of this section. (Tag number 35 was also defined in [RFC7049]; a discussion of this tag number follows in Section 3.4.5.3.) Note that many other tag numbers have been defined since the publication of [RFC7049]; see the registry described at Section 9.2 for the complete list.",
      "ja": "IANAは、セクション9.2に記載されているようにタグ番号のレジストリを維持しています。表5に、このセクションの残りの部分で定義を定義して[RFC7049]で定義されたタグ番号のリストを示します。（タグ番号35は[RFC7049]でも定義されています。このタグ番号の説明は3.4.5.3項に続きます。）[RFC7049]の公開以来、他の多くのタグ番号が定義されています。完全なリストについては、セクション9.2で説明されているレジストリを参照してください。"
    },
    {
      "indent": 8,
      "text": "+=======+=============+==================================+\n| Tag   | Data Item   | Semantics                        |\n+=======+=============+==================================+\n| 0     | text string | Standard date/time string; see   |\n|       |             | Section 3.4.1                    |\n+-------+-------------+----------------------------------+\n| 1     | integer or  | Epoch-based date/time; see       |\n|       | float       | Section 3.4.2                    |\n+-------+-------------+----------------------------------+\n| 2     | byte string | Unsigned bignum; see             |\n|       |             | Section 3.4.3                    |\n+-------+-------------+----------------------------------+\n| 3     | byte string | Negative bignum; see             |\n|       |             | Section 3.4.3                    |\n+-------+-------------+----------------------------------+\n| 4     | array       | Decimal fraction; see            |\n|       |             | Section 3.4.4                    |\n+-------+-------------+----------------------------------+\n| 5     | array       | Bigfloat; see Section 3.4.4      |\n+-------+-------------+----------------------------------+\n| 21    | (any)       | Expected conversion to base64url |\n|       |             | encoding; see Section 3.4.5.2    |\n+-------+-------------+----------------------------------+\n| 22    | (any)       | Expected conversion to base64    |\n|       |             | encoding; see Section 3.4.5.2    |\n+-------+-------------+----------------------------------+\n| 23    | (any)       | Expected conversion to base16    |\n|       |             | encoding; see Section 3.4.5.2    |\n+-------+-------------+----------------------------------+\n| 24    | byte string | Encoded CBOR data item; see      |\n|       |             | Section 3.4.5.1                  |\n+-------+-------------+----------------------------------+\n| 32    | text string | URI; see Section 3.4.5.3         |\n+-------+-------------+----------------------------------+\n| 33    | text string | base64url; see Section 3.4.5.3   |\n+-------+-------------+----------------------------------+\n| 34    | text string | base64; see Section 3.4.5.3      |\n+-------+-------------+----------------------------------+\n| 36    | text string | MIME message; see                |\n|       |             | Section 3.4.5.3                  |\n+-------+-------------+----------------------------------+\n| 55799 | (any)       | Self-described CBOR; see         |\n|       |             | Section 3.4.6                    |\n+-------+-------------+----------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 5: Tag Numbers Defined in RFC 7049",
      "ja": "表5：RFC 7049で定義されているタグ番号"
    },
    {
      "indent": 3,
      "text": "Conceptually, tags are interpreted in the generic data model, not at (de-)serialization time. A small number of tags (at this time, tag number 25 and tag number 29 [IANA.cbor-tags]) have been registered with semantics that may require processing at (de-)serialization time: the decoder needs to be aware of, and the encoder needs to be in control of, the exact sequence in which data items are encoded into the CBOR data item. This means these tags cannot be implemented on top of an arbitrary generic CBOR encoder/decoder (which might not reflect the serialization order for entries in a map at the data model level and vice versa); their implementation therefore typically needs to be integrated into the generic encoder/decoder. The definition of new tags with this property is NOT RECOMMENDED.",
      "ja": "概念的には、タグは汎用データモデルで解釈されます。（現時点ではタグ番号25とタグ番号29 [IANA.CBOR-TAGS]）が少数のタグで、（DE-）シリアライゼーション時間で処理することができるセマンティクスに登録されています。デコーダは、注意する必要があります。そして、エンコーダは、データ項目がCBORデータ項目にエンコードされている正確なシーケンスを制御する必要がある。これは、これらのタグを任意の一般的なCBORエンコーダ/デコーダの上に実装できないことを意味します（これはデータモデルレベルでのマップ内のエントリのシリアル化順序を反映していない可能性があります）。したがって、それらの実装は通常、一般的なエンコーダ/デコーダに統合される必要がある。このプロパティを使用した新しいタグの定義はお勧めできません。"
    },
    {
      "indent": 3,
      "text": "IANA allocated tag numbers 65535, 4294967295, and 18446744073709551615 (binary all-ones in 16-bit, 32-bit, and 64-bit). These can be used as a convenience for implementers who want a single-integer data structure to indicate either the presence of a specific tag or absence of a tag. That allocation is described in Section 10 of [CBOR-TAGS]. These tags are not intended to occur in actual CBOR data items; implementations MAY flag such an occurrence as an error.",
      "ja": "IANA割り当てタグ番号65535,4294967295、および18446744073709551615（16ビット、32ビット、64ビット）。これらは、単一整数データ構造がタグの特定のタグの存在またはタグの存在のいずれかを示すことを望んでいる実装者の利便性として使用できます。その割り当ては[CBOBOR-TAG]の第10章で説明されています。これらのタグは実際のCBORデータ項目で発生することを意図していません。実装は、そのような発生にエラーとしてフラグを立てるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Protocols can extend the generic data model (Section 2) with data items representing points in time by using tag numbers 0 and 1, with arbitrarily sized integers by using tag numbers 2 and 3, and with floating-point values of arbitrary size and precision by using tag numbers 4 and 5.",
      "ja": "タグ番号0および1を使用して、タグ番号0および3を使用して任意のサイズと精度の浮動小数点値を用いて、任意のサイズの整数を用いて、汎用データ項目を用いて汎用データモデル（セクション2）を延長することができる。タグ番号4と5を使用する。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Standard Date/Time String",
      "section_title": true,
      "ja": "3.4.1. 標準日時文字列"
    },
    {
      "indent": 3,
      "text": "Tag number 0 contains a text string in the standard format described by the \"date-time\" production in [RFC3339], as refined by Section 3.3 of [RFC4287], representing the point in time described there. A nested item of another type or a text string that doesn't match the format described in [RFC4287] is invalid.",
      "ja": "タグ番号0は、[RFC4287]の「RFC4287」の「日付 - 時刻」制作で説明されているテキスト文字列を含み、[RFC4287]のセクション3.3で表され、そこに記載されている時点を表します。[RFC4287]で説明されているフォーマットと一致しない別のタイプまたはテキスト文字列のネストされた項目は無効です。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Epoch-Based Date/Time",
      "section_title": true,
      "ja": "3.4.2. エポックベースの日時"
    },
    {
      "indent": 3,
      "text": "Tag number 1 contains a numerical value counting the number of seconds from 1970-01-01T00:00Z in UTC time to the represented point in civil time.",
      "ja": "タグ番号1には、ALTC時期のATC時刻の1970-01-01T00：00Zの秒数をカウントする数値が含まれています。"
    },
    {
      "indent": 3,
      "text": "The tag content MUST be an unsigned or negative integer (major types 0 and 1) or a floating-point number (major type 7 with additional information 25, 26, or 27). Other contained types are invalid.",
      "ja": "タグの内容は、符号なしまたは負の整数（メジャータイプ0と1）または浮動小数点数（追加情報25,26、または27を持つメジャータイプ7）でなければなりません。他の含有タイプは無効です。"
    },
    {
      "indent": 3,
      "text": "Nonnegative values (major type 0 and nonnegative floating-point numbers) stand for time values on or after 1970-01-01T00:00Z UTC and are interpreted according to POSIX [TIME_T]. (POSIX time is also known as \"UNIX Epoch time\".) Leap seconds are handled specially by POSIX time, and this results in a 1-second discontinuity several times per decade. Note that applications that require the expression of times beyond early 2106 cannot leave out support of 64-bit integers for the tag content.",
      "ja": "非負の値（メジャータイプ0と非負の浮動小数点数）は、1970-01-01T00：00Z UTCの時または後の時間値を表し、POSIX [time_t]に従って解釈されます。（POSIX時間は「UNIX EPOCH TIME」とも呼ばれます。）うるう秒はPOSIX時間によって特別に取り扱われ、これにより10年あたり数回1秒の不連続性が得られます。2106の初期を超えて発現を必要とするアプリケーションは、タグコンテンツのための64ビット整数のサポートを除外することができないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Negative values (major type 1 and negative floating-point numbers) are interpreted as determined by the application requirements as there is no universal standard for UTC count-of-seconds time before 1970-01-01T00:00Z (this is particularly true for points in time that precede discontinuities in national calendars). The same applies to non-finite values.",
      "ja": "負の値（メジャータイプ1および負の浮動小数点数）は、1970-01-01t00：00Zの常時常時普遍的な標準がないため、アプリケーション要件によって決定されたと解釈されます（これはポイントに特に当てはまります）。国家カレンダーの不連続性の前にある間。同じことが非有限値にも当てはまります。"
    },
    {
      "indent": 3,
      "text": "To indicate fractional seconds, floating-point values can be used within tag number 1 instead of integer values. Note that this generally requires binary64 support, as binary16 and binary32 provide nonzero fractions of seconds only for a short period of time around early 1970. An application that requires tag number 1 support may restrict the tag content to be an integer (or a floating-point value) only.",
      "ja": "小数秒を示すために、整数値の代わりにタグ番号1内で浮動小数点値を使用できます。Binary16およびBinary32は、1970年の初めに短期間の短期間のゼロ以外のフラクションを提供するため、これには一般にBinary64サポートが必要です。タグ番号1のサポートを必要とするアプリケーションは、タグの内容を整数（またはフローティング - ）に制限される可能性があります。ポイント値）のみ。"
    },
    {
      "indent": 3,
      "text": "Note that platform types for date/time may include \"null\" or \"undefined\" values, which may also be desirable at an application protocol level. While emitting tag number 1 values with non-finite tag content values (e.g., with NaN for undefined date/time values or with Infinity for an expiry date that is not set) may seem an obvious way to handle this, using untagged \"null\" or \"undefined\" avoids the use of non-finites and results in a shorter encoding. Application protocol designers are encouraged to consider these cases and include clear guidelines for handling them.",
      "ja": "日付/時刻のプラットフォームタイプには、「NULL」または「未定義」の値が含まれます。これは、アプリケーションプロトコルレベルでも望ましい場合があります。タグ番号1の値を非有限タグ内容値で発行している間（例えば、未定義の日付/時刻値の場合、または設定されていない有効期限の無限大との場合）は、タグなしの「null」を使用してこれを処理するための明らかな方法であるように思われる可能性があります。または「未定義」は、非有数の使用を回避し、短縮符号化をもたらす。アプリケーションプロトコル設計者は、これらのケースを検討することをお勧めし、それらを処理するための明確なガイドラインを含みます。"
    },
    {
      "indent": 0,
      "text": "3.4.3. Bignums",
      "section_title": true,
      "ja": "3.4.3. 巨大な整数"
    },
    {
      "indent": 3,
      "text": "Protocols using tag numbers 2 and 3 extend the generic data model (Section 2) with \"bignums\" representing arbitrarily sized integers. In the basic generic data model, bignum values are not equal to integers from the same model, but the extended generic data model created by this tag definition defines equivalence based on numeric value, and preferred serialization (Section 4.1) never makes use of bignums that also can be expressed as basic integers (see below).",
      "ja": "タグ番号2と3を使用したプロトコルは、任意のサイズの整数を表す「Bigrums」を備えた汎用データモデル（セクション2）を拡張します。基本的な一般的なデータモデルでは、Bignum値は同じモデルの整数と同じではありませんが、このタグ定義によって作成された拡張総データモデルは数値に基づいて等価性を定義し、優先シリアル化（セクション4.1）はBigrumsを使用することはありません。基本整数としても表現することもできます（下記参照）。"
    },
    {
      "indent": 3,
      "text": "Bignums are encoded as a byte string data item, which is interpreted as an unsigned integer n in network byte order. Contained items of other types are invalid. For tag number 2, the value of the bignum is n. For tag number 3, the value of the bignum is -1 - n. The preferred serialization of the byte string is to leave out any leading zeroes (note that this means the preferred serialization for n = 0 is the empty byte string, but see below). Decoders that understand these tags MUST be able to decode bignums that do have leading zeroes. The preferred serialization of an integer that can be represented using major type 0 or 1 is to encode it this way instead of as a bignum (which means that the empty string never occurs in a bignum when using preferred serialization). Note that this means the non-preferred choice of a bignum representation instead of a basic integer for encoding a number is not intended to have application semantics (just as the choice of a longer basic integer representation than needed, such as 0x1800 for 0x00, does not).",
      "ja": "Bignumsはバイト文字列データ項目としてエンコードされます。これは、ネットワークバイト順に符号なし整数nとして解釈されます。他の種類の含有項目は無効です。タグ番号2の場合、Bignumの値はnです。タグ番号3の場合、Bignumの値は-1  -  nです。バイト文字列の優先シリアル化は、先行ゼロを除外することです（つまり、n = 0の優先シリアル化は空のバイト文字列ですが、下記参照）。これらのタグを理解しているデコーダは、先頭のゼロを持つビグラムをデコードできる必要があります。メジャータイプ0または1を使用して表すことができる整数の好ましいシリアル化は、この方法ではなく、Bigrumとしてエンコードすることです（これは、優先シリアル化を使用するときには、空の文字列がBignumでは発生しないことを意味します）。これは、数値をエンコードするための基本整数の代わりにBignum表現の非優先選択を意味することに注意してください（0x00の場合は0x1800など、必要以上に長い基本整数表現の選択と同じように）アプリケーションセマンティクスを使用することを意図していません。そうではありません。"
    },
    {
      "indent": 3,
      "text": "For example, the number 18446744073709551616 (2^(64)) is represented as 0b110_00010 (major type 6, tag number 2), followed by 0b010_01001 (major type 2, length 9), followed by 0x010000000000000000 (one byte 0x01 and eight bytes 0x00). In hexadecimal:",
      "ja": "例えば、18446744073709551616 (2^(64)) という数値は、0b110_00010 (メジャータイプ 6、タグ番号 2)、続いて 0b010_01001 (メジャータイプ 2、長さ 9)、続いて 0x010000000000000000 (1バイト 0x01、8バイト 0x00) として表されます。16進数では以下のようになります。"
    },
    {
      "indent": 0,
      "text": "C2                        -- Tag 2\n   49                     -- Byte string of length 9\n      010000000000000000  -- Bytes content",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.4.4. Decimal Fractions and Bigfloats",
      "section_title": true,
      "ja": "3.4.4. 10進数とビッグフロート"
    },
    {
      "indent": 3,
      "text": "Protocols using tag number 4 extend the generic data model with data items representing arbitrary-length decimal fractions of the form m*(10^(e)). Protocols using tag number 5 extend the generic data model with data items representing arbitrary-length binary fractions of the form m*(2^(e)). As with bignums, values of different types are not equal in the generic data model.",
      "ja": "タグ番号4を使用したプロトコルは、任意の長さの10進数を表すデータ項目をM *（10 ^（e））の任意の長さの小数分数を表す汎用データモデルを拡張します。タグ番号5を使用したプロトコルは、M *（2 ^（e））の任意の長さの2進数画分を表すデータ項目を使用して一般的なデータモデルを拡張します。バイ信号と同様に、さまざまなタイプの値は一般データモデルでは等しくありません。"
    },
    {
      "indent": 3,
      "text": "Decimal fractions combine an integer mantissa with a base-10 scaling factor. They are most useful if an application needs the exact representation of a decimal fraction such as 1.1 because there is no exact representation for many decimal fractions in binary floating-point representations.",
      "ja": "小数部は、整数仮数を基本10スケーリング係数と組み合わせます。アプリケーションが1.1のような小数点分数の正確な表現を必要とする場合、それらは最も便利です。"
    },
    {
      "indent": 3,
      "text": "\"Bigfloats\" combine an integer mantissa with a base-2 scaling factor. They are binary floating-point values that can exceed the range or the precision of the three IEEE 754 formats supported by CBOR (Section 3.3). Bigfloats may also be used by constrained applications that need some basic binary floating-point capability without the need for supporting IEEE 754.",
      "ja": "「BigFloats」は、整数仮数をBASE-2スケーリングファクタと組み合わせます。それらは、CBORでサポートされている3つのIEEE 754フォーマットの範囲または精度を超えることができるバイナリ浮動小数点値です。BigFloatは、IEEE 754をサポートする必要なしに、いくつかの基本的なバイナリ浮動小数点機能を必要とする制約付きアプリケーションによっても使用され得る。"
    },
    {
      "indent": 3,
      "text": "A decimal fraction or a bigfloat is represented as a tagged array that contains exactly two integer numbers: an exponent e and a mantissa m. Decimal fractions (tag number 4) use base-10 exponents; the value of a decimal fraction data item is m*(10^(e)). Bigfloats (tag number 5) use base-2 exponents; the value of a bigfloat data item is m*(2^(e)). The exponent e MUST be represented in an integer of major type 0 or 1, while the mantissa can also be a bignum (Section 3.4.3). Contained items with other structures are invalid.",
      "ja": "小数点数またはbigFloatは、指数eと仮数a mを正確に2つ含むタグ付きアレイとして表されます。10進数の画分（タグ番号4）基本10の指数を使用します。小数分数データ項目の値はm *（10 ^（e））です。bigfloats（タグ番号5）base-2指数を使用します。BigFloatデータ項目の値はm *（2 ^（e））です。指数eは、マンシサもBigrumでもかまいませんが、メジャータイプ0または1の整数で表す必要があります（セクション3.4.3）。他の構造を持つ含有項目は無効です。"
    },
    {
      "indent": 3,
      "text": "An example of a decimal fraction is the representation of the number 273.15 as 0b110_00100 (major type 6 for tag, additional information 4 for the tag number), followed by 0b100_00010 (major type 4 for the array, additional information 2 for the length of the array), followed by 0b001_00001 (major type 1 for the first integer, additional information 1 for the value of -2), followed by 0b000_11001 (major type 0 for the second integer, additional information 25 for a two-byte value), followed by 0b0110101010110011 (27315 in two bytes). In hexadecimal:",
      "ja": "小数分数の例は、273.15としての数値273.15（タグ用のメジャータイプ6、タグ番号の追加情報4）、続いて0B100_00010（アレイのメジャータイプ4、その長さの追加情報2）の表現です。ARRAY）、続いて0B001_00001（最初の整数のメジャータイプ1、-2の追加情報1）、続いて0B000_11001（2番目の整数のメジャータイプ0、2バイト値の追加情報25）が続きます。（2バイトで27315）。16進数で："
    },
    {
      "indent": 0,
      "text": "C4             -- Tag 4\n   82          -- Array of length 2\n      21       -- -2\n      19 6ab3  -- 27315",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An example of a bigfloat is the representation of the number 1.5 as 0b110_00101 (major type 6 for tag, additional information 5 for the tag number), followed by 0b100_00010 (major type 4 for the array, additional information 2 for the length of the array), followed by 0b001_00000 (major type 1 for the first integer, additional information 0 for the value of -1), followed by 0b000_00011 (major type 0 for the second integer, additional information 3 for the value of 3). In hexadecimal:",
      "ja": "BigFloatの例は、0B110_00101としての数値1.5（タグのメジャータイプ6、タグ番号の追加情報5）の表現、その後に0B100_00010（アレイのメジャータイプ4、アレイの長さのための追加情報2）の表現です。）、0B001_00000（最初の整数のメジャータイプ1、-1のメジャータイプ1、-1の場合は追加情報0）、続いて0B000_00011（2番目の整数のメジャータイプ0、値3の追加情報3）が続きます。16進数で："
    },
    {
      "indent": 0,
      "text": "C5             -- Tag 5\n   82          -- Array of length 2\n      20       -- -1\n      03       -- 3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decimal fractions and bigfloats provide no representation of Infinity, -Infinity, or NaN; if these are needed in place of a decimal fraction or bigfloat, the IEEE 754 half-precision representations from Section 3.3 can be used.",
      "ja": "10進数とビッグフローは、無限大、 -  infinity、またはnanの表現を提供しません。これらが10進数分数またはBigFloatの代わりに必要な場合は、セクション3.3からのIEEE 754の半精度表現を使用できます。"
    },
    {
      "indent": 0,
      "text": "3.4.5. Content Hints",
      "section_title": true,
      "ja": "3.4.5. コンテンツのヒント"
    },
    {
      "indent": 3,
      "text": "The tags in this section are for content hints that might be used by generic CBOR processors. These content hints do not extend the generic data model.",
      "ja": "このセクションのタグは、一般的なCBOBORプロセッサによって使用される可能性があるコンテンツのヒント用です。これらのコンテンツのヒントは、一般的なデータモデルを拡張しません。"
    },
    {
      "indent": 0,
      "text": "3.4.5.1. Encoded CBOR Data Item",
      "section_title": true,
      "ja": "3.4.5.1. エンコードされたCBORデータ項目"
    },
    {
      "indent": 3,
      "text": "Sometimes it is beneficial to carry an embedded CBOR data item that is not meant to be decoded immediately at the time the enclosing data item is being decoded. Tag number 24 (CBOR data item) can be used to tag the embedded byte string as a single data item encoded in CBOR format. Contained items that aren't byte strings are invalid. A contained byte string is valid if it encodes a well-formed CBOR data item; validity checking of the decoded CBOR item is not required for tag validity (but could be offered by a generic decoder as a special option).",
      "ja": "囲まれたデータ項目が復号化されているときにすぐに復号化されることを意図していない組み込みのCBORデータを持ち込むことが有益であることがあります。タグ番号24（CBORデータ項目）を使用して、埋め込みバイト文字列をCBOBOR形式でエンコードされた単一のデータ項目としてタグ付けできます。バイト文字列のない含有項目は無効です。含有されているバイト文字列は、それが整形式のCBORデータ項目を符号化する場合に有効である。復号化されたCBOBOBOR項目の妥当性検査は、タグの有効性には必要ありません（ただし、特別なオプションとして一般的なデコーダによって提供される可能性があります）。"
    },
    {
      "indent": 0,
      "text": "3.4.5.2. Expected Later Encoding for CBOR-to-JSON Converters",
      "section_title": true,
      "ja": "3.4.5.2. CBOBOR-TO-JSONコンバーターのための符号化"
    },
    {
      "indent": 3,
      "text": "Tag numbers 21 to 23 indicate that a byte string might require a specific encoding when interoperating with a text-based representation. These tags are useful when an encoder knows that the byte string data it is writing is likely to be later converted to a particular JSON-based usage. That usage specifies that some strings are encoded as base64, base64url, and so on. The encoder uses byte strings instead of doing the encoding itself to reduce the message size, to reduce the code size of the encoder, or both. The encoder does not know whether or not the converter will be generic, and therefore wants to say what it believes is the proper way to convert binary strings to JSON.",
      "ja": "タグ番号21~23は、テキストベースの表現と相互運用されたときにバイト文字列が特定のエンコーディングを必要とする可能性があることを示す。これらのタグは、エンコーダが書き込まれているバイト文字列データが後で特定のJSONベースの使用に変換される可能性があることを知っている場合に役立ちます。その使用法は、いくつかの文字列がBase64、Base64URLなどとしてエンコードされていることを指定します。エンコーダは、エンコーディング自体を実行して、エンコーダのサイズを縮小し、エンコーダのコードサイズ、またはその両方を減らすのではなく、バイト文字列を使用します。エンコーダは、コンバータが一般的なものであるかどうかわからないため、バイナリ文字列をJSONに変換するための適切な方法であると考えています。"
    },
    {
      "indent": 3,
      "text": "The data item tagged can be a byte string or any other data item. In the latter case, the tag applies to all of the byte string data items contained in the data item, except for those contained in a nested data item tagged with an expected conversion.",
      "ja": "タグ付けされたデータ項目は、バイト文字列またはその他のデータ項目にすることができます。後者の場合、タグはデータ項目に含まれているすべてのバイト文字列データ項目に適用されます。"
    },
    {
      "indent": 3,
      "text": "These three tag numbers suggest conversions to three of the base data encodings defined in [RFC4648]. Tag number 21 suggests conversion to base64url encoding (Section 5 of [RFC4648]) where padding is not used (see Section 3.2 of [RFC4648]); that is, all trailing equals signs (\"=\") are removed from the encoded string. Tag number 22 suggests conversion to classical base64 encoding (Section 4 of [RFC4648]) with padding as defined in RFC 4648. For both base64url and base64, padding bits are set to zero (see Section 3.5 of [RFC4648]), and the conversion to alternate encoding is performed on the contents of the byte string (that is, without adding any line breaks, whitespace, or other additional characters). Tag number 23 suggests conversion to base16 (hex) encoding with uppercase alphabetics (see Section 8 of [RFC4648]). Note that, for all three tag numbers, the encoding of the empty byte string is the empty text string.",
      "ja": "これら3つのタグ番号は、[RFC4648]で定義されている3つの基本データエンコーディングに変換を提案します。タグ番号21は、PADDINGが使用されていないBase64URLエンコーディング（RFC4648]のセクション5）への変換を提案します（[RFC4648]のセクション3.2を参照）。つまり、末尾のすべての末尾は符号化された文字列から削除されます。タグ番号22は、RFC 4648で定義されているパディング付きのPADDINGを使用したClassical Base64エンコーディング（RFC4648]セクション4）への変換を提案します。Base64URLとBase64の両方で、パディングビットはゼロに設定されます（[RFC4648]のセクション3.5）、および変換代替のエンコードには、バイト文字列の内容（つまり、ラインブレーク、空白、または他の追加の文字を追加することなく）に対して実行されます。タグ番号23は、大文字のアルファベット社を使用したBase16（HEX）エンコーディングへの変換を提案します（[RFC4648]のセクション8を参照）。3つのタグ番号すべてについて、空のバイト文字列のエンコーディングは空のテキスト文字列です。"
    },
    {
      "indent": 0,
      "text": "3.4.5.3. Encoded Text",
      "section_title": true,
      "ja": "3.4.5.3. エンコードされたテキスト"
    },
    {
      "indent": 3,
      "text": "Some text strings hold data that have formats widely used on the Internet, and sometimes those formats can be validated and presented to the application in appropriate form by the decoder. There are tags for some of these formats.",
      "ja": "いくつかのテキスト文字列は、インターネット上で広く使用されているフォーマットを持つデータを保持し、そして時にはそれらのフォーマットを検証し、デコーダによって適切な形式でアプリケーションに提示することができる。これらのフォーマットのいくつかのタグがあります。"
    },
    {
      "indent": 3,
      "text": "* Tag number 32 is for URIs, as defined in [RFC3986]. If the text string doesn't match the \"URI-reference\" production, the string is invalid.",
      "ja": "* タグ番号32は、[RFC3986]で定義されているように、URI用です。テキスト文字列が「URI参照」プロダクションと一致しない場合、文字列は無効です。"
    },
    {
      "indent": 3,
      "text": "* Tag numbers 33 and 34 are for base64url- and base64-encoded text strings, respectively, as defined in [RFC4648]. If any of the following apply:",
      "ja": "* タグ番号33および34は、[RFC4648]で定義されているBase64URLおよびBase64エンコードテキスト文字列用です。次のいずれかが適用された場合："
    },
    {
      "indent": 6,
      "text": "- the encoded text string contains non-alphabet characters or only 1 alphabet character in the last block of 4 (where alphabet is defined by Section 5 of [RFC4648] for tag number 33 and Section 4 of [RFC4648] for tag number 34), or",
      "ja": "- エンコードされたテキスト文字列には、4つの最後のブロック内の文字以外の文字、または4つのアルファベット文字だけが含まれています（ここで、アルファベットはタグ番号33の[RFC4648]、[RFC4648]の[Tag Number 34のセクション4）、または"
    },
    {
      "indent": 6,
      "text": "- the padding bits in a 2- or 3-character block are not 0, or",
      "ja": "- 2文字または3文字のブロックのパディングビットは0、または"
    },
    {
      "indent": 6,
      "text": "- the base64 encoding has the wrong number of padding characters, or",
      "ja": "- Base64エンコーディングには間違った数のパディング文字があります。"
    },
    {
      "indent": 6,
      "text": "- the base64url encoding has padding characters,",
      "ja": "- Base64URLエンコーディングにはパディング文字があります。"
    },
    {
      "indent": 6,
      "text": "the string is invalid.",
      "ja": "文字列は無効です。"
    },
    {
      "indent": 3,
      "text": "* Tag number 36 is for MIME messages (including all headers), as defined in [RFC2045]. A text string that isn't a valid MIME message is invalid. (For this tag, validity checking may be particularly onerous for a generic decoder and might therefore not be offered. Note that many MIME messages are general binary data and therefore cannot be represented in a text string; [IANA.cbor-tags] lists a registration for tag number 257 that is similar to tag number 36 but uses a byte string as its tag content.)",
      "ja": "* タグ番号36は、[RFC2045]で定義されているように、MIMEメッセージ（すべてのヘッダーを含む）用です。有効なMIMEメッセージではないテキスト文字列が無効です。（このタグの場合、妥当性チェックは一般的なデコーダにとって特に著しい場合があり、したがって提供されません。多くのMIMEメッセージは一般的なバイナリデータであり、したがってテキスト文字列で表現することはできません。[IANA.CBOBOR-TAGS]タグ番号257の登録は、タグ番号36に似ていますが、そのタグコンテンツとしてバイト文字列を使用します。）"
    },
    {
      "indent": 3,
      "text": "Note that tag numbers 33 and 34 differ from 21 and 22 in that the data is transported in base-encoded form for the former and in raw byte string form for the latter.",
      "ja": "タグ番号33および34は、データが後者のための基本符号化された形式でデータが搬送されるという点で、21および22と異なる。"
    },
    {
      "indent": 3,
      "text": "[RFC7049] also defined a tag number 35 for regular expressions that are in Perl Compatible Regular Expressions (PCRE/PCRE2) form [PCRE] or in JavaScript regular expression syntax [ECMA262]. The state of the art in these regular expression specifications has since advanced and is continually advancing, so this specification does not attempt to update the references. Instead, this tag remains available (as registered in [RFC7049]) for applications that specify the particular regular expression variant they use out-of-band (possibly by limiting the usage to a defined common subset of both PCRE and ECMA262). As this specification clarifies tag validity beyond [RFC7049], we note that due to the open way the tag was defined in [RFC7049], any contained string value needs to be valid at the CBOR tag level (but then may not be \"expected\" at the application level).",
      "ja": "[RFC7049] Perl互換の正規表現（PCRE / PCRE2）フォーム[PCRE]またはJavaScript正規表現構文[ECMA262]で、正規表現のタグ番号35を定義しました。これらの正規表現仕様の最先端の最先端の状態は、以降、これ以降は継続的に進行中であるため、この仕様は参照を更新しようとしません。代わりに、このタグは、帯域外の特定の正規表現バリアントを指定するアプリケーション（おそらくPCREとECMA262の両方の定義された共通サブセットに制限することによって）を指定するアプリケーションについては、（RFC7049]に登録されているように、[RFC7049]に登録されています）。この仕様は[RFC7049]を超えてタグの妥当性を明確にしているので、タグが[RFC7049]で定義されているため、CBORタグレベルでも有効である必要があります（ただし、「期待できない場合があります」ということに注意してください。アプリケーションレベルで）。"
    },
    {
      "indent": 0,
      "text": "3.4.6. Self-Described CBOR",
      "section_title": true,
      "ja": "3.4.6. 自己記述CBOR"
    },
    {
      "indent": 3,
      "text": "In many applications, it will be clear from the context that CBOR is being employed for encoding a data item. For instance, a specific protocol might specify the use of CBOR, or a media type is indicated that specifies its use. However, there may be applications where such context information is not available, such as when CBOR data is stored in a file that does not have disambiguating metadata. Here, it may help to have some distinguishing characteristics for the data itself.",
      "ja": "多くのアプリケーションでは、CBORがデータ項目を符号化するために採用されているという文脈から明らかであろう。たとえば、特定のプロトコルがCBORの使用を指定することも、その使用を指定するメディアタイプが示されています。しかしながら、CBORデータが曖昧さを曖昧さしないファイルに格納されている場合など、そのようなコンテキスト情報が利用できないアプリケーションがあり得る。ここでは、データ自体にいくつかの区別する特性を持つのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "Tag number 55799 is defined for this purpose, specifically for use at the start of a stored encoded CBOR data item as specified by an application. It does not impart any special semantics on the data item that it encloses; that is, the semantics of the tag content enclosed in tag number 55799 is exactly identical to the semantics of the tag content itself.",
      "ja": "タグ番号55799は、この目的のために、アプリケーションによって指定されているように格納された符号化されたCBORデータ項目の開始時に使用するために定義される。それが囲むデータ項目に特別な意味論を与えません。すなわち、タグ番号55799に囲まれたタグコンテンツのセマンティクスは、タグコンテンツ自体のセマンティクスと全く同じである。"
    },
    {
      "indent": 3,
      "text": "The serialization of this tag's head is 0xd9d9f7, which does not appear to be in use as a distinguishing mark for any frequently used file types. In particular, 0xd9d9f7 is not a valid start of a Unicode text in any Unicode encoding if it is followed by a valid CBOR data item.",
      "ja": "このタグのヘッドのシリアル化は0xD9D9F7です。これは、頻繁に使用されるファイルタイプの識別マークとして使用されていないようです。特に、0xD9D9F7は、有効なCBORデータ項目が続く場合、Unicodeエンコーディング内のUnicodeテキストの有効な開始ではありません。"
    },
    {
      "indent": 3,
      "text": "For instance, a decoder might be able to decode both CBOR and JSON. Such a decoder would need to mechanically distinguish the two formats. An easy way for an encoder to help the decoder would be to tag the entire CBOR item with tag number 55799, the serialization of which will never be found at the beginning of a JSON text.",
      "ja": "たとえば、デコーダはCBORとJSONの両方をデコードできる可能性があります。そのようなデコーダは、2つのフォーマットを機械的に区別する必要があるであろう。エンコーダがデコーダがタグ番号55799でタグを付けるのを助けるためのエンコーダが簡単な方法であるため、そのシリアル化はJSONテキストの先頭には決して見つからない。"
    },
    {
      "indent": 0,
      "text": "4. Serialization Considerations",
      "section_title": true,
      "ja": "4. シリアル化の考慮事項"
    },
    {
      "indent": 0,
      "text": "4.1. Preferred Serialization",
      "section_title": true,
      "ja": "4.1. 好ましい直列化"
    },
    {
      "indent": 3,
      "text": "For some values at the data model level, CBOR provides multiple serializations. For many applications, it is desirable that an encoder always chooses a preferred serialization (preferred encoding); however, the present specification does not put the burden of enforcing this preference on either the encoder or decoder.",
      "ja": "データモデルレベルである値の場合、CBORは複数の直列化を提供します。多くの用途では、エンコーダが常に好ましい直列化（好ましい符号化）を選択することが望ましい。しかしながら、本明細書は、エンコーダまたはデコーダのいずれかでこの好みを強化する負担を払わない。"
    },
    {
      "indent": 3,
      "text": "Some constrained decoders may be limited in their ability to decode non-preferred serializations: for example, if only integers below 1_000_000_000 (one billion) are expected in an application, the decoder may leave out the code that would be needed to decode 64-bit arguments in integers. An encoder that always uses preferred serialization (\"preferred encoder\") interoperates with this decoder for the numbers that can occur in this application. Generally speaking, a preferred encoder is more universally interoperable (and also less wasteful) than one that, say, always uses 64-bit integers.",
      "ja": "いくつかの制約付きデコーダは、非優先シリアル化を復号する能力において制限されてもよい。たとえば、1_000_000_000より下の整数（10億）のみが予想される場合、デコーダは64ビットをデコードするために必要となるコードを除外することができる。整数の引数。常に優先シリアル化（「優先エンコーダ」）を使用するエンコーダは、このアプリケーションで発生する可能性がある番号についてこのデコーダと相互運用されます。一般的に言って、好ましいエンコーダは、常に64ビットの整数を使用するものよりも、より普遍的に相互運用可能な（そしてまた無駄にない）。"
    },
    {
      "indent": 3,
      "text": "Similarly, a constrained encoder may be limited in the variety of representation variants it supports such that it does not emit preferred serializations (\"variant encoder\"). For instance, a constrained encoder could be designed to always use the 32-bit variant for an integer that it encodes even if a short representation is available (assuming that there is no application need for integers that can only be represented with the 64-bit variant). A decoder that does not rely on receiving only preferred serializations (\"variation-tolerant decoder\") can therefore be said to be more universally interoperable (it might very well optimize for the case of receiving preferred serializations, though). Full implementations of CBOR decoders are by definition variation tolerant; the distinction is only relevant if a constrained implementation of a CBOR decoder meets a variant encoder.",
      "ja": "同様に、制約付きエンコーダは、それが好ましい直列化（「変異体エンコーダ」）を発しないように支持する様々な表現変異体において制限されてもよい。たとえば、拘束エンコーダは、短い表現が利用可能であっても符号化されていても符号化する整数に対して常に32ビットのバリアントを使用するように設計することができます（64ビットでのみ表現できる整数のアプリケーションが必要ではないと仮定します。バリアント）。したがって、好ましい直列化のみを受信することに頼らない復号器（「変動耐性デコーダ」）は、より普遍的に相互運用可能であると言える（しかしながら、好ましい直列化を受ける場合には非常に最適化され得る可能性がある）。CBORデコーダの完全実装は定義バリエーション耐性によるものです。CBORデコーダの制約付き実装がバリアントエンコーダを満たす場合、区別は関連性がある。"
    },
    {
      "indent": 3,
      "text": "The preferred serialization always uses the shortest form of representing the argument (Section 3); it also uses the shortest floating-point encoding that preserves the value being encoded.",
      "ja": "優先シリアル化は常に引数を表す最短形式を使用します（セクション3）。それはまた、符号化されている値を保持する最短浮動小数点符号化を使用する。"
    },
    {
      "indent": 3,
      "text": "The preferred serialization for a floating-point value is the shortest floating-point encoding that preserves its value, e.g., 0xf94580 for the number 5.5, and 0xfa45ad9c00 for the number 5555.5. For NaN values, a shorter encoding is preferred if zero-padding the shorter significand towards the right reconstitutes the original NaN value (for many applications, the single NaN encoding 0xf97e00 will suffice).",
      "ja": "浮動小数点値の好ましいシリアル化は、5555.5の数5.5の数値5.5の0xF94580、および0xFA45AD9C00を保持する最短浮動小数点符号化である。NAN値については、右側に短い大部分を右に再構成することをゼロパディングすると、より短い符号化が好ましい（多くの用途のために、0xF97E00を符号化する単一のNANは十分であろう）。"
    },
    {
      "indent": 3,
      "text": "Definite-length encoding is preferred whenever the length is known at the time the serialization of the item starts.",
      "ja": "アイテムのシリアル化が開始される時点で長さが知られているときはいつでも、明確な長さのエンコーディングが推奨されます。"
    },
    {
      "indent": 0,
      "text": "4.2. Deterministically Encoded CBOR",
      "section_title": true,
      "ja": "4.2. 決定論的に符号化されたCBOR."
    },
    {
      "indent": 3,
      "text": "Some protocols may want encoders to only emit CBOR in a particular deterministic format; those protocols might also have the decoders check that their input is in that deterministic format. Those protocols are free to define what they mean by a \"deterministic format\" and what encoders and decoders are expected to do. This section defines a set of restrictions that can serve as the base of such a deterministic format.",
      "ja": "一部のプロトコルは、エンコーダが特定の決定論的形式で炭水化物のみを発行することを望んでいる可能性があります。これらのプロトコルはまた、それらの入力がその決定論的形式にあることを復号化器をチェックすることもできる。これらのプロトコルは、「決定論的形式」とは、エンコーダとデコーダが行うことが期待されるものを定義することができます。このセクションでは、そのような決定論的形式の基本として機能することができる一連の制限事項を定義します。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Core Deterministic Encoding Requirements",
      "section_title": true,
      "ja": "4.2.1. コア決定論的エンコード要件"
    },
    {
      "indent": 3,
      "text": "A CBOR encoding satisfies the \"core deterministic encoding requirements\" if it satisfies the following restrictions:",
      "ja": "CBORエンコードは、以下の制限を満たす場合、「コア決定論的エンコード要件」を満たします。"
    },
    {
      "indent": 3,
      "text": "* Preferred serialization MUST be used. In particular, this means that arguments (see Section 3) for integers, lengths in major types 2 through 5, and tags MUST be as short as possible, for instance:",
      "ja": "* 好ましい直列化を使用する必要があります。特に、これは、関数（セクション3を参照）（セクション3を参照）、メジャータイプ2から5の長さ、およびタグはできるだけ短くなければならないことを意味します。"
    },
    {
      "indent": 6,
      "text": "- 0 to 23 and -1 to -24 MUST be expressed in the same byte as the major type;",
      "ja": "- メジャータイプと同じバイトで表現する必要があります。"
    },
    {
      "indent": 6,
      "text": "- 24 to 255 and -25 to -256 MUST be expressed only with an additional uint8_t;",
      "ja": "- 24~255、および-25~-2006は、追加のUINT8_Tでのみ表現する必要があります。"
    },
    {
      "indent": 6,
      "text": "- 256 to 65535 and -257 to -65536 MUST be expressed only with an additional uint16_t;",
      "ja": "- 256~65535および-257~-65536は、追加のUINT16_Tでのみ表現する必要があります。"
    },
    {
      "indent": 6,
      "text": "- 65536 to 4294967295 and -65537 to -4294967296 MUST be expressed only with an additional uint32_t.",
      "ja": "- 65536~4294967295、および-65537~-4294967296は、追加のUINT32_Tでのみ表現する必要があります。"
    },
    {
      "indent": 6,
      "text": "Floating-point values also MUST use the shortest form that preserves the value, e.g., 1.5 is encoded as 0xf93e00 (binary16) and 1000000.5 as 0xfa49742408 (binary32). (One implementation of this is to have all floats start as a 64-bit float, then do a test conversion to a 32-bit float; if the result is the same numeric value, use the shorter form and repeat the process with a test conversion to a 16-bit float. This also works to select 16-bit float for positive and negative Infinity as well.)",
      "ja": "浮動小数点値は、値、例えば1.5が0xF93E00（Binary16）および1000000.5として0xFA49742408（Binary32）として符号化されている最短形式を使用する必要があります。（これの1つの実装は、すべてのフロートを64ビットのフロートとして開始することです。その後、32ビットのフロートへのテスト変換を行います。結果が同じ数値である場合は、より短いフォームを使用してテストでプロセスを繰り返します。16ビットのフロートへの変換これはまた、正および負の無限大のために16ビットのフロートを選択するようにも機能します。）"
    },
    {
      "indent": 3,
      "text": "* Indefinite-length items MUST NOT appear. They can be encoded as definite-length items instead.",
      "ja": "* 無期限の長さの項目が表示されてはいけません。それらは代わりに明確な項目として符号化することができる。"
    },
    {
      "indent": 3,
      "text": "* The keys in every map MUST be sorted in the bytewise lexicographic order of their deterministic encodings. For example, the following keys are sorted correctly:",
      "ja": "* すべてのマップのキーは、その決定論的なエンコーディングのBytewiseの辞書の順序でソートされている必要があります。たとえば、次のキーが正しくソートされています。"
    },
    {
      "indent": 6,
      "text": "1. 10, encoded as 0x0a.",
      "ja": "1. 10、0x0Aとして符号化されています。"
    },
    {
      "indent": 6,
      "text": "2. 100, encoded as 0x1864.",
      "ja": "2. 100、0x1864として符号化されています。"
    },
    {
      "indent": 6,
      "text": "3. -1, encoded as 0x20.",
      "ja": "3. 0x20として符号化された。"
    },
    {
      "indent": 6,
      "text": "4. \"z\", encoded as 0x617a.",
      "ja": "4. 0x617Aとして符号化された「Z」。"
    },
    {
      "indent": 6,
      "text": "5. \"aa\", encoded as 0x626161.",
      "ja": "5. \"aa\"、0x626161としてエンコードされました。"
    },
    {
      "indent": 6,
      "text": "6. [100], encoded as 0x811864.",
      "ja": "6. [100]、0x811864としてエンコードされました。"
    },
    {
      "indent": 6,
      "text": "7. [-1], encoded as 0x8120.",
      "ja": "7. [-1]、0x8120として符号化されています。"
    },
    {
      "indent": 6,
      "text": "8. false, encoded as 0xf4.",
      "ja": "8. False、0xF4としてエンコードされました。"
    },
    {
      "indent": 6,
      "text": "|  Implementation note: the self-delimiting nature of the CBOR\n|  encoding means that there are no two well-formed CBOR encoded\n|  data items where one is a prefix of the other.  The bytewise\n|  lexicographic comparison of deterministic encodings of\n|  different map keys therefore always ends in a position where\n|  the byte differs between the keys, before the end of a key is\n|  reached.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2.2. Additional Deterministic Encoding Considerations",
      "section_title": true,
      "ja": "4.2.2. 追加の決定論的符号化に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "CBOR tags present additional considerations for deterministic encoding. If a CBOR-based protocol were to provide the same semantics for the presence and absence of a specific tag (e.g., by allowing both tag 1 data items and raw numbers in a date/time position, treating the latter as if they were tagged), the deterministic format would not allow the presence of the tag, based on the \"shortest form\" principle. For example, a protocol might give encoders the choice of representing a URL as either a text string or, using Section 3.4.5.3, tag number 32 containing a text string. This protocol's deterministic encoding needs either to require that the tag is present or to require that it is absent, not allow either one.",
      "ja": "CBORタグは、決定論的符号化のための追加の考慮事項を提示します。CBOBベースのプロトコルが特定のタグの存在と不在のために同じ意味論を（例えば、日付/時刻の位置に許可することによって）同じ意味論を提供することであった場合（たとえば、日時位置の両方のデータ項目と生の数字がタグ付けされているかのように扱います）。、決定論的フォーマットは、「最短型」原理に基づいて、タグの存在を許可しないであろう。たとえば、プロトコルは、テキスト文字列またはセクション3.4.5.3、テキスト文字列を含むタグ番号32を使用して、URLをテキスト文字列として表現することを選択することができます。このプロトコルの決定論的エンコーディングは、タグが存在すること、またはそれが存在しないことを要求する必要があり、どちらかを許可しないことを必要とします。"
    },
    {
      "indent": 3,
      "text": "In a protocol that does require tags in certain places to obtain specific semantics, the tag needs to appear in the deterministic format as well. Deterministic encoding considerations also apply to the content of tags.",
      "ja": "特定のセマンティクスを取得するために特定の場所でタグを必要とするプロトコルでは、タグは決定論的形式でも表示される必要があります。決定論的符号化の考慮事項は、タグの内容にも適用されます。"
    },
    {
      "indent": 3,
      "text": "If a protocol includes a field that can express integers with an absolute value of 2^(64) or larger using tag numbers 2 or 3 (Section 3.4.3), the protocol's deterministic encoding needs to specify whether smaller integers are also expressed using these tags or using major types 0 and 1. Preferred serialization uses the latter choice, which is therefore recommended.",
      "ja": "タグ番号2または3を使用して2 ^（64）の絶対値（セクション3.4.3）の絶対値を持つ整数を表現できるフィールドが含まれている場合、プロトコルの決定論的エンコーディングは、これらを使用してより小さな整数を表すかどうかを指定する必要があります。タグまたはメジャータイプ0と1を使用すると、優先シリアル化は後者の選択を使用します。"
    },
    {
      "indent": 3,
      "text": "Protocols that include floating-point values, whether represented using basic floating-point values (Section 3.3) or using tags (or both), may need to define extra requirements on their deterministic encodings, such as:",
      "ja": "基本的な浮動小数点値（セクション3.3）またはタグを使用して表現されたかどうか（またはその両方）を使用して表現されているかどうか、またはタグを使用しているかどうか（またはその両方）を含むプロトコルは、次のような決定論的エンコーディングに追加の要件を定義する必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "* Although IEEE floating-point values can represent both positive and negative zero as distinct values, the application might not distinguish these and might decide to represent all zero values with a positive sign, disallowing negative zero. (The application may also want to restrict the precision of floating-point values in such a way that there is never a need to represent 64-bit -- or even 32-bit -- floating-point values.)",
      "ja": "* IEEE浮動小数点値は、正確な値として正と負の両方のゼロを表すことができますが、アプリケーションはこれらを区別しない可能性があり、正の符号ですべてのゼロ値を表すことを決定し、負のゼロを許可しません。（アプリケーションは、64ビットまたは32ビット浮動小数点値を表す必要がないように、浮動小数点値の精度を制限することもできます。）"
    },
    {
      "indent": 3,
      "text": "* If a protocol includes a field that can express floating-point values, with a specific data model that declares integer and floating-point values to be interchangeable, the protocol's deterministic encoding needs to specify whether, for example, the integer 1.0 is encoded as 0x01 (unsigned integer), 0xf93c00 (binary16), 0xfa3f800000 (binary32), or 0xfb3ff0000000000000 (binary64). Example rules for this are:",
      "ja": "* プロトコルに浮動小数点値を表すことができるフィールドが含まれている場合、整数と浮動小数点値を互換的に宣言する特定のデータモデルが含まれている場合、プロトコルの決定論的エンコーディングは、たとえば整数1.0が0x01としてエンコードされているかどうかを指定する必要があります。（符号なし整数）、0xF93C00（Binary16）、0xFA3F800000（Binary32）、または0xFB3FF00000000000（Binary 64）。これに対する規則の例："
    },
    {
      "indent": 6,
      "text": "1. Encode integral values that fit in 64 bits as values from major types 0 and 1, and other values as the preferred (smallest of 16-, 32-, or 64-bit) floating-point representation that accurately represents the value,",
      "ja": "1. メジャータイプ0と1からの値として64ビットに収まる積分値、およびその他の値は、値を正確に表す浮動小数点表現の値（16,32、または64ビット）の浮動小数点表現としての他の値を符号化します。"
    },
    {
      "indent": 6,
      "text": "2. Encode all values as the preferred floating-point representation that accurately represents the value, even for integral values, or",
      "ja": "2. 整数値に対しても、値を正確に表す優先浮動小数点表現としてすべての値を符号化する。"
    },
    {
      "indent": 6,
      "text": "3. Encode all values as 64-bit floating-point representations.",
      "ja": "3. すべての値を64ビットの浮動小数点表現としてエンコードします。"
    },
    {
      "indent": 6,
      "text": "Rule 1 straddles the boundaries between integers and floating-point values, and Rule 3 does not use preferred serialization, so Rule 2 may be a good choice in many cases.",
      "ja": "規則1は整数と浮動小数点値の間の境界を跨いで、規則3は優先シリアル化を使用しないため、規則2は多くの場合良い選択である可能性があります。"
    },
    {
      "indent": 3,
      "text": "* If NaN is an allowed value, and there is no intent to support NaN payloads or signaling NaNs, the protocol needs to pick a single representation, typically 0xf97e00. If that simple choice is not possible, specific attention will be needed for NaN handling.",
      "ja": "* NANが許容値であり、NANペイロードまたはシグナリングNANをサポートする意図がない場合、プロトコルは通常0xF97E00を選択する必要があります。その単純な選択が不可能な場合は、ナノ処理には特定の注意が必要になります。"
    },
    {
      "indent": 3,
      "text": "* Subnormal numbers (nonzero numbers with the lowest possible exponent of a given IEEE 754 number format) may be flushed to zero outputs or be treated as zero inputs in some floating-point implementations. A protocol's deterministic encoding may want to specifically accommodate such implementations while creating an onus on other implementations by excluding subnormal numbers from interchange, interchanging zero instead.",
      "ja": "* 非正規数（特定のIEEE 754番号フォーマットの不要な指数を持つゼロ以外の数）は、ゼロ出力にフラッシュされるか、ある程度の浮動小数点実装でゼロ入力として扱われます。プロトコルの決定論的エンコーディングは、代わりにゼロを交換することによって、他の実装上のONUを作成しながら、そのような実装に特に対応することを望みます。"
    },
    {
      "indent": 3,
      "text": "* The same number can be represented by different decimal fractions, by different bigfloats, and by different forms under other tags that may be defined to express numeric values. Depending on the implementation, it may not always be practical to determine whether any of these forms (or forms in the basic generic data model) are equivalent. An application protocol that presents choices of this kind for the representation format of numbers needs to be explicit about how the formats for deterministic encoding are to be chosen.",
      "ja": "* 同じ番号は、さまざまなBigFloat、および数値を表現するように定義され得る他のタグの下の異なる形式で異なる小数点分割で表すことができます。実装に応じて、これらのフォーム（または基本汎用データモデル）のいずれかが同等であるかどうかを判断することは必ずしも実用的ではないかもしれません。数値の表現形式のこの種の選択を示すアプリケーションプロトコルは、決定論的エンコーディングのフォーマットがどのように選択されるべきかについて明示的である必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Length-First Map Key Ordering",
      "section_title": true,
      "ja": "4.2.3. 長さ - 最初のマップの鍵の順序付け"
    },
    {
      "indent": 3,
      "text": "The core deterministic encoding requirements (Section 4.2.1) sort map keys in a different order from the one suggested by Section 3.9 of [RFC7049] (called \"Canonical CBOR\" there). Protocols that need to be compatible with the order specified in [RFC7049] can instead be specified in terms of this specification's \"length-first core deterministic encoding requirements\":",
      "ja": "コア決定論的符号化要件（セクション4.2.1）[RFC7049]のセクション3.9によって示唆されたもの（そこでCORONCAL CBORと呼ばれる）とは、マップキーを異なる順序で並べ替えます。[RFC7049]で指定された順序と互換性があるプロトコルは、代わりにこの仕様の「Length-First Core決定論的エンコード要件」に関して指定できます。"
    },
    {
      "indent": 3,
      "text": "A CBOR encoding satisfies the \"length-first core deterministic encoding requirements\" if it satisfies the core deterministic encoding requirements except that the keys in every map MUST be sorted such that:",
      "ja": "CBORエンコードは、すべてのマップ内のキーをソートする必要があることを除いて、コア決定論的エンコード要件を満たす場合、「長さ - ファーストコア決定論的符号化要件」を満たす。"
    },
    {
      "indent": 3,
      "text": "1. If two keys have different lengths, the shorter one sorts earlier;",
      "ja": "1. 2つのキーの長さが異なる場合は、より短い方が順に並びます。"
    },
    {
      "indent": 3,
      "text": "2. If two keys have the same length, the one with the lower value in (bytewise) lexical order sorts earlier.",
      "ja": "2. 2つのキーの長さが同じである場合は、（Bytewise）字句順の値が小さい方の値が早くソートされます。"
    },
    {
      "indent": 3,
      "text": "For example, under the length-first core deterministic encoding requirements, the following keys are sorted correctly:",
      "ja": "たとえば、長さのコアの決定論的エンコード要件の下では、次のキーが正しくソートされます。"
    },
    {
      "indent": 3,
      "text": "1. 10, encoded as 0x0a.",
      "ja": "1. 10、0x0Aとして符号化されています。"
    },
    {
      "indent": 3,
      "text": "2. -1, encoded as 0x20.",
      "ja": "2. 0x20として符号化された。"
    },
    {
      "indent": 3,
      "text": "3. false, encoded as 0xf4.",
      "ja": "3. False、0xF4としてエンコードされました。"
    },
    {
      "indent": 3,
      "text": "4. 100, encoded as 0x1864.",
      "ja": "4. 100、0x1864として符号化されています。"
    },
    {
      "indent": 3,
      "text": "5. \"z\", encoded as 0x617a.",
      "ja": "5. 0x617Aとして符号化された「Z」。"
    },
    {
      "indent": 3,
      "text": "6. [-1], encoded as 0x8120.",
      "ja": "6. [-1]、0x8120として符号化されています。"
    },
    {
      "indent": 3,
      "text": "7. \"aa\", encoded as 0x626161.",
      "ja": "7. \"aa\"、0x626161としてエンコードされました。"
    },
    {
      "indent": 3,
      "text": "8. [100], encoded as 0x811864.",
      "ja": "8. [100]、0x811864としてエンコードされました。"
    },
    {
      "indent": 6,
      "text": "|  Although [RFC7049] used the term \"Canonical CBOR\" for its form\n|  of requirements on deterministic encoding, this document avoids\n|  this term because \"canonicalization\" is often associated with\n|  specific uses of deterministic encoding only.  The terms are\n|  essentially interchangeable, however, and the set of core\n|  requirements in this document could also be called \"Canonical\n|  CBOR\", while the length-first-ordered version of that could be\n|  called \"Old Canonical CBOR\".",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Creating CBOR-Based Protocols",
      "section_title": true,
      "ja": "5. CBORベースのプロトコルの作成"
    },
    {
      "indent": 3,
      "text": "Data formats such as CBOR are often used in environments where there is no format negotiation. A specific design goal of CBOR is to not need any included or assumed schema: a decoder can take a CBOR item and decode it with no other knowledge.",
      "ja": "CBORなどのデータフォーマットは、フォーマット交渉がない環境でよく使用されます。CBORの特定の設計目標は、含まれているまたは想定されるスキーマを必要としないことです。デコーダはCBORアイテムを取得し、他の知識を復号することができます。"
    },
    {
      "indent": 3,
      "text": "Of course, in real-world implementations, the encoder and the decoder will have a shared view of what should be in a CBOR data item. For example, an agreed-to format might be \"the item is an array whose first value is a UTF-8 string, second value is an integer, and subsequent values are zero or more floating-point numbers\" or \"the item is a map that has byte strings for keys and contains a pair whose key is 0xab01\".",
      "ja": "もちろん、実際の実装では、エンコーダとデコーダはCBOBORデータ項目にあるべきものの共有ビューを持ちます。たとえば、合意されたフォーマットは「アイテムは最初の値がUTF-8文字列であるアレイで、2番目の値は整数で、後続の値はゼロ以上の浮動小数点数」または「アイテムはキーにバイト文字列を持つマップには、キーが0xab01 \"のペアが含まれています。"
    },
    {
      "indent": 3,
      "text": "CBOR-based protocols MUST specify how their decoders handle invalid and other unexpected data. CBOR-based protocols MAY specify that they treat arbitrary valid data as unexpected. Encoders for CBOR-based protocols MUST produce only valid items, that is, the protocol cannot be designed to make use of invalid items. An encoder can be capable of encoding as many or as few types of values as is required by the protocol in which it is used; a decoder can be capable of understanding as many or as few types of values as is required by the protocols in which it is used. This lack of restrictions allows CBOR to be used in extremely constrained environments.",
      "ja": "CBORベースのプロトコルは、それらのデコーダが無効および他の予期せぬデータをどのように処理するかを指定する必要があります。CBORベースのプロトコルは、それらが任意の有効なデータを予期しないように扱うように指定できます。CBORベースのプロトコルのエンコーダは有効な項目のみを生成する必要があります。つまり、プロトコルは無効なアイテムを利用するように設計できません。エンコーダは、使用されているプロトコルによって必要とされるのと同じくらい多くのタイプの値を符号化することができる。デコーダは、使用されているプロトコルによって必要とされるのと同じくらい多くのタイプの値を理解することができる。この制限の欠如は、極めて拘束された環境でCBORを使用することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The rest of this section discusses some considerations in creating CBOR-based protocols. With few exceptions, it is advisory only and explicitly excludes any language from BCP 14 [RFC2119] [RFC8174] other than words that could be interpreted as \"MAY\" in the sense of BCP 14. The exceptions aim at facilitating interoperability of CBOR-based protocols while making use of a wide variety of both generic and application-specific encoders and decoders.",
      "ja": "このセクションの残りの部分では、CBORベースのプロトコルの作成に関する考慮事項について説明します。ほんの少しの例外で、BCP 14の意味で「5月」として解釈される可能性のある言葉以外のBCP 14 [RFC8174]からのあらゆる言語だけを明示的に除外します。プロトコルは、一般的なエンコーダとアプリケーション固有のエンコーダとデコーダの両方を使用しながら使用しているプロトコルです。"
    },
    {
      "indent": 0,
      "text": "5.1. CBOR in Streaming Applications",
      "section_title": true,
      "ja": "5.1. ストリーミングアプリケーションの炭"
    },
    {
      "indent": 3,
      "text": "In a streaming application, a data stream may be composed of a sequence of CBOR data items concatenated back-to-back. In such an environment, the decoder immediately begins decoding a new data item if data is found after the end of a previous data item.",
      "ja": "ストリーミングアプリケーションでは、データストリームは、バックツー間に連結されたCBORデータ項目のシーケンスから構成されてもよい。そのような環境では、デコーダは直ちに前のデータ項目の終了後にデータが見つかった場合に新しいデータ項目を復号化し始める。"
    },
    {
      "indent": 3,
      "text": "Not all of the bytes making up a data item may be immediately available to the decoder; some decoders will buffer additional data until a complete data item can be presented to the application. Other decoders can present partial information about a top-level data item to an application, such as the nested data items that could already be decoded, or even parts of a byte string that hasn't completely arrived yet. Such an application also MUST have a matching streaming security mechanism, where the desired protection is available for incremental data presented to the application.",
      "ja": "データ項目を構成するすべてのバイトがすぐにデコーダに利用できるわけではない。一部のデコーダは、完全なデータ項目がアプリケーションに提示されるまで追加のデータをバッファリングします。他のデコーダは、すでに復号化されている可能性があるネストされたデータ項目、または完全に到着していないバイト文字列の一部でさえも、最上位データ項目に関する部分的な情報をアプリケーションに提示することができる。そのようなアプリケーションはまた、適切なストリーミングセキュリティメカニズムを有していなければならず、ここでは、所望の保護はアプリケーションに提示された増分データに対して利用可能である。"
    },
    {
      "indent": 3,
      "text": "Note that some applications and protocols will not want to use indefinite-length encoding. Using indefinite-length encoding allows an encoder to not need to marshal all the data for counting, but it requires a decoder to allocate increasing amounts of memory while waiting for the end of the item. This might be fine for some applications but not others.",
      "ja": "一部のアプリケーションとプロトコルは、無期限のエンコーディングを使用したくないことに注意してください。不定長のエンコーディングを使用することで、エンコーダはカウントするためにすべてのデータをマーシャルする必要がないが、アイテムの終わりを待っている間に増加量のメモリを割り当てるためのデコーダが必要である。これはいくつかのアプリケーションでは問題ありませんが、他のアプリケーションでは問題ありません。"
    },
    {
      "indent": 0,
      "text": "5.2. Generic Encoders and Decoders",
      "section_title": true,
      "ja": "5.2. 一般的なエンコーダとデコーダ"
    },
    {
      "indent": 3,
      "text": "A generic CBOR decoder can decode all well-formed encoded CBOR data items and present the data items to an application. See Appendix C. (The diagnostic notation, Section 8, may be used to present well-formed CBOR values to humans.)",
      "ja": "一般的なCBOBORデコーダは、すべての整形式の符号化されたCBOBORデータ項目を復号し、データ項目をアプリケーションに提示することができる。付録C.（診断表記法、セクション8を使用して人間に十分に形成されたCBOR値を紹介することができる。）"
    },
    {
      "indent": 3,
      "text": "Generic CBOR encoders provide an application interface that allows the application to specify any well-formed value to be encoded as a CBOR data item, including simple values and tags unknown to the encoder.",
      "ja": "一般的なCBOBORエンコーダは、アプリケーションがCBOODERデータ項目として符号化される整形式の値を指定することを可能にするアプリケーションインタフェースを提供します。"
    },
    {
      "indent": 3,
      "text": "Even though CBOR attempts to minimize these cases, not all well-formed CBOR data is valid: for example, the encoded text string \"0x62c0ae\" does not contain valid UTF-8 (because [RFC3629] requires always using the shortest form) and so is not a valid CBOR item. Also, specific tags may make semantic constraints that may be violated, for instance, by a bignum tag enclosing another tag or by an instance of tag number 0 containing a byte string or containing a text string with contents that do not match the \"date-time\" production of [RFC3339]. There is no requirement that generic encoders and decoders make unnatural choices for their application interface to enable the processing of invalid data. Generic encoders and decoders are expected to forward simple values and tags even if their specific codepoints are not registered at the time the encoder/ decoder is written (Section 5.4).",
      "ja": "CBORがこれらのケースを最小限に抑えようとしても、すべての整形式のCBOBORデータが有効ではありません。たとえば、エンコードされたテキスト文字列 \"0x62C0AE\"には有効なUTF-8が含まれていません（[RFC3629]は常に最短フォームを使用する必要があるため）有効なCBORアイテムではありません。また、特定のタグは、例えば別のタグを囲むBignumタグ、またはバイト文字列を含むタグ番号0のインスタンスによって、あるいは「日付 - と一致させない内容を含むテキスト文字列を含む」によって違反する可能性がある意味の制約を作成することができる。「RFC3339の生産」。一般的なエンコーダやデコーダが無効なデータの処理を可能にするためにそれらのアプリケーションインタフェースに対して不自然な選択をするという要件はありません。一般的なエンコーダとデコーダは、エンコーダ/デコーダが書き込まれた時点で特定のコードポイントが登録されていなくても、単純な値とタグを転送すると予想されます（セクション5.4）。"
    },
    {
      "indent": 0,
      "text": "5.3. Validity of Items",
      "section_title": true,
      "ja": "5.3. アイテムの妥当性"
    },
    {
      "indent": 3,
      "text": "A well-formed but invalid CBOR data item (Section 1.2) presents a problem with interpreting the data encoded in it in the CBOR data model. A CBOR-based protocol could be specified in several layers, in which the lower layers don't process the semantics of some of the CBOR data they forward. These layers can't notice any validity errors in data they don't process and MUST forward that data as-is. The first layer that does process the semantics of an invalid CBOR item MUST pick one of two choices:",
      "ja": "整形式だが無効なCBOBORデータ項目（セクション1.2）は、CBOBORデータモデルに符号化されたデータの解釈に関する問題を提示する。CBORベースのプロトコルはいくつかの層で指定でき、下部層はそれらが前述のCBORデータのいくつかの意味論を処理しない。これらのレイヤーは、処理されていないデータの有効性エラーを認識できず、そのデータをそのまま転送する必要があります。無効なCBOR項目のセマンティクスを処理する最初のレイヤーは、2つの選択肢の1つを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Replace the problematic item with an error marker and continue with the next item, or",
      "ja": "1. 問題のあるアイテムをエラーマーカーに置き換えて、次の項目を続ける"
    },
    {
      "indent": 3,
      "text": "2. Issue an error and stop processing altogether.",
      "ja": "2. エラーを発行して処理を完全に停止します。"
    },
    {
      "indent": 3,
      "text": "A CBOR-based protocol MUST specify which of these options its decoders take for each kind of invalid item they might encounter.",
      "ja": "CBORベースのプロトコルは、これらのオプションのどれがデコーダのどれが遭遇する可能性のある各種の各種のものにかかるかを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Such problems might occur at the basic validity level of CBOR or in the context of tags (tag validity).",
      "ja": "そのような問題は、CBORの基本的な妥当性レベルまたはタグの文脈（タグの有効性）で発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Basic validity",
      "section_title": true,
      "ja": "5.3.1. 基本的な妥当性"
    },
    {
      "indent": 3,
      "text": "Two kinds of validity errors can occur in the basic generic data model:",
      "ja": "基本的な一般データモデルでは、2種類の有効性エラーが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Duplicate keys in a map: Generic decoders (Section 5.2) make data available to applications using the native CBOR data model. That data model includes maps (key-value mappings with unique keys), not multimaps (key-value mappings where multiple entries can have the same key). Thus, a generic decoder that gets a CBOR map item that has duplicate keys will decode to a map with only one instance of that key, or it might stop processing altogether. On the other hand, a \"streaming decoder\" may not even be able to notice. See Section 5.6 for more discussion of keys in maps.",
      "ja": "マップ内の重複キー：汎用デコーダ（セクション5.2）は、ネイティブCBORデータモデルを使用してアプリケーションでデータを使用可能にします。そのデータモデルはマルチマップではなくマップ（一意のキーを持つキー値マッピング）を含みます（複数のエントリが同じキーを持つことができるキー値マッピング）。したがって、重複キーを持つCBOBORマップ項目を取得する一般的なデコーダは、そのキーのインスタンスのみを持つマップにデコードするか、または完全に処理を停止する可能性があります。一方、「ストリーミングデコーダ」が気付くことができない場合があります。マップ内のキーの詳細については、セクション5.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "Invalid UTF-8 string: A decoder might or might not want to verify that the sequence of bytes in a UTF-8 string (major type 3) is actually valid UTF-8 and react appropriately.",
      "ja": "無効なUTF-8文字列：デコーダは、UTF-8文字列（メジャータイプ3）内のバイトのシーケンスが実際に有効なUTF-8であることを確認し、適切に反応することを確認したくない場合があります。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Tag validity",
      "section_title": true,
      "ja": "5.3.2. タグの妥当性"
    },
    {
      "indent": 3,
      "text": "Two additional kinds of validity errors are introduced by adding tags to the basic generic data model:",
      "ja": "基本汎用データモデルにタグを追加することによって、追加の2種類の有効性エラーが導入されています。"
    },
    {
      "indent": 3,
      "text": "Inadmissible type for tag content: Tag numbers (Section 3.4) specify what type of data item is supposed to be used as their tag content; for example, the tag numbers for unsigned or negative bignums are supposed to be put on byte strings. A decoder that decodes the tagged data item into a native representation (a native big integer in this example) is expected to check the type of the data item being tagged. Even decoders that don't have such native representations available in their environment may perform the check on those tags known to them and react appropriately.",
      "ja": "タグコンテンツのための許可されていないタイプ：タグ番号（セクション3.4）タグコンテンツとして使用するには、どのタイプのデータ項目が使用されているかを指定します。たとえば、符号なしまたは負のビグラムのタグ番号はバイト文字列に配置されることになっています。タグ付きデータ項目をネイティブ表現（この例ではネイティブの大きな整数）にデコードするデコーダは、タグ付けされているデータ項目の種類を確認すると予想されます。環境で利用可能なそのような在来の表現を持たないデコーダでさえも、それらに知られているタグのチェックを実行し、適切に反応することがある。"
    },
    {
      "indent": 3,
      "text": "Inadmissible value for tag content: The type of data item may be admissible for a tag's content, but the specific value may not be; e.g., a value of \"yesterday\" is not acceptable for the content of tag 0, even though it properly is a text string. A decoder that normally ingests such tags into equivalent platform types might present this tag to the application in a similar way to how it would present a tag with an unknown tag number (Section 5.4).",
      "ja": "タグコンテンツの許可されていません。データ項目の種類は、タグの内容を認めている可能性がありますが、特定の値はできません。例えば、「昨日」の値は、適切にテキスト文字列であっても、タグ0の内容には受け入れられません。そのようなタグを通常同等のプラットフォームタイプに摂取するデコーダは、未知のタグ番号を持つタグを提示する方法と同様の方法でこのタグをアプリケーションに提示する可能性があります（セクション5.4）。"
    },
    {
      "indent": 0,
      "text": "5.4. Validity and Evolution",
      "section_title": true,
      "ja": "5.4. 妥当性と進化"
    },
    {
      "indent": 3,
      "text": "A decoder with validity checking will expend the effort to reliably detect data items with validity errors. For example, such a decoder needs to have an API that reports an error (and does not return data) for a CBOR data item that contains any of the validity errors listed in the previous subsection.",
      "ja": "妥当性検査を備えたデコーダは、有効性エラーを持つデータ項目を確実に検出するための努力を費やします。例えば、そのようなデコーダは、前のサブセクションにリストされている妥当性エラーのいずれかを含むCBORデータ項目に対して、エラー（およびデータを返さない）を報告するAPIを有する必要がある。"
    },
    {
      "indent": 3,
      "text": "The set of tags defined in the \"Concise Binary Object Representation (CBOR) Tags\" registry (Section 9.2), as well as the set of simple values defined in the \"Concise Binary Object Representation (CBOR) Simple Values\" registry (Section 9.1), can grow at any time beyond the set understood by a generic decoder. A validity-checking decoder can do one of two things when it encounters such a case that it does not recognize:",
      "ja": "「簡潔なバイナリオブジェクト表現（CBOR）」レジストリ（セクション9.2）で定義されているタグのセット、および「簡潔なバイナリオブジェクト表現（CBOR）単純な値」レジストリ（セクション9.1）で定義されている単純な値のセットです。汎用デコーダによって理解されているセットを超えて、いつでも成長することができます。有効性検査デコーダは、それが認識されないような場合に遭遇したときに2つのことのうちの1つを実行することができる。"
    },
    {
      "indent": 3,
      "text": "* It can report an error (and not return data). Note that treating this case as an error can cause ossification and is thus not encouraged. This error is not a validity error, per se. This kind of error is more likely to be raised by a decoder that would be performing validity checking if this were a known case.",
      "ja": "* エラー（返し返りデータがない）を報告できます。このケースを誤りとして処理することは骨化を引き起こす可能性があり、したがって奨励されないことに注意してください。このエラーは、それ自体有効性エラーではありません。この種の誤差は、これが既知の場合であれば妥当性チェックを実行する復号器によって提起される可能性が高い。"
    },
    {
      "indent": 3,
      "text": "* It can emit the unknown item (type, value, and, for tags, the decoded tagged data item) to the application calling the decoder, and then give the application an indication that the decoder did not recognize that tag number or simple value.",
      "ja": "* それは、不明なアイテム（タイプ、値、およびタグ、復号化されたタグ付けされたデータ項目）をデコーダの呼び出しを呼び出してから、そのタグ番号または単純な値を認識しなかったことをアプリケーションに与えることができます。"
    },
    {
      "indent": 3,
      "text": "The latter approach, which is also appropriate for decoders that do not support validity checking, provides forward compatibility with newly registered tags and simple values without the requirement to update the encoder at the same time as the calling application. (For this, the decoder's API needs the ability to mark unknown items so that the calling application can handle them in a manner appropriate for the program.)",
      "ja": "妥当性検査をサポートしていないデコーダにも適切である後者のアプローチは、呼び出し側アプリケーションと同時にエンコーダを更新するための要件なしに、新しく登録されたタグと単純な値との互換性を提供します。（このために、デコーダのAPIは、呼び出し側アプリケーションがプログラムに適した方法でそれらを処理できるように、未知のアイテムをマークする機能を必要とします。）"
    },
    {
      "indent": 3,
      "text": "Since some of the processing needed for validity checking may have an appreciable cost (in particular with duplicate detection for maps), support of validity checking is not a requirement placed on all CBOR decoders.",
      "ja": "妥当性検査に必要な処理の一部は、（特に地図のための重複検知を用いて）かなりのコストを有することがあるので、妥当性検査の支援はすべてのCBORデコーダ上に配置された要件ではない。"
    },
    {
      "indent": 3,
      "text": "Some encoders will rely on their applications to provide input data in such a way that valid CBOR results from the encoder. A generic encoder may also want to provide a validity-checking mode where it reliably limits its output to valid CBOR, independent of whether or not its application is indeed providing API-conformant data.",
      "ja": "一部のエンコーダは、有効なCBOODがエンコーダから生じるように入力データを提供するためにアプリケーションに依存します。一般的なエンコーダはまた、そのアプリケーションが実際にAPI準拠のデータを提供するかどうかとは無関係に、それが確実にその出力を有効なCBORに確実に制限する妥当性検査モードを提供したいと思うかもしれない。"
    },
    {
      "indent": 0,
      "text": "5.5. Numbers",
      "section_title": true,
      "ja": "5.5. 数字"
    },
    {
      "indent": 3,
      "text": "CBOR-based protocols should take into account that different language environments pose different restrictions on the range and precision of numbers that are representable. For example, the basic JavaScript number system treats all numbers as floating-point values, which may result in the silent loss of precision in decoding integers with more than 53 significant bits. Another example is that, since CBOR keeps the sign bit for its integer representation in the major type, it has one bit more for signed numbers of a certain length (e.g., -2^(64)..2^(64)-1 for 1+8-byte integers) than the typical platform signed integer representation of the same length (-2^(63)..2^(63)-1 for 8-byte int64_t). A protocol that uses numbers should define its expectations on the handling of nontrivial numbers in decoders and receiving applications.",
      "ja": "CBORベースのプロトコルは、異なる言語環境が表現可能な数の範囲と精度に異なる制限を損なうことを考慮に入れるべきです。たとえば、基本的なJavaScript Number Systemはすべての数値を浮動小数点値として扱います。これにより、53以上の有効ビットを超える整数の復号化における精度が無音損失が発生する可能性があります。別の例は、CBORがその整数表現のために符号ビットを主要なタイプの整数表現に保つので、ある長さの符号付き数（例えば、-2 ^（64）..2 ^（64）-1の符号付き数）を有することである。典型的なプラットフォームよりも1 8バイトの整数では、同じ長さの符号付き整数表現（-2 ^（63）.. 2 ^（63）-1の8バイトINT64_T）。数字を使用するプロトコルは、デコーダ内の非検出およびアプリケーションの受信に関する期待を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "A CBOR-based protocol that includes floating-point numbers can restrict which of the three formats (half-precision, single-precision, and double-precision) are to be supported. For an integer-only application, a protocol may want to completely exclude the use of floating-point values.",
      "ja": "浮動小数点数を含むCBORベースのプロトコルは、3つのフォーマット（半精度、単精度、および倍精度）のどれをサポートするかを制限することができます。整数専用アプリケーションの場合、プロトコルは浮動小数点値の使用を完全に除外したいと思うかもしれません。"
    },
    {
      "indent": 3,
      "text": "A CBOR-based protocol designed for compactness may want to exclude specific integer encodings that are longer than necessary for the application, such as to save the need to implement 64-bit integers. There is an expectation that encoders will use the most compact integer representation that can represent a given value. However, a compact application that does not require deterministic encoding should accept values that use a longer-than-needed encoding (such as encoding \"0\" as 0b000_11001 followed by two bytes of 0x00) as long as the application can decode an integer of the given size. Similar considerations apply to floating-point values; decoding both preferred serializations and longer-than-needed ones is recommended.",
      "ja": "コンパクトさのために設計されたCBORベースのプロトコルは、64ビット整数を実装する必要があるなど、アプリケーションに必要なものよりも長い特定の整数エンコーディングを除外したいと思うかもしれません。エンコーダは、特定の値を表すことができる最もコンパクトな整数表現を使用することが期待されています。ただし、決定論的エンコーディングを必要としないコンパクトなアプリケーションは、アプリケーションがの整数を復号することができる限り、必要なエンコードを使用する値を使用する値を受け入れます（0B000_11001として「0B000_11001は、2バイトの0x00は、2バイトの0x00の2バイト）」を受け入れます。与えられたサイズ。浮動小数点値にも同様の考察が適用されます。好ましい直列化と長いものより長いものを復号することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "CBOR-based protocols for constrained applications that provide a choice between representing a specific number as an integer and as a decimal fraction or bigfloat (such as when the exponent is small and nonnegative) might express a quality-of-implementation expectation that the integer representation is used directly.",
      "ja": "特定の数値を整数として表現し、小数点数（指数が小さく、非負のような）として選択を提供する制約付きアプリケーションのためのCBOBORベースのプロトコルは、整数表現を実装しています。直接使用されています。"
    },
    {
      "indent": 0,
      "text": "5.6. Specifying Keys for Maps",
      "section_title": true,
      "ja": "5.6. マップのキーの指定"
    },
    {
      "indent": 3,
      "text": "The encoding and decoding applications need to agree on what types of keys are going to be used in maps. In applications that need to interwork with JSON-based applications, conversion is simplified by limiting keys to text strings only; otherwise, there has to be a specified mapping from the other CBOR types to text strings, and this often leads to implementation errors. In applications where keys are numeric in nature, and numeric ordering of keys is important to the application, directly using the numbers for the keys is useful.",
      "ja": "エンコードおよび復号化アプリケーションは、どの種類のキーがマップで使用される予定のキーを同意する必要があります。JSONベースのアプリケーションとの相互作用を必要とするアプリケーションでは、キーをテキスト文字列のみに制限することで変換が簡単になります。それ以外の場合は、他のCBORタイプからテキスト文字列への指定されたマッピングが必要です。これにより実装エラーが発生します。キーがNatureで数値で、キーの数値順序がアプリケーションにとって重要なアプリケーションでは、キーの番号を直接使用することが役に立ちます。"
    },
    {
      "indent": 3,
      "text": "If multiple types of keys are to be used, consideration should be given to how these types would be represented in the specific programming environments that are to be used. For example, in JavaScript Maps [ECMA262], a key of integer 1 cannot be distinguished from a key of floating-point 1.0. This means that, if integer keys are used, the protocol needs to avoid the use of floating-point keys the values of which happen to be integer numbers in the same map.",
      "ja": "複数の種類のキーを使用する場合は、使用される特定のプログラミング環境でこれらのタイプがどのように表されるかを考慮する必要があります。たとえば、JavaScriptマップ[ECMA262]では、整数1のキーを浮動小数点1.0のキーとは区別できません。つまり、整数キーが使用されている場合、プロトコルは、その値が同じマップ内の整数の数値である浮動小数点キーの使用を回避する必要があります。"
    },
    {
      "indent": 3,
      "text": "Decoders that deliver data items nested within a CBOR data item immediately on decoding them (\"streaming decoders\") often do not keep the state that is necessary to ascertain uniqueness of a key in a map. Similarly, an encoder that can start encoding data items before the enclosing data item is completely available (\"streaming encoder\") may want to reduce its overhead significantly by relying on its data source to maintain uniqueness.",
      "ja": "データ項目を復号化する（「ストリーミングデコーダ」）CBORデータ項目内にネストされたデータ項目を配信するデコーダ（「ストリーミングデコーダ」）は、地図内の鍵の一意性を確かめるために必要な状態を維持しないことが多い。同様に、囲むデータ項目が完全に利用可能な前にデータ項目を符号化することができるエンコーダ（「ストリーミングエンコーダ」）は、一意性を維持するためにそのデータ源に頼ることによってそのオーバーヘッドを大幅に減少させたいと思うかもしれない。"
    },
    {
      "indent": 3,
      "text": "A CBOR-based protocol MUST define what to do when a receiving application sees multiple identical keys in a map. The resulting rule in the protocol MUST respect the CBOR data model: it cannot prescribe a specific handling of the entries with the identical keys, except that it might have a rule that having identical keys in a map indicates a malformed map and that the decoder has to stop with an error. When processing maps that exhibit entries with duplicate keys, a generic decoder might do one of the following:",
      "ja": "CBORベースのプロトコルは、受信側アプリケーションが複数の同一のキーをマップに見たときに何をすべきかを定義する必要があります。プロトコル内の結果のルールはCBOBORデータモデルを尊重しなければなりません。マップ内に同じキーを持つ規則が不正なマップを示し、デコーダが持っていることを除いて、同じキーを持つエントリの特定の処理を規定することはできません。エラーで停止します。重複したキーを持つエントリを示すマップを処理するとき、一般的なデコーダは次のいずれかを実行する可能性があります。"
    },
    {
      "indent": 3,
      "text": "* Not accept maps with duplicate keys (that is, enforce validity for maps, see also Section 5.4). These generic decoders are universally useful. An application may still need to perform its own duplicate checking based on application rules (for instance, if the application equates integers and floating-point values in map key positions for specific maps).",
      "ja": "* 重複キーでマップを受け入れない（つまり、マップの有効性を強制するには、セクション5.4も参照してください）。これらの一般的なデコーダは普遍的に役立ちます。アプリケーションは、アプリケーションルールに基づいて独自の重複チェックを実行する必要があります（たとえば、アプリケーションが特定のマップのマップキーポジションの整数と浮動小数点値）。"
    },
    {
      "indent": 3,
      "text": "* Pass all map entries to the application, including ones with duplicate keys. This requires that the application handle (check against) duplicate keys, even if the application rules are identical to the generic data model rules.",
      "ja": "* 重複キーを含むものを含むすべてのマップエントリをアプリケーションに渡します。これには、アプリケーションのルールが汎用データモデルの規則と同じであっても、アプリケーションが複製キー（確認）を取扱っていることを必要とします。"
    },
    {
      "indent": 3,
      "text": "* Lose some entries with duplicate keys, e.g., deliver only the final (or first) entry out of the entries with the same key. With such a generic decoder, applications may get different results for a specific key on different runs, and with different generic decoders, which value is returned is based on generic decoder implementation and the actual order of keys in the map. In particular, applications cannot validate key uniqueness on their own as they do not necessarily see all entries; they may not be able to use such a generic decoder if they need to validate key uniqueness. These generic decoders can only be used in situations where the data source and transfer always provide valid maps; this is not possible if the data source and transfer can be attacked.",
      "ja": "* たとえば、鍵を重複しているようなエントリを失います。そして、同じキーを持つエントリから最後の（または最初の）エントリのみを配信します。そのような一般的なデコーダでは、アプリケーションは異なる実行上の特定のキーに対して異なる結果を得ることができ、異なる一般的なデコーダを使用して、その値が返されることは一般的なデコーダの実装およびマップ内のキーの実際の順序に基づいています。特に、アプリケーションは、必ずしもすべてのエントリを見るわけではないので、それら自身の重要な一意性を検証できません。それらが重要な一意性を検証する必要がある場合、それらはそのような一般的なデコーダを使用することができないかもしれません。これらの一般的なデコーダは、データソースと転送が常に有効なマップを提供する状況でのみ使用できます。データソースと転送を攻撃することができればこれは不可能です。"
    },
    {
      "indent": 3,
      "text": "Generic decoders need to document which of these three approaches they implement.",
      "ja": "一般的なデコーダは、それらが実装するこれら3つのアプローチのどれを文書化する必要があります。"
    },
    {
      "indent": 3,
      "text": "The CBOR data model for maps does not allow ascribing semantics to the order of the key/value pairs in the map representation. Thus, a CBOR-based protocol MUST NOT specify that changing the key/value pair order in a map changes the semantics, except to specify that some orders are disallowed, for example, where they would not meet the requirements of a deterministic encoding (Section 4.2). (Any secondary effects of map ordering such as on timing, cache usage, and other potential side channels are not considered part of the semantics but may be enough reason on their own for a protocol to require a deterministic encoding format.)",
      "ja": "マップのCBORデータモデルは、マップ表現内のキー/値ペアの順序への推奨セマンティクスを許可しません。したがって、CBOBベースのプロトコルは、マップ内のキー/値のペアの順序を変更することを指定してはいけません（セクションでは、決定論的エンコーディングの要件を満たしていない場合は、一部の注文が許可されないように指定してはいけません（セクション4.2）。（タイミング、キャッシュ使用量、およびその他の潜在的なサイドチャネルなどのマップ順序の2次の影響は、セマンティクスの一部と見なされませんが、決定論的な符号化フォーマットを必要とするためにプロトコルで十分な理由である可能性があります。）"
    },
    {
      "indent": 3,
      "text": "Applications for constrained devices should consider using small integers as keys if they have maps with a small number of frequently used keys; for instance, a set of 24 or fewer keys can be encoded in a single byte as unsigned integers, up to 48 if negative integers are also used. Less frequently occurring keys can then use integers with longer encodings.",
      "ja": "制約付きデバイス用のアプリケーションは、少数の頻繁に使用されているキーを持つマップがある場合は、キーとして小さな整数を使用することを検討する必要があります。たとえば、2つのキーのセットを1バイトに符号なし整数として符号化することができ、負の整数も使用されている場合には最大48個まで符号化することができる。頻繁に発生するキーは、より長いエンコーディングを持つ整数を使用できます。"
    },
    {
      "indent": 0,
      "text": "5.6.1. Equivalence of Keys",
      "section_title": true,
      "ja": "5.6.1. キーの等価性"
    },
    {
      "indent": 3,
      "text": "The specific data model that applies to a CBOR data item is used to determine whether keys occurring in maps are duplicates or distinct.",
      "ja": "CBORデータ項目に適用される特定のデータモデルを使用して、マップで発生したキーが重複または異なるかを判断するために使用されます。"
    },
    {
      "indent": 3,
      "text": "At the generic data model level, numerically equivalent integer and floating-point values are distinct from each other, as they are from the various big numbers (Tags 2 to 5). Similarly, text strings are distinct from byte strings, even if composed of the same bytes. A tagged value is distinct from an untagged value or from a value tagged with a different tag number.",
      "ja": "一般的なデータモデルレベルでは、数値的に等価な整数値と浮動小数点値は、さまざまな大きな数からのものです（タグ2~5）。同様に、テキスト文字列は同じバイトで構成されていても、バイト文字列とは異なります。タグ付き値は、タグなし値または異なるタグ番号でタグ付けされた値から異なります。"
    },
    {
      "indent": 3,
      "text": "Within each of these groups, numeric values are distinct unless they are numerically equal (specifically, -0.0 is equal to 0.0); for the purpose of map key equivalence, NaN values are equivalent if they have the same significand after zero-extending both significands at the right to 64 bits.",
      "ja": "これらの各グループ内で、数値は数値的に等しい限り異なる（具体的には0.0に等しい）。MAPキーの等価性の目的のために、NAN値は、ゼロから64ビットの両方の大部分を拡張した後に同じ大分を持つ場合、NAN値は同等です。"
    },
    {
      "indent": 3,
      "text": "Both byte strings and text strings are compared byte by byte, arrays are compared element by element, and are equal if they have the same number of bytes/elements and the same values at the same positions. Two maps are equal if they have the same set of pairs regardless of their order; pairs are equal if both the key and value are equal.",
      "ja": "バイト文字列とテキスト文字列の両方はバイトによってバイトによって比較され、アレイは要素によって要素によって比較され、同じ数のバイト/要素と同じ位置に同じ値を持つ場合は同じです。順序に関係なく、2つのマップは同じペアのセットを持つ場合は同じです。キーと値の両方が等しい場合、ペアは等しくなります。"
    },
    {
      "indent": 3,
      "text": "Tagged values are equal if both the tag number and the tag content are equal. (Note that a generic decoder that provides processing for a specific tag may not be able to distinguish some semantically equivalent values, e.g., if leading zeroes occur in the content of tag 2 or tag 3 (Section 3.4.3).) Simple values are equal if they simply have the same value. Nothing else is equal in the generic data model; a simple value 2 is not equivalent to an integer 2, and an array is never equivalent to a map.",
      "ja": "タグ番号とタグの内容の両方が等しい場合、タグ付き値は同じです。（特定のタグに対して処理を提供する一般的なデコーダは、タグ2またはタグ3の内容で先行ゼロが発生した場合には、いくつかの意味的に等価な値を区別できない場合があります（セクション3.4.3）。単純な値は単に同じ値を持つ場合は同じです。一般的なデータモデルでは他には何も同じです。単純な値2は整数2と同等ではなく、配列はマップに相当することはありません。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 2.2, specific data models can make values equivalent for the purpose of comparing map keys that are distinct in the generic data model. Note that this implies that a generic decoder may deliver a decoded map to an application that needs to be checked for duplicate map keys by that application (alternatively, the decoder may provide a programming interface to perform this service for the application). Specific data models are not able to distinguish values for map keys that are equal for this purpose at the generic data model level.",
      "ja": "セクション2.2で説明されているように、特定のデータモデルは、一般的なデータモデルでは異なるマップキーを比較する目的で値を同等にすることができます。これは、一般的なデコーダがそのアプリケーションによって重複するマップキーについてチェックされる必要があるアプリケーションに復号化されたマップを配信することができることに留意されたい（あるいは、デコーダは、このアプリケーションのためにこのサービスを実行するためのプログラミングインターフェースを提供することができる）。特定のデータモデルは、この目的に等しいマップキーの値を一般的なデータモデルレベルで区別することはできません。"
    },
    {
      "indent": 0,
      "text": "5.7. Undefined Values",
      "section_title": true,
      "ja": "5.7. 未定義の値"
    },
    {
      "indent": 3,
      "text": "In some CBOR-based protocols, the simple value (Section 3.3) of \"undefined\" might be used by an encoder as a substitute for a data item with an encoding problem, in order to allow the rest of the enclosing data items to be encoded without harm.",
      "ja": "いくつかのCBORベースのプロトコルでは、「未定義」の単純値（セクション3.3）は、残りの囲みデータ項目を符号化することを可能にするために、符号化問題を有するデータ項目の代わりとしてエンコーダによって使用され得る。害なしに。"
    },
    {
      "indent": 0,
      "text": "6. Converting Data between CBOR and JSON",
      "section_title": true,
      "ja": "6. CBORとJSONの間のデータの変換"
    },
    {
      "indent": 3,
      "text": "This section gives non-normative advice about converting between CBOR and JSON. Implementations of converters MAY use whichever advice here they want.",
      "ja": "このセクションでは、CBORとJSONの間の変換に関する規範的なアドバイスを示します。コンバータの実装は、ここで望むどちらのアドバイスを使用することもできます。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that a JSON text is a sequence of characters, not an encoded sequence of bytes, while a CBOR data item consists of bytes, not characters.",
      "ja": "JSONテキストは、符号化されたバイトのシーケンスではなく、CBORデータ項目が文字ではなくバイトで構成されている一連の文字であることは注目に値します。"
    },
    {
      "indent": 0,
      "text": "6.1. Converting from CBOR to JSON",
      "section_title": true,
      "ja": "6.1. CBORからJSONへの変換"
    },
    {
      "indent": 3,
      "text": "Most of the types in CBOR have direct analogs in JSON. However, some do not, and someone implementing a CBOR-to-JSON converter has to consider what to do in those cases. The following non-normative advice deals with these by converting them to a single substitute value, such as a JSON null.",
      "ja": "CBOR内のタイプのほとんどはJSONに直接の類似体があります。しかし、何もしない、そして、CBOR-TO-JSONのコンバーターを実装する人は、それらの場合に何をすべきかを考慮する必要があります。以下の非規範的アドバイスは、JSON NULLなどの単一の代替値にそれらを変換することによってこれらを扱います。"
    },
    {
      "indent": 3,
      "text": "* An integer (major type 0 or 1) becomes a JSON number.",
      "ja": "* 整数（メジャータイプ0または1）がJSON番号になります。"
    },
    {
      "indent": 3,
      "text": "* A byte string (major type 2) that is not embedded in a tag that specifies a proposed encoding is encoded in base64url without padding and becomes a JSON string.",
      "ja": "* 提案したエンコーディングを指定するタグに埋め込まれていないバイト文字列（メジャータイプ2）は、PDINGなしでBase64URLでエンコードされ、JSON文字列になります。"
    },
    {
      "indent": 3,
      "text": "* A UTF-8 string (major type 3) becomes a JSON string. Note that JSON requires escaping certain characters ([RFC8259], Section 7): quotation mark (U+0022), reverse solidus (U+005C), and the \"C0 control characters\" (U+0000 through U+001F). All other characters are copied unchanged into the JSON UTF-8 string.",
      "ja": "* UTF-8文字列（メジャータイプ3）がJSON文字列になります。JSONでは、特定の文字（[RFC8259]、セクション7）：引用符（U 0022）、リバースソリッド（U 005C）、および「C0制御文字」（U 0000からU 001F）が必要です。他のすべての文字がJSON UTF-8文字列に変更されずにコピーされます。"
    },
    {
      "indent": 3,
      "text": "* An array (major type 4) becomes a JSON array.",
      "ja": "* 配列（メジャータイプ4）がJSONアレイになります。"
    },
    {
      "indent": 3,
      "text": "* A map (major type 5) becomes a JSON object. This is possible directly only if all keys are UTF-8 strings. A converter might also convert other keys into UTF-8 strings (such as by converting integers into strings containing their decimal representation); however, doing so introduces a danger of key collision. Note also that, if tags on UTF-8 strings are ignored as proposed below, this will cause a key collision if the tags are different but the strings are the same.",
      "ja": "* マップ（メジャータイプ5）がJSONオブジェクトになります。これはすべてのキーがUTF-8文字列である場合にのみ直接可能です。コンバータはまた、他のキーをUTF-8文字列に変換することもできます（整数を10進表現を含む文字列に変換するなど）。しかし、そうすることで、鍵衝突の危険性が紹介されています。また、UTF-8文字列のタグが以下に提案されているように無視された場合、タグが異なるが文字列が同じ場合はキーの衝突が発生します。"
    },
    {
      "indent": 3,
      "text": "* False (major type 7, additional information 20) becomes a JSON false.",
      "ja": "* false（メジャータイプ7、追加情報20）がJSON FALSEになります。"
    },
    {
      "indent": 3,
      "text": "* True (major type 7, additional information 21) becomes a JSON true.",
      "ja": "* TRUE（メジャータイプ7、追加情報21）はJSON TRUEになります。"
    },
    {
      "indent": 3,
      "text": "* Null (major type 7, additional information 22) becomes a JSON null.",
      "ja": "* NULL（メジャータイプ7、追加情報22）がJSON NULLになります。"
    },
    {
      "indent": 3,
      "text": "* A floating-point value (major type 7, additional information 25 through 27) becomes a JSON number if it is finite (that is, it can be represented in a JSON number); if the value is non-finite (NaN, or positive or negative Infinity), it is represented by the substitute value.",
      "ja": "* 浮動小数点値（メジャータイプ7、追加情報25~27）は、有限の場合（つまり、JSON番号に表すことができる）JSON数となる。値が非有限（NaN、または正または負の無限遠）の場合、それは代替値によって表されます。"
    },
    {
      "indent": 3,
      "text": "* Any other simple value (major type 7, any additional information value not yet discussed) is represented by the substitute value.",
      "ja": "* 他の単純な値（メジャータイプ7、まだ議論されていない追加情報値）は代替値によって表されます。"
    },
    {
      "indent": 3,
      "text": "* A bignum (major type 6, tag number 2 or 3) is represented by encoding its byte string in base64url without padding and becomes a JSON string. For tag number 3 (negative bignum), a \"~\" (ASCII tilde) is inserted before the base-encoded value. (The conversion to a binary blob instead of a number is to prevent a likely numeric overflow for the JSON decoder.)",
      "ja": "* Bignum（メジャータイプ6、タグ番号2または3）は、PDDINGなしでBase64URLのそのバイト文字列をエンコードしてJSON文字列になります。タグ番号3（負のBignum）の場合、「〜」（ASCIIチルダ）が基本符号化された値の前に挿入されます。（数値の代わりにバイナリBLOBへの変換は、JSONデコーダの可能性のある数値オーバーフローを防ぐことです。）"
    },
    {
      "indent": 3,
      "text": "* A byte string with an encoding hint (major type 6, tag number 21 through 23) is encoded as described by the hint and becomes a JSON string.",
      "ja": "* エンコードヒント（メジャータイプ6、タグ番号21から23）を持つバイト文字列は、ヒントによって記述されてJSON文字列になります。"
    },
    {
      "indent": 3,
      "text": "* For all other tags (major type 6, any other tag number), the tag content is represented as a JSON value; the tag number is ignored.",
      "ja": "* 他のすべてのタグ（メジャータイプ6、その他のタグ番号）では、タグの内容はJSON値として表されます。タグ番号は無視されます。"
    },
    {
      "indent": 3,
      "text": "* Indefinite-length items are made definite before conversion.",
      "ja": "* 変換前の期間の長さの項目は明確にされます。"
    },
    {
      "indent": 3,
      "text": "A CBOR-to-JSON converter may want to keep to the JSON profile I-JSON [RFC7493], to maximize interoperability and increase confidence that the JSON output can be processed with predictable results. For example, this has implications on the range of integers that can be represented reliably, as well as on the top-level items that may be supported by older JSON implementations.",
      "ja": "CBOR-TO JSONコンバータは、相互運用性を最大化し、JSON出力を予測可能な結果で処理できるという信頼性を高めるために、JSONプロファイルi-JSON [RFC7493]を維持したい場合があります。たとえば、これは確実に表現できる整数の範囲、ならびに古いJSON実装によってサポートされる可能性のある最上位項目に影響を与えます。"
    },
    {
      "indent": 0,
      "text": "6.2. Converting from JSON to CBOR",
      "section_title": true,
      "ja": "6.2. JSONからCBORへの変換"
    },
    {
      "indent": 3,
      "text": "All JSON values, once decoded, directly map into one or more CBOR values. As with any kind of CBOR generation, decisions have to be made with respect to number representation. In a suggested conversion:",
      "ja": "すべてのJSON値は、一度復号化され、1つ以上のCBOR値に直接マッピングされます。あらゆる種類の炭水化物の発生と同様に、数字表現に関して決定を行う必要があります。提案された変換で："
    },
    {
      "indent": 3,
      "text": "* JSON numbers without fractional parts (integer numbers) are represented as integers (major types 0 and 1, possibly major type 6, tag number 2 and 3), choosing the shortest form; integers longer than an implementation-defined threshold may instead be represented as floating-point values. The default range that is represented as integer is -2^(53)+1..2^(53)-1 (fully exploiting the range for exact integers in the binary64 representation often used for decoding JSON [RFC7493]). A CBOR-based protocol, or a generic converter implementation, may choose -2^(32)..2^(32)-1 or -2^(64)..2^(64)-1 (fully using the integer ranges available in CBOR with uint32_t or uint64_t, respectively) or even -2^(31)..2^(31)-1 or -2^(63)..2^(63)-1 (using popular ranges for two's complement signed integers). (If the JSON was generated from a JavaScript implementation, its precision is already limited to 53 bits maximum.)",
      "ja": "* 分数部分のないJSON数（整数）は整数（メジャータイプ0と1、おそらく主要なタイプ6、タグ番号2と3）として表され、最短の形式を選択します。実装定義の閾値よりも長い整数は代わりに浮動小数点値として表すことができる。整数として表されるデフォルトの範囲は-2 ^（53）1..2 ^（53）-1です（JSON [RFC7493のデコードによく使用されるBinary64表現の正確な整数の範囲を完全に活用します）。CBOBベースのプロトコル、または一般的なコンバータの実装は、-2 ^（32）を選択してもよいし、2 ^（32）-1または-2 ^（64）.. 2 ^（64）-1（完全に整数を使用UINT32_TまたはUINT64_T、または-2 ^（31）でさえも、CBOBORで入手可能な範囲は、2 ^（31）-1または-2 ^（63）を使用しています。補数符号付き整数）。（Jobascriptの実装からJSONが生成された場合、その精度はすでに最大53ビットに制限されています。）"
    },
    {
      "indent": 3,
      "text": "* Numbers with fractional parts are represented as floating-point values, performing the decimal-to-binary conversion based on the precision provided by IEEE 754 binary64. The mathematical value of the JSON number is converted to binary64 using the roundTiesToEven procedure in Section 4.3.1 of [IEEE754]. Then, when encoding in CBOR, the preferred serialization uses the shortest floating-point representation exactly representing this conversion result; for instance, 1.5 is represented in a 16-bit floating-point value (not all implementations will be capable of efficiently finding the minimum form, though). Instead of using the default binary64 precision, there may be an implementation-defined limit to the precision of the conversion that will affect the precision of the represented values. Decimal representation should only be used on the CBOR side if that is specified in a protocol.",
      "ja": "* 小数部分を持つ数字は浮動小数点値として表され、IEEE 754 Binary 64によって提供される精度に基づいて小二値変換を実行します。JSON番号の数学的値は、[IEEE754]の4.3.1項のRoundtiestoEvenプロシージャを使用してBinary64に変換されます。次に、CBORで符号化すると、好ましい直列化はこの変換結果を正確に表す最短浮動小数点表現を使用する。たとえば、1.5は16ビットの浮動小数点値で表されます（すべての実装は最小形式を効率的に見つけることができます）。デフォルトのBinary64の精度を使用する代わりに、表現された値の精度に影響を与える変換の精度に実装定義の制限があるかもしれません。それがプロトコルで指定されている場合にのみ、10進表現をCBOR側で使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "CBOR has been designed to generally provide a more compact encoding than JSON. One implementation strategy that might come to mind is to perform a JSON-to-CBOR encoding in place in a single buffer. This strategy would need to carefully consider a number of pathological cases, such as that some strings represented with no or very few escapes and longer (or much longer) than 255 bytes may expand when encoded as UTF-8 strings in CBOR. Similarly, a few of the binary floating-point representations might cause expansion from some short decimal representations (1.1, 1e9) in JSON. This may be hard to get right, and any ensuing vulnerabilities may be exploited by an attacker.",
      "ja": "CBORは一般的にJSONよりコンパクトなエンコーディングを提供するように設計されています。気になる可能性がある1つの実装戦略は、単一のバッファ内のJSONからCBORエンコーディングを実行することです。この戦略は、CBORのUTF-8文字列として符号化されたときに、NOまたは非常に少ない（またははるかに長い）程度のいくつかの文字列が拡大する可能性があるなど、いくつかの文字列を慎重に検討する必要があります。同様に、いくつかのバイナリ浮動小数点表現は、JSONの短い10進表現（1.1,1E9）から拡大を引き起こす可能性があります。これは正しく手に入れるのが難しいかもしれません、そして、続く脆弱性は攻撃者によって悪用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "7. Future Evolution of CBOR",
      "section_title": true,
      "ja": "7. CBORの将来進化"
    },
    {
      "indent": 3,
      "text": "Successful protocols evolve over time. New ideas appear, implementation platforms improve, related protocols are developed and evolve, and new requirements from applications and protocols are added. Facilitating protocol evolution is therefore an important design consideration for any protocol development.",
      "ja": "プロトコルが成功すると、経時的に進化します。新しいアイデアが表示され、実装プラットフォームが改善され、関連プロトコルが開発され、進化し、アプリケーションやプロトコルからの新しい要件が追加されます。したがって、プロトコルの進化を容易にすることは、プロトコル開発のための重要な設計上の考慮事項です。"
    },
    {
      "indent": 3,
      "text": "For protocols that will use CBOR, CBOR provides some useful mechanisms to facilitate their evolution. Best practices for this are well known, particularly from JSON format development of JSON-based protocols. Therefore, such best practices are outside the scope of this specification.",
      "ja": "CBORを使用するプロトコルの場合、CBORは彼らの進化を促進するためにいくつかの便利なメカニズムを提供します。これに対するベストプラクティスは、特にJSONベースのプロトコルのJSONフォーマットの開発からよく知られています。したがって、このようなベストプラクティスはこの仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "However, facilitating the evolution of CBOR itself is very well within its scope. CBOR is designed to both provide a stable basis for development of CBOR-based protocols and to be able to evolve. Since a successful protocol may live for decades, CBOR needs to be designed for decades of use and evolution. This section provides some guidance for the evolution of CBOR. It is necessarily more subjective than other parts of this document. It is also necessarily incomplete, lest it turn into a textbook on protocol development.",
      "ja": "しかし、CBOR自体の進化を促進することはその範囲内で非常によくあります。CBORは、CBORベースのプロトコルの開発に安定した基準を提供し、進化することができるように設計されています。成功したプロトコルは何十年もの間生きている可能性があるので、CBORは何十年もの使用と進化のために設計される必要があります。このセクションでは、CBORの進化のためのいくつかのガイダンスを提供します。この文書の他の部分よりも必ずしも主観的です。それはまた必然的に不完全であり、プロトコル開発に関する教科書に変わる。"
    },
    {
      "indent": 0,
      "text": "7.1. Extension Points",
      "section_title": true,
      "ja": "7.1. 拡張ポイント"
    },
    {
      "indent": 3,
      "text": "In a protocol design, opportunities for evolution are often included in the form of extension points. For example, there may be a codepoint space that is not fully allocated from the outset, and the protocol is designed to tolerate and embrace implementations that start using more codepoints than initially allocated.",
      "ja": "プロトコル設計では、進化の機会はしばしば延長点の形式に含まれます。たとえば、最初から完全に割り当てられていないコードポイントスペースがあり、プロトコルは最初に割り当てられているよりも多くのコードポイントを使用し始める実装を許容し除外するように設計されています。"
    },
    {
      "indent": 3,
      "text": "Sizing the codepoint space may be difficult because the range required may be hard to predict. Protocol designs should attempt to make the codepoint space large enough so that it can slowly be filled over the intended lifetime of the protocol.",
      "ja": "必要な範囲が予測が困難である可能性があるため、コードポイントスペースをサイズ設定することは困難です。プロトコル設計は、コードポイントスペースを十分に大きくすることを試みるべきであり、それがプロトコルの意図された有効期間にわたってゆっくり埋めることができるようにするべきである。"
    },
    {
      "indent": 3,
      "text": "CBOR has three major extension points:",
      "ja": "CBORには3つの主要な延長点があります。"
    },
    {
      "indent": 3,
      "text": "the \"simple\" space (values in major type 7): Of the 24 efficient (and 224 slightly less efficient) values, only a small number have been allocated. Implementations receiving an unknown simple data item may easily be able to process it as such, given that the structure of the value is indeed simple. The IANA registry in Section 9.1 is the appropriate way to address the extensibility of this codepoint space.",
      "ja": "「シンプルな」スペース（メジャータイプ7の値）：24効率（および224わずかに効率的ではない）値の場合、小さい数だけが割り当てられています。未知の単純なデータ項目を受信する実装は、値の構造が確かに単純であることを考えると、それ自体を容易に処理することができます。セクション9.1のIANAレジストリは、このコードポイントスペースの拡張性に対処するための適切な方法です。"
    },
    {
      "indent": 3,
      "text": "the \"tag\" space (values in major type 6): The total codepoint space is abundant; only a tiny part of it has been allocated. However, not all of these codepoints are equally efficient: the first 24 only consume a single (\"1+0\") byte, and half of them have already been allocated. The next 232 values only consume two (\"1+1\") bytes, with nearly a quarter already allocated. These subspaces need some curation to last for a few more decades. Implementations receiving an unknown tag number can choose to process just the enclosed tag content or, preferably, to process the tag as an unknown tag number wrapping the tag content. The IANA registry in Section 9.2 is the appropriate way to address the extensibility of this codepoint space.",
      "ja": "「タグ」スペース（メジャータイプ6の値）：合計コードポイントスペースは豊富です。それの小さな部分だけが割り当てられています。ただし、これらのCEDEPOINTはすべて同様に効率的ではありません。最初の24は単一（ \"1 0\"）バイトを消費し、半数はすでに割り当てられています。次の232の値は2つの（ \"1 1\"）バイトを消費します（ \"1 1\"）。これらの部分空間には、数十年間持続するためのいくつかのキュレーションが必要です。未知のタグ番号を受信する実装は、囲まれたタグコンテンツだけ、または好ましくはタグを処理することを選択することができ、タグコンテンツを包む未知のタグ番号として処理することができる。セクション9.2のIANAレジストリは、このコードポイントスペースの拡張性に対処するための適切な方法です。"
    },
    {
      "indent": 3,
      "text": "the \"additional information\" space: An implementation receiving an unknown additional information value has no way to continue decoding, so allocating codepoints in this space is a major step beyond just exercising an extension point. There are also very few codepoints left. See also Section 7.2.",
      "ja": "「追加情報」スペース：未知の追加情報値を受信する実装は、復号化を継続する方法はありませんので、このスペースにコードポイントを割り当てることは、拡張ポイントを行使するだけの大きなステップです。左側のコードポイントもほとんどありません。セクション7.2も参照してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Curating the Additional Information Space",
      "section_title": true,
      "ja": "7.2. 追加情報スペースをキュレーションする"
    },
    {
      "indent": 3,
      "text": "The human mind is sometimes drawn to filling in little perceived gaps to make something neat. We expect the remaining gaps in the codepoint space for the additional information values to be an attractor for new ideas, just because they are there.",
      "ja": "人間の心は、何かをきれいにするために少し知覚されたギャップを記入するために描かれていることがあります。それらがあるという理由だけで、追加の情報値のためのコードポイントスペースの残りのギャップが新しいアイデアのためのアトラクタになることを期待しています。"
    },
    {
      "indent": 3,
      "text": "The present specification does not manage the additional information codepoint space by an IANA registry. Instead, allocations out of this space can only be done by updating this specification.",
      "ja": "本明細書は、IANAレジストリによる追加情報コードポイントスペースを管理しません。代わりに、このスペースからの割り当ては、この仕様を更新することによってのみ実行できます。"
    },
    {
      "indent": 3,
      "text": "For an additional information value of n >= 24, the size of the additional data typically is 2^(n-24) bytes. Therefore, additional information values 28 and 29 should be viewed as candidates for 128-bit and 256-bit quantities, in case a need arises to add them to the protocol. Additional information value 30 is then the only additional information value available for general allocation, and there should be a very good reason for allocating it before assigning it through an update of the present specification.",
      "ja": "n> = 24の追加情報値の場合、追加データのサイズは通常2 ^（n  -  24）バイトである。したがって、追加情報値28および29は、プロトコルに追加される必要がある場合には、128ビットおよび256ビット数量の候補と見なすべきである。その場合、追加情報値30は、一般的な割り当てに利用可能な唯一の追加情報値であり、本明細書の更新を通じて割り当てる前にそれを割り当てるための非常に良い理由があるべきである。"
    },
    {
      "indent": 0,
      "text": "8. Diagnostic Notation",
      "section_title": true,
      "ja": "8. 診断表記"
    },
    {
      "indent": 3,
      "text": "CBOR is a binary interchange format. To facilitate documentation and debugging, and in particular to facilitate communication between entities cooperating in debugging, this section defines a simple human-readable diagnostic notation. All actual interchange always happens in the binary format.",
      "ja": "CBORはバイナリ交換形式です。マニュアルとデバッグを容易にするために、特にデバッグに協力しているエンティティ間の通信を容易にするために、このセクションでは単純な人間が読める診断表記を定義します。実際の交換はすべてバイナリ形式で常に起こります。"
    },
    {
      "indent": 3,
      "text": "Note that this truly is a diagnostic format; it is not meant to be parsed. Therefore, no formal definition (as in ABNF) is given in this document. (Implementers looking for a text-based format for representing CBOR data items in configuration files may also want to consider YAML [YAML].)",
      "ja": "これは本当に診断フォーマットです。解析されることを意図していません。したがって、この文書には正式な定義（ABNFのように）はありません。（構成ファイル内のCBORデータ項目を表すためのテキストベースのフォーマットを探している実装者は、YAML [YAML]を検討したい場合があります。）"
    },
    {
      "indent": 3,
      "text": "The diagnostic notation is loosely based on JSON as it is defined in RFC 8259, extending it where needed.",
      "ja": "診断表記は、RFC 8259で定義されているため、JSONに基づいているため、必要に応じて拡張します。"
    },
    {
      "indent": 3,
      "text": "The notation borrows the JSON syntax for numbers (integer and floating-point), True (>true<), False (>false<), Null (>null<), UTF-8 strings, arrays, and maps (maps are called objects in JSON; the diagnostic notation extends JSON here by allowing any data item in the key position). Undefined is written >undefined< as in JavaScript. The non-finite floating-point numbers Infinity, -Infinity, and NaN are written exactly as in this sentence (this is also a way they can be written in JavaScript, although JSON does not allow them). A tag is written as an integer number for the tag number, followed by the tag content in parentheses; for instance, a date in the format specified by RFC 3339 (ISO 8601) could be notated as:",
      "ja": "この表記は、数字（整数と浮動小数点）のJSON構文（> true <）、false（> false <）、null（> null <）、UTF-8文字列、配列、およびマップ（MAPSが呼び出されます）JSON内のオブジェクト。診断表記は、ここではJSONをここで鍵位置に許可することによって拡張します）。未定義の<JavaScriptのようにundefined <。非有限の浮動小数点数の無限大、-Infinity、およびNaNはこの文のように正確に書かれています（これはJovaScriptで書くことができる方法でもありますが、JSONはそれらを許可しません）。タグは、タグ番号の整数番号として書かれ、その後にタグ内容が括弧で囲まれています。たとえば、RFC 3339（ISO 8601）で指定された形式の日付は、次のように注目できます。"
    },
    {
      "indent": 8,
      "text": "0(\"2013-03-21T20:04:00Z\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or the equivalent relative time as the following:",
      "ja": "または次のような相対的な相対時間"
    },
    {
      "indent": 8,
      "text": "1(1363896240)",
      "ja": "1（1363896240）"
    },
    {
      "indent": 3,
      "text": "Byte strings are notated in one of the base encodings, without padding, enclosed in single quotes, prefixed by >h< for base16, >b32< for base32, >h32< for base32hex, >b64< for base64 or base64url (the actual encodings do not overlap, so the string remains unambiguous). For example, the byte string 0x12345678 could be written h'12345678', b32'CI2FM6A', or b64'EjRWeA'.",
      "ja": "バイト文字列は、PADDINGの1つで表しています.Piddingは、PDINGを、BASE16、> H32 <BASE32HEX、> B64 <BASE64またはBASS64URL（実際のエンコーディング（実際のエンコーディング（実際のエンコーディング）重ならないように、文字列は明確なままです。たとえば、バイト文字列0x12345678は、H'12345678 '、B32'CI2FM6A'、またはB64'EJREA 'を書くことができます。"
    },
    {
      "indent": 3,
      "text": "Unassigned simple values are given as \"simple()\" with the appropriate integer in the parentheses. For example, \"simple(42)\" indicates major type 7, value 42.",
      "ja": "割り当てられていない単純な値は、括弧内の適切な整数を持つ \"Simple（）\"として与えられます。例えば、「単純（42）」は主要なタイプ7、値42を示す。"
    },
    {
      "indent": 3,
      "text": "A number of useful extensions to the diagnostic notation defined here are provided in Appendix G of [RFC8610], \"Extended Diagnostic Notation\" (EDN). Similarly, this notation could be extended in a separate document to provide documentation for NaN payloads, which are not covered in this document.",
      "ja": "ここで定義されている診断表記法に対するいくつかの便利な拡張は、[RFC8610]、「拡張診断表記」（EDN）の付録Gに提供されています。同様に、この文書ではカバーされていないNaNペイロードの文書化を提供するために、この表記法を別の文書で拡張することができます。"
    },
    {
      "indent": 0,
      "text": "8.1. Encoding Indicators",
      "section_title": true,
      "ja": "8.1. エンコードインジケータ"
    },
    {
      "indent": 3,
      "text": "Sometimes it is useful to indicate in the diagnostic notation which of several alternative representations were actually used; for example, a data item written >1.5< by a diagnostic decoder might have been encoded as a half-, single-, or double-precision float.",
      "ja": "時々それは実際にいくつかの代替表現のうちのいくつかの診断表記を示すことが有用である。たとえば、診断デコーダによって書かれたデータ項目は、半分、単精度のフロート、または倍精度のフロートとしてエンコードされている可能性があります。"
    },
    {
      "indent": 3,
      "text": "The convention for encoding indicators is that anything starting with an underscore and all following characters that are alphanumeric or underscore is an encoding indicator, and can be ignored by anyone not interested in this information. For example, \"_\" or \"_3\". Encoding indicators are always optional.",
      "ja": "エンコードインジケータの規約は、アンダースコアで始まるもの、および英数字またはアンダースコアである次のすべての文字では、符号化インジケータであり、この情報に関心がない人によって無視されることがあります。たとえば、 \"_\"または \"_3\"です。エンコードインジケータは常にオプションです。"
    },
    {
      "indent": 3,
      "text": "A single underscore can be written after the opening brace of a map or the opening bracket of an array to indicate that the data item was represented in indefinite-length format. For example, [_ 1, 2] contains an indicator that an indefinite-length representation was used to represent the data item [1, 2].",
      "ja": "単一のアンダースコアは、データ項目が不定長の形式で表されていることを示すために、アレイの開口部ブレースまたはアレイの開口ブラケットの後に書き込むことができる。例えば、[_ 1,2]は、データ項目[1,2]を表すために不定長の表現を使用した指標を含む。"
    },
    {
      "indent": 3,
      "text": "An underscore followed by a decimal digit n indicates that the preceding item (or, for arrays and maps, the item starting with the preceding bracket or brace) was encoded with an additional information value of 24+n. For example, 1.5_1 is a half-precision floating-point number, while 1.5_3 is encoded as double precision. This encoding indicator is not shown in Appendix A. (Note that the encoding indicator \"_\" is thus an abbreviation of the full form \"_7\", which is not used.)",
      "ja": "アンダースコアとそれに続く10進数字nは、前の項目（またはアレイとマップのために、前のブラケットまたはブレースで始まる項目）が24 nの追加情報値で符号化されていることを示す。たとえば、1.5_1は半精度の浮動小数点数ですが、1.5_3は倍精度として符号化されています。この符号化インジケータは付録Aには示されていない。したがって、符号化インジケータ「_」は、使用されていないフルフォーム「_7」の略語である。）"
    },
    {
      "indent": 3,
      "text": "The detailed chunk structure of byte and text strings of indefinite length can be notated in the form (_ h'0123', h'4567') and (_ \"foo\", \"bar\"). However, for an indefinite-length string with no chunks inside, (_ ) would be ambiguous as to whether a byte string (0x5fff) or a text string (0x7fff) is meant and is therefore not used. The basic forms ''_ and \"\"_ can be used instead and are reserved for the case of no chunks only -- not as short forms for the (permitted, but not really useful) encodings with only empty chunks, which need to be notated as (_ ''), (_ \"\"), etc., to preserve the chunk structure.",
      "ja": "無期限のバイトの詳細なチャンク構造は、（_ h'0123 '、H'4567'）、（_ \"foo\"、 \"bar\"）の形で表現できます。ただし、チャンクなしの不定長文字列の場合は、（_）、バイト文字列（0x5FFF）またはテキスト文字列（0x7FFF）が意味されているかどうかに関しては（_）が曖昧になり、使用されません。代わりに基本形式の「_と」_を使用することができ、Chunksのみの場合の場合は予約されています - （許可されていますが、実際には便利ではありません）の短い形式ではありません。チャンク構造を保持するために（_ ''）、（_ \"\"）などの表記されています。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has created two registries for new CBOR values. The registries are separate, that is, not under an umbrella registry, and follow the rules in [RFC8126]. IANA has also assigned a new media type, an associated CoAP Content-Format entry, and a structured syntax suffix.",
      "ja": "IANAは、新しいCBOR値に2つのレジストリを作成しました。レジストリは別々です。つまり、傘レジストリではなく、[RFC8126]のルールに従います。IANAはまた、新しいメディアタイプ、関連するCOAAコンテンツフォーマットエントリ、および構造化構文サフィックスを割り当てました。"
    },
    {
      "indent": 0,
      "text": "9.1. CBOR Simple Values Registry",
      "section_title": true,
      "ja": "9.1. CBORシンプルな値レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"Concise Binary Object Representation (CBOR) Simple Values\" registry at [IANA.cbor-simple-values]. The initial values are shown in Table 4.",
      "ja": "IANAは「IANA.CBOR-SIMPLE-VALUES」で「簡潔なバイナリオブジェクト表現（CBOR）の単純な値」を作成しました。初期値を表4に示す。"
    },
    {
      "indent": 3,
      "text": "New entries in the range 0 to 19 are assigned by Standards Action [RFC8126]. It is suggested that IANA allocate values starting with the number 16 in order to reserve the lower numbers for contiguous blocks (if any).",
      "ja": "0から19の範囲の新しいエントリは、標準アクション[RFC8126]によって割り当てられます。隣接ブロックの場合は、下位のブロック（もし）を予約するために、IANAが数値16から始まる値を割り当てることが示唆されています。"
    },
    {
      "indent": 3,
      "text": "New entries in the range 32 to 255 are assigned by Specification Required.",
      "ja": "32から255の範囲の新規エントリは、必要な仕様によって割り当てられます。"
    },
    {
      "indent": 0,
      "text": "9.2. CBOR Tags Registry",
      "section_title": true,
      "ja": "9.2. CBORタグレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"Concise Binary Object Representation (CBOR) Tags\" registry at [IANA.cbor-tags]. The tags that were defined in [RFC7049] are described in detail in Section 3.4, and other tags have already been defined since then.",
      "ja": "IANAは「IANA.cbobour-Tags」で「簡潔なバイナリオブジェクト表現（CBOR）タグ」レジストリを作成しました。[RFC7049]で定義されたタグについては、セクション3.4で詳しく説明し、その後他のタグはすでに定義されています。"
    },
    {
      "indent": 3,
      "text": "New entries in the range 0 to 23 (\"1+0\") are assigned by Standards Action. New entries in the ranges 24 to 255 (\"1+1\") and 256 to 32767 (lower half of \"1+2\") are assigned by Specification Required. New entries in the range 32768 to 18446744073709551615 (upper half of \"1+2\", \"1+4\", and \"1+8\") are assigned by First Come First Served. The template for registration requests is:",
      "ja": "0から23（ \"1 0\"）の範囲の新しいエントリは、標準アクションによって割り当てられます。範囲24~255（「1 1」）と256~32767の新たなエントリ（「1 2」の下半分）は、必要な仕様によって割り当てられます。32768~18446744073709555615（「1 2」の上半分、1 4インチ、「1 8」）が最初にサービス提供されている範囲の新規エントリ。登録要求のテンプレートは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Data item",
      "ja": "* データ項目"
    },
    {
      "indent": 3,
      "text": "* Semantics (short form)",
      "ja": "* セマンティクス（短縮形）"
    },
    {
      "indent": 3,
      "text": "In addition, First Come First Served requests should include:",
      "ja": "さらに、最初に最初にサービスされている要求に含まれるべきです。"
    },
    {
      "indent": 3,
      "text": "* Point of contact",
      "ja": "* 接点"
    },
    {
      "indent": 3,
      "text": "* Description of semantics (URL) -- This description is optional; the URL can point to something like an Internet-Draft or a web page.",
      "ja": "* セマンティクスの説明（URL） - この説明はオプションです。URLはインターネットドラフトやWebページのようなものを指すことがあります。"
    },
    {
      "indent": 3,
      "text": "Applicants exercising the First Come First Served range and making a suggestion for a tag number that is not representable in 32 bits (i.e., larger than 4294967295) should be aware that this could reduce interoperability with implementations that do not support 64-bit numbers.",
      "ja": "出願人は最初のサービスを行使し、32ビットで表現可能ではないタグ番号の提案を行っており（すなわち、4294967295より大きい）。これにより、64ビット数をサポートしない実装との相互運用性を低下させる可能性があることに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.3. Media Types Registry",
      "section_title": true,
      "ja": "9.3. メディアタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "The Internet media type [RFC6838] (\"MIME type\") for a single encoded CBOR data item is \"application/cbor\" as defined in the \"Media Types\" registry [IANA.media-types]:",
      "ja": "単一のエンコードされたCBORデータ項目のインターネットメディアタイプ（「MIMEタイプ」）は、「メディアタイプ」レジストリ[IANA.MEDIA-TYPES]で定義されている「アプリケーション/ CBOR」です。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: cbor",
      "ja": "サブタイプ名：CBOR."
    },
    {
      "indent": 3,
      "text": "Required parameters: n/a",
      "ja": "必要なパラメータ：N / A."
    },
    {
      "indent": 3,
      "text": "Optional parameters: n/a",
      "ja": "オプションのパラメータ：n / A."
    },
    {
      "indent": 3,
      "text": "Encoding considerations: Binary",
      "ja": "エンコードに関する考慮事項：バイナリ"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 10 of RFC 8949.",
      "ja": "セキュリティ上の考慮事項：RFC 8949のセクション10を参照してください。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: n/a",
      "ja": "相互運用性の考慮事項：N / A."
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 8949",
      "ja": "公開仕様：RFC 8949"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Many",
      "ja": "このメディアタイプを使用するアプリケーション：多数"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "Magic number(s):  n/a\nFile extension(s):  .cbor\nMacintosh file type code(s):  n/a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: IETF CBOR Working Group (cbor@ietf.org) or IETF Applications and Real-Time Area (art@ietf.org)",
      "ja": "関連情報については、連絡先のある人とEメールアドレス：IETF CBORワーキンググループ（CBOR@IETF.ORG）またはIETFアプリケーションとリアルタイムエリア（art@ietf.org）"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図された使用法：一般的な"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: none",
      "ja": "使用制限：なし"
    },
    {
      "indent": 3,
      "text": "Author: IETF CBOR Working Group (cbor@ietf.org)",
      "ja": "著者：IETF CBORワーキンググループ（CBOR@IETF.ORG）"
    },
    {
      "indent": 3,
      "text": "Change controller: The IESG (iesg@ietf.org)",
      "ja": "変更コントローラー：IESG（iesg@ietf.org）"
    },
    {
      "indent": 0,
      "text": "9.4. CoAP Content-Format Registry",
      "section_title": true,
      "ja": "9.4. COAP Content-Formatレジストリ"
    },
    {
      "indent": 3,
      "text": "The CoAP Content-Format for CBOR has been registered in the \"CoAP Content-Formats\" subregistry within the \"Constrained RESTful Environments (CoRE) Parameters\" registry [IANA.core-parameters]:",
      "ja": "CBORのCOAPコンテンツフォーマットは、「制約付きRESTFUL環境（コア）パラメータ」レジストリ[IANA.CORE-PARAMPERAMEDAGE]内の「COAA Content-Formats」サブレイストに登録されています。"
    },
    {
      "indent": 3,
      "text": "Media Type: application/cbor",
      "ja": "メディアタイプ：アプリケーション/ CBOR"
    },
    {
      "indent": 3,
      "text": "Encoding: -",
      "ja": "エンコード： - "
    },
    {
      "indent": 3,
      "text": "ID: 60",
      "ja": "ID：60"
    },
    {
      "indent": 3,
      "text": "Reference: RFC 8949",
      "ja": "参照：RFC 8949"
    },
    {
      "indent": 0,
      "text": "9.5. Structured Syntax Suffix Registry",
      "section_title": true,
      "ja": "9.5. 構造化構文サフィックスレジストリ"
    },
    {
      "indent": 3,
      "text": "The structured syntax suffix [RFC6838] for media types based on a single encoded CBOR data item is +cbor, which IANA has registered in the \"Structured Syntax Suffixes\" registry [IANA.structured-suffix]:",
      "ja": "単一のエンコードされたCBORデータ項目に基づくメディアタイプのための構造化シンタックスサフィックス[RFC6838]は、「構造化構文サフィックス」レジストリ[IANA.STRUCTURED-SUFFIX]に登録したCBORです。"
    },
    {
      "indent": 3,
      "text": "Name: Concise Binary Object Representation (CBOR)",
      "ja": "名前：簡潔なバイナリオブジェクト表現（CBOR）"
    },
    {
      "indent": 3,
      "text": "+suffix:  +cbor",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "References: RFC 8949",
      "ja": "参照：RFC 8949"
    },
    {
      "indent": 3,
      "text": "Encoding Considerations: CBOR is a binary format.",
      "ja": "エンコードに関する考慮事項：CBORはバイナリ形式です。"
    },
    {
      "indent": 3,
      "text": "Interoperability Considerations: n/a",
      "ja": "相互運用性の考慮事項：N / A."
    },
    {
      "indent": 3,
      "text": "Fragment Identifier Considerations: The syntax and semantics of fragment identifiers specified for +cbor SHOULD be as specified for \"application/cbor\". (At publication of RFC 8949, there is no fragment identification syntax defined for \"application/cbor\".)",
      "ja": "フラグメント識別子の考慮事項：CBORに指定されているフラグメント識別子の構文とセマンティクスは、「アプリケーション/ CBOR」に指定する必要があります。（RFC 8949の出版時には、「アプリケーション/ CBOR」に定義されているフラグメント識別構文はありません。）"
    },
    {
      "indent": 6,
      "text": "The syntax and semantics for fragment identifiers for a specific \"xxx/yyy+cbor\" SHOULD be processed as follows:",
      "ja": "特定の「XXX / YYY CBOR」のフラグメント識別子の構文とセマンティクスは次のように処理されるべきです。"
    },
    {
      "indent": 6,
      "text": "* For cases defined in +cbor, where the fragment identifier resolves per the +cbor rules, then process as specified in +cbor.",
      "ja": "* CBORで定義されているケースでは、フラグメント識別子がCBOBORの規則ごとに解決され、次にCBORで指定されているようにプロセスを実行します。"
    },
    {
      "indent": 6,
      "text": "* For cases defined in +cbor, where the fragment identifier does not resolve per the +cbor rules, then process as specified in \"xxx/yyy+cbor\".",
      "ja": "* CBORで定義されている場合、フラグメント識別子がCBOBORルールごとに解決されない場合は、「XXX / YYY CBOR」で指定されているプロセスを処理します。"
    },
    {
      "indent": 6,
      "text": "* For cases not defined in +cbor, then process as specified in \"xxx/yyy+cbor\".",
      "ja": "* CBORで定義されていない場合は、「XXX / YYY CBOR」で指定されているとおりに処理します。"
    },
    {
      "indent": 3,
      "text": "Security Considerations: See Section 10 of RFC 8949.",
      "ja": "セキュリティ上の考慮事項：RFC 8949のセクション10を参照してください。"
    },
    {
      "indent": 3,
      "text": "Contact: IETF CBOR Working Group (cbor@ietf.org) or IETF Applications and Real-Time Area (art@ietf.org)",
      "ja": "連絡先：IETF CBORワーキンググループ（CBOR@IETF.ORG）またはIETFアプリケーションとリアルタイムエリア（art@ietf.org）"
    },
    {
      "indent": 3,
      "text": "Author/Change Controller: IETF",
      "ja": "作成者/変更コントローラー：IETF"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A network-facing application can exhibit vulnerabilities in its processing logic for incoming data. Complex parsers are well known as a likely source of such vulnerabilities, such as the ability to remotely crash a node, or even remotely execute arbitrary code on it. CBOR attempts to narrow the opportunities for introducing such vulnerabilities by reducing parser complexity, by giving the entire range of encodable values a meaning where possible.",
      "ja": "ネットワーク向けアプリケーションは、着信データの処理ロジックで脆弱性を発揮できます。複雑なパーサーは、ノードをリモートでクラッシュさせる機能など、そのような脆弱性の源としてよく知られています。また、リモートで任意のコードをリモートで実行することさえあります。CBORは、符号化可能値の全範囲を可能な限りの意味を意味することによって、パーサの複雑さを減らすことによってそのような脆弱性を導入する機会を狭めようとしています。"
    },
    {
      "indent": 3,
      "text": "Because CBOR decoders are often used as a first step in processing unvalidated input, they need to be fully prepared for all types of hostile input that may be designed to corrupt, overrun, or achieve control of the system decoding the CBOR data item. A CBOR decoder needs to assume that all input may be hostile even if it has been checked by a firewall, has come over a secure channel such as TLS, is encrypted or signed, or has come from some other source that is presumed trusted.",
      "ja": "CBORデコーダは、検証されていない入力を処理する最初のステップとしてよく使用されるため、システムの破損、オーバーラン、またはCBOBORデータ項目の復号化、または制御を行うように設計されているすべてのタイプの敵対入力に対して完全に準備される必要があります。CBORデコーダは、ファイアウォールによってチェックされていてもすべての入力が敵対的である可能性があると仮定する必要があり、TLSのような安全なチャネルを超えて暗号化または署名されているか、信頼されている他のソースから来たか"
    },
    {
      "indent": 3,
      "text": "Section 4.1 gives examples of limitations in interoperability when using a constrained CBOR decoder with input from a CBOR encoder that uses a non-preferred serialization. When a single data item is consumed both by such a constrained decoder and a full decoder, it can lead to security issues that can be exploited by an attacker who can inject or manipulate content.",
      "ja": "セクション4.1は、非優先シリアル化を使用するCBORエンコーダからの入力を伴う制約付きCBORデコーダを使用するときの相互運用性の制限の例を示しています。そのような制約付きデコーダとフルデコーダの両方によって単一のデータ項目が消費されると、コンテンツを注入または操作することができる攻撃者によって悪用されることができるセキュリティ問題につながる可能性がある。"
    },
    {
      "indent": 3,
      "text": "As discussed throughout this document, there are many values that can be considered \"equivalent\" in some circumstances and \"not equivalent\" in others. As just one example, the numeric value for the number \"one\" might be expressed as an integer or a bignum. A system interpreting CBOR input might accept either form for the number \"one\", or might reject one (or both) forms. Such acceptance or rejection can have security implications in the program that is using the interpreted input.",
      "ja": "この文書を通して説明したように、状況によっては「同等の」と見なすことができる多くの値があり、他の状況では「同等のものではない」。一例だけでは、「1」という番号の数値は、整数またはBignumとして表される可能性があります。CBOBOR入力を解釈するシステムは、番号「1」のいずれかのフォームを受け入れることも、1つのフォーム（またはその両方）を拒否することがあります。そのような受け入れまたは拒絶は、解釈された入力を使用しているプログラムにおいてセキュリティの影響を受ける可能性がある。"
    },
    {
      "indent": 3,
      "text": "Hostile input may be constructed to overrun buffers, to overflow or underflow integer arithmetic, or to cause other decoding disruption. CBOR data items might have lengths or sizes that are intentionally extremely large or too short. Resource exhaustion attacks might attempt to lure a decoder into allocating very big data items (strings, arrays, maps, or even arbitrary precision numbers) or exhaust the stack depth by setting up deeply nested items. Decoders need to have appropriate resource management to mitigate these attacks. (Items for which very large sizes are given can also attempt to exploit integer overflow vulnerabilities.)",
      "ja": "敵対的な入力は、バッファをオーバーランするように構築され、整数演算またはアンダーフロー演算、または他の復号化中断を引き起こすことがあります。CBORデータ項目には、意図的に非常に大きい、または短すぎる長さやサイズがある可能性があります。リソースの枯渇攻撃は、非常に大きなデータ項目の割り当て（文字列、配列、マップ、さらには任意の精密数）を割り当てるためにデコーダを誘導したり、深く入れ子になったアイテムを設定してスタックの深さを排気したりする可能性があります。デコーダは、これらの攻撃を軽減するために適切なリソース管理を持つ必要があります。（非常に大きなサイズが与えられるアイテムはまた、整数のオーバーフローの脆弱性を悪用することを試みる可能性があります。）"
    },
    {
      "indent": 3,
      "text": "A CBOR decoder, by definition, only accepts well-formed CBOR; this is the first step to its robustness. Input that is not well-formed CBOR causes no further processing from the point where the lack of well-formedness was detected. If possible, any data decoded up to this point should have no impact on the application using the CBOR decoder.",
      "ja": "CBORデコーダは、定義によって、よく形成されたCBORを受け入れるだけです。これはその堅牢性の最初のステップです。十分に形成されていないCBORは、十分に形成されていない点からそれ以上の処理を引き起こさない。可能であれば、この時点まで復号されたデータは、CBORデコーダを使用しているアプリケーションに影響を与えないはずです。"
    },
    {
      "indent": 3,
      "text": "In addition to ascertaining well-formedness, a CBOR decoder might also perform validity checks on the CBOR data. Alternatively, it can leave those checks to the application using the decoder. This choice needs to be clearly documented in the decoder. Beyond the validity at the CBOR level, an application also needs to ascertain that the input is in alignment with the application protocol that is serialized in CBOR.",
      "ja": "十分に形成されることに加えて、CBORデコーダはCBORデータの有効性チェックを実行することができる。あるいは、それらのチェックをデコーダを使用してアプリケーションにチェックすることもできます。この選択はデコーダには明確に文書化される必要があります。CBORレベルでの妥当性を超えて、アプリケーションは、CBORでシリアル化されているアプリケーションプロトコルと整列していることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "The input check itself may consume resources. This is usually linear in the size of the input, which means that an attacker has to spend resources that are commensurate to the resources spent by the defender on input validation. However, an attacker might be able to craft inputs that will take longer for a target decoder to process than for the attacker to produce. Processing for arbitrary-precision numbers may exceed linear effort. Also, some hash-table implementations that are used by decoders to build in-memory representations of maps can be attacked to spend quadratic effort, unless a secret key (see Section 7 of [SIPHASH_LNCS], also [SIPHASH_OPEN]) or some other mitigation is employed. Such superlinear efforts can be exploited by an attacker to exhaust resources at or before the input validator; they therefore need to be avoided in a CBOR decoder implementation. Note that tag number definitions and their implementations can add security considerations of this kind; this should then be discussed in the security considerations of the tag number definition.",
      "ja": "入力チェック自体はリソースを消費する可能性があります。これは通常、入力のサイズで線形です。つまり、攻撃者は、Defenderが費やしているリソースに支持されたリソースを入力検証に費やす必要があります。ただし、攻撃者は、攻撃者が生産するためよりもターゲットデコーダが処理するのに時間がかかる入力を作り出すことができるかもしれません。任意精度数の処理は線形努力を超える可能性があります。また、秘密鍵（Siphash_LNCSのセクション7、Siphash_open]のセクション7を参照）またはその他の緩和を除いて、マップ内のメモリ表現を構築するためにデコーダによって使用されるいくつかのハッシュテーブル実装を攻撃することができる。雇用されている。そのような超円の努力は、攻撃者が入力バリデータ以前またはその前にリソースを排出することによって利用することができる。したがって、それらはCBORデコーダの実装では避ける必要があります。タグ番号の定義とその実装はこの種のセキュリティ上の考慮事項を追加することができることに注意してください。これは、タグ番号の定義のセキュリティ上の考慮事項で説明するはずです。"
    },
    {
      "indent": 3,
      "text": "CBOR encoders do not receive input directly from the network and are thus not directly attackable in the same way as CBOR decoders. However, CBOR encoders often have an API that takes input from another level in the implementation and can be attacked through that API. The design and implementation of that API should assume the behavior of its caller may be based on hostile input or on coding mistakes. It should check inputs for buffer overruns, overflow and underflow of integer arithmetic, and other such errors that are aimed to disrupt the encoder.",
      "ja": "CBORエンコーダはネットワークから直接入力を受け取らず、CBORデコーダと同じ方法で直接攻撃されない。ただし、CBORエンコーダには、実装内の別のレベルから入力を受けるAPIがあり、そのAPIを通して攻撃される可能性があります。そのAPIの設計と実装は、その発信者の動作が敵対的な入力または符号化間隔に基づいている可能性があると仮定するべきである。バッファオーバーラン、オーバーフロー、および整数演算のアンダーフロー、およびエンコーダの中断を目的としたその他のエラーの入力を確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Protocols should be defined in such a way that potential multiple interpretations are reliably reduced to a single interpretation. For example, an attacker could make use of invalid input such as duplicate keys in maps, or exploit different precision in processing numbers to make one application base its decisions on a different interpretation than the one that will be used by a second application. To facilitate consistent interpretation, encoder and decoder implementations should provide a validity-checking mode of operation (Section 5.4). Note, however, that a generic decoder cannot know about all requirements that an application poses on its input data; it is therefore not relieving the application from performing its own input checking. Also, since the set of defined tag numbers evolves, the application may employ a tag number that is not yet supported for validity checking by the generic decoder it uses. Generic decoders therefore need to document which tag numbers they support and what validity checking they provide for those tag numbers as well as for basic CBOR (UTF-8 checking, duplicate map key checking).",
      "ja": "プロトコルは、潜在的な複数の解釈が確実に単一の解釈に減少するように定義されるべきです。たとえば、攻撃者は、マップ内の重複キーなどの無効な入力を利用することも、1つのアプリケーションが2番目のアプリケーションで使用されるものとは異なる解釈で1つのアプリケーションを決定するために異なる精度を処理することができます。一貫した解釈を容易にするために、エンコーダおよびデコーダの実装は有効性チェック動作モードを提供する必要があります（セクション5.4）。ただし、一般的なデコーダは、アプリケーションがその入力データを搭載したすべての要件について知らないことに注意してください。したがって、アプリケーションは独自の入力チェックを実行することを軽減しません。また、定義されたタグ番号のセットが進化するため、アプリケーションは、使用する一般的なデコーダによる有効性検査ではまだサポートされていないタグ番号を採用することができる。したがって、一般的なデコーダは、どのタグ番号をサポートしているか、およびそれらがそれらがこれらのタグ番号を提供する妥当性検査と基本的なCBOR（UTF-8チェック、重複マップキーチェック）を文書化する必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 3.4.3 notes that using the non-preferred choice of a bignum representation instead of a basic integer for encoding a number is not intended to have application semantics, but it can have such semantics if an application receiving CBOR data is using a decoder in the basic generic data model. This disparity causes a security issue if the two sets of semantics differ. Thus, applications using CBOR need to specify the data model that they are using for each use of CBOR data.",
      "ja": "セクション3.4.3番号をエンコードするための基本整数の代わりにBignum表現の非優先選択を使用することは、アプリケーションセマンティクスを持つことを意図していませんが、CBOBORデータを受信しているアプリケーションがデコーダを使用している場合はそのようなセマンティクスを持つことができます。基本的な一般データモデル2組のセマンティクスが異なる場合、この格差はセキュリティの問題を引き起こします。したがって、CBORを使用するアプリケーションは、CBOBORデータの使用ごとに使用しているデータモデルを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is common to convert CBOR data to other formats. In many cases, CBOR has more expressive types than other formats; this is particularly true for the common conversion to JSON. The loss of type information can cause security issues for the systems that are processing the less-expressive data.",
      "ja": "CBORデータを他のフォーマットに変換するのは一般的です。多くの場合、CBORは他のフォーマットよりも表現的な型を持っています。これはJSONへの一般的な変換に特に当てはまります。タイプ情報の損失は、より遅いデータを処理しているシステムのセキュリティ上の問題を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Section 6.2 describes a possibly common usage scenario of converting between CBOR and JSON that could allow an attack if the attacker knows that the application is performing the conversion.",
      "ja": "第6.2節では、攻撃者がアプリケーションが変換を実行していることを知っている場合、攻撃者が攻撃を許可する可能性があるCBORとJSON間の変換の一般的な使用シナリオについて説明します。"
    },
    {
      "indent": 3,
      "text": "Security considerations for the use of base16 and base64 from [RFC4648], and the use of UTF-8 from [RFC3629], are relevant to CBOR as well.",
      "ja": "[RFC4648]からBASE16とBASIC64を使用するためのセキュリティ上の考慮事項と[RFC3629]からのUTF-8の使用は、CBORにも関連しています。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[C] International Organization for Standardization, \"Information technology - Programming languages - C\", Fourth Edition, ISO/IEC 9899:2018, June 2018, <https://www.iso.org/standard/74528.html>.",
      "ja": "[C]標準化のための国際機関、「情報技術 - プログラミング言語 -  C」、第4版、ISO / IEC 9899：2018、2018年6月、<https：//www.iso.org/standard/74528.html>。"
    },
    {
      "indent": 3,
      "text": "[Cplusplus20] International Organization for Standardization, \"Programming languages - C++\", Sixth Edition, ISO/IEC DIS 14882, ISO/IEC ISO/IEC JTC1 SC22 WG21 N 4860, March 2020, <https://isocpp.org/files/papers/N4860.pdf>.",
      "ja": "[Cplusplus20]国際標準化、「プログラミング言語 -  C」、第6版、ISO / IEC DIS 14882、ISO / IEC IEC JTC1 SC22 WG21 N 4860、2020年3月、<https://isocp.org/files/論文/ N4860.pdf>。"
    },
    {
      "indent": 3,
      "text": "[IEEE754] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE Std 754-2019, DOI 10.1109/IEEESTD.2019.8766229, <https://ieeexplore.ieee.org/document/8766229>.",
      "ja": "[IEEE754] IEEE、「浮動小数点演算のためのIEEE規格」、IEEE STD 754-2019、DOI 10.1109 / IEEESTD.2019.8766229、<https：//ieeexplore.iee.org/document/8766229>。"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, DOI 10.17487/RFC2045, November 1996, <https://www.rfc-editor.org/info/rfc2045>.",
      "ja": "[RFC2045] Freed、N.およびN.Borenstein、「マルチポーズインターネットメール拡張（MIME）パート1：インターネットメッセージボディのフォーマット」、RFC 2045、DOI 10.17487 / RFC2045、1996年11月、<https：///www.rfc-editor.org/info/rfc2045>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https：//www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, DOI 10.17487/RFC3339, July 2002, <https://www.rfc-editor.org/info/rfc3339>.",
      "ja": "[RFC3339] Klyne、G.およびC. NEWMAN、「インターネット上の日時：Timestamps」、RFC 3339、DOI 10.17487 / RFC3339、2002年7月、<https：//www.rfc-editor.org/info/rfc3339>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] YERGEAU、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https：//www.rfc-editor.org/info/RFC3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Field、R.、およびL.Masinter、「Uniform Resource Identifier（URI）：汎用構文」、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月、<https：//www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4287] Nottingham, M., Ed. and R. Sayre, Ed., \"The Atom Syndication Format\", RFC 4287, DOI 10.17487/RFC4287, December 2005, <https://www.rfc-editor.org/info/rfc4287>.",
      "ja": "[RFC4287]ノッティンガム、M、ED。R. Sayre、Ed。、「Atom Syndication Format」、RFC 4287、DOI 10.17487 / RFC4287、2005年12月、<https：//www.rfc-editor.org/info/rfc4287>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「Base16、Base32、およびBase64データエンコーディング」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<https：//www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]綿、M.、Leiba、B.およびT.Narten、「RFCSのIANAに関する考察のためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<HTTPS：// WWW.rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[TIME_T] The Open Group, \"The Open Group Base Specifications\", Section 4.16, 'Seconds Since the Epoch', Issue 7, 2018 Edition, IEEE Std 1003.1, 2018, <https://pubs.opengroup.org/onlinepubs/9699919799/ basedefs/V1_chap04.html#tag_04_16>.",
      "ja": "[time_t]オープングループ、「オープングループ基本仕様」、4.16節、「エポック」、2018年、2018年、IEEE STD 1003.1,2018、<https://pubs.opengroup.org/onlinepubs/9699919799 / BASEDEFS / v1_chap04.html #ag_04_16>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ASN.1] International Telecommunication Union, \"Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, 2015, <https://www.itu.int/rec/T-REC-X.690-201508-I/en>.",
      "ja": "[ASN.1]国際電気通信組合、「情報技術 -  ASN.1符号化規則：基本符号化規則（BER）、正規符号化規則（CER）および識別エンコーディング規則（DER）」、ITU-T勧告X.690、2015、<https://www.itu.int/rec/t-rec-x.690-201508-i/ja>。"
    },
    {
      "indent": 3,
      "text": "[BSON] Various, \"BSON - Binary JSON\", <http://bsonspec.org/>.",
      "ja": "[BSON]さまざまな「BSON  -  Binary JSON」、<http://bsonspec.org/>。"
    },
    {
      "indent": 3,
      "text": "[CBOR-TAGS] Bormann, C., \"Notable CBOR Tags\", Work in Progress, Internet-Draft, draft-bormann-cbor-notable-tags-02, 25 June 2020, <https://tools.ietf.org/html/draft-bormann-cbor-notable-tags-02>.",
      "ja": "[CBOR-TAG] Bormann、C.、「注目すべき履歴書」、進行中の作業、インターネットドラフト、ドラフト -  Bormann-Cbor-Notim-Tags-02,25 6月25日、<https：//tools.ietf.org/ html / draft-bormann-cbor-notam-02>。"
    },
    {
      "indent": 3,
      "text": "[ECMA262] Ecma International, \"ECMAScript 2020 Language Specification\", Standard ECMA-262, 11th Edition, June 2020, <https://www.ecma-international.org/publications/standards/Ecma-262.htm>.",
      "ja": "[ECMA262] ECMA International、「ECMAScript 2020言語仕様」、標準ECMA-262、第11版、2020年6月、<https：//www.ecma-international.org/publications/standards/ecma-262.htm>。"
    },
    {
      "indent": 3,
      "text": "[Err3764] RFC Errata, Erratum ID 3764, RFC 7049, <https://www.rfc-editor.org/errata/eid3764>.",
      "ja": "[ERR3764] RFCエラータ、Erratum ID 3764、RFC 7049、<https://www.rfc-editor.org/errata/eid3764>。"
    },
    {
      "indent": 3,
      "text": "[Err3770] RFC Errata, Erratum ID 3770, RFC 7049, <https://www.rfc-editor.org/errata/eid3770>.",
      "ja": "[ERR3770] RFCエラータ、Erratum ID 3770、RFC 7049、<https://www.rfc-editor.org/errata/eid3770>。"
    },
    {
      "indent": 3,
      "text": "[Err4294] RFC Errata, Erratum ID 4294, RFC 7049, <https://www.rfc-editor.org/errata/eid4294>.",
      "ja": "[ERR4294] RFCエラータ、Erratum ID 4294、RFC 7049、<https://www.rfc-editor.org/errata/eid4294>。"
    },
    {
      "indent": 3,
      "text": "[Err4409] RFC Errata, Erratum ID 4409, RFC 7049, <https://www.rfc-editor.org/errata/eid4409>.",
      "ja": "[ERR4409] RFCエラータ、Erratum ID 4409、RFC 7049、<https://www.rfc-editor.org/errata/eid4409>。"
    },
    {
      "indent": 3,
      "text": "[Err4963] RFC Errata, Erratum ID 4963, RFC 7049, <https://www.rfc-editor.org/errata/eid4963>.",
      "ja": "[ERR4963] RFCエラータ、Erratum ID 4963、RFC 7049、<https://www.rfc-editor.org/errata/eid4963>。"
    },
    {
      "indent": 3,
      "text": "[Err4964] RFC Errata, Erratum ID 4964, RFC 7049, <https://www.rfc-editor.org/errata/eid4964>.",
      "ja": "[err4964] RFCエラータ、Erratum ID 4964、RFC 7049、<https://www.rfc-editor.org/errata/eid4964>。"
    },
    {
      "indent": 3,
      "text": "[Err5434] RFC Errata, Erratum ID 5434, RFC 7049, <https://www.rfc-editor.org/errata/eid5434>.",
      "ja": "[ERR5434] RFCエラータ、Erratum ID 5434、RFC 7049、<https://www.rfc-editor.org/errata/eid5434>。"
    },
    {
      "indent": 3,
      "text": "[Err5763] RFC Errata, Erratum ID 5763, RFC 7049, <https://www.rfc-editor.org/errata/eid5763>.",
      "ja": "[ERR5763] RFCエラータ、Erratum ID 5763、RFC 7049、<https://www.rfc-editor.org/errata/eid5763>。"
    },
    {
      "indent": 3,
      "text": "[Err5917] RFC Errata, Erratum ID 5917, RFC 7049, <https://www.rfc-editor.org/errata/eid5917>.",
      "ja": "[ERR5917] RFCエラータ、Erratum ID 5917、RFC 7049、<https://www.rfc-editor.org/errata/eid5917>。"
    },
    {
      "indent": 3,
      "text": "[IANA.cbor-simple-values] IANA, \"Concise Binary Object Representation (CBOR) Simple Values\", <https://www.iana.org/assignments/cbor-simple-values>.",
      "ja": "[IANA.CBOR-SIMPLE-VALUES] IANA、「簡潔なバイナリオブジェクト表現（CBOR）単純な値」、<https：//www.iana.org/assignments/cbobor-simple-values>。"
    },
    {
      "indent": 3,
      "text": "[IANA.cbor-tags] IANA, \"Concise Binary Object Representation (CBOR) Tags\", <https://www.iana.org/assignments/cbor-tags>.",
      "ja": "[IANA.CBOR-TAGS] IANA、「簡潔なバイナリオブジェクト表現（CBOR）タグ」、<https：//www.iana.org/assignments/cbor-tags>。"
    },
    {
      "indent": 3,
      "text": "[IANA.core-parameters] IANA, \"Constrained RESTful Environments (CoRE) Parameters\", <https://www.iana.org/assignments/core-parameters>.",
      "ja": "[IANA.CORE-PARAMATCOLS] IANA、「制約付きRESTFUL環境（コア）パラメータ」、<https：//www.iana.org/ashignments/core-parameters>。"
    },
    {
      "indent": 3,
      "text": "[IANA.media-types] IANA, \"Media Types\", <https://www.iana.org/assignments/media-types>.",
      "ja": "[IANA.MEDIA-TYPES] IANA、「メディアタイプ」、<https：//www.iana.org/assignments/media-types>。"
    },
    {
      "indent": 3,
      "text": "[IANA.structured-suffix] IANA, \"Structured Syntax Suffixes\", <https://www.iana.org/assignments/media-type-structured-suffix>.",
      "ja": "[IANA.STRUCTURED-SUFFIX] IANA、「構造化構文接尾辞」、<https：//www.iana.org/assignments/media-type-Structured-Suffix>。"
    },
    {
      "indent": 3,
      "text": "[MessagePack] Furuhashi, S., \"MessagePack\", <https://msgpack.org/>.",
      "ja": "[MessagePack]古橋、S.、 \"MessagePack\"、<https：//msgpack.org/>。"
    },
    {
      "indent": 3,
      "text": "[PCRE] Hazel, P., \"PCRE - Perl Compatible Regular Expressions\", <https://www.pcre.org/>.",
      "ja": "[PCRE]ヘーゼル、P.、 \"PCRE  -  PERL対応正規表現\"、<https：//www.pcre.org/>。"
    },
    {
      "indent": 3,
      "text": "[RFC0713] Haverty, J., \"MSDTP-Message Services Data Transmission Protocol\", RFC 713, DOI 10.17487/RFC0713, April 1976, <https://www.rfc-editor.org/info/rfc713>.",
      "ja": "[RFC0713] Haverty、J.、 \"MSDTP-Message Servicesデータ伝送プロトコル\"、RFC 713、DOI 10.17487 / RFC0713、1976年4月、<https://www.rfc-editor.org/info/rfc713>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <https://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838] Freed、N.、Klensin、J.、およびT.Hansen、「メディアタイプの仕様および登録手順」、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<https：///www.rfc-editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC7049] Bormann, C. and P. Hoffman, \"Concise Binary Object Representation (CBOR)\", RFC 7049, DOI 10.17487/RFC7049, October 2013, <https://www.rfc-editor.org/info/rfc7049>.",
      "ja": "[RFC7049] Bormann、C.およびP.Hoffman、「簡潔なバイナリオブジェクト表現（CBOR）」、RFC 7049、DOI 10.17487 / RFC7049、2013年10月、<https：//www.rfc-editor.org/info/rfc7049>。"
    },
    {
      "indent": 3,
      "text": "[RFC7228] Bormann, C., Ersue, M., and A. Keranen, \"Terminology for Constrained-Node Networks\", RFC 7228, DOI 10.17487/RFC7228, May 2014, <https://www.rfc-editor.org/info/rfc7228>.",
      "ja": "[RFC7228] Bormann、C.、Eresut、M.およびA.ケラネン、「拘束ノードネットワークのための用語」、RFC 7228、DOI 10.17487 / RFC 7228、2014年5月、<https：//www.rfc-editor.org/ info / rfc7228>。"
    },
    {
      "indent": 3,
      "text": "[RFC7493] Bray, T., Ed., \"The I-JSON Message Format\", RFC 7493, DOI 10.17487/RFC7493, March 2015, <https://www.rfc-editor.org/info/rfc7493>.",
      "ja": "[RFC7493] Bray、T.、Ed。、「I-JSONメッセージフォーマット」、RFC 7493、DOI 10.17487 / RFC7493、2015年3月、<https：//www.rfc-editor.org/info/rfc7493>。"
    },
    {
      "indent": 3,
      "text": "[RFC7991] Hoffman, P., \"The \"xml2rfc\" Version 3 Vocabulary\", RFC 7991, DOI 10.17487/RFC7991, December 2016, <https://www.rfc-editor.org/info/rfc7991>.",
      "ja": "[RFC7991] HOFFMAN、P.、「XML2RFC「バージョン3語彙」、RFC 7991、DOI 10.17487 / RFC7991、2016年12月、<https://www.rfc-editor.org/info/rfc7991>。"
    },
    {
      "indent": 3,
      "text": "[RFC8259] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017, <https://www.rfc-editor.org/info/rfc8259>.",
      "ja": "[RFC8259] Bray、T.、ED。、「JavaScriptオブジェクト表記（JSON）データ交換フォーマット」、STD 90、RFC 8259、DOI 10.17487 / RFC8259、2017年12月、<https：//www.rfc-editor.org/ info / rfc8259>。"
    },
    {
      "indent": 3,
      "text": "[RFC8610] Birkholz, H., Vigano, C., and C. Bormann, \"Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures\", RFC 8610, DOI 10.17487/RFC8610, June 2019, <https://www.rfc-editor.org/info/rfc8610>.",
      "ja": "[RFC8610] Birkholz、H.、Vigano、C. Bormann、「簡潔なデータ定義言語（CDDL）：簡潔なバイナリオブジェクト表現（CBOR）とJSONデータ構造を表現する表記規則」、RFC 8610、DOI 10.17487/ RFC8610、2019年6月、<https://www.rfc-editor.org/info/rfc8610>。"
    },
    {
      "indent": 3,
      "text": "[RFC8618] Dickinson, J., Hague, J., Dickinson, S., Manderson, T., and J. Bond, \"Compacted-DNS (C-DNS): A Format for DNS Packet Capture\", RFC 8618, DOI 10.17487/RFC8618, September 2019, <https://www.rfc-editor.org/info/rfc8618>.",
      "ja": "[RFC8618]ディッキンソン、J.、Hague、J.、Dickinson、S.、Manderson、T.、J. Bond、「コンパクトDNS（C-DNS）：DNSパケットキャプチャのフォーマット、RFC 8618、DOI10.17487 / RFC8618、2019年9月、<https：//www.rfc-editor.org/info/rfc8618>。"
    },
    {
      "indent": 3,
      "text": "[RFC8742] Bormann, C., \"Concise Binary Object Representation (CBOR) Sequences\", RFC 8742, DOI 10.17487/RFC8742, February 2020, <https://www.rfc-editor.org/info/rfc8742>.",
      "ja": "[RFC8742] Bormann、C.、「CBOR）シーケンス」、RFC 8742、DOI 10.17487 / RFC8742、2020年2月、<https://www.rfc-editor.org/info/rfc8742>。"
    },
    {
      "indent": 3,
      "text": "[RFC8746] Bormann, C., Ed., \"Concise Binary Object Representation (CBOR) Tags for Typed Arrays\", RFC 8746, DOI 10.17487/RFC8746, February 2020, <https://www.rfc-editor.org/info/rfc8746>.",
      "ja": "[RFC8746] Bormann、C.、ED。、「付随する配列のための簡潔なバイナリオブジェクト表現（CBOR）タグ」、RFC 8746、DOI 10.17487 / RFC8746、2020年2月、<https：//www.rfc-editor.org/info/ RFC8746>。"
    },
    {
      "indent": 3,
      "text": "[SIPHASH_LNCS] Aumasson, J. and D. Bernstein, \"SipHash: A Fast Short-Input PRF\", Progress in Cryptology - INDOCRYPT 2012, pp. 489-508, DOI 10.1007/978-3-642-34931-7_28, 2012, <https://doi.org/10.1007/978-3-642-34931-7_28>.",
      "ja": "[SIPHASH_LNCS] Aumasson、J.およびD.Bernstein、「Siphash：高速短冊PRF」、暗号学の進捗状況 -  IndoCrypt 2012、PP。489-508、DOI 10.1007 / 978-3-642-34931-7_28,28,28、<https：//doi.org/10.1007/978-3-642-34931-7_28>。"
    },
    {
      "indent": 3,
      "text": "[SIPHASH_OPEN] Aumasson, J. and D.J. Bernstein, \"SipHash: a fast short-input PRF\", <https://www.aumasson.jp/siphash/siphash.pdf>.",
      "ja": "[Siphash_open] Aumasson、J.およびD.J.Bernstein、 \"Siphash：高速短縮PRF\"、<https：//www.aumasson.jp/siphash/siphash.pdf>。"
    },
    {
      "indent": 3,
      "text": "[YAML] Ben-Kiki, O., Evans, C., and I.d. Net, \"YAML Ain't Markup Language (YAML[TM]) Version 1.2\", 3rd Edition, October 2009, <https://www.yaml.org/spec/1.2/spec.html>.",
      "ja": "[YAML]ベンキキ、O.、Evans、C.、およびI.D.NET、「マークアップ言語（YAML [TM]）バージョン1.2 \"、第3版、2009年10月、<https：//www.yaml.org/spec/1.2/spec.html>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Examples of Encoded CBOR Data Items",
      "section_title": true,
      "ja": "付録A.符号化されたCBOBORデータ項目の例"
    },
    {
      "indent": 3,
      "text": "The following table provides some CBOR-encoded values in hexadecimal (right column), together with diagnostic notation for these values (left column). Note that the string \"\\u00fc\" is one form of diagnostic notation for a UTF-8 string containing the single Unicode character U+00FC (LATIN SMALL LETTER U WITH DIAERESIS, \"ü\"). Similarly, \"\\u6c34\" is a UTF-8 string in diagnostic notation with a single character U+6C34 (CJK UNIFIED IDEOGRAPH-6C34, \"水\"), often representing \"water\", and \"\\ud800\\udd51\" is a UTF-8 string in diagnostic notation with a single character U+10151 (GREEK ACROPHONIC ATTIC FIFTY STATERS, \"𐅑\"). (Note that all these single-character strings could also be represented in native UTF-8 in diagnostic notation, just not if an ASCII-only specification is required.) In the diagnostic notation provided for bignums, their intended numeric value is shown as a decimal number (such as 18446744073709551616) instead of a tagged byte string (such as 2(h'010000000000000000')).",
      "ja": "次の表は、これらの値の診断表記（左列）とともに、16進数（右列）のCBORエンコードされた値を示しています。文字列 \"\\ u00fc\"は、単一のUnicode文字U 00FC（Diaeresisを搭載したラテン小文字、 \"Ü\"）を含むUTF-8文字列の診断表記の一種です。同様に、「\\ u6c34」は、単一の文字U 6 C34（CJK Unified Ideograph-6C34、 \"水\"）を使用した診断表記のUTF-8文字列です。1文字の診断表記の診断表記法u 10151（ギリシャのアクロフォニック屋根裏部屋50ターズ、 \"𐅑\"）。（これらのシングル文字の文字列はすべて診断表記のネイティブUTF-8で表すこともできます。）Bigrousに提供されている診断表記の場合、それらの意図された数値はAとして示されています。タグ付きバイト文字列（2（H'010000000000000000 '）など）の代わりに10進数（1844674407370955616）。"
    },
    {
      "indent": 3,
      "text": "+==============================+====================================+\n|Diagnostic                    | Encoded                            |\n+==============================+====================================+\n|0                             | 0x00                               |\n+------------------------------+------------------------------------+\n|1                             | 0x01                               |\n+------------------------------+------------------------------------+\n|10                            | 0x0a                               |\n+------------------------------+------------------------------------+\n|23                            | 0x17                               |\n+------------------------------+------------------------------------+\n|24                            | 0x1818                             |\n+------------------------------+------------------------------------+\n|25                            | 0x1819                             |\n+------------------------------+------------------------------------+\n|100                           | 0x1864                             |\n+------------------------------+------------------------------------+\n|1000                          | 0x1903e8                           |\n+------------------------------+------------------------------------+\n|1000000                       | 0x1a000f4240                       |\n+------------------------------+------------------------------------+\n|1000000000000                 | 0x1b000000e8d4a51000               |\n+------------------------------+------------------------------------+\n|18446744073709551615          | 0x1bffffffffffffffff               |\n+------------------------------+------------------------------------+\n|18446744073709551616          | 0xc249010000000000000000           |\n+------------------------------+------------------------------------+\n|-18446744073709551616         | 0x3bffffffffffffffff               |\n+------------------------------+------------------------------------+\n|-18446744073709551617         | 0xc349010000000000000000           |\n+------------------------------+------------------------------------+\n|-1                            | 0x20                               |\n+------------------------------+------------------------------------+\n|-10                           | 0x29                               |\n+------------------------------+------------------------------------+\n|-100                          | 0x3863                             |\n+------------------------------+------------------------------------+\n|-1000                         | 0x3903e7                           |\n+------------------------------+------------------------------------+\n|0.0                           | 0xf90000                           |\n+------------------------------+------------------------------------+\n|-0.0                          | 0xf98000                           |\n+------------------------------+------------------------------------+\n|1.0                           | 0xf93c00                           |\n+------------------------------+------------------------------------+\n|1.1                           | 0xfb3ff199999999999a               |\n+------------------------------+------------------------------------+\n|1.5                           | 0xf93e00                           |\n+------------------------------+------------------------------------+\n|65504.0                       | 0xf97bff                           |\n+------------------------------+------------------------------------+\n|100000.0                      | 0xfa47c35000                       |\n+------------------------------+------------------------------------+\n|3.4028234663852886e+38        | 0xfa7f7fffff                       |\n+------------------------------+------------------------------------+\n|1.0e+300                      | 0xfb7e37e43c8800759c               |\n+------------------------------+------------------------------------+\n|5.960464477539063e-8          | 0xf90001                           |\n+------------------------------+------------------------------------+\n|0.00006103515625              | 0xf90400                           |\n+------------------------------+------------------------------------+\n|-4.0                          | 0xf9c400                           |\n+------------------------------+------------------------------------+\n|-4.1                          | 0xfbc010666666666666               |\n+------------------------------+------------------------------------+\n|Infinity                      | 0xf97c00                           |\n+------------------------------+------------------------------------+\n|NaN                           | 0xf97e00                           |\n+------------------------------+------------------------------------+\n|-Infinity                     | 0xf9fc00                           |\n+------------------------------+------------------------------------+\n|Infinity                      | 0xfa7f800000                       |\n+------------------------------+------------------------------------+\n|NaN                           | 0xfa7fc00000                       |\n+------------------------------+------------------------------------+\n|-Infinity                     | 0xfaff800000                       |\n+------------------------------+------------------------------------+\n|Infinity                      | 0xfb7ff0000000000000               |\n+------------------------------+------------------------------------+\n|NaN                           | 0xfb7ff8000000000000               |\n+------------------------------+------------------------------------+\n|-Infinity                     | 0xfbfff0000000000000               |\n+------------------------------+------------------------------------+\n|false                         | 0xf4                               |\n+------------------------------+------------------------------------+\n|true                          | 0xf5                               |\n+------------------------------+------------------------------------+\n|null                          | 0xf6                               |\n+------------------------------+------------------------------------+\n|undefined                     | 0xf7                               |\n+------------------------------+------------------------------------+\n|simple(16)                    | 0xf0                               |\n+------------------------------+------------------------------------+\n|simple(255)                   | 0xf8ff                             |\n+------------------------------+------------------------------------+\n|0(\"2013-03-21T20:04:00Z\")     | 0xc074323031332d30332d32315432303a |\n|                              | 30343a30305a                       |\n+------------------------------+------------------------------------+\n|1(1363896240)                 | 0xc11a514b67b0                     |\n+------------------------------+------------------------------------+\n|1(1363896240.5)               | 0xc1fb41d452d9ec200000             |\n+------------------------------+------------------------------------+\n|23(h'01020304')               | 0xd74401020304                     |\n+------------------------------+------------------------------------+\n|24(h'6449455446')             | 0xd818456449455446                 |\n+------------------------------+------------------------------------+\n|32(\"http://www.example.com\")  | 0xd82076687474703a2f2f7777772e6578 |\n|                              | 616d706c652e636f6d                 |\n+------------------------------+------------------------------------+\n|h''                           | 0x40                               |\n+------------------------------+------------------------------------+\n|h'01020304'                   | 0x4401020304                       |\n+------------------------------+------------------------------------+\n|\"\"                            | 0x60                               |\n+------------------------------+------------------------------------+\n|\"a\"                           | 0x6161                             |\n+------------------------------+------------------------------------+\n|\"IETF\"                        | 0x6449455446                       |\n+------------------------------+------------------------------------+\n|\"\\\"\\\\\"                        | 0x62225c                           |\n+------------------------------+------------------------------------+\n|\"\\u00fc\"                      | 0x62c3bc                           |\n+------------------------------+------------------------------------+\n|\"\\u6c34\"                      | 0x63e6b0b4                         |\n+------------------------------+------------------------------------+\n|\"\\ud800\\udd51\"                | 0x64f0908591                       |\n+------------------------------+------------------------------------+\n|[]                            | 0x80                               |\n+------------------------------+------------------------------------+\n|[1, 2, 3]                     | 0x83010203                         |\n+------------------------------+------------------------------------+\n|[1, [2, 3], [4, 5]]           | 0x8301820203820405                 |\n+------------------------------+------------------------------------+\n|[1, 2, 3, 4, 5, 6, 7, 8, 9,   | 0x98190102030405060708090a0b0c0d0e |\n|10, 11, 12, 13, 14, 15, 16,   | 0f101112131415161718181819         |\n|17, 18, 19, 20, 21, 22, 23,   |                                    |\n|24, 25]                       |                                    |\n+------------------------------+------------------------------------+\n|{}                            | 0xa0                               |\n+------------------------------+------------------------------------+\n|{1: 2, 3: 4}                  | 0xa201020304                       |\n+------------------------------+------------------------------------+\n|{\"a\": 1, \"b\": [2, 3]}         | 0xa26161016162820203               |\n+------------------------------+------------------------------------+\n|[\"a\", {\"b\": \"c\"}]             | 0x826161a161626163                 |\n+------------------------------+------------------------------------+\n|{\"a\": \"A\", \"b\": \"B\", \"c\": \"C\",| 0xa5616161416162614261636143616461 |\n|\"d\": \"D\", \"e\": \"E\"}           | 4461656145                         |\n+------------------------------+------------------------------------+\n|(_ h'0102', h'030405')        | 0x5f42010243030405ff               |\n+------------------------------+------------------------------------+\n|(_ \"strea\", \"ming\")           | 0x7f657374726561646d696e67ff       |\n+------------------------------+------------------------------------+\n|[_ ]                          | 0x9fff                             |\n+------------------------------+------------------------------------+\n|[_ 1, [2, 3], [_ 4, 5]]       | 0x9f018202039f0405ffff             |\n+------------------------------+------------------------------------+\n|[_ 1, [2, 3], [4, 5]]         | 0x9f01820203820405ff               |\n+------------------------------+------------------------------------+\n|[1, [2, 3], [_ 4, 5]]         | 0x83018202039f0405ff               |\n+------------------------------+------------------------------------+\n|[1, [_ 2, 3], [4, 5]]         | 0x83019f0203ff820405               |\n+------------------------------+------------------------------------+\n|[_ 1, 2, 3, 4, 5, 6, 7, 8, 9, | 0x9f0102030405060708090a0b0c0d0e0f |\n|10, 11, 12, 13, 14, 15, 16,   | 101112131415161718181819ff         |\n|17, 18, 19, 20, 21, 22, 23,   |                                    |\n|24, 25]                       |                                    |\n+------------------------------+------------------------------------+\n|{_ \"a\": 1, \"b\": [_ 2, 3]}     | 0xbf61610161629f0203ffff           |\n+------------------------------+------------------------------------+\n|[\"a\", {_ \"b\": \"c\"}]           | 0x826161bf61626163ff               |\n+------------------------------+------------------------------------+\n|{_ \"Fun\": true, \"Amt\": -2}    | 0xbf6346756ef563416d7421ff         |\n+------------------------------+------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 6: Examples of Encoded CBOR Data Items",
      "ja": "表6：符号化されたCBOBORデータ項目の例"
    },
    {
      "indent": 0,
      "text": "Appendix B. Jump Table for Initial Byte",
      "section_title": true,
      "ja": "付録B.初期バイトのジャンプテーブル"
    },
    {
      "indent": 3,
      "text": "For brevity, this jump table does not show initial bytes that are reserved for future extension. It also only shows a selection of the initial bytes that can be used for optional features. (All unsigned integers are in network byte order.)",
      "ja": "簡潔にするために、このジャンプテーブルは将来の拡張子のために予約されている初期バイトを表示しません。また、オプション機能に使用できる初期バイトの選択も表示されます。（符号なし整数はすべてネットワークバイト順にあります。）"
    },
    {
      "indent": 6,
      "text": "+============+================================================+\n| Byte       | Structure/Semantics                            |\n+============+================================================+\n| 0x00..0x17 | unsigned integer 0x00..0x17 (0..23)            |\n+------------+------------------------------------------------+\n| 0x18       | unsigned integer (one-byte uint8_t follows)    |\n+------------+------------------------------------------------+\n| 0x19       | unsigned integer (two-byte uint16_t follows)   |\n+------------+------------------------------------------------+\n| 0x1a       | unsigned integer (four-byte uint32_t follows)  |\n+------------+------------------------------------------------+\n| 0x1b       | unsigned integer (eight-byte uint64_t follows) |\n+------------+------------------------------------------------+\n| 0x20..0x37 | negative integer -1-0x00..-1-0x17 (-1..-24)    |\n+------------+------------------------------------------------+\n| 0x38       | negative integer -1-n (one-byte uint8_t for n  |\n|            | follows)                                       |\n+------------+------------------------------------------------+\n| 0x39       | negative integer -1-n (two-byte uint16_t for n |\n|            | follows)                                       |\n+------------+------------------------------------------------+\n| 0x3a       | negative integer -1-n (four-byte uint32_t for  |\n|            | n follows)                                     |\n+------------+------------------------------------------------+\n| 0x3b       | negative integer -1-n (eight-byte uint64_t for |\n|            | n follows)                                     |\n+------------+------------------------------------------------+\n| 0x40..0x57 | byte string (0x00..0x17 bytes follow)          |\n+------------+------------------------------------------------+\n| 0x58       | byte string (one-byte uint8_t for n, and then  |\n|            | n bytes follow)                                |\n+------------+------------------------------------------------+\n| 0x59       | byte string (two-byte uint16_t for n, and then |\n|            | n bytes follow)                                |\n+------------+------------------------------------------------+\n| 0x5a       | byte string (four-byte uint32_t for n, and     |\n|            | then n bytes follow)                           |\n+------------+------------------------------------------------+\n| 0x5b       | byte string (eight-byte uint64_t for n, and    |\n|            | then n bytes follow)                           |\n+------------+------------------------------------------------+\n| 0x5f       | byte string, byte strings follow, terminated   |\n|            | by \"break\"                                     |\n+------------+------------------------------------------------+\n| 0x60..0x77 | UTF-8 string (0x00..0x17 bytes follow)         |\n+------------+------------------------------------------------+\n| 0x78       | UTF-8 string (one-byte uint8_t for n, and then |\n|            | n bytes follow)                                |\n+------------+------------------------------------------------+\n| 0x79       | UTF-8 string (two-byte uint16_t for n, and     |\n|            | then n bytes follow)                           |\n+------------+------------------------------------------------+\n| 0x7a       | UTF-8 string (four-byte uint32_t for n, and    |\n|            | then n bytes follow)                           |\n+------------+------------------------------------------------+\n| 0x7b       | UTF-8 string (eight-byte uint64_t for n, and   |\n|            | then n bytes follow)                           |\n+------------+------------------------------------------------+\n| 0x7f       | UTF-8 string, UTF-8 strings follow, terminated |\n|            | by \"break\"                                     |\n+------------+------------------------------------------------+\n| 0x80..0x97 | array (0x00..0x17 data items follow)           |\n+------------+------------------------------------------------+\n| 0x98       | array (one-byte uint8_t for n, and then n data |\n|            | items follow)                                  |\n+------------+------------------------------------------------+\n| 0x99       | array (two-byte uint16_t for n, and then n     |\n|            | data items follow)                             |\n+------------+------------------------------------------------+\n| 0x9a       | array (four-byte uint32_t for n, and then n    |\n|            | data items follow)                             |\n+------------+------------------------------------------------+\n| 0x9b       | array (eight-byte uint64_t for n, and then n   |\n|            | data items follow)                             |\n+------------+------------------------------------------------+\n| 0x9f       | array, data items follow, terminated by        |\n|            | \"break\"                                        |\n+------------+------------------------------------------------+\n| 0xa0..0xb7 | map (0x00..0x17 pairs of data items follow)    |\n+------------+------------------------------------------------+\n| 0xb8       | map (one-byte uint8_t for n, and then n pairs  |\n|            | of data items follow)                          |\n+------------+------------------------------------------------+\n| 0xb9       | map (two-byte uint16_t for n, and then n pairs |\n|            | of data items follow)                          |\n+------------+------------------------------------------------+\n| 0xba       | map (four-byte uint32_t for n, and then n      |\n|            | pairs of data items follow)                    |\n+------------+------------------------------------------------+\n| 0xbb       | map (eight-byte uint64_t for n, and then n     |\n|            | pairs of data items follow)                    |\n+------------+------------------------------------------------+\n| 0xbf       | map, pairs of data items follow, terminated by |\n|            | \"break\"                                        |\n+------------+------------------------------------------------+\n| 0xc0       | text-based date/time (data item follows; see   |\n|            | Section 3.4.1)                                 |\n+------------+------------------------------------------------+\n| 0xc1       | epoch-based date/time (data item follows; see  |\n|            | Section 3.4.2)                                 |\n+------------+------------------------------------------------+\n| 0xc2       | unsigned bignum (data item \"byte string\"       |\n|            | follows)                                       |\n+------------+------------------------------------------------+\n| 0xc3       | negative bignum (data item \"byte string\"       |\n|            | follows)                                       |\n+------------+------------------------------------------------+\n| 0xc4       | decimal Fraction (data item \"array\" follows;   |\n|            | see Section 3.4.4)                             |\n+------------+------------------------------------------------+\n| 0xc5       | bigfloat (data item \"array\" follows; see       |\n|            | Section 3.4.4)                                 |\n+------------+------------------------------------------------+\n| 0xc6..0xd4 | (tag)                                          |\n+------------+------------------------------------------------+\n| 0xd5..0xd7 | expected conversion (data item follows; see    |\n|            | Section 3.4.5.2)                               |\n+------------+------------------------------------------------+\n| 0xd8..0xdb | (more tags; 1/2/4/8 bytes of tag number and    |\n|            | then a data item follow)                       |\n+------------+------------------------------------------------+\n| 0xe0..0xf3 | (simple value)                                 |\n+------------+------------------------------------------------+\n| 0xf4       | false                                          |\n+------------+------------------------------------------------+\n| 0xf5       | true                                           |\n+------------+------------------------------------------------+\n| 0xf6       | null                                           |\n+------------+------------------------------------------------+\n| 0xf7       | undefined                                      |\n+------------+------------------------------------------------+\n| 0xf8       | (simple value, one byte follows)               |\n+------------+------------------------------------------------+\n| 0xf9       | half-precision float (two-byte IEEE 754)       |\n+------------+------------------------------------------------+\n| 0xfa       | single-precision float (four-byte IEEE 754)    |\n+------------+------------------------------------------------+\n| 0xfb       | double-precision float (eight-byte IEEE 754)   |\n+------------+------------------------------------------------+\n| 0xff       | \"break\" stop code                              |\n+------------+------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 7: Jump Table for Initial Byte",
      "ja": "表7：初回バイトのジャンプテーブル"
    },
    {
      "indent": 0,
      "text": "Appendix C. Pseudocode",
      "section_title": true,
      "ja": "付録C C擬蔵"
    },
    {
      "indent": 3,
      "text": "The well-formedness of a CBOR item can be checked by the pseudocode in Figure 1. The data is well-formed if and only if:",
      "ja": "CBOBOR項目の整形式は、図1の擬似コードによって確認できます。データは、次の場合に限り、"
    },
    {
      "indent": 3,
      "text": "* the pseudocode does not \"fail\";",
      "ja": "* 疑似コードは「失敗」しません。"
    },
    {
      "indent": 3,
      "text": "* after execution of the pseudocode, no bytes are left in the input (except in streaming applications).",
      "ja": "* 疑似コードを実行した後、バイトは入力に残されません（ストリーミングアプリケーションを除く）。"
    },
    {
      "indent": 3,
      "text": "The pseudocode has the following prerequisites:",
      "ja": "疑似コードには次の前提条件があります。"
    },
    {
      "indent": 3,
      "text": "* take(n) reads n bytes from the input data and returns them as a byte string. If n bytes are no longer available, take(n) fails.",
      "ja": "* （n）入力データからnバイトを読み取り、それらをバイト文字列として返します。nバイトが使用できなくなった場合は、（n）に失敗します。"
    },
    {
      "indent": 3,
      "text": "* uint() converts a byte string into an unsigned integer by interpreting the byte string in network byte order.",
      "ja": "* UINT（）は、ネットワークバイト順にバイト文字列を解釈することによって、バイト文字列を符号なし整数に変換します。"
    },
    {
      "indent": 3,
      "text": "* Arithmetic works as in C.",
      "ja": "* 算術演算はCのように機能します"
    },
    {
      "indent": 3,
      "text": "* All variables are unsigned integers of sufficient range.",
      "ja": "* すべての変数は十分な範囲の符号なし整数です。"
    },
    {
      "indent": 3,
      "text": "Note that \"well_formed\" returns the major type for well-formed definite-length items, but 99 for an indefinite-length item (or -1 for a \"break\" stop code, only if \"breakable\" is set). This is used in \"well_formed_indefinite\" to ascertain that indefinite-length strings only contain definite-length strings as chunks.",
      "ja": "\"WELL_FORMED\"は、整形式の明確な項目のメジャータイプを返しますが、「破損できない」が設定されている場合に限り、不定長項目（または-1の停止コードの場合は-1）に99を返します。これは、Indefite-Lengthの文字列のみが塊として明確な長さの文字列を含むことを確認するために \"Well_formed_indefinite\"で使用されます。"
    },
    {
      "indent": 3,
      "text": "well_formed(breakable = false) {\n  // process initial bytes\n  ib = uint(take(1));\n  mt = ib >> 5;\n  val = ai = ib & 0x1f;\n  switch (ai) {\n    case 24: val = uint(take(1)); break;\n    case 25: val = uint(take(2)); break;\n    case 26: val = uint(take(4)); break;\n    case 27: val = uint(take(8)); break;\n    case 28: case 29: case 30: fail();\n    case 31:\n      return well_formed_indefinite(mt, breakable);\n  }\n  // process content\n  switch (mt) {\n    // case 0, 1, 7 do not have content; just use val\n    case 2: case 3: take(val); break; // bytes/UTF-8\n    case 4: for (i = 0; i < val; i++) well_formed(); break;\n    case 5: for (i = 0; i < val*2; i++) well_formed(); break;\n    case 6: well_formed(); break;     // 1 embedded data item\n    case 7: if (ai == 24 && val < 32) fail(); // bad simple\n  }\n  return mt;                    // definite-length data item\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "well_formed_indefinite(mt, breakable) {\n  switch (mt) {\n    case 2: case 3:\n      while ((it = well_formed(true)) != -1)\n        if (it != mt)           // need definite-length chunk\n          fail();               //    of same type\n      break;\n    case 4: while (well_formed(true) != -1); break;\n    case 5: while (well_formed(true) != -1) well_formed(); break;\n    case 7:\n      if (breakable)\n        return -1;              // signal break out\n      else fail();              // no enclosing indefinite\n    default: fail();            // wrong mt\n  }\n  return 99;                    // indefinite-length data item\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 1: Pseudocode for Well-Formedness Check",
      "ja": "図1：整形式チェックの疑似コード"
    },
    {
      "indent": 3,
      "text": "Note that the remaining complexity of a complete CBOR decoder is about presenting data that has been decoded to the application in an appropriate form.",
      "ja": "CBORデコーダの残りの複雑さは、適切な形式でアプリケーションにデコードされたデータを提示することです。"
    },
    {
      "indent": 3,
      "text": "Major types 0 and 1 are designed in such a way that they can be encoded in C from a signed integer without actually doing an if-then-else for positive/negative (Figure 2). This uses the fact that (-1-n), the transformation for major type 1, is the same as ~n (bitwise complement) in C unsigned arithmetic; ~n can then be expressed as (-1)^n for the negative case, while 0^n leaves n unchanged for nonnegative. The sign of a number can be converted to -1 for negative and 0 for nonnegative (0 or positive) by arithmetic-shifting the number by one bit less than the bit length of the number (for example, by 63 for 64-bit numbers).",
      "ja": "メジャータイプ0と1は、実際にIF-THER / NOLESの場合は、符号付き整数からC内で符号化できるように設計されています（図2）。これは（-1  -  n）、主タイプ1の変換は、C符号なし算術における~N（ビット単位相補）と同じであるという事実を使用する。~Nは、負の場合について（-1）^ nと表現することができ、0 ^ nは非負の場合はnは変化しない。数字のビット長よりも1ビット減少した数値を1ビットずつ算術シフトして、数字の符号を-1に変換することができます（たとえば、63ビット数は63 x 63）。）。"
    },
    {
      "indent": 3,
      "text": "void encode_sint(int64_t n) {\n  uint64t ui = n >> 63;    // extend sign to whole length\n  unsigned mt = ui & 0x20; // extract (shifted) major type\n  ui ^= n;                 // complement negatives\n  if (ui < 24)\n    *p++ = mt + ui;\n  else if (ui < 256) {\n    *p++ = mt + 24;\n    *p++ = ui;\n  } else\n       ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 2: Pseudocode for Encoding a Signed Integer",
      "ja": "図2：符号付き整数をエンコードするための疑似コード"
    },
    {
      "indent": 3,
      "text": "See Section 1.2 for some specific assumptions about the profile of the C language used in these pieces of code.",
      "ja": "これらのコードで使用されているC言語のプロファイルに関する特定の仮定については、セクション1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Half-Precision",
      "section_title": true,
      "ja": "付録D.半精度"
    },
    {
      "indent": 3,
      "text": "As half-precision floating-point numbers were only added to IEEE 754 in 2008 [IEEE754], today's programming platforms often still only have limited support for them. It is very easy to include at least decoding support for them even without such support. An example of a small decoder for half-precision floating-point numbers in the C language is shown in Figure 3. A similar program for Python is in Figure 4; this code assumes that the 2-byte value has already been decoded as an (unsigned short) integer in network byte order (as would be done by the pseudocode in Appendix C).",
      "ja": "2008年の半精密浮動小数点数がIEEE 754にのみ加算された[IEEE754]は、今日のプログラミングプラットフォームは依然としてそれらの支持だけが限られています。そのようなサポートなしでさえもそれらのために少なくとも復号化サポートを含むことは非常に簡単である。C言語における半精度浮動小数点数のための小さいデコーダの例を図3に示す.Python用の同様のプログラムは図4にあります。このコードは、2バイトの値がネットワークバイト順に（付録Cの疑似コードによって行われるように）既にネットワークバイト順に既に復号されていると仮定しています。"
    },
    {
      "indent": 3,
      "text": "#include <math.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "double decode_half(unsigned char *halfp) {\n  unsigned half = (halfp[0] << 8) + halfp[1];\n  unsigned exp = (half >> 10) & 0x1f;\n  unsigned mant = half & 0x3ff;\n  double val;\n  if (exp == 0) val = ldexp(mant, -24);\n  else if (exp != 31) val = ldexp(mant + 1024, exp - 25);\n  else val = mant == 0 ? INFINITY : NAN;\n  return half & 0x8000 ? -val : val;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 3: C Code for a Half-Precision Decoder",
      "ja": "図3：半精定デコーダのCコード"
    },
    {
      "indent": 3,
      "text": "import struct from math import ldexp",
      "ja": "数学のインポートLDEXPからの構造体をインポートする"
    },
    {
      "indent": 3,
      "text": "def decode_single(single):\n    return struct.unpack(\"!f\", struct.pack(\"!I\", single))[0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "def decode_half(half):\n    valu = (half & 0x7fff) << 13 | (half & 0x8000) << 16\n    if ((half & 0x7c00) != 0x7c00):\n        return ldexp(decode_single(valu), 112)\n    return decode_single(valu | 0x7f800000)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 4: Python Code for a Half-Precision Decoder",
      "ja": "図4：半精密デコーダのPythonコード"
    },
    {
      "indent": 0,
      "text": "Appendix E. Comparison of Other Binary Formats to CBOR's Design Objectives",
      "ja": "付録E.他のバイナリフォーマットのCBORの設計目標との比較",
      "section_title": true
    },
    {
      "indent": 3,
      "text": "The proposal for CBOR follows a history of binary formats that is as long as the history of computers themselves. Different formats have had different objectives. In most cases, the objectives of the format were never stated, although they can sometimes be implied by the context where the format was first used. Some formats were meant to be universally usable, although history has proven that no binary format meets the needs of all protocols and applications.",
      "ja": "CBORの提案は、コンピュータ自体の歴史の限りであるバイナリ形式の歴史に従います。さまざまな形式の目的が異なります。ほとんどの場合、フォーマットの目的は決して述べられていませんでしたが、フォーマットが最初に使用されたコンテキストによって暗示されることがあります。いくつかのフォーマットは普遍的に使用可能であることを意味していましたが、歴史はすべてのプロトコルとアプリケーションのニーズを満たすことが証明されています。"
    },
    {
      "indent": 3,
      "text": "CBOR differs from many of these formats due to it starting with a set of objectives and attempting to meet just those. This section compares a few of the dozens of formats with CBOR's objectives in order to help the reader decide if they want to use CBOR or a different format for a particular protocol or application.",
      "ja": "CBORは、一連の目的から始めてそれらだけに会いようとしているため、これらのフォーマットの多くとは異なります。このセクションでは、読者がCBORまたは特定のプロトコルやアプリケーションに異なるフォーマットを使用したい場合に、リーダーが決定するのを助けるために、CBORの目標との数十の形式の数十のフォーマットを比較します。"
    },
    {
      "indent": 3,
      "text": "Note that the discussion here is not meant to be a criticism of any format: to the best of our knowledge, no format before CBOR was meant to cover CBOR's objectives in the priority we have assigned them. A brief recap of the objectives from Section 1.1 is:",
      "ja": "ここでの議論はあらゆる形式の批判的であることを意味するものではありません。セクション1.1からの目的の簡単な回収は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. unambiguous encoding of most common data formats from Internet standards",
      "ja": "1. インターネット規格からの最も一般的なデータフォーマットの明確なエンコーディング"
    },
    {
      "indent": 3,
      "text": "2. code compactness for encoder or decoder",
      "ja": "2. エンコーダまたはデコーダのためのコードコンパクトさ"
    },
    {
      "indent": 3,
      "text": "3. no schema description needed",
      "ja": "3. スキーマ記述は必要ありません"
    },
    {
      "indent": 3,
      "text": "4. reasonably compact serialization",
      "ja": "4. 合理的にコンパクトな直列化"
    },
    {
      "indent": 3,
      "text": "5. applicability to constrained and unconstrained applications",
      "ja": "5. 制約および制約のないアプリケーションへの適用性"
    },
    {
      "indent": 3,
      "text": "6. good JSON conversion",
      "ja": "6. 良いJSON変換"
    },
    {
      "indent": 3,
      "text": "7. extensibility",
      "ja": "7. 伸縮性"
    },
    {
      "indent": 3,
      "text": "A discussion of CBOR and other formats with respect to a different set of design objectives is provided in Section 5 and Appendix C of [RFC8618].",
      "ja": "セクション5および[RFC8618]のセクション5および付録Cには、CBORおよびその他のデザイン目標に関するその他のフォーマットに関する説明が提供されています。"
    },
    {
      "indent": 0,
      "text": "E.1. ASN.1 DER, BER, and PER",
      "section_title": true,
      "ja": "E.1. ASN.1 Der、BER、およびPER"
    },
    {
      "indent": 3,
      "text": "[ASN.1] has many serializations. In the IETF, DER and BER are the most common. The serialized output is not particularly compact for many items, and the code needed to decode numeric items can be complex on a constrained device.",
      "ja": "[ASN.1]は多くの直列化をしています。IETFでは、DERとBERが最も一般的です。シリアル化された出力は多くの項目に対して特にコンパクトではなく、数値をデコードするのに必要なコードは制約付きデバイス上で複雑になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Few (if any) IETF protocols have adopted one of the several variants of Packed Encoding Rules (PER). There could be many reasons for this, but one that is commonly stated is that PER makes use of the schema even for parsing the surface structure of the data item, requiring significant tool support. There are different versions of the ASN.1 schema language in use, which has also hampered adoption.",
      "ja": "IETFプロトコルがいくつかのIETFプロトコルを採用している（あたり）、パックされたエンコーディング規則のいくつかの変形例（PER）を採用しています。これには多くの理由があるかもしれませんが、一般的に記載されているものは、データ項目の表面構造を解析するためでさえもスキーマを利用することであり、かなりのツールサポートを必要とすることです。使用中のASN.1スキーマ言語の異なるバージョンがあります。これも採用を妨げました。"
    },
    {
      "indent": 0,
      "text": "E.2. MessagePack",
      "section_title": true,
      "ja": "E.2. メッセージパック"
    },
    {
      "indent": 3,
      "text": "[MessagePack] is a concise, widely implemented counted binary serialization format, similar in many properties to CBOR, although somewhat less regular. While the data model can be used to represent JSON data, MessagePack has also been used in many remote procedure call (RPC) applications and for long-term storage of data.",
      "ja": "[MessagePack]は、CBORの多くのプロパティで似ている簡潔で広く実装された2進直列化フォーマットです。データモデルをJSONデータを表すことができるが、MessagePackは多くのリモートプロシージャコール（RPC）アプリケーションおよびデータの長期格納にも使用されています。"
    },
    {
      "indent": 3,
      "text": "MessagePack has been essentially stable since it was first published around 2011; it has not yet had a transition. The evolution of MessagePack is impeded by an imperative to maintain complete backwards compatibility with existing stored data, while only few bytecodes are still available for extension. Repeated requests over the years from the MessagePack user community to separate out binary and text strings in the encoding recently have led to an extension proposal that would leave MessagePack's \"raw\" data ambiguous between its usages for binary and text data. The extension mechanism for MessagePack remains unclear.",
      "ja": "MessagePackは2011年頃に最初に公開されて以来、基本的に安定しています。まだ移行していません。MessagePackの進化は、既存の格納されたデータとの完全な後方互換性を維持するために命令的に妨げられますが、拡張には依然として使用可能なバイトコードです。MessagePackのユーザーコミュニティからの年間にわたる要求を繰り返し要求して、エンコーディング内のバイナリとテキスト文字列を分離すると、MessagePackの「RAW」データをバイナリデータとテキストデータの使用にあいまいなものとの間で残した拡張提案が可能になりました。MessagePackの拡張メカニズムは不明のままです。"
    },
    {
      "indent": 0,
      "text": "E.3. BSON",
      "section_title": true,
      "ja": "E.3. b"
    },
    {
      "indent": 3,
      "text": "[BSON] is a data format that was developed for the storage of JSON-like maps (JSON objects) in the MongoDB database. Its major distinguishing feature is the capability for in-place update, which prevents a compact representation. BSON uses a counted representation except for map keys, which are null-byte terminated. While BSON can be used for the representation of JSON-like objects on the wire, its specification is dominated by the requirements of the database application and has become somewhat baroque. The status of how BSON extensions will be implemented remains unclear.",
      "ja": "[BSON]は、MongoDBデータベースのJSONのようなマップ（JSONオブジェクト）のストレージ用に開発されたデータ形式です。その主要な識別機能は、インプレース更新の能力であり、コンパクトな表現を防ぎます。BSONは、NULLバイトが終了しているマップキーを除くカウントされた表現を使用します。BSONをワイヤ上のJSON様オブジェクトの表現に使用することができますが、その仕様はデータベースアプリケーションの要件によって支配され、ややバロック様式になりました。BSON拡張機能がどのように実装されるかの状況は不明のままです。"
    },
    {
      "indent": 0,
      "text": "E.4. MSDTP: RFC 713",
      "section_title": true,
      "ja": "E.4. MSDTP：RFC 713"
    },
    {
      "indent": 3,
      "text": "Message Services Data Transmission (MSDTP) is a very early example of a compact message format; it is described in [RFC0713], written in 1976. It is included here for its historical value, not because it was ever widely used.",
      "ja": "メッセージサービスデータ送信（MSDTP）は、コンパクトメッセージフォーマットの非常に早い例です。1976年に書かれた[RFC0713]に記載されています。これは歴史的価値がここに含まれています。"
    },
    {
      "indent": 0,
      "text": "E.5. Conciseness on the Wire",
      "section_title": true,
      "ja": "E.5. ワイヤーの簡潔さ"
    },
    {
      "indent": 3,
      "text": "While CBOR's design objective of code compactness for encoders and decoders is a higher priority than its objective of conciseness on the wire, many people focus on the wire size. Table 8 shows some encoding examples for the simple nested array [1, [2, 3]]; where some form of indefinite-length encoding is supported by the encoding, [_ 1, [2, 3]] (indefinite length on the outer array) is also shown.",
      "ja": "CBOODERSおよびDECODERSのコードコンパクト性のCBORの設計目的は、ワイヤーの簡潔さの目的より高い優先順位です。多くの人がワイヤサイズに焦点を当てています。表8は、単純な入れ子アレイ[1、[2,3]]の符号化例を示しています。いくつかの形の不定長符号化が符号化によって支持されている場合、[_ 1、[2]、3]（外側アレイ上の不定長）も示されている。"
    },
    {
      "indent": 7,
      "text": "+=============+============================+================+\n| Format      | [1, [2, 3]]                | [_ 1, [2, 3]]  |\n+=============+============================+================+\n| RFC 713     | c2 05 81 c2 02 82 83       |                |\n+-------------+----------------------------+----------------+\n| ASN.1 BER   | 30 0b 02 01 01 30 06 02 01 | 30 80 02 01 01 |\n|             | 02 02 01 03                | 30 06 02 01 02 |\n|             |                            | 02 01 03 00 00 |\n+-------------+----------------------------+----------------+\n| MessagePack | 92 01 92 02 03             |                |\n+-------------+----------------------------+----------------+\n| BSON        | 22 00 00 00 10 30 00 01 00 |                |\n|             | 00 00 04 31 00 13 00 00 00 |                |\n|             | 10 30 00 02 00 00 00 10 31 |                |\n|             | 00 03 00 00 00 00 00       |                |\n+-------------+----------------------------+----------------+\n| CBOR        | 82 01 82 02 03             | 9f 01 82 02 03 |\n|             |                            | ff             |\n+-------------+----------------------------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 8: Examples for Different Levels of Conciseness",
      "ja": "表8：さまざまな意識レベルの例"
    },
    {
      "indent": 0,
      "text": "Appendix F. Well-Formedness Errors and Examples",
      "section_title": true,
      "ja": "付録F. 整形式性エラーと例"
    },
    {
      "indent": 3,
      "text": "There are three basic kinds of well-formedness errors that can occur in decoding a CBOR data item:",
      "ja": "CBORデータ項目を復号する際に発生する可能性がある3つの基本的な種類の整形式誤差があります。"
    },
    {
      "indent": 3,
      "text": "Too much data: There are input bytes left that were not consumed. This is only an error if the application assumed that the input bytes would span exactly one data item. Where the application uses the self-delimiting nature of CBOR encoding to permit additional data after the data item, as is done in CBOR sequences [RFC8742], for example, the CBOR decoder can simply indicate which part of the input has not been consumed.",
      "ja": "データ：消費されなかった入力バイトが残っています。アプリケーションが入力バイトが正確に1つのデータ項目に及ぶと想定している場合、これはエラーのみです。アプリケーションがCBOR符号化の自己区切りの性質を使用してデータ項目の後に追加のデータを許可すると、CBOBORシーケンス[RFC8742]で行われているように、CBORデコーダは、入力のどの部分が消費されていないかを単に示すことができる。"
    },
    {
      "indent": 3,
      "text": "Too little data: The input data available would need additional bytes added at their end for a complete CBOR data item. This may indicate the input is truncated; it is also a common error when trying to decode random data as CBOR. For some applications, however, this may not actually be an error, as the application may not be certain it has all the data yet and can obtain or wait for additional input bytes. Some of these applications may have an upper limit for how much additional data can appear; here the decoder may be able to indicate that the encoded CBOR data item cannot be completed within this limit.",
      "ja": "データ：利用可能な入力データは、完全なCBORデータ項目に対して最後に追加された追加のバイトが必要になります。これは入力が切り捨てられていることを示すかもしれません。ランダムデータをCBORとしてデコードしようとすると、一般的なエラーです。ただし、アプリケーションによっては、アプリケーションがすべてのデータがまだあることが確実でなく、追加の入力バイトを取得または待つことができます。これらのアプリケーションのいくつかは、追加データがどの程度表示され得るかについての上限を持つかもしれません。ここで、デコーダは、符号化されたCBOBORデータ項目をこの制限内で完了させることができないことを示すことができるかもしれない。"
    },
    {
      "indent": 3,
      "text": "Syntax error: The input data are not consistent with the requirements of the CBOR encoding, and this cannot be remedied by adding (or removing) data at the end.",
      "ja": "構文エラー：入力データはCBORエンコーディングの要件と一致していません。これは、最後にデータを追加（または削除）することで解決できません。"
    },
    {
      "indent": 3,
      "text": "In Appendix C, errors of the first kind are addressed in the first paragraph and bullet list (requiring \"no bytes are left\"), and errors of the second kind are addressed in the second paragraph/bullet list (failing \"if n bytes are no longer available\"). Errors of the third kind are identified in the pseudocode by specific instances of calling fail(), in order:",
      "ja": "付録Cでは、最初の種類のエラーが最初の段落と箇条書きリストで扱われています（「バイトは残っていない」という必要があり、2番目の種類のエラーは2番目の段落/箇条書きリストでアドレス指定されています。利用できない\"）。3番目の種類のエラーは、呼び出し元（）の特定のインスタンスによって疑似コードで識別されます。"
    },
    {
      "indent": 3,
      "text": "* a reserved value is used for additional information (28, 29, 30)",
      "ja": "* 予約値は追加情報（28,29,30）に使用されます。"
    },
    {
      "indent": 3,
      "text": "* major type 7, additional information 24, value < 32 (incorrect)",
      "ja": "* メジャータイプ7、追加情報24、値<32（不適切）"
    },
    {
      "indent": 3,
      "text": "* incorrect substructure of indefinite-length byte string or text string (may only contain definite-length strings of the same major type)",
      "ja": "* 不定長バイト文字列またはテキスト文字列の誤った部分構造（同じメジャータイプの明確な文字列のみを含む場合があります）"
    },
    {
      "indent": 3,
      "text": "* \"break\" stop code (major type 7, additional information 31) occurs in a value position of a map or except at a position directly in an indefinite-length item where also another enclosed data item could occur",
      "ja": "* 「ブレーク」の停止コード（メジャータイプ7、付加情報31）は、マップの値位置で、または別の囲まれたデータ項目も発生する可能性がある不定長項目に直接位置を除いて行われる。"
    },
    {
      "indent": 3,
      "text": "* additional information 31 used with major type 0, 1, or 6",
      "ja": "* 追加情報31は、メジャータイプ0,1、または6で使用されます。"
    },
    {
      "indent": 0,
      "text": "F.1. Examples of CBOR Data Items That Are Not Well-Formed",
      "section_title": true,
      "ja": "F.1. よく形成されていないCBORデータ項目の例"
    },
    {
      "indent": 3,
      "text": "This subsection shows a few examples for CBOR data items that are not well-formed. Each example is a sequence of bytes, each shown in hexadecimal; multiple examples in a list are separated by commas.",
      "ja": "このサブセクションは、整形式ではないCBORデータ項目のいくつかの例を示しています。各例は、それぞれ16進数で示されている一連のバイトです。リスト内の複数の例はコンマで区切られています。"
    },
    {
      "indent": 3,
      "text": "Examples for well-formedness error kind 1 (too much data) can easily be formed by adding data to a well-formed encoded CBOR data item.",
      "ja": "整形された符号化されたCBOBORデータ項目にデータを追加することによって、整形式誤差の例1（データ）を容易に形成することができる。"
    },
    {
      "indent": 3,
      "text": "Similarly, examples for well-formedness error kind 2 (too little data) can be formed by truncating a well-formed encoded CBOR data item. In test suites, it may be beneficial to specifically test with incomplete data items that would require large amounts of addition to be completed (for instance by starting the encoding of a string of a very large size).",
      "ja": "同様に、整形式符号化CBORデータ項目を切り捨てることにより、良好な誤差種2の例（データ）を形成することができる。テストスイートでは、大量の追加を必要とする不完全なデータ項目を具体的にテストすることが有益であり得る（たとえば、非常に大きいサイズの文字列の符号化を開始することによって）。"
    },
    {
      "indent": 3,
      "text": "A premature end of the input can occur in a head or within the enclosed data, which may be bare strings or enclosed data items that are either counted or should have been ended by a \"break\" stop code.",
      "ja": "入力の時期尚早の端は、ヘッド内または囲まれたデータ内で発生する可能性があり、これは、カウントされているか、または「ブレーク」の停止コードによって終了したか、または終了する必要があるか、または終了する必要があります。"
    },
    {
      "indent": 0,
      "text": "End of input in a head:\n  18, 19, 1a, 1b, 19 01, 1a 01 02, 1b 01 02 03 04 05 06 07, 38, 58, 78, 98, 9a 01 ff 00, b8, d8, f8, f9 00, fa 00 00, fb 00 00 00\n\nDefinite-length strings with short data:\n  41, 61, 5a ff ff ff ff 00, 5b ff ff ff ff ff ff ff ff 01 02 03, 7a ff ff ff ff 00, 7b 7f ff ff ff ff ff ff ff 01 02 03\n\nDefinite-length maps and arrays not closed with enough items:\n  81, 81 81 81 81 81 81 81 81 81, 82 00, a1, a2 01 02, a1 00, a2 00 00 00\n\nTag number not followed by tag content:\n  c0\n\nIndefinite-length strings not closed by a \"break\" stop code:\n  5f 41 00, 7f 61 00\n\nIndefinite-length maps and arrays not closed by a \"break\" stop code:\n  9f, 9f 01 02, bf, bf 01 02 01 02, 81 9f, 9f 80 00, 9f 9f 9f 9f 9f ff ff ff ff, 9f 81 9f 81 9f 9f ff ff ff\n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A few examples for the five subkinds of well-formedness error kind 3 (syntax error) are shown below.",
      "ja": "適切な誤差誤り型3（構文誤差）の5つの部分側のサブフレンドのいくつかの例を以下に示す。"
    },
    {
      "indent": 0,
      "text": "Subkind 1:\n  Reserved additional information values:\n    1c, 1d, 1e, 3c, 3d, 3e, 5c, 5d, 5e, 7c, 7d, 7e, 9c, 9d, 9e, bc, bd, be, dc, dd, de, fc, fd, fe,\n\nSubkind 2:\n  Reserved two-byte encodings of simple values:\n    f8 00, f8 01, f8 18, f8 1f\n\nSubkind 3:\n  Indefinite-length string chunks not of the correct type:\n    5f 00 ff, 5f 21 ff, 5f 61 00 ff, 5f 80 ff, 5f a0 ff, 5f c0 00 ff, 5f e0 ff, 7f 41 00 ff\n  Indefinite-length string chunks not definite length:\n    5f 5f 41 00 ff ff, 7f 7f 61 00 ff ff\n\nSubkind 4:\n  Break occurring on its own outside of an indefinite-length item:\n    ff\n  Break occurring in a definite-length array or map or a tag:\n    81 ff, 82 00 ff, a1 ff, a1 ff 00, a1 00 ff, a2 00 00 ff, 9f 81 ff, 9f 82 9f 81 9f 9f ff ff ff ff\n  Break in an indefinite-length map that would lead to an odd number of items (break in a value position):\n    bf 00 ff, bf 00 00 00 ff\n\nSubkind 5:\n  Major type 0, 1, 6 with additional information 31:\n    1f, 3f, df\n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix G. Changes from RFC 7049",
      "ja": "付録G. RFC 7049からの変更",
      "section_title": true
    },
    {
      "indent": 3,
      "text": "As discussed in the introduction, this document formally obsoletes RFC 7049 while keeping full compatibility with the interchange format from RFC 7049. This document provides editorial improvements, added detail, and fixed errata. This document does not create a new version of the format.",
      "ja": "序論で説明したように、この文書はRFC 7049からの交換形式との完全な互換性を保ちながらRFC 7049を正式に廃止します。この文書は編集上の改善、詳細、および固定された正誤表を提供します。この文書はフォーマットの新しいバージョンを作成しません。"
    },
    {
      "indent": 0,
      "text": "G.1. Errata Processing and Clerical Changes",
      "section_title": true,
      "ja": "G.1. エラータ処理と事務変更"
    },
    {
      "indent": 3,
      "text": "The two verified errata on RFC 7049, [Err3764] and [Err3770], concerned two encoding examples in the text that have been corrected (Section 3.4.3: \"29\" -> \"49\", Section 5.5: \"0b000_11101\" -> \"0b000_11001\"). Also, RFC 7049 contained an example using the numeric value 24 for a simple value [Err5917], which is not well-formed; this example has been removed. Errata report 5763 [Err5763] pointed to an error in the wording of the definition of tags; this was resolved during a rewrite of Section 3.4. Errata report 5434 [Err5434] pointed out that the Universal Binary JSON (UBJSON) example in Appendix E no longer complied with the version of UBJSON current at the time of the errata report submission. It turned out that the UBJSON specification had completely changed since 2013; this example therefore was removed. Other errata reports [Err4409] [Err4963] [Err4964] complained that the map key sorting rules for canonical encoding were onerous; these led to a reconsideration of the canonical encoding suggestions and replacement by the deterministic encoding suggestions (described below). An editorial suggestion in errata report 4294 [Err4294] was also implemented (improved symmetry by adding \"Second value\" to a comment to the last example in Section 3.2.2).",
      "ja": "RFC 7049に関する検証済みの2つのエラッタ[Err3764]と[Err3770]は、本文中の2つのエンコード例に関するもので、修正済みです（セクション3.4.3：「29」→「49」、セクション5.5：「0b000_11101」→「0b000_11001」）。また、RFC 7049には、数値24を単純な値として使用している例[Err5917]が含まれていましたが、これは整形式ではないため削除されました。エラッタレポート5763[Err5763]は、タグの定義の文言に誤りがあると指摘していましたが、セクション3.4の書き換え中に修正されました。エラッタレポート5434 [Err5434] では、付録EのUniversal Binary JSON (UBJSON) の例が、エラッタレポート提出時点のUBJSONの最新バージョンに準拠していないことが指摘されました。UBJSON仕様は2013年以降完全に変更されていたことが判明したため、この例は削除されました。その他のエラッタレポート [Err4409] [Err4963] [Err4964] では、標準エンコーディングにおけるマップキーのソートルールが煩雑であるとの指摘があり、標準エンコーディングの提案を再検討し、決定論的エンコーディングの提案（後述）に置き換えました。エラッタレポート4294 [Err4294] の編集上の提案も実装されました（セクション3.2.2の最後の例のコメントに「Second value」を追加することで対称性を改善しました）。"
    },
    {
      "indent": 3,
      "text": "Other clerical changes include:",
      "ja": "その他の事務の変更は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* the use of new xml2rfc functionality [RFC7991];",
      "ja": "* 新しいXML2RFC機能の使用[RFC7991]。"
    },
    {
      "indent": 3,
      "text": "* more explanation of the notation used;",
      "ja": "* 使用されている表記の説明。"
    },
    {
      "indent": 3,
      "text": "* the update of references, e.g., from RFC 4627 to [RFC8259], from CNN-TERMS to [RFC7228], and from the 5.1 edition to the 11th edition of [ECMA262]; the addition of a reference to [IEEE754] and importation of required definitions; the addition of references to [C] and [Cplusplus20]; and the addition of a reference to [RFC8618] that further illustrates the discussion in Appendix E;",
      "ja": "* 参照の更新、例えば、RFC 4627から[RFC8259]、CNN  - 用語から[RFC7228]、および5.1版から第11版の[ECMA262]への更新。[IEEE754]への参照と必要な定義の輸入の追加。[c]と[cplusplus20]への参照の追加。付録Eにおける議論をさらに説明する[RFC8618]への参照の追加。"
    },
    {
      "indent": 3,
      "text": "* in the discussion of diagnostic notation (Section 8), the \"Extended Diagnostic Notation\" (EDN) defined in [RFC8610] is now mentioned, the gap in representing NaN payloads is now highlighted, and an explanation of representing indefinite-length strings with no chunks has been added (Section 8.1);",
      "ja": "* 診断表記法の説明（第8節）では、[RFC8610]で定義された「拡張診断表記」（EDN）がここに述べられているため、ナンペイロードを表す際のギャップは強調表示されており、無期限の文字列を表す説明チャンクが追加されました（セクション8.1）。"
    },
    {
      "indent": 3,
      "text": "* the addition of this appendix.",
      "ja": "* この付録の追加。"
    },
    {
      "indent": 0,
      "text": "G.2. Changes in IANA Considerations",
      "section_title": true,
      "ja": "G.2. IANAの考慮事項の変更"
    },
    {
      "indent": 3,
      "text": "The IANA considerations were generally updated (clerical changes, e.g., now pointing to the CBOR Working Group as the author of the specification). References to the respective IANA registries were added to the informative references.",
      "ja": "IANAの考慮事項は一般的に更新されました（例えば、事務職の作業グループを説明のために、事務官の作業グループを指しています）。それぞれのIANAレジストリへの参照は有益な参照に追加されました。"
    },
    {
      "indent": 3,
      "text": "In the \"Concise Binary Object Representation (CBOR) Tags\" registry [IANA.cbor-tags], tags in the space from 256 to 32767 (lower half of \"1+2\") are no longer assigned by First Come First Served; this range is now Specification Required.",
      "ja": "\"簡潔なバイナリ オブジェクト表現 (CBOR) タグ\" レジストリ [IANA.cbor-tags] では、256 から 32767 (\"1+2\" の下半分) までのスペースのタグは先着順で割り当てられなくなり、この範囲は仕様が必要になりました。"
    },
    {
      "indent": 0,
      "text": "G.3. Changes in Suggestions and Other Informational Components",
      "section_title": true,
      "ja": "G.3. 提案やその他の情報構成要素の変化"
    },
    {
      "indent": 3,
      "text": "While revising the document, beyond the addressing of the errata reports, the working group drew upon nearly seven years of experience with CBOR in a diverse set of applications. This led to a number of editorial changes, including adding tables for illustration, but also emphasizing some aspects and de-emphasizing others.",
      "ja": "文書を修正しながら、エラータレポートのアドレッシングを超えて、ワーキンググループは、さまざまなアプリケーションの中でCBORとほぼ7年間の経験を務めました。イラストのためのテーブルの追加を含む、いくつかの側面を強調し、他の側面を強調しても、いくつかの側面を強調しても、いくつかの編集的な変更がありました。"
    },
    {
      "indent": 3,
      "text": "A significant addition is Section 2, which discusses the CBOR data model and its small variations involved in the processing of CBOR. The introduction of terms for those variations (basic generic, extended generic, specific) enables more concise language in other places of the document and also helps to clarify expectations of implementations and of the extensibility features of the format.",
      "ja": "重要な追加はセクション2であり、CBORデータモデルとCBORの処理に関与するその小さな変動について説明します。これらのバリエーションのための用語の導入（基本総称、拡張総称、特有）は、文書の他の場所でより簡潔な言語を可能にし、また実装の期待とフォーマットの拡張機能の特徴を明確にするのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "As a format derived from the JSON ecosystem, RFC 7049 was influenced by the JSON number system that was in turn inherited from JavaScript at the time. JSON does not provide distinct integers and floating-point values (and the latter are decimal in the format). CBOR provides binary representations of numbers, which do differ between integers and floating-point values. Experience from implementation and use suggested that the separation between these two number domains should be more clearly drawn in the document; language that suggested an integer could seamlessly stand in for a floating-point value was removed. Also, a suggestion (based on I-JSON [RFC7493]) was added for handling these types when converting JSON to CBOR, and the use of a specific rounding mechanism has been recommended.",
      "ja": "JSONエコシステムから派生したフォーマットとして、RFC 7049はその時点でJavaScriptから継承されていたJSON番号システムの影響を受けました。JSONは、明確な整数と浮動小数点値を提供しません（そして後者はフォーマットの10進数です）。CBORは数字の2進表現を提供します。これは整数と浮動小数点値の間で異なります。実施と使用からの経験は、これら2つの数ドメイン間の分離が文書内でより明確に描かれるべきであることを提案した。整数を示唆した言語は、浮動小数点値のためにシームレスに立つことができました。また、JSONをCBORに変換するときにこれらのタイプを取り扱うために、（I-JSON [RFC7493]に基づく）の提案が追加され、特定の丸め機構の使用が推奨されています。"
    },
    {
      "indent": 3,
      "text": "For a single value in the data model, CBOR often provides multiple encoding options. A new section (Section 4) introduces the term \"preferred serialization\" (Section 4.1) and defines it for various kinds of data items. On the basis of this terminology, the section then discusses how a CBOR-based protocol can define \"deterministic encoding\" (Section 4.2), which avoids terms \"canonical\" and \"canonicalization\" from RFC 7049. The suggestion of \"Core Deterministic Encoding Requirements\" (Section 4.2.1) enables generic support for such protocol-defined encoding requirements. This document further eases the implementation of deterministic encoding by simplifying the map ordering suggested in RFC 7049 to a simple lexicographic ordering of encoded keys. A description of the older suggestion is kept as an alternative, now termed \"length-first map key ordering\" (Section 4.2.3).",
      "ja": "データモデルの単一の値については、CBORは多くの場合、複数のエンコードオプションを提供します。新しいセクション（セクション4）では、「優先シリアル化」という用語（4.1節）を紹介し、さまざまな種類のデータ項目について定義します。この用語に基づいて、セクションは、CBORベースのプロトコルが「決定論的符号化」（セクション4.2）を定義できる方法について説明し、これはRFC 7049からの用語「正準」および「正規化」を回避する。「コア決定論的符号化要件の提案」「（セクション4.2.1）このようなプロトコル定義のエンコーディング要件に対する一般的なサポートを有効にします。この文書は、RFC 7049で提案されたマップ順序を符号化キーの単純な辞書順序付けに単純化することによって、決定論的符号化の実装をさらに容易にする。古い提案の説明は代替案として保管されており、現在「長さ - 最初の地図鍵順序」と呼ばれます（セクション4.2.3）。"
    },
    {
      "indent": 3,
      "text": "The terminology for well-formed and valid data was sharpened and more stringently used, avoiding less well-defined alternative terms such as \"syntax error\", \"decoding error\", and \"strict mode\" outside of examples. Also, a third level of requirements that an application has on its input data beyond CBOR-level validity is now explicitly called out. Well-formed (processable at all), valid (checked by a validity-checking generic decoder), and expected input (as checked by the application) are treated as a hierarchy of layers of acceptability.",
      "ja": "整形式および有効なデータのための用語は鮮明され、そしてより厳格に使用され、例以外の「構文誤差」、「復号誤差」、および「厳密モード」などの明確な定義された代替項を回避した。また、アプリケーションがCBORレベルの妥当性を超えてその入力データにあるという3番目のレベルの要件は、明示的に呼び出されます。有効（有効性検査汎用デコーダによってチェックされている）、予想される入力（アプリケーションによってチェックされている）は、許容可能性の層の階層として扱われます。"
    },
    {
      "indent": 3,
      "text": "The handling of non-well-formed simple values was clarified in text and pseudocode. Appendix F was added to discuss well-formedness errors and provide examples for them. The pseudocode was updated to be more portable, and some portability considerations were added.",
      "ja": "非整形式の単純値の取り扱いは、テキストおよび擬似コードで明確にされた。付録Fを追加して、正常性誤差を議論し、それらの例を提供した。疑似コードはより移植可能に更新され、いくつかの移植性の考慮が追加されました。"
    },
    {
      "indent": 3,
      "text": "The discussion of validity has been sharpened in two areas. Map validity (handling of duplicate keys) was clarified, and the domain of applicability of certain implementation choices explained. Also, while streamlining the terminology for tags, tag numbers, and tag content, discussion was added on tag validity, and the restrictions were clarified on tag content, in general and specifically for tag 1.",
      "ja": "妥当性についての議論は2つの分野で研磨されています。マップの有効性（重複キーの処理）が明確にされ、特定の実装選択の適用可能性のドメインが説明されました。また、タグ、タグ数、およびタグ内容の用語を合理化しながら、タグの妥当性について議論を追加し、その制限はタグ含有量、一般にタグ1のために制限された。"
    },
    {
      "indent": 3,
      "text": "An implementation note (and note for future tag definitions) was added to Section 3.4 about defining tags with semantics that depend on serialization order.",
      "ja": "シリアル化順序に依存するセマンティクスを使用して、タグを定義する方法については、実装ノート（および将来のタグ定義のメモ）がセクション3.4に追加されました。"
    },
    {
      "indent": 3,
      "text": "Tag 35 is not defined by this document; the registration based on the definition in RFC 7049 remains in place.",
      "ja": "タグ35はこの文書によって定義されていません。RFC 7049の定義に基づく登録は依存しています。"
    },
    {
      "indent": 3,
      "text": "Terminology was introduced in Section 3 for \"argument\" and \"head\", simplifying further discussion.",
      "ja": "項目3には「議論」および「頭」についての用語を紹介し、さらなる議論を簡素化した。"
    },
    {
      "indent": 3,
      "text": "The security considerations (Section 10) were mostly rewritten and significantly expanded; in multiple other places, the document is now more explicit that a decoder cannot simply condone well-formedness errors.",
      "ja": "セキュリティ上の考慮事項（セクション10）は主に書き換えられ、大幅に拡張されました。他の複数の場所では、ドキュメントはデコーダが単に十分に形成されたエラーを調整することができないことをより明確にするようになりました。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "CBOR was inspired by MessagePack. MessagePack was developed and promoted by Sadayuki Furuhashi (\"frsyuki\"). This reference to MessagePack is solely for attribution; CBOR is not intended as a version of, or replacement for, MessagePack, as it has different design goals and requirements.",
      "ja": "CBORはMessagePackに触発されました。Furuhashi Sadayuki（ \"Frsyuki\"）によって掲載され、宣伝されました。MessagePackへのこの参照は帰属のみです。CBORは、デザインの目標と要件が異なるため、MessagePackのバージョン、または交換用の交換として意図されていません。"
    },
    {
      "indent": 3,
      "text": "The need for functionality beyond the original MessagePack specification became obvious to many people at about the same time around the year 2012. BinaryPack is a minor derivation of MessagePack that was developed by Eric Zhang for the binaryjs project. A similar, but different, extension was made by Tim Caswell for his msgpack-js and msgpack-js-browser projects. Many people have contributed to the discussion about extending MessagePack to separate text string representation from byte string representation.",
      "ja": "元のMessagePackの仕様を超えた機能の必要性は、2012年の約2012年頃に多くの人々に明らかになりました.BinaryPackは、BinaryJSプロジェクトのEric Zhangによって開発されたMessagePackのマイナーな導出です。MSGPACK-JSおよびMSGPACK-JSブラウザプロジェクトのTIM CASWELLによって、似たように異なる拡張が行われました。多くの人がMessagePackの拡張についての議論に貢献しています。"
    },
    {
      "indent": 3,
      "text": "The encoding of the additional information in CBOR was inspired by the encoding of length information designed by Klaus Hartke for CoAP.",
      "ja": "CBORの追加情報の符号化は、Klaus Hartkeによって設計された長さ情報の符号化に触発された。"
    },
    {
      "indent": 3,
      "text": "This document also incorporates suggestions made by many people, notably Dan Frost, James Manger, Jeffrey Yasskin, Joe Hildebrand, Keith Moore, Laurence Lundblade, Matthew Lepinski, Michael Richardson, Nico Williams, Peter Occil, Phillip Hallam-Baker, Ray Polk, Stuart Cheshire, Tim Bray, Tony Finch, Tony Hansen, and Yaron Sheffer. Benjamin Kaduk provided an extensive review during IESG processing. Éric Vyncke, Erik Kline, Robert Wilton, and Roman Danyliw provided further IESG comments, which included an IoT directorate review by Eve Schooler.",
      "ja": "この文書はまた、多くの人々、特にダンフロスト、ジェームズマネージャ、ジェームズマネージャ、ジェームズマネージャー、ジェムーリーヤシキ、ジョーヒルデブランド、キースムーア、ローレンスランドブレード、マイチューレパンソン、マイケルリチャードソン、ピーターオック、ピータースティュート、スチュアートチェシャー、Tim Breay、Tony Finch、Tony Hansen、およびYaron Sheffer。Benjamin Kadukは、IESG処理中に広範囲のレビューを提供しました。エリックVyncke、Erik Kline、Robert Wilton、およびRoman DanyLiwは、Eve SurchererによるIoT Distracateレビューを含む、さらにIESGのコメントを提供しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Carsten Bormann Universität Bremen TZI Postfach 330440 D-28359 Bremen Germany",
      "ja": "Bremen Tzi Postfach 330440 D-28359ブレーメンドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49-421-218-63921\nEmail: cabo@tzi.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Paul Hoffman ICANN",
      "ja": "Paul Hoffman icann."
    },
    {
      "indent": 3,
      "text": "Email: paul.hoffman@icann.org",
      "raw": true,
      "ja": ""
    }
  ]
}