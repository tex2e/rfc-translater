{
  "title": {
    "text": "RFC 9106 - Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications",
    "ja": "RFC 9106 - パスワードハッシュおよびProof-of-WorkアプリケーションのためのArgon2メモリハード機能"
  },
  "number": 9106,
  "created_at": "2021-09-09 02:59:07.875194+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          A. Biryukov\nRequest for Comments: 9106                                       D. Dinu\nCategory: Informational                         University of Luxembourg\nISSN: 2070-1721                                          D. Khovratovich\n                                                         ABDK Consulting\n                                                            S. Josefsson\n                                                                  SJD AB\n                                                          September 2021",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications",
      "ja": "パスワードハッシュおよびProof-of-WorkアプリケーションのためのArgon2メモリハード機能"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Argon2 memory-hard function for password hashing and proof-of-work applications. We provide an implementer-oriented description with test vectors. The purpose is to simplify adoption of Argon2 for Internet protocols. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.",
      "ja": "このドキュメントは、パスワードハッシュおよびプルーフ・オブ・ワーク（PoW）アプリケーション向けのArgon2メモリハード関数について説明します。実装者向けの説明とテストベクトルを提供します。このドキュメントの目的は、インターネットプロトコルへのArgon2の導入を簡素化することです。このドキュメントは、IRTFのCrypto Forum Research Group（CFRG）の成果物です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書はインターネット標準のトラック仕様ではありません。情報提供のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットリサーチタスクフォース（IRTF）の製品です。IRTFはインターネット関連の研究開発活動の結果を発行しています。これらの結果は展開には適していない可能性があります。このRFCは、インターネットリサーチタスクフォース（IRTF）のCryptoフォーラム研究グループの合意を表しています。IRSGによる出版が承認された文書は、インターネット規格のレベルレベルの候補者ではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9106.",
      "ja": "この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/rfc9106で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2021 IETF信頼と文書著者として識別された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、この文書の公開日に有効なIETF文書（https://truste.ietf.org/License-info）に関するBCP 78とIETF信頼の法的規定を受けています。この文書に関してあなたの権利と制限を説明するので、これらの文書を慎重に見直してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Language\n2.  Notation and Conventions\n3.  Argon2 Algorithm\n  3.1.  Argon2 Inputs and Outputs\n  3.2.  Argon2 Operation\n  3.3.  Variable-Length Hash Function H'\n  3.4.  Indexing\n    3.4.1.  Computing the 32-Bit Values J_1 and J_2\n    3.4.2.  Mapping J_1 and J_2 to Reference Block Index [l][z]\n  3.5.  Compression Function G\n  3.6.  Permutation P\n4.  Parameter Choice\n5.  Test Vectors\n  5.1.  Argon2d Test Vectors\n  5.2.  Argon2i Test Vectors\n  5.3.  Argon2id Test Vectors\n6.  IANA Considerations\n7.  Security Considerations\n  7.1.  Security as a Hash Function and KDF\n  7.2.  Security against Time-Space Trade-off Attacks\n  7.3.  Security for Time-Bounded Defenders\n  7.4.  Recommendations\n8.  References\n  8.1.  Normative References\n  8.2.  Informative References\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the Argon2 [ARGON2ESP] memory-hard function for password hashing and proof-of-work applications. We provide an implementer-oriented description with test vectors. The purpose is to simplify adoption of Argon2 for Internet protocols. This document corresponds to version 1.3 of the Argon2 hash function.",
      "ja": "この文書は、パスワードハッシュおよびプルーフ・オブ・ワーク（PoW）アプリケーション向けのメモリハード関数Argon2 [ARGON2ESP] について説明します。実装者向けの説明とテストベクトルを提供します。インターネットプロトコルへのArgon2の導入を簡素化することを目的としています。この文書は、Argon2ハッシュ関数のバージョン1.3に対応しています。"
    },
    {
      "indent": 3,
      "text": "Argon2 is a memory-hard function [HARD]. It is a streamlined design. It aims at the highest memory-filling rate and effective use of multiple computing units, while still providing defense against trade-off attacks. Argon2 is optimized for the x86 architecture and exploits the cache and memory organization of the recent Intel and AMD processors. Argon2 has one primary variant, Argon2id, and two supplementary variants, Argon2d and Argon2i. Argon2d uses data-dependent memory access, which makes it suitable for cryptocurrencies and proof-of-work applications with no threats from side-channel timing attacks. Argon2i uses data-independent memory access, which is preferred for password hashing and password-based key derivation. Argon2id works as Argon2i for the first half of the first pass over the memory and as Argon2d for the rest, thus providing both side-channel attack protection and brute-force cost savings due to time-memory trade-offs. Argon2i makes more passes over the memory to protect from trade-off attacks [AB15].",
      "ja": "Argon2はメモリハード関数[HARD]です。合理化された設計で、最高のメモリ充填率と複数のコンピューティングユニットの効率的な利用を目指しつつ、トレードオフ攻撃に対する防御機能も備えています。Argon2はx86アーキテクチャ向けに最適化されており、最新のIntelおよびAMDプロセッサのキャッシュとメモリ構成を活用します。Argon2には、Argon2idという主要なバリアントと、Argon2dとArgon2iという2つの補助バリアントがあります。Argon2dはデータ依存型メモリアクセスを使用するため、サイドチャネルタイミング攻撃の脅威がなく、暗号通貨やプルーフオブワークアプリケーションに適しています。Argon2iはデータ非依存型メモリアクセスを使用するため、パスワードハッシュやパスワードベースの鍵導出に適しています。Argon2idは、メモリの最初のパスの前半ではArgon2iとして動作し、残りの半分ではArgon2dとして動作します。これにより、サイドチャネル攻撃からの保護と、時間とメモリのトレードオフによるブルートフォース攻撃のコスト削減の両方を実現します。 Argon2iはトレードオフ攻撃から保護するためにメモリを何度も通過します[AB15]。"
    },
    {
      "indent": 3,
      "text": "Argon2id MUST be supported by any implementation of this document, whereas Argon2d and Argon2i MAY be supported.",
      "ja": "Argon2id はこのドキュメントのすべての実装でサポートされる必要がありますが、Argon2d と Argon2i はサポートされる場合があります。"
    },
    {
      "indent": 3,
      "text": "Argon2 is also a mode of operation over a fixed-input-length compression function G and a variable-input-length hash function H. Even though Argon2 can be potentially used with an arbitrary function H, as long as it provides outputs up to 64 bytes, the BLAKE2b function [BLAKE2] is used in this document.",
      "ja": "Argon2 は、固定入力長の圧縮関数 G と可変入力長のハッシュ関数 H 上での動作モードでもあります。Argon2 は、64 バイトまでの出力を提供する限り、任意の関数 H で使用できる可能性がありますが、このドキュメントでは BLAKE2b 関数 [BLAKE2] が使用されます。"
    },
    {
      "indent": 3,
      "text": "For further background and discussion, see the Argon2 paper [ARGON2].",
      "ja": "詳しい背景と議論については、Argon2 の論文 [ARGON2] を参照してください。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Crypto Forum Research Group (CFRG).",
      "ja": "この文書は、Crypto Forum Research Group（CFRG）の合意を表しています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Conventions",
      "section_title": true,
      "ja": "2. 表記法と規則"
    },
    {
      "indent": 3,
      "text": "x^y : integer x multiplied by itself integer y times",
      "ja": "x^y : 整数xを整数y回掛け合わせた値"
    },
    {
      "indent": 3,
      "text": "a*b : multiplication of integer a and integer b",
      "ja": "a*b : 整数aと整数bの乗算"
    },
    {
      "indent": 3,
      "text": "c-d : subtraction of integer d from integer c",
      "ja": "整数からの整数dのC-D減算"
    },
    {
      "indent": 3,
      "text": "E_f : variable E with subscript index f",
      "ja": "c-d : 整数cから整数dを減算する"
    },
    {
      "indent": 3,
      "text": "g / h : integer g divided by integer h. The result is a rational number.",
      "ja": "g / h : 整数 g を整数 h で割った値。結果は有理数です。"
    },
    {
      "indent": 3,
      "text": "I(j) : function I evaluated at j",
      "ja": "I(j) : j で評価された関数 I"
    },
    {
      "indent": 3,
      "text": "K || L : string K concatenated with string L",
      "ja": "K || L : 文字列 K と文字列 L を連結したもの"
    },
    {
      "indent": 3,
      "text": "a XOR b : bitwise exclusive-or between bitstrings a and b",
      "ja": "a XOR b : ビット列 a と b のビット単位の排他的論理和"
    },
    {
      "indent": 3,
      "text": "a mod b : remainder of integer a modulo integer b, always in range [0, b-1]",
      "ja": "a mod b : 整数aを整数bで割った余り。範囲は常に[0, b-1]"
    },
    {
      "indent": 3,
      "text": "a >>> n : rotation of 64-bit string a to the right by n bits",
      "ja": "a >>> n : 64ビット文字列 a を右に n ビット回転する"
    },
    {
      "indent": 3,
      "text": "trunc(a) : the 64-bit value, truncated to the 32 least significant bits",
      "ja": "trunc(a) : 64ビット値を下位32ビットに切り捨てた値"
    },
    {
      "indent": 3,
      "text": "floor(a) : the largest integer not bigger than a",
      "ja": "floor(a) : a以下の最大の整数"
    },
    {
      "indent": 3,
      "text": "ceil(a) : the smallest integer not smaller than a",
      "ja": "ceil(a) : a以上の最小の整数"
    },
    {
      "indent": 3,
      "text": "extract(a, i) : the i-th set of 32 bits from bitstring a, starting from 0-th",
      "ja": "extract(a, i) : ビット列aから0番目から始まるi番目の32ビットセット"
    },
    {
      "indent": 3,
      "text": "|A| : the number of elements in set A",
      "ja": "|A| : 集合Aの要素数"
    },
    {
      "indent": 3,
      "text": "LE32(a) : 32-bit integer a converted to a byte string in little endian (for example, 123456 (decimal) is 40 E2 01 00)",
      "ja": "LE32(a) : 32ビット整数aをリトルエンディアンのバイト文字列に変換したもの（例えば、123456（10進数）は40 E2 01 00）"
    },
    {
      "indent": 3,
      "text": "LE64(a) : 64-bit integer a converted to a byte string in little endian (for example, 123456 (decimal) is 40 E2 01 00 00 00 00 00)",
      "ja": "LE64(a) : 64ビット整数 a をリトルエンディアンのバイト文字列に変換したもの（例えば、123456（10進数）は40 E2 01 00 00 00 00 00）"
    },
    {
      "indent": 3,
      "text": "int32(s) : 32-bit string s is converted to a non-negative integer in little endian",
      "ja": "int32(s) : 32ビット文字列sをリトルエンディアンの非負整数に変換する"
    },
    {
      "indent": 3,
      "text": "int64(s) : 64-bit string s is converted to a non-negative integer in little endian",
      "ja": "int64(s) : 64ビット文字列sをリトルエンディアンの非負整数に変換します。"
    },
    {
      "indent": 3,
      "text": "length(P) : the byte length of string P expressed as 32-bit integer",
      "ja": "length(P) : 文字列Pのバイト長を32ビット整数で表したもの"
    },
    {
      "indent": 3,
      "text": "ZERO(P) : the P-byte zero string",
      "ja": "ZERO(P) : Pバイトのゼロ文字列"
    },
    {
      "indent": 0,
      "text": "3. Argon2 Algorithm",
      "section_title": true,
      "ja": "3. Argon2アルゴリズム"
    },
    {
      "indent": 0,
      "text": "3.1. Argon2 Inputs and Outputs",
      "section_title": true,
      "ja": "3.1. Argon2入力と出力"
    },
    {
      "indent": 3,
      "text": "Argon2 has the following input parameters:",
      "ja": "Argon2 には次の入力パラメータがあります。"
    },
    {
      "indent": 3,
      "text": "* Message string P, which is a password for password hashing applications. It MUST have a length not greater than 2^(32)-1 bytes.",
      "ja": "* メッセージ文字列P。パスワードハッシュアプリケーションのパスワードである。2^(32)-1バイト以下の長さを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Nonce S, which is a salt for password hashing applications. It MUST have a length not greater than 2^(32)-1 bytes. 16 bytes is RECOMMENDED for password hashing. The salt SHOULD be unique for each password.",
      "ja": "* パスワードハッシュアプリケーション用のソルトであるノンスS。長さは2^(32)-1バイト以下でなければなりません。パスワードハッシュには16バイトが推奨されます。ソルトはパスワードごとに一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "* Degree of parallelism p determines how many independent (but synchronizing) computational chains (lanes) can be run. It MUST be an integer value from 1 to 2^(24)-1.",
      "ja": "* 並列度Pの程度は、独立した（しかし同期化）計算チェーン（レーン）を実行できるものを決定する。1~2^(24)-1の整数値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Tag length T MUST be an integer number of bytes from 4 to 2^(32)- 1.",
      "ja": "* タグ長Tは、4から2^(32)-1までの整数バイト数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Memory size m MUST be an integer number of kibibytes from 8*p to 2^(32)-1. The actual number of blocks is m', which is m rounded down to the nearest multiple of 4*p.",
      "ja": "* メモリサイズmは、8*pから2^(32)-1までのキビバイト単位の整数でなければなりません。実際のブロック数はm'で、これはmを4*pの倍数に切り捨てた値です。"
    },
    {
      "indent": 3,
      "text": "* Number of passes t (used to tune the running time independently of the memory size) MUST be an integer number from 1 to 2^(32)-1.",
      "ja": "* パス数 t (メモリサイズとは無関係に実行時間を調整するために使用される) は、1 から 2^(32)-1 までの整数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Version number v MUST be one byte 0x13.",
      "ja": "* バージョン番号vは1バイト0x13でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Secret value K is OPTIONAL. If used, it MUST have a length not greater than 2^(32)-1 bytes.",
      "ja": "* 秘密値Kはオプションです。使用する場合は、その長さは2^(32)-1バイト以下でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Associated data X is OPTIONAL. If used, it MUST have a length not greater than 2^(32)-1 bytes.",
      "ja": "* 関連データXはオプションです。使用する場合は、長さが2^(32)-1バイト以下である必要があります。"
    },
    {
      "indent": 3,
      "text": "* Type y MUST be 0 for Argon2d, 1 for Argon2i, or 2 for Argon2id.",
      "ja": "* タイプ y は、Argon2d の場合は 0、Argon2i の場合は 1、Argon2id の場合は 2 である必要があります。"
    },
    {
      "indent": 3,
      "text": "The Argon2 output, or \"tag\", is a string T bytes long.",
      "ja": "Argon2 の出力、つまり「タグ」は、T バイトの長さの文字列です。"
    },
    {
      "indent": 0,
      "text": "3.2. Argon2 Operation",
      "section_title": true,
      "ja": "3.2. Argon2操作"
    },
    {
      "indent": 3,
      "text": "Argon2 uses an internal compression function G with two 1024-byte inputs, a 1024-byte output, and an internal hash function H^x(), with x being its output length in bytes. Here, H^x() applied to string A is the BLAKE2b ([BLAKE2], Section 3.3) function, which takes (d,ll,kk=0,nn=x) as parameters, where d is A padded to a multiple of 128 bytes and ll is the length of d in bytes. The compression function G is based on its internal permutation. A variable-length hash function H' built upon H is also used. G is described in Section 3.5, and H' is described in Section 3.3.",
      "ja": "Argon2は、2つの1024バイトの入力と1つの1024バイトの出力を持つ内部圧縮関数Gと、内部ハッシュ関数H^x()（xは出力長（バイト単位））を使用します。ここで、文字列Aに適用されるH^x()はBLAKE2b（[BLAKE2]、セクション3.3）関数であり、(d,ll,kk=0,nn=x)をパラメータとして受け取ります。ここで、dはAを128バイトの倍数にパディングしたもの、llはdのバイト長です。圧縮関数Gは、その内部順列に基づいています。また、Hに基づいて構築された可変長ハッシュ関数H'も使用されます。Gについてはセクション3.5で、H'についてはセクション3.3で説明します。"
    },
    {
      "indent": 3,
      "text": "The Argon2 operation is as follows.",
      "ja": "Argon2の操作は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Establish H_0 as the 64-byte value as shown below. If K, X, or S has zero length, it is just absent, but its length field remains.",
      "ja": "1. H_0を以下の64バイトの値として設定します。K、X、またはSの長さが0の場合、それらは単に存在しないだけで、長さフィールドは保持されます。"
    },
    {
      "indent": 7,
      "text": "H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||\n        LE32(v) || LE32(y) || LE32(length(P)) || P ||\n        LE32(length(S)) || S ||  LE32(length(K)) || K ||\n        LE32(length(X)) || X)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Figure 1: H_0 Generation",
      "ja": "図1：H_0の生成"
    },
    {
      "indent": 3,
      "text": "2. Allocate the memory as m' 1024-byte blocks, where m' is derived as:",
      "ja": "2. メモリを m' 個の 1024 バイト ブロックとして割り当てます。ここで、m' は次のように導出されます。"
    },
    {
      "indent": 7,
      "text": "m' = 4 * p * floor (m / 4p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 2: Memory Allocation",
      "ja": "図2：メモリ割り当て"
    },
    {
      "indent": 7,
      "text": "For p lanes, the memory is organized in a matrix B[i][j] of blocks with p rows (lanes) and q = m' / p columns.",
      "ja": "p 個のプレーンの場合、メモリは p 行 (レーン) と q = m' / p 列のブロックのマトリックス B[i][j] に編成されます。"
    },
    {
      "indent": 3,
      "text": "3. Compute B[i][0] for all i ranging from (and including) 0 to (not including) p.",
      "ja": "3. 0（0を含む）からp（pを含まない）までのすべてのiについてB[i][0]を計算します。"
    },
    {
      "indent": 7,
      "text": "B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 3: Lane Starting Blocks",
      "ja": "図3：レーンスターティングブロック"
    },
    {
      "indent": 3,
      "text": "4. Compute B[i][1] for all i ranging from (and including) 0 to (not including) p.",
      "ja": "4. 0（0を含む）からp（pを含まない）までのすべてのiについてB[i][1]を計算します。"
    },
    {
      "indent": 7,
      "text": "B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 4: Second Lane Blocks",
      "ja": "図4：2番目のレーンブロック"
    },
    {
      "indent": 3,
      "text": "5. Compute B[i][j] for all i ranging from (and including) 0 to (not including) p and for all j ranging from (and including) 2 to (not including) q. The computation MUST proceed slicewise (Section 3.4): first, blocks from slice 0 are computed for all lanes (in an arbitrary order of lanes), then blocks from slice 1 are computed, etc. The block indices l and z are determined for each i, j differently for Argon2d, Argon2i, and Argon2id.",
      "ja": "5. 0（0を含む）からp（pを含まない）までのすべてのiと、2（2を含む）からq（qを含まない）までのすべてのjについて、B[i][j]を計算します。計算はスライス単位で行う必要があります（セクション3.4）。まず、スライス0のブロックがすべてのレーンについて計算されます（レーンの順序は任意）。次に、スライス1のブロックが計算されます。ブロックインデックスlとzは、Argon2d、Argon2i、Argon2idごとにiとjごとに異なります。"
    },
    {
      "indent": 7,
      "text": "B[i][j] = G(B[i][j-1], B[l][z])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 5: Further Block Generation",
      "ja": "図5：さらなるブロック生成"
    },
    {
      "indent": 3,
      "text": "6. If the number of passes t is larger than 1, we repeat step 5. We compute B[i][0] and B[i][j] for all i raging from (and including) 0 to (not including) p and for all j ranging from (and including) 1 to (not including) q. However, blocks are computed differently as the old value is XORed with the new one:",
      "ja": "6. パス数tが1より大きい場合、ステップ5を繰り返します。0（0を含む）からp（pを含まない）までのすべてのiと、1（1を含む）からq（qを含まない）までのすべてのjについて、B[i][0]とB[i][j]を計算します。ただし、ブロックの計算方法は異なり、古い値と新しい値の排他的論理和が取られます。"
    },
    {
      "indent": 7,
      "text": "B[i][0] = G(B[i][q-1], B[l][z]) XOR B[i][0];\nB[i][j] = G(B[i][j-1], B[l][z]) XOR B[i][j].",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Figure 6: Further Passes",
      "ja": "図6：それ以上の通過"
    },
    {
      "indent": 3,
      "text": "7. After t steps have been iterated, the final block C is computed as the XOR of the last column:",
      "ja": "7. t ステップが反復された後、最終ブロック C は最後の列の XOR として計算されます。"
    },
    {
      "indent": 7,
      "text": "C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 29,
      "text": "Figure 7: Final Block",
      "ja": "図7：最終ブロック"
    },
    {
      "indent": 3,
      "text": "8. The output tag is computed as H'^T(C).",
      "ja": "8. 出力タグはH'^T(C)として計算されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Variable-Length Hash Function H'",
      "section_title": true,
      "ja": "3.3. 可変長ハッシュ関数H'"
    },
    {
      "indent": 3,
      "text": "Let V_i be a 64-byte block and W_i be its first 32 bytes. Then we define function H' as follows:",
      "ja": "V_iを64バイトのブロック、W_iをその最初の32バイトとします。関数H'を以下のように定義します。"
    },
    {
      "indent": 11,
      "text": "if T <= 64\n    H'^T(A) = H^T(LE32(T)||A)\nelse\n    r = ceil(T/32)-2\n    V_1 = H^(64)(LE32(T)||A)\n    V_2 = H^(64)(V_1)\n    ...\n    V_r = H^(64)(V_{r-1})\n    V_{r+1} = H^(T-32*r)(V_{r})\n    H'^T(X) = W_1 || W_2 || ... || W_r || V_{r+1}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 8: Function H' for Tag and Initial Block Computations",
      "ja": "図8：タグと初期ブロック計算の関数h '"
    },
    {
      "indent": 0,
      "text": "3.4. Indexing",
      "section_title": true,
      "ja": "3.4. 索引付け"
    },
    {
      "indent": 3,
      "text": "To enable parallel block computation, we further partition the memory matrix into SL = 4 vertical slices. The intersection of a slice and a lane is called a segment, which has a length of q/SL. Segments of the same slice can be computed in parallel and do not reference blocks from each other. All other blocks can be referenced.",
      "ja": "並列ブロック計算を可能にするため、メモリマトリックスをさらにSL = 4の垂直スライスに分割します。スライスとレーンの交差部分はセグメントと呼ばれ、長さはq/SLです。同じスライス内のセグメントは並列計算が可能で、互いにブロックを参照しません。他のすべてのブロックは参照可能です。"
    },
    {
      "indent": 5,
      "text": "  slice 0    slice 1    slice 2    slice 3\n  ___/\\___   ___/\\___   ___/\\___   ___/\\___\n /        \\ /        \\ /        \\ /        \\\n+----------+----------+----------+----------+\n|          |          |          |          | > lane 0\n+----------+----------+----------+----------+\n|          |          |          |          | > lane 1\n+----------+----------+----------+----------+\n|          |          |          |          | > lane 2\n+----------+----------+----------+----------+\n|         ...        ...        ...         | ...\n+----------+----------+----------+----------+\n|          |          |          |          | > lane p - 1\n+----------+----------+----------+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 9: Single-Pass Argon2 with p Lanes and 4 Slices",
      "ja": "図9：Pレーンと4スライスを持つシングルパスArgon2"
    },
    {
      "indent": 0,
      "text": "3.4.1. Computing the 32-Bit Values J_1 and J_2",
      "section_title": true,
      "ja": "3.4.1. 32ビット値J_1とJ_2の計算"
    },
    {
      "indent": 0,
      "text": "3.4.1.1. Argon2d",
      "section_title": true,
      "ja": "3.4.1.1. Argon2d"
    },
    {
      "indent": 3,
      "text": "J_1 is given by the first 32 bits of block B[i][j-1], while J_2 is given by the next 32 bits of block B[i][j-1]:",
      "ja": "J_1はブロックB [i] [j  -  1]の最初の32ビットによって与えられ、J_2はブロックB [i] [J-1]の次の32ビットによって与えられます。"
    },
    {
      "indent": 3,
      "text": "J_1 = int32(extract(B[i][j-1], 0))\nJ_2 = int32(extract(B[i][j-1], 1))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 10: Deriving J1,J2 in Argon2d",
      "ja": "図10：ARGON2DのJ1、J2を導出する"
    },
    {
      "indent": 0,
      "text": "3.4.1.2. Argon2i",
      "section_title": true,
      "ja": "3.4.1.2. Argon2i."
    },
    {
      "indent": 3,
      "text": "For each segment, we do the following. First, we compute the value Z as:",
      "ja": "セグメントごとに、次のようにします。まず、値zを次のように計算します。"
    },
    {
      "indent": 3,
      "text": "Z= ( LE64(r) || LE64(l) || LE64(sl) || LE64(m') ||\n     LE64(t) || LE64(y) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 11: Input to Compute J1,J2 in Argon2i",
      "ja": "図11：argon2iのJ1、J2を計算するための入力"
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "ただし"
    },
    {
      "indent": 3,
      "text": "r: the pass number. l: the lane number. sl: the slice number. m': the total number of memory blocks. t: the total number of passes. y: the Argon2 type (0 for Argon2d, 1 for Argon2i, 2 for Argon2id)",
      "ja": "r: パス番号. l: レーン番号. sl: スライス番号. m': メモリブロックの合計数. t: パスの合計数. y: Argon2 のタイプ (Argon2d の場合は 0、Argon2i の場合は 1、Argon2id の場合は 2)"
    },
    {
      "indent": 3,
      "text": "Then we compute:",
      "ja": "それから我々は計算します："
    },
    {
      "indent": 3,
      "text": "q/(128*SL) 1024-byte values\nG(ZERO(1024),G(ZERO(1024),\nZ || LE64(1) || ZERO(968) )),\nG(ZERO(1024),G(ZERO(1024),\nZ || LE64(2) || ZERO(968) )),... ,\nG(ZERO(1024),G(ZERO(1024),\nZ || LE64(q/(128*SL)) || ZERO(968) )),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "which are partitioned into q/(SL) 8-byte values X, which are viewed as X1||X2 and converted to J_1=int32(X1) and J_2=int32(X2).",
      "ja": "これらはq/(SL)個の8バイト値Xに分割され、X1||X2として表示され、J_1=int32(X1)およびJ_2=int32(X2)に変換されます。"
    },
    {
      "indent": 3,
      "text": "The values r, l, sl, m', t, y, and i are represented as 8 bytes in little endian.",
      "ja": "r、l、sl、m'、t、y、i の値は、リトルエンディアンでは 8 バイトとして表されます。"
    },
    {
      "indent": 0,
      "text": "3.4.1.3. Argon2id",
      "section_title": true,
      "ja": "3.4.1.3. Argon2id"
    },
    {
      "indent": 3,
      "text": "If the pass number is 0 and the slice number is 0 or 1, then compute J_1 and J_2 as for Argon2i, else compute J_1 and J_2 as for Argon2d.",
      "ja": "パス数が 0 でスライス数が 0 または 1 の場合は、Argon2i の場合と同様に J_1 と J_2 を計算し、それ以外の場合は Argon2d の場合と同様に J_1 と J_2 を計算します。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Mapping J_1 and J_2 to Reference Block Index [l][z]",
      "section_title": true,
      "ja": "3.4.2. J_1とJ_2を参照ブロックインデックス[l][z]にマッピングする"
    },
    {
      "indent": 3,
      "text": "The value of l = J_2 mod p gives the index of the lane from which the block will be taken. For the first pass (r=0) and the first slice (sl=0), the block is taken from the current lane.",
      "ja": "l = J_2 mod p の値は、ブロックが取得されるレーンのインデックスを示します。最初のパス（r=0）と最初のスライス（sl=0）では、ブロックは現在のレーンから取得されます。"
    },
    {
      "indent": 3,
      "text": "The set W contains the indices that are referenced according to the following rules:",
      "ja": "セット W には、次の規則に従って参照されるインデックスが含まれます。"
    },
    {
      "indent": 3,
      "text": "1. If l is the current lane, then W includes the indices of all blocks in the last SL - 1 = 3 segments computed and finished, as well as the blocks computed in the current segment in the current pass excluding B[i][j-1].",
      "ja": "1. l が現在のレーンである場合、W には、計算されて終了した最後の SL - 1 = 3 セグメント内のすべてのブロックのインデックスと、B[i][j-1] を除く現在のパスの現在のセグメントで計算されたブロックが含まれます。"
    },
    {
      "indent": 3,
      "text": "2. If l is not the current lane, then W includes the indices of all blocks in the last SL - 1 = 3 segments computed and finished in lane l. If B[i][j] is the first block of a segment, then the very last index from W is excluded.",
      "ja": "2. lが現在のレーンでない場合、Wにはレーンlで計算され終了した最後のSL - 1 = 3セグメントのすべてのブロックのインデックスが含まれます。B[i][j]がセグメントの最初のブロックである場合、Wの最後のインデックスは除外されます。"
    },
    {
      "indent": 3,
      "text": "Then take a block from W with a nonuniform distribution over [0, |W|) using the following mapping:",
      "ja": "次に、次のマッピングを使用して、[0, |W|) 上の非均一分布を持つ W からブロックを取得します。"
    },
    {
      "indent": 3,
      "text": "J_1 -> |W|(1 - J_1^2 / 2^(64))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 12: Computing J1",
      "ja": "図12：コンピューティングJ1"
    },
    {
      "indent": 3,
      "text": "To avoid floating point computation, the following approximation is used:",
      "ja": "浮動小数点計算を回避するために、次の近似値が使用されます。"
    },
    {
      "indent": 3,
      "text": "x = J_1^2 / 2^(32)\ny = (|W| * x) / 2^(32)\nzz = |W| - 1 - y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 13: Computing J1, Part 2",
      "ja": "図13：コンピューティングJ1、その2"
    },
    {
      "indent": 3,
      "text": "Then take the zz-th index from W; it will be the z value for the reference block index [l][z].",
      "ja": "次にWからzz番目のインデックスを取得します。これが参照ブロックインデックス[l][z]のz値になります。"
    },
    {
      "indent": 0,
      "text": "3.5. Compression Function G",
      "section_title": true,
      "ja": "3.5. 圧縮関数G."
    },
    {
      "indent": 3,
      "text": "The compression function G is built upon the BLAKE2b-based transformation P. P operates on the 128-byte input, which can be viewed as eight 16-byte registers:",
      "ja": "圧縮関数 G は、BLAKE2b ベースの変換 P に基づいて構築されます。P は 128 バイトの入力に対して動作し、これは 8 つの 16 バイト レジスタとして見ることができます。"
    },
    {
      "indent": 3,
      "text": "P(A_0, A_1, ... ,A_7) = (B_0, B_1, ... ,B_7)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 14: Blake Round Function P",
      "ja": "図14：ブレイクラウンド関数P."
    },
    {
      "indent": 3,
      "text": "The compression function G(X, Y) operates on two 1024-byte blocks X and Y. It first computes R = X XOR Y. Then R is viewed as an 8x8 matrix of 16-byte registers R_0, R_1, ... , R_63. Then P is first applied to each row, and then to each column to get Z:",
      "ja": "圧縮関数 G(X, Y) は、2つの1024バイトブロック X と Y に対して作用します。まず、R = X XOR Y を計算します。次に、R は16バイトレジスタ R_0、R_1、…、R_63 からなる8x8行列とみなされます。次に、P を各行に適用し、次に各列に適用して Z を取得します。"
    },
    {
      "indent": 3,
      "text": "( Q_0,  Q_1,  Q_2, ... ,  Q_7) <- P( R_0,  R_1,  R_2, ... ,  R_7)\n( Q_8,  Q_9, Q_10, ... , Q_15) <- P( R_8,  R_9, R_10, ... , R_15)\n                              ...\n(Q_56, Q_57, Q_58, ... , Q_63) <- P(R_56, R_57, R_58, ... , R_63)\n( Z_0,  Z_8, Z_16, ... , Z_56) <- P( Q_0,  Q_8, Q_16, ... , Q_56)\n( Z_1,  Z_9, Z_17, ... , Z_57) <- P( Q_1,  Q_9, Q_17, ... , Q_57)\n                              ...\n( Z_7, Z_15, Z 23, ... , Z_63) <- P( Q_7, Q_15, Q_23, ... , Q_63)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 15: Core of Compression Function G",
      "ja": "図15：圧縮関数Gの中核"
    },
    {
      "indent": 3,
      "text": "Finally, G outputs Z XOR R:",
      "ja": "最後に、G は Z XOR R を出力します。"
    },
    {
      "indent": 3,
      "text": "G: (X, Y) -> R -> Q -> Z -> Z XOR R",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "+---+       +---+\n| X |       | Y |\n+---+       +---+\n  |           |\n  ---->XOR<----\n--------|\n|      \\ /\n|     +---+\n|     | R |\n|     +---+\n|       |\n|      \\ /\n|   P rowwise\n|       |\n|      \\ /\n|     +---+\n|     | Q |\n|     +---+\n|       |\n|      \\ /\n|  P columnwise\n|       |\n|      \\ /\n|     +---+\n|     | Z |\n|     +---+\n|       |\n|      \\ /\n------>XOR\n        |\n       \\ /",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 16: Argon2 Compression Function G",
      "ja": "図16：Argon2圧縮関数G"
    },
    {
      "indent": 0,
      "text": "3.6. Permutation P",
      "section_title": true,
      "ja": "3.6. 順列P"
    },
    {
      "indent": 3,
      "text": "Permutation P is based on the round function of BLAKE2b.  The eight\n16-byte inputs S_0, S_1, ... , S_7 are viewed as a 4x4 matrix of\n64-bit words, where S_i = (v_{2*i+1} || v_{2*i}):",
      "ja": "順列PはBLAKE2bのラウンド関数に基づいています。8つの16バイト入力S_0、S_1、…、S_7は、64ビットワードの4x4行列として表されます。ここで、S_i = (v_{2*i+1} || v_{2*i})です。"
    },
    {
      "indent": 8,
      "text": " v_0  v_1  v_2  v_3\n v_4  v_5  v_6  v_7\n v_8  v_9 v_10 v_11\nv_12 v_13 v_14 v_15",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 17: Matrix Element Labeling",
      "ja": "図17：行列要素のラベル付け"
    },
    {
      "indent": 3,
      "text": "It works as follows:",
      "ja": "それは次のように動作します。"
    },
    {
      "indent": 8,
      "text": "GB(v_0, v_4,  v_8, v_12)\nGB(v_1, v_5,  v_9, v_13)\nGB(v_2, v_6, v_10, v_14)\nGB(v_3, v_7, v_11, v_15)\n\nGB(v_0, v_5, v_10, v_15)\nGB(v_1, v_6, v_11, v_12)\nGB(v_2, v_7,  v_8, v_13)\nGB(v_3, v_4,  v_9, v_14)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 18: Feeding Matrix Elements to GB",
      "ja": "図18：マトリックス要素をGBに入力する"
    },
    {
      "indent": 3,
      "text": "GB(a, b, c, d) is defined as follows:",
      "ja": "GB(a, b, c, d)は次のように定義されます。"
    },
    {
      "indent": 11,
      "text": "a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)\nd = (d XOR a) >>> 32\nc = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)\nb = (b XOR c) >>> 24",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)\nd = (d XOR a) >>> 16\nc = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)\nb = (b XOR c) >>> 63",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 19: Details of GB",
      "ja": "図19：GBの詳細"
    },
    {
      "indent": 3,
      "text": "The modular additions in GB are combined with 64-bit multiplications. Multiplications are the only difference from the original BLAKE2b design. This choice is done to increase the circuit depth and thus the running time of ASIC implementations, while having roughly the same running time on CPUs thanks to parallelism and pipelining.",
      "ja": "GBにおけるモジュラー加算は、64ビット乗算と組み合わせられています。乗算は、オリジナルのBLAKE2b設計との唯一の違いです。この選択は、回路の深さを増やし、ASIC実装の実行時間を短縮する一方で、並列処理とパイプライン化によりCPUとほぼ同等の実行時間を実現するためです。"
    },
    {
      "indent": 0,
      "text": "4. Parameter Choice",
      "section_title": true,
      "ja": "4. パラメータの選択"
    },
    {
      "indent": 3,
      "text": "Argon2d is optimized for settings where the adversary does not get regular access to system memory or CPU, i.e., they cannot run side-channel attacks based on the timing information, nor can they recover the password much faster using garbage collection. These settings are more typical for backend servers and cryptocurrency minings. For practice, we suggest the following settings:",
      "ja": "Argon2dは、攻撃者がシステムメモリやCPUに定期的にアクセスできない環境向けに最適化されています。つまり、タイミング情報に基づくサイドチャネル攻撃を実行できず、ガベージコレクションを使用してパスワードを高速に復元することもできません。これらの設定は、バックエンドサーバーや暗号通貨マイニングでより一般的に使用されます。練習のために、以下の設定をお勧めします。"
    },
    {
      "indent": 3,
      "text": "* Cryptocurrency mining, which takes 0.1 seconds on a 2 GHz CPU using 1 core -- Argon2d with 2 lanes and 250 MB of RAM.",
      "ja": "* 2 GHz CPU、1 コア、2 レーン、250 MB の RAM を備えた Argon2d で 0.1 秒かかる暗号通貨マイニング。"
    },
    {
      "indent": 3,
      "text": "Argon2id is optimized for more realistic settings, where the adversary can possibly access the same machine, use its CPU, or mount cold-boot attacks. We suggest the following settings:",
      "ja": "Argon2idは、攻撃者が同じマシンにアクセスしたり、そのCPUを利用したり、コールドブート攻撃を仕掛けたりする可能性のある、より現実的な設定に最適化されています。以下の設定をお勧めします。"
    },
    {
      "indent": 3,
      "text": "* Backend server authentication, which takes 0.5 seconds on a 2 GHz CPU using 4 cores -- Argon2id with 8 lanes and 4 GiB of RAM.",
      "ja": "* バックエンド サーバーの認証。4 つのコアを使用する 2 GHz CPU、8 レーンと 4 GiB の RAM を備えた Argon2id では 0.5 秒かかります。"
    },
    {
      "indent": 3,
      "text": "* Key derivation for hard-drive encryption, which takes 3 seconds on a 2 GHz CPU using 2 cores -- Argon2id with 4 lanes and 6 GiB of RAM.",
      "ja": "* ハードドライブ暗号化のキー導出。2 GHz CPU、2 コア、4 レーン、6 GiB の RAM を備えた Argon2id で 3 秒かかります。"
    },
    {
      "indent": 3,
      "text": "* Frontend server authentication, which takes 0.5 seconds on a 2 GHz CPU using 2 cores -- Argon2id with 4 lanes and 1 GiB of RAM.",
      "ja": "* フロントエンド サーバー認証。2 GHz CPU、2 コア、4 レーン、1 GiB の RAM を備えた Argon2id で 0.5 秒かかります。"
    },
    {
      "indent": 3,
      "text": "We recommend the following procedure to select the type and the parameters for practical use of Argon2.",
      "ja": "ARGON2の実用化のためのタイプとパラメータを選択するには、次の手順を推奨します。"
    },
    {
      "indent": 3,
      "text": "1. If a uniformly safe option that is not tailored to your application or hardware is acceptable, select Argon2id with t=1 iteration, p=4 lanes, m=2^(21) (2 GiB of RAM), 128-bit salt, and 256-bit tag size. This is the FIRST RECOMMENDED option.",
      "ja": "1. アプリケーションやハードウェアに合わせて調整されていない、均一に安全なオプションが許容される場合は、t=1イテレーション、p=4レーン、m=2^(21)（RAM 2GiB）、128ビットソルト、256ビットタグサイズのArgon2idを選択してください。これは第一推奨オプションです。"
    },
    {
      "indent": 3,
      "text": "2. If much less memory is available, a uniformly safe option is Argon2id with t=3 iterations, p=4 lanes, m=2^(16) (64 MiB of RAM), 128-bit salt, and 256-bit tag size. This is the SECOND RECOMMENDED option.",
      "ja": "2. 利用可能なメモリが大幅に少ない場合、均一に安全な選択肢として、t=3回の反復、p=4レーン、m=2^(16)（RAM 64MiB）、128ビットソルト、256ビットタグサイズでArgon2idを実行することが挙げられます。これは2番目に推奨される選択肢です。"
    },
    {
      "indent": 3,
      "text": "3. Otherwise, start with selecting the type y. If you do not know the difference between the types or you consider side-channel attacks to be a viable threat, choose Argon2id.",
      "ja": "3. それ以外の場合は、まずタイプyを選択してください。タイプの違いがわからない場合、またはサイドチャネル攻撃が現実的な脅威であると考えられる場合は、Argon2idを選択してください。"
    },
    {
      "indent": 3,
      "text": "4. Select p=4 lanes.",
      "ja": "4. p=4レーンを選択します。"
    },
    {
      "indent": 3,
      "text": "5. Figure out the maximum amount of memory that each call can afford and translate it to the parameter m.",
      "ja": "5. 各呼び出しが許容できるメモリの最大量を計算し、それをパラメーター m に変換します。"
    },
    {
      "indent": 3,
      "text": "6. Figure out the maximum amount of time (in seconds) that each call can afford.",
      "ja": "6. 各呼び出しに許容される最大時間 (秒単位) を計算します。"
    },
    {
      "indent": 3,
      "text": "7. Select the salt length. A length of 128 bits is sufficient for all applications but can be reduced to 64 bits in the case of space constraints.",
      "ja": "7. ソルトの長さを選択します。128ビットの長さはすべてのアプリケーションで十分ですが、スペースの制約がある場合は64ビットに短縮できます。"
    },
    {
      "indent": 3,
      "text": "8. Select the tag length. A length of 128 bits is sufficient for most applications, including key derivation. If longer keys are needed, select longer tags.",
      "ja": "8. タグの長さを選択してください。128ビットの長さは、鍵導出を含むほとんどのアプリケーションでは十分です。より長い鍵が必要な場合は、より長いタグを選択してください。"
    },
    {
      "indent": 3,
      "text": "9. If side-channel attacks are a viable threat or if you're uncertain, enable the memory-wiping option in the library call.",
      "ja": "9. サイドチャネル攻撃が現実的な脅威である場合、または不確かな場合は、ライブラリ呼び出しでメモリ消去オプションを有効にします。"
    },
    {
      "indent": 3,
      "text": "10. Run the scheme of type y, memory m, and p lanes using a different number of passes t. Figure out the maximum t such that the running time does not exceed the affordable time. If it even exceeds for t = 1, reduce m accordingly.",
      "ja": "10. 型y、メモリm、プレーンpのスキームを、パス数tを変えて実行します。実行時間が許容時間を超えないようなtの最大値を求めます。t = 1でも許容時間を超える場合は、mをそれに応じて減らしてください。"
    },
    {
      "indent": 3,
      "text": "11. Use Argon2 with determined values m, p, and t.",
      "ja": "11. 決定された値 m、p、および t を持つ Argon2 を使用します。"
    },
    {
      "indent": 0,
      "text": "5. Test Vectors",
      "section_title": true,
      "ja": "5. テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section contains test vectors for Argon2.",
      "ja": "このセクションにはArgon2のテストベクトルが含まれています。"
    },
    {
      "indent": 0,
      "text": "5.1. Argon2d Test Vectors",
      "section_title": true,
      "ja": "5.1. Argon2dテストベクトル"
    },
    {
      "indent": 3,
      "text": "We provide test vectors with complete outputs (tags). For the convenience of developers, we also provide some interim variables -- concretely, the first and last memory blocks of each pass.",
      "ja": "完全な出力（タグ）を持つテストベクトルを提供します。開発者の利便性を考慮し、各パスの最初と最後のメモリブロックといった中間変数も提供します。"
    },
    {
      "indent": 3,
      "text": "=======================================\nArgon2d version number 19\n=======================================\nMemory: 32 KiB\nPasses: 3\nParallelism: 4 lanes\nTag length: 32 bytes\nPassword[32]: 01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\nSalt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02\nSecret[8]: 03 03 03 03 03 03 03 03\nAssociated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04\nPre-hashing digest: b8 81 97 91 a0 35 96 60\n                    bb 77 09 c8 5f a4 8f 04\n                    d5 d8 2c 05 c5 f2 15 cc\n                    db 88 54 91 71 7c f7 57\n                    08 2c 28 b9 51 be 38 14\n                    10 b5 fc 2e b7 27 40 33\n                    b9 fd c7 ae 67 2b ca ac\n                    5d 17 90 97 a4 af 31 09\n\n After pass 0:\nBlock 0000 [  0]: db2fea6b2c6f5c8a\nBlock 0000 [  1]: 719413be00f82634\nBlock 0000 [  2]: a1e3f6dd42aa25cc\nBlock 0000 [  3]: 3ea8efd4d55ac0d1\n...\nBlock 0031 [124]: 28d17914aea9734c\nBlock 0031 [125]: 6a4622176522e398\nBlock 0031 [126]: 951aa08aeecb2c05\nBlock 0031 [127]: 6a6c49d2cb75d5b6\n\n After pass 1:\nBlock 0000 [  0]: d3801200410f8c0d\nBlock 0000 [  1]: 0bf9e8a6e442ba6d\nBlock 0000 [  2]: e2ca92fe9c541fcc\nBlock 0000 [  3]: 6269fe6db177a388\n...\nBlock 0031 [124]: 9eacfcfbdb3ce0fc\nBlock 0031 [125]: 07dedaeb0aee71ac\nBlock 0031 [126]: 074435fad91548f4\nBlock 0031 [127]: 2dbfff23f31b5883\n\n After pass 2:\nBlock 0000 [  0]: 5f047b575c5ff4d2\nBlock 0000 [  1]: f06985dbf11c91a8\nBlock 0000 [  2]: 89efb2759f9a8964\nBlock 0000 [  3]: 7486a73f62f9b142\n...\nBlock 0031 [124]: 57cfb9d20479da49\nBlock 0031 [125]: 4099654bc6607f69\nBlock 0031 [126]: f142a1126075a5c8\nBlock 0031 [127]: c341b3ca45c10da5\nTag: 51 2b 39 1b 6f 11 62 97\n     53 71 d3 09 19 73 42 94\n     f8 68 e3 be 39 84 f3 c1\n     a1 3a 4d b9 fa be 4a cb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2. Argon2i Test Vectors",
      "section_title": true,
      "ja": "5.2. Argon2iテストベクトル"
    },
    {
      "indent": 3,
      "text": "=======================================\nArgon2i version number 19\n=======================================\nMemory: 32 KiB\nPasses: 3\nParallelism: 4 lanes\nTag length: 32 bytes\nPassword[32]: 01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\nSalt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02\nSecret[8]: 03 03 03 03 03 03 03 03\nAssociated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04\nPre-hashing digest: c4 60 65 81 52 76 a0 b3\n                    e7 31 73 1c 90 2f 1f d8\n                    0c f7 76 90 7f bb 7b 6a\n                    5c a7 2e 7b 56 01 1f ee\n                    ca 44 6c 86 dd 75 b9 46\n                    9a 5e 68 79 de c4 b7 2d\n                    08 63 fb 93 9b 98 2e 5f\n                    39 7c c7 d1 64 fd da a9\n\n After pass 0:\nBlock 0000 [  0]: f8f9e84545db08f6\nBlock 0000 [  1]: 9b073a5c87aa2d97\nBlock 0000 [  2]: d1e868d75ca8d8e4\nBlock 0000 [  3]: 349634174e1aebcc\n...\nBlock 0031 [124]: 975f596583745e30\nBlock 0031 [125]: e349bdd7edeb3092\nBlock 0031 [126]: b751a689b7a83659\nBlock 0031 [127]: c570f2ab2a86cf00\n\n After pass 1:\nBlock 0000 [  0]: b2e4ddfcf76dc85a\nBlock 0000 [  1]: 4ffd0626c89a2327\nBlock 0000 [  2]: 4af1440fff212980\nBlock 0000 [  3]: 1e77299c7408505b\n...\nBlock 0031 [124]: e4274fd675d1e1d6\nBlock 0031 [125]: 903fffb7c4a14c98\nBlock 0031 [126]: 7e5db55def471966\nBlock 0031 [127]: 421b3c6e9555b79d\n\n After pass 2:\nBlock 0000 [  0]: af2a8bd8482c2f11\nBlock 0000 [  1]: 785442294fa55e6d\nBlock 0000 [  2]: 9256a768529a7f96\nBlock 0000 [  3]: 25a1c1f5bb953766\n...\nBlock 0031 [124]: 68cf72fccc7112b9\nBlock 0031 [125]: 91e8c6f8bb0ad70d\nBlock 0031 [126]: 4f59c8bd65cbb765\nBlock 0031 [127]: 71e436f035f30ed0\nTag: c8 14 d9 d1 dc 7f 37 aa\n     13 f0 d7 7f 24 94 bd a1\n     c8 de 6b 01 6d d3 88 d2\n     99 52 a4 c4 67 2b 6c e8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3. Argon2id Test Vectors",
      "section_title": true,
      "ja": "5.3. Argon2idテストベクトル"
    },
    {
      "indent": 3,
      "text": "=======================================\nArgon2id version number 19\n=======================================\nMemory: 32 KiB, Passes: 3,\nParallelism: 4 lanes, Tag length: 32 bytes\nPassword[32]: 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01\n01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01\nSalt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02\nSecret[8]: 03 03 03 03 03 03 03 03\nAssociated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04\nPre-hashing digest: 28 89 de 48 7e b4 2a e5 00 c0 00 7e d9 25 2f\n 10 69 ea de c4 0d 57 65 b4 85 de 6d c2 43 7a 67 b8 54 6a 2f 0a\n cc 1a 08 82 db 8f cf 74 71 4b 47 2e 94 df 42 1a 5d a1 11 2f fa\n 11 43 43 70 a1 e9 97\n\n After pass 0:\nBlock 0000 [  0]: 6b2e09f10671bd43\nBlock 0000 [  1]: f69f5c27918a21be\nBlock 0000 [  2]: dea7810ea41290e1\nBlock 0000 [  3]: 6787f7171870f893\n...\nBlock 0031 [124]: 377fa81666dc7f2b\nBlock 0031 [125]: 50e586398a9c39c8\nBlock 0031 [126]: 6f732732a550924a\nBlock 0031 [127]: 81f88b28683ea8e5\n\n After pass 1:\nBlock 0000 [  0]: 3653ec9d01583df9\nBlock 0000 [  1]: 69ef53a72d1e1fd3\nBlock 0000 [  2]: 35635631744ab54f\nBlock 0000 [  3]: 599512e96a37ab6e\n...\nBlock 0031 [124]: 4d4b435cea35caa6\nBlock 0031 [125]: c582210d99ad1359\nBlock 0031 [126]: d087971b36fd6d77\nBlock 0031 [127]: a55222a93754c692\n\n After pass 2:\nBlock 0000 [  0]: 942363968ce597a4\nBlock 0000 [  1]: a22448c0bdad5760\nBlock 0000 [  2]: a5f80662b6fa8748\nBlock 0000 [  3]: a0f9b9ce392f719f\n...\nBlock 0031 [124]: d723359b485f509b\nBlock 0031 [125]: cb78824f42375111\nBlock 0031 [126]: 35bc8cc6e83b1875\nBlock 0031 [127]: 0b012846a40f346a\nTag: 0d 64 0d f5 8d 78 76 6c 08 c0 37 a3 4a 8b 53 c9 d0\n 1e f0 45 2d 75 b6 5e b5 25 20 e9 6b 01 e6 59",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "この文書にはIANAの行動がありません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Security as a Hash Function and KDF",
      "section_title": true,
      "ja": "7.1. ハッシュ関数とKDFとしてのセキュリティ"
    },
    {
      "indent": 3,
      "text": "The collision and preimage resistance levels of Argon2 are equivalent to those of the underlying BLAKE2b hash function. To produce a collision, 2^(256) inputs are needed. To find a preimage, 2^(512) inputs must be tried.",
      "ja": "Argon2の衝突およびプリーマージ抵抗レベルは、基礎となるBlake2Bハッシュ関数と同等である。衝突を生み出すには、2^(256)入力が必要です。プリ画像を見つけるには、2^(512)入力を試す必要があります。"
    },
    {
      "indent": 3,
      "text": "The KDF security is determined by the key length and the size of the internal state of hash function H'. To distinguish the output of the keyed Argon2 from random, a minimum of (2^(128),2^length(K)) calls to BLAKE2b are needed.",
      "ja": "KDFセキュリティは、キー長とハッシュ関数H'の内部状態のサイズによって決まります。キー付きArgon2の出力をランダムに区別するために、Blake2bへの最小値（2^(128)、2^length(k)）呼び出しが必要です。"
    },
    {
      "indent": 0,
      "text": "7.2. Security against Time-Space Trade-off Attacks",
      "section_title": true,
      "ja": "7.2. タイムスペーストレードオフ攻撃に対するセキュリティ"
    },
    {
      "indent": 3,
      "text": "Time-space trade-offs allow computing a memory-hard function storing fewer memory blocks at the cost of more calls to the internal compression function. The advantage of trade-off attacks is measured in the reduction factor to the time-area product, where memory and extra compression function cores contribute to the area and time is increased to accommodate the recomputation of missed blocks. A high reduction factor may potentially speed up the preimage search.",
      "ja": "時間と空間のトレードオフにより、メモリに負荷のかかる関数を、内部圧縮関数の呼び出し回数を増やすことで、より少ないメモリブロックで計算することが可能になります。トレードオフ攻撃の利点は、時間と面積の積に対する削減係数で測定されます。メモリと追加の圧縮関数コアが面積に寄与し、失われたブロックの再計算に対応するために時間が長くなります。削減係数が高いと、原像探索が高速化される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The best-known attack on the 1-pass and 2-pass Argon2i is the low-storage attack described in [CBS16], which reduces the time-area product (using the peak memory value) by the factor of 5. The best attack on Argon2i with 3 passes or more is described in [AB16], with the reduction factor being a function of memory size and the number of passes (e.g., for 1 gibibyte of memory, a reduction factor of 3 for 3 passes, 2.5 for 4 passes, 2 for 6 passes). The reduction factor grows by about 0.5 with every doubling of the memory size. To completely prevent time-space trade-offs from [AB16], the number of passes MUST exceed the binary logarithm of memory minus 26. Asymptotically, the best attack on 1-pass Argon2i is given in [BZ17], with maximal advantage of the adversary upper bounded by O(m^(0.233)), where m is the number of blocks. This attack is also asymptotically optimal as [BZ17] also proves the upper bound on any attack is O(m^(0.25)).",
      "ja": "1パスおよび2パスのArgon2iに対する最もよく知られた攻撃は、[CBS16]で説明されている低ストレージ攻撃であり、これは（ピークメモリ値を使用して）時間面積積を5分の1に削減します。3パス以上のArgon2iに対する最良の攻撃は[AB16]で説明されており、削減係数はメモリサイズとパス数の関数です（例えば、1ギガバイトのメモリの場合、3パスで削減係数は3、4パスで2.5、6パスで2）。削減係数は、メモリサイズが2倍になるごとに約0.5ずつ増加します。 [AB16]による時間と空間のトレードオフを完全に防ぐには、パス数はメモリの2進対数から26を引いた値を超えなければならない。漸近的に、1パスArgon2iに対する最良の攻撃は[BZ17]で示されており、攻撃者の最大優位性の上限はO(m^(0.233))である（mはブロック数）。この攻撃は漸近的に最適であり、[BZ17]ではあらゆる攻撃の上限がO(m^(0.25))であることが証明されている。"
    },
    {
      "indent": 3,
      "text": "The best trade-off attack on t-pass Argon2d is the ranking trade-off attack, which reduces the time-area product by the factor of 1.33.",
      "ja": "T-PASS ARGON2Dに対する最良のトレードオフ攻撃はランキングのトレードオフ攻撃です。"
    },
    {
      "indent": 3,
      "text": "The best attack on Argon2id can be obtained by complementing the best attack on the 1-pass Argon2i with the best attack on a multi-pass Argon2d. Thus, the best trade-off attack on 1-pass Argon2id is the combined low-storage attack (for the first half of the memory) and the ranking attack (for the second half), which generate the factor of about 2.1. The best trade-off attack on t-pass Argon2id is the ranking trade-off attack, which reduces the time-area product by the factor of 1.33.",
      "ja": "Argon2idに対する最良の攻撃は、1パスArgon2iに対する最良の攻撃とマルチパスArgon2dに対する最良の攻撃を補完することで得られます。したがって、1パスArgon2idに対する最良のトレードオフ攻撃は、ローストレージ攻撃（メモリの前半部分）とランキング攻撃（メモリの後半部分）を組み合わせたものであり、これにより約2.1倍の係数が生成されます。tパスArgon2idに対する最良のトレードオフ攻撃はランキングトレードオフ攻撃であり、これにより時間面積積が1.33倍に減少します。"
    },
    {
      "indent": 0,
      "text": "7.3. Security for Time-Bounded Defenders",
      "section_title": true,
      "ja": "7.3. 時間制限のある防御者のためのセキュリティ"
    },
    {
      "indent": 3,
      "text": "A bottleneck in a system employing the password hashing function is often the function latency rather than memory costs. A rational defender would then maximize the brute-force costs for the attacker equipped with a list of hashes, salts, and timing information for fixed computing time on the defender's machine. The attack cost estimates from [AB16] imply that for Argon2i, 3 passes is almost optimal for most reasonable memory sizes; for Argon2d and Argon2id, 1 pass maximizes the attack costs for the constant defender time.",
      "ja": "パスワードハッシュ関数を使用するシステム内のボトルネックは、メモリコストではなく関数の待ち時間です。その後、Rational Defenderは、ディフェンダーのマシン上の固定コンピューティング時間のためのハッシュ、ソルト、およびタイミング情報のリストを備えた攻撃者のためのブルートフォースコストを最大化するでしょう。[AB16]からの攻撃コスト見積もりは、Argon2iの場合、3パスが最も合理的なメモリサイズにはほぼ最適です。Argon2dとArgon2idの場合、1パスは定数の防御時間の攻撃コストを最大化します。"
    },
    {
      "indent": 0,
      "text": "7.4. Recommendations",
      "section_title": true,
      "ja": "7.4. 推奨事項"
    },
    {
      "indent": 3,
      "text": "The Argon2id variant with t=1 and 2 GiB memory is the FIRST RECOMMENDED option and is suggested as a default setting for all environments. This setting is secure against side-channel attacks and maximizes adversarial costs on dedicated brute-force hardware. The Argon2id variant with t=3 and 64 MiB memory is the SECOND RECOMMENDED option and is suggested as a default setting for memory-constrained environments.",
      "ja": "T = 1および2 GIBメモリを持つArgon2idバリアントは、最初の推奨オプションであり、すべての環境のデフォルト設定として提案されています。この設定は、サイドチャネル攻撃に対して安全であり、専用のブルートフォースハードウェア上の敵対的コストを最大化します。T = 3と64 MIBメモリを持つArgon2idバリアントは、2番目の推奨オプションです。メモリ制約付き環境のデフォルト設定として提案されています。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[BLAKE2] Saarinen, M-J., Ed. and J-P. Aumasson, \"The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)\", RFC 7693, DOI 10.17487/RFC7693, November 2015, <https://www.rfc-editor.org/info/rfc7693>.",
      "ja": "[Blake2] Saarinen、M-J。、ED。そしてJ-P。Aumasson、「Blake2暗号化ハッシュとメッセージ認証コード（Mac）」、RFC 7693、DOI 10.17487 / RFC7693、2015年11月、<https://www.rfc-editor.org/info/rfc7693>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AB15] Biryukov, A. and D. Khovratovich, \"Tradeoff Cryptanalysis of Memory-Hard Functions\", ASIACRYPT 2015, DOI 10.1007/978-3-662-48800-3_26, December 2015, <https://eprint.iacr.org/2015/227.pdf>.",
      "ja": "[AB15] Biryukov、A.およびD.Khovratovich、「メモリ - ハード機能のトレードオフクリプターシス」、Asiacrypt 2015、DOI 10.1007 / 978-3-662-48800-3_26、2015年12月、<https://eprint.iacr.ORG/2015/227.pdf>。"
    },
    {
      "indent": 3,
      "text": "[AB16] Alwen, J. and J. Blocki, \"Efficiently Computing Data-Independent Memory-Hard Functions\", CRYPTO 2016, DOI 10.1007/978-3-662-53008-5_9, March 2016, <https://eprint.iacr.org/2016/115.pdf>.",
      "ja": "[AB16] Alwen、J.およびJ.Blocki、「データ独立メモリハード機能を効率的に計算する」、Crypto 2016、DOI 10.1007 / 978-3-662-53008-5_9、2016年3月、<https://eprint.iacr.org/2016/115.pdf>。"
    },
    {
      "indent": 3,
      "text": "[ARGON2] Biryukov, A., Dinu, D., and D. Khovratovich, \"Argon2: the memory-hard function for password hashing and other applications\", March 2017, <https://www.cryptolux.org/images/0/0d/Argon2.pdf>.",
      "ja": "[Argon2] Biryukov、A.、Dinu、D.、D.Khovratovich、 \"Argon2：パスワードハッシュおよびその他のアプリケーションのメモリハード機能\"、2017年3月、<https://www.cryptolux.org/images/0/0D/ARGON2.PDF>。"
    },
    {
      "indent": 3,
      "text": "[ARGON2ESP] Biryukov, A., Dinu, D., and D. Khovratovich, \"Argon2: New Generation of Memory-Hard Functions for Password Hashing and Other Applications\", Euro SnP 2016, DOI 10.1109/EuroSP.2016.31, March 2016, <https://www.cryptolux.org/images/d/d0/Argon2ESP.pdf>.",
      "ja": "[Argon2esp] Biryukov、A.、Dinu、D.、D.Khovratovich、「Argon2：パスワードハッシュおよびその他のアプリケーションの新世代のメモリハード機能」、ユーロSNP 2016、DOI 10.1109 / Eurosp.2016.31、2016年3月、<https://www.cryptolux.org/images/d/d0/argon2esp.pdf>。"
    },
    {
      "indent": 3,
      "text": "[BZ17] Blocki, J. and S. Zhou, \"On the Depth-Robustness and Cumulative Pebbling Cost of Argon2i\", TCC 2017, DOI 10.1007/978-3-319-70500-2_15, May 2017, <https://eprint.iacr.org/2017/442.pdf>.",
      "ja": "[BZ17] BZ17、「Argon2iの奥深くに疎足費と累積恵みの費用について」、TCC 2017、DOI 10.1007 / 978-3-319-70500-2_15、2017年5月、<https://eprint.iacr.org/2017/442.pdf>。"
    },
    {
      "indent": 3,
      "text": "[CBS16] Boneh, D., Corrigan-Gibbs, H., and S. Schechter, \"Balloon Hashing: A Memory-Hard Function Providing Provable Protection Against Sequential Attacks\", ASIACRYPT 2016, DOI 10.1007/978-3-662-53887-6_8, May 2017, <https://eprint.iacr.org/2016/027.pdf>.",
      "ja": "[CBS16] Boneh、D.、Corrigan-Gibbs、H.、およびS.Schechter、「Balloon Hashing：逐次攻撃に対する証明された保護を提供するメモリハード機能」、Asiacrypt 2016、DOI 10.1007 / 978-3-662-53887-6_8、2017年5月、<https://eprint.iacr.org/2016/027.pdf>。"
    },
    {
      "indent": 3,
      "text": "[HARD] Alwen, J. and V. Serbinenko, \"High Parallel Complexity Graphs and Memory-Hard Functions\", STOC '15, DOI 10.1145/2746539.2746622, June 2015, <https://eprint.iacr.org/2014/238.pdf>.",
      "ja": "[ハード] Alwen、J.およびV.Serbinenko、「高並列複雑度グラフおよびメモリハード機能」、STOC '15、DOI 10.1145 / 2746539.2746622、<https://eprint.iacr.org/2014/238.pdf>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We greatly thank the following individuals who helped in preparing and reviewing this document: Jean-Philippe Aumasson, Samuel Neves, Joel Alwen, Jeremiah Blocki, Bill Cox, Arnold Reinhold, Solar Designer, Russ Housley, Stanislav Smyshlyaev, Kenny Paterson, Alexey Melnikov, and Gwynne Raskind.",
      "ja": "このドキュメントの準備とレビューに協力してくださった以下の方々に深く感謝いたします: Jean-Philippe Aumasson、Samuel Neves、Joel Alwen、Jeremiah Blocki、Bill Cox、Arnold Reinhold、Solar Designer、Russ Housley、Stanislav Smyshlyaev、Kenny Paterson、Alexey Melnikov、および Gwynne Raskind。"
    },
    {
      "indent": 3,
      "text": "The work described in this document was done before Daniel Dinu joined Intel, while he was at the University of Luxembourg.",
      "ja": "この文書で説明されている作品は、Daniel DinuがIntelに加わる前に行われましたが、彼はルクセンブルク大学にいました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Alex Biryukov University of Luxembourg",
      "ja": "ルクセンブルク大学アレックスビルイコフ大学"
    },
    {
      "indent": 3,
      "text": "Email: alex.biryukov@uni.lu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Daniel Dinu University of Luxembourg",
      "ja": "Daniel Dinuルクセンブルク大学"
    },
    {
      "indent": 3,
      "text": "Email: daniel.dinu@intel.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dmitry Khovratovich ABDK Consulting",
      "ja": "Dmitry Khovratovich ABDKコンサルティング"
    },
    {
      "indent": 3,
      "text": "Email: khovratovich@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simon Josefsson SJD AB",
      "ja": "Simon Josefsson SJD AB."
    },
    {
      "indent": 3,
      "text": "Email: simon@josefsson.org\nURI:   http://josefsson.org/",
      "raw": true,
      "ja": ""
    }
  ]
}