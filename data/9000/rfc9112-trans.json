{
  "title": {
    "text": "RFC 9112 - HTTP/1.1 (RFC 9112)",
    "ja": "RFC 9112 - HTTP/1.1（RFC 9112）"
  },
  "number": 9112,
  "created_at": "2022-06-10 03:00:02.005502+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                  R. Fielding, Ed.\nRequest for Comments: 9112                                         Adobe\nSTD: 99                                               M. Nottingham, Ed.\nObsoletes: 7230                                                   Fastly\nCategory: Standards Track                                J. Reschke, Ed.\nISSN: 2070-1721                                               greenbytes\n                                                               June 2022",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 32,
      "text": "HTTP/1.1",
      "ja": "HTTP/1.1"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document specifies the HTTP/1.1 message syntax, message parsing, connection management, and related security concerns.",
      "ja": "Hypertext Transfer Protocol（HTTP）は、分散型、協調型、ハイパーテキスト情報システムのためのステートレスなアプリケーションレベルプロトコルです。このドキュメントは、HTTP/1.1メッセージの構文、メッセージの解析、接続管理、および関連するセキュリティ上の懸念を規定します。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes portions of RFC 7230.",
      "ja": "このドキュメントは、RFC 7230の一部を置き換えます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の成果物です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、Internet Engineering Steering Group（IESG）によって公開が承認されています。インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9112.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9112 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright (c) 2022 IETF Trust および文書の著者として特定された人物。All rights reserved."
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78および、このドキュメントの発行日に有効なIETFドキュメントに関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、トラスト法的規定のセクション4.eで説明されている修正BSDライセンスのテキストを含める必要があり、修正BSDライセンスで説明されているように保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開可能にされたIETFドキュメントまたはIETFへの寄稿からの資料が含まれている場合があります。この資料の一部の著作権を管理する人物は、IETF標準化プロセスの外でそのような資料の変更を許可する権利をIETFトラストに付与していない可能性があります。そのような資料の著作権を管理する人物から適切なライセンスを取得しない限り、このドキュメントはIETF標準化プロセスの外で変更してはならず、RFCとして公開するためのフォーマットや英語以外の言語への翻訳を除き、IETF標準化プロセスの外で派生著作物を作成してはなりません。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Notation\n  1.2.  Syntax Notation\n2.  Message\n  2.1.  Message Format\n  2.2.  Message Parsing\n  2.3.  HTTP Version\n3.  Request Line\n  3.1.  Method\n  3.2.  Request Target\n    3.2.1.  origin-form\n    3.2.2.  absolute-form\n    3.2.3.  authority-form\n    3.2.4.  asterisk-form\n  3.3.  Reconstructing the Target URI\n4.  Status Line\n5.  Field Syntax\n  5.1.  Field Line Parsing\n  5.2.  Obsolete Line Folding\n6.  Message Body\n  6.1.  Transfer-Encoding\n  6.2.  Content-Length\n  6.3.  Message Body Length\n7.  Transfer Codings\n  7.1.  Chunked Transfer Coding\n    7.1.1.  Chunk Extensions\n    7.1.2.  Chunked Trailer Section\n    7.1.3.  Decoding Chunked\n  7.2.  Transfer Codings for Compression\n  7.3.  Transfer Coding Registry\n  7.4.  Negotiating Transfer Codings\n8.  Handling Incomplete Messages\n9.  Connection Management\n  9.1.  Establishment\n  9.2.  Associating a Response to a Request\n  9.3.  Persistence\n    9.3.1.  Retrying Requests\n    9.3.2.  Pipelining\n  9.4.  Concurrency\n  9.5.  Failures and Timeouts\n  9.6.  Tear-down\n  9.7.  TLS Connection Initiation\n  9.8.  TLS Connection Closure\n10. Enclosing Messages as Data\n  10.1.  Media Type message/http\n  10.2.  Media Type application/http\n11. Security Considerations\n  11.1.  Response Splitting\n  11.2.  Request Smuggling\n  11.3.  Message Integrity\n  11.4.  Message Confidentiality\n12. IANA Considerations\n  12.1.  Field Name Registration\n  12.2.  Media Type Registration\n  12.3.  Transfer Coding Registration\n  12.4.  ALPN Protocol ID Registration\n13. References\n  13.1.  Normative References\n  13.2.  Informative References\nAppendix A.  Collected ABNF\nAppendix B.  Differences between HTTP and MIME\n  B.1.  MIME-Version\n  B.2.  Conversion to Canonical Form\n  B.3.  Conversion of Date Formats\n  B.4.  Conversion of Content-Encoding\n  B.5.  Conversion of Content-Transfer-Encoding\n  B.6.  MHTML and Line Length Limitations\nAppendix C.  Changes from Previous RFCs\n  C.1.  Changes from HTTP/0.9\n  C.2.  Changes from HTTP/1.0\n    C.2.1.  Multihomed Web Servers\n    C.2.2.  Keep-Alive Connections\n    C.2.3.  Introduction of Transfer-Encoding\n  C.3.  Changes from RFC 7230\nAcknowledgements\nIndex\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive messages for flexible interaction with network-based hypertext information systems. HTTP/1.1 is defined by:",
      "ja": "Hypertext Transfer Protocol（HTTP）は、ネットワークベースのハイパーテキスト情報システムとの柔軟な対話のために、拡張可能なセマンティクスと自己記述的なメッセージを使用する、ステートレスなアプリケーションレベルのリクエスト/レスポンスプロトコルです。HTTP/1.1は以下によって定義されます。"
    },
    {
      "indent": 3,
      "text": "* This document",
      "ja": "* このドキュメント"
    },
    {
      "indent": 3,
      "text": "* \"HTTP Semantics\" [HTTP]",
      "ja": "* 「HTTPセマンティクス」[HTTP]"
    },
    {
      "indent": 3,
      "text": "* \"HTTP Caching\" [CACHING]",
      "ja": "* 「HTTPキャッシュ」[CACHING]"
    },
    {
      "indent": 3,
      "text": "This document specifies how HTTP semantics are conveyed using the HTTP/1.1 message syntax, framing, and connection management mechanisms. Its goal is to define the complete set of requirements for HTTP/1.1 message parsers and message-forwarding intermediaries.",
      "ja": "このドキュメントは、HTTP/1.1メッセージの構文、フレーミング、および接続管理メカニズムを使用してHTTPセマンティクスがどのように伝達されるかを規定します。その目標は、HTTP/1.1メッセージパーサーとメッセージ転送を行う仲介者に対する要件の完全なセットを定義することです。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes the portions of RFC 7230 related to HTTP/1.1 messaging and connection management, with the changes being summarized in Appendix C.3. The other parts of RFC 7230 are obsoleted by \"HTTP Semantics\" [HTTP].",
      "ja": "このドキュメントは、HTTP/1.1メッセージングと接続管理に関連するRFC 7230の部分を置き換えるものであり、変更点は付録C.3に要約されています。RFC 7230の他の部分は、「HTTP Semantics」[HTTP]によって置き換えられます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Notation",
      "section_title": true,
      "ja": "1.1. 要件表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", および \"OPTIONAL\" は、ここに示すようにすべて大文字で表示される場合にのみ、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Conformance criteria and considerations regarding error handling are defined in Section 2 of [HTTP].",
      "ja": "エラー処理に関する適合基準と考慮事項は、[HTTP]のセクション2で定義されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Syntax Notation",
      "section_title": true,
      "ja": "1.2. 構文表記"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], extended with the notation for case-sensitivity in strings defined in [RFC7405].",
      "ja": "この仕様では、[RFC5234]のAugmented Backus-Naur Form（ABNF）表記を使用し、[RFC7405]で定義された文字列の大文字小文字の区別のための表記で拡張しています。"
    },
    {
      "indent": 3,
      "text": "It also uses a list extension, defined in Section 5.6.1 of [HTTP], that allows for compact definition of comma-separated lists using a \"#\" operator (similar to how the \"*\" operator indicates repetition). Appendix A shows the collected grammar with all list operators expanded to standard ABNF notation.",
      "ja": "また、[HTTP]のセクション5.6.1で定義されているリスト拡張を使用しており、「#」演算子を使用してカンマ区切りリストをコンパクトに定義できます（「*」演算子が繰り返しを示すのと同様）。付録Aは、すべてのリスト演算子が標準のABNF表記に展開された収集済みの文法を示しています。"
    },
    {
      "indent": 3,
      "text": "As a convention, ABNF rule names prefixed with \"obs-\" denote obsolete grammar rules that appear for historical reasons.",
      "ja": "慣習として、「obs-」という接頭辞が付いたABNFルール名は、歴史的な理由で存在する廃止された文法ルールを示します。"
    },
    {
      "indent": 3,
      "text": "The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).",
      "ja": "[RFC5234]の付録B.1で定義されているように、次のコアルールが参照により含まれます：ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（制御文字）、DIGIT（10進数 0-9）、DQUOTE（二重引用符）、HEXDIG（16進数 0-9/A-F/a-f）、HTAB（水平タブ）、LF（ラインフィード）、OCTET（任意の8ビットデータシーケンス）、SP（スペース）、およびVCHAR（任意の表示可能な[USASCII]文字）。"
    },
    {
      "indent": 3,
      "text": "The rules below are defined in [HTTP]:",
      "ja": "以下のルールは[HTTP]で定義されています。"
    },
    {
      "indent": 5,
      "text": "BWS           = <BWS, see [HTTP], Section 5.6.3>\nOWS           = <OWS, see [HTTP], Section 5.6.3>\nRWS           = <RWS, see [HTTP], Section 5.6.3>\nabsolute-path = <absolute-path, see [HTTP], Section 4.1>\nfield-name    = <field-name, see [HTTP], Section 5.1>\nfield-value   = <field-value, see [HTTP], Section 5.5>\nobs-text      = <obs-text, see [HTTP], Section 5.6.4>\nquoted-string = <quoted-string, see [HTTP], Section 5.6.4>\ntoken         = <token, see [HTTP], Section 5.6.2>\ntransfer-coding =\n                <transfer-coding, see [HTTP], Section 10.1.4>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The rules below are defined in [URI]:",
      "ja": "以下のルールは[URI]で定義されています。"
    },
    {
      "indent": 5,
      "text": "absolute-URI  = <absolute-URI, see [URI], Section 4.3>\nauthority     = <authority, see [URI], Section 3.2>\nuri-host      = <host, see [URI], Section 3.2.2>\nport          = <port, see [URI], Section 3.2.3>\nquery         = <query, see [URI], Section 3.4>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2. Message",
      "section_title": true,
      "ja": "2. メッセージ"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 clients and servers communicate by sending messages. See Section 3 of [HTTP] for the general terminology and core concepts of HTTP.",
      "ja": "HTTP/1.1クライアントとサーバーは、メッセージを送信して通信します。HTTPの一般用語とコア概念については、[HTTP]のセクション3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.1. Message Format",
      "section_title": true,
      "ja": "2.1. メッセージ形式"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 message consists of a start-line followed by a CRLF and a sequence of octets in a format similar to the Internet Message Format [RFC5322]: zero or more header field lines (collectively referred to as the \"headers\" or the \"header section\"), an empty line indicating the end of the header section, and an optional message body.",
      "ja": "HTTP/1.1メッセージは、start-line、それに続くCRLF、およびインターネットメッセージ形式[RFC5322]と同様の形式のオクテットシーケンスで構成されます。これには、0個以上のヘッダーフィールド行（まとめて「ヘッダー」または「ヘッダーセクション」と呼ばれます）、ヘッダーセクションの終わりを示す空行、およびオプションのメッセージ本文が含まれます。"
    },
    {
      "indent": 5,
      "text": "HTTP-message = start-line CRLF *( field-line CRLF ) CRLF [ message-body ]",
      "ja": "HTTP-message = start-line CRLF *( field-line CRLF ) CRLF [ message-body ]"
    },
    {
      "indent": 3,
      "text": "A message can be either a request from client to server or a response from server to client. Syntactically, the two types of messages differ only in the start-line, which is either a request-line (for requests) or a status-line (for responses), and in the algorithm for determining the length of the message body (Section 6).",
      "ja": "メッセージは、クライアントからサーバーへのリクエスト、またはサーバーからクライアントへのレスポンスのいずれかです。構文的には、2種類のメッセージはstart-line（リクエストの場合はrequest-line、レスポンスの場合はstatus-line）と、メッセージ本文の長さを決定するアルゴリズム（セクション6）のみが異なります。"
    },
    {
      "indent": 5,
      "text": "start-line     = request-line / status-line",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats. In practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method), and clients are implemented to only expect a response.",
      "ja": "理論的には、クライアントはリクエストを受信し、サーバーはレスポンスを受信し、異なるstart-line形式でそれらを区別することができます。実際には、サーバーはリクエストのみを期待するように実装され（レスポンスは未知または無効なリクエストメソッドとして解釈されます）、クライアントはレスポンスのみを期待するように実装されます。"
    },
    {
      "indent": 3,
      "text": "HTTP makes use of some protocol elements similar to the Multipurpose Internet Mail Extensions (MIME) [RFC2045]. See Appendix B for the differences between HTTP and MIME messages.",
      "ja": "HTTPは、Multipurpose Internet Mail Extensions（MIME）[RFC2045]に類似したいくつかのプロトコル要素を使用しています。HTTPメッセージとMIMEメッセージの違いについては、付録Bを参照してください。"
    },
    {
      "indent": 0,
      "text": "2.2. Message Parsing",
      "section_title": true,
      "ja": "2.2. メッセージの解析"
    },
    {
      "indent": 3,
      "text": "The normal procedure for parsing an HTTP message is to read the start-line into a structure, read each header field line into a hash table by field name until the empty line, and then use the parsed data to determine if a message body is expected. If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.",
      "ja": "HTTPメッセージを解析する通常の手順は、start-lineを構造体に読み込み、空行まで各ヘッダーフィールド行をフィールド名ごとにハッシュテーブルに読み込み、解析されたデータを使用してメッセージ本文が期待されるかどうかを判断することです。メッセージ本文が示されている場合、メッセージ本文の長さに等しいオクテット数が読み取られるか、接続が閉じられるまで、ストリームとして読み取られます。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII]. Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A). String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field line value after message parsing has delineated the individual field lines.",
      "ja": "受信者は、US-ASCII [USASCII]のスーパーセットであるエンコーディングのオクテットシーケンスとしてHTTPメッセージを解析する必要があります。特定のエンコーディングに関係なく、HTTPメッセージをUnicode文字のストリームとして解析すると、文字列処理ライブラリがオクテットLF（%x0A）を含む無効なマルチバイト文字シーケンスを処理する方法が異なるため、セキュリティ上の脆弱性が生じます。文字列ベースのパーサーは、メッセージ解析によって個々のフィールド行が切り出された後のヘッダーフィールド行値内など、要素がメッセージから抽出された後にのみ、プロトコル要素内で安全に使用できます。"
    },
    {
      "indent": 3,
      "text": "Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",
      "ja": "start-lineとフィールドの行末記号はシーケンスCRLFですが、受信者は単一のLFを行末記号として認識し、先行するCRを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content. A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.",
      "ja": "送信者は、コンテンツ以外のプロトコル要素内で、裸のCR（直後にLFが続かないCR文字）を生成してはなりません。そのような裸のCRの受信者は、要素を処理するかメッセージを転送する前に、その要素を無効と見なすか、各裸のCRをSPに置き換える必要があります。"
    },
    {
      "indent": 3,
      "text": "Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.",
      "ja": "古いHTTP/1.0ユーザーエージェントの実装では、行末で終了していないメッセージ本文の読み取りに失敗したいくつかの初期のサーバーアプリケーションの回避策として、POSTリクエストの後に追加のCRLFを送信する場合があります。HTTP/1.1ユーザーエージェントは、リクエストの前後に余分なCRLFを付けてはなりません。リクエストメッセージ本文を行末で終了したい場合、ユーザーエージェントは終了CRLFオクテットをメッセージ本文の長さの一部としてカウントする必要があります。"
    },
    {
      "indent": 3,
      "text": "In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.",
      "ja": "堅牢性のために、request-lineを受信して解析することを期待しているサーバーは、request-lineの前に受信した少なくとも1つの空行（CRLF）を無視する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT send whitespace between the start-line and the first header field.",
      "ja": "送信者は、start-lineと最初のヘッダーフィールドの間に空白を送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated). Rejection or removal of invalid whitespace-preceded lines is necessary to prevent their misinterpretation by downstream recipients that might be vulnerable to request smuggling (Section 11.2) or response splitting (Section 11.1) attacks.",
      "ja": "start-lineと最初のヘッダーフィールドの間に空白を受信した受信者は、メッセージを無効として拒否するか、それ以上の処理を行わずに空白で始まる各行を消費する必要があります（つまり、適切に形成されたヘッダーフィールドが受信されるかヘッダーセクションが終了するまで、空白で始まる後続の行とともに、行全体を無視します）。無効な空白で始まる行の拒否または削除は、リクエストスマグリング（セクション11.2）またはレスポンス分割（セクション11.1）攻撃に対して脆弱な可能性のある下流の受信者による誤解を防ぐために必要です。"
    },
    {
      "indent": 3,
      "text": "When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",
      "ja": "HTTPリクエストメッセージのみをリッスンしているサーバー、またはstart-lineからHTTPリクエストメッセージであると思われるものを処理しているサーバーが、上記の堅牢性の例外を除いてHTTP-message文法と一致しないオクテットシーケンスを受信した場合、サーバーは400（Bad Request）レスポンスで応答し、接続を閉じる必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "2.3. HTTP Version",
      "section_title": true,
      "ja": "2.3. HTTPバージョン"
    },
    {
      "indent": 3,
      "text": "HTTP uses a \"<major>.<minor>\" numbering scheme to indicate versions of the protocol. This specification defines version \"1.1\". Section 2.5 of [HTTP] specifies the semantics of HTTP version numbers.",
      "ja": "HTTPは、「<major>。<minor>」番号付けスキームを使用して、プロトコルのバージョンを示します。この仕様はバージョン「1.1」を定義します。[HTTP]のセクション2.5は、HTTPバージョン番号のセマンティクスを指定します。"
    },
    {
      "indent": 3,
      "text": "The version of an HTTP/1.x message is indicated by an HTTP-version field in the start-line. HTTP-version is case-sensitive.",
      "ja": "HTTP/1.xメッセージのバージョンは、start-lineのHTTP-versionフィールドで示されます。HTTP-versionは大文字小文字を区別します。"
    },
    {
      "indent": 5,
      "text": "HTTP-version  = HTTP-name \"/\" DIGIT \".\" DIGIT\nHTTP-name     = %s\"HTTP\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [HTTP/1.0] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored. This specification places recipient-version requirements on some new features so that a conformant sender will only use compatible features until it has determined, through configuration or the receipt of a message, that the recipient supports HTTP/1.1.",
      "ja": "HTTP/1.1メッセージがHTTP/1.0受信者[HTTP/1.0]またはバージョンが不明な受信者に送信される場合、HTTP/1.1メッセージは、すべての新しい機能が無視されれば有効なHTTP/1.0メッセージとして解釈できるように構築されます。この仕様では、いくつかの新機能に受信者バージョンの要件を設けており、適合する送信者は、構成またはメッセージの受信を通じて受信者がHTTP/1.1をサポートしていると判断するまで、互換性のある機能のみを使用します。"
    },
    {
      "indent": 3,
      "text": "Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages, unless it is purposefully downgraded as a workaround for an upstream issue. In other words, an intermediary is not allowed to blindly forward the start-line without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages. Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.",
      "ja": "HTTPメッセージを処理する仲介者（つまり、トンネルとして動作するもの以外のすべての仲介者）は、上流の問題の回避策として意図的にダウングレードしない限り、転送されるメッセージで自身のHTTP-versionを送信する必要があります。言い換えれば、仲介者は、そのメッセージのプロトコルバージョンが、その仲介者がメッセージの受信と送信の両方で適合しているバージョンと一致することを確認せずに、start-lineを盲目的に転送することは許可されていません。HTTP-versionを書き換えずにHTTPメッセージを転送すると、下流の受信者がメッセージ送信者のバージョンを使用して、その送信者との後の通信でどの機能が安全に使用できるかを判断する際に、通信エラーが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol. Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.",
      "ja": "クライアントがHTTP仕様を誤って実装しており、後のバージョンのレスポンスを正しく処理できないことがわかっているか疑われる場合（たとえば、クライアントがバージョン番号を正しく解析できない場合や、仲介者がプロトコルの特定のマイナーバージョンに準拠していないにもかかわらずHTTP-versionを盲目的に転送することが知られている場合など）、サーバーはHTTP/1.1リクエストに対してHTTP/1.0レスポンスを送信してもよい（MAY）。このようなプロトコルのダウングレードは、1つ以上のリクエストヘッダーフィールド（例：User-Agent）が、誤りがあることが知られているクライアントによって送信された値と一意に一致する場合など、特定のクライアント属性によってトリガーされない限り、実行すべきではありません（SHOULD NOT）。"
    },
    {
      "indent": 0,
      "text": "3. Request Line",
      "section_title": true,
      "ja": "3. リクエストライン"
    },
    {
      "indent": 3,
      "text": "A request-line begins with a method token, followed by a single space (SP), the request-target, and another single space (SP), and ends with the protocol version.",
      "ja": "request-lineは、メソッドトークンで始まり、その後に単一のスペース（SP）、request-target、および別の単一のスペース（SP）が続き、プロトコルバージョンで終わります。"
    },
    {
      "indent": 5,
      "text": "request-line   = method SP request-target SP HTTP-version",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in request smuggling security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.2).",
      "ja": "request-lineの文法ルールでは、各コンポーネント要素を単一のSPオクテットで区切る必要がありますが、受信者は代わりに空白区切りの単語境界で解析し、CRLFターミネーターを除いて、あらゆる形式の空白をSP区切り文字として扱い、先行または後続の空白を無視してもよい（MAY）。このような空白には、SP、HTAB、VT（%x0B）、FF（%x0C）、または裸のCRの1つ以上のオクテットが含まれます。ただし、メッセージの複数の受信者がいて、それぞれが堅牢性について独自の解釈を持っている場合、寛容な解析はリクエストスマグリングのセキュリティ脆弱性につながる可能性があります（セクション11.2を参照）。"
    },
    {
      "indent": 3,
      "text": "HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.3 of [HTTP]. A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code. A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).",
      "ja": "HTTPは、[HTTP]のセクション2.3で説明されているように、request-lineの長さに事前定義された制限を設けません。実装しているどのメソッドよりも長いメソッドを受信したサーバーは、501（Not Implemented）ステータスコードで応答する必要があります（SHOULD）。解析したいどのURIよりも長いrequest-targetを受信したサーバーは、414（URI Too Long）ステータスコードで応答する必要があります（[HTTP]のセクション15.5.15を参照）。"
    },
    {
      "indent": 3,
      "text": "Various ad hoc limitations on request-line length are found in practice. It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.",
      "ja": "実際には、request-lineの長さに対するさまざまなアドホックな制限が見られます。すべてのHTTP送信者と受信者が、少なくとも8000オクテットのrequest-line長をサポートすることが推奨されます（RECOMMENDED）。"
    },
    {
      "indent": 0,
      "text": "3.1. Method",
      "section_title": true,
      "ja": "3.1. メソッド"
    },
    {
      "indent": 3,
      "text": "The method token indicates the request method to be performed on the target resource. The request method is case-sensitive.",
      "ja": "メソッドトークンは、ターゲットリソースに対して実行されるリクエストメソッドを示します。リクエストメソッドは大文字小文字を区別します。"
    },
    {
      "indent": 5,
      "text": "method         = token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The request methods defined by this specification can be found in Section 9 of [HTTP], along with information regarding the HTTP method registry and considerations for defining new methods.",
      "ja": "この仕様で定義されたリクエストメソッドは、HTTPメソッドレジストリに関する情報および新しいメソッドを定義するための考慮事項とともに、[HTTP]のセクション9に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2. Request Target",
      "section_title": true,
      "ja": "3.2. リクエストターゲット"
    },
    {
      "indent": 3,
      "text": "The request-target identifies the target resource upon which to apply the request. The client derives a request-target from its desired target URI. There are four distinct formats for the request-target, depending on both the method being requested and whether the request is to a proxy.",
      "ja": "request-targetは、リクエストを適用するターゲットリソースを識別します。クライアントは、目的のターゲットURIからrequest-targetを導き出します。リクエストされるメソッドと、リクエストがプロキシに対するものかどうかに応じて、request-targetには4つの異なる形式があります。"
    },
    {
      "indent": 5,
      "text": "request-target = origin-form\n               / absolute-form\n               / authority-form\n               / asterisk-form",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "No whitespace is allowed in the request-target. Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent as the request-target in a malformed request-line.",
      "ja": "request-targetでは空白は許可されていません。残念ながら、一部のユーザーエージェントは、ハイパーテキスト参照で見つかった空白を適切にエンコードまたは除外できず、その結果、許可されていない文字が不正な形式のrequest-line内のrequest-targetとして送信されることになります。"
    },
    {
      "indent": 3,
      "text": "Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded. A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.",
      "ja": "無効なrequest-lineの受信者は、400（Bad Request）エラー、またはrequest-targetを適切にエンコードした301（Moved Permanently）リダイレクトのいずれかで応答する必要があります（SHOULD）。無効なrequest-lineは、リクエストチェーンに沿ったセキュリティフィルターを回避するために意図的に作成された可能性があるため、受信者はリダイレクトなしで自動修正してリクエストを処理しようとすべきではありません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "A client MUST send a Host header field (Section 7.2 of [HTTP]) in all HTTP/1.1 request messages. If the target URI includes an authority component, then a client MUST send a field value for Host that is identical to that authority component, excluding any userinfo subcomponent and its \"@\" delimiter (Section 4.2 of [HTTP]). If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field value.",
      "ja": "クライアントは、すべてのHTTP/1.1リクエストメッセージでHostヘッダーフィールド（[HTTP]のセクション7.2）を送信する必要があります。ターゲットURIにauthorityコンポーネントが含まれている場合、クライアントは、userinfoサブコンポーネントとその「@」区切り文字（[HTTP]のセクション4.2）を除き、そのauthorityコンポーネントと同一のHostフィールド値を送信する必要があります。ターゲットURIのauthorityコンポーネントが欠落しているか未定義の場合、クライアントは空のフィールド値を持つHostヘッダーフィールドを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field line or a Host header field with an invalid field value.",
      "ja": "サーバーは、HostヘッダーフィールドがないHTTP/1.1リクエストメッセージ、および複数のHostヘッダーフィールド行または無効なフィールド値を持つHostヘッダーフィールドを含むリクエストメッセージに対して、400（Bad Request）ステータスコードで応答する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.1. origin-form",
      "section_title": true,
      "ja": "3.2.1. origin-form"
    },
    {
      "indent": 3,
      "text": "The most common form of request-target is the \"origin-form\".",
      "ja": "request-targetの最も一般的な形式は「origin-form」です。"
    },
    {
      "indent": 5,
      "text": "origin-form = absolute-path [ \"?\" query ]",
      "ja": "origin-form = absolute-path [ \"?\" query ]"
    },
    {
      "indent": 3,
      "text": "When making a request directly to an origin server, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send only the absolute path and query components of the target URI as the request-target. If the target URI's path component is empty, the client MUST send \"/\" as the path within the origin-form of request-target. A Host header field is also sent, as defined in Section 7.2 of [HTTP].",
      "ja": "CONNECTまたはサーバー全体のOPTIONSリクエスト（詳細は後述）以外で、オリジンサーバーに直接リクエストを行う場合、クライアントはターゲットURIの絶対パスとクエリコンポーネントのみをrequest-targetとして送信する必要があります。ターゲットURIのパスコンポーネントが空の場合、クライアントはrequest-targetのorigin-form内のパスとして「/」を送信する必要があります。[HTTP]のセクション7.2で定義されているように、Hostヘッダーフィールドも送信されます。"
    },
    {
      "indent": 3,
      "text": "For example, a client wishing to retrieve a representation of the resource identified as",
      "ja": "たとえば、識別されたリソースの表現を取得したいクライアント"
    },
    {
      "indent": 5,
      "text": "http://www.example.org/where?q=now",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "directly from the origin server would open (or reuse) a TCP connection to port 80 of the host \"www.example.org\" and send the lines:",
      "ja": "Origin Serverから直接、ホスト「www.example.org」のポート80へのTCP接続を開きます（または再利用します）。"
    },
    {
      "indent": 3,
      "text": "GET /where?q=now HTTP/1.1\nHost: www.example.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "followed by the remainder of the request message.",
      "ja": "リクエストメッセージの残りの部分が続きます。"
    },
    {
      "indent": 0,
      "text": "3.2.2. absolute-form",
      "section_title": true,
      "ja": "3.2.2. 絶対形式"
    },
    {
      "indent": 3,
      "text": "When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send the target URI in \"absolute-form\" as the request-target.",
      "ja": "CONNECTまたはサーバー全体のOPTIONSリクエスト（詳細は後述）を除いて、プロキシにリクエストを行う場合、クライアントはターゲットURIを「absolute-form」でrequest-targetとして送信する必要があります。"
    },
    {
      "indent": 5,
      "text": "absolute-form  = absolute-URI",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The proxy is requested to either service that request from a valid cache, if possible, or make the same request on the client's behalf either to the next inbound proxy server or directly to the origin server indicated by the request-target. Requirements on such \"forwarding\" of messages are defined in Section 7.6 of [HTTP].",
      "ja": "プロキシは、可能であれば有効なキャッシュからそのリクエストを処理するか、クライアントに代わって次のインバウンドプロキシサーバーに、またはrequest-targetで示されているオリジンサーバーに直接同じリクエストを行うように要求されます。このようなメッセージの「転送」に関する要件は、[HTTP]のセクション7.6で定義されています。"
    },
    {
      "indent": 3,
      "text": "An example absolute-form of request-line would be:",
      "ja": "リクエストラインの絶対的な形式の例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form, since this allows the Host information to be forwarded through ancient HTTP/1.0 proxies that might not have implemented Host.",
      "ja": "クライアントは、リクエストターゲットが絶対フォームにある場合でも、ホストヘッダーフィールドをHTTP/1.1リクエストで送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a proxy receives a request with an absolute-form of request-target, the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target. A proxy that forwards such a request MUST generate a new Host field value based on the received request-target rather than forward the received Host field value.",
      "ja": "プロキシがabsolute-formのrequest-targetを持つリクエストを受信した場合、プロキシは受信したHostヘッダーフィールド（もしあれば）を無視し、代わりにrequest-targetのホスト情報に置き換える必要があります。そのようなリクエストを転送するプロキシは、受信したHostフィールド値を転送するのではなく、受信したrequest-targetに基づいて新しいHostフィールド値を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an origin server receives a request with an absolute-form of request-target, the origin server MUST ignore the received Host header field (if any) and instead use the host information of the request-target. Note that if the request-target does not have an authority component, an empty Host header field will be sent in this case.",
      "ja": "オリジンサーバーがabsolute-formのrequest-targetを持つリクエストを受信した場合、オリジンサーバーは受信したHostヘッダーフィールド（もしあれば）を無視し、代わりにrequest-targetのホスト情報を使用する必要があります。request-targetにauthorityコンポーネントがない場合、この場合は空のHostヘッダーフィールドが送信されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A server MUST accept the absolute-form in requests even though most HTTP/1.1 clients will only send the absolute-form to a proxy.",
      "ja": "ほとんどのHTTP/1.1クライアントは絶対フォームをプロキシに送信するだけであっても、サーバーはリクエストで絶対フォームを受け入れる必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.3. authority-form",
      "section_title": true,
      "ja": "3.2.3. 権限形式"
    },
    {
      "indent": 3,
      "text": "The \"authority-form\" of request-target is only used for CONNECT requests (Section 9.3.6 of [HTTP]). It consists of only the uri-host and port number of the tunnel destination, separated by a colon (\":\").",
      "ja": "request-targetの「authority-form」は、CONNECTリクエスト（[HTTP]のセクション9.3.6）にのみ使用されます。これは、コロン（\":\"）で区切られたトンネルの宛先のuri-hostとポート番号のみで構成されています。"
    },
    {
      "indent": 5,
      "text": "authority-form = uri-host \":\" port",
      "ja": "authority-form = uri-host \":\" port"
    },
    {
      "indent": 3,
      "text": "When making a CONNECT request to establish a tunnel through one or more proxies, a client MUST send only the host and port of the tunnel destination as the request-target. The client obtains the host and port from the target URI's authority component, except that it sends the scheme's default port if the target URI elides the port. For example, a CONNECT request to \"http://www.example.com\" looks like the following:",
      "ja": "1つ以上のプロキシを介してトンネルを確立するためのCONNECTリクエストを作成する場合、クライアントはトンネルの宛先のホストとポートのみをrequest-targetとして送信する必要があります。クライアントは、ターゲットURIがポートを省略している場合にスキームのデフォルトポートを送信することを除いて、ターゲットURIのauthorityコンポーネントからホストとポートを取得します。たとえば、「http://www.example.com」へのCONNECTリクエストは次のようになります。"
    },
    {
      "indent": 3,
      "text": "CONNECT www.example.com:80 HTTP/1.1\nHost: www.example.com",
      "ja": "CONNECT www.example.com:80 HTTP/1.1\nHost: www.example.com"
    },
    {
      "indent": 0,
      "text": "3.2.4. asterisk-form",
      "section_title": true,
      "ja": "3.2.4. アスタリスク形式"
    },
    {
      "indent": 3,
      "text": "The \"asterisk-form\" of request-target is only used for a server-wide OPTIONS request (Section 9.3.7 of [HTTP]).",
      "ja": "request-targetの「asterisk-form」は、サーバー全体のOPTIONSリクエスト（[HTTP]のセクション9.3.7）にのみ使用されます。"
    },
    {
      "indent": 5,
      "text": "asterisk-form = \"*\"",
      "ja": "asterisk-form = \"*\""
    },
    {
      "indent": 3,
      "text": "When a client wishes to request OPTIONS for the server as a whole, as opposed to a specific named resource of that server, the client MUST send only \"*\" (%x2A) as the request-target. For example,",
      "ja": "クライアントが、そのサーバーの特定の名前付きリソースではなく、サーバー全体に対してOPTIONSをリクエストしたい場合、クライアントはrequest-targetとして「*」（%x2A）のみを送信する必要があります。例えば、"
    },
    {
      "indent": 3,
      "text": "OPTIONS * HTTP/1.1\n",
      "ja": "OPTIONS * HTTP/1.1"
    },
    {
      "indent": 3,
      "text": "If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of \"*\" when it forwards the request to the indicated origin server.",
      "ja": "プロキシが、パスが空でクエリコンポーネントがないURIを持つabsolute-formのrequest-targetを使用したOPTIONSリクエストを受信した場合、リクエストチェーンの最後のプロキシは、指定されたオリジンサーバーへリクエストを転送する際に、「*」のrequest-targetを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, the request",
      "ja": "たとえば、リクエスト"
    },
    {
      "indent": 3,
      "text": "OPTIONS http://www.example.org:8001 HTTP/1.1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "would be forwarded by the final proxy as",
      "ja": "最終的なプロキシによって次のように転送されます"
    },
    {
      "indent": 3,
      "text": "OPTIONS * HTTP/1.1\nHost: www.example.org:8001",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "after connecting to port 8001 of host \"www.example.org\".",
      "ja": "ホスト「www.example.org」のポート8001に接続した後。"
    },
    {
      "indent": 0,
      "text": "3.3. Reconstructing the Target URI",
      "section_title": true,
      "ja": "3.3. ターゲットURIの再構築"
    },
    {
      "indent": 3,
      "text": "The target URI is the request-target when the request-target is in absolute-form. In that case, a server will parse the URI into its generic components for further evaluation.",
      "ja": "request-targetがabsolute-formの場合、ターゲットURIはrequest-targetです。その場合、サーバーはURIをその一般的なコンポーネントに解析して、さらなる評価を行います。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the server reconstructs the target URI from the connection context and various parts of the request message in order to identify the target resource (Section 7.1 of [HTTP]):",
      "ja": "それ以外の場合、サーバーは、ターゲットリソース（[http]のセクション7.1）を識別するために、接続コンテキストとリクエストメッセージのさまざまな部分からターゲットURIを再構築します。"
    },
    {
      "indent": 3,
      "text": "* If the server's configuration provides for a fixed URI scheme, or a scheme is provided by a trusted outbound gateway, that scheme is used for the target URI. This is common in large-scale deployments because a gateway server will receive the client's connection context and replace that with their own connection to the inbound server. Otherwise, if the request is received over a secured connection, the target URI's scheme is \"https\"; if not, the scheme is \"http\".",
      "ja": "* サーバーの構成が固定URIスキームを提供する場合、またはスキームが信頼できるアウトバウンドゲートウェイによって提供される場合、そのスキームはターゲットURIに使用されます。これは、ゲートウェイサーバーがクライアントの接続コンテキストを受信し、インバウンドサーバーへの独自の接続に置き換えるため、大規模な展開で一般的です。それ以外の場合、リクエストが担保付き接続で受信された場合、ターゲットURIのスキームは「HTTPS」です。そうでない場合、スキームは「HTTP」です。"
    },
    {
      "indent": 3,
      "text": "* If the request-target is in authority-form, the target URI's authority component is the request-target. Otherwise, the target URI's authority component is the field value of the Host header field. If there is no Host header field or if its field value is empty or invalid, the target URI's authority component is empty.",
      "ja": "* リクエストターゲットが権限形式にある場合、ターゲットURIの権限コンポーネントはリクエストターゲットです。それ以外の場合、ターゲットURIの権限コンポーネントは、ホストヘッダーフィールドのフィールド値です。ホストヘッダーフィールドがない場合、またはそのフィールド値が空または無効な場合、ターゲットURIの権限コンポーネントは空です。"
    },
    {
      "indent": 3,
      "text": "* If the request-target is in authority-form or asterisk-form, the target URI's combined path and query component is empty. Otherwise, the target URI's combined path and query component is the request-target.",
      "ja": "* リクエストターゲットが権威形式またはアスタリスク形式である場合、ターゲットURIの組み合わせパスとクエリコンポーネントが空です。それ以外の場合、ターゲットURIの組み合わせパスとクエリコンポーネントがリクエストターゲットです。"
    },
    {
      "indent": 3,
      "text": "* The components of a reconstructed target URI, once determined as above, can be recombined into absolute-URI form by concatenating the scheme, \"://\", authority, and combined path and query component.",
      "ja": "* 再構築されたターゲットURIのコンポーネントは、上記のように決定されると、スキーム、「://」、authority、および結合されたパスとクエリコンポーネントを連結することにより、absolute-URI形式に再結合できます。"
    },
    {
      "indent": 3,
      "text": "Example 1: The following message received over a secure connection",
      "ja": "例1：安全な接続で受信した次のメッセージ"
    },
    {
      "indent": 3,
      "text": "GET /pub/WWW/TheProject.html HTTP/1.1\nHost: www.example.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "has a target URI of",
      "ja": "のターゲットURIがあります"
    },
    {
      "indent": 5,
      "text": "https://www.example.org/pub/WWW/TheProject.html",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 2: The following message received over an insecure connection",
      "ja": "例2：安全でない接続を介して受信した次のメッセージ"
    },
    {
      "indent": 3,
      "text": "OPTIONS * HTTP/1.1\nHost: www.example.org:8080",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "has a target URI of",
      "ja": "のターゲットURIがあります"
    },
    {
      "indent": 5,
      "text": "http://www.example.org:8080",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the target URI's authority component is empty and its URI scheme requires a non-empty authority (as is the case for \"http\" and \"https\"), the server can reject the request or determine whether a configured default applies that is consistent with the incoming connection's context. Context might include connection details like address and port, what security has been applied, and locally defined information specific to that server's configuration. An empty authority is replaced with the configured default before further processing of the request.",
      "ja": "ターゲットURIの権限コンポーネントが空であり、そのURIスキームが空でない権限を必要とする場合（「HTTP」と「HTTPS」の場合と同様）、サーバーは、構成されたデフォルトが適用されるかどうかを要求または判断することができます。着信接続のコンテキスト。コンテキストには、アドレスやポートなどの接続の詳細、適用されているセキュリティ、およびそのサーバーの構成に固有のローカルで定義された情報が含まれる場合があります。空の権限は、リクエストをさらに処理する前に、設定されたデフォルトに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "Supplying a default name for authority within the context of a secured connection is inherently unsafe if there is any chance that the user agent's intended authority might differ from the default. A server that can uniquely identify an authority from the request context MAY use that identity as a default without this risk. Alternatively, it might be better to redirect the request to a safe resource that explains how to obtain a new client.",
      "ja": "ユーザーエージェントの意図された権限がデフォルトと異なる可能性がある場合、保護された接続のコンテキスト内で権限のデフォルト名を提供することは、本質的に安全ではありません。要求コンテキストから権限を一意に識別できるサーバーは、このリスクなしにそのIDをデフォルトとして使用する場合があります。または、新しいクライアントを取得する方法を説明する安全なリソースにリクエストをリダイレクトする方が良いかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note that reconstructing the client's target URI is only half of the process for identifying a target resource. The other half is determining whether that target URI identifies a resource for which the server is willing and able to send a response, as defined in Section 7.4 of [HTTP].",
      "ja": "クライアントのターゲットURIの再構築は、ターゲットリソースを識別するプロセスの半分にすぎないことに注意してください。残りの半分は、そのターゲットURIが、[HTTP]のセクション7.4で定義されているように、サーバーが応答を送信することを望んでいるリソースを識別するかどうかを決定しています。"
    },
    {
      "indent": 0,
      "text": "4. Status Line",
      "section_title": true,
      "ja": "4. ステータス行"
    },
    {
      "indent": 3,
      "text": "The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, and another space and ending with an OPTIONAL textual phrase describing the status code.",
      "ja": "応答メッセージの最初の行は、プロトコルバージョン、スペース（SP）、ステータスコード、および別のスペースで構成されるステータスラインであり、ステータスコードを説明するオプションのテキストフレーズで終了します。"
    },
    {
      "indent": 5,
      "text": "status-line = HTTP-version SP status-code SP [ reason-phrase ]",
      "ja": "status-line = HTTP-version SP status-code SP [ reason-phrase ]"
    },
    {
      "indent": 3,
      "text": "Although the status-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the line terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in response splitting security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.1).",
      "ja": "ステータスラインの文法ルールでは、各コンポーネント要素を単一のSPオクテットで区切る必要がありますが、受信者は代わりに、空白区切りの単語境界で解析し、行末記号を除いて、あらゆる形式の空白をSP区切り文字として扱い、先行または後続の空白を無視してもよい（MAY）。このような空白には、SP、HTAB、VT（%x0B）、FF（%x0C）、または裸のCRの1つ以上のオクテットが含まれます。ただし、メッセージの複数の受信者がいて、それぞれが堅牢性について独自の解釈を持っている場合、寛容な解析はレスポンス分割（response splitting）のセキュリティ脆弱性につながる可能性があります（セクション11.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The status-code element is a 3-digit integer code describing the result of the server's attempt to understand and satisfy the client's corresponding request. A recipient parses and interprets the remainder of the response message in light of the semantics defined for that status code, if the status code is recognized by that recipient, or in accordance with the class of that status code when the specific code is unrecognized.",
      "ja": "ステータスコード要素は、クライアントの対応する要求を理解し、満たそうとするサーバーの試みの結果を説明する3桁の整数コードです。受信者は、そのステータスコードがその受信者によって認識されている場合、または特定のコードが認識されていない場合にそのステータスコードのクラスに従って、そのステータスコードで定義されたセマンティクスに照らして、応答メッセージの残りを解析および解釈します。"
    },
    {
      "indent": 5,
      "text": "status-code    = 3DIGIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HTTP's core status codes are defined in Section 15 of [HTTP], along with the classes of status codes, considerations for the definition of new status codes, and the IANA registry for collecting such definitions.",
      "ja": "HTTPのコアステータスコードは、[HTTP]のセクション15で定義され、ステータスコードのクラス、新しいステータスコードの定義に関する考慮事項、およびそのような定義を収集するIANAレジストリが定義されています。"
    },
    {
      "indent": 3,
      "text": "The reason-phrase element exists for the sole purpose of providing a textual description associated with the numeric status code, mostly out of deference to earlier Internet application protocols that were more frequently used with interactive text clients.",
      "ja": "reason-phrase要素は、数値のステータスコードに関連付けられたテキスト説明を提供するという唯一の目的のために存在します。これは主に、対話型テキストクライアントでより頻繁に使用されていた初期のインターネットアプリケーションプロトコルへの配慮からです。"
    },
    {
      "indent": 5,
      "text": "reason-phrase  = 1*( HTAB / SP / VCHAR / obs-text )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A client SHOULD ignore the reason-phrase content because it is not a reliable channel for information (it might be translated for a given locale, overwritten by intermediaries, or discarded when the message is forwarded via other versions of HTTP). A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).",
      "ja": "クライアントは、情報の信頼できるチャネルではないため、Reason-Phraseコンテンツを無視する必要があります（特定のロケールに対して翻訳されたり、仲介者によって上書きされたり、HTTPの他のバージョンを介してメッセージを転送したときに破棄されます）。サーバーは、Reason-Phraseが存在しない場合でも、ステータスコードをReason-Phraseから分離するスペースを送信する必要があります（つまり、ステータスラインがスペースで終了します）。"
    },
    {
      "indent": 0,
      "text": "5. Field Syntax",
      "section_title": true,
      "ja": "5. フィールド構文"
    },
    {
      "indent": 3,
      "text": "Each field line consists of a case-insensitive field name followed by a colon (\":\"), optional leading whitespace, the field line value, and optional trailing whitespace.",
      "ja": "各フィールドラインは、ケースに依存しないフィールド名で構成されており、それに続くコロン（ \"：\"）、オプションの先頭の白文学、フィールドライン値、およびオプションの末尾の白文学が続きます。"
    },
    {
      "indent": 5,
      "text": "field-line = field-name \":\" OWS field-value OWS",
      "ja": "field-line = field-name \":\" OWS field-value OWS"
    },
    {
      "indent": 3,
      "text": "Rules for parsing within field values are defined in Section 5.5 of [HTTP]. This section covers the generic syntax for header field inclusion within, and extraction from, HTTP/1.1 messages.",
      "ja": "フィールド値内の解析のルールは、[HTTP]のセクション5.5で定義されています。このセクションでは、HTTP/1.1メッセージからのヘッダーフィールドを含めるための一般的な構文をカバーします。"
    },
    {
      "indent": 0,
      "text": "5.1. Field Line Parsing",
      "section_title": true,
      "ja": "5.1. フィールドライン解析"
    },
    {
      "indent": 3,
      "text": "Messages are parsed using a generic algorithm, independent of the individual field names. The contents within a given field line value are not parsed until a later stage of message interpretation (usually after the message's entire field section has been processed).",
      "ja": "メッセージは、個々のフィールド名とは無関係に、一般的なアルゴリズムを使用して解析されます。特定のフィールドライン値内の内容は、メッセージ解釈の後期段階まで解析されません（通常、メッセージのフィールド全体が処理された後）。"
    },
    {
      "indent": 3,
      "text": "No whitespace is allowed between the field name and colon. In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling. A server MUST reject, with a response status code of 400 (Bad Request), any received request message that contains whitespace between a header field name and colon. A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.",
      "ja": "フィールド名とコロンの間には、空白は許可されていません。過去には、このような空白の取り扱いの違いが、リクエストルーティングと応答処理におけるセキュリティ脆弱性につながりました。サーバーは、ヘッダーフィールド名とコロンの間に空白を含む受信リクエストメッセージを、400（Bad Request）の応答ステータスコードで拒否する必要があります。プロキシは、メッセージを下流に転送する前に、応答メッセージからそのような空白を削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "A field line value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field line value is preferred for consistent readability by humans. The field line value does not include that leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field line value, or after the last non-whitespace octet of the field line value, is excluded by parsers when extracting the field line value from a field line.",
      "ja": "フィールドライン値の前に、および/またはその後にオプションのWhitespace（OWS）が続く場合があります。フィールドライン値に先行する単一のSPは、人間が一貫した読みやすくするために好まれます。フィールドライン値には、その先頭または末尾の空白は含まれません。フィールドライン値の最初の非空白オクテットの前、またはフィールドライン値の最後の非空白オクテットの後に発生するOWSは、フィールドラインからフィールドライン値を抽出するときにパーサーによって除外されます。"
    },
    {
      "indent": 0,
      "text": "5.2. Obsolete Line Folding",
      "section_title": true,
      "ja": "5.2. 時代遅れの線の折りたたみ"
    },
    {
      "indent": 3,
      "text": "Historically, HTTP/1.x field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold). This specification deprecates such line folding except within the \"message/http\" media type (Section 10.1).",
      "ja": "歴史的に、HTTP/1.xフィールド値は、各追加行の前に少なくとも1つのスペースまたは水平タブ（obs-fold）を置くことで、複数の行に拡張できました。この仕様では、「message/http」メディアタイプ（セクション10.1）内を除き、そのような行の折りたたみを廃止（deprecate）します。"
    },
    {
      "indent": 5,
      "text": "obs-fold = OWS CRLF RWS ; obsolete line folding",
      "ja": "obs-fold = OWS CRLF RWS ; 廃止された行の折りたたみ"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the \"message/http\" media type.",
      "ja": "送信者は、メッセージが「message/http」メディアタイプ内のパッケージを目的としていない限り、行の折りたたみ（つまり、obs-foldルールに一致するフィールドライン値がある）を含むメッセージを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "A server that receives an obs-fold in a request message that is not within a \"message/http\" container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",
      "ja": "「message/http」コンテナ内にないリクエストメッセージでobs-foldを受信するサーバーは、400（Bad Request）を送信することでメッセージを拒否するか（廃止された行の折りたたみが受け入れられないことを説明する表現を含めることが望ましい）、フィールド値を解釈するかメッセージを下流に転送する前に、受信した各obs-foldを1つ以上のSPオクテットに置き換える必要があります。"
    },
    {
      "indent": 3,
      "text": "A proxy or gateway that receives an obs-fold in a response message that is not within a \"message/http\" container MUST either discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",
      "ja": "「message/http」コンテナ内にない応答メッセージでobs-foldを受信するプロキシまたはゲートウェイは、メッセージを破棄し、502（Bad Gateway）応答に置き換えるか（受け入れられない行の折りたたみを受信したことを説明する表現を含めることが望ましい）、フィールド値を解釈するかメッセージを下流に転送する前に、受信した各obs-foldを1つ以上のSPオクテットに置き換える必要があります。"
    },
    {
      "indent": 3,
      "text": "A user agent that receives an obs-fold in a response message that is not within a \"message/http\" container MUST replace each received obs-fold with one or more SP octets prior to interpreting the field value.",
      "ja": "「message/http」コンテナ内にない応答メッセージでobs-foldを受信するユーザーエージェントは、フィールド値を解釈する前に、受信した各obs-foldを1つ以上のSPオクテットに置き換える必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Message Body",
      "section_title": true,
      "ja": "6. メッセージ本文"
    },
    {
      "indent": 3,
      "text": "The message body (if any) of an HTTP/1.1 message is used to carry content (Section 6.4 of [HTTP]) for the request or response. The message body is identical to the content unless a transfer coding has been applied, as described in Section 6.1.",
      "ja": "HTTP/1.1メッセージのメッセージ本文（もしあれば）は、要求または応答のコンテンツ（[http]のセクション6.4）を運ぶために使用されます。セクション6.1で説明されているように、メッセージ本文は、転送コーディングが適用されない限り、コンテンツと同一です。"
    },
    {
      "indent": 5,
      "text": "message-body = *OCTET",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The rules for determining when a message body is present in an HTTP/1.1 message differ for requests and responses.",
      "ja": "http/1.1メッセージにメッセージ本文がいつ存在するかを決定するためのルールは、リクエストと応答に対して異なります。"
    },
    {
      "indent": 3,
      "text": "The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field. Request message framing is independent of method semantics.",
      "ja": "リクエスト内のメッセージ本文の存在は、コンテンツレングスまたは転送エンコードヘッダーフィールドによって通知されます。リクエストメッセージフレーミングは、メソッドセマンティクスとは無関係です。"
    },
    {
      "indent": 3,
      "text": "The presence of a message body in a response, as detailed in Section 6.3, depends on both the request method to which it is responding and the response status code. This corresponds to when response content is allowed by HTTP semantics (Section 6.4.1 of [HTTP]).",
      "ja": "セクション6.3で詳述されているように、応答内のメッセージ本文の存在は、応答している要求方法と応答ステータスコードの両方に依存します。これは、応答コンテンツがHTTPセマンティクスによって許可される場合に対応します（[HTTP]のセクション6.4.1）。"
    },
    {
      "indent": 0,
      "text": "6.1. Transfer-Encoding",
      "section_title": true,
      "ja": "6.1. 転送エンコード"
    },
    {
      "indent": 3,
      "text": "The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the content in order to form the message body. Transfer codings are defined in Section 7.",
      "ja": "転送エンコードヘッダーフィールドには、メッセージ本文を形成するためにコンテンツに適用された（または適用される）転送コーディングのシーケンスに対応する転送コーディング名をリストします。転送コーディングはセクション7で定義されています。"
    },
    {
      "indent": 5,
      "text": "Transfer-Encoding = #transfer-coding\n                     ; defined in [HTTP], Section 10.1.4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit dynamically generated content. It also serves to distinguish encodings that are only applied in transit from the encodings that are a characteristic of the selected representation.",
      "ja": "転送エンコードは、7ビット輸送サービス（[RFC2045]、セクション6）でバイナリデータの安全な輸送を可能にするように設計されたMIMEのコンテンツ移動エンコードフィールドに類似しています。ただし、安全な輸送には、8ビットクリーン転送プロトコルの焦点が異なります。HTTPの場合、転送エンコードは主に動的に生成されたコンテンツを正確に区切ることを目的としています。また、選択した表現の特徴であるエンコーディングからのみ、輸送中に適用されるエンコーディングを区別するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance. A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed). If any transfer coding other than chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed. If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.",
      "ja": "受信者は、コンテンツサイズが事前に不明な場合にメッセージのフレーミングに重要な役割を果たすため、チャンク転送コーディング（セクション7.1）を解析できる必要があります。送信者は、チャンクされた転送コーディングをメッセージ本文に複数回適用してはなりません（つまり、すでにチャンクされたメッセージをチャンキングすることは許可されていません）。チャンク以外の転送コーディングがリクエストのコンテンツに適用される場合、送信者は最終転送コーディングとしてチャンクされている必要があります。チャンク以外の転送コーディングが応答のコンテンツに適用される場合、送信者は最終転送コーディングとしてチャンクを適用するか、接続を閉じてメッセージを終了する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding: gzip, chunked",
      "ja": "Transfer-Encoding: gzip, chunked"
    },
    {
      "indent": 3,
      "text": "indicates that the content has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.",
      "ja": "GZIPコーディングを使用してコンテンツが圧縮され、メッセージ本文の形成中にチャンクコーディングを使用してチャンクされていることを示します。"
    },
    {
      "indent": 3,
      "text": "Unlike Content-Encoding (Section 8.4.1 of [HTTP]), Transfer-Encoding is a property of the message, not of the representation. Any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field value. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.",
      "ja": "コンテンツエンコード（[http]のセクション8.4.1）とは異なり、転送エンコードはメッセージのプロパティであり、表現ではありません。要求/応答チェーンに沿った受信者は、受信した転送コーディングをデコードするか、メッセージ本文に追加の転送コーディングを適用する場合があります。エンコードパラメーターに関する追加情報は、この仕様で定義されていない他のヘッダーフィールドによって提供できます。"
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.",
      "ja": "Transfer-Encodingは、HEADリクエストへの応答、またはGETリクエストへの304（Not Modified）応答（[HTTP]のセクション15.4.5）で送信される場合があります（MAY）。これらにはメッセージ本文が含まれませんが、リクエストが無条件のGETであった場合にオリジンサーバーがメッセージ本文に転送コーディングを適用したであろうことを示すためです。ただし、応答チェーン上の受信者（オリジンサーバーを含む）は不要な場合に転送コーディングを削除できるため、この表示は必須ではありません。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).",
      "ja": "サーバーは、1xxまたは204（コンテンツなし）のステータスコードを使用して、任意の応答で転送エンコードヘッダーフィールドを送信してはなりません。サーバーは、接続要求に対する2xx（成功）応答（[http]のセクション9.3.6）で転送エンコードヘッダーフィールドを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).",
      "ja": "わからない転送コーディングでリクエストメッセージを受信するサーバーは、501（実装されていない）で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process transfer-encoded content, and that an HTTP/1.0 message received with a Transfer-Encoding is likely to have been forwarded without proper handling of the chunked transfer coding in transit.",
      "ja": "Transfer-EncodingはHTTP/1.1に追加されました。一般に、実装広告はHTTP/1.0サポートのみが転送エンコードコンテンツの処理方法を理解していないこと、および転送エンコードで受信したHTTP/1.0メッセージは、チャンク転送コーディングの適切な処理なしに転送された可能性が高いと想定されています。輸送中。"
    },
    {
      "indent": 3,
      "text": "A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response. A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions).",
      "ja": "クライアントは、サーバーがHTTP/1.1リクエスト（または後のマイナーリビジョン）を処理することがわかっていない限り、転送エンコードを含むリクエストを送信してはなりません。このような知識は、特定のユーザー構成の形であるか、以前に受信した応答のバージョンを覚えている可能性があります。対応する要求がHTTP/1.1（または後のマイナーリビジョン）を示していない限り、サーバーは転送エンコードを含む応答を送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "Early implementations of Transfer-Encoding would occasionally send both a chunked transfer coding for message framing and an estimated Content-Length header field for use by progress bars. This is why Transfer-Encoding is defined as overriding Content-Length, as opposed to them being mutually incompatible. Unfortunately, forwarding such a message can lead to vulnerabilities regarding request smuggling (Section 11.2) or response splitting (Section 11.1) attacks if any downstream recipient fails to parse the message according to this specification, particularly when a downstream recipient only implements HTTP/1.0.",
      "ja": "Transfer-Encodingの初期の実装では、メッセージフレーミング用のchunked転送コーディングと、プログレスバーで使用するための推定Content-Lengthヘッダーフィールドの両方を送信することがありました。これが、Transfer-EncodingとContent-Lengthが相互に互換性がないのではなく、Transfer-EncodingがContent-Lengthをオーバーライドすると定義されている理由です。残念ながら、そのようなメッセージを転送すると、下流の受信者がこの仕様に従ってメッセージを解析できない場合、特に下流の受信者がHTTP/1.0のみを実装している場合に、リクエストスマグリング（セクション11.2）またはレスポンス分割（セクション11.1）攻撃に関する脆弱性につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone. Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.",
      "ja": "サーバーは、コンテンツレングスと転送エンコードの両方を含むリクエストを拒否するか、転送エンコードのみに従ってそのような要求を処理する場合があります。とにかく、サーバーは、潜在的な攻撃を回避するためにそのような要求に応答した後、接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message. The message sender might have retained a portion of the message, in buffer, that could be misinterpreted by further use of the connection.",
      "ja": "転送エンコードヘッダーフィールドを含むHTTP/1.0メッセージを受信するサーバーまたはクライアントは、コンテンツ長が存在していても、フレーミングが故障しているかのようにメッセージを扱う必要があり、メッセージを処理した後に接続を閉じます。メッセージ送信者は、バッファーでメッセージの一部を保持している可能性があります。これは、接続のさらなる使用によって誤って解釈される可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Content-Length",
      "section_title": true,
      "ja": "6.2. コンテンツレングス"
    },
    {
      "indent": 3,
      "text": "When a message does not have a Transfer-Encoding header field, a Content-Length header field (Section 8.6 of [HTTP]) can provide the anticipated size, as a decimal number of octets, for potential content. For messages that do include content, the Content-Length field value provides the framing information necessary for determining where the data (and message) ends. For messages that do not include content, the Content-Length indicates the size of the selected representation (Section 8.6 of [HTTP]).",
      "ja": "メッセージに転送エンコードヘッダーフィールドがない場合、コンテンツレングスヘッダーフィールド（[http]のセクション8.6）は、潜在的なコンテンツに対して、10進数のオクテットとして予想されるサイズを提供できます。コンテンツを含むメッセージの場合、コンテンツレングスのフィールド値は、データ（およびメッセージ）が終了する場所を決定するために必要なフレーミング情報を提供します。コンテンツを含むメッセージの場合、コンテンツ長は選択された表現のサイズを示します（[http]のセクション8.6）。"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.",
      "ja": "送信者は、転送エンコードヘッダーフィールドを含むメッセージにコンテンツレングスヘッダーフィールドを送信してはなりません。"
    },
    {
      "indent": 6,
      "text": "|  *Note:* HTTP's use of Content-Length for message framing\n|  differs significantly from the same field's use in MIME, where\n|  it is an optional field used only within the \"message/external-\n|  body\" media-type.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.3. Message Body Length",
      "section_title": true,
      "ja": "6.3. メッセージボディの長さ"
    },
    {
      "indent": 3,
      "text": "The length of a message body is determined by one of the following (in order of precedence):",
      "ja": "メッセージ本文の長さは、次のいずれか（優先順位で）によって決定されます。"
    },
    {
      "indent": 3,
      "text": "1. Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body or trailer section.",
      "ja": "1. ヘッドリクエストへの応答と1xx（情報）、204（コンテンツなし）、または304（変更されていない）ステータスコードを含む応答は、ヘッダーフィールドの後に最初の空の行によって常に終了します。メッセージ、したがってメッセージ本文またはトレーラーセクションを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "2. Any 2xx (Successful) response to a CONNECT request implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message.",
      "ja": "2. 接続要求に対する2xx（成功）応答は、ヘッダーフィールドを終了する空の行の直後に接続がトンネルになることを意味します。クライアントは、そのようなメッセージで受信したコンテンツレングスまたは転送エンコードヘッダーフィールドを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. An intermediary that chooses to forward the message MUST first remove the received Content-Length field and process the Transfer-Encoding (as described below) prior to forwarding the message downstream.",
      "ja": "3. メッセージがTransfer-EncodingとContent-Lengthヘッダーフィールドの両方とともに受信された場合、Transfer-EncodingはContent-Lengthをオーバーライドします。このようなメッセージは、リクエストスマグリング（セクション11.2）またはレスポンス分割（セクション11.1）を実行する試みを示している可能性があり、エラーとして処理すべきです。メッセージを転送することを選択した仲介者は、メッセージを下流に転送する前に、まず受信したContent-Lengthフィールドを削除し、（以下で説明するように）Transfer-Encodingを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "4. If a Transfer-Encoding header field is present and the chunked transfer coding (Section 7.1) is the final encoding, the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.",
      "ja": "4. 転送エンコードヘッダーフィールドが存在し、チャンクされた転送コーディング（セクション7.1）が最終エンコーディングである場合、メッセージボディの長さは、転送コーディングがデータが完了することを示すまで、チャンクデータを読み取り、デコードすることによって決定されます。"
    },
    {
      "indent": 7,
      "text": "If a Transfer-Encoding header field is present in a response and the chunked transfer coding is not the final encoding, the message body length is determined by reading the connection until it is closed by the server.",
      "ja": "転送エンコードヘッダーフィールドが応答中に存在し、チャンクされた転送コーディングが最終エンコードではない場合、メッセージボディの長さは、サーバーによって閉じられるまで接続を読み取ることによって決定されます。"
    },
    {
      "indent": 7,
      "text": "If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.",
      "ja": "転送エンコードヘッダーフィールドがリクエストに存在し、チャンクされた転送コーディングが最終エンコードではない場合、メッセージボディの長さを確実に決定することはできません。サーバーは、400（悪い要求）ステータスコードで応答し、接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "5. If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value). If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. If it is in a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client. If it is in a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response.",
      "ja": "5. Transfer-Encodingなしでメッセージが受信され、無効なContent-Lengthヘッダーフィールドがある場合、メッセージフレーミングは無効であり、受信者はそれを回復不可能なエラーとして扱う必要があります。ただし、フィールド値をカンマ区切りリスト（[HTTP]のセクション5.6.1）として正常に解析でき、リスト内のすべての値が有効で、かつリスト内のすべての値が同じである場合を除きます（この場合、メッセージはContent-Lengthフィールド値として使用されるその単一の値で処理されます）。回復不可能なエラーがリクエストメッセージにある場合、サーバーは400（Bad Request）ステータスコードで応答し、接続を閉じる必要があります。プロキシによって受信された応答メッセージにある場合、プロキシはサーバーへの接続を閉じ、受信した応答を破棄し、クライアントに502（Bad Gateway）応答を送信する必要があります。ユーザーエージェントが受信した応答メッセージに含まれている場合、ユーザーエージェントはサーバーへの接続を閉じて、受信した応答を破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "6. If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection.",
      "ja": "6. 有効なコンテンツレングスヘッダーフィールドが転送エンコードなしで存在する場合、その小数値はオクテットの予想されるメッセージボディの長さを定義します。指定されたオクテットの数を受信する前に送信者が接続を閉じるか、受信者がタイムアウトした場合、受信者はメッセージが不完全で接続を閉じることを検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "7. If this is a request message and none of the above are true, then the message body length is zero (no message body is present).",
      "ja": "7. これがリクエストメッセージであり、上記のいずれも真でない場合、メッセージボディの長さはゼロです（メッセージ本文は存在しません）。"
    },
    {
      "indent": 3,
      "text": "8. Otherwise, this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.",
      "ja": "8. それ以外の場合、これはメッセージボディの長さが宣言されていない応答メッセージであるため、メッセージボディの長さは、サーバーが接続を閉じる前に受信したオクテットの数によって決定されます。"
    },
    {
      "indent": 3,
      "text": "Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.",
      "ja": "ネットワーク障害によって中断された部分的に受信されたメッセージと、正常に完了したクローズ区切りの（close-delimited）応答メッセージを区別する方法がないため、サーバーは可能な限りエンコードまたは長さ区切りの（length-delimited）メッセージを生成する必要があります（SHOULD）。クローズ区切り機能は、主にHTTP/1.0との後方互換性のために存在します。"
    },
    {
      "indent": 6,
      "text": "|  *Note:* Request messages are never close-delimited because they\n|  are always explicitly framed by length or transfer coding, with\n|  the absence of both implying the request ends immediately after\n|  the header section.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).",
      "ja": "サーバーは、411（長さが必要）で応答することにより、メッセージ本文を含むがコンテンツ長ではないリクエストを拒否する場合があります。"
    },
    {
      "indent": 3,
      "text": "Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding. This is typically because such services are implemented via a gateway that requires a content length in advance of being called, and the server is unable or unwilling to buffer the entire request before processing.",
      "ja": "チャンク以外の転送コーディングが適用されていない限り、メッセージ本文を含むリクエストを送信するクライアントは、既存の一部が既存のためにチャンクされた転送コーディングではなく、メッセージボディの長さが事前に知られている場合は有効なコンテンツ長ヘッダーフィールドを使用する必要がありますサービスは、チャンクされた転送コーディングを理解していても、411（長さが必要）ステータスコードでチャンキングに応答します。これは通常、そのようなサービスが、呼び出される前にコンテンツの長さを必要とするゲートウェイを介して実装されており、サーバーが処理前にリクエスト全体をバッファリングすることができないか、または不本意なためです。"
    },
    {
      "indent": 3,
      "text": "A user agent that sends a request that contains a message body MUST send either a valid Content-Length header field or use the chunked transfer coding. A client MUST NOT use the chunked transfer coding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.",
      "ja": "メッセージ本文を含むリクエストを送信するユーザーエージェントは、有効なコンテンツレングスヘッダーフィールドを送信するか、チャンク転送コーディングを使用する必要があります。クライアントは、サーバーがHTTP/1.1（またはそれ以降）リクエストを処理することを知っていない限り、チャンク転送コーディングを使用してはなりません。このような知識は、特定のユーザー構成の形で、または以前に受信した応答のバージョンを覚えている可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY discard the remaining data or attempt to determine if that data belongs as part of the prior message body, which might be the case if the prior message's Content-Length value is incorrect. A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning.",
      "ja": "接続の最後のリクエストに対する最終的な応答が完全に受信され、読み取る追加データが残っている場合、ユーザーエージェントは残りのデータを破棄するか、そのデータが以前のメッセージ本文の一部として属するかどうかを判断しようとすることができます。事前のメッセージのコンテンツレングス値が正しくない場合。クライアントは、そのような動作が中毒をキャッシュすることに対して脆弱であるため、そのような追加データを個別の応答として処理、キャッシュ、または転送してはなりません。"
    },
    {
      "indent": 0,
      "text": "7. Transfer Codings",
      "section_title": true,
      "ja": "7. コーディングを転送します"
    },
    {
      "indent": 3,
      "text": "Transfer coding names are used to indicate an encoding transformation that has been, can be, or might need to be applied to a message's content in order to ensure \"safe transport\" through the network. This differs from a content coding in that the transfer coding is a property of the message rather than a property of the representation that is being transferred.",
      "ja": "転送コーディング名は、ネットワークを介した「安全な輸送」を確保するために、メッセージのコンテンツに適用される、または適用する必要がある、または必要なエンコード変換を示すために使用されます。これは、転送コーディングが転送されている表現のプロパティではなく、メッセージのプロパティであるという点で、コンテンツコーディングとは異なります。"
    },
    {
      "indent": 3,
      "text": "All transfer-coding names are case-insensitive and ought to be registered within the HTTP Transfer Coding registry, as defined in Section 7.3. They are used in the Transfer-Encoding (Section 6.1) and TE (Section 10.1.4 of [HTTP]) header fields (the latter also defining the \"transfer-coding\" grammar).",
      "ja": "すべての転送コーディング名はケース非感受性であり、セクション7.3で定義されているように、HTTP転送コーディングレジストリ内に登録する必要があります。それらは、転送エンコード（セクション6.1）およびTE（[HTTP]のセクション10.1.4）ヘッダーフィールド（後者も「転送コーディング」文法も定義する）で使用されます。"
    },
    {
      "indent": 0,
      "text": "7.1. Chunked Transfer Coding",
      "section_title": true,
      "ja": "7.1. チャンク転送コーディング"
    },
    {
      "indent": 3,
      "text": "The chunked transfer coding wraps content in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer section containing trailer fields. Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message.",
      "ja": "チャンクされた転送コーディングは、コンテンツをラップして、それぞれが独自のサイズインジケーターを備えた一連のチャンクとして転送し、その後、トレーラーフィールドを含むオプションのトレーラーセクションが続きます。Chunkedにより、未知のサイズのコンテンツストリームを一連の長さの識別バッファーとして転送できます。これにより、送信者は接続の持続性を保持し、受信者はメッセージ全体をいつ受け取ったかを知ることができます。"
    },
    {
      "indent": 5,
      "text": "chunked-body   = *chunk\n                 last-chunk\n                 trailer-section\n                 CRLF",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF chunk-size = 1*HEXDIG last-chunk = 1*(\"0\") [ chunk-ext ] CRLF",
      "ja": "chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF chunk-size = 1*HEXDIG last-chunk = 1*(\"0\") [ chunk-ext ] CRLF"
    },
    {
      "indent": 5,
      "text": "chunk-data     = 1*OCTET ; a sequence of chunk-size octets",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer section, and finally terminated by an empty line.",
      "ja": "チャンクサイズのフィールドは、オクテットのチャンクデータのサイズを示す一連の16進数です。チャンクされた転送コーディングは、ゼロのチャンクサイズのチャンクが受信され、おそらくトレーラーセクションが続き、最終的に空のラインで終了すると完了します。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST be able to parse and decode the chunked transfer coding.",
      "ja": "受信者は、チャンク転送コーディングを解析およびデコードできる必要があります。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response. Additionally, very large chunk sizes may cause overflows or loss of precision if their values are not represented accurately in a receiving implementation. Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.",
      "ja": "HTTP/1.1は、充電された応答のサイズを制限する手段を定義しません。これにより、中間者が応答全体をバッファリングすることを保証できます。さらに、非常に大きなチャンクサイズは、受信の実装で値が正確に表されない場合、オーバーフローまたは精度の損失を引き起こす可能性があります。したがって、受信者は、潜在的に大きな16進数を予測し、整数変換のオーバーフローまたは整数表現による精度の損失による解析エラーを防ぐ必要があります。"
    },
    {
      "indent": 3,
      "text": "The chunked coding does not define any parameters. Their presence SHOULD be treated as an error.",
      "ja": "チャンクされたコーディングは、パラメーターを定義しません。それらの存在はエラーとして扱われるべきです。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Chunk Extensions",
      "section_title": true,
      "ja": "7.1.1. チャンクエクステンション"
    },
    {
      "indent": 3,
      "text": "The chunked coding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size.",
      "ja": "チャンクされたコーディングにより、各チャンクは、チャンクサイズの直後に、チャンクごとのメタデータ（署名やハッシュなど）、メッセージ本文のランダム化を供給するために、ゼロ以上のチャンク拡張機能を含めることができます。サイズ。"
    },
    {
      "indent": 5,
      "text": "chunk-ext      = *( BWS \";\" BWS chunk-ext-name\n                    [ BWS \"=\" BWS chunk-ext-val ] )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "chunk-ext-name = token chunk-ext-val = token / quoted-string",
      "ja": "chunk-ext-name = token chunk-ext-val = token / quoted-string"
    },
    {
      "indent": 3,
      "text": "The chunked coding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, the use of chunk extensions is generally limited to specialized HTTP services such as \"long polling\" (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection.",
      "ja": "チャンクされたコーディングは各接続に固有のものであり、高レベルのアプリケーションが拡張を検査する機会がある前に、各受信者（仲介者を含む）によって削除または再確認される可能性があります。したがって、チャンクエクステンションの使用は、一般に、「長いポーリング」（クライアントとサーバーがチャンク拡張機能の使用に関して期待を共有できる）などの特殊なHTTPサービスまたはエンドツーエンドの保護された接続内のパディングに限定されます。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded.",
      "ja": "受信者は、認識されていないチャンク拡張機能を無視する必要があります。サーバーは、メッセージの他の部分に長さの制限とタイムアウトを適用し、適切な4XX（クライアントエラーを生成するのと同じように、提供されるサービスの合理的な金額にリクエストで受信されたチャンク拡張機能の総長を制限する必要があります（クライアントエラー）その量を超えた場合の応答。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Chunked Trailer Section",
      "section_title": true,
      "ja": "7.1.2. チャンクされたトレーラーセクション"
    },
    {
      "indent": 3,
      "text": "A trailer section allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the content is sent, such as a message integrity check, digital signature, or post-processing status. The proper use and limitations of trailer fields are defined in Section 6.5 of [HTTP].",
      "ja": "トレーラーセクションを使用すると、送信者は、メッセージの整合性チェック、デジタル署名、ポスト処理ステータスなど、コンテンツの送信中に動的に生成されるメタデータを提供するために、チャンクメッセージの最後に追加のフィールドを含めることができます。トレーラーフィールドの適切な使用と制限は、[HTTP]のセクション6.5で定義されています。"
    },
    {
      "indent": 5,
      "text": "trailer-section   = *( field-line CRLF )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields. A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section. A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.",
      "ja": "メッセージからチャンクされたコーディングを削除する受信者は、受信したトレーラーフィールドを選択的に保持または破棄することができます。受信したトレーラーフィールドを保持する受信者は、トレーラーフィールドを受け取ったヘッダーフィールドとは別に保存/転送するか、受信したトレーラーフィールドをヘッダーセクションにマージする必要があります。受信者は、対応するヘッダーフィールドの定義が明示的に許可され、トレーラーフィールド値を安全に統合する方法を指示しない限り、受信したトレーラーフィールドをヘッダーセクションにマージしてはなりません。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Decoding Chunked",
      "section_title": true,
      "ja": "7.1.3. ダンクのデコード"
    },
    {
      "indent": 3,
      "text": "A process for decoding the chunked transfer coding can be represented in pseudo-code as:",
      "ja": "チャンクされた転送コーディングをデコードするプロセスは、擬似コードで表すことができます。"
    },
    {
      "indent": 5,
      "text": "length := 0\nread chunk-size, chunk-ext (if any), and CRLF\nwhile (chunk-size > 0) {\n   read chunk-data and CRLF\n   append chunk-data to content\n   length := length + chunk-size\n   read chunk-size, chunk-ext (if any), and CRLF\n}\nread trailer field\nwhile (trailer field is not empty) {\n   if (trailer fields are stored/forwarded separately) {\n       append trailer field to existing trailer fields\n   }\n   else if (trailer field is understood and defined as mergeable) {\n       merge trailer field with existing header fields\n   }\n   else {\n       discard trailer field\n   }\n   read trailer field\n}\nContent-Length := length\nRemove \"chunked\" from Transfer-Encoding",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2. Transfer Codings for Compression",
      "section_title": true,
      "ja": "7.2. 圧縮のためにコーディングを転送します"
    },
    {
      "indent": 3,
      "text": "The following transfer coding names for compression are defined by the same algorithm as their corresponding content coding:",
      "ja": "圧縮の次の転送コーディング名は、対応するコンテンツコーディングと同じアルゴリズムによって定義されます。"
    },
    {
      "indent": 3,
      "text": "compress (and x-compress) See Section 8.4.1.1 of [HTTP].",
      "ja": "compress（および x-compress） [HTTP]のセクション8.4.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "deflate See Section 8.4.1.2 of [HTTP].",
      "ja": "デフレート[HTTP]のセクション8.4.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "gzip (and x-gzip) See Section 8.4.1.3 of [HTTP].",
      "ja": "GZIP（およびX-GZIP）[HTTP]のセクション8.4.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The compression codings do not define any parameters. The presence of parameters with any of these compression codings SHOULD be treated as an error.",
      "ja": "圧縮コーディングは、パラメーターを定義しません。これらの圧縮コーディングのいずれかを使用したパラメーターの存在は、エラーとして扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3. Transfer Coding Registry",
      "section_title": true,
      "ja": "7.3. コーディングレジストリを転送します"
    },
    {
      "indent": 3,
      "text": "The \"HTTP Transfer Coding Registry\" defines the namespace for transfer coding names. It is maintained at <https://www.iana.org/assignments/http-parameters>.",
      "ja": "「HTTP転送コーディングレジストリ」は、転送コーディング名の名前空間を定義します。<https://www.iana.org/assignments/http-parameters>に維持されています。"
    },
    {
      "indent": 3,
      "text": "Registrations MUST include the following fields:",
      "ja": "登録には、次のフィールドを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* Name",
      "ja": "* 名前"
    },
    {
      "indent": 3,
      "text": "* Description",
      "ja": "* 説明"
    },
    {
      "indent": 3,
      "text": "* Pointer to specification text",
      "ja": "* 仕様テキストへのポインタ"
    },
    {
      "indent": 3,
      "text": "Names of transfer codings MUST NOT overlap with names of content codings (Section 8.4.1 of [HTTP]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 7.2.",
      "ja": "転送コーディングの名前は、セクション7.2で定義されている圧縮コーディングの場合のように、エンコード変換が同一でない限り、コンテンツコーディングの名前（[http]のセクション8.4.1）と重複してはなりません。"
    },
    {
      "indent": 3,
      "text": "The TE header field (Section 10.1.4 of [HTTP]) uses a pseudo-parameter named \"q\" as the rank value when multiple transfer codings are acceptable. Future registrations of transfer codings SHOULD NOT define parameters called \"q\" (case-insensitively) in order to avoid ambiguities.",
      "ja": "TEヘッダーフィールド（[HTTP]のセクション10.1.4）は、複数の転送コードが許容される場合、「Q」という名前の擬似パラメーターをランク値として使用します。曖昧さを避けるために、転送コーディングの将来の登録は、「Q」（ケースインテンシテーブ）と呼ばれるパラメーターを定義してはなりません。"
    },
    {
      "indent": 3,
      "text": "Values to be added to this namespace require IETF Review (see Section 4.8 of [RFC8126]) and MUST conform to the purpose of transfer coding defined in this specification.",
      "ja": "この名前空間に追加する値は、IETFレビューが必要であり（[RFC8126]のセクション4.8を参照）、この仕様で定義された転送コーディングの目的に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.",
      "ja": "エンコード形式の識別にプログラム名を使用することは望ましくなく、将来のエンコーディングには阻止されます。"
    },
    {
      "indent": 0,
      "text": "7.4. Negotiating Transfer Codings",
      "section_title": true,
      "ja": "7.4. 転送コードの交渉"
    },
    {
      "indent": 3,
      "text": "The TE field (Section 10.1.4 of [HTTP]) is used in HTTP/1.1 to indicate what transfer codings, besides chunked, the client is willing to accept in the response and whether the client is willing to preserve trailer fields in a chunked transfer coding.",
      "ja": "TEフィールド（[HTTP]のセクション10.1.4）はHTTP/1.1で使用され、どの転送コーディングを示すかを示します。コーディングを転送します。"
    },
    {
      "indent": 3,
      "text": "A client MUST NOT send the chunked transfer coding name in TE; chunked is always acceptable for HTTP/1.1 recipients.",
      "ja": "クライアントは、TEでチャンクされた転送コーディング名を送信してはなりません。チャンクは、HTTP/1.1レシピエントで常に受け入れられます。"
    },
    {
      "indent": 3,
      "text": "Three examples of TE use are below.",
      "ja": "米国の3つの例を以下に示します。"
    },
    {
      "indent": 3,
      "text": "TE: deflate\nTE:\nTE: trailers, deflate;q=0.5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When multiple transfer codings are acceptable, the client MAY rank the codings by preference using a case-insensitive \"q\" parameter (similar to the qvalues used in content negotiation fields; see Section 12.4.2 of [HTTP]). The rank value is a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means \"not acceptable\".",
      "ja": "複数の転送コードが許容される場合、クライアントは、ケースに依存しない「Q」パラメーターを使用して好みによってコーディングをランク付けできます（コンテンツネゴシエーションフィールドで使用されるQ値と同様です。[HTTP]のセクション12.4.2を参照）。ランク値は0〜1の範囲の実数です。0.001は最も好ましくなく、1が最も優先されます。0の値は「受け入れられない」を意味します。"
    },
    {
      "indent": 3,
      "text": "If the TE field value is empty or if no TE field is present, the only acceptable transfer coding is chunked. A message with no transfer coding is always acceptable.",
      "ja": "TEフィールド値が空の場合、またはTEフィールドが存在しない場合、唯一の許容可能な転送コーディングがチャンキングされます。転送コーディングのないメッセージは常に受け入れられます。"
    },
    {
      "indent": 3,
      "text": "The keyword \"trailers\" indicates that the sender will not discard trailer fields, as described in Section 6.5 of [HTTP].",
      "ja": "キーワード「トレーラー」は、[HTTP]のセクション6.5で説明されているように、送信者がトレーラーフィールドを破棄しないことを示します。"
    },
    {
      "indent": 3,
      "text": "Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a \"TE\" connection option within the Connection header field (Section 7.6.1 of [HTTP]) in order to prevent the TE header field from being forwarded by intermediaries that do not support its semantics.",
      "ja": "TEヘッダーフィールドは即時接続にのみ適用されるため、TEの送信者は、TEヘッダーフィールドが存在するのを防ぐために、接続ヘッダーフィールド内に「TE」接続オプション（[HTTP]のセクション7.6.1）を送信する必要があります。そのセマンティクスをサポートしていない仲介者によって転送されます。"
    },
    {
      "indent": 0,
      "text": "8. Handling Incomplete Messages",
      "section_title": true,
      "ja": "8. 不完全なメッセージの処理"
    },
    {
      "indent": 3,
      "text": "A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",
      "ja": "通常、キャンセルされた要求またはトリガーされたタイムアウトの例外により、不完全な要求メッセージを受信するサーバーは、接続を閉じる前にエラー応答を送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete. Cache requirements for incomplete responses are defined in Section 3.3 of [CACHING].",
      "ja": "接続が時期尚早に閉じられている場合、または刻んだ転送コーディングのデコードが失敗したときに発生する可能性のある不完全な応答メッセージを受信するクライアントは、メッセージを不完全として記録する必要があります。不完全な応答のキャッシュ要件は、[キャッシュ]のセクション3.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next.",
      "ja": "ヘッダーセクションの中央で応答が終了し（空の行が受信される前に）、ステータスコードがヘッダーフィールドに依存して応答の完全な意味を伝える場合、クライアントは意味が伝えられていると仮定できません。クライアントは、次に実行するアクションを決定するためにリクエストを繰り返す必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "A message body that uses the chunked transfer coding is incomplete if the zero-sized chunk that terminates the encoding has not been received. A message that uses a valid Content-Length is incomplete if the size of the message body received (in octets) is less than the value given by Content-Length. A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, if the header section was received intact, is considered complete unless an error was indicated by the underlying connection (e.g., an \"incomplete close\" in TLS would leave the response incomplete, as described in Section 9.8).",
      "ja": "エンコードを終了するゼロサイズのチャンクが受信されていない場合、チャンク転送コーディングを使用するメッセージ本文は不完全です。有効なコンテンツレングスを使用するメッセージは、（オクテットで）受信したメッセージ本文のサイズがコンテンツレングスで与えられる値よりも少ない場合、不完全です。接続された転送コーディングもコンテンツ長もない応答は、接続の閉鎖によって終了し、ヘッダーセクションがそのまま受信された場合、基礎となる接続によってエラーが示されない限り完全とみなされます（例えば、「不完全な閉じる」TLSは、セクション9.8で説明されているように、応答を不完全なままにします。"
    },
    {
      "indent": 0,
      "text": "9. Connection Management",
      "section_title": true,
      "ja": "9. 接続管理"
    },
    {
      "indent": 3,
      "text": "HTTP messaging is independent of the underlying transport- or session-layer connection protocol(s). HTTP only presumes a reliable transport with in-order delivery of requests and the corresponding in-order delivery of responses. The mapping of HTTP request and response structures onto the data units of an underlying transport protocol is outside the scope of this specification.",
      "ja": "HTTPメッセージングは、基礎となる輸送またはセッション層接続プロトコルとは無関係です。HTTPは、リクエストの順序配信と対応する応答の配信を伴う信頼できる輸送のみを推定します。基礎となる輸送プロトコルのデータ単位へのHTTP要求と応答構造のマッピングは、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "As described in Section 7.3 of [HTTP], the specific connection protocols to be used for an HTTP interaction are determined by client configuration and the target URI. For example, the \"http\" URI scheme (Section 4.2.1 of [HTTP]) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol.",
      "ja": "[HTTP]のセクション7.3で説明したように、HTTP相互作用に使用される特定の接続プロトコルは、クライアント構成とターゲットURIによって決定されます。たとえば、「HTTP」URIスキーム（[HTTP]のセクション4.2.1）は、デフォルトのTCPポートが80のTCPのデフォルト接続を示しますが、クライアントは他の接続を介してプロキシを使用するように構成されている場合があります。、ポート、またはプロトコル。"
    },
    {
      "indent": 3,
      "text": "HTTP implementations are expected to engage in connection management, which includes maintaining the state of current connections, establishing a new connection or reusing an existing connection, processing messages received on a connection, detecting connection failures, and closing each connection. Most clients maintain multiple connections in parallel, including more than one connection per server endpoint. Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks.",
      "ja": "HTTP実装は、現在の接続の状態の維持、新しい接続の確立、既存の接続の確立、接続で受信したメッセージの処理、接続障害の検出、各接続の閉鎖など、接続管理に関与することが期待されています。ほとんどのクライアントは、サーバーエンドポイントごとに複数の接続を含む、複数の接続を並行して維持しています。ほとんどのサーバーは、数千の同時接続を維持するように設計されていますが、リクエストキューを制御して公正使用を可能にし、サービス拒否攻撃を検出します。"
    },
    {
      "indent": 0,
      "text": "9.1. Establishment",
      "section_title": true,
      "ja": "9.1. 確率"
    },
    {
      "indent": 3,
      "text": "It is beyond the scope of this specification to describe how connections are established via various transport- or session-layer protocols. Each HTTP connection maps to one underlying transport connection.",
      "ja": "さまざまな輸送またはセッション層プロトコルを介して接続がどのように確立されるかを説明するのは、この仕様の範囲を超えています。各HTTP接続は、1つの基礎となる輸送接続にマップします。"
    },
    {
      "indent": 0,
      "text": "9.2. Associating a Response to a Request",
      "section_title": true,
      "ja": "9.2. リクエストへの応答を関連付けます"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 does not include a request identifier for associating a given request message with its corresponding one or more response messages. Hence, it relies on the order of response arrival to correspond exactly to the order in which requests are made on the same connection. More than one response message per request only occurs when one or more informational responses (1xx; see Section 15.2 of [HTTP]) precede a final response to the same request.",
      "ja": "HTTP/1.1には、特定の要求メッセージを対応する1つ以上の応答メッセージに関連付けるための要求識別子は含まれていません。したがって、同じ接続でリクエストが行われる順序に正確に対応するために、応答の到着の順序に依存しています。要求ごとに複数の応答メッセージは、1つ以上の情報応答（1xx; [http]のセクション15.2を参照）が同じリクエストに対する最終的な応答の前に発生した場合にのみ発生します。"
    },
    {
      "indent": 3,
      "text": "A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the first outstanding request that has not yet received a final (non-1xx) response.",
      "ja": "接続に複数の未解決のリクエストを持っているクライアントは、送信された注文の未解決のリクエストのリストを維持する必要があり、最終（非1xx）を受け取っていない最初の未解決のリクエストにその接続に関する各受信応答メッセージを関連付ける必要があります。応答。"
    },
    {
      "indent": 3,
      "text": "If a client receives data on a connection that doesn't have outstanding requests, the client MUST NOT consider that data to be a valid response; the client SHOULD close the connection, since message delimitation is now ambiguous, unless the data consists only of one or more CRLF (which can be discarded per Section 2.2).",
      "ja": "クライアントが未解決のリクエストを持たない接続に関するデータを受信した場合、クライアントはそのデータを有効な応答と見なしてはなりません。データが1つ以上のCRLFのみで構成されていない限り、メッセージの区切りが曖昧になるため、クライアントは接続を閉じる必要があります（セクション2.2に従って破棄できます）。"
    },
    {
      "indent": 0,
      "text": "9.3. Persistence",
      "section_title": true,
      "ja": "9.3. 持続性"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 defaults to the use of \"persistent connections\", allowing multiple requests and responses to be carried over a single connection. HTTP implementations SHOULD support persistent connections.",
      "ja": "HTTP/1.1は、「永続的な接続」の使用にデフォルトであり、複数のリクエストと応答を単一の接続に渡すことができます。HTTP実装は、永続的な接続をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "A recipient determines whether a connection is persistent or not based on the protocol version and Connection header field (Section 7.6.1 of [HTTP]) in the most recently received message, if any:",
      "ja": "受信者は、最近受信したメッセージのプロトコルバージョンと接続ヘッダーフィールド（[http]のセクション7.6.1）に基づいて、接続が永続的かどうかを決定します。"
    },
    {
      "indent": 3,
      "text": "* If the \"close\" connection option is present (Section 9.6), the connection will not persist after the current response; else,",
      "ja": "* 「閉じる」接続オプションが存在する場合（セクション9.6）、現在の応答の後に接続が続きません。そうしないと、"
    },
    {
      "indent": 3,
      "text": "* If the received protocol is HTTP/1.1 (or later), the connection will persist after the current response; else,",
      "ja": "* 受信したプロトコルがHTTP/1.1（またはそれ以降）の場合、現在の応答の後に接続が持続します。そうしないと、"
    },
    {
      "indent": 3,
      "text": "* If the received protocol is HTTP/1.0, the \"keep-alive\" connection option is present, either the recipient is not a proxy or the message is a response, and the recipient wishes to honor the HTTP/1.0 \"keep-alive\" mechanism, the connection will persist after the current response; otherwise,",
      "ja": "* 受信したプロトコルがHTTP/1.0であり、「keep-alive」接続オプションが存在し、受信者がプロキシではないかメッセージが応答であり、かつ受信者がHTTP/1.0の「keep-alive」メカニズムを尊重したい場合、接続は現在の応答の後も持続します。それ以外の場合、"
    },
    {
      "indent": 3,
      "text": "* The connection will close after the current response.",
      "ja": "* 現在の応答の後、接続は閉じられます。"
    },
    {
      "indent": 3,
      "text": "A client that does not support persistent connections MUST send the \"close\" connection option in every request message.",
      "ja": "永続的な接続をサポートしていないクライアントは、すべてのリクエストメッセージに「閉じる」接続オプションを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A server that does not support persistent connections MUST send the \"close\" connection option in every response message that does not have a 1xx (Informational) status code.",
      "ja": "永続的な接続をサポートしないサーバーは、1xx（情報）ステータスコードがないすべての応答メッセージに「閉じる」接続オプションを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client MAY send additional requests on a persistent connection until it sends or receives a \"close\" connection option or receives an HTTP/1.0 response without a \"keep-alive\" connection option.",
      "ja": "クライアントは、「閉じる」接続オプションを送信または受信するか、「キープアライブ」接続オプションなしでHTTP/1.0応答を受信するまで、永続的な接続に追加のリクエストを送信できます。"
    },
    {
      "indent": 3,
      "text": "In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 6. A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request. Likewise, a client MUST read the entire response message body if it intends to reuse the same connection for a subsequent request.",
      "ja": "セクション6で説明されているように、接続に関するすべてのメッセージが自己定義のメッセージ長（つまり、接続の閉鎖によって定義されていないもの）がある必要があります。応答を送信した後の接続。それ以外の場合、永続的な接続に関する残りのデータは、次のリクエストとして誤解されます。同様に、クライアントは、後続のリクエストのために同じ接続を再利用する予定の場合、応答メッセージ本体全体を読み取る必要があります。"
    },
    {
      "indent": 3,
      "text": "A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Appendix C.2.2 for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).",
      "ja": "プロキシサーバーは、HTTP/1.0クライアントとの永続的な接続を維持してはなりません（多くのHTTP/1.0クライアントによって実装されたKEEP-ALIVEヘッダーフィールドの問題の情報と議論については、付録C.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "See Appendix C.2.2 for more information on backwards compatibility with HTTP/1.0 clients.",
      "ja": "HTTP/1.0クライアントとの後方互換性の詳細については、付録C.2.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.3.1. Retrying Requests",
      "section_title": true,
      "ja": "9.3.1. リクエストの再試行"
    },
    {
      "indent": 3,
      "text": "Connections can be closed at any time, with or without intention. Implementations ought to anticipate the need to recover from asynchronous close events. The conditions under which a client can automatically retry a sequence of outstanding requests are defined in Section 9.2.2 of [HTTP].",
      "ja": "接続は、意図の有無にかかわらず、いつでも閉じることができます。実装は、非同期の緊密なイベントから回復する必要性を予測する必要があります。クライアントが一連の未解決の要求を自動的に再試行できる条件は、[HTTP]のセクション9.2.2で定義されています。"
    },
    {
      "indent": 0,
      "text": "9.3.2. Pipelining",
      "section_title": true,
      "ja": "9.3.2. パイプライン"
    },
    {
      "indent": 3,
      "text": "A client that supports persistent connections MAY \"pipeline\" its requests (i.e., send multiple requests without waiting for each response). A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 9.2.1 of [HTTP]), but it MUST send the corresponding responses in the same order that the requests were received.",
      "ja": "永続的な接続をサポートするクライアントは、リクエストを「パイプライン」する場合があります（つまり、各応答を待つことなく複数のリクエストを送信します）。サーバーは、すべて安全な方法（[http]のセクション9.2.1）がある場合、すべてのパイプラインリクエストを並行して処理できますが、リクエストが受信されたのと同じ順序で対応する応答を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses. When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 9.6).",
      "ja": "パイプラインが要求するクライアントは、対応するすべての応答を受信する前に接続が閉じる場合、未回答の要求を再試行する必要があります。接続に失敗した後にパイプラインリクエストを再試行する場合（最後の完全な応答でサーバーによって接続が明示的に閉じられていない）、クライアントは、以前のパイプラインの最初の残りの要求がエラー応答を引き起こした可能性があるため、接続確立の直後にパイプラインをしてはなりません。早期に閉じた接続で複数のリクエストが送信されると、再び失われる可能性があります（セクション9.6で説明されているTCPリセット問題を参照）。"
    },
    {
      "indent": 3,
      "text": "Idempotent methods (Section 9.2.2 of [HTTP]) are significant to pipelining because they can be automatically retried after a connection failure. A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence.",
      "ja": "iDempotentメソッド（[http]のセクション9.2.2）は、接続の障害後に自動的に再試行できるため、パイプラインに重要です。ユーザーエージェントが、パイプ化されたシーケンスを含む部分的な障害条件を検出および回復する手段を持っている場合を除き、その方法の最終的な応答ステータスコードが受信されるまで、非公開法の後にパイプライン要求を要求してはなりません。"
    },
    {
      "indent": 3,
      "text": "An intermediary that receives pipelined requests MAY pipeline those requests when forwarding them inbound, since it can rely on the outbound user agent(s) to determine what requests can be safely pipelined. If the inbound connection fails before receiving a response, the pipelining intermediary MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods; otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly.",
      "ja": "パイプラインのリクエストを受信する仲介者は、アウトバウンドユーザーエージェントに依存して安全にパイプラインできるリクエストを決定できるため、インバウンドを転送するときにそれらのリクエストをパイプラインする場合があります。応答を受信する前にインバウンド接続が失敗した場合、パイプライン中間の仲介者は、リクエストがすべて等量のメソッドを持っている場合、応答をまだ受け取っていない一連の要求を再試行しようとする場合があります。それ以外の場合、パイプラインの仲介者は、受信した応答を転送し、対応するアウトバウンド接続を閉じて、それに応じてアウトバウンドユーザーエージェントが回復できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "9.4. Concurrency",
      "section_title": true,
      "ja": "9.4. 並行性"
    },
    {
      "indent": 3,
      "text": "A client ought to limit the number of simultaneous open connections that it maintains to a given server.",
      "ja": "クライアントは、特定のサーバーに維持する同時のオープン接続の数を制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications. As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections.",
      "ja": "HTTPの以前の改訂により、特定の数の接続が天井として与えられましたが、これは多くのアプリケーションでは非現実的であることがわかりました。その結果、この仕様では、特定の最大数の接続数を義務付けているわけではありませんが、代わりに、複数の接続を開くときにクライアントが保守的であることを奨励します。"
    },
    {
      "indent": 3,
      "text": "Multiple connections are typically used to avoid the \"head-of-line blocking\" problem, wherein a request that takes significant server-side processing and/or transfers very large content would block subsequent requests on the same connection. However, each connection consumes server resources.",
      "ja": "通常、複数の接続が使用され、「ヘッドオブラインブロッキング」問題を回避するために使用されます。これにより、サーバー側の大幅な処理や非常に大きなコンテンツを転送するリクエストが、同じ接続の後続のリクエストをブロックします。ただし、各接続はサーバーリソースを消費します。"
    },
    {
      "indent": 3,
      "text": "Furthermore, using multiple connections can cause undesirable side effects in congested networks. Using larger numbers of connections can also cause side effects in otherwise uncongested networks, because their aggregate and initially synchronized sending behavior can cause congestion that would not have been present if fewer parallel connections had been used.",
      "ja": "さらに、複数の接続を使用すると、混雑したネットワークで望ましくない副作用が発生する可能性があります。また、より多くの接続を使用すると、それ以外の場合は拡張されていないネットワークに副作用を引き起こす可能性があります。なぜなら、それらの総合的に同期した送信動作は、並列接続が少ない場合は存在しなかった混雑を引き起こす可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client.",
      "ja": "サーバーは、単一のクライアントからの過剰な数のオープン接続など、サービス拒否攻撃の虐待的または特性と見なされるトラフィックを拒否する可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "9.5. Failures and Timeouts",
      "section_title": true,
      "ja": "9.5. 障害とタイムアウト"
    },
    {
      "indent": 3,
      "text": "Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server. The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.",
      "ja": "サーバーは通常、それを超えて非アクティブな接続を維持しなくなるタイムアウト値があります。プロキシサーバーは、クライアントが同じプロキシサーバーを介してより多くの接続を行う可能性が高いため、これをより高い値にする可能性があります。永続的な接続を使用すると、クライアントまたはサーバーのいずれかのこのタイムアウトの長さ（または存在）に要件がありません。"
    },
    {
      "indent": 3,
      "text": "A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",
      "ja": "タイムアウトを希望するクライアントまたはサーバーは、接続に優雅なクローズを発行する必要があります。接続の両側の迅速な閉鎖により、割り当てられたシステムリソースを再生することができるため、実装は閉鎖信号のオープン接続を常に監視し、必要に応じて応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the \"idle\" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.",
      "ja": "クライアント、サーバー、またはプロキシは、いつでもトランスポート接続を閉じることができます。たとえば、クライアントは、サーバーが「アイドル」接続を閉じることを決定したと同時に、新しいリクエストを送信し始めた可能性があります。サーバーの観点から見ると、接続はアイドル状態で閉じられていますが、クライアントの観点からは、リクエストが進行中です。"
    },
    {
      "indent": 3,
      "text": "A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry. The latter technique can exacerbate network congestion or server load.",
      "ja": "サーバーは、可能であれば、永続的な接続を維持し、基礎となるトランスポートのフロー制御メカニズムを許可して、クライアントが再試行することを期待して接続を終了するのではなく、一時的な過負荷を解決します。後者の手法は、ネットワークの混雑またはサーバーの負荷を悪化させる可能性があります。"
    },
    {
      "indent": 3,
      "text": "A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request. If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection.",
      "ja": "メッセージ本文を送信するクライアントは、リクエストを送信している間にネットワーク接続を監視する必要があります。クライアントが、サーバーがメッセージ本文を受信したくないことを示す応答を確認し、接続を閉じている場合、クライアントはすぐにボディの送信を停止し、接続の側面を閉じる必要があります。"
    },
    {
      "indent": 0,
      "text": "9.6. Tear-down",
      "section_title": true,
      "ja": "9.6. 取り壊す"
    },
    {
      "indent": 3,
      "text": "The \"close\" connection option is defined as a signal that the sender will close this connection after completion of the response. A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the \"close\" connection option when it intends to close a connection. For example,",
      "ja": "「閉じる」接続オプションは、応答の完了後に送信者がこの接続を閉じるという信号として定義されます。送信者は、接続を閉じる予定の場合に「閉じる」接続オプションを含む接続ヘッダーフィールド（[http]のセクション7.6.1）を送信する必要があります。例えば、"
    },
    {
      "indent": 3,
      "text": "Connection: close",
      "ja": "Connection: close"
    },
    {
      "indent": 3,
      "text": "as a request header field indicates that this is the last request that the client will send on this connection, while in a response, the same field indicates that the server is going to close this connection after the response message is complete.",
      "ja": "リクエストヘッダーフィールドは、これがクライアントがこの接続で送信する最後のリクエストであることを示していますが、応答では、同じフィールドは、応答メッセージが完了した後にサーバーがこの接続を閉じることを示します。"
    },
    {
      "indent": 3,
      "text": "Note that the field name \"Close\" is reserved, since using that name as a header field might conflict with the \"close\" connection option.",
      "ja": "その名前をヘッダーフィールドとして使用すると、「クローズ」接続オプションと競合する可能性があるため、フィールド名「close」は予約されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A client that sends a \"close\" connection option MUST NOT send further requests on that connection (after the one containing the \"close\") and MUST close the connection after reading the final response message corresponding to this request.",
      "ja": "「閉じる」接続オプションを送信するクライアントは、その接続にさらに要求を送信してはなりません（「閉じる」を含む後）は、この要求に対応する最終応答メッセージを読んだ後に接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "A server that receives a \"close\" connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the \"close\" connection option. The server SHOULD send a \"close\" connection option in its final response on that connection. The server MUST NOT process any further requests received on that connection.",
      "ja": "「閉じる」接続オプションを受信するサーバーは、「閉じる」接続オプションを含むリクエストに最終的な応答を送信した後、接続の閉鎖を開始する必要があります（以下を参照）。サーバーは、その接続の最終応答で「閉じる」接続オプションを送信する必要があります。サーバーは、その接続で受信したリクエストを処理してはなりません。"
    },
    {
      "indent": 3,
      "text": "A server that sends a \"close\" connection option MUST initiate closure of the connection (see below) after it sends the response containing the \"close\" connection option. The server MUST NOT process any further requests received on that connection.",
      "ja": "「閉じる」接続オプションを送信するサーバーは、「閉じる」接続オプションを含む応答を送信した後、接続の閉鎖を開始する必要があります（以下を参照）。サーバーは、その接続で受信したリクエストを処理してはなりません。"
    },
    {
      "indent": 3,
      "text": "A client that receives a \"close\" connection option MUST cease sending requests on that connection and close the connection after reading the response message containing the \"close\" connection option; if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.",
      "ja": "「閉じる」接続オプションを受信するクライアントは、「閉じる」接続オプションを含む応答メッセージを読んだ後、その接続の要求の送信を停止し、接続を閉じる必要があります。接続に追加のパイプラインリクエストが送信されていた場合、クライアントはサーバーによって処理されると想定してはなりません。"
    },
    {
      "indent": 3,
      "text": "If a server performs an immediate close of a TCP connection, there is a significant risk that the client will not be able to read the last HTTP response. If the server receives additional data from the client on a fully closed connection, such as another request sent by the client before receiving the server's response, the server's TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client's unacknowledged input buffers before they can be read and interpreted by the client's HTTP parser.",
      "ja": "サーバーがTCP接続の即時閉鎖を実行する場合、クライアントが最後のHTTP応答を読み取ることができないという重大なリスクがあります。サーバーの応答を受信する前にクライアントから送信された別の要求など、完全に閉じた接続でサーバーがクライアントから追加のデータを受信した場合、サーバーのTCPスタックはクライアントにリセットパケットを送信します。残念ながら、リセットパケットは、クライアントのHTTPパーサーによって読み取って解釈する前に、クライアントの未把持の入力バッファーを消去する可能性があります。"
    },
    {
      "indent": 3,
      "text": "To avoid the TCP reset problem, servers typically close a connection in stages. First, the server performs a half-close by closing only the write side of the read/write connection. The server then continues to read from the connection until it receives a corresponding close by the client, or until the server is reasonably certain that its own TCP stack has received the client's acknowledgement of the packet(s) containing the server's last response. Finally, the server fully closes the connection.",
      "ja": "TCPリセットの問題を回避するために、サーバーは通常、ステージで接続を閉じます。まず、サーバーは、読み取り/書き込み接続の書き込み側のみを閉じることにより、半分を実行します。その後、サーバーは、クライアントが対応する閉鎖を受信するまで、またはサーバーがサーバーの最後の応答を含むパケットのクライアントの確認を受信したことをサーバーが合理的に確信するまで、接続から読み続けます。最後に、サーバーは接続を完全に閉じます。"
    },
    {
      "indent": 3,
      "text": "It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.",
      "ja": "リセットの問題がTCP専用であるか、他の輸送接続プロトコルにも見られるかどうかは不明です。"
    },
    {
      "indent": 3,
      "text": "Note that a TCP connection that is half-closed by the client does not delimit a request message, nor does it imply that the client is no longer interested in a response. In general, transport signals cannot be relied upon to signal edge cases, since HTTP/1.1 is independent of transport.",
      "ja": "クライアントによって半分閉鎖されているTCP接続は、要求メッセージを区切らないことも、クライアントがもはや応答に関心がないことを意味しないことに注意してください。一般に、HTTP/1.1は輸送とは無関係であるため、輸送信号はエッジケースを信号に依存することはできません。"
    },
    {
      "indent": 0,
      "text": "9.7. TLS Connection Initiation",
      "section_title": true,
      "ja": "9.7. TLS接続開始"
    },
    {
      "indent": 3,
      "text": "Conceptually, HTTP/TLS is simply sending HTTP messages over a connection secured via TLS [TLS13].",
      "ja": "概念的には、HTTP/TLSは、TLS [TLS13]を介して保護された接続を介してHTTPメッセージを送信しているだけです。"
    },
    {
      "indent": 3,
      "text": "The HTTP client also acts as the TLS client. It initiates a connection to the server on the appropriate port and sends the TLS ClientHello to begin the TLS handshake. When the TLS handshake has finished, the client may then initiate the first HTTP request. All HTTP data MUST be sent as TLS \"application data\" but is otherwise treated like a normal connection for HTTP (including potential reuse as a persistent connection).",
      "ja": "HTTPクライアントは、TLSクライアントとしても機能します。適切なポートのサーバーへの接続を開始し、TLS ClientHelloを送信してTLSハンドシェイクを開始します。TLSの握手が終了したら、クライアントは最初のHTTP要求を開始することがあります。すべてのHTTPデータは、TLS「アプリケーションデータ」として送信する必要がありますが、それ以外の場合はHTTPの通常の接続のように扱われます（潜在的な再利用を含む）。"
    },
    {
      "indent": 0,
      "text": "9.8. TLS Connection Closure",
      "section_title": true,
      "ja": "9.8. TLS接続閉鎖"
    },
    {
      "indent": 3,
      "text": "TLS uses an exchange of closure alerts prior to (non-error) connection closure to provide secure connection closure; see Section 6.1 of [TLS13]. When a valid closure alert is received, an implementation can be assured that no further data will be received on that connection.",
      "ja": "TLSは、（非エラー）接続閉鎖の前に閉鎖アラートの交換を使用して、安全な接続閉鎖を提供します。[TLS13]のセクション6.1を参照してください。有効な閉鎖アラートが受信された場合、その接続でそれ以上のデータが受信されないことを実装することができます。"
    },
    {
      "indent": 3,
      "text": "When an implementation knows that it has sent or received all the message data that it cares about, typically by detecting HTTP message boundaries, it might generate an \"incomplete close\" by sending a closure alert and then closing the connection without waiting to receive the corresponding closure alert from its peer.",
      "ja": "実装が、通常はHTTPメッセージの境界を検出することにより、それが気にかけているすべてのメッセージデータを送信または受信したことを知っている場合、閉鎖アラートを送信してから、対応するのを待つことなく接続を閉じることにより、「不完全なクローズ」を生成する可能性がありますピアからの閉鎖アラート。"
    },
    {
      "indent": 3,
      "text": "An incomplete close does not call into question the security of the data already received, but it could indicate that subsequent data might have been truncated. As TLS is not directly aware of HTTP message framing, it is necessary to examine the HTTP data itself to determine whether messages are complete. Handling of incomplete messages is defined in Section 8.",
      "ja": "不完全なクローズは、すでに受信したデータのセキュリティに疑問を投げかけることはありませんが、後続のデータが切り捨てられている可能性があることを示す可能性があります。TLSはHTTPメッセージフレーミングを直接認識していないため、メッセージが完了したかどうかを判断するためにHTTPデータ自体を調べる必要があります。不完全なメッセージの処理は、セクション8で定義されています。"
    },
    {
      "indent": 3,
      "text": "When encountering an incomplete close, a client SHOULD treat as completed all requests for which it has received either",
      "ja": "不完全なクローズに遭遇したとき、クライアントはどちらかを受け取ったすべてのリクエストを完了するにつれて扱う必要があります"
    },
    {
      "indent": 3,
      "text": "1. as much data as specified in the Content-Length header field or",
      "ja": "1. コンテンツレングスヘッダーフィールドで指定されているように多くのデータまたは"
    },
    {
      "indent": 3,
      "text": "2. the terminal zero-length chunk (when Transfer-Encoding of chunked is used).",
      "ja": "2. 端子ゼロ長塊（チャンクの転送エンコードが使用される場合）。"
    },
    {
      "indent": 3,
      "text": "A response that has neither chunked transfer coding nor Content-Length is complete only if a valid closure alert has been received. Treating an incomplete message as complete could expose implementations to attack.",
      "ja": "充電された転送コーディングもコンテンツ長もない応答は、有効な閉鎖アラートが受信された場合にのみ完了します。不完全なメッセージを完全に扱うと、攻撃に実装を公開する可能性があります。"
    },
    {
      "indent": 3,
      "text": "A client detecting an incomplete close SHOULD recover gracefully.",
      "ja": "不完全なクローズを検出するクライアントは、優雅に回復するはずです。"
    },
    {
      "indent": 3,
      "text": "Clients MUST send a closure alert before closing the connection. Clients that do not expect to receive any more data MAY choose not to wait for the server's closure alert and simply close the connection, thus generating an incomplete close on the server side.",
      "ja": "クライアントは、接続を閉じる前に閉鎖アラートを送信する必要があります。これ以上のデータを受け取ることを期待していないクライアントは、サーバーのクロージャーアラートを待機せず、接続を閉じるだけで、サーバー側に不完全な近接を生成することを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "Servers SHOULD be prepared to receive an incomplete close from the client, since the client can often locate the end of server data.",
      "ja": "クライアントはサーバーデータの終了を見つけることができることが多いため、クライアントから不完全なクローズを受信するようにサーバーを準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection. Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.",
      "ja": "サーバーは、接続を閉じる前にクライアントとの閉鎖アラートの交換を開始しようとする必要があります。サーバーは、クロージャーアラートを送信した後に接続を閉じる可能性があり、クライアント側に不完全なクローズを生成する場合があります。"
    },
    {
      "indent": 0,
      "text": "10. Enclosing Messages as Data",
      "section_title": true,
      "ja": "10. メッセージをデータとして囲む"
    },
    {
      "indent": 0,
      "text": "10.1. Media Type message/http",
      "section_title": true,
      "ja": "10.1. メディアタイプメッセージ/http"
    },
    {
      "indent": 3,
      "text": "The \"message/http\" media type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all \"message\" types regarding line length and encodings. Because of the line length limitations, field values within \"message/http\" are allowed to use line folding (obs-fold), as described in Section 5.2, to convey the field value over multiple lines. A recipient of \"message/http\" data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.",
      "ja": "「メッセージ/HTTP」メディアタイプを使用して、単一のHTTP要求または応答メッセージを囲むことができます。ラインの長さの制限のため、セクション5.2で説明されているように、「メッセージ/HTTP」内のフィールド値は、複数の行でフィールド値を伝えるために、ライン折りたたみ（倍数）を使用できます。「メッセージ/http」データの受信者は、メッセージが消費されたときに、時代遅れの線の折りたたみを1つ以上のSP文字に置き換える必要があります。"
    },
    {
      "indent": 3,
      "text": "Type name: message",
      "ja": "タイプ名：メッセージ"
    },
    {
      "indent": 3,
      "text": "Subtype name: http",
      "ja": "サブタイプ名：http"
    },
    {
      "indent": 3,
      "text": "Required parameters: N/A",
      "ja": "必要なパラメーター：n/a"
    },
    {
      "indent": 3,
      "text": "Optional parameters: version, msgtype",
      "ja": "オプションのパラメーター：バージョン、msgtype"
    },
    {
      "indent": 6,
      "text": "version: The HTTP-version number of the enclosed message (e.g., \"1.1\"). If not present, the version can be determined from the first line of the body.",
      "ja": "バージョン：囲まれたメッセージのHTTPバージョン数（例： \"1.1\"）。存在しない場合、バージョンはボディの最初の行から決定できます。"
    },
    {
      "indent": 6,
      "text": "msgtype: The message type -- \"request\" or \"response\". If not present, the type can be determined from the first line of the body.",
      "ja": "msgtype：メッセージタイプ - 「リクエスト」または「応答」。存在しない場合、タイプは身体の最初の行から決定できます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are permitted",
      "ja": "エンコーディングの考慮事項：「7bit」、「8bit」、または「binary」のみが許可されます"
    },
    {
      "indent": 3,
      "text": "Security considerations: see Section 11",
      "ja": "セキュリティ上の考慮事項：セクション11を参照してください"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: N/A",
      "ja": "相互運用性の考慮事項：n/a"
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 9112 (see Section 10.1).",
      "ja": "公開された仕様：RFC 9112（セクション10.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: N/A",
      "ja": "このメディアタイプを使用するアプリケーション：n/a"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: N/A",
      "ja": "フラグメント識別子の考慮事項：n/a"
    },
    {
      "indent": 3,
      "text": "Additional information:  Magic number(s):  N/A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Deprecated alias names for this type: N/A",
      "ja": "このタイプの非推奨エイリアス名：n/a"
    },
    {
      "indent": 28,
      "text": "File extension(s):  N/A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Macintosh file type code(s):  N/A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Person and email address to contact for further information: See Aut hors' Addresses section.",
      "ja": "詳細については、個人とメールアドレスをお問い合わせください：Aut Horsのアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図された使用法：共通"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: N/A",
      "ja": "使用に関する制限：n/a"
    },
    {
      "indent": 3,
      "text": "Author: See Authors' Addresses section.",
      "ja": "著者：著者のアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Change controller: IESG",
      "ja": "Change Controller：IESG"
    },
    {
      "indent": 0,
      "text": "10.2. Media Type application/http",
      "section_title": true,
      "ja": "10.2. メディアタイプアプリケーション/http"
    },
    {
      "indent": 3,
      "text": "The \"application/http\" media type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed).",
      "ja": "「アプリケーション/HTTP」メディアタイプを使用して、1つ以上のHTTP要求または応答メッセージのパイプラインを囲むことができます（混合されていません）。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: http",
      "ja": "サブタイプ名：http"
    },
    {
      "indent": 3,
      "text": "Required parameters: N/A",
      "ja": "必要なパラメーター：n/a"
    },
    {
      "indent": 3,
      "text": "Optional parameters: version, msgtype",
      "ja": "オプションのパラメーター：バージョン、msgtype"
    },
    {
      "indent": 6,
      "text": "version: The HTTP-version number of the enclosed messages (e.g., \"1.1\"). If not present, the version can be determined from the first line of the body.",
      "ja": "バージョン：囲まれたメッセージのHTTPバージョン数（例： \"1.1\"）。存在しない場合、バージョンはボディの最初の行から決定できます。"
    },
    {
      "indent": 6,
      "text": "msgtype: The message type -- \"request\" or \"response\". If not present, the type can be determined from the first line of the body.",
      "ja": "msgtype：メッセージタイプ - 「リクエスト」または「応答」。存在しない場合、タイプは身体の最初の行から決定できます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: HTTP messages enclosed by this type are in \"binary\" format; use of an appropriate Content-Transfer-Encoding is required when transmitted via email.",
      "ja": "考慮事項のエンコード：このタイプで囲まれたHTTPメッセージは「バイナリ」形式です。電子メールで送信される場合、適切なコンテンツ移動エンコードの使用が必要です。"
    },
    {
      "indent": 3,
      "text": "Security considerations: see Section 11",
      "ja": "セキュリティ上の考慮事項：セクション11を参照してください"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: N/A",
      "ja": "相互運用性の考慮事項：n/a"
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 9112 (see Section 10.2).",
      "ja": "公開された仕様：RFC 9112（セクション10.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: N/A",
      "ja": "このメディアタイプを使用するアプリケーション：n/a"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: N/A",
      "ja": "フラグメント識別子の考慮事項：n/a"
    },
    {
      "indent": 3,
      "text": "Additional information:  Deprecated alias names for this type:  N/A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Magic number(s):  N/A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "File extension(s):  N/A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Macintosh file type code(s):  N/A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Person and email address to contact for further information: See Aut hors' Addresses section.",
      "ja": "詳細については、個人とメールアドレスをお問い合わせください：Aut Horsのアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図された使用法：共通"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: N/A",
      "ja": "使用に関する制限：n/a"
    },
    {
      "indent": 3,
      "text": "Author: See Authors' Addresses section.",
      "ja": "著者：著者のアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Change controller: IESG",
      "ja": "Change Controller：IESG"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is meant to inform developers, information providers, and users about known security considerations relevant to HTTP message syntax and parsing. Security considerations about HTTP semantics, content, and routing are addressed in [HTTP].",
      "ja": "このセクションは、HTTPメッセージの構文と解析に関連する既知のセキュリティに関する考慮事項について、開発者、情報プロバイダー、およびユーザーに通知することを目的としています。HTTPセマンティクス、コンテンツ、およびルーティングに関するセキュリティ上の考慮事項は、[HTTP]で対処されています。"
    },
    {
      "indent": 0,
      "text": "11.1. Response Splitting",
      "section_title": true,
      "ja": "11.1. 応答分割"
    },
    {
      "indent": 3,
      "text": "Response splitting (a.k.a. CRLF injection) is a common technique, used in various attacks on Web usage, that exploits the line-based nature of HTTP message framing and the ordered association of requests to responses on persistent connections [Klein]. This technique can be particularly damaging when the requests pass through a shared cache.",
      "ja": "レスポンス分割（別名CRLFインジェクション）は、Web使用に関するさまざまな攻撃で使用される一般的な手法であり、HTTPメッセージフレーミングのラインベースの性質と、永続的な接続の応答とのリクエストの順序付き関連を活用します[Klein]。この手法は、リクエストが共有キャッシュを通過する場合に特に損害を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "Response splitting exploits a vulnerability in servers (usually within an application server) where an attacker can send encoded data within some parameter of the request that is later decoded and echoed within any of the response header fields of the response. If the decoded data is crafted to look like the response has ended and a subsequent response has begun, the response has been split, and the content within the apparent second response is controlled by the attacker. The attacker can then make any other request on the same persistent connection and trick the recipients (including intermediaries) into believing that the second half of the split is an authoritative answer to the second request.",
      "ja": "応答の分割は、攻撃者がリクエストの一部のパラメーター内でエンコードされたデータを送信して、後でデコードされ、応答の応答ヘッダーフィールドのいずれか内にエコーされます。デコードされたデータが応答が終了し、その後の応答が開始されるように作成され、応答が分割され、見かけの2番目の応答内のコンテンツが攻撃者によって制御されます。攻撃者は、同じ永続的な接続で他の要求を行い、受信者（仲介者を含む）をだまして、分割の後半が2番目の要求に対する権威ある回答であると信じることができます。"
    },
    {
      "indent": 3,
      "text": "For example, a parameter within the request-target might be read by an application server and reused within a redirect, resulting in the same parameter being echoed in the Location header field of the response. If the parameter is decoded by the application and not properly encoded when placed in the response field, the attacker can send encoded CRLF octets and other content that will make the application's single response look like two or more responses.",
      "ja": "たとえば、リクエストターゲット内のパラメーターはアプリケーションサーバーによって読み取られ、リダイレクト内で再利用される場合があり、その結果、同じパラメーターが応答の位置ヘッダーフィールドにエコーされます。パラメーターがアプリケーションによってデコードされ、応答フィールドに配置されたときに適切にエンコードされていない場合、攻撃者はエンコードされたCRLFオクテットおよびその他のコンテンツを送信できます。"
    },
    {
      "indent": 3,
      "text": "A common defense against response splitting is to filter requests for data that looks like encoded CR and LF (e.g., \"%0D\" and \"%0A\"). However, that assumes the application server is only performing URI decoding rather than more obscure data transformations like charset transcoding, XML entity translation, base64 decoding, sprintf reformatting, etc. A more effective mitigation is to prevent anything other than the server's core protocol libraries from sending a CR or LF within the header section, which means restricting the output of header fields to APIs that filter for bad octets and not allowing application servers to write directly to the protocol stream.",
      "ja": "レスポンス分割に対する一般的な防御策は、エンコードされたCRやLF（例：「%0D」や「%0A」）のように見えるデータを含むリクエストをフィルタリングすることです。ただし、これは、アプリケーションサーバーが、文字セットのトランスコーディング、XMLエンティティ変換、base64デコード、sprintfの再フォーマットなどのより不明瞭なデータ変換ではなく、URIデコードのみを実行していると仮定しています。より効果的な緩和策は、サーバーのコアプロトコルライブラリ以外のものがヘッダーセクション内でCRまたはLFを送信するのを防ぐことです。これは、ヘッダーフィールドの出力を不正なオクテットをフィルタリングするAPIに制限し、アプリケーションサーバーがプロトコルストリームに直接書き込むことを許可しないことを意味します。"
    },
    {
      "indent": 0,
      "text": "11.2. Request Smuggling",
      "section_title": true,
      "ja": "11.2. 密輸をリクエストします"
    },
    {
      "indent": 3,
      "text": "Request smuggling ([Linhart]) is a technique that exploits differences in protocol parsing among various recipients to hide additional requests (which might otherwise be blocked or disabled by policy) within an apparently harmless request. Like response splitting, request smuggling can lead to a variety of attacks on HTTP usage.",
      "ja": "リクエストスマグリング（[Linhart]）は、さまざまな受信者間のプロトコル解析の違いを悪用して、一見無害なリクエスト内に追加のリクエスト（ポリシーによってブロックまたは無効にされる可能性のあるもの）を隠す手法です。レスポンス分割と同様に、リクエストスマグリングはHTTPの使用に対するさまざまな攻撃につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "This specification has introduced new requirements on request parsing, particularly with regard to message framing in Section 6.3, to reduce the effectiveness of request smuggling.",
      "ja": "この仕様により、特にセクション6.3のメッセージフレーミングに関して、リクエストの解析に関する新しい要件が導入され、要求の密輸の有効性が低下しました。"
    },
    {
      "indent": 0,
      "text": "11.3. Message Integrity",
      "section_title": true,
      "ja": "11.3. メッセージの整合性"
    },
    {
      "indent": 3,
      "text": "HTTP does not define a specific mechanism for ensuring message integrity, instead relying on the error-detection ability of underlying transport protocols and the use of length or chunk-delimited framing to detect completeness. Historically, the lack of a single integrity mechanism has been justified by the informal nature of most HTTP communication. However, the prevalence of HTTP as an information access mechanism has resulted in its increasing use within environments where verification of message integrity is crucial.",
      "ja": "HTTPは、メッセージの整合性を確保するための特定のメカニズムを定義しません。代わりに、基礎となる輸送プロトコルのエラー検出能力と、完全性を検出するための長さまたはチャンク削除フレーミングの使用に依存します。歴史的に、単一の整合性メカニズムの欠如は、ほとんどのHTTP通信の非公式の性質によって正当化されてきました。ただし、情報アクセスメカニズムとしてのHTTPの有病率は、メッセージの整合性の検証が重要な環境内での使用の増加をもたらしました。"
    },
    {
      "indent": 3,
      "text": "The mechanisms provided with the \"https\" scheme, such as authenticated encryption, provide protection against modification of messages. Care is needed, however, to ensure that connection closure cannot be used to truncate messages (see Section 9.8). User agents might refuse to accept incomplete messages or treat them specially. For example, a browser being used to view medical history or drug interaction information needs to indicate to the user when such information is detected by the protocol to be incomplete, expired, or corrupted during transfer. Such mechanisms might be selectively enabled via user agent extensions or the presence of message integrity metadata in a response.",
      "ja": "認証された暗号化などの「HTTPS」スキームで提供されるメカニズムは、メッセージの変更に対する保護を提供します。ただし、メッセージの切り捨てに接続クロージャーを使用できないことを確認するには注意が必要です（セクション9.8を参照）。ユーザーエージェントは、不完全なメッセージを受け入れるか、特別に扱うことを拒否する場合があります。たとえば、病歴や薬物相互作用情報を表示するために使用されるブラウザは、そのような情報がプロトコルによって検出され、転送中に不完全、期限切れ、または破損していることを検出した場合にユーザーに示す必要があります。このようなメカニズムは、ユーザーエージェント拡張またはメッセージの整合性メタデータの存在を介して選択的に有効にされる場合があります。"
    },
    {
      "indent": 3,
      "text": "The \"http\" scheme provides no protection against accidental or malicious modification of messages.",
      "ja": "「HTTP」スキームは、メッセージの偶発的または悪意のある変更に対する保護を提供しません。"
    },
    {
      "indent": 3,
      "text": "Extensions to the protocol might be used to mitigate the risk of unwanted modification of messages by intermediaries, even when the \"https\" scheme is used. Integrity might be assured by using message authentication codes or digital signatures that are selectively added to messages via extensible metadata fields.",
      "ja": "プロトコルへの拡張は、「HTTPS」スキームが使用されている場合でも、仲介者によるメッセージの不要な変更のリスクを軽減するために使用される場合があります。拡張可能なメタデータフィールドを介してメッセージに選択的に追加されるメッセージ認証コードまたはデジタル署名を使用することにより、整合性が保証される場合があります。"
    },
    {
      "indent": 0,
      "text": "11.4. Message Confidentiality",
      "section_title": true,
      "ja": "11.4. メッセージの機密性"
    },
    {
      "indent": 3,
      "text": "HTTP relies on underlying transport protocols to provide message confidentiality when that is desired. HTTP has been specifically designed to be independent of the transport protocol, such that it can be used over many forms of encrypted connection, with the selection of such transports being identified by the choice of URI scheme or within user agent configuration.",
      "ja": "HTTPは、基礎となる輸送プロトコルに依存して、それが必要な場合にメッセージの機密性を提供します。HTTPは、トランスポートプロトコルとは独立しているように特別に設計されており、多くの形式の暗号化された接続で使用できるように、そのようなトランスポートの選択はURIスキームの選択またはユーザーエージェント構成によって識別されます。"
    },
    {
      "indent": 3,
      "text": "The \"https\" scheme can be used to identify resources that require a confidential connection, as described in Section 4.2.2 of [HTTP].",
      "ja": "[HTTPS]スキームを使用して、[HTTP]のセクション4.2.2で説明されているように、機密接続を必要とするリソースを識別できます。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The change controller for the following registrations is: \"IETF (iesg@ietf.org) - Internet Engineering Task Force\".",
      "ja": "次の登録の変更コントローラーは、「IETF（iesg@ietf.org） - インターネットエンジニアリングタスクフォース」です。"
    },
    {
      "indent": 0,
      "text": "12.1. Field Name Registration",
      "section_title": true,
      "ja": "12.1. フィールド名登録"
    },
    {
      "indent": 3,
      "text": "IANA has added the following field names to the \"Hypertext Transfer Protocol (HTTP) Field Name Registry\" at <https://www.iana.org/assignments/http-fields>, as described in Section 18.4 of [HTTP].",
      "ja": "IANAは、[http]のセクション18.4で説明されているように、「https://www.iana.org/assignments/http-fields> <https://www.iana.org/assignments/http-fields> <https://www.iana.org> <https://www.iana.org> <https://www.iana.org>」の「ハイパーテキスト転送プロトコル（http）フィールド名レジストリ」に追加したフィールド名を追加しました。"
    },
    {
      "indent": 3,
      "text": "+===================+===========+=========+============+\n| Field Name        | Status    | Section | Comments   |\n+===================+===========+=========+============+\n| Close             | permanent | 9.6     | (reserved) |\n+-------------------+-----------+---------+------------+\n| MIME-Version      | permanent | B.1     |            |\n+-------------------+-----------+---------+------------+\n| Transfer-Encoding | permanent | 6.1     |            |\n+-------------------+-----------+---------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 0,
      "text": "12.2. Media Type Registration",
      "section_title": true,
      "ja": "12.2. メディアタイプの登録"
    },
    {
      "indent": 3,
      "text": "IANA has updated the \"Media Types\" registry at <https://www.iana.org/assignments/media-types> with the registration information in Sections 10.1 and 10.2 for the media types \"message/ http\" and \"application/http\", respectively.",
      "ja": "IANAは、<https://www.iana.org/assignments/media-types> <https://www.iana.org>の「メディアタイプ」レジストリを更新しました。\"、 それぞれ。"
    },
    {
      "indent": 0,
      "text": "12.3. Transfer Coding Registration",
      "section_title": true,
      "ja": "12.3. コーディング登録を転送します"
    },
    {
      "indent": 3,
      "text": "IANA has updated the \"HTTP Transfer Coding Registry\" at <https://www.iana.org/assignments/http-parameters/> with the registration procedure of Section 7.3 and the content coding names summarized in the table below.",
      "ja": "IANAは、セクション7.3の登録手順で「https://www.iana.org/assignments/http-parameters/> <https://www.iana.org/assignments/http-parameters/>」の「HTTP転送レジストリ」を更新し、以下の表にまとめたコンテンツコーディング名を更新しました。"
    },
    {
      "indent": 3,
      "text": "+============+===========================================+=========+\n| Name       | Description                               | Section |\n+============+===========================================+=========+\n| chunked    | Transfer in a series of chunks            | 7.1     |\n+------------+-------------------------------------------+---------+\n| compress   | UNIX \"compress\" data format [Welch]       | 7.2     |\n+------------+-------------------------------------------+---------+\n| deflate    | \"deflate\" compressed data ([RFC1951])     | 7.2     |\n|            | inside the \"zlib\" data format ([RFC1950]) |         |\n+------------+-------------------------------------------+---------+\n| gzip       | GZIP file format [RFC1952]                | 7.2     |\n+------------+-------------------------------------------+---------+\n| trailers   | (reserved)                                | 12.3    |\n+------------+-------------------------------------------+---------+\n| x-compress | Deprecated (alias for compress)           | 7.2     |\n+------------+-------------------------------------------+---------+\n| x-gzip     | Deprecated (alias for gzip)               | 7.2     |\n+------------+-------------------------------------------+---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 6,
      "text": "|  *Note:* the coding name \"trailers\" is reserved because its use\n|  would conflict with the keyword \"trailers\" in the TE header\n|  field (Section 10.1.4 of [HTTP]).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12.4. ALPN Protocol ID Registration",
      "section_title": true,
      "ja": "12.4. ALPNプロトコルID登録"
    },
    {
      "indent": 3,
      "text": "IANA has updated the \"TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs\" registry at <https://www.iana.org/assignments/ tls-extensiontype-values/> with the registration below:",
      "ja": "IANAは、「TLSアプリケーションレイヤープロトコルネゴシエーション（ALPN）プロトコルIDS」レジストリを<https://www.iana.org/assignments/ tls-extensiontype-values/>に更新しました。"
    },
    {
      "indent": 10,
      "text": "+==========+=============================+===========+\n| Protocol | Identification Sequence     | Reference |\n+==========+=============================+===========+\n| HTTP/1.1 | 0x68 0x74 0x74 0x70 0x2f    | RFC 9112  |\n|          | 0x31 0x2e 0x31 (\"http/1.1\") |           |\n+----------+-----------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13. 参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[CACHING] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Caching\", STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, <https://www.rfc-editor.org/info/rfc9111>.",
      "ja": "[キャッシュ]フィールディング、R。、編、ノッティンガム、M.、編、J。レスケ、編、「HTTPキャッシュ」、STD 98、RFC 9111、DOI 10.17487/RFC9111、2022年6月、<https：//www.rfc-editor.org/info/rfc9111>。"
    },
    {
      "indent": 3,
      "text": "[HTTP] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Semantics\", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <https://www.rfc-editor.org/info/rfc9110>.",
      "ja": "[HTTP] Fielding、R.、Ed。、Nottingham、M.、Ed。、およびJ. Reschke、ed。、 \"HTTP Semantics\"、Std 97、RFC 9110、DOI 10.17487/RFC9110、2022年6月、<https：//www.rfc-editor.org/info/rfc9110>。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch, P. and J-L. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, DOI 10.17487/RFC1950, May 1996, <https://www.rfc-editor.org/info/rfc1950>.",
      "ja": "[RFC1950] Deutsch、P。およびJ-L。Gailly、「Zlib圧縮データ形式の仕様バージョン3.3」、RFC 1950、DOI 10.17487/RFC1950、1996年5月、<https://www.rfc-editor.org/info/rfc1950>。"
    },
    {
      "indent": 3,
      "text": "[RFC1951] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, DOI 10.17487/RFC1951, May 1996, <https://www.rfc-editor.org/info/rfc1951>.",
      "ja": "[RFC1951] Deutsch、P。、「圧縮データ形式の仕様バージョン1.3」、RFC 1951、DOI 10.17487/RFC1951、1996年5月、<https://www.rfc-editor.org/info/rfc1951>。"
    },
    {
      "indent": 3,
      "text": "[RFC1952] Deutsch, P., \"GZIP file format specification version 4.3\", RFC 1952, DOI 10.17487/RFC1952, May 1996, <https://www.rfc-editor.org/info/rfc1952>.",
      "ja": "[RFC1952] Deutsch、P。、「GZIPファイル形式の仕様バージョン4.3」、RFC 1952、DOI 10.17487/RFC1952、1996年5月、<https://www.rfc-editor.org/info/rfc1952>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <https://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234] Crocker、D.、ed。P. Overell、「構文仕様のためのBNFの増強：ABNF：STD 68、RFC 5234、DOI 10.17487/RFC5234、2008年1月、<https://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7405] Kyzivat, P., \"Case-Sensitive String Support in ABNF\", RFC 7405, DOI 10.17487/RFC7405, December 2014, <https://www.rfc-editor.org/info/rfc7405>.",
      "ja": "[RFC7405] Kyzivat、P。、「ABNFでのケースセンシティブストリングサポート」、RFC 7405、DOI 10.17487/RFC7405、2014年12月、<https://www.rfc-editor.org/info/rfc7405>"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[TLS13] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[TLS13] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc846>"
    },
    {
      "indent": 3,
      "text": "[URI] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[URI] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、Std 66、RFC 3986、DOI 10.17487/RFC3986、2005年1月、<https：//www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[USASCII] American National Standards Institute, \"Coded Character Set -- 7-bit American Standard Code for Information Interchange\", ANSI X3.4, 1986.",
      "ja": "[USASCII] American National Standards Institute、「コード化された文字セット - 情報交換のための7ビットアメリカ標準コード」、ANSI X3.4、1986。"
    },
    {
      "indent": 3,
      "text": "[Welch] Welch, T., \"A Technique for High-Performance Data Compression\", IEEE Computer 17(6), DOI 10.1109/MC.1984.1659158, June 1984, <https://ieeexplore.ieee.org/document/1659158/>.",
      "ja": "[ウェルチ]ウェルチ、T。、「高性能データ圧縮の手法」、IEEEコンピューター17（6）、DOI 10.1109/MC.1984.1659158、1984年6月、<https://ieeexplore.ieee.org/document/165915888/>。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[HTTP/1.0] Berners-Lee, T., Fielding, R., and H. Frystyk, \"Hypertext Transfer Protocol -- HTTP/1.0\", RFC 1945, DOI 10.17487/RFC1945, May 1996, <https://www.rfc-editor.org/info/rfc1945>.",
      "ja": "[HTTP/1.0] Berners-Lee、T.、Fielding、R。、およびH. Frystyk、「HyperText Transfer Protocol-HTTP/1.0」、RFC 1945、DOI 10.17487/RFC1945、1996年5月、<https：// wwwwwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc1945>。"
    },
    {
      "indent": 3,
      "text": "[Klein] Klein, A., \"Divide and Conquer - HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics\", March 2004, <https://packetstormsecurity.com/papers/general/ whitepaper_httpresponse.pdf>.",
      "ja": "[クライン]クライン、A。、「分割と征服-HTTP応答分割、Webキャッシュ中毒攻撃、および関連トピック」、2004年3月<https://packetstormsecurity.com/papers/general/ whitepaper_httpresponse.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Linhart] Linhart, C., Klein, A., Heled, R., and S. Orrin, \"HTTP Request Smuggling\", June 2005, <https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf>.",
      "ja": "[Linhart] Linhart、C.、Klein、A.、Heled、R。、およびS. Orrin、「HTTP Request Smuggling」、2005年6月、<https://www.cgisecurity.com/lib/http-request-smuggling.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, DOI 10.17487/RFC2045, November 1996, <https://www.rfc-editor.org/info/rfc2045>.",
      "ja": "[RFC2045] Freed、N。およびN. Borenstein、「多目的インターネットメール拡張機能（MIME）パート1：インターネットメッセージボディの形式」、RFC 2045、DOI 10.17487/RFC2045、1996年11月、<https：//www.rfc-editor.org/info/rfc2045>。"
    },
    {
      "indent": 3,
      "text": "[RFC2046] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\", RFC 2046, DOI 10.17487/RFC2046, November 1996, <https://www.rfc-editor.org/info/rfc2046>.",
      "ja": "[RFC2046] Freed、N。およびN. Borenstein、「多目的インターネットメール拡張機能（MIME）パート2：メディアタイプ」、RFC 2046、DOI 10.17487/RFC2046、1996年11月、<https://www.rfc-editor.orgg/info/rfc2046>。"
    },
    {
      "indent": 3,
      "text": "[RFC2049] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples\", RFC 2049, DOI 10.17487/RFC2049, November 1996, <https://www.rfc-editor.org/info/rfc2049>.",
      "ja": "[RFC2049] Freed、N。and N. Borenstein、「多目的インターネットメール拡張機能（MIME）パート5：適合基準と例」、RFC 2049、DOI 10.17487/RFC2049、1996年11月、<https：//www.rfc-editor.org/info/rfc2049>。"
    },
    {
      "indent": 3,
      "text": "[RFC2068] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2068, DOI 10.17487/RFC2068, January 1997, <https://www.rfc-editor.org/info/rfc2068>.",
      "ja": "[RFC2068] Fielding、R.、Gettys、J.、Mogul、J.、Frystyk、H。、およびT. Berners-Lee、 \"HyperText Transfer Protocol-HTTP/1.1\"、RFC 2068、DOI 10.17487/RFC2068、1月1997、<https://www.rfc-editor.org/info/rfc2068>。"
    },
    {
      "indent": 3,
      "text": "[RFC2557] Palme, J., Hopmann, A., and N. Shelness, \"MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)\", RFC 2557, DOI 10.17487/RFC2557, March 1999, <https://www.rfc-editor.org/info/rfc2557>.",
      "ja": "[RFC2557] Palme、J.、Hopmann、A。、およびN. Shelness、「HTML（MHTML）などの集計文書のMIMEカプセル化」、RFC 2557、DOI 10.17487/RFC2557、1999年3月、<HTTPS：//.rfc-editor.org/info/rfc2557>。"
    },
    {
      "indent": 3,
      "text": "[RFC5322] Resnick, P., Ed., \"Internet Message Format\", RFC 5322, DOI 10.17487/RFC5322, October 2008, <https://www.rfc-editor.org/info/rfc5322>.",
      "ja": "[RFC5322] Resnick、P.、ed。、「インターネットメッセージフォーマット」、RFC 5322、DOI 10.17487/RFC5322、2008年10月、<https://www.rfc-editor.org/info/rfc5321。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <https://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230] Fielding、R.、ed。and J. Reschke、ed。、「HyperText Transfer Protocol（HTTP/1.1）：メッセージの構文とルーティング」、RFC 7230、DOI 10.17487/RFC7230、2014年6月、<https://www.rfc-editor.org/info/RFC7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487/RFC8126、2017年6月、<https：// wwwwwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc8126>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Collected ABNF",
      "section_title": true,
      "ja": "付録A. ABNFを収集しました"
    },
    {
      "indent": 3,
      "text": "In the collected ABNF below, list rules are expanded per Section 5.6.1 of [HTTP].",
      "ja": "以下の収集されたABNFでは、[HTTP]のセクション5.6.1ごとにリストルールが拡張されています。"
    },
    {
      "indent": 3,
      "text": "BWS = <BWS, see [HTTP], Section 5.6.3>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HTTP-message = start-line CRLF *( field-line CRLF ) CRLF [\n message-body ]\nHTTP-name = %x48.54.54.50 ; HTTP\nHTTP-version = HTTP-name \"/\" DIGIT \".\" DIGIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OWS = <OWS, see [HTTP], Section 5.6.3>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RWS = <RWS, see [HTTP], Section 5.6.3>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding = [ transfer-coding *( OWS \",\" OWS transfer-coding\n ) ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "absolute-URI = <absolute-URI, see [URI], Section 4.3>\nabsolute-form = absolute-URI\nabsolute-path = <absolute-path, see [HTTP], Section 4.1>\nasterisk-form = \"*\"\nauthority = <authority, see [URI], Section 3.2>\nauthority-form = uri-host \":\" port",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF\nchunk-data = 1*OCTET\nchunk-ext = *( BWS \";\" BWS chunk-ext-name [ BWS \"=\" BWS chunk-ext-val\n ] )\nchunk-ext-name = token\nchunk-ext-val = token / quoted-string\nchunk-size = 1*HEXDIG\nchunked-body = *chunk last-chunk trailer-section CRLF",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "field-line = field-name \":\" OWS field-value OWS\nfield-name = <field-name, see [HTTP], Section 5.1>\nfield-value = <field-value, see [HTTP], Section 5.5>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "last-chunk = 1*\"0\" [ chunk-ext ] CRLF",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "message-body = *OCTET\nmethod = token",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "obs-fold = OWS CRLF RWS\nobs-text = <obs-text, see [HTTP], Section 5.6.4>\norigin-form = absolute-path [ \"?\" query ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "port = <port, see [URI], Section 3.2.3>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "query = <query, see [URI], Section 3.4>\nquoted-string = <quoted-string, see [HTTP], Section 5.6.4>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "reason-phrase = 1*( HTAB / SP / VCHAR / obs-text )\nrequest-line = method SP request-target SP HTTP-version\nrequest-target = origin-form / absolute-form / authority-form /\n asterisk-form",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "start-line = request-line / status-line status-code = 3DIGIT status-line = HTTP-version SP status-code SP [ reason-phrase ]",
      "ja": "start-line = request-line / status-line status-code = 3DIGIT status-line = HTTP-version SP status-code SP [ reason-phrase ]"
    },
    {
      "indent": 3,
      "text": "token = <token, see [HTTP], Section 5.6.2>\ntrailer-section = *( field-line CRLF )\ntransfer-coding = <transfer-coding, see [HTTP], Section 10.1.4>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uri-host = <host, see [URI], Section 3.2.2>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Differences between HTTP and MIME",
      "section_title": true,
      "ja": "付録B. HTTPとMIMEの違い"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 uses many of the constructs defined for the Internet Message Format [RFC5322] and Multipurpose Internet Mail Extensions (MIME) [RFC2045] to allow a message body to be transmitted in an open variety of representations and with extensible fields. However, some of these constructs have been reinterpreted to better fit the needs of interactive communication, leading to some differences in how MIME constructs are used within HTTP. These differences were carefully chosen to optimize performance over binary connections, allow greater freedom in the use of new media types, ease date comparisons, and accommodate common implementations.",
      "ja": "HTTP/1.1は、インターネットメッセージ形式[RFC5322]および多目的インターネットメールエクステンション（MIME）[RFC2045]で定義された多くのコンストラクトを使用して、メッセージ本文をオープンなさまざまな表現と拡張可能なフィールドで送信できるようにします。ただし、これらのコンストラクトのいくつかは、インタラクティブなコミュニケーションのニーズに合わせてより適切に適合するように再解釈されており、HTTP内でMIMEコンストラクトがどのように使用されるかにいくつかの違いにつながります。これらの違いは、バイナリ接続のパフォーマンスを最適化し、新しいメディアタイプの使用の自由度を高め、日付の比較を容易にし、一般的な実装に対応するために慎重に選択されました。"
    },
    {
      "indent": 3,
      "text": "This appendix describes specific areas where HTTP differs from MIME. Proxies and gateways to and from strict MIME environments need to be aware of these differences and provide the appropriate conversions where necessary.",
      "ja": "この付録では、HTTPがMIMEと異なる特定の領域について説明しています。厳格なマイム環境との間でのプロキシとゲートウェイは、これらの違いを認識し、必要に応じて適切な変換を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "B.1. MIME-Version",
      "section_title": true,
      "ja": "B.1. mime-version"
    },
    {
      "indent": 3,
      "text": "HTTP is not a MIME-compliant protocol. However, messages can include a single MIME-Version header field to indicate what version of the MIME protocol was used to construct the message. Use of the MIME-Version header field indicates that the message is in full conformance with the MIME protocol (as defined in [RFC2045]). Senders are responsible for ensuring full conformance (where possible) when exporting HTTP messages to strict MIME environments.",
      "ja": "HTTPはMIME準拠のプロトコルではありません。ただし、メッセージには、メッセージの構築に使用されたMIMEプロトコルのバージョンを示すために、単一のMime-versionヘッダーフィールドを含めることができます。Mime-versionヘッダーフィールドの使用は、メッセージがmimeプロトコルに完全に適合していることを示しています（[RFC2045]で定義されています）。送信者は、HTTPメッセージを厳格なMIME環境にエクスポートするときに（可能な場合）、完全な適合性を確保する責任があります。"
    },
    {
      "indent": 0,
      "text": "B.2. Conversion to Canonical Form",
      "section_title": true,
      "ja": "B.2. 標準形式への変換"
    },
    {
      "indent": 3,
      "text": "MIME requires that an Internet mail body part be converted to canonical form prior to being transferred, as described in Section 4 of [RFC2049], and that content with a type of \"text\" represents line breaks as CRLF, forbidding the use of CR or LF outside of line break sequences [RFC2046]. In contrast, HTTP does not care whether CRLF, bare CR, or bare LF are used to indicate a line break within content.",
      "ja": "MIMEでは、[RFC2049]のセクション4で説明されているように、転送される前にインターネットメールボディの部分を標準形式に変換する必要があり、「テキスト」の種類を持つコンテンツは、CRLFとしての線切断を表し、CRまたはCRの使用を禁止することを必要とします。ラインブレイクシーケンスの外側のLF [RFC2046]。対照的に、HTTPは、CRLF、Bare CR、またはBare LFがコンテンツ内のラインブレイクを示すために使用されるかどうかを気にしません。"
    },
    {
      "indent": 3,
      "text": "A proxy or gateway from HTTP to a strict MIME environment ought to translate all line breaks within text media types to the RFC 2049 canonical form of CRLF. Note, however, this might be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some charsets that do not use octets 13 and 10 to represent CR and LF, respectively.",
      "ja": "HTTPから厳格なMIME環境へのプロキシまたはゲートウェイは、テキストメディアタイプ内のすべてのラインブレークをRFC 2049 CRLF形式に変換する必要があります。ただし、これは、コンテンツエンコードの存在と、HTTPがそれぞれCRとLFを表すためにオクテット13と10を使用しない一部の充電器を使用できるという事実によって複雑になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Conversion will break any cryptographic checksums applied to the original content unless the original content is already in canonical form. Therefore, the canonical form is recommended for any content that uses such checksums in HTTP.",
      "ja": "コンバージョンは、元のコンテンツがすでに標準的な形式でない限り、元のコンテンツに適用される暗号化チェックサムを破壊します。したがって、HTTPでそのようなチェックサムを使用するコンテンツには、標準形式が推奨されます。"
    },
    {
      "indent": 0,
      "text": "B.3. Conversion of Date Formats",
      "section_title": true,
      "ja": "B.3. 日付形式の変換"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 uses a restricted set of date formats (Section 5.6.7 of [HTTP]) to simplify the process of date comparison. Proxies and gateways from other protocols ought to ensure that any Date header field present in a message conforms to one of the HTTP/1.1 formats and rewrite the date if necessary.",
      "ja": "HTTP/1.1は、日付の比較のプロセスを簡素化するために、制限付き日付形式（[HTTP]のセクション5.6.7）を使用します。他のプロトコルからのプロキシとゲートウェイは、メッセージに存在する日付ヘッダーフィールドがHTTP/1.1形式のいずれかに適合し、必要に応じて日付を書き換えることを保証する必要があります。"
    },
    {
      "indent": 0,
      "text": "B.4. Conversion of Content-Encoding",
      "section_title": true,
      "ja": "B.4. コンテンツエンコードの変換"
    },
    {
      "indent": 3,
      "text": "MIME does not include any concept equivalent to HTTP's Content-Encoding header field. Since this acts as a modifier on the media type, proxies and gateways from HTTP to MIME-compliant protocols ought to either change the value of the Content-Type header field or decode the representation before forwarding the message. (Some experimental applications of Content-Type for Internet mail have used a media-type parameter of \";conversions=<content-coding>\" to perform a function equivalent to Content-Encoding. However, this parameter is not part of the MIME standards.)",
      "ja": "MIMEには、HTTPのコンテンツエンコードヘッダーフィールドに相当するコンセプトは含まれていません。これはメディアタイプの修飾子として機能するため、HTTPからMIMEに準拠したプロトコルへのプロキシとゲートウェイは、メッセージを転送する前にコンテンツタイプのヘッダーフィールドの値を変更するか、表現をデコードする必要があります。（インターネットメールのコンテンツタイプのいくつかの実験的アプリケーションでは、 \"; conventions = <content-coding>\"のメディアタイプのパラメーターを使用して、コンテンツエンコードに相当する関数を実行しました。ただし、このパラメーターはMIME標準の一部ではありません。。）"
    },
    {
      "indent": 0,
      "text": "B.5. Conversion of Content-Transfer-Encoding",
      "section_title": true,
      "ja": "B.5. コンテンツ移動エンコードの変換"
    },
    {
      "indent": 3,
      "text": "HTTP does not use the Content-Transfer-Encoding field of MIME. Proxies and gateways from MIME-compliant protocols to HTTP need to remove any Content-Transfer-Encoding prior to delivering the response message to an HTTP client.",
      "ja": "HTTPは、MIMEのコンテンツ転移エンコードフィールドを使用しません。MIMEに準拠したプロトコルからHTTPまでのプロキシとゲートウェイは、HTTPクライアントに応答メッセージを配信する前に、コンテンツ転移エンコードを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where \"safe transport\" is defined by the limitations of the protocol being used. Such a proxy or gateway ought to transform and label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.",
      "ja": "HTTPからMIMEに準拠したプロトコルへのプロキシとゲートウェイは、メッセージが正しい形式であることを保証し、そのプロトコルの安全な輸送のためのエンコードであり、「安全な輸送」が使用されているプロトコルの制限によって定義されます。このようなプロキシまたはゲートウェイは、適切なコンテンツトランスファーエンコードでデータを変換およびラベル付けする必要があります。"
    },
    {
      "indent": 0,
      "text": "B.6. MHTML and Line Length Limitations",
      "section_title": true,
      "ja": "B.6. MHTMLおよびラインの長さの制限"
    },
    {
      "indent": 3,
      "text": "HTTP implementations that share code with MHTML [RFC2557] implementations need to be aware of MIME line length limitations. Since HTTP does not have this limitation, HTTP does not fold long lines. MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations and folding, canonicalization, etc., since HTTP transfers message-bodies without modification and, aside from the \"multipart/byteranges\" type (Section 14.6 of [HTTP]), does not interpret the content or any MIME header lines that might be contained therein.",
      "ja": "MHTML [RFC2557]とコードを共有するHTTP実装は、MIME行の長さの制限を認識する必要があります。HTTPにはこの制限がないため、HTTPは長い行を折りません。HTTPによって転送されるMHTMLメッセージは、行の長さの制限と折り畳み、正規化などを含むMHTMLのすべての規則に従います。これは、HTTPはメッセージ本文を変更せずに転送し、「multipart/byteranges」タイプ（[HTTP]のセクション14.6）を除いて、その中に含まれる可能性のあるコンテンツやMIMEヘッダー行を解釈しないためです。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Changes from Previous RFCs",
      "section_title": true,
      "ja": "付録C.以前のRFCからの変更"
    },
    {
      "indent": 0,
      "text": "C.1. Changes from HTTP/0.9",
      "section_title": true,
      "ja": "C.1. HTTP/0.9からの変更"
    },
    {
      "indent": 3,
      "text": "Since HTTP/0.9 did not support header fields in a request, there is no mechanism for it to support name-based virtual hosts (selection of resource by inspection of the Host header field). Any server that implements name-based virtual hosts ought to disable support for HTTP/0.9. Most requests that appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x requests caused by a client failing to properly encode the request-target.",
      "ja": "HTTP/0.9はリクエストでヘッダーフィールドをサポートしていなかったため、名前ベースの仮想ホスト（ホストヘッダーフィールドの検査によるリソースの選択）をサポートするメカニズムはありません。名前ベースの仮想ホストを実装するサーバーは、HTTP/0.9のサポートを無効にする必要があります。HTTP/0.9のように見えるほとんどのリクエストは、実際には、クライアントがリクエストターゲットを適切にエンコードしないことによって引き起こされるひどく構築されたHTTP/1.x要求です。"
    },
    {
      "indent": 0,
      "text": "C.2. Changes from HTTP/1.0",
      "section_title": true,
      "ja": "C.2. HTTP/1.0からの変更"
    },
    {
      "indent": 0,
      "text": "C.2.1. Multihomed Web Servers",
      "section_title": true,
      "ja": "C.2.1. マルチホームWebサーバー"
    },
    {
      "indent": 3,
      "text": "The requirements that clients and servers support the Host header field (Section 7.2 of [HTTP]), report an error if it is missing from an HTTP/1.1 request, and accept absolute URIs (Section 3.2) are among the most important changes defined by HTTP/1.1.",
      "ja": "クライアントとサーバーがHostヘッダーフィールド（[HTTP]のセクション7.2）をサポートし、HTTP/1.1リクエストから欠落している場合にエラーを報告し、絶対URI（セクション3.2）を受け入れるという要件は、HTTP/1.1で定義された最も重要な変更の1つです。"
    },
    {
      "indent": 3,
      "text": "Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no established mechanism for distinguishing the intended server of a request other than the IP address to which that request was directed. The Host header field was introduced during the development of HTTP/1.1 and, though it was quickly implemented by most HTTP/1.0 browsers, additional requirements were placed on all HTTP/1.1 requests in order to ensure complete adoption. At the time of this writing, most HTTP-based services are dependent upon the Host header field for targeting requests.",
      "ja": "古いHTTP/1.0クライアントは、IPアドレスとサーバーの1対1の関係を想定していました。その要求が指示されたIPアドレス以外の要求の意図したサーバーを区別するための確立されたメカニズムはありませんでした。ホストヘッダーフィールドはHTTP/1.1の開発中に導入され、ほとんどのHTTP/1.0ブラウザによって迅速に実装されましたが、完全な採用を確実にするためにすべてのHTTP/1.1要求に追加要件が配置されました。この執筆時点では、ほとんどのHTTPベースのサービスは、リクエストをターゲットにするためのホストヘッダーフィールドに依存しています。"
    },
    {
      "indent": 0,
      "text": "C.2.2. Keep-Alive Connections",
      "section_title": true,
      "ja": "C.2.2. アリブな接続を維持します"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response. However, some implementations implement the explicitly negotiated (\"Keep-Alive\") version of persistent connections described in Section 19.7.1 of [RFC2068].",
      "ja": "HTTP/1.0では、各接続はリクエストの前にクライアントによって確立され、応答を送信した後にサーバーによって閉じられます。ただし、一部の実装は、[RFC2068]のセクション19.7.1で説明されている永続的な接続の明示的にネゴシエートされた（「キープアライブ」）バージョンを実装しています。"
    },
    {
      "indent": 3,
      "text": "Some clients and servers might wish to be compatible with these previous approaches to persistent connections, by explicitly negotiating for them with a \"Connection: keep-alive\" request header field. However, some experimental implementations of HTTP/1.0 persistent connections are faulty; for example, if an HTTP/1.0 proxy server doesn't understand Connection, it will erroneously forward that header field to the next inbound server, which would result in a hung connection.",
      "ja": "一部のクライアントとサーバーは、「接続：キープアライブ」リクエストヘッダーフィールドで明示的に交渉することにより、永続的な接続に対するこれらの以前のアプローチと互換性があることを望む場合があります。ただし、HTTP/1.0の永続的な接続のいくつかの実験的実装に故障しています。たとえば、HTTP/1.0プロキシサーバーが接続を理解していない場合、そのヘッダーフィールドが次のインバウンドサーバーに誤って転送されると、接続が吊り下がります。"
    },
    {
      "indent": 3,
      "text": "One attempted solution was the introduction of a Proxy-Connection header field, targeted specifically at proxies. In practice, this was also unworkable, because proxies are often deployed in multiple layers, bringing about the same problem discussed above.",
      "ja": "解決策の1つは、特にプロキシをターゲットとするプロキシ接続ヘッダーフィールドの導入でした。実際には、これも実行できませんでした。なぜなら、プロキシはしばしば複数の層に展開され、上記の同じ問題をもたらすからです。"
    },
    {
      "indent": 3,
      "text": "As a result, clients are encouraged not to send the Proxy-Connection header field in any requests.",
      "ja": "その結果、クライアントは、どのリクエストでもプロキシ接続ヘッダーフィールドを送信しないことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Clients are also encouraged to consider the use of \"Connection: keep-alive\" in requests carefully; while they can enable persistent connections with HTTP/1.0 servers, clients using them will need to monitor the connection for \"hung\" requests (which indicate that the client ought to stop sending the header field), and this mechanism ought not be used by clients at all when a proxy is being used.",
      "ja": "また、クライアントは、リクエストで「接続：維持」の使用を慎重に検討することも奨励されています。HTTP/1.0サーバーとの永続的な接続を有効にすることはできますが、クライアントを使用するクライアントは、「HUNG」要求の接続を監視する必要があります（クライアントがヘッダーフィールドの送信を停止する必要があることを示します）。プロキシが使用されている場合。"
    },
    {
      "indent": 0,
      "text": "C.2.3. Introduction of Transfer-Encoding",
      "section_title": true,
      "ja": "C.2.3. 転送エンコードの導入"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 introduces the Transfer-Encoding header field (Section 6.1). Transfer codings need to be decoded prior to forwarding an HTTP message over a MIME-compliant protocol.",
      "ja": "HTTP/1.1では、転送エンコードヘッダーフィールドを導入します（セクション6.1）。MIMEに準拠したプロトコルを介してHTTPメッセージを転送する前に、転送コーディングをデコードする必要があります。"
    },
    {
      "indent": 0,
      "text": "C.3. Changes from RFC 7230",
      "section_title": true,
      "ja": "C.3. RFC 7230からの変更"
    },
    {
      "indent": 3,
      "text": "Most of the sections introducing HTTP's design goals, history, architecture, conformance criteria, protocol versioning, URIs, message routing, and header fields have been moved to [HTTP]. This document has been reduced to just the messaging syntax and connection management requirements specific to HTTP/1.1.",
      "ja": "HTTPの設計目標、履歴、アーキテクチャ、適合基準、プロトコルバージョン、URIS、メッセージルーティング、ヘッダーフィールドを導入するセクションのほとんどが[HTTP]に移動されました。このドキュメントは、HTTP/1.1に固有のメッセージング構文と接続管理要件のみに削減されました。"
    },
    {
      "indent": 3,
      "text": "Bare CRs have been prohibited outside of content. (Section 2.2)",
      "ja": "裸のCRSはコンテンツ以外で禁止されています。（セクション2.2）"
    },
    {
      "indent": 3,
      "text": "The ABNF definition of authority-form has changed from the more general authority component of a URI (in which port is optional) to the specific host:port format that is required by CONNECT. (Section 3.2.3)",
      "ja": "権限形式のABNF定義は、URIのより一般的な権限コンポーネント（ポートがオプション）から特定のホスト：Connectが必要とするポート形式に変更されました。（セクション3.2.3）"
    },
    {
      "indent": 3,
      "text": "Recipients are required to avoid smuggling/splitting attacks when processing an ambiguous message framing. (Section 6.1)",
      "ja": "曖昧なメッセージフレーミングを処理する際に、密輸/分割攻撃を避ける必要があります。（セクション6.1）"
    },
    {
      "indent": 3,
      "text": "In the ABNF for chunked extensions, (bad) whitespace around \";\" and \"=\" has been reintroduced. Whitespace was removed in [RFC7230], but that change was found to break existing implementations. (Section 7.1.1)",
      "ja": "chunked拡張のABNFにおいて、「;」および「=」の周囲の（悪い）空白が再導入されました。空白は[RFC7230]で削除されましたが、その変更は既存の実装を壊すことが判明しました。（セクション7.1.1）"
    },
    {
      "indent": 3,
      "text": "Trailer field semantics now transcend the specifics of chunked transfer coding. The decoding algorithm for chunked (Section 7.1.3) has been updated to encourage storage/forwarding of trailer fields separately from the header section, to only allow merging into the header section if the recipient knows the corresponding field definition permits and defines how to merge, and otherwise to discard the trailer fields instead of merging. The trailer part is now called the trailer section to be more consistent with the header section and more distinct from a body part. (Section 7.1.2)",
      "ja": "トレーラーフィールドセマンティクスは、チャンク転送コーディングの詳細を超越しました。チャンクされたデコードアルゴリズム（セクション7.1.3）は、ヘッダーセクションとは別にトレーラーフィールドのストレージ/転送を促進するために更新されました。、およびマージする代わりにトレーラーフィールドを破棄するため。トレーラーの部分は、ヘッダーセクションとより一貫性があり、身体部分とより明確になるように、トレーラーセクションと呼ばれます。（セクション7.1.2）"
    },
    {
      "indent": 3,
      "text": "Transfer coding parameters called \"q\" are disallowed in order to avoid conflicts with the use of ranks in the TE header field. (Section 7.3)",
      "ja": "「Q」と呼ばれる転送コーディングパラメーターは、TEヘッダーフィールドでのランクの使用との競合を回避するために禁止されています。（セクション7.3）"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "See Appendix \"Acknowledgements\" of [HTTP], which applies to this document as well.",
      "ja": "[http]の付録「謝辞」を参照してください。これはこのドキュメントにも適用されます。"
    },
    {
      "indent": 0,
      "text": "Index",
      "ja": "索引"
    },
    {
      "indent": 3,
      "text": "A C D F G H M O R T X",
      "ja": "A C D F G H M O R T X"
    },
    {
      "indent": 6,
      "text": "A",
      "ja": "A"
    },
    {
      "indent": 9,
      "text": "absolute-form (of request-target) Section 3.2.2 application/http Media Type *_Section 10.2_* asterisk-form (of request-target) Section 3.2.4 authority-form (of request-target) Section 3.2.3",
      "ja": "absolute-form（request-targetの） セクション3.2.2 application/http メディアタイプ *_Section 10.2_* asterisk-form（request-targetの） セクション3.2.4 authority-form（request-targetの） セクション3.2.3"
    },
    {
      "indent": 6,
      "text": "C",
      "ja": "C"
    },
    {
      "indent": 9,
      "text": "chunked (Coding Format)  Section 6.1; Section 6.3\nchunked (transfer coding)  *_Section 7.1_*\nclose  Section 9.3; *_Section 9.6_*\ncompress (transfer coding)  *_Section 7.2_*\nConnection header field  Section 9.6\nContent-Length header field  Section 6.2\nContent-Transfer-Encoding header field  Appendix B.5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "D",
      "ja": "D"
    },
    {
      "indent": 9,
      "text": "deflate (transfer coding) *_Section 7.2_*",
      "ja": "Deflate（転送コーディング） *_Section 7.2_ *"
    },
    {
      "indent": 6,
      "text": "F",
      "ja": "F"
    },
    {
      "indent": 9,
      "text": "Fields\n   Close  *_Section 9.6, Paragraph 4_*\n   MIME-Version  *_Appendix B.1_*\n   Transfer-Encoding  *_Section 6.1_*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "G",
      "ja": "G"
    },
    {
      "indent": 9,
      "text": "Grammar\n   ALPHA  *_Section 1.2_*\n   CR  *_Section 1.2_*\n   CRLF  *_Section 1.2_*\n   CTL  *_Section 1.2_*\n   DIGIT  *_Section 1.2_*\n   DQUOTE  *_Section 1.2_*\n   HEXDIG  *_Section 1.2_*\n   HTAB  *_Section 1.2_*\n   HTTP-message  *_Section 2.1_*\n   HTTP-name  *_Section 2.3_*\n   HTTP-version  *_Section 2.3_*\n   LF  *_Section 1.2_*\n   OCTET  *_Section 1.2_*\n   SP  *_Section 1.2_*\n   Transfer-Encoding  *_Section 6.1_*\n   VCHAR  *_Section 1.2_*\n   absolute-form  Section 3.2; *_Section 3.2.2_*\n   asterisk-form  Section 3.2; *_Section 3.2.4_*\n   authority-form  Section 3.2; *_Section 3.2.3_*\n   chunk  *_Section 7.1_*\n   chunk-data  *_Section 7.1_*\n   chunk-ext  Section 7.1; *_Section 7.1.1_*\n   chunk-ext-name  *_Section 7.1.1_*\n   chunk-ext-val  *_Section 7.1.1_*\n   chunk-size  *_Section 7.1_*\n   chunked-body  *_Section 7.1_*\n   field-line  *_Section 5_*; Section 7.1.2\n   field-name  Section 5\n   field-value  Section 5\n   last-chunk  *_Section 7.1_*\n   message-body  *_Section 6_*\n   method  *_Section 3.1_*\n   obs-fold  *_Section 5.2_*\n   origin-form  Section 3.2; *_Section 3.2.1_*\n   reason-phrase  *_Section 4_*\n   request-line  *_Section 3_*\n   request-target  *_Section 3.2_*\n   start-line  *_Section 2.1_*\n   status-code  *_Section 4_*\n   status-line  *_Section 4_*\n   trailer-section  Section 7.1; *_Section 7.1.2_*\ngzip (transfer coding)  *_Section 7.2_*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "H",
      "ja": "H"
    },
    {
      "indent": 9,
      "text": "Header Fields MIME-Version *_Appendix B.1_* Transfer-Encoding *_Section 6.1_* header line Section 2.1 header section Section 2.1 headers Section 2.1",
      "ja": "Header Fields MIME-Version *_Appendix B.1_* Transfer-Encoding *_Section 6.1_* header line セクション2.1 header section セクション2.1 headers セクション2.1"
    },
    {
      "indent": 6,
      "text": "M",
      "ja": "M"
    },
    {
      "indent": 9,
      "text": "Media Type\n   application/http  *_Section 10.2_*\n   message/http  *_Section 10.1_*\nmessage/http Media Type  *_Section 10.1_*\nmethod  *_Section 3.1_*\nMIME-Version header field  *_Appendix B.1_*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "O",
      "ja": "O"
    },
    {
      "indent": 9,
      "text": "origin-form (of request-target) Section 3.2.1",
      "ja": "origin-form（request-targetの） セクション3.2.1"
    },
    {
      "indent": 6,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 9,
      "text": "request-target *_Section 3.2_*",
      "ja": "request-target *_Section 3.2_*"
    },
    {
      "indent": 6,
      "text": "T",
      "ja": "T"
    },
    {
      "indent": 9,
      "text": "Transfer-Encoding header field *_Section 6.1_*",
      "ja": "Transfer-Encoding header field *_Section 6.1_*"
    },
    {
      "indent": 6,
      "text": "X",
      "ja": "X"
    },
    {
      "indent": 9,
      "text": "x-compress (transfer coding)  *_Section 7.2_*\nx-gzip (transfer coding)  *_Section 7.2_*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding (editor) Adobe 345 Park Ave San Jose, CA 95110 United States of America Email: fielding@gbiv.com URI: https://roy.gbiv.com/",
      "ja": "Roy T. Fielding（編集者）Adobe 345 Park Ave San Jose、CA 95110アメリカ合衆国電子メール：Fielding@gbiv.com URI：https：//roy.gbiv.com/"
    },
    {
      "indent": 3,
      "text": "Mark Nottingham (editor) Fastly Prahran Australia Email: mnot@mnot.net URI: https://www.mnot.net/",
      "ja": "マーク・ノッティンガム（編集者）急速にPrahran Australiaメール：mnot@mnot.net uri：https：//www.mnot.net/"
    },
    {
      "indent": 3,
      "text": "Julian Reschke (editor)\ngreenbytes GmbH\nHafenweg 16\n48155 Münster\nGermany\nEmail: julian.reschke@greenbytes.de\nURI:   https://greenbytes.de/tech/webdav/",
      "raw": true,
      "ja": ""
    }
  ]
}