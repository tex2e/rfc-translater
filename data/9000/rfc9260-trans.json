{
  "title": {
    "text": "RFC 9260 - Stream Control Transmission Protocol (RFC 9260)",
    "ja": "RFC 9260 - ストリーム制御伝送プロトコル（RFC 9260）"
  },
  "number": 9260,
  "created_at": "2022-06-06 03:00:04.000096+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        R. Stewart\nRequest for Comments: 9260                                 Netflix, Inc.\nObsoletes: 4460, 4960, 6096, 7053, 8540                         M. Tüxen\nCategory: Standards Track                Münster Univ. of Appl. Sciences\nISSN: 2070-1721                                               K. Nielsen\n                                                            Kamstrup A/S\n                                                               June 2022",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Stream Control Transmission Protocol",
      "ja": "ストリーム制御伝送プロトコル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Stream Control Transmission Protocol (SCTP) and obsoletes RFC 4960. It incorporates the specification of the chunk flags registry from RFC 6096 and the specification of the I bit of DATA chunks from RFC 7053. Therefore, RFCs 6096 and 7053 are also obsoleted by this document. In addition, RFCs 4460 and 8540, which describe errata for SCTP, are obsoleted by this document.",
      "ja": "このドキュメントでは、ストリーム制御伝送プロトコル（SCTP）とobutoletes RFC 4960について説明します。RFC6096のチャンクフラグレジストリの仕様と、RFC 7053のIビットデータチャンクの仕様を組み込んでいます。したがって、RFCS 6096および7053はまた、このドキュメントで廃止されました。さらに、SCTPのERRATAを記述するRFCS 4460および8540は、このドキュメントによって廃止されています。"
    },
    {
      "indent": 3,
      "text": "SCTP was originally designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks. It is also suited to be used for other applications, for example, WebRTC.",
      "ja": "SCTPはもともと、IPネットワークを介して公開された電話ネットワーク（PSTN）シグナリングメッセージを輸送するように設計されていました。また、他のアプリケーション、たとえばWebrtcに使用するのにも適しています。"
    },
    {
      "indent": 3,
      "text": "SCTP is a reliable transport protocol operating on top of a connectionless packet network, such as IP. It offers the following services to its users:",
      "ja": "SCTPは、IPなどのConnectionless Packetネットワークの上で動作する信頼性の高いトランスポートプロトコルです。次のサービスをユーザーに提供します。"
    },
    {
      "indent": 3,
      "text": "* acknowledged error-free, non-duplicated transfer of user data,",
      "ja": "* 認知されているエラーのない、非重複していないユーザーデータの転送、"
    },
    {
      "indent": 3,
      "text": "* data fragmentation to conform to discovered Path Maximum Transmission Unit (PMTU) size,",
      "ja": "* 発見されたパス最大透過ユニット（PMTU）サイズに準拠するためのデータ断片化、"
    },
    {
      "indent": 3,
      "text": "* sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages,",
      "ja": "* 個々のユーザーメッセージの順序付け注文のオプションを備えた複数のストリーム内のユーザーメッセージのシーケンスの配信、"
    },
    {
      "indent": 3,
      "text": "* optional bundling of multiple user messages into a single SCTP packet, and",
      "ja": "* 複数のユーザーメッセージを単一のSCTPパケットにバンドリングするオプション、および"
    },
    {
      "indent": 3,
      "text": "* network-level fault tolerance through supporting of multi-homing at either or both ends of an association.",
      "ja": "* 関連性のいずれかまたは両端でのマルチホミングをサポートすることによるネットワークレベルの断層トレランス。"
    },
    {
      "indent": 3,
      "text": "The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks.",
      "ja": "SCTPの設計には、適切な混雑回避行動と洪水および仮面舞踏会攻撃に対する抵抗が含まれます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9260.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9260で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFの寄付からの資料が含まれている場合があります。IETF標準プロセスの外。そのような資料の著作権を制御する人から適切なライセンスを取得せずに、このドキュメントはIETF標準プロセスの外側に変更されない場合があり、その派生作業は、ITF標準プロセスの外側で作成されない場合があります。RFCとしての出版またはそれを英語以外の言語に翻訳するため。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Motivation\n  1.2.  Architectural View of SCTP\n  1.3.  Key Terms\n  1.4.  Abbreviations\n  1.5.  Functional View of SCTP\n    1.5.1.  Association Startup and Takedown\n    1.5.2.  Sequenced Delivery within Streams\n    1.5.3.  User Data Fragmentation\n    1.5.4.  Acknowledgement and Congestion Avoidance\n    1.5.5.  Chunk Bundling\n    1.5.6.  Packet Validation\n    1.5.7.  Path Management\n  1.6.  Serial Number Arithmetic\n  1.7.  Changes from RFC 4960\n2.  Conventions\n3.  SCTP Packet Format\n  3.1.  SCTP Common Header Field Descriptions\n  3.2.  Chunk Field Descriptions\n    3.2.1.  Optional/Variable-Length Parameter Format\n    3.2.2.  Reporting of Unrecognized Parameters\n  3.3.  SCTP Chunk Definitions\n    3.3.1.  Payload Data (DATA) (0)\n    3.3.2.  Initiation (INIT) (1)\n      3.3.2.1.  Optional or Variable-Length Parameters in INIT\n              chunks\n    3.3.3.  Initiation Acknowledgement (INIT ACK) (2)\n      3.3.3.1.  Optional or Variable-Length Parameters in INIT ACK\n              Chunks\n    3.3.4.  Selective Acknowledgement (SACK) (3)\n    3.3.5.  Heartbeat Request (HEARTBEAT) (4)\n    3.3.6.  Heartbeat Acknowledgement (HEARTBEAT ACK) (5)\n    3.3.7.  Abort Association (ABORT) (6)\n    3.3.8.  Shutdown Association (SHUTDOWN) (7)\n    3.3.9.  Shutdown Acknowledgement (SHUTDOWN ACK) (8)\n    3.3.10. Operation Error (ERROR) (9)\n      3.3.10.1.  Invalid Stream Identifier (1)\n      3.3.10.2.  Missing Mandatory Parameter (2)\n      3.3.10.3.  Stale Cookie (3)\n      3.3.10.4.  Out of Resource (4)\n      3.3.10.5.  Unresolvable Address (5)\n      3.3.10.6.  Unrecognized Chunk Type (6)\n      3.3.10.7.  Invalid Mandatory Parameter (7)\n      3.3.10.8.  Unrecognized Parameters (8)\n      3.3.10.9.  No User Data (9)\n      3.3.10.10. Cookie Received While Shutting Down (10)\n      3.3.10.11. Restart of an Association with New Addresses (11)\n      3.3.10.12. User-Initiated Abort (12)\n      3.3.10.13. Protocol Violation (13)\n    3.3.11. Cookie Echo (COOKIE ECHO) (10)\n    3.3.12. Cookie Acknowledgement (COOKIE ACK) (11)\n    3.3.13. Shutdown Complete (SHUTDOWN COMPLETE) (14)\n4.  SCTP Association State Diagram\n5.  Association Initialization\n  5.1.  Normal Establishment of an Association\n    5.1.1.  Handle Stream Parameters\n    5.1.2.  Handle Address Parameters\n    5.1.3.  Generating State Cookie\n    5.1.4.  State Cookie Processing\n    5.1.5.  State Cookie Authentication\n    5.1.6.  An Example of Normal Association Establishment\n  5.2.  Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO,\n        and COOKIE ACK Chunks\n    5.2.1.  INIT Chunk Received in COOKIE-WAIT or COOKIE-ECHOED\n            State (Item B)\n    5.2.2.  Unexpected INIT Chunk in States Other than CLOSED,\n            COOKIE-ECHOED, COOKIE-WAIT, and SHUTDOWN-ACK-SENT\n    5.2.3.  Unexpected INIT ACK Chunk\n    5.2.4.  Handle a COOKIE ECHO Chunk When a TCB Exists\n      5.2.4.1.  An Example of an Association Restart\n    5.2.5.  Handle Duplicate COOKIE ACK Chunk\n    5.2.6.  Handle Stale Cookie Error\n  5.3.  Other Initialization Issues\n    5.3.1.  Selection of Tag Value\n  5.4.  Path Verification\n6.  User Data Transfer\n  6.1.  Transmission of DATA Chunks\n  6.2.  Acknowledgement on Reception of DATA Chunks\n    6.2.1.  Processing a Received SACK Chunk\n  6.3.  Management of Retransmission Timer\n    6.3.1.  RTO Calculation\n    6.3.2.  Retransmission Timer Rules\n    6.3.3.  Handle T3-rtx Expiration\n  6.4.  Multi-Homed SCTP Endpoints\n    6.4.1.  Failover from an Inactive Destination Address\n  6.5.  Stream Identifier and Stream Sequence Number\n  6.6.  Ordered and Unordered Delivery\n  6.7.  Report Gaps in Received DATA TSNs\n  6.8.  CRC32c Checksum Calculation\n  6.9.  Fragmentation and Reassembly\n  6.10. Bundling\n7.  Congestion Control\n  7.1.  SCTP Differences from TCP Congestion Control\n  7.2.  SCTP Slow-Start and Congestion Avoidance\n    7.2.1.  Slow-Start\n    7.2.2.  Congestion Avoidance\n    7.2.3.  Congestion Control\n    7.2.4.  Fast Retransmit on Gap Reports\n    7.2.5.  Reinitialization\n      7.2.5.1.  Change of Differentiated Services Code Points\n      7.2.5.2.  Change of Routes\n  7.3.  PMTU Discovery\n8.  Fault Management\n  8.1.  Endpoint Failure Detection\n  8.2.  Path Failure Detection\n  8.3.  Path Heartbeat\n  8.4.  Handle \"Out of the Blue\" Packets\n  8.5.  Verification Tag\n    8.5.1.  Exceptions in Verification Tag Rules\n9.  Termination of Association\n  9.1.  Abort of an Association\n  9.2.  Shutdown of an Association\n10. ICMP Handling\n11. Interface with Upper Layer\n  11.1.  ULP-to-SCTP\n    11.1.1.  Initialize\n    11.1.2.  Associate\n    11.1.3.  Shutdown\n    11.1.4.  Abort\n    11.1.5.  Send\n    11.1.6.  Set Primary\n    11.1.7.  Receive\n    11.1.8.  Status\n    11.1.9.  Change Heartbeat\n    11.1.10. Request Heartbeat\n    11.1.11. Get SRTT Report\n    11.1.12. Set Failure Threshold\n    11.1.13. Set Protocol Parameters\n    11.1.14. Receive Unsent Message\n    11.1.15. Receive Unacknowledged Message\n    11.1.16. Destroy SCTP Instance\n  11.2.  SCTP-to-ULP\n    11.2.1.  DATA ARRIVE Notification\n    11.2.2.  SEND FAILURE Notification\n    11.2.3.  NETWORK STATUS CHANGE Notification\n    11.2.4.  COMMUNICATION UP Notification\n    11.2.5.  COMMUNICATION LOST Notification\n    11.2.6.  COMMUNICATION ERROR Notification\n    11.2.7.  RESTART Notification\n    11.2.8.  SHUTDOWN COMPLETE Notification\n12. Security Considerations\n  12.1.  Security Objectives\n  12.2.  SCTP Responses to Potential Threats\n    12.2.1.  Countering Insider Attacks\n    12.2.2.  Protecting against Data Corruption in the Network\n    12.2.3.  Protecting Confidentiality\n    12.2.4.  Protecting against Blind Denial-of-Service Attacks\n      12.2.4.1.  Flooding\n      12.2.4.2.  Blind Masquerade\n      12.2.4.3.  Improper Monopolization of Services\n  12.3.  SCTP Interactions with Firewalls\n  12.4.  Protection of Non-SCTP-capable Hosts\n13. Network Management Considerations\n14. Recommended Transmission Control Block (TCB) Parameters\n  14.1.  Parameters Necessary for the SCTP Instance\n  14.2.  Parameters Necessary per Association (i.e., the TCB)\n  14.3.  Per Transport Address Data\n  14.4.  General Parameters Needed\n15. IANA Considerations\n  15.1.  IETF-Defined Chunk Extension\n  15.2.  IETF-Defined Chunk Flags Registration\n  15.3.  IETF-Defined Chunk Parameter Extension\n  15.4.  IETF-Defined Additional Error Causes\n  15.5.  Payload Protocol Identifiers\n  15.6.  Port Numbers Registry\n16. Suggested SCTP Protocol Parameter Values\n17. References\n  17.1.  Normative References\n  17.2.  Informative References\nAppendix A.  CRC32c Checksum Calculation\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This section explains the reasoning behind the development of the Stream Control Transmission Protocol (SCTP), the services it offers, and the basic concepts needed to understand the detailed description of the protocol.",
      "ja": "このセクションでは、ストリーム制御伝送プロトコル（SCTP）の開発の背後にある理由、提供するサービス、およびプロトコルの詳細な説明を理解するために必要な基本概念について説明します。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC4960]. In addition to that, it incorporates the specification of the chunk flags registry from [RFC6096] and the specification of the I bit of DATA chunks from [RFC7053]. Therefore, [RFC6096] and [RFC7053] are also obsoleted by this document.",
      "ja": "この文書は廃止[RFC4960]。それに加えて、[RFC6096]のChunk Flagsレジストリの仕様と、[RFC7053]のIビットデータチャンクの仕様が組み込まれています。したがって、[RFC6096]および[RFC7053]もこのドキュメントによって廃止されます。"
    },
    {
      "indent": 0,
      "text": "1.1. Motivation",
      "section_title": true,
      "ja": "1.1. 動機"
    },
    {
      "indent": 3,
      "text": "TCP [RFC0793] has performed immense service as the primary means of reliable data transfer in IP networks. However, an increasing number of recent applications have found TCP too limiting and have incorporated their own reliable data transfer protocol on top of UDP [RFC0768]. The limitations that users have wished to bypass include the following:",
      "ja": "TCP [RFC0793]は、IPネットワークでの信頼できるデータ転送の主要な手段として計り知れないサービスを実行しました。ただし、最近のアプリケーションの数が増えているため、TCPが制限されていることがわかり、UDP [RFC0768]の上に独自の信頼できるデータ転送プロトコルを組み込んでいます。ユーザーがバイパスしたいという制限には、以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "* TCP provides both reliable data transfer and strict order-of-transmission delivery of data. Some applications need reliable transfer without sequence maintenance, while others would be satisfied with partial ordering of the data. In both of these cases, the head-of-line blocking offered by TCP causes unnecessary delay.",
      "ja": "* TCPは、信頼できるデータ転送とデータの移動順序配信の両方の両方を提供します。シーケンスのメンテナンスなしで信頼できる転送が必要なアプリケーションもあれば、データの部分的な順序に満足するアプリケーションもあります。これらの両方のケースでは、TCPによって提供される頭部ブロッキングは不必要な遅延を引き起こします。"
    },
    {
      "indent": 3,
      "text": "* The stream-oriented nature of TCP is often an inconvenience. Applications add their own record marking to delineate their messages and make explicit use of the push facility to ensure that a complete message is transferred in a reasonable time.",
      "ja": "* TCPのストリーム指向の性質は、多くの場合不便です。アプリケーションは、独自のレコードマーキングを追加してメッセージを描き、プッシュ機能を明示的に使用して、完全なメッセージが妥当な時間内に転送されるようにします。"
    },
    {
      "indent": 3,
      "text": "* The limited scope of TCP sockets complicates the task of providing highly available data transfer capability using multi-homed hosts.",
      "ja": "* TCPソケットの限られた範囲は、マルチホームのホストを使用して、非常に利用可能なデータ転送機能を提供するタスクを複雑にします。"
    },
    {
      "indent": 3,
      "text": "* TCP is relatively vulnerable to denial-of-service attacks, such as SYN attacks.",
      "ja": "* TCPは、Syn攻撃などのサービス拒否攻撃に対して比較的脆弱です。"
    },
    {
      "indent": 3,
      "text": "Transport of PSTN signaling across the IP network is an application for which all of these limitations of TCP are relevant. While this application directly motivated the development of SCTP, other applications might find SCTP a good match to their requirements. One example of this is the use of data channels in the WebRTC infrastructure.",
      "ja": "IPネットワークを介したPSTNシグナル伝達の輸送は、TCPのこれらすべての制限が関連するアプリケーションです。このアプリケーションはSCTPの開発を直接動機付けましたが、他のアプリケーションはSCTPが要件に適していると感じる可能性があります。この一例は、WeBRTCインフラストラクチャでのデータチャネルの使用です。"
    },
    {
      "indent": 0,
      "text": "1.2. Architectural View of SCTP",
      "section_title": true,
      "ja": "1.2. SCTPの建築ビュー"
    },
    {
      "indent": 3,
      "text": "SCTP is viewed as a layer between the SCTP user application (\"SCTP user\" for short) and a connectionless packet network service, such as IP. The remainder of this document assumes SCTP runs on top of IP. The basic service offered by SCTP is the reliable transfer of user messages between peer SCTP users. It performs this service within the context of an association between two SCTP endpoints. Section 11 of this document sketches the API that exists at the boundary between SCTP and the SCTP upper layers.",
      "ja": "SCTPは、SCTPユーザーアプリケーション（略して「SCTPユーザー」）とIPなどのConnectionLess Packet Networkサービスの間のレイヤーと見なされます。このドキュメントの残りの部分は、SCTPがIPの上で実行されると仮定しています。SCTPが提供する基本サービスは、ピアSCTPユーザー間でユーザーメッセージの信頼できる転送です。2つのSCTPエンドポイント間の関連性のコンテキスト内でこのサービスを実行します。このドキュメントのセクション11では、SCTPとSCTP上層の境界に存在するAPIをスケッチします。"
    },
    {
      "indent": 3,
      "text": "SCTP is connection oriented in nature, but the SCTP association is a broader concept than the TCP connection. SCTP provides the means for each SCTP endpoint (Section 1.3) to provide the other endpoint (during association startup) with a list of transport addresses (i.e., multiple IP addresses in combination with an SCTP port) through which that endpoint can be reached and from which it will originate SCTP packets. The association spans transfers over all of the possible source/destination combinations that can be generated from each endpoint's lists.",
      "ja": "SCTPは本質的に接続指向ですが、SCTP関連はTCP接続よりも広範な概念です。SCTPは、各SCTPエンドポイント（セクション1.3）の手段を提供し、他のエンドポイント（アソシエーションスタートアップ中）にトランスポートアドレスのリスト（つまり、SCTPポートと組み合わせた複数のIPアドレス）を提供します。SCTPパケットが発生します。アソシエーションは、各エンドポイントのリストから生成できるすべての可能なソース/宛先の組み合わせにまたがります。"
    },
    {
      "indent": 4,
      "text": " _____________                                      _____________\n|  SCTP User  |                                    |  SCTP User  |\n| Application |                                    | Application |\n|-------------|                                    |-------------|\n|    SCTP     |                                    |    SCTP     |\n|  Transport  |                                    |  Transport  |\n|   Service   |                                    |   Service   |\n|-------------|                                    |-------------|\n|             |One or more    ----      One or more|             |\n| IP Network  |IP address      \\/        IP address| IP Network  |\n|   Service   |appearances     /\\       appearances|   Service   |\n|_____________|               ----                 |_____________|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "SCTP Node A |<-------- Network transport ------->| SCTP Node B",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 1: An SCTP Association",
      "ja": "図1：SCTP協会"
    },
    {
      "indent": 3,
      "text": "In addition to encapsulating SCTP packets in IPv4 or IPv6, it is also possible to encapsulate SCTP packets in UDP as specified in [RFC6951] or encapsulate them in DTLS as specified in [RFC8261].",
      "ja": "IPv4またはIPv6のSCTPパケットのカプセル化に加えて、[RFC6951]で指定されているようにUDPのSCTPパケットをカプセル化するか、[RFC8261]で指定されているDTLSでそれらをカプセル化することも可能です。"
    },
    {
      "indent": 0,
      "text": "1.3. Key Terms",
      "section_title": true,
      "ja": "1.3. 重要な用語"
    },
    {
      "indent": 3,
      "text": "Some of the language used to describe SCTP has been introduced in the previous sections. This section provides a consolidated list of the key terms and their definitions.",
      "ja": "SCTPを説明するために使用される言語の一部は、前のセクションで紹介されています。このセクションでは、主要な用語とその定義の統合リストを提供します。"
    },
    {
      "indent": 3,
      "text": "Active Destination Transport Address: A transport address on a peer endpoint that a transmitting endpoint considers available for receiving user messages.",
      "ja": "アクティブな宛先輸送住所：ユーザーメッセージの受信に利用できる送信エンドポイントが考慮したピアエンドポイント上の輸送アドレス。"
    },
    {
      "indent": 3,
      "text": "Association Maximum DATA Chunk Size (AMDCS): The smallest Path Maximum DATA Chunk Size (PMDCS) of all destination addresses.",
      "ja": "アソシエーション最大データチャンクサイズ（AMDC）：すべての宛先アドレスの最小パス最小データチャンクサイズ（PMDC）。"
    },
    {
      "indent": 3,
      "text": "Bundling of Chunks: An optional multiplexing operation, whereby more than one chunk can be carried in the same SCTP packet.",
      "ja": "チャンクのバンドル：オプションの多重化操作。これにより、同じSCTPパケットで複数のチャンクを運ぶことができます。"
    },
    {
      "indent": 3,
      "text": "Bundling of User Messages: An optional multiplexing operation, whereby more than one user message can be carried in the same SCTP packet. Each user message occupies its own DATA chunk.",
      "ja": "ユーザーメッセージのバンドル：オプションの多重化操作。これにより、同じSCTPパケットで複数のユーザーメッセージを携帯できます。各ユーザーメッセージは、独自のデータチャンクを占有します。"
    },
    {
      "indent": 3,
      "text": "Chunk: A unit of information within an SCTP packet, consisting of a chunk header and chunk-specific content.",
      "ja": "Chunk：チャンクヘッダーとチャンク固有のコンテンツで構成されるSCTPパケット内の情報単位。"
    },
    {
      "indent": 3,
      "text": "Congestion Window (cwnd): An SCTP variable that limits outstanding data, in number of bytes, that a sender can send to a particular destination transport address before receiving an acknowledgement.",
      "ja": "輻輳ウィンドウ（CWND）：確認者が確認を受ける前に特定の宛先輸送アドレスに送信できるバイト数で、未発生データを制限するSCTP変数。"
    },
    {
      "indent": 3,
      "text": "Control Chunk: A chunk not being used for transmitting user data, i.e., every chunk that is not a DATA chunk.",
      "ja": "コントロールチャンク：ユーザーデータの送信に使用されていないチャンク、つまり、データチャンクではないすべてのチャンク。"
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack Point: The Transmission Sequence Number (TSN) of the last DATA chunk acknowledged via the Cumulative TSN Ack field of a SACK chunk.",
      "ja": "累積TSN ACKポイント：サックチャンクの累積TSN ACKフィールドを介して認められた最後のデータチャンクの伝送シーケンス番号（TSN）。"
    },
    {
      "indent": 3,
      "text": "Flightsize: The number of bytes of outstanding data to a particular destination transport address at any given time.",
      "ja": "Flightsize：特定の宛先輸送アドレスへの未解決のデータのバイト数。"
    },
    {
      "indent": 3,
      "text": "Idle Destination Address: An address that has not had user messages sent to it within some length of time, normally the 'HB.interval' or greater.",
      "ja": "アイドル宛先アドレス：ある時間内にユーザーメッセージが送信されていないアドレス、通常は「hb.interval」以上です。"
    },
    {
      "indent": 3,
      "text": "Inactive Destination Transport Address: An address that is considered inactive due to errors and unavailable to transport user messages.",
      "ja": "非アクティブな宛先輸送アドレス：エラーのために非アクティブであると見なされ、ユーザーメッセージの輸送に利用できないアドレス。"
    },
    {
      "indent": 3,
      "text": "Message (or User Message): Data submitted to SCTP by the Upper-Layer Protocol (ULP).",
      "ja": "メッセージ（またはユーザーメッセージ）：上層層プロトコル（ULP）によってSCTPに提出されたデータ。"
    },
    {
      "indent": 3,
      "text": "Network Byte Order: Most significant byte first, a.k.a., big endian.",
      "ja": "ネットワークバイト順序：最も重要なバイトファースト、別名、ビッグエンディアン。"
    },
    {
      "indent": 3,
      "text": "Ordered Message: A user message that is delivered in order with respect to all previous user messages sent within the stream on which the message was sent.",
      "ja": "注文されたメッセージ：メッセージが送信されたストリーム内で送信されたすべての以前のユーザーメッセージに関して順番に配信されるユーザーメッセージ。"
    },
    {
      "indent": 3,
      "text": "Outstanding Data (or Data Outstanding or Data In Flight): The total size of the DATA chunks associated with outstanding TSNs. A retransmitted DATA chunk is counted once in outstanding data. A DATA chunk that is classified as lost but that has not yet been retransmitted is not in outstanding data.",
      "ja": "未解決のデータ（または飛行中のデータまたはデータ）：未解決のTSNに関連するデータチャンクの合計サイズ。再送信されたデータチャンクは、未払いのデータに1回カウントされます。失われたと分類されているが、まだ再送信されていないデータチャンクは、未解決のデータには含まれていません。"
    },
    {
      "indent": 3,
      "text": "Outstanding TSN (at an SCTP Endpoint): A TSN (and the associated DATA chunk) that has been sent by the endpoint but for which it has not yet received an acknowledgement.",
      "ja": "未解決のTSN（SCTPエンドポイント）：エンドポイントによって送信されたが、まだ確認を受けていないTSN（および関連するデータチャンク）。"
    },
    {
      "indent": 3,
      "text": "\"Out of the Blue\" (OOTB) Packet: A correctly formed packet, for which the receiver cannot identify the association it belongs to. See Section 8.4.",
      "ja": "「Out of the Blue」（OOTB）パケット：正しく形成されたパケット。受信者は、それが属する関連付けを識別できません。セクション8.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Path: The route taken by the SCTP packets sent by one SCTP endpoint to a specific destination transport address of its peer SCTP endpoint. Sending to different destination transport addresses does not necessarily guarantee getting separate paths. Within this specification, a path is identified by the destination transport address, since the routing is assumed to be stable. This includes, in particular, the source address being selected when sending packets to the destination address.",
      "ja": "パス：SCTPエンドポイントが1つのSCTPエンドポイントによって送信されたSCTPパケットによって採取されたルートは、ピアSCTPエンドポイントの特定の宛先輸送アドレスに送信されます。さまざまな宛先輸送アドレスに送信しても、必ずしも別のパスを取得することを保証するものではありません。この仕様内では、ルーティングが安定していると想定されるため、宛先輸送アドレスによってパスが識別されます。これには、特に、宛先アドレスにパケットを送信するときに選択されるソースアドレスが含まれます。"
    },
    {
      "indent": 3,
      "text": "Path Maximum DATA Chunk Size (PMDCS): The maximum size (including the DATA chunk header) of a DATA chunk that fits into an SCTP packet not exceeding the PMTU of a particular destination address.",
      "ja": "パス最大データチャンクサイズ（PMDCS）：特定の宛先アドレスのPMTUを超えないSCTPパケットに収まるデータチャンクの最大サイズ（データチャンクヘッダーを含む）。"
    },
    {
      "indent": 3,
      "text": "Path Maximum Transmission Unit (PMTU): The maximum size (including the SCTP common header and all chunks including their paddings) of an SCTP packet that can be sent to a particular destination address without using IP-level fragmentation.",
      "ja": "PATH最大送信ユニット（PMTU）：IPレベルの断片化を使用せずに特定の宛先アドレスに送信できるSCTPパケットの最大サイズ（SCTP共通ヘッダーとパディングを含むすべてのチャンク）。"
    },
    {
      "indent": 3,
      "text": "Primary Path: The destination and source address that will be put into a packet outbound to the peer endpoint by default. The definition includes the source address since an implementation MAY wish to specify both destination and source address to better control the return path taken by reply chunks and on which interface the packet is transmitted when the data sender is multi-homed.",
      "ja": "プライマリパス：デフォルトでピアエンドポイントにアウトバウンドするパケットに配置される宛先およびソースアドレス。定義にはソースアドレスが含まれます。これは、実装が宛先とソースアドレスの両方を指定して、返信チャンクによって実行されるリターンパスをより適切に制御し、データ送信者がマルチホームのときにパケットが送信されるインターフェイスをより適切に制御することをお勧めする場合があります。"
    },
    {
      "indent": 3,
      "text": "Receiver Window (rwnd): An SCTP variable a data sender uses to store the most recently calculated receiver window of its peer, in number of bytes. This gives the sender an indication of the space available in the receiver's inbound buffer.",
      "ja": "受信機ウィンドウ（RWND）：SCTP変数データ送信者が使用して、最近計算されたピアのレシーバーウィンドウをバイト数で保存します。これにより、送信者は、受信機のインバウンドバッファーで利用可能なスペースを示します。"
    },
    {
      "indent": 3,
      "text": "SCTP Association: A protocol relationship between SCTP endpoints, composed of the two SCTP endpoints and protocol state information, including Verification Tags and the currently active set of Transmission Sequence Numbers (TSNs), etc. An association can be uniquely identified by the transport addresses used by the endpoints in the association. Two SCTP endpoints MUST NOT have more than one SCTP association between them at any given time.",
      "ja": "SCTP Association：2つのSCTPエンドポイントとプロトコル状態情報で構成されるSCTPエンドポイント間のプロトコル関係、検証タグと現在アクティブな送信シーケンス番号（TSN）など。協会のエンドポイントによって。2つのSCTPエンドポイントには、それらの間に1つ以上のSCTP関連がある必要があります。"
    },
    {
      "indent": 3,
      "text": "SCTP Endpoint: The logical sender/receiver of SCTP packets. On a multi-homed host, an SCTP endpoint is represented to its peers as a combination of a set of eligible destination transport addresses to which SCTP packets can be sent and a set of eligible source transport addresses from which SCTP packets can be received. All transport addresses used by an SCTP endpoint MUST use the same port number but can use multiple IP addresses. A transport address used by an SCTP endpoint MUST NOT be used by another SCTP endpoint. In other words, a transport address is unique to an SCTP endpoint.",
      "ja": "SCTPエンドポイント：SCTPパケットの論理送信者/受信機。マルチホームのホストでは、SCTPエンドポイントは、SCTPパケットを送信できる適格な宛先輸送アドレスのセットと、SCTPパケットを受信できる適格なソーストランスポートアドレスのセットの組み合わせとして、同僚に表されます。SCTPエンドポイントで使用されるすべての輸送アドレスは、同じポート番号を使用する必要がありますが、複数のIPアドレスを使用できます。SCTPエンドポイントで使用されるトランスポートアドレスは、別のSCTPエンドポイントで使用してはなりません。言い換えれば、トランスポートアドレスはSCTPエンドポイントに固有のものです。"
    },
    {
      "indent": 3,
      "text": "SCTP Packet (or Packet): The unit of data delivery across the interface between SCTP and the connectionless packet network (e.g., IP). An SCTP packet includes the common SCTP header, possible SCTP control chunks, and user data encapsulated within SCTP DATA chunks.",
      "ja": "SCTPパケット（またはパケット）：SCTPとConnectionless Packet Network（IPなど）の間のインターフェイス全体のデータ配信ユニット。SCTPパケットには、一般的なSCTPヘッダー、可能なSCTP制御チャンク、およびSCTPデータチャンク内でカプセル化されたユーザーデータが含まれます。"
    },
    {
      "indent": 3,
      "text": "SCTP User Application (or SCTP User): The logical higher-layer application entity that uses the services of SCTP, also called the Upper-Layer Protocol (ULP).",
      "ja": "SCTPユーザーアプリケーション（またはSCTPユーザー）：SCTPのサービスを使用する論理上の高層アプリケーションエンティティ（上位層プロトコル（ULP））。"
    },
    {
      "indent": 3,
      "text": "Slow-Start Threshold (ssthresh): An SCTP variable. This is the threshold that the endpoint will use to determine whether to perform slow-start or congestion avoidance on a particular destination transport address. Ssthresh is in number of bytes.",
      "ja": "スロースタートしきい値（SSthresh）：SCTP変数。これは、エンドポイントが特定の宛先輸送アドレスでスロースタート回避を実行するか混雑回避を実行するかを決定するために使用するしきい値です。SSthreshはバイト数です。"
    },
    {
      "indent": 3,
      "text": "State Cookie: A container of all information needed to establish an association.",
      "ja": "State Cookie：関連を確立するために必要なすべての情報のコンテナ。"
    },
    {
      "indent": 3,
      "text": "Stream: A unidirectional logical channel established from one to another associated SCTP endpoint, within which all user messages are delivered in sequence, except for those submitted to the unordered delivery service.",
      "ja": "ストリーム：1つの順方向の論理チャンネルから別の関連するSCTPエンドポイントに確立され、順序付けられていない配信サービスに提出されたものを除き、すべてのユーザーメッセージが順番に配信されます。"
    },
    {
      "indent": 6,
      "text": "Note: The relationship between stream numbers in opposite directions is strictly a matter of how the applications use them. It is the responsibility of the SCTP user to create and manage these correlations if they are so desired.",
      "ja": "注：反対方向のストリーム番号の関係は、アプリケーションがそれらを使用する方法の厳密な問題です。SCTPユーザーの責任は、これらの相関が非常に望まれている場合に作成および管理することです。"
    },
    {
      "indent": 3,
      "text": "Stream Sequence Number: A 16-bit sequence number used internally by SCTP to ensure sequenced delivery of the user messages within a given stream. One Stream Sequence Number is attached to each ordered user message.",
      "ja": "ストリームシーケンス番号：SCTPが内部的に使用する16ビットシーケンス番号は、特定のストリーム内のユーザーメッセージのシーケンスの配信を保証します。1つのストリームシーケンス番号が、注文された各ユーザーメッセージに添付されています。"
    },
    {
      "indent": 3,
      "text": "Tie-Tags: Two 32-bit random numbers that together make a 64-bit nonce. These tags are used within a State Cookie and TCB so that a newly restarting association can be linked to the original association within the endpoint that did not restart and yet not reveal the true Verification Tags of an existing association.",
      "ja": "タイタグ：64ビットのnonceを作成する2つの32ビットの乱数。これらのタグは、状態CookieおよびTCB内で使用されるため、新たに再起動する関連付けは、再起動せず、既存の関連付けの真の検証タグを明らかにしないエンドポイント内の元の関連付けにリンクできます。"
    },
    {
      "indent": 3,
      "text": "Transmission Control Block (TCB): An internal data structure created by an SCTP endpoint for each of its existing SCTP associations to other SCTP endpoints. TCB contains all the status and operational information for the endpoint to maintain and manage the corresponding association.",
      "ja": "送信制御ブロック（TCB）：既存の各SCTP関連のSCTPエンドポイントによって作成された内部データ構造は、他のSCTPエンドポイントに至ります。TCBには、対応する関連付けを維持および管理するためのエンドポイントのすべてのステータスと運用情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Transmission Sequence Number (TSN): A 32-bit sequence number used internally by SCTP. One TSN is attached to each chunk containing user data to permit the receiving SCTP endpoint to acknowledge its receipt and detect duplicate deliveries.",
      "ja": "送信シーケンス番号（TSN）：SCTPが内部で使用する32ビットシーケンス番号。1つのTSNが各チャンクを含むユーザーデータに接続されており、受信SCTPエンドポイントがその受領を認め、重複配信を検出できるようにします。"
    },
    {
      "indent": 3,
      "text": "Transport Address: A transport address is typically defined by a network-layer address, a transport-layer protocol, and a transport-layer port number. In the case of SCTP running over IP, a transport address is defined by the combination of an IP address and an SCTP port number (where SCTP is the transport protocol).",
      "ja": "輸送アドレス：輸送アドレスは、通常、ネットワーク層アドレス、輸送層プロトコル、輸送層ポート番号によって定義されます。IPを介して実行されているSCTPの場合、トランスポートアドレスはIPアドレスとSCTPポート番号（SCTPが輸送プロトコル）の組み合わせによって定義されます。"
    },
    {
      "indent": 3,
      "text": "Unordered Message: Unordered messages are \"unordered\" with respect to any other message; this includes both other unordered messages as well as other ordered messages. An unordered message might be delivered prior to or later than ordered messages sent on the same stream.",
      "ja": "順序付けられていないメッセージ：他のメッセージに関して、順序付けられていないメッセージは「順序付けられていません」。これには、他の秩序化されていないメッセージと他の順序付けメッセージの両方が含まれます。同じストリームで送信された順序付けられたメッセージよりも、順序付けられていないメッセージが配信される場合があります。"
    },
    {
      "indent": 3,
      "text": "User Message: The unit of data delivery across the interface between SCTP and its user.",
      "ja": "ユーザーメッセージ：SCTPとそのユーザーの間のインターフェイス全体のデータ配信ユニット。"
    },
    {
      "indent": 3,
      "text": "Verification Tag: A 32-bit unsigned integer that is randomly generated. The Verification Tag provides a key that allows a receiver to verify that the SCTP packet belongs to the current association and is not an old or stale packet from a previous association.",
      "ja": "検証タグ：ランダムに生成される32ビットの署名されていない整数。検証タグは、受信者がSCTPパケットが現在の協会に属し、以前の協会の古いパケットや古いパケットではないことを確認できるキーを提供します。"
    },
    {
      "indent": 0,
      "text": "1.4. Abbreviations",
      "section_title": true,
      "ja": "1.4. 略語"
    },
    {
      "indent": 3,
      "text": "MAC Message Authentication Code [RFC2104]",
      "ja": "Macメッセージ認証コード[RFC2104]"
    },
    {
      "indent": 3,
      "text": "RTO Retransmission Timeout",
      "ja": "RTO再送信タイムアウト"
    },
    {
      "indent": 3,
      "text": "RTT Round-Trip Time",
      "ja": "RTTラウンドトリップ時間"
    },
    {
      "indent": 3,
      "text": "RTTVAR Round-Trip Time Variation",
      "ja": "RTTVARラウンドトリップタイムバリエーション"
    },
    {
      "indent": 3,
      "text": "SCTP Stream Control Transmission Protocol",
      "ja": "SCTPストリーム制御伝送プロトコル"
    },
    {
      "indent": 3,
      "text": "SRTT Smoothed RTT",
      "ja": "SRTTはRTTを滑らかにしました"
    },
    {
      "indent": 3,
      "text": "TCB Transmission Control Block",
      "ja": "TCB伝送制御ブロック"
    },
    {
      "indent": 3,
      "text": "TLV Type-Length-Value coding format",
      "ja": "TLVタイプ長値コーディング形式"
    },
    {
      "indent": 3,
      "text": "TSN Transmission Sequence Number",
      "ja": "TSN伝送シーケンス番号"
    },
    {
      "indent": 3,
      "text": "ULP Upper-Layer Protocol",
      "ja": "ULP上層層プロトコル"
    },
    {
      "indent": 0,
      "text": "1.5. Functional View of SCTP",
      "section_title": true,
      "ja": "1.5. SCTPの機能ビュー"
    },
    {
      "indent": 3,
      "text": "The SCTP transport service can be decomposed into a number of functions. These are depicted in Figure 2 and explained in the remainder of this section.",
      "ja": "SCTP輸送サービスは、多くの機能に分解できます。これらは図2に示されており、このセクションの残りの部分で説明されています。"
    },
    {
      "indent": 27,
      "text": "SCTP User Application",
      "ja": "SCTPユーザーアプリケーション"
    },
    {
      "indent": 11,
      "text": "-----------------------------------------------------\n _____________                  ____________________\n|             |                | Sequenced Delivery |\n| Association |                |   within Streams   |\n|             |                |____________________|\n|   Startup   |\n|             |         ____________________________\n|     and     |        |  User Data Fragmentation   |\n|             |        |____________________________|\n|  Takedown   |\n|             |         ____________________________\n|             |        |      Acknowledgement       |\n|             |        |            and             |\n|             |        |    Congestion Avoidance    |\n|             |        |____________________________|\n|             |\n|             |         ____________________________\n|             |        |       Chunk Bundling       |\n|             |        |____________________________|\n|             |\n|             |     ________________________________\n|             |    |       Packet Validation        |\n|             |    |________________________________|\n|             |\n|             |     ________________________________\n|             |    |        Path Management         |\n|_____________|    |________________________________|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 2: Functional View of the SCTP Transport Service",
      "ja": "図2：SCTP輸送サービスの機能的ビュー"
    },
    {
      "indent": 0,
      "text": "1.5.1. Association Startup and Takedown",
      "section_title": true,
      "ja": "1.5.1. 協会のスタートアップとテイクダウン"
    },
    {
      "indent": 3,
      "text": "An association is initiated by a request from the SCTP user (see the description of the ASSOCIATE (or SEND) primitive in Section 11).",
      "ja": "Associationは、SCTPユーザーからのリクエストによって開始されます（セクション11のアソシエイト（または送信）原始の説明を参照）。"
    },
    {
      "indent": 3,
      "text": "A cookie mechanism, similar to one described by Karn and Simpson in [RFC2522], is employed during the initialization to provide protection against synchronization attacks. The cookie mechanism uses a four-way handshake, the last two legs of which are allowed to carry user data for fast setup. The startup sequence is described in Section 5 of this document.",
      "ja": "[RFC2522]でKarnとSimpsonによって説明されたものと同様のCookieメカニズムは、初期化中に同期攻撃に対する保護を提供するために採用されています。Cookieメカニズムは、4方向の握手を使用します。最後の2つの脚は、高速セットアップのためにユーザーデータを運ぶことができます。スタートアップシーケンスについては、このドキュメントのセクション5で説明します。"
    },
    {
      "indent": 3,
      "text": "SCTP provides for graceful close (i.e., shutdown) of an active association on request from the SCTP user. See the description of the SHUTDOWN primitive in Section 11. SCTP also allows ungraceful close (i.e., abort), either on request from the user (ABORT primitive) or as a result of an error condition detected within the SCTP layer. Section 9 describes both the graceful and the ungraceful close procedures.",
      "ja": "SCTPは、SCTPユーザーからのリクエストに応じて、アクティブな関連付けの優雅なクローズ（つまり、シャットダウン）を提供します。セクション11のシャットダウンプリミティブの説明を参照してください。SCTPでは、ユーザーからの要求（Abort Primitive）またはSCTP層内で検出されたエラー条件の結果として、非魅力的なクローズ（つまり、Abort）も許可します。セクション9では、優雅な手順と不名誉な緊密な手順の両方について説明します。"
    },
    {
      "indent": 3,
      "text": "SCTP does not support a half-open state (like TCP) wherein one side continues sending data while the other end is closed. When either endpoint performs a shutdown, the association on each peer will stop accepting new data from its user and only deliver data in queue at the time of the graceful close (see Section 9).",
      "ja": "SCTPは、一方の側がデータの送信を継続し、もう一方の端が閉じている半分のオープン状態（TCPのような）をサポートしていません。いずれかのエンドポイントがシャットダウンを実行すると、各ピアの関連付けはユーザーから新しいデータの受け入れを停止し、優雅なクローズの時点でキュー内のデータを配信するのを停止します（セクション9を参照）。"
    },
    {
      "indent": 0,
      "text": "1.5.2. Sequenced Delivery within Streams",
      "section_title": true,
      "ja": "1.5.2. ストリーム内のシーケンス配信"
    },
    {
      "indent": 3,
      "text": "The term \"stream\" is used in SCTP to refer to a sequence of user messages that are to be delivered to the upper-layer protocol in order with respect to other messages within the same stream. This is in contrast to its usage in TCP, where it refers to a sequence of bytes (in this document, a byte is assumed to be 8 bits).",
      "ja": "「ストリーム」という用語は、SCTPで使用されて、同じストリーム内の他のメッセージに関して上層層プロトコルに配信される一連のユーザーメッセージを指します。これは、TCPでの使用法とは対照的であり、バイトのシーケンスを指します（このドキュメントでは、バイトは8ビットと想定されます）。"
    },
    {
      "indent": 3,
      "text": "At association startup time, the SCTP user can specify the number of streams to be supported by the association. This number is negotiated with the remote end (see Section 5.1.1). User messages are associated with stream numbers (SEND, RECEIVE primitives; Section 11). Internally, SCTP assigns a Stream Sequence Number to each message passed to it by the SCTP user. On the receiving side, SCTP ensures that messages are delivered to the SCTP user in sequence within a given stream. However, while one stream might be blocked waiting for the next in-sequence user message, delivery from other streams might proceed.",
      "ja": "Associationの起動時に、SCTPユーザーは、アソシエーションによってサポートされるストリームの数を指定できます。この番号は、リモートエンドと交渉されます（セクション5.1.1を参照）。ユーザーメッセージは、ストリーム番号に関連付けられています（送信、プリミティブの受信、セクション11）。内部的には、SCTPはSCTPユーザーによって渡された各メッセージにストリームシーケンス番号を割り当てます。受信側では、SCTPは、特定のストリーム内で順番にメッセージがSCTPユーザーに配信されることを保証します。ただし、次のシーケンスユーザーメッセージを待っている1つのストリームがブロックされる可能性がありますが、他のストリームからの配信が進行する可能性があります。"
    },
    {
      "indent": 3,
      "text": "SCTP provides a mechanism for bypassing the sequenced delivery service. User messages sent using this mechanism are delivered to the SCTP user as soon as they are received.",
      "ja": "SCTPは、シーケンスされた配信サービスをバイパスするためのメカニズムを提供します。このメカニズムを使用して送信されるユーザーメッセージは、受信したらすぐにSCTPユーザーに配信されます。"
    },
    {
      "indent": 0,
      "text": "1.5.3. User Data Fragmentation",
      "section_title": true,
      "ja": "1.5.3. ユーザーデータの断片化"
    },
    {
      "indent": 3,
      "text": "When needed, SCTP fragments user messages to ensure that the size of the SCTP packet passed to the lower layer does not exceed the PMTU. Once a user message has been fragmented, this fragmentation cannot be changed anymore. On receipt, fragments are reassembled into complete messages before being passed to the SCTP user.",
      "ja": "必要に応じて、SCTPはユーザーメッセージをフラグメントして、下層に渡されたSCTPパケットのサイズがPMTUを超えないことを確認します。ユーザーメッセージが断片化されると、この断片化はもう変更できません。受領すると、SCTPユーザーに渡される前に、フラグメントが完全なメッセージに再組み立てされます。"
    },
    {
      "indent": 0,
      "text": "1.5.4. Acknowledgement and Congestion Avoidance",
      "section_title": true,
      "ja": "1.5.4. 謝辞と混雑の回避"
    },
    {
      "indent": 3,
      "text": "SCTP assigns a Transmission Sequence Number (TSN) to each user data fragment or unfragmented message. The TSN is independent of any Stream Sequence Number assigned at the stream level. The receiving end acknowledges all TSNs received, even if there are gaps in the sequence. If a user data fragment or unfragmented message needs to be retransmitted, the TSN assigned to it is used. In this way, reliable delivery is kept functionally separate from sequenced stream delivery.",
      "ja": "sctpは、各ユーザーデータフラグメントまたはfragmentedメッセージに送信シーケンス番号（TSN）を割り当てます。TSNは、ストリームレベルで割り当てられたストリームシーケンス番号から独立しています。受信側は、シーケンスにギャップがある場合でも、受信したすべてのTSNを認めます。ユーザーデータのフラグメントまたはフラグメントされていないメッセージを再送信する必要がある場合、それに割り当てられたTSNが使用されます。このようにして、信頼できる配信は、シーケンスされたストリーム配信とは機能的に分離されています。"
    },
    {
      "indent": 3,
      "text": "The acknowledgement and congestion avoidance function is responsible for packet retransmission when timely acknowledgement has not been received. Packet retransmission is conditioned by congestion avoidance procedures similar to those used for TCP. See Sections 6 and 7 for detailed descriptions of the protocol procedures associated with this function.",
      "ja": "謝辞と混雑回避機能は、タイムリーな謝辞が受け取られていない場合のパケットの再送信の原因です。パケットの再送信は、TCPに使用されるものと同様の混雑回避手順によって条件付けられます。この関数に関連するプロトコル手順の詳細な説明については、セクション6および7を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.5.5. Chunk Bundling",
      "section_title": true,
      "ja": "1.5.5. チャンクバンドル"
    },
    {
      "indent": 3,
      "text": "As described in Section 3, the SCTP packet as delivered to the lower layer consists of a common header followed by one or more chunks. Each chunk contains either user data or SCTP control information. An SCTP implementation supporting bundling on the sender side might delay the sending of user messages to allow the corresponding DATA chunks to be bundled.",
      "ja": "セクション3で説明されているように、下層に配信されるSCTPパケットは、共通のヘッダーと1つ以上のチャンクが続くもので構成されています。各チャンクには、ユーザーデータまたはSCTP制御情報のいずれかが含まれています。送信者側でのバンドルをサポートするSCTP実装により、ユーザーメッセージの送信が遅れて、対応するデータチャンクをバンドルできるようにする可能性があります。"
    },
    {
      "indent": 3,
      "text": "The SCTP user has the option to request that an SCTP implementation does not delay the sending of a user message just for this purpose. However, even if the SCTP user has chosen this option, the SCTP implementation might delay the sending due to other reasons (for example, due to congestion control or flow control) and might also bundle multiple DATA chunks, if possible.",
      "ja": "SCTPユーザーには、SCTP実装がこの目的のためだけにユーザーメッセージの送信を遅らせないことを要求するオプションがあります。ただし、SCTPユーザーがこのオプションを選択したとしても、SCTPの実装は、他の理由（たとえば、混雑制御やフロー制御のため）のために送信を遅らせる可能性があり、可能であれば複数のデータチャンクをバンドルすることもあります。"
    },
    {
      "indent": 0,
      "text": "1.5.6. Packet Validation",
      "section_title": true,
      "ja": "1.5.6. パケット検証"
    },
    {
      "indent": 3,
      "text": "A mandatory Verification Tag field and a 32-bit checksum field (see Appendix A for a description of the 32-bit Cyclic Redundancy Check (CRC32c) checksum) are included in the SCTP common header. The Verification Tag value is chosen by each end of the association during association startup. Packets received without the expected Verification Tag value are discarded, as a protection against blind masquerade attacks and against stale SCTP packets from a previous association. The CRC32c checksum is set by the sender of each SCTP packet to provide additional protection against data corruption in the network. The receiver of an SCTP packet with an invalid CRC32c checksum silently discards the packet.",
      "ja": "必須検証タグフィールドと32ビットチェックサムフィールド（32ビット環状冗長チェック（CRC32C）チェックサムの説明については、付録Aを参照）をSCTP共通ヘッダーに含まれています。確認タグ値は、協会のスタートアップ中に協会の各端によって選択されます。予想される検証タグ値なしで受信されたパケットは、盲検マスカレード攻撃に対する保護および以前の関連付けからの古いSCTPパケットに対する保護として、破棄されます。CRC32Cチェックサムは、各SCTPパケットの送信者によって設定され、ネットワーク内のデータ腐敗に対する追加の保護を提供します。無効なCRC32Cチェックサムを備えたSCTPパケットの受信機は、パケットを静かに破棄します。"
    },
    {
      "indent": 0,
      "text": "1.5.7. Path Management",
      "section_title": true,
      "ja": "1.5.7. パス管理"
    },
    {
      "indent": 3,
      "text": "The sending SCTP user is able to manipulate the set of transport addresses used as destinations for SCTP packets through the primitives described in Section 11. The SCTP path management function monitors reachability through heartbeats when other packet traffic is inadequate to provide this information and advises the SCTP user when reachability of any transport address of the peer endpoint changes. The path management function chooses the destination transport address for each outgoing SCTP packet based on the SCTP user's instructions and the currently perceived reachability status of the eligible destination set. The path management function is also responsible for reporting the eligible set of local transport addresses to the peer endpoint during association startup and for reporting the transport addresses returned from the peer endpoint to the SCTP user.",
      "ja": "送信SCTPユーザーは、セクション11で説明されているプリミティブを介してSCTPパケットの目的地として使用される輸送アドレスのセットを操作できます。SCTPパス管理関数は、他のパケットトラフィックがこの情報を提供し、SCTPにアドバイスするには不十分な場合、心拍を介して到達可能性を監視します。ユーザーピアエンドポイントの輸送アドレスの到達可能性が変更されます。パス管理機能は、SCTPユーザーの命令と適格な宛先セットの現在知覚されている到達可能性ステータスに基づいて、各発信SCTPパケットの宛先輸送アドレスを選択します。パス管理関数は、アソシエーションスタートアップ中に適格なローカルトランスポートアドレスをピアエンドポイントに報告し、ピアエンドポイントからSCTPユーザーに返される輸送アドレスを報告する責任もあります。"
    },
    {
      "indent": 3,
      "text": "At association startup, a primary path is defined for each SCTP endpoint and is used to send SCTP packets normally.",
      "ja": "Association Startupでは、各SCTPエンドポイントに対して主要なパスが定義され、SCTPパケットの正常な送信に使用されます。"
    },
    {
      "indent": 3,
      "text": "On the receiving end, the path management is responsible for verifying the existence of a valid SCTP association to which the inbound SCTP packet belongs before passing it for further processing.",
      "ja": "受信側では、パス管理は、インバウンドSCTPパケットが属する有効なSCTP関連の存在を検証する責任があります。"
    },
    {
      "indent": 3,
      "text": "Note: Path Management and Packet Validation are done at the same time; although described separately above, in reality, they cannot be performed as separate items.",
      "ja": "注：パス管理とパケット検証は同時に行われます。上記で別々に説明していますが、実際には、個別のアイテムとして実行することはできません。"
    },
    {
      "indent": 0,
      "text": "1.6. Serial Number Arithmetic",
      "section_title": true,
      "ja": "1.6. シリアル番号算術"
    },
    {
      "indent": 3,
      "text": "It is essential to remember that the actual Transmission Sequence Number space is finite, though very large. This space ranges from 0 to 2^32 - 1. Since the space is finite, all arithmetic dealing with Transmission Sequence Numbers MUST be performed modulo 2^32. This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2^32 - 1 to 0 again. There are some subtleties to computer modulo arithmetic, so great care has to be taken in programming the comparison of such values. When referring to TSNs, the symbol \"<=\" means \"less than or equal\" (modulo 2^32).",
      "ja": "非常に大きいものの、実際の伝送シーケンス番号スペースは有限であることを覚えておくことが不可欠です。このスペースの範囲は0から2^32-1の範囲です。スペースは有限であるため、伝送シーケンス番号を扱うすべての算術数値を実行する必要があります。この署名されていない算術により、2^32-1から0に再びサイクリングする際のシーケンス数の関係が保持されます。コンピューターモジュロの算術にはいくつかの微妙さがあるので、そのような値の比較をプログラミングする際には細心の注意を払う必要があります。TSNSを参照する場合、シンボル「<=」は「より低い」と意味します（Modulo 2^32）。"
    },
    {
      "indent": 3,
      "text": "Comparisons and arithmetic on TSNs in this document SHOULD use Serial Number Arithmetic, as defined in [RFC1982], where SERIAL_BITS = 32.",
      "ja": "このドキュメントのTSNSの比較と算術は、[RFC1982]で定義されているように、Serial_bits = 32で定義されているシリアル番号算術を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT transmit a DATA chunk with a TSN that is more than 2^31 - 1 above the beginning TSN of its current send window. Doing so will cause problems in comparing TSNs.",
      "ja": "エンドポイントは、現在の送信ウィンドウの最初のTSNより上に2^31-1を超えるTSNを使用してデータチャンクを送信してはなりません。そうすることで、TSNを比較する際に問題が発生します。"
    },
    {
      "indent": 3,
      "text": "Transmission Sequence Numbers wrap around when they reach 2^32 - 1. That is, the next TSN a DATA chunk MUST use after transmitting TSN = 2^32 - 1 is TSN = 0.",
      "ja": "トランスミッションシーケンス番号が2^32-1に達したときにラップを回転させます。つまり、TSN = 2^32-1を送信した後にデータチャンクが使用する必要がある次のTSNはTSN = 0です。"
    },
    {
      "indent": 3,
      "text": "Any arithmetic done on Stream Sequence Numbers SHOULD use Serial Number Arithmetic, as defined in [RFC1982], where SERIAL_BITS = 16. All other arithmetic and comparisons in this document use normal arithmetic.",
      "ja": "ストリームシーケンス番号で行われた算術は、[RFC1982]で定義されているように、Serial_bits = 16で定義されているシリアル番号算術を使用する必要があります。このドキュメントの他のすべての算術と比較は、通常の算術を使用します。"
    },
    {
      "indent": 0,
      "text": "1.7. Changes from RFC 4960",
      "section_title": true,
      "ja": "1.7. RFC 4960からの変更"
    },
    {
      "indent": 3,
      "text": "SCTP was originally defined in [RFC4960], which this document obsoletes. Readers interested in the details of the various changes that this document incorporates are asked to consult [RFC8540].",
      "ja": "SCTPはもともと[RFC4960]で定義されていましたが、この文書は廃止されました。この文書が組み込まれているさまざまな変更の詳細に興味のある読者は、[RFC8540]に相談するように求められます。"
    },
    {
      "indent": 3,
      "text": "In addition to these and further editorial changes, the following changes have been incorporated in this document:",
      "ja": "これらおよびさらなる編集上の変更に加えて、次の変更がこのドキュメントに組み込まれています。"
    },
    {
      "indent": 3,
      "text": "* Update references.",
      "ja": "* 参照を更新します。"
    },
    {
      "indent": 3,
      "text": "* Improve the language related to requirements levels.",
      "ja": "* 要件レベルに関連する言語を改善します。"
    },
    {
      "indent": 3,
      "text": "* Allow the ASSOCIATE primitive to take multiple remote addresses; also refer to the socket API specification.",
      "ja": "* アソシエイトプリミティブが複数のリモートアドレスを取得できるようにします。ソケットAPI仕様も参照してください。"
    },
    {
      "indent": 3,
      "text": "* Refer to the Packetization Layer Path MTU Discovery (PLPMTUD) specification for path MTU discovery.",
      "ja": "* Path MTU Discoveryのパケット化レイヤーパスMTUディスカバリー（PLPMTUD）仕様を参照してください。"
    },
    {
      "indent": 3,
      "text": "* Move the description of ICMP handling from the Appendix to the main text.",
      "ja": "* ICMP処理の説明を付録からメインテキストに移動します。"
    },
    {
      "indent": 3,
      "text": "* Remove the Appendix describing Explicit Congestion Notification (ECN) handling from the document.",
      "ja": "* ドキュメントからの明示的な混雑通知（ECN）処理を説明する付録を削除します。"
    },
    {
      "indent": 3,
      "text": "* Describe the packet size handling more precisely by introducing PMTU, PMDCS, and AMDCS.",
      "ja": "* PMTU、PMDCS、およびAMDCを導入して、より正確に処理するパケットサイズを説明してください。"
    },
    {
      "indent": 3,
      "text": "* Add the definition of control chunk.",
      "ja": "* コントロールチャンクの定義を追加します。"
    },
    {
      "indent": 3,
      "text": "* Improve the description of the handling of INIT and INIT ACK chunks with invalid mandatory parameters.",
      "ja": "* 無効な必須パラメーターを使用して、initとinit ackチャンクの取り扱いの説明を改善します。"
    },
    {
      "indent": 3,
      "text": "* Allow using L > 1 for Appropriate Byte Counting (ABC) during slow start.",
      "ja": "* スロースタート中に適切なバイトカウント（ABC）にL> 1を使用してください。"
    },
    {
      "indent": 3,
      "text": "* Explicitly describe the reinitialization of the congestion controller on route changes.",
      "ja": "* ルートの変更に関する混雑コントローラーの再初期化を明示的に説明してください。"
    },
    {
      "indent": 3,
      "text": "* Improve the terminology to make it clear that this specification does not describe a full mesh architecture.",
      "ja": "* この仕様が完全なメッシュアーキテクチャを説明していないことを明確にするために、用語を改善します。"
    },
    {
      "indent": 3,
      "text": "* Improve the description of sequence number generation (Transmission Sequence Number and Stream Sequence Number).",
      "ja": "* シーケンス数の生成の説明を改善します（伝送シーケンス番号とストリームシーケンス番号）。"
    },
    {
      "indent": 3,
      "text": "* Improve the description of reneging.",
      "ja": "* Renegingの説明を改善します。"
    },
    {
      "indent": 3,
      "text": "* Don't require the change of the Cumulative TSN Ack anymore for increasing the congestion window. This improves the consistency with the handling in congestion avoidance.",
      "ja": "* 混雑ウィンドウを増やすために、累積TSN ACKの変更をもう必要ない。これにより、混雑回避の取り扱いとの一貫性が向上します。"
    },
    {
      "indent": 3,
      "text": "* Improve the description of the State Cookie.",
      "ja": "* State Cookieの説明を改善します。"
    },
    {
      "indent": 3,
      "text": "* Fix the API for retrieving messages in case of association failures.",
      "ja": "* 関連性の障害が発生した場合にメッセージを取得するためにAPIを修正します。"
    },
    {
      "indent": 0,
      "text": "2. Conventions",
      "section_title": true,
      "ja": "2. 規約"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. SCTP Packet Format",
      "section_title": true,
      "ja": "3. SCTPパケット形式"
    },
    {
      "indent": 3,
      "text": "An SCTP packet is composed of a common header and chunks. A chunk contains either control information or user data.",
      "ja": "SCTPパケットは、共通のヘッダーとチャンクで構成されています。チャンクには、制御情報またはユーザーデータのいずれかが含まれます。"
    },
    {
      "indent": 3,
      "text": "The SCTP packet format is shown below:",
      "ja": "SCTPパケット形式を以下に示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Common Header                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Chunk #1                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Chunk #n                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "INIT, INIT ACK, and SHUTDOWN COMPLETE chunks MUST NOT be bundled with any other chunk into an SCTP packet. All other chunks MAY be bundled to form an SCTP packet that does not exceed the PMTU. See Section 6.10 for more details on chunk bundling.",
      "ja": "init、init ack、およびシャットダウン完全チャンクを他のチャンクとsctpパケットにバンドルしてはなりません。他のすべてのチャンクは、PMTUを超えないSCTPパケットを形成するためにバンドルされる場合があります。チャンクバンドルの詳細については、セクション6.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a user data message does not fit into one SCTP packet, it can be fragmented into multiple chunks using the procedure defined in Section 6.9.",
      "ja": "ユーザーデータメッセージが1つのSCTPパケットに収まらない場合、セクション6.9で定義されている手順を使用して、複数のチャンクに断片化できます。"
    },
    {
      "indent": 3,
      "text": "All integer fields in an SCTP packet MUST be transmitted in network byte order, unless otherwise stated.",
      "ja": "SCTPパケット内のすべての整数フィールドは、特に明記しない限り、ネットワークバイトの順序で送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1. SCTP Common Header Field Descriptions",
      "section_title": true,
      "ja": "3.1. SCTP共通ヘッダーフィールドの説明"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Source Port Number       |    Destination Port Number    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Verification Tag                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Checksum                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Source Port Number: 16 bits (unsigned integer) This is the SCTP sender's port number. It can be used by the receiver in combination with the source IP address, the SCTP Destination Port Number, and possibly the destination IP address to identify the association to which this packet belongs. The Source Port Number 0 MUST NOT be used.",
      "ja": "ソースポート番号：16ビット（符号なし整数）これはSCTP送信者のポート番号です。レシーバーは、ソースIPアドレス、SCTP宛先ポート番号、および宛先IPアドレスと組み合わせて使用して、このパケットが属する関連付けを識別できます。ソースポート番号0を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Destination Port Number: 16 bits (unsigned integer) This is the SCTP port number to which this packet is destined. The receiving host will use this port number to de-multiplex the SCTP packet to the correct receiving endpoint/application. The Destination Port Number 0 MUST NOT be used.",
      "ja": "宛先ポート番号：16ビット（符号なし整数）これは、このパケットが運命づけられているSCTPポート番号です。受信ホストは、このポート番号を使用して、SCTPパケットを正しい受信エンドポイント/アプリケーションに脱マルテックスします。宛先ポート番号0を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Verification Tag: 32 bits (unsigned integer) The receiver of an SCTP packet uses the Verification Tag to validate the sender of this packet. On transmit, the value of the Verification Tag MUST be set to the value of the Initiate Tag received from the peer endpoint during the association initialization, with the following exceptions:",
      "ja": "検証タグ：32ビット（符号なし整数）SCTPパケットの受信機は、検証タグを使用してこのパケットの送信者を検証します。送信時に、検証タグの値は、次の例外を除き、Associationの初期化中にピアエンドポイントから受信した開始タグの値に設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "* A packet containing an INIT chunk MUST have a zero Verification Tag.",
      "ja": "* initチャンクを含むパケットには、ゼロ検証タグが必要です。"
    },
    {
      "indent": 6,
      "text": "* A packet containing a SHUTDOWN COMPLETE chunk with the T bit set MUST have the Verification Tag copied from the packet with the SHUTDOWN ACK chunk.",
      "ja": "* Tビットセットを備えたシャットダウン完全チャンクを含むパケットには、シャットダウンACKチャンクでパケットからコピーされた検証タグが必要です。"
    },
    {
      "indent": 6,
      "text": "* A packet containing an ABORT chunk MAY have the Verification Tag copied from the packet that caused the ABORT chunk to be sent. For details, see Sections 8.4 and 8.5.",
      "ja": "* 中止チャンクを含むパケットには、中止チャンクが送信される原因となったパケットから検証タグがコピーされる場合があります。詳細については、セクション8.4および8.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "Checksum: 32 bits (unsigned integer) This field contains the checksum of the SCTP packet. Its calculation is discussed in Section 6.8. SCTP uses the CRC32c algorithm as described in Appendix A for calculating the checksum.",
      "ja": "チェックサム：32ビット（符号なし整数）このフィールドには、SCTPパケットのチェックサムが含まれています。その計算については、セクション6.8で説明します。SCTPは、チェックサムを計算するために付録Aで説明されているようにCRC32Cアルゴリズムを使用します。"
    },
    {
      "indent": 0,
      "text": "3.2. Chunk Field Descriptions",
      "section_title": true,
      "ja": "3.2. チャンクフィールドの説明"
    },
    {
      "indent": 3,
      "text": "The figure below illustrates the field format for the chunks to be transmitted in the SCTP packet. Each chunk is formatted with a Chunk Type field, a Chunk Flags field, a Chunk Length field, and a Chunk Value field.",
      "ja": "以下の図は、SCTPパケットで送信されるチャンクのフィールド形式を示しています。各チャンクは、チャンクタイプフィールド、チャンクフラグフィールド、チャンク長フィールド、およびチャンク値フィールドでフォーマットされています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Chunk Type   |  Chunk Flags  |         Chunk Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                          Chunk Value                          /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Type: 8 bits (unsigned integer) This field identifies the type of information contained in the Chunk Value field. It takes a value from 0 to 254. The value of 255 is reserved for future use as an extension field.",
      "ja": "チャンクタイプ：8ビット（符号なし整数）このフィールドは、チャンク値フィールドに含まれる情報のタイプを識別します。値は0から254です。255の値は、拡張フィールドとして将来使用するために予約されています。"
    },
    {
      "indent": 6,
      "text": "The values of Chunk Types defined in this document are as follows:",
      "ja": "このドキュメントで定義されているチャンクタイプの値は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "+==========+===========================================+\n| ID Value | Chunk Type                                |\n+==========+===========================================+\n| 0        | Payload Data (DATA)                       |\n+----------+-------------------------------------------+\n| 1        | Initiation (INIT)                         |\n+----------+-------------------------------------------+\n| 2        | Initiation Acknowledgement (INIT ACK)     |\n+----------+-------------------------------------------+\n| 3        | Selective Acknowledgement (SACK)          |\n+----------+-------------------------------------------+\n| 4        | Heartbeat Request (HEARTBEAT)             |\n+----------+-------------------------------------------+\n| 5        | Heartbeat Acknowledgement (HEARTBEAT ACK) |\n+----------+-------------------------------------------+\n| 6        | Abort (ABORT)                             |\n+----------+-------------------------------------------+\n| 7        | Shutdown (SHUTDOWN)                       |\n+----------+-------------------------------------------+\n| 8        | Shutdown Acknowledgement (SHUTDOWN ACK)   |\n+----------+-------------------------------------------+\n| 9        | Operation Error (ERROR)                   |\n+----------+-------------------------------------------+\n| 10       | State Cookie (COOKIE ECHO)                |\n+----------+-------------------------------------------+\n| 11       | Cookie Acknowledgement (COOKIE ACK)       |\n+----------+-------------------------------------------+\n| 12       | Reserved for Explicit Congestion          |\n|          | Notification Echo (ECNE)                  |\n+----------+-------------------------------------------+\n| 13       | Reserved for Congestion Window Reduced    |\n|          | (CWR)                                     |\n+----------+-------------------------------------------+\n| 14       | Shutdown Complete (SHUTDOWN COMPLETE)     |\n+----------+-------------------------------------------+\n| 15 to 62 | Unassigned                                |\n+----------+-------------------------------------------+\n| 63       | Reserved for IETF-defined Chunk           |\n|          | Extensions                                |\n+----------+-------------------------------------------+\n| 64 to    | Unassigned                                |\n| 126      |                                           |\n+----------+-------------------------------------------+\n| 127      | Reserved for IETF-defined Chunk           |\n|          | Extensions                                |\n+----------+-------------------------------------------+\n| 128 to   | Unassigned                                |\n| 190      |                                           |\n+----------+-------------------------------------------+\n| 191      | Reserved for IETF-defined Chunk           |\n|          | Extensions                                |\n+----------+-------------------------------------------+\n| 192 to   | Unassigned                                |\n| 254      |                                           |\n+----------+-------------------------------------------+\n| 255      | Reserved for IETF-defined Chunk           |\n|          | Extensions                                |\n+----------+-------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 29,
      "text": "Table 1: Chunk Types",
      "ja": "表1：チャンクタイプ"
    },
    {
      "indent": 6,
      "text": "Note: The ECNE and CWR chunk types are reserved for future use of Explicit Congestion Notification (ECN).",
      "ja": "注：ECNEおよびCWRチャンクタイプは、明示的な混雑通知（ECN）の将来の使用のために予約されています。"
    },
    {
      "indent": 6,
      "text": "Chunk Types are encoded such that the highest-order 2 bits specify the action that is taken if the processing endpoint does not recognize the Chunk Type.",
      "ja": "チャンクタイプは、最大の2ビットが処理エンドポイントがチャンクタイプを認識しない場合に実行されるアクションを指定するようにエンコードされます。"
    },
    {
      "indent": 10,
      "text": "+----+--------------------------------------------------+\n| 00 | Stop processing this SCTP packet and discard the |\n|    | unrecognized chunk and all further chunks.       |\n+----+--------------------------------------------------+\n| 01 | Stop processing this SCTP packet, discard the    |\n|    | unrecognized chunk and all further chunks, and   |\n|    | report the unrecognized chunk in an ERROR chunk  |\n|    | using the 'Unrecognized Chunk Type' error cause. |\n+----+--------------------------------------------------+\n| 10 | Skip this chunk and continue processing.         |\n+----+--------------------------------------------------+\n| 11 | Skip this chunk and continue processing, but     |\n|    | report it in an ERROR chunk using the            |\n|    | 'Unrecognized Chunk Type' error cause.           |\n+----+--------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 2: Processing of Unknown Chunks",
      "ja": "表2：不明なチャンクの処理"
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits The usage of these bits depends on the Chunk Type, as given by the Chunk Type field. Unless otherwise specified, they are set to 0 on transmit and are ignored on receipt.",
      "ja": "チャンクフラグ：8ビットこれらのビットの使用は、チャンクタイプフィールドで与えられたチャンクタイプに依存します。特に指定されていない限り、送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Chunk Length: 16 bits (unsigned integer) This value represents the size of the chunk in bytes, including the Chunk Type, Chunk Flags, Chunk Length, and Chunk Value fields. Therefore, if the Chunk Value field is zero-length, the Length field will be set to 4. The Chunk Length field does not count any chunk padding. However, it does include any padding of variable-length parameters other than the last parameter in the chunk.",
      "ja": "チャンク長：16ビット（符号なし整数）この値は、チャンクタイプ、チャンクフラグ、チャンク長、チャンク値フィールドなど、バイトのチャンクのサイズを表します。したがって、チャンク値フィールドがゼロ長の場合、長さフィールドは4に設定されます。チャンク長フィールドはチャンクパディングをカウントしません。ただし、チャンクの最後のパラメーター以外の可変長パラメーターのパディングが含まれます。"
    },
    {
      "indent": 6,
      "text": "Note: A robust implementation is expected to accept the chunk whether or not the final padding has been included in the Chunk Length.",
      "ja": "注：最終的なパディングがチャンクの長さに含まれているかどうかにかかわらず、堅牢な実装はチャンクを受け入れることが期待されます。"
    },
    {
      "indent": 3,
      "text": "Chunk Value: variable length The Chunk Value field contains the actual information to be transferred in the chunk. The usage and format of this field is dependent on the Chunk Type.",
      "ja": "チャンク値：変動長チャンク値フィールドには、チャンクで転送される実際の情報が含まれています。このフィールドの使用法と形式は、チャンクタイプに依存します。"
    },
    {
      "indent": 3,
      "text": "The total length of a chunk (including Type, Length, and Value fields) MUST be a multiple of 4 bytes. If the length of the chunk is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes, and this padding is not included in the Chunk Length field. The sender MUST NOT pad with more than 3 bytes. The receiver MUST ignore the padding bytes.",
      "ja": "チャンクの全長（タイプ、長さ、値フィールドを含む）は、4バイトの倍数でなければなりません。チャンクの長さが4バイトの倍数ではない場合、送信者はすべてのゼロバイトでチャンクを埋める必要があり、このパディングはチャンク長フィールドに含まれていません。送信者は、3バイト以上のパッドをパッドしてはなりません。受信機は、パディングバイトを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "SCTP-defined chunks are described in detail in Section 3.3. The guidelines for IETF-defined chunk extensions can be found in Section 15.1 of this document.",
      "ja": "SCTP定義のチャンクについては、セクション3.3で詳しく説明しています。IETF定義のチャンク拡張機能のガイドラインは、このドキュメントのセクション15.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Optional/Variable-Length Parameter Format",
      "section_title": true,
      "ja": "3.2.1. オプション/変数長パラメーター形式"
    },
    {
      "indent": 3,
      "text": "Chunk values of SCTP control chunks consist of a chunk-type-specific header of required fields, followed by zero or more parameters. The optional and variable-length parameters contained in a chunk are defined in a Type-Length-Value format, as shown below.",
      "ja": "SCTPコントロールチャンクのチャンク値は、必要なフィールドのチャンクタイプ固有のヘッダーで構成され、その後はゼロ以上のパラメーターが続きます。チャンクに含まれるオプションおよび可変長パラメーターは、以下に示すように、タイプ長価値形式で定義されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Parameter Type         |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                        Parameter Value                        /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Parameter Type: 16 bits (unsigned integer) The Type field is a 16-bit identifier of the type of parameter. It takes a value of 0 to 65534.",
      "ja": "パラメータータイプ：16ビット（符号なし整数）タイプフィールドは、パラメーターのタイプの16ビット識別子です。0〜65534の値が必要です。"
    },
    {
      "indent": 6,
      "text": "The value of 65535 is reserved for IETF-defined extensions. Values other than those defined in specific SCTP chunk descriptions are reserved for use by IETF.",
      "ja": "65535の値は、IETF定義の拡張機能用に予約されています。特定のSCTPチャンク説明で定義されている値以外の値は、IETFが使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "Parameter Length: 16 bits (unsigned integer) The Parameter Length field contains the size of the parameter in bytes, including the Parameter Type, Parameter Length, and Parameter Value fields. Thus, a parameter with a zero-length Parameter Value field would have a Parameter Length field of 4. The Parameter Length does not include any padding bytes.",
      "ja": "パラメーターの長さ：16ビット（符号なし整数）パラメーター長さフィールドには、パラメータータイプ、パラメーター長、およびパラメーター値フィールドを含むバイトのパラメーターのサイズが含まれます。したがって、ゼロ長いパラメーター値フィールドを持つパラメーターには、パラメーターの長さフィールドが4になります。パラメーターの長さには、パディングバイトが含まれません。"
    },
    {
      "indent": 3,
      "text": "Parameter Value: variable length The Parameter Value field contains the actual information to be transferred in the parameter.",
      "ja": "パラメーター値：変数長さパラメーター値フィールドには、パラメーターで転送される実際の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The total length of a parameter (including Parameter Type, Parameter Length, and Parameter Value fields) MUST be a multiple of 4 bytes. If the length of the parameter is not a multiple of 4 bytes, the sender pads the parameter at the end (i.e., after the Parameter Value field) with all zero bytes. The length of the padding is not included in the Parameter Length field. A sender MUST NOT pad with more than 3 bytes. The receiver MUST ignore the padding bytes.",
      "ja": "パラメーターの合計長（パラメータータイプ、パラメーター長、およびパラメーター値フィールドを含む）は、4バイトの倍数でなければなりません。パラメーターの長さが4バイトの倍数でない場合、送信者はすべてのゼロバイトを持つ最後のパラメーター（つまり、パラメーター値フィールドの後）にパッドをパッドします。パディングの長さは、パラメーターの長さフィールドに含まれていません。送信者は、3バイト以上のパッドをパッドしてはなりません。受信機は、パディングバイトを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Parameter Types are encoded such that the highest-order 2 bits specify the action that is taken if the processing endpoint does not recognize the Parameter Type.",
      "ja": "パラメータータイプは、最大の2ビットが処理エンドポイントがパラメータータイプを認識しない場合に実行されるアクションを指定するようにエンコードされます。"
    },
    {
      "indent": 6,
      "text": "+----+--------------------------------------------------------+\n| 00 | Stop processing this parameter and do not process any  |\n|    | further parameters within this chunk.                  |\n+----+--------------------------------------------------------+\n| 01 | Stop processing this parameter, do not process any     |\n|    | further parameters within this chunk, and report the   |\n|    | unrecognized parameter, as described in Section 3.2.2. |\n+----+--------------------------------------------------------+\n| 10 | Skip this parameter and continue processing.           |\n+----+--------------------------------------------------------+\n| 11 | Skip this parameter and continue processing, but       |\n|    | report the unrecognized parameter, as described in     |\n|    | Section 3.2.2.                                         |\n+----+--------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 3: Processing of Unknown Parameters",
      "ja": "表3：不明なパラメーターの処理"
    },
    {
      "indent": 3,
      "text": "Please note that, when an INIT or INIT ACK chunk is received, in all four cases, an INIT ACK or COOKIE ECHO chunk is sent in response, respectively. In the 00 or 01 case, the processing of the parameters after the unknown parameter is canceled, but no processing already done is rolled back.",
      "ja": "INITまたはINIT ACKチャンクを受信した場合、4つのケースすべてで、それぞれ応答してINIT ACKまたはCookieエコーチャンクが送信されることに注意してください。00または01のケースでは、不明なパラメーターがキャンセルされた後のパラメーターの処理がキャンセルされましたが、すでに実行されていない処理は巻き戻されていません。"
    },
    {
      "indent": 3,
      "text": "The actual SCTP parameters are defined in the specific SCTP chunk sections. The rules for IETF-defined parameter extensions are defined in Section 15.3. Parameter types MUST be unique across all chunks. For example, the parameter type '5' is used to represent an IPv4 address (see Section 3.3.2.1.1). The value '5' then is reserved across all chunks to represent an IPv4 address and MUST NOT be reused with a different meaning in any other chunk.",
      "ja": "実際のSCTPパラメーターは、特定のSCTPチャンクセクションで定義されています。IETF定義のパラメーター拡張機能のルールは、セクション15.3で定義されています。パラメータータイプは、すべてのチャンクにわたって一意でなければなりません。たとえば、パラメータータイプ '5'は、IPv4アドレスを表すために使用されます（セクション3.3.2.1.1を参照）。値「5」は、IPv4アドレスを表すためにすべてのチャンクにわたって予約されており、他のチャンクで異なる意味で再利用してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Reporting of Unrecognized Parameters",
      "section_title": true,
      "ja": "3.2.2. 認識されていないパラメーターのレポート"
    },
    {
      "indent": 3,
      "text": "If the receiver of an INIT chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it MUST put the \"Unrecognized Parameter\" parameter(s) in the INIT ACK chunk sent in response to the INIT chunk. Note that, if the receiver of the INIT chunk is not going to establish an association (e.g., due to lack of resources), an \"Unrecognized Parameters\" error cause would not be included with any ABORT chunk being sent to the sender of the INIT chunk.",
      "ja": "init chunkの受信者が認識されていないパラメーターを検出し、セクション3.2.1に従ってそれらを報告する必要がある場合、initチャンクに応じて送信されたinit ackチャンクに「認識されていないパラメーター」パラメーターを配置する必要があります。initチャンクの受信者が関連性を確立しない場合（例えば、リソースの不足により）、「認識されていないパラメーター」エラー原因は、initの送信者に送信される中止チャンクに含まれないことに注意してください。かたまり。"
    },
    {
      "indent": 3,
      "text": "If the receiver of any other chunk (e.g., INIT ACK) detects unrecognized parameters and has to report them according to Section 3.2.1, it SHOULD bundle the ERROR chunk containing the \"Unrecognized Parameters\" error cause with the chunk sent in response (e.g., COOKIE ECHO). If the receiver of an INIT ACK chunk cannot bundle the COOKIE ECHO chunk with the ERROR chunk, the ERROR chunk MAY be sent separately but not before the COOKIE ACK chunk has been received.",
      "ja": "他のチャンクの受信機（例：init ACK）が認識されていないパラメーターを検出し、セクション3.2.1に従ってそれらを報告する必要がある場合、「認識されていないパラメーター」を含むエラーチャンクをバンドルする必要があります。、クッキーエコー）。init ackチャンクの受信機がエラーチャンクでクッキーエコーチャンクをバンドルできない場合、クッキーackチャンクが受信される前ではなく、エラーチャンクを個別に送信できます。"
    },
    {
      "indent": 3,
      "text": "Any time a COOKIE ECHO chunk is sent in a packet, it MUST be the first chunk.",
      "ja": "Cookie Echo Chunkがパケットに送られるときはいつでも、それは最初のチャンクである必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. SCTP Chunk Definitions",
      "section_title": true,
      "ja": "3.3. SCTPチャンク定義"
    },
    {
      "indent": 3,
      "text": "This section defines the format of the different SCTP chunk types.",
      "ja": "このセクションでは、さまざまなSCTPチャンクタイプの形式を定義します。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Payload Data (DATA) (0)",
      "section_title": true,
      "ja": "3.3.1. ペイロードデータ（データ）（0）"
    },
    {
      "indent": 3,
      "text": "The following format MUST be used for the DATA chunk:",
      "ja": "次の形式は、データチャンクに使用する必要があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 0    |  Res  |I|U|B|E|            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              TSN                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Stream Identifier S      |   Stream Sequence Number n    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  Payload Protocol Identifier                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                 User Data (seq n of Stream S)                 /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Res: 4 bits All set to 0 on transmit and ignored on receipt.",
      "ja": "Res：4ビットはすべて送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "I bit: 1 bit The (I)mmediate bit MAY be set by the sender whenever the sender of a DATA chunk can benefit from the corresponding SACK chunk being sent back without delay. See Section 4 of [RFC7053] for a discussion of the benefits.",
      "ja": "私はビット：1ビットデータチャンクの送信者が、対応するサックチャンクが遅滞なく送り返されることから利益を得ることができるときはいつでも、送信者によって設定される場合があります。利点の議論については、[RFC7053]のセクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "U bit: 1 bit The (U)nordered bit, if set to 1, indicates that this is an unordered DATA chunk, and there is no Stream Sequence Number assigned to this DATA chunk. Therefore, the receiver MUST ignore the Stream Sequence Number field.",
      "ja": "uビット：1ビット（u）norderedビットは、1に設定されている場合、これが順序付けられていないデータチャンクであり、このデータチャンクに割り当てられたストリームシーケンス番号がないことを示します。したがって、レシーバーはストリームシーケンス番号フィールドを無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "After reassembly (if necessary), unordered DATA chunks MUST be dispatched to the upper layer by the receiver without any attempt to reorder.",
      "ja": "再組み立て後（必要に応じて）、順序付けられていないデータチャンクを、並べ替えを試みずに受信機によって上層に派遣する必要があります。"
    },
    {
      "indent": 6,
      "text": "If an unordered user message is fragmented, each fragment of the message MUST have its U bit set to 1.",
      "ja": "順序付けられていないユーザーメッセージが断片化されている場合、メッセージの各フラグメントはuビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "B bit: 1 bit The (B)eginning fragment bit, if set, indicates the first fragment of a user message.",
      "ja": "bビット：1ビット（b）eginningフラグメントビットは、設定されている場合、ユーザーメッセージの最初のフラグメントを示します。"
    },
    {
      "indent": 3,
      "text": "E bit: 1 bit The (E)nding fragment bit, if set, indicates the last fragment of a user message.",
      "ja": "eビット：1ビット（e）ndingフラグメントビットは、設定されている場合、ユーザーメッセージの最後のフラグメントを示します。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer) This field indicates the length of the DATA chunk in bytes from the beginning of the type field to the end of the User Data field excluding any padding. A DATA chunk with one byte of user data will have the Length field set to 17 (indicating 17 bytes).",
      "ja": "長さ：16ビット（符号なし整数）このフィールドは、パディングを除くタイプフィールドの先頭からユーザーデータフィールドの最後までバイト単位のデータチャンクの長さを示します。1バイトのユーザーデータを備えたデータチャンクの長さフィールドは17に設定されています（17バイトを示します）。"
    },
    {
      "indent": 6,
      "text": "A DATA chunk with a User Data field of length L will have the Length field set to (16 + L) (indicating 16 + L bytes) where L MUST be greater than 0.",
      "ja": "長さlのユーザーデータフィールドを持つデータチャンクの長さフィールドは（16 L）（16 Lバイトを示す）に設定され、Lは0より大きくする必要があります。"
    },
    {
      "indent": 3,
      "text": "TSN: 32 bits (unsigned integer) This value represents the TSN for this DATA chunk. The valid range of TSN is from 0 to 4294967295 (2^32 - 1). TSN wraps back to 0 after reaching 4294967295.",
      "ja": "TSN：32ビット（符号なし整数）この値は、このデータチャンクのTSNを表します。TSNの有効な範囲は0〜4294967295（2^32-1）です。TSNは4294967295に達した後、0に戻ります。"
    },
    {
      "indent": 3,
      "text": "Stream Identifier S: 16 bits (unsigned integer) Identifies the stream to which the following user data belongs.",
      "ja": "ストリーム識別子s：16ビット（符号なし整数）は、次のユーザーデータが属するストリームを識別します。"
    },
    {
      "indent": 3,
      "text": "Stream Sequence Number n: 16 bits (unsigned integer) This value represents the Stream Sequence Number of the following user data within the stream S. Valid range is 0 to 65535.",
      "ja": "ストリームシーケンス番号n：16ビット（符号なし整数）この値は、ストリームS内の次のユーザーデータのストリームシーケンス番号を表します。有効な範囲は0〜65535です。"
    },
    {
      "indent": 6,
      "text": "When a user message is fragmented by SCTP for transport, the same Stream Sequence Number MUST be carried in each of the fragments of the message.",
      "ja": "ユーザーメッセージが輸送のためにSCTPによって断片化されている場合、メッセージの各フラグメントに同じストリームシーケンス番号を掲載する必要があります。"
    },
    {
      "indent": 3,
      "text": "Payload Protocol Identifier: 32 bits (unsigned integer) This value represents an application (or upper layer) specified protocol identifier. This value is passed to SCTP by its upper layer and sent to its peer. This identifier is not used by SCTP but can be used by certain network entities, as well as by the peer application, to identify the type of information being carried in this DATA chunk. This field MUST be sent even in fragmented DATA chunks (to make sure it is available for agents in the middle of the network). Note that this field is not touched by an SCTP implementation; the upper layer is responsible for the host to network byte order conversion of this field.",
      "ja": "ペイロードプロトコル識別子：32ビット（符号なし整数）この値は、アプリケーション（または上層）指定されたプロトコル識別子を表します。この値は、上層によってSCTPに渡され、ピアに送信されます。この識別子はSCTPでは使用されませんが、特定のネットワークエンティティとピアアプリケーションで使用することができ、このデータチャンクで実行される情報のタイプを識別します。このフィールドは、断片化されたデータチャンクでも送信する必要があります（ネットワークの中央にあるエージェントが利用できることを確認するには）。このフィールドは、SCTP実装によって触れられていないことに注意してください。上層層は、このフィールドのホストがバイトの順序変換をネットワークにする責任があります。"
    },
    {
      "indent": 6,
      "text": "The value 0 indicates that no application identifier is specified by the upper layer for this payload data.",
      "ja": "値0は、このペイロードデータの上層によって指定されているアプリケーション識別子が指定されていないことを示します。"
    },
    {
      "indent": 3,
      "text": "User Data: variable length This is the payload user data. The implementation MUST pad the end of the data to a 4-byte boundary with all zero bytes. Any padding MUST NOT be included in the Length field. A sender MUST never add more than 3 bytes of padding.",
      "ja": "ユーザーデータ：可変長さがペイロードユーザーデータです。実装は、データの最後をすべてのゼロバイトで4バイトの境界に埋めなければなりません。パディングは長さフィールドに含めてはなりません。送信者は、3バイト以上のパディングを追加してはいけません。"
    },
    {
      "indent": 3,
      "text": "An unfragmented user message MUST have both the B and E bits set to 1. Setting both B and E bits to 0 indicates a middle fragment of a multi-fragment user message, as summarized in the following table:",
      "ja": "fragmented Unfragmentedユーザーメッセージには、BとEビットの両方を1に設定する必要があります。BビットとEビットの両方を0に設定すると、次の表にまとめたように、マルチフラグメントユーザーメッセージの中央フラグメントを示します。"
    },
    {
      "indent": 11,
      "text": "+===+===+===========================================+\n| B | E |                Description                |\n+===+===+===========================================+\n| 1 | 0 |  First piece of a fragmented user message |\n+---+---+-------------------------------------------+\n| 0 | 0 | Middle piece of a fragmented user message |\n+---+---+-------------------------------------------+\n| 0 | 1 |  Last piece of a fragmented user message  |\n+---+---+-------------------------------------------+\n| 1 | 1 |            Unfragmented message           |\n+---+---+-------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 4: Fragment Description Flags",
      "ja": "表4：フラグメント説明フラグ"
    },
    {
      "indent": 3,
      "text": "When a user message is fragmented into multiple chunks, the TSNs are used by the receiver to reassemble the message. This means that the TSNs for each fragment of a fragmented user message MUST be strictly sequential.",
      "ja": "ユーザーメッセージが複数のチャンクに断片化されると、TSNは受信者によって使用されてメッセージを再組み立てします。これは、断片化されたユーザーメッセージの各フラグメントのTSNSが厳密に順次必要でなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The TSNs of DATA chunks sent SHOULD be strictly sequential.",
      "ja": "送信されるデータチャンクのTSNは、厳密に順番に行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The extension described in [RFC8260] can be used to mitigate the head of line blocking when transferring large user messages.",
      "ja": "注：[RFC8260]で説明されている拡張機能を使用して、大規模なユーザーメッセージを転送するときにラインブロッキングのヘッドを軽減できます。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Initiation (INIT) (1)",
      "section_title": true,
      "ja": "3.3.2. 開始（init）（1）"
    },
    {
      "indent": 3,
      "text": "This chunk is used to initiate an SCTP association between two endpoints. The format of the INIT chunk is shown below:",
      "ja": "このチャンクは、2つのエンドポイント間のSCTP関連を開始するために使用されます。initチャンクの形式を以下に示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 1    |  Chunk Flags  |      Chunk Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Initiate Tag                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Advertised Receiver Window Credit (a_rwnd)           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Number of Outbound Streams   |   Number of Inbound Streams   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Initial TSN                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/              Optional/Variable-Length Parameters              /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following parameters are specified for the INIT chunk. Unless otherwise noted, each parameter MUST only be included once in the INIT chunk.",
      "ja": "INITチャンクには、次のパラメーターが指定されています。特に明記しない限り、各パラメーターはinit chunkに1回しか含める必要があります。"
    },
    {
      "indent": 13,
      "text": "+===================================+===========+\n| Fixed-Length Parameter            | Status    |\n+===================================+===========+\n| Initiate Tag                      | Mandatory |\n+-----------------------------------+-----------+\n| Advertised Receiver Window Credit | Mandatory |\n+-----------------------------------+-----------+\n| Number of Outbound Streams        | Mandatory |\n+-----------------------------------+-----------+\n| Number of Inbound Streams         | Mandatory |\n+-----------------------------------+-----------+\n| Initial TSN                       | Mandatory |\n+-----------------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 5: Fixed-Length Parameters of INIT Chunks",
      "ja": "表5：initチャンクの固定長のパラメーター"
    },
    {
      "indent": 4,
      "text": "+===================================+============+================+\n| Variable-Length Parameter         | Status     | Type Value     |\n+===================================+============+================+\n| IPv4 Address (Note 1)             | Optional   | 5              |\n+-----------------------------------+------------+----------------+\n| IPv6 Address (Note 1)             | Optional   | 6              |\n+-----------------------------------+------------+----------------+\n| Cookie Preservative               | Optional   | 9              |\n+-----------------------------------+------------+----------------+\n| Reserved for ECN Capable (Note 2) | Optional   | 32768 (0x8000) |\n+-----------------------------------+------------+----------------+\n| Host Name Address (Note 3)        | Deprecated | 11             |\n+-----------------------------------+------------+----------------+\n| Supported Address Types (Note 4)  | Optional   | 12             |\n+-----------------------------------+------------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 6: Variable-Length Parameters of INIT Chunks",
      "ja": "表6：initチャンクの可変長パラメーター"
    },
    {
      "indent": 3,
      "text": "Note 1: The INIT chunks can contain multiple addresses that can be IPv4 and/or IPv6 in any combination.",
      "ja": "注1：initチャンクには、任意の組み合わせでIPv4および/またはIPv6になる可能性のある複数のアドレスを含めることができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: The ECN Capable field is reserved for future use of Explicit Congestion Notification.",
      "ja": "注2：ECN有能なフィールドは、明示的な混雑通知の将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Note 3: An INIT chunk MUST NOT contain the Host Name Address parameter. The receiver of an INIT chunk containing a Host Name Address parameter MUST send an ABORT chunk and MAY include an \"Unresolvable Address\" error cause.",
      "ja": "注3：initチャンクには、ホスト名アドレスパラメーターを含めてはなりません。ホスト名アドレスパラメーターを含むinitチャンクの受信機には、中止チャンクを送信する必要があり、「解決できないアドレス」エラー原因を含めることができます。"
    },
    {
      "indent": 3,
      "text": "Note 4: This parameter, when present, specifies all the address types the sending endpoint can support. The absence of this parameter indicates that the sending endpoint can support any address type.",
      "ja": "注4：このパラメーターは、存在する場合、送信エンドポイントがサポートできるすべてのアドレスタイプを指定します。このパラメーターがないことは、送信エンドポイントが任意のアドレスタイプをサポートできることを示しています。"
    },
    {
      "indent": 3,
      "text": "If an INIT chunk is received with all mandatory parameters that are specified for the INIT chunk, then the receiver SHOULD process the INIT chunk and send back an INIT ACK. The receiver of the INIT chunk MAY bundle an ERROR chunk with the COOKIE ACK chunk later. However, restrictive implementations MAY send back an ABORT chunk in response to the INIT chunk.",
      "ja": "initチャンクに指定されたすべての必須パラメーターでinitチャンクが受信された場合、受信者はinitチャンクを処理し、init ackを送り返す必要があります。init chunkの受信者は、後でCookie ACKチャンクでエラーチャンクを束ねる場合があります。ただし、制限的な実装は、initチャンクに応じて中止チャンクを送り返す場合があります。"
    },
    {
      "indent": 3,
      "text": "The Chunk Flags field in INIT chunks is reserved, and all bits in it SHOULD be set to 0 by the sender and ignored by the receiver.",
      "ja": "initチャンクのチャンクフラグフィールドは予約されており、その中のすべてのビットは送信者によって0に設定され、レシーバーによって無視される必要があります。"
    },
    {
      "indent": 3,
      "text": "Initiate Tag: 32 bits (unsigned integer) The receiver of the INIT chunk (the responding end) records the value of the Initiate Tag parameter. This value MUST be placed into the Verification Tag field of every SCTP packet that the receiver of the INIT chunk transmits within this association.",
      "ja": "開始タグ：32ビット（符号なし整数）init chunk（応答端）の受信機は、initiateタグパラメーターの値を記録します。この値は、initチャンクの受信者がこの関連付け内に送信するすべてのSCTPパケットの検証タグフィールドに配置する必要があります。"
    },
    {
      "indent": 6,
      "text": "The Initiate Tag is allowed to have any value except 0. See Section 5.3.1 for more on the selection of the tag value.",
      "ja": "Initiateタグには、0以外の値が許可されます。タグ値の選択については、セクション5.3.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "If the value of the Initiate Tag in a received INIT chunk is found to be 0, the receiver MUST silently discard the packet.",
      "ja": "受信したinitチャンクの開始タグの値が0であることがわかった場合、受信者はパケットを静かに破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer) This value represents the dedicated buffer space, in number of bytes, the sender of the INIT chunk has reserved in association with this window.",
      "ja": "広告の受信機ウィンドウクレジット（A_RWND）：32ビット（符号なし整数）この値は、専用のバッファースペースを表します。バイト数で、initチャンクの送信者はこのウィンドウに関連して予約されています。"
    },
    {
      "indent": 6,
      "text": "The Advertised Receiver Window Credit MUST NOT be smaller than 1500.",
      "ja": "広告されたレシーバーウィンドウクレジットは、1500を超えてはなりません。"
    },
    {
      "indent": 6,
      "text": "A receiver of an INIT chunk with the a_rwnd value set to a value smaller than 1500 MUST discard the packet, SHOULD send a packet in response containing an ABORT chunk and using the Initiate Tag as the Verification Tag, and MUST NOT change the state of any existing association.",
      "ja": "1500未満の値に設定されたA_RWND値を使用したinitチャンクの受信者は、パケットを破棄する必要があります。中止チャンクを含み、検証タグとして開始タグを使用してパケットを送信する必要があります。既存の協会。"
    },
    {
      "indent": 6,
      "text": "During the life of the association, this buffer space SHOULD NOT be reduced (i.e., dedicated buffers ought not to be taken away from this association); however, an endpoint MAY change the value of a_rwnd it sends in SACK chunks.",
      "ja": "協会の存続期間中、このバッファースペースを減らすべきではありません（つまり、専用のバッファーをこの協会から奪うべきではありません）。ただし、エンドポイントは、サックチャンクで送信するA_RWNDの値を変更する場合があります。"
    },
    {
      "indent": 3,
      "text": "Number of Outbound Streams (OS): 16 bits (unsigned integer) Defines the number of outbound streams the sender of this INIT chunk wishes to create in this association. The value of 0 MUST NOT be used.",
      "ja": "アウトバウンドストリームの数（OS）：16ビット（符号なし整数）は、この協会で作成したいこのInit Chunkの送信者の送信者の数を定義します。0の値を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "A receiver of an INIT chunk with the OS value set to 0 MUST discard the packet, SHOULD send a packet in response containing an ABORT chunk and using the Initiate Tag as the Verification Tag, and MUST NOT change the state of any existing association.",
      "ja": "OS値を0に設定したINITチャンクの受信機は、パケットを破棄し、中止チャンクを含み、検証タグとして開始タグを使用してパケットを送信する必要があり、既存の関連付けの状態を変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "Number of Inbound Streams (MIS): 16 bits (unsigned integer) Defines the maximum number of streams the sender of this INIT chunk allows the peer end to create in this association. The value 0 MUST NOT be used.",
      "ja": "インバウンドストリームの数（MIS）：16ビット（符号なし整数）は、このinitチャンクの送信者がこの関連性にピアエンドを作成できる最大数のストリームを定義します。値0を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: There is no negotiation of the actual number of streams; instead, the two endpoints will use the min(requested, offered). See Section 5.1.1 for details.",
      "ja": "注：実際のストリーム数の交渉はありません。代わりに、2つのエンドポイントはMIN（要求、提供された）を使用します。詳細については、セクション5.1.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "A receiver of an INIT chunk with the MIS value set to 0 MUST discard the packet, SHOULD send a packet in response containing an ABORT chunk and using the Initiate Tag as the Verification Tag, and MUST NOT change the state of any existing association.",
      "ja": "MIS値を0に設定したINITチャンクの受信機は、パケットを破棄する必要があり、中止チャンクを含み、検証タグとして開始タグを使用してパケットを送信する必要があり、既存の関連付けの状態を変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "Initial TSN (I-TSN): 32 bits (unsigned integer) Defines the TSN that the sender of the INIT chunk will use initially. The valid range is from 0 to 4294967295 and the Initial TSN SHOULD be set to a random value in that range. The methods described in [RFC4086] can be used for the Initial TSN randomization.",
      "ja": "初期TSN（I-TSN）：32ビット（符号なし整数）は、initチャンクの送信者が最初に使用するTSNを定義します。有効な範囲は0〜4294967295で、初期のTSNはその範囲のランダム値に設定する必要があります。[RFC4086]で説明されている方法は、初期のTSNランダム化に使用できます。"
    },
    {
      "indent": 0,
      "text": "3.3.2.1. Optional or Variable-Length Parameters in INIT chunks",
      "section_title": true,
      "ja": "3.3.2.1. initチャンクのオプションまたは可変長パラメーター"
    },
    {
      "indent": 3,
      "text": "The following parameters follow the Type-Length-Value format as defined in Section 3.2.1. Any Type-Length-Value fields MUST be placed after the fixed-length fields. (The fixed-length fields are defined in the previous section.)",
      "ja": "次のパラメーターは、セクション3.2.1で定義されているタイプ長値形式に従います。任意のタイプ長価値フィールドは、固定長のフィールドの後に配置する必要があります。（固定長のフィールドは、前のセクションで定義されています。）"
    },
    {
      "indent": 0,
      "text": "3.3.2.1.1. IPv4 Address (5)",
      "section_title": true,
      "ja": "3.3.2.1.1. IPv4アドレス（5）"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Type = 5            |          Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IPv4 Address: 32 bits (unsigned integer) Contains an IPv4 address of the sending endpoint. It is binary encoded.",
      "ja": "IPv4アドレス：32ビット（符号なし整数）には、送信エンドポイントのIPv4アドレスが含まれています。バイナリエンコードされています。"
    },
    {
      "indent": 0,
      "text": "3.3.2.1.2. IPv6 Address (6)",
      "section_title": true,
      "ja": "3.3.2.1.2. IPv6アドレス（6）"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Type = 6            |          Length = 20          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                         IPv6 Address                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IPv6 Address: 128 bits (unsigned integer) Contains an IPv6 [RFC8200] address of the sending endpoint. It is binary encoded.",
      "ja": "IPv6アドレス：128ビット（符号なし整数）には、送信エンドポイントのIPv6 [RFC8200]アドレスが含まれています。バイナリエンコードされています。"
    },
    {
      "indent": 6,
      "text": "A sender MUST NOT use an IPv4-mapped IPv6 address [RFC4291] but SHOULD instead use an IPv4 Address parameter for an IPv4 address.",
      "ja": "送信者は、IPv4-Mapped IPv6アドレス[RFC4291]を使用してはなりませんが、代わりにIPv4アドレスにIPv4アドレスパラメーターを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Combined with the Source Port Number in the SCTP common header, the value passed in an IPv4 or IPv6 Address parameter indicates a transport address the sender of the INIT chunk will support for the association being initiated. That is, during the life time of this association, this IP address can appear in the source address field of an IP datagram sent from the sender of the INIT chunk and can be used as a destination address of an IP datagram sent from the receiver of the INIT chunk.",
      "ja": "SCTP共通ヘッダーのソースポート番号と組み合わせることで、IPv4またはIPv6アドレスパラメーターで渡される値は、INITチャンクの送信者が開始される関連付けをサポートするトランスポートアドレスを示します。つまり、この協会の生涯の間に、このIPアドレスは、initチャンクの送信者から送信されたIPデータグラムのソースアドレスフィールドに表示され、の受信者から送信されたIPデータグラムの宛先アドレスとして使用できます。init chunk。"
    },
    {
      "indent": 3,
      "text": "More than one IP Address parameter can be included in an INIT chunk when the sender of the INIT chunk is multi-homed. Moreover, a multi-homed endpoint might have access to different types of network; thus, more than one address type can be present in one INIT chunk, i.e., IPv4 and IPv6 addresses are allowed in the same INIT chunk.",
      "ja": "INITチャンクの送信者がマルチホームになった場合、INITチャンクに複数のIPアドレスパラメーターを含めることができます。さらに、マルチホームのエンドポイントは、異なるタイプのネットワークにアクセスできる場合があります。したがって、1つのinitチャンクに複数のアドレスタイプが存在する可能性があります。つまり、IPv4およびIPv6アドレスが同じinitチャンクで許可されます。"
    },
    {
      "indent": 3,
      "text": "If the INIT chunk contains at least one IP Address parameter, then the source address of the IP datagram containing the INIT chunk and any additional address(es) provided within the INIT can be used as destinations by the endpoint receiving the INIT chunk. If the INIT chunk does not contain any IP Address parameters, the endpoint receiving the INIT chunk MUST use the source address associated with the received IP datagram as its sole destination address for the association.",
      "ja": "initチャンクに少なくとも1つのIPアドレスパラメーターが含まれている場合、INITチャンクを含むIPデータグラムのソースアドレスと、init内で提供される追加のアドレスは、initチャンクを受信するエンドポイントによって宛先として使用できます。initチャンクにIPアドレスパラメーターが含まれていない場合、INITチャンクを受信するエンドポイントは、受信したIPデータグラムに関連付けられたソースアドレスを、関連付けの唯一の宛先アドレスとして使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that not using any IP Address parameters in the INIT and INIT ACK chunk is a way to make an association more likely to work in combination with Network Address Translation (NAT).",
      "ja": "initおよびinit ackチャンクでIPアドレスパラメーターを使用しないことは、ネットワークアドレス変換（NAT）と組み合わせて作業する可能性が高いようにする方法であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.3.2.1.3. Cookie Preservative (9)",
      "section_title": true,
      "ja": "3.3.2.1.3. クッキー防腐剤（9）"
    },
    {
      "indent": 3,
      "text": "The sender of the INIT chunk uses this parameter to suggest to the receiver of the INIT chunk a longer life span for the State Cookie.",
      "ja": "INIT Chunkの送信者は、このパラメーターを使用して、INITの受信者にState Cookieのより長い寿命をとります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Type = 9            |          Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Suggested Cookie Life-Span Increment (msec.)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Suggested Cookie Life-Span Increment: 32 bits (unsigned integer) This parameter indicates to the receiver how much increment in milliseconds the sender wishes the receiver to add to its default cookie life span.",
      "ja": "提案されたCookie Life-Span Increment：32ビット（符号なし整数）このパラメーターは、送信者がレシーバーにデフォルトのCookie寿命に追加することを望むミリ秒単位でどれだけの増加を受信者に示します。"
    },
    {
      "indent": 6,
      "text": "This optional parameter MAY be added to the INIT chunk by the sender when it reattempts establishing an association with a peer to which its previous attempt of establishing the association failed due to a stale cookie operation error. The receiver MAY choose to ignore the suggested cookie life span increase for its own security reasons.",
      "ja": "このオプションのパラメーターは、以前のアソシエーションを確立するために関連性を確立することを再確認するときに、送信者によってinitチャンクに追加される場合があります。受信者は、独自のセキュリティ上の理由で提案されたCookieの寿命の増加を無視することを選択できます。"
    },
    {
      "indent": 0,
      "text": "3.3.2.1.4. Host Name Address (11)",
      "section_title": true,
      "ja": "3.3.2.1.4. ホスト名アドレス（11）"
    },
    {
      "indent": 3,
      "text": "The sender of an INIT chunk or INIT ACK chunk MUST NOT include this parameter. The usage of the Host Name Address parameter is deprecated. The receiver of an INIT chunk or an INIT ACK containing a Host Name Address parameter MUST send an ABORT chunk and MAY include an \"Unresolvable Address\" error cause.",
      "ja": "init chunkまたはinit ackチャンクの送信者には、このパラメーターを含めてはなりません。ホスト名アドレスパラメーターの使用法は非推奨です。INITチャンクまたはホスト名アドレスパラメーターを含むINIT ACKの受信機は、中止チャンクを送信する必要があり、「解決できないアドレス」エラー原因を含めることができます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Type = 11           |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                           Host Name                           /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Host Name: variable length This field contains a host name in \"host name syntax\" per Section 2.1 of [RFC1123]. The method for resolving the host name is out of scope of SCTP.",
      "ja": "ホスト名：変数長このフィールドには、[RFC1123]のセクション2.1ごとに「ホスト名構文」にホスト名が含まれています。ホスト名を解決する方法は、SCTPの範囲外です。"
    },
    {
      "indent": 6,
      "text": "At least one null terminator is included in the Host Name string and MUST be included in the length.",
      "ja": "ホスト名文字列に少なくとも1つのヌルターミネーターが含まれており、長さに含める必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.2.1.5. Supported Address Types (12)",
      "section_title": true,
      "ja": "3.3.2.1.5. サポートされているアドレスタイプ（12）"
    },
    {
      "indent": 3,
      "text": "The sender of the INIT chunk uses this parameter to list all the address types it can support.",
      "ja": "init chunkの送信者は、このパラメーターを使用して、サポートできるすべてのアドレスタイプをリストします。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Type = 12           |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Address Type #1        |        Address Type #2        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            ......                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Address Type: 16 bits (unsigned integer) This is filled with the type value of the corresponding address TLV (e.g., 5 for indicating IPv4, and 6 for indicating IPv6). The value indicating the Host Name Address parameter MUST NOT be used when sending this parameter and MUST be ignored when receiving this parameter.",
      "ja": "アドレスタイプ：16ビット（符号なし整数）これは、対応するアドレスTLVのタイプ値で満たされています（例：IPv4を示す場合は5、IPv6を示す場合は6）。ホスト名アドレスパラメーターを示す値は、このパラメーターを送信するときに使用する必要はなく、このパラメーターを受信するときは無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Initiation Acknowledgement (INIT ACK) (2)",
      "section_title": true,
      "ja": "3.3.3. 開始承認（init ack）（2）"
    },
    {
      "indent": 3,
      "text": "The INIT ACK chunk is used to acknowledge the initiation of an SCTP association. The format of the INIT ACK chunk is shown below:",
      "ja": "init ackチャンクは、SCTP協会の開始を認めるために使用されます。init ackチャンクの形式を以下に示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 2    |  Chunk Flags  |         Chunk Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Initiate Tag                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Advertised Receiver Window Credit               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Number of Outbound Streams   |   Number of Inbound Streams   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Initial TSN                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/              Optional/Variable-Length Parameters              /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The parameter part of INIT ACK is formatted similarly to the INIT chunk. The following parameters are specified for the INIT ACK chunk:",
      "ja": "init ackのパラメーター部分は、initチャンクと同様にフォーマットされます。INIT ACKチャンクには、次のパラメーターが指定されています。"
    },
    {
      "indent": 13,
      "text": "+===================================+===========+\n| Fixed-Length Parameter            | Status    |\n+===================================+===========+\n| Initiate Tag                      | Mandatory |\n+-----------------------------------+-----------+\n| Advertised Receiver Window Credit | Mandatory |\n+-----------------------------------+-----------+\n| Number of Outbound Streams        | Mandatory |\n+-----------------------------------+-----------+\n| Number of Inbound Streams         | Mandatory |\n+-----------------------------------+-----------+\n| Initial TSN                       | Mandatory |\n+-----------------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 7: Fixed-Length Parameters of INIT ACK Chunks",
      "ja": "表7：init ackチャンクの固定長パラメーター"
    },
    {
      "indent": 3,
      "text": "It uses two extra variable parameters: the State Cookie and the Unrecognized Parameter.",
      "ja": "状態Cookieと認識されていないパラメーターの2つの追加の変数パラメーターを使用します。"
    },
    {
      "indent": 4,
      "text": "+===================================+============+================+\n| Variable-Length Parameter         | Status     | Type Value     |\n+===================================+============+================+\n| State Cookie                      | Mandatory  | 7              |\n+-----------------------------------+------------+----------------+\n| IPv4 Address (Note 1)             | Optional   | 5              |\n+-----------------------------------+------------+----------------+\n| IPv6 Address (Note 1)             | Optional   | 6              |\n+-----------------------------------+------------+----------------+\n| Unrecognized Parameter            | Optional   | 8              |\n+-----------------------------------+------------+----------------+\n| Reserved for ECN Capable (Note 2) | Optional   | 32768 (0x8000) |\n+-----------------------------------+------------+----------------+\n| Host Name Address (Note 3)        | Deprecated | 11             |\n+-----------------------------------+------------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 8: Variable-Length Parameters of INIT ACK Chunks",
      "ja": "表8：init ackチャンクの可変長パラメーター"
    },
    {
      "indent": 3,
      "text": "Note 1: The INIT ACK chunks can contain any number of IP Address parameters that can be IPv4 and/or IPv6 in any combination.",
      "ja": "注1：init ackチャンクには、任意の組み合わせでIPv4および/またはIPv6になる可能性のあるIPアドレスパラメーターを任意の数に含めることができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: The ECN Capable field is reserved for future use of Explicit Congestion Notification.",
      "ja": "注2：ECN有能なフィールドは、明示的な混雑通知の将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Note 3: An INIT ACK chunk MUST NOT contain the Host Name Address parameter. The receiver of INIT ACK chunks containing a Host Name Address parameter MUST send an ABORT chunk and MAY include an \"Unresolvable Address\" error cause.",
      "ja": "注3：init ackチャンクには、ホスト名アドレスパラメーターを含めてはなりません。ホスト名アドレスパラメーターを含むINIT ACKチャンクの受信機には、中止チャンクを送信する必要があり、「解決できないアドレス」エラー原因を含めることができます。"
    },
    {
      "indent": 3,
      "text": "The Chunk Flags field in INIT ACK chunks is reserved, and all bits in it SHOULD be set to 0 by the sender and ignored by the receiver.",
      "ja": "init ackチャンクのチャンクフラグフィールドは予約されており、その中のすべてのビットは送信者によって0に設定され、レシーバーによって無視される必要があります。"
    },
    {
      "indent": 3,
      "text": "Initiate Tag: 32 bits (unsigned integer) The receiver of the INIT ACK chunk records the value of the Initiate Tag parameter. This value MUST be placed into the Verification Tag field of every SCTP packet that the receiver of the INIT ACK chunk transmits within this association.",
      "ja": "開始タグ：32ビット（符号なし整数）init ackチャンクの受信機は、initiateタグパラメーターの値を記録します。この値は、init ackチャンクの受信者がこの関連付け内に送信するすべてのSCTPパケットの検証タグフィールドに配置する必要があります。"
    },
    {
      "indent": 6,
      "text": "The Initiate Tag MUST NOT take the value 0. See Section 5.3.1 for more on the selection of the Initiate Tag value.",
      "ja": "Initiateタグは、値0を取得してはなりません。ETIATIATEATタグ値の選択については、セクション5.3.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk with the Initiate Tag set to 0, it MUST destroy the TCB and SHOULD send an ABORT chunk with the T bit set. If such an INIT ACK chunk is received in any state other than CLOSED or COOKIE-WAIT, it SHOULD be discarded silently (see Section 5.2.3).",
      "ja": "Cookie-Wait StateのエンドポイントがINITACKチャンクを受信した場合、Initiateタグが0に設定されている場合、TCBを破壊する必要があり、Tビットセットで中止チャンクを送信する必要があります。このようなinit ackチャンクが閉じたまたはクッキーウェイト以外のどの状態でも受信されている場合、静かに廃棄する必要があります（セクション5.2.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer) This value represents the dedicated buffer space, in number of bytes, the sender of the INIT ACK chunk has reserved in association with this window.",
      "ja": "宣伝されたレシーバーウィンドウクレジット（A_RWND）：32ビット（符号なし整数）この値は、専用のバッファースペースを表します。バイト数で、init ackチャンクの送信者はこのウィンドウに関連して予約されています。"
    },
    {
      "indent": 6,
      "text": "The Advertised Receiver Window Credit MUST NOT be smaller than 1500.",
      "ja": "広告されたレシーバーウィンドウクレジットは、1500を超えてはなりません。"
    },
    {
      "indent": 6,
      "text": "A receiver of an INIT ACK chunk with the a_rwnd value set to a value smaller than 1500 MUST discard the packet, SHOULD send a packet in response containing an ABORT chunk and using the Initiate Tag as the Verification Tag, and MUST NOT change the state of any existing association.",
      "ja": "1500未満の値に設定されたA_RWND値を持つINIT ACKチャンクの受信機は、パケットを破棄する必要があります。中止チャンクを含み、検証タグとして開始タグを使用してパケットを送信する必要があり、の状態を変更してはなりません。既存の協会。"
    },
    {
      "indent": 6,
      "text": "During the life of the association, this buffer space SHOULD NOT be reduced (i.e., dedicated buffers ought not to be taken away from this association); however, an endpoint MAY change the value of a_rwnd it sends in SACK chunks.",
      "ja": "協会の存続期間中、このバッファースペースを減らすべきではありません（つまり、専用のバッファーをこの協会から奪うべきではありません）。ただし、エンドポイントは、サックチャンクで送信するA_RWNDの値を変更する場合があります。"
    },
    {
      "indent": 3,
      "text": "Number of Outbound Streams (OS): 16 bits (unsigned integer) Defines the number of outbound streams the sender of this INIT ACK chunk wishes to create in this association. The value of 0 MUST NOT be used, and the value MUST NOT be greater than the MIS value sent in the INIT chunk.",
      "ja": "アウトバウンドストリームの数（OS）：16ビット（符号なし整数）は、このINIT ACK Chunkの送信者がこの協会で作成したいと望んでいるアウトバウンドストリームの数を定義します。0の値を使用してはなりません。値は、init chunkで送信されたmis値よりも大きくしてはなりません。"
    },
    {
      "indent": 6,
      "text": "If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk with the OS value set to 0, it MUST destroy the TCB and SHOULD send an ABORT chunk. If such an INIT ACK chunk is received in any state other than CLOSED or COOKIE-WAIT, it SHOULD be discarded silently (see Section 5.2.3).",
      "ja": "Cookie-Wait状態のエンドポイントがOS値を0に設定してinit ackチャンクを受信した場合、TCBを破壊する必要があり、中止チャンクを送信する必要があります。このようなinit ackチャンクが閉じたまたはクッキーウェイト以外のどの状態でも受信されている場合、静かに廃棄する必要があります（セクション5.2.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Number of Inbound Streams (MIS): 16 bits (unsigned integer) Defines the maximum number of streams the sender of this INIT ACK chunk allows the peer end to create in this association. The value 0 MUST NOT be used.",
      "ja": "インバウンドストリームの数（MIS）：16ビット（符号なし整数）は、このinit ackチャンクの送信者がこの関連性にピアエンドを作成できるようにするストリームの最大数を定義します。値0を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: There is no negotiation of the actual number of streams, but instead the two endpoints will use the min(requested, offered). See Section 5.1.1 for details.",
      "ja": "注：実際のストリーム数の交渉はありませんが、代わりに2つのエンドポイントはMIN（要求、提供された）を使用します。詳細については、セクション5.1.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "If an endpoint in the COOKIE-WAIT state receives an INIT ACK chunk with the MIS value set to 0, it MUST destroy the TCB and SHOULD send an ABORT chunk. If such an INIT ACK chunk is received in any state other than CLOSED or COOKIE-WAIT, it SHOULD be discarded silently (see Section 5.2.3).",
      "ja": "Cookie-Wait状態のエンドポイントが0に設定されたINIT ACKチャンクを受け取った場合、TCBを破壊する必要があり、中止チャンクを送信する必要があります。このようなinit ackチャンクが閉じたまたはクッキーウェイト以外のどの状態でも受信されている場合、静かに廃棄する必要があります（セクション5.2.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Initial TSN (I-TSN): 32 bits (unsigned integer) Defines the TSN that the sender of the INIT ACK chunk will use initially. The valid range is from 0 to 4294967295 and the Initial TSN SHOULD be set to a random value in that range. The methods described in [RFC4086] can be used for the Initial TSN randomization.",
      "ja": "初期TSN（I-TSN）：32ビット（符号なし整数）は、INIT ACKチャンクの送信者が最初に使用するTSNを定義します。有効な範囲は0〜4294967295で、初期のTSNはその範囲のランダム値に設定する必要があります。[RFC4086]で説明されている方法は、初期のTSNランダム化に使用できます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: An implementation MUST be prepared to receive an INIT ACK chunk that is quite large (more than 1500 bytes) due to the variable size of the State Cookie and the variable address list. For example, if a responder to the INIT chunk has 1000 IPv4 addresses it wishes to send, it would need at least 8,000 bytes to encode this in the INIT ACK chunk.",
      "ja": "実装注：状態Cookieの変動サイズと変数アドレスリストのために、非常に大きい（1500バイト以上）INIT ACKチャンクを受信するために実装を準備する必要があります。たとえば、init chunkのレスポンダーに送信を希望する1000のIPv4アドレスがある場合、INIT ACKチャンクでこれをエンコードするには少なくとも8,000バイトが必要です。"
    },
    {
      "indent": 3,
      "text": "If an INIT ACK chunk is received with all mandatory parameters that are specified for the INIT ACK chunk, then the receiver SHOULD process the INIT ACK chunk and send back a COOKIE ECHO chunk. The receiver of the INIT ACK chunk MAY bundle an ERROR chunk with the COOKIE ECHO chunk. However, restrictive implementations MAY send back an ABORT chunk in response to the INIT ACK chunk.",
      "ja": "init ACKチャンクに指定されたすべての必須パラメーターでinit ackチャンクが受信された場合、受信者はinit ackチャンクを処理し、クッキーエコーチャンクを送り返す必要があります。init ackチャンクのレシーバーは、クッキーエコーチャンクでエラーチャンクをバンドルする場合があります。ただし、制限的な実装は、init ackチャンクに応じて中止チャンクを送り返す場合があります。"
    },
    {
      "indent": 3,
      "text": "In combination with the Source Port Number carried in the SCTP common header, each IP Address parameter in the INIT ACK chunk indicates to the receiver of the INIT ACK chunk a valid transport address supported by the sender of the INIT ACK chunk for the life time of the association being initiated.",
      "ja": "SCTP共通ヘッダーに掲載されたソースポート番号と組み合わせて、init ackチャンクの各IPアドレスパラメーターは、init ackチャンクの受信機に、init ackチャンクの送信者がサポートする有効なトランスポートアドレスを示します。協会が開始されます。"
    },
    {
      "indent": 3,
      "text": "If the INIT ACK chunk contains at least one IP Address parameter, then the source address of the IP datagram containing the INIT ACK chunk and any additional address(es) provided within the INIT ACK chunk MAY be used as destinations by the receiver of the INIT ACK chunk. If the INIT ACK chunk does not contain any IP Address parameters, the receiver of the INIT ACK chunk MUST use the source address associated with the received IP datagram as its sole destination address for the association.",
      "ja": "init ACKチャンクに少なくとも1つのIPアドレスパラメーターが含まれている場合、INIT ACKチャンクを含むIPデータグラムのソースアドレスと、init ackチャンク内で提供される追加アドレスは、initの受信者によって目的地として使用できます。ackチャンク。init ackチャンクにIPアドレスパラメーターが含まれていない場合、init ackチャンクの受信者は、受信したIPデータグラムに関連付けられたソースアドレスを、関連付けの唯一の宛先アドレスとして使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The State Cookie and Unrecognized Parameters use the Type-Length-Value format as defined in Section 3.2.1 and are described below. The other fields are defined in the same way as their counterparts in the INIT chunk.",
      "ja": "State Cookieおよび認識されていないパラメーターは、セクション3.2.1で定義されているタイプ長値形式を使用し、以下に説明します。他のフィールドは、init chunkのカウンターパートと同じように定義されています。"
    },
    {
      "indent": 0,
      "text": "3.3.3.1. Optional or Variable-Length Parameters in INIT ACK Chunks",
      "section_title": true,
      "ja": "3.3.3.1. init ackチャンクのオプションまたは可変長パラメーター"
    },
    {
      "indent": 3,
      "text": "The State Cookie and Unrecognized Parameters use the Type-Length-Value format, as defined in Section 3.2.1, and are described below. The IPv4 Address parameter is described in Section 3.3.2.1.1, and the IPv6 Address parameter is described in Section 3.3.2.1.2. The Host Name Address parameter is described in Section 3.3.2.1.4 and MUST NOT be included in an INIT ACK chunk. Any Type-Length-Value fields MUST be placed after the fixed-length fields. (The fixed-length fields are defined in the previous section.)",
      "ja": "State Cookieおよび認識されていないパラメーターは、セクション3.2.1で定義されているように、タイプ長価値形式を使用し、以下に説明します。IPv4アドレスパラメーターはセクション3.3.2.1.1で説明されており、IPv6アドレスパラメーターはセクション3.3.2.1.2で説明されています。ホスト名アドレスパラメーターはセクション3.3.2.1.4で説明されており、init ackチャンクに含めてはなりません。任意のタイプ長価値フィールドは、固定長のフィールドの後に配置する必要があります。（固定長のフィールドは、前のセクションで定義されています。）"
    },
    {
      "indent": 0,
      "text": "3.3.3.1.1. State Cookie (7)",
      "section_title": true,
      "ja": "3.3.3.1.1. ステートクッキー（7）"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Type = 7            |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                            Cookie                             /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Cookie: variable length This parameter value MUST contain all the necessary state and parameter information required for the sender of this INIT ACK chunk to create the association, along with a Message Authentication Code (MAC). See Section 5.1.3 for details on State Cookie definition.",
      "ja": "Cookie：変数長このパラメーター値には、メッセージ認証コード（MAC）とともに、このinit ackチャンクの送信者に必要なすべての必要な状態およびパラメーター情報を含める必要があります。State Cookieの定義の詳細については、セクション5.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.3.1.2. Unrecognized Parameter (8)",
      "section_title": true,
      "ja": "3.3.3.1.2. 認識されていないパラメーター（8）"
    },
    {
      "indent": 3,
      "text": "This parameter is returned to the originator of the INIT chunk when the INIT chunk contains an unrecognized parameter that has a type that indicates it SHOULD be reported to the sender.",
      "ja": "このパラメーターは、initチャンクに送信者に報告されるべきタイプを持つ認識されていないパラメーターを含む場合、initチャンクの発信者に返されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Type = 8            |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Unrecognized Parameter                     /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unrecognized Parameter: variable length The Parameter Value field will contain an unrecognized parameter copied from the INIT chunk complete with Parameter Type, Length, and Value fields.",
      "ja": "認識されていないパラメーター：変数長さパラメーター値フィールドには、パラメータータイプ、長さ、および値フィールドを備えたinitチャンクからコピーされた認識されていないパラメーターが含まれます。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Selective Acknowledgement (SACK) (3)",
      "section_title": true,
      "ja": "3.3.4. 選択的承認（袋）（3）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent to the peer endpoint to acknowledge received DATA chunks and to inform the peer endpoint of gaps in the received subsequences of DATA chunks as represented by their TSNs.",
      "ja": "このチャンクはピアエンドポイントに送信され、受信したデータチャンクを確認し、TSNSで表されるデータチャンクの受信サブセンスのギャップのピアエンドポイントに通知します。"
    },
    {
      "indent": 3,
      "text": "The SACK chunk MUST contain the Cumulative TSN Ack, Advertised Receiver Window Credit (a_rwnd), Number of Gap Ack Blocks, and Number of Duplicate TSNs fields.",
      "ja": "Sack Chunkには、累積TSN ACK、宣伝されたレシーバーウィンドウクレジット（A_RWND）、ギャップACKブロックの数、および重複するTSNSフィールドの数が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "By definition, the value of the Cumulative TSN Ack parameter is the last TSN received before a break in the sequence of received TSNs occurs; the next TSN value following this one has not yet been received at the endpoint sending the SACK chunk. This parameter therefore acknowledges receipt of all TSNs less than or equal to its value.",
      "ja": "定義上、累積TSN ACKパラメーターの値は、受信したTSNSのシーケンスの休憩が発生する前に受信した最後のTSNです。これに続く次のTSN値は、サックチャンクを送信するエンドポイントでまだ受信されていません。したがって、このパラメーターは、その値以下のすべてのTSNの受領を確認します。"
    },
    {
      "indent": 3,
      "text": "The handling of a_rwnd by the receiver of the SACK chunk is discussed in detail in Section 6.2.1.",
      "ja": "Sack Chunkの受信者によるA_RWNDの取り扱いについては、セクション6.2.1で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "The SACK chunk also contains zero or more Gap Ack Blocks. Each Gap Ack Block acknowledges a subsequence of TSNs received following a break in the sequence of received TSNs. The Gap Ack Blocks SHOULD be isolated. This means that the TSN just before each Gap Ack Block and the TSN just after each Gap Ack Block have not been received. By definition, all TSNs acknowledged by Gap Ack Blocks are greater than the value of the Cumulative TSN Ack.",
      "ja": "サックチャンクには、ゼロ以上のギャップACKブロックも含まれています。各GAP ACKブロックは、受信したTSNSのシーケンスの休憩後に受信されたTSNSのサブシーケンスを認めています。ギャップACKブロックは分離する必要があります。これは、各ギャップACKブロックの直前にTSNと各ギャップACKブロックの直後にTSNが受信されていないことを意味します。定義上、GAP ACKブロックによって認められるすべてのTSNは、累積TSN ACKの値よりも大きくなります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 3    |  Chunk Flags  |         Chunk Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Cumulative TSN Ack                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Advertised Receiver Window Credit (a_rwnd)           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = M |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Gap Ack Block #1 Start     |     Gap Ack Block #1 End      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Gap Ack Block #N Start     |     Gap Ack Block #N End      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Duplicate TSN 1                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Duplicate TSN M                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits All set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：送信時に8ビットはすべて0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack: 32 bits (unsigned integer) The largest TSN, such that all TSNs smaller than or equal to it have been received and the next one has not been received. In the case where no DATA chunk has been received, this value is set to the peer's Initial TSN minus one.",
      "ja": "累積TSN ACK：32ビット（符号なし整数）最大のTSN。データチャンクが受信されていない場合、この値はピアの最初のTSNから1を引いたものに設定されます。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer) This field indicates the updated receive buffer space in bytes of the sender of this SACK chunk; see Section 6.2.1 for details.",
      "ja": "宣伝されているレシーバーウィンドウクレジット（A_RWND）：32ビット（符号なし整数）このフィールドは、このサックチャンクの送信者のバイト単位で更新された受信バッファースペースを示します。詳細については、セクション6.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Number of Gap Ack Blocks: 16 bits (unsigned integer) Indicates the number of Gap Ack Blocks included in this SACK chunk.",
      "ja": "ギャップACKブロックの数：16ビット（符号なし整数）は、このサックチャンクに含まれるギャップACKブロックの数を示します。"
    },
    {
      "indent": 3,
      "text": "Number of Duplicate TSNs: 16 bit This field contains the number of duplicate TSNs the endpoint has received. Each duplicate TSN is listed following the Gap Ack Block list.",
      "ja": "重複するTSNSの数：16ビットこのフィールドには、エンドポイントが受信した重複TSNの数が含まれています。各重複TSNは、GAP ACKブロックリストに従ってリストされています。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Blocks: These fields contain the Gap Ack Blocks. They are repeated for each Gap Ack Block up to the number of Gap Ack Blocks defined in the Number of Gap Ack Blocks field. All DATA chunks with TSNs greater than or equal to (Cumulative TSN Ack + Gap Ack Block Start) and less than or equal to (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack Block are assumed to have been received correctly.",
      "ja": "ギャップACKブロック：これらのフィールドには、ギャップACKブロックが含まれています。それらは、GAP ACKブロックの数で定義されたギャップACKブロックの数まで、各ギャップACKブロックについて繰り返されます。各ギャップACKブロックの（累積TSN ACKギャップACKブロック開始）以下（累積TSN ACKギャップACKブロックの開始）以下（累積TSN ACKギャップACKブロックの開始）以下のすべてのデータチャンクは、正しく受信されたと考えられています。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Block Start: 16 bits (unsigned integer) Indicates the Start offset TSN for this Gap Ack Block. To calculate the actual TSN number, the Cumulative TSN Ack is added to this offset number. This calculated TSN identifies the lowest TSN in this Gap Ack Block that has been received.",
      "ja": "ギャップACKブロック開始：16ビット（符号なし整数）このギャップACKブロックの開始オフセットTSNを示します。実際のTSN番号を計算するために、累積TSN ACKがこのオフセット番号に追加されます。この計算されたTSNは、受信されたこのギャップACKブロックで最も低いTSNを識別します。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Block End: 16 bits (unsigned integer) Indicates the End offset TSN for this Gap Ack Block. To calculate the actual TSN number, the Cumulative TSN Ack is added to this offset number. This calculated TSN identifies the highest TSN in this Gap Ack Block that has been received.",
      "ja": "ギャップACKブロックの終わり：16ビット（符号なし整数）は、このギャップACKブロックの終了オフセットTSNを示します。実際のTSN番号を計算するために、累積TSN ACKがこのオフセット番号に追加されます。この計算されたTSNは、受信されたこのギャップACKブロックで最高のTSNを識別します。"
    },
    {
      "indent": 6,
      "text": "For example, assume that the receiver has the following DATA chunks newly arrived at the time when it decides to send a Selective ACK:",
      "ja": "たとえば、受信者が選択的ACKを送信することを決定したときに次のデータチャンクが新しく到着したと仮定します。"
    },
    {
      "indent": 24,
      "text": "------------\n| TSN = 17 |\n------------\n|          | <- still missing\n------------\n| TSN = 15 |\n------------\n| TSN = 14 |\n------------\n|          | <- still missing\n------------\n| TSN = 12 |\n------------\n| TSN = 11 |\n------------\n| TSN = 10 |\n------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Then, the parameter part of the SACK chunk MUST be constructed as follows (assuming the new a_rwnd is set to 4660 by the sender):",
      "ja": "次に、サックチャンクのパラメーター部分を次のように構築する必要があります（新しいA_RWNDが送信者によって4660に設定されていると仮定します）。"
    },
    {
      "indent": 18,
      "text": "+-------------------+-------------------+\n|        Cumulative TSN Ack = 12        |\n+-------------------+-------------------+\n|             a_rwnd = 4660             |\n+-------------------+-------------------+\n| num of block = 2  |  num of dup = 0   |\n+-------------------+-------------------+\n|block #1 start = 2 | block #1 end = 3  |\n+-------------------+-------------------+\n|block #2 start = 5 | block #2 end = 5  |\n+-------------------+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Duplicate TSN: 32 bits (unsigned integer) Indicates the number of times a TSN was received in duplicate since the last SACK chunk was sent. Every time a receiver gets a duplicate TSN (before sending the SACK chunk), it adds it to the list of duplicates. The duplicate count is reinitialized to zero after sending each SACK chunk.",
      "ja": "重複TSN：32ビット（符号なし整数）は、最後のサックチャンクが送信されて以来、TSNが重複して受信した回数を示します。レシーバーが重複したTSNを取得するたびに（サックチャンクを送信する前に）、重複のリストに追加します。重複カウントは、各サックチャンクを送信した後、ゼロに再活性化されます。"
    },
    {
      "indent": 6,
      "text": "For example, if a receiver were to get the TSN 19 three times, it would list 19 twice in the outbound SACK chunk. After sending the SACK chunk, if it received yet one more TSN 19, it would list 19 as a duplicate once in the next outgoing SACK chunk.",
      "ja": "たとえば、受信者がTSN 19を3回取得する場合、アウトバウンドサックチャンクに19を2回リストします。サックチャンクを送信した後、もう1つのTSN 19を受け取った場合、次の発信サックチャンクで1回複製として19をリストします。"
    },
    {
      "indent": 0,
      "text": "3.3.5. Heartbeat Request (HEARTBEAT) (4)",
      "section_title": true,
      "ja": "3.3.5. ハートビートリクエスト（ハートビート）（4）"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD send a HEARTBEAT (HB) chunk to its peer endpoint to probe the reachability of a particular destination transport address defined in the present association.",
      "ja": "エンドポイントは、ハートビート（HB）チャンクをピアエンドポイントに送信して、現在の協会で定義されている特定の宛先輸送アドレスの到達可能性を調べる必要があります。"
    },
    {
      "indent": 3,
      "text": "The parameter field contains the Heartbeat Information, which is a variable-length opaque data structure understood only by the sender.",
      "ja": "パラメーターフィールドには、送信者によってのみ理解される可変長さの不透明データ構造であるハートビート情報が含まれています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 4    |  Chunk Flags  |       Heartbeat Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/          Heartbeat Information TLV (Variable-Length)          /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Length: 16 bits (unsigned integer) Set to the size of the chunk in bytes, including the chunk header and the Heartbeat Information field.",
      "ja": "ハートビートの長さ：チャンクヘッダーやハートビート情報フィールドなど、バイトのチャンクのサイズに設定された16ビット（符号なし整数）。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Information: variable length Defined as a variable-length parameter using the format described in Section 3.2.1, that is:",
      "ja": "ハートビート情報：セクション3.2.1で説明されている形式を使用して可変長パラメーターとして定義された可変長さ、つまり："
    },
    {
      "indent": 15,
      "text": "+=====================+===========+============+\n| Variable Parameters | Status    | Type Value |\n+=====================+===========+============+\n| Heartbeat Info      | Mandatory | 1          |\n+---------------------+-----------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 9: Variable-Length Parameters of HEARTBEAT Chunks",
      "ja": "表9：ハートビートチャンクの可変長パラメーター"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Heartbeat Info Type = 1    |        HB Info Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                Sender-Specific Heartbeat Info                 /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "The Sender-Specific Heartbeat Info field SHOULD include information about the sender's current time when this HEARTBEAT chunk is sent and the destination transport address to which this HEARTBEAT chunk is sent (see Section 8.3). This information is simply reflected back by the receiver in the HEARTBEAT ACK chunk (see Section 3.3.6). Note also that the HEARTBEAT chunk is both for reachability checking and for path verification (see Section 5.4). When a HEARTBEAT chunk is being used for path verification purposes, it MUST include a random nonce of length 64 bits or longer ([RFC4086] provides some information on randomness guidelines).",
      "ja": "送信者固有のハートビート情報フィールドには、このハートビートチャンクが送信される場合の送信者の現在の時間に関する情報と、このハートビートチャンクが送信される宛先輸送住所に関する情報を含める必要があります（セクション8.3を参照）。この情報は、ハートビートACKチャンクのレシーバーによって単純に反映されます（セクション3.3.6を参照）。また、ハートビートチャンクは、到達可能性チェックとパス検証の両方であることに注意してください（セクション5.4を参照）。パス検証の目的でハートビートチャンクが使用されている場合、長さ64ビット以上のランダムな非CEを含める必要があります（[RFC4086]は、ランダム性ガイドラインに関する情報を提供します）。"
    },
    {
      "indent": 0,
      "text": "3.3.6. Heartbeat Acknowledgement (HEARTBEAT ACK) (5)",
      "section_title": true,
      "ja": "3.3.6. ハートビートの謝辞（ハートビートACK）（5）"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST send this chunk to its peer endpoint as a response to a HEARTBEAT chunk (see Section 8.3). A packet containing the HEARTBEAT ACK chunk is always sent to the source IP address of the IP datagram containing the HEARTBEAT chunk to which this HEARTBEAT ACK chunk is responding.",
      "ja": "エンドポイントは、ハートビートチャンクへの応答として、このチャンクをピアエンドポイントに送信する必要があります（セクション8.3を参照）。ハートビートACKチャンクを含むパケットは、このハートビートACKチャンクが応答しているハートビートチャンクを含むIPデータグラムのソースIPアドレスに常に送信されます。"
    },
    {
      "indent": 3,
      "text": "The parameter field contains a variable-length opaque data structure.",
      "ja": "パラメーターフィールドには、可変長の不透明なデータ構造が含まれています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 5    |  Chunk Flags  |     Heartbeat Ack Length      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/          Heartbeat Information TLV (Variable-Length)          /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Ack Length: 16 bits (unsigned integer) Set to the size of the chunk in bytes, including the chunk header and the Heartbeat Information field.",
      "ja": "ハートビートACKの長さ：チャンクヘッダーやハートビート情報フィールドなど、バイトのチャンクのサイズに設定された16ビット（符号なし整数）。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Information: variable length This field MUST contain the Heartbeat Info parameter (as defined in Section 3.3.5) of the Heartbeat Request to which this Heartbeat Acknowledgement is responding.",
      "ja": "ハートビート情報：可変長このフィールドには、このハートビートの確認が応答しているハートビートリクエストのハートビート情報パラメーター（セクション3.3.5で定義されている）が含まれている必要があります。"
    },
    {
      "indent": 15,
      "text": "+=====================+===========+============+\n| Variable Parameters | Status    | Type Value |\n+=====================+===========+============+\n| Heartbeat Info      | Mandatory | 1          |\n+---------------------+-----------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 10: Variable-Length Parameters of HEARTBEAT ACK Chunks",
      "ja": "表10：ハートビートACKチャンクの可変長パラメーター"
    },
    {
      "indent": 0,
      "text": "3.3.7. Abort Association (ABORT) (6)",
      "section_title": true,
      "ja": "3.3.7. 中止協会（中止）（6）"
    },
    {
      "indent": 3,
      "text": "The ABORT chunk is sent to the peer of an association to close the association. The ABORT chunk MAY contain error causes to inform the receiver about the reason of the abort. DATA chunks MUST NOT be bundled with ABORT chunks. Control chunks (except for INIT, INIT ACK, and SHUTDOWN COMPLETE) MAY be bundled with an ABORT chunk, but they MUST be placed before the ABORT chunk in the SCTP packet; otherwise, they will be ignored by the receiver.",
      "ja": "中止チャンクは、協会を閉鎖するために協会のピアに送られます。中止チャンクには、中止の理由について受信者に通知するためにエラー原因が含まれる場合があります。データチャンクを中止するチャンクにバンドルしてはなりません。コントロールチャンク（init、init ack、およびシャットダウンが完了することを除く）は、中止チャンクにバンドルされる場合がありますが、SCTPパケットの中止チャンクの前に配置する必要があります。それ以外の場合、それらは受信機によって無視されます。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives an ABORT chunk with a format error or no TCB is found, it MUST silently discard it. Moreover, under any circumstances, an endpoint that receives an ABORT chunk MUST NOT respond to that ABORT chunk by sending an ABORT chunk of its own.",
      "ja": "エンドポイントがフォーマットエラーで中止チャンクを受信するか、TCBが見つからない場合、静かに破棄する必要があります。さらに、どんな状況でも、中止塊を受け取るエンドポイントは、独自の中止チャンクを送信することで、その中断のチャンクに応答してはなりません。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 6    |  Reserved   |T|            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                   zero or more Error Causes                   /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Reserved: 7 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：8ビット予約済み：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 6,
      "text": "T bit: 1 bit The T bit is set to 0 if the sender filled in the Verification Tag expected by the peer. If the Verification Tag is reflected, the T bit MUST be set to 1. Reflecting means that the sent Verification Tag is the same as the received one.",
      "ja": "Tビット：1ビットTビットは、ピアが予想される検証タグに送信者が記入された場合、0に設定されています。検証タグが反映されている場合、tビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer) Set to the size of the chunk in bytes, including the chunk header and all the Error Cause fields present.",
      "ja": "長さ：チャンクヘッダーと存在するすべてのエラー原因フィールドを含む、バイトのチャンクのサイズに設定された16ビット（符号なし整数）。"
    },
    {
      "indent": 3,
      "text": "See Section 3.3.10 for Error Cause definitions.",
      "ja": "エラー原因の定義については、セクション3.3.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note: Special rules apply to this chunk for verification; please see Section 8.5.1 for details.",
      "ja": "注：検証のためにこのチャンクには特別なルールが適用されます。詳細については、セクション8.5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.8. Shutdown Association (SHUTDOWN) (7)",
      "section_title": true,
      "ja": "3.3.8. シャットダウン協会（シャットダウン）（7）"
    },
    {
      "indent": 3,
      "text": "An endpoint in an association MUST use this chunk to initiate a graceful close of the association with its peer. This chunk has the following format.",
      "ja": "協会のエンドポイントは、このチャンクを使用して、そのピアとの関連性の優雅な密接を開始する必要があります。このチャンクには次の形式があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 7    |  Chunk Flags  |          Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Cumulative TSN Ack                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer) Indicates the length of the parameter. Set to 8.",
      "ja": "長さ：16ビット（符号なし整数）は、パラメーターの長さを示します。8に設定します。"
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack: 32 bits (unsigned integer) The largest TSN, such that all TSNs smaller than or equal to it have been received and the next one has not been received.",
      "ja": "累積TSN ACK：32ビット（符号なし整数）最大のTSN。"
    },
    {
      "indent": 3,
      "text": "Note: Since the SHUTDOWN chunk does not contain Gap Ack Blocks, it cannot be used to acknowledge TSNs received out of order. In a SACK chunk, lack of Gap Ack Blocks that were previously included indicates that the data receiver reneged on the associated DATA chunks.",
      "ja": "注：シャットダウンチャンクにはギャップACKブロックが含まれていないため、故障したTSNを認めるために使用することはできません。袋のチャンクでは、以前に含まれていたギャップACKブロックの欠如は、関連するデータチャンクでre辱されたデータ受信機が示されています。"
    },
    {
      "indent": 3,
      "text": "Since the SHUTDOWN chunk does not contain Gap Ack Blocks, the receiver of the SHUTDOWN chunk MUST NOT interpret the lack of a Gap Ack Block as a renege. (See Section 6.2 for information on reneging.)",
      "ja": "シャットダウンチャンクにはギャップACKブロックが含まれていないため、シャットダウンチャンクの受信者は、GAP ACKブロックの欠如をRenegeとして解釈してはなりません。（Renegingの詳細については、セクション6.2を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN chunk MAY bundle a SACK chunk to indicate any gaps in the received TSNs.",
      "ja": "シャットダウンチャンクの送信者は、受け取ったTSNのギャップを示すためにサックチャンクを束ねることができます。"
    },
    {
      "indent": 0,
      "text": "3.3.9. Shutdown Acknowledgement (SHUTDOWN ACK) (8)",
      "section_title": true,
      "ja": "3.3.9. シャットダウン謝辞（シャットダウンACK）（8）"
    },
    {
      "indent": 3,
      "text": "This chunk MUST be used to acknowledge the receipt of the SHUTDOWN chunk at the completion of the shutdown process; see Section 9.2 for details.",
      "ja": "このチャンクは、シャットダウンプロセスの完了時にシャットダウンチャンクの受領を認めるために使用する必要があります。詳細については、セクション9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The SHUTDOWN ACK chunk has no parameters.",
      "ja": "シャットダウンACKチャンクにはパラメーターがありません。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 8    |  Chunk Flags  |          Length = 4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 0,
      "text": "3.3.10. Operation Error (ERROR) (9)",
      "section_title": true,
      "ja": "3.3.10. 操作エラー（エラー）（9）"
    },
    {
      "indent": 3,
      "text": "An endpoint sends this chunk to its peer endpoint to notify it of certain error conditions. It contains one or more error causes. An Operation Error is not considered fatal in and of itself, but the corresponding error cause MAY be used with an ABORT chunk to report a fatal condition. An ERROR chunk has the following format:",
      "ja": "エンドポイントは、このチャンクをピアエンドポイントに送信して、特定のエラー条件を通知します。1つ以上のエラー原因が含まれています。操作エラーはそれ自体で致命的であるとは見なされませんが、致命的な状態を報告するために中止チャンクで対応するエラー原因を使用できます。エラーチャンクには次の形式があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 9    |  Chunk Flags  |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                   one or more Error Causes                    /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer) Set to the size of the chunk in bytes, including the chunk header and all the Error Cause fields present.",
      "ja": "長さ：チャンクヘッダーと存在するすべてのエラー原因フィールドを含む、バイトのチャンクのサイズに設定された16ビット（符号なし整数）。"
    },
    {
      "indent": 3,
      "text": "Error causes are defined as variable-length parameters using the format described in Section 3.2.1, that is:",
      "ja": "エラー原因は、セクション3.2.1で説明されている形式を使用して、可変長パラメーターとして定義されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Cause Code           |         Cause Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Cause-Specific Information                   /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Cause Code: 16 bits (unsigned integer) Defines the type of error conditions being reported.",
      "ja": "原因コード：16ビット（符号なし整数）は、報告されているエラー条件のタイプを定義します。"
    },
    {
      "indent": 11,
      "text": "+=======+==============================================+\n| Value | Cause Code                                   |\n+=======+==============================================+\n| 1     | Invalid Stream Identifier                    |\n+-------+----------------------------------------------+\n| 2     | Missing Mandatory Parameter                  |\n+-------+----------------------------------------------+\n| 3     | Stale Cookie                                 |\n+-------+----------------------------------------------+\n| 4     | Out of Resource                              |\n+-------+----------------------------------------------+\n| 5     | Unresolvable Address                         |\n+-------+----------------------------------------------+\n| 6     | Unrecognized Chunk Type                      |\n+-------+----------------------------------------------+\n| 7     | Invalid Mandatory Parameter                  |\n+-------+----------------------------------------------+\n| 8     | Unrecognized Parameters                      |\n+-------+----------------------------------------------+\n| 9     | No User Data                                 |\n+-------+----------------------------------------------+\n| 10    | Cookie Received While Shutting Down          |\n+-------+----------------------------------------------+\n| 11    | Restart of an Association with New Addresses |\n+-------+----------------------------------------------+\n| 12    | User-Initiated Abort                         |\n+-------+----------------------------------------------+\n| 13    | Protocol Violation                           |\n+-------+----------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 29,
      "text": "Table 11: Cause Code",
      "ja": "表11：原因コード"
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer) Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields.",
      "ja": "原因の長さ：原因コード、原因の長さ、原因固有の情報フィールドなど、バイトのパラメーターのサイズに設定された16ビット（符号なし整数）。"
    },
    {
      "indent": 3,
      "text": "Cause-Specific Information: variable length This field carries the details of the error condition.",
      "ja": "原因固有の情報：可変長このフィールドには、エラー条件の詳細が記載されています。"
    },
    {
      "indent": 3,
      "text": "Sections 3.3.10.1 - 3.3.10.13 define error causes for SCTP. Guidelines for the IETF to define new error cause values are discussed in Section 15.4.",
      "ja": "セクション3.3.10.1-3.3.10.13SCTPのエラー原因を定義します。新しいエラー原因値を定義するIETFのガイドラインについては、セクション15.4で説明します。"
    },
    {
      "indent": 0,
      "text": "3.3.10.1. Invalid Stream Identifier (1)",
      "section_title": true,
      "ja": "3.3.10.1. 無効なストリーム識別子（1）"
    },
    {
      "indent": 3,
      "text": "Indicates that the endpoint received a DATA chunk sent using a nonexistent stream.",
      "ja": "エンドポイントが、存在しないストリームを使用して送信されたデータチャンクを受信したことを示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 1         |       Cause Length = 8        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Stream Identifier       |          (Reserved)           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Stream Identifier: 16 bits (unsigned integer) Contains the Stream Identifier of the DATA chunk received in error.",
      "ja": "ストリーム識別子：16ビット（符号なし整数）には、誤って受信したデータチャンクのストリーム識別子が含まれています。"
    },
    {
      "indent": 3,
      "text": "Reserved: 16 bits This field is reserved. It is set to all 0's on transmit and ignored on receipt.",
      "ja": "予約済み：16ビットこのフィールドは予約されています。送信時にすべての0に設定され、受領時に無視されます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.2. Missing Mandatory Parameter (2)",
      "section_title": true,
      "ja": "3.3.10.2. 欠落している必須パラメーター（2）"
    },
    {
      "indent": 3,
      "text": "Indicates that one or more mandatory TLV parameters are missing in a received INIT or INIT ACK chunk.",
      "ja": "受信したinitまたはinit ackチャンクで1つ以上の必須のTLVパラメーターが欠落していることを示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 2         |   Cause Length = 8 + N * 2    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Number of missing params = N                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Missing Param Type #1     |     Missing Param Type #2     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Missing Param Type #N-1    |     Missing Param Type #N     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Number of Missing params: 32 bits (unsigned integer) This field contains the number of parameters contained in the Cause-Specific Information field.",
      "ja": "不足しているパラマの数：32ビット（符号なし整数）このフィールドには、原因固有の情報フィールドに含まれるパラメーターの数が含まれています。"
    },
    {
      "indent": 3,
      "text": "Missing Param Type: 16 bits (unsigned integer) Each field will contain the missing mandatory parameter number.",
      "ja": "欠落したパラマイプタイプ：16ビット（符号なし整数）各フィールドには、欠落している必須パラメーター番号が含まれます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.3. Stale Cookie (3)",
      "section_title": true,
      "ja": "3.3.10.3. 古いクッキー（3）"
    },
    {
      "indent": 3,
      "text": "Indicates the receipt of a valid State Cookie that has expired.",
      "ja": "有効期限が切れた有効な状態Cookieの受領を示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 3         |       Cause Length = 8        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Measure of Staleness (usec.)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Measure of Staleness: 32 bits (unsigned integer) This field contains the difference, rounded up in microseconds, between the current time and the time the State Cookie expired.",
      "ja": "老化の尺度：32ビット（符号なし整数）このフィールドには、現在の時刻と状態Cookieが期限切れになった間に、マイクロ秒で丸められた違いが含まれています。"
    },
    {
      "indent": 6,
      "text": "The sender of this error cause MAY choose to report how long past expiration the State Cookie is by including a non-zero value in the Measure of Staleness field. If the sender does not wish to provide the Measure of Staleness, it SHOULD set this field to the value of zero.",
      "ja": "このエラーの原因の送信者は、stalcookieの測定フィールドに非ゼロ値を含めることにより、州のCookieが過去の有効期限がどれだけの期間であるかを報告することを選択できます。送信者が頑固さの尺度を提供したくない場合、このフィールドをゼロの値に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.10.4. Out of Resource (4)",
      "section_title": true,
      "ja": "3.3.10.4. リソースから（4）"
    },
    {
      "indent": 3,
      "text": "Indicates that the sender is out of resource. This is usually sent in combination with or within an ABORT chunk.",
      "ja": "送信者がリソースから外れていることを示します。これは通常、中止塊と組み合わせて、または中止塊内で送信されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 4         |       Cause Length = 4        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.10.5. Unresolvable Address (5)",
      "section_title": true,
      "ja": "3.3.10.5. 解決不可能なアドレス（5）"
    },
    {
      "indent": 3,
      "text": "Indicates that the sender is not able to resolve the specified address parameter (e.g., type of address is not supported by the sender). This is usually sent in combination with or within an ABORT chunk.",
      "ja": "送信者が指定されたアドレスパラメーターを解決できないことを示します（たとえば、アドレスのタイプが送信者によってサポートされていません）。これは通常、中止塊と組み合わせて、または中止塊内で送信されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 5         |         Cause Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                     Unresolvable Address                      /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unresolvable Address: variable length The Unresolvable Address field contains the complete Type, Length, and Value of the address parameter (or Host Name parameter) that contains the unresolvable address or host name.",
      "ja": "解決不可能なアドレス：可変長さ解決不可能なアドレスフィールドには、解決不可能なアドレスまたはホスト名を含むアドレスパラメーター（またはホスト名パラメーター）の完全なタイプ、長さ、および値が含まれます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.6. Unrecognized Chunk Type (6)",
      "section_title": true,
      "ja": "3.3.10.6. 認識されていないチャンクタイプ（6）"
    },
    {
      "indent": 3,
      "text": "This error cause is returned to the originator of the chunk if the receiver does not understand the chunk and the upper bits of the 'Chunk Type' are set to 01 or 11.",
      "ja": "このエラー原因は、受信機がチャンクを理解しておらず、「チャンクタイプ」の上部ビットが01または11に設定されている場合、チャンクの発信元に返されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 6         |         Cause Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Unrecognized Chunk                       /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unrecognized Chunk: variable length The Unrecognized Chunk field contains the unrecognized chunk from the SCTP packet complete with Chunk Type, Chunk Flags, and Chunk Length.",
      "ja": "認識されていないチャンク：可変長さのないチャンクフィールドには、チャンクタイプ、チャンクフラグ、チャンクの長さを備えたSCTPパケットからの認識されていないチャンクが含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.10.7. Invalid Mandatory Parameter (7)",
      "section_title": true,
      "ja": "3.3.10.7. 無効な必須パラメーター（7）"
    },
    {
      "indent": 3,
      "text": "This error cause is returned to the originator of an INIT or INIT ACK chunk when one of the mandatory parameters is set to an invalid value.",
      "ja": "このエラー原因は、必須パラメーターのいずれかが無効な値に設定されている場合、initまたはinit ackチャンクのオリジネーターに返されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 7         |       Cause Length = 4        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.10.8. Unrecognized Parameters (8)",
      "section_title": true,
      "ja": "3.3.10.8. 認識されていないパラメーター（8）"
    },
    {
      "indent": 3,
      "text": "This error cause is returned to the originator of the INIT ACK chunk if the receiver does not recognize one or more Optional TLV parameters in the INIT ACK chunk.",
      "ja": "このエラー原因は、受信機がinit ackチャンクの1つ以上のオプションのTLVパラメーターを認識しない場合、init ackチャンクの発信元に返されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 8         |         Cause Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Unrecognized Parameters                    /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unrecognized Parameters: variable length The Unrecognized Parameters field contains the unrecognized parameters copied from the INIT ACK chunk complete with TLV. This error cause is normally contained in an ERROR chunk bundled with the COOKIE ECHO chunk when responding to the INIT ACK chunk, when the sender of the COOKIE ECHO chunk wishes to report unrecognized parameters.",
      "ja": "認識されていないパラメーター：可変長さのないパラメーターフィールドには、TLVを備えたinit ackチャンクからコピーされた認識されていないパラメーターが含まれています。このエラー原因は、通常、Cookie Echo Chunkの送信者が認識されていないパラメーターを報告したい場合、Init ACKチャンクに応答するときにクッキーエコーチャンクにバンドルされたエラーチャンクに含まれます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.9. No User Data (9)",
      "section_title": true,
      "ja": "3.3.10.9. ユーザーデータはありません（9）"
    },
    {
      "indent": 3,
      "text": "This error cause is returned to the originator of a DATA chunk if a received DATA chunk has no user data.",
      "ja": "受信したデータチャンクにユーザーデータがない場合、このエラー原因はデータチャンクの発信元に返されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 9         |       Cause Length = 8        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              TSN                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TSN: 32 bits (unsigned integer) This parameter contains the TSN of the DATA chunk received with no User Data field.",
      "ja": "TSN：32ビット（符号なし整数）このパラメーターには、ユーザーデータフィールドなしで受信したデータチャンクのTSNが含まれています。"
    },
    {
      "indent": 3,
      "text": "This cause code is normally returned in an ABORT chunk (see Section 6.2).",
      "ja": "この原因コードは通常、中止チャンクで返されます（セクション6.2を参照）。"
    },
    {
      "indent": 0,
      "text": "3.3.10.10. Cookie Received While Shutting Down (10)",
      "section_title": true,
      "ja": "3.3.10.10. シャットダウン中に受け取ったクッキー（10）"
    },
    {
      "indent": 3,
      "text": "A COOKIE ECHO chunk was received while the endpoint was in the SHUTDOWN-ACK-SENT state. This error is usually returned in an ERROR chunk bundled with the retransmitted SHUTDOWN ACK chunk.",
      "ja": "エンドポイントがシャットダウン済みの状態にある間に、クッキーエコーチャンクが受信されました。このエラーは通常、再送信されたシャットダウンACKチャンクにバンドルされたエラーチャンクで返されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 10        |       Cause Length = 4        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.10.11. Restart of an Association with New Addresses (11)",
      "section_title": true,
      "ja": "3.3.10.11. 新しいアドレスとの関連性の再開（11）"
    },
    {
      "indent": 3,
      "text": "An INIT chunk was received on an existing association. But the INIT chunk added addresses to the association that were previously not part of the association. The new addresses are listed in the error cause. This error cause is normally sent as part of an ABORT chunk refusing the INIT chunk (see Section 5.2).",
      "ja": "既存の協会でinit chunkが受け取られました。しかし、init chunkは、以前は協会の一部ではなかった協会に住所を追加しました。新しいアドレスは、エラー原因にリストされています。このエラー原因は、通常、INITチャンクを拒否する中止チャンクの一部として送信されます（セクション5.2を参照）。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 11        |         Cause Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                       New Address TLVs                        /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: Each New Address TLV is an exact copy of the TLV that was found in the INIT chunk that was new, including the Parameter Type and the Parameter Length.",
      "ja": "注：新しいアドレスTLVは、パラメータータイプとパラメーターの長さを含む、新品のinitチャンクで見つかったTLVの正確なコピーです。"
    },
    {
      "indent": 0,
      "text": "3.3.10.12. User-Initiated Abort (12)",
      "section_title": true,
      "ja": "3.3.10.12. ユーザー開始中断（12）"
    },
    {
      "indent": 3,
      "text": "This error cause MAY be included in ABORT chunks that are sent because of an upper-layer request. The upper layer can specify an Upper Layer Abort Reason that is transported by SCTP transparently and MAY be delivered to the upper-layer protocol at the peer.",
      "ja": "このエラー原因は、上層層の要求のために送信される中止チャンクに含まれる場合があります。上層層は、SCTPによって透過的に輸送され、ピアの上層層プロトコルに配信される可能性のある上層の中止理由を指定できます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Cause Code = 12        |         Cause Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                   Upper Layer Abort Reason                    /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.10.13. Protocol Violation (13)",
      "section_title": true,
      "ja": "3.3.10.13. プロトコル違反（13）"
    },
    {
      "indent": 3,
      "text": "This error cause MAY be included in ABORT chunks that are sent because an SCTP endpoint detects a protocol violation of the peer that is not covered by the error causes described in Sections 3.3.10.1 - 3.3.10.12. An implementation MAY provide additional information specifying what kind of protocol violation has been detected.",
      "ja": "このエラー原因は、SCTPエンドポイントがセクション3.3.10.1-3.3.10.12で説明されているエラー原因でカバーされていないピアのプロトコル違反を検出するため、送信される中止チャンクに含まれる場合があります。実装は、どのようなプロトコル違反が検出されたかを指定する追加情報を提供する場合があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Cause Code = 13         |        Cause Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Additional Information                     /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.11. Cookie Echo (COOKIE ECHO) (10)",
      "section_title": true,
      "ja": "3.3.11. クッキーエコー（クッキーエコー）（10）"
    },
    {
      "indent": 3,
      "text": "This chunk is used only during the initialization of an association. It is sent by the initiator of an association to its peer to complete the initialization process. This chunk MUST precede any DATA chunk sent within the association but MAY be bundled with one or more DATA chunks in the same packet.",
      "ja": "このチャンクは、関連付けの初期化中にのみ使用されます。協会のイニシエーターからピアに送信され、初期化プロセスを完了します。このチャンクは、協会内で送信されるデータチャンクの前に先行する必要がありますが、同じパケット内の1つ以上のデータチャンクにバンドルされる場合があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 10   |  Chunk Flags  |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                            Cookie                             /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer) Set to the size of the chunk in bytes, including the 4 bytes of the chunk header and the size of the cookie.",
      "ja": "長さ：チャンクヘッダーの4バイトとCookieのサイズを含む、バイトのチャンクのサイズに設定された16ビット（符号なし整数）。"
    },
    {
      "indent": 3,
      "text": "Cookie: variable size This field MUST contain the exact cookie received in the State Cookie parameter from the previous INIT ACK chunk.",
      "ja": "Cookie：可変サイズこのフィールドには、以前のinit ackチャンクから州のCookieパラメーターで受信した正確なCookieが含まれている必要があります。"
    },
    {
      "indent": 6,
      "text": "An implementation SHOULD make the cookie as small as possible to ensure interoperability.",
      "ja": "実装では、相互運用性を確保するために、Cookieをできるだけ小さくする必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: A Cookie Echo does not contain a State Cookie parameter; instead, the data within the State Cookie's Parameter Value becomes the data within the Cookie Echo's Chunk Value. This allows an implementation to change only the first 2 bytes of the State Cookie parameter to become a COOKIE ECHO chunk.",
      "ja": "注：Cookie Echoには、状態Cookieパラメーターが含まれていません。代わりに、State Cookieのパラメーター値内のデータは、Cookie Echoのチャンク値内のデータになります。これにより、実装が状態Cookieパラメーターの最初の2バイトのみを変更して、Cookie Echo Chunkになることができます。"
    },
    {
      "indent": 0,
      "text": "3.3.12. Cookie Acknowledgement (COOKIE ACK) (11)",
      "section_title": true,
      "ja": "3.3.12. クッキー謝辞（Cookie ack）（11）"
    },
    {
      "indent": 3,
      "text": "This chunk is used only during the initialization of an association. It is used to acknowledge the receipt of a COOKIE ECHO chunk. This chunk MUST precede any DATA or SACK chunk sent within the association but MAY be bundled with one or more DATA chunks or SACK chunk's in the same SCTP packet.",
      "ja": "このチャンクは、関連付けの初期化中にのみ使用されます。クッキーエコーチャンクの受領を認めるために使用されます。このチャンクは、協会内で送信されたデータまたはサックチャンクの前に先行する必要がありますが、同じSCTPパケットに1つ以上のデータチャンクまたはサックチャンクにバンドルされる場合があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 11   |  Chunk Flags  |          Length = 4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 0,
      "text": "3.3.13. Shutdown Complete (SHUTDOWN COMPLETE) (14)",
      "section_title": true,
      "ja": "3.3.13. シャットダウン完全（シャットダウン完全）（14）"
    },
    {
      "indent": 3,
      "text": "This chunk MUST be used to acknowledge the receipt of the SHUTDOWN ACK chunk at the completion of the shutdown process; see Section 9.2 for details.",
      "ja": "このチャンクは、シャットダウンプロセスの完了時にシャットダウンACKチャンクの受領を認めるために使用する必要があります。詳細については、セクション9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The SHUTDOWN COMPLETE chunk has no parameters.",
      "ja": "シャットダウン完全チャンクにはパラメーターがありません。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 14   |  Reserved   |T|          Length = 4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits Reserved: 7 bits Set to 0 on transmit and ignored on receipt.",
      "ja": "チャンクフラグ：8ビット予約済み：送信時に0に設定され、受領時に無視されます。"
    },
    {
      "indent": 6,
      "text": "T bit: 1 bit The T bit is set to 0 if the sender filled in the Verification Tag expected by the peer. If the Verification Tag is reflected, the T bit MUST be set to 1. Reflecting means that the sent Verification Tag is the same as the received one.",
      "ja": "Tビット：1ビットTビットは、ピアが予想される検証タグに送信者が記入された場合、0に設定されています。検証タグが反映されている場合、tビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Special rules apply to this chunk for verification; please see Section 8.5.1 for details.",
      "ja": "注：検証のためにこのチャンクには特別なルールが適用されます。詳細については、セクション8.5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. SCTP Association State Diagram",
      "section_title": true,
      "ja": "4. SCTP協会の状態図"
    },
    {
      "indent": 3,
      "text": "During the life time of an SCTP association, the SCTP endpoint's association progresses from one state to another in response to various events. The events that might potentially advance an association's state include:",
      "ja": "SCTP協会の生涯の間、SCTPエンドポイントの協会は、さまざまなイベントに応じて、ある状態から別の状態に進みます。協会の状態を潜在的に前進させる可能性のあるイベントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* SCTP user primitive calls, e.g., [ASSOCIATE], [SHUTDOWN], or [ABORT],",
      "ja": "* SCTPユーザープリミティブコール、例えば[アソシエイト]、[シャットダウン]、または[Abort]、"
    },
    {
      "indent": 3,
      "text": "* reception of INIT, COOKIE ECHO, ABORT, SHUTDOWN, etc., and control chunks, or",
      "ja": "* init、cookie echo、abort、shutdownなどの受信、チャンク、またはコントロール、または"
    },
    {
      "indent": 3,
      "text": "* some timeout events.",
      "ja": "* いくつかのタイムアウトイベント。"
    },
    {
      "indent": 3,
      "text": "The state diagram in the figures below illustrates state changes, together with the causing events and resulting actions. Note that some of the error conditions are not shown in the state diagram. Full descriptions of all special cases are found in the text.",
      "ja": "以下の図の状態図は、原因となるイベントと結果のアクションとともに、状態の変化を示しています。エラー条件の一部は状態図に示されていないことに注意してください。すべての特別なケースの完全な説明は、テキストにあります。"
    },
    {
      "indent": 3,
      "text": "Note: Chunk names are given in all capital letters, while parameter names have the first letter capitalized, e.g., COOKIE ECHO chunk type vs. State Cookie parameter. If more than one event/message can occur that causes a state transition, it is labeled (A) or (B).",
      "ja": "注：チャンク名はすべての大文字で指定されますが、パラメーター名には最初の文字が大文字になります。状態遷移を引き起こす複数のイベント/メッセージが発生する可能性がある場合、それは（a）または（b）とラベル付けされます。"
    },
    {
      "indent": 3,
      "text": "                        -----          -------- (from any state)\n                      /       \\      /receive ABORT      [ABORT]\n        receive INIT |         |    |--------------  or ----------\n---------------------|         v    v    delete TCB     send ABORT\ngenerate State Cookie \\    +---------+                  delete TCB\n        send INIT ACK   ---|  CLOSED |\n                           +---------+\n                             /      \\\n                            /        \\  [ASSOCIATE]\n                           |          |-----------------\n                           |          | create TCB\n                           |          | send INIT\n          receive valid    |          | start T1-init timer\n          COOKIE  ECHO     |          v\n      (1) -----------------|    +-----------+\n          create TCB       |    |COOKIE-WAIT| (2)\n          send COOKIE ACK  |    +-----------+\n                           |          |\n                           |          | receive INIT ACK\n                           |          |-------------------\n                           |          | send COOKIE ECHO\n                           |          | stop T1-init timer\n                           |          | start T1-cookie timer\n                           |          v\n                           |   +-------------+\n                           |   |COOKIE-ECHOED| (3)\n                           |   +-------------+\n                           |          |\n                           |          | receive COOKIE ACK\n                           |          |-------------------\n                           |          | stop T1-cookie timer\n                           v          v\n                         +---------------+\n                         |  ESTABLISHED  |\n                         +---------------+\n                                 |\n                                 |\n                        /--------+--------\\\n    [SHUTDOWN]         /                   \\\n    -------------------|                   |\n    check outstanding  |                   |\n    DATA chunks        |                   |\n                       v                   |\n              +----------------+           |\n              |SHUTDOWN-PENDING|           | receive SHUTDOWN\n              +----------------+           |------------------\n                                           | check outstanding\n                       |                   | DATA chunks\nNo more outstanding    |                   |\n-----------------------|                   |\nsend SHUTDOWN          |                   |\nstart T2-shutdown timer|                   |\n                       v                   v\n                +-------------+   +-----------------+\n            (4) |SHUTDOWN-SENT|   |SHUTDOWN-RECEIVED| (5,6)\n                +-------------+   +-----------------+\n                       |  \\                |\nreceive SHUTDOWN ACK   |   \\               |\n-----------------------|    \\              |\nstop T2-shutdown timer |     \\             |\nsend SHUTDOWN COMPLETE |      \\            |\ndelete TCB             |       \\           |\n                       |        \\          | No more outstanding\n                       |         \\         |--------------------\n                       |          \\        | send SHUTDOWN ACK\nreceive SHUTDOWN      -|-          \\       | start T2-shutdown timer\n--------------------/  | \\----------\\      |\nsend SHUTDOWN ACK      |             \\     |\nstart T2-shutdown timer|              \\    |\n                       |               \\   |\n                       |                |  |\n                       |                v  v\n                       |          +-----------------+\n                       |          |SHUTDOWN-ACK-SENT| (7)\n                       |          +-----------------+\n                       |                   | (A)\n                       |                   |receive SHUTDOWN COMPLETE\n                       |                   |-------------------------\n                       |                   | stop T2-shutdown timer\n                       |                   | delete TCB\n                       |                   |\n                       |                   | (B)\n                       |                   | receive SHUTDOWN ACK\n                       |                   |-----------------------\n                       |                   | stop T2-shutdown timer\n                       |                   | send SHUTDOWN COMPLETE\n                       |                   | delete TCB\n                       |                   |\n                       \\    +---------+    /\n                        \\-->| CLOSED  |<--/\n                            +---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 3: State Transition Diagram of SCTP",
      "ja": "図3：SCTPの状態遷移図"
    },
    {
      "indent": 3,
      "text": "The following applies:",
      "ja": "以下が適用されます："
    },
    {
      "indent": 3,
      "text": "1) If the State Cookie in the received COOKIE ECHO chunk is invalid (i.e., failed to pass the integrity check), the receiver MUST silently discard the packet. Or, if the received State Cookie is expired (see Section 5.1.5), the receiver MUST send back an ERROR chunk. In either case, the receiver stays in the CLOSED state.",
      "ja": "1) 受信したCookie Echo Chunkの状態Cookieが無効である場合（つまり、整合性チェックに合格できなかった場合）、受信者はパケットを静かに捨てる必要があります。または、受信した状態Cookieの有効期限が切れている場合（セクション5.1.5を参照）、受信者はエラーチャンクを送信する必要があります。どちらの場合でも、受信者は閉じた状態にとどまります。"
    },
    {
      "indent": 3,
      "text": "2) If the T1-init timer expires, the endpoint MUST retransmit the INIT chunk and restart the T1-init timer. The endpoint stays in the COOKIE-WAIT state. This MUST be repeated up to 'Max.Init.Retransmits' times. After that, the endpoint MUST abort the initialization process and report the error to the SCTP user.",
      "ja": "2) T1-ISITタイマーの有効期限が切れた場合、エンドポイントはinitチャンクを再送信し、T1-Initタイマーを再起動する必要があります。エンドポイントは、Cookie-Wait状態にとどまります。これは、「max.init.retransmits」の時代まで繰り返す必要があります。その後、エンドポイントは初期化プロセスを中止し、エラーをSCTPユーザーに報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "3) If the T1-cookie timer expires, the endpoint MUST retransmit COOKIE ECHO chunk and restart the T1-cookie timer. The endpoint stays in the COOKIE-ECHOED state. This MUST be repeated up to 'Max.Init.Retransmits' times. After that, the endpoint MUST abort the initialization process and report the error to the SCTP user.",
      "ja": "3) T1-Cookieタイマーが期限切れになった場合、エンドポイントはCookie Echo Chunkを再送信し、T1-Cookieタイマーを再起動する必要があります。エンドポイントは、Cookieでエコーされた状態にとどまります。これは、「max.init.retransmits」の時代まで繰り返す必要があります。その後、エンドポイントは初期化プロセスを中止し、エラーをSCTPユーザーに報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "4) In the SHUTDOWN-SENT state, the endpoint MUST acknowledge any received DATA chunks without delay.",
      "ja": "4) シャットダウン状態では、エンドポイントは遅滞なく受信したデータのチャンクを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "5) In the SHUTDOWN-RECEIVED state, the endpoint MUST NOT accept any new send requests from its SCTP user.",
      "ja": "5) シャットダウンが推定される状態では、エンドポイントはSCTPユーザーからの新しい送信要求を受け入れてはなりません。"
    },
    {
      "indent": 3,
      "text": "6) In the SHUTDOWN-RECEIVED state, the endpoint MUST transmit or retransmit data and leave this state when all data in queue is transmitted.",
      "ja": "6) シャットダウンが推定される状態では、エンドポイントはデータを送信または再送信し、キュー内のすべてのデータが送信された場合にこの状態を離れる必要があります。"
    },
    {
      "indent": 3,
      "text": "7) In the SHUTDOWN-ACK-SENT state, the endpoint MUST NOT accept any new send requests from its SCTP user.",
      "ja": "7) Shutdown-ack-Sent状態では、エンドポイントはSCTPユーザーからの新しい送信要求を受け入れてはなりません。"
    },
    {
      "indent": 3,
      "text": "The CLOSED state is used to indicate that an association is not created (i.e., does not exist).",
      "ja": "閉じた状態は、関連性が作成されていないことを示すために使用されます（つまり、存在しません）。"
    },
    {
      "indent": 0,
      "text": "5. Association Initialization",
      "section_title": true,
      "ja": "5. 協会の初期化"
    },
    {
      "indent": 3,
      "text": "Before the first data transmission can take place from one SCTP endpoint (\"A\") to another SCTP endpoint (\"Z\"), the two endpoints MUST complete an initialization process in order to set up an SCTP association between them.",
      "ja": "最初のデータ送信が1つのSCTPエンドポイント（ \"A\"）から別のSCTPエンドポイント（ \"z\"）に行われる前に、2つのエンドポイントは、それらの間にSCTP関連を設定するために初期化プロセスを完了する必要があります。"
    },
    {
      "indent": 3,
      "text": "The SCTP user at an endpoint can use the ASSOCIATE primitive to initialize an SCTP association to another SCTP endpoint.",
      "ja": "エンドポイントのSCTPユーザーは、アソシエイトプリミティブを使用して、SCTPアソシエーションを別のSCTPエンドポイントに初期化できます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: From an SCTP user's point of view, an association might be implicitly opened, without an ASSOCIATE primitive (see Section 11.1.2) being invoked, by the initiating endpoint's sending of the first user data to the destination endpoint. The initiating SCTP will assume default values for all mandatory and optional parameters for the INIT/INIT ACK chunk.",
      "ja": "実装注：SCTPユーザーの視点から、エンドポイントが最初のユーザーデータを宛先エンドポイントに送信することにより、アソシエイトプリミティブ（セクション11.1.2を参照）が呼び出されることなく、関連性が暗黙的に開かれる可能性があります。開始SCTPは、init/init ackチャンクのすべての必須およびオプションのパラメーターのデフォルト値を想定します。"
    },
    {
      "indent": 3,
      "text": "Once the association is established, unidirectional streams are open for data transfer on both ends (see Section 5.1.1).",
      "ja": "関連が確立されると、両端のデータ転送のために一方向のストリームが開かれています（セクション5.1.1を参照）。"
    },
    {
      "indent": 0,
      "text": "5.1. Normal Establishment of an Association",
      "section_title": true,
      "ja": "5.1. 協会の通常の確立"
    },
    {
      "indent": 3,
      "text": "The initialization process consists of the following steps (assuming that SCTP endpoint \"A\" tries to set up an association with SCTP endpoint \"Z\" and \"Z\" accepts the new association):",
      "ja": "初期化プロセスは、次の手順で構成されています（SCTPエンドポイント「A」がSCTPエンドポイント「Z」との関連付けを設定しようとすると仮定し、「Z」は新しい関連付けを受け入れます）："
    },
    {
      "indent": 3,
      "text": "A) \"A\" first builds a TCB and sends an INIT chunk to \"Z\". In the INIT chunk, \"A\" MUST provide its Verification Tag (Tag_A) in the Initiate Tag field. Tag_A SHOULD be a random number in the range of 1 to 4294967295 (see Section 5.3.1 for Tag value selection). After sending the INIT chunk, \"A\" starts the T1-init timer and enters the COOKIE-WAIT state.",
      "ja": "a）「a」は最初にTCBを構築し、「z」にinitチャンクを送信します。init chunkでは、 \"a\"はeatiateタグフィールドに検証タグ（tag_a）を提供する必要があります。TAG_Aは、1〜4294967295の範囲の乱数である必要があります（タグ値の選択については、セクション5.3.1を参照）。init chunkを送信した後、「a」はT1-Initタイマーを開始し、Cookie-Wait状態に入ります。"
    },
    {
      "indent": 3,
      "text": "B) \"Z\" responds immediately with an INIT ACK chunk. The destination IP address of the INIT ACK chunk MUST be set to the source IP address of the INIT chunk to which this INIT ACK chunk is responding. In the response, besides filling in other parameters, \"Z\" MUST set the Verification Tag field to Tag_A and also provide its own Verification Tag (Tag_Z) in the Initiate Tag field.",
      "ja": "b） \"z\"は、init ackチャンクですぐに応答します。init ackチャンクの宛先IPアドレスは、このinit ackチャンクが応答しているinitチャンクのソースIPアドレスに設定する必要があります。応答では、他のパラメーターに記入することに加えて、「z」は検証タグフィールドをtag_aに設定し、開始タグフィールドに独自の検証タグ（tag_z）を提供する必要があります。"
    },
    {
      "indent": 7,
      "text": "Moreover, \"Z\" MUST generate and send along with the INIT ACK chunk a State Cookie. See Section 5.1.3 for State Cookie generation.",
      "ja": "さらに、「z」は、init ack chunk a state cookieとともに生成して送信する必要があります。州のクッキー生成については、セクション5.1.3を参照してください。"
    },
    {
      "indent": 7,
      "text": "After sending an INIT ACK chunk with the State Cookie parameter, \"Z\" MUST NOT allocate any resources or keep any states for the new association. Otherwise, \"Z\" will be vulnerable to resource attacks.",
      "ja": "State Cookieパラメーターを使用してinit ackチャンクを送信した後、「z」はリソースを割り当てたり、新しい協会の状態を維持したりしてはなりません。それ以外の場合、「Z」はリソース攻撃に対して脆弱になります。"
    },
    {
      "indent": 3,
      "text": "C) Upon reception of the INIT ACK chunk from \"Z\", \"A\" stops the T1-init timer and leaves the COOKIE-WAIT state. \"A\" then sends the State Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, starts the T1-cookie timer, and enters the COOKIE-ECHOED state.",
      "ja": "c）「Z」からのINIT ACKチャンクを受信すると、「A」はT1INITタイマーを停止し、Cookie-Wait状態を離れます。「A」は、Cookie Echo ChunkでINIT ACKチャンクで受け取った状態Cookieを送信し、T1-Cookieタイマーを開始し、Cookieエコー状態に入ります。"
    },
    {
      "indent": 7,
      "text": "The COOKIE ECHO chunk MAY be bundled with any pending outbound DATA chunks, but it MUST be the first chunk in the packet and, until the COOKIE ACK chunk is returned, the sender MUST NOT send any other packets to the peer.",
      "ja": "Cookie Echo Chunkは、保留中のアウトバウンドデータチャンクにバンドルされる場合がありますが、それはパケットの最初のチャンクである必要があり、Cookie Ack Chunkが返されるまで、送信者は他のパケットをピアに送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "D) Upon reception of the COOKIE ECHO chunk, endpoint \"Z\" replies with a COOKIE ACK chunk after building a TCB and moving to the ESTABLISHED state. A COOKIE ACK chunk MAY be bundled with any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK chunk MUST be the first chunk in the packet.",
      "ja": "d）Cookie Echo Chunkを受信すると、TCBを構築して確立された状態に移動した後、エンドポイント「Z」はCookie ACKチャンクで応答します。Cookie Ackチャンクは、保留中のデータチャンク（および/またはサックチャンク）にバンドルされる場合がありますが、Cookie Ackチャンクはパケットの最初のチャンクでなければなりません。"
    },
    {
      "indent": 7,
      "text": "Implementation Note: An implementation can choose to send the COMMUNICATION UP notification to the SCTP user upon reception of a valid COOKIE ECHO chunk.",
      "ja": "実装注：実装は、有効なCookie Echo Chunkを受信すると、通信通知をSCTPユーザーに送信することを選択できます。"
    },
    {
      "indent": 3,
      "text": "E) Upon reception of the COOKIE ACK chunk, endpoint \"A\" moves from the COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie timer. It can also notify its ULP about the successful establishment of the association with a COMMUNICATION UP notification (see Section 11).",
      "ja": "e）Cookie Ack Chunkを受信すると、エンドポイント「A」はCookieでエコーされた状態から確立された状態に移動し、T1-Cookieタイマーを停止します。また、コミュニケーションのアップ通知との関連の確立の成功についてULPに通知することもできます（セクション11を参照）。"
    },
    {
      "indent": 3,
      "text": "An INIT or INIT ACK chunk MUST NOT be bundled with any other chunk. They MUST be the only chunks present in the SCTP packets that carry them.",
      "ja": "initまたはinit ackチャンクを他のチャンクにバンドルしてはなりません。それらは、それらを運ぶSCTPパケットに存在する唯一のチャンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST send the INIT ACK chunk to the IP address from which it received the INIT chunk.",
      "ja": "エンドポイントは、initチャンクを受け取ったIPアドレスにinit ackチャンクを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The T1-init timer and T1-cookie timer SHOULD follow the same rules given in Section 6.3. If the application provided multiple IP addresses of the peer, there SHOULD be a T1-init and T1-cookie timer for each address of the peer. Retransmissions of INIT chunks and COOKIE ECHO chunks SHOULD use all addresses of the peer similar to retransmissions of DATA chunks.",
      "ja": "T1-ISITタイマーとT1-Cookieタイマーは、セクション6.3に示されているのと同じルールに従う必要があります。アプリケーションがピアの複数のIPアドレスを提供した場合、ピアの各アドレスにT1-InitおよびT1-Cookieタイマーがあるはずです。InitチャンクとCookieエコーチャンクの再送信は、データチャンクの再送信と同様のピアのすべてのアドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but decides not to establish the new association due to missing mandatory parameters in the received INIT or INIT ACK chunk, invalid parameter values, or lack of local resources, it SHOULD respond with an ABORT chunk. It SHOULD also specify the cause of abort, such as the type of the missing mandatory parameters, etc., by including an error cause in the ABORT chunk. The Verification Tag field in the common header of the outbound SCTP packet containing the ABORT chunk MUST be set to the Initiate Tag value of the received INIT or INIT ACK chunk this ABORT chunk is responding to.",
      "ja": "エンドポイントがinit、init ack、またはcookieエコーチャンクを受信しますが、受信したinitまたはinit ackチャンク、無効なパラメーター値、またはローカルリソースの欠如に必須パラメーターが欠落しているため、新しい関連性を確立しないことを決定した場合、応答する必要があります。中止塊。また、不定塊にエラー原因を含めることにより、欠落している必須パラメーターなどのタイプなど、中止の原因を指定する必要があります。アコートチャンクを含むアウトバウンドSCTPパケットの共通ヘッダーの検証タグフィールドは、受信したinitまたはinit ackチャンクの開始タグ値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that a COOKIE ECHO chunk that does not pass the integrity check is not considered an 'invalid mandatory parameter' and requires special handling; see Section 5.1.5.",
      "ja": "整合性チェックに合格しないCookieエコーチャンクは、「無効な必須パラメーター」とは見なされず、特別な取り扱いが必要であることに注意してください。セクション5.1.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "After the reception of the first DATA chunk in an association, the endpoint MUST immediately respond with a SACK chunk to acknowledge the DATA chunk. Subsequent acknowledgements SHOULD be done as described in Section 6.2.",
      "ja": "関連性における最初のデータチャンクを受信した後、エンドポイントは、データチャンクを認めるためにサックチャンクで直ちに応答する必要があります。セクション6.2で説明されているように、後続の承認を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "When the TCB is created, each endpoint MUST set its internal Cumulative TSN Ack Point to the value of its transmitted Initial TSN minus one.",
      "ja": "TCBが作成されると、各エンドポイントは、内部累積TSN ACKポイントを送信された初期TSNマイナス1の値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: The IP addresses and SCTP port are generally used as the key to find the TCB within an SCTP instance.",
      "ja": "実装注：IPアドレスとSCTPポートは、通常、SCTPインスタンス内でTCBを見つけるためのキーとして使用されます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Handle Stream Parameters",
      "section_title": true,
      "ja": "5.1.1. ストリームパラメーターを処理します"
    },
    {
      "indent": 3,
      "text": "In the INIT and INIT ACK chunks, the sender of the chunk MUST indicate the number of outbound streams (OS) it wishes to have in the association, as well as the maximum inbound streams (MIS) it will accept from the other endpoint.",
      "ja": "init and init ackチャンクでは、チャンクの送信者は、協会に希望するアウトバウンドストリーム（OS）の数と、他のエンドポイントから受け入れる最大インバウンドストリーム（MIS）を示す必要があります。"
    },
    {
      "indent": 3,
      "text": "After receiving the stream configuration information from the other side, each endpoint MUST perform the following check: If the peer's MIS is less than the endpoint's OS, meaning that the peer is incapable of supporting all the outbound streams the endpoint wants to configure, the endpoint MUST use MIS outbound streams and MAY report any shortage to the upper layer. The upper layer can then choose to abort the association if the resource shortage is unacceptable.",
      "ja": "反対側からストリーム構成情報を受信した後、各エンドポイントは次のチェックを実行する必要があります。ピアのMISがエンドポイントのOSよりも少ない場合、ピアはエンドポイントが設定したいすべてのアウトバウンドストリームをサポートできないことを意味します。ミスアウトバウンドストリームを使用する必要があり、上層層に不足を報告する場合があります。上層層は、リソース不足が受け入れられない場合、関連性を中止することを選択できます。"
    },
    {
      "indent": 3,
      "text": "After the association is initialized, the valid outbound stream identifier range for either endpoint MUST be 0 to min(local OS, remote MIS) - 1.",
      "ja": "関連付けが初期化された後、いずれかのエンドポイントの有効なアウトバウンドストリーム識別子範囲は0〜min（ローカルOS、リモートMIS）-1でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Handle Address Parameters",
      "section_title": true,
      "ja": "5.1.2. アドレスパラメーターを処理します"
    },
    {
      "indent": 3,
      "text": "During the association initialization, an endpoint uses the following rules to discover and collect the destination transport address(es) of its peer.",
      "ja": "協会の初期化中、エンドポイントは次のルールを使用して、ピアの宛先輸送アドレス（ES）を発見および収集します。"
    },
    {
      "indent": 3,
      "text": "A) If there are no address parameters present in the received INIT or INIT ACK chunk, the endpoint MUST take the source IP address from which the chunk arrives and record it, in combination with the SCTP Source Port Number, as the only destination transport address for this peer.",
      "ja": "a）受信したinitまたはinit ackチャンクにアドレスパラメーターが存在しない場合、エンドポイントは、唯一の宛先輸送アドレスとして、SCTPソースポート番号と組み合わせて、チャンクが到着するソースIPアドレスを取得し、それを記録する必要があります。このピアのために。"
    },
    {
      "indent": 3,
      "text": "B) If there is a Host Name Address parameter present in the received INIT or INIT ACK chunk, the endpoint MUST immediately send an ABORT chunk and MAY include an \"Unresolvable Address\" error cause to its peer. The ABORT chunk SHOULD be sent to the source IP address from which the last peer packet was received.",
      "ja": "b）受信したinitまたはinit ackチャンクにホスト名アドレスパラメーターが存在する場合、エンドポイントはすぐに中止チャンクを送信する必要があり、ピアに「解決できないアドレス」エラー原因を含めることができます。中止チャンクは、最後のピアパケットを受信したソースIPアドレスに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "C) If there are only IPv4/IPv6 addresses present in the received INIT or INIT ACK chunk, the receiver MUST derive and record all the transport addresses from the received chunk AND the source IP address that sent the INIT or INIT ACK chunk. The transport addresses are derived by the combination of SCTP Source Port Number (from the common header) and the IP Address parameter(s) carried in the INIT or INIT ACK chunk and the source IP address of the IP datagram. The receiver SHOULD use only these transport addresses as destination transport addresses when sending subsequent packets to its peer.",
      "ja": "c）受信したinitまたはinit ackチャンクに存在するIPv4/IPv6アドレスのみがある場合、受信者は受信したチャンクからすべての輸送アドレスと、initまたはinit ackチャンクを送信したソースIPアドレスからすべての輸送アドレスを導出して記録する必要があります。トランスポートアドレスは、sctpソースポート番号（共通ヘッダーから）と、initまたはinit ackチャンクで運ばれるIPアドレスパラメーターとIPデータグラムのソースIPアドレスの組み合わせによって導き出されます。レシーバーは、後続のパケットをピアに送信する際に、これらの輸送アドレスのみを宛先輸送アドレスとして使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "D) An INIT or INIT ACK chunk MUST be treated as belonging to an already established association (or one in the process of being established) if the use of any of the valid address parameters contained within the chunk would identify an existing TCB.",
      "ja": "d）initまたはinit ackチャンクは、チャンク内に含まれる有効なアドレスパラメーターの使用が既存のTCBを識別する場合、既に確立された関連付け（または確立されているプロセス）に属するものとして扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: In some cases (e.g., when the implementation does not control the source IP address that is used for transmitting), an endpoint might need to include in its INIT or INIT ACK chunk all possible IP addresses from which packets to the peer could be transmitted.",
      "ja": "実装注：場合によっては（たとえば、実装が送信に使用されるソースIPアドレスを制御しない場合）、エンドポイントは、ピアへのパケットが可能なすべての可能なIPアドレスをinitまたはinit ackチャンクに含める必要がある場合があります。送信されます。"
    },
    {
      "indent": 3,
      "text": "After all transport addresses are derived from the INIT or INIT ACK chunk using the above rules, the endpoint selects one of the transport addresses as the initial primary path.",
      "ja": "上記のルールを使用して、すべての輸送アドレスがinitまたはinit ackチャンクから導出された後、エンドポイントは輸送アドレスの1つを初期プライマリパスとして選択します。"
    },
    {
      "indent": 3,
      "text": "The packet containing the INIT ACK chunk MUST be sent to the source address of the packet containing the INIT chunk.",
      "ja": "init ackチャンクを含むパケットは、initチャンクを含むパケットのソースアドレスに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of INIT chunks MAY include a 'Supported Address Types' parameter in the INIT chunk to indicate what types of addresses are acceptable.",
      "ja": "initチャンクの送信者には、initチャンクに「サポートされているアドレスタイプ」パラメーターが含まれているため、どのタイプのアドレスが許容できるかを示します。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: In the case that the receiver of an INIT ACK chunk fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a reinitiation by using a 'Supported Address Types' parameter in the new INIT chunk to indicate what types of address it prefers.",
      "ja": "実装注：init ackチャンクの受信者がサポートされていないタイプのためにアドレスパラメーターを解決できない場合、開始プロセスを中止してから、新しいinitの「サポートされているアドレスタイプ」パラメーターを使用して再現を試みることができます。どのタイプのアドレスが好むかを示すチャンク。"
    },
    {
      "indent": 3,
      "text": "If an SCTP endpoint that only supports either IPv4 or IPv6 receives IPv4 and IPv6 addresses in an INIT or INIT ACK chunk from its peer, it MUST use all the addresses belonging to the supported address family. The other addresses MAY be ignored. The endpoint SHOULD NOT respond with any kind of error indication.",
      "ja": "IPv4またはIPv6のいずれかをサポートするSCTPエンドポイントが、ピアからINITまたはINITACKチャンクでIPv4およびIPv6アドレスを受信する場合、サポートされているアドレスファミリに属するすべてのアドレスを使用する必要があります。他のアドレスは無視される場合があります。エンドポイントは、いかなる種類のエラー表示で応答しないでください。"
    },
    {
      "indent": 3,
      "text": "If an SCTP endpoint lists in the 'Supported Address Types' parameter either IPv4 or IPv6 but uses the other family for sending the packet containing the INIT chunk, or if it also lists addresses of the other family in the INIT chunk, then the address family that is not listed in the 'Supported Address Types' parameter SHOULD also be considered as supported by the receiver of the INIT chunk. The receiver of the INIT chunk SHOULD NOT respond with any kind of error indication.",
      "ja": "SCTPエンドポイントが「サポートされているアドレスタイプ」パラメーターにIPv4またはIPv6のいずれかのパラメーターにリストされていますが、他のファミリを使用してinitチャンクを含むパケットを送信する場合、またはinitチャンクの他のファミリのアドレスもリストする場合は、アドレスファミリをリストします。これは、「サポートされているアドレスタイプ」パラメーターには、initチャンクの受信者によってサポートされていると見なされる必要があります。init chunkの受信者は、いかなる種類のエラー表示で応答しないでください。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Generating State Cookie",
      "section_title": true,
      "ja": "5.1.3. ステートクッキーを生成します"
    },
    {
      "indent": 3,
      "text": "When sending an INIT ACK chunk as a response to an INIT chunk, the sender of the INIT ACK chunk creates a State Cookie and sends it in the State Cookie parameter of the INIT ACK chunk. Inside this State Cookie, the sender MUST include a MAC (see [RFC2104] for an example) to provide integrity protection on the State Cookie. The State Cookie SHOULD also contain a timestamp on when the State Cookie is created and the lifespan of the State Cookie, along with all the information necessary for it to establish the association, including the port numbers and the Verification Tags.",
      "ja": "init chunkへの応答としてinit ackチャンクを送信すると、init ackチャンクの送信者は状態クッキーを作成し、init ackチャンクのステートクッキーパラメーターに送信します。この状態Cookie内では、送信者は、状態Cookieに整合性保護を提供するために、Mac（例については[RFC2104]を参照）を含める必要があります。State Cookieには、State Cookieが作成される時期とState Cookieの寿命も、ポート番号や検証タグを含む関連性を確立するために必要なすべての情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The method used to generate the MAC is strictly a private matter for the receiver of the INIT chunk. The use of a MAC is mandatory to prevent denial-of-service attacks. MAC algorithms can have different performances depending on the platform. Choosing a high-performance MAC algorithm increases the resistance against cookie flooding attacks. A MAC with acceptable security properties SHOULD be used. The secret key SHOULD be random ([RFC4086] provides some information on randomness guidelines). The secret keys need to have an appropriate size. The secret key SHOULD be changed reasonably frequently (e.g., hourly), and the timestamp in the State Cookie MAY be used to determine which key is used to verify the MAC.",
      "ja": "MACを生成するために使用される方法は、INITチャンクの受信者にとって厳密に私的な問題です。Macの使用は、サービス拒否攻撃を防ぐために必須です。Macアルゴリズムは、プラットフォームに応じて異なるパフォーマンスを持つことができます。高性能MACアルゴリズムを選択すると、Cookie洪水攻撃に対する抵抗が増加します。許容可能なセキュリティプロパティを備えたMACを使用する必要があります。シークレットキーはランダムでなければなりません（[RFC4086]は、ランダム性ガイドラインに関するいくつかの情報を提供します）。秘密のキーには適切なサイズが必要です。シークレットキーは合理的に頻繁に変更される必要があります（たとえば、1時間ごと）、州のクッキーのタイムスタンプを使用して、どのキーを使用してMACを検証するかを決定することができます。"
    },
    {
      "indent": 3,
      "text": "If the State Cookie is not encrypted, it MUST NOT contain information that is not being envisioned to be shared.",
      "ja": "状態Cookieが暗号化されていない場合、共有されると想定されていない情報を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD make the cookie as small as possible to ensure interoperability.",
      "ja": "実装では、相互運用性を確保するために、Cookieをできるだけ小さくする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.4. State Cookie Processing",
      "section_title": true,
      "ja": "5.1.4. 状態クッキー処理"
    },
    {
      "indent": 3,
      "text": "When an endpoint (in the COOKIE-WAIT state) receives an INIT ACK chunk with a State Cookie parameter, it MUST immediately send a COOKIE ECHO chunk to its peer with the received State Cookie. The sender MAY also add any pending DATA chunks to the packet after the COOKIE ECHO chunk.",
      "ja": "（Cookie-Wait Stateで）エンドポイントがState Cookieパラメーターを使用してinit ackチャンクを受け取る場合、受け取った状態Cookieでピアにクッキーエコーチャンクをすぐに送信する必要があります。送信者は、Cookie Echo Chunkの後、保留中のデータチャンクをパケットに追加することもできます。"
    },
    {
      "indent": 3,
      "text": "The endpoint MUST also start the T1-cookie timer after sending the COOKIE ECHO chunk. If the timer expires, the endpoint MUST retransmit the COOKIE ECHO chunk and restart the T1-cookie timer. This is repeated until either a COOKIE ACK chunk is received or 'Max.Init.Retransmits' (see Section 16) is reached, causing the peer endpoint to be marked unreachable (and thus the association enters the CLOSED state).",
      "ja": "エンドポイントは、Cookie Echo Chunkを送信した後、T1-Cookieタイマーを起動する必要があります。タイマーの有効期限が切れた場合、エンドポイントはCookieエコーチャンクを再送信し、T1-Cookieタイマーを再起動する必要があります。これは、Cookie Ackチャンクを受信するか、「max.init.retransmits」（セクション16を参照）に到達し、ピアエンドポイントに到達不能にマークされます（したがって、関連付けが閉じた状態に入る）まで繰り返されます。"
    },
    {
      "indent": 0,
      "text": "5.1.5. State Cookie Authentication",
      "section_title": true,
      "ja": "5.1.5. 状態クッキー認証"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a COOKIE ECHO chunk from another endpoint with which it has no association, it takes the following actions:",
      "ja": "エンドポイントが関連性のない別のエンドポイントからクッキーエコーチャンクを受信すると、次のアクションが必要です。"
    },
    {
      "indent": 3,
      "text": "1) Compute a MAC using the information carried in the State Cookie and the secret key. The timestamp in the State Cookie MAY be used to determine which secret key to use. If secrets are kept only for a limited amount of time and the secret key to use is not available anymore, the packet containing the COOKIE ECHO chunk MUST be silently discarded. [RFC2104] can be used as a guideline for generating the MAC.",
      "ja": "1) State CookieとSecret Keyに携帯されている情報を使用してMacを計算します。州のクッキーのタイムスタンプを使用して、使用する秘密の鍵を決定することができます。秘密が限られた時間のためにのみ保持され、使用する秘密の鍵が利用できなくなった場合、Cookie Echo Chunkを含むパケットは静かに捨てなければなりません。[RFC2104]は、Macを生成するためのガイドラインとして使用できます。"
    },
    {
      "indent": 3,
      "text": "2) Authenticate the State Cookie as one that it previously generated by comparing the computed MAC against the one carried in the State Cookie. If this comparison fails, the SCTP packet, including the COOKIE ECHO chunk and any DATA chunks, MUST be silently discarded.",
      "ja": "2) State Cookieを、計算されたMacをState Cookieで運ばれたMacと比較することにより、以前に生成したものとして認証します。この比較が失敗した場合、Cookieエコーチャンクやデータチャンクを含むSCTPパケットは、静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "3) Compare the port numbers and the Verification Tag contained within the COOKIE ECHO chunk to the actual port numbers and the Verification Tag within the SCTP common header of the received packet. If these values do not match, the packet MUST be silently discarded.",
      "ja": "3) クッキーエコーチャンク内に含まれるポート番号と検証タグを、実際のポート番号と、受信したパケットのSCTP共通ヘッダー内の検証タグを比較します。これらの値が一致しない場合、パケットは静かに破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "4) Compare the creation timestamp in the State Cookie to the current local time. If the elapsed time is longer than the lifespan carried in the State Cookie, then the packet, including the COOKIE ECHO chunk and any attached DATA chunks, SHOULD be discarded, and the endpoint MUST transmit an ERROR chunk with a \"Stale Cookie\" error cause to the peer endpoint.",
      "ja": "4) 州のCookieの作成タイムスタンプを現在の現地時間と比較してください。経過時間が州のクッキーで運ばれる寿命よりも長い場合、Cookie Echo Chunkや添付のデータチャンクを含むパケットを破棄する必要があり、エンドポイントは「古いCookie」エラー原因の原因でエラーチャンクを送信する必要があります。ピアエンドポイントへ。"
    },
    {
      "indent": 3,
      "text": "5) If the State Cookie is valid, create an association to the sender of the COOKIE ECHO chunk with the information in the State Cookie carried in the COOKIE ECHO chunk and enter the ESTABLISHED state.",
      "ja": "5) 状態Cookieが有効な場合は、Cookie Echo Cookieの情報とCookie Echo Cookieの送信者との関連を作成し、Cookie Echo Chunkで運ばれ、確立された状態に入ります。"
    },
    {
      "indent": 3,
      "text": "6) Send a COOKIE ACK chunk to the peer acknowledging receipt of the COOKIE ECHO chunk. The COOKIE ACK chunk MAY be bundled with an outbound DATA chunk or SACK chunk; however, the COOKIE ACK chunk MUST be the first chunk in the SCTP packet.",
      "ja": "6) Cookie Echo Chunkの受領を承認するピアにCookie Ackチャンクを送信します。Cookie ACKチャンクは、アウトバウンドデータチャンクまたはサックチャンクにバンドルされる場合があります。ただし、Cookie ACKチャンクは、SCTPパケットの最初のチャンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "7) Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO chunk with a SACK chunk (subsequent DATA chunk acknowledgement SHOULD follow the rules defined in Section 6.2). As mentioned in step 6, if the SACK chunk is bundled with the COOKIE ACK chunk, the COOKIE ACK chunk MUST appear first in the SCTP packet.",
      "ja": "7) Cookie Echo Chunkにバンドルされたデータチャンクをサックチャンクですぐに確認します（後続のデータチャンク承認は、セクション6.2で定義されているルールに従う必要があります）。ステップ6で述べたように、Sack ChunkがCookie Ack Chunkにバンドルされている場合、Cookie Ack Chunkは最初にSCTPパケットに表示する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a COOKIE ECHO chunk is received from an endpoint with which the receiver of the COOKIE ECHO chunk has an existing association, the procedures in Section 5.2 SHOULD be followed.",
      "ja": "Cookie Echo Chunkのレシーバーに既存の関連性があるエンドポイントからCookie Echo Chunkが受信される場合、セクション5.2の手順に従う必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.6. An Example of Normal Association Establishment",
      "section_title": true,
      "ja": "5.1.6. 正常な協会の施設の例"
    },
    {
      "indent": 3,
      "text": "In the following example, \"A\" initiates the association and then sends a user message to \"Z\"; then, \"Z\" sends two user messages to \"A\" later (assuming no bundling or fragmentation occurs):",
      "ja": "次の例では、「a」が協会を開始し、「z」にユーザーメッセージを送信します。次に、「z」は2つのユーザーメッセージを「a」に送信します（バンドルや断片化が発生しないと仮定します）："
    },
    {
      "indent": 3,
      "text": "Endpoint A                                          Endpoint Z\n{app sets association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A\n      & other info]  ------\\\n(Start T1-init timer)       \\\n(Enter COOKIE-WAIT state)    \\---> (compose Cookie_Z)\n                                /-- INIT ACK [Veri Tag=Tag_A,\n                               /             I-Tag=Tag_Z,\n(Cancel T1-init timer) <------/              Cookie_Z, & other info]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COOKIE ECHO [Cookie_Z] ------\\\n(Start T1-cookie timer)       \\\n(Enter COOKIE-ECHOED state)    \\---> (build TCB, enter ESTABLISHED\n                                      state)\n                               /---- COOKIE ACK\n                              /\n(Cancel T1-cookie timer, <---/\n enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=init TSN_A\n    Strm=0,Seq=0 & user data]--\\\n(Start T3-rtx timer)            \\\n                                 \\->\n                               /----- SACK [TSN Ack=init TSN_A,\n                                            Block=0]\n(Cancel T3-rtx timer) <------/\n                                      ...\n                                     {app sends 2 messages;strm 0}\n                               /---- DATA\n                              /        [TSN=init TSN_Z,\n                          <--/          Strm=0,Seq=0 & user data 1]\nSACK [TSN Ack=init TSN_Z,      /---- DATA\n      Block=0]     --------\\  /        [TSN=init TSN_Z +1,\n                            \\/          Strm=0,Seq=1 & user data 2]\n                     <------/\\\n                              \\\n                               \\------>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 4: A Setup Example",
      "ja": "図4：セットアップの例"
    },
    {
      "indent": 3,
      "text": "If the T1-init timer expires at \"A\" after the INIT or COOKIE ECHO chunks are sent, the same INIT or COOKIE ECHO chunk with the same Initiate Tag (i.e., Tag_A) or State Cookie is retransmitted and the timer is restarted. This is repeated 'Max.Init.Retransmits' times before \"A\" considers \"Z\" unreachable and reports the failure to its upper layer (and thus the association enters the CLOSED state).",
      "ja": "INITまたはCookieエコーチャンクが送信された後、T1INITタイマーが「A」で期限切れになった場合、同じinitiateタグ（つまり、tag_a）を使用して同じinitまたはcookieエコーチャンクまたは状態クッキーが再送信され、タイマーが再起動されます。これは、「Z \"が到達不能と見なされ、上層層への失敗を報告する前に「max.init.retransmits」の時代に繰り返されます（したがって、関連付けは閉じた状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "When retransmitting the INIT chunk, the endpoint MUST follow the rules defined in Section 6.3 to determine the proper timer value.",
      "ja": "initチャンクを再送信する場合、エンドポイントはセクション6.3で定義されているルールに従って、適切なタイマー値を決定する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK Chunks",
      "ja": "5.2. 重複または予期しないinit、init ack、cookie echo、cookie ackチャンクを処理する"
    },
    {
      "indent": 3,
      "text": "During the life time of an association (in one of the possible states), an endpoint can receive from its peer endpoint one of the setup chunks (INIT, INIT ACK, COOKIE ECHO, or COOKIE ACK). The receiver treats such a setup chunk as a duplicate and process it as described in this section.",
      "ja": "協会の生涯（可能な状態の1つで）の間に、エンドポイントはピアエンドポイントからセットアップチャンクの1つ（init、init ack、cookie echo、またはcookie ack）を受け取ることができます。受信者は、このセットチャンクを複製として処理し、このセクションで説明したように処理します。"
    },
    {
      "indent": 3,
      "text": "Note: An endpoint will not receive the chunk unless the chunk was sent to an SCTP transport address and is from an SCTP transport address associated with this endpoint. Therefore, the endpoint processes such a chunk as part of its current association.",
      "ja": "注：チャンクがSCTP輸送アドレスに送信され、このエンドポイントに関連付けられたSCTP輸送アドレスからのものでない限り、エンドポイントはチャンクを受け取りません。したがって、エンドポイントは、現在の関連付けの一部としてそのようなチャンクを処理します。"
    },
    {
      "indent": 3,
      "text": "The following scenarios can cause duplicated or unexpected chunks:",
      "ja": "次のシナリオは、重複または予期しないチャンクを引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "A) the peer has crashed without being detected, restarted itself, and sent a new INIT chunk trying to restore the association,",
      "ja": "a）ピアは、検出されずにクラッシュし、再起動し、協会を復元しようとして新しいイニシ額を送信しました。"
    },
    {
      "indent": 3,
      "text": "B) both sides are trying to initialize the association at about the same time,",
      "ja": "b）双方がほぼ同時に協会を初期化しようとしている、"
    },
    {
      "indent": 3,
      "text": "C) the chunk is from a stale packet that was used to establish the present association or a past association that is no longer in existence,",
      "ja": "c）チャンクは、現在の関連性または存在しなくなった過去の関連性を確立するために使用された古いパケットからのものです。"
    },
    {
      "indent": 3,
      "text": "D) the chunk is a false packet generated by an attacker, or",
      "ja": "d）チャンクは、攻撃者によって生成された誤ったパケットです。"
    },
    {
      "indent": 3,
      "text": "E) the peer never received the COOKIE ACK chunk and is retransmitting its COOKIE ECHO chunk.",
      "ja": "e）ピアはCookie ACKチャンクを受け取ったことはなく、Cookie Echo Chunkを再送信しています。"
    },
    {
      "indent": 3,
      "text": "The rules in the following sections are applied in order to identify and correctly handle these cases.",
      "ja": "これらのケースを特定して正しく処理するために、次のセクションのルールが適用されます。"
    },
    {
      "indent": 0,
      "text": "5.2.1. INIT Chunk Received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)",
      "ja": "5.2.1. Cookie-WaitまたはCookie-Echoed状態で受け取ったinitチャンク（アイテムB）"
    },
    {
      "indent": 3,
      "text": "This usually indicates an initialization collision, i.e., each endpoint is attempting, at about the same time, to establish an association with the other endpoint.",
      "ja": "これは通常、初期化の衝突を示しています。つまり、各エンドポイントは、ほぼ同時に、他のエンドポイントとの関連を確立しようとしています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT chunk in the COOKIE-WAIT state, an endpoint MUST respond with an INIT ACK chunk using the same parameters it sent in its original INIT chunk (including its Initiate Tag, unchanged). When responding, the following rules MUST be applied:",
      "ja": "Cookie-Wait状態でinitチャンクを受け取ると、エンドポイントは、元のinitチャンク（開始タグを含む、変更されていない）で送信したのと同じパラメーターを使用して、init ackチャンクで応答する必要があります。応答する場合、次のルールを適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "1) The packet containing the INIT ACK chunk MUST only be sent to an address passed by the upper layer in the request to initialize the association.",
      "ja": "1) init ackチャンクを含むパケットは、関連性を初期化するためにリクエストの上層層で渡されたアドレスにのみ送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "2) The packet containing the INIT ACK chunk MUST only be sent to an address reported in the incoming INIT chunk.",
      "ja": "2) init ackチャンクを含むパケットは、着信Initチャンクで報告された住所にのみ送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "3) The packet containing the INIT ACK chunk SHOULD be sent to the source address of the received packet containing the INIT chunk.",
      "ja": "3) init ackチャンクを含むパケットは、initチャンクを含む受信パケットのソースアドレスに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT chunk in the COOKIE-ECHOED state, an endpoint MUST respond with an INIT ACK chunk using the same parameters it sent in its original INIT chunk (including its Initiate Tag, unchanged), provided that no new address has been added to the forming association. If the INIT chunk indicates that a new address has been added to the association, then the entire INIT chunk MUST be discarded, and the state of the existing association SHOULD NOT be changed. An ABORT chunk SHOULD be sent in a response that MAY include the \"Restart of an Association with New Addresses\" error cause. The error SHOULD list the addresses that were added to the restarting association.",
      "ja": "クッキーエコー状態でのinitチャンクを受信すると、エンドポイントは、新しいアドレスが追加されていない場合、元のINITチャンク（開始タグを含む）で送信したのと同じパラメーターを使用してINIT ACKチャンクで応答する必要があります。形成協会へ。init chunkが新しいアドレスが協会に追加されたことを示した場合、initチャンク全体を破棄する必要があり、既存の関連付けの状態を変更してはなりません。中止チャンクは、「新しいアドレスとの関連性の再起動」エラー原因を含む可能性のある応答で送信する必要があります。エラーには、再起動協会に追加されたアドレスをリストする必要があります。"
    },
    {
      "indent": 3,
      "text": "When responding in either state (COOKIE-WAIT or COOKIE-ECHOED) with an INIT ACK chunk, the original parameters are combined with those from the newly received INIT chunk. The endpoint MUST also generate a State Cookie with the INIT ACK chunk. The endpoint uses the parameters sent in its INIT chunk to calculate the State Cookie.",
      "ja": "INIT ACKチャンクで状態（Cookie-WaitまたはCookieエコー）のいずれかで応答する場合、元のパラメーターは、新しく受信されたinitチャンクのパラメーターと組み合わされます。エンドポイントは、init ackチャンクでステートクッキーを生成する必要があります。エンドポイントは、initチャンクで送信されたパラメーターを使用して、状態Cookieを計算します。"
    },
    {
      "indent": 3,
      "text": "After that, the endpoint MUST NOT change its state, the T1-init timer MUST be left running, and the corresponding TCB MUST NOT be destroyed. The normal procedures for handling State Cookies when a TCB exists will resolve the duplicate INIT chunks to a single association.",
      "ja": "その後、エンドポイントは状態を変更してはなりません。T1-ISITタイマーを実行したままにしておく必要があり、対応するTCBを破壊してはなりません。TCBが存在する場合の状態Cookieを処理するための通常の手順は、重複したinitチャンクを単一の関連付けに解決します。"
    },
    {
      "indent": 3,
      "text": "For an endpoint that is in the COOKIE-ECHOED state, it MUST populate its Tie-Tags within both the association TCB and inside the State Cookie (see Section 5.2.2 for a description of the Tie-Tags).",
      "ja": "Cookieでエコーされた状態にあるエンドポイントの場合、Association TCBとState Cookie内のタイタグを入力する必要があります（タイタグの説明については、セクション5.2.2を参照）。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Unexpected INIT Chunk in States Other than CLOSED, COOKIE-ECHOED, COOKIE-WAIT, and SHUTDOWN-ACK-SENT",
      "ja": "5.2.2. クローズド、クッキーエコー、クッキーウェイト、シャットダウン済みのセント以外の状態で予期しない初期塊"
    },
    {
      "indent": 3,
      "text": "Unless otherwise stated, upon receipt of an unexpected INIT chunk for this association, the endpoint MUST generate an INIT ACK chunk with a State Cookie. Before responding, the endpoint MUST check to see if the unexpected INIT chunk adds new addresses to the association. If new addresses are added to the association, the endpoint MUST respond with an ABORT chunk, copying the 'Initiate Tag' of the unexpected INIT chunk into the 'Verification Tag' of the outbound packet carrying the ABORT chunk. In the ABORT chunk, the error cause MAY be set to \"Restart of an Association with New Addresses\". The error SHOULD list the addresses that were added to the restarting association. If no new addresses are added, when responding to the INIT chunk in the outbound INIT ACK chunk, the endpoint MUST copy its current Tie-Tags to a reserved place within the State Cookie and the association's TCB. We refer to these locations inside the cookie as the Peer's-Tie-Tag and the Local-Tie-Tag. We will refer to the copy within an association's TCB as the Local Tag and Peer's Tag. The outbound SCTP packet containing this INIT ACK chunk MUST carry a Verification Tag value equal to the Initiate Tag found in the unexpected INIT chunk. And the INIT ACK chunk MUST contain a new Initiate Tag (randomly generated; see Section 5.3.1). Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK chunk and cookie.",
      "ja": "特に明記しない限り、この関連性の予期せぬinitチャンクを受け取ったとき、エンドポイントは州のクッキーでinit ackチャンクを生成する必要があります。応答する前に、エンドポイントは、予期しないinitチャンクが協会に新しいアドレスを追加するかどうかを確認する必要があります。新しいアドレスが協会に追加された場合、エンドポイントは中止チャンクで応答し、予期しないinitチャンクの「開始タグ」をコピーする必要があります。中止チャンクでは、エラー原因を「新しいアドレスとの関連性の再起動」に設定することができます。エラーには、再起動協会に追加されたアドレスをリストする必要があります。新しいアドレスが追加されていない場合、アウトバウンドINIT ACKチャンクのINITチャンクに応答する場合、エンドポイントは現在のタイタグを州のCookieおよびAssociationのTCB内の予約場所にコピーする必要があります。クッキー内のこれらの場所を、ピアのタイタグおよびローカルタイタグと呼びます。協会のTCB内のコピーをローカルタグとピアのタグと呼びます。このinit ackチャンクを含むアウトバウンドSCTPパケットは、予期しないinitチャンクで見つかった開始タグに等しい検証タグ値を運ぶ必要があります。そして、init ackチャンクには、新しいinitiateタグが含まれている必要があります（ランダムに生成されます。セクション5.3.1を参照）。エンドポイントのその他のパラメーターは、協会の既存のパラメーター（例えば、アウトバウンドストリームの数）からINIT ACKチャンクとCookieにコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "After sending the INIT ACK or ABORT chunk, the endpoint MUST take no further actions, i.e., the existing association, including its current state, and the corresponding TCB MUST NOT be changed.",
      "ja": "init ackまたはabortチャンクを送信した後、エンドポイントはそれ以上のアクション、つまりその現在の状態を含む既存の関連付けを行わなければならず、対応するTCBを変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "Only when a TCB exists and the association is not in a COOKIE-WAIT or SHUTDOWN-ACK-SENT state are the Tie-Tags populated with a random value other than 0. For a normal association INIT chunk (i.e., the endpoint is in the CLOSED state), the Tie-Tags MUST be set to 0 (indicating that no previous TCB existed).",
      "ja": "TCBが存在し、協会がCookie-Waitまたはshutdown-ack-Sent状態にない場合にのみ、0以外のランダムな値が入力されたタイタグがあります。閉じた状態）、タイタグは0に設定する必要があります（以前のTCBが存在しなかったことを示します）。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Unexpected INIT ACK Chunk",
      "section_title": true,
      "ja": "5.2.3. 予期しないinit ackチャンク"
    },
    {
      "indent": 3,
      "text": "If an INIT ACK chunk is received by an endpoint in any state other than the COOKIE-WAIT or CLOSED state, the endpoint SHOULD discard the INIT ACK chunk. An unexpected INIT ACK chunk usually indicates the processing of an old or duplicated INIT chunk.",
      "ja": "Cookie-Waitまたは閉じた状態以外の任意の状態のEndpointによってinit ackチャンクが受信される場合、エンドポイントはinit ackチャンクを破棄する必要があります。予期しないinit ackチャンクは、通常、古いまたは重複したinitチャンクの処理を示します。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Handle a COOKIE ECHO Chunk When a TCB Exists",
      "section_title": true,
      "ja": "5.2.4. TCBが存在するときにクッキーエコーチャンクを処理します"
    },
    {
      "indent": 3,
      "text": "When a COOKIE ECHO chunk is received by an endpoint in any state for an existing association (i.e., not in the CLOSED state), the following rules are applied:",
      "ja": "Cookie Echo Chunkが既存の関連付け（つまり、閉じた状態ではなく）の任意の状態のエンドポイントによって受信されると、次のルールが適用されます。"
    },
    {
      "indent": 3,
      "text": "1) Compute a MAC as described in step 1 of Section 5.1.5.",
      "ja": "1) セクション5.1.5のステップ1で説明されているように、Macを計算します。"
    },
    {
      "indent": 3,
      "text": "2) Authenticate the State Cookie as described in step 2 of Section 5.1.5 (this is case C or D above).",
      "ja": "2) セクション5.1.5のステップ2で説明されているように、状態Cookieを認証します（これは上記のケースCまたはDです）。"
    },
    {
      "indent": 3,
      "text": "3) Compare the timestamp in the State Cookie to the current time. If the State Cookie is older than the lifespan carried in the State Cookie and the Verification Tags contained in the State Cookie do not match the current association's Verification Tags, the packet, including the COOKIE ECHO chunk and any DATA chunks, SHOULD be discarded. The endpoint also MUST transmit an ERROR chunk with a \"Stale Cookie\" error cause to the peer endpoint (this is case C or D in Section 5.2).",
      "ja": "3) 州のクッキーのタイムスタンプを現在の時刻と比較してください。状態CookieがState Cookieで運ばれた寿命よりも古く、State Cookieに含まれる検証タグが現在の協会の検証タグと一致しない場合、Cookie Echo Chunkやデータチャンクを含むパケットを廃棄する必要があります。また、エンドポイントは、「古いクッキー」エラー原因でエラーチャンクをピアエンドポイントに送信する必要があります（これはセクション5.2のケースCまたはDです）。"
    },
    {
      "indent": 7,
      "text": "If both Verification Tags in the State Cookie match the Verification Tags of the current association, consider the State Cookie valid (this is case E in Section 5.2), even if the lifespan is exceeded.",
      "ja": "状態Cookieの両方の検証タグが現在の協会の検証タグと一致する場合、寿命を超えていても、状態Cookieが有効（これはセクション5.2のケースE）を検討してください。"
    },
    {
      "indent": 3,
      "text": "4) If the State Cookie proves to be valid, unpack the TCB into a temporary TCB.",
      "ja": "4) 状態Cookieが有効であることが証明されている場合は、TCBを一時的なTCBに解除します。"
    },
    {
      "indent": 3,
      "text": "5) Refer to Table 12 to determine the correct action to be taken.",
      "ja": "5) 表12を参照して、取られる正しいアクションを決定します。"
    },
    {
      "indent": 3,
      "text": "+===========+============+===============+================+========+\n| Local Tag | Peer's Tag | Local-Tie-Tag | Peer's-Tie-Tag | Action |\n+===========+============+===============+================+========+\n|     X     |     X      |       M       |       M        |  (A)   |\n+-----------+------------+---------------+----------------+--------+\n|     M     |     X      |       A       |       A        |  (B)   |\n+-----------+------------+---------------+----------------+--------+\n|     M     |     0      |       A       |       A        |  (B)   |\n+-----------+------------+---------------+----------------+--------+\n|     X     |     M      |       0       |       0        |  (C)   |\n+-----------+------------+---------------+----------------+--------+\n|     M     |     M      |       A       |       A        |  (D)   |\n+-----------+------------+---------------+----------------+--------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Table 12: Handling of a COOKIE ECHO Chunk When a TCB Exists",
      "ja": "表12：TCBが存在するときのクッキーエコーチャンクの取り扱い"
    },
    {
      "indent": 3,
      "text": "Legend:",
      "ja": "伝説："
    },
    {
      "indent": 3,
      "text": "X - Tag does not match the existing TCB. M - Tag matches the existing TCB. 0 - Tag unknown (Peer's Tag not known yet / No Tie-Tag in cookie). A - All cases, i.e., M, X, or 0.",
      "ja": "X -TAGは既存のTCBと一致しません。M-タグは既存のTCBと一致します。0-タグ不明（ピアのタグはまだ知られていない /クッキーにタイタグなし）。A-すべての場合、つまりm、x、または0。"
    },
    {
      "indent": 3,
      "text": "For any case not shown in Table 12, the cookie SHOULD be silently discarded.",
      "ja": "表12に示されていない場合は、Cookieを静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Action:",
      "ja": "アクション："
    },
    {
      "indent": 3,
      "text": "A) In this case, the peer might have restarted. When the endpoint recognizes this potential 'restart', the existing session is treated the same as if it received an ABORT chunk followed by a new COOKIE ECHO chunk with the following exceptions:",
      "ja": "a）この場合、ピアが再起動した可能性があります。エンドポイントがこの潜在的な「再起動」を認識すると、既存のセッションは、以下の例外を除いて、中止チャンクに続いて新しいCookieエコーチャンクが続いた場合と同じように扱われます。"
    },
    {
      "indent": 7,
      "text": "* Any SCTP DATA chunks MAY be retained (this is an implementation-specific option).",
      "ja": "* SCTPデータチャンクが保持される場合があります（これは実装固有のオプションです）。"
    },
    {
      "indent": 7,
      "text": "* A RESTART notification SHOULD be sent to the ULP instead of a COMMUNICATION LOST notification.",
      "ja": "* 通信通知の代わりに、再起動通知をULPに送信する必要があります。"
    },
    {
      "indent": 7,
      "text": "All the congestion control parameters (e.g., cwnd, ssthresh) related to this peer MUST be reset to their initial values (see Section 6.2.1).",
      "ja": "このピアに関連するすべての混雑制御パラメーター（例：CWND、SSTHRESH）は、初期値にリセットする必要があります（セクション6.2.1を参照）。"
    },
    {
      "indent": 7,
      "text": "After this, the endpoint enters the ESTABLISHED state.",
      "ja": "この後、エンドポイントは確立された状態に入ります。"
    },
    {
      "indent": 7,
      "text": "If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes that the peer has restarted (Action A), it MUST NOT set up a new association but instead resend the SHUTDOWN ACK chunk and send an ERROR chunk with a \"Cookie Received While Shutting Down\" error cause to its peer.",
      "ja": "エンドポイントがShutdown-ack-Sent状態にあり、ピアが再起動したことを認識している場合（アクションA）、新しい関連付けを設定してはなりません。「エラーの原因」をピアにシャットダウンします。"
    },
    {
      "indent": 3,
      "text": "B) In this case, both sides might be attempting to start an association at about the same time, but the peer endpoint sent its INIT chunk after responding to the local endpoint's INIT chunk. Thus, it might have picked a new Verification Tag, not being aware of the previous tag it had sent this endpoint. The endpoint SHOULD stay in or enter the ESTABLISHED state, but it MUST update its peer's Verification Tag from the State Cookie, stop any T1-init or T1-cookie timers that might be running, and send a COOKIE ACK chunk.",
      "ja": "b）この場合、双方はほぼ同時に関連性を開始しようとしているかもしれませんが、ピアエンドポイントはローカルエンドポイントのinitチャンクに応答した後、イニシ塊を送信しました。したがって、このエンドポイントを送信した以前のタグを認識せずに、新しい検証タグを選択した可能性があります。エンドポイントは確立された状態にとどまるか、入力する必要がありますが、州のCookieからピアの検証タグを更新し、実行中のT1-InitまたはT1-Cookieタイマーを停止し、Cookie ACK Chunkを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "C) In this case, the local endpoint's cookie has arrived late. Before it arrived, the local endpoint sent an INIT chunk and received an INIT ACK chunk and finally sent a COOKIE ECHO chunk with the peer's same tag but a new tag of its own. The cookie SHOULD be silently discarded. The endpoint SHOULD NOT change states and SHOULD leave any timers running.",
      "ja": "c）この場合、ローカルエンドポイントのCookieが遅れて到着しました。到着する前に、ローカルエンドポイントはINITチャンクを送信し、INIT ACKチャンクを受け取り、最終的にピアの同じタグでCookie Echo Chunkを送信しましたが、それ自体の新しいタグを送信しました。Cookieは静かに廃棄する必要があります。エンドポイントは状態を変更してはならず、タイマーを実行したままにしておく必要があります。"
    },
    {
      "indent": 3,
      "text": "D) When both local and remote tags match, the endpoint SHOULD enter the ESTABLISHED state if it is in the COOKIE-ECHOED state. It SHOULD stop any T1-cookie timer that is running and send a COOKIE ACK chunk.",
      "ja": "d）ローカルタグとリモートタグの両方が一致する場合、エンドポイントがCookieエコー状態にある場合、エンドポイントは確立された状態に入る必要があります。実行中のT1-Cookieタイマーを停止し、Cookie ACKチャンクを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The \"peer's Verification Tag\" is the tag received in the Initiate Tag field of the INIT or INIT ACK chunk.",
      "ja": "注：「ピアの検証タグ」は、initまたはinit ackチャンクの開始タグフィールドで受信したタグです。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1. An Example of an Association Restart",
      "section_title": true,
      "ja": "5.2.4.1. 協会の再起動の例"
    },
    {
      "indent": 3,
      "text": "In the following example, \"A\" initiates the association after a restart has occurred. Endpoint \"Z\" had no knowledge of the restart until the exchange (i.e., Heartbeats had not yet detected the failure of \"A\") (assuming no bundling or fragmentation occurs):",
      "ja": "次の例では、再起動が発生した後、「A」が協会を開始します。Endpoint \"z\"は、交換まで再起動の知識がありませんでした（つまり、Heartbeatsはまだ「A」の障害を検出していませんでした）（バンドリングや断片化が発生しないと仮定）："
    },
    {
      "indent": 3,
      "text": "Endpoint A                                          Endpoint Z\n<-------------- Association is established---------------------->\nTag=Tag_A                                             Tag=Tag_Z\n<--------------------------------------------------------------->\n{A crashes and restarts}\n{app sets up an association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A'\n      & other info]  --------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-WAIT state)      \\---> (find an existing TCB,\n                                      populate TieTags if needed,\n                                      compose Cookie_Z with Tie-Tags\n                                      and other info)\n                                /--- INIT ACK [Veri Tag=Tag_A',\n                               /               I-Tag=Tag_Z',\n(Cancel T1-init timer) <------/                Cookie_Z]\n                                     (leave original TCB in place)\nCOOKIE ECHO [Veri=Tag_Z',\n             Cookie_Z]-------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (Find existing association,\n                                      Tie-Tags in Cookie_Z match\n                                      Tie-Tags in TCB,\n                                      Tags do not match, i.e.,\n                                      case X X M M above,\n                                      Announce Restart to ULP\n                                      and reset association).\n                               /---- COOKIE ACK\n(Cancel T1-init timer, <------/\n Enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=Initial TSN_A\n    Strm=0,Seq=0 & user data]--\\\n(Start T3-rtx timer)            \\\n                                 \\->\n                              /--- SACK [TSN Ack=init TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 5: A Restart Example",
      "ja": "図5：再起動例"
    },
    {
      "indent": 0,
      "text": "5.2.5. Handle Duplicate COOKIE ACK Chunk",
      "section_title": true,
      "ja": "5.2.5. 重複したCookie ackチャンクを処理します"
    },
    {
      "indent": 3,
      "text": "At any state other than COOKIE-ECHOED, an endpoint SHOULD silently discard a received COOKIE ACK chunk.",
      "ja": "Cookieエコー以外のどの状態でも、エンドポイントは、受け取ったCookie ACKチャンクを静かに廃棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.6. Handle Stale Cookie Error",
      "section_title": true,
      "ja": "5.2.6. 古いクッキーエラーを処理します"
    },
    {
      "indent": 3,
      "text": "Receipt of an ERROR chunk with a \"Stale Cookie\" error cause indicates one of a number of possible events:",
      "ja": "「古いクッキー」エラー原因でエラーチャンクを受信して、可能なイベントの1つを示します。"
    },
    {
      "indent": 3,
      "text": "A) The association failed to completely set up before the State Cookie issued by the sender was processed.",
      "ja": "a）送信者が発行した州のCookieが処理される前に、協会は完全にセットアップできませんでした。"
    },
    {
      "indent": 3,
      "text": "B) An old State Cookie was processed after setup completed.",
      "ja": "b）セットアップが完了した後、古い州のクッキーが処理されました。"
    },
    {
      "indent": 3,
      "text": "C) An old State Cookie is received from someone that the receiver is not interested in having an association with and the ABORT chunk was lost.",
      "ja": "c）古い州のクッキーは、レシーバーが関連性を持つことに興味がなく、中止チャンクが失われた人から受け取られます。"
    },
    {
      "indent": 3,
      "text": "When processing an ERROR chunk with a \"Stale Cookie\" error cause, an endpoint SHOULD first examine if an association is in the process of being set up, i.e., the association is in the COOKIE-ECHOED state. In all cases, if the association is not in the COOKIE-ECHOED state, the ERROR chunk SHOULD be silently discarded.",
      "ja": "「古いCookie」エラー原因でエラーチャンクを処理する場合、エンドポイントは、関連性がセットアップのプロセスにあるかどうか、つまり、関連性がCookieでエコーされた状態にあるかどうかを最初に調べる必要があります。すべての場合において、協会がCookieでエコーされた状態にない場合、エラーチャンクは静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the association is in the COOKIE-ECHOED state, the endpoint MAY elect one of the following three alternatives.",
      "ja": "協会がCookieでエコーされた状態にある場合、エンドポイントは次の3つの選択肢のいずれかを選択する可能性があります。"
    },
    {
      "indent": 3,
      "text": "1) Send a new INIT chunk to the endpoint to generate a new State Cookie and reattempt the setup procedure.",
      "ja": "1) 新しいステートクッキーを生成するために新しいINITチャンクをエンドポイントに送信し、セットアップ手順を再確認します。"
    },
    {
      "indent": 3,
      "text": "2) Discard the TCB and report to the upper layer the inability to set up the association.",
      "ja": "2) TCBを廃棄し、関連性をセットアップできないことを上層に報告します。"
    },
    {
      "indent": 3,
      "text": "3) Send a new INIT chunk to the endpoint, adding a Cookie Preservative parameter requesting an extension to the life time of the State Cookie. When calculating the time extension, an implementation SHOULD use the RTT information measured based on the previous COOKIE ECHO/ERROR chunk exchange and SHOULD add no more than 1 second beyond the measured RTT, due to long State Cookie life times making the endpoint more subject to a replay attack.",
      "ja": "3) エンドポイントに新しいinitチャンクを送信し、州のクッキーの寿命の延長を要求するCookie Perservativeパラメーターを追加します。時間延長を計算する場合、実装は、以前のCookieエコー/エラーチャンク交換に基づいて測定されたRTT情報を使用する必要があります。リプレイ攻撃。"
    },
    {
      "indent": 0,
      "text": "5.3. Other Initialization Issues",
      "section_title": true,
      "ja": "5.3. その他の初期化の問題"
    },
    {
      "indent": 0,
      "text": "5.3.1. Selection of Tag Value",
      "section_title": true,
      "ja": "5.3.1. タグ値の選択"
    },
    {
      "indent": 3,
      "text": "Initiate Tag values SHOULD be selected from the range of 1 to 2^32 - 1. It is very important that the Initiate Tag value be randomized to help protect against off-path attacks. The methods described in [RFC4086] can be used for the Initiate Tag randomization. Careful selection of Initiate Tags is also necessary to prevent old duplicate packets from previous associations being mistakenly processed as belonging to the current association.",
      "ja": "タグ値の開始は、1〜2^32-1の範囲から選択する必要があります。1回のタグ値をランダム化して、パス攻撃から保護することが非常に重要です。[RFC4086]で説明されている方法は、開始タグのランダム化に使用できます。開始タグの慎重な選択は、現在の関連付けに属すると誤って処理される以前の関連付けから古い複製パケットを防ぐためにも必要です。"
    },
    {
      "indent": 3,
      "text": "Moreover, the Verification Tag value used by either endpoint in a given association MUST NOT change during the life time of an association. A new Verification Tag value MUST be used each time the endpoint tears down and then reestablishes an association to the same peer.",
      "ja": "さらに、特定の関連付けのいずれかのエンドポイントで使用される検証タグ値は、協会の生涯に変化してはなりません。エンドポイントが引き裂き、同じピアへの関連付けを再確立するたびに、新しい検証タグ値を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.4. Path Verification",
      "section_title": true,
      "ja": "5.4. パス検証"
    },
    {
      "indent": 3,
      "text": "During association establishment, the two peers exchange a list of addresses. In the predominant case, these lists accurately represent the addresses owned by each peer. However, a misbehaving peer might supply addresses that it does not own. To prevent this, the following rules are applied to all addresses of the new association:",
      "ja": "協会の設立中、2人のピアは住所のリストを交換します。主要な場合、これらのリストは各ピアが所有するアドレスを正確に表します。ただし、誤動作のピアは、所有していない住所を提供する可能性があります。これを防ぐために、次のルールが新しい協会のすべてのアドレスに適用されます。"
    },
    {
      "indent": 3,
      "text": "1) Any addresses passed to the sender of the INIT chunk by its upper layer in the request to initialize an association are automatically considered to be CONFIRMED.",
      "ja": "1) Associationを初期化するリクエストで上層層によってINITチャンクの送信者に渡されたアドレスは、自動的に確認されると見なされます。"
    },
    {
      "indent": 3,
      "text": "2) For the receiver of the COOKIE ECHO chunk, the only CONFIRMED address is the address to which the packet containing the INIT ACK chunk was sent.",
      "ja": "2) Cookie Echo Chunkの受信機の場合、確認された唯一のアドレスは、init ackチャンクを含むパケットが送信されたアドレスです。"
    },
    {
      "indent": 3,
      "text": "3) All other addresses not covered by rules 1 and 2 are considered UNCONFIRMED and are subject to probing for verification.",
      "ja": "3) 規則1および2でカバーされていない他のすべてのアドレスは、未確認と見なされ、検証のために調査されます。"
    },
    {
      "indent": 3,
      "text": "To probe an address for verification, an endpoint will send HEARTBEAT chunks including a 64-bit random nonce and a path indicator (to identify the address that the HEARTBEAT chunk is sent to) within the Heartbeat Info parameter.",
      "ja": "検証のためにアドレスを調べるために、エンドポイントは、ハートビート情報パラメーター内で、64ビットのランダムなノンセとパスインジケータ（ハートビートチャンクが送信されるアドレスを識別する）を含むハートビートチャンクを送信します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the HEARTBEAT ACK chunk, a verification is made that the nonce included in the Heartbeat Info parameter is the one sent to the address indicated inside the Heartbeat Info parameter. When this match occurs, the address that the original HEARTBEAT was sent to is now considered CONFIRMED and available for normal data transfer.",
      "ja": "ハートビートACKチャンクを受け取ると、ハートビート情報パラメーターに含まれるノンセが、ハートビート情報パラメーター内に示されているアドレスに送信されたものであることが確認されます。この一致が発生すると、元のハートビートが送信されたアドレスが確認されたと見なされ、通常のデータ転送に利用可能になりました。"
    },
    {
      "indent": 3,
      "text": "These probing procedures are started when an association moves to the ESTABLISHED state and are ended when all paths are confirmed.",
      "ja": "これらの調査手順は、関連が確立された状態に移動すると開始され、すべてのパスが確認されたときに終了します。"
    },
    {
      "indent": 3,
      "text": "In each RTO, a probe MAY be sent on an active UNCONFIRMED path in an attempt to move it to the CONFIRMED state. If during this probing the path becomes inactive, this rate is lowered to the normal HEARTBEAT rate. At the expiration of the RTO timer, the error counter of any path that was probed but not CONFIRMED is incremented by one and subjected to path failure detection, as defined in Section 8.2. When probing UNCONFIRMED addresses, however, the association overall error count is not incremented.",
      "ja": "各RTOでは、確認された状態に移動しようとして、アクティブな未確認のパスにプローブを送信できます。この調査中にパスが非アクティブになると、このレートは通常のハートビートレートに低下します。RTOタイマーの有効期限が切れると、セクション8.2で定義されているように、調査されたが確認されていないパスのエラーカウンターが1つによって増加し、パス障害検出を受けます。ただし、未確認のアドレスを調査する場合、関連性の全体的なエラー数は増加しません。"
    },
    {
      "indent": 3,
      "text": "The number of packets containing HEARTBEAT chunks sent at each RTO SHOULD be limited by the 'HB.Max.Burst' parameter. It is an implementation decision as to how to distribute packets containing HEARTBEAT chunks to the peer's addresses for path verification.",
      "ja": "各RTOで送信されるハートビートチャンクを含むパケットの数は、「hb.max.burst」パラメーターによって制限される必要があります。これは、パス検証のためにピアのアドレスにハートビートのチャンクを含むパケットを配布する方法に関する実装決定です。"
    },
    {
      "indent": 3,
      "text": "Whenever a path is confirmed, an indication MAY be given to the upper layer.",
      "ja": "パスが確認されるたびに、上層に示される場合があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT send any chunks to an UNCONFIRMED address, with the following exceptions:",
      "ja": "エンドポイントは、次の例外を除き、未確認のアドレスにチャンクを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "* A HEARTBEAT chunk including a nonce MAY be sent to an UNCONFIRMED address.",
      "ja": "* ノンセを含む心拍のチャンクは、未確認のアドレスに送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "* A HEARTBEAT ACK chunk MAY be sent to an UNCONFIRMED address.",
      "ja": "* ハートビートACKチャンクは、未確認のアドレスに送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "* A COOKIE ACK chunk MAY be sent to an UNCONFIRMED address, but it MUST be bundled with a HEARTBEAT chunk including a nonce. An implementation that does not support bundling MUST NOT send a COOKIE ACK chunk to an UNCONFIRMED address.",
      "ja": "* Cookie ACKチャンクは、未確認のアドレスに送信される場合がありますが、NonCeを含むハートビートチャンクにバンドルする必要があります。バンドルをサポートしない実装は、未確認のアドレスにCookie ACKチャンクを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "* A COOKIE ECHO chunk MAY be sent to an UNCONFIRMED address, but it MUST be bundled with a HEARTBEAT chunk including a nonce, and the size of the SCTP packet MUST NOT exceed the PMTU. If the implementation does not support bundling or if the bundled COOKIE ECHO chunk plus HEARTBEAT chunk (including nonce) would result in an SCTP packet larger than the PMTU, then the implementation MUST NOT send a COOKIE ECHO chunk to an UNCONFIRMED address.",
      "ja": "* Cookie Echo Chunkは未確認のアドレスに送信される場合がありますが、非CEを含むハートビートチャンクにバンドルする必要があり、SCTPパケットのサイズはPMTUを超えてはなりません。実装がバンドルをサポートしていない場合、またはバンドルされたCookie Echo Chunk Plus Heartbeat Chunk（NonCeを含む）がPMTUよりも大きいSCTPパケットになった場合、実装はCookie Echo Chunkを未確認のアドレスに送信してはなりません。"
    },
    {
      "indent": 0,
      "text": "6. User Data Transfer",
      "section_title": true,
      "ja": "6. ユーザーデータ転送"
    },
    {
      "indent": 3,
      "text": "Data transmission MUST only happen in the ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-RECEIVED states. The only exception to this is that DATA chunks are allowed to be bundled with an outbound COOKIE ECHO chunk when in the COOKIE-WAIT state.",
      "ja": "データ送信は、確立された、シャットダウンペンディング、およびシャットダウンが推定される状態でのみ発生する必要があります。これの唯一の例外は、Cookie-Wait状態の場合、データチャンクをアウトバウンドクッキーエコーチャンクにバンドルできることです。"
    },
    {
      "indent": 3,
      "text": "DATA chunks MUST only be received according to the rules below in ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-SENT states. A DATA chunk received in CLOSED is out of the blue and SHOULD be handled per Section 8.4. A DATA chunk received in any other state SHOULD be discarded.",
      "ja": "データチャンクは、確立された、シャットダウンペンディング、およびシャットダウン状態の以下のルールに従ってのみ受け取る必要があります。閉じたデータチャンクは青から外れており、セクション8.4に従って処理する必要があります。他の州で受け取ったデータチャンクは廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "A SACK chunk MUST be processed in ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-RECEIVED states. An incoming SACK chunk MAY be processed in COOKIE-ECHOED. A SACK chunk in the CLOSED state is out of the blue and SHOULD be processed according to the rules in Section 8.4. A SACK chunk received in any other state SHOULD be discarded.",
      "ja": "サックチャンクは、確立された、シャットダウンペンディング、およびシャットダウン状態で処理する必要があります。入ってくる袋のチャンクは、Cookieエコーで処理される場合があります。閉じた状態の袋の塊は青から外れており、セクション8.4のルールに従って処理する必要があります。他の州で受け取った袋の塊を捨てる必要があります。"
    },
    {
      "indent": 3,
      "text": "For transmission efficiency, SCTP defines mechanisms for bundling of small user messages and fragmentation of large user messages. The following diagram depicts the flow of user messages through SCTP.",
      "ja": "送信効率のために、SCTPは、小さなユーザーメッセージのバンドルと大規模なユーザーメッセージの断片化のメカニズムを定義します。次の図は、SCTPを介したユーザーメッセージのフローを示しています。"
    },
    {
      "indent": 3,
      "text": "In this section, the term \"data sender\" refers to the endpoint that transmits a DATA chunk, and the term \"data receiver\" refers to the endpoint that receives a DATA chunk. A data receiver will transmit SACK chunks.",
      "ja": "このセクションでは、「データ送信者」という用語は、データチャンクを送信するエンドポイントを指し、「データレシーバー」という用語は、データチャンクを受信するエンドポイントを指します。データレシーバーは、サックチャンクを送信します。"
    },
    {
      "indent": 7,
      "text": "           +-------------------------+\n           |      User Messages      |\n           +-------------------------+\n SCTP user        ^  |\n==================|==|=======================================\n                  |  v (1)\n       +------------------+    +---------------------+\n       | SCTP DATA Chunks |    | SCTP Control Chunks |\n       +------------------+    +---------------------+\n                  ^  |             ^  |\n                  |  v (2)         |  v (2)\n               +--------------------------+\n               |       SCTP packets       |\n               +--------------------------+\n SCTP                      ^  |\n===========================|==|===========================\n                           |  v\n       Connectionless Packet Transfer Service (e.g., IP)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 6: Illustration of User Data Transfer",
      "ja": "図6：ユーザーデータ転送の図"
    },
    {
      "indent": 3,
      "text": "The following applies:",
      "ja": "以下が適用されます："
    },
    {
      "indent": 3,
      "text": "1) When converting user messages into DATA chunks, an endpoint MUST fragment large user messages into multiple DATA chunks. The size of each DATA chunk SHOULD be smaller than or equal to the Association Maximum DATA Chunk Size (AMDCS). The data receiver will normally reassemble the fragmented message from DATA chunks before delivery to the user (see Section 6.9 for details).",
      "ja": "1) ユーザーメッセージをデータチャンクに変換する場合、エンドポイントは大きなユーザーメッセージを複数のデータチャンクに分割する必要があります。各データチャンクのサイズは、アソシエーション最大データチャンクサイズ（AMDC）以下である必要があります。データレシーバーは通常、ユーザーに配信する前に、データチャンクからの断片化されたメッセージを再組み立てします（詳細については、セクション6.9を参照）。"
    },
    {
      "indent": 3,
      "text": "2) Multiple DATA and control chunks MAY be bundled by the sender into a single SCTP packet for transmission, as long as the final size of the SCTP packet does not exceed the current PMTU. The receiver will unbundle the packet back into the original chunks. Control chunks MUST come before DATA chunks in the packet.",
      "ja": "2) SCTPパケットの最終サイズが現在のPMTUを超えない限り、複数のデータと制御チャンクを送信者によって単一のSCTPパケットにバンドルすることができます。受信機は、パケットを元のチャンクに戻します。パケット内のデータチャンクの前に、コントロールチャンクが来なければなりません。"
    },
    {
      "indent": 3,
      "text": "The fragmentation and bundling mechanisms, as detailed in Sections 6.9 and 6.10, are OPTIONAL to implement by the data sender, but they MUST be implemented by the data receiver, i.e., an endpoint MUST properly receive and process bundled or fragmented data.",
      "ja": "セクション6.9および6.10で詳述されているように、断片化とバンドルメカニズムはデータ送信者によって実装するためにオプションですが、データ受信機によって実装する必要があります。つまり、エンドポイントは適切にバンドルまたは断片化されたデータを受信および処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Transmission of DATA Chunks",
      "section_title": true,
      "ja": "6.1. データチャンクの送信"
    },
    {
      "indent": 3,
      "text": "This section specifies the rules for sending DATA chunks. In particular, it defines zero window probing, which is required to avoid the indefinite stalling of an association in case of a loss of packets containing SACK chunks performing window updates.",
      "ja": "このセクションでは、データチャンクを送信するためのルールを指定します。特に、ウィンドウプロービングはゼロを定義します。これは、ウィンドウの更新を実行するサックチャンクを含むパケットが失われた場合に、関連性の無期限の失速を回避するために必要です。"
    },
    {
      "indent": 3,
      "text": "This document is specified as if there is a single retransmission timer per destination transport address, but implementations MAY have a retransmission timer for each DATA chunk.",
      "ja": "このドキュメントは、宛先輸送アドレスごとに単一の再送信タイマーがあるかのように指定されていますが、実装には各データチャンクの再送信タイマーがある場合があります。"
    },
    {
      "indent": 3,
      "text": "The following general rules MUST be applied by the data sender for transmission and/or retransmission of outbound DATA chunks:",
      "ja": "以下の一般的なルールは、送信および/またはアウトバウンドデータチャンクの再送信のためにデータ送信者によって適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A) At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e., rwnd is smaller than the size of the next DATA chunk; see Section 6.2.1), except for zero window probes.",
      "ja": "a）特定の時間に、ピアのRWNDがピアにバッファスペースがないことを示している場合、データ送信者は任意の宛先輸送アドレスに新しいデータを送信してはなりません（つまり、RWNDは次のデータチャンクのサイズよりも小さくなります。セクション6.2を参照してください。.1）、ゼロウィンドウプローブを除く。"
    },
    {
      "indent": 7,
      "text": "A zero window probe is a DATA chunk sent when the receiver has no buffer space. This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK chunks having been lost in transit from the data receiver to the data sender. A zero window probe MUST only be sent when the cwnd allows (see rule B below). A zero window probe SHOULD only be sent when all outstanding DATA chunks have been cumulatively acknowledged and no DATA chunks are in flight. Senders MUST support zero window probing.",
      "ja": "ゼロウィンドウプローブは、レシーバーにバッファスペースがない場合に送信されるデータチャンクです。このルールにより、送信者は、データ受信者からデータ送信者への輸送中に袋のチャンクが失われたために送信者が逃したRWNDの変更を調査できます。ゼロウィンドウプローブは、CWNDが許可する場合にのみ送信する必要があります（以下のルールBを参照）。ゼロウィンドウプローブは、すべての未解決のデータチャンクが累積的に認識され、データチャンクが飛行中でない場合にのみ送信する必要があります。送信者は、ゼロウィンドウプロービングをサポートする必要があります。"
    },
    {
      "indent": 7,
      "text": "If the sender continues to receive SACK chunks from the peer while doing zero window probing, the unacknowledged window probes SHOULD NOT increment the error counter for the association or any destination transport address. This is because the receiver could keep its window closed for an indefinite time. Section 6.2 describes the receiver behavior when it advertises a zero window. The sender SHOULD send the first zero window probe after 1 RTO when it detects that the receiver has closed its window and SHOULD increase the probe interval exponentially afterwards. Also note that the cwnd SHOULD be adjusted according to Section 7.2.1. Zero window probing does not affect the calculation of cwnd.",
      "ja": "送信者がゼロウィンドウプロービングを行っている間にピアから袋のチャンクを受け取り続けた場合、承認されていないウィンドウプローブは、関連性または宛先輸送アドレスのエラーカウンターをインクリメントしてはなりません。これは、レシーバーが無期限に窓を閉じたままにすることができるためです。セクション6.2では、ゼロウィンドウを宣伝するときの受信者の動作について説明します。送信者は、レシーバーがウィンドウを閉じており、その後プローブ間隔を指数関数的に増加させることを検出したときに、1 RTOの後に最初のゼロウィンドウプローブを送信する必要があります。また、CWNDはセクション7.2.1に従って調整する必要があることに注意してください。ゼロウィンドウプローブは、CWNDの計算に影響しません。"
    },
    {
      "indent": 7,
      "text": "The sender MUST also have an algorithm for sending new DATA chunks to avoid silly window syndrome (SWS) as described in [RFC1122]. The algorithm can be similar to the one described in Section 4.2.3.4 of [RFC1122].",
      "ja": "送信者は、[RFC1122]に記載されているように、愚かなウィンドウ症候群（SWS）を避けるために、新しいデータチャンクを送信するためのアルゴリズムも持っている必要があります。アルゴリズムは、[RFC1122]のセクション4.2.3.4で説明したものと類似できます。"
    },
    {
      "indent": 3,
      "text": "B) At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd + (PMDCS - 1) or more bytes of data outstanding to that transport address. If data is available, the sender SHOULD exceed cwnd by up to (PMDCS - 1) bytes on a new data transmission if the flightsize does not currently reach cwnd. The breach of cwnd MUST constitute one packet only.",
      "ja": "b）特定の時間に、送信者は、CWND（PMDCS -1）以上のデータをその輸送アドレスに掲載している場合、特定の輸送アドレスに新しいデータを送信してはなりません。データが利用可能な場合、送信者は、フライトサイズが現在CWNDに到達しない場合、新しいデータ送信の最大（PMDC -1）バイトまでCWNDを超える必要があります。CWNDの違反は、1つのパケットのみを構成する必要があります。"
    },
    {
      "indent": 3,
      "text": "C) When the time comes for the sender to transmit, before sending new DATA chunks, the sender MUST first transmit any DATA chunks that are marked for retransmission (limited by the current cwnd).",
      "ja": "c）新しいデータチャンクを送信する前に送信者が送信する時が来たとき、送信者は最初に再送信のためにマークされたデータチャンクを送信する必要があります（現在のCWNDによって制限されます）。"
    },
    {
      "indent": 3,
      "text": "D) When the time comes for the sender to transmit new DATA chunks, the protocol parameter 'Max.Burst' SHOULD be used to limit the number of packets sent. The limit MAY be applied by adjusting cwnd temporarily, as follows:",
      "ja": "d）送信者が新しいデータチャンクを送信する時が来たら、プロトコルパラメーター「Max.Burst」を使用して、送信されるパケットの数を制限する必要があります。次のように、CWNDを一時的に調整することで制限を適用できます。"
    },
    {
      "indent": 6,
      "text": "if ((flightsize + Max.Burst * PMDCS) < cwnd)\n    cwnd = flightsize + Max.Burst * PMDCS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Or, it MAY be applied by strictly limiting the number of packets emitted by the output routine. When calculating the number of packets to transmit, and particularly when using the formula above, cwnd SHOULD NOT be changed permanently.",
      "ja": "または、出力ルーチンによって放出されるパケットの数を厳密に制限することにより適用される場合があります。送信するパケットの数を計算する場合、特に上記の式を使用する場合、CWNDを永久に変更しないでください。"
    },
    {
      "indent": 3,
      "text": "E) Then, the sender can send as many new DATA chunks as rule A and rule B allow.",
      "ja": "e）その後、送信者は、ルールAとルールBが許可するのと同じくらい多くの新しいデータチャンクを送信できます。"
    },
    {
      "indent": 3,
      "text": "Multiple DATA chunks committed for transmission MAY be bundled in a single packet. Furthermore, DATA chunks being retransmitted MAY be bundled with new DATA chunks, as long as the resulting SCTP packet size does not exceed the PMTU. A ULP can request that no bundling is performed, but this only turns off any delays that an SCTP implementation might be using to increase bundling efficiency. It does not in itself stop all bundling from occurring (i.e., in case of congestion or retransmission).",
      "ja": "送信のためにコミットされた複数のデータチャンクは、単一のパケットにバンドルされる場合があります。さらに、結果のSCTPパケットサイズがPMTUを超えない限り、再送信されるデータチャンクには、新しいデータチャンクがバンドルされる場合があります。ULPは、バンドルが実行されないことを要求できますが、これにより、SCTP実装がバンドル効率を向上させるために使用している可能性のある遅延のみがオフになります。それ自体は、すべてのバンドルが発生するのを止めません（つまり、混雑や再送信の場合）。"
    },
    {
      "indent": 3,
      "text": "Before an endpoint transmits a DATA chunk, if any received DATA chunks have not been acknowledged (e.g., due to delayed ack), the sender SHOULD create a SACK chunk and bundle it with the outbound DATA chunk, as long as the size of the final SCTP packet does not exceed the current PMTU. See Section 6.2.",
      "ja": "エンドポイントがデータチャンクを送信する前に、受信したデータチャンクが認められていない場合（たとえば、ACKが遅れたため）、送信者はサックチャンクを作成し、最終的なサイズのサイズがある限り、アウトバウンドデータチャンクでそれをバンドルする必要がありますSCTPパケットは現在のPMTUを超えません。セクション6.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "When the window is full (i.e., transmission is disallowed by rule A and/or rule B), the sender MAY still accept send requests from its upper layer but MUST transmit no more DATA chunks until some or all of the outstanding DATA chunks are acknowledged and transmission is allowed by rule A and rule B again.",
      "ja": "ウィンドウがいっぱいになった場合（つまり、ルールAおよび/またはルールBによって送信が許可されていません）、送信者は引き続き上層からの送信要求を受け入れることができますが、未解決のデータチャンクの一部またはすべてが認められるまで、これ以上のデータチャンクを送信する必要がありますまた、伝送はルールAとルールBによって再び許可されます。"
    },
    {
      "indent": 3,
      "text": "Whenever a transmission or retransmission is made to any address, if the T3-rtx timer of that address is not currently running, the sender MUST start that timer. If the timer for that address is already running, the sender MUST restart the timer if the earliest (i.e., lowest TSN) outstanding DATA chunk sent to that address is being retransmitted. Otherwise, the data sender MUST NOT restart the timer.",
      "ja": "アドレスに送信または再送信が行われるたびに、そのアドレスのT3-RTXタイマーが現在実行されていない場合、送信者はそのタイマーを開始する必要があります。そのアドレスのタイマーが既に実行されている場合、そのアドレスに送信された最も早い（つまり、最も低いTSN）顕著なデータチャンクが再送信されている場合、送信者はタイマーを再起動する必要があります。それ以外の場合、データ送信者はタイマーを再起動してはなりません。"
    },
    {
      "indent": 3,
      "text": "When starting or restarting the T3-rtx timer, the timer value SHOULD be adjusted according to the timer rules defined in Sections 6.3.2 and 6.3.3.",
      "ja": "T3-RTXタイマーを開始または再起動するときは、セクション6.3.2および6.3.3で定義されているタイマールールに従ってタイマー値を調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "The data sender MUST NOT use a TSN that is more than 2^31 - 1 above the beginning TSN of the current send window.",
      "ja": "データ送信者は、現在の送信ウィンドウの最初のTSNの上に2^31-1を超えるTSNを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "For each stream, the data sender MUST NOT have more than 2^16 - 1 ordered user messages in the current send window.",
      "ja": "各ストリームについて、データ送信者は、現在の送信ウィンドウに2^16-1を超えるユーザーメッセージを超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "Whenever the sender of a DATA chunk can benefit from the corresponding SACK chunk being sent back without delay, the sender MAY set the I bit in the DATA chunk header. Please note that why the sender has set the I bit is irrelevant to the receiver.",
      "ja": "データチャンクの送信者が、対応するサックチャンクが遅滞なく送り返されることから利益を得ることができるときはいつでも、送信者はIビットをデータチャンクヘッダーに設定することができます。送信者がIビットを設定した理由は、レシーバーとは無関係であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Reasons for setting the I bit include, but are not limited to, the following (see Section 4 of [RFC7053] for a discussion of the benefits):",
      "ja": "Iビットを設定する理由は、次のことを含めますが、これらに限定されません（利点の議論については[RFC7053]のセクション4を参照）："
    },
    {
      "indent": 3,
      "text": "* The application requests that the I bit of the last DATA chunk of a user message be set when providing the user message to the SCTP implementation (see Section 11.1).",
      "ja": "* アプリケーションでは、ユーザーメッセージの最後のデータチャンクのIビットが、SCTP実装にユーザーメッセージを提供するときに設定することを要求します（セクション11.1を参照）。"
    },
    {
      "indent": 3,
      "text": "* The sender is in the SHUTDOWN-PENDING state.",
      "ja": "* 送信者は、シャットダウン留置状態にあります。"
    },
    {
      "indent": 3,
      "text": "* The sending of a DATA chunk fills the congestion or receiver window.",
      "ja": "* データチャンクの送信により、うっ血または受信機ウィンドウが埋められます。"
    },
    {
      "indent": 0,
      "text": "6.2. Acknowledgement on Reception of DATA Chunks",
      "section_title": true,
      "ja": "6.2. データチャンクの受信に関する謝辞"
    },
    {
      "indent": 3,
      "text": "The SCTP endpoint MUST always acknowledge the reception of each valid DATA chunk when the DATA chunk received is inside its receive window.",
      "ja": "SCTPエンドポイントは、受信したデータチャンクが受信ウィンドウ内にある場合、各有効なデータチャンクの受信を常に確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the receiver's advertised window is 0, the receiver MUST drop any new incoming DATA chunk with a TSN larger than the largest TSN received so far. Also, if the new incoming DATA chunk holds a TSN value less than the largest TSN received so far, then the receiver SHOULD drop the largest TSN held for reordering and accept the new incoming DATA chunk. In either case, if such a DATA chunk is dropped, the receiver MUST immediately send back a SACK chunk with the current receive window showing only DATA chunks received and accepted so far. The dropped DATA chunk(s) MUST NOT be included in the SACK chunk, as they were not accepted. The receiver MUST also have an algorithm for advertising its receive window to avoid receiver silly window syndrome (SWS), as described in [RFC1122]. The algorithm can be similar to the one described in Section 4.2.3.3 of [RFC1122].",
      "ja": "レシーバーの広告ウィンドウが0の場合、受信者は、これまでに受け取った最大のTSNよりも大きいTSNを使用して、新しい着信データチャンクをドロップする必要があります。また、新しい着信データチャンクがこれまでに受け取った最大のTSNよりもTSN値が少ない場合、受信者は、新しい着信データチャンクを並べ替えて受け入れるために保持されている最大のTSNをドロップする必要があります。どちらの場合でも、そのようなデータチャンクがドロップされた場合、受信者は、これまでに受信および受け入れられたデータチャンクのみを表示する現在の受信ウィンドウで、すぐにサックチャンクを送り返す必要があります。ドロップされたデータチャンクは、受け入れられなかったため、サックチャンクに含めてはなりません。[RFC1122]に記載されているように、受信機の愚かなウィンドウ症候群（SWS）を避けるために、受信ウィンドウを宣伝するためのアルゴリズムも受信する必要があります。アルゴリズムは、[RFC1122]のセクション4.2.3.3で説明したものと類似できます。"
    },
    {
      "indent": 3,
      "text": "The guidelines on the delayed acknowledgement algorithm specified in Section 4.2 of [RFC5681] SHOULD be followed. Specifically, an acknowledgement SHOULD be generated for at least every second packet (not every second DATA chunk) received and SHOULD be generated within 200 ms of the arrival of any unacknowledged DATA chunk. In some situations, it might be beneficial for an SCTP transmitter to be more conservative than the algorithms detailed in this document allow. However, an SCTP transmitter MUST NOT be more aggressive in sending SACK chunks than the following algorithms allow.",
      "ja": "[RFC5681]のセクション4.2で指定された遅延承認アルゴリズムのガイドラインに従う必要があります。具体的には、少なくとも2秒ごとのパケット（各2秒のデータチャンクではない）ごとに確認を生成する必要があり、未解決のデータチャンクの到着から200ミリ秒以内に生成する必要があります。状況によっては、SCTP送信機がこのドキュメントで詳述されているアルゴリズムよりも保守的であることが有益である可能性があります。ただし、SCTP送信機は、次のアルゴリズムが許可するよりも、サックチャンクを送信する際に攻撃的であってはなりません。"
    },
    {
      "indent": 3,
      "text": "An SCTP receiver MUST NOT generate more than one SACK chunk for every incoming packet, other than to update the offered window as the receiving application consumes new data. When the window opens up, an SCTP receiver SHOULD send additional SACK chunks to update the window even if no new data is received. The receiver MUST avoid sending a large number of window updates -- in particular, large bursts of them. One way to achieve this is to send a window update only if the window can be increased by at least a quarter of the receive buffer size of the association.",
      "ja": "SCTPレシーバーは、受信アプリケーションが新しいデータを消費するときに提供されるウィンドウを更新する以外に、着信パケットごとに複数のサックチャンクを生成してはなりません。ウィンドウが開くと、SCTPレシーバーは、新しいデータが受信されていなくても、ウィンドウを更新するために追加のサックチャンクを送信する必要があります。受信者は、多数のウィンドウの更新、特に大きなバーストの送信を避ける必要があります。これを達成する1つの方法は、窓を受信バッファーサイズの少なくとも4分の1で増やすことができる場合にのみ、ウィンドウの更新を送信することです。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: The maximum delay for generating an acknowledgement MAY be configured by the SCTP administrator, either statically or dynamically, in order to meet the specific timing requirement of the protocol being carried.",
      "ja": "実装注：承認を生成するための最大遅延は、実行中のプロトコルの特定のタイミング要件を満たすために、静的または動的にSCTP管理者によって構成される場合があります。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT allow the maximum delay (protocol parameter 'SACK.Delay') to be configured to be more than 500 ms. In other words, an implementation MAY lower the value of 'SACK.Delay' below 500 ms but MUST NOT raise it above 500 ms.",
      "ja": "実装により、最大遅延（プロトコルパラメーター 'sack.delay'）を500ミリ秒以上に設定することを許可してはなりません。言い換えれば、実装は「sack.delay」の値を500ミリ秒未満に低下させる可能性がありますが、500ミリ秒を超えて上昇してはなりません。"
    },
    {
      "indent": 3,
      "text": "Acknowledgements MUST be sent in SACK chunks unless shutdown was requested by the ULP, in which case an endpoint MAY send an acknowledgement in the SHUTDOWN chunk. A SACK chunk can acknowledge the reception of multiple DATA chunks. See Section 3.3.4 for SACK chunk format. In particular, the SCTP endpoint MUST fill in the Cumulative TSN Ack field to indicate the latest sequential TSN (of a valid DATA chunk) it has received. Any received DATA chunks with TSN greater than the value in the Cumulative TSN Ack field are reported in the Gap Ack Block fields. The SCTP endpoint MUST report as many Gap Ack Blocks as can fit in a single SACK chunk such that the size of the SCTP packet does not exceed the current PMTU.",
      "ja": "ULPによってシャットダウンが要求されない限り、謝辞は袋のチャンクで送信する必要があります。その場合、エンドポイントはシャットダウンチャンクで確認を送信する場合があります。サックチャンクは、複数のデータチャンクの受信を認めることができます。サックチャンク形式については、セクション3.3.4を参照してください。特に、SCTPエンドポイントは、累積TSN ACKフィールドを埋めて、受信した最新の順次TSN（有効なデータチャンクの）を示す必要があります。累積TSN ACKフィールドの値よりも大きいTSNを持つ受信したデータチャンクは、GAP ACKブロックフィールドで報告されています。SCTPエンドポイントは、SCTPパケットのサイズが現在のPMTUを超えないように、単一のサックチャンクに収まると同じくらい多くのギャップACKブロックを報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "The SHUTDOWN chunk does not contain Gap Ack Block fields. Therefore, the endpoint SHOULD use a SACK chunk instead of the SHUTDOWN chunk to acknowledge DATA chunks received out of order.",
      "ja": "シャットダウンチャンクには、ギャップACKブロックフィールドは含まれていません。したがって、エンドポイントは、シャットダウンチャンクの代わりにサックチャンクを使用して、故障したデータチャンクを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an SCTP packet containing a DATA chunk with the I bit set, the receiver SHOULD NOT delay the sending of the corresponding SACK chunk, i.e., the receiver SHOULD immediately respond with the corresponding SACK chunk.",
      "ja": "I BITセットでデータチャンクを含むSCTPパケットを受信したら、受信者は対応するサックチャンクの送信を遅らせないでください。つまり、受信機は、対応するサックチャンクですぐに応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a packet arrives with duplicate DATA chunk(s) and with no new DATA chunk(s), the endpoint MUST immediately send a SACK chunk with no delay. If a packet arrives with duplicate DATA chunk(s) bundled with new DATA chunks, the endpoint MAY immediately send a SACK chunk. Normally, receipt of duplicate DATA chunks will occur when the original SACK chunk was lost and the peer's RTO has expired. The duplicate TSN number(s) SHOULD be reported in the SACK chunk as duplicate.",
      "ja": "複製データチャンクでパケットが到着し、新しいデータチャンクなしで到着すると、エンドポイントはすぐに遅延なしでサックチャンクを送信する必要があります。重複したデータチャンクが新しいデータチャンクにバンドルされた重複したパケットが到着すると、エンドポイントはすぐにサックチャンクを送信する可能性があります。通常、元のサックチャンクが失われ、ピアのRTOが失効したときに、重複したデータチャンクの受信が発生します。重複したTSN番号は、サックチャンクで複製として報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a SACK chunk, it MAY use the duplicate TSN information to determine if SACK chunk loss is occurring. Further use of this data is for future study.",
      "ja": "エンドポイントがサックチャンクを受信すると、重複したTSN情報を使用して、サックチャンク損失が発生しているかどうかを判断する場合があります。このデータのさらなる使用は、将来の研究のためです。"
    },
    {
      "indent": 3,
      "text": "The data receiver is responsible for maintaining its receive buffers. The data receiver SHOULD notify the data sender in a timely manner of changes in its ability to receive data. How an implementation manages its receive buffers is dependent on many factors (e.g., operating system, memory management system, amount of memory, etc.). However, the data sender strategy defined in Section 6.2.1 is based on the assumption of receiver operation similar to the following:",
      "ja": "データレシーバーは、受信バッファーを維持する責任があります。データ受信者は、データを受信する機能をタイムリーに変更してデータ送信者に通知する必要があります。実装が受信バッファーを管理する方法は、多くの要因（例：オペレーティングシステム、メモリ管理システム、メモリ量など）に依存します。ただし、セクション6.2.1で定義されているデータ送信者戦略は、以下と同様のレシーバー操作の仮定に基づいています。"
    },
    {
      "indent": 3,
      "text": "A) At initialization of the association, the endpoint tells the peer how much receive buffer space it has allocated to the association in the INIT or INIT ACK chunk. The endpoint sets a_rwnd to this value.",
      "ja": "a）協会の初期化時に、エンドポイントはピアに、initまたはinit ackチャンクの協会に割り当てられたバッファースペースの受信スペースの量を伝えます。エンドポイントは、A_RWNDをこの値に設定します。"
    },
    {
      "indent": 3,
      "text": "B) As DATA chunks are received and buffered, decrement a_rwnd by the number of bytes received and buffered. This is, in effect, closing rwnd at the data sender and restricting the amount of data it can transmit.",
      "ja": "b）データチャンクが受信および緩衝されると、受信およびバッファリングされたバイト数によってA_RWNDを減少させます。これは、実際には、データ送信者でRWNDを閉じ、送信できるデータの量を制限することです。"
    },
    {
      "indent": 3,
      "text": "C) As DATA chunks are delivered to the ULP and released from the receive buffers, increment a_rwnd by the number of bytes delivered to the upper layer. This is, in effect, opening up rwnd on the data sender and allowing it to send more data. The data receiver SHOULD NOT increment a_rwnd unless it has released bytes from its receive buffer. For example, if the receiver is holding fragmented DATA chunks in a reassembly queue, it SHOULD NOT increment a_rwnd.",
      "ja": "c）データチャンクがULPに配信され、受信バッファーから解放されると、上層に配信されるバイト数によってA_RWNDを増加させます。これは、実際には、データ送信者にRWNDを開き、より多くのデータを送信できるようにしています。データレシーバーは、受信バッファーからバイトをリリースしない限り、A_RWNDを増やすべきではありません。たとえば、レシーバーが断片化されたデータチャンクを再組み立てキューに保持している場合、A_RWNDを増加させないでください。"
    },
    {
      "indent": 3,
      "text": "D) When sending a SACK chunk, the data receiver SHOULD place the current value of a_rwnd into the a_rwnd field. The data receiver SHOULD take into account that the data sender will not retransmit DATA chunks that are acked via the Cumulative TSN Ack (i.e., will drop from its retransmit queue).",
      "ja": "d）サックチャンクを送信するとき、データレシーバーはA_RWNDの現在の値をA_RWNDフィールドに配置する必要があります。データ受信者は、データ送信者が累積TSN ACKを介してAckされるデータチャンクを再送信しないことを考慮に入れる必要があります（つまり、再送信キューからドロップします）。"
    },
    {
      "indent": 3,
      "text": "Under certain circumstances, the data receiver MAY drop DATA chunks that it has received but has not released from its receive buffers (i.e., delivered to the ULP). These DATA chunks might have been acked in Gap Ack Blocks. For example, the data receiver might be holding data in its receive buffers while reassembling a fragmented user message from its peer when it runs out of receive buffer space. It MAY drop these DATA chunks even though it has acknowledged them in Gap Ack Blocks. If a data receiver drops DATA chunks, it MUST NOT include them in Gap Ack Blocks in subsequent SACK chunks until they are received again via retransmission. In addition, the endpoint SHOULD take into account the dropped data when calculating its a_rwnd.",
      "ja": "特定の状況では、データ受信機は受信したが受信バッファーから放出されていないデータチャンクをドロップする可能性があります（つまり、ULPに配信されます）。これらのデータチャンクは、ギャップACKブロックでAckedになっている可能性があります。たとえば、データ受信機は、受信バッファースペースがなくなったときにピアから断片化されたユーザーメッセージを再組み立てしながら、受信バッファーにデータを保持している可能性があります。GAPACKブロックでそれらを認めているにもかかわらず、これらのデータチャンクをドロップする可能性があります。データレシーバーがデータチャンクをドロップする場合、再送信により再び受信されるまで、後続のサックチャンクのギャップACKブロックにそれらを含めてはなりません。さらに、エンドポイントは、A_RWNDを計算するときに削除されたデータを考慮に入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT revoke a SACK chunk and discard data. Only in extreme circumstances might an endpoint use this procedure (such as out of buffer space). The data receiver SHOULD take into account that dropping data that has been acked in Gap Ack Blocks can result in suboptimal retransmission strategies in the data sender and thus in suboptimal performance.",
      "ja": "エンドポイントは、サックチャンクを取り消してデータを破棄してはなりません。極端な状況でのみ、エンドポイントがこの手順（バッファスペースから外れなど）を使用する可能性があります。データレシーバーは、GAP ACKブロックでAckされているデータをドロップすると、データ送信者の次の再送信戦略が生じる可能性があることを考慮に入れて、したがって、最適ではないパフォーマンスになります。"
    },
    {
      "indent": 3,
      "text": "The following example illustrates the use of delayed acknowledgements:",
      "ja": "次の例は、遅延承認の使用を示しています。"
    },
    {
      "indent": 3,
      "text": "Endpoint A Endpoint Z",
      "ja": "エンドポイントAエンドポイントz"
    },
    {
      "indent": 3,
      "text": "{App sends 3 messages; strm 0}\nDATA [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)\n(Start T3-rtx timer)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DATA [TSN=8,Strm=0,Seq=4] ------------> (send ack)\n                              /------- SACK [TSN Ack=8,block=0]\n(cancel T3-rtx timer)  <-----/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DATA [TSN=9,Strm=0,Seq=5] ------------> (ack delayed)\n(Start T3-rtx timer)\n                                       ...\n                                       {App sends 1 message; strm 1}\n                                       (bundle SACK with DATA)\n                                /----- SACK [TSN Ack=9,block=0] \\\n                               /         DATA [TSN=6,Strm=1,Seq=2]\n(cancel T3-rtx timer)  <------/        (Start T3-rtx timer)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(ack delayed)\n(send ack)\nSACK [TSN Ack=6,block=0] -------------> (cancel T3-rtx timer)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 7: Delayed Acknowledgement Example",
      "ja": "図7：承認の遅延例"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives a DATA chunk with no user data (i.e., the Length field is set to 16), it SHOULD send an ABORT chunk with a \"No User Data\" error cause.",
      "ja": "エンドポイントがユーザーデータなしでデータチャンクを受信した場合（つまり、長さフィールドが16に設定されています）、「ユーザーデータなし」エラー原因で中断チャンクを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT send a DATA chunk with no user data part. This avoids the need to be able to return a zero-length user message in the API, especially in the socket API as specified in [RFC6458] for details.",
      "ja": "エンドポイントは、ユーザーデータパートなしでデータチャンクを送信しないでください。これにより、詳細については、[RFC6458]で指定されているように、API、特にソケットAPIでゼロの長さのユーザーメッセージを返す必要がなくなります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Processing a Received SACK Chunk",
      "section_title": true,
      "ja": "6.2.1. 受信したサックチャンクを処理します"
    },
    {
      "indent": 3,
      "text": "Each SACK chunk an endpoint receives contains an a_rwnd value. This value represents the amount of buffer space the data receiver, at the time of transmitting the SACK chunk, has left of its total receive buffer space (as specified in the INIT/INIT ACK chunk). Using a_rwnd, Cumulative TSN Ack, and Gap Ack Blocks, the data sender can develop a representation of the peer's receive buffer space.",
      "ja": "各サックチャンクエンドポイントを受信するには、A_RWND値が含まれています。この値は、サックチャンクを送信する時点で、データレシーバーが総受信バッファースペース（init/init ackチャンクで指定されているように）の左にあるバッファスペースの量を表します。A_RWND、累積TSN ACK、およびGAP ACKブロックを使用して、データ送信者はピアの受信バッファースペースの表現を開発できます。"
    },
    {
      "indent": 3,
      "text": "One of the problems the data sender takes into account when processing a SACK chunk is that a SACK chunk can be received out of order. That is, a SACK chunk sent by the data receiver can pass an earlier SACK chunk and be received first by the data sender. If a SACK chunk is received out of order, the data sender can develop an incorrect view of the peer's receive buffer space.",
      "ja": "サックチャンクを処理する際にデータ送信者が考慮する問題の1つは、サックチャンクを故障して受け取ることができることです。つまり、データレシーバーから送信されたサックチャンクは、以前のサックチャンクを渡して、最初にデータ送信者が受信することができます。サックチャンクが故障していない場合、データ送信者はピアの受信バッファースペースの誤ったビューを開発できます。"
    },
    {
      "indent": 3,
      "text": "Since there is no explicit identifier that can be used to detect out-of-order SACK chunks, the data sender uses heuristics to determine if a SACK chunk is new.",
      "ja": "秩序外のサックチャンクを検出するために使用できる明示的な識別子はないため、データ送信者はヒューリスティックを使用して、サックチャンクが新しいかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD use the following rules to calculate the rwnd, using the a_rwnd value, the Cumulative TSN Ack, and Gap Ack Blocks in a received SACK chunk.",
      "ja": "エンドポイントは、A_RWND値、累積TSN ACK、および受信したサックチャンクのGAP ACKブロックを使用して、RWNDを計算するために次のルールを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A) At the establishment of the association, the endpoint initializes the rwnd to the Advertised Receiver Window Credit (a_rwnd) the peer specified in the INIT or INIT ACK chunk.",
      "ja": "a）協会の設立時に、エンドポイントは、rwndを広告されたレシーバーウィンドウクレジット（a_rwnd）に初期化します。"
    },
    {
      "indent": 3,
      "text": "B) Any time a DATA chunk is transmitted (or retransmitted) to a peer, the endpoint subtracts the data size of the chunk from the rwnd of that peer.",
      "ja": "b）データチャンクがピアに送信（または再送信）される場合、エンドポイントはそのピアのRWNDからチャンクのデータサイズを差し引きます。"
    },
    {
      "indent": 3,
      "text": "C) Any time a DATA chunk is marked for retransmission, either via T3-rtx timer expiration (Section 6.3.3) or via Fast Retransmit (Section 7.2.4), add the data size of those chunks to the rwnd.",
      "ja": "c）T3-RTXタイマーの有効期限（セクション6.3.3）を介して、または高速再送信（セクション7.2.4）を介して、データチャンクが再送信のためにマークされた場合、それらのチャンクのデータサイズをRWNDに追加します。"
    },
    {
      "indent": 3,
      "text": "D) Any time a SACK chunk arrives, the endpoint performs the following:",
      "ja": "d）サックチャンクが到着するたびに、エンドポイントは次のことを実行します。"
    },
    {
      "indent": 7,
      "text": "i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point, then drop the SACK chunk. Since Cumulative TSN Ack is monotonically increasing, a SACK chunk whose Cumulative TSN Ack is less than the Cumulative TSN Ack Point indicates an out-of-order SACK chunk.",
      "ja": "i) 累積TSN ACKが累積TSN ACKポイントよりも少ない場合は、サックチャンクをドロップします。累積TSN ACKは単調に増加しているため、累積TSN ACKが累積TSN ACKポイントよりも累積的なTSN ACKよりも少ないサックチャンクは、オーダーオブオーダーサックチャンクを示しています。"
    },
    {
      "indent": 7,
      "text": "ii) Set rwnd equal to the newly received a_rwnd minus the number of bytes still outstanding after processing the Cumulative TSN Ack and the Gap Ack Blocks.",
      "ja": "ii）累積TSN ACKとGAP ACKブロックを処理した後、まだ未解決のバイト数を差し引いて、新しく受信したA_RWNDから等しく設定します。"
    },
    {
      "indent": 7,
      "text": "iii) If the SACK chunk is missing a TSN that was previously acknowledged via a Gap Ack Block (e.g., the data receiver reneged on the data), then consider the corresponding DATA that might be possibly missing: Count one miss indication towards Fast Retransmit as described in Section 7.2.4, and if no retransmit timer is running for the destination address to which the DATA chunk was originally transmitted, then T3-rtx is started for that destination address.",
      "ja": "iii）サックチャンクにギャップACKブロックを介して以前に認識されていたTSNが欠落している場合（たとえば、データをreったデータ受信機など）、欠落している可能性のある対応するデータを検討してください。セクション7.2.4で説明されており、データチャンクが元々送信された宛先アドレスに対して再送信タイマーが実行されていない場合、その宛先アドレスに対してT3-RTXが開始されます。"
    },
    {
      "indent": 7,
      "text": "iv) If the Cumulative TSN Ack matches or exceeds the Fast Recovery exit point (Section 7.2.4), Fast Recovery is exited.",
      "ja": "iv）累積TSN ACKが高速回復出口ポイント（セクション7.2.4）に一致するか、それを超えると、高速回復が終了します。"
    },
    {
      "indent": 0,
      "text": "6.3. Management of Retransmission Timer",
      "section_title": true,
      "ja": "6.3. 再送信タイマーの管理"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint uses a retransmission timer T3-rtx to ensure data delivery in the absence of any feedback from its peer. The duration of this timer is referred to as RTO (retransmission timeout).",
      "ja": "SCTPエンドポイントは、再送信タイマーT3-RTXを使用して、ピアからのフィードバックがない場合にデータ配信を確保します。このタイマーの期間は、RTO（再送信タイムアウト）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint's peer is multi-homed, the endpoint will calculate a separate RTO for each different destination transport address of its peer endpoint.",
      "ja": "エンドポイントのピアがマルチホームの場合、エンドポイントは、ピアエンドポイントの異なる宛先輸送アドレスごとに個別のRTOを計算します。"
    },
    {
      "indent": 3,
      "text": "The computation and management of RTO in SCTP follow closely how TCP manages its retransmission timer. To compute the current RTO, an endpoint maintains two state variables per destination transport address: SRTT (smoothed round-trip time) and RTTVAR (round-trip time variation).",
      "ja": "SCTPでのRTOの計算と管理は、TCPが再送信タイマーを管理する方法に密接に続きます。現在のRTOを計算するために、エンドポイントは、宛先輸送アドレスごとの2つの状態変数（SRTT（滑らかな往復時間）とRTTVAR（往復時間の変動）を維持します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. RTO Calculation",
      "section_title": true,
      "ja": "6.3.1. RTO計算"
    },
    {
      "indent": 3,
      "text": "The rules governing the computation of SRTT, RTTVAR, and RTO are as follows:",
      "ja": "SRTT、RTTVAR、およびRTOの計算を管理する規則は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "C1) Until an RTT measurement has been made for a packet sent to the given destination transport address, set RTO to the protocol parameter 'RTO.Initial'.",
      "ja": "C1）指定された宛先輸送アドレスに送信されるパケットに対してRTT測定が行われるまで、RTOをプロトコルパラメーター「RTO.Initial」に設定します。"
    },
    {
      "indent": 3,
      "text": "C2) When the first RTT measurement R is made, perform:",
      "ja": "c2）最初のRTT測定rが作成されたら、実行してください。"
    },
    {
      "indent": 6,
      "text": "SRTT = R\nRTTVAR = R/2\nRTO = SRTT + 4 * RTTVAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "C3) When a new RTT measurement R' is made, perform:",
      "ja": "c3）新しいRTT測定r 'が作成されたら、実行してください。"
    },
    {
      "indent": 6,
      "text": "RTTVAR = (1 - RTO.Beta) * RTTVAR + RTO.Beta * |SRTT - R'|\nSRTT = (1 - RTO.Alpha) * SRTT + RTO.Alpha * R'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Note: The value of SRTT used in the update to RTTVAR is its value before updating SRTT itself using the second assignment.",
      "ja": "注：RTTVARのアップデートで使用されるSRTTの値は、2番目の割り当てを使用してSRTT自体を更新する前の値です。"
    },
    {
      "indent": 8,
      "text": "After the computation, update:",
      "ja": "計算後、更新："
    },
    {
      "indent": 6,
      "text": "RTO = SRTT + 4 * RTTVAR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "C4) When data is in flight and when allowed by rule C5 below, a new RTT measurement MUST be made each round trip. Furthermore, new RTT measurements SHOULD be made no more than once per round trip for a given destination transport address. There are two reasons for this recommendation: First, it appears that measuring more frequently often does not in practice yield any significant benefit [ALLMAN99]; second, if measurements are made more often, then the values of 'RTO.Alpha' and 'RTO.Beta' in rule C3 above SHOULD be adjusted so that SRTT and RTTVAR still adjust to changes at roughly the same rate (in terms of how many round trips it takes them to reflect new values) as they would if making only one measurement per round trip and using 'RTO.Alpha' and 'RTO.Beta' as given in rule C3. However, the exact nature of these adjustments remains a research issue.",
      "ja": "c4）データが飛行中であり、下のルールC5で許可された場合、各往復旅行する新しいRTT測定を行う必要があります。さらに、特定の宛先輸送住所の往復ごとに新しいRTT測定を行う必要があります。この推奨事項には2つの理由があります。まず、より頻繁に測定することは実際には重要な利益をもたらさないことが多いようです[Allman99]。第二に、測定値がより頻繁に行われる場合、上記のルールC3の「rto.alpha」と「rto.beta」の値を調整する必要があります。往復の多くの往復は、往復に1回の測定を行い、ルールC3に記載されている「RTO.alpha」と「RTO.BETA」を使用する場合のように、新しい値を反映するのにかかります。ただし、これらの調整の正確な性質は、研究問題のままです。"
    },
    {
      "indent": 3,
      "text": "C5) Karn's algorithm: RTT measurements MUST NOT be made using chunks that were retransmitted (and thus for which it is ambiguous whether the reply was for the first instance of the chunk or for a later instance).",
      "ja": "c5）Karnのアルゴリズム：RTT測定は、再送信されたチャンクを使用して行わないでください（したがって、返信がチャンクの最初のインスタンスであったのか、それとも後の例であったかどうかはあいまいです）。"
    },
    {
      "indent": 8,
      "text": "RTT measurements SHOULD only be made using a DATA chunk with TSN r if no DATA chunk with TSN less than or equal to r was retransmitted since the DATA chunk with TSN r was sent first.",
      "ja": "TSN R以下のTSNを使用したデータチャンクがTSN R以下のデータチャンクが最初に送信されたため、TSNを使用したデータチャンクがRを使用していない場合、TSN Rのデータチャンクを使用してRTT測定を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "C6) Whenever RTO is computed, if it is less than 'RTO.Min' seconds, then it is rounded up to 'RTO.Min' seconds. The reason for this rule is that RTOs that do not have a high minimum value are susceptible to unnecessary timeouts [ALLMAN99].",
      "ja": "c6）RTOが計算されるたびに、 'rto.min'秒未満の場合、 'rto.min'秒まで丸められます。この規則の理由は、最小値が高いRTOSが不必要なタイムアウトの影響を受けやすいためです[Allman99]。"
    },
    {
      "indent": 3,
      "text": "C7) A maximum value MAY be placed on RTO, provided it is at least 'RTO.Max' seconds.",
      "ja": "c7）少なくとも「RTO.max」秒である場合、RTOに最大値を配置できます。"
    },
    {
      "indent": 3,
      "text": "There is no requirement for the clock granularity G used for computing RTT measurements and the different state variables, other than:",
      "ja": "RTT測定とさまざまな状態変数の計算に使用されるクロックGranularity Gには、以外の要件はありません。"
    },
    {
      "indent": 3,
      "text": "G1) Whenever RTTVAR is computed, if RTTVAR == 0, then adjust RTTVAR = G.",
      "ja": "g1）rttvarが計算されるときはいつでも、rttvar == 0の場合、rttvar = gを調整します。"
    },
    {
      "indent": 3,
      "text": "Experience [ALLMAN99] has shown that finer clock granularities (less than 100 msec) perform somewhat better than more coarse granularities.",
      "ja": "Experience [Allman99]は、より細かいクロック粒度（100ミリ秒未満）が粗い粒度よりもやや優れたパフォーマンスを発揮することを示しています。"
    },
    {
      "indent": 3,
      "text": "See Section 16 for suggested parameter values.",
      "ja": "提案されたパラメーター値については、セクション16を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Retransmission Timer Rules",
      "section_title": true,
      "ja": "6.3.2. 再送信タイマールール"
    },
    {
      "indent": 3,
      "text": "The rules for managing the retransmission timer are as follows:",
      "ja": "再送信タイマーを管理するためのルールは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "R1) Every time a DATA chunk is sent to any address (including a retransmission), if the T3-rtx timer of that address is not running, start it running so that it will expire after the RTO of that address. The RTO used here is that obtained after any doubling due to previous T3-rtx timer expirations on the corresponding destination address as discussed in rule E2 below.",
      "ja": "R1）データチャンクが任意のアドレス（再送信を含む）に送信されるたびに、そのアドレスのT3-RTXタイマーが実行されていない場合、そのアドレスのRTOの後に期限切れになるように実行してください。ここで使用されているRTOは、以下のルールE2で説明したように、対応する宛先アドレスの以前のT3-RTXタイマーの有効期限のために倍増した後に得られたものです。"
    },
    {
      "indent": 3,
      "text": "R2) Whenever all outstanding data sent to an address have been acknowledged, turn off the T3-rtx timer of that address.",
      "ja": "R2）アドレスに送信されたすべての未解決のデータが確認されたときはいつでも、そのアドレスのT3-RTXタイマーをオフにします。"
    },
    {
      "indent": 3,
      "text": "R3) Whenever a SACK chunk is received that acknowledges the DATA chunk with the earliest outstanding TSN for that address, restart the T3-rtx timer for that address with its current RTO (if there is still outstanding data on that address).",
      "ja": "R3）そのアドレスの最初の未解決のTSNを使用したデータチャンクを認めるサックチャンクが受信されるたびに、そのアドレスのT3-RTXタイマーを現在のRTOで再起動します（そのアドレスに未払いのデータがまだある場合）。"
    },
    {
      "indent": 3,
      "text": "R4) Whenever a SACK chunk is received missing a TSN that was previously acknowledged via a Gap Ack Block, start the T3-rtx for the destination address to which the DATA chunk was originally transmitted if it is not already running.",
      "ja": "R4）GAP ACKブロックを介して以前に認められていたTSNを失ったサックチャンクを受け取ったときはいつでも、データチャンクがまだ実行されていない場合は元々送信された宛先アドレスのT3-RTXを起動します。"
    },
    {
      "indent": 3,
      "text": "The following example shows the use of various timer rules (assuming that the receiver uses delayed acks).",
      "ja": "次の例は、さまざまなタイマールールの使用を示しています（レシーバーが遅延ACKを使用していると仮定します）。"
    },
    {
      "indent": 3,
      "text": "Endpoint A                                         Endpoint Z\n{App begins to send}\nData [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)\n(Start T3-rtx timer)\n                                        {App sends 1 message; strm 1}\n                                        (bundle ack with data)\nDATA [TSN=8,Strm=0,Seq=4] ----\\     /-- SACK [TSN Ack=7,Block=0]\n                               \\   /      DATA [TSN=6,Strm=1,Seq=2]\n                                \\ /     (Start T3-rtx timer)\n                                 \\\n                                / \\\n(Restart T3-rtx timer)  <------/   \\--> (ack delayed)\n(ack delayed)\n{send ack}\nSACK [TSN Ack=6,Block=0] --------------> (Cancel T3-rtx timer)\n                                        ..\n                                        (send ack)\n(Cancel T3-rtx timer)  <-------------- SACK [TSN Ack=8,Block=0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 8: Timer Rule Examples",
      "ja": "図8：タイマールールの例"
    },
    {
      "indent": 0,
      "text": "6.3.3. Handle T3-rtx Expiration",
      "section_title": true,
      "ja": "6.3.3. T3-RTXの有効期限を処理します"
    },
    {
      "indent": 3,
      "text": "Whenever the retransmission timer T3-rtx expires for a destination address, do the following:",
      "ja": "再送信タイマーT3-RTXが宛先アドレスの有効期限が切れるときはいつでも、次のことを行います。"
    },
    {
      "indent": 3,
      "text": "E1) For the destination address for which the timer expires, adjust its ssthresh with rules defined in Section 7.2.3 and set cwnd = PMDCS.",
      "ja": "e1）タイマーの有効期限が切れる宛先アドレスについては、セクション7.2.3で定義されたルールとCWND = PMDCSを設定して、そのsSthreshを調整します。"
    },
    {
      "indent": 3,
      "text": "E2) For the destination address for which the timer expires, set RTO = RTO * 2 (\"back off the timer\"). The maximum value discussed in rule C7 above ('RTO.Max') MAY be used to provide an upper bound to this doubling operation.",
      "ja": "e2）タイマーの有効期限が切れる宛先アドレスの場合、rto = rto * 2（ \"タイマーからバックオフ\"）を設定します。上記のルールC7で説明されている最大値（ 'rto.max'）を使用して、この倍増操作の上限を提供できます。"
    },
    {
      "indent": 3,
      "text": "E3) Determine how many of the earliest (i.e., lowest TSN) outstanding DATA chunks for the address for which the T3-rtx has expired will fit into a single SCTP packet, subject to the PMTU corresponding to the destination transport address to which the retransmission is being sent (this might be different from the address for which the timer expires; see Section 6.4). Call this value K. Bundle and retransmit those K DATA chunks in a single packet to the destination endpoint.",
      "ja": "e3）T3-RTXの有効期限が切れたアドレスの最も早い（つまり、最も低いTSN）未発行データチャンクの数を決定します。単一のSCTPパケットに適合します。送信されています（これは、タイマーの期限が切れるアドレスとは異なる場合があります。セクション6.4を参照）。この値Kを呼び出します。これらのKデータチャンクを単一のパケットで宛先エンドポイントに再送信します。"
    },
    {
      "indent": 3,
      "text": "E4) Start the retransmission timer T3-rtx on the destination address to which the retransmission is sent if rule R1 above indicates to do so. The RTO to be used for starting T3-rtx SHOULD be the one for the destination address to which the retransmission is sent, which, when the receiver is multi-homed, might be different from the destination address for which the timer expired (see Section 6.4 below).",
      "ja": "e4）上記のルールR1がそうすることを示した場合、再送信が送信される宛先アドレスで再送信タイマーT3-RTXを開始します。T3-RTXを開始するために使用されるRTOは、再送信が送信される宛先アドレスのものである必要があります。これは、レシーバーがマルチホームされている場合、タイマーの有効期限が切れる宛先アドレスとは異なる場合があります（セクションを参照6.4以下）。"
    },
    {
      "indent": 3,
      "text": "After retransmitting, once a new RTT measurement is obtained (which can happen only when new data has been sent and acknowledged, per rule C5, or for a measurement made from a HEARTBEAT chunk; see Section 8.3), the computation in rule C3 is performed, including the computation of RTO, which might result in \"collapsing\" RTO back down after it has been subject to doubling (rule E2).",
      "ja": "再送信後、新しいRTT測定が取得されると（これは、ルールC5ごとに、またはハートビートチャンクから行われた測定の場合に新しいデータが送信および承認された場合にのみ発生する可能性があります。セクション8.3を参照）、ルールC3の計算が実行されます。、RTOの計算を含む。これにより、RTOが2倍になった後に「崩壊」したRTOが戻ってくる可能性があります（ルールE2）。"
    },
    {
      "indent": 3,
      "text": "Any DATA chunks that were sent to the address for which the T3-rtx timer expired but did not fit in an SCTP packet of size smaller than or equal to the PMTU (rule E3 above) SHOULD be marked for retransmission and sent as soon as cwnd allows (normally, when a SACK chunk arrives).",
      "ja": "T3-RTXタイマーが期限切れになったが、PMTU以下のSCTPパケット（上記のルールE3）以下のSCTPパケットに収まらなかったアドレスに送信されたデータチャンクは、再送信のためにマークを付け、CWNDとしてすぐに送信する必要があります。許可します（通常、袋のチャンクが到着したとき）。"
    },
    {
      "indent": 3,
      "text": "The final rule for managing the retransmission timer concerns failover (see Section 6.4.1):",
      "ja": "再送信タイマーを管理するための最終規則は、フェールオーバーに関するものです（セクション6.4.1を参照）："
    },
    {
      "indent": 3,
      "text": "F1) Whenever an endpoint switches from the current destination transport address to a different one, the current retransmission timers are left running. As soon as the endpoint transmits a packet containing DATA chunk(s) to the new transport address, start the timer on that transport address, using the RTO value of the destination address to which the data is being sent, if rule R1 indicates to do so.",
      "ja": "f1）エンドポイントが現在の宛先輸送アドレスから別の輸送アドレスに切り替わるたびに、現在の再送信タイマーは実行されたままです。エンドポイントがデータチャンクを含むパケットを新しいトランスポートアドレスに送信するとすぐに、ルールR1が行うことを示している場合、データが送信されている宛先アドレスのRTO値を使用して、その輸送アドレスのタイマーを開始します。それで。"
    },
    {
      "indent": 0,
      "text": "6.4. Multi-Homed SCTP Endpoints",
      "section_title": true,
      "ja": "6.4. マルチホームのSCTPエンドポイント"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint is considered multi-homed if there is more than one transport address that can be used as a destination address to reach that endpoint.",
      "ja": "SCTPエンドポイントは、そのエンドポイントに到達するために宛先アドレスとして使用できる複数の輸送アドレスがある場合、マルチホームと見なされます。"
    },
    {
      "indent": 3,
      "text": "Moreover, the ULP of an endpoint selects one of the multiple destination addresses of a multi-homed peer endpoint as the primary path (see Sections 5.1.2 and 11.1 for details).",
      "ja": "さらに、エンドポイントのULPは、マルチホームのピアエンドポイントの複数の宛先アドレスの1つをプライマリパスとして選択します（詳細については、セクション5.1.2および11.1を参照）。"
    },
    {
      "indent": 3,
      "text": "By default, an endpoint SHOULD always transmit to the primary path, unless the SCTP user explicitly specifies the destination transport address (and possibly source transport address) to use.",
      "ja": "デフォルトでは、SCTPユーザーが使用する宛先輸送アドレス（および場合によってはソーストランスポートアドレス）を明示的に指定しない限り、エンドポイントは常にプライマリパスに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD transmit reply chunks (e.g., INIT ACK, COOKIE ACK, and HEARTBEAT ACK) in response to control chunks to the same destination transport address from which it received the control chunk to which it is replying.",
      "ja": "エンドポイントは、応答しているコントロールチャンクを受け取った同じ宛先輸送アドレスへのコントロールチャンクに応じて、応答チャンク（INIT ACK、Cookie ACK、およびHeartbeat ACK）を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The selection of the destination transport address for packets containing SACK chunks is implementation dependent. However, an endpoint SHOULD NOT vary the destination transport address of a SACK chunk when it receives DATA chunks coming from the same source address.",
      "ja": "サックチャンクを含むパケットの宛先輸送アドレスの選択は、実装に依存します。ただし、エンドポイントは、同じソースアドレスから来るデータチャンクを受信した場合、サックチャンクの宛先輸送アドレスを変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "When acknowledging multiple DATA chunks received in packets from different source addresses in a single SACK chunk, the SACK chunk MAY be transmitted to one of the destination transport addresses from which the DATA or control chunks being acknowledged were received.",
      "ja": "単一のサックチャンクの異なるソースアドレスからパケットで受信された複数のデータチャンクを認める場合、サックチャンクは、承認されたデータまたは制御チャンクが受信される宛先輸送アドレスの1つに送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "When a receiver of a duplicate DATA chunk sends a SACK chunk to a multi-homed endpoint, it MAY be beneficial to vary the destination address and not use the source address of the DATA chunk. The reason is that receiving a duplicate from a multi-homed endpoint might indicate that the return path (as specified in the source address of the DATA chunk) for the SACK chunk is broken.",
      "ja": "複製データチャンクの受信者がサックチャンクをマルチホームのエンドポイントに送信する場合、宛先アドレスを変更し、データチャンクのソースアドレスを使用しないことが有益かもしれません。その理由は、マルチホームのエンドポイントから複製を受信することは、サックチャンクのリターンパス（データチャンクのソースアドレスで指定されているように）が壊れていることを示している可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, when its peer is multi-homed, an endpoint SHOULD try to retransmit a chunk that timed out to an active destination transport address that is different from the last destination address to which the chunk was sent.",
      "ja": "さらに、ピアがマルチホームになった場合、エンドポイントは、チャンクが送信された最後の宛先アドレスとは異なるアクティブな宛先輸送アドレスにタイミングを出したチャンクを再送信しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "When its peer is multi-homed, an endpoint SHOULD send fast retransmissions to the same destination transport address to which the original data was sent. If the primary path has been changed and the original data was sent to the old primary path before the Fast Retransmit, the implementation MAY send it to the new primary path.",
      "ja": "ピアがマルチホームの場合、エンドポイントは、元のデータが送信された同じ宛先輸送アドレスに高速再送信を送信する必要があります。プライマリパスが変更され、元のデータが高速再送信の前に古いプライマリパスに送信された場合、実装はそれを新しいプライマリパスに送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "Retransmissions do not affect the total outstanding data count. However, if the DATA chunk is retransmitted onto a different destination address, both the outstanding data counts on the new destination address and the old destination address to which the data chunk was last sent is adjusted accordingly.",
      "ja": "再送信は、未発生のデータカウント全体に影響しません。ただし、データチャンクが別の宛先アドレスに再送信される場合、新しい宛先アドレスの未解決のデータカウントと、データチャンクが最後に送信された古い宛先アドレスの両方がそれに応じて調整されます。"
    },
    {
      "indent": 0,
      "text": "6.4.1. Failover from an Inactive Destination Address",
      "section_title": true,
      "ja": "6.4.1. 非アクティブな宛先アドレスからのフェールオーバー"
    },
    {
      "indent": 3,
      "text": "Some of the transport addresses of a multi-homed SCTP endpoint might become inactive due to either the occurrence of certain error conditions (see Section 8.2) or adjustments from the SCTP user.",
      "ja": "マルチホームのSCTPエンドポイントの輸送アドレスの一部は、特定のエラー条件（セクション8.2を参照）またはSCTPユーザーからの調整のいずれかのために、非アクティブになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "When there is outbound data to send and the primary path becomes inactive (e.g., due to failures) or where the SCTP user explicitly requests to send data to an inactive destination transport address before reporting an error to its ULP, the SCTP endpoint SHOULD try to send the data to an alternate active destination transport address if one exists.",
      "ja": "送信するアウトバウンドデータがあり、プライマリパスが非アクティブになり（障害により）、またはSCTPユーザーがULPにエラーを報告する前に非アクティブな宛先輸送アドレスにデータを送信するように明示的に要求する場合、SCTPエンドポイントは存在する場合は、別のアクティブな宛先輸送アドレスにデータを送信します。"
    },
    {
      "indent": 3,
      "text": "When retransmitting data that timed out, if the endpoint is multi-homed, it needs to consider each source-destination address pair in its retransmission selection policy. When retransmitting timed-out data, the endpoint SHOULD attempt to pick the most divergent source-destination pair from the original source-destination pair to which the packet was transmitted.",
      "ja": "タイミングを合わせたデータを再送信する場合、エンドポイントがマルチホームの場合、再送信選択ポリシーで各ソース照明アドレスペアを考慮する必要があります。タイムアウトデータを再送信するとき、エンドポイントは、パケットが送信された元のソース照明ペアから最も多様なソース照明ペアを選択しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Rules for picking the most divergent source-destination pair are an implementation decision and are not specified within this document.",
      "ja": "注：最も多様なソースデステーションペアを選択するためのルールは、実装決定であり、このドキュメント内では指定されていません。"
    },
    {
      "indent": 0,
      "text": "6.5. Stream Identifier and Stream Sequence Number",
      "section_title": true,
      "ja": "6.5. ストリーム識別子とストリームシーケンス番号"
    },
    {
      "indent": 3,
      "text": "Every DATA chunk MUST carry a valid stream identifier. If an endpoint receives a DATA chunk with an invalid stream identifier, it SHOULD acknowledge the reception of the DATA chunk following the normal procedure, immediately send an ERROR chunk with cause set to \"Invalid Stream Identifier\" (see Section 3.3.10), and discard the DATA chunk. The endpoint MAY bundle the ERROR chunk and the SACK chunk in the same packet.",
      "ja": "すべてのデータチャンクは、有効なストリーム識別子を運ぶ必要があります。エンドポイントが無効なストリーム識別子を使用してデータチャンクを受信した場合、通常の手順に従ってデータチャンクの受信を確認する必要があります。データチャンクを破棄します。エンドポイントは、エラーチャンクとサックチャンクを同じパケットにバンドルする場合があります。"
    },
    {
      "indent": 3,
      "text": "The Stream Sequence Number in all the outgoing streams MUST start from 0 when the association is established. The Stream Sequence Number of an outgoing stream MUST be incremented by 1 for each ordered user message sent on that outgoing stream. In particular, when the Stream Sequence Number reaches the value 65535, the next Stream Sequence Number MUST be set to 0. For unordered user messages, the Stream Sequence Number MUST NOT be changed.",
      "ja": "すべての発信ストリームのストリームシーケンス番号は、アソシエーションが確立されたときに0から開始する必要があります。発信ストリームのストリームシーケンス番号は、その発信ストリームに送信された注文されたユーザーメッセージごとに1個ずつ増加する必要があります。特に、ストリームシーケンス番号が値65535に達すると、次のストリームシーケンス番号を0に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6. Ordered and Unordered Delivery",
      "section_title": true,
      "ja": "6.6. 注文されていない命令のない配達"
    },
    {
      "indent": 3,
      "text": "Within a stream, an endpoint MUST deliver DATA chunks received with the U flag set to 0 to the upper layer according to the order of their Stream Sequence Number. If DATA chunks arrive out of order of their Stream Sequence Number, the endpoint MUST hold the received DATA chunks from delivery to the ULP until they are reordered.",
      "ja": "ストリーム内で、エンドポイントは、uフラグを0に設定して、ストリームシーケンス番号の順序に応じて上層層に0に設定されたデータチャンクを配信する必要があります。データチャンクがストリームシーケンス番号の順序外に到着した場合、エンドポイントは、並べ替えるまで、受信したデータチャンクをULPへの配信から並べ替えるまで保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "However, an SCTP endpoint can indicate that no ordered delivery is required for a particular DATA chunk transmitted within the stream by setting the U flag of the DATA chunk to 1.",
      "ja": "ただし、SCTPエンドポイントは、データチャンクのUフラグを1に設定することにより、ストリーム内に送信される特定のデータチャンクに順序付けられた配信が不要であることを示すことができます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a DATA chunk with the U flag set to 1, it bypasses the ordering mechanism and immediately deliver the data to the upper layer (after reassembly if the user data is fragmented by the data sender).",
      "ja": "エンドポイントがUフラグを1に設定してデータチャンクを受信すると、順序付けメカニズムをバイパスし、すぐにデータを上層に配信します（ユーザーデータがデータ送信者によって断片化された場合）。"
    },
    {
      "indent": 3,
      "text": "This provides an effective way of transmitting \"out-of-band\" data in a given stream. Also, a stream can be used as an \"unordered\" stream by simply setting the U flag to 1 in all DATA chunks sent through that stream.",
      "ja": "これにより、特定のストリームで「帯域外」データを送信する効果的な方法が提供されます。また、ストリームは、そのストリームから送信されたすべてのデータチャンクでUフラグを1に設定するだけで、「順序付けられていない」ストリームとして使用できます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: When sending an unordered DATA chunk, an implementation MAY choose to place the DATA chunk in an outbound packet that is at the head of the outbound transmission queue if possible.",
      "ja": "実装注：順序付けられていないデータチャンクを送信する場合、実装は、可能であれば、アウトバウンド送信キューのヘッドにあるアウトバウンドパケットにデータチャンクを配置することを選択できます。"
    },
    {
      "indent": 3,
      "text": "The 'Stream Sequence Number' field in a DATA chunk with U flag set to 1 has no significance. The sender can fill the 'Stream Sequence Number' with arbitrary value, but the receiver MUST ignore the field.",
      "ja": "Uフラグを1に設定したデータチャンクの「ストリームシーケンス番号」フィールドは重要ではありません。送信者は「ストリームシーケンス番号」を任意の値で埋めることができますが、受信者はフィールドを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: When transmitting ordered and unordered data, an endpoint does not increment its Stream Sequence Number when transmitting a DATA chunk with U flag set to 1.",
      "ja": "注：順序付きデータと順序付けられていないデータを送信すると、uフラグを1に設定してデータチャンクを送信すると、エンドポイントがストリームシーケンス番号を増加させません。"
    },
    {
      "indent": 0,
      "text": "6.7. Report Gaps in Received DATA TSNs",
      "section_title": true,
      "ja": "6.7. 受信したデータTSNSのギャップを報告します"
    },
    {
      "indent": 3,
      "text": "Upon the reception of a new DATA chunk, an endpoint examines the continuity of the TSNs received. If the endpoint detects a gap in the received DATA chunk sequence, it SHOULD send a SACK chunk with Gap Ack Blocks immediately. The data receiver continues sending a SACK chunk after receipt of each SCTP packet that does not fill the gap.",
      "ja": "新しいデータチャンクを受信すると、エンドポイントは受信したTSNの連続性を調べます。エンドポイントが受信したデータチャンクシーケンスのギャップを検出した場合、GAP ACKブロックを備えたサックチャンクをすぐに送信する必要があります。データレシーバーは、ギャップを埋めない各SCTPパケットを受け取った後、サックチャンクの送信を続けます。"
    },
    {
      "indent": 3,
      "text": "Based on the Gap Ack Block from the received SACK chunk, the endpoint can calculate the missing DATA chunks and make decisions on whether to retransmit them (see Section 6.2.1 for details).",
      "ja": "受信したサックチャンクからのギャップACKブロックに基づいて、エンドポイントは欠落データチャンクを計算し、それらを再送信するかどうかを決定することができます（詳細については、セクション6.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Multiple gaps can be reported in one single SACK chunk (see Section 3.3.4).",
      "ja": "1つのサックチャンクで複数のギャップを報告できます（セクション3.3.4を参照）。"
    },
    {
      "indent": 3,
      "text": "When its peer is multi-homed, the SCTP endpoint SHOULD always try to send the SACK chunk to the same destination address from which the last DATA chunk was received.",
      "ja": "ピアがマルチホームの場合、SCTPエンドポイントは常に、最後のデータチャンクが受信された同じ宛先アドレスにサックチャンクを送信しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon the reception of a SACK chunk, the endpoint MUST remove all DATA chunks that have been acknowledged by the SACK chunk's Cumulative TSN Ack from its transmit queue. All DATA chunks with TSNs not included in the Gap Ack Blocks that are smaller than the highest-acknowledged TSN reported in the SACK chunk MUST be treated as \"missing\" by the sending endpoint. The number of \"missing\" reports for each outstanding DATA chunk MUST be recorded by the data sender to make retransmission decisions. See Section 7.2.4 for details.",
      "ja": "サックチャンクを受信すると、エンドポイントは、送信キューからSack Chunkの累積TSN ACKによって認識されたすべてのデータチャンクを削除する必要があります。TSNSを使用したすべてのデータチャンクは、サックチャンクで報告されている最も概説された最高のTSNよりも小さいギャップACKブロックに含まれていないものを含めて、送信エンドポイントによって「欠落」として扱わなければなりません。再送信決定を行うには、データ送信者がデータ送信者によって記録する必要があります。詳細については、セクション7.2.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "The following example shows the use of SACK chunk to report a gap.",
      "ja": "次の例は、ギャップを報告するためにサックチャンクの使用を示しています。"
    },
    {
      "indent": 5,
      "text": "Endpoint A                                    Endpoint Z\n{App sends 3 messages; strm 0}\nDATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)\n(Start T3-rtx timer)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,\n                                            immediately send ack)\n                                /----- SACK [TSN Ack=6,Block=1,\n                               /             Start=2,End=2]\n                        <-----/\n(remove 6 from out-queue,\n and mark 7 as \"1\" missing report)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 9: Reporting a Gap Using SACK Chunk",
      "ja": "図9：サックチャンクを使用してギャップを報告します"
    },
    {
      "indent": 3,
      "text": "The maximum number of Gap Ack Blocks that can be reported within a single SACK chunk is limited by the current PMTU. When a single SACK chunk cannot cover all the Gap Ack Blocks needed to be reported due to the PMTU limitation, the endpoint MUST send only one SACK chunk. This single SACK chunk MUST report the Gap Ack Blocks from the lowest to highest TSNs, within the size limit set by the PMTU, and leave the remaining highest TSN numbers unacknowledged.",
      "ja": "単一のサックチャンク内で報告できるギャップACKブロックの最大数は、現在のPMTUによって制限されています。単一のサックチャンクがPMTU制限のために報告する必要があるすべてのギャップACKブロックをカバーできない場合、エンドポイントは1つのサックチャンクのみを送信する必要があります。このシングルサックチャンクは、PMTUによって設定されたサイズ制限内で、ギャップACKブロックを最低のTSNから最高のTSNSから最高のTSNSから報告し、残りの最高のTSN数を未解決のままにしておく必要があります。"
    },
    {
      "indent": 0,
      "text": "6.8. CRC32c Checksum Calculation",
      "section_title": true,
      "ja": "6.8. CRC32Cチェックサムの計算"
    },
    {
      "indent": 3,
      "text": "When sending an SCTP packet, the endpoint MUST strengthen the data integrity of the transmission by including the CRC32c checksum value calculated on the packet, as described below.",
      "ja": "SCTPパケットを送信する場合、エンドポイントは、以下に説明するように、パケットに計算されたCRC32Cチェックサム値を含めることにより、送信のデータの整合性を強化する必要があります。"
    },
    {
      "indent": 3,
      "text": "After the packet is constructed (containing the SCTP common header and one or more control or DATA chunks), the transmitter MUST:",
      "ja": "パケットが構築された後（SCTP共通ヘッダーと1つ以上の制御またはデータチャンクを含む）、送信機は以下を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "1) fill in the proper Verification Tag in the SCTP common header and initialize the checksum field to 0,",
      "ja": "1) SCTP共通ヘッダーの適切な確認タグを入力し、チェックサムフィールドを0に初期化します。"
    },
    {
      "indent": 3,
      "text": "2) calculate the CRC32c checksum of the whole packet, including the SCTP common header and all the chunks (refer to Appendix A for details of the CRC32c algorithm), and",
      "ja": "2) SCTP共通ヘッダーとすべてのチャンクを含むパケット全体のCRC32Cチェックサムを計算します（CRC32Cアルゴリズムの詳細については付録Aを参照）、および"
    },
    {
      "indent": 3,
      "text": "3) put the resultant value into the checksum field in the common header and leave the rest of the bits unchanged.",
      "ja": "3) 結果の値を共通ヘッダーのチェックサムフィールドに入れ、残りのビットを変更しておきます。"
    },
    {
      "indent": 3,
      "text": "When an SCTP packet is received, the receiver MUST first check the CRC32c checksum as follows:",
      "ja": "SCTPパケットを受信した場合、受信者は最初にCRC32Cチェックサムを次のように確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "1) Store the received CRC32c checksum value aside.",
      "ja": "1) 受信したCRC32Cチェックサム値を脇に保存します。"
    },
    {
      "indent": 3,
      "text": "2) Replace the 32 bits of the checksum field in the received SCTP packet with 0 and calculate a CRC32c checksum value of the whole received packet.",
      "ja": "2) 受信したSCTPパケットのチェックサムフィールドの32ビットを0で交換し、受信したパケット全体のCRC32Cチェックサム値を計算します。"
    },
    {
      "indent": 3,
      "text": "3) Verify that the calculated CRC32c checksum is the same as the received CRC32c checksum. If it is not, the receiver MUST treat the packet as an invalid SCTP packet.",
      "ja": "3) 計算されたCRC32Cチェックサムが受信したCRC32Cチェックサムと同じであることを確認します。そうでない場合、受信者はパケットを無効なSCTPパケットとして扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "The default procedure for handling invalid SCTP packets is to silently discard them.",
      "ja": "無効なSCTPパケットを処理するためのデフォルトの手順は、それらを静かに破棄することです。"
    },
    {
      "indent": 3,
      "text": "Any hardware implementation SHOULD permit alternative verification of the CRC in software.",
      "ja": "ハードウェアの実装では、ソフトウェア中のCRCの代替検証が可能になるはずです。"
    },
    {
      "indent": 0,
      "text": "6.9. Fragmentation and Reassembly",
      "section_title": true,
      "ja": "6.9. 断片化と再組み立て"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY support fragmentation when sending DATA chunks, but it MUST support reassembly when receiving DATA chunks. If an endpoint supports fragmentation, it MUST fragment a user message if the size of the user message to be sent causes the outbound SCTP packet size to exceed the current PMTU. An endpoint that does not support fragmentation and is requested to send a user message such that the outbound SCTP packet size would exceed the current PMTU MUST return an error to its upper layer and MUST NOT attempt to send the user message.",
      "ja": "エンドポイントは、データチャンクを送信する際の断片化をサポートする場合がありますが、データチャンクを受信するときは再組み立てをサポートする必要があります。エンドポイントがフラグメンテーションをサポートする場合、ユーザーメッセージのサイズが送信される場合、ユーザーメッセージをフラグメントする必要があります。断片化をサポートせず、アウトバウンドSCTPパケットサイズが現在のPMTUを超えるようにユーザーメッセージを送信するように要求されるエンドポイントは、エラーを上層に返す必要があり、ユーザーメッセージを送信しようとしないでください。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation MAY provide a mechanism to the upper layer that disables fragmentation when sending DATA chunks. When fragmentation of DATA chunks is disabled, the SCTP implementation MUST behave in the same way an implementation that does not support fragmentation, i.e., it rejects calls that would result in sending SCTP packets that exceed the current PMTU.",
      "ja": "SCTP実装は、データチャンクを送信するときに断片化を無効にする上層にメカニズムを提供する場合があります。データチャンクの断片化が無効になっている場合、SCTP実装は、断片化をサポートしない実装と同じように動作する必要があります。つまり、現在のPMTUを超えるSCTPパケットを送信する呼び出しを拒否します。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: In this error case, the SEND primitive discussed in Section 11.1.5 would need to return an error to the upper layer.",
      "ja": "実装注：このエラーの場合、セクション11.1.5で説明されている原始的な送信は、エラーを上層に返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If its peer is multi-homed, the endpoint SHOULD choose a DATA chunk size smaller than or equal to the AMDCS.",
      "ja": "ピアがマルチホームの場合、エンドポイントはAMDCよりも小さいデータチャンクサイズを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once a user message is fragmented, it cannot be re-fragmented. Instead, if the PMTU has been reduced, then IP fragmentation MUST be used. Therefore, an SCTP association can fail if IP fragmentation is not working on any path. Please see Section 7.3 for details of PMTU discovery.",
      "ja": "ユーザーメッセージが断片化されると、再燃することはできません。代わりに、PMTUが削減された場合、IPフラグメンテーションを使用する必要があります。したがって、IPの断片化がどのパスでも機能していない場合、SCTP関連は失敗する可能性があります。PMTU発見の詳細については、セクション7.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "When determining when to fragment, the SCTP implementation MUST take into account the SCTP packet header as well as the DATA chunk header(s). The implementation MUST also take into account the space required for a SACK chunk if bundling a SACK chunk with the DATA chunk.",
      "ja": "いつ断片化するかを決定するとき、SCTP実装では、SCTPパケットヘッダーとデータチャンクヘッダーを考慮する必要があります。また、データチャンクにサックチャンクをバンドする場合、サックチャンクに必要なスペースを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Fragmentation takes the following steps:",
      "ja": "フラグメンテーションは次の手順を実行します。"
    },
    {
      "indent": 3,
      "text": "1) The data sender MUST break the user message into a series of DATA chunks. The sender SHOULD choose a size of DATA chunks that is smaller than or equal to the AMDCS.",
      "ja": "1) データ送信者は、ユーザーメッセージを一連のデータチャンクに分割する必要があります。送信者は、AMDCよりも小さいデータチャンクのサイズを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "2) The transmitter MUST then assign, in sequence, a separate TSN to each of the DATA chunks in the series. The transmitter assigns the same Stream Sequence Number to each of the DATA chunks. If the user indicates that the user message is to be delivered using unordered delivery, then the U flag of each DATA chunk of the user message MUST be set to 1.",
      "ja": "2) 送信機は、シリーズの各データチャンクに個別のTSNを順番に割り当てる必要があります。送信機は、各データチャンクに同じストリームシーケンス番号を割り当てます。ユーザーがユーザーメッセージを順序の配信を使用して配信することを示している場合、ユーザーメッセージの各データチャンクのUフラグを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "3) The transmitter MUST also set the B/E bits of the first DATA chunk in the series to 10, the B/E bits of the last DATA chunk in the series to 01, and the B/E bits of all other DATA chunks in the series to 00.",
      "ja": "3) トランスミッターは、シリーズの最初のデータチャンクのB/Eビットを10に、シリーズの最後のデータチャンクのB/Eビットを01に設定する必要があります。シリーズ00。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST recognize fragmented DATA chunks by examining the B/ E bits in each of the received DATA chunks and queue the fragmented DATA chunks for reassembly. Once the user message is reassembled, SCTP passes the reassembled user message to the specific stream for possible reordering and final dispatching.",
      "ja": "エンドポイントは、受信した各データチャンクのB/ Eビットを調べることにより、断片化されたデータチャンクを認識し、再組み立てのために断片化されたデータチャンクをキューにキューする必要があります。ユーザーメッセージが再組み立てされると、SCTPは、並べ替えと最終的なディスパッチの可能性のために、特定のストリームに再構築されたユーザーメッセージを渡します。"
    },
    {
      "indent": 3,
      "text": "If the data receiver runs out of buffer space while still waiting for more fragments to complete the reassembly of the message, it SHOULD dispatch part of its inbound message through a partial delivery API (see Section 11), freeing some of its receive buffer space so that the rest of the message can be received.",
      "ja": "データの受信機がバッファスペースを使い果たしている間、メッセージの再組み立てを完了するためのより多くのフラグメントがまだ待機している場合、部分配信APIを介してインバウンドメッセージの一部を発送する必要があります（セクション11を参照）、受信バッファースペースの一部を解放する必要があります。メッセージの残りの部分を受信できること。"
    },
    {
      "indent": 0,
      "text": "6.10. Bundling",
      "section_title": true,
      "ja": "6.10. バンドリング"
    },
    {
      "indent": 3,
      "text": "An endpoint bundles chunks by simply including multiple chunks in one outbound SCTP packet. The total size of the resultant SCTP packet MUST be less that or equal to the current PMTU.",
      "ja": "エンドポイントは、1つのアウトバウンドSCTPパケットに複数のチャンクを含めるだけでチャンクをバンドルします。結果のSCTPパケットの合計サイズは、現在のPMTUと等しくなる必要があります。"
    },
    {
      "indent": 3,
      "text": "If its peer endpoint is multi-homed, the sending endpoint SHOULD choose a size no larger than the PMTU of the current primary path.",
      "ja": "ピアエンドポイントがマルチホームの場合、送信エンドポイントは、現在のプライマリパスのPMTUより大きいサイズを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "When bundling control chunks with DATA chunks, an endpoint MUST place control chunks first in the outbound SCTP packet. The transmitter MUST transmit DATA chunks within an SCTP packet in increasing order of TSN.",
      "ja": "データチャンクでコントロールチャンクをバンドルするとき、エンドポイントは、最初にアウトバウンドSCTPパケットにコントロールチャンクを配置する必要があります。送信機は、TSNの順序を増やしてSCTPパケット内でデータチャンクを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Since control chunks are placed first in a packet and since DATA chunks are transmitted before SHUTDOWN or SHUTDOWN ACK chunks, DATA chunks cannot be bundled with SHUTDOWN or SHUTDOWN ACK chunks.",
      "ja": "注：コントロールチャンクは最初にパケットに配置され、データチャンクがシャットダウンまたはシャットダウンACKチャンクの前に送信されるため、データチャンクをシャットダウンまたはシャットダウンACKチャンクにバンドルすることはできません。"
    },
    {
      "indent": 3,
      "text": "Partial chunks MUST NOT be placed in an SCTP packet. A partial chunk is a chunk that is not completely contained in the SCTP packet; i.e., the SCTP packet is too short to contain all the bytes of the chunk as indicated by the chunk length.",
      "ja": "部分的なチャンクをSCTPパケットに入れてはいけません。部分的なチャンクは、SCTPパケットに完全に含まれていないチャンクです。つまり、SCTPパケットは、チャンクの長さで示されるように、チャンクのすべてのバイトを封じ込めるには短すぎます。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST process received chunks in their order in the packet. The receiver uses the Chunk Length field to determine the end of a chunk and beginning of the next chunk, taking account of the fact that all chunks end on a 4-byte boundary. If the receiver detects a partial chunk, it MUST drop the chunk.",
      "ja": "エンドポイントは、パケットで受信したチャンクを処理する必要があります。レシーバーは、チャンク長フィールドを使用して、すべてのチャンクが4バイトの境界で終わるという事実を考慮して、チャンクの終わりと次のチャンクの始まりを決定します。受信機が部分チャンクを検出した場合、チャンクをドロップする必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT bundle INIT, INIT ACK, or SHUTDOWN COMPLETE chunks with any other chunks.",
      "ja": "エンドポイントは、init、init ack、またはシャットダウンを他のチャンクで完全に束ねてはいけません。"
    },
    {
      "indent": 0,
      "text": "7. Congestion Control",
      "section_title": true,
      "ja": "7. 混雑制御"
    },
    {
      "indent": 3,
      "text": "Congestion control is one of the basic functions in SCTP. To manage congestion, the mechanisms and algorithms in this section are to be employed.",
      "ja": "混雑制御は、SCTPの基本機能の1つです。輻輳を管理するために、このセクションのメカニズムとアルゴリズムを採用します。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: As far as its specific performance requirements are met, an implementation is always allowed to adopt a more conservative congestion control algorithm than the one defined below.",
      "ja": "実装注：特定のパフォーマンス要件が満たされている限り、実装は常に、以下に定義されているものよりも保守的な混雑制御アルゴリズムを採用することが許可されています。"
    },
    {
      "indent": 3,
      "text": "The congestion control algorithms used by SCTP are based on [RFC5681]. This section describes how the algorithms defined in [RFC5681] are adapted for use in SCTP. We first list differences in protocol designs between TCP and SCTP and then describe SCTP's congestion control scheme. The description will use the same terminology as in TCP congestion control whenever appropriate.",
      "ja": "SCTPで使用される混雑制御アルゴリズムは、[RFC5681]に基づいています。このセクションでは、[RFC5681]で定義されているアルゴリズムがSCTPで使用するためにどのように適合しているかについて説明します。最初に、TCPとSCTPの間のプロトコル設計の違いをリストし、SCTPの混雑制御スキームを説明します。この説明は、適切な場合はいつでもTCP混雑制御と同じ用語を使用します。"
    },
    {
      "indent": 3,
      "text": "SCTP congestion control is always applied to the entire association and not to individual streams.",
      "ja": "SCTP混雑制御は、個々のストリームではなく、常に関連性全体に適用されます。"
    },
    {
      "indent": 0,
      "text": "7.1. SCTP Differences from TCP Congestion Control",
      "section_title": true,
      "ja": "7.1. TCP混雑制御とのSCTPの違い"
    },
    {
      "indent": 3,
      "text": "Gap Ack Blocks in the SCTP SACK chunk carry the same semantic meaning as the TCP SACK. TCP considers the information carried in the SACK as advisory information only. SCTP considers the information carried in the Gap Ack Blocks in the SACK chunk as advisory. In SCTP, any DATA chunk that has been acknowledged by a SACK chunk, including DATA that arrived at the receiving end out of order, is not considered fully delivered until the Cumulative TSN Ack Point passes the TSN of the DATA chunk (i.e., the DATA chunk has been acknowledged by the Cumulative TSN Ack field in the SACK chunk). Consequently, the value of cwnd controls the amount of outstanding data, rather than (as in the case of non-SACK TCP) the upper bound between the highest acknowledged sequence number and the latest DATA chunk that can be sent within the congestion window. SCTP SACK leads to different implementations of Fast Retransmit and Fast Recovery than non-SACK TCP. As an example, see [FALL96].",
      "ja": "SCTPサックチャンクのギャップACKブロックは、TCPサックと同じ意味の意味を持ちます。TCPは、袋に掲載された情報をアドバイザリー情報のみと見なします。SCTPは、サックチャンク内のギャップACKブロックにある情報をアドバイザリーと見なします。SCTPでは、受信側に到達したデータを含むサックチャンクによって認識されたデータチャンクは、累積TSN ACKポイントがデータチャンクのTSNを通過するまで完全に配信されるとは見なされません（つまり、データはデータになります。チャンクは、サックチャンクの累積TSN ACKフィールドによって認められています）。したがって、CWNDの値は、（非サックTCPの場合のように）最高の確認されたシーケンス番号と輻輳ウィンドウ内で送信できる最新のデータチャンクの間の上限ではなく、未解決のデータの量を制御します。SCTPサックは、非サックTCPとは異なる高速再送信および高速回復の実装につながります。例として、[fall96]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The biggest difference between SCTP and TCP, however, is multi-homing. SCTP is designed to establish robust communication associations between two endpoints, each of which might be reachable by more than one transport address. Potentially different addresses might lead to different data paths between the two endpoints; thus, ideally, one needs a separate set of congestion control parameters for each of the paths. The treatment here of congestion control for multi-homed receivers is new with SCTP and might require refinement in the future. The current algorithms make the following assumptions:",
      "ja": "ただし、SCTPとTCPの最大の違いは、マルチホミングです。SCTPは、2つのエンドポイント間に堅牢な通信関連を確立するように設計されており、それぞれが複数の輸送住所によって到達可能になる可能性があります。潜在的に異なるアドレスは、2つのエンドポイント間で異なるデータパスにつながる可能性があります。したがって、理想的には、各パスに対して個別の混雑制御パラメーターが必要です。マルチホームの受信機の輻輳制御のここでの治療は、SCTPで新しく、将来的に改良が必要になる場合があります。現在のアルゴリズムは、次の仮定を作成します。"
    },
    {
      "indent": 3,
      "text": "* The sender usually uses the same destination address until being instructed by the upper layer to do otherwise; however, SCTP MAY change to an alternate destination in the event an address is marked inactive (see Section 8.2). Also, SCTP MAY retransmit to a different transport address than the original transmission.",
      "ja": "* 送信者は通常、上層層によって指示されるまで同じ宛先アドレスを使用します。ただし、SCTPは、アドレスが非アクティブであるとマークされている場合の代替宛先に変更される場合があります（セクション8.2を参照）。また、SCTPは、元の送信とは異なる輸送アドレスに再送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "* The sender keeps a separate congestion control parameter set for each of the destination addresses it can send to (not each source-destination pair but for each destination). The parameters SHOULD decay if the address is not used for a long enough time period. [RFC5681] specifies this period of time as a retransmission timeout.",
      "ja": "* 送信者は、送信できる宛先アドレスごとに個別の輻輳制御パラメーターセットを保持します（各ソース照明ペアではなく、各宛先に対して）。アドレスが十分に長い期間使用されない場合、パラメーターは減衰する必要があります。[RFC5681]この期間を再送信タイムアウトとして指定します。"
    },
    {
      "indent": 3,
      "text": "* For each of the destination addresses, an endpoint does slow start upon the first transmission to that address.",
      "ja": "* 宛先アドレスのそれぞれについて、エンドポイントはそのアドレスへの最初の送信からの開始が遅くなります。"
    },
    {
      "indent": 3,
      "text": "Note: TCP guarantees in-sequence delivery of data to its upper-layer protocol within a single TCP session. This means that when TCP notices a gap in the received sequence number, it waits until the gap is filled before delivering the data that was received with sequence numbers higher than that of the missing data. On the other hand, SCTP can deliver data to its upper-layer protocol, even if there is a gap in TSN if the Stream Sequence Numbers are in sequence for a particular stream (i.e., the missing DATA chunks are for a different stream) or if unordered delivery is indicated. Although this does not affect cwnd, it might affect rwnd calculation.",
      "ja": "注：TCPは、単一のTCPセッション内での上層層プロトコルへのデータの配列配信を保証します。これは、TCPが受信したシーケンス番号のギャップに気付いた場合、ギャップが入力されるまで待機してから、欠落データのシーケンス番号よりも高いシーケンス番号で受信したデータを配信することを意味します。一方、SCTPは、特定のストリームのストリームシーケンス番号がシーケンスにある場合にTSNにギャップがある場合でも、上層層プロトコルにデータを配信できます（つまり、欠落データチャンクは異なるストリーム用です）または順序付けられていない配達が示されている場合。これはCWNDには影響しませんが、RWND計算に影響する可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.2. SCTP Slow-Start and Congestion Avoidance",
      "section_title": true,
      "ja": "7.2. SCTPスロースタートおよび混雑回避"
    },
    {
      "indent": 3,
      "text": "The slow-start and congestion avoidance algorithms MUST be used by an endpoint to control the amount of data being injected into the network. The congestion control in SCTP is employed in regard to the association, not to an individual stream. In some situations, it might be beneficial for an SCTP sender to be more conservative than the algorithms allow; however, an SCTP sender MUST NOT be more aggressive than the following algorithms allow.",
      "ja": "スロースタートおよび輻輳回避アルゴリズムは、ネットワークに注入されるデータの量を制御するためにエンドポイントで使用する必要があります。SCTPの混雑制御は、個々のストリームではなく、関連付けに関して採用されています。状況によっては、SCTP送信者がアルゴリズムが許可するよりも保守的であることが有益かもしれません。ただし、SCTP送信者は、次のアルゴリズムが許可するよりも攻撃的であってはなりません。"
    },
    {
      "indent": 3,
      "text": "Like TCP, an SCTP endpoint uses the following three control variables to regulate its transmission rate.",
      "ja": "TCPと同様に、SCTPエンドポイントは次の3つの制御変数を使用して、その伝送速度を調節します。"
    },
    {
      "indent": 3,
      "text": "* Receiver advertised window size (rwnd, in bytes), which is set by the receiver based on its available buffer space for incoming packets.",
      "ja": "* 受信機は、窓のサイズ（RWND、バイト）を宣伝しました。これは、着信パケット用の利用可能なバッファースペースに基づいて受信機によって設定されています。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is kept on the entire association.",
      "ja": "注：この変数は、関連性全体に保持されます。"
    },
    {
      "indent": 3,
      "text": "* Congestion control window (cwnd, in bytes), which is adjusted by the sender based on observed network conditions.",
      "ja": "* 輻輳制御ウィンドウ（CWND、バイト）。これは、観測されたネットワーク条件に基づいて送信者によって調整されます。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is maintained on a per-destination-address basis.",
      "ja": "注：この変数は、命令ごとに維持されます。"
    },
    {
      "indent": 3,
      "text": "* Slow-start threshold (ssthresh, in bytes), which is used by the sender to distinguish slow-start and congestion avoidance phases.",
      "ja": "* スロースタートしきい値（SSThresh、inバイト）。これは、スロースタートと輻輳の回避フェーズを区別するために送信者が使用します。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is maintained on a per-destination-address basis.",
      "ja": "注：この変数は、命令ごとに維持されます。"
    },
    {
      "indent": 3,
      "text": "SCTP also requires one additional control variable, partial_bytes_acked, which is used during the congestion avoidance phase to facilitate cwnd adjustment.",
      "ja": "SCTPには、CWND調整を容易にするために混雑回避段階で使用される追加の制御変数Partial_bytes_ackedも必要です。"
    },
    {
      "indent": 3,
      "text": "Unlike TCP, an SCTP sender MUST keep a set of the control variables cwnd, ssthresh, and partial_bytes_acked for EACH destination address of its peer (when its peer is multi-homed). When calculating one of these variables, the length of the DATA chunk, including the padding, SHOULD be used.",
      "ja": "TCPとは異なり、SCTP送信者は、ピアの各宛先アドレスに対してCWND、SSTHRESH、およびpartial_bytes_ackedのコントロール変数のセットを保持する必要があります（ピアがマルチホームの場合）。これらの変数のいずれかを計算する場合、パディングを含むデータチャンクの長さを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Only one rwnd is kept for the whole association (no matter if the peer is multi-homed or has a single address).",
      "ja": "協会全体に1つのRWNDのみが保持されています（ピアがマルチホームであるか、単一のアドレスがあるかに関係なく）。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Slow-Start",
      "section_title": true,
      "ja": "7.2.1. スロースタート"
    },
    {
      "indent": 3,
      "text": "Beginning data transmission into a network with unknown conditions or after a sufficiently long idle period requires SCTP to probe the network to determine the available capacity. The slow-start algorithm is used for this purpose at the beginning of a transfer or after repairing loss detected by the retransmission timer.",
      "ja": "未知の条件のあるネットワークへのデータ送信を開始するか、十分に長いアイドル期間を経て、SCTPがネットワークをプローブして利用可能な容量を決定する必要があります。スロースタートアルゴリズムは、転送の開始時または再送信タイマーによって検出された損失の修復後にこの目的に使用されます。"
    },
    {
      "indent": 3,
      "text": "* The initial cwnd before data transmission MUST be set to min(4 * PMDCS, max(2 * PMDCS, 4404)) bytes if the peer address is an IPv4 address and to min(4 * PMDCS, max(2 * PMDCS, 4344)) bytes if the peer address is an IPv6 address.",
      "ja": "* ピアアドレスがIPv4アドレスであり最小（4 * PMDCS、MAX（2 * PMDCS、4344）である場合、データ送信前の最初のCWNDは最小（4 * PMDCS、MAX（2 * PMDCS、4404））バイトに設定する必要があります。）ピアアドレスがIPv6アドレスの場合、バイテス。"
    },
    {
      "indent": 3,
      "text": "* The initial cwnd after a retransmission timeout MUST be no more than PMDCS, and only one packet is allowed to be in flight until successful acknowledgement.",
      "ja": "* 再送信タイムアウト後の最初のCWNDはPMDCに過ぎない必要があり、成功するまで1つのパケットが飛行中に許可されている必要があります。"
    },
    {
      "indent": 3,
      "text": "* The initial value of ssthresh SHOULD be arbitrarily high (e.g., the size of the largest-possible advertised window).",
      "ja": "* SSthreshの初期値は、任意に高くする必要があります（たとえば、最大の広告ウィンドウのサイズ）。"
    },
    {
      "indent": 3,
      "text": "* Whenever cwnd is greater than zero, the endpoint is allowed to have cwnd bytes of data outstanding on that transport address. A limited overbooking as described in rule B in Section 6.1 SHOULD be supported.",
      "ja": "* CWNDがゼロを超える場合はいつでも、エンドポイントは、その輸送アドレスにCWNDバイトのデータを発行することが許可されています。セクション6.1のルールBで説明されている限られたオーバーブッキングをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "* When cwnd is less than or equal to ssthresh, an SCTP endpoint MUST use the slow-start algorithm to increase cwnd only if the current congestion window is being fully utilized and the data sender is not in Fast Recovery. Only when these two conditions are met can the cwnd be increased; otherwise, the cwnd MUST NOT be increased. If these conditions are met, then cwnd MUST be increased by, at most, the lesser of",
      "ja": "* CWNDがSSTHRESHよりも低い場合、SCTPエンドポイントはスロースタートアルゴリズムを使用してCWNDを増加させる必要があります。これらの2つの条件が満たされた場合にのみ、CWNDを増やすことができます。それ以外の場合、CWNDを増やしてはなりません。これらの条件が満たされている場合、CWNDはせいぜい、より少ないほど増加する必要があります"
    },
    {
      "indent": 6,
      "text": "1. the total size of the previously outstanding DATA chunk(s) acknowledged and",
      "ja": "1. 以前に顕著なデータチャンクの合計サイズが認められ、"
    },
    {
      "indent": 6,
      "text": "2. L times the destination's PMDCS.",
      "ja": "2. lは目的地のPMDCを使用します。"
    },
    {
      "indent": 6,
      "text": "The first upper bound protects against the ACK-Splitting attack outlined in [SAVAGE99]. The positive integer L SHOULD be 1 and MAY be larger than 1. See [RFC3465] for details of choosing L.",
      "ja": "最初の上限は、[savage99]で概説されているACK分割攻撃から保護します。正の整数Lは1であり、1より大きい場合があります。"
    },
    {
      "indent": 6,
      "text": "In instances where its peer endpoint is multi-homed, if an endpoint receives a SACK chunk that results in updating the cwnd, then it SHOULD update its cwnd (or cwnds) apportioned to the destination addresses to which it transmitted the acknowledged data.",
      "ja": "ピアエンドポイントがマルチホームになっている場合、エンドポイントがCWNDを更新するサックチャンクを受信する場合、認められたデータを送信した宛先アドレスに配分されたCWND（またはCWND）を更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "* While the endpoint does not transmit data on a given transport address, the cwnd of the transport address SHOULD be adjusted to max(cwnd / 2, 4 * PMDCS) once per RTO. Before the first cwnd adjustment, the ssthresh of the transport address SHOULD be set to the cwnd.",
      "ja": "* エンドポイントは特定の輸送アドレスにデータを送信しませんが、輸送アドレスのCWNDは、RTOごとに1回MAX（CWND / 2、4 * PMDCS）に調整する必要があります。最初のCWND調整の前に、輸送アドレスのsSthreshをCWNDに設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Congestion Avoidance",
      "section_title": true,
      "ja": "7.2.2. 混雑回避"
    },
    {
      "indent": 3,
      "text": "When cwnd is greater than ssthresh, cwnd SHOULD be incremented by PMDCS per RTT if the sender has cwnd or more bytes of data outstanding for the corresponding transport address. The basic recommendations for incrementing cwnd during congestion avoidance are as follows:",
      "ja": "CWNDがSSTHRESHよりも大きい場合、送信者が対応するトランスポートアドレスに対してCWND以上のデータのバイト以上のバイトを持っている場合、CWNDはRTTあたりPMDCによって増加する必要があります。混雑回避中にCWNDを増やすための基本的な推奨事項は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* SCTP MAY increment cwnd by PMDCS.",
      "ja": "* SCTPは、PMDCSによってCWNDを増加させる場合があります。"
    },
    {
      "indent": 3,
      "text": "* SCTP SHOULD increment cwnd by PMDCS once per RTT when the sender has cwnd or more bytes of data outstanding for the corresponding transport address.",
      "ja": "* SCTPは、送信者が対応するトランスポートアドレスに対してCWND以上のデータのバイト以上のバイトを持っている場合、RTTごとに1回PMDCによってCWNDを増分する必要があります。"
    },
    {
      "indent": 3,
      "text": "* SCTP MUST NOT increment cwnd by more than PMDCS per RTT.",
      "ja": "* SCTPは、RTTごとにPMDCを超えることでCWNDを増加させてはなりません。"
    },
    {
      "indent": 3,
      "text": "In practice, an implementation can achieve this goal in the following way:",
      "ja": "実際には、実装は次の方法でこの目標を達成できます。"
    },
    {
      "indent": 3,
      "text": "* partial_bytes_acked is initialized to 0.",
      "ja": "* partial_bytes_ackedは0に初期化されます。"
    },
    {
      "indent": 3,
      "text": "* Whenever cwnd is greater than ssthresh, upon each SACK chunk arrival, increase partial_bytes_acked by the total number of bytes (including the chunk header and the padding) of all new DATA chunks acknowledged in that SACK chunk, including chunks acknowledged by the new Cumulative TSN Ack, by Gap Ack Blocks, and by the number of bytes of duplicated chunks reported in Duplicate TSNs.",
      "ja": "* CWNDがSSTHRESHよりも大きいときはいつでも、各袋のチャンク到着時に、パルティアル_BYTES_ACKEDを増やします（チャンクヘッダーとパディングを含む）すべての新しいデータチャンクのバイトの総数（チャンクヘッダーを含む）は、新しい累積TSN ACKによって認められたチャンクを含む、そのサックチャンクで認められています。、ギャップACKブロック、および重複TSNSで報告された重複したチャンクのバイト数によって。"
    },
    {
      "indent": 3,
      "text": "* When (1) partial_bytes_acked is greater than cwnd and (2) before the arrival of the SACK chunk the sender had less than cwnd bytes of data outstanding (i.e., before the arrival of the SACK chunk, flightsize was less than cwnd), reset partial_bytes_acked to cwnd.",
      "ja": "* （1）partial_bytes_ackedがCWNDよりも大きく、（2）サックチャンクの到着前に、送信者はCWNDのバイト未満のデータを未払いの場合（つまり、サックチャンクの到着前に、フライトサイズがCWND未満でした）、Partial_bytes_acked_ackedededcwndへ。"
    },
    {
      "indent": 3,
      "text": "* When (1) partial_bytes_acked is equal to or greater than cwnd and (2) before the arrival of the SACK chunk the sender had cwnd or more bytes of data outstanding (i.e., before the arrival of the SACK chunk, flightsize was greater than or equal to cwnd), partial_bytes_acked is reset to (partial_bytes_acked - cwnd). Next, cwnd is increased by PMDCS.",
      "ja": "* （1）partial_bytes_ackedがcwnd以上であり、（2）サックチャンクの到着前に（2）送信者はCWND以上のバイトのデータが未解決のデータを持っていた場合（つまり、サックチャンクの到着前に、フライトサイズは大きかったか等でしたcwndに）、partial_bytes_ackedは（partial_bytes_acked -cwnd）にリセットされます。次に、CWNDはPMDCSによって増加します。"
    },
    {
      "indent": 3,
      "text": "* Same as in the slow start, when the sender does not transmit DATA chunks on a given transport address, the cwnd of the transport address SHOULD be adjusted to max(cwnd / 2, 4 * PMDCS) per RTO.",
      "ja": "* スロースタートと同じように、送信者が特定の輸送アドレスでデータチャンクを送信しない場合、輸送アドレスのCWNDは、RTOごとにMAX（CWND / 2、4 * PMDCS）に調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "* When all of the data transmitted by the sender has been acknowledged by the receiver, partial_bytes_acked is initialized to 0.",
      "ja": "* 送信者によって送信されるすべてのデータが受信機によって認められている場合、partial_bytes_ackedは0に初期化されます。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Congestion Control",
      "section_title": true,
      "ja": "7.2.3. 混雑制御"
    },
    {
      "indent": 3,
      "text": "Upon detection of packet losses from SACK chunks (see Section 7.2.4), an endpoint SHOULD do the following:",
      "ja": "サックチャンクからのパケット損失を検出すると（セクション7.2.4を参照）、エンドポイントは次のことを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "ssthresh = max(cwnd / 2, 4 * PMDCS)\ncwnd = ssthresh\npartial_bytes_acked = 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Basically, a packet loss causes cwnd to be cut in half.",
      "ja": "基本的に、パケットの損失により、CWNDが半分に削減されます。"
    },
    {
      "indent": 3,
      "text": "When the T3-rtx timer expires on an address, SCTP SHOULD perform slow start by:",
      "ja": "T3-RTXタイマーがアドレスで期限切れになると、SCTPは次のようにスロースタートを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "ssthresh = max(cwnd / 2, 4 * PMDCS)\ncwnd = PMDCS\npartial_bytes_acked = 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and ensure that no more than one SCTP packet will be in flight for that address until the endpoint receives acknowledgement for successful delivery of data to that address.",
      "ja": "また、エンドポイントがそのアドレスへの成功したデータの配信の認識を受け取るまで、そのアドレスのSCTPパケットが1つしか飛行しないようにします。"
    },
    {
      "indent": 0,
      "text": "7.2.4. Fast Retransmit on Gap Reports",
      "section_title": true,
      "ja": "7.2.4. ギャップレポートの高速再送信"
    },
    {
      "indent": 3,
      "text": "In the absence of data loss, an endpoint performs delayed acknowledgement. However, whenever an endpoint notices a hole in the arriving TSN sequence, it SHOULD start sending a SACK chunk back every time a packet arrives carrying data until the hole is filled.",
      "ja": "データの損失がない場合、エンドポイントは遅延承認を実行します。ただし、エンドポイントが到着するTSNシーケンスの穴に気付いたときはいつでも、パケットが穴を開けるまでパケットが届くたびにサックチャンクの送信を開始するはずです。"
    },
    {
      "indent": 3,
      "text": "Whenever an endpoint receives a SACK chunk that indicates that some TSNs are missing, it SHOULD wait for two further miss indications (via subsequent SACK chunks for a total of three missing reports) on the same TSNs before taking action with regard to Fast Retransmit.",
      "ja": "一部のTSNが欠落していることを示すエンドポイントがサックチャンクを受け取るときはいつでも、同じTSNでさらに2つのミス適応症（その後の3つのサックチャンクを介して）を待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "Miss indications SHOULD follow the Highest TSN Newly Acknowledged (HTNA) algorithm. For each incoming SACK chunk, miss indications are incremented only for missing TSNs prior to the HTNA in the SACK chunk. A newly acknowledged DATA chunk is one not previously acknowledged in a SACK chunk. If an endpoint is in Fast Recovery and a SACK chunks arrives that advances the Cumulative TSN Ack Point, the miss indications are incremented for all TSNs reported missing in the SACK chunk.",
      "ja": "ミス適応症は、新たに認められた（HTNA）アルゴリズムの最高のTSNに従う必要があります。入ってくる各サックチャンクについて、ミスの表示は、サックチャンクのHTNAの前に欠落しているTSNSのみで増加します。新たに認められたデータチャンクは、サックチャンクで以前に認められていなかったものです。エンドポイントが急速に回復し、累積TSN ACKポイントを前進させるサックチャンクが到着すると、サックチャンクで失われたすべてのTSNについてミス適応症が増加します。"
    },
    {
      "indent": 3,
      "text": "When the third consecutive miss indication is received for one or more TSNs, the data sender does the following:",
      "ja": "1つ以上のTSNに対して3回連続のミス表示が受信されると、データ送信者は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1) Mark the DATA chunk(s) with three miss indications for retransmission.",
      "ja": "1) 再送信のための3つのミス適応症でデータチャンクをマークします。"
    },
    {
      "indent": 3,
      "text": "2) If not in Fast Recovery, adjust the ssthresh and cwnd of the destination address(es) to which the missing DATA chunks were last sent, according to the formula described in Section 7.2.3.",
      "ja": "2) 迅速な回復がない場合は、セクション7.2.3で説明した式に従って、欠落データチャンクが最後に送信された宛先アドレス（ES）のSSTHRESHとCWNDを調整します。"
    },
    {
      "indent": 3,
      "text": "3) If not in Fast Recovery, determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the PMTU of the destination transport address to which the packet is being sent. Call this value K. Retransmit those K DATA chunks in a single packet. When a Fast Retransmit is being performed, the sender SHOULD ignore the value of cwnd and SHOULD NOT delay retransmission for this single packet.",
      "ja": "3) 迅速な回復がない場合は、再送信のためにマークされた最古の（つまり、最低のTSN）データチャンクが単一のパケットに適合するものの数を決定します。この値Kを呼び出します。1つのパケットでこれらのKデータチャンクを再送信します。高速再送信が実行されている場合、送信者はCWNDの値を無視し、この単一のパケットの再送信を遅らせないでください。"
    },
    {
      "indent": 3,
      "text": "4) Restart the T3-rtx timer only if the last SACK chunk acknowledged the lowest outstanding TSN number sent to that address or the endpoint is retransmitting the first outstanding DATA chunk sent to that address.",
      "ja": "4) T3-RTXタイマーを再起動します。最後のSack Chunkがそのアドレスに送信された最低の優れたTSN番号を認めた場合、またはエンドポイントがそのアドレスに送信された最初の未解決のデータチャンクを再送信します。"
    },
    {
      "indent": 3,
      "text": "5) Mark the DATA chunk(s) as being fast retransmitted and thus ineligible for a subsequent Fast Retransmit. Those TSNs marked for retransmission due to the Fast-Retransmit algorithm that did not fit in the sent datagram carrying K other TSNs are also marked as ineligible for a subsequent Fast Retransmit. However, as they are marked for retransmission, they will be retransmitted later on as soon as cwnd allows.",
      "ja": "5) データチャンクを迅速に再送信しているため、その後の高速再送信の資格がないとマークします。他のTSNを運ぶ送信されたデータグラムに適合しなかった高速再送信アルゴリズムのために、再送信のためにマークされたこれらのTSNは、その後の高速再送信の資格がないとマークされています。ただし、再送信のためにマークされているため、CWNDが許すとすぐに再送信されます。"
    },
    {
      "indent": 3,
      "text": "6) If not in Fast Recovery, enter Fast Recovery and mark the highest outstanding TSN as the Fast Recovery exit point. When a SACK chunk acknowledges all TSNs up to and including this exit point, Fast Recovery is exited. While in Fast Recovery, the ssthresh and cwnd SHOULD NOT change for any destinations due to a subsequent Fast Recovery event (i.e., one SHOULD NOT reduce the cwnd further due to a subsequent Fast Retransmit).",
      "ja": "6) 迅速な回復がない場合は、高速回復を入力し、最高の優れたTSNを高速回復出口ポイントとしてマークします。Sack Chunkがこの出口ポイントまでのすべてのTSNを認識すると、高速回復が終了します。速い回復中、SSthreshとCWNDは、その後の速い回復イベントのために目的地の変更を変更してはなりません（つまり、その後の速い再送信のためにCWNDをさらに減らすべきではありません）。"
    },
    {
      "indent": 3,
      "text": "Note: Before the above adjustments, if the received SACK chunk also acknowledges new DATA chunks and advances the Cumulative TSN Ack Point, the cwnd adjustment rules defined in Sections 7.2.1 and 7.2.2 MUST be applied first.",
      "ja": "注：上記の調整の前に、受信したSack Chunkが新しいデータチャンクを認め、累積TSN ACKポイントを前進させる場合、セクション7.2.1および7.2.2で定義されているCWND調整ルールを最初に適用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5. Reinitialization",
      "section_title": true,
      "ja": "7.2.5. 再初期化"
    },
    {
      "indent": 3,
      "text": "During the lifetime of an SCTP association, events can happen that result in using the network under unknown new conditions. When detected by an SCTP implementation, the congestion control MUST be reinitialized.",
      "ja": "SCTP協会の寿命の間に、未知の新しい条件下でネットワークを使用するイベントが発生する可能性があります。SCTP実装によって検出される場合、混雑制御を再活性化する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5.1. Change of Differentiated Services Code Points",
      "section_title": true,
      "ja": "7.2.5.1. 差別化されたサービスコードポイントの変更"
    },
    {
      "indent": 3,
      "text": "SCTP implementations MAY allow an application to configure the Differentiated Services Code Point (DSCP) used for sending packets. If a DSCP change might result in outgoing packets being queued in different queues, the congestion control parameters for all affected destination addresses MUST be reset to their initial values.",
      "ja": "SCTP実装により、アプリケーションはパケットの送信に使用される差別化されたサービスコードポイント（DSCP）を構成することができます。DSCPの変更により、異なるキューで発信パケットがキューになっている可能性がある場合、影響を受けるすべての宛先アドレスの輻輳制御パラメーターは、初期値にリセットする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5.2. Change of Routes",
      "section_title": true,
      "ja": "7.2.5.2. ルートの変更"
    },
    {
      "indent": 3,
      "text": "SCTP implementations MAY be aware of routing changes affecting packets sent to a destination address. In particular, this includes the selection of a different source address used for sending packets to a destination address. If such a routing change happens, the congestion control parameters for the affected destination addresses MUST be reset to their initial values.",
      "ja": "SCTPの実装は、宛先アドレスに送信されるパケットに影響を与えるルーティングの変更を認識している場合があります。特に、これには、宛先アドレスにパケットを送信するために使用される別のソースアドレスの選択が含まれます。このようなルーティングの変更が発生した場合、影響を受ける宛先アドレスの輻輳制御パラメーターは、初期値にリセットする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3. PMTU Discovery",
      "section_title": true,
      "ja": "7.3. PMTUディスカバリー"
    },
    {
      "indent": 3,
      "text": "[RFC8899], [RFC8201], and [RFC1191] specify \"Packetization Layer Path MTU Discovery\", whereby an endpoint maintains an estimate of PMTU along a given Internet path and refrains from sending packets along that path that exceed the PMTU, other than occasional attempts to probe for a change in the PMTU. [RFC8899] is thorough in its discussion of the PMTU discovery mechanism and strategies for determining the current end-to-end PMTU setting as well as detecting changes in this value.",
      "ja": "[RFC8899]、[RFC8201]、および[RFC1191]は、「パケット化レイヤーパスMTU発見」を指定します。PMTUの変更のための調査を試みます。[RFC8899]は、現在のエンドツーエンドPMTU設定を決定し、この値の変更を検出するためのPMTU発見メカニズムと戦略の議論において徹底的です。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD apply these techniques and SHOULD do so on a per-destination-address basis.",
      "ja": "エンドポイントはこれらの手法を適用する必要があり、命題ごとにそれを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "There are two important SCTP-specific points regarding PMTU discovery:",
      "ja": "PMTU発見に関しては、2つの重要なSCTP固有のポイントがあります。"
    },
    {
      "indent": 3,
      "text": "1) SCTP associations can span multiple addresses. An endpoint MUST maintain separate PMTU estimates for each destination address of its peer.",
      "ja": "1) SCTPアソシエーションは、複数のアドレスにまたがる可能性があります。エンドポイントは、ピアの各宛先アドレスの個別のPMTU推定値を維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "2) The sender SHOULD track an AMDCS that will be the smallest PMDCS discovered for all of the peer's destination addresses. When fragmenting messages into multiple parts, this AMDCS SHOULD be used to calculate the size of each DATA chunk. This will allow retransmissions to be seamlessly sent to an alternate address without encountering IP fragmentation.",
      "ja": "2) 送信者は、ピアのすべての宛先アドレスで発見された最小のPMDCとなるAMDCを追跡する必要があります。メッセージを複数の部分に分割する場合、このAMDCを使用して各データチャンクのサイズを計算する必要があります。これにより、再送信をIPの断片化に遭遇することなく、代替アドレスにシームレスに送信できます。"
    },
    {
      "indent": 0,
      "text": "8. Fault Management",
      "section_title": true,
      "ja": "8. 障害管理"
    },
    {
      "indent": 0,
      "text": "8.1. Endpoint Failure Detection",
      "section_title": true,
      "ja": "8.1. エンドポイント障害検出"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD keep a counter on the total number of consecutive retransmissions to its peer (this includes data retransmissions to all the destination transport addresses of the peer if it is multi-homed), including the number of unacknowledged HEARTBEAT chunks observed on the path that is currently used for data transfer. Unacknowledged HEARTBEAT chunks observed on paths different from the path currently used for data transfer SHOULD NOT increment the association error counter, as this could lead to association closure even if the path that is currently used for data transfer is available (but idle). If the value of this counter exceeds the limit indicated in the protocol parameter 'Association.Max.Retrans', the endpoint SHOULD consider the peer endpoint unreachable and SHALL stop transmitting any more data to it (and thus the association enters the CLOSED state). In addition, the endpoint SHOULD report the failure to the upper layer and optionally report back all outstanding user data remaining in its outbound queue. The association is automatically closed when the peer endpoint becomes unreachable.",
      "ja": "エンドポイントは、ピアへの連続した再送信の総数にカウンターを維持する必要があります（これには、マルチホームの場合、ピアのすべての宛先輸送アドレスへのデータ再送信が含まれます）。現在、データ転送に使用されています。データ転送に現在使用されているパスとは異なるパスで観察された未充填のハートビートチャンクは、データ転送に現在使用されているパスが利用可能であっても関連性の閉鎖につながる可能性があるため、関連性エラーカウンターを増加させる必要はありません（ただし、アイドル状態）。このカウンターの値が、プロトコルパラメーター「Association.max.retrans」に示されている制限を超える場合、エンドポイントはピアエンドポイントが到達不可能であると考える必要があり、それ以上のデータの送信を停止する必要があります（したがって、関連付けは閉じた状態に入ります）。さらに、エンドポイントは上層層に障害を報告し、オプションでアウトバウンドキューに残っているすべての未解決のユーザーデータを報告する必要があります。ピアエンドポイントが到達不能になると、関連性は自動的に閉じられます。"
    },
    {
      "indent": 3,
      "text": "The counter used for endpoint failure detection MUST be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK chunk). When a HEARTBEAT ACK chunk is received from the peer endpoint, the counter SHOULD also be reset. The receiver of the HEARTBEAT ACK chunk MAY choose not to clear the counter if there is outstanding data on the association. This allows for handling the possible difference in reachability based on DATA chunks and HEARTBEAT chunks.",
      "ja": "エンドポイントの故障検出に使用されるカウンターは、そのピアエンドポイントに送信されるデータチャンクが（サックチャンクを受信することにより）確認されるたびにリセットする必要があります。ピアエンドポイントからハートビートACKチャンクが受信されると、カウンターもリセットする必要があります。ハートビートACKチャンクの受信機は、関連性に関する未解決のデータがある場合、カウンターをクリアしないことを選択できます。これにより、データのチャンクとハートビートのチャンクに基づいて、リーチ性の可能性のある違いを処理できます。"
    },
    {
      "indent": 0,
      "text": "8.2. Path Failure Detection",
      "section_title": true,
      "ja": "8.2. パス障害検出"
    },
    {
      "indent": 3,
      "text": "When its peer endpoint is multi-homed, an endpoint SHOULD keep an error counter for each of the destination transport addresses of the peer endpoint.",
      "ja": "ピアエンドポイントがマルチホームの場合、エンドポイントは、ピアエンドポイントの各宛先輸送アドレスのエラーカウンターを保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each time the T3-rtx timer expires on any address, or when a HEARTBEAT chunk sent to an idle address is not acknowledged within an RTO, the error counter of that destination address will be incremented. When the value in the error counter exceeds the protocol parameter 'Path.Max.Retrans' of that destination address, the endpoint SHOULD mark the destination transport address as inactive, and a notification SHOULD be sent to the upper layer.",
      "ja": "T3-RTXタイマーが任意のアドレスで期限切れになるたびに、またはアイドル状態のアドレスに送られたハートビートチャンクがRTO内で確認されない場合、その宛先アドレスのエラーカウンターが増加します。エラーカウンターの値がその宛先アドレスのプロトコルパラメーター「path.max.retrans」を超える場合、エンドポイントは宛先輸送アドレスを非アクティブとしてマークし、通知を上層に送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an outstanding TSN is acknowledged or a HEARTBEAT chunk sent to that address is acknowledged with a HEARTBEAT ACK chunk, the endpoint SHOULD clear the error counter of the destination transport address to which the DATA chunk was last sent (or HEARTBEAT chunk was sent) and SHOULD also report to the upper layer when an inactive destination address is marked as active. When the peer endpoint is multi-homed and the last chunk sent to it was a retransmission to an alternate address, there exists an ambiguity as to whether or not the acknowledgement could be credited to the address of the last chunk sent. However, this ambiguity does not seem to have significant consequences for SCTP behavior. If this ambiguity is undesirable, the transmitter MAY choose not to clear the error counter if the last chunk sent was a retransmission.",
      "ja": "未解決のTSNが認められるか、そのアドレスに送信されたハートビートチャンクがハートビートACKチャンクで認められる場合、エンドポイントは、データチャンクが最後に送信された宛先輸送アドレスのエラーカウンターをクリアする必要があります（またはハートビートチャンクが送信されました）。また、非アクティブな宛先アドレスがアクティブとしてマークされている場合、上層にも報告する必要があります。ピアエンドポイントがマルチホームであり、最後に送信されたチャンクが代替アドレスへの再送信であった場合、承認が最後のチャンクの住所にクレジットされる可能性があるかどうかについてのあいまいさが存在します。ただし、このあいまいさは、SCTP行動に大きな結果をもたらすものではないようです。このあいまいさが望ましくない場合、送信機が最後に送信された場合、エラーカウンターをクリアしないことを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "Note: When configuring the SCTP endpoint, the user ought to avoid having the value of 'Association.Max.Retrans' larger than the summation of the 'Path.Max.Retrans' of all the destination addresses for the remote endpoint. Otherwise, all the destination addresses might become inactive while the endpoint still considers the peer endpoint reachable. When this condition occurs, how SCTP chooses to function is implementation specific.",
      "ja": "注：SCTPエンドポイントを構成する場合、ユーザーは、リモートエンドポイントのすべての宛先アドレスの「PATH.MAX.RETRANS」の合計よりも「Association.max.retrans」の値が大きくなることを避ける必要があります。それ以外の場合、エンドポイントはピアエンドポイントに到達可能と見なされている間、すべての宛先アドレスが非アクティブになる可能性があります。この条件が発生すると、SCTPが機能することを選択する方法は実装固有です。"
    },
    {
      "indent": 3,
      "text": "When the primary path is marked inactive (due to excessive retransmissions, for instance), the sender MAY automatically transmit new packets to an alternate destination address if one exists and is active. If more than one alternate address is active when the primary path is marked inactive, only ONE transport address SHOULD be chosen and used as the new destination transport address.",
      "ja": "プライマリパスが非アクティブにマークされている場合（たとえば、過度の再送信のため）、送信者は、存在してアクティブである場合、新しいパケットを代替宛先アドレスに自動的に送信できます。プライマリパスが不活性とマークされている場合、複数の代替アドレスがアクティブになっている場合、1つの輸送アドレスのみを選択し、新しい宛先輸送アドレスとして使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3. Path Heartbeat",
      "section_title": true,
      "ja": "8.3. パスハートビート"
    },
    {
      "indent": 3,
      "text": "By default, an SCTP endpoint SHOULD monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es). The sending of HEARTBEAT chunks MAY begin upon reaching the ESTABLISHED state and is discontinued after sending either a SHUTDOWN chunk or SHUTDOWN ACK chunk. A receiver of a HEARTBEAT chunk MUST respond to a HEARTBEAT chunk with a HEARTBEAT ACK chunk after entering the COOKIE-ECHOED state (sender of the INIT chunk) or the ESTABLISHED state (receiver of the INIT chunk), up until reaching the SHUTDOWN-SENT state (sender of the SHUTDOWN chunk) or the SHUTDOWN-ACK-SENT state (receiver of the SHUTDOWN chunk).",
      "ja": "デフォルトでは、SCTPエンドポイントは、宛先輸送アドレス（ES）に定期的にハートビートチャンクを送信することにより、ピアのアイドル宛先輸送アドレスの到達可能性を監視する必要があります。ハートビートチャンクの送信は、確立された状態に到達すると開始される可能性があり、シャットダウンチャンクまたはシャットダウンACKチャンクのいずれかを送信した後に中止されます。ハートビートチャンクのレシーバーは、クッキーエコード状態（initチャンクの送信者）または確立された状態（initチャンクの受信者）に入った後、ハートビートのackチャンクでハートビートチャンクに応答する必要があります。状態（シャットダウンチャンクの送信者）またはシャットダウン - セント状態（シャットダウンチャンクの受信者）。"
    },
    {
      "indent": 3,
      "text": "A destination transport address is considered \"idle\" if no new chunk that can be used for updating path RTT (usually including first transmission DATA, INIT, COOKIE ECHO, or HEARTBEAT chunks, etc.) and no HEARTBEAT chunk has been sent to it within the current heartbeat period of that address. This applies to both active and inactive destination addresses.",
      "ja": "宛先輸送アドレスは、パスRTT（通常は最初の伝送データ、init、cookieエコー、またはハートビートチャンクなど）の更新に使用できる新しいチャンクが使用されない場合、「アイドル」と見なされ、その中にハートビートチャンクが送信されていません。そのアドレスの現在のハートビート期間。これは、アクティブおよび非アクティブな宛先アドレスの両方に適用されます。"
    },
    {
      "indent": 3,
      "text": "The upper layer can optionally initiate the following functions:",
      "ja": "上層層は、オプションで次の機能を開始できます。"
    },
    {
      "indent": 3,
      "text": "A) Disable heartbeat on a specific destination transport address of a given association,",
      "ja": "a）特定の関連付けの特定の目的地輸送アドレスでハートビートを無効にする、"
    },
    {
      "indent": 3,
      "text": "B) Change the 'HB.interval',",
      "ja": "b）「hb.interval」を変更し、"
    },
    {
      "indent": 3,
      "text": "C) Re-enable heartbeat on a specific destination transport address of a given association, and",
      "ja": "c）特定の関連付けの特定の目的地輸送住所での再度のないハートビート、および"
    },
    {
      "indent": 3,
      "text": "D) Request the sending of an on-demand HEARTBEAT chunk on a specific destination transport address of a given association.",
      "ja": "d）特定の関連付けの特定の宛先輸送住所にオンデマンドのハートビートチャンクの送信を要求します。"
    },
    {
      "indent": 3,
      "text": "The endpoint SHOULD increment the respective error counter of the destination transport address each time a HEARTBEAT chunk is sent to that address and not acknowledged within one RTO.",
      "ja": "エンドポイントは、ハートビートチャンクがそのアドレスに送信され、1つのRTO内で確認されないたびに、宛先輸送アドレスのそれぞれのエラーカウンターをインクリメントする必要があります。"
    },
    {
      "indent": 3,
      "text": "When the value of this counter exceeds the protocol parameter 'Path.Max.Retrans', the endpoint SHOULD mark the corresponding destination address as inactive if it is not so marked and SHOULD also report to the upper layer the change in reachability of this destination address. After this, the endpoint SHOULD continue sending HEARTBEAT chunks on this destination address but SHOULD stop increasing the counter.",
      "ja": "このカウンターの値がプロトコルパラメーター「path.max.retrans」を超える場合、エンドポイントは、それがそれほどマークされていない場合、対応する宛先アドレスを非アクティブとしてマークし、またこの宛先アドレスの到達可能性の変更を上層に報告する必要があります。この後、エンドポイントはこの宛先アドレスにハートビートのチャンクを送信し続ける必要がありますが、カウンターの増加を停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of the HEARTBEAT chunk SHOULD include in the Heartbeat Information field of the chunk the current time when the packet is sent and the destination address to which the packet is sent.",
      "ja": "ハートビートチャンクの送信者は、パケットが送信された現在の時刻とパケットが送信される宛先アドレスのハートビート情報フィールドに、チャンクのハートビート情報フィールドに含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: An alternative implementation of the heartbeat mechanism that can be used is to increment the error counter variable every time a HEARTBEAT chunk is sent to a destination. Whenever a HEARTBEAT ACK chunk arrives, the sender SHOULD clear the error counter of the destination that the HEARTBEAT chunk was sent to. This, in effect, would clear the previously stroked error (and any other error counts as well).",
      "ja": "実装注：使用できるハートビートメカニズムの代替実装は、ハートビートチャンクが宛先に送信されるたびにエラーカウンター変数を増分することです。ハートビートACKチャンクが到着するたびに、送信者はハートビートチャンクが送信された宛先のエラーカウンターをクリアする必要があります。これにより、実際には、以前にstrokedしたエラー（および他のエラーもカウントされます）がクリアされます。"
    },
    {
      "indent": 3,
      "text": "The receiver of the HEARTBEAT chunk SHOULD immediately respond with a HEARTBEAT ACK chunk that contains the Heartbeat Information TLV, together with any other received TLVs, copied unchanged from the received HEARTBEAT chunk.",
      "ja": "ハートビートチャンクの受信機は、受け入れたハートビートチャンクから変更されていない他の受信したTLVとともに、ハートビート情報TLVを含むハートビートACKチャンクですぐに応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the HEARTBEAT ACK chunk, the sender of the HEARTBEAT chunk SHOULD clear the error counter of the destination transport address to which the HEARTBEAT chunk was sent and mark the destination transport address as active if it is not so marked. The endpoint SHOULD report to the upper layer when an inactive destination address is marked as active due to the reception of the latest HEARTBEAT ACK chunk. The receiver of the HEARTBEAT ACK chunk SHOULD also clear the association overall error count (as defined in Section 8.1).",
      "ja": "ハートビートACKチャンクを受け取ると、ハートビートチャンクの送信者は、ハートビートチャンクが送信された宛先輸送アドレスのエラーカウンターをクリアし、マークされていない場合は宛先輸送アドレスをアクティブとしてマークします。エンドポイントは、最新のハートビートACKチャンクの受信により、非アクティブな宛先アドレスがアクティブとしてマークされている場合、上層に報告する必要があります。ハートビートACKチャンクの受信機は、関連性の全体的なエラーカウントをクリアする必要があります（セクション8.1で定義されているように）。"
    },
    {
      "indent": 3,
      "text": "The receiver of the HEARTBEAT ACK chunk SHOULD also perform an RTT measurement for that destination transport address using the time value carried in the HEARTBEAT ACK chunk.",
      "ja": "ハートビートACKチャンクの受信機は、ハートビートACKチャンクで運ばれる時間値を使用して、その宛先輸送アドレスのRTT測定を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "On an idle destination address that is allowed to heartbeat, it is RECOMMENDED that a HEARTBEAT chunk is sent once per RTO of that destination address plus the protocol parameter 'HB.interval', with jittering of +/- 50% of the RTO value and exponential backoff of the RTO if the previous HEARTBEAT chunk is unanswered.",
      "ja": "ハートビートを許可されているアイドル宛先アドレスでは、その宛先アドレスのRTOに1回、プロトコルパラメーター「hb.interval」に1回送信することをお勧めします。以前のハートビートチャンクが未回答の場合、RTOのバックオフ。"
    },
    {
      "indent": 3,
      "text": "A primitive is provided for the SCTP user to change the 'HB.interval' and turn on or off the heartbeat on a given destination address. The 'HB.interval' set by the SCTP user is added to the RTO of that destination (including any exponential backoff). Only one heartbeat SHOULD be sent each time the heartbeat timer expires (if multiple destinations are idle). It is an implementation decision on how to choose which of the candidate idle destinations to heartbeat to (if more than one destination is idle).",
      "ja": "SCTPユーザーが「HB.INTERVAL」を変更し、特定の宛先アドレスのハートビートをオンまたはオフにするためのプリミティブが提供されます。SCTPユーザーによって設定された「Hb.Interval」は、その宛先のRTOに追加されます（指数関数的バックオフを含む）。ハートビートタイマーが期限切れになるたびに1つのハートビートを送信する必要があります（複数の宛先がアイドル状態にある場合）。これは、ハートビートする候補者のアイドル目的地を選択する方法に関する実装決定です（複数の宛先がアイドル状態である場合）。"
    },
    {
      "indent": 3,
      "text": "When tuning the 'HB.interval', there is a side effect that SHOULD be taken into account. When this value is increased, i.e., the time between the sending of HEARTBEAT chunks is longer, the detection of lost ABORT chunks takes longer as well. If a peer endpoint sends an ABORT chunk for any reason and the ABORT chunk is lost, the local endpoint will only discover the lost ABORT chunk by sending a DATA chunk or HEARTBEAT chunk (thus causing the peer to send another ABORT chunk). This is to be considered when tuning the heartbeat timer. If the sending of HEARTBEAT chunks is disabled, only sending DATA chunks to the association will discover a lost ABORT chunk from the peer.",
      "ja": "「Hb.Interval」を調整するとき、考慮すべき副作用があります。この値が増加すると、つまり、ハートビートチャンクの送信までの時間が長くなると、失われた中止チャンクの検出にも時間がかかります。ピアエンドポイントが何らかの理由で中止チャンクを送信し、中止チャンクが失われた場合、ローカルエンドポイントはデータチャンクまたはハートビートチャンクを送信することによって失われた中止チャンクを発見します（したがって、ピアは別の中止チャンクを送信します）。これは、ハートビートタイマーを調整するときに考慮されます。ハートビートチャンクの送信が無効になっている場合、協会にデータチャンクを送信するだけで、ピアから失われた中止チャンクが発見されます。"
    },
    {
      "indent": 0,
      "text": "8.4. Handle \"Out of the Blue\" Packets",
      "section_title": true,
      "ja": "8.4. 「青から」パケットを処理します"
    },
    {
      "indent": 3,
      "text": "An SCTP packet is called an \"Out of the Blue\" (OOTB) packet if it is correctly formed (i.e., passed the receiver's CRC32c check; see Section 6.8), but the receiver is not able to identify the association to which this packet belongs.",
      "ja": "SCTPパケットは、正しく形成されている場合（つまり、受信者のCRC32Cチェックに合格した場合、セクション6.8を参照）場合、「青から」（OOTB）パケットと呼ばれますが、受信者はこのパケットが属する関連付けを識別できません。。"
    },
    {
      "indent": 3,
      "text": "The receiver of an OOTB packet does the following:",
      "ja": "OOTBパケットの受信者は、次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1) If the OOTB packet is to or from a non-unicast address, a receiver SHOULD silently discard the packet. Otherwise,",
      "ja": "1) OOTBパケットが非ユニカストアドレスとの間で、またはそれ以外の場合、受信者はパケットを静かに廃棄する必要があります。さもないと、"
    },
    {
      "indent": 3,
      "text": "2) If the OOTB packet contains an ABORT chunk, the receiver MUST silently discard the OOTB packet and take no further action. Otherwise,",
      "ja": "2) OOTBパケットに中止チャンクが含まれている場合、受信者はooTBパケットを静かに破棄し、それ以上のアクションを実行する必要があります。さもないと、"
    },
    {
      "indent": 3,
      "text": "3) If the packet contains an INIT chunk with a Verification Tag set to 0, it SHOULD be processed as described in Section 5.1. If, for whatever reason, the INIT chunk cannot be processed normally and an ABORT chunk has to be sent in response, the Verification Tag of the packet containing the ABORT chunk MUST be the Initiate Tag of the received INIT chunk, and the T bit of the ABORT chunk has to be set to 0, indicating that the Verification Tag is not reflected. Otherwise,",
      "ja": "3) パケットに検証タグが0に設定されたinitチャンクが含まれている場合、セクション5.1で説明されているように処理する必要があります。何らかの理由で、init chunkを正常に処理できず、それに応じて中止チャンクを送信する必要がある場合、中止チャンクを含むパケットの検証タグは、受信したinitチャンクの開始タグでなければなりません。中止チャンクを0に設定する必要があり、検証タグが反映されていないことを示します。さもないと、"
    },
    {
      "indent": 3,
      "text": "4) If the packet contains a COOKIE ECHO chunk as the first chunk, it MUST be processed as described in Section 5.1. Otherwise,",
      "ja": "4) パケットに最初のチャンクとしてCookieエコーチャンクが含まれている場合、セクション5.1で説明されているように処理する必要があります。さもないと、"
    },
    {
      "indent": 3,
      "text": "5) If the packet contains a SHUTDOWN ACK chunk, the receiver SHOULD respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE chunk. When sending the SHUTDOWN COMPLETE chunk, the receiver of the OOTB packet MUST fill in the Verification Tag field of the outbound packet with the Verification Tag received in the SHUTDOWN ACK chunk and set the T bit in the Chunk Flags to indicate that the Verification Tag is reflected. Otherwise,",
      "ja": "5) パケットにシャットダウンACKチャンクが含まれている場合、受信者はシャットダウン完全チャンクでOOTBパケットの送信者に応答する必要があります。シャットダウン完全なチャンクを送信するとき、OOTBパケットの受信機は、アウトバウンドパケットの検証タグフィールドにシャットダウンACKチャンクで受信した検証タグを入力し、チャンクフラグにTビットを設定して、検証タグがあることを示す必要があります。反射。さもないと、"
    },
    {
      "indent": 3,
      "text": "6) If the packet contains a SHUTDOWN COMPLETE chunk, the receiver SHOULD silently discard the packet and take no further action. Otherwise,",
      "ja": "6) パケットにシャットダウンの完全なチャンクが含まれている場合、受信者はパケットを静かに廃棄し、それ以上のアクションを実行しません。さもないと、"
    },
    {
      "indent": 3,
      "text": "7) If the packet contains an ERROR chunk with the \"Stale Cookie\" error cause or a COOKIE ACK chunk, the SCTP packet SHOULD be silently discarded. Otherwise,",
      "ja": "7) パケットに「古いCookie」エラー原因またはCookie ACKチャンクのエラーチャンクが含まれている場合、SCTPパケットは静かに破棄する必要があります。さもないと、"
    },
    {
      "indent": 3,
      "text": "8) The receiver SHOULD respond to the sender of the OOTB packet with an ABORT chunk. When sending the ABORT chunk, the receiver of the OOTB packet MUST fill in the Verification Tag field of the outbound packet with the value found in the Verification Tag field of the OOTB packet and set the T bit in the Chunk Flags to indicate that the Verification Tag is reflected. After sending this ABORT chunk, the receiver of the OOTB packet MUST discard the OOTB packet and MUST NOT take any further action.",
      "ja": "8) レシーバーは、中止チャンクでOOTBパケットの送信者に応答する必要があります。Abort Chunkを送信するとき、OOTBパケットの受信機は、OOTBパケットの検証タグフィールドにある値にアウトバウンドパケットの検証タグフィールドに記入し、チャンクフラグにTビットを設定して、検証を示すように設定する必要があります。タグが反映されます。この中止チャンクを送信した後、OOTBパケットの受信者はOOTBパケットを破棄する必要があり、それ以上のアクションを実行してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.5. Verification Tag",
      "section_title": true,
      "ja": "8.5. 検証タグ"
    },
    {
      "indent": 3,
      "text": "The Verification Tag rules defined in this section apply when sending or receiving SCTP packets that do not contain an INIT, SHUTDOWN COMPLETE, COOKIE ECHO (see Section 5.1), ABORT, or SHUTDOWN ACK chunk. The rules for sending and receiving SCTP packets containing one of these chunk types are discussed separately in Section 8.5.1.",
      "ja": "このセクションで定義されている検証タグルールは、init、shutdown Complete、cookie echo（セクション5.1を参照）、中絶、またはackチャンクをシャットダウンするSCTPパケットを送信または受信するときに適用されます。これらのチャンクタイプのいずれかを含むSCTPパケットを送信および受信するためのルールについては、セクション8.5.1で個別に説明します。"
    },
    {
      "indent": 3,
      "text": "When sending an SCTP packet, the endpoint MUST fill in the Verification Tag field of the outbound packet with the tag value in the Initiate Tag parameter of the INIT or INIT ACK chunk received from its peer.",
      "ja": "SCTPパケットを送信する場合、エンドポイントは、ピアから受け取ったinitまたはinit ackチャンクのinitiateタグパラメーターのタグ値をアウトバウンドパケットの検証タグフィールドに記入する必要があります。"
    },
    {
      "indent": 3,
      "text": "When receiving an SCTP packet, the endpoint MUST ensure that the value in the Verification Tag field of the received SCTP packet matches its own tag. If the received Verification Tag value does not match the receiver's own tag value, the receiver MUST silently discard the packet and MUST NOT process it any further, except for those cases listed in Section 8.5.1 below.",
      "ja": "SCTPパケットを受信するとき、エンドポイントは、受信したSCTPパケットの検証タグフィールドの値が独自のタグと一致することを確認する必要があります。受信した検証タグ値がレシーバー自身のタグ値と一致しない場合、受信者はパケットを静かに破棄する必要があり、以下のセクション8.5.1にリストされているケースを除き、それ以上処理してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.5.1. Exceptions in Verification Tag Rules",
      "section_title": true,
      "ja": "8.5.1. 検証タグルールの例外"
    },
    {
      "indent": 3,
      "text": "A) Rules for packets carrying an INIT chunk: * The sender MUST set the Verification Tag of the packet to 0.",
      "ja": "a）initチャンクを運ぶパケットのルール： *送信者は、パケットの検証タグを0に設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "* When an endpoint receives an SCTP packet with the Verification Tag set to 0, it SHOULD verify that the packet contains only an INIT chunk. Otherwise, the receiver MUST silently discard the packet.",
      "ja": "* エンドポイントが0に設定された検証タグを持つSCTPパケットを受信すると、パケットにinitチャンクのみが含まれていることを確認する必要があります。それ以外の場合、受信者はパケットを静かに破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "B) Rules for packets carrying an ABORT chunk: * The endpoint MUST always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value if it is known.",
      "ja": "b）中止塊を運ぶパケットのルール： *エンドポイントは、既知の場合、アウトバウンドパケットの検証タグフィールドに常に宛先エンドポイントのタグ値を入力する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the ABORT chunk is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.",
      "ja": "* Abort ChunkがOOTBパケットに応じて送信される場合、エンドポイントはセクション8.4で説明されている手順に従う必要があります。"
    },
    {
      "indent": 6,
      "text": "* The receiver of an ABORT chunk MUST accept the packet if the Verification Tag field of the packet matches its own tag and the T bit is not set OR if it is set to its Peer's Tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action.",
      "ja": "* 中止チャンクの受信機は、パケットの検証タグフィールドが独自のタグと一致し、tビットが設定されていない場合、またはピアのタグに設定されていない場合、tビットがチャンクフラグに設定されていない場合、パケットを受け入れる必要があります。それ以外の場合、受信者はパケットを静かに破棄し、それ以上のアクションを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "C) Rules for packets carrying a SHUTDOWN COMPLETE chunk: * When sending a SHUTDOWN COMPLETE chunk, if the receiver of the SHUTDOWN ACK chunk has a TCB, then the destination endpoint's tag MUST be used and the T bit MUST NOT be set. Only where no TCB exists SHOULD the sender use the Verification Tag from the SHUTDOWN ACK chunk and MUST set the T bit.",
      "ja": "c）シャットダウンを運ぶパケットのルール完全チャンク： *シャットダウン完全チャンクを送信する場合、シャットダウンACKチャンクの受信機にTCBがある場合、宛先エンドポイントのタグを使用する必要があり、Tビットを設定してはなりません。TCBが存在しない場合のみ、送信者はシャットダウンACKチャンクの検証タグを使用し、Tビットを設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The receiver of a SHUTDOWN COMPLETE chunk accepts the packet if the Verification Tag field of the packet matches its own tag and the T bit is not set OR if it is set to its Peer's Tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action. An endpoint MUST ignore the SHUTDOWN COMPLETE chunk if it is not in the SHUTDOWN-ACK-SENT state.",
      "ja": "* シャットダウンの受信者は、パケットの検証タグフィールドが独自のタグと一致し、Tビットが設定されていない場合、またはピアのタグに設定されていない場合、Tビットがチャンクフラグに設定されていない場合、パケットを受け入れます。それ以外の場合、受信者はパケットを静かに破棄し、それ以上のアクションを実行する必要があります。エンドポイントは、シャットダウンの停止状態にない場合、シャットダウン完全チャンクを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "D) Rules for packets carrying a COOKIE ECHO chunk: * When sending a COOKIE ECHO chunk, the endpoint MUST use the value of the Initiate Tag received in the INIT ACK chunk.",
      "ja": "d）Cookie Echo Chunkを運ぶパケットのルール： * Cookie Echo Chunkを送信する場合、エンドポイントはinit ackチャンクで受信された開始タグの値を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The receiver of a COOKIE ECHO chunk follows the procedures in Section 5.",
      "ja": "* Cookie Echo Chunkの受信機は、セクション5の手順に従います。"
    },
    {
      "indent": 3,
      "text": "E) Rules for packets carrying a SHUTDOWN ACK chunk: * If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state, the procedures in Section 8.4 SHOULD be followed; in other words, it is treated as an OOTB packet.",
      "ja": "e）シャットダウンACKチャンクを運ぶパケットのルール： *受信機がCookieエコーまたはCookie-Wait状態にある場合、セクション8.4の手順に従う必要があります。言い換えれば、それはOOTBパケットとして扱われます。"
    },
    {
      "indent": 0,
      "text": "9. Termination of Association",
      "section_title": true,
      "ja": "9. 関連付けの終了"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD terminate its association when it exits from service. An association can be terminated by either abort or shutdown. An abort of an association is abortive by definition in that any data pending on either end of the association is discarded and not delivered to the peer. A shutdown of an association is considered a graceful close where all data in queue by either endpoint is delivered to the respective peers. However, in the case of a shutdown, SCTP does not support a half-open state (like TCP), wherein one side might continue sending data while the other end is closed. When either endpoint performs a shutdown, the association on each peer will stop accepting new data from its user and only deliver data in queue at the time of sending or receiving the SHUTDOWN chunk.",
      "ja": "エンドポイントは、サービスから終了するときに関連性を終了する必要があります。関連付けは、中止またはシャットダウンによって終了できます。協会のいずれかの端で保留中のデータが廃棄され、ピアに配信されないという点で、協会の中絶は定義上中絶します。協会のシャットダウンは、いずれかのエンドポイントによるキュー内のすべてのデータがそれぞれのピアに配信される優雅な近接と見なされます。ただし、シャットダウンの場合、SCTPは半分のオープン状態（TCPのような）をサポートしていません。この状態は、一方の側がデータの送信を続ける可能性があり、もう一方の端が閉じています。いずれかのエンドポイントがシャットダウンを実行すると、各ピアの関連付けはユーザーから新しいデータの受け入れを停止し、シャットダウンチャンクの送信または受信時にキュー内のデータのみを配信します。"
    },
    {
      "indent": 0,
      "text": "9.1. Abort of an Association",
      "section_title": true,
      "ja": "9.1. 協会の中絶"
    },
    {
      "indent": 3,
      "text": "When an endpoint decides to abort an existing association, it MUST send an ABORT chunk to its peer endpoint. The sender MUST fill in the peer's Verification Tag in the outbound packet and MUST NOT bundle any DATA chunk with the ABORT chunk. If the association is aborted on request of the upper layer, a \"User-Initiated Abort\" error cause (see Section 3.3.10.12) SHOULD be present in the ABORT chunk.",
      "ja": "エンドポイントが既存の関連付けを中止することを決定した場合、ピアエンドポイントに中止チャンクを送信する必要があります。送信者は、アウトバウンドパケットのピアの検証タグを記入し、Abort Chunkでデータチャンクをバンドルしてはなりません。関連性が上層の要求に応じて中止された場合、「ユーザーが開始した中止」エラー原因（セクション3.3.10.12を参照）を中止塊に存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT respond to any received packet that contains an ABORT chunk (also see Section 8.4).",
      "ja": "エンドポイントは、中止チャンクを含む受信したパケットに応答してはなりません（セクション8.4も参照）。"
    },
    {
      "indent": 3,
      "text": "An endpoint receiving an ABORT chunk MUST apply the special Verification Tag check rules described in Section 8.5.1.",
      "ja": "中止チャンクを受信するエンドポイントは、セクション8.5.1で説明されている特別な検証タグチェックルールを適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "After checking the Verification Tag, the receiving endpoint MUST remove the association from its record and SHOULD report the termination to its upper layer. If a \"User-Initiated Abort\" error cause is present in the ABORT chunk, the Upper Layer Abort Reason SHOULD be made available to the upper layer.",
      "ja": "検証タグを確認した後、受信エンドポイントはそのレコードから協会を削除し、上層層に終了を報告する必要があります。「ユーザーが開始した中止」エラー原因が中止チャンクに存在する場合、上層の前層の理由を上層層で利用できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "9.2. Shutdown of an Association",
      "section_title": true,
      "ja": "9.2. 協会のシャットダウン"
    },
    {
      "indent": 3,
      "text": "Using the SHUTDOWN primitive (see Section 11.1), the upper layer of an endpoint in an association can gracefully close the association. This will allow all outstanding DATA chunks from the peer of the shutdown initiator to be delivered before the association terminates.",
      "ja": "シャットダウンプリミティブ（セクション11.1を参照）を使用して、関連性のエンドポイントの上層層は、関連性を優雅に閉じることができます。これにより、協会が終了する前に、Shutdownイニシエーターのピアからのすべての未解決のデータチャンクが配信されるようになります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the SHUTDOWN primitive from its upper layer, the endpoint enters the SHUTDOWN-PENDING state and remains there until all outstanding data has been acknowledged by its peer. The endpoint accepts no new data from its upper layer but retransmits data to the peer endpoint if necessary to fill gaps.",
      "ja": "上層層からプリミティブを受け取ると、エンドポイントはシャットダウンの維持状態に入り、すべての未解決のデータがピアによって認められるまでそこにとどまります。エンドポイントは、上層の新しいデータを受け入れませんが、ギャップを埋めるために必要に応じて、データをピアエンドポイントに再送信します。"
    },
    {
      "indent": 3,
      "text": "Once all its outstanding data has been acknowledged, the endpoint sends a SHUTDOWN chunk to its peer, including in the Cumulative TSN Ack field the last sequential TSN it has received from the peer. It SHOULD then start the T2-shutdown timer and enter the SHUTDOWN-SENT state. If the timer expires, the endpoint MUST resend the SHUTDOWN chunk with the updated last sequential TSN received from its peer.",
      "ja": "すべての未解決のデータが認められると、エンドポイントは、累積TSN ACKフィールドを含む、ピアから受け取った最後のシーケンシャルTSNを含むシャットダウンチャンクをピアに送信します。その後、T2-Shutdownタイマーを起動し、Shutdown-Sent Stateを入力する必要があります。タイマーが期限切れになった場合、エンドポイントは、ピアから受け取った更新された最後のシーケンシャルTSNでシャットダウンチャンクを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The rules in Section 6.3 MUST be followed to determine the proper timer value for T2-shutdown. To indicate any gaps in TSN, the endpoint MAY also bundle a SACK chunk with the SHUTDOWN chunk in the same SCTP packet.",
      "ja": "T2-Shutdownの適切なタイマー値を決定するには、セクション6.3のルールに従う必要があります。TSNのギャップを示すために、エンドポイントは、同じSCTPパケットのシャットダウンチャンクでサックチャンクをバンドルすることもできます。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD limit the number of retransmissions of the SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded, the endpoint SHOULD destroy the TCB and SHOULD report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state). The reception of any packet from its peer (i.e., as the peer sends all of its queued DATA chunks) SHOULD clear the endpoint's retransmission count and restart the T2-shutdown timer, giving its peer ample opportunity to transmit all of its queued DATA chunks that have not yet been sent.",
      "ja": "エンドポイントは、プロトコルパラメーター「Association.max.retrans」へのシャットダウンチャンクの再送信の数を制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊し、ピアエンドポイントを上層に到達できないことを報告する必要があります（したがって、関連付けは閉じた状態に入ります）。ピアからのパケットの受信（つまり、ピアがキューに囲まれたデータチャンクをすべて送信するため）は、エンドポイントの再送信数をクリアし、T2-shutdownタイマーを再起動し、ピアがキューに囲まれたすべてのデータチャンクをすべて送信する十分な機会を与えます。まだ送られていません。"
    },
    {
      "indent": 3,
      "text": "Upon reception of the SHUTDOWN chunk, the peer endpoint does the following:",
      "ja": "シャットダウンチャンクを受信すると、ピアエンドポイントは次のことを行います。"
    },
    {
      "indent": 3,
      "text": "* enter the SHUTDOWN-RECEIVED state,",
      "ja": "* シャットダウンが推奨される状態を入力し、"
    },
    {
      "indent": 3,
      "text": "* stop accepting new data from its SCTP user, and",
      "ja": "* SCTPユーザーから新しいデータを受け入れるのをやめ、"
    },
    {
      "indent": 3,
      "text": "* verify, by checking the Cumulative TSN Ack field of the chunk, that all its outstanding DATA chunks have been received by the SHUTDOWN chunk sender.",
      "ja": "* チャンクの累積TSN ACKフィールドをチェックすることにより、その優れたデータチャンクがすべてシャットダウンチャンク送信者によって受信されたことを確認します。"
    },
    {
      "indent": 3,
      "text": "Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST ignore ULP shutdown requests but MUST continue responding to SHUTDOWN chunks from its peer.",
      "ja": "エンドポイントがシャットダウンを受け取った状態に達したら、ULPシャットダウン要求を無視する必要がありますが、ピアからのシャットダウンチャンクに応答し続ける必要があります。"
    },
    {
      "indent": 3,
      "text": "If there are still outstanding DATA chunks left, the SHUTDOWN chunk receiver MUST continue to follow normal data transmission procedures defined in Section 6, until all outstanding DATA chunks are acknowledged; however, the SHUTDOWN chunk receiver MUST NOT accept new data from its SCTP user.",
      "ja": "未解決のデータチャンクがまだ残っている場合、シャットダウンチャンクレシーバーは、すべての未解決のデータチャンクが認められるまで、セクション6で定義された通常のデータ送信手順に続く必要があります。ただし、シャットダウンチャンクレシーバーは、SCTPユーザーから新しいデータを受け入れてはなりません。"
    },
    {
      "indent": 3,
      "text": "While in the SHUTDOWN-SENT state, the SHUTDOWN chunk sender MUST immediately respond to each received packet containing one or more DATA chunks with a SHUTDOWN chunk and restart the T2-shutdown timer. If a SHUTDOWN chunk by itself cannot acknowledge all of the received DATA chunks (i.e., there are TSNs that can be acknowledged that are larger than the cumulative TSN and thus gaps exist in the TSN sequence) or if duplicate TSNs have been received, then a SACK chunk MUST also be sent.",
      "ja": "シャットダウン状態では、シャットダウンチャンクセンダーは、シャットダウンチャンクを備えた1つ以上のデータチャンクを含む各受信パケットに直ちに応答し、T2-Shutdownタイマーを再起動する必要があります。シャットダウンチャンク自体が受信したすべてのデータチャンクを認めることができない場合（つまり、累積TSNよりも大きいため、ギャップがTSNシーケンスに存在することを認識できるTSNがあります）、または重複TSNを受け取った場合、サックチャンクも送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN chunk MAY also start an overall guard timer T5-shutdown-guard to bound the overall time for the shutdown sequence. At the expiration of this timer, the sender SHOULD abort the association by sending an ABORT chunk. If the T5-shutdown-guard timer is used, it SHOULD be set to the RECOMMENDED value of 5 times 'RTO.Max'.",
      "ja": "シャットダウンチャンクの送信者は、全体的なガードタイマーT5-Shutdown-Guardを開始して、シャットダウンシーケンスの全体的な時間をバインドすることもできます。このタイマーの有効期限が切れば、送信者は中止チャンクを送信して協会を中止する必要があります。T5-Shutdown-Guardタイマーを使用する場合、5回の 'rto.max'の推奨値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the receiver of the SHUTDOWN chunk has no more outstanding DATA chunks, the SHUTDOWN chunk receiver MUST send a SHUTDOWN ACK chunk and start a T2-shutdown timer of its own, entering the SHUTDOWN-ACK-SENT state. If the timer expires, the endpoint MUST resend the SHUTDOWN ACK chunk.",
      "ja": "シャットダウンチャンクの受信者に未解決のデータチャンクがなくなると、シャットダウンチャンクレシーバーはシャットダウンACKチャンクを送信し、独自のT2-Shutdownタイマーを起動して、シャットダウンの停止状態に入ります。タイマーの有効期限が切れた場合、エンドポイントはシャットダウンACKチャンクを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN ACK chunk SHOULD limit the number of retransmissions of the SHUTDOWN ACK chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded, the endpoint SHOULD destroy the TCB and SHOULD report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state).",
      "ja": "シャットダウンACKチャンクの送信者は、Shutdown ACK Chunkの再送信数をプロトコルパラメーター「Association.max.Retrans」に制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊し、ピアエンドポイントを上層に到達できないことを報告する必要があります（したがって、関連付けは閉じた状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the SHUTDOWN ACK chunk, the sender of the SHUTDOWN chunk MUST stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer, and remove all record of the association.",
      "ja": "シャットダウンACKチャンクを受け取ると、シャットダウンチャンクの送信者は、T2-Shutdownタイマーを停止し、ピアに完全なチャンクをシャットダウンしたチャンクを送信し、協会のすべての記録を削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon reception of the SHUTDOWN COMPLETE chunk, the endpoint verifies that it is in the SHUTDOWN-ACK-SENT state; if it is not, the chunk SHOULD be discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state, the endpoint SHOULD stop the T2-shutdown timer and remove all knowledge of the association (and thus the association enters the CLOSED state).",
      "ja": "シャットダウンが完全なチャンクを受信すると、エンドポイントは、それがシャットダウン済みの状態にあることを確認します。そうでない場合は、チャンクを破棄する必要があります。エンドポイントがShutdown-ack-Sent状態にある場合、エンドポイントはT2-Shutdownタイマーを停止し、関連性のすべての知識を削除する必要があります（したがって、協会は閉じた状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD ensure that all its outstanding DATA chunks have been acknowledged before initiating the shutdown procedure.",
      "ja": "エンドポイントは、シャットダウン手順を開始する前に、すべての未解決のデータチャンクが認められていることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD reject any new data request from its upper layer if it is in the SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED, or SHUTDOWN-ACK-SENT state.",
      "ja": "エンドポイントは、シャットダウンペンディング、シャットダウンセント、シャットダウン、またはシャットダウンの停止状態にある場合、上層から新しいデータ要求を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in the SHUTDOWN-ACK-SENT state and receives an INIT chunk (e.g., if the SHUTDOWN COMPLETE chunk was lost) with source and destination transport addresses (either in the IP addresses or in the INIT chunk) that belong to this association, it SHOULD discard the INIT chunk and retransmit the SHUTDOWN ACK chunk.",
      "ja": "エンドポイントがShutdown-ack-Sent状態にあり、ソースおよび宛先輸送アドレス（IPアドレスまたはINITチャンク）を使用して、INITチャンク（たとえば、完全なチャンクが失われた場合）を受け取る場合関連性、INITチャンクを破棄し、シャットダウンACKチャンクを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Receipt of a packet containing an INIT chunk with the same source and destination IP addresses as used in transport addresses assigned to an endpoint but with a different port number indicates the initialization of a separate association.",
      "ja": "注：エンドポイントに割り当てられた輸送アドレスで使用されているが、異なるポート番号を持つ同じソースと宛先IPアドレスを持つINITチャンクを含むパケットの受領は、個別の関連付けの初期化を示します。"
    },
    {
      "indent": 3,
      "text": "The sender of the INIT or COOKIE ECHO chunk SHOULD respond to the receipt of a SHUTDOWN ACK chunk with a stand-alone SHUTDOWN COMPLETE chunk in an SCTP packet with the Verification Tag field of its common header set to the same tag that was received in the packet containing the SHUTDOWN ACK chunk. This is considered an OOTB packet as defined in Section 8.4. The sender of the INIT chunk lets T1-init continue running and remains in the COOKIE-WAIT or COOKIE-ECHOED state. Normal T1-init timer expiration will cause the INIT or COOKIE chunk to be retransmitted and thus start a new association.",
      "ja": "initまたはcookie echo chunkの送信者は、sctpパケットのスタンドアロンシャットダウン完全チャンクでシャットダウンACKチャンクの受領に応答する必要があります。シャットダウンACKチャンクを含むパケット。これは、セクション8.4で定義されているOOTBパケットと見なされます。init chunkの送信者は、t1-initを実行し続け、Cookie-waitまたはcookieエコー状態にとどまります。通常のT1-INITタイマーの有効期限は、INITまたはCookieチャンクを再送信し、新しい関連付けを開始します。"
    },
    {
      "indent": 3,
      "text": "If a SHUTDOWN chunk is received in the COOKIE-WAIT or COOKIE ECHOED state, the SHUTDOWN chunk SHOULD be silently discarded.",
      "ja": "Cookie-WaitまたはCookie Echoed状態でシャットダウンチャンクが受信された場合、シャットダウンチャンクは静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in the SHUTDOWN-SENT state and receives a SHUTDOWN chunk from its peer, the endpoint SHOULD respond immediately with a SHUTDOWN ACK chunk to its peer and move into the SHUTDOWN-ACK-SENT state, restarting its T2-shutdown timer.",
      "ja": "エンドポイントがシャットダウン状態にあり、ピアからシャットダウンチャンクを受け取る場合、エンドポイントはすぐにピアにシャットダウンACKチャンクで応答し、T2-Shutdownタイマーを再起動してシャットダウン型の状態に移動する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in the SHUTDOWN-ACK-SENT state and receives a SHUTDOWN ACK, it MUST stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer, and remove all record of the association.",
      "ja": "エンドポイントがShutdown-ack-Sent状態にあり、シャットダウンACKを受信する場合、T2-Shutdownタイマーを停止し、ピアに完全なチャンクを送信し、協会のすべての記録を削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. ICMP Handling",
      "section_title": true,
      "ja": "10. ICMP処理"
    },
    {
      "indent": 3,
      "text": "Whenever an ICMP message is received by an SCTP endpoint, the following procedures MUST be followed to ensure proper utilization of the information being provided by layer 3.",
      "ja": "SCTPエンドポイントによってICMPメッセージが受信される場合はいつでも、レイヤー3で提供される情報を適切に利用するために、次の手順に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "ICMP1) An implementation MAY ignore all ICMPv4 messages where the type field is not set to \"Destination Unreachable\".",
      "ja": "ICMP1）実装は、タイプフィールドが「宛先の到達不能」に設定されていないすべてのICMPV4メッセージを無視する場合があります。"
    },
    {
      "indent": 3,
      "text": "ICMP2) An implementation MAY ignore all ICMPv6 messages where the type field is not \"Destination Unreachable\", \"Parameter Problem\", or \"Packet Too Big\".",
      "ja": "ICMP2）実装は、タイプフィールドが「宛先の到達不能」、「パラメーター問題」、または「パケットが大きすぎる」ではないすべてのICMPV6メッセージを無視する場合があります。"
    },
    {
      "indent": 3,
      "text": "ICMP3) An implementation SHOULD ignore any ICMP messages where the code indicates \"Port Unreachable\".",
      "ja": "ICMP3）実装は、コードが「到達不能」を示すICMPメッセージを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "ICMP4) An implementation MAY ignore all ICMPv6 messages of type \"Parameter Problem\" if the code is not \"Unrecognized Next Header Type Encountered\".",
      "ja": "ICMP4）実装は、コードが「遭遇しない」という認識されていない「パラメーター問題」のタイプ「パラメーター問題」のすべてのICMPV6メッセージを無視する場合があります。"
    },
    {
      "indent": 3,
      "text": "ICMP5) An implementation MUST use the payload of the ICMP message (v4 or v6) to locate the association that sent the message to which ICMP is responding. If the association cannot be found, an implementation SHOULD ignore the ICMP message.",
      "ja": "ICMP5）実装は、ICMPメッセージ（V4またはV6）のペイロードを使用して、ICMPが応答しているメッセージを送信した関連付けを見つける必要があります。協会が見つからない場合、実装はICMPメッセージを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "ICMP6) An implementation MUST validate that the Verification Tag contained in the ICMP message matches the Verification Tag of the peer. If the Verification Tag is not 0 and does not match, discard the ICMP message. If it is 0 and the ICMP message contains enough bytes to verify that the chunk type is an INIT chunk and that the Initiate Tag matches the tag of the peer, continue with ICMP7. If the ICMP message is too short or the chunk type or the Initiate Tag does not match, silently discard the packet.",
      "ja": "ICMP6）実装は、ICMPメッセージに含まれる検証タグがピアの検証タグと一致することを検証する必要があります。検証タグが0ではなく、一致しない場合は、ICMPメッセージを破棄します。0であり、ICMPメッセージに、チャンクタイプがinitチャンクであり、開始タグがピアのタグと一致することを確認するのに十分なバイトが含まれている場合、ICMP7で続行します。ICMPメッセージが短すぎる場合、またはチャンクタイプまたは開始タグが一致しない場合は、パケットを静かに破棄します。"
    },
    {
      "indent": 3,
      "text": "ICMP7) If the ICMP message is either an ICMPv6 message of type \"Packet Too Big\" or an ICMPv4 message of type \"Destination Unreachable\" and code \"Fragmentation Needed\", an implementation SHOULD process this information as defined for PMTU discovery.",
      "ja": "ICMP7）ICMPメッセージが、「パケットが大きすぎる」タイプのICMPv6メッセージまたは「宛先の届かない」タイプのICMPV4メッセージであり、コード「フラグメンテーション」のいずれかである場合、実装はPMTU発見のために定義されたこの情報を処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "ICMP8) If the ICMP code is \"Unrecognized Next Header Type Encountered\" or \"Protocol Unreachable\", an implementation MUST treat this message as an abort with the T bit set if it does not contain an INIT chunk. If it does contain an INIT chunk and the association is in the COOKIE-WAIT state, handle the ICMP message like an ABORT chunk.",
      "ja": "ICMP8）ICMPコードが「認識されていない次のヘッダータイプが遭遇する」または「プロトコルの到達不能」である場合、実装は、このメッセージをinitチャンクが含まれていない場合はtビットセットで中止として扱う必要があります。init chunkが含まれていて、関連性がCookie-wait状態にある場合は、中止チャンクのようにICMPメッセージを処理します。"
    },
    {
      "indent": 3,
      "text": "ICMP9) If the ICMP type is \"Destination Unreachable\", the implementation MAY move the destination to the unreachable state or, alternatively, increment the path error counter. SCTP MAY provide information to the upper layer indicating the reception of ICMP messages when reporting a network status change.",
      "ja": "ICMP9）ICMPタイプが「宛先の到達不能」の場合、実装は宛先を到達不可能な状態に移動するか、あるいはパスエラーカウンターを増加させる場合があります。SCTPは、ネットワークステータスの変更を報告するときにICMPメッセージの受信を示す上層層に情報を提供する場合があります。"
    },
    {
      "indent": 3,
      "text": "These procedures differ from [RFC1122] and from its requirements for processing of port-unreachable messages and the requirements that an implementation MUST abort associations in response to a protocol unreachable message. Port-unreachable messages are not processed, since an implementation will send an ABORT chunk, not a port-unreachable message. The stricter handling of the protocol unreachable message is due to security concerns for hosts that do not support SCTP.",
      "ja": "これらの手順は、[RFC1122]や、ポート未任務のメッセージの処理に関する要件と、実装がプロトコルの到達不可能なメッセージに応じて関連性を中止する必要があるという要件とは異なります。実装は、ポート不可能なメッセージではなく、中止チャンクを送信するため、ポート未任務のメッセージは処理されません。プロトコルの到達不可能なメッセージのより厳格な処理は、SCTPをサポートしていないホストのセキュリティ上の懸念によるものです。"
    },
    {
      "indent": 0,
      "text": "11. Interface with Upper Layer",
      "section_title": true,
      "ja": "11. 上層とのインターフェース"
    },
    {
      "indent": 3,
      "text": "The Upper Layer Protocols (ULPs) request services by passing primitives to SCTP and receive notifications from SCTP for various events.",
      "ja": "上層層プロトコル（ULPS）は、プリミティブをSCTPに渡し、さまざまなイベントのSCTPから通知を受け取ることによりサービスを要求します。"
    },
    {
      "indent": 3,
      "text": "The primitives and notifications described in this section can be used as a guideline for implementing SCTP. The following functional description of ULP interface primitives is shown for illustrative purposes. Different SCTP implementations can have different ULP interfaces. However, all SCTP implementations are expected to provide a certain minimum set of services to guarantee that all SCTP implementations can support the same protocol hierarchy.",
      "ja": "このセクションで説明するプリミティブと通知は、SCTPを実装するためのガイドラインとして使用できます。ULP界面のプリミティブの次の機能的な説明は、説明のために示されています。SCTPの実装が異なると、異なるULPインターフェイスがあります。ただし、すべてのSCTP実装は、すべてのSCTP実装が同じプロトコル階層をサポートできることを保証するために、特定の最小セットのサービスを提供することが期待されています。"
    },
    {
      "indent": 3,
      "text": "Please note that this section is informational only.",
      "ja": "このセクションは情報のみであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "[RFC6458] and Section 7 (\"Socket API Considerations\") of [RFC7053] define an extension of the socket API for SCTP as described in this document.",
      "ja": "[RFC6458]および[RFC7053]のセクション7（「ソケットAPI考慮事項」）は、このドキュメントで説明されているSCTPのソケットAPIの拡張を定義します。"
    },
    {
      "indent": 0,
      "text": "11.1. ULP-to-SCTP",
      "section_title": true,
      "ja": "11.1. ULP-to-SCTP"
    },
    {
      "indent": 3,
      "text": "The following sections functionally characterize a ULP/SCTP interface. The notation used is similar to most procedure or function calls in high-level languages.",
      "ja": "次のセクションは、ULP/SCTPインターフェイスを機能的に特徴付けます。使用される表記は、高レベルの言語でのほとんどの手順または関数呼び出しに似ています。"
    },
    {
      "indent": 3,
      "text": "The ULP primitives described below specify the basic functions that SCTP performs to support inter-process communication. Individual implementations define their own exact format and provide combinations or subsets of the basic functions in single calls.",
      "ja": "以下に説明するULPプリミティブは、SCTPが実行するために実行する基本的な機能を指定します。個々の実装は、独自の正確な形式を定義し、単一呼び出しで基本関数の組み合わせまたはサブセットを提供します。"
    },
    {
      "indent": 0,
      "text": "11.1.1. Initialize",
      "section_title": true,
      "ja": "11.1.1. 初期化"
    },
    {
      "indent": 3,
      "text": "INITIALIZE ([local port],[local eligible address list]) -> local SCTP instance name",
      "ja": "初期化（[ローカルポート]、[ローカル資格のあるアドレスリスト]） - >ローカルSCTPインスタンス名"
    },
    {
      "indent": 3,
      "text": "This primitive allows SCTP to initialize its internal data structures and allocate necessary resources for setting up its operation environment. Once SCTP is initialized, ULP can communicate directly with other endpoints without re-invoking this primitive.",
      "ja": "この原始により、SCTPは内部データ構造を初期化し、操作環境を設定するために必要なリソースを割り当てることができます。SCTPが初期化されると、ULPはこのプリミティブを再拒否せずに他のエンドポイントと直接通信できます。"
    },
    {
      "indent": 3,
      "text": "SCTP will return a local SCTP instance name to the ULP.",
      "ja": "SCTPは、ローカルSCTPインスタンス名をULPに返します。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: None.",
      "ja": "必須属性：なし。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: local port: SCTP port number, if ULP wants it to be specified.",
      "ja": "オプションの属性：ローカルポート：SCTPポート番号、ULPが指定したい場合。"
    },
    {
      "indent": 6,
      "text": "local eligible address list: an address list that the local SCTP endpoint binds. By default, if an address list is not included, all IP addresses assigned to the host are used by the local endpoint.",
      "ja": "ローカル資格のあるアドレスリスト：ローカルSCTPエンドポイントがバインドするアドレスリスト。デフォルトでは、アドレスリストが含まれていない場合、ホストに割り当てられたすべてのIPアドレスがローカルエンドポイントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: If this optional attribute is supported by an implementation, it will be the responsibility of the implementation to enforce that the IP source address field of any SCTP packets sent by this endpoint contains one of the IP addresses indicated in the local eligible address list.",
      "ja": "実装注：このオプションの属性が実装によってサポートされている場合、このエンドポイントによって送信されたSCTPパケットのIPソースアドレスフィールドに、ローカル適格アドレスリストに示されているIPアドレスの1つが含まれていることを実装することは実装の責任です。。"
    },
    {
      "indent": 0,
      "text": "11.1.2. Associate",
      "section_title": true,
      "ja": "11.1.2. 仲間、同僚"
    },
    {
      "indent": 3,
      "text": "ASSOCIATE(local SCTP instance name, initial destination transport addr list, outbound stream count) -> association id [,destination transport addr list] [,outbound stream count]",
      "ja": "アソシエイト（ローカルSCTPインスタンス名、初期宛先輸送ADDRリスト、アウトバウンドストリームカウント） - > Association ID [、宛先輸送ADDRリスト] [、アウトバウンドストリームカウント]"
    },
    {
      "indent": 3,
      "text": "This primitive allows the upper layer to initiate an association to a specific peer endpoint.",
      "ja": "この原始により、上層が特定のピアエンドポイントに関連性を開始できます。"
    },
    {
      "indent": 3,
      "text": "The peer endpoint is specified by one or more of the transport addresses that defines the endpoint (see Section 1.3). If the local SCTP instance has not been initialized, the ASSOCIATE is considered an error.",
      "ja": "ピアエンドポイントは、エンドポイントを定義する1つ以上の輸送アドレスによって指定されています（セクション1.3を参照）。ローカルSCTPインスタンスが初期化されていない場合、アソシエイトはエラーと見なされます。"
    },
    {
      "indent": 3,
      "text": "An association id, which is a local handle to the SCTP association, will be returned on successful establishment of the association. If SCTP is not able to open an SCTP association with the peer endpoint, an error is returned.",
      "ja": "SCTP協会のローカルハンドルである協会IDは、協会の成功した設立により返されます。SCTPがピアエンドポイントとSCTP関連を開くことができない場合、エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Other association parameters can be returned, including the complete destination transport addresses of the peer as well as the outbound stream count of the local endpoint. One of the transport addresses from the returned destination addresses will be selected by the local endpoint as the default primary path for sending SCTP packets to this peer. The returned \"destination transport addr list\" can be used by the ULP to change the default primary path or to force sending a packet to a specific transport address.",
      "ja": "ピアの完全な宛先輸送アドレスやローカルエンドポイントのアウトバウンドストリームカウントなど、他の関連付けパラメーターを返すことができます。返された宛先アドレスからの輸送アドレスの1つは、このピアにSCTPパケットを送信するためのデフォルトのプライマリパスとしてローカルエンドポイントによって選択されます。返された「Destination Transport AddRリスト」は、ULPがデフォルトのプライマリパスを変更するか、特定の輸送アドレスにパケットを強制的に送信するために使用できます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: If the ASSOCIATE primitive is implemented as a blocking function call, the ASSOCIATE primitive can return association parameters in addition to the association id upon successful establishment. If ASSOCIATE primitive is implemented as a non-blocking call, only the association id is returned and association parameters are passed using the COMMUNICATION UP notification.",
      "ja": "実装注：アソシエイトプリミティブがブロッキング関数呼び出しとして実装されている場合、アソシエイトプリミティブは、成功した確立時にアソシエーションIDに加えてアソシエーションパラメーターを返すことができます。アソシエイトプリミティブが非ブロッキングコールとして実装されている場合、Association IDのみが返され、Association Parametersは通信アップ通知を使用して渡されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: local SCTP instance name: obtained from the INITIALIZE operation.",
      "ja": "必須属性：ローカルSCTPインスタンス名：初期化操作から取得。"
    },
    {
      "indent": 6,
      "text": "initial destination transport addr list: a non-empty list of transport addresses of the peer endpoint with which the association is to be established.",
      "ja": "初期宛先輸送ADDRリスト：協会が確立されるピアエンドポイントの輸送住所の空白のリスト。"
    },
    {
      "indent": 6,
      "text": "outbound stream count: the number of outbound streams the ULP would like to open towards this peer endpoint.",
      "ja": "アウトバウンドストリームカウント：ULPがこのピアエンドポイントに向けて開きたいアウトバウンドストリームの数。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: None.",
      "ja": "オプションの属性：なし。"
    },
    {
      "indent": 0,
      "text": "11.1.3. Shutdown",
      "section_title": true,
      "ja": "11.1.3. シャットダウン"
    },
    {
      "indent": 3,
      "text": "SHUTDOWN(association id) -> result",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Gracefully closes an association. Any locally queued user data will be delivered to the peer. The association will be terminated only after the peer acknowledges all the SCTP packets sent. A success code will be returned on successful termination of the association. If attempting to terminate the association results in a failure, an error code is returned.",
      "ja": "関連性を優雅に閉じます。ローカルでキューに囲まれたユーザーデータは、ピアに配信されます。協会は、ピアが送信されたすべてのSCTPパケットを認めた後にのみ終了します。成功コードは、協会の成功した終了時に返されます。協会を終了しようとすると、障害が発生すると、エラーコードが返されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: None.",
      "ja": "オプションの属性：なし。"
    },
    {
      "indent": 0,
      "text": "11.1.4. Abort",
      "section_title": true,
      "ja": "11.1.4. アボート"
    },
    {
      "indent": 3,
      "text": "ABORT(association id [, Upper Layer Abort Reason]) -> result",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ungracefully closes an association. Any locally queued user data will be discarded, and an ABORT chunk is sent to the peer. A success code will be returned on successful abort of the association. If attempting to abort the association results in a failure, an error code is returned.",
      "ja": "協会を不平を言っています。ローカルでキューに囲まれたユーザーデータは破棄され、中止チャンクがピアに送信されます。成功コードは、協会の成功した中絶で返されます。協会を中止しようとすると、障害が発生した場合、エラーコードが返されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: Upper Layer Abort Reason: reason of the abort to be passed to the peer.",
      "ja": "オプションの属性：上層層中絶理由：中止の理由がピアに渡される理由。"
    },
    {
      "indent": 0,
      "text": "11.1.5. Send",
      "section_title": true,
      "ja": "11.1.5. 送信"
    },
    {
      "indent": 3,
      "text": "SEND(association id, buffer address, byte count [,context]\n[,stream id] [,life time] [,destination transport address]\n[,unordered flag] [,no-bundle flag] [,payload protocol-id]\n[,sack-immediately flag]) -> result",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This is the main method to send user data via SCTP.",
      "ja": "これは、SCTPを介してユーザーデータを送信する主な方法です。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "buffer address: the location where the user message to be transmitted is stored.",
      "ja": "バッファアドレス：送信されるユーザーメッセージが保存される場所。"
    },
    {
      "indent": 6,
      "text": "byte count: the size of the user data in number of bytes.",
      "ja": "バイト数：バイト数のユーザーデータのサイズ。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: context: optional information provided that will be carried in the SEND FAILURE notification to the ULP if the transportation of this user message fails.",
      "ja": "オプションの属性：コンテキスト：このユーザーメッセージの輸送が失敗した場合、ULPへの送信障害通知で送信されるオプションの情報が提供されます。"
    },
    {
      "indent": 6,
      "text": "stream id: indicates which stream to send the data on. If not specified, stream 0 will be used.",
      "ja": "ストリームID：データを送信するストリームを示します。指定されていない場合、ストリーム0が使用されます。"
    },
    {
      "indent": 6,
      "text": "life time: specifies the life time of the user data. The user data will not be sent by SCTP after the life time expires. This parameter can be used to avoid efforts to transmit stale user messages. SCTP notifies the ULP if the data cannot be initiated to transport (i.e., sent to the destination via SCTP's SEND primitive) within the life time variable. However, the user data will be transmitted if SCTP has attempted to transmit a chunk before the life time expired.",
      "ja": "寿命：ユーザーデータの寿命を指定します。ユーザーデータは、寿命が経過した後、SCTPによって送信されません。このパラメーターは、古いユーザーメッセージを送信する努力を回避するために使用できます。SCTPは、寿命変数内でデータを輸送するためにデータを開始できない場合（つまり、SCTPのSend Primitiveを介して宛先に送信される）、ULPに通知します。ただし、SCTPが寿命が切れる前にチャンクを送信しようとした場合、ユーザーデータは送信されます。"
    },
    {
      "indent": 9,
      "text": "Implementation Note: In order to better support the data life time option, the transmitter can hold back the assigning of the TSN number to an outbound DATA chunk to the last moment. And, for implementation simplicity, once a TSN number has been assigned, the sender considers the send of this DATA chunk as committed, overriding any life time option attached to the DATA chunk.",
      "ja": "実装注：データライフタイムオプションをより適切にサポートするために、送信機はTSN番号のアウトバウンドデータチャンクへの割り当てを最後の瞬間に抑えることができます。また、実装の単純さのために、TSN番号が割り当てられたら、送信者はこのデータチャンクの送信をコミットし、データチャンクに添付された任意の寿命オプションをオーバーライドします。"
    },
    {
      "indent": 6,
      "text": "destination transport address: specified as one of the destination transport addresses of the peer endpoint to which this packet is sent. Whenever possible, SCTP uses this destination transport address for sending the packets, instead of the current primary path.",
      "ja": "宛先輸送住所：このパケットが送信されるピアエンドポイントの宛先輸送アドレスの1つとして指定されています。可能な限り、SCTPは、現在のプライマリパスではなく、パケットを送信するためにこの宛先輸送アドレスを使用します。"
    },
    {
      "indent": 6,
      "text": "unordered flag: this flag, if present, indicates that the user would like the data delivered in an unordered fashion to the peer (i.e., the U flag is set to 1 on all DATA chunks carrying this message).",
      "ja": "順序付けられていないフラグ：このフラグは、存在する場合、ユーザーがピアに順序付けられていないファッションで配信されるデータを望んでいることを示します（つまり、Uフラグは、このメッセージを伝えるすべてのデータチャンクで1に設定されます）。"
    },
    {
      "indent": 6,
      "text": "no-bundle flag: instructs SCTP not to delay the sending of DATA chunks for this user data just to allow it to be bundled with other outbound DATA chunks. When faced with network congestion, SCTP might still bundle the data, even when this flag is present.",
      "ja": "バンドルフラグなし：他のアウトバウンドデータチャンクにバンドルできるように、このユーザーデータのデータチャンクの送信を遅らせないようにSCTPに指示します。ネットワークの混雑に直面している場合、SCTPは、このフラグが存在する場合でもデータをバンドルする可能性があります。"
    },
    {
      "indent": 6,
      "text": "payload protocol-id: a 32-bit unsigned integer that is to be passed to the peer, indicating the type of payload protocol data being transmitted. Note that the upper layer is responsible for the host to network byte order conversion of this field, which is passed by SCTP as 4 bytes of opaque data.",
      "ja": "Payload Protocol-ID：ピアに渡される32ビットの符号なし整数で、送信されるペイロードプロトコルデータのタイプを示します。上層層は、このフィールドのネットワークバイトの順序変換に責任があることに注意してください。このフィールドは、SCTPによって4バイトの不透明なデータとして渡されます。"
    },
    {
      "indent": 6,
      "text": "sack-immediately flag: set the I bit on the last DATA chunk used for the user message to be transmitted.",
      "ja": "sack-medielyフラグ：ユーザーメッセージが送信される最後のデータチャンクにiビットを設定します。"
    },
    {
      "indent": 0,
      "text": "11.1.6. Set Primary",
      "section_title": true,
      "ja": "11.1.6. プライマリを設定します"
    },
    {
      "indent": 3,
      "text": "SETPRIMARY(association id, destination transport address, [source transport address]) -> result",
      "ja": "SetPrimary（Association ID、宛先輸送アドレス、[ソース輸送アドレス]） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local SCTP to use the specified destination transport address as the primary path for sending packets.",
      "ja": "ローカルSCTPに、指定された宛先輸送アドレスをパケットを送信するための主要なパスとして使用するよう指示します。"
    },
    {
      "indent": 3,
      "text": "The result of attempting this operation is returned. If the specified destination transport address is not present in the \"destination transport address list\" returned earlier in an ASSOCIATE primitive or COMMUNICATION UP notification, an error is returned.",
      "ja": "この操作を試みた結果が返されます。指定された宛先輸送アドレスが「宛先輸送アドレスリスト」に存在しない場合、アソシエイトプリミティブまたは通信アップ通知で早期に返された場合、エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "destination transport address: specified as one of the transport addresses of the peer endpoint, which is used as the primary address for sending packets. This overrides the current primary address information maintained by the local SCTP endpoint.",
      "ja": "宛先輸送アドレス：ピアエンドポイントの輸送アドレスの1つとして指定されています。これは、パケットの送信の主要アドレスとして使用されます。これは、ローカルSCTPエンドポイントによって維持されている現在のプライマリアドレス情報をオーバーライドします。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: source transport address: optionally, some implementations can allow you to set the default source address placed in all outgoing IP datagrams.",
      "ja": "オプションの属性：ソーストランスポートアドレス：オプションで、一部の実装では、すべての発信IPデータグラムに配置されたデフォルトのソースアドレスを設定できます。"
    },
    {
      "indent": 0,
      "text": "11.1.7. Receive",
      "section_title": true,
      "ja": "11.1.7. 受け取る"
    },
    {
      "indent": 3,
      "text": "RECEIVE(association id, buffer address, buffer size [,stream id]) -> byte count [,transport address] [,stream id] [,stream sequence number] [,partial flag] [,payload protocol-id]",
      "ja": "受信（Association ID、バッファーアドレス、バッファサイズ[、ストリームID]） - >バイトカウント[、トランスポートアドレス] [、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、ペイロードプロトコル-ID]"
    },
    {
      "indent": 3,
      "text": "This primitive reads the first user message in the SCTP in-queue into the buffer specified by ULP, if there is one available. The size of the message read, in bytes, will be returned. It might, depending on the specific implementation, also return other information, such as the sender's address, the stream id on which it is received, whether there are more messages available for retrieval, etc. For ordered messages, their Stream Sequence Number might also be returned.",
      "ja": "このプリミティブは、利用可能な場合がある場合、ULPで指定されたバッファーにsctp in-queueの最初のユーザーメッセージを読み取ります。読み取られたメッセージのサイズは、バイトで返されます。特定の実装に応じて、送信者のアドレス、受信したストリームID、検索用に利用可能なメッセージが増えるかどうかなど、他の情報を返します。返品されます。"
    },
    {
      "indent": 3,
      "text": "Depending upon the implementation, if this primitive is invoked when no message is available, the implementation returns an indication of this condition or blocks the invoking process until data does become available.",
      "ja": "実装に応じて、メッセージが利用できないときにこのプリミティブが呼び出された場合、実装はこの条件の表示を返したり、データが利用可能になるまで呼び出しプロセスをブロックします。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "buffer address: the memory location indicated by the ULP to store the received message.",
      "ja": "バッファアドレス：受信したメッセージを保存するためにULPが示すメモリの位置。"
    },
    {
      "indent": 6,
      "text": "buffer size: the maximum size of data to be received, in bytes.",
      "ja": "バッファサイズ：受信するデータの最大サイズ、バイト。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: stream id: to indicate which stream to receive the data on.",
      "ja": "オプションの属性：ストリームID：データを受信するストリームを示すため。"
    },
    {
      "indent": 6,
      "text": "stream sequence number: the Stream Sequence Number assigned by the sending SCTP peer.",
      "ja": "ストリームシーケンス番号：SCTPピアの送信によって割り当てられたストリームシーケンス番号。"
    },
    {
      "indent": 6,
      "text": "partial flag: if this returned flag is set to 1, then this primitive contains a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number accompanies this primitive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "部分フラグ：この返されたフラグが1に設定されている場合、この原始にはメッセージ全体の部分的な配信が含まれています。このフラグが設定されると、ストリームIDとストリームシーケンス番号がこのプリミティブに伴います。このフラグが0に設定されている場合、このストリームシーケンス番号に対してこれ以上配信が受信されないことを示します。"
    },
    {
      "indent": 6,
      "text": "payload protocol-id: a 32-bit unsigned integer that is received from the peer indicating the type of payload protocol of the received data. Note that the upper layer is responsible for the host to network byte order conversion of this field, which is passed by SCTP as 4 bytes of opaque data.",
      "ja": "ペイロードプロトコルID：受信したデータのペイロードプロトコルのタイプを示すピアから受信される32ビットの非署名整数。上層層は、このフィールドのネットワークバイトの順序変換に責任があることに注意してください。このフィールドは、SCTPによって4バイトの不透明なデータとして渡されます。"
    },
    {
      "indent": 0,
      "text": "11.1.8. Status",
      "section_title": true,
      "ja": "11.1.8. 状態"
    },
    {
      "indent": 3,
      "text": "STATUS(association id) -> status data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This primitive returns a data block containing the following information:",
      "ja": "このプリミティブは、次の情報を含むデータブロックを返します。"
    },
    {
      "indent": 3,
      "text": "* association connection state,",
      "ja": "* アソシエーション接続状態、"
    },
    {
      "indent": 3,
      "text": "* destination transport address list,",
      "ja": "* 宛先輸送アドレスリスト、"
    },
    {
      "indent": 3,
      "text": "* destination transport address reachability states,",
      "ja": "* 宛先輸送アドレスの到達可能状態、"
    },
    {
      "indent": 3,
      "text": "* current receiver window size,",
      "ja": "* 現在のレシーバーウィンドウサイズ、"
    },
    {
      "indent": 3,
      "text": "* current congestion window sizes,",
      "ja": "* 現在の混雑ウィンドウサイズ、"
    },
    {
      "indent": 3,
      "text": "* number of unacknowledged DATA chunks,",
      "ja": "* 未承認のデータチャンクの数、"
    },
    {
      "indent": 3,
      "text": "* number of DATA chunks pending receipt,",
      "ja": "* 保留中のデータチャンクの数、"
    },
    {
      "indent": 3,
      "text": "* primary path,",
      "ja": "* 主要な道、"
    },
    {
      "indent": 3,
      "text": "* most recent SRTT on primary path,",
      "ja": "* プライマリパスに関する最新のSRTT、"
    },
    {
      "indent": 3,
      "text": "* RTO on primary path,",
      "ja": "* プライマリパスでのRTO、"
    },
    {
      "indent": 3,
      "text": "* SRTT and RTO on other destination addresses, etc.",
      "ja": "* 他の宛先アドレスなどでのSRTTおよびRTO。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: None.",
      "ja": "オプションの属性：なし。"
    },
    {
      "indent": 0,
      "text": "11.1.9. Change Heartbeat",
      "section_title": true,
      "ja": "11.1.9. ハートビートを変更します"
    },
    {
      "indent": 3,
      "text": "CHANGE HEARTBEAT(association id, destination transport address, new state [,interval]) -> result",
      "ja": "ハートビートを変更する（協会ID、宛先輸送アドレス、新しい状態[、間隔]） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local endpoint to enable or disable heartbeat on the specified destination transport address.",
      "ja": "指定された宛先輸送アドレスでハートビートを有効または無効にするようにローカルエンドポイントに指示します。"
    },
    {
      "indent": 3,
      "text": "The result of attempting this operation is returned.",
      "ja": "この操作を試みた結果が返されます。"
    },
    {
      "indent": 3,
      "text": "Note: Even when enabled, heartbeat will not take place if the destination transport address is not idle.",
      "ja": "注：有効にしても、宛先輸送アドレスがアイドル状態でない場合、ハートビートは行われません。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "destination transport address: specified as one of the transport addresses of the peer endpoint.",
      "ja": "宛先輸送住所：ピアエンドポイントの輸送アドレスの1つとして指定されています。"
    },
    {
      "indent": 6,
      "text": "new state: the new state of heartbeat for this destination transport address (either enabled or disabled).",
      "ja": "新しい状態：この宛先輸送アドレスの新しいハートビートの状態（有効または無効）。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: interval: if present, indicates the frequency of the heartbeat if this is to enable heartbeat on a destination transport address. This value is added to the RTO of the destination transport address. This value, if present, affects all destinations.",
      "ja": "オプションの属性：間隔：存在する場合、これが宛先輸送アドレスでハートビートを有効にするために心拍の頻度を示します。この値は、宛先輸送アドレスのRTOに追加されます。この値は、存在する場合、すべての目的地に影響します。"
    },
    {
      "indent": 0,
      "text": "11.1.10. Request Heartbeat",
      "section_title": true,
      "ja": "11.1.10. ハートビートをリクエストします"
    },
    {
      "indent": 3,
      "text": "REQUESTHEARTBEAT(association id, destination transport address) -> result",
      "ja": "RequestHeartBeat（Association ID、宛先輸送アドレス） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local endpoint to perform a heartbeat on the specified destination transport address of the given association. The returned result indicates whether the transmission of the HEARTBEAT chunk to the destination address is successful.",
      "ja": "指定された協会の指定された宛先輸送アドレスでハートビートを実行するようローカルエンドポイントに指示します。返された結果は、宛先アドレスへのハートビートチャンクの送信が成功しているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "destination transport address: the transport address of the association on which a heartbeat is issued.",
      "ja": "宛先輸送住所：ハートビートが発行された協会の輸送住所。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: None.",
      "ja": "オプションの属性：なし。"
    },
    {
      "indent": 0,
      "text": "11.1.11. Get SRTT Report",
      "section_title": true,
      "ja": "11.1.11. SRTTレポートを入手してください"
    },
    {
      "indent": 3,
      "text": "GETSRTTREPORT(association id, destination transport address) -> srtt result",
      "ja": "GetSrtTreport（Association ID、宛先輸送アドレス） - > SRTT結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local SCTP to report the current SRTT measurement on the specified destination transport address of the given association. The returned result can be an integer containing the most recent SRTT in milliseconds.",
      "ja": "地元のSCTPに、指定された関連付けの指定された宛先輸送アドレスに関する現在のSRTT測定を報告するよう指示します。返された結果は、ミリ秒単位での最新のSRTTを含む整数である可能性があります。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "destination transport address: the transport address of the association on which the SRTT measurement is to be reported.",
      "ja": "宛先輸送住所：SRTT測定が報告される関連付けの輸送アドレス。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: None.",
      "ja": "オプションの属性：なし。"
    },
    {
      "indent": 0,
      "text": "11.1.12. Set Failure Threshold",
      "section_title": true,
      "ja": "11.1.12. 障害のしきい値を設定します"
    },
    {
      "indent": 3,
      "text": "SETFAILURETHRESHOLD(association id, destination transport address, failure threshold) -> result",
      "ja": "setFailureThreshold（Association ID、宛先輸送アドレス、障害のしきい値） - >結果"
    },
    {
      "indent": 3,
      "text": "This primitive allows the local SCTP to customize the reachability failure detection threshold 'Path.Max.Retrans' for the specified destination address. Note that this can also be done using the SETPROTOCOLPARAMETERS primitive (Section 11.1.13).",
      "ja": "このプリミティブにより、ローカルSCTPは、指定された宛先アドレスの到達可能性障害検出しきい値「path.max.retrans」をカスタマイズできます。これは、SetProtocolparametersプリミティブを使用して実行できることに注意してください（セクション11.1.13）。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "destination transport address: the transport address of the association on which the failure detection threshold is to be set.",
      "ja": "宛先輸送住所：故障検出しきい値が設定される関連付けの輸送アドレス。"
    },
    {
      "indent": 6,
      "text": "failure threshold: the new value of 'Path.Max.Retrans' for the destination address.",
      "ja": "障害のしきい値：宛先アドレスの「path.max.retrans」の新しい値。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: None.",
      "ja": "オプションの属性：なし。"
    },
    {
      "indent": 0,
      "text": "11.1.13. Set Protocol Parameters",
      "section_title": true,
      "ja": "11.1.13. プロトコルパラメーターを設定します"
    },
    {
      "indent": 3,
      "text": "SETPROTOCOLPARAMETERS(association id, [destination transport address,] protocol parameter list) -> result",
      "ja": "SetProtoColParameters（Association ID、[宛先輸送アドレス]プロトコルパラメーターリスト） - >結果"
    },
    {
      "indent": 3,
      "text": "This primitive allows the local SCTP to customize the protocol parameters.",
      "ja": "この原始により、ローカルSCTPはプロトコルパラメーターをカスタマイズできます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: association id: local handle to the SCTP association.",
      "ja": "必須属性：Association ID：SCTP Associationのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "protocol parameter list: the specific names and values of the protocol parameters (e.g., 'Association.Max.Retrans' (see Section 16) or other parameters like the DSCP) that the SCTP user wishes to customize.",
      "ja": "プロトコルパラメーターリスト：SCTPユーザーがカスタマイズしたいプロトコルパラメーター（ 'Association.max.retrans'（セクション16を参照）またはDSCPのようなその他のパラメーター）の特定の名前と値。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: destination transport address: some of the protocol parameters might be set on a per-destination-transport-address basis.",
      "ja": "オプションの属性：宛先輸送アドレス：プロトコルパラメーターの一部は、輸送ごとのアドレス（アドレス）に基づいて設定される場合があります。"
    },
    {
      "indent": 0,
      "text": "11.1.14. Receive Unsent Message",
      "section_title": true,
      "ja": "11.1.14. 安全でないメッセージを受信します"
    },
    {
      "indent": 3,
      "text": "RECEIVE_UNSENT(data retrieval id, buffer address, buffer size [,stream id] [, stream sequence number] [,partial flag] [,payload protocol-id])",
      "ja": "receive_unsent（データ取得ID、バッファアドレス、バッファサイズ[、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、ペイロードプロトコル-ID]））"
    },
    {
      "indent": 3,
      "text": "This primitive reads a user message that has never been sent into the buffer specified by ULP.",
      "ja": "このプリミティブは、ULPによって指定されたバッファに送信されたことがないユーザーメッセージを読み取ります。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: data retrieval id: the identification passed to the ULP in the SEND FAILURE notification.",
      "ja": "必須属性：データ取得ID：send障害通知でULPに渡された識別。"
    },
    {
      "indent": 6,
      "text": "buffer address: the memory location indicated by the ULP to store the received message.",
      "ja": "バッファアドレス：受信したメッセージを保存するためにULPが示すメモリの位置。"
    },
    {
      "indent": 6,
      "text": "buffer size: the maximum size of data to be received, in bytes.",
      "ja": "バッファサイズ：受信するデータの最大サイズ、バイト。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: stream id: this is a return value that is set to indicate which stream the data was sent to.",
      "ja": "オプションの属性：ストリームID：これは、データが送信されたストリームを示すように設定されている返品値です。"
    },
    {
      "indent": 6,
      "text": "stream sequence number: this value is returned, indicating the Stream Sequence Number that was associated with the message.",
      "ja": "ストリームシーケンス番号：この値は返され、メッセージに関連付けられたストリームシーケンス番号を示します。"
    },
    {
      "indent": 6,
      "text": "partial flag: if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number accompanies this primitive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "部分フラグ：この返されたフラグが1に設定されている場合、このメッセージはメッセージ全体の部分的な配信です。このフラグが設定されると、ストリームIDとストリームシーケンス番号がこのプリミティブに伴います。このフラグが0に設定されている場合、このストリームシーケンス番号に対してこれ以上配信が受信されないことを示します。"
    },
    {
      "indent": 6,
      "text": "payload protocol-id: The 32-bit unsigned integer that was set to be sent to the peer, indicating the type of payload protocol of the received data.",
      "ja": "ペイロードプロトコルID：ピアに送信されるように設定された32ビットの符号なし整数で、受信したデータのペイロードプロトコルのタイプを示します。"
    },
    {
      "indent": 0,
      "text": "11.1.15. Receive Unacknowledged Message",
      "section_title": true,
      "ja": "11.1.15. 未承認のメッセージを受信します"
    },
    {
      "indent": 3,
      "text": "RECEIVE_UNACKED(data retrieval id, buffer address, buffer size, [,stream id] [,stream sequence number] [,partial flag] [,payload protocol-id])",
      "ja": "receive_unacked（データ取得ID、バッファアドレス、バッファサイズ、[、ストリームID] [、ストリームシーケンス番号] [、部分フラグ] [、ペイロードプロトコルID]））"
    },
    {
      "indent": 3,
      "text": "This primitive reads a user message that has been sent and has not been acknowledged by the peer into the buffer specified by ULP.",
      "ja": "このプリミティブは、PEERがULPによって指定されたバッファーに紹介されていないユーザーメッセージを読み取ります。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: data retrieval id: the identification passed to the ULP in the SEND FAILURE notification.",
      "ja": "必須属性：データ取得ID：send障害通知でULPに渡された識別。"
    },
    {
      "indent": 6,
      "text": "buffer address: the memory location indicated by the ULP to store the received message.",
      "ja": "バッファアドレス：受信したメッセージを保存するためにULPが示すメモリの位置。"
    },
    {
      "indent": 6,
      "text": "buffer size: the maximum size of data to be received, in bytes.",
      "ja": "バッファサイズ：受信するデータの最大サイズ、バイト。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: stream id: this is a return value that is set to indicate which stream the data was sent to.",
      "ja": "オプションの属性：ストリームID：これは、データが送信されたストリームを示すように設定されている返品値です。"
    },
    {
      "indent": 6,
      "text": "stream sequence number: this value is returned, indicating the Stream Sequence Number that was associated with the message.",
      "ja": "ストリームシーケンス番号：この値は返され、メッセージに関連付けられたストリームシーケンス番号を示します。"
    },
    {
      "indent": 6,
      "text": "partial flag: if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number accompanies this primitive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "部分フラグ：この返されたフラグが1に設定されている場合、このメッセージはメッセージ全体の部分的な配信です。このフラグが設定されると、ストリームIDとストリームシーケンス番号がこのプリミティブに伴います。このフラグが0に設定されている場合、このストリームシーケンス番号に対してこれ以上配信が受信されないことを示します。"
    },
    {
      "indent": 6,
      "text": "payload protocol-id: the 32-bit unsigned integer that was sent to the peer indicating the type of payload protocol of the received data.",
      "ja": "ペイロードプロトコルID：受信したデータのペイロードプロトコルのタイプを示すピアに送信された32ビットの符号なし整数。"
    },
    {
      "indent": 0,
      "text": "11.1.16. Destroy SCTP Instance",
      "section_title": true,
      "ja": "11.1.16. SCTPインスタンスを破壊します"
    },
    {
      "indent": 3,
      "text": "DESTROY(local SCTP instance name)",
      "ja": "Destroy（ローカルSCTPインスタンス名）"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes: local SCTP instance name: this is the value that was passed to the application in the initialize primitive and it indicates which SCTP instance is to be destroyed.",
      "ja": "必須属性：ローカルSCTPインスタンス名：これは、初期化のプリミティブ化のアプリケーションに渡された値であり、どのSCTPインスタンスが破壊されるかを示します。"
    },
    {
      "indent": 3,
      "text": "Optional attributes: None.",
      "ja": "オプションの属性：なし。"
    },
    {
      "indent": 0,
      "text": "11.2. SCTP-to-ULP",
      "section_title": true,
      "ja": "11.2. sctp-to-unp"
    },
    {
      "indent": 3,
      "text": "It is assumed that the operating system or application environment provides a means for the SCTP to asynchronously signal the ULP process. When SCTP does signal a ULP process, certain information is passed to the ULP.",
      "ja": "オペレーティングシステムまたはアプリケーション環境は、SCTPがULPプロセスを非同期的に信号する手段を提供すると想定されています。SCTPがULPプロセスを通知すると、特定の情報がULPに渡されます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: In some cases, this might be done through a separate socket or error channel.",
      "ja": "実装注：場合によっては、これは別のソケットまたはエラーチャネルを介して実行される場合があります。"
    },
    {
      "indent": 0,
      "text": "11.2.1. DATA ARRIVE Notification",
      "section_title": true,
      "ja": "11.2.1. データは通知に到着します"
    },
    {
      "indent": 3,
      "text": "SCTP invokes this notification on the ULP when a user message is successfully received and ready for retrieval.",
      "ja": "SCTPは、ユーザーメッセージが正常に受信され、検索の準備ができたときにULPに関するこの通知を呼び出します。"
    },
    {
      "indent": 3,
      "text": "The following might optionally be passed with the notification:",
      "ja": "以下は、オプションで通知とともに渡される場合があります。"
    },
    {
      "indent": 3,
      "text": "association id: local handle to the SCTP association.",
      "ja": "協会ID：SCTP協会のローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "stream id: to indicate which stream the data is received on.",
      "ja": "ストリームID：データが受信されるストリームを示すため。"
    },
    {
      "indent": 0,
      "text": "11.2.2. SEND FAILURE Notification",
      "section_title": true,
      "ja": "11.2.2. 失敗通知を送信します"
    },
    {
      "indent": 3,
      "text": "If a message cannot be delivered, SCTP invokes this notification on the ULP.",
      "ja": "メッセージを配信できない場合、SCTPはULPでこの通知を呼び出します。"
    },
    {
      "indent": 3,
      "text": "The following might optionally be passed with the notification:",
      "ja": "以下は、オプションで通知とともに渡される場合があります。"
    },
    {
      "indent": 3,
      "text": "association id: local handle to the SCTP association.",
      "ja": "協会ID：SCTP協会のローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "data retrieval id: an identification used to retrieve unsent and unacknowledged data.",
      "ja": "データ取得ID：無セントおよび未充填データの取得に使用される識別。"
    },
    {
      "indent": 3,
      "text": "mode: indicates whether no part of the message never has been sent or if at least part of it has been sent but it is not completely acknowledged.",
      "ja": "モード：メッセージの一部が送信されていないかどうか、または少なくともその一部が送信されたが、完全には認められていないかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "cause code: indicating the reason of the failure, e.g., size too large, message life time expiration, etc.",
      "ja": "原因コード：障害の理由、たとえば大きすぎるサイズ、メッセージの時間の有効期限などを示します。"
    },
    {
      "indent": 3,
      "text": "context: optional information associated with this message (see Section 11.1.5).",
      "ja": "コンテキスト：このメッセージに関連付けられたオプションの情報（セクション11.1.5を参照）。"
    },
    {
      "indent": 0,
      "text": "11.2.3. NETWORK STATUS CHANGE Notification",
      "section_title": true,
      "ja": "11.2.3. ネットワークステータスの変更通知"
    },
    {
      "indent": 3,
      "text": "When a destination transport address is marked inactive (e.g., when SCTP detects a failure) or marked active (e.g., when SCTP detects a recovery), SCTP invokes this notification on the ULP.",
      "ja": "宛先輸送アドレスが不活性にマークされている場合（たとえば、SCTPが障害を検出する場合）またはマークされたアクティブ（例：SCTPが回復を検出する場合）、SCTPはULPでこの通知を呼び出します。"
    },
    {
      "indent": 3,
      "text": "The following is passed with the notification:",
      "ja": "以下に通知が渡されます。"
    },
    {
      "indent": 3,
      "text": "association id: local handle to the SCTP association.",
      "ja": "協会ID：SCTP協会のローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "destination transport address: this indicates the destination transport address of the peer endpoint affected by the change.",
      "ja": "宛先輸送住所：これは、変更の影響を受けるピアエンドポイントの宛先輸送アドレスを示します。"
    },
    {
      "indent": 3,
      "text": "new-status: this indicates the new status.",
      "ja": "New-status：これは、新しいステータスを示します。"
    },
    {
      "indent": 0,
      "text": "11.2.4. COMMUNICATION UP Notification",
      "section_title": true,
      "ja": "11.2.4. 通信通知"
    },
    {
      "indent": 3,
      "text": "This notification is used when SCTP becomes ready to send or receive user messages or when a lost communication to an endpoint is restored.",
      "ja": "この通知は、SCTPがユーザーメッセージの送信または受信の準備ができたとき、またはエンドポイントへの通信の紛失が復元されたときに使用されます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: If the ASSOCIATE primitive is implemented as a blocking function call, the association parameters are returned as a result of the ASSOCIATE primitive itself. In that case, the COMMUNICATION UP notification is optional at the association initiator's side.",
      "ja": "実装注：アソシエイトプリミティブがブロッキング関数呼び出しとして実装されている場合、アソシエイトプリミティブ自体の結果としてアソシエーションパラメーターが返されます。その場合、Associationイニシエーター側では通信通知がオプションです。"
    },
    {
      "indent": 3,
      "text": "The following is passed with the notification:",
      "ja": "以下に通知が渡されます。"
    },
    {
      "indent": 3,
      "text": "association id: local handle to the SCTP association.",
      "ja": "協会ID：SCTP協会のローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "status: this indicates what type of event has occurred.",
      "ja": "ステータス：これは、どのタイプのイベントが発生したかを示します。"
    },
    {
      "indent": 3,
      "text": "destination transport address list: the complete set of transport addresses of the peer.",
      "ja": "宛先輸送アドレスリスト：ピアの輸送アドレスの完全なセット。"
    },
    {
      "indent": 3,
      "text": "outbound stream count: the maximum number of streams allowed to be used in this association by the ULP.",
      "ja": "アウトバウンドストリームカウント：ULPがこの関連付けで使用できるストリームの最大数。"
    },
    {
      "indent": 3,
      "text": "inbound stream count: the number of streams the peer endpoint has requested with this association (this might not be the same number as 'outbound stream count').",
      "ja": "インバウンドストリームカウント：ピアエンドポイントがこの関連付けで要求したストリームの数（これは「アウトバウンドストリームカウント」と同じではない可能性があります）。"
    },
    {
      "indent": 0,
      "text": "11.2.5. COMMUNICATION LOST Notification",
      "section_title": true,
      "ja": "11.2.5. 通信は通知を失いました"
    },
    {
      "indent": 3,
      "text": "When SCTP loses communication to an endpoint completely (e.g., via Heartbeats) or detects that the endpoint has performed an abort operation, it invokes this notification on the ULP.",
      "ja": "SCTPがエンドポイントへの通信を完全に（ハートビート経由で）完全に失ったり、エンドポイントが中止操作を実行したことを検出すると、ULPでこの通知を呼び出します。"
    },
    {
      "indent": 3,
      "text": "The following is passed with the notification:",
      "ja": "以下に通知が渡されます。"
    },
    {
      "indent": 3,
      "text": "association id: local handle to the SCTP association.",
      "ja": "協会ID：SCTP協会のローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "status: this indicates what type of event has occurred; the status might indicate that a failure OR a normal termination event occurred in response to a shutdown or abort request.",
      "ja": "ステータス：これは、どのタイプのイベントが発生したかを示します。ステータスは、シャットダウンまたは中止要求に応じて障害または正常な終了イベントが発生したことを示している場合があります。"
    },
    {
      "indent": 3,
      "text": "The following might be passed with the notification:",
      "ja": "通知とともに以下に渡される場合があります。"
    },
    {
      "indent": 3,
      "text": "last-acked: the TSN last acked by that peer endpoint.",
      "ja": "最終済み：TSNは、そのピアエンドポイントによって最後にアクセスされました。"
    },
    {
      "indent": 3,
      "text": "last-sent: the TSN last sent to that peer endpoint.",
      "ja": "最終セント：TSNは最後にそのピアエンドポイントに送信されました。"
    },
    {
      "indent": 3,
      "text": "Upper Layer Abort Reason: the abort reason specified in case of a user-initiated abort.",
      "ja": "上層中止された理由：ユーザーが開始した中止の場合に指定された中止理由。"
    },
    {
      "indent": 0,
      "text": "11.2.6. COMMUNICATION ERROR Notification",
      "section_title": true,
      "ja": "11.2.6. 通信エラー通知"
    },
    {
      "indent": 3,
      "text": "When SCTP receives an ERROR chunk from its peer and decides to notify its ULP, it can invoke this notification on the ULP.",
      "ja": "SCTPがピアからエラーチャンクを受け取り、ULPに通知することを決定した場合、ULPに関するこの通知を呼び出すことができます。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "通知で以下を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "association id: local handle to the SCTP association.",
      "ja": "協会ID：SCTP協会のローカルハンドル。"
    },
    {
      "indent": 3,
      "text": "error info: this indicates the type of error and optionally some additional information received through the ERROR chunk.",
      "ja": "エラー情報：これは、エラーの種類と、オプションでエラーチャンクによって受信された追加情報を示します。"
    },
    {
      "indent": 0,
      "text": "11.2.7. RESTART Notification",
      "section_title": true,
      "ja": "11.2.7. 通知を再起動します"
    },
    {
      "indent": 3,
      "text": "When SCTP detects that the peer has restarted, it might send this notification to its ULP.",
      "ja": "SCTPがピアが再起動したことを検出すると、この通知をULPに送信する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "通知で以下を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "association id: local handle to the SCTP association.",
      "ja": "協会ID：SCTP協会のローカルハンドル。"
    },
    {
      "indent": 0,
      "text": "11.2.8. SHUTDOWN COMPLETE Notification",
      "section_title": true,
      "ja": "11.2.8. 完全な通知をシャットダウンします"
    },
    {
      "indent": 3,
      "text": "When SCTP completes the shutdown procedures (Section 9.2), this notification is passed to the upper layer.",
      "ja": "SCTPがシャットダウン手順（セクション9.2）を完了すると、この通知は上層に渡されます。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "通知で以下を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "association id: local handle to the SCTP association.",
      "ja": "協会ID：SCTP協会のローカルハンドル。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12. セキュリティ上の考慮事項"
    },
    {
      "indent": 0,
      "text": "12.1. Security Objectives",
      "section_title": true,
      "ja": "12.1. セキュリティ目標"
    },
    {
      "indent": 3,
      "text": "As a common transport protocol designed to reliably carry time-sensitive user messages, such as billing or signaling messages for telephony services, between two networked endpoints, SCTP has the following security objectives:",
      "ja": "2つのネットワーク化されたエンドポイント間のテレフォニーサービスの請求や信号メッセージなど、時間に敏感なユーザーメッセージを確実に伝達するように設計された一般的なトランスポートプロトコルとして、SCTPには次のセキュリティ目標があります。"
    },
    {
      "indent": 3,
      "text": "* availability of reliable and timely data transport services",
      "ja": "* 信頼できるタイムリーなデータ輸送サービスの可用性"
    },
    {
      "indent": 3,
      "text": "* integrity of the user-to-user information carried by SCTP",
      "ja": "* SCTPが運ぶユーザーからユーザーへの情報の整合性"
    },
    {
      "indent": 0,
      "text": "12.2. SCTP Responses to Potential Threats",
      "section_title": true,
      "ja": "12.2. 潜在的な脅威に対するSCTP応答"
    },
    {
      "indent": 3,
      "text": "SCTP could potentially be used in a wide variety of risk situations. It is important for operators of systems running SCTP to analyze their particular situations and decide on the appropriate counter-measures.",
      "ja": "SCTPは、さまざまなリスク状況で使用される可能性があります。SCTPを実行しているシステムのオペレーターが特定の状況を分析し、適切なカウンター測定を決定することが重要です。"
    },
    {
      "indent": 3,
      "text": "Operators of systems running SCTP might consult [RFC2196] for guidance in securing their site.",
      "ja": "SCTPを実行しているシステムのオペレーターは、サイトを確保する際のガイダンスについて[RFC2196]に相談する場合があります。"
    },
    {
      "indent": 0,
      "text": "12.2.1. Countering Insider Attacks",
      "section_title": true,
      "ja": "12.2.1. インサイダー攻撃に対抗します"
    },
    {
      "indent": 3,
      "text": "The principles of [RFC2196] might be applied to minimize the risk of theft of information or sabotage by insiders. Such procedures include publication of security policies, control of access at the physical, software, and network levels, and separation of services.",
      "ja": "[RFC2196]の原則を適用して、インサイダーによる情報や妨害行為のリスクを最小限に抑えることができます。このような手順には、セキュリティポリシーの公開、物理的、ソフトウェア、ネットワークレベルでのアクセスの制御、およびサービスの分離が含まれます。"
    },
    {
      "indent": 0,
      "text": "12.2.2. Protecting against Data Corruption in the Network",
      "section_title": true,
      "ja": "12.2.2. ネットワーク内のデータ腐敗から保護します"
    },
    {
      "indent": 3,
      "text": "Where the risk of undetected errors in datagrams delivered by the lower-layer transport services is considered to be too great, additional integrity protection is required. If this additional protection were provided in the application layer, the SCTP header would remain vulnerable to deliberate integrity attacks. While the existing SCTP mechanisms for detection of packet replays are considered sufficient for normal operation, stronger protections are needed to protect SCTP when the operating environment contains significant risk of deliberate attacks from a sophisticated adversary.",
      "ja": "低層輸送サービスによって配信されたデータグラムの検出されないエラーのリスクが大きすぎると考えられている場合、追加の整合性保護が必要です。この追加の保護がアプリケーション層に提供された場合、SCTPヘッダーは意図的な整合性攻撃に対して脆弱なままです。パケットリプレイを検出するための既存のSCTPメカニズムは通常の操作に十分であると考えられていますが、操作環境に洗練された敵からの意図的な攻撃の重大なリスクが含まれている場合、SCTPを保護するために強力な保護が必要です。"
    },
    {
      "indent": 3,
      "text": "The SCTP Authentication extension SCTP-AUTH [RFC4895] MAY be used when the threat environment requires stronger integrity protections but does not require confidentiality.",
      "ja": "SCTP認証拡張SCTP-Auth [RFC4895]は、脅威環境がより強力な整合性保護を必要とするが、機密性を必要としない場合に使用できます。"
    },
    {
      "indent": 0,
      "text": "12.2.3. Protecting Confidentiality",
      "section_title": true,
      "ja": "12.2.3. 機密性の保護"
    },
    {
      "indent": 3,
      "text": "In most cases, the risk of breach of confidentiality applies to the signaling data payload, not to the SCTP or lower-layer protocol overheads. If that is true, encryption of the SCTP user data only might be considered. As with the supplementary checksum service, user data encryption MAY be performed by the SCTP user application. [RFC6083] MAY be used for this. Alternately, the user application MAY use an implementation-specific API to request that the IP Encapsulating Security Payload (ESP) [RFC4303] be used to provide confidentiality and integrity.",
      "ja": "ほとんどの場合、機密性の違反のリスクは、SCTPまたは低層プロトコルオーバーヘッドではなく、信号データペイロードに適用されます。それが本当なら、SCTPユーザーデータの暗号化のみが考慮される場合があります。補足チェックサムサービスと同様に、SCTPユーザーアプリケーションによってユーザーデータ暗号化が実行される場合があります。[RFC6083]はこれに使用できます。あるいは、ユーザーアプリケーションは実装固有のAPIを使用して、セキュリティペイロード（ESP）[RFC4303]を使用して機密性と整合性を提供することを要求する場合があります。"
    },
    {
      "indent": 3,
      "text": "Particularly for mobile users, the requirement for confidentiality might include the masking of IP addresses and ports. In this case, ESP SHOULD be used instead of application-level confidentiality. If ESP is used to protect confidentiality of SCTP traffic, an ESP cryptographic transform that includes cryptographic integrity protection MUST be used, because, if there is a confidentiality threat, there will also be a strong integrity threat.",
      "ja": "特にモバイルユーザーにとって、機密性の要件には、IPアドレスとポートのマスキングが含まれる場合があります。この場合、アプリケーションレベルの機密性の代わりにESPを使用する必要があります。SCTPトラフィックの機密性を保護するためにESPを使用する場合、暗号化の脅威がある場合、強力な整合性の脅威もあるため、暗号化の整合性保護を含むESP暗号化変換を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Regardless of where confidentiality is provided, the Internet Key Exchange Protocol version 2 (IKEv2) [RFC7296] SHOULD be used for key management of ESP.",
      "ja": "機密性が提供される場所に関係なく、Internet Key Exchange Protocolバージョン2（IKEV2）[RFC7296]を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Operators might consult [RFC4301] for more information on the security services available at and immediately above the Internet Protocol layer.",
      "ja": "オペレーターは、インターネットプロトコルレイヤーのすぐ上で利用可能なセキュリティサービスの詳細については、[RFC4301]を参照する場合があります。"
    },
    {
      "indent": 0,
      "text": "12.2.4. Protecting against Blind Denial-of-Service Attacks",
      "section_title": true,
      "ja": "12.2.4. 盲目的なサービス拒否攻撃から保護する"
    },
    {
      "indent": 3,
      "text": "A blind attack is one where the attacker is unable to intercept or otherwise see the content of data flows passing to and from the target SCTP node. Blind denial-of-service attacks can take the form of flooding, masquerade, or improper monopolization of services.",
      "ja": "ブラインド攻撃とは、攻撃者がターゲットSCTPノードとの間を通過するデータフローのコンテンツを傍受するか、そうでなければ表示できない場合です。盲目的な拒否攻撃は、サービスの洪水、仮面舞踏会、または不適切な独占の形をとることができます。"
    },
    {
      "indent": 0,
      "text": "12.2.4.1. Flooding",
      "section_title": true,
      "ja": "12.2.4.1. 洪水"
    },
    {
      "indent": 3,
      "text": "The objective of flooding is to cause loss of service and incorrect behavior at target systems through resource exhaustion, interference with legitimate transactions, and exploitation of buffer-related software bugs. Flooding can be directed either at the SCTP node or at resources in the intervening IP Access Links or the Internet. Where the latter entities are the target, flooding will manifest itself as loss of network services, including potentially the breach of any firewalls in place.",
      "ja": "洪水の目的は、リソースの疲労、合法的なトランザクションへの干渉、およびバッファ関連ソフトウェアのバグの悪用を通じて、ターゲットシステムでサービスの損失と誤った動作を引き起こすことです。洪水は、SCTPノードまたは介在するIPアクセスリンクまたはインターネットのリソースのいずれかに向けられます。後者のエンティティがターゲットである場合、洪水は、潜在的にファイアウォールの違反を含むネットワークサービスの損失として現れます。"
    },
    {
      "indent": 3,
      "text": "In general, protection against flooding begins at the equipment design level, where it includes measures such as:",
      "ja": "一般に、洪水に対する保護は、次のような尺度が含まれている機器設計レベルで始まります。"
    },
    {
      "indent": 3,
      "text": "* avoiding commitment of limited resources before determining that the request for service is legitimate.",
      "ja": "* サービスの要求が合法であると判断する前に、限られたリソースのコミットメントを回避します。"
    },
    {
      "indent": 3,
      "text": "* giving priority to completion of processing in progress over the acceptance of new work.",
      "ja": "* 新しい仕事の受け入れをめぐる進行中の処理の完了を優先します。"
    },
    {
      "indent": 3,
      "text": "* identification and removal of duplicate or stale queued requests for service.",
      "ja": "* 重複または古いキューのリクエストの識別と削除。"
    },
    {
      "indent": 3,
      "text": "* not responding to unexpected packets sent to non-unicast addresses.",
      "ja": "* 非ユニカストアドレスに送信される予期しないパケットに応答しません。"
    },
    {
      "indent": 3,
      "text": "Network equipment is expected to be capable of generating an alarm and log if a suspicious increase in traffic occurs. The log provides information, such as the identity of the incoming link and source address(es) used, which will help the network or SCTP system operator to take protective measures. Procedures are expected to be in place for the operator to act on such alarms if a clear pattern of abuse emerges.",
      "ja": "ネットワーク機器は、トラフィックの不審な増加が発生した場合、アラームとログを生成できると予想されます。ログは、使用される着信リンクとソースアドレスのIDなどの情報を提供します。これは、ネットワークまたはSCTPシステムオペレーターが保護対策を講じるのに役立ちます。乱用の明確なパターンが出現した場合、オペレーターがそのようなアラームに作用する手順が実施されると予想されます。"
    },
    {
      "indent": 3,
      "text": "The design of SCTP is resistant to flooding attacks, particularly in its use of a four-way startup handshake, its use of a cookie to defer commitment of resources at the responding SCTP node until the handshake is completed, and its use of a Verification Tag to prevent insertion of extraneous packets into the flow of an established association.",
      "ja": "SCTPの設計は、特に4方向のスタートアップハンドシェイクの使用、ハンドシェイクが完了するまで応答するSCTPノードでのリソースのコミットメントを延期するためのCookieの使用、および検証タグの使用において、洪水攻撃に耐性があります。確立された関連付けの流れへの外部パケットの挿入を防ぐため。"
    },
    {
      "indent": 3,
      "text": "ESP might be useful in reducing the risk of certain kinds of denial-of-service attacks.",
      "ja": "ESPは、特定の種類のサービス攻撃のリスクを減らすのに役立つかもしれません。"
    },
    {
      "indent": 3,
      "text": "Support for the Host Name Address parameter has been removed from the protocol. Endpoints receiving INIT or INIT ACK chunks containing the Host Name Address parameter MUST send an ABORT chunk in response and MAY include an \"Unresolvable Address\" error cause.",
      "ja": "ホスト名アドレスパラメーターのサポートは、プロトコルから削除されました。ホスト名アドレスパラメーターを含むinitまたはinit ackチャンクを受信するエンドポイントは、それに応じて中止チャンクを送信する必要があり、「解決できないアドレス」エラー原因を含めることができます。"
    },
    {
      "indent": 0,
      "text": "12.2.4.2. Blind Masquerade",
      "section_title": true,
      "ja": "12.2.4.2. ブラインドマスカレード"
    },
    {
      "indent": 3,
      "text": "Masquerade can be used to deny service in several ways:",
      "ja": "マスカレードは、いくつかの方法でサービスを拒否するために使用できます。"
    },
    {
      "indent": 3,
      "text": "* by tying up resources at the target SCTP node to which the impersonated node has limited access. For example, the target node can by policy permit a maximum of one SCTP association with the impersonated SCTP node. The masquerading attacker can attempt to establish an association purporting to come from the impersonated node so that the latter cannot do so when it requires it.",
      "ja": "* ターゲットSCTPノードでリソースを結び付けることにより、なりすましされたノードがアクセスが制限されています。たとえば、ターゲットノードは、ポリシーにより、偽装されたSCTPノードとの最大1つのSCTP関連を許可できます。攻撃者は、攻撃者を攻撃する攻撃者を、非難されたノードから来ると主張する協会を確立しようとすることができ、後者がそれを必要とするときにそうすることができないようにすることができます。"
    },
    {
      "indent": 3,
      "text": "* by deliberately allowing the impersonation to be detected, thereby provoking counter-measures that cause the impersonated node to be locked out of the target SCTP node.",
      "ja": "* 意図的になりすましを検出できるようにすることにより、ターゲットSCTPノードからなりすましたノードをロックアウトする対抗測定を引き起こします。"
    },
    {
      "indent": 3,
      "text": "* by interfering with an established association by inserting extraneous content such as a SHUTDOWN chunk.",
      "ja": "* シャットダウンチャンクなどの無関係なコンテンツを挿入することにより、確立された関連性を妨害することにより。"
    },
    {
      "indent": 3,
      "text": "SCTP reduces the risk of blind masquerade attacks through IP spoofing by use of the four-way startup handshake. Because the initial exchange is memoryless, no lockout mechanism is triggered by blind masquerade attacks. In addition, the packet containing the INIT ACK chunk with the State Cookie is transmitted back to the IP address from which it received the packet containing the INIT chunk. Thus, the attacker would not receive the INIT ACK chunk containing the State Cookie. SCTP protects against insertion of extraneous packets into the flow of an established association by use of the Verification Tag.",
      "ja": "SCTPは、4方向のスタートアップハンドシェイクを使用して、IPスプーフィングを通じて盲目的な仮面舞踏会攻撃のリスクを減らします。最初の交換はメモリレスであるため、ブラインドマスカレード攻撃によってロックアウトメカニズムがトリガーされません。さらに、State Cookieにinit ackチャンクを含むパケットは、initチャンクを含むパケットを受け取ったIPアドレスに送信されます。したがって、攻撃者は状態Cookieを含むinit ackチャンクを受け取りません。SCTPは、検証タグを使用することにより、確立された関連付けの流れへの外部パケットの挿入から保護します。"
    },
    {
      "indent": 3,
      "text": "Logging of received INIT chunks and abnormalities, such as unexpected INIT ACK chunks, might be considered as a way to detect patterns of hostile activity. However, the potential usefulness of such logging has to be weighed against the increased SCTP startup processing it implies, rendering the SCTP node more vulnerable to flooding attacks. Logging is pointless without the establishment of operating procedures to review and analyze the logs on a routine basis.",
      "ja": "予期しないinit ackチャンクなど、受信した初期のチャンクと異常の伐採は、敵対的な活動のパターンを検出する方法と見なされる可能性があります。ただし、このようなロギングの潜在的な有用性は、SCTPスタートアップ処理の増加と比較検討する必要があり、SCTPノードの洪水攻撃に対してより脆弱になります。ロギングは、ルーチンベースでログをレビューおよび分析するための操作手順を確立することなく無意味です。"
    },
    {
      "indent": 0,
      "text": "12.2.4.3. Improper Monopolization of Services",
      "section_title": true,
      "ja": "12.2.4.3. サービスの不適切な独占"
    },
    {
      "indent": 3,
      "text": "Attacks under this heading are performed openly and legitimately by the attacker. They are directed against fellow users of the target SCTP node or of the shared resources between the attacker and the target node. Possible attacks include the opening of a large number of associations between the attacker's node and the target or transfer of large volumes of information within a legitimately established association.",
      "ja": "この見出しの下での攻撃は、攻撃者によって公然と合法的に行われます。それらは、ターゲットSCTPノードまたは攻撃者とターゲットノードの間の共有リソースの仲間のユーザーに向けられています。考えられる攻撃には、攻撃者のノードと、合法的に確立された関連付け内でのターゲットのターゲットまたは大量の情報の転送の間に多数の関連性が開かれることが含まれます。"
    },
    {
      "indent": 3,
      "text": "Policy limits are expected to be placed on the number of associations per adjoining SCTP node. SCTP user applications are expected to be capable of detecting large volumes of illegitimate or \"no-op\" messages within a given association and either logging or terminating the association as a result, based on local policy.",
      "ja": "隣接するSCTPノードあたりの関連付けの数には、ポリシー制限が配置されると予想されます。SCTPユーザーアプリケーションは、特定の協会内で大量の違法または「ノーオップ」メッセージを検出し、現地ポリシーに基づいて結果として協会を記録または終了することができると予想されます。"
    },
    {
      "indent": 0,
      "text": "12.3. SCTP Interactions with Firewalls",
      "section_title": true,
      "ja": "12.3. SCTPファイアウォールとの相互作用"
    },
    {
      "indent": 3,
      "text": "It is helpful for some firewalls if they can inspect just the first fragment of a fragmented SCTP packet and unambiguously determine whether it corresponds to an INIT chunk (for further information, please refer to [RFC1858]). Accordingly, we stress the requirements, as stated in Section 3.1, that (1) an INIT chunk MUST NOT be bundled with any other chunk in a packet and (2) a packet containing an INIT chunk MUST have a zero Verification Tag. The receiver of an INIT chunk MUST silently discard the INIT chunk and all further chunks if the INIT chunk is bundled with other chunks or the packet has a non-zero Verification Tag.",
      "ja": "一部のファイアウォールは、断片化されたSCTPパケットの最初の断片のみを検査し、Initチャンクに対応するかどうかを明確に決定できる場合に役立ちます（詳細については、[RFC1858]を参照してください）。したがって、セクション3.1に記載されているように、（1）INITチャンクをパケットに他のチャンクにバンドルしてはならず、（2）initチャンクを含むパケットにはゼロ検証タグが必要であることを要件に強調します。init chunkの受信者は、initチャンクを静かに捨てなければなりません。initチャンクが他のチャンクにバンドルされている場合、またはパケットに非ゼロ検証タグがある場合、すべてのチャンクがあります。"
    },
    {
      "indent": 0,
      "text": "12.4. Protection of Non-SCTP-capable Hosts",
      "section_title": true,
      "ja": "12.4. 非SCTP対応ホストの保護"
    },
    {
      "indent": 3,
      "text": "To provide a non-SCTP-capable host with the same level of protection against attacks as for SCTP-capable ones, all SCTP implementations MUST implement the ICMP handling described in Section 10.",
      "ja": "SCTP対応の攻撃と同じレベルの保護を持つ非SCTP対応ホストを提供するには、すべてのSCTP実装がセクション10で説明されているICMP処理を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an SCTP implementation receives a packet containing multiple control or DATA chunks and the processing of the packet would result in sending multiple chunks in response, the sender of the response chunk(s) MUST NOT send more than one packet containing chunks other than DATA chunks. This requirement protects the network for triggering a packet burst in response to a single packet. If bundling is supported, multiple response chunks that fit into a single packet MAY be bundled together into one single response packet. If bundling is not supported, then the sender MUST NOT send more than one response chunk and MUST discard all other responses. Note that this rule does not apply to a SACK chunk, since a SACK chunk is, in itself, a response to DATA chunks, and a SACK chunk does not require a response of more DATA chunks.",
      "ja": "SCTP実装が複数のコントロールまたはデータチャンクを含むパケットを受信し、パケットの処理により複数のチャンクが応答されます。応答チャンクの送信者は、データチャンク以外のチャンクを含むパケットを1つ以上送信してはなりません。。この要件は、単一のパケットに応じてパケットバーストをトリガーするためのネットワークを保護します。バンドリングがサポートされている場合、単一のパケットに適合する複数の応答チャンクが1つの単一の応答パケットにバンドルされる場合があります。バンドリングがサポートされていない場合、送信者は複数の応答チャンクを送信してはならず、他のすべての応答を破棄する必要があります。サックチャンク自体がデータチャンクへの応答であり、サックチャンクはより多くのデータチャンクの応答を必要としないため、このルールはサックチャンクには適用されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation MUST abort the association if it receives a SACK chunk acknowledging a TSN that has not been sent.",
      "ja": "SCTPの実装は、送信されていないTSNを認めるサックチャンクを受け取った場合、協会を中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation that receives an INIT chunk that would require a large packet in response, due to the inclusion of multiple \"Unrecognized Parameter\" parameters, MAY (at its discretion) elect to omit some or all of the \"Unrecognized Parameter\" parameters to reduce the size of the INIT ACK chunk. Due to a combination of the size of the State Cookie parameter and the number of addresses a receiver of an INIT chunk indicates to a peer, it is always possible that the INIT ACK chunk will be larger than the original INIT chunk. An SCTP implementation SHOULD attempt to make the INIT ACK chunk as small as possible to reduce the possibility of byte amplification attacks.",
      "ja": "複数の「認識されていないパラメーター」パラメーターが含まれているため、それに応じて大きなパケットを必要とするINITチャンクを受信するSCTP実装は、（その裁量で）「認識されていないパラメーター」パラメーターの一部またはすべてを省略して、削減することができます。init ackチャンクのサイズ。State Cookieパラメーターのサイズと、initチャンクの受信機がピアに示すアドレスの数の組み合わせにより、init ackチャンクが元のinitチャンクよりも大きくなる可能性があります。SCTPの実装は、バイト増幅攻撃の可能性を減らすために、init ackチャンクを可能な限り小さくしようとする必要があります。"
    },
    {
      "indent": 0,
      "text": "13. Network Management Considerations",
      "section_title": true,
      "ja": "13. ネットワーク管理の考慮事項"
    },
    {
      "indent": 3,
      "text": "The MIB module for SCTP defined in [RFC3873] applies for the version of the protocol specified in this document.",
      "ja": "[RFC3873]で定義されているSCTPのMIBモジュールは、このドキュメントで指定されたプロトコルのバージョンに適用されます。"
    },
    {
      "indent": 0,
      "text": "14. Recommended Transmission Control Block (TCB) Parameters",
      "section_title": true,
      "ja": "14. 推奨される伝送制御ブロック（TCB）パラメーター"
    },
    {
      "indent": 3,
      "text": "This section details a set of parameters that are expected to be contained within the TCB for an implementation. This section is for illustrative purposes and is not considered to be requirements on an implementation or as an exhaustive list of all parameters inside an SCTP TCB. Each implementation might need its own additional parameters for optimization.",
      "ja": "このセクションでは、実装のためにTCB内に含まれると予想されるパラメーターのセットを詳しく説明します。このセクションは、説明の目的であり、実装の要件とは見なされていないか、SCTP TCB内のすべてのパラメーターの網羅的なリストとしては見なされません。各実装には、最適化のために独自の追加パラメーターが必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "14.1. Parameters Necessary for the SCTP Instance",
      "section_title": true,
      "ja": "14.1. SCTPインスタンスに必要なパラメーター"
    },
    {
      "indent": 3,
      "text": "Associations: A list of current associations and mappings to the data consumers for each association. This might be in the form of a hash table or other implementation-dependent structure. The data consumers might be process identification information, such as file descriptors, named pipe pointer, or table pointers dependent on how SCTP is implemented.",
      "ja": "協会：各協会のデータ消費者への現在の関連付けとマッピングのリスト。これは、ハッシュテーブルまたはその他の実装依存構造の形である可能性があります。データ消費者は、SCTPの実装方法に依存するファイル記述子、パイプポインターという名前のファイル記述子、パイプポインター、またはテーブルポインターなどのプロセス識別情報です。"
    },
    {
      "indent": 3,
      "text": "Secret Key: A secret key used by this endpoint to compute the MAC. This SHOULD be a cryptographic quality random number with a sufficient length. Discussion in [RFC4086] can be helpful in selection of the key.",
      "ja": "シークレットキー：Macを計算するためにこのエンドポイントで使用されるシークレットキー。これは、十分な長さの暗号化品質の乱数である必要があります。[RFC4086]での議論は、キーの選択に役立ちます。"
    },
    {
      "indent": 3,
      "text": "Address List: The list of IP addresses that this instance has bound. This information is passed to one's peer(s) in INIT and INIT ACK chunks.",
      "ja": "アドレスリスト：このインスタンスがバインドしているIPアドレスのリスト。この情報は、initとinit ackチャンクでピアに渡されます。"
    },
    {
      "indent": 3,
      "text": "SCTP Port: The local SCTP port number to which the endpoint is bound.",
      "ja": "SCTPポート：エンドポイントがバインドされているローカルSCTPポート番号。"
    },
    {
      "indent": 0,
      "text": "14.2. Parameters Necessary per Association (i.e., the TCB)",
      "section_title": true,
      "ja": "14.2. アソシエーションごとに必要なパラメーター（つまり、TCB）"
    },
    {
      "indent": 3,
      "text": "Peer Verification Tag: Tag value to be sent in every packet and is received in the INIT or INIT ACK chunk.",
      "ja": "ピア検証タグ：すべてのパケットで送信されるタグ値は、initまたはinit ackチャンクで受信されます。"
    },
    {
      "indent": 3,
      "text": "My Verification Tag: Tag expected in every inbound packet and sent in the INIT or INIT ACK chunk.",
      "ja": "私の検証タグ：すべてのインバウンドパケットで期待され、initまたはinit ackチャンクで送信されます。"
    },
    {
      "indent": 3,
      "text": "State: COOKIE-WAIT, COOKIE-ECHOED, ESTABLISHED, SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED, SHUTDOWN-ACK-SENT.",
      "ja": "状態：Cookie-Wait、Cookie-Eched、確立、シャットダウンペンディング、シャットダウンセント、シャットダウンが想定されている、Shutdown-Quack-Sent。"
    },
    {
      "indent": 18,
      "text": "Note: No \"CLOSED\" state is illustrated, since, if an association is \"CLOSED\", its TCB SHOULD be removed.",
      "ja": "注：「閉じた」状態は示されていません。これは、関連性が「閉じている」場合、TCBを削除する必要があるためです。"
    },
    {
      "indent": 3,
      "text": "Peer Transport Address List: A list of SCTP transport addresses to which the peer is bound. This information is derived from the INIT or INIT ACK chunk and is used to associate an inbound packet with a given association. Normally, this information is hashed or keyed for quick lookup and access of the TCB.",
      "ja": "ピアトランスポートアドレスリスト：ピアが拘束されるSCTP輸送アドレスのリスト。この情報は、initまたはinit ackチャンクから派生しており、インバウンドパケットを特定の関連性と関連付けるために使用されます。通常、この情報は、TCBの迅速な検索とアクセスのためにハッシュまたはキーで済みます。"
    },
    {
      "indent": 3,
      "text": "Primary Path: This is the current primary destination transport address of the peer endpoint. It might also specify a source transport address on this endpoint.",
      "ja": "プライマリパス：これは、ピアエンドポイントの現在の主要な宛先輸送アドレスです。また、このエンドポイントにソーストランスポートアドレスを指定する場合があります。"
    },
    {
      "indent": 3,
      "text": "Overall Error Count: The overall association error count.",
      "ja": "全体的なエラーカウント：全体的な関連性エラーカウント。"
    },
    {
      "indent": 3,
      "text": "Overall Error Threshold: The threshold for this association that, if the Overall Error Count reaches, will cause this association to be torn down.",
      "ja": "全体的なエラーしきい値：この関連付けのしきい値は、全体的なエラーカウントが達すると、この関連付けが取り壊されるということです。"
    },
    {
      "indent": 3,
      "text": "Peer Rwnd: Current calculated value of the peer's rwnd.",
      "ja": "ピアRWND：ピアのRWNDの現在の計算値。"
    },
    {
      "indent": 3,
      "text": "Next TSN: The next TSN number to be assigned to a new DATA chunk. This is sent in the INIT or INIT ACK chunk to the peer and incremented each time a DATA chunk is assigned a TSN (normally, just prior to transmit or during fragmentation).",
      "ja": "次のTSN：新しいデータチャンクに割り当てられる次のTSN番号。これは、initまたはinit ackチャンクでピアに送信され、データチャンクにTSNが割り当てられるたびに増加します（通常、送信直前または断片化中）。"
    },
    {
      "indent": 3,
      "text": "Last Rcvd TSN: This is the last TSN received in sequence. This value is set initially by taking the peer's Initial TSN, received in the INIT or INIT ACK chunk, and subtracting one from it.",
      "ja": "最後のRCVD TSN：これは、順番に受け取った最後のTSNです。この値は、最初にピアの最初のTSNを取得し、initまたはinit ackチャンクで受信し、そこからそれを差し引くことによって設定されます。"
    },
    {
      "indent": 3,
      "text": "Mapping Array: An array of bits or bytes indicating which out-of-order TSNs have been received (relative to the Last Rcvd TSN). If no gaps exist, i.e., no out-of-order packets have been received, this array will be set to all zero. This structure might be in the form of a circular buffer or bit array.",
      "ja": "マッピング配列：どの秩序外のTSNが受信されたかを示すビットまたはバイトの配列（最後のRCVD TSNと比較して）。ギャップが存在しない場合、つまり、オーダーアウトオブオーダーパケットが受信されていない場合、この配列はすべてゼロに設定されます。この構造は、円形のバッファーまたはビットアレイの形である場合があります。"
    },
    {
      "indent": 3,
      "text": "Ack State: This flag indicates if the next received packet is to be responded to with a SACK chunk. This is initialized to 0. When a packet is received, it is incremented. If this value reaches 2 or more, a SACK chunk is sent and the value is reset to 0. Note: This is used only when no DATA chunks are received out of order. When DATA chunks are out of order, SACK chunks are not delayed (see Section 6).",
      "ja": "ACK状態：このフラグは、次の受信したパケットがサックチャンクで応答するかどうかを示します。これは0に初期化されます。パケットが受信されると、インクリメントが表示されます。この値が2以上に達すると、サックチャンクが送信され、値は0にリセットされます。データチャンクが故障していない場合、サックチャンクは遅延しません（セクション6を参照）。"
    },
    {
      "indent": 3,
      "text": "Inbound Streams: An array of structures to track the inbound streams, normally including the next sequence number expected and possibly the stream number.",
      "ja": "インバウンドストリーム：インバウンドストリームを追跡するための構造の配列。通常は、予想される次のシーケンス番号と、場合によってはストリーム番号を含みます。"
    },
    {
      "indent": 3,
      "text": "Outbound Streams: An array of structures to track the outbound streams, normally including the next sequence number to be sent on the stream.",
      "ja": "アウトバウンドストリーム：アウトバウンドストリームを追跡するための構造の配列。通常は、ストリームで送信される次のシーケンス番号を含みます。"
    },
    {
      "indent": 3,
      "text": "Reasm Queue: A reassembly queue.",
      "ja": "reasm queue：再組み立てキュー。"
    },
    {
      "indent": 3,
      "text": "Receive Buffer: A buffer to store received user data that has not been delivered to the upper layer.",
      "ja": "受信バッファ：上層に配信されていない受信ユーザーデータを保存するバッファー。"
    },
    {
      "indent": 3,
      "text": "Local Transport Address List: The list of local IP addresses bound in to this association.",
      "ja": "ローカルトランスポートアドレスリスト：この協会に縛られたローカルIPアドレスのリスト。"
    },
    {
      "indent": 3,
      "text": "Association Maximum DATA Chunk Size: The smallest Path Maximum DATA Chunk Size of all destination addresses.",
      "ja": "アソシエーション最大データチャンクサイズ：すべての宛先アドレスの最小パス最小データチャンクサイズ。"
    },
    {
      "indent": 0,
      "text": "14.3. Per Transport Address Data",
      "section_title": true,
      "ja": "14.3. 輸送アドレスデータごと"
    },
    {
      "indent": 3,
      "text": "For each destination transport address in the peer's address list derived from the INIT or INIT ACK chunk, a number of data elements need to be maintained, including:",
      "ja": "initまたはinit ackチャンクから派生したピアのアドレスリストの各宛先輸送アドレスについて、以下を含む多くのデータ要素を維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "Error Count: The current error count for this destination.",
      "ja": "エラーカウント：この宛先の現在のエラーカウント。"
    },
    {
      "indent": 3,
      "text": "Error Threshold: Current error threshold for this destination, i.e., what value marks the destination down if error count reaches this value.",
      "ja": "エラーしきい値：この宛先の現在のエラーしきい値、つまり、エラーカウントがこの値に達した場合、宛先をマークする値は何ですか。"
    },
    {
      "indent": 3,
      "text": "cwnd: The current congestion window.",
      "ja": "CWND：現在の混雑ウィンドウ。"
    },
    {
      "indent": 3,
      "text": "ssthresh: The current ssthresh value.",
      "ja": "SSTHRESH：現在のSSthresh値。"
    },
    {
      "indent": 3,
      "text": "RTO: The current retransmission timeout value.",
      "ja": "RTO：現在の再送信タイムアウト値。"
    },
    {
      "indent": 3,
      "text": "SRTT: The current smoothed round-trip time.",
      "ja": "SRTT：現在の滑らかな往復時間。"
    },
    {
      "indent": 3,
      "text": "RTTVAR: The current RTT variation.",
      "ja": "RTTVAR：現在のRTTバリエーション。"
    },
    {
      "indent": 3,
      "text": "partial bytes acked: The tracking method for increase of cwnd when in congestion avoidance mode (see Section 7.2.2).",
      "ja": "部分的なバイトがアクセスされます：混雑回避モードの場合、CWNDの増加の追跡方法（セクション7.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "state: The current state of this destination, i.e., DOWN, UP, ALLOW-HEARTBEAT, NO-HEARTBEAT, etc.",
      "ja": "状態：この目的地の現在の状態、つまりダウン、アップ、ハートビート、ハートビートなしなど。"
    },
    {
      "indent": 3,
      "text": "PMTU: The current known PMTU.",
      "ja": "PMTU：現在の既知のPMTU。"
    },
    {
      "indent": 3,
      "text": "PMDCS: The current known PMDCS.",
      "ja": "PMDCS：現在の既知のPMDC。"
    },
    {
      "indent": 3,
      "text": "Per Destination Timer: A timer used by each destination.",
      "ja": "宛先タイマーごと：各宛先が使用するタイマー。"
    },
    {
      "indent": 3,
      "text": "RTO-Pending: A flag used to track if one of the DATA chunks sent to this address is currently being used to compute an RTT. If this flag is 0, the next DATA chunk sent to this destination is expected to be used to compute an RTT and this flag is expected to be set. Every time the RTT calculation completes (i.e., the DATA chunk is acknowledged), clear this flag.",
      "ja": "RTOペンディング：このアドレスに送信されたデータチャンクの1つが現在RTTの計算に使用されているかどうかを追跡するために使用されるフラグ。このフラグが0の場合、この宛先に送信される次のデータチャンクがRTTの計算に使用されると予想され、このフラグが設定されると予想されます。RTT計算が完了するたびに（つまり、データチャンクが認められている）、このフラグをクリアします。"
    },
    {
      "indent": 3,
      "text": "last-time: The time to which this destination was last sent. This can be used to determine if the sending of a HEARTBEAT chunk is needed.",
      "ja": "最後の時間：この目的地が最後に送られた時間。これを使用して、ハートビートチャンクの送信が必要かどうかを判断できます。"
    },
    {
      "indent": 0,
      "text": "14.4. General Parameters Needed",
      "section_title": true,
      "ja": "14.4. 必要な一般的なパラメーター"
    },
    {
      "indent": 3,
      "text": "Out Queue: A queue of outbound DATA chunks.",
      "ja": "アウトキュー：アウトバウンドデータチャンクのキュー。"
    },
    {
      "indent": 3,
      "text": "In Queue: A queue of inbound DATA chunks.",
      "ja": "キュー：インバウンドデータチャンクのキュー。"
    },
    {
      "indent": 0,
      "text": "15. IANA Considerations",
      "section_title": true,
      "ja": "15. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document defines five registries that IANA maintains:",
      "ja": "このドキュメントでは、IANAが維持している5つのレジストリを定義します。"
    },
    {
      "indent": 3,
      "text": "* through definition of additional chunk types,",
      "ja": "* 追加のチャンクタイプの定義を通じて、"
    },
    {
      "indent": 3,
      "text": "* through definition of additional chunk flags,",
      "ja": "* 追加のチャンクフラグの定義を通じて、"
    },
    {
      "indent": 3,
      "text": "* through definition of additional parameter types,",
      "ja": "* 追加のパラメータータイプの定義を通じて、"
    },
    {
      "indent": 3,
      "text": "* through definition of additional cause codes within ERROR chunks, or",
      "ja": "* エラーチャンク内の追加の原因コードの定義を通じて、または"
    },
    {
      "indent": 3,
      "text": "* through definition of additional payload protocol identifiers.",
      "ja": "* 追加のペイロードプロトコル識別子の定義を介して。"
    },
    {
      "indent": 3,
      "text": "IANA has performed the following updates for the above five registries:",
      "ja": "IANAは、上記の5つのレジストリに対して次の更新を実行しました。"
    },
    {
      "indent": 3,
      "text": "* In the \"Chunk Types\" registry, IANA has replaced the registry reference to [RFC4960] and [RFC6096] with a reference to this document.",
      "ja": "* 「チャンクタイプ」レジストリでは、IANAは[RFC4960]および[RFC6096]へのレジストリ参照をこのドキュメントへの参照に置き換えました。"
    },
    {
      "indent": 6,
      "text": "In addition, in the Notes section, the reference to Section 3.2 of [RFC6096] has been updated with a reference to Section 15.2 of this document.",
      "ja": "さらに、ノートセクションでは、[RFC6096]のセクション3.2への参照が、このドキュメントのセクション15.2への参照を備えて更新されました。"
    },
    {
      "indent": 6,
      "text": "Finally, each reference to [RFC4960] has been replaced with a reference to this document for the following chunk types:",
      "ja": "最後に、[RFC4960]への各参照は、次のチャンクタイプのこのドキュメントへの参照に置き換えられました。"
    },
    {
      "indent": 6,
      "text": "- Payload Data (DATA)",
      "ja": "- ペイロードデータ（データ）"
    },
    {
      "indent": 6,
      "text": "- Initiation (INIT)",
      "ja": "- 開始（init）"
    },
    {
      "indent": 6,
      "text": "- Initiation Acknowledgement (INIT ACK)",
      "ja": "- 開始承認（init ack）"
    },
    {
      "indent": 6,
      "text": "- Selective Acknowledgement (SACK)",
      "ja": "- 選択的承認（袋）"
    },
    {
      "indent": 6,
      "text": "- Heartbeat Request (HEARTBEAT)",
      "ja": "- ハートビートリクエスト（ハートビート）"
    },
    {
      "indent": 6,
      "text": "- Heartbeat Acknowledgement (HEARTBEAT ACK)",
      "ja": "- ハートビートの謝辞（ハートビートACK）"
    },
    {
      "indent": 6,
      "text": "- Abort (ABORT)",
      "ja": "- 中止（中止）"
    },
    {
      "indent": 6,
      "text": "- Shutdown (SHUTDOWN)",
      "ja": "- シャットダウン（シャットダウン）"
    },
    {
      "indent": 6,
      "text": "- Shutdown Acknowledgement (SHUTDOWN ACK)",
      "ja": "- シャットダウンの謝辞（シャットダウンACK）"
    },
    {
      "indent": 6,
      "text": "- Operation Error (ERROR)",
      "ja": "- 操作エラー（エラー）"
    },
    {
      "indent": 6,
      "text": "- State Cookie (COOKIE ECHO)",
      "ja": "- ステートクッキー（クッキーエコー）"
    },
    {
      "indent": 6,
      "text": "- Cookie Acknowledgement (COOKIE ACK)",
      "ja": "- クッキー謝辞（Cookie Ack）"
    },
    {
      "indent": 6,
      "text": "- Reserved for Explicit Congestion Notification Echo (ECNE)",
      "ja": "- 明示的な混雑通知エコー（ECNE）のために予約"
    },
    {
      "indent": 6,
      "text": "- Reserved for Congestion Window Reduced (CWR)",
      "ja": "- 混雑ウィンドウの予約済み（CWR）"
    },
    {
      "indent": 6,
      "text": "- Shutdown Complete (SHUTDOWN COMPLETE)",
      "ja": "- シャットダウン完全（シャットダウン完全）"
    },
    {
      "indent": 6,
      "text": "- Reserved for IETF-defined Chunk Extensions",
      "ja": "- IETF定義のチャンクエクステンション用に予約されています"
    },
    {
      "indent": 3,
      "text": "* In the \"Chunk Parameter Types\" registry, IANA has replaced the registry reference to [RFC4960] with a reference to this document.",
      "ja": "* 「チャンクパラメータータイプ」レジストリでは、IANAはこのドキュメントへの参照にレジストリ参照を[RFC4960]に置き換えました。"
    },
    {
      "indent": 6,
      "text": "IANA has changed the name of the \"Unrecognized Parameters\" chunk parameter type to \"Unrecognized Parameter\" in the \"Chunk Parameter Types\" registry.",
      "ja": "IANAは、「認識されていないパラメーター」チャンクパラメータータイプの名前を、「チャンクパラメータータイプ」レジストリの「認識されていないパラメーター」に変更しました。"
    },
    {
      "indent": 6,
      "text": "In addition, each reference to [RFC4960] has been replaced with a reference to this document for the following chunk parameter types:",
      "ja": "さらに、[RFC4960]への各参照は、次のチャンクパラメータータイプのこのドキュメントへの参照に置き換えられています。"
    },
    {
      "indent": 6,
      "text": "- Heartbeat Info",
      "ja": "- ハートビート情報"
    },
    {
      "indent": 6,
      "text": "- IPv4 Address",
      "ja": "- IPv4アドレス"
    },
    {
      "indent": 6,
      "text": "- IPv6 Address",
      "ja": "- IPv6アドレス"
    },
    {
      "indent": 6,
      "text": "- State Cookie",
      "ja": "- ステートクッキー"
    },
    {
      "indent": 6,
      "text": "- Unrecognized Parameter",
      "ja": "- 認識されていないパラメーター"
    },
    {
      "indent": 6,
      "text": "- Cookie Preservative",
      "ja": "- クッキー防腐剤"
    },
    {
      "indent": 6,
      "text": "- Host Name Address",
      "ja": "- ホスト名アドレス"
    },
    {
      "indent": 6,
      "text": "- Supported Address Types",
      "ja": "- サポートされているアドレスタイプ"
    },
    {
      "indent": 6,
      "text": "IANA has added a reference to this document for the following chunk parameter type:",
      "ja": "IANAは、次のチャンクパラメータータイプについてこのドキュメントへの参照を追加しました。"
    },
    {
      "indent": 6,
      "text": "- Reserved for ECN Capable (0x8000)",
      "ja": "- ECN能力のために予約（0x8000）"
    },
    {
      "indent": 6,
      "text": "Also, IANA has added the value 65535 to be reserved for IETF-defined extensions.",
      "ja": "また、IANAは、IETF定義の拡張機能のために予約される値65535を追加しました。"
    },
    {
      "indent": 3,
      "text": "* In the \"Chunk Flags\" registry, IANA replaced the registry reference to [RFC6096] with a reference to this document.",
      "ja": "* 「Chunk Flags」レジストリでは、IANAはこのドキュメントへの参照にレジストリ参照を[RFC6096]に置き換えました。"
    },
    {
      "indent": 6,
      "text": "In addition, each reference to [RFC4960] has been replaced with a reference to this document for the following DATA chunk flags:",
      "ja": "さらに、[RFC4960]への各参照は、次のデータチャンクフラグのこのドキュメントへの参照に置き換えられました。"
    },
    {
      "indent": 6,
      "text": "- E bit",
      "ja": "- eビット"
    },
    {
      "indent": 6,
      "text": "- B bit",
      "ja": "- Bビット"
    },
    {
      "indent": 6,
      "text": "- U bit",
      "ja": "- uビット"
    },
    {
      "indent": 6,
      "text": "IANA has also replaced the reference to [RFC7053] with a reference to this document for the following DATA chunk flag:",
      "ja": "IANAは、[RFC7053]への参照を、次のデータチャンクフラグのこのドキュメントへの参照に置き換えました。"
    },
    {
      "indent": 6,
      "text": "- I bit",
      "ja": "- 私は噛みつきます"
    },
    {
      "indent": 6,
      "text": "IANA has replaced the reference to [RFC4960] with a reference to this document for the following ABORT chunk flag:",
      "ja": "IANAは、[RFC4960]への参照を、次の中止チャンクフラグのこのドキュメントへの参照に置き換えました。"
    },
    {
      "indent": 6,
      "text": "- T bit",
      "ja": "- Tビット"
    },
    {
      "indent": 6,
      "text": "IANA has replaced the reference to [RFC4960] with a reference to this document for the following SHUTDOWN COMPLETE chunk flag:",
      "ja": "IANAは、[RFC4960]への参照を、次のシャットダウン完全なチャンクフラグのこのドキュメントへの参照に置き換えました。"
    },
    {
      "indent": 6,
      "text": "- T bit",
      "ja": "- Tビット"
    },
    {
      "indent": 3,
      "text": "* In the \"Error Cause Codes\" registry, IANA has replaced the registry reference to [RFC4960] with a reference to this document.",
      "ja": "* 「エラー原因コード」レジストリでは、IANAはこのドキュメントへの参照にレジストリ参照を[RFC4960]に置き換えました。"
    },
    {
      "indent": 6,
      "text": "IANA has changed the name of the \"User Initiated Abort\" error cause to \"User-Initiated Abort\" and the name of the \"Stale Cookie Error\" error cause to \"Stale Cookie\" in the \"Error Cause Codes\" registry.",
      "ja": "IANAは、「ユーザーが中止した」エラー原因の名前を「ユーザーが開始した中止」に変更し、「古いクッキーエラー」エラーの名前は、「エラーコード」レジストリで「古いクッキー」に「古いクッキー」に「古くなっています」。"
    },
    {
      "indent": 6,
      "text": "In addition, each reference to [RFC4960] has been replaced with a reference to this document for the following cause codes:",
      "ja": "さらに、[RFC4960]への各参照は、次の原因コードについて、このドキュメントへの参照に置き換えられました。"
    },
    {
      "indent": 6,
      "text": "- Invalid Stream Identifier",
      "ja": "- 無効なストリーム識別子"
    },
    {
      "indent": 6,
      "text": "- Missing Mandatory Parameter",
      "ja": "- 欠落している必須パラメーター"
    },
    {
      "indent": 6,
      "text": "- Stale Cookie",
      "ja": "- 古いクッキー"
    },
    {
      "indent": 6,
      "text": "- Out of Resource",
      "ja": "- リソースから"
    },
    {
      "indent": 6,
      "text": "- Unresolvable Address",
      "ja": "- 解決できないアドレス"
    },
    {
      "indent": 6,
      "text": "- Unrecognized Chunk Type",
      "ja": "- 認識されていないチャンクタイプ"
    },
    {
      "indent": 6,
      "text": "- Invalid Mandatory Parameter",
      "ja": "- 無効な必須パラメーター"
    },
    {
      "indent": 6,
      "text": "- Unrecognized Parameters",
      "ja": "- 認識されていないパラメーター"
    },
    {
      "indent": 6,
      "text": "- No User Data",
      "ja": "- ユーザーデータはありません"
    },
    {
      "indent": 6,
      "text": "- Cookie Received While Shutting Down",
      "ja": "- クッキーはシャットダウン中に受け取った"
    },
    {
      "indent": 6,
      "text": "- Restart of an Association with New Addresses",
      "ja": "- 新しいアドレスとの関連付けを再開します"
    },
    {
      "indent": 6,
      "text": "IANA has also replaced each reference to [RFC4460] with a reference to this document for the following cause codes:",
      "ja": "IANAは、次の原因コードのこのドキュメントへの参照に、[RFC4460]への各参照を次のように置き換えました。"
    },
    {
      "indent": 6,
      "text": "- User-Initiated Abort",
      "ja": "- ユーザーが開始した中止"
    },
    {
      "indent": 6,
      "text": "- Protocol Violation",
      "ja": "- プロトコル違反"
    },
    {
      "indent": 3,
      "text": "* In the \"SCTP Payload Protocol Identifiers\" registry, IANA has replaced the registry reference to [RFC4960] with a reference to this document.",
      "ja": "* 「SCTPペイロードプロトコル識別子」レジストリでは、IANAはこのドキュメントへの参照にレジストリ参照を[RFC4960]に置き換えました。"
    },
    {
      "indent": 6,
      "text": "IANA has replaced the reference to [RFC4960] with a reference to this document for the following SCTP payload protocol identifier:",
      "ja": "IANAは、[RFC4960]への参照を、次のSCTPペイロードプロトコル識別子のこのドキュメントへの参照に置き換えました。"
    },
    {
      "indent": 6,
      "text": "- Reserved by SCTP",
      "ja": "- SCTPによって予約されています"
    },
    {
      "indent": 3,
      "text": "SCTP requires that the IANA \"Port Numbers\" registry be opened for SCTP port registrations; Section 15.6 describes how. An IESG-appointed Expert Reviewer supports IANA in evaluating SCTP port allocation requests.",
      "ja": "SCTPでは、SCTPポート登録のためにIANAの「ポート番号」レジストリを開く必要があります。セクション15.6では、その方法について説明します。IESGに任命された専門家レビューアは、SCTPポート割り当てリクエストの評価においてIANAをサポートしています。"
    },
    {
      "indent": 3,
      "text": "In the \"Service Name and Transport Protocol Port Number Registry\", IANA has replaced each reference to [RFC4960] with a reference to this document for the following SCTP port numbers:",
      "ja": "「サービス名と輸送プロトコルポート番号レジストリ」で、IANAは次のSCTPポート番号のこのドキュメントへの参照に、[RFC4960]への各参照を次のように置き換えました。"
    },
    {
      "indent": 3,
      "text": "* 9 (discard)",
      "ja": "* 9（破棄）"
    },
    {
      "indent": 3,
      "text": "* 20 (ftp-data)",
      "ja": "* 20（ftp-data）"
    },
    {
      "indent": 3,
      "text": "* 21 (ftp)",
      "ja": "* 21（FTP）"
    },
    {
      "indent": 3,
      "text": "* 22 (ssh)",
      "ja": "* 22（SSH）"
    },
    {
      "indent": 3,
      "text": "* 80 (http)",
      "ja": "* 80（http）"
    },
    {
      "indent": 3,
      "text": "* 179 (bgp)",
      "ja": "* 179（BGP）"
    },
    {
      "indent": 3,
      "text": "* 443 (https)",
      "ja": "* 443（https）"
    },
    {
      "indent": 3,
      "text": "Furthermore, in the \"Hypertext Transfer Protocol (HTTP) Digest Algorithm Values\" registry, IANA has replaced the reference to Appendix B of [RFC4960] with a reference to Appendix A of this document.",
      "ja": "さらに、「ハイパーテキスト転送プロトコル（HTTP）ダイジェストアルゴリズム値」レジストリでは、IANAは[RFC4960]の付録Bへの参照をこのドキュメントの付録Aへの参照に置き換えました。"
    },
    {
      "indent": 3,
      "text": "In addition, in the \"ONC RPC Netids (Standards Action)\" registry, IANA has replaced each reference to [RFC4960] with a reference to this document for the following netids:",
      "ja": "さらに、「ONC RPC NetIDS（標準アクション）」レジストリでは、IANAは次のNetIDのこのドキュメントへの参照に[RFC4960]への各参照を置き換えました。"
    },
    {
      "indent": 3,
      "text": "* sctp",
      "ja": "* sctp"
    },
    {
      "indent": 3,
      "text": "* sctp6",
      "ja": "* SCTP6"
    },
    {
      "indent": 3,
      "text": "In the \"IPFIX Information Elements\" registry, IANA has replaced each reference to [RFC4960] with a reference to this document for the following elements with the name:",
      "ja": "「IPFIX情報要素」レジストリでは、IANAは[RFC4960]への各参照を、次の要素のこのドキュメントへの参照に置き換えました。"
    },
    {
      "indent": 3,
      "text": "* sourceTransportPort",
      "ja": "* Sourcetransportport"
    },
    {
      "indent": 3,
      "text": "* destinationTransportPort",
      "ja": "* DestinationTransportport"
    },
    {
      "indent": 3,
      "text": "* collectorTransportPort",
      "ja": "* CollectorTransportport"
    },
    {
      "indent": 3,
      "text": "* exporterTransportPort",
      "ja": "* Exportransportport"
    },
    {
      "indent": 3,
      "text": "* postNAPTSourceTransportPort",
      "ja": "* postnaptsourcetransportport"
    },
    {
      "indent": 3,
      "text": "* postNAPTDestinationTransportPort",
      "ja": "* PostNaptDestinationTransportport"
    },
    {
      "indent": 0,
      "text": "15.1. IETF-Defined Chunk Extension",
      "section_title": true,
      "ja": "15.1. IETF定義のチャンク拡張"
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk type codes is done through an IETF Review action, as defined in [RFC8126]. Documentation for a new chunk MUST contain the following information:",
      "ja": "[RFC8126]で定義されているように、新しいチャンクタイプコードの割り当ては、IETFレビューアクションを通じて行われます。新しいチャンクのドキュメントには、次の情報が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "a) A long and short name for the new chunk type.",
      "ja": "a) 新しいチャンクタイプの長くて短い名前。"
    },
    {
      "indent": 3,
      "text": "b) A detailed description of the structure of the chunk, which MUST conform to the basic structure defined in Section 3.2.",
      "ja": "b) セクション3.2で定義されている基本構造に準拠する必要があるチャンクの構造の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "c) A detailed definition and description of intended use of each field within the chunk, including the chunk flags if any. Defined chunk flags will be used as initial entries in the chunk flags table for the new chunk type.",
      "ja": "c) チャンクフラグが含まれる場合を含む、チャンク内の各フィールドの使用の使用の詳細な定義と説明。定義されたチャンクフラグは、新しいチャンクタイプのChunk Flagsテーブルの初期エントリとして使用されます。"
    },
    {
      "indent": 3,
      "text": "d) A detailed procedural description of the use of the new chunk type within the operation of the protocol.",
      "ja": "d) プロトコルの操作内での新しいチャンクタイプの使用に関する詳細な手続き的説明。"
    },
    {
      "indent": 3,
      "text": "The last chunk type (255) is reserved for future extension if necessary.",
      "ja": "最後のチャンクタイプ（255）は、必要に応じて将来の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "For each new chunk type, IANA creates a registration table for the chunk flags of that type. The procedure for registering particular chunk flags is described in Section 15.2.",
      "ja": "新しいチャンクタイプごとに、IANAはそのタイプのチャンクフラグの登録表を作成します。特定のチャンクフラグを登録する手順については、セクション15.2で説明しています。"
    },
    {
      "indent": 0,
      "text": "15.2. IETF-Defined Chunk Flags Registration",
      "section_title": true,
      "ja": "15.2. IETF定義のチャンクフラグ登録"
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk flags is done through an RFC Required action, as defined in [RFC8126]. Documentation for the chunk flags MUST contain the following information:",
      "ja": "[RFC8126]で定義されているように、新しいチャンクフラグの割り当ては、RFC必須アクションを通じて行われます。チャンクフラグのドキュメントには、次の情報が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "a) A name for the new chunk flag.",
      "ja": "a) 新しいチャンクフラグの名前。"
    },
    {
      "indent": 3,
      "text": "b) A detailed procedural description of the use of the new chunk flag within the operation of the protocol. It MUST be considered that implementations not supporting the flag will send 0 on transmit and just ignore it on receipt.",
      "ja": "b) プロトコルの操作内での新しいチャンクフラグの使用に関する詳細な手続き的説明。フラグをサポートしていない実装は、送信時に0を送信し、受信時にそれを無視するだけであると考える必要があります。"
    },
    {
      "indent": 3,
      "text": "IANA selects a chunk flags value. This MUST be one of 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, or 0x80, which MUST be unique within the chunk flag values for the specific chunk type.",
      "ja": "IANAはチャンクフラグの値を選択します。これは、0x01、0x02、0x04、0x08、0x10、0x20、0x40、または0x80のいずれかでなければなりません。これは、特定のチャンクタイプのチャンクフラグ値内で一意でなければなりません。"
    },
    {
      "indent": 0,
      "text": "15.3. IETF-Defined Chunk Parameter Extension",
      "section_title": true,
      "ja": "15.3. IETF定義のチャンクパラメーター拡張"
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk parameter type codes is done through an IETF Review action, as defined in [RFC8126]. Documentation of the chunk parameter MUST contain the following information:",
      "ja": "[RFC8126]で定義されているように、新しいChunkパラメータータイプコードの割り当ては、IETFレビューアクションを通じて行われます。チャンクパラメーターのドキュメントには、次の情報が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "a) Name of the parameter type.",
      "ja": "a) パラメータータイプの名前。"
    },
    {
      "indent": 3,
      "text": "b) Detailed description of the structure of the parameter field. This structure MUST conform to the general Type-Length-Value format described in Section 3.2.1.",
      "ja": "b) パラメーターフィールドの構造の詳細な説明。この構造は、セクション3.2.1で説明されている一般的なタイプ長価値形式に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "c) Detailed definition of each component of the parameter value.",
      "ja": "c) パラメーター値の各コンポーネントの詳細な定義。"
    },
    {
      "indent": 3,
      "text": "d) Detailed description of the intended use of this parameter type and an indication of whether and under what circumstances multiple instances of this parameter type can be found within the same chunk.",
      "ja": "d) このパラメータータイプの使用の使用の詳細な説明と、このパラメータータイプの複数のインスタンスが同じチャンク内で見つけることができるかどうか、およびどのような状況でどのような状況で表示されるかを示しています。"
    },
    {
      "indent": 3,
      "text": "e) Each parameter type MUST be unique across all chunks.",
      "ja": "e) 各パラメータータイプは、すべてのチャンクにわたって一意でなければなりません。"
    },
    {
      "indent": 0,
      "text": "15.4. IETF-Defined Additional Error Causes",
      "section_title": true,
      "ja": "15.4. IETF定義の追加エラー原因"
    },
    {
      "indent": 3,
      "text": "Additional cause codes can be allocated through a Specification Required action as defined in [RFC8126]. Provided documentation MUST include the following information:",
      "ja": "[RFC8126]で定義されているように、追加の原因コードは、必要なアクションを使用して割り当てることができます。提供されたドキュメントには、次の情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "a) Name of the error condition.",
      "ja": "a) エラー条件の名前。"
    },
    {
      "indent": 3,
      "text": "b) Detailed description of the conditions under which an SCTP endpoint issues an ERROR (or ABORT) chunk with this cause code.",
      "ja": "b) SCTPエンドポイントがこの原因コードでエラー（または中止）チャンクを発行する条件の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "c) Expected action by the SCTP endpoint that receives an ERROR (or ABORT) chunk containing this cause code.",
      "ja": "c) この原因コードを含むエラー（または中止）チャンクを受信するSCTPエンドポイントによる予想アクション。"
    },
    {
      "indent": 3,
      "text": "d) Detailed description of the structure and content of data fields that accompany this cause code.",
      "ja": "d) この原因コードに伴うデータフィールドの構造と内容の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "The initial word (32 bits) of a cause code parameter MUST conform to the format shown in Section 3.3.10, that is:",
      "ja": "原因コードパラメーターの最初の単語（32ビット）は、セクション3.3.10に示す形式に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "* first 2 bytes contain the cause code value",
      "ja": "* 最初の2バイトには原因コード値が含まれています"
    },
    {
      "indent": 3,
      "text": "* last 2 bytes contain the length of the error cause.",
      "ja": "* 最後の2バイトには、エラー原因の長さが含まれています。"
    },
    {
      "indent": 0,
      "text": "15.5. Payload Protocol Identifiers",
      "section_title": true,
      "ja": "15.5. ペイロードプロトコル識別子"
    },
    {
      "indent": 3,
      "text": "The assignment of payload protocol identifiers is done using the First Come First Served policy, as defined in [RFC8126].",
      "ja": "ペイロードプロトコル識別子の割り当ては、[RFC8126]で定義されているように、最初のCome First Serverポリシーを使用して行われます。"
    },
    {
      "indent": 3,
      "text": "Except for value 0, which is reserved to indicate an unspecified payload protocol identifier in a DATA chunk, an SCTP implementation will not be responsible for standardizing or verifying any payload protocol identifiers. An SCTP implementation simply receives the identifier from the upper layer and carries it with the corresponding payload data.",
      "ja": "データチャンク内の不特定のペイロードプロトコル識別子を示すために予約されている値0を除き、SCTP実装は、ペイロードプロトコル識別子の標準化または検証に責任を負いません。SCTP実装は、単に上層から識別子を受信し、対応するペイロードデータでそれを運びます。"
    },
    {
      "indent": 3,
      "text": "The upper layer, i.e., the SCTP user, SHOULD standardize any specific protocol identifier with IANA if it is so desired. The use of any specific payload protocol identifier is out of the scope of this specification.",
      "ja": "上層層、つまりSCTPユーザーは、IANAとの特定のプロトコル識別子を非常に望んでいる場合は標準化する必要があります。特定のペイロードプロトコル識別子の使用は、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "15.6. Port Numbers Registry",
      "section_title": true,
      "ja": "15.6. ポート番号レジストリ"
    },
    {
      "indent": 3,
      "text": "SCTP services can use contact port numbers to provide service to unknown callers, as in TCP and UDP. An IESG-appointed Expert Reviewer supports IANA in evaluating SCTP port allocation requests, according to the procedure defined in [RFC8126]. The details of this process are defined in [RFC6335].",
      "ja": "SCTPサービスは、TCPやUDPのように、連絡先ポート番号を使用して未知の発信者にサービスを提供できます。IESGに任命された専門家のレビューアは、[RFC8126]で定義されている手順に従って、SCTPポート割り当て要求の評価においてIANAをサポートしています。このプロセスの詳細は[RFC6335]で定義されています。"
    },
    {
      "indent": 0,
      "text": "16. Suggested SCTP Protocol Parameter Values",
      "section_title": true,
      "ja": "16. 提案されたSCTPプロトコルパラメーター値"
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "次のプロトコルパラメーターが推奨されます。"
    },
    {
      "indent": 3,
      "text": "RTO.Initial:  1 second\nRTO.Min:  1 second\nRTO.Max:  60 seconds\nMax.Burst:  4\nRTO.Alpha:  1/8\nRTO.Beta:  1/4\nValid.Cookie.Life:  60 seconds\nAssociation.Max.Retrans:  10 attempts\nPath.Max.Retrans:  5 attempts (per destination address)\nMax.Init.Retransmits:  8 attempts\nHB.interval:  30 seconds\nHB.Max.Burst:  1\nSACK.Delay:  200 milliseconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Implementation Note: The SCTP implementation can allow ULP to customize some of these protocol parameters (see Section 11).",
      "ja": "実装注：SCTP実装により、ULPはこれらのプロトコルパラメーターの一部をカスタマイズできます（セクション11を参照）。"
    },
    {
      "indent": 3,
      "text": "'RTO.Min' SHOULD be set as described above in this section.",
      "ja": "「RTO.min」は、このセクションで上記のように設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "17. References",
      "section_title": true,
      "ja": "17. 参考文献"
    },
    {
      "indent": 0,
      "text": "17.1. Normative References",
      "section_title": true,
      "ja": "17.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ITU.V42.1994] International Telecommunications Union, \"Error-correcting Procedures for DCEs Using Asynchronous-to-Synchronous Conversion\", ITU-T Recommendation V.42, 1994.",
      "ja": "[ITU.V42.1994] International Telecommunications Union、「非同期から同期への変換を使用したDCEのエラー修正手順」、ITU-T推奨V.42、1994。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <https://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122] Braden、R.、ed。、「インターネットホストの要件 - 通信レイヤー」、STD 3、RFC 1122、DOI 10.17487/RFC1122、1989年10月、<https://www.rfc-editor.org/info/RFC1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC1123] Braden, R., Ed., \"Requirements for Internet Hosts - Application and Support\", STD 3, RFC 1123, DOI 10.17487/RFC1123, October 1989, <https://www.rfc-editor.org/info/rfc1123>.",
      "ja": "[RFC1123] Braden、R.、ed。、「インターネットホストの要件 - アプリケーションとサポート」、STD 3、RFC 1123、DOI 10.17487/RFC1123、1989年10月、<https://www.rfc-editor.org/info/rfc1123>。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, DOI 10.17487/RFC1191, November 1990, <https://www.rfc-editor.org/info/rfc1191>.",
      "ja": "[RFC1191] Mogul、J。およびS. Deering、「Path MTU Discovery」、RFC 1191、DOI 10.17487/RFC1191、1990年11月、<https://www.rfc-editor.org/info/rfc1191>。"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, DOI 10.17487/RFC1982, August 1996, <https://www.rfc-editor.org/info/rfc1982>.",
      "ja": "[RFC1982] Elz、R。およびR. Bush、「シリアル番号算術」、RFC 1982、DOI 10.17487/RFC1982、1996年8月、<https://www.rfc-editor.org/info/rfc1982>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, DOI 10.17487/RFC4291, February 2006, <https://www.rfc-editor.org/info/rfc4291>.",
      "ja": "[RFC4291] Hinden、R。and S. Deering、「IPバージョン6アドレス指定アーキテクチャ」、RFC 4291、DOI 10.17487/RFC4291、2006年2月、<https://www.rfc-editor.org/info/rfc4291>"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, DOI 10.17487/RFC4303, December 2005, <https://www.rfc-editor.org/info/rfc4303>.",
      "ja": "[RFC4303] Kent、S。、「セキュリティペイロード（ESP）をカプセル化するIP」、RFC 4303、DOI 10.17487/RFC4303、2005年12月、<https://www.rfc-editor.org/info/rfc4303>。"
    },
    {
      "indent": 3,
      "text": "[RFC4895] Tuexen, M., Stewart, R., Lei, P., and E. Rescorla, \"Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)\", RFC 4895, DOI 10.17487/RFC4895, August 2007, <https://www.rfc-editor.org/info/rfc4895>.",
      "ja": "[RFC4895] Tuexen、M.、Stewart、R.、Lei、P。、およびE. Rescorla、「ストリーム制御伝送プロトコル（SCTP）の認証チャンク」、RFC 4895、DOI 10.17487/RFC4895、2007年8月、<HTTPS <HTTPS：//www.rfc-editor.org/info/rfc4895>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <https://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681] Allman、M.、Paxson、V.、およびE. Blanton、「TCP混雑制御」、RFC 5681、DOI 10.17487/RFC5681、2009年9月、<https://www.rfc-editor.org/info/RFC5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC6335] Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, \"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry\", BCP 165, RFC 6335, DOI 10.17487/RFC6335, August 2011, <https://www.rfc-editor.org/info/rfc6335>.",
      "ja": "[RFC6335] Cotton、M.、Eggert、L.、Touch、J.、Westerlund、M。、およびS. Cheshire、「インターネットが割り当てられた数字権（IANA）手順サービス名と輸送プロトコルポート番号レジストリの管理のための手順\"、BCP 165、RFC 6335、DOI 10.17487/RFC6335、2011年8月、<https://www.rfc-editor.org/info/rfc635>。"
    },
    {
      "indent": 3,
      "text": "[RFC6083] Tuexen, M., Seggelmann, R., and E. Rescorla, \"Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP)\", RFC 6083, DOI 10.17487/RFC6083, January 2011, <https://www.rfc-editor.org/info/rfc6083>.",
      "ja": "[RFC6083] Tuexen、M.、Seggelmann、R。、およびE. Rescorla、「Stream Control Transmission Protocol（SCTP）のデータグラム輸送層セキュリティ（DTL）」、RFC 6083、DOI 10.17487/RFC6083、2011年1月、<HTTPS：//www.rfc-editor.org/info/rfc6083>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, <https://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296] Kaufman、C.、Hoffman、P.、Nir、Y.、Eronen、P.、およびT. Kivinen、「インターネットキー交換プロトコルバージョン2（IKEV2）」、STD 79、RFC 7296、DOI 10.17487/RFC7296、2014年10月、<https://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487/RFC8126、2017年6月、<https：// wwwwwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8200] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <https://www.rfc-editor.org/info/rfc8200>.",
      "ja": "[RFC8200] Deering、S。and R. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、STD 86、RFC 8200、DOI 10.17487/RFC8200、2017年7月、<https://www.rfc-editor.org/info/rfc8200>。"
    },
    {
      "indent": 3,
      "text": "[RFC8201] McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., \"Path MTU Discovery for IP version 6\", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, <https://www.rfc-editor.org/info/rfc8201>.",
      "ja": "[RFC8201] McCann、J.、Deering、S.、Mogul、J.、およびR. Hinden、ed。、「IPバージョン6のPath MTU Discovery」、STD 87、RFC 8201、DOI 10.17487/RFC8201、2017年7月、<https://www.rfc-editor.org/info/rfc8201>。"
    },
    {
      "indent": 3,
      "text": "[RFC8899] Fairhurst, G., Jones, T., Tüxen, M., Rüngeler, I., and T. Völker, \"Packetization Layer Path MTU Discovery for Datagram Transports\", RFC 8899, DOI 10.17487/RFC8899, September 2020, <https://www.rfc-editor.org/info/rfc8899>.",
      "ja": "[RFC8899] Fairhurst、G.、Jones、T.、Tüxen、M.、Rüngeler、I。、およびT.Völker、「Datagram Transports for Datagram TransportsのPacketization Lay Path Mtu Discovery」、DOI 10.17487/RFC8899、2020年9月、2020年9月、<https://www.rfc-editor.org/info/rfc8899>。"
    },
    {
      "indent": 0,
      "text": "17.2. Informative References",
      "section_title": true,
      "ja": "17.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[FALL96] Fall, K. and S. Floyd, \"Simulation-based Comparisons of Tahoe, Reno, and SACK TCP\", SIGCOM 99, V. 26, N. 3, pp 5-21, July 1996.",
      "ja": "[Fall96] Fall、K。およびS. Floyd、「Tahoe、Reno、およびSack TCPのシミュレーションベースの比較」、Sigcom 99、V。26、N。3、pp 5-21、1996年7月。"
    },
    {
      "indent": 3,
      "text": "[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and T. Anderson, \"TCP Congestion Control with a Misbehaving Receiver\", ACM Computer Communications Review 29(5), October 1999.",
      "ja": "[Savage99] Savage、S.、Cardwell、N.、Wetherall、D。、およびT. Anderson、「不正行為レシーバーによるTCP混雑制御」、ACM Computer Communications Review 29（5）、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[ALLMAN99] Allman, M. and V. Paxson, \"On Estimating End-to-End Network Path Properties\", SIGCOM 99, October 1999.",
      "ja": "[Allman99] Allman、M。and V. Paxson、「エンドツーエンドネットワークパスプロパティの推定について」、Sigcom 99、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[WILLIAMS93] Williams, R., \"A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS\", SIGCOM 99, August 1993, <https://archive.org/stream/PainlessCRC/crc_v3.txt>.",
      "ja": "[Williams93] Williams、R。、「CRCエラー検出アルゴリズムの痛みのないガイド」、Sigcom 99、1993年8月、<https://archive.org/stream/painlesscrc/crc_v3.txt>。"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, <https://www.rfc-editor.org/info/rfc768>.",
      "ja": "[RFC0768] POSTEL、J。、「ユーザーデータグラムプロトコル」、STD 6、RFC 768、DOI 10.17487/RFC0768、1980年8月、<https://www.rfc-editor.org/info/rfc768>。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <https://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC0793] Postel、J。、「伝送制御プロトコル」、STD 7、RFC 793、DOI 10.17487/RFC0793、1981年9月、<https://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC1858] Ziemba, G., Reed, D., and P. Traina, \"Security Considerations for IP Fragment Filtering\", RFC 1858, DOI 10.17487/RFC1858, October 1995, <https://www.rfc-editor.org/info/rfc1858>.",
      "ja": "[RFC1858] Ziemba、G.、Reed、D。、およびP. Traina、「IPフラグメントフィルタリングのセキュリティ上の考慮事項」、RFC 1858、DOI 10.17487/RFC1858、1995年10月、<https://www.rfc-editor.org/info/rfc1858>。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. CaNetti、「HMAC：メッセージ認証のためのキー付きハッシング」、RFC 2104、DOI 10.17487/RFC2104、1997年2月、<https：//www.rfc-editor.org/info/rfc2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2196] Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196, DOI 10.17487/RFC2196, September 1997, <https://www.rfc-editor.org/info/rfc2196>.",
      "ja": "[RFC2196] Fraser、B。、「サイトセキュリティハンドブック」、FYI 8、RFC 2196、DOI 10.17487/RFC2196、1997年9月、<https://www.rfc-editor.org/info/rfc2196>。"
    },
    {
      "indent": 3,
      "text": "[RFC2522] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, DOI 10.17487/RFC2522, March 1999, <https://www.rfc-editor.org/info/rfc2522>.",
      "ja": "[RFC2522] Karn、P。and W. Simpson、「Photuris：Session-Key Management Protocol」、RFC 2522、DOI 10.17487/RFC2522、1999年3月、<https://www.rfc-editor.org/info/rfc2522>。"
    },
    {
      "indent": 3,
      "text": "[RFC2960] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, DOI 10.17487/RFC2960, October 2000, <https://www.rfc-editor.org/info/rfc2960>.",
      "ja": "[RFC2960] Stewart、R.、Xie、Q.、Morneault、K.、Sharp、C.、Schwarzbauer、H.、Taylor、T.、Rytina、I.、Kalla、M.、Zhang、L。、およびV。Paxson、「Stream Control Transmission Protocol」、RFC 2960、DOI 10.17487/RFC2960、2000年10月、<https://www.rfc-editor.org/info/rfc2960>。"
    },
    {
      "indent": 3,
      "text": "[RFC3465] Allman, M., \"TCP Congestion Control with Appropriate Byte Counting (ABC)\", RFC 3465, DOI 10.17487/RFC3465, February 2003, <https://www.rfc-editor.org/info/rfc3465>.",
      "ja": "[RFC3465] Allman、M。、「適切なバイトカウント（ABC）によるTCP混雑制御」、RFC 3465、DOI 10.17487/RFC3465、2003年2月、<https://www.rfc-editor.org/info/rfc3465>"
    },
    {
      "indent": 3,
      "text": "[RFC3873] Pastor, J. and M. Belinchon, \"Stream Control Transmission Protocol (SCTP) Management Information Base (MIB)\", RFC 3873, DOI 10.17487/RFC3873, September 2004, <https://www.rfc-editor.org/info/rfc3873>.",
      "ja": "[RFC3873]牧師、J。およびM.ベリンチョン、「ストリーム制御伝送プロトコル（SCTP）管理情報ベース（MIB）」、RFC 3873、DOI 10.17487/RFC3873、2004年9月、<https：//www.rfc-editor。org/info/rfc3873>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <https://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] EastLake 3rd、D.、Schiller、J。、およびS. Crocker、「セキュリティのランダム性要件」、BCP 106、RFC 4086、DOI 10.17487/RFC4086、2005年6月、<https：//www.rfc-editor.org/info/rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, DOI 10.17487/RFC4301, December 2005, <https://www.rfc-editor.org/info/rfc4301>.",
      "ja": "[RFC4301] Kent、S。およびK. SEO、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、DOI 10.17487/RFC4301、2005年12月、<https://www.rfc-editor.org/info/rfc4301>。"
    },
    {
      "indent": 3,
      "text": "[RFC4460] Stewart, R., Arias-Rodriguez, I., Poon, K., Caro, A., and M. Tuexen, \"Stream Control Transmission Protocol (SCTP) Specification Errata and Issues\", RFC 4460, DOI 10.17487/RFC4460, April 2006, <https://www.rfc-editor.org/info/rfc4460>.",
      "ja": "[RFC4460] Stewart、R.、Arias-Rodriguez、I.、Poon、K.、Caro、A。、およびM. Tuexen、「Stream Control Transmission Protocol（SCTP）Specification Errata and Issues」、RFC 4460、DOI 10.17487/RFC4460、2006年4月、<https://www.rfc-editor.org/info/rfc4460>。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., Ed., \"Stream Control Transmission Protocol\", RFC 4960, DOI 10.17487/RFC4960, September 2007, <https://www.rfc-editor.org/info/rfc4960>.",
      "ja": "[RFC4960] Stewart、R.、ed。、「Stream Control Transmission Protocol」、RFC 4960、DOI 10.17487/RFC4960、2007年9月、<https://www.rfc-editor.org/info/rfc4960>。"
    },
    {
      "indent": 3,
      "text": "[RFC6096] Tuexen, M. and R. Stewart, \"Stream Control Transmission Protocol (SCTP) Chunk Flags Registration\", RFC 6096, DOI 10.17487/RFC6096, January 2011, <https://www.rfc-editor.org/info/rfc6096>.",
      "ja": "[RFC6096] Tuexen、M。およびR. Stewart、「ストリーム制御伝送プロトコル（SCTP）チャンクフラグ登録」、RFC 6096、DOI 10.17487/RFC6096、2011年1月、<https://www.rfc-editor.org/info/rfc6096>。"
    },
    {
      "indent": 3,
      "text": "[RFC6458] Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich, \"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)\", RFC 6458, DOI 10.17487/RFC6458, December 2011, <https://www.rfc-editor.org/info/rfc6458>.",
      "ja": "[RFC6458] Stewart、R.、Tuexen、M.、Poon、K.、Lei、P。、およびV. Yasevich、「Sockets API拡張機能（SCTP）、RFC 6458、DOI 10.17487/RFC64588888888888888888、2011年12月、<https://www.rfc-editor.org/info/rfc6458>。"
    },
    {
      "indent": 3,
      "text": "[RFC6951] Tuexen, M. and R. Stewart, \"UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication\", RFC 6951, DOI 10.17487/RFC6951, May 2013, <https://www.rfc-editor.org/info/rfc6951>.",
      "ja": "[RFC6951] Tuexen、M。およびR. Stewart、「エンドホスト通信のためのストリーム制御伝送プロトコル（SCTP）パケットのUDPカプセル化」、RFC 6951、DOI 10.17487/RFC6951、2013年5月、<https：//www.rfc-editor.org/info/rfc6951>。"
    },
    {
      "indent": 3,
      "text": "[RFC7053] Tuexen, M., Ruengeler, I., and R. Stewart, \"SACK-IMMEDIATELY Extension for the Stream Control Transmission Protocol\", RFC 7053, DOI 10.17487/RFC7053, November 2013, <https://www.rfc-editor.org/info/rfc7053>.",
      "ja": "[RFC7053] Tuexen、M.、Ruengeler、I。、およびR. Stewart、「ストリーム制御伝送プロトコルの補助的拡張式」、RFC 7053、DOI 10.17487/RFC7053、2013年11月、<https：//ww.rfc-editor.org/info/rfc7053>。"
    },
    {
      "indent": 3,
      "text": "[RFC8260] Stewart, R., Tuexen, M., Loreto, S., and R. Seggelmann, \"Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol\", RFC 8260, DOI 10.17487/RFC8260, November 2017, <https://www.rfc-editor.org/info/rfc8260>.",
      "ja": "[RFC8260] Stewart、R.、Tuexen、M.、Loreto、S。、およびR. Seggelmann、「ストリームスケジューラーとユーザーメッセージインターリービングのインターリービング」、RFC 8260、DOI 10.17487/RFC8260、2017年11月、<<<<<https://www.rfc-editor.org/info/rfc8260>。"
    },
    {
      "indent": 3,
      "text": "[RFC8261] Tuexen, M., Stewart, R., Jesup, R., and S. Loreto, \"Datagram Transport Layer Security (DTLS) Encapsulation of SCTP Packets\", RFC 8261, DOI 10.17487/RFC8261, November 2017, <https://www.rfc-editor.org/info/rfc8261>.",
      "ja": "[RFC8261] Tuexen、M.、Stewart、R.、Jesup、R。、およびS. Loreto、「データグラム輸送層セキュリティ（DTLS）SCTPパケットのカプセル化」、RFC 8261、DOI 10.17487/RFC8261、2017年11月、<HTTPS <<HTTPS：//www.rfc-editor.org/info/rfc8261>。"
    },
    {
      "indent": 3,
      "text": "[RFC8540] Stewart, R., Tuexen, M., and M. Proshin, \"Stream Control Transmission Protocol: Errata and Issues in RFC 4960\", RFC 8540, DOI 10.17487/RFC8540, February 2019, <https://www.rfc-editor.org/info/rfc8540>.",
      "ja": "[RFC8540] Stewart、R.、Tuexen、M。、およびM. Proshin、「Stream Control Transmission Protocol：Errata and Issues in RFC 4960」、RFC 8540、DOI 10.17487/RFC8540、2019年2月、<https：// www。rfc-editor.org/info/rfc8540>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. CRC32c Checksum Calculation",
      "section_title": true,
      "ja": "付録A. CRC32Cチェックサムの計算"
    },
    {
      "indent": 3,
      "text": "We define a 'reflected value' as one that is the opposite of the normal bit order of the machine. The 32-bit CRC (Cyclic Redundancy Check) is calculated, as described for CRC32c and uses the polynomial code 0x11EDC6F41 (Castagnoli93) or x^32+x^28+x^27+x^26+x^25+x^23+x^22 +x^20+x^19+x^18+x^14+x^13+x^11+x^10+x^9+x^8+x^6+x^0. The CRC is computed using a procedure similar to ETHERNET CRC [ITU.V42.1994], modified to reflect transport-level usage.",
      "ja": "「反射値」を、マシンの通常のビット順序の反対のものとして定義します。32ビットCRC（環状冗長チェック）が計算され、CRC32Cについて説明されており、多項式コード0x11EDC6F41（castAgnoli93）またはx^32 x^28 x^27 x^26 x^25 x^23 x^22 x^26 x^25 x^23 x^22 x^20 x^19 x^18 x^14 x^13 x^11 x^10 x^9 x^8 x^6 x^0。CRCは、輸送レベルの使用量を反映するように変更されたイーサネットCRC [ITU.V42.1994]に似た手順を使用して計算されます。"
    },
    {
      "indent": 3,
      "text": "CRC computation uses polynomial division. A message bit-string M is transformed to a polynomial, M(X), and the CRC is calculated from M(X) using polynomial arithmetic.",
      "ja": "CRC計算は、多項式分割を使用します。メッセージビットストリングMは多項式M（x）に変換され、CRCは多項式算術を使用してM（x）から計算されます。"
    },
    {
      "indent": 3,
      "text": "When CRCs are used at the link layer, the polynomial is derived from on-the-wire bit ordering: the first bit 'on the wire' is the high-order coefficient. Since SCTP is a transport-level protocol, it cannot know the actual serial-media bit ordering. Moreover, different links in the path between SCTP endpoints can use different link-level bit orders.",
      "ja": "CRCがリンクレイヤーで使用される場合、多項式はワイヤビットの順序付けから派生します。最初のビット「ワイヤ」は高次係数です。SCTPはトランスポートレベルのプロトコルであるため、実際のシリアルメディアビットの順序を知ることはできません。さらに、SCTPエンドポイント間のパス内の異なるリンクは、異なるリンクレベルのビット注文を使用できます。"
    },
    {
      "indent": 3,
      "text": "A convention therefore is established for mapping SCTP transport messages to polynomials for purposes of CRC computation. The bit-ordering for mapping SCTP messages to polynomials is that bytes are taken most-significant first, but, within each byte, bits are taken least-significant first. The first byte of the message provides the eight highest coefficients. Within each byte, the least-significant SCTP bit gives the most-significant polynomial coefficient within that byte, and the most-significant SCTP bit is the least-significant polynomial coefficient in that byte. (This bit ordering is sometimes called 'mirrored' or 'reflected' [WILLIAMS93].) CRC polynomials are to be transformed back into SCTP transport-level byte values, using a consistent mapping.",
      "ja": "したがって、CRC計算を目的として、SCTP輸送メッセージを多項式にマッピングするための条約が確立されます。SCTPメッセージを多項式にマッピングするためのビット順序は、バイトが最初に最も重要であることですが、各バイト内で、ビットは最初に最も重要ではないことです。メッセージの最初のバイトは、8つの最高の係数を提供します。各バイト内で、最も重要でないSCTPビットは、そのバイト内で最も重要な多項式係数を与え、最も重要なSCTPビットは、そのバイトで最も重要でない多項式係数です。（このビット順序は、「ミラーリング」または「反射」と呼ばれることもあります[Williams93]。）CRC多項式は、一貫したマッピングを使用して、SCTPトランスポートレベルのバイト値に変換されます。"
    },
    {
      "indent": 3,
      "text": "The SCTP transport-level CRC value can be calculated as follows:",
      "ja": "SCTPトランスポートレベルのCRC値は、次のように計算できます。"
    },
    {
      "indent": 3,
      "text": "* CRC input data is assigned to a byte stream, numbered from 0 to N-1.",
      "ja": "* CRC入力データは、0からN-1の番号のバイトストリームに割り当てられます。"
    },
    {
      "indent": 3,
      "text": "* The transport-level byte stream is mapped to a polynomial value. An N-byte PDU with j bytes numbered 0 to N-1 is considered as coefficients of a polynomial M(x) of order 8*N-1, with bit 0 of byte j being coefficient x^(8*(N-j)-8) and bit 7 of byte j being coefficient x^(8*(N-j)-1).",
      "ja": "* トランスポートレベルのバイトストリームは、多項式値にマッピングされます。n-1に番号が付けられたjバイトを持つnバイトPDUは、順序8*n-1の多項式m（x）の係数と見なされ、バイトjのビット0は係数x^（8*（n-j） - 8）およびバイトJのビット7は係数x^（8*（n-j）-1）です。"
    },
    {
      "indent": 3,
      "text": "* The CRC remainder register is initialized with all 1s and the CRC is computed with an algorithm that simultaneously multiplies by x^32 and divides by the CRC polynomial.",
      "ja": "* CRCの残りのレジスタはすべての1で初期化され、CRCは同時にx^32を乗算し、CRC多項式で除算するアルゴリズムで計算されます。"
    },
    {
      "indent": 3,
      "text": "* The polynomial is multiplied by x^32 and divided by G(x), the generator polynomial, producing a remainder R(x) of degree less than or equal to 31.",
      "ja": "* 多項式にx^32を乗算し、発電機多項式であるg（x）を除算し、31以下の程度の程度のr（x）を生成します。"
    },
    {
      "indent": 3,
      "text": "* The coefficients of R(x) are considered a 32-bit sequence.",
      "ja": "* r（x）の係数は32ビットシーケンスと見なされます。"
    },
    {
      "indent": 3,
      "text": "* The bit sequence is complemented. The result is the CRC polynomial.",
      "ja": "* ビットシーケンスが補完されます。結果はCRC多項式です。"
    },
    {
      "indent": 3,
      "text": "* The CRC polynomial is mapped back into SCTP transport-level bytes. The coefficient of x^31 gives the value of bit 7 of SCTP byte 0, and the coefficient of x^24 gives the value of bit 0 of byte 0. The coefficient of x^7 gives bit 7 of byte 3, and the coefficient of x^0 gives bit 0 of byte 3. The resulting 4-byte transport-level sequence is the 32-bit SCTP checksum value.",
      "ja": "* CRC多項式は、SCTPトランスポートレベルのバイトにマッピングされます。x^31の係数はSCTPバイト0のビット7の値を与え、x^24の係数はバイト0のビット0の値を与えますx^7はバイト3のビット7と係数を与えますx^0のバイト3のビット0を与えます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Standards documents, textbooks, and vendor literature on CRCs often follow an alternative formulation, in which the register used to hold the remainder of the long-division algorithm is initialized to zero rather than all ones, and instead the first 32 bits of the message are complemented. The long-division algorithm used in our formulation is specified such that the initial multiplication by 2^32 and the long-division are combined into one simultaneous operation. For such algorithms, and for messages longer than 64 bits, the two specifications are precisely equivalent. That equivalence is the intent of this document.",
      "ja": "実装注：CRCに関する標準文書、教科書、およびベンダーの文献は、多くの場合、代替の定式化に従います。この定式化では、残りの長さのアルゴリズムの残りを保持するために使用されていました。メッセージが補完されます。製剤で使用される長距離アルゴリズムは、2^32の初期乗算と長距離が1つの同時動作に結合されるように指定されています。このようなアルゴリズムの場合、および64ビットより長いメッセージの場合、2つの仕様はまったく同等です。その同等性は、このドキュメントの意図です。"
    },
    {
      "indent": 3,
      "text": "Implementors of SCTP are warned that both specifications are to be found in the literature, sometimes with no restriction on the long-division algorithm. The choice of formulation in this document is to permit non-SCTP usage, where the same CRC algorithm can be used to protect messages shorter than 64 bits.",
      "ja": "SCTPの実装者は、両方の仕様が文献に記載されていることを警告されています。時には長距離アルゴリズムに制限がない場合があります。このドキュメントの定式化の選択は、同じCRCアルゴリズムを使用して64ビットより短いメッセージを保護できる非SCTP使用を可能にすることです。"
    },
    {
      "indent": 3,
      "text": "There can be a computational advantage in validating the association against the Verification Tag, prior to performing a checksum, as invalid tags will result in the same action as a bad checksum in most cases. The exceptions for this technique would be packets containing INIT chunks and some SHUTDOWN-COMPLETE chunks, as well as a stale COOKIE ECHO chunks. These special-case exchanges represent small packets and will minimize the effect of the checksum calculation.",
      "ja": "チェックサムを実行する前に、確認タグに対する関連性を検証する際に計算上の利点がある可能性があります。無効なタグは、ほとんどの場合、悪いチェックサムと同じアクションにつながるためです。この手法の例外は、initチャンクといくつかのシャットダウン完全なチャンクを含むパケットと、古いクッキーエコーチャンクです。これらの特別ケース交換は小さなパケットを表しており、チェックサムの計算の影響を最小限に抑えます。"
    },
    {
      "indent": 3,
      "text": "The following non-normative sample code is taken from an open-source CRC generator [WILLIAMS93], using the \"mirroring\" technique and yielding a lookup table for SCTP CRC32c with 256 entries, each 32 bits wide. While neither especially slow nor especially fast, as software table-lookup CRCs go, it has the advantage of working on both big-endian and little-endian CPUs, using the same (host-order) lookup tables, and using only the predefined ntohl() and htonl() operations. The code is somewhat modified from [WILLIAMS93] to ensure portability between big-endian and little-endian architectures, use fixed-sized types to allow portability between 32-bit and 64-bit platforms, and use general C code improvements. (Note that, if the byte endian-ness of the target architecture is known to be little endian, the final bit-reversal and byte-reversal steps can be folded into a single operation.)",
      "ja": "次の非規範的なサンプルコードは、オープンソースCRCジェネレーター[Williams93]から取得され、「ミラーリング」手法を使用し、256エントリのSCTP CRC32Cのルックアップテーブルを幅それぞれ32ビット幅で採取します。ソフトウェアのテーブルルックアップCRCが進むにつれて、特に遅くも速いことも特に高速ではありませんが、同じ（ホストの）ルックアップテーブルを使用し、事前定義されたNTOHLのみを使用して、ビッグエンディアンとリトルエンディアンの両方のCPUに取り組むという利点があります。（）およびhtonl（）操作。このコードは、[Williams93]からやや変更されており、ビッグエンディアンとリトルエンディアンのアーキテクチャ間の移植性を確保し、固定サイズのタイプを使用して32ビットと64ビットのプラットフォーム間の移植性を可能にし、一般的なCコードの改善を使用します。（ターゲットアーキテクチャのバイトエンディアン性がリトルエンディアンであることが知られている場合、最終的なビット反転およびバイト反転ステップを単一の操作に折りたたむことができることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\n/****************************************************************/\n/* Note: The definitions for Ross Williams's table generator    */\n/* would be TB_WIDTH=4, TB_POLY=0x1EDC6F41, TB_REVER=TRUE.      */\n/* For Mr. Williams's direct calculation code, use the settings */\n/* cm_width=32, cm_poly=0x1EDC6F41, cm_init=0xFFFFFFFF,         */\n/* cm_refin=TRUE, cm_refot=TRUE, cm_xorot=0x00000000.           */\n/****************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Example of the crc table file */\n#ifndef __crc32cr_h__\n#define __crc32cr_h__",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define CRC32C_POLY 0x1EDC6F41UL\n#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uint32_t crc_c[256] = {\n  0x00000000UL, 0xF26B8303UL, 0xE13B70F7UL, 0x1350F3F4UL,\n  0xC79A971FUL, 0x35F1141CUL, 0x26A1E7E8UL, 0xD4CA64EBUL,\n  0x8AD958CFUL, 0x78B2DBCCUL, 0x6BE22838UL, 0x9989AB3BUL,\n  0x4D43CFD0UL, 0xBF284CD3UL, 0xAC78BF27UL, 0x5E133C24UL,\n  0x105EC76FUL, 0xE235446CUL, 0xF165B798UL, 0x030E349BUL,\n  0xD7C45070UL, 0x25AFD373UL, 0x36FF2087UL, 0xC494A384UL,\n  0x9A879FA0UL, 0x68EC1CA3UL, 0x7BBCEF57UL, 0x89D76C54UL,\n  0x5D1D08BFUL, 0xAF768BBCUL, 0xBC267848UL, 0x4E4DFB4BUL,\n  0x20BD8EDEUL, 0xD2D60DDDUL, 0xC186FE29UL, 0x33ED7D2AUL,\n  0xE72719C1UL, 0x154C9AC2UL, 0x061C6936UL, 0xF477EA35UL,\n  0xAA64D611UL, 0x580F5512UL, 0x4B5FA6E6UL, 0xB93425E5UL,\n  0x6DFE410EUL, 0x9F95C20DUL, 0x8CC531F9UL, 0x7EAEB2FAUL,\n  0x30E349B1UL, 0xC288CAB2UL, 0xD1D83946UL, 0x23B3BA45UL,\n  0xF779DEAEUL, 0x05125DADUL, 0x1642AE59UL, 0xE4292D5AUL,\n  0xBA3A117EUL, 0x4851927DUL, 0x5B016189UL, 0xA96AE28AUL,\n  0x7DA08661UL, 0x8FCB0562UL, 0x9C9BF696UL, 0x6EF07595UL,\n  0x417B1DBCUL, 0xB3109EBFUL, 0xA0406D4BUL, 0x522BEE48UL,\n  0x86E18AA3UL, 0x748A09A0UL, 0x67DAFA54UL, 0x95B17957UL,\n  0xCBA24573UL, 0x39C9C670UL, 0x2A993584UL, 0xD8F2B687UL,\n  0x0C38D26CUL, 0xFE53516FUL, 0xED03A29BUL, 0x1F682198UL,\n  0x5125DAD3UL, 0xA34E59D0UL, 0xB01EAA24UL, 0x42752927UL,\n  0x96BF4DCCUL, 0x64D4CECFUL, 0x77843D3BUL, 0x85EFBE38UL,\n  0xDBFC821CUL, 0x2997011FUL, 0x3AC7F2EBUL, 0xC8AC71E8UL,\n  0x1C661503UL, 0xEE0D9600UL, 0xFD5D65F4UL, 0x0F36E6F7UL,\n  0x61C69362UL, 0x93AD1061UL, 0x80FDE395UL, 0x72966096UL,\n  0xA65C047DUL, 0x5437877EUL, 0x4767748AUL, 0xB50CF789UL,\n  0xEB1FCBADUL, 0x197448AEUL, 0x0A24BB5AUL, 0xF84F3859UL,\n  0x2C855CB2UL, 0xDEEEDFB1UL, 0xCDBE2C45UL, 0x3FD5AF46UL,\n  0x7198540DUL, 0x83F3D70EUL, 0x90A324FAUL, 0x62C8A7F9UL,\n  0xB602C312UL, 0x44694011UL, 0x5739B3E5UL, 0xA55230E6UL,\n  0xFB410CC2UL, 0x092A8FC1UL, 0x1A7A7C35UL, 0xE811FF36UL,\n  0x3CDB9BDDUL, 0xCEB018DEUL, 0xDDE0EB2AUL, 0x2F8B6829UL,\n  0x82F63B78UL, 0x709DB87BUL, 0x63CD4B8FUL, 0x91A6C88CUL,\n  0x456CAC67UL, 0xB7072F64UL, 0xA457DC90UL, 0x563C5F93UL,\n  0x082F63B7UL, 0xFA44E0B4UL, 0xE9141340UL, 0x1B7F9043UL,\n  0xCFB5F4A8UL, 0x3DDE77ABUL, 0x2E8E845FUL, 0xDCE5075CUL,\n  0x92A8FC17UL, 0x60C37F14UL, 0x73938CE0UL, 0x81F80FE3UL,\n  0x55326B08UL, 0xA759E80BUL, 0xB4091BFFUL, 0x466298FCUL,\n  0x1871A4D8UL, 0xEA1A27DBUL, 0xF94AD42FUL, 0x0B21572CUL,\n  0xDFEB33C7UL, 0x2D80B0C4UL, 0x3ED04330UL, 0xCCBBC033UL,\n  0xA24BB5A6UL, 0x502036A5UL, 0x4370C551UL, 0xB11B4652UL,\n  0x65D122B9UL, 0x97BAA1BAUL, 0x84EA524EUL, 0x7681D14DUL,\n  0x2892ED69UL, 0xDAF96E6AUL, 0xC9A99D9EUL, 0x3BC21E9DUL,\n  0xEF087A76UL, 0x1D63F975UL, 0x0E330A81UL, 0xFC588982UL,\n  0xB21572C9UL, 0x407EF1CAUL, 0x532E023EUL, 0xA145813DUL,\n  0x758FE5D6UL, 0x87E466D5UL, 0x94B49521UL, 0x66DF1622UL,\n  0x38CC2A06UL, 0xCAA7A905UL, 0xD9F75AF1UL, 0x2B9CD9F2UL,\n  0xFF56BD19UL, 0x0D3D3E1AUL, 0x1E6DCDEEUL, 0xEC064EEDUL,\n  0xC38D26C4UL, 0x31E6A5C7UL, 0x22B65633UL, 0xD0DDD530UL,\n  0x0417B1DBUL, 0xF67C32D8UL, 0xE52CC12CUL, 0x1747422FUL,\n  0x49547E0BUL, 0xBB3FFD08UL, 0xA86F0EFCUL, 0x5A048DFFUL,\n  0x8ECEE914UL, 0x7CA56A17UL, 0x6FF599E3UL, 0x9D9E1AE0UL,\n  0xD3D3E1ABUL, 0x21B862A8UL, 0x32E8915CUL, 0xC083125FUL,\n  0x144976B4UL, 0xE622F5B7UL, 0xF5720643UL, 0x07198540UL,\n  0x590AB964UL, 0xAB613A67UL, 0xB831C993UL, 0x4A5A4A90UL,\n  0x9E902E7BUL, 0x6CFBAD78UL, 0x7FAB5E8CUL, 0x8DC0DD8FUL,\n  0xE330A81AUL, 0x115B2B19UL, 0x020BD8EDUL, 0xF0605BEEUL,\n  0x24AA3F05UL, 0xD6C1BC06UL, 0xC5914FF2UL, 0x37FACCF1UL,\n  0x69E9F0D5UL, 0x9B8273D6UL, 0x88D28022UL, 0x7AB90321UL,\n  0xAE7367CAUL, 0x5C18E4C9UL, 0x4F48173DUL, 0xBD23943EUL,\n  0xF36E6F75UL, 0x0105EC76UL, 0x12551F82UL, 0xE03E9C81UL,\n  0x34F4F86AUL, 0xC69F7B69UL, 0xD5CF889DUL, 0x27A40B9EUL,\n  0x79B737BAUL, 0x8BDCB4B9UL, 0x988C474DUL, 0x6AE7C44EUL,\n  0xBE2DA0A5UL, 0x4C4623A6UL, 0x5F16D052UL, 0xAD7D5351UL,\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 3,
      "text": "/* Example of table build routine */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <stdio.h>\n#include <stdlib.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define OUTPUT_FILE \"crc32cr.h\" #define CRC32C_POLY 0x1EDC6F41UL",
      "ja": "#define output_file \"crc32cr.h\" #define crc32c_poly 0x1edc6f41ul"
    },
    {
      "indent": 3,
      "text": "static FILE *tf;",
      "ja": "静的ファイル *tf;"
    },
    {
      "indent": 3,
      "text": "static uint32_t\nreflect_32(uint32_t b)\n{\n  int i;\n  uint32_t rw = 0UL;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  for (i = 0; i < 32; i++) {\n    if (b & 1)\n      rw |= 1UL << (31 - i);\n    b >>= 1;\n  }\n  return (rw);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "static uint32_t\nbuild_crc_table (int index)\n{\n  int i;\n  uint32_t rb;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "rb = reflect_32(index);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  for (i = 0; i < 8; i++) {\n    if (rb & 0x80000000UL)\n      rb = (rb << 1) ^ (uint32_t)CRC32C_POLY;\n    else\n      rb <<= 1;\n  }\n  return (reflect_32(rb));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int\nmain (void)\n{\n  int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "printf(\"\\nGenerating CRC32c table file <%s>.\\n\",\nOUTPUT_FILE);\nif ((tf = fopen(OUTPUT_FILE, \"w\")) == NULL) {\n  printf(\"Unable to open %s.\\n\", OUTPUT_FILE);\n  exit (1);\n}\nfprintf(tf, \"#ifndef __crc32cr_h__\\n\");\nfprintf(tf, \"#define __crc32cr_h__\\n\\n\");\nfprintf(tf, \"#define CRC32C_POLY 0x%08XUL\\n\",\n  (uint32_t)CRC32C_POLY);\nfprintf(tf,\n  \"#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])\\n\");\nfprintf(tf, \"\\nuint32_t crc_c[256] =\\n{\\n\");\nfor (i = 0; i < 256; i++) {\n  fprintf(tf, \"0x%08XUL,\", build_crc_table (i));\n  if ((i & 3) == 3)\n    fprintf(tf, \"\\n\");\n  else\n    fprintf(tf, \" \");\n}\nfprintf(tf, \"};\\n\\n#endif\\n\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  if (fclose(tf) != 0)\n    printf(\"Unable to close <%s>.\\n\", OUTPUT_FILE);\n  else\n    printf(\"\\nThe CRC32c table has been written to <%s>.\\n\",\n      OUTPUT_FILE);\n  return (0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Example of crc insertion */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"crc32cr.h\"",
      "ja": "#include \"crc32cr.h\""
    },
    {
      "indent": 3,
      "text": "uint32_t\ngenerate_crc32c(unsigned char *buffer, unsigned int length)\n{\n  unsigned int i;\n  uint32_t crc32 = 0xffffffffUL;\n  uint32_t result;\n  uint32_t byte0, byte1, byte2, byte3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "for (i = 0; i < length; i++) {\n  CRC32C(crc32, buffer[i]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "result = ~crc32;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*  result now holds the negated polynomial remainder,\n *  since the table and algorithm are \"reflected\" [williams95].\n *  That is, result has the same value as if we mapped the message\n *  to a polynomial, computed the host-bit-order polynomial\n *  remainder, performed final negation, and then did an\n *  end-for-end bit-reversal.\n *  Note that a 32-bit bit-reversal is identical to four in-place\n *  8-bit bit-reversals followed by an end-for-end byteswap.\n *  In other words, the bits of each byte are in the right order,\n *  but the bytes have been byteswapped.  So, we now do an explicit\n *  byteswap.  On a little-endian machine, this byteswap and\n *  the final ntohl cancel out and could be elided.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  byte0 = result & 0xff;\n  byte1 = (result>>8) & 0xff;\n  byte2 = (result>>16) & 0xff;\n  byte3 = (result>>24) & 0xff;\n  crc32 = ((byte0 << 24) |\n           (byte1 << 16) |\n           (byte2 << 8)  |\n           byte3);\n  return (crc32);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int\ninsert_crc32(unsigned char *buffer, unsigned int length)\n{\n  SCTP_message *message;\n  uint32_t crc32;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  message = (SCTP_message *)buffer;\n  message->common_header.checksum = 0UL;\n  crc32 = generate_crc32c(buffer,length);\n  /* and insert it into the message */\n  message->common_header.checksum = htonl(crc32);\n  return (1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int\nvalidate_crc32(unsigned char *buffer, unsigned int length)\n{\n  SCTP_message *message;\n  unsigned int i;\n  uint32_t original_crc32;\n  uint32_t crc32;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  /* save and zero checksum */\n  message = (SCTP_message *)buffer;\n  original_crc32 = ntohl(message->common_header.checksum);\n  message->common_header.checksum = 0L;\n  crc32 = generate_crc32c(buffer, length);\n  return ((original_crc32 == crc32) ? 1 : -1);\n}\n<CODE ENDS>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "An undertaking represented by this updated document is not a small feat and represents the summation of the initial coauthors of [RFC2960]: Q. Xie, K. Morneault, C. Sharp, H. Schwarzbauer, T. Taylor, I. Rytina, M. Kalla, L. Zhang, and V. Paxson.",
      "ja": "この更新されたドキュメントで表される事業は小さな偉業ではなく、[RFC2960]の最初の共著者の合計を表しています：Q。Xie、K。Morneault、C。Sharp、H。Schwarzbauer、T。Taylor、I。Rytina、M M。カラ、L。チャン、およびV.パクソン。"
    },
    {
      "indent": 3,
      "text": "Add to that, the comments from everyone who contributed to [RFC2960]: Mark Allman, R. J. Atkinson, Richard Band, Scott Bradner, Steve Bellovin, Peter Butler, Ram Dantu, R. Ezhirpavai, Mike Fisk, Sally Floyd, Atsushi Fukumoto, Matt Holdrege, Henry Houh, Christian Huitema, Gary Lehecka, Jonathan Lee, David Lehmann, John Loughney, Daniel Luan, Barry Nagelberg, Thomas Narten, Erik Nordmark, Lyndon Ong, Shyamal Prasad, Kelvin Porter, Heinz Prantner, Jarno Rajahalme, Raymond E. Reeves, Renee Revis, Ivan Arias Rodriguez, A. Sankar, Greg Sidebottom, Brian Wyld, La Monte Yarroll, and many others for their invaluable comments.",
      "ja": "それに加えて、[RFC2960]に貢献したすべての人からのコメント：マーク・オールマン、R。J。アトキンソン、リチャードバンド、スコットブラッドナー、スティーブベロビン、ピーターバトラー、ラムダントゥ、R。ホールデージ、ヘンリー・ホー、クリスチャン・フイテマ、ゲイリー・レヘッカ、ジョナサン・リー、デビッド・レーマン、ジョン・ラフニー、ダニエル・ルアン、バリー・ナゲルバーグ、トーマス・ナルテン、エリック・ノードマーク、リンドン・オンド、シャマル・プラサド、ケルヴィン・ポーター、ハインズ・プラントナー、ジャルノ・ラーマン・イェンズ・プラントナー、Reeves、Renee Revis、Ivan Arias Rodriguez、A。Sankar、Greg Sidebottom、Brian Wyld、La Monte Yarroll、その他多くのコメントについて。"
    },
    {
      "indent": 3,
      "text": "Then, add the coauthors of [RFC4460]: I. Arias-Rodriguez, K. Poon, and A. Caro.",
      "ja": "次に、[RFC4460]の共著者を追加します：I。Arias-Rodriguez、K。Poon、およびA. Caro。"
    },
    {
      "indent": 3,
      "text": "Then, add to these the efforts of all the subsequent seven SCTP interoperability tests and those who commented on [RFC4460], as shown in its acknowledgements: Barry Zuckerman, La Monte Yarroll, Qiaobing Xie, Wang Xiaopeng, Jonathan Wood, Jeff Waskow, Mike Turner, John Townsend, Sabina Torrente, Cliff Thomas, Yuji Suzuki, Manoj Solanki, Sverre Slotte, Keyur Shah, Jan Rovins, Ben Robinson, Renee Revis, Ian Periam, RC Monee, Sanjay Rao, Sujith Radhakrishnan, Heinz Prantner, Biren Patel, Nathalie Mouellic, Mitch Miers, Bernward Meyknecht, Stan McClellan, Oliver Mayor, Tomas Orti Martin, Sandeep Mahajan, David Lehmann, Jonathan Lee, Philippe Langlois, Karl Knutson, Joe Keller, Gareth Keily, Andreas Jungmaier, Janardhan Iyengar, Mutsuya Irie, John Hebert, Kausar Hassan, Fred Hasle, Dan Harrison, Jon Grim, Laurent Glaude, Steven Furniss, Atsushi Fukumoto, Ken Fujita, Steve Dimig, Thomas Curran, Serkan Cil, Melissa Campbell, Peter Butler, Rob Brennan, Harsh Bhondwe, Brian Bidulock, Caitlin Bestler, Jon Berger, Robby Benedyk, Stephen Baucke, Sandeep Balani, and Ronnie Sellar.",
      "ja": "次に、これらに、その後のすべての7つのSCTP相互運用性テストの努力と、その認識に示されているように、[RFC4460]にコメントした人：バリーザッカーマン、ラモンテヤロル、Qiaobing Xie、王Xiaopeng、ジョナサンウッド、ジェフワスコフ、マイキターナー、ジョン・タウンゼンド、サビーナ・トレンテ、クリフ・トーマス、鈴木ゆっくり、マノジ・ソルンキ、スヴェレ・スロッテ、キール・シャー、ヤン・ロビンズ、ベン・ロビンソン、レニー・レビス、イアン・ペリアム、RC・モニー、サンジェイ・ラオ、スジス・ラダクリシュナン、ヘインズ・プラントナン、ビリエン・パテルナタリー・マウエリック、ミッチ・マイアーズ、ベルンワード・メイクネヒト、スタン・マクレラン、オリバー市長、トマス・オルティ・マーティン、サンディープ・マハジャン、デビッド・レーマン、ジョナサン・リー、フィリップ・ラングロイス、カール・ナットソン、ジョー・ケラー、ガーリー・キーイ、ジャナルダ・イエイヤ、ムット・イエガー、ジョンマー・イエイヤ、 Hebert、Kausar Hassan、Fred Hasle、Dan Harrison、Jon Grim、Laurent Glaude、Steven Furniss、Atsushi Fukumoto、Ken Fujita、Steve Dimig、Thomas Curran、Serkan Cil、Melissa Campbell、Petetケイトリン・ベスTler、Jon Berger、Robby Benedyk、Stephen Baucke、Sandeep Balani、およびRonnie Sellar。"
    },
    {
      "indent": 3,
      "text": "A special thanks to Mark Allman, who actually should have been a coauthor of [RFC4460] for his work on the max-burst but managed to wiggle out due to a technicality.",
      "ja": "Max-Burstでの仕事のために[RFC4460]の共著者であるはずだったが、専門性のためになんとか揺れ動くことができたMark Allmanに感謝します。"
    },
    {
      "indent": 3,
      "text": "Also, we would like to acknowledge Lyndon Ong and Phil Conrad for their valuable input and many contributions.",
      "ja": "また、Lyndon OngとPhil Conradの貴重な意見と多くの貢献について認めたいと思います。"
    },
    {
      "indent": 3,
      "text": "Furthermore, you have [RFC4960] and those who have commented upon that, including Alfred Hönes and Ronnie Sellars.",
      "ja": "さらに、[RFC4960]と、AlfredHönesやRonnie Sellarsなど、コメントした人がいます。"
    },
    {
      "indent": 3,
      "text": "Then, add the coauthor of [RFC8540]: Maksim Proshin.",
      "ja": "次に、[RFC8540]の共著者を追加します：Maksim Proshin。"
    },
    {
      "indent": 3,
      "text": "And people who have commented on [RFC8540]: Pontus Andersson, Eric W. Biederman, Cedric Bonnet, Spencer Dawkins, Gorry Fairhurst, Benjamin Kaduk, Mirja Kühlewind, Peter Lei, Gyula Marosi, Lionel Morand, Jeff Morriss, Tom Petch, Kacheong Poon, Julien Pourtet, Irene Rüngeler, Michael Welzl, and Qiaobing Xie.",
      "ja": "[RFC8540]についてコメントした人々：ポントゥス・アンダーソン、エリック・W・ビーダーマン、セドリック・ボンネット、スペンサー・ドーキンス、ゴリー・フェアハースト、ベンジャミン・カドゥク、ミルジャ・キュルウィンド、ピーター・レイ、ギュラ・マロシ、リオン・モランド、ジョフ・モリス・モランド、トム・モリス・モランド、ジュリエン・プルテット、アイリーン・ルンゲラー、マイケル・ウェルツル、Qiaobing Xie。"
    },
    {
      "indent": 3,
      "text": "And, finally, the people who have provided comments for this document, including Gorry Fairhurst, Martin Duke, Benjamin Kaduk, Tero Kivinen, Eliot Lear, Marcelo Ricardo Leitner, David Mandelberg, John Preuß Mattsson, Claudio Porfiri, Maksim Proshin, Ines Robles, Timo Völker, Magnus Westerlund, and Zhouming.",
      "ja": "そして最後に、Gorry Fairhurst、Martin Duke、Benjamin Kaduk、Tero Kivinen、Eliot Lear、Marcelo Ricardo Leitner、David Mandelberg、JohnPreußMattsson、Claudio Porfiri、Maksim Proshin、Ines Robles、Ines Roblesなど、この文書にコメントを提供した人々はこの文書を提供しました。ティモ・ヴァルカー、マグナス・ウェスターランド、およびズーミング。"
    },
    {
      "indent": 3,
      "text": "Our thanks cannot be adequately expressed to all of you who have participated in the coding, testing, and updating process of this document. All we can say is, Thank You!",
      "ja": "このドキュメントのコーディング、テスト、および更新に参加したすべての皆さんに感謝することはできません。私たちが言えることは、ありがとう！"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart Netflix, Inc. 2455 Heritage Green Ave Davenport, FL 33837 United States of America Email: randall@lakerest.net",
      "ja": "Randall R. Stewart Netflix、Inc。2455 Heritage Green Ave Davenport、FL 33837アメリカ合衆国電子メール：randall@lakerest.net"
    },
    {
      "indent": 3,
      "text": "Michael Tüxen Münster University of Applied Sciences Stegerwaldstrasse 39 48565 Steinfurt Germany Email: tuexen@fh-muenster.de",
      "ja": "MichaelTüxenMünsterUniversity of Applied Sciences StegerwaldStrasse 39 48565 Steinfurt Germanyメール：tuexen@fh-muenster.de"
    },
    {
      "indent": 3,
      "text": "Karen E. E. Nielsen Kamstrup A/S Industrivej 28 DK-8660 Skanderborg Denmark Email: kee@kamstrup.com",
      "ja": "Karen E. E. Nielsen Kamstrup A/S Industrivej 28 DK-8660 Skanderborg Denmarkメール：kee@kamstrup.com"
    }
  ]
}