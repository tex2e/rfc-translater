{
  "title": {
    "text": "RFC 9381 - Verifiable Random Functions (VRFs)",
    "ja": "RFC 9381 - 検証可能なランダム関数（VRF）"
  },
  "number": 9381,
  "created_at": "2024-03-20 16:23:05.482292+09:00",
  "updated_by": "自動生成(GPT)＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          S. Goldberg\nRequest for Comments: 9381                             Boston University\nCategory: Informational                                        L. Reyzin\nISSN: 2070-1721                           Boston University and Algorand\n                                                         D. Papadopoulos\n                          Hong Kong University of Science and Technology\n                                                               J. Včelák\n                                                                     NS1\n                                                             August 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Verifiable Random Functions (VRFs)",
      "title": true,
      "section_title": true,
      "ja": "検証可能なランダム関数（VRF）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "A Verifiable Random Function (VRF) is the public key version of a keyed cryptographic hash. Only the holder of the secret key can compute the hash, but anyone with the public key can verify the correctness of the hash. VRFs are useful for preventing enumeration of hash-based data structures. This document specifies VRF constructions based on RSA and elliptic curves that are secure in the cryptographic random oracle model.",
      "ja": "検証可能なランダム関数（VRF）は、鍵付き暗号ハッシュの公開鍵バージョンです。秘密鍵の保持者だけがハッシュを計算できますが、公開鍵を持つ者はハッシュの正当性を検証できます。VRFは、ハッシュベースのデータ構造の列挙を防ぐのに役立ちます。この文書は、RSAと楕円曲線に基づくVRF構築を、暗号的ランダムオラクルモデルで安全なものとして指定します。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.",
      "ja": "この文書は、IRTFのCrypto Forum Research Group（CFRG）の成果です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書はインターネット標準トラック仕様ではありません。情報提供のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書はインターネット研究タスクフォース（IRTF）の成果です。IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの成果は展開に適していない可能性があります。このRFCは、インターネット研究タスクフォース（IRTF）のCrypto Forum Research Groupの合意を表しています。IRSGによって公表が承認された文書は、インターネット標準のいかなるレベルの候補としても適していません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9381.",
      "ja": "この文書の現在の状況、誤り表、およびフィードバック方法に関する情報は、https://www.rfc-editor.org/info/rfc9381 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書の著者として特定された個人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、この文書の公開日に有効なBCP 78およびIETF文書に関連するIETF信託の法的規定（https://trustee.ietf.org/license-info）の対象となります。これらの文書を注意深く確認してください。これらは、この文書に関するあなたの権利と制限を説明しています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements\n  1.2.  Terminology\n2.  VRF Algorithms\n3.  VRF Security Properties\n  3.1.  Full Uniqueness\n  3.2.  Full Collision Resistance\n  3.3.  Trusted Uniqueness and Trusted Collision Resistance\n  3.4.  Full Pseudorandomness or Selective Pseudorandomness\n  3.5.  Unpredictability under Malicious Key Generation\n4.  RSA Full Domain Hash VRF (RSA-FDH-VRF)\n  4.1.  RSA-FDH-VRF Proving\n  4.2.  RSA-FDH-VRF Proof to Hash\n  4.3.  RSA-FDH-VRF Verifying\n  4.4.  RSA-FDH-VRF Ciphersuites\n5.  Elliptic Curve VRF (ECVRF)\n  5.1.  ECVRF Proving\n  5.2.  ECVRF Proof to Hash\n  5.3.  ECVRF Verifying\n  5.4.  ECVRF Auxiliary Functions\n    5.4.1.  ECVRF Encode to Curve\n    5.4.2.  ECVRF Nonce Generation\n    5.4.3.  ECVRF Challenge Generation\n    5.4.4.  ECVRF Decode Proof\n    5.4.5.  ECVRF Validate Key\n  5.5.  ECVRF Ciphersuites\n6.  IANA Considerations\n7.  Security Considerations\n  7.1.  Key Generation\n    7.1.1.  Uniqueness and Collision Resistance under Malicious Key\n            Generation\n    7.1.2.  Pseudorandomness under Malicious Key Generation\n    7.1.3.  Unpredictability under Malicious Key Generation\n  7.2.  Security Levels\n  7.3.  Selective vs. Full Pseudorandomness\n  7.4.  Proper Pseudorandom Nonce for the ECVRF\n  7.5.  Side-Channel Attacks\n  7.6.  Proofs Provide No Secrecy for the VRF Input\n  7.7.  Prehashing\n  7.8.  Hash Function Domain Separation\n  7.9.  Hash Function Salting\n  7.10. Futureproofing\n8.  References\n  8.1.  Normative References\n  8.2.  Informative References\nAppendix A.  Test Vectors for the RSA-FDH-VRF Ciphersuites\n  A.1.  RSA-FDH-VRF-SHA256\n  A.2.  RSA-FDH-VRF-SHA384\n  A.3.  RSA-FDH-VRF-SHA512\nAppendix B.  Test Vectors for the ECVRF Ciphersuites\n  B.1.  ECVRF-P256-SHA256-TAI\n  B.2.  ECVRF-P256-SHA256-SSWU\n  B.3.  ECVRF-EDWARDS25519-SHA512-TAI\n  B.4.  ECVRF-EDWARDS25519-SHA512-ELL2\nContributors\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A Verifiable Random Function (VRF) [MRV99] is the public key version of a keyed cryptographic hash. Only the holder of the VRF secret key can compute the hash, but anyone with the corresponding public key can verify the correctness of the hash.",
      "ja": "検証可能なランダム関数（VRF）[MRV99]は、キー付き暗号ハッシュの公開鍵バージョンです。 VRF秘密鍵の保持者だけがハッシュを計算できますが、対応する公開鍵を持つ誰もがハッシュの正しさを検証できます。"
    },
    {
      "indent": 3,
      "text": "A key application of the VRF is to provide privacy against offline dictionary attacks (also known as enumeration attacks) on data stored in a hash-based data structure. In this application, a Prover holds the VRF secret key and uses the VRF hashing to construct a hash-based data structure on the input data.",
      "ja": "VRFの主要な用途の1つは、ハッシュベースのデータ構造に格納されたデータに対するオフライン辞書攻撃（列挙攻撃とも呼ばれる）に対するプライバシーを提供することです。このアプリケーションでは、プルーバはVRFの秘密鍵を保持し、VRFハッシングを使用して入力データ上のハッシュベースのデータ構造を構築します。"
    },
    {
      "indent": 3,
      "text": "Due to the nature of the VRF, only the Prover can answer queries about whether or not some data is stored in the data structure. Anyone who knows the VRF public key can verify that the Prover has answered the queries correctly. However, no offline inferences (i.e., inferences without querying the Prover) can be made about the data stored in the data structure.",
      "ja": "VRFの性質上、データがデータ構造に格納されているかどうかに関するクエリに対応できるのはプルーバーだけです。VRFの公開鍵を知っている人は、プルーバーがクエリに正しく答えたかどうかを検証できます。ただし、データ構造に格納されているデータについては、オフライン推論（つまり、プルーバーにクエリを送信せずに推論すること）はできません。"
    },
    {
      "indent": 3,
      "text": "This document defines VRFs based on RSA and elliptic curves. The choices of VRFs for inclusion in this document were based, in part, on synergy with existing RFCs and commonly available implementations of individual components that are used within the VRFs.",
      "ja": "この文書は、RSAと楕円曲線に基づくVRFを定義しています。この文書に含まれるVRFの選択は、既存のRFCとVRF内で使用される個々のコンポーネントの一般的に利用可能な実装とのシナジーに基づいています。"
    },
    {
      "indent": 3,
      "text": "The particular choice of the VRF for a given application depends on the desired security properties, the availability of cryptographically strong implementations, efficiency constraints, and the trust one places in RSA and elliptic curve Diffie-Hellman assumptions (and the trust in a particular choice of curve in the case of elliptic curves). Differences in the security properties provided by the different options are discussed in Sections 3 and 7.",
      "ja": "特定のアプリケーションにおけるVRFの選択は、望ましいセキュリティ特性、暗号的に強力な実装の利用可能性、効率の制約、RSAおよび楕円曲線Diffie-Hellmanの仮定に対する信頼（および楕円曲線の場合の特定の曲線の選択に対する信頼）に依存します。異なるオプションが提供するセキュリティ特性の違いについては、セクション3および7で議論されています。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Crypto Forum Research Group (CFRG).",
      "ja": "この文書は、Crypto Forum Research Group（CFRG）の合意を表しています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements",
      "section_title": true,
      "ja": "1.1. 要件"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書における「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」というキーワードは、全て大文字で表記されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "The following terminology is used throughout this document:",
      "ja": "この文書全体で以下の用語が使用されます："
    },
    {
      "indent": 3,
      "text": "SK:",
      "ja": "SK:"
    },
    {
      "indent": 12,
      "text": "The secret key for the VRF. (Note: The secret key is also sometimes called a \"private key\".)",
      "ja": "VRFの秘密鍵。 （注：秘密鍵は時々「プライベートキー」とも呼ばれます。）"
    },
    {
      "indent": 3,
      "text": "PK:",
      "ja": "PK:"
    },
    {
      "indent": 12,
      "text": "The public key for the VRF.",
      "ja": "VRFの公開鍵。"
    },
    {
      "indent": 3,
      "text": "alpha or alpha_string:",
      "ja": "alphaまたはalpha_string:"
    },
    {
      "indent": 12,
      "text": "The input to be hashed by the VRF.",
      "ja": "VRF によってハッシュされる入力。"
    },
    {
      "indent": 3,
      "text": "beta or beta_string:",
      "ja": "betaまたはbeta_string:"
    },
    {
      "indent": 12,
      "text": "The VRF hash output.",
      "ja": "VRFハッシュ出力。"
    },
    {
      "indent": 3,
      "text": "pi or pi_string:",
      "ja": "piまたはpi_string:"
    },
    {
      "indent": 12,
      "text": "The VRF proof.",
      "ja": "VRFの証明。"
    },
    {
      "indent": 3,
      "text": "Prover:",
      "ja": "Prover:"
    },
    {
      "indent": 12,
      "text": "Holds the VRF secret key SK and public key PK.",
      "ja": "VRFの秘密鍵SKと公開鍵PKを保持します。"
    },
    {
      "indent": 3,
      "text": "Verifier:",
      "ja": "検証者:"
    },
    {
      "indent": 12,
      "text": "Holds the VRF public key PK.",
      "ja": "VRFの公開鍵PKを保持します。"
    },
    {
      "indent": 3,
      "text": "Adversary:",
      "ja": "Adversary:"
    },
    {
      "indent": 12,
      "text": "Potential attacker; often used to define a security property.",
      "ja": "潜在的な攻撃者；セキュリティプロパティを定義するためによく使用されます。"
    },
    {
      "indent": 3,
      "text": "Malicious (or adversarial):",
      "ja": "悪意のある（または敵対的な）:"
    },
    {
      "indent": 12,
      "text": "Performed by an adversary.",
      "ja": "敵によって行われました。"
    },
    {
      "indent": 0,
      "text": "2. VRF Algorithms",
      "section_title": true,
      "ja": "2. VRFアルゴリズム"
    },
    {
      "indent": 3,
      "text": "A VRF comes with a key generation algorithm that generates a VRF public key PK and secret key SK.",
      "ja": "VRFには、VRF公開鍵PKと秘密鍵SKを生成するキー生成アルゴリズムが付属しています。"
    },
    {
      "indent": 3,
      "text": "The Prover hashes an input alpha using the VRF secret key SK to obtain a VRF hash output beta:",
      "ja": "Proverは、VRF秘密鍵SKを使用して入力alphaをハッシュし、VRFハッシュ出力betaを取得します。"
    },
    {
      "indent": 3,
      "text": " beta = VRF_hash(SK, alpha)",
      "ja": "beta = VRF_hash(SK, alpha)"
    },
    {
      "indent": 3,
      "text": "The VRF_hash algorithm is deterministic, in the sense that it always produces the same output beta, given the same pair of inputs (SK, alpha).",
      "ja": "VRF_hashアルゴリズムは、同じ入力ペア（SK、α）が与えられた場合、常に同じ出力βを生成する決定論的です。"
    },
    {
      "indent": 3,
      "text": "The Prover also uses the secret key SK to construct a proof pi that beta is the correct hash output:",
      "ja": "Proverは、秘密鍵SKを使用して、betaが正しいハッシュ出力であることを証明する証明piを構築します。"
    },
    {
      "indent": 3,
      "text": " pi = VRF_prove(SK, alpha)",
      "ja": "pi = VRF_prove(SK, alpha)"
    },
    {
      "indent": 3,
      "text": "The VRFs defined in this document allow anyone to deterministically obtain the VRF hash output beta directly from the proof value pi by using the function VRF_proof_to_hash:",
      "ja": "このドキュメントで定義されたVRFは、関数VRF_proof_to_hashを使用して、誰でも証明値piからVRFハッシュ出力βを確実に取得できます。"
    },
    {
      "indent": 3,
      "text": " beta = VRF_proof_to_hash(pi)",
      "ja": "beta = VRF_proof_to_hash(pi)"
    },
    {
      "indent": 3,
      "text": "Thus, for the VRFs defined in this document, VRF_hash is defined as",
      "ja": "したがって、この文書で定義されたVRFについて、VRF_hashは次のように定義されます。"
    },
    {
      "indent": 3,
      "text": " VRF_hash(SK, alpha) = VRF_proof_to_hash(VRF_prove(SK, alpha)),",
      "ja": "VRF_hash(SK, alpha) = VRF_proof_to_hash(VRF_prove(SK, alpha)),"
    },
    {
      "indent": 3,
      "text": "and therefore this document will specify VRF_prove and VRF_proof_to_hash rather than VRF_hash.",
      "ja": "したがって、この文書では、VRF_hash ではなく VRF_prove および VRF_proof_to_hash を指定します。"
    },
    {
      "indent": 3,
      "text": "The proof pi allows a Verifier holding the public key PK to verify that beta is the correct VRF hash of input alpha under key PK. Thus, the VRFs defined in this document also come with an algorithm",
      "ja": "証明 pi は、公開鍵 PK を持つ検証者が、入力 alpha の正しい VRF ハッシュが鍵 PK の下で beta であることを検証できるようにします。したがって、この文書で定義された VRF には、アルゴリズムも付属しています。"
    },
    {
      "indent": 3,
      "text": " VRF_verify(PK, alpha, pi)",
      "ja": "VRF_verify(PK, alpha, pi)"
    },
    {
      "indent": 3,
      "text": "that outputs (\"VALID\", beta = VRF_proof_to_hash(pi)) if pi is valid, and \"INVALID\" otherwise.",
      "ja": "pi が有効であれば \"VALID\" 、そうでなければ \"INVALID\" を出力します。"
    },
    {
      "indent": 0,
      "text": "3. VRF Security Properties",
      "section_title": true,
      "ja": "3. VRFセキュリティプロパティ"
    },
    {
      "indent": 3,
      "text": "VRFs are designed to ensure the following security properties: uniqueness (full or trusted), collision resistance (full or trusted), and pseudorandomness (full or selective). Some are designed to also ensure unpredictability under malicious key generation. We now describe these properties.",
      "ja": "VRFは、次のセキュリティプロパティを確保するように設計されています：一意性（完全または信頼された）、衝突耐性（完全または信頼された）、および疑似ランダム性（完全または選択的）。一部は、悪意のある鍵生成の下での予測不可能性も確保するように設計されています。これらのプロパティについて説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Full Uniqueness",
      "section_title": true,
      "ja": "3.1. 完全な一意性"
    },
    {
      "indent": 3,
      "text": "Uniqueness means that, for any fixed VRF public key and for any input alpha, it is infeasible to find proofs for more than one VRF output beta.",
      "ja": "一意性とは、任意の固定されたVRF公開鍵および任意の入力αに対して、1つ以上のVRF出力βの証明を見つけることが困難であることを意味します。"
    },
    {
      "indent": 3,
      "text": "More precisely, \"full uniqueness\" means that an adversary cannot find",
      "ja": "より正確には、「完全な一意性」とは、敵対者が見つけることができないことを意味します。"
    },
    {
      "indent": 6,
      "text": "* a VRF public key PK,",
      "ja": "* VRFの公開鍵PK、"
    },
    {
      "indent": 6,
      "text": "* a VRF input alpha, and",
      "ja": "* a VRF 入力α、および"
    },
    {
      "indent": 6,
      "text": "* two proofs pi1 and pi2",
      "ja": "* 二つの証明 pi1 と pi2"
    },
    {
      "indent": 3,
      "text": "such that",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "* VRF_verify(PK, alpha, pi1) outputs (\"VALID\", beta1),",
      "ja": "* VRF_verify(PK, alpha, pi1) は、（\"VALID\", beta1）を出力します。"
    },
    {
      "indent": 6,
      "text": "* VRF_verify(PK, alpha, pi2) outputs (\"VALID\", beta2), and",
      "ja": "* VRF_verify(PK, alpha, pi2) は（\"VALID\", beta2）を出力します。"
    },
    {
      "indent": 6,
      "text": "* beta1 is not equal to beta2.",
      "ja": "* beta1はbeta2と等しくありません。"
    },
    {
      "indent": 0,
      "text": "3.2. Full Collision Resistance",
      "section_title": true,
      "ja": "3.2. 完全な衝突耐性"
    },
    {
      "indent": 3,
      "text": "Like cryptographic hash functions, VRFs are collision resistant. Collision resistance means that it is infeasible to find two different inputs alpha1 and alpha2 with the same output beta.",
      "ja": "VRFも暗号ハッシュ関数と同様に、衝突耐性があります。衝突耐性とは、異なる2つの入力alpha1とalpha2を同じ出力betaで見つけることが困難であることを意味します。"
    },
    {
      "indent": 3,
      "text": "More precisely, \"full collision resistance\" means that an adversary cannot find",
      "ja": "より正確に言うと、「完全な衝突耐性」とは、敵対者が見つけることができないことを意味します。"
    },
    {
      "indent": 6,
      "text": "* a VRF public key PK,",
      "ja": "* VRFの公開鍵PK、"
    },
    {
      "indent": 6,
      "text": "* two VRF inputs alpha1 and alpha2 that are not equal to each other, and",
      "ja": "* 互いに等しくない2つのVRF入力alpha1とalpha2、"
    },
    {
      "indent": 6,
      "text": "* two proofs pi1 and pi2",
      "ja": "* 二つの証明 pi1 と pi2"
    },
    {
      "indent": 3,
      "text": "such that",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "* VRF_verify(PK, alpha1, pi1) outputs (\"VALID\", beta1),",
      "ja": "* VRF_verify(PK, alpha1, pi1) は、(\"VALID\", beta1) を出力します。"
    },
    {
      "indent": 6,
      "text": "* VRF_verify(PK, alpha2, pi2) outputs (\"VALID\", beta2), and",
      "ja": "* VRF_verify(PK, alpha2, pi2）は（\"VALID\", beta2) を出力します。"
    },
    {
      "indent": 6,
      "text": "* beta1 is equal to beta2.",
      "ja": "* beta1はbeta2に等しい。"
    },
    {
      "indent": 0,
      "text": "3.3. Trusted Uniqueness and Trusted Collision Resistance",
      "section_title": true,
      "ja": "3.3. 信頼性のある一意性と信頼性のある衝突耐性"
    },
    {
      "indent": 3,
      "text": "Full uniqueness and full collision resistance hold even if the VRF keys are generated maliciously. For some applications, it is sufficient for a VRF to possess weaker security properties than full uniqueness and full collision resistance. These properties are called \"trusted uniqueness\" and \"trusted collision resistance\"; they are the same as full uniqueness and full collision resistance, respectively, but are not guaranteed to hold if the adversary gets to choose the VRF public key PK. Instead, they are guaranteed to hold only if the VRF keys PK and SK are generated as specified by the VRF key generation algorithm and then given to the adversary. In other words, they are guaranteed to hold even if the adversary has knowledge of SK and PK but are not guaranteed to hold if the adversary has the ability to choose SK and PK.",
      "ja": "完全な一意性と完全な衝突耐性は、VRFキーが悪意を持って生成された場合でも保持されます。一部のアプリケーションでは、VRFが完全な一意性と完全な衝突耐性よりも弱いセキュリティ特性を持っていれば十分です。これらの特性は「信頼された一意性」と「信頼された衝突耐性」と呼ばれ、それぞれ完全な一意性と完全な衝突耐性と同じですが、敵対者がVRF公開鍵PKを選択する権限がある場合には保証されません。代わりに、VRFキーPKとSKがVRFキー生成アルゴリズムに従って生成され、その後敵対者に与えられた場合にのみ保証されます。言い換えれば、敵対者がSKとPKの知識を持っていても保証されますが、敵対者がSKとPKを選択する能力を持っている場合には保証されません。"
    },
    {
      "indent": 3,
      "text": "As further discussed in Section 7.1.1, some of the VRFs specified in this document satisfy only trusted uniqueness and trusted collision resistance. VRFs in this document that satisfy only trusted uniqueness and trusted collision resistance MUST NOT be used in applications that need protection against adversarial VRF key generation.",
      "ja": "この文書で指定された一部のVRFは、信頼された一意性と信頼された衝突耐性のみを満たしています。信頼された一意性と信頼された衝突耐性のみを満たすこの文書のVRFは、敵対的なVRF鍵生成に対する保護が必要なアプリケーションで使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.4. Full Pseudorandomness or Selective Pseudorandomness",
      "section_title": true,
      "ja": "3.4. 完全擬似乱数性または選択的擬似乱数性"
    },
    {
      "indent": 3,
      "text": "Pseudorandomness ensures that when someone who does not know SK sees a VRF hash output beta without its corresponding VRF proof pi, beta is indistinguishable from a random value.",
      "ja": "疑似乱数性は、SKを知らない人が、対応するVRF証明πなしにVRFハッシュ出力βを見た場合、βがランダムな値と区別できないことを保証します。"
    },
    {
      "indent": 3,
      "text": "More precisely, suppose that the public and secret VRF keys (PK, SK) were generated correctly. Pseudorandomness ensures that the VRF hash output beta (without its corresponding VRF proof pi) on any adversarially chosen \"target\" VRF input alpha looks indistinguishable from random for any adversary who does not know the VRF secret key SK. This holds even if the adversary sees VRF hash outputs beta' and proofs pi' for multiple other inputs alpha' (and even if those other inputs alpha' are chosen by the adversary).",
      "ja": "より正確には、公開鍵と秘密鍵（PK、SK）が正しく生成されたと仮定します。擬似乱数性は、VRFハッシュ出力β（対応するVRF証明πを除く）が、敵対的に選択された「ターゲット」VRF入力αに対して、VRF秘密鍵SKを知らない敵対者にとってランダムと区別できないようにします。これは、敵対者が他の複数の入力α'に対してVRFハッシュ出力β'と証明π'を見た場合でも成立します（そしてそれらの他の入力α'が敵対者によって選択された場合であっても）。"
    },
    {
      "indent": 3,
      "text": "The \"full pseudorandomness\" security property holds even against an adversary who is allowed to choose the target VRF input alpha at any time, even after it observes VRF outputs beta' and proofs pi' on a variety of chosen inputs alpha'.",
      "ja": "「完全擬似ランダム性」セキュリティプロパティは、選択された入力α'に対するVRF出力β'および証明π'を観察した後でも、いつでもターゲットVRF入力αを選択できる敵対者に対しても成立します。"
    },
    {
      "indent": 3,
      "text": "\"Selective pseudorandomness\" is a weaker security property that suffices in many applications. This security property holds against an adversary who chooses the target VRF input alpha first, before it learns the VRF public key PK and obtains VRF outputs beta' and proofs pi' on other inputs alpha' of its choice.",
      "ja": "「選択的擬似ランダム性」は、多くのアプリケーションで十分なセキュリティ特性です。このセキュリティ特性は、標的となるVRF入力αを選択した後にVRF公開鍵PKを知り、自分の選択した他の入力α'に対するVRF出力β'と証明π'を取得する前に、敵対者が最初に選択する場合に成立します。"
    },
    {
      "indent": 3,
      "text": "As further discussed in Section 7.3, the VRFs specified in this document satisfy both full pseudorandomness and selective pseudorandomness, but their quantitative security against the selective pseudorandomness attack is stronger.",
      "ja": "この文は以下のように翻訳されます：この文書で指定されたVRFは、完全擬似乱数性と選択的擬似乱数性の両方を満たしていますが、選択的擬似乱数性攻撃に対するその定量的セキュリティはより強力です。"
    },
    {
      "indent": 3,
      "text": "It is important to remember that the VRF output beta is always distinguishable from random by the Prover or by any other party that knows the VRF secret key SK. Such a party can easily distinguish beta from a random value by comparing beta to the result of VRF_hash(SK, alpha). In particular, if the key is generated maliciously, even parties other than the Prover may know SK, and thus pseudorandomness cannot be guaranteed.",
      "ja": "VRFの出力βは、VRFの秘密鍵SKを知っているProverや他の当事者によって常にランダムと区別できることを覚えておくことが重要です。そのような当事者は、βをVRF_hash(SK, alpha)の結果と比較することで、簡単にβをランダムな値と区別することができます。特に、鍵が悪意を持って生成された場合、Prover以外の当事者でもSKを知っている可能性があり、そのため擬似ランダム性を保証することはできません。"
    },
    {
      "indent": 3,
      "text": "Similarly, the VRF output beta is always distinguishable from random by any party that knows a valid VRF proof pi corresponding to the VRF input alpha, even if this party does not know the VRF secret key SK. Such a party can easily distinguish beta from a random value by checking to see whether VRF_verify(PK, alpha, pi) returns (\"VALID\", beta).",
      "ja": "同様に、VRFの出力βは、VRF入力αに対応する有効なVRF証明πを知っている任意の当事者によって常にランダムと区別できます。このような当事者は、VRF_verify(PK, alpha, pi) が（\"VALID\"、beta）を返すかどうかを確認することで、簡単にβをランダムな値と区別できます。"
    },
    {
      "indent": 3,
      "text": "Additionally, the VRF output beta may be distinguishable from random if VRF key generation was not done correctly (for example, if VRF keys were generated with bad randomness).",
      "ja": "さらに、VRF出力βは、VRFキーの生成が正しく行われていない場合（たとえば、VRFキーが悪い乱数で生成された場合）にランダムと区別できるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.5. Unpredictability under Malicious Key Generation",
      "section_title": true,
      "ja": "3.5. 悪意のある鍵生成における予測不可能性"
    },
    {
      "indent": 3,
      "text": "As explained in Section 3.4, pseudorandomness cannot hold against malicious key generation. For instance, if an adversary outputs VRF keys that are deterministically generated (or hard-coded and publicly known), then the outputs are easily derived by anyone and are therefore not pseudorandom.",
      "ja": "セクション3.4で説明したように、悪意のある鍵生成に対して擬似ランダム性は保持されません。たとえば、敵対者が決定論的に生成された（またはハードコードされて一般に知られている）VRF鍵を出力した場合、出力は誰でも簡単に導出できるため、それらはしたがって擬似ランダムではありません。"
    },
    {
      "indent": 3,
      "text": "There is, however, a different type of unpredictability that is desirable in certain VRF applications (such as leader selection in the consensus protocols of [GHMVZ17] and [DGKR18]), called \"unpredictability under malicious key generation\". This property is similar to the unpredictability achieved by an (ordinary, unkeyed) cryptographic hash function: if the input has enough entropy (i.e., cannot be predicted), then the correct output is indistinguishable from uniformly random, no matter how the VRF keys are generated.",
      "ja": "ただし、[GHMVZ17]および[DGKR18]の合意プロトコルにおけるリーダー選択など、特定のVRFアプリケーションで望ましい別の種類の予測不可能性があります。これは「悪意のある鍵生成の下での予測不可能性」と呼ばれ、（通常の、鍵のない）暗号ハッシュ関数によって達成される予測不可能性に類似した性質です：入力に十分なエントロピー（つまり、予測できない）がある場合、VRFキーがどのように生成されているかに関係なく、正しい出力は一様ランダムと区別できません。"
    },
    {
      "indent": 3,
      "text": "A formal definition of this property appears in Section 3.2 of [DGKR18]. As further discussed in Section 7.1.3, only some of the VRFs specified in this document satisfy this property.",
      "ja": "この特性の形式的な定義は、[DGKR18]のセクション3.2に記載されています。さらに、セクション7.1.3で詳しく議論されていますが、この文書で指定されているVRFのうち、この特性を満たすものは一部です。"
    },
    {
      "indent": 0,
      "text": "4. RSA Full Domain Hash VRF (RSA-FDH-VRF)",
      "section_title": true,
      "ja": "4. RSA Full Domain Hash VRF（RSA-FDH-VRF）"
    },
    {
      "indent": 3,
      "text": "The RSA Full Domain Hash VRF (RSA-FDH-VRF) is a VRF that, for suitable key lengths, satisfies the \"trusted uniqueness\", \"trusted collision resistance\", and \"full pseudorandomness\" properties defined in Section 3, as further discussed in Section 7. Its security follows from the standard RSA assumption in the random oracle model. Formal security proofs are provided in [PWHVNRG17].",
      "ja": "RSA Full Domain Hash VRF（RSA-FDH-VRF）は、適切な鍵長に対して、「信頼された一意性」、「信頼された衝突耐性」、および「完全な擬似ランダム性」の性質を満たすVRFであり、セクション3で定義されたものであり、セクション7でさらに議論されています。そのセキュリティは、ランダムオラクルモデルにおける標準的なRSA仮定に従います。形式的なセキュリティ証明は[PWHVNRG17]で提供されています。"
    },
    {
      "indent": 3,
      "text": "The VRF computes the proof pi as a deterministic RSA signature on input alpha using the RSA Full Domain Hashing algorithm [RFC8017] parameterized with the selected hash algorithm. RSA signature verification is used to verify the correctness of the proof. The VRF hash output beta is simply obtained by hashing the proof pi with the selected hash algorithm.",
      "ja": "VRFは、選択されたハッシュアルゴリズムを用いたRSA Full Domain Hashingアルゴリズム[RFC8017]でパラメータ化された入力alphaに対する決定論的RSA署名として証明πを計算します。RSA署名検証は、証明の正確性を検証するために使用されます。VRFハッシュ出力βは、単純に選択されたハッシュアルゴリズムで証明πをハッシュ化することで得られます。"
    },
    {
      "indent": 3,
      "text": "The key pair for the RSA-FDH-VRF MUST satisfy the conditions specified in Section 3 of [RFC8017].",
      "ja": "RSA-FDH-VRFのキーペアは、[RFC8017]のセクション3で指定された条件を満たさなければなりません。"
    },
    {
      "indent": 3,
      "text": "In this section, the notation from [RFC8017] is used.",
      "ja": "このセクションでは、[RFC8017] からの表記法が使用されています。"
    },
    {
      "indent": 3,
      "text": "Parameters used:",
      "ja": "使用されたパラメータ:"
    },
    {
      "indent": 6,
      "text": "(n, e):",
      "ja": "(n, e):"
    },
    {
      "indent": 15,
      "text": "RSA public key",
      "ja": "RSA公開鍵"
    },
    {
      "indent": 6,
      "text": "K:",
      "ja": "K:"
    },
    {
      "indent": 15,
      "text": "RSA private key (its representation is implementation dependent)",
      "ja": "RSAの秘密鍵（その表現は実装に依存します）"
    },
    {
      "indent": 6,
      "text": "k:",
      "ja": "k:"
    },
    {
      "indent": 15,
      "text": "length, in octets, of the RSA modulus n (k must be less than 2^32)",
      "ja": "RSAモジュラスnの長さ（オクテット単位、kは2^32未満である必要があります）"
    },
    {
      "indent": 3,
      "text": "Fixed options (specified in Section 4.4):",
      "ja": "固定オプション（セクション4.4で指定）:"
    },
    {
      "indent": 6,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 15,
      "text": "cryptographic hash function",
      "ja": "暗号学的ハッシュ関数"
    },
    {
      "indent": 6,
      "text": "hLen:",
      "ja": "hLen:"
    },
    {
      "indent": 15,
      "text": "output length, in octets, of hash function Hash",
      "ja": "ハッシュ関数 Hash の出力長（オクテット単位）"
    },
    {
      "indent": 6,
      "text": "suite_string:",
      "ja": "suite_string:"
    },
    {
      "indent": 15,
      "text": "an octet string specifying the RSA-FDH-VRF ciphersuite, which determines the above options",
      "ja": "上記のオプションを決定するRSA-FDH-VRFサイファースイートを指定するオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Primitives used:",
      "ja": "使用されるプリミティブ:"
    },
    {
      "indent": 6,
      "text": "I2OSP:",
      "ja": "I2OSP:"
    },
    {
      "indent": 15,
      "text": "Conversion of a non-negative integer to an octet string as defined in Section 4.1 of [RFC8017] (given an integer and a length (in octets), produces a big-endian representation of the integer, zero-padded to the desired length)",
      "ja": "[RFC8017]のセクション4.1で定義されている非負整数をオクテット文字列に変換する（整数と長さ（オクテット単位）を指定すると、整数のビッグエンディアン表現を生成し、所望の長さにゼロパディングする）"
    },
    {
      "indent": 6,
      "text": "OS2IP:",
      "ja": "OS2IP:"
    },
    {
      "indent": 15,
      "text": "Conversion of an octet string to a non-negative integer as defined in Section 4.2 of [RFC8017] (given a big-endian encoding of an integer, produces the integer)",
      "ja": "[RFC8017]のセクション4.2で定義されているオクテット文字列を非負整数に変換する（整数のビッグエンディアン符号化を与えられた場合、整数を生成する）"
    },
    {
      "indent": 6,
      "text": "RSASP1:",
      "ja": "RSASP1:"
    },
    {
      "indent": 15,
      "text": "RSA signature primitive as defined in Section 5.2.1 of [RFC8017] (given a private key and an input, raises the input to the private RSA exponent modulo n)",
      "ja": "[RFC8017]のセクション5.2.1で定義されているRSA署名プリミティブ（秘密鍵と入力を与えられ、入力を秘密RSA指数でnで割った余りに上げる）"
    },
    {
      "indent": 6,
      "text": "RSAVP1:",
      "ja": "RSAVP1:"
    },
    {
      "indent": 15,
      "text": "RSA verification primitive as defined in Section 5.2.2 of [RFC8017] (given a public key and an input, raises the input to the public RSA exponent modulo n)",
      "ja": "[RFC8017]のセクション5.2.2で定義されているRSA検証プリミティブ（公開鍵と入力を与えられ、入力を公開RSA指数でnを法として上げる）"
    },
    {
      "indent": 6,
      "text": "MGF1:",
      "ja": "MGF1:"
    },
    {
      "indent": 15,
      "text": "Mask generation function based on the hash function Hash as defined in Appendix B.2.1 of [RFC8017] (given an input, produces a random-oracle-like output of desired length)",
      "ja": "[RFC8017]の付録B.2.1で定義されているハッシュ関数Hashに基づくマスク生成関数（入力を受け取り、所望の長さのランダムオラクルのような出力を生成する）"
    },
    {
      "indent": 6,
      "text": "||:",
      "ja": "||:"
    },
    {
      "indent": 15,
      "text": "octet string concatenation",
      "ja": "オクテット文字列の連結"
    },
    {
      "indent": 0,
      "text": "4.1. RSA-FDH-VRF Proving",
      "section_title": true,
      "ja": "4.1. RSA-FDH-VRF Proving"
    },
    {
      "indent": 3,
      "text": "RSAFDHVRF_prove(K, alpha_string[, MGF_salt])",
      "ja": "RSAFDHVRF_prove(K、alpha_string [、MGF_salt])"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "K:",
      "ja": "K:"
    },
    {
      "indent": 15,
      "text": "RSA private key",
      "ja": "RSAの秘密鍵"
    },
    {
      "indent": 6,
      "text": "alpha_string:",
      "ja": "alpha_string:"
    },
    {
      "indent": 15,
      "text": "VRF hash input, an octet string",
      "ja": "VRFハッシュ入力、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Optional input:",
      "ja": "オプションの入力:"
    },
    {
      "indent": 6,
      "text": "MGF_salt:",
      "ja": "MGF_salt:"
    },
    {
      "indent": 15,
      "text": "a public octet string used as a hash function salt; this input is not used when MGF_salt is specified as part of the ciphersuite",
      "ja": "ハッシュ関数のソルトとして使用されるパブリックなオクテット文字列；この入力は、MGF_saltが暗号スイートの一部として指定されている場合には使用されません。"
    },
    {
      "indent": 6,
      "text": "pi_string:",
      "ja": "pi_string:"
    },
    {
      "indent": 15,
      "text": "proof, an octet string of length k",
      "ja": "proof、長さkのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 8,
      "text": "1. mgf_domain_separator = 0x01",
      "ja": "1. mgf_domain_separator = 0x01"
    },
    {
      "indent": 8,
      "text": "2. EM = MGF1(suite_string || mgf_domain_separator || MGF_salt || alpha_string, k - 1)",
      "ja": "2. EM = MGF1(suite_string || mgf_domain_separator || MGF_salt || alpha_string, k - 1)"
    },
    {
      "indent": 8,
      "text": "3. m = OS2IP(EM)",
      "ja": "3. m = OS2IP(EM)"
    },
    {
      "indent": 8,
      "text": "4. s = RSASP1(K, m)",
      "ja": "4. s = RSASP1(K, m)"
    },
    {
      "indent": 8,
      "text": "5. pi_string = I2OSP(s, k)",
      "ja": "5. pi_string = I2OSP(s, k)"
    },
    {
      "indent": 8,
      "text": "6. Output pi_string",
      "ja": "6. pi_stringを出力"
    },
    {
      "indent": 0,
      "text": "4.2. RSA-FDH-VRF Proof to Hash",
      "section_title": true,
      "ja": "4.2. RSA-FDH-VRF証明をハッシュ化"
    },
    {
      "indent": 3,
      "text": "RSAFDHVRF_proof_to_hash(pi_string)",
      "ja": "RSAFDHVRF_proof_to_hash(pi_string)"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "pi_string:",
      "ja": "pi_string:"
    },
    {
      "indent": 15,
      "text": "proof, an octet string of length k",
      "ja": "証明、長さkのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 6,
      "text": "beta_string:",
      "ja": "beta_string:"
    },
    {
      "indent": 15,
      "text": "VRF hash output, an octet string of length hLen",
      "ja": "VRFハッシュ出力、長さhLenのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Important note:",
      "ja": "重要な注意事項:"
    },
    {
      "indent": 3,
      "text": " RSAFDHVRF_proof_to_hash should be run only on a pi_string value that is known to have been produced by RSAFDHVRF_prove, or from within RSAFDHVRF_verify as specified in Section 4.3.",
      "ja": "RSAFDHVRF_proof_to_hashは、RSAFDHVRF_proveによって生成されたことがわかっているpi_string値でのみ実行する必要があります。または、セクション4.3で指定されているように、RSAFDHVRF_verify内部から実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 8,
      "text": "1. proof_to_hash_domain_separator = 0x02",
      "ja": "1. proof_to_hash_domain_separator = 0x02"
    },
    {
      "indent": 8,
      "text": "2. beta_string = Hash(suite_string || proof_to_hash_domain_separator || pi_string)",
      "ja": "2. beta_string = Hash(suite_string || proof_to_hash_domain_separator || pi_string)"
    },
    {
      "indent": 8,
      "text": "3. Output beta_string",
      "ja": "3. 出力β文字列"
    },
    {
      "indent": 0,
      "text": "4.3. RSA-FDH-VRF Verifying",
      "section_title": true,
      "ja": "4.3. RSA-FDH-VRF 検証"
    },
    {
      "indent": 3,
      "text": "RSAFDHVRF_verify((n, e), alpha_string, pi_string[, MGF_salt])",
      "ja": "RSAFDHVRF_verify((n, e), alpha_string, pi_string[, MGF_salt])"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "(n, e):",
      "ja": "(n, e):"
    },
    {
      "indent": 15,
      "text": "RSA public key",
      "ja": "RSA公開鍵"
    },
    {
      "indent": 6,
      "text": "alpha_string:",
      "ja": "alpha_string:"
    },
    {
      "indent": 15,
      "text": "VRF hash input, an octet string",
      "ja": "VRFハッシュ入力、オクテット文字列"
    },
    {
      "indent": 6,
      "text": "pi_string:",
      "ja": "pi_string:"
    },
    {
      "indent": 15,
      "text": "proof to be verified, an octet string of length k",
      "ja": "検証するための証拠、長さkのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Optional input:",
      "ja": "オプションの入力:"
    },
    {
      "indent": 6,
      "text": "MGF_salt:",
      "ja": "MGF_salt:"
    },
    {
      "indent": 15,
      "text": "a public octet string used as a hash function salt; this input is not used when MGF_salt is specified as part of the ciphersuite",
      "ja": "ハッシュ関数のソルトとして使用されるパブリックなオクテット文字列；この入力は、MGF_saltが暗号スイートの一部として指定されている場合には使用されません。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 12,
      "text": "(\"VALID\", beta_string), where beta_string is the VRF hash output, an octet string of length hLen, or",
      "ja": "(\"VALID\"、beta_string)、ここでbeta_stringはVRFハッシュ出力であり、長さhLenのオクテット文字列です。"
    },
    {
      "indent": 12,
      "text": "\"INVALID\"",
      "ja": "\"INVALID\""
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 8,
      "text": "1. s = OS2IP(pi_string)",
      "ja": "1. s = OS2IP(pi_string)"
    },
    {
      "indent": 8,
      "text": "2. m = RSAVP1((n, e), s); if RSAVP1 returns \"signature representative out of range\", output \"INVALID\" and stop",
      "ja": "2. m = RSAVP1((n, e), s); もしRSAVP1が「署名代表が範囲外」と返したら、「INVALID」と出力して処理を停止します。"
    },
    {
      "indent": 8,
      "text": "3. mgf_domain_separator = 0x01",
      "ja": "3. mgf_domain_separator = 0x01"
    },
    {
      "indent": 8,
      "text": "4. EM' = MGF1(suite_string || mgf_domain_separator || MGF_salt || alpha_string, k - 1)",
      "ja": "4. EM' = MGF1(suite_string || mgf_domain_separator || MGF_salt || alpha_string, k - 1)"
    },
    {
      "indent": 8,
      "text": "5. m' = OS2IP(EM')",
      "ja": "5. m' = OS2IP(EM')"
    },
    {
      "indent": 8,
      "text": "6. If m and m' are equal, output (\"VALID\", RSAFDHVRF_proof_to_hash(pi_string)); else output \"INVALID\"",
      "ja": "6. もし m と m' が等しい場合、出力は (\"VALID\", RSAFDHVRF_proof_to_hash(pi_string)); そうでない場合は \"INVALID\" を出力します。"
    },
    {
      "indent": 0,
      "text": "4.4. RSA-FDH-VRF Ciphersuites",
      "section_title": true,
      "ja": "4.4. RSA-FDH-VRFサイファースイート"
    },
    {
      "indent": 3,
      "text": "This document defines RSA-FDH-VRF-SHA256 as follows:",
      "ja": "この文書は、RSA-FDH-VRF-SHA256を以下のように定義します。"
    },
    {
      "indent": 6,
      "text": "* suite_string = 0x01.",
      "ja": "* suite_string = 0x01."
    },
    {
      "indent": 6,
      "text": "* The hash function Hash is SHA-256 as specified in [RFC6234], with hLen = 32.",
      "ja": "* ハッシュ関数 Hash は、[RFC6234] で指定されている SHA-256 であり、hLen = 32 です。"
    },
    {
      "indent": 6,
      "text": "* MGF_salt = I2OSP(k, 4) || I2OSP(n, k).",
      "ja": "* MGF_salt = I2OSP(k, 4) || I2OSP(n, k).  \nMGF_salt = I2OSP(k, 4) || I2OSP(n, k)."
    },
    {
      "indent": 3,
      "text": "This document defines RSA-FDH-VRF-SHA384 as follows:",
      "ja": "この文書は、RSA-FDH-VRF-SHA384を以下のように定義します。"
    },
    {
      "indent": 6,
      "text": "* suite_string = 0x02.",
      "ja": "* suite_string = 0x02."
    },
    {
      "indent": 6,
      "text": "* The hash function Hash is SHA-384 as specified in [RFC6234], with hLen = 48.",
      "ja": "* ハッシュ関数 Hash は、[RFC6234] で指定されている SHA-384 であり、hLen = 48 です。"
    },
    {
      "indent": 6,
      "text": "* MGF_salt = I2OSP(k, 4) || I2OSP(n, k).",
      "ja": "* MGF_salt = I2OSP(k, 4) || I2OSP(n, k).  \nMGF_salt = I2OSP(k, 4) || I2OSP(n, k)."
    },
    {
      "indent": 3,
      "text": "This document defines RSA-FDH-VRF-SHA512 as follows:",
      "ja": "この文書は、RSA-FDH-VRF-SHA512を以下のように定義します。"
    },
    {
      "indent": 6,
      "text": "* suite_string = 0x03.",
      "ja": "* suite_string = 0x03."
    },
    {
      "indent": 6,
      "text": "* The hash function Hash is SHA-512 as specified in [RFC6234], with hLen = 64.",
      "ja": "* ハッシュ関数 Hash は、[RFC6234] で指定されている SHA-512 であり、hLen = 64 です。"
    },
    {
      "indent": 6,
      "text": "* MGF_salt = I2OSP(k, 4) || I2OSP(n, k).",
      "ja": "* MGF_salt = I2OSP(k, 4) || I2OSP(n, k)。\n"
    },
    {
      "indent": 0,
      "text": "5. Elliptic Curve VRF (ECVRF)",
      "section_title": true,
      "ja": "5. 楕円曲線VRF（ECVRF）"
    },
    {
      "indent": 3,
      "text": "The Elliptic Curve Verifiable Random Function (ECVRF) is a VRF that, for suitable parameter choices, satisfies the \"full uniqueness\", \"trusted collision resistance\", and \"full pseudorandomness\" properties defined in Section 3. If the validate_key parameter given to ECVRF_verify is TRUE, then the ECVRF additionally satisfies \"full collision resistance\" and \"unpredictability under malicious key generation\". See Section 7 for further discussion. Formal security proofs are provided in [PWHVNRG17].",
      "ja": "楕円曲線検証可能ランダム関数（ECVRF）は、適切なパラメータ選択に対して、セクション3で定義された「完全な一意性」、「信頼できる衝突耐性」、「完全な擬似ランダム性」の特性を満たすVRFです。ECVRF_verifyに与えられたvalidate_keyパラメータがTRUEの場合、ECVRFはさらに「完全な衝突耐性」と「悪意のある鍵生成に対する予測不可能性」を満たします。詳細についてはセクション7を参照してください。形式的なセキュリティ証明は[PWHVNRG17]で提供されています。"
    },
    {
      "indent": 3,
      "text": "Notation used:",
      "ja": "使用される表記:"
    },
    {
      "indent": 12,
      "text": "Elliptic curve operations are written in additive notation, with P+Q denoting point addition and x*P denoting scalar multiplication of a point P by a scalar x",
      "ja": "楕円曲線の操作は加法表記で書かれ、P+Q は点の加算を、x*P はスカラー x による点 P のスカラー倍を示します。"
    },
    {
      "indent": 6,
      "text": "x^y:",
      "ja": "x^y:"
    },
    {
      "indent": 15,
      "text": "x raised to the power y",
      "ja": "xのy乗"
    },
    {
      "indent": 6,
      "text": "x*y:",
      "ja": "x*y:"
    },
    {
      "indent": 15,
      "text": "x multiplied by y",
      "ja": "x かける y"
    },
    {
      "indent": 6,
      "text": "s || t:",
      "ja": "s || t:"
    },
    {
      "indent": 15,
      "text": "concatenation of octet strings s and t",
      "ja": "sとtのオクテット文字列の連結"
    },
    {
      "indent": 6,
      "text": "0xMN (where M and N are hexadecimal digits):",
      "ja": "0xMN（MとNは16進数の数字）:"
    },
    {
      "indent": 15,
      "text": "a single octet with value M*16+N; equivalently, int_to_string(M*16+N, 1), where int_to_string is as defined below",
      "ja": "値がM*16+Nである1バイトのデータ；同等に、int_to_string(M*16+N, 1)、ただし、int_to_stringは以下で定義されている。"
    },
    {
      "indent": 3,
      "text": "Fixed options (specified in Section 5.5):",
      "ja": "固定オプション（セクション5.5で指定）:"
    },
    {
      "indent": 6,
      "text": "F:",
      "ja": "F:"
    },
    {
      "indent": 15,
      "text": "finite field",
      "ja": "有限体"
    },
    {
      "indent": 6,
      "text": "fLen:",
      "ja": "fLen:"
    },
    {
      "indent": 15,
      "text": "length, in octets, of an element in F encoded as an octet string",
      "ja": "Fでエンコードされた要素の長さ（オクテット単位）"
    },
    {
      "indent": 6,
      "text": "E:",
      "ja": "E:"
    },
    {
      "indent": 15,
      "text": "elliptic curve (EC) defined over F",
      "ja": "有限体F上の楕円曲線（EC）"
    },
    {
      "indent": 6,
      "text": "ptLen:",
      "ja": "ptLen:"
    },
    {
      "indent": 15,
      "text": "length, in octets, of a point on E encoded as an octet string",
      "ja": "Eでエンコードされたポイントの長さ（オクテット単位）をオクテット文字列として表したもの"
    },
    {
      "indent": 6,
      "text": "G:",
      "ja": "G:"
    },
    {
      "indent": 15,
      "text": "subgroup of E of large prime order",
      "ja": "大きな素数次数のEの部分群"
    },
    {
      "indent": 6,
      "text": "q:",
      "ja": "q:"
    },
    {
      "indent": 15,
      "text": "prime order of group G",
      "ja": "グループGの素数次数"
    },
    {
      "indent": 6,
      "text": "qLen:",
      "ja": "qLen:"
    },
    {
      "indent": 15,
      "text": "length of q, in octets, i.e., the smallest integer such that 2^(8qLen) > q",
      "ja": "qの長さ（オクテット単位）、つまり、2^(8qLen) > q となる最小の整数qLen"
    },
    {
      "indent": 6,
      "text": "cLen:",
      "ja": "cLen:"
    },
    {
      "indent": 15,
      "text": "length, in octets, of a challenge value used by the VRF (note that in the typical case, cLen is qLen/2 or close to it)",
      "ja": "VRFが使用するチャレンジ値の長さ（オクテット単位）（通常の場合、cLenはqLen/2またはそれに近いことに注意してください）"
    },
    {
      "indent": 6,
      "text": "cofactor:",
      "ja": "共因子:"
    },
    {
      "indent": 15,
      "text": "number of points on E divided by q",
      "ja": "E上の点の数をqで割ったもの"
    },
    {
      "indent": 6,
      "text": "B:",
      "ja": "B:"
    },
    {
      "indent": 15,
      "text": "generator of group G",
      "ja": "G群の生成元"
    },
    {
      "indent": 6,
      "text": "Hash:",
      "ja": "ハッシュ:"
    },
    {
      "indent": 15,
      "text": "cryptographic hash function",
      "ja": "暗号学的ハッシュ関数"
    },
    {
      "indent": 6,
      "text": "hLen:",
      "ja": "hLen:"
    },
    {
      "indent": 15,
      "text": "output length, in octets, of Hash (hLen must be at least cLen; in the typical case, it is at least qLen)",
      "ja": "ハッシュの出力長（オクテット単位）（hLenは少なくともcLenである必要があります；通常の場合、少なくともqLenである）"
    },
    {
      "indent": 6,
      "text": "ECVRF_encode_to_curve:",
      "ja": "ECVRF_encode_to_curve:"
    },
    {
      "indent": 15,
      "text": "a function that hashes strings to points on E",
      "ja": "E上の点に文字列をハッシュする関数"
    },
    {
      "indent": 6,
      "text": "ECVRF_nonce_generation:",
      "ja": "ECVRF_nonce_generation:"
    },
    {
      "indent": 15,
      "text": "a function that derives a pseudorandom nonce from SK and the input as part of ECVRF proving",
      "ja": "ECVRF証明の一部として、SKと入力から疑似乱数のナンスを導出する関数"
    },
    {
      "indent": 6,
      "text": "suite_string:",
      "ja": "suite_string:"
    },
    {
      "indent": 15,
      "text": "an octet string specifying the ECVRF ciphersuite, which determines the above options as well as type conversions and parameter generation",
      "ja": "上記のオプションを決定するECVRFサイファースイートを指定するオクテット文字列、およびタイプ変換とパラメータ生成"
    },
    {
      "indent": 3,
      "text": "Type conversions (specified in Section 5.5):",
      "ja": "型変換（第5.5節で指定）:"
    },
    {
      "indent": 6,
      "text": "int_to_string(a, len):",
      "ja": "int_to_string(a, len):"
    },
    {
      "indent": 15,
      "text": "conversion of non-negative integer a to octet string of length len",
      "ja": "非負整数aを長さlenのオクテット文字列に変換します。"
    },
    {
      "indent": 6,
      "text": "string_to_int(a_string):",
      "ja": "string_to_int(a_string):"
    },
    {
      "indent": 15,
      "text": "conversion of an octet string a_string to a non-negative integer",
      "ja": "octet stringであるa_stringを非負の整数に変換"
    },
    {
      "indent": 6,
      "text": "point_to_string:",
      "ja": "point_to_string:"
    },
    {
      "indent": 15,
      "text": "conversion of a point on E to a ptLen-octet string",
      "ja": "E上の点をptLenオクテット文字列に変換"
    },
    {
      "indent": 6,
      "text": "string_to_point:",
      "ja": "string_to_point:"
    },
    {
      "indent": 15,
      "text": "conversion of a ptLen-octet string to a point on E. string_to_point returns \"INVALID\" if the octet string does not convert to a valid EC point on the curve E",
      "ja": "ptLenオクテット文字列をE上の点に変換します。string_to_pointは、オクテット文字列が曲線E上の有効なEC点に変換されない場合に「INVALID」を返します。"
    },
    {
      "indent": 12,
      "text": "Note that with certain software libraries (for big integer and elliptic curve arithmetic), the int_to_string and point_to_string conversions are not needed when the libraries encode integers and EC points in the same way as required by the ciphersuites. For example, in some implementations, EC point operations will take octet strings as inputs and produce octet strings as outputs, without introducing a separate elliptic curve point type.",
      "ja": "特定のソフトウェアライブラリ（大きな整数および楕円曲線演算用）では、ciphersuites で必要とされる方法と同じように整数とECポイントをエンコードする場合、int_to_string および point_to_string の変換は不要です。例えば、一部の実装では、ECポイント操作は入力としてオクテット文字列を取り、出力としてオクテット文字列を生成し、別個の楕円曲線ポイントタイプを導入しません。"
    },
    {
      "indent": 3,
      "text": "Parameters used (the generation of these parameters is specified in Section 5.5):",
      "ja": "使用されるパラメータ（これらのパラメータの生成はセクション5.5で指定されています）:"
    },
    {
      "indent": 6,
      "text": "SK:",
      "ja": "SK:"
    },
    {
      "indent": 15,
      "text": "VRF secret key",
      "ja": "VRF シークレットキー"
    },
    {
      "indent": 6,
      "text": "x:",
      "ja": "x:"
    },
    {
      "indent": 15,
      "text": "VRF secret scalar, an integer. Note: Depending on the ciphersuite used, the VRF secret scalar may be equal to SK; else it is derived from SK",
      "ja": "VRFの秘密スカラーは整数です。注意：使用される暗号スイートによっては、VRFの秘密スカラーがSKと等しい場合もあります。それ以外の場合は、SKから派生します。"
    },
    {
      "indent": 6,
      "text": "Y = x*B:",
      "ja": "Y = x*B:"
    },
    {
      "indent": 15,
      "text": "VRF public key, a point on E",
      "ja": "VRF公開鍵、E上の点"
    },
    {
      "indent": 6,
      "text": "PK_string = point_to_string(Y):",
      "ja": "PK_string = point_to_string(Y):"
    },
    {
      "indent": 15,
      "text": "VRF public key represented as an octet string",
      "ja": "VRF公開鍵はオクテット文字列として表されます。"
    },
    {
      "indent": 6,
      "text": "encode_to_curve_salt:",
      "ja": "encode_to_curve_salt:"
    },
    {
      "indent": 15,
      "text": "a public value used as a hash function salt",
      "ja": "ハッシュ関数のソルトとして使用される公開値"
    },
    {
      "indent": 0,
      "text": "5.1. ECVRF Proving",
      "section_title": true,
      "ja": "5.1. ECVRF Proving"
    },
    {
      "indent": 3,
      "text": "ECVRF_prove(SK, alpha_string[, encode_to_curve_salt])",
      "ja": "ECVRF_prove(SK、alpha_string [、encode_to_curve_salt])"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "SK:",
      "ja": "SK:"
    },
    {
      "indent": 15,
      "text": "VRF secret key",
      "ja": "VRF シークレットキー"
    },
    {
      "indent": 6,
      "text": "alpha_string:",
      "ja": "alpha_string:"
    },
    {
      "indent": 15,
      "text": "input alpha, an octet string",
      "ja": "入力は、オクテット文字列のαです。"
    },
    {
      "indent": 3,
      "text": "Optional input:",
      "ja": "オプションの入力:"
    },
    {
      "indent": 6,
      "text": "encode_to_curve_salt:",
      "ja": "encode_to_curve_salt:"
    },
    {
      "indent": 15,
      "text": "a public salt value, an octet string; this input is not used when encode_to_curve_salt is specified as part of the ciphersuite",
      "ja": "公開ソルト値、オクテット文字列；この入力は、シプスイートの一部として encode_to_curve_salt が指定されている場合には使用されません。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 6,
      "text": "pi_string:",
      "ja": "pi_string:"
    },
    {
      "indent": 15,
      "text": "VRF proof, an octet string of length ptLen+cLen+qLen",
      "ja": "VRF証明、長さptLen+cLen+qLenのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 8,
      "text": "1. Use SK to derive the VRF secret scalar x and the VRF public key Y = x*B",
      "ja": "1. SKを使用して、VRFの秘密スカラーxとVRFの公開鍵Y = x*Bを導出します。"
    },
    {
      "indent": 12,
      "text": "(this derivation depends on the ciphersuite, as per Section 5.5; these values can be cached, for example, after key generation, and need not be rederived each time)",
      "ja": "（この導出は、セクション5.5に従った暗号スイートに依存します。これらの値は、たとえば鍵生成後にキャッシュされることができ、毎回再導出する必要はありません）"
    },
    {
      "indent": 8,
      "text": "2. H = ECVRF_encode_to_curve(encode_to_curve_salt, alpha_string) (see Section 5.4.1)",
      "ja": "2. H = ECVRF_encode_to_curve(encode_to_curve_salt, alpha_string)（セクション5.4.1を参照）"
    },
    {
      "indent": 8,
      "text": "3. h_string = point_to_string(H)",
      "ja": "3. h_string = point_to_string(H)"
    },
    {
      "indent": 8,
      "text": "4. Gamma = x*H",
      "ja": "4. Gamma = x*H"
    },
    {
      "indent": 8,
      "text": "5. k = ECVRF_nonce_generation(SK, h_string) (see Section 5.4.2)",
      "ja": "5. k = ECVRF_nonce_generation(SK, h_string)（セクション5.4.2を参照）"
    },
    {
      "indent": 8,
      "text": "6. c = ECVRF_challenge_generation(Y, H, Gamma, k*B, k*H) (see Section 5.4.3)",
      "ja": "6. c = ECVRF_challenge_generation(Y, H, Gamma, k*B, k*H)（セクション5.4.3を参照）"
    },
    {
      "indent": 8,
      "text": "7. s = (k + c*x) mod q",
      "ja": "7. s = (k + c*x) mod q"
    },
    {
      "indent": 8,
      "text": "8. pi_string = point_to_string(Gamma) || int_to_string(c, cLen) || int_to_string(s, qLen)",
      "ja": "8. pi_string = point_to_string(Gamma) || int_to_string(c, cLen) || int_to_string(s, qLen)"
    },
    {
      "indent": 8,
      "text": "9. Output pi_string",
      "ja": "9. pi_stringを出力"
    },
    {
      "indent": 0,
      "text": "5.2. ECVRF Proof to Hash",
      "section_title": true,
      "ja": "5.2. ECVRF証明をハッシュ化"
    },
    {
      "indent": 3,
      "text": "ECVRF_proof_to_hash(pi_string)",
      "ja": "ECVRF_proof_to_hash(pi_string)"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "pi_string:",
      "ja": "pi_string:"
    },
    {
      "indent": 15,
      "text": "VRF proof, an octet string of length ptLen+cLen+qLen",
      "ja": "VRF証明、長さptLen+cLen+qLenのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 6,
      "text": "\"INVALID\", or",
      "ja": "\"INVALID\", or"
    },
    {
      "indent": 6,
      "text": "beta_string:",
      "ja": "beta_string:"
    },
    {
      "indent": 15,
      "text": "VRF hash output, an octet string of length hLen",
      "ja": "VRFハッシュ出力、長さhLenのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Important note:",
      "ja": "重要な注意点:"
    },
    {
      "indent": 3,
      "text": " ECVRF_proof_to_hash should be run only on a pi_string value that is known to have been produced by ECVRF_prove, or from within ECVRF_verify as specified in Section 5.3.",
      "ja": "ECVRF_proof_to_hashは、ECVRF_proveによって生成されたことがわかっているpi_string値でのみ実行する必要があります。または、セクション5.3で指定されているECVRF_verify内から実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 8,
      "text": "1. D = ECVRF_decode_proof(pi_string) (see Section 5.4.4)",
      "ja": "1. D = ECVRF_decode_proof(pi_string)（セクション5.4.4を参照）"
    },
    {
      "indent": 8,
      "text": "2. If D is \"INVALID\", output \"INVALID\" and stop",
      "ja": "2. もしDが「INVALID」であれば、「INVALID」と出力して処理を停止します。"
    },
    {
      "indent": 8,
      "text": "3. (Gamma, c, s) = D",
      "ja": "3. (Gamma, c, s) = D"
    },
    {
      "indent": 8,
      "text": "4. proof_to_hash_domain_separator_front = 0x03",
      "ja": "4. proof_to_hash_domain_separator_front = 0x03"
    },
    {
      "indent": 8,
      "text": "5. proof_to_hash_domain_separator_back = 0x00",
      "ja": "5. proof_to_hash_domain_separator_back = 0x00"
    },
    {
      "indent": 8,
      "text": "6. beta_string = Hash(suite_string || proof_to_hash_domain_separator_front || point_to_string(cofactor * Gamma) || proof_to_hash_domain_separator_back)",
      "ja": "6. beta_string = Hash(suite_string || proof_to_hash_domain_separator_front || point_to_string(cofactor * Gamma) || proof_to_hash_domain_separator_back)"
    },
    {
      "indent": 8,
      "text": "7. Output beta_string",
      "ja": "7. 出力β文字列"
    },
    {
      "indent": 0,
      "text": "5.3. ECVRF Verifying",
      "section_title": true,
      "ja": "5.3. ECVRF検証"
    },
    {
      "indent": 3,
      "text": "ECVRF_verify(PK_string, alpha_string, pi_string[, encode_to_curve_salt, validate_key])",
      "ja": "ECVRF_verify(PK_string, alpha_string, pi_string[, encode_to_curve_salt, validate_key])"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "PK_string:",
      "ja": "PK_string:"
    },
    {
      "indent": 15,
      "text": "public key, an octet string",
      "ja": "公開鍵、オクテット文字列"
    },
    {
      "indent": 6,
      "text": "alpha_string:",
      "ja": "alpha_string:"
    },
    {
      "indent": 15,
      "text": "VRF input, an octet string",
      "ja": "VRF入力、オクテット文字列"
    },
    {
      "indent": 6,
      "text": "pi_string:",
      "ja": "pi_string:"
    },
    {
      "indent": 15,
      "text": "VRF proof, an octet string of length ptLen+cLen+qLen",
      "ja": "VRFの証明は、長さptLen+cLen+qLenのオクテット文字列です。"
    },
    {
      "indent": 3,
      "text": "Optional input:",
      "ja": "オプションの入力:"
    },
    {
      "indent": 6,
      "text": "encode_to_curve_salt:",
      "ja": "encode_to_curve_salt:"
    },
    {
      "indent": 15,
      "text": "a public salt value, an octet string; this input is not used when encode_to_curve_salt is specified as part of the ciphersuite",
      "ja": "公開されたソルト値、オクテット文字列；この入力は、シプスイートの一部として encode_to_curve_salt が指定されている場合には使用されません。"
    },
    {
      "indent": 6,
      "text": "validate_key:",
      "ja": "validate_key:"
    },
    {
      "indent": 15,
      "text": "a boolean. An implementation MAY support only the option of validate_key = TRUE, or only the option of validate_key = FALSE, in which case this input is not needed. If an implementation supports only one option, it MUST specify which option it supports",
      "ja": "ブール値。実装は、validate_key = TRUE のオプションのみをサポートする場合がありますし、validate_key = FALSE のオプションのみをサポートする場合もあります。その場合、この入力は必要ありません。実装が1つのオプションのみをサポートする場合、どのオプションをサポートしているかを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 12,
      "text": "(\"VALID\", beta_string), where beta_string is the VRF hash output, an octet string of length hLen, or",
      "ja": "(\"VALID\"、beta_string)、ここでbeta_stringはVRFハッシュ出力であり、長さhLenのオクテット文字列です。"
    },
    {
      "indent": 12,
      "text": "\"INVALID\"",
      "ja": "\"INVALID\""
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 10,
      "text": "1. Y = string_to_point(PK_string)",
      "ja": "1. Y = string_to_point(PK_string)"
    },
    {
      "indent": 10,
      "text": "2. If Y is \"INVALID\", output \"INVALID\" and stop",
      "ja": "2. Y が \"INVALID\" の場合、\"INVALID\" を出力して停止します。"
    },
    {
      "indent": 10,
      "text": "3. If validate_key, run ECVRF_validate_key(Y) (Section 5.4.5); if it outputs \"INVALID\", output \"INVALID\" and stop",
      "ja": "3. validate_keyがある場合、ECVRF_validate_key(Y)（セクション5.4.5）を実行します。出力が「INVALID」の場合、「INVALID」と出力して停止します。"
    },
    {
      "indent": 10,
      "text": "4. D = ECVRF_decode_proof(pi_string) (see Section 5.4.4)",
      "ja": "4. D = ECVRF_decode_proof(pi_string)（セクション5.4.4を参照）"
    },
    {
      "indent": 10,
      "text": "5. If D is \"INVALID\", output \"INVALID\" and stop",
      "ja": "5. もしDが「INVALID」であれば、「INVALID」と出力して停止します。"
    },
    {
      "indent": 10,
      "text": "6. (Gamma, c, s) = D",
      "ja": "6. (Gamma, c, s) = D"
    },
    {
      "indent": 10,
      "text": "7. H = ECVRF_encode_to_curve(encode_to_curve_salt, alpha_string) (see Section 5.4.1)",
      "ja": "7. H = ECVRF_encode_to_curve(encode_to_curve_salt, alpha_string)（セクション5.4.1を参照）"
    },
    {
      "indent": 10,
      "text": "8. U = s*B - c*Y",
      "ja": "8. U = s*B - c*Y"
    },
    {
      "indent": 10,
      "text": "9. V = s*H - c*Gamma",
      "ja": "9. V = s*H - c*Gamma"
    },
    {
      "indent": 10,
      "text": "10. c' = ECVRF_challenge_generation(Y, H, Gamma, U, V) (see Section 5.4.3)",
      "ja": "10. c' = ECVRF_challenge_generation(Y, H, Gamma, U, V)（セクション5.4.3を参照）"
    },
    {
      "indent": 10,
      "text": "11. If c and c' are equal, output (\"VALID\", ECVRF_proof_to_hash(pi_string)); else output \"INVALID\"",
      "ja": "11. もし c と c' が等しい場合は、(\"VALID\", ECVRF_proof_to_hash(pi_string)) を出力してください。そうでない場合は \"INVALID\" を出力してください。"
    },
    {
      "indent": 3,
      "text": "Note that the first three steps need to be performed only once for a given public key.",
      "ja": "与えられた公開鍵に対して最初の3つのステップは1度だけ実行する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.4. ECVRF Auxiliary Functions",
      "section_title": true,
      "ja": "5.4. ECVRF補助関数"
    },
    {
      "indent": 0,
      "text": "5.4.1. ECVRF Encode to Curve",
      "section_title": true,
      "ja": "5.4.1. ECVRF Encode to Curve "
    },
    {
      "indent": 3,
      "text": "The ECVRF_encode_to_curve algorithm takes a public salt (see Section 7.9) and the VRF input alpha and converts it to H, an EC point in G. This algorithm is the only place the VRF input alpha is used for proving and verifying. See Section 7.7 for further discussion.",
      "ja": "ECVRF_encode_to_curveアルゴリズムは、公開ソルト（セクション7.9を参照）とVRF入力αを取り、G内のECポイントであるHに変換します。このアルゴリズムは、証明および検証のためにVRF入力αが使用される唯一の場所です。詳細については、セクション7.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "This section specifies a number of such algorithms; these algorithms are not compatible with each other and are intended for use with the various ciphersuites specified in Section 5.5.",
      "ja": "このセクションでは、いくつかのそのようなアルゴリズムが指定されています。これらのアルゴリズムは互換性がなく、セクション5.5で指定されたさまざまなサイファースイートと共に使用することを意図しています。"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "encode_to_curve_salt:",
      "ja": "encode_to_curve_salt:"
    },
    {
      "indent": 15,
      "text": "public salt value, an octet string",
      "ja": "公開ソルト値、オクテット文字列"
    },
    {
      "indent": 6,
      "text": "alpha_string:",
      "ja": "alpha_string:"
    },
    {
      "indent": 15,
      "text": "value to be hashed, an octet string",
      "ja": "ハッシュ化される値、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 6,
      "text": "H:",
      "ja": "H:"
    },
    {
      "indent": 15,
      "text": "hashed value, a point in G",
      "ja": "ハッシュ値、G内の点"
    },
    {
      "indent": 0,
      "text": "5.4.1.1. ECVRF_encode_to_curve_try_and_increment",
      "section_title": true,
      "ja": "5.4.1.1. ECVRF_encode_to_curve_try_and_increment"
    },
    {
      "indent": 3,
      "text": "The ECVRF_encode_to_curve_try_and_increment(encode_to_curve_salt, alpha_string) algorithm implements ECVRF_encode_to_curve in a simple and generic way that works for any elliptic curve. To use this algorithm, hLen MUST be at least fLen.",
      "ja": "ECVRF_encode_to_curve_try_and_increment(encode_to_curve_salt, alpha_string)アルゴリズムは、任意の楕円曲線に対して機能するシンプルで汎用的な方法でECVRF_encode_to_curveを実装します。このアルゴリズムを使用するには、hLenは少なくともfLenである必要があります。"
    },
    {
      "indent": 3,
      "text": "The running time of this algorithm depends on alpha_string. For the ciphersuites specified in Section 5.5, this algorithm is expected to find a valid curve point after approximately two attempts (i.e., when ctr = 1) on average.",
      "ja": "このアルゴリズムの実行時間は、alpha_stringに依存します。セクション5.5で指定されたサイファースイートについて、このアルゴリズムは、平均して約2回の試行（つまり、ctr = 1のとき）後に有効な曲線上の点を見つけることが期待されています。"
    },
    {
      "indent": 3,
      "text": "However, because the algorithm's running time depends on alpha_string, this algorithm SHOULD be avoided in applications where it is important that the VRF input alpha remain secret.",
      "ja": "ただし、アルゴリズムの実行時間はalpha_stringに依存するため、このアルゴリズムはVRFの入力alphaが秘密のままであることが重要なアプリケーションでは避けるべきです。"
    },
    {
      "indent": 3,
      "text": "ECVRF_encode_to_curve_try_and_increment(encode_to_curve_salt, alpha_string)",
      "ja": "ECVRF_encode_to_curve_try_and_increment(encode_to_curve_salt, alpha_string)"
    },
    {
      "indent": 3,
      "text": "Fixed option (specified in Section 5.5):",
      "ja": "固定オプション（セクション5.5で指定）:"
    },
    {
      "indent": 6,
      "text": "interpret_hash_value_as_a_point:",
      "ja": "interpret_hash_value_as_a_point:"
    },
    {
      "indent": 15,
      "text": "a function that attempts to convert a cryptographic hash value to a point on E; may output \"INVALID\"",
      "ja": "暗号ハッシュ値をE上の点に変換しようとする関数；\"INVALID\"を出力する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ:"
    },
    {
      "indent": 8,
      "text": "1. ctr = 0",
      "ja": "1. ctr = 0"
    },
    {
      "indent": 8,
      "text": "2. encode_to_curve_domain_separator_front = 0x01",
      "ja": "2. encode_to_curve_domain_separator_front = 0x01"
    },
    {
      "indent": 8,
      "text": "3. encode_to_curve_domain_separator_back = 0x00",
      "ja": "3. encode_to_curve_domain_separator_back = 0x00"
    },
    {
      "indent": 8,
      "text": "4. H = \"INVALID\"",
      "ja": "4. H = \"無効\""
    },
    {
      "indent": 8,
      "text": "5. While H is \"INVALID\" or H is the identity element of the elliptic curve group:",
      "ja": "5. H が \"INVALID\" であるか、H が楕円曲線群の単位元である場合:"
    },
    {
      "indent": 16,
      "text": "a. ctr_string = int_to_string(ctr, 1)",
      "ja": "a. ctr_string = int_to_string(ctr, 1)"
    },
    {
      "indent": 16,
      "text": "b. hash_string = Hash(suite_string || encode_to_curve_domain_separator_front || encode_to_curve_salt || alpha_string || ctr_string || encode_to_curve_domain_separator_back)",
      "ja": "b. hash_string = Hash(suite_string || encode_to_curve_domain_separator_front || encode_to_curve_salt || alpha_string || ctr_string || encode_to_curve_domain_separator_back)"
    },
    {
      "indent": 16,
      "text": "c. H = interpret_hash_value_as_a_point(hash_string)",
      "ja": "c. H = ハッシュ文字列をポイントとして解釈する"
    },
    {
      "indent": 16,
      "text": "d. If H is not \"INVALID\" and cofactor > 1, set H = cofactor * H",
      "ja": "d. もしHが\"INVALID\"でなく、かつcofactorが1より大きい場合、H = cofactor * Hと設定します。"
    },
    {
      "indent": 16,
      "text": "e. ctr = ctr + 1",
      "ja": "e. ctr = ctr + 1"
    },
    {
      "indent": 8,
      "text": "6. Output H",
      "ja": "6. Output H"
    },
    {
      "indent": 3,
      "text": "Note that even though the loop is infinite as written and int_to_string(ctr, 1) may fail when ctr reaches 256, each of the options for the interpret_hash_value_as_a_point function specified in Section 5.5 will succeed on roughly half hash_string values. Thus, the loop is expected to stop after two iterations, and ctr is overwhelmingly unlikely (probability about 2^-256) to reach 256.",
      "ja": "注意してください。ループは無限であり、ctrが256に達したときにint_to_string(ctr, 1)が失敗する可能性がありますが、セクション5.5で指定されたinterpret_hash_value_as_a_point関数のオプションのいずれも、hash_stringの値のおおよそ半分で成功します。したがって、ループは2回の反復後に停止することが期待され、ctrが256に達する可能性は非常に低いです（確率はおよそ2^-256）。"
    },
    {
      "indent": 0,
      "text": "5.4.1.2. ECVRF_encode_to_curve_h2c_suite",
      "section_title": true,
      "ja": "5.4.1.2. ECVRF_encode_to_curve_h2c_suite"
    },
    {
      "indent": 3,
      "text": "The ECVRF_encode_to_curve_h2c_suite(encode_to_curve_salt, alpha_string) algorithm implements ECVRF_encode_to_curve using one of the several hash-to-curve options defined in [RFC9380]. The specific choice of the hash-to-curve option (called the Suite ID in [RFC9380]) is given by the h2c_suite_ID_string parameter.",
      "ja": "ECVRF_encode_to_curve_h2c_suite(encode_to_curve_salt, alpha_string)アルゴリズムは、[RFC9380]で定義されている複数のハッシュ・トゥ・カーブ・オプションの1つを使用してECVRF_encode_to_curveを実装します。ハッシュ・トゥ・カーブ・オプションの具体的な選択肢（[RFC9380]でSuite IDと呼ばれる）は、h2c_suite_ID_stringパラメータによって与えられます。"
    },
    {
      "indent": 3,
      "text": "ECVRF_encode_to_curve_h2c_suite(encode_to_curve_salt, alpha_string)",
      "ja": "ECVRF_encode_to_curve_h2c_suite（encode_to_curve_salt、alpha_string）"
    },
    {
      "indent": 3,
      "text": "Fixed option (specified in Section 5.5):",
      "ja": "固定オプション（セクション5.5で指定）:"
    },
    {
      "indent": 6,
      "text": "h2c_suite_ID_string:",
      "ja": "h2c_suite_ID_string:"
    },
    {
      "indent": 15,
      "text": "a hash-to-curve Suite ID, encoded in ASCII (see discussion below)",
      "ja": "ASCIIでエンコードされたハッシュ・トゥ・カーブ・スイートID（以下の議論を参照）"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 8,
      "text": "1. string_to_be_hashed = encode_to_curve_salt || alpha_string",
      "ja": "1. string_to_be_hashed = encode_to_curve_salt || alpha_string"
    },
    {
      "indent": 8,
      "text": "2. H = encode(string_to_be_hashed)",
      "ja": "2. H = encode(string_to_be_hashed)"
    },
    {
      "indent": 12,
      "text": "(the encode function is discussed below)",
      "ja": "（エンコード機能については後述します）"
    },
    {
      "indent": 8,
      "text": "3. Output H",
      "ja": "3. Output H"
    },
    {
      "indent": 3,
      "text": "The encode function is provided by the hash-to-curve suite (as specified in Section 8 of [RFC9380]) whose ID is h2c_suite_ID_string. The domain separation tag DST, a parameter in the hash-to-curve suite, SHALL be set to",
      "ja": "encode関数は、ハッシュ・トゥ・カーブ・スイートによって提供されます（[RFC9380]のセクション8で指定されています）。そのIDはh2c_suite_ID_stringです。ハッシュ・トゥ・カーブ・スイートのパラメータであるドメイン分離タグDSTは、次のように設定されます。"
    },
    {
      "indent": 3,
      "text": " \"ECVRF_\" || h2c_suite_ID_string || suite_string",
      "ja": "\"ECVRF_\" || h2c_suite_ID_string || suite_string"
    },
    {
      "indent": 3,
      "text": "where \"ECVRF_\" is represented as a 6-byte ASCII encoding (in hexadecimal, octets 45 43 56 52 46 5F).",
      "ja": "\"ECVRF_\" は、6 バイトの ASCII エンコーディング（16 進数で、オクテット 45 43 56 52 46 5F）で表されます。"
    },
    {
      "indent": 0,
      "text": "5.4.2. ECVRF Nonce Generation",
      "section_title": true,
      "ja": "5.4.2. ECVRFノンス生成"
    },
    {
      "indent": 3,
      "text": "The following algorithms generate the nonce value k in a deterministic pseudorandom fashion. This section specifies a number of such algorithms; these algorithms are not compatible with each other. The choice of a particular algorithm from the options specified in this section depends on the ciphersuite, as specified in Section 5.5.",
      "ja": "以下のアルゴリズムは、決定論的疑似乱数方式でnonce値kを生成します。このセクションでは、いくつかのそのようなアルゴリズムが指定されています。これらのアルゴリズムは互換性がありません。このセクションで指定されたオプションから特定のアルゴリズムを選択することは、セクション5.5で指定されている暗号スイートに依存します。"
    },
    {
      "indent": 0,
      "text": "5.4.2.1. ECVRF Nonce Generation from RFC 6979",
      "section_title": true,
      "ja": "5.4.2.1. ECVRF RFC 6979からのNonce生成"
    },
    {
      "indent": 3,
      "text": "ECVRF_nonce_generation_RFC6979(SK, h_string)",
      "ja": "ECVRF_nonce_generation_RFC6979(SK, h_string)"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "SK:",
      "ja": "SK:"
    },
    {
      "indent": 15,
      "text": "an ECVRF secret key",
      "ja": "ECVRFの秘密鍵"
    },
    {
      "indent": 6,
      "text": "h_string:",
      "ja": "h_string:"
    },
    {
      "indent": 15,
      "text": "an octet string",
      "ja": "オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 6,
      "text": "k:",
      "ja": "k:"
    },
    {
      "indent": 15,
      "text": "an integer nonce between 1 and q-1",
      "ja": "1からq-1の間の整数ナンス"
    },
    {
      "indent": 3,
      "text": "The ECVRF_nonce_generation function is implemented according to the process specified in Section 3.2 of [RFC6979], where",
      "ja": "ECVRF_nonce_generation関数は、[RFC6979]のセクション3.2で指定されたプロセスに従って実装されています。"
    },
    {
      "indent": 6,
      "text": "* Input m is set equal to h_string.",
      "ja": "* 入力mはh_stringに等しいと設定されます。"
    },
    {
      "indent": 6,
      "text": "* The \"suitable for DSA or ECDSA\" check in Step h.3 is omitted.",
      "ja": "* Step h.3 での \"DSA または ECDSA に適している\" チェックが省略されています。"
    },
    {
      "indent": 6,
      "text": "* The hash function H is Hash, and its output length hlen (in bits) is set as hLen*8 (note that hlen is not to be confused with hLen, which is used in this document to represent the length of the output of Hash in octets).",
      "ja": "* ハッシュ関数HはHashであり、その出力長hlen（ビット単位）はhLen*8と設定されます（hlenは、この文書でHashの出力の長さをオクテット単位で表すために使用されるhLenと混同しないでください）。"
    },
    {
      "indent": 6,
      "text": "* The secret key x is set equal to the VRF secret scalar x.",
      "ja": "* 秘密鍵 x は、VRF 秘密スカラー x に等しい値と設定されます。"
    },
    {
      "indent": 6,
      "text": "* The prime q is the same as in this specification.",
      "ja": "* このプライム q は、この仕様書と同じです。"
    },
    {
      "indent": 6,
      "text": "* qlen is the binary length of q, i.e., the smallest integer such that 2^qlen > q (this qlen is not to be confused with qLen, which is used in this document to represent the length of q in octets).",
      "ja": "* qlenは、qのバイナリ長であり、つまり、2^qlen > q となる最小の整数です（このqlenは、この文書でqの長さをオクテットで表すために使用されるqLenとは混同しないでください）。"
    },
    {
      "indent": 6,
      "text": "* All the other values and primitives are as defined in [RFC6979].",
      "ja": "* 他のすべての値とプリミティブは[RFC6979]で定義されているものと同じです。"
    },
    {
      "indent": 0,
      "text": "5.4.2.2. ECVRF Nonce Generation from RFC 8032",
      "section_title": true,
      "ja": "5.4.2.2. ECVRF Nonce Generation from RFC 8032"
    },
    {
      "indent": 3,
      "text": "The following is derived from Steps 2 and 3 in Section 5.1.6 of [RFC8032]. To use this algorithm, hLen MUST be at least 64.",
      "ja": "次のものは、[RFC8032]のセクション5.1.6のステップ2およびステップ3から派生しています。このアルゴリズムを使用するには、hLenは少なくとも64である必要があります。"
    },
    {
      "indent": 3,
      "text": "ECVRF_nonce_generation_RFC8032(SK, h_string)",
      "ja": "ECVRF_nonce_generation_RFC8032(SK, h_string)"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "SK:",
      "ja": "SK:"
    },
    {
      "indent": 15,
      "text": "an ECVRF secret key",
      "ja": "ECVRFの秘密鍵"
    },
    {
      "indent": 6,
      "text": "h_string:",
      "ja": "h_string:"
    },
    {
      "indent": 15,
      "text": "an octet string",
      "ja": "オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 6,
      "text": "k:",
      "ja": "k:"
    },
    {
      "indent": 15,
      "text": "an integer nonce between 0 and q-1",
      "ja": "0からq-1の間の整数ナンス"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "Steps:"
    },
    {
      "indent": 8,
      "text": "1. hashed_sk_string = Hash(SK)",
      "ja": "1. hashed_sk_string = Hash(SK)"
    },
    {
      "indent": 8,
      "text": "2. truncated_hashed_sk_string = hashed_sk_string[32]...hashed_sk_string[63]",
      "ja": "2. truncated_hashed_sk_string = hashed_sk_string[32]...hashed_sk_string[63]"
    },
    {
      "indent": 8,
      "text": "3. k_string = Hash(truncated_hashed_sk_string || h_string)",
      "ja": "3. k_string = Hash(truncated_hashed_sk_string || h_string)"
    },
    {
      "indent": 8,
      "text": "4. k = string_to_int(k_string) mod q",
      "ja": "4. k = string_to_int(k_string) mod q"
    },
    {
      "indent": 0,
      "text": "5.4.3. ECVRF Challenge Generation",
      "section_title": true,
      "ja": "5.4.3. ECVRFチャレンジ生成"
    },
    {
      "indent": 3,
      "text": "ECVRF_challenge_generation(P1, P2, P3, P4, P5)",
      "ja": "ECVRF_challenge_generation(P1, P2, P3, P4, P5)"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "P1, P2, P3, P4, P5:",
      "ja": "P1、P2、P3、P4、P5:"
    },
    {
      "indent": 15,
      "text": "EC points",
      "ja": "ECポイント"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 6,
      "text": "c:",
      "ja": "c:"
    },
    {
      "indent": 15,
      "text": "challenge value, an integer between 0 and 2^(8*cLen)-1",
      "ja": "challenge value、0から2^(8*cLen)-1の間の整数"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 8,
      "text": "1. challenge_generation_domain_separator_front = 0x02",
      "ja": "1. challenge_generation_domain_separator_front = 0x02"
    },
    {
      "indent": 8,
      "text": "2. Initialize str = suite_string || challenge_generation_domain_separator_front",
      "ja": "2. str = suite_string || challenge_generation_domain_separator_front を初期化します"
    },
    {
      "indent": 8,
      "text": "3. For PJ in [P1, P2, P3, P4, P5]:",
      "ja": "3. [P1、P2、P3、P4、P5] の PJ について:"
    },
    {
      "indent": 12,
      "text": "str = str || point_to_string(PJ)",
      "ja": "str = str || point_to_string(PJ)"
    },
    {
      "indent": 8,
      "text": "4. challenge_generation_domain_separator_back = 0x00",
      "ja": "4. challenge_generation_domain_separator_back = 0x00"
    },
    {
      "indent": 8,
      "text": "5. str = str || challenge_generation_domain_separator_back",
      "ja": "5. str = str || challenge_generation_domain_separator_back"
    },
    {
      "indent": 8,
      "text": "6. c_string = Hash(str)",
      "ja": "6. c_string = Hash(str)"
    },
    {
      "indent": 8,
      "text": "7. truncated_c_string = c_string[0]...c_string[cLen-1]",
      "ja": "7. truncated_c_string = c_string[0]...c_string[cLen-1]"
    },
    {
      "indent": 8,
      "text": "8. c = string_to_int(truncated_c_string)",
      "ja": "8. c = string_to_int(truncated_c_string)"
    },
    {
      "indent": 8,
      "text": "9. Output c",
      "ja": "9. Output c"
    },
    {
      "indent": 0,
      "text": "5.4.4. ECVRF Decode Proof",
      "section_title": true,
      "ja": "5.4.4. ECVRF デコード証明"
    },
    {
      "indent": 3,
      "text": "ECVRF_decode_proof(pi_string)",
      "ja": "ECVRF_decode_proof(pi_string)"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "pi_string:",
      "ja": "pi_string:"
    },
    {
      "indent": 15,
      "text": "VRF proof, an octet string (ptLen+cLen+qLen octets)",
      "ja": "VRF証明、オクテット文字列（ptLen+cLen+qLenオクテット）"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 6,
      "text": "\"INVALID\", or",
      "ja": "\"INVALID\", or"
    },
    {
      "indent": 6,
      "text": "Gamma:",
      "ja": "Gamma:"
    },
    {
      "indent": 15,
      "text": "a point on E",
      "ja": "E上の1点"
    },
    {
      "indent": 6,
      "text": "c:",
      "ja": "c:"
    },
    {
      "indent": 15,
      "text": "an integer between 0 and 2^(8*cLen)-1",
      "ja": "0から2^(8*cLen)-1の間の整数"
    },
    {
      "indent": 6,
      "text": "s:",
      "ja": "s:"
    },
    {
      "indent": 15,
      "text": "an integer between 0 and q-1",
      "ja": "0からq-1までの整数"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ:"
    },
    {
      "indent": 8,
      "text": "1. gamma_string = pi_string[0]...pi_string[ptLen-1]",
      "ja": "1. gamma_string = pi_string[0]...pi_string[ptLen-1]"
    },
    {
      "indent": 8,
      "text": "2. c_string = pi_string[ptLen]...pi_string[ptLen+cLen-1]",
      "ja": "2. c_string = pi_string[ptLen]...pi_string[ptLen+cLen-1]"
    },
    {
      "indent": 8,
      "text": "3. s_string = pi_string[ptLen+cLen]...pi_string[ptLen+cLen+qLen-1]",
      "ja": "3. s_string = pi_string[ptLen+cLen]...pi_string[ptLen+cLen+qLen-1]"
    },
    {
      "indent": 8,
      "text": "4. Gamma = string_to_point(gamma_string)",
      "ja": "4. Gamma = string_to_point(gamma_string)"
    },
    {
      "indent": 8,
      "text": "5. If Gamma = \"INVALID\", output \"INVALID\" and stop",
      "ja": "5. もしガンマが「INVALID」なら、「INVALID」と出力して停止します。"
    },
    {
      "indent": 8,
      "text": "6. c = string_to_int(c_string)",
      "ja": "6. c = string_to_int(c_string)"
    },
    {
      "indent": 8,
      "text": "7. s = string_to_int(s_string)",
      "ja": "7. s = string_to_int(s_string)"
    },
    {
      "indent": 8,
      "text": "8. If s >= q, output \"INVALID\" and stop",
      "ja": "8. もし s >= q なら、\"INVALID\" を出力して停止します。"
    },
    {
      "indent": 8,
      "text": "9. Output Gamma, c, and s",
      "ja": "9. ガンマ、c、およびsを出力する"
    },
    {
      "indent": 0,
      "text": "5.4.5. ECVRF Validate Key",
      "section_title": true,
      "ja": "5.4.5. ECVRFキーを検証"
    },
    {
      "indent": 3,
      "text": "ECVRF_validate_key(Y)",
      "ja": "ECVRF_validate_key(Y)"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "Input:"
    },
    {
      "indent": 6,
      "text": "Y:",
      "ja": "Y:"
    },
    {
      "indent": 15,
      "text": "public key, a point on E",
      "ja": "公開鍵、E上の点"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "Output:"
    },
    {
      "indent": 12,
      "text": "\"VALID\" or \"INVALID\"",
      "ja": "\"VALID\" または \"INVALID\""
    },
    {
      "indent": 3,
      "text": "Important note:",
      "ja": "重要な注意事項:"
    },
    {
      "indent": 3,
      "text": " The public key Y provided as input to this procedure MUST be a valid point on E.",
      "ja": "この手続きに入力される公開鍵Yは、E上の有効な点でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "Steps:"
    },
    {
      "indent": 8,
      "text": "1. Let Y' = cofactor*Y",
      "ja": "1. Y' = cofactor*Y"
    },
    {
      "indent": 8,
      "text": "2. If Y' is the identity element of the elliptic curve group, output \"INVALID\" and stop",
      "ja": "2. もしY'が楕円曲線群の単位元である場合、\"INVALID\"と出力して処理を停止します。"
    },
    {
      "indent": 8,
      "text": "3. Output \"VALID\"",
      "ja": "3. \"VALID\""
    },
    {
      "indent": 3,
      "text": "Note that if the cofactor = 1, then Step 1 simply sets Y'=Y. In particular, for the P-256 curve, ECVRF_validate_key simply ensures that Y is not the point at infinity.",
      "ja": "注意：もし cofactor = 1 なら、ステップ 1 は単に Y' = Y を設定します。特に、P-256 曲線の場合、ECVRF_validate_key は単に Y が無限の点でないことを確認します。"
    },
    {
      "indent": 3,
      "text": "Any algorithm with identical input-output behavior MAY be used in place of the above steps. For example, if the total number of Y values that could cause Step 2 to output \"INVALID\" is small, it may be more efficient to simply check Y against a fixed list of such values. For example, the following algorithm MAY be used for the edwards25519 curve:",
      "ja": "上記の手順の代わりに、入出力の振る舞いが同一である任意のアルゴリズムを使用しても構いません。たとえば、ステップ2が「INVALID」と出力する可能性のあるY値の総数が少ない場合、Yを固定されたそのような値のリストと単純に照合する方が効率的かもしれません。たとえば、edwards25519曲線に対して以下のアルゴリズムを使用しても構いません。"
    },
    {
      "indent": 10,
      "text": "1. PK_string = point_to_string(Y)",
      "ja": "1. PK_string = point_to_string(Y)"
    },
    {
      "indent": 10,
      "text": "2. oneTwentySeven_string = 0x7F",
      "ja": "2. oneTwentySeven_string = 0x7F"
    },
    {
      "indent": 10,
      "text": "3. y_string[31] = y_string[31] & oneTwentySeven_string",
      "ja": "3. y_string[31] = y_string[31] & oneTwentySeven_string"
    },
    {
      "indent": 14,
      "text": "(this step clears the high-order bit of octet 31)",
      "ja": "（この手順は、オクテット31の上位ビットをクリアします）"
    },
    {
      "indent": 10,
      "text": "4. bad_pk[0] = int_to_string(0, 32)",
      "ja": "4. bad_pk[0] = int_to_string(0, 32)"
    },
    {
      "indent": 10,
      "text": "5. bad_pk[1] = int_to_string(1, 32)",
      "ja": "5. bad_pk[1] = int_to_string(1, 32)"
    },
    {
      "indent": 10,
      "text": "6. bad_y2 = 2707385501144840649318225287225658788936804267575313519 463743609750303402022",
      "ja": "6. bad_y2 = 2707385501144840649318225287225658788936804267575313519463743609750303402022"
    },
    {
      "indent": 10,
      "text": "7. bad_pk[2] = int_to_string(bad_y2, 32)",
      "ja": "7. bad_pk[2] = int_to_string(bad_y2, 32)"
    },
    {
      "indent": 10,
      "text": "8. bad_pk[3] = int_to_string(p-bad_y2, 32)",
      "ja": "8. bad_pk[3] = int_to_string(p-bad_y2, 32)"
    },
    {
      "indent": 10,
      "text": "9. bad_pk[4] = int_to_string(p-1, 32)",
      "ja": "9. bad_pk[4] = int_to_string(p-1, 32) \n\nbad_pk[4] = int_to_string(p-1, 32)"
    },
    {
      "indent": 10,
      "text": "10. bad_pk[5] = int_to_string(p, 32)",
      "ja": "10. bad_pk[5] = int_to_string(p, 32)"
    },
    {
      "indent": 10,
      "text": "11. bad_pk[6] = int_to_string(p+1, 32)",
      "ja": "11. bad_pk[6] = int_to_string(p+1, 32)"
    },
    {
      "indent": 10,
      "text": "12. If y_string is in the list [bad_pk[0],...,bad_pk[6]], output \"INVALID\" and stop",
      "ja": "12. y_string がリスト [bad_pk[0],...,bad_pk[6]] に含まれている場合、\"INVALID\" と出力して処理を停止します。"
    },
    {
      "indent": 10,
      "text": "13. Output \"VALID\"",
      "ja": "13. \"VALID\""
    },
    {
      "indent": 3,
      "text": "(This algorithm works for the following reason. Note that there are eight bad points -- namely, the points whose order is 1, 2, 4, or 8 -- on the edwards25519 curve. Their y-coordinates happen to be 0 (two points of order 4), 1 (one point of order 1), bad_y2 (two points of order 8), p-bad_y2 (two points of order 8), and p-1 (one point of order 2). They can be obtained by converting the points specified in [X25519] to Edwards coordinates. Thus, bad_pk[0] (of order 4), bad_pk[2] (of order 8), and bad_pk[3] (of order 8) each match two bad points, depending on the sign of the x-coordinate. This sign is cleared in Step 3 in order to make sure that it does not affect the comparison.  bad_pk[1] (of order 1) and bad_pk[4] (of order 2) each match one bad point, because the x-coordinate is 0 for these two points. Note that the first five list elements cover the eight bad points. However, to cover the case when the y-coordinate of the public key Y has not been modular reduced by p, the list also includes bad_pk[5] and bad_pk[6], which are simply bad_pk[0] and bad_pk[1] shifted by p. There is no need to shift the other bad_pk values by p (or any bad_pk values by a larger multiple of p), because their y-coordinates would exceed 2^255, and the algorithm ensures that y_string corresponds to an integer less than 2^255 in Step 3.)",
      "ja": "（このアルゴリズムは次の理由で機能します。注意すべきは、edwards25519曲線上には8つの悪い点があることです。すなわち、順序が1、2、4、または8である点です。これらのy座標は0（順序4の2点）、1（順序1の1点）、bad_y2（順序8の2点）、p-bad_y2（順序8の2点）、およびp-1（順序2の1点）になります。これらは、[X25519]で指定された点をEdwards座標に変換することで取得できます。したがって、bad_pk[0]（順序4）、bad_pk[2]（順序8）、およびbad_pk[3]（順序8）は、x座標の符号に応じて2つの悪い点にそれぞれ一致します。この符号は、比較に影響を与えないようにステップ3でクリアされます。bad_pk[1]（順序1）およびbad_pk[4]（順序2）は、x座標がこれら2点で0であるため、それぞれ1つの悪い点に一致します。最初の5つのリスト要素が8つの悪い点をカバーしていることに注意してください。ただし、公開鍵Yのy座標がpでモジュラー削減されていない場合をカバーするために、リストには単純にpでシフトされたbad_pk[0]およびbad_pk[1]であるbad_pk[5]およびbad_pk[6]も含まれています。他のbad_pk値をp（またはpの大きな倍数）でシフトする必要はありません。なぜなら、それらのy座標が2^255を超えるためであり、アルゴリズムはステップ3でy_stringが2^255未満の整数に対応するように確実にします。）"
    },
    {
      "indent": 0,
      "text": "5.5. ECVRF Ciphersuites",
      "section_title": true,
      "ja": "5.5. ECVRFサイファースイート"
    },
    {
      "indent": 3,
      "text": "This document defines ECVRF-P256-SHA256-TAI as follows:",
      "ja": "この文書は、ECVRF-P256-SHA256-TAIを以下のように定義します。"
    },
    {
      "indent": 6,
      "text": "* suite_string = 0x01.",
      "ja": "* suite_string = 0x01."
    },
    {
      "indent": 6,
      "text": "* The EC group G is the NIST P-256 elliptic curve, with the finite field and curve parameters as specified in Section 3.2.1.3 of [SP-800-186] and Section 2.6 of [RFC5114]. For this group, fLen = qLen = 32 and cofactor = 1.",
      "ja": "* ECグループGは、NIST P-256楕円曲線であり、有限体および曲線パラメータは[SP-800-186]のセクション3.2.1.3および[RFC5114]のセクション2.6で指定されています。このグループにおいて、fLen = qLen = 32 および cofactor = 1 です。"
    },
    {
      "indent": 6,
      "text": "* cLen = 16.",
      "ja": "* cLen = 16。"
    },
    {
      "indent": 6,
      "text": "* The key pair generation primitive is specified in Section 3.2.1 of [SECG1] (q, B, SK, and Y in this document correspond to n, G, d, and Q in Section 3.2.1 of [SECG1]). In this ciphersuite, the secret scalar x is equal to the secret key SK.",
      "ja": "* キーペア生成プリミティブは、[SECG1]のセクション3.2.1で指定されています（この文書のq、B、SK、およびYは、[SECG1]のセクション3.2.1のn、G、d、およびQに対応しています）。このサイファースイートでは、秘密スカラーxは秘密鍵SKと等しいです。"
    },
    {
      "indent": 6,
      "text": "* encode_to_curve_salt = PK_string.",
      "ja": "* encode_to_curve_salt = PK_string."
    },
    {
      "indent": 6,
      "text": "* The ECVRF_nonce_generation function is as specified in Section 5.4.2.1.",
      "ja": "* ECVRF_nonce_generation 関数は、セクション 5.4.2.1 で指定されている通りです。"
    },
    {
      "indent": 6,
      "text": "* The int_to_string function is the I2OSP function specified in Section 4.1 of [RFC8017]. (This is big-endian representation.)",
      "ja": "* int_to_string 関数は、[RFC8017] のセクション 4.1 で指定されている I2OSP 関数です。（これはビッグエンディアン表現です。）"
    },
    {
      "indent": 6,
      "text": "* The string_to_int function is the OS2IP function specified in Section 4.2 of [RFC8017]. (This is big-endian representation.)",
      "ja": "* string_to_int関数は[RFC8017]のセクション4.2で指定されたOS2IP関数です。（これはビッグエンディアン表現です。）"
    },
    {
      "indent": 6,
      "text": "* The point_to_string function converts a point on E to an octet string according to the encoding specified in Section 2.3.3 of [SECG1] with point compression on. This implies that ptLen = fLen + 1 = 33. (Note that certain software implementations do not introduce a separate elliptic curve point type and instead directly treat the EC point as an octet string per the above encoding. When using such an implementation, the point_to_string function can be treated as the identity function.)",
      "ja": "* point_to_string 関数は、[SECG1] のセクション 2.3.3 で指定されたエンコーディングに従って、点 E 上の点をポイント圧縮を有効にしてオクテット文字列に変換します。これは、ptLen = fLen + 1 = 33 を意味します。（特定のソフトウェア実装では、独自の楕円曲線ポイントタイプを導入せず、代わりに上記のエンコーディングに従って EC ポイントを直接オクテット文字列として扱います。このような実装を使用する場合、point_to_string 関数は同一関数として扱うことができます。）"
    },
    {
      "indent": 6,
      "text": "* The string_to_point function converts an octet string to a point on E according to the encoding specified in Section 2.3.4 of [SECG1]. This function MUST output \"INVALID\" if the octet string does not decode to a point on the curve E.",
      "ja": "* string_to_point 関数は、[SECG1] のセクション 2.3.4 で指定されたエンコーディングに従って、オクテット文字列を E 上の点に変換します。この関数は、オクテット文字列が曲線 E 上の点にデコードされない場合には \"INVALID\" を出力する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The hash function Hash is SHA-256 as specified in [RFC6234], with hLen = 32.",
      "ja": "* ハッシュ関数 Hash は、[RFC6234] で指定されている SHA-256 であり、hLen = 32 です。"
    },
    {
      "indent": 6,
      "text": "* The ECVRF_encode_to_curve function is as specified in Section 5.4.1.1, with interpret_hash_value_as_a_point(s) = string_to_point(0x02 || s).",
      "ja": "* ECVRF_encode_to_curve関数は、Section 5.4.1.1で指定されている通りであり、interpret_hash_value_as_a_point(s) = string_to_point(0x02 || s)です。"
    },
    {
      "indent": 3,
      "text": "This document defines ECVRF-P256-SHA256-SSWU as identical to ECVRF-P256-SHA256-TAI, except that",
      "ja": "このドキュメントは、ECVRF-P256-SHA256-SSWUをECVRF-P256-SHA256-TAIと同一として定義しますが、"
    },
    {
      "indent": 6,
      "text": "* suite_string = 0x02.",
      "ja": "* suite_string = 0x02."
    },
    {
      "indent": 6,
      "text": "* The ECVRF_encode_to_curve function is as specified in Section 5.4.1.2, with h2c_suite_ID_string = P256_XMD:SHA-256_SSWU_NU_ (the suite is defined in Section 8.2 of [RFC9380]).",
      "ja": "* ECVRF_encode_to_curve関数は、セクション5.4.1.2で指定されており、h2c_suite_ID_string = P256_XMD:SHA-256_SSWU_NU_（このスイートは[RFC9380]のセクション8.2で定義されています）とします。"
    },
    {
      "indent": 3,
      "text": "This document defines ECVRF-EDWARDS25519-SHA512-TAI as follows:",
      "ja": "この文書は、ECVRF-EDWARDS25519-SHA512-TAIを以下のように定義します。"
    },
    {
      "indent": 6,
      "text": "* suite_string = 0x03.",
      "ja": "* suite_string = 0x03."
    },
    {
      "indent": 6,
      "text": "* The EC group G is the edwards25519 elliptic curve, with the finite field and curve parameters as defined in Table 1 in Section 5.1 of [RFC8032]. For this group, fLen = qLen = 32 and cofactor = 8.",
      "ja": "* ECグループGは、[RFC8032]のセクション5.1の表1で定義されている有限体および曲線パラメータを持つedwards25519楕円曲線です。このグループにおいて、fLen = qLen = 32 およびコファクター = 8 です。"
    },
    {
      "indent": 6,
      "text": "* cLen = 16.",
      "ja": "* cLen = 16。"
    },
    {
      "indent": 6,
      "text": "* The secret key and generation of the secret scalar and the public key are specified in Section 5.1.5 of [RFC8032].",
      "ja": "* [RFC8032]のセクション5.1.5で、秘密鍵と秘密スカラーおよび公開鍵の生成方法が指定されています。"
    },
    {
      "indent": 6,
      "text": "* encode_to_curve_salt = PK_string.",
      "ja": "* encode_to_curve_salt = PK_string."
    },
    {
      "indent": 6,
      "text": "* The ECVRF_nonce_generation function is as specified in Section 5.4.2.2.",
      "ja": "* ECVRF_nonce_generation 関数は、セクション 5.4.2.2 で指定されている通りです。"
    },
    {
      "indent": 6,
      "text": "* The int_to_string function is implemented as specified in the first paragraph of Section 5.1.2 of [RFC8032]. (This is little-endian representation.)",
      "ja": "* int_to_string関数は、[RFC8032]のセクション5.1.2の最初の段落で指定されている通りに実装されています。（これはリトルエンディアン表現です。）"
    },
    {
      "indent": 6,
      "text": "* The string_to_int function interprets the string as an integer in little-endian representation.",
      "ja": "* string_to_int関数は、文字列をリトルエンディアン表現の整数として解釈します。"
    },
    {
      "indent": 6,
      "text": "* The point_to_string function converts a point on E to an octet string according to the encoding specified in Section 5.1.2 of [RFC8032]. This implies that ptLen = fLen = 32. (Note that certain software implementations do not introduce a separate elliptic curve point type and instead directly treat the EC point as an octet string per the above encoding. When using such an implementation, the point_to_string function can be treated as the identity function.)",
      "ja": "* point_to_string関数は、[RFC8032]のセクション5.1.2で指定されたエンコーディングに従って、E上の点をオクテット文字列に変換します。これは、ptLen = fLen = 32を意味します。（特定のソフトウェア実装では、独立した楕円曲線点タイプを導入せず、代わりに上記のエンコーディングに従ってECポイントを直接オクテット文字列として扱います。このような実装を使用する場合、point_to_string関数は同一関数として扱うことができます。）"
    },
    {
      "indent": 6,
      "text": "* The string_to_point function converts an octet string to a point on E according to the encoding specified in Section 5.1.3 of [RFC8032]. This function MUST output \"INVALID\" if the octet string does not decode to a point on the curve E.",
      "ja": "* string_to_point 関数は、[RFC8032] のセクション 5.1.3 で指定されたエンコーディングに従って、オクテット文字列を E 上の点に変換します。この関数は、オクテット文字列が曲線 E 上の点にデコードされない場合には \"INVALID\" を出力する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The hash function Hash is SHA-512 as specified in [RFC6234], with hLen = 64.",
      "ja": "* ハッシュ関数 Hash は、[RFC6234] で指定されている SHA-512 であり、hLen = 64 です。"
    },
    {
      "indent": 6,
      "text": "* The ECVRF_encode_to_curve function is as specified in Section 5.4.1.1, with interpret_hash_value_as_a_point(s) = string_to_point(s[0]...s[31]).",
      "ja": "* ECVRF_encode_to_curve関数は、Section 5.4.1.1で指定されている通りであり、interpret_hash_value_as_a_point(s) = string_to_point(s[0]...s[31])です。"
    },
    {
      "indent": 3,
      "text": "This document defines ECVRF-EDWARDS25519-SHA512-ELL2 as identical to ECVRF-EDWARDS25519-SHA512-TAI, except that",
      "ja": "このドキュメントは、ECVRF-EDWARDS25519-SHA512-ELL2を、ECVRF-EDWARDS25519-SHA512-TAIと同一と定義します。"
    },
    {
      "indent": 6,
      "text": "* suite_string = 0x04.",
      "ja": "* suite_string = 0x04."
    },
    {
      "indent": 6,
      "text": "* The ECVRF_encode_to_curve function is as specified in Section 5.4.1.2, with h2c_suite_ID_string = edwards25519_XMD:SHA-512_ELL2_NU_ (the suite is defined in Section 8.5 of [RFC9380]).",
      "ja": "* ECVRF_encode_to_curve関数は、h2c_suite_ID_string = edwards25519_XMD:SHA-512_ELL2_NU_（このスイートは[RFC9380]のセクション8.5で定義されています）に指定された通りです。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "この文書にはIANAのアクションはありません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Key Generation",
      "section_title": true,
      "ja": "7.1. 鍵生成"
    },
    {
      "indent": 3,
      "text": "Implementations of the VRFs defined in this document MUST ensure that they generate VRF keys correctly and use good randomness. However, in some applications, keys may be generated by an adversary who does not necessarily implement this document. We now discuss the implications of this possibility.",
      "ja": "このドキュメントで定義されたVRFの実装は、VRFキーを正しく生成し、良好なランダム性を使用することを確実にする必要があります。ただし、一部のアプリケーションでは、このドキュメントを必ずしも実装していない敵対者によってキーが生成される場合があります。この可能性の影響について今後議論します。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Uniqueness and Collision Resistance under Malicious Key Generation",
      "section_title": true,
      "ja": "7.1.1. 悪意のある鍵生成における一意性と衝突耐性"
    },
    {
      "indent": 3,
      "text": "See Section 3 for definitions of uniqueness and collision resistance properties.",
      "ja": "一意性と衝突耐性のプロパティの定義については、セクション3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The RSA-FDH-VRF satisfies only the \"trusted\" variants of uniqueness and collision resistance. Thus, for the RSA-FDH-VRF, uniqueness and collision resistance may not hold if the keys are generated adversarially (specifically, if the RSA function specified in the public key is not bijective because the modulus n or the exponent e are chosen without complying with [RFC8017]); thus, the RSA-FDH-VRF as defined in this document does not have \"full uniqueness\" and \"full collision resistance\". Therefore, if malicious key generation is a concern, the RSA-FDH-VRF has to be enhanced by additional cryptographic checks (such as zero-knowledge proofs) to ensure that its public key has the right form. These enhancements are left for future specifications.",
      "ja": "RSA-FDH-VRFは、一意性と衝突耐性の「信頼できる」バリアントのみを満たします。したがって、RSA-FDH-VRFにおいて、鍵が敵対的に生成された場合（具体的には、公開鍵で指定されたRSA関数が[RFC8017]に準拠せずにモジュラスnまたは指数eが選択された場合）、一意性と衝突耐性が保持されない可能性があります。したがって、このドキュメントで定義されたRSA-FDH-VRFには「完全な一意性」と「完全な衝突耐性」がありません。したがって、悪意のある鍵生成が懸念される場合、RSA-FDH-VRFは、その公開鍵が適切な形式であることを確認するために、追加の暗号的チェック（ゼロ知識証明など）によって強化する必要があります。これらの強化は、将来の仕様に任されています。"
    },
    {
      "indent": 3,
      "text": "For the ECVRF, the Verifier MUST obtain E and B from a trusted source, such as a ciphersuite specification, rather than from the Prover. If the Verifier does so, then the ECVRF satisfies \"full uniqueness\", ensuring uniqueness even under malicious key generation. The ECVRF also satisfies \"trusted collision resistance\". It additionally satisfies \"full collision resistance\" if the validate_key parameter given to ECVRF_verify is TRUE. This setting of ECVRF_verify ensures collision resistance under malicious key generation.",
      "ja": "ECVRFについて、検証者は証明者からではなく、暗号スイートの仕様などの信頼できるソースからEとBを取得する必要があります。検証者がそうすると、ECVRFは「完全な一意性」を満たし、悪意のある鍵生成の下でも一意性を保証します。 ECVRFはまた「信頼された衝突耐性」を満たします。 ECVRF_verifyに渡されるvalidate_keyパラメータがTRUEの場合、さらに「完全な衝突耐性」を満たします。このECVRF_verifyの設定により、悪意のある鍵生成の下でも衝突耐性が確保されます。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Pseudorandomness under Malicious Key Generation",
      "section_title": true,
      "ja": "7.1.2. 悪意のある鍵生成下の疑似乱数性"
    },
    {
      "indent": 3,
      "text": "Without good randomness, the \"pseudorandomness\" properties of the VRF (defined in Section 3.4) may not hold. Note that it is not possible to guarantee pseudorandomness in the face of adversarially generated VRF keys. This is because an adversary can always use bad randomness to generate the VRF keys, and thus the VRF output may not be pseudorandom.",
      "ja": "良好なランダム性がないと、VRFの「擬似ランダム性」の特性が保持されないかもしれません。悪意のある生成されたVRFキーに対して擬似ランダム性を保証することは不可能であることに注意してください。これは、敵対的に生成されたVRFキーを使用する敵対者が常に悪いランダム性を使用してVRFキーを生成できるため、VRFの出力が擬似ランダムでない可能性があるためです。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Unpredictability under Malicious Key Generation",
      "section_title": true,
      "ja": "7.1.3. 悪意のある鍵生成における予測不可能性"
    },
    {
      "indent": 3,
      "text": "Unpredictability under malicious key generation (defined in Section 3.5) does not hold for the RSA-FDH-VRF. (Specifically, the VRF output may be predictable if the RSA function specified in the public key is far from bijective because the modulus n or the exponent e are chosen without complying with [RFC8017].) If unpredictability under malicious key generation is desired, the RSA-FDH-VRF has to be enhanced by additional cryptographic checks (such as zero-knowledge proofs) to ensure that its public key has the right form. These enhancements are left for future specifications.",
      "ja": "悪意のある鍵生成の下での予測不可能性（セクション3.5で定義されている）は、RSA-FDH-VRFには当てはまりません。（具体的には、公開鍵で指定されたRSA関数が全単射から遠い場合、VRFの出力は予測可能になる可能性があります。なぜなら、モジュラスnや指数eが[RFC8017]に準拠せずに選択されているためです。）悪意のある鍵生成の下での予測不可能性が必要な場合、RSA-FDH-VRFは、その公開鍵が適切な形式であることを確認するために、追加の暗号的チェック（ゼロ知識証明など）によって強化する必要があります。これらの強化は、将来の仕様に任されています。"
    },
    {
      "indent": 3,
      "text": "Unpredictability under malicious key generation holds for the ECVRF if the validate_key parameter given to ECVRF_verify is TRUE.",
      "ja": "ECVRF_verifyに与えられたvalidate_keyパラメータがTRUEの場合、悪意のある鍵生成に対するECVRFの予測不可能性が保持されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Security Levels",
      "section_title": true,
      "ja": "7.2. セキュリティレベル"
    },
    {
      "indent": 3,
      "text": "As shown in [PWHVNRG17], the RSA-FDH-VRF satisfies the trusted uniqueness property unconditionally. The security level of the RSA-FDH-VRF, measured in bits, for the other two properties is as follows (in the random oracle model for the functions MGF1 and Hash):",
      "ja": "[PWHVNRG17]に示されているように、RSA-FDH-VRFは信頼される一意性特性を無条件に満たします。 RSA-FDH-VRFのセキュリティレベル（ビット単位で測定）は、他の2つの特性について次のようになります（関数MGF1およびハッシュのランダムオラクルモデルで）。"
    },
    {
      "indent": 3,
      "text": "For trusted collision resistance:",
      "ja": "信頼できる衝突耐性のため:"
    },
    {
      "indent": 12,
      "text": "approximately 8*min(k/2, hLen/2) (as shown in [PWHVNRG17]).",
      "ja": "約8 * min(k/2, hLen/2)（[PWHVNRG17]に示されているように）。"
    },
    {
      "indent": 3,
      "text": "For selective pseudorandomness:",
      "ja": "選択的擬似乱数性のために:"
    },
    {
      "indent": 12,
      "text": "approximately as strong as the security, in bits, of the RSA problem for the key (n, e) (as shown in [GNPRVZ15]).",
      "ja": "キー(n、e)のRSA問題のセキュリティの強さは、おおよそRSA問題のビット数と同程度です（[GNPRVZ15]に示されているように）。"
    },
    {
      "indent": 3,
      "text": "As shown in [PWHVNRG17], the security level of the ECVRF, measured in bits, is as follows (in the random oracle model for the functions Hash and ECVRF_encode_to_curve):",
      "ja": "[PWHVNRG17]に示されているように、ECVRFのセキュリティレベル（ビット単位で測定）は、次の通りです（関数HashおよびECVRF_encode_to_curveのランダムオラクルモデルにおいて）："
    },
    {
      "indent": 3,
      "text": "For uniqueness (both trusted and full):",
      "ja": "一意性のため（信頼されたものと完全なものの両方）:"
    },
    {
      "indent": 12,
      "text": "approximately 8*min(qLen, cLen).",
      "ja": "約8 * min(qLen、cLen)。"
    },
    {
      "indent": 3,
      "text": "For collision resistance (trusted or full, depending on whether validation is performed as explained in Section 7.1.1):",
      "ja": "衝突耐性（信頼されたものまたは完全なもの、検証がセクション7.1.1で説明されるように行われるかに応じて）："
    },
    {
      "indent": 12,
      "text": "approximately 8*min(qLen/2, hLen/2).",
      "ja": "約8 * min(qLen/2, hLen/2)。"
    },
    {
      "indent": 3,
      "text": "For selective pseudorandomness:",
      "ja": "選択的擬似乱数性のために:"
    },
    {
      "indent": 12,
      "text": "approximately as strong as the security, in bits, of the decisional Diffie-Hellman problem in the group G (which is at most 8*qLen/2).",
      "ja": "グループGにおける決定的ディフィー・ヘルマン問題のセキュリティの強さ（ビット単位）とほぼ同等です（最大で8*qLen/2）。"
    },
    {
      "indent": 3,
      "text": "See Section 3 for the definitions of these security properties and Section 7.3 for the discussion of full pseudorandomness.",
      "ja": "これらのセキュリティプロパティの定義については、セクション3を参照してください。完全擬似乱数性の議論については、セクション7.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3. Selective vs. Full Pseudorandomness",
      "section_title": true,
      "ja": "7.3. 選択的対完全擬似乱数性"
    },
    {
      "indent": 3,
      "text": "[PWHVNRG17] presents cryptographic reductions to an underlying hard problem (namely, the RSA problem for the RSA-FDH-VRF and the decisional Diffie-Hellman problem for the ECVRF) to prove that the VRFs specified in this document possess not only selective pseudorandomness but also full pseudorandomness (see Section 3.4 for an explanation of these notions). However, the cryptographic reductions are tighter for selective pseudorandomness than for full pseudorandomness. Specifically, the approximate provable security level, measured in bits, for full pseudorandomness may be obtained from the provable security level for selective pseudorandomness (given in Section 7.2) by subtracting the binary logarithm of the number of proofs produced for a given secret key. This holds for both the RSA-FDH-VRF and the ECVRF.",
      "ja": "[PWHVNRG17]は、この文書で指定されたVRFが選択的擬似ランダム性だけでなく完全な擬似ランダム性を持つことを証明するために、基礎となる難しい問題（つまり、RSA-FDH-VRFのRSA問題とECVRFの決定的Diffie-Hellman問題）への暗号学的還元を提示しています（これらの概念の説明についてはセクション3.4を参照）。ただし、暗号学的還元は、選択的擬似ランダム性に対して完全な擬似ランダム性よりも厳密です。具体的には、特定の秘密鍵に対して生成される証明の数の二進対数を引くことで、完全な擬似ランダム性のためのおおよその証明可能なセキュリティレベル（ビット単位で測定）は、選択的擬似ランダム性のための証明可能なセキュリティレベル（セクション7.2で与えられている）から得られます。これは、RSA-FDH-VRFとECVRFの両方に対して成り立ちます。"
    },
    {
      "indent": 3,
      "text": "While no known attacks against full pseudorandomness are stronger than similar attacks against selective pseudorandomness, some applications may be concerned about tightness of cryptographic reductions to ensure specific levels of provable security. Such applications may consider the following three options:",
      "ja": "既知の完全擬似乱数性に対する攻撃は、選択的擬似乱数性に対する攻撃と同等以上の強さではありませんが、特定の証明可能なセキュリティレベルを確保するための暗号学的還元の緊密さについて懸念を抱くアプリケーションもあります。そのようなアプリケーションは、以下の3つのオプションを検討することができます："
    },
    {
      "indent": 6,
      "text": "* They may limit the number of proofs produced for a given secret key, to reduce the loss in the provable security level.",
      "ja": "* 与えられた秘密鍵に対して生成される証明の数を制限することがあります。これは、証明可能なセキュリティレベルの低下を減らすためです。"
    },
    {
      "indent": 6,
      "text": "* They may work to ensure that selective pseudorandomness is sufficient for the application. That is, they may design the application such that pseudorandomness of outputs matters only for inputs that are chosen independently of the VRF key.",
      "ja": "* 彼らは、選択的擬似乱数性がアプリケーションに十分であることを確認するために作業するかもしれません。つまり、彼らは、出力の擬似乱数性がVRFキーとは独立して選択された入力にのみ影響するようにアプリケーションを設計するかもしれません。"
    },
    {
      "indent": 6,
      "text": "* They may increase security parameters to make up for lossy security reductions. For the RSA-FDH-VRF, this means increasing the RSA key length. For the ECVRF, this means increasing the cryptographic strength of the EC group G by specifying a new ciphersuite.",
      "ja": "* 彼らは、セキュリティの低下を補うためにセキュリティパラメータを増やすことができます。RSA-FDH-VRFの場合、これはRSA鍵長の増加を意味します。ECVRFの場合、新しい暗号スイートを指定することでECグループGの暗号強度を増やすことを意味します。"
    },
    {
      "indent": 0,
      "text": "7.4. Proper Pseudorandom Nonce for the ECVRF",
      "section_title": true,
      "ja": "7.4. ECVRFのための適切な擬似乱数ナンス"
    },
    {
      "indent": 3,
      "text": "The security of the ECVRF defined in this document relies on the fact that the nonce k used in the ECVRF_prove algorithm is chosen uniformly and pseudorandomly modulo q and is unknown to the adversary. Otherwise, an adversary may be able to recover the VRF secret scalar x (and thus break pseudorandomness of the VRF) after observing several valid VRF proofs pi, using, for example, techniques described in [BreHen19]. The nonce generation methods specified in the ECVRF ciphersuites of Section 5.5 are designed with this requirement in mind.",
      "ja": "このドキュメントで定義されたECVRFのセキュリティは、ECVRF_proveアルゴリズムで使用されるノンスkが一様かつ擬似ランダムにqで剰余を取られ、かつ敵対者には未知であるという事実に依存しています。そうでないと、敵対者は、例えば[BreHen19]で説明されている技術を使用して、いくつかの有効なVRF証明πを観察した後にVRF秘密スカラーxを回復し（したがってVRFの擬似ランダム性を破壊し）る可能性があります。セクション5.5のECVRFサイファースイートで指定されたノンス生成方法は、この要件を考慮して設計されています。"
    },
    {
      "indent": 0,
      "text": "7.5. Side-Channel Attacks",
      "section_title": true,
      "ja": "7.5. Side-Channel Attacks\n側面チャネル攻撃"
    },
    {
      "indent": 3,
      "text": "Side-channel attacks on cryptographic primitives are an important issue. Implementers should take care to avoid side-channel attacks that leak information about the VRF secret key SK (and the nonce k used in the ECVRF), which is used in VRF_prove. In most applications, the VRF_proof_to_hash and VRF_verify algorithms take only inputs that are public, and thus side-channel attacks are typically not a concern for these algorithms.",
      "ja": "暗号プリミティブへのサイドチャネル攻撃は重要な問題です。実装者は、VRFプルーフで使用されるVRF秘密鍵SK（およびECVRFで使用されるノンスk）に関する情報を漏洩させるサイドチャネル攻撃を回避するよう注意を払う必要があります。ほとんどのアプリケーションでは、VRF_proof_to_hashおよびVRF_verifyアルゴリズムは一般に公開された入力のみを取り、したがってこれらのアルゴリズムに対するサイドチャネル攻撃は通常懸念されません。"
    },
    {
      "indent": 3,
      "text": "The VRF input alpha may also be a sensitive input to VRF_prove and may need to be protected against side-channel attacks. Below, we discuss one particular class of such attacks: timing attacks that can be used to leak information about the VRF input alpha.",
      "ja": "VRF入力αはVRF_proveに対しても機密性の高い入力となる場合があり、サイドチャネル攻撃から保護する必要があるかもしれません。以下では、そのような攻撃の1つであるタイミング攻撃について説明します。"
    },
    {
      "indent": 3,
      "text": "The ECVRF_encode_to_curve_try_and_increment algorithm (defined in Section 5.4.1.1) SHOULD NOT be used in applications where the VRF input alpha is secret and is hashed by the VRF on the fly. This is because the algorithm's running time depends on the VRF input alpha and thus creates a timing channel that can be used to learn information about alpha. That said, for most inputs, the amount of information obtained from such a timing attack is likely to be small (1 bit, on average), since the algorithm is expected to find a valid curve point after only two attempts. However, there might be inputs that cause the algorithm to make many attempts before it finds a valid curve point; for such inputs, the information leaked in a timing attack will be more than 1 bit.",
      "ja": "ECVRF_encode_to_curve_try_and_incrementアルゴリズム（セクション5.4.1.1で定義されています）は、VRF入力αが秘密であり、VRFがその場でハッシュ化されるアプリケーションで使用すべきではありません。これは、アルゴリズムの実行時間がVRF入力αに依存するため、αに関する情報を学習するために使用できるタイミングチャネルを作成するためです。それにもかかわらず、ほとんどの入力に対して、そのようなタイミング攻撃から得られる情報量は少ない可能性が高いです（平均で1ビット）、なぜならアルゴリズムは通常、有効な曲線上の点を見つけるのに2回の試行しか必要としないからです。ただし、アルゴリズムが有効な曲線上の点を見つける前に多くの試行を行う入力があるかもしれません。そのような入力の場合、タイミング攻撃で漏洩する情報は1ビット以上になります。"
    },
    {
      "indent": 3,
      "text": "ECVRF-P256-SHA256-SSWU and ECVRF-EDWARDS25519-SHA512-ELL2 can be made to run in time that is independent of alpha, following recommendations in [RFC9380].",
      "ja": "ECVRF-P256-SHA256-SSWUとECVRF-EDWARDS25519-SHA512-ELL2は、[RFC9380]の推奨に従って、αに依存しない時間で実行できます。"
    },
    {
      "indent": 0,
      "text": "7.6. Proofs Provide No Secrecy for the VRF Input",
      "section_title": true,
      "ja": "7.6. 証明はVRF入力に秘密を提供しません。"
    },
    {
      "indent": 3,
      "text": "The VRF proof pi is not designed to provide secrecy and, in general, may reveal the VRF input alpha. Anyone who knows PK and pi is able to perform an offline dictionary attack to search for alpha, by verifying guesses for alpha using VRF_verify. This is in contrast to the VRF hash output beta, which, without the proof, is pseudorandom and thus is designed to reveal no information about alpha.",
      "ja": "VRFの証明piは機密性を提供するために設計されておらず、一般的にはVRFの入力alphaを明らかにする可能性があります。PKとpiを知っている人は、VRF_verifyを使用してalphaの推測を検証することで、オフラインの辞書攻撃を実行できます。これは、証明なしのVRFハッシュ出力betaとは対照的であり、擬似ランダムであり、したがってalphaに関する情報を明らかにしないように設計されています。"
    },
    {
      "indent": 0,
      "text": "7.7. Prehashing",
      "section_title": true,
      "ja": "7.7. Prehashing"
    },
    {
      "indent": 3,
      "text": "The VRFs specified in this document allow for read-once access to the input alpha for both signing and verifying. Thus, additional prehashing of alpha (as specified, for example, in [RFC8032] for Edwards-curve Digital Signature Algorithm (EdDSA) signatures) is not needed, even for applications that need to handle long alpha or to support the Initialize-Update-Finalize (IUF) interface (in such an interface, alpha is not supplied all at once, but rather in pieces by a sequence of calls to Update). The ECVRF, in particular, uses alpha only in ECVRF_encode_to_curve. The curve point H becomes the representative of alpha thereafter.",
      "ja": "このドキュメントで指定されたVRFは、署名と検証の両方で入力αへの一度だけのアクセスを可能にします。したがって、追加のαの事前ハッシング（たとえば、Edwards-curve Digital Signature Algorithm（EdDSA）署名の[RFC8032]で指定されているように）は、長いαを処理する必要があるアプリケーションやInitialize-Update-Finalize（IUF）インターフェースをサポートする必要があるアプリケーションでも必要ありません（このようなインターフェースでは、αは一度にすべて提供されるのではなく、Updateの一連の呼び出しによって部分的に提供されます）。特に、ECVRFはECVRF_encode_to_curveでのみαを使用します。その後、曲線点Hがαの代表となります。"
    },
    {
      "indent": 0,
      "text": "7.8. Hash Function Domain Separation",
      "section_title": true,
      "ja": "7.8. ハッシュ関数のドメイン分離"
    },
    {
      "indent": 3,
      "text": "Hashing is used for different purposes in the two VRFs. Specifically, in the RSA-FDH-VRF, hashing is used in MGF1 and in proof_to_hash; in the ECVRF, hashing is used in encode_to_curve, nonce_generation, challenge_generation, and proof_to_hash. The theoretical analysis treats each of these functions as a separate hash function, modeled as a random oracle. This analysis still holds even if the same hash function is used, as long as the inputs given to the hash function for a given SK and alpha are overwhelmingly unlikely to be equal to each other or to any inputs given to the hash function for the same SK and different alpha. This is indeed the case for the RSA-FDH-VRF defined in this document, because the second octets of the inputs to the hash function used in MGF1 and in proof_to_hash are different.",
      "ja": "ハッシングは、2つのVRFで異なる目的で使用されています。具体的には、RSA-FDH-VRFでは、ハッシングがMGF1およびproof_to_hashで使用され、ECVRFでは、encode_to_curve、nonce_generation、challenge_generation、およびproof_to_hashで使用されます。理論的な分析では、これらの各機能を別々のハッシュ関数として扱い、ランダムオラクルとしてモデル化されます。同じハッシュ関数が使用されていても、特定のSKとαに対してハッシュ関数に与えられる入力が互いに等しいか、または同じSKと異なるαに対してハッシュ関数に与えられる入力と等しい可能性が圧倒的に低い場合、この分析は依然として成立します。このドキュメントで定義されているRSA-FDH-VRFには、このようなケースが当てはまります。なぜなら、MGF1およびproof_to_hashで使用されるハッシュ関数への入力の2番目のオクテットが異なるからです。"
    },
    {
      "indent": 3,
      "text": "This is also the case for the ECVRF ciphersuites defined in this document, because",
      "ja": "このドキュメントで定義されているECVRFサイプスイートについても同様になります。"
    },
    {
      "indent": 6,
      "text": "* Inputs to the hash function used in nonce_generation are unlikely to equal inputs used in encode_to_curve, proof_to_hash, and challenge_generation. This follows, since nonce_generation inputs a secret to the hash function that is not used by honest parties as input to any other hash function and is not available to the adversary.",
      "ja": "* nonce_generationで使用されるハッシュ関数への入力は、encode_to_curve、proof_to_hash、およびchallenge_generationで使用される入力と一致する可能性は低いです。これは、nonce_generationがハッシュ関数に秘密を入力するため、正直な参加者が他のハッシュ関数の入力として使用しない秘密であり、敵対者には利用できないためです。"
    },
    {
      "indent": 6,
      "text": "* The second octets of the inputs to the hash function used in proof_to_hash, challenge_generation, and encode_to_curve_try_and_increment are all different.",
      "ja": "* proof_to_hash、challenge_generation、およびencode_to_curve_try_and_incrementで使用されるハッシュ関数への入力の2番目のオクテットはすべて異なります。"
    },
    {
      "indent": 6,
      "text": "* The last octet of the inputs to the hash function used in proof_to_hash, challenge_generation, and encode_to_curve_try_and_increment is always zero and is therefore different from the last octet of the input to the hash function used in ECVRF_encode_to_curve_h2c_suite, which is set equal to the nonzero length of the domain separation tag per [RFC9380].",
      "ja": "* proof_to_hash、challenge_generation、およびencode_to_curve_try_and_incrementで使用されるハッシュ関数への入力の最後のオクテットは常にゼロであり、したがって、ECVRF_encode_to_curve_h2c_suiteで使用されるハッシュ関数への入力の最後のオクテットとは異なります。これは[RFC9380]によるドメイン分離タグの非ゼロ長と等しく設定されています。"
    },
    {
      "indent": 0,
      "text": "7.9. Hash Function Salting",
      "section_title": true,
      "ja": "7.9. ハッシュ関数のソルティング"
    },
    {
      "indent": 3,
      "text": "If a hash collision is found, in order to make it more difficult for the adversary to exploit such a collision, the MGF1 function for the RSA-FDH-VRF and the ECVRF_encode_to_curve function for the ECVRF use a public value in addition to alpha (as a so-called salt). This value is determined by the ciphersuite. For the ciphersuites defined in this document, it is set equal to the string representation of the RSA modulus and EC public key, respectively. Implementations that do not use one of the ciphersuites (see Section 7.10) MAY use a different salt. For example, if a group of public keys shares the same salt, then the hash of the VRF input alpha will be the same for the entire group of public keys; this can be helpful for some protocols that use the VRF.",
      "ja": "ハッシュ衝突が見つかった場合、悪意のある者がその衝突を悪用するのをより困難にするために、RSA-FDH-VRFのMGF1関数とECVRFのECVRF_encode_to_curve関数は、αに加えてパブリック値（いわゆるソルト）を使用します。この値は、サイファースイートによって決定されます。この文書で定義されたサイファースイートでは、それぞれRSAモジュラスとEC公開鍵の文字列表現と等しく設定されます。サイファースイートのいずれかを使用しない実装は、異なるソルトを使用しても構いません（セクション7.10を参照）。たとえば、一連の公開鍵が同じソルトを共有している場合、VRF入力αのハッシュは一連の公開鍵全体で同じになります。これは、VRFを使用する一部のプロトコルに役立つことがあります。"
    },
    {
      "indent": 0,
      "text": "7.10. Futureproofing",
      "section_title": true,
      "ja": "7.10. 将来対応"
    },
    {
      "indent": 3,
      "text": "If future designs need to specify variants (e.g., additional ciphersuites) of the RSA-FDH-VRF or the ECVRF as defined in this document, then, to avoid the possibility that an adversary can obtain a VRF output under one variant and then claim it was obtained under another variant, they should specify a different suite_string constant. The suite_string constants discussed in this document are all single octets; if a future suite_string constant is longer than one octet, then it should start with a different octet than the suite_string constants discussed in this document. Then, for the RSA-FDH-VRF, the inputs to the hash function used in MGF1 and proof_to_hash will be different from other ciphersuites. For the ECVRF, the inputs to the ECVRF_encode_to_curve hash function used in producing H are then guaranteed to be different from other ciphersuites; since all the other hashing done by the Prover depends on H, inputs to all the hash functions used by the Prover will also be different from other ciphersuites as long as ECVRF_encode_to_curve is collision resistant.",
      "ja": "このドキュメントで定義されたRSA-FDH-VRFまたはECVRFの変種（たとえば、追加の暗号スイート）を指定する必要がある将来の設計がある場合、敵対者が1つの変種でVRF出力を取得し、それを別の変種で取得したと主張する可能性を避けるために、異なるsuite_string定数を指定する必要があります。このドキュメントで議論されているsuite_string定数はすべて1オクテットです。将来のsuite_string定数が1オクテットよりも長い場合、このドキュメントで議論されているsuite_string定数とは異なるオクテットで始める必要があります。その後、RSA-FDH-VRFの場合、MGF1およびproof_to_hashで使用されるハッシュ関数への入力は他の暗号スイートと異なるものになります。ECVRFの場合、Hを生成する際に使用されるECVRF_encode_to_curveハッシュ関数への入力は他の暗号スイートとは異なるものになります。Proverが行う他のハッシュに依存するすべてのハッシュ関数への入力も、ECVRF_encode_to_curveが衝突耐性である限り、他の暗号スイートと異なるものになります。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5114]  Lepinski, M. and S. Kent, \"Additional Diffie-Hellman\n           Groups for Use with IETF Standards\", RFC 5114,\n           DOI 10.17487/RFC5114, January 2008,\n           <https://www.rfc-editor.org/info/rfc5114>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6234]  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n           (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n           DOI 10.17487/RFC6234, May 2011,\n           <https://www.rfc-editor.org/info/rfc6234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6979]  Pornin, T., \"Deterministic Usage of the Digital Signature\n           Algorithm (DSA) and Elliptic Curve Digital Signature\n           Algorithm (ECDSA)\", RFC 6979, DOI 10.17487/RFC6979, August\n           2013, <https://www.rfc-editor.org/info/rfc6979>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n           \"PKCS #1: RSA Cryptography Specifications Version 2.2\",\n           RFC 8017, DOI 10.17487/RFC8017, November 2016,\n           <https://www.rfc-editor.org/info/rfc8017>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9380]  Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,\n           and C. A. Wood, \"Hashing to Elliptic Curves\", RFC 9380,\n           DOI 10.17487/RFC9380, August 2023,\n           <https://www.rfc-editor.org/info/rfc9380>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SECG1]    Standards for Efficient Cryptography Group (SECG), \"SEC 1:\n           Elliptic Curve Cryptography\", Version 2.0, May 2009,\n           <https://www.secg.org/sec1-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP-800-186]\n           National Institute for Standards and Technology (NIST),\n           \"Recommendations for Discrete Logarithm-based\n           Cryptography: Elliptic Curve Domain Parameters\", NIST SP\n           800-186, DOI 10.6028/NIST.SP.800-186, February 2023,\n           <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n           NIST.SP.800-186.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ANSI.X9-62-2005]\n           American National Standards Institute (ANSI), \"Public Key\n           Cryptography for the Financial Services Industry: the\n           Elliptic Curve Digital Signature Algorithm (ECDSA)\", ANSI\n           X9.62, November 2005,\n           <https://standards.globalspec.com/std/1955141/\n           ANSI%20X9.62>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[BreHen19] Breitner, J. and N. Heninger, \"Biased Nonce Sense: Lattice\n           Attacks against Weak ECDSA Signatures in\n           Cryptocurrencies\", Cryptology ePrint Archive, Paper\n           2019/023, April 2019, <https://eprint.iacr.org/2019/023>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DGKR18]   David, B., Gaži, P., Kiayias, A., and A. Russell,\n           \"Ouroboros Praos: An adaptively-secure, semi-synchronous\n           proof-of-stake blockchain\", Cryptology ePrint Archive,\n           Paper 2017/573, April 2023,\n           <https://eprint.iacr.org/2017/573>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[GHMVZ17]  Gilad, Y., Hemo, R., Micali, S., Vlachos, G., and N.\n           Zeldovich, \"Algorand: Scaling Byzantine Agreements for\n           Cryptocurrencies\", Cryptology ePrint Archive, Paper\n           2017/454, September 2017,\n           <https://eprint.iacr.org/2017/454>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[GNPRVZ15] Goldberg, S., Naor, M., Papadopoulos, D., Reyzin, L.,\n           Vasant, S., and A. Ziv, \"NSEC5: Provably Preventing DNSSEC\n           Zone Enumeration\", Cryptology ePrint Archive, Paper\n           2014/582, December 2014,\n           <https://eprint.iacr.org/2014/582>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MRV99]    Micali, S., Rabin, M., and S. Vadhan, \"Verifiable Random\n           Functions\", FOCS '99: Proceedings of the 40th Annual\n           Symposium on Foundations of Computer Science, pp. 120-130,\n           DOI 10.1109/SFFCS.1999.814584, October 1999,\n           <https://dash.harvard.edu/handle/1/5028196>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PWHVNRG17]\n           Papadopoulos, D., Wessels, D., Huque, S., Naor, M.,\n           Včelák, J., Reyzin, L., and S. Goldberg, \"Making NSEC5\n           Practical for DNSSEC\", Cryptology ePrint Archive, Paper\n           2017/099, August 2022, <https://eprint.iacr.org/2017/099>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[X25519]   Bernstein, D.J., \"How do I validate Curve25519 public\n           keys?\", 2006, <https://cr.yp.to/ecdh.html#validate>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Test Vectors for the RSA-FDH-VRF Ciphersuites",
      "section_title": true,
      "ja": "付録A. RSA-FDH-VRFサイファースイートのテストベクトル"
    },
    {
      "indent": 3,
      "text": "The test vectors in this section were generated using code provided at <https://github.com/reyzin/rsa-fdh-vrf>.",
      "ja": "このセクションのテストベクトルは、<https://github.com/reyzin/rsa-fdh-vrf> で提供されているコードを使用して生成されました。"
    },
    {
      "indent": 3,
      "text": "There are three keys used in the nine examples below. First, we provide the keys. They are shown in hexadecimal big-endian notation.",
      "ja": "以下の9つの例で使用される3つのキーがあります。最初に、キーを提供します。これらは16進数のビッグエンディアン表記で表示されます。"
    },
    {
      "indent": 3,
      "text": "2048-bit key:",
      "ja": "2048ビットのキー:"
    },
    {
      "indent": 3,
      "text": "p = efb52a568fa3038fffb853e2183791c6bc81ceee86d20e8f9b6401dc79a8f1\nf6248d3a25fdb3f99245fce41667da038f59745b87cc1aed8b4a9c1d74e7d5c16c\nf7343f2b12f1b5055337369bf018fa07adc0d16f2164a516e80d2b4734f0c6563d\n6ee6d4a9e1a54e300cfe9ee679afc3d14a152dfb49b6cfb208bbf921f764af\nq = ecbca5ee88bbc635d8263aaba84f6502fdb2b4998a40f7c149133d840b6b1b\nd9a972fe2a981c770272b78fda213f76a062dd865dd116d4c8980975ee9347fe0f\n500567e51d78dbee4a34e626051cf018d7feb72f19189525d4f70b6467d0cef514\n633ab08a9e7a9ec632064b7b5e3e82128fe563757a614092fc5cf624d10e1b\nn = ddaba77202bafb796b85bcec98958aa58ae2d117cbc66a6e75c4c2af983985\na3064eaef93e2b03393256d94d75d6a6656b2956524ed8711898a0c3abae84371d\na0283bc5f433fc384d810a3c118ed302c0b03da16bee70b80ba3480e7acc1eb358\nb3f20fbe90cc4c8a7e2ba9e28b2a3800a5efbaa3c264f79b231f7cdc9577818df1\nbac60ef7a3f78a44f046fd29b0689556da7a7f61eefe67427f3f691aee0a4b1efe\n2ee2e0e6091143ebb7d69254c9d8ab01ff5e0ad7329f566082f9251e64f436c547\ne68de75351ea3a09746ceb7efed2d234121088aaed01696583c172ec88bc173a0d\n4d8ec43f4dcc18ff8379317e83ef9685536283368c9c6deb783075\ne = 010001\nd = d5c5ceab929a841e2a654536de4788f7f0a2a086d44bbb245f8aab3df00db9\n24e8d644c3b502820f4cce98adacf09e73bc0e9762b50ae2b697aaa24914fa08b5\n1758f59c07cf827341bb2a0597e126f9c69db031d60692c9cadf62842444696f08\n223154a1b0be752a325725748644e6d12935b1c66f983379773bcc8c65d06262e9\n3b5bb774dd2784265c23e9a7fc5e8871eb6bcc9968a6bc360a98874b623ec59f41\naf0a9ecec6af095cb7e5aca11472363950dcbbfcf678fe003358b4ff0060a391da\na45a1bd81c166b6221fb07e4f5da75e27d8d5fdbbf87ecbd7f5a4d804597070faa\ned22f197511b218788816689375245ddf7fa12337f3e7e898fb9d9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3072-bit key:",
      "ja": "3072ビットのキー:"
    },
    {
      "indent": 3,
      "text": "p = ee5adea28491084e6635bd73fd95649915a11da410d3f361c8eccc90a4b834\n25146da7b9e9d3994fd37d5fad7fb759ae451eb99b1102d4671ead23a2925133d1\n9df49cf9d7e9dcb69fd7555ca095338d0d2a84abb6825050eaf5fffaeff17ccb08\n33c6079081dfcbd98ced36a593557d29d64b0e0253ce2ee4e07fe2a06269dfe5ca\n230fad221a593a69d9534b2521c1b41d116cafdee02106228ff41433605453e237\n777626953e79b46a84f50069e25b4f50496a928708abce30559eb183cf\nq = fb585bbc12f5695951f70a25e27682dc568acf56115ad749709b2a6e915cdd\n66dfa06db09b390c00b7c7ebeea00845f73c999d8ea9352b1128bdf10113c7500b\n76a03f6b38d0920b5589961549be3d841ccc306f3edd600a53b4b9d4fa1249af87\naf58dfb3ed694289477e853f7d062f58911f7bdb98033b001ee90f11b78f031cff\nac2b5a07e11b01a2a6c1cda059a728f8253a5ff87267623253fc022d3993b27e2f\n344b99eb6072ff7c7ee160724f8fbca562be49247ffae42b55ea79dad5\nn = ea055cef495dec2d8fb3aef519ca87bd1575fa0ae15dd433f4a5f6c40d34ed\n6ba2388172ab7d2183ed970a669d427dc2774ced66a3f082b8e23e94e7de7532f4\nf30bb4a5bbf2e1db2cba0752858a7c7a9bb892c5d6af7e90a7cee8f0097d14498c\n8b482f86348640af61b66640538e834f23ba8f906048db0e57b6fdc162ba2a8a0e\naedd5423f23d8f89413223d89f473029cba11a211eb59e41fb8f0b8ddc651d115d\n9f07ac30296485a9adbd71cc5d9e4a448bd6d70785e838a978b2e66513eb897c96\n2e85f00a36cc0a3a613183d8bd1572f895901eb8155af9797dbd4aa14726f41571\n2bf0eb29fa0a9e938cf5325def05d3af7e686227456d903233e316c8cc50341615\ne59b665f0a4a2c32cfccbf9469bdf89564481fb7afc27a7127741f79424e0a35cd\nc466dd33ef5a2067f75c86e06af9c03c68c6e78be5f1a4f49ea03569cd9f74c3a0\nff290ca4ce2c2fa5b770ef8032b26a517c257b7b1c424622c5c04cf20f2290a268\n939e0cc79dfbac71842f94727b07bfafaded7db6c7f13b\ne = 010001\nd = 6e68e957dbfd7c1862dc1b87780b9dcf0ff9016770bc9c09873b66194941d7\n6218bf2013c1e4df9326dd4402f5df110656d2ec8ea87a28b2a1cb74e590872aeb\n765fe772ea21c57d6ab4ba0fad019189273f05c061719afd14af02277dd28d67c5\nef50b75b521ca51819b9bcb44cb7c82be66776a45f490050dc0171e77374f1ed00\nd06f8beb09b711a9682107d8840d4a23edf6ac25441fdbf2b584dfa6a67cee21eb\n51c484f09416e11914e774713f1a17600fb9e4e99fbbd83fdcba4b09145dd98094\n49a1713777161c912d5d595362314b0ea9d1199e97780e8b3293a39af4019fcc74\n6aaf78dbb7db06852c3358a9ed02ab1d15831a148b27b932c117445a4a6f5114ed\nfa3ccc9a9862df714b78a5362aab5e30501b4a729af73e3cdcabe19aac4928b668\n969780ad33d9df206d904b978a055f4abbc64987744526856e16ef55962453e3ed\n7a8055b0d79d051c50c94584ec7501dbd4856d7a21e43f25d8749e683cca2f53f5\n75af1d80f39d8e6932ffdf201d179cbf98314c4048c6c1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "4096-bit key:",
      "ja": "4096ビットのキー:"
    },
    {
      "indent": 3,
      "text": "p = ac803464c8b2082153e15d5a0698d0a2990397fa01c1edd6171a5315e743c9\n9feb7acd31c37529d4f83405e657c390488d19f7da9ef9d9f9cff4b460d2a26eb1\n0f90cf4aaf55a19e21dc3bb697723a673e12bbc6580adc7bb72adaddf4682d656f\nf5b992e62379bc7b0ac977f2bfbcfac634e04ed597ef302684be72c6bf7db10b80\nf452d412d09e63e017acba378ccc6ea58e683e5641d1e72248f3201a5632f4af75\n25e91f9e0733731d264fe36802f416cb3e182b21e67a12e3bfba9a9cf40a45ff32\naddfae78063933120238ac61fbb995300a8602aa84f993bed375d6ccba86ad0c8e\nfa5f0950aa2c92779febce9d05fa7a1f0d6e5c0d785de93c108297\nq = feb39bb6ee78adfa524e9c0821f60c20d3cff74f8b49731d67ea27d218bcb2\n0c87498d30dfd398bc23daff7b33dc330db93e6c0e5e6196e035446c6db7cfdb98\n68b9518d94670b31f9c4d2109cf32c9cc8ac2fc4a6c2e1078510522c81610a81a7\n07997933ee24030b572a76ee51aa683312ecaa51d8558b3b19cccf65fc867354ae\n193fd5c4f5d5a7180c5ca1e90fcc42f6915dff69a3d1e49046f6c3ef841b262ba8\n9ddcfde2ed3caeb5bd594181a76f6f1ce01fc65c6f925f6d5b77037c2cbf7b6047\ne19f7b9c846c80238f1c8284c33bfd90c79de91381bb883b0de568aaf4b4a3c3f9\nc98f92e9f6a51f010bcc1dacfd72bfdfda29f527d7f4913153bef7\nn = aba03a8d8527bfc0cbea1cb9a100f4ee7870aedd74a6406f108f7a07f37433\n6025357e256d655b342d73369102d03c7dcf3c14ed70aac7ebb62498c570068f71\nf1f165e14527f96d946ba839412252eacea604e7d6fd47a0bb9de776679fa9ad64\n85a076fda04a2015322626dcd2eb91d6b6248802e6d453eb4cbf5e1bfebed02d6a\nb36cfe3dd1e8b9749d4853a029940a0bed3aa3128fd8e2e6cd1115db15405bb383\n7012f56bdc5a6895ec5cc6bca52f7952cfe3c7d5d81d4d3d1c9a29a429eeedfbf5\n8da0a5b17480875b8071f49eb568fc8d8c023c83b3ed870c3775aaf0578485d757\nb4ab18d8e5fdb30c2b5586047e6203ab1636e376f1c7031f171e2807a2058ece89\n0cc8fae29ba819df76b45ddb514caee63db1c5e7a3af7468febff82bfe2eb79e3c\n5d1383b7ebee86f02e9cc1853f0f4486f7eb8fee23a2f794317ffd1c39471086df\nbfc0e3c0f412f917225f5c551557f38c11f172eca257e4b5908a571e4daa7c7434\n903701f21937df87d10de9b50ada97e65855d5e786db8f3f86248b55d999ec3153\n8bd1a409f3e13de46dccc05325774e89016708f8a96240ae1c16641e8b12ab0725\n7e88aa50d3546e7a91073d85ed601775a3c08e9b7c242d20664dfd4e70a05218d9\nf2c7d760fab3cd772d9362527917cf5b51817e8c2aef51cb3b0dd8cb838097e513\n537f1d9c3c4708f44ed270db963c7d72cf11b1\ne = 010001\nd = 1efd8dd524282b4deb04592f83cd226d353e53b5156d37d15652321ce16f28\n1fc258487105b1f9a81054ef937bc89243bd7a01e56624d078d5a9021514c77a7b\n7eceb230dd45fc9a36e4c1b9a4f347b9b29af3e3d14466fcb5242c398b389f70f9\ne7cf33ed54564e38c597720909e513ae8bb149060d1c6612e506e13d78e087c2cb\nb39e88c22cf73315c598dbd0ddf1276743ed04a943644c84949ef32d5e4702c805\n81e54a7fb18879be28b21008dc63182b45f2c190f1b748cd322efc39f2807c64b4\nd06023cb49583418e7b6ac0f447eb2abf48e2ad335583cbc8dff2760c2cce14623\n46326708336f7e374253ed213e990044927c52d29591f414571e509afc2396a6af\n9843303a19673bcdec1e3fc7c0d6c3f43b4bf88ce83e2bdcfb5e39069fe32800cf\n3f6f6d9917b8083a66ce23a9ab5b0c95bbcc6dfc21d38dadecc20725b13ce2954b\na1bd45ec151a8877fed317cac60b2afaa96c826df6d1c48e7c10649dccc75bdf90\n5c362c6934da06c3ce30f5befc1cf776d7fda673625147b1108ecb5473f7f58827\n9533eb184d748230443694b9761b01532ba707563ffa4962321e44fdb710025e8a\n6e00d29bf01ea040618ee111b5d79ac860083f91aa614777cc99d739458f7c53d6\n3cea7155b118068e0b30b35ed6d0cfc75672f18d075157a3ed31bfa1ce2cea2343\n57ec76117cc687c274636077abc437cb70a029",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.1. RSA-FDH-VRF-SHA256",
      "section_title": true,
      "ja": "A.1. RSA-FDH-VRF-SHA256"
    },
    {
      "indent": 3,
      "text": "Example 1, using the 2048-bit key above:",
      "ja": "例1、上記の2048ビットキーを使用します。"
    },
    {
      "indent": 3,
      "text": "alpha =  (the empty string)\nEM = 092ea69ca4f5630d4bd1012805ad23528a5f44c040829b4a0208491913ee3\n9711889bce5347765072efb0b7f8ad9798c830085d9babe10c29f1a649dbb9a64c\n93a8cdaa325d37814faa15a1071ba81c39275f3cd66ce70fd21ee3acc7ac127c5d\ne8f2a816b05aff19e4e63451cfe51fef059b2547302387449b4df1ab8eaa5bfc84\ndbbc5edf3b07eb8fe3fe2a93858bd0d55d6f0686f2eb449ed4c609b3083de04b49\nd409a425509d89d282de806a6ce66892edc30337f780b15c7695b26383516f1fc1\n8f7eab52557c654467600e2e272ef41e7e4a060b42f7533bae603a7fa50f497a64\na1508b93826d99643a2001d1c958a7a06da0370668634d678a5de\npi = 14234ff8a9487e1b36a23086e258135b8a8a7ff2e23f19c0dfeca0c0a943f\n119ebd336fdc292ef67b56e32ba06f9941893754a8b97c82f68974b2b34c17f6d4\n3bfd55eb110cd7ea3452d59a24e4ddb8d4cdf040c814e22e3537ca09c2e2dc5dd8\nea281e6492ad335378f9f437eed30c51eeeee66ef14efb4000c75c802e9c5a6bb8\n039c0258d4347981159d0ef6990b5e9c8ac2fb03915d7ff1ffa0626e2e11714a63\n342e59124c1fcea8e2816c1d9a7751feaaa66cf6c82cd3c58ffde66460d98246ab\n358cc33baefae4dfb0d191e9b6d6c0e3f92c35200408925dc8bef39b78d1259f81\n63a5003a693555f05290ef2e68345f27c6e2a8847c5c919d92e7505\nbeta =\n79f0615d4677fb72571889453644013f1a31b08d222e3cee349d64ce1c41045a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 2, using the 3072-bit key above:",
      "ja": "Example 2、上記の3072ビットキーを使用した場合："
    },
    {
      "indent": 3,
      "text": "alpha = 74657374 (4 bytes; ASCII \"test\")\nEM = 20a059b7f7034d0d7696c63328cbbd4b40f7c656a632b4129915018fe6c5d\nee8b5bde68ec2a5a78b1ca8483386e3a1a0fa07b4d329ea55facc3145c663ca90d\nf5ae46c903211a21bf908dc9a33bd09410cc09c7b4de5fbc79de3413bc80bccf2d\n3aca2fc9c60c776619849ed3e704057ac3d5deacff845d5bc8084ac730c19a1466\n8e53b5b8b90446b2272eaf59cdf985a7804c7b91cea1ce2582099b7b0f20163b11\nd23110939dd62081b5aa46c62db76b2ac28473d2488970d480bdd8bef8cae9e812\n74fe3f9925b012c1b55cba8c4291ec7433223cb872e422bb9e0d3775670d587e40\n3660ff440a9c11a18a488abc716ae36840b2ef5b0db4a90d88f91d79536cef378b\nf8e76d173288e26241df522a3cf6bece49c960e43a2d93e7bed10b90580c5b3aff\n056507b4ef27368579832cb4aeecc99c2d8ba402117457df5ae0ed28068ef8b2e0\nd4582f8edacfcad02c83bfab778460b979e9e984827bbefe2b544c0f3ed715dde6\ndc1d7fc7c0f1f87d78aed8e148004b9f62e0321214c7c\npi = 69f6042d400dfad4bdb9974fb73d12ec7823c6632df6b0a97ebc14d8a443f\n74e1eb1a99b37204ba5c7e53bdaf7e3e3fae9efe47cc01d0b061585c8d757ecf00\n663b3e1bd447d55b6ebd066b814a8d9c4434b224e9cb053a1fd038a58f3bf6b0c7\n5b6f48f3c8d1ca398a730c133f86f244655f24c445324fdacd291d6d907f93efb2\n4b59e509f2f370392f5e262fc106292792352d93800f0a1e3a389786619a622f60\n05cab78ea5f0b5b7ca91ad2a9c6c34fc4a3f9b0332b99e907ffa7f750cdc8342e1\n2da78f13ad49953bae1751c983ce3cd3335288ac856f85057a7f05acba6465a1c6\n901ba30bc65b79fb7a847c42a5b4942d600ef316030f2ccafbc6f2e1ff0b46fb5c\n8517cd98c93f81acf370cfdab559bb4270d07db5466e2342d56c476089f4738404\n34cbcdbd1853b487a6df346208d12c17a48fe50b73b96f640a9761f570a516f615\n7432b83dd18a1d05cc27b6f283a02fcfda147cf1471772e469961004bde7fa1585\n7e7bf97b5a83c33fddbd9f4b2e2488f4ed5f7463c93f30b\nbeta =\nbfe966f3fabde6f38a2792ad59bc836bbca39de6eff64f15a42886deff6dfcc5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 3, using the 4096-bit key above:",
      "ja": "例3、上記の4096ビットキーを使用します。"
    },
    {
      "indent": 3,
      "text": "alpha = 73616d706c65 (6 bytes; ASCII \"sample\")\nEM = 17524fa1710b2f8a04e55da403b9b287b99a47afe9b81d3421482e3959b73\nb4d4d4f4b52243ff2bfd2d29b1f030b521d0699065faa2b8903cca2b24cff42956\n1234fcbd7bcccdac61b7dcb7bc61cd857287b4b42357adbd2fc83ecfc0d5bc199e\n1f6e298b5e470bfc540bc85e933b02035792d65d861096dc03f048cae51c9adc6c\n1ec09e7f5e595681b3d3976d94ba1a65c83c7e82503db5478d3d91b2e00a0f24e7\nffee1faed68aa62ad7ba4b2912ceb636064766f0535d3ca1369760d8edebc3c8d7\nf5b4de784b644b59e44e24e436298cc33a3cd0f676d6fa0b76ca3b9b11aa68e078\n9e83bd27b3af08518b9a5eb5f34f4953a79dc25c1285b20fa73e558dd99638eb51\nbf89c80d7989f6e925d8ca5ed1d3f29cc1e1065400e4abbdbcf898791be12c5ae2\n5661bf7de58a4cb6608c9a4dcc18150638068bb6452b25589ae0a943a67f024dd4\nb5d9e7940c01886f798316156e5771c19457f9104618e271ae7863b65fd07f87fc\nd7862690115ce2d963eeac60f78b47c037d6ed3000b43d8149cee08df10a97158e\ne1daaf0a3963d23fb6ab0615891734e3039417d8ce03bfc18920c832a40385de95\nd99b546b4bd24ecbfb2e75e9158ae1769bcff444990f54aa40e6a14e0aca52df00\n062afbf81f6ce8193c53f8d26ac71324fc1db878379178abd695cf04a0fae3432d\n1efffa73bba15b4e81fbaf598146a0c3edafc\npi = 745cc4b6cb75b925194374cdf91b498e8d687c5d9cae1eb5352446c554c2c\n43ac4aa3e2db5cf5e366df635ce156a277ebdbe78c5598588c98257069253127e5\n7c9735b498f2939f14e1d019795cbd74cee2693acda2666624f174e8f666494aa1\n2641bce0677acd20e5552d2690117bddb38678a18acdc380bd9d93f3b10960f9be\n0c141fc14f5f30da324ff14020cb5b8aed9fbca3fc44b4973d8e5527bd81f5ae5d\na67e5cc995abd1f7f9cdd3fa89b243fd4d5d5086ddb4eed77a2851fda1d4463f5e\ne037a4015aa40c420c2e609d5d0da4ef4a1622131022bdd9c9dc26d177b392663e\na42050ef485fe9d53a8d28d84b82a21101bed5b213c82b578ce7c9c6f7c1bf9eca\n3c248ace9f8835f3850158749111ce1a3bdf5766add72a95a47c8866a4817c42c5\ncbd85d7bef52afab567e564f6625be9e04be6f7da012af68e6623ce4f29c692ba0\nb5f7665bb435a2168bd3b88aae0c6168bb87ea6977f35bb5ad833d96dd14d340f2\na67b241b01fd8caf415842fd0a9dd5f4ccf4e70f15efdb85332e1df2bb186be15f\n7195176435e01bfd00592710023c3a88ac0eea7189b32296f865a310375111a5f1\n1b74d0c74b98dfe4c41ccbe695ea801ba47f37b878c1ed0fff8302705b63c89120\n9ea63defa892969e015a86d97945189444524e5fb660f2b9d1dce337a12e0d003e\na6262ca3194515cc3aa10b1a03ac9dd6995b54d\nbeta =\nb663c5f90da1c12cd5d0e6d049679459e6f79f9fe16bc8b8e7e4d64d66500bd9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. RSA-FDH-VRF-SHA384",
      "section_title": true,
      "ja": "A.2. RSA-FDH-VRF-SHA384"
    },
    {
      "indent": 3,
      "text": "Example 4, using the 2048-bit key above:",
      "ja": "Example 4、上記の2048ビットキーを使用した場合："
    },
    {
      "indent": 3,
      "text": "alpha =  (the empty string)\nEM = 1fa5c0079423d46edb63a833abb2e6ecfd5f39d1f2bd68fc666274d9e8ed8\nea8a13411126861167a4ba1d014d5ae213372de6bb4227b12e68e16e13ce108536\nacb25f7219c49388f757219716fcb74eb0245b826c7e47ca793864885684b7673e\n2f8579f26e78d63a940eacb23bf7619290cb5cd20859482c410fbd6d83a61f8940\n866f512be7ac041fc23c3ee71d918ec994f3efa62f4f1f44eaa29f5b37a1e93e24\n73d8677fcbec312838379a3e05899ce44227c0c428fbd7d4f2d0b46cfde7254e39\n67b220f8661f5dfbce7a3bf19364f522914478cead3eff0f0e02d166c251319bcf\n86701af1c48436f49ceac990f52940f7da6ac6f5fdafa5c55dc77\npi = cffe6067bd9a1285dc1e8e543e8582c1250407cbfbcb2d01c4ddbc0d4ecb5\nedeb721fb33147cf95f3084f7ce611f9877814770b14b8a671abc7ff085cf5cbe9\n1e72d17f076d62db478d4758412a4e4b77a5591dc32b764a501d27e34e56189ba7\n347a96f141ed1290f8ef7c4ce4009a9aba0715cbd0148721ea72bce00a22e59460\n421a21e4d121fc0b4eda62479d93724afae7556abe66326487be38cfb795ac1968\nc33a3890f2d8c0f7dfbe88bc76f16cbfd2b0f7ee8663abfd7b789caa5f6c77dd1c\na991c9a9cc532f7550ad6184c8ece12ca4bea7e67f32405416a1f83245b09d06e7\nb4214157fb444be12a2eddc4381678f2b862fb240fcedd2da7ffcb3\nbeta = dc37e83f8de0e990abada5096a05ca74754cfe7fe8e46b831e241009194\n15415dcd5a305f5fb8195713cebc78649c8d1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 5, using the 3072-bit key above:",
      "ja": "上記の3072ビットキーを使用した例5："
    },
    {
      "indent": 3,
      "text": "alpha = 74657374 (4 bytes; ASCII \"test\")\nEM = fa2fd7c735c961b43b01c005faefc4e39505ede3914076d4dee40d52acf72\n7de1782386ad6e9e07faf7666c8f45fde93b024d97c40651b957cfcccc42b8596a\n68a5495c02313ed9ecbb705ab0689c38b9e57af035189e377ad50b4704004c2a97\n3d9f7554204b03e8b925a973d41a9c3432246eb2eab2f729f03d3a63c9c38c0cc2\nbaa440ed5e2d61644405e4b5c1acaac85d8de75a4de00419a478e6c44a97b3e898\n75c318400ce8d75b84c416ffd501ba78dd3203f21c6610fcaa4d8fc94f45e80dc6\n5b7e48967199e7acdb18d82413b7018192a6fa2da5d6838adb8e6139f8d12abcce\n7d5fd20cfa031c4971e563d4863d498591dc652a937db5e0bfd68535e3c9db9611\n8874287c2291a5d3b29aa142795e60f1ade2c8c4d627ee678b652f5fded61f9a60\nd2fa9cf5fb5e6a7fd63d81c91ea2269388f0a96fae77da0957695779385c757489\n56972ab1cb5e19ad3cc6a357b9ffd368ca985dd9c0e53dd42aff5985f7a234af96\nad9e34e459a958b808e858f6d7be2e964c33cefad9660\npi = 22c9278e7171183cf6a3ce108f0400e308a9177c39a171f77777c106c966e\nb041824ce43fa56c5c77576646dd110e0b5d7f838bd5b1d1bf2c1feb1520397dd5\n2d3cea6dbb49d786aa3bf3f5235e7692e583d290c7192102a6e0cb64f5229a326d\n4d00267fd75aae9687167ea0d3d450b2d63519ad605e64c77438728a190a129b11\n63939a5b7b0721b8d81efbf99a96944f63bf80ecc932fe40402d67c3e099a317cd\n1d13ac6947096308050ea6dad18fdb0958ae565d07d29e619673798f52b8d1dfdb\nf29b4641324ea6db5b9f35870acde7bf68e0829534d1c1f43ca9a16861efd82fb8\n83e35d581f613d2dfbc89d01a84fdf081a3a850f2e865188cd995857222160c547\n80dc310a6ec100b9bac30f3af92e641360cad8dc255b56fa28e88ffcbef8ebe6ba\n8557e4ec44a7d0ebef882ade36db0d89be71ecaa2b35026c9d328d2384b54ae68d\ne2ea70160ddde9aced5a8d896590fc185b408732cc04a249eff27501594902bf3a\nf4a3743c4da50c5d62a74746007dedb8358ecfef78c75ab\nbeta = 5bdf742667ad10080f4ca573ec66f751e82e4077d0db1b281df421af68d\n39412e70362dc5101b4b46e1e453eea7e0989",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 6, using the 4096-bit key above:",
      "ja": "Example 6、上記の4096ビットキーを使用した場合："
    },
    {
      "indent": 3,
      "text": "alpha = 73616d706c65 (6 bytes; ASCII \"sample\")\nEM = 1b1d2f330ee20b9b1754f5e6ee4126cf03ea2c7f4e8c52d96111da7f99509\n042428ec2f2eafdf41716c04a9976a26df77b3d4cea8b10b216e7786fb49e923d9\n84a2ee13ad82b95783b68fcf3444b65d1353619602ae06e392dc030be105d4cebc\n6ff8a647b79115357833bd5312b9d3f0df1a307e782ff4db8de0eb16259d6bff2f\n57b3dd60a57693d607c42013cbcfc140a77d4a651492854afbacca377ed6729d1c\nbe72999a62a96190fb630e5abc54d5cbe93254426df4e2315dbc777360ffb2401b\n3dedbed1acacf4b3a63b5ff8e5ab6c0f8ffd9e2a34fffd68a8a593c64de2660dce\ndaaab13cd42ebf5720d49f3120b01f45f29d1f465e995b148c9266aa97793a9da2\nf38831d00f95f9688b1c50b52a4cbcc14f8287db822381cdddf609c9c178286b1b\nc2f94d7ef4d5ceb1293dd7b0fac16d1b3a8b2a7fcc454e52efd2de5a799397fd55\na909641fa775463f4808b520c3ebe0f94e2765f8538d91a4f53bb746e7d5eaf55b\n3876503760f5c015f9e52bc54bdfc9632028db5e88b7dc0b1e9f1661d0a9b3574e\n46311de8ef6278c4c14f68375763e5df0d4cf221a4c3e84493ed0c36984c172d87\nb513857af4b6c10174dea9db6464e2bab210aa492987f0255d2c5588b1c79769da\n03b62f691d5c4e5fac65505c317bf96b4f70e97c002aa0a032b02e48ee3aead570\n3bde3186ce138f29ba36219fd3558af417945\npi = 89d801e364fd48c3b8672e7d7abd8a2a1e5bd36bb1e38af5aaefa2f01cde6\n86fa2e33f88fdcc8eb3babcf1c66cbbf7dcddb614041813990787be5feabe86bbe\nc373d2cbf7c080caa0e37a339d5de1d1455de28f9bef76cd72500c669e9cab4599\nb55dc155d9dd5810174c170f646d3b0b459347c17347c0281eecf5055cf887d6bd\n0a2c962c77d5ff9355a53cea64c34ea0888110ec4eb32da69022e293a8843d4c06\nc9d6e020c594335720467a8337c6a939fb2c5d710f7bdab48a52f4e7483dae062c\n1b9f66f7c9038ba9ceef3d61cb4cc004319c94a267a2425b5f042cd7f1a17922d6\n596a88a6fefaef41fc87742f2badee7d7613179589b4d02611ac8fd7895d926f48\n4f79542cdf7f034dd536c9596da2f588ac9840f6bb05875bd17107e7458cc5ea36\n8a7699fd60c35b54253a718c26cf518712be9d86213b2c6bddd0b7dd169f9240e7\n7bfc44223675454f9c5596ad2e6e607ea65011a721ecbfa993172ae372ae874377\n9b33278d25e11ced77b14bc481fce60e4fc10a8a211d8b359906509d6830c653d9\n1c1a86865219db43f62c70ac6780644d2bd73c5c256527a3eaefaebaf1f2207324\n17e17dbf598636616f70f2088969ac796a853dc8a5f270a1c505797e83d1675e4f\n40b59c150ca06c49bb0967a2e0c7e74eff9e182d0f7bb6f54f68fe788b89d2191c\n87bbf7f3927978449c2174baa581dc64a9c58ed\nbeta = 8ec4d150788513c85eea3490d1a1ee1b7a397602d3f9c8b467527f09fab\n5252e539f82e8002825608295ebbba19644dd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. RSA-FDH-VRF-SHA512",
      "section_title": true,
      "ja": "A.3. RSA-FDH-VRF-SHA512"
    },
    {
      "indent": 3,
      "text": "Example 7, using the 2048-bit key above:",
      "ja": "Example 7、上記の2048ビットキーを使用した場合："
    },
    {
      "indent": 3,
      "text": "alpha =  (the empty string)\nEM = 7b08a7fff4e5d8fd4978ac5a0ddf48537a2bb3f952dcdc00affb25d747b40\n85c29c68dddaa87378db32396219ce784acebe70699286318f42794927f546de5d\n85bbefd80a02c3aa714fc17090baa0d0f7fb504e1af0b79ea02d41dc0bf576b8f2\n1472dd4c55f96bd64772d3ebd0347abe74b9fdf35b754d0405e42ceb0e290fdd91\nef766a3e27ff59cd86572d15274f6fd49400ec4d126145f3cae200d67d5d108999\n61658ece7dcbf41f1cca63f8b50399955416a1f55e0af116fac2a9fd1f2dc0085e\n6ad6c1c4bc12d9308d9a030c3e2ea7f037d1c98beb23d43d67a97e5bf52382b8e8\n90c5967ab42f2010cac985d3a52fe726045746d4ffef901127646\npi = a280db108df5ad6ac1bed67efbc5c6fc6da0d301b9c0b41d26e379cd223c6\n13c59d52c987e4baaa6de4de2103284ddd56aa0b662dfe8faa8f6a503b83b7c81f\n481e23a08761d49a151ada1d9daa132138bbd6f80204c7fa87716b120df957224f\n92b32a3a0f96c3b209080c408618a92382ab5575f10a57c24ee0ffd01d6b822dc3\n6b27600bf36aafadf0a01e65aa6a0f2fc1a9dcd207d9bf5181a9ca69120e154108\n00a26efd3ce619349592eeff7b1851737bd033a83f88744ddd3d3e782efb6d2438\nffda22ddcaa32c821c6730a05d5bdab88c354809d615884744ff10276496bee70b\n62feb6ed07a3948823e9ee2a453dbcd4450192c9de0128adfc7e147\nbeta = 808ca1f8f66a48118aacb011394bd4e5f0011c89ca913943d467b81cc5c\n43086e588abdde061c3ee30f4c15b2a6b51ad0ada42c0737fd7b2206fb43d35c8e\nd22",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 8, using the 3072-bit key above:",
      "ja": "上記の3072ビットキーを使用したExample 8："
    },
    {
      "indent": 3,
      "text": "alpha = 74657374 (4 bytes; ASCII \"test\")\nEM = 803b6618f0ad47da2db309b1f57807a286500020c9e2b1427ebd9fff1104e\n3aa8a69210441cd58344bd810c4900825c84b1e5e36825f1e397df54c4419f8525\nd9a09a49e7fedc18b8d906cbd9ea831c55f2aaa0461e19ddd6ec9d14dafa1fcf49\nb77458a65427b7f060bc7425538e5d3af1813752cb452d0b098514110399734d1f\n55870c65ea3e799e6d9024a9e2fb95883e580578811a8c7d34b18f8fabc6c05fb9\n697335fcf2cb1b7576ee7a39dcff129e1f142106c45f30a8ae62370f576d1d1d8c\n6307fccfe25cb431f348dea81b6b7e6307bbefda2a0b23036653a612226392a573\nb7d62e28f9fecc7f4be0bf0a3049ce8ed276b34130faa943aeeedf962b42a3fc6c\n881bbf9a62039e9c0850f1393a2a02c6848d06c3520e086541d8af99ea3ef9f9da\n2e3b2bd3172682a47e5965899bc576b66e29a0b8dcf06871202a1a4e7f2ff19bdd\n9eac2241129a73d7d01303b80372ac62a0d5b6bfd1d7119e561ace229cd53d2c99\n63d6127b9ade16dce4b07d1cd89247ffc438811dc8b3c\npi = 1aa828e0a751074fed2fa776fd29336a84987c064eeebcd3a8129fb688b47\neb7109987d01db0c3624ba7cc75e2f1ad60f5e204a250a329048bc34df34d41bfe\nea6651774d249ff9fc29aeabdf524400527aa1c4100b1af86b2dcc2e7aecc77f38\n6b80f29ccd807cb705b5057431832dafe56733a1e7bfcba1d052a26d1a8512f297\nb5abad5afd64fbcf21b57531a9b2c8217c0d9f1c875c196d998f61e8017f6b6ebe\n7317545ed390e18305bc96abb1514ec271963d02bed91ccf029d022189f84bac8c\nfa216da54e39919118348dfea6f4f6532b49da7820ee2a21f42b762e107722ad0a\nbf62271e0640d6b1c4d1a39b94ebd74b4283de2d6550cbdb1f29cac51671e9c8fc\n0ea0fdbb082a14a221e0531615f2bcfba0d70e99e4997cb00f81fcab2b95566322\n0234a5e90f29bd08e6fa50dd92770d9e514e0f9eb27aee634877bcea681ffd7da2\nb5be2f80c1dde1243b17ac726401cf961c5ce06640eb93352402c1ebc59c92188c\n511b375d63124846b46017fe36dc13fc2d34dbd80b312e0\nbeta = 9202b6715b7921c5eb35572ed9ebb85848d3345efadd665049ce889be46\n322586d4177864c9179468473518c6b6ac2e9c85ae5ee5fcd3c0d8e6d4d8f18be6\n238",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 9, using the 4096-bit key above:",
      "ja": "例9、上記の4096ビットキーを使用します。"
    },
    {
      "indent": 3,
      "text": "alpha = 73616d706c65 (6 bytes; ASCII \"sample\")\nEM = 289607894786ccf223b1e758232f3402aa50cd48bca3d2bd64b2ea9b4a69d\nc91756a42b2c1feaaa777763b9b7c91888c580433ac85f5fbb360f129ecee739f6\n9b560657687d38f7d43c84f6605005c38f56c91310eff27bae49b14d8a36542d69\nb70efca8637b845be0f029c085a7b6aad6ca0eb65fffdf8d55d9538d3b54044ebb\nc26e092b2f3ddaece7aa5b4b234ec848bfdc72a4ecdc10c66fb845cfc5ad39756e\n7f26007cea0ebf1e878636f4e39308fe7a317a9b7e90051536ac028bc1a2ec200a\n5dad0e3b74717bd9e7ea620919e315799e0fea7b0895fcbc0b95686b2495dc23e3\ncd56a16652b0df0dbd3ca8a6c96b13973a0c31a5541e211229da8a56e588a616c7\n21baab8e2d30313008c2374887f147598468b378bf8949ab1165b9348245d0a6a5\nf795918fce05f0d072f81f78c7224e7f1c4684877d714f231d5775c88759086121\n2eae2d174761158ac7d653b18f0d4b71362c0eb8a67bed1a48a4e7dc739b2b4469\n4514cae7f192d236afb1ab2409f24dfa94a2d705d0087860d844ba04564bb6733c\na20089417d74eaed86d7e68ced681e9d88a9c3d7e6a33927592820cb9a38d45393\n32e509296489e54cd6b8495f100c36debe1f719578b15e8a99cc8febc3212e8147\n8aeca616a5230ae84e7079f52aefb2ec2a97157fb5d60e1ddcf03b134be2c93ffb\na41d5d068750adc8df07e5a264640f7e586bd\npi = 17d7635cac33b0b72ea1c0afb1f681d1a96c5073ed9f88ed8bb54eb428d7b\n2db4ee3355eee512ddc7af50694b37fd389f990278e22095b2582c78c4ed6070b0\nc7382b0308b6d546141a9b0d6ebb3af97abd93c16a5d34a2d805d8aa444fed2297\nd017571a693d221fda094d40500ab9b203d397a7543e72b26b06e561d49696e01d\neebfed58b46611dd5a346e227d7519f8ffd1dc76a172c9f7f355c3e7e5ee7773ed\nab00a22af5c39367f3779da68ce6da9f8a594f5f6149012501181653572fe5549a\n9c2bf36148b3bdc94feaedd600727fe5c11b7dcbfd73002ae08061cb4b84ba47f1\nbf8c5d46bc2acb7cb4964a6dca7eedc396e663a64121d93dade8b83cea09d76653\ncca1a8d20d6b7323a890651dc575025ba1be02d08c5946f50cde438339b06e8633\n198da0d467d2cac7d98ae62dd71353f6fb19aa9daac851d0ce237b21db93b91e51\n8d5c1ac36cdf874975deb7aab3942acc3980f221f33ad1254eb8ac3138e087d045\nc4746e0b7eedcaf2a1a173559783eba8691555c1b0e468f8efe6501679b760038e\nd6fc9ce6aa5ae24b3f1178713793c8e5ee96035a2f0ee02e2d10ac098613358d3c\nff10f4dff3437f2a48252c5d6805288fbd7ee05356f80db12aaeabf6638677abf5\nb8eb2376fb76861cf1b817d5a0b878dae6beac44f078f37d982d941a77582a7778\n4fabd632e28d664d9f705f31e24d1ca623dfac7\nbeta = 6026f6defaf534cc79ce7c1b0370fb53e4825d2d44f549f696e06d693c3\n9e852e21a5e3b6ff093618dd277b40678957e1b90e8e6ca742efed30dc309b3b24\n2b8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Test Vectors for the ECVRF Ciphersuites",
      "section_title": true,
      "ja": "付録B. ECVRFサイファースイートのテストベクトル"
    },
    {
      "indent": 3,
      "text": "The test vectors in this section were generated using code provided at <https://github.com/reyzin/ecvrf>.",
      "ja": "このセクションのテストベクトルは、<https://github.com/reyzin/ecvrf> で提供されているコードを使用して生成されました。"
    },
    {
      "indent": 0,
      "text": "B.1. ECVRF-P256-SHA256-TAI",
      "section_title": true,
      "ja": "B.1. ECVRF-P256-SHA256-TAI"
    },
    {
      "indent": 3,
      "text": "The example secret keys and messages in Examples 10 and 11 are taken from Appendix A.2.5 of [RFC6979].",
      "ja": "Example 10および11の秘密鍵とメッセージは、[RFC6979]の付録A.2.5から取られています。"
    },
    {
      "indent": 3,
      "text": "Example 10:",
      "ja": "Example 10:"
    },
    {
      "indent": 3,
      "text": "SK = x =\nc9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\nPK =\n0360fed4ba255a9d31c961eb74c6356d68c049b8923b61fa6ce669622e60f29fb6\nalpha = 73616d706c65 (6 bytes; ASCII \"sample\")\ntry_and_increment succeeded on ctr = 1\nH =\n0272a877532e9ac193aff4401234266f59900a4a9e3fc3cfc6a4b7e467a15d06d4\nk =\n0d90591273453d2dc67312d39914e3a93e194ab47a58cd598886897076986f77\nU = k*B =\n02bb6a034f67643c6183c10f8b41dc4babf88bff154b674e377d90bde009c21672\nV = k*H =\n02893ebee7af9a0faa6da810da8a91f9d50e1dc071240c9706726820ff919e8394\npi = 035b5c726e8c0e2c488a107c600578ee75cb702343c153cb1eb8dec77f4b5\n071b4a53f0a46f018bc2c56e58d383f2305e0975972c26feea0eb122fe7893c15a\nf376b33edf7de17c6ea056d4d82de6bc02f\nbeta =\na3ad7b0ef73d8fc6655053ea22f9bede8c743f08bbed3d38821f0e16474b505e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 11:",
      "ja": "Example 11:"
    },
    {
      "indent": 3,
      "text": "SK = x =\nc9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\nPK =\n0360fed4ba255a9d31c961eb74c6356d68c049b8923b61fa6ce669622e60f29fb6\nalpha = 74657374 (4 bytes; ASCII \"test\")\ntry_and_increment succeeded on ctr = 3\nH =\n02173119b4fff5e6f8afed4868a29fe8920f1b54c2cf89cc7b301d0d473de6b974\nk =\n5852353a868bdce26938cde1826723e58bf8cb06dd2fed475213ea6f3b12e961\nU = k*B =\n022779a2cafcb65414c4a04a4b4d2adf4c50395f57995e89e6de823250d91bc48e\nV = k*H =\n033b4a14731672e82339f03b45ff6b5b13dee7ada38c9bf1d6f8f61e2ce5921119\npi = 034dac60aba508ba0c01aa9be80377ebd7562c4a52d74722e0abae7dc3080\nddb56c19e067b15a8a8174905b13617804534214f935b94c2287f797e393eb0816\n969d864f37625b443f30f1a5a33f2b3c854\nbeta =\na284f94ceec2ff4b3794629da7cbafa49121972671b466cab4ce170aa365f26d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The example secret key in Example 12 is taken from Appendix L.4.2 of [ANSI.X9-62-2005].",
      "ja": "Example 12の例の秘密鍵は、[ANSI.X9-62-2005]の付録L.4.2から取得されています。"
    },
    {
      "indent": 3,
      "text": "Example 12:",
      "ja": "Example 12:"
    },
    {
      "indent": 3,
      "text": "SK = x =\n2ca1411a41b17b24cc8c3b089cfd033f1920202a6c0de8abb97df1498d50d2c8\nPK =\n03596375e6ce57e0f20294fc46bdfcfd19a39f8161b58695b3ec5b3d16427c274d\nalpha = 4578616d706c65207573696e67204543445341206b65792066726f6d20\n417070656e646978204c2e342e32206f6620414e53492e58392d36322d32303035\n(62 bytes; ASCII \"Example using ECDSA key from Appendix L.4.2 of\nANSI.X9-62-2005\")\ntry_and_increment succeeded on ctr = 1\nH =\n0258055c26c4b01d01c00fb57567955f7d39cd6f6e85fd37c58f696cc6b7aa761d\nk =\n5689e2e08e1110b4dda293ac21667eac6db5de4a46a519c73d533f69be2f4da3\nU = k*B =\n020f465cd0ec74d2e23af0abde4c07e866ae4e5138bded5dd1196b8843f380db84\nV = k*H =\n036cb6f811428fc4904370b86c488f60c280fa5b496d2f34ff8772f60ed24b2d1d\npi = 03d03398bf53aa23831d7d1b2937e005fb0062cbefa06796579f2a1fc7e7b\n8c667d091c00b0f5c3619d10ecea44363b5a599cadc5b2957e223fec62e81f7b48\n25fc799a771a3d7334b9186bdbee87316b1\nbeta =\n90871e06da5caa39a3c61578ebb844de8635e27ac0b13e829997d0d95dd98c19",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "B.2. ECVRF-P256-SHA256-SSWU",
      "section_title": true,
      "ja": "B.2. ECVRF-P256-SHA256-SSWU"
    },
    {
      "indent": 3,
      "text": "The example secret keys and messages in Examples 13 and 14 are taken from Appendix A.2.5 of [RFC6979].",
      "ja": "例13と14の秘密鍵とメッセージは、[RFC6979]の付録A.2.5から取られています。"
    },
    {
      "indent": 3,
      "text": "Example 13:",
      "ja": "Example 13:"
    },
    {
      "indent": 3,
      "text": "SK = x =\nc9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\nPK =\n0360fed4ba255a9d31c961eb74c6356d68c049b8923b61fa6ce669622e60f29fb6\nalpha = 73616d706c65 (6 bytes; ASCII \"sample\")\nIn SSWU: uniform_bytes = 5024e98d6067dec313af09ff0cbe78218324a645c\n2a4b0aae2453f6fe91aa3bd9471f7b4a5fbf128e4b53f0c59603f7e\nIn SSWU: u =\ndf565615a2372e8b31b8771f7503bafc144e48b05688b97958cc27ce29a8d810\nIn SSWU: x1 =\ne7e39eb8a4c982426fcff629e55a3e13516cfeb62c02c369b1e750316f5e94eb\nIn SSWU: gx1 is a nonsquare\nH =\n02b31973e872d4a097e2cfae9f37af9f9d73428fde74ac537dda93b5f18dbc5842\nk =\ne92820035a0a8afe132826c6312662b6ea733fc1a0d33737945016de54d02dd8\nU = k*B =\n031490f49d0355ffcdf66e40df788bee93861917ee713acff79be40d20cc91a30a\nV = k*H =\n03701df0228138fa3d16612c0d720389326b3265151bc7ac696ea4d0591cd053e3\npi = 0331d984ca8fece9cbb9a144c0d53df3c4c7a33080c1e02ddb1a96a365394\nc7888782fffde7b842c38c20c08de6ec6c2e7027a97000f2c9fa4425d5c03e639f\nb48fde58114d755985498d7eb234cf4aed9\nbeta =\n21e66dc9747430f17ed9efeda054cf4a264b097b9e8956a1787526ed00dc664b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 14:",
      "ja": "Example 14:"
    },
    {
      "indent": 3,
      "text": "SK = x =\nc9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\nPK =\n0360fed4ba255a9d31c961eb74c6356d68c049b8923b61fa6ce669622e60f29fb6\nalpha = 74657374 (4 bytes; ASCII \"test\")\nIn SSWU: uniform_bytes = 910cc66d84a57985a1d15843dad83fd9138a109af\nb243b7fa5d64d766ec9ca3894fdcf46ebeb21a3972eb452a4232fd3\nIn SSWU: u =\nd8b0107f7e7aa36390240d834852f8703a6dc407019d6196bda5861b8fc00181\nIn SSWU: x1 =\nccc747fa7318b9486ce4044adbbecaa084c27be6eda88eb7b7f3d688fd0968c7\nIn SSWU: gx1 is a square\nH =\n03ccc747fa7318b9486ce4044adbbecaa084c27be6eda88eb7b7f3d688fd0968c7\nk =\nfebc3451ea7639fde2cf41ffd03f463124ecb3b5a79913db1ed069147c8a7dea\nU = k*B =\n031200f9900e96f811d1247d353573f47e0d9da601fc992566234fc1a5b37749ae\nV = k*H =\n02d3715dcfee136c7ae50e95ffca76f4ca6c29ddfb92a39c31a0d48e75c6605cd1\npi = 03f814c0455d32dbc75ad3aea08c7e2db31748e12802db23640203aebf1fa\n8db2743aad348a3006dc1caad7da28687320740bf7dd78fe13c298867321ce3b36\nb79ec3093b7083ac5e4daf3465f9f43c627\nbeta =\n8e7185d2b420e4f4681f44ce313a26d05613323837da09a69f00491a83ad25dd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The example secret key in Example 15 is taken from Appendix L.4.2 of [ANSI.X9-62-2005].",
      "ja": "Example 15の例の秘密鍵は、[ANSI.X9-62-2005]の付録L.4.2から取得されています。"
    },
    {
      "indent": 3,
      "text": "Example 15:",
      "ja": "Example 15:"
    },
    {
      "indent": 3,
      "text": "SK = x =\n2ca1411a41b17b24cc8c3b089cfd033f1920202a6c0de8abb97df1498d50d2c8\nPK =\n03596375e6ce57e0f20294fc46bdfcfd19a39f8161b58695b3ec5b3d16427c274d\nalpha = 4578616d706c65207573696e67204543445341206b65792066726f6d20\n417070656e646978204c2e342e32206f6620414e53492e58392d36322d32303035\n(62 bytes; ASCII \"Example using ECDSA key from Appendix L.4.2 of\nANSI.X9-62-2005\")\nIn SSWU: uniform_bytes = 9b81d55a242d3e8438d3bcfb1bee985a87fd14480\n2c9268cf9adeee160e6e9ff765569797a0f701cb4316018de2e7dd4\nIn SSWU: u =\ne43c98c2ae06d13839fedb0303e5ee815896beda39be83fb11325b97976efdce\nIn SSWU: x1 =\nbe9e195a50f175d3563aed8dc2d9f513a5536c1e9aee1757d86c08d32d582a86\nIn SSWU: gx1 is a nonsquare\nH =\n022dd5150e5a2a24c66feab2f68532be1486e28e07f1b9a055cf38ccc16f6595ff\nk =\n8e29221f33564f3f66f858ba2b0c14766e1057adbd422c3e7d0d99d5e142b613\nU = k*B =\n03a8823ff9fd16bf879261c740b9c7792b77fee0830f21314117e441784667958d\nV = k*H =\n02d48fbb45921c755b73b25be2f23379e3ce69294f6cee9279815f57f4b422659d\npi = 039f8d9cdc162c89be2871cbcb1435144739431db7fab437ab7bc4e2651a9\ne99d5488405a11a6c7fc8defddd9e1573a563b7333aab4effe73ae9803274174c6\n59269fd39b53e133dcd9e0d24f01288de9a\nbeta =\n4fbadf33b42a5f42f23a6f89952d2e634a6e3810f15878b46ef1bb85a04fe95a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "B.3. ECVRF-EDWARDS25519-SHA512-TAI",
      "section_title": true,
      "ja": "B.3. ECVRF-EDWARDS25519-SHA512-TAI"
    },
    {
      "indent": 3,
      "text": "The example secret keys and messages in Examples 16, 17, and 18 are taken from Section 7.1 of [RFC8032].",
      "ja": "Example 16、17、および18の例の秘密鍵とメッセージは、[RFC8032]のセクション7.1から取られています。"
    },
    {
      "indent": 3,
      "text": "Example 16:",
      "ja": "Example 16:"
    },
    {
      "indent": 3,
      "text": "SK =\n9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60\nPK =\nd75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a\nalpha =  (the empty string)\nx =\n307c83864f2833cb427a2ef1c00a013cfdff2768d980c0a3a520f006904de94f\ntry_and_increment succeeded on ctr = 0\nH =\n91bbed02a99461df1ad4c6564a5f5d829d0b90cfc7903e7a5797bd658abf3318\nk_string = 7100f3d9eadb6dc4743b029736ff283f5be494128df128df2817106\nf345b8594b6d6da2d6fb0b4c0257eb337675d96eab49cf39e66cc2c9547c2bf8b2\na6afae4\nk =\n8a49edbd1492a8ee09766befe50a7d563051bf3406cbffc20a88def030730f0f\nU = k*B =\naef27c725be964c6a9bf4c45ca8e35df258c1878b838f37d9975523f09034071\nV = k*H =\n5016572f71466c646c119443455d6cb9b952f07d060ec8286d678615d55f954f\npi = 8657106690b5526245a92b003bb079ccd1a92130477671f6fc01ad16f26f7\n23f26f8a57ccaed74ee1b190bed1f479d9727d2d0f9b005a6e456a35d4fb0daab1\n268a1b0db10836d9826a528ca76567805\nbeta = 90cf1df3b703cce59e2a35b925d411164068269d7b2d29f3301c03dd757\n876ff66b71dda49d2de59d03450451af026798e8f81cd2e333de5cdf4f3e140fdd\n8ae",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 17:",
      "ja": "Example 17:"
    },
    {
      "indent": 3,
      "text": "SK =\n4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb\nPK =\n3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c\nalpha = 72 (1 byte)\nx =\n68bd9ed75882d52815a97585caf4790a7f6c6b3b7f821c5e259a24b02e502e51\ntry_and_increment succeeded on ctr = 1\nH =\n5b659fc3d4e9263fd9a4ed1d022d75eaacc20df5e09f9ea937502396598dc551\nk_string = 42589bbf0c485c3c91c1621bb4bfe04aed7be76ee48f9b00793b234\n2acb9c167cab856f9f9d4febc311330c20b0a8afd3743d05433e8be8d32522ecdc\n16cc5ce\nk =\nd8c3a66921444cb3427d5d989f9b315aa8ca3375e9ec4d52207711a1fdb44107\nU = k*B =\n1dcb0a4821a2c48bf53548228b7f170962988f6d12f5439f31987ef41f034ab3\nV = k*H =\nfd03c0bf498c752161bae4719105a074630a2aa5f200ff7b3995f7bfb1513423\npi = f3141cd382dc42909d19ec5110469e4feae18300e94f304590abdced48aed\n5933bf0864a62558b3ed7f2fea45c92a465301b3bbf5e3e54ddf2d935be3b67926\nda3ef39226bbc355bdc9850112c8f4b02\nbeta = eb4440665d3891d668e7e0fcaf587f1b4bd7fbfe99d0eb2211ccec90496\n310eb5e33821bc613efb94db5e5b54c70a848a0bef4553a41befc57663b56373a5\n031",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 18:",
      "ja": "Example 18:"
    },
    {
      "indent": 3,
      "text": "SK =\nc5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b4458f7\nPK =\nfc51cd8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025\nalpha = af82 (2 bytes)\nx =\n909a8b755ed902849023a55b15c23d11ba4d7f4ec5c2f51b1325a181991ea95c\ntry_and_increment succeeded on ctr = 0\nH =\nbf4339376f5542811de615e3313d2b36f6f53c0acfebb482159711201192576a\nk_string = 38b868c335ccda94a088428cbf3ec8bc7955bfaffe1f3bd2aa2c59f\nc31a0febc59d0e1af3715773ce11b3bbdd7aba8e3505d4b9de6f7e4a96e67e0d6b\nb6d6c3a\nk =\n5ffdbc72135d936014e8ab708585fda379405542b07e3bd2c0bd48437fbac60a\nU = k*B =\n2bae73e15a64042fcebf062abe7e432b2eca6744f3e8265bc38e009cd577ecd5\nV = k*H =\n88cba1cb0d4f9b649d9a86026b69de076724a93a65c349c988954f0961c5d506\npi = 9bc0f79119cc5604bf02d23b4caede71393cedfbb191434dd016d30177ccb\nf8096bb474e53895c362d8628ee9f9ea3c0e52c7a5c691b6c18c9979866568add7\na2d41b00b05081ed0f58ee5e31b3a970e\nbeta = 645427e5d00c62a23fb703732fa5d892940935942101e456ecca7bb217c\n61c452118fec1219202a0edcf038bb6373241578be7217ba85a2687f7a0310b2df\n19f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "B.4. ECVRF-EDWARDS25519-SHA512-ELL2",
      "section_title": true,
      "ja": "B.4. ECVRF-EDWARDS25519-SHA512-ELL2"
    },
    {
      "indent": 3,
      "text": "The example secret keys and messages in Examples 19, 20, and 21 are taken from Section 7.1 of [RFC8032].",
      "ja": "Example 19、20、および21の例の秘密キーとメッセージは、[RFC8032]のセクション7.1から取られています。"
    },
    {
      "indent": 3,
      "text": "Example 19:",
      "ja": "Example 19:"
    },
    {
      "indent": 3,
      "text": "SK =\n9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60\nPK =\nd75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a\nalpha =  (the empty string)\nx =\n307c83864f2833cb427a2ef1c00a013cfdff2768d980c0a3a520f006904de94f\nIn Elligator2: uniform_bytes = d620782a206d9de584b74e23ae5ee1db5ca\n5298b3fc527c4867f049dee6dd419b3674967bd614890f621c128d72269ae\nIn Elligator2: u =\n30f037b9745a57a9a2b8a68da81f397c39d46dee9d047f86c427c53f8b29a55c\nIn Elligator2: gx1 =\n8cb66318fb2cea01672d6c27a5ab662ae33220961607f69276080a56477b4a08\nIn Elligator2: gx1 is a square\nH =\nb8066ebbb706c72b64390324e4a3276f129569eab100c26b9f05011200c1bad9\nk_string = b5682049fee54fe2d519c9afff73bbfad724e69a82d5051496a4245\n8f817bed7a386f96b1a78e5736756192aeb1818a20efb336a205ffede351cfe88d\nab8d41c\nk =\n55cbb247af9b8372259a97b2cfec656d78868deb33b203d51b9961c364522400\nU = k*B =\n762f5c178b68f0cddcc1157918edf45ec334ac8e8286601a3256c3bbf858edd9\nV = k*H =\n4652eba1c4612e6fce762977a59420b451e12964adbe4fbecd58a7aeff5860af\npi = 7d9c633ffeee27349264cf5c667579fc583b4bda63ab71d001f89c10003ab\n46f14adf9a3cd8b8412d9038531e865c341cafa73589b023d14311c331a9ad15ff\n2fb37831e00f0acaa6d73bc9997b06501\nbeta = 9d574bf9b8302ec0fc1e21c3ec5368269527b87b462ce36dab2d14ccf80\nc53cccf6758f058c5b1c856b116388152bbe509ee3b9ecfe63d93c3b4346c1fbc6\nc54",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 20:",
      "ja": "Example 20:"
    },
    {
      "indent": 3,
      "text": "SK =\n4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb\nPK =\n3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c\nalpha = 72 (1 byte)\nx =\n68bd9ed75882d52815a97585caf4790a7f6c6b3b7f821c5e259a24b02e502e51\nIn Elligator2: uniform_bytes = 04ae20a9ad2a2330fb33318e376a2448bd7\n7bb99e81d126f47952b156590444a9225b84128b66a2f15b41294fa2f2f6d\nIn Elligator2: u =\n3092f033b16d4d5f74a3f7dc7091fe434b449065152b95476f121de899bb773d\nIn Elligator2: gx1 =\n25d7fe7f82456e7078e99fdb24ef2582b4608357cdba9c39a8d535a3fd98464d\nIn Elligator2: gx1 is a nonsquare\nH =\n76ac3ccb86158a9104dff819b1ca293426d305fd76b39b13c9356d9b58c08e57\nk_string = 88bf479281fd29a6cbdffd67e2c5ec0024d92f14eaed58f43f22f37\nc4c37f1d41e65c036fbf01f9fba11d554c07494d0c02e7e5c9d64be88ef78cab75\n44e444d\nk =\n9565956daeedf376cad61b829b2a4d21ba1b52e9b3e2457477a64630a9711003\nU = k*B =\n8ec26e77b8cb3114dd2265fe1564a4efb40d109aa3312536d93dfe3d8d80a061\nV = k*H =\nfe799eb5770b4e3a5a27d22518bb631db183c8316bb552155f442c62a47d1c8b\npi = 47b327393ff2dd81336f8a2ef10339112401253b3c714eeda879f12c50907\n2ef055b48372bb82efbdce8e10c8cb9a2f9d60e93908f93df1623ad78a86a028d6\nbc064dbfc75a6a57379ef855dc6733801\nbeta = 38561d6b77b71d30eb97a062168ae12b667ce5c28caccdf76bc88e093e4\n635987cd96814ce55b4689b3dd2947f80e59aac7b7675f8083865b46c89b2ce9cc\n735",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 21:",
      "ja": "Example 21:"
    },
    {
      "indent": 3,
      "text": "SK =\nc5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b4458f7\nPK =\nfc51cd8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025\nalpha = af82 (2 bytes)\nx =\n909a8b755ed902849023a55b15c23d11ba4d7f4ec5c2f51b1325a181991ea95c\nIn Elligator2: uniform_bytes = be0aed556e36cdfddf8f1eeddbb7356a24f\nad64cf95a922a098038f215588b216beabbfe6acf20256188e883292b7a3a\nIn Elligator2: u =\nf6675dc6d17fc790d4b3f1c6acf689a13d8b5815f23880092a925af94cd6fa24\nIn Elligator2: gx1 =\na63d48e3247c903e22fdfb88fd9295e396712a5fe576af335dbe16f99f0af26c\nIn Elligator2: gx1 is a square\nH = 13d2a8b5ca32db7e98094a61f656a08c6c964344e058879a386a947a4e189ed1\nk_string = a7ddd74a3a7d165d511b02fa268710ddbb3b939282d276fa2efcfa5\naaf79cf576087299ca9234aacd7cd674d912deba00f4e291733ef189a51e36c861\nb3d683b\nk =\n1fda4077f737098b3f361c33a36cccafd7e9e9b720e1f84011254e25f37eed02\nU = k*B =\na012f35433df219a88ab0f9481f4e0065d00422c3285f3d34a8b0202f20bac60\nV = k*H =\nfb613986d171b3e98319c7ca4dc44c5dd8314a6e5616c1a4f16ce72bd7a0c25a\npi = 926e895d308f5e328e7aa159c06eddbe56d06846abf5d98c2512235eaa57f\ndce35b46edfc655bc828d44ad09d1150f31374e7ef73027e14760d42e77341fe05\n467bb286cc2c9d7fde29120a0b2320d04\nbeta = 121b7f9b9aaaa29099fc04a94ba52784d44eac976dd1a3cca458733be5c\nd090a7b5fbd148444f17f8daf1fb55cb04b1ae85a626e30a54b4b0f8abf4a43314\na58",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Contributors",
      "section_title": true,
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "This document would not be possible without the work of Moni Naor, Sachin Vasant, and Asaf Ziv.  Chloe Martindale provided a thorough cryptographer's review. Liliya Akhmetzyanova, Tony Arcieri, Gary Belvin, Mario Cao Cueto, Brian Chen, Sergey Gorbunov, Shumon Huque, Gorka Irazoqui Apecechea, Marek Jankowski, Burt Kaliski, Mallory Knodel, David C. Lawrence, Derek Ting-Haye Leung, Antonio Marcedone, Piotr Nojszewski, Chris Peikert, Colin Perkins, Trevor Perrin, Sam Scott, Stanislav Smyshlyaev, Adam Suhl, Nick Sullivan, Christopher Wood, Jiayu Xu, and Annie Yousar provided valuable input to this document. Christopher Wood, Malte Thomsen, Marcus Rasmussen, and Tobias Vestergaard provided independent verification of the test vectors. Riad Wahby helped this document align with [RFC9380].",
      "ja": "この文書は、Moni Naor、Sachin Vasant、およびAsaf Zivの業績なしには実現しなかったでしょう。Chloe Martindaleは徹底的な暗号専門家のレビューを提供しました。Liliya Akhmetzyanova、Tony Arcieri、Gary Belvin、Mario Cao Cueto、Brian Chen、Sergey Gorbunov、Shumon Huque、Gorka Irazoqui Apecechea、Marek Jankowski、Burt Kaliski、Mallory Knodel、David C. Lawrence、Derek Ting-Haye Leung、Antonio Marcedone、Piotr Nojszewski、Chris Peikert、Colin Perkins、Trevor Perrin、Sam Scott、Stanislav Smyshlyaev、Adam Suhl、Nick Sullivan、Christopher Wood、Jiayu Xu、およびAnnie Yousarはこの文書に貴重な入力を提供しました。Christopher Wood、Malte Thomsen、Marcus Rasmussen、およびTobias Vestergaardはテストベクトルの独立した検証を提供しました。Riad Wahbyはこの文書が[RFC9380]と整合するのを支援しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Sharon Goldberg\nBoston University\n665 Commonwealth Avenue\nBoston, MA 02215\nUnited States of America\nEmail: goldbe@cs.bu.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Leonid Reyzin\nBoston University and Algorand\n665 Commonwealth Avenue\nBoston, MA 02215\nUnited States of America\nEmail: reyzin@bu.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dimitrios Papadopoulos\nHong Kong University of Science and Technology\nClearwater Bay\nHong Kong\nEmail: dipapado@cse.ust.hk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jan Včelák\nNS1\nEmail: jvcelak@ns1.com",
      "raw": true,
      "ja": ""
    }
  ]
}