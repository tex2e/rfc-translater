{
  "title": {
    "text": "RFC 9382 - SPAKE2, a Password-Authenticated Key Exchange",
    "ja": "RFC 9382 - SPAKE2、パスワード認証鍵交換"
  },
  "number": 9382,
  "created_at": "2024-03-20 12:47:44.924468+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                              W. Ladd\nRequest for Comments: 9382                                        Akamai\nCategory: Informational                                   September 2023\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "SPAKE2, a Password-Authenticated Key Exchange",
      "title": true,
      "section_title": true,
      "ja": "SPAKE2、パスワード認証鍵交換"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes SPAKE2, which is a protocol for two parties that share a password to derive a strong shared key without disclosing the password. This method is compatible with any group, is computationally efficient, and has a security proof. This document predated the Crypto Forum Research Group (CFRG) password-authenticated key exchange (PAKE) competition, and it was not selected; however, given existing use of variants in Kerberos and other applications, it was felt that publication was beneficial. Applications that need a symmetric PAKE, but are unable to hash onto an elliptic curve at execution time, can use SPAKE2. This document is a product of the Crypto Forum Research Group in the Internet Research Task Force (IRTF).",
      "ja": "この文書は、パスワードを共有する2つの当事者がパスワードを開示せずに強力な共有鍵を導出するためのプロトコルであるSPAKE2を説明しています。この方法はどのグループとも互換性があり、計算効率が高く、セキュリティの証明があります。この文書は、Crypto Forum Research Group（CFRG）のパスワード認証鍵交換（PAKE）コンペティションより前に作成され、選択されませんでした。しかし、既存のKerberosや他のアプリケーションで変種が使用されていることを鑑み、公開が有益であると考えられました。実行時に楕円曲線にハッシュできないが、対称PAKEが必要なアプリケーションは、SPAKE2を使用できます。この文書は、インターネット研究タスクフォース（IRTF）のCrypto Forum Research Groupの成果物です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書はインターネット標準トラック仕様ではありません。情報提供のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the individual opinion(s) of one or more members of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書はInternet Research Task Force（IRTF）の成果物です。 IRTFは、インターネット関連の研究開発活動の結果を公表しています。 これらの結果は、展開に適していない場合があります。 このRFCは、Internet Research Task Force（IRTF）のCrypto Forum Research Groupの1人以上のメンバーの個人的な意見を表しています。 IRSGによって公開が承認された文書は、インターネット標準のいかなるレベルの候補にもなりません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9382.",
      "ja": "この文書の現在の状況、誤植、およびフィードバックの方法に関する情報は、https://www.rfc-editor.org/info/rfc9382 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書の著者として特定された人々。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、この文書の公開日に有効なBCP 78およびIETF文書に関するIETF信託の法的規定（https://trustee.ietf.org/license-info）の対象となります。これらの文書を注意深く確認してください。これらは、この文書に関するあなたの権利と制限を説明しています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Requirements Notation\n3.  Definition of SPAKE2\n  3.1.  Protocol Flow\n  3.2.  Setup\n  3.3.  SPAKE2\n4.  Key Schedule and Key Confirmation\n5.  Per-User M and N and M=N\n6.  Ciphersuites\n7.  Security Considerations\n8.  IANA Considerations\n9.  References\n  9.1.  Normative References\n  9.2.  Informative References\nAppendix A.  Algorithm Used for Point Generation\nAppendix B.  SPAKE2 Test Vectors\nAcknowledgements\nContributors\nAuthor's Address",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes SPAKE2, which is a means for two parties that share a password to derive a strong shared key without disclosing the password. This password-based key exchange protocol is compatible with any group (requiring only a scheme to map a random input of a fixed length per group to a random group element), is computationally efficient, and has a security proof. Predetermined parameters for a selection of commonly used groups are also provided for use by other protocols.",
      "ja": "この文書は、パスワードを共有する2つの当事者がパスワードを明かさずに強力な共有鍵を導出する手段であるSPAKE2について説明しています。このパスワードベースの鍵交換プロトコルは、任意のグループと互換性があり（グループごとに固定長のランダム入力をランダムなグループ要素にマッピングするスキームのみが必要）、計算効率がよく、セキュリティの証明があります。一般的に使用されるいくつかのグループに対する事前定義されたパラメータも提供されており、他のプロトコルで使用することができます。"
    },
    {
      "indent": 3,
      "text": "SPAKE2 was not selected as the result of the CFRG PAKE selection competition. However, given existing use of variants in Kerberos and other applications, it was felt that publication was beneficial. This RFC represents the individual opinion(s) of one or more members of the Crypto Forum Research Group of the IRTF.",
      "ja": "SPAKE2はCFRG PAKE選定コンペティションの結果として選択されませんでした。ただし、既存のKerberosや他のアプリケーションでのバリアントの使用が考慮され、公開が有益であると感じられました。このRFCは、IRTFのCrypto Forum Research Groupの1人以上のメンバーの個人的な意見を表しています。"
    },
    {
      "indent": 3,
      "text": "Many of these applications predated methods to hash to elliptic curves being available or predated the publication of the PAKEs that were chosen as an outcome of the PAKE selection competition. In cases where a symmetric PAKE is needed and hashing onto an elliptic curve at protocol execution time is not available, SPAKE2 is useful.",
      "ja": "これらのアプリケーションの多くは、楕円曲線へのハッシュ方法が利用可能になる前、またはPAKE選定コンペティションの結果として選択されたPAKEの公開前に作成されました。プロトコル実行時に楕円曲線へのハッシュが利用できない場合、対称PAKEが必要な場合、SPAKE2が役立ちます。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Notation",
      "section_title": true,
      "ja": "2. 要件表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書におけるキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、全て大文字で表記されている場合に限り、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "3. Definition of SPAKE2",
      "section_title": true,
      "ja": "3. Definition of SPAKE2"
    },
    {
      "indent": 0,
      "text": "3.1. Protocol Flow",
      "section_title": true,
      "ja": "3.1. プロトコルフロー"
    },
    {
      "indent": 3,
      "text": "SPAKE2 is a two-round protocol, wherein the first round establishes a shared secret between A and B, and the second round serves as key confirmation. Prior to invocation, A and B are provisioned with information, such as the input password needed to run the protocol. We assume that the roles of A and B are agreed upon by both sides: A goes first and uses M, and B goes second and uses N. If this assignment of roles is not possible, a symmetric variant MUST be used, as described later Section 5. For instance, A may be the client when using TCP or TLS as an underlying protocol, and B may be the server. Most protocols have such a distinction. During the first round, A sends a public value pA to B, and B responds with its own public value pB. Both A and B then derive a shared secret used to produce encryption and authentication keys. The latter are used during the second round for key confirmation. (Section 4 details the key derivation and confirmation steps.) In particular, A sends a key confirmation message cA to B, and B responds with its own key confirmation message cB. A MUST NOT consider the protocol complete until it receives and verifies cB. Likewise, B MUST NOT consider the protocol complete until it receives and verifies cA.",
      "ja": "SPAKE2は2ラウンドのプロトコルで、最初のラウンドはAとBの間で共有秘密を確立し、2番目のラウンドは鍵確認として機能します。呼び出し前に、AとBはプロトコルを実行するために必要な入力パスワードなどの情報を提供されます。AとBの役割が両者で合意されていると仮定します：Aが最初に行動し、Mを使用し、Bが2番目に行動し、Nを使用します。役割の割り当てが不可能な場合は、後述のセクション5で説明されているように、対称的なバリアントを使用する必要があります。たとえば、TCPやTLSを基礎プロトコルとして使用する場合、Aはクライアントであり、Bはサーバーである場合があります。ほとんどのプロトコルにはそのような区別があります。最初のラウンド中、Aは公開値pAをBに送信し、Bは独自の公開値pBで応答します。その後、AとBは暗号化および認証キーを生成するために使用される共有秘密を導出します。後者は鍵確認のために2番目のラウンド中に使用されます。（セクション4ではキーの導出と確認手順の詳細が説明されています。）特に、AはBに鍵確認メッセージcAを送信し、Bは独自の鍵確認メッセージcBで応答します。AはcBを受信して検証するまでプロトコルを完了とは見なしてはなりません。同様に、BはcAを受信して検証するまでプロトコルを完了とは見なしてはなりません。"
    },
    {
      "indent": 3,
      "text": "This sample flow is shown below.",
      "ja": "このサンプルフローは以下に示されています。"
    },
    {
      "indent": 5,
      "text": "              A                       B\n              |                       |\n              |                       |\n(compute pA)  |          pA           |\n              |---------------------->|\n              |          pB           | (compute pB)\n              |<----------------------|\n              |                       |\n              |   (derive secrets)    |\n              |                       |\n(compute cA)  |          cA           |\n              |---------------------->|\n              |          cB           | (compute cB)\n              |                       | (check cA)\n              |<----------------------|\n(check cB)    |                       |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2. Setup",
      "section_title": true,
      "ja": "3.2. セットアップ"
    },
    {
      "indent": 3,
      "text": "Let G be a group in which the gap Diffie-Hellman (GDH) problem is hard. Suppose G has order p*h, where p is a large prime and h will be called the cofactor. Let I be the unit element in G, e.g., the point at infinity if G is an elliptic curve group. We denote the operations in the group additively. We assume there is a representation of elements of G as byte strings: common choices would be SEC1 [SEC1] uncompressed or compressed for elliptic curve groups or big-endian integers of a fixed (per-group) length for prime field DH. Applications MUST specify this encoding, typically by referring to the document defining the group. We fix two elements, M and N, in the prime-order subgroup of G, as defined in Table 1 of this document for common groups, as well as generator P of the (large) prime-order subgroup of G. In the case of a composite order group, we will work in the quotient group. For common groups used in this document, P is specified in the document defining the group, so we do not repeat it here.",
      "ja": "GがGap Diffie-Hellman (GDH) 問題が困難とされるグループであるとします。Gの位数がp*hであり、pは大きな素数であり、hは余因子と呼ばれます。Gにおいて単位元をIとし、例えば、Gが楕円曲線群である場合は無限遠点とします。グループ内の演算は加法的に表します。Gの要素をバイト列として表現することを前提とします。一般的な選択肢は、楕円曲線群の場合は非圧縮または圧縮されたSEC1、素体DHの場合は固定長のビッグエンディアン整数です。アプリケーションはこのエンコーディングを明示しなければなりません。通常は、グループを定義する文書を参照することで指定します。この文書の一般的なグループにおいて、表1で定義されるGの素数位数の部分群内の2つの要素MとN、および（大きな）素数位数の部分群の生成元Pを固定します。合成位数グループの場合、商群で作業します。この文書で使用される一般的なグループにおいて、Pはグループを定義する文書で指定されているため、ここで繰り返しません。"
    },
    {
      "indent": 3,
      "text": "For elliptic curves other than the ones in this document, the methods described in [RFC9380] SHOULD be used to generate M and N, e.g., via M = hash_to_curve(\"M SPAKE2 seed OID x\") and N = hash_to_curve(\"N SPAKE2 seed OID x\"), where x is an OID for the curve. Applications MAY include a domain separation tag (DST) in this step, as specified in [RFC9380], though this is not required.",
      "ja": "このドキュメントに記載されている楕円曲線以外の楕円曲線については、[RFC9380] で説明されている方法を使用して M と N を生成するべきです。たとえば、M = hash_to_curve(\"M SPAKE2 seed OID x\") および N = hash_to_curve(\"N SPAKE2 seed OID x\") のように、ここで x は曲線の OID です。アプリケーションは、このステップで [RFC9380] で指定されているように、ドメイン分離タグ（DST）を含めることができますが、これは必須ではありません。"
    },
    {
      "indent": 3,
      "text": "|| denotes concatenation of byte strings. We also let len(S) denote the length of a string in bytes, represented as an eight-byte little-endian number. Finally, let nil represent an empty string, i.e., len(nil) = 0. Text strings in double quotes are treated as their ASCII encodings throughout this document.",
      "ja": "||はバイト文字列の連結を示します。また、len(S)はバイト文字列の長さを示し、8バイトのリトルエンディアン数値として表されます。最後に、nilは空の文字列を表し、つまりlen(nil) = 0です。二重引用符で囲まれたテキスト文字列は、この文書全体でASCIIエンコーディングとして扱われます。"
    },
    {
      "indent": 3,
      "text": "KDF(ikm, salt, info, L) is a key-derivation function that takes as input a salt, input keying material (IKM), an info string, and derived key length L to derive a cryptographic key of length L. MAC(key, message) is a Message Authentication Code algorithm that takes a secret key and message as input to produce an output. Let Hash be a hash function from arbitrary strings to bit strings of a fixed length that is at least 256 bits long. Common choices for Hash are SHA-256 or SHA-512 [RFC6234]. Let MHF be a memory-hard hash function designed to slow down brute-force attackers. Scrypt [RFC7914] is a common example of this function. The output length of MHF matches that of Hash. Parameter selection for MHF is out of scope for this document. Section 6 specifies variants of KDF, MAC, and Hash that are suitable for use with the protocols contained herein.",
      "ja": "KDF(ikm、salt、info、L)は、入力としてsalt、入力鍵素材(IKM)、情報文字列、および導出鍵の長さLを取り、長さLの暗号鍵を導出する鍵導出関数です。MAC(key、message)は、秘密鍵とメッセージを入力として取り、出力を生成するメッセージ認証コードアルゴリズムです。Hashは、256ビット以上の固定長のビット文字列に任意の文字列をハッシュするハッシュ関数です。Hashの一般的な選択肢は、SHA-256またはSHA-512[RFC6234]です。MHFは、ブルートフォース攻撃者を遅らせるために設計されたメモリハードハッシュ関数です。Scrypt[RFC7914]は、この関数の一般的な例です。MHFの出力長はHashの出力長と一致します。MHFのパラメータ選択は、この文書の範囲外です。セクション6では、ここに含まれるプロトコルと適合するKDF、MAC、およびHashのバリアントが指定されています。"
    },
    {
      "indent": 3,
      "text": "Let A and B be two parties. A and B may also have digital representations of the parties' identities, such as Media Access Control addresses or other names (hostnames, usernames, etc.). A and B may share additional authenticated data (AAD) of a length that is at most 2^16 - 128 bits and separate from their identities, which they may want to include in the protocol execution. One example of AAD is a list of supported protocol versions if SPAKE2 were used in a higher-level protocol that negotiates use of a particular PAKE. Including this list would ensure that both parties agree upon the same set of supported protocols and therefore prevents downgrade attacks. We also assume A and B share integer w; typically, w = MHF(pw) mod p for a user-supplied password, pw. Standards, such as [NIST.SP.800-56Ar3], suggest taking mod p of a hash value that is 64 bits longer than that needed to represent p to remove statistical bias introduced by the modulation. Protocols using this specification MUST define the method used to compute w. In some cases, it may be necessary to carry out various forms of normalization of the password before hashing [RFC8265]. The hashing algorithm SHOULD be an MHF so as to slow down brute-force attackers.",
      "ja": "AとBを2つの当事者とします。AとBは、MACアドレスやその他の名前（ホスト名、ユーザー名など）など、当事者のアイデンティティのデジタル表現を持つことがあります。AとBは、プロトコルの実行に含めたい追加の認証データ（AAD）を共有することができます。AADの長さは、最大で2^16 - 128ビットであり、アイデンティティから分離されています。AADの1つの例は、SPAKE2が特定のPAKEの使用を交渉する上位プロトコルで使用される場合のサポートされるプロトコルバージョンのリストです。このリストを含めることで、両当事者が同じサポートされるプロトコルのセットに同意し、ダウングレード攻撃を防ぐことができます。また、AとBが整数wを共有していると仮定します。通常、w = MHF(pw) mod pとなります。ここで、pwはユーザーが提供したパスワードです。[NIST.SP.800-56Ar3]などの標準では、pを表現するのに必要な長さよりも64ビット長いハッシュ値のmod pを取ることが提案されており、これにより導入された統計的バイアスが除去されます。この仕様を使用するプロトコルは、wを計算するための方法を定義する必要があります。場合によっては、ハッシュ化する前にパスワードのさまざまな形式の正規化を行う必要がある場合があります。ハッシュアルゴリズムは、ブルートフォース攻撃者を遅らせるためにMHFであるべきです。"
    },
    {
      "indent": 0,
      "text": "3.3. SPAKE2",
      "section_title": true,
      "ja": "3.3. SPAKE2"
    },
    {
      "indent": 3,
      "text": "To begin, A picks x randomly and uniformly from the integers in [0,p) and calculates X=x*P and pA=w*M+X. Then, it transmits pA to B.",
      "ja": "始めに、Aは[0、p)の整数からxをランダムに一様に選び、X=x*Pを計算し、pA=w*M+Xを計算します。その後、pAをBに送信します。"
    },
    {
      "indent": 3,
      "text": "B selects y randomly and uniformly from the integers in [0,p) and calculates Y=y*P and pB=w*N+Y. Then, it transmits pB to A.",
      "ja": "Bは[0、p)の整数からyをランダムに一様に選択し、Y=y*Pを計算し、pB=w*N+Yを計算します。その後、pBをAに送信します。"
    },
    {
      "indent": 3,
      "text": "Both A and B calculate group element K. A calculates it as h*x*(pB-w*N), while B calculates it as h*y*(pA-w*M). A knows pB because it has received it, and likewise B knows pA. The multiplication by h prevents small subgroup confinement attacks by computing a unique value in the quotient group.",
      "ja": "AとBの両方がグループ要素Kを計算します。Aはそれをh*x*(pB-w*N)として計算し、一方Bはh*y*(pA-w*M)として計算します。Aはそれを受け取ったため、pBを知っていますし、同様にBもpAを知っています。hによる乗算は、商群内の一意の値を計算することで小さな部分群閉じ込め攻撃を防ぎます。"
    },
    {
      "indent": 3,
      "text": "K is a shared value, though it MUST NOT be used or output as a shared secret from the protocol. Both A and B must derive two additional shared secrets from the protocol transcript, which includes K. This use of the transcript ensures any manipulation of the messages sent is reflected in the keys. The transcript TT is encoded as follows:",
      "ja": "Kは共有値ですが、プロトコルから共有秘密として使用または出力してはいけません。AとBは、Kを含むプロトコルのトランスクリプトから2つの追加の共有秘密を導出しなければなりません。このトランスクリプトの使用により、送信されたメッセージの操作が鍵に反映されます。トランスクリプトTTは次のようにエンコードされます："
    },
    {
      "indent": 11,
      "text": "TT = len(A)  || A\n  || len(B)  || B\n  || len(pA) || pA\n  || len(pB) || pB\n  || len(K)  || K\n  || len(w)  || w",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Here, w is encoded as a big-endian number padded to the length of p. This representation prevents timing attacks that otherwise would reveal the length of w. len(w) is thus a constant for a given group. We include it for consistency.",
      "ja": "ここでは、w は p の長さにパディングされたビッグエンディアンの数値としてエンコードされます。この表現は、w の長さを明らかにする可能性があるタイミング攻撃を防ぎます。したがって、len(w) は特定のグループに対して一定です。私たちは一貫性のためにそれを含めています。"
    },
    {
      "indent": 3,
      "text": "If an identity is absent, it is encoded as a zero-length string. This MUST only be done for applications in which identities are implicit. Otherwise, the protocol risks unknown key-share attacks, where both sides of a connection disagree over who is authenticated.",
      "ja": "もしアイデンティティが存在しない場合、それはゼロ長の文字列としてエンコードされます。これはアイデンティティが暗黙的であるアプリケーションでのみ行われなければなりません。そうでない場合、プロトコルは未知の鍵共有攻撃のリスクにさらされます。接続の両側で誰が認証されたかについて不一致が生じます。"
    },
    {
      "indent": 3,
      "text": "Upon completion of this protocol, A and B compute shared secrets Ke, KcA, and KcB, as specified in Section 4. A MUST send B a key confirmation message so that both parties agree upon these shared secrets. The confirmation message cA is computed as a MAC over the protocol transcript TT, using KcA as follows: cA = MAC(KcA, TT). Similarly, B MUST send A a confirmation message using a MAC that is computed equivalently, except with the use of KcB. Key confirmation verification requires computing cA (or cB, respectively) and checking for equality against that which was received.",
      "ja": "このプロトコルの完了後、AとBはセクション4で指定されたように、共有シークレットKe、KcA、およびKcBを計算します。AはBに鍵確認メッセージを送信する必要があります。確認メッセージcAは、KcAを使用してプロトコルトランスクリプトTT上でMACを計算することによって計算されます：cA = MAC(KcA, TT)。同様に、BはKcBを使用して計算されるMACを使用してAに確認メッセージを送信する必要があります。鍵確認の検証には、cA（またはcB）を計算し、受信したものとの等価性を確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Key Schedule and Key Confirmation",
      "section_title": true,
      "ja": "4. キースケジュールとキー確認"
    },
    {
      "indent": 3,
      "text": "The protocol transcript TT, as defined in Section 3.3, is unique and secret to A and B (though it contains some substrings that are not secret). Both parties use TT to derive shared symmetric secrets Ke and Ka as Ke || Ka = Hash(TT), with |Ke| = |Ka|. The length of each key is equal to half of the digest output, e.g., 128 bits for SHA-256. Keys MUST be at least 128 bits in length.",
      "ja": "プロトコルトランスクリプトTTは、セクション3.3で定義されており、AとBにとって一意かつ秘密です（一部の部分文字列は秘密ではありません）。両当事者は、TTを使用して共有対称秘密鍵KeとKaを導出します。Ke || Ka = Hash(TT)、|Ke| = |Ka|。各鍵の長さは、ダイジェスト出力の半分に等しく、たとえばSHA-256の場合は128ビットです。鍵の長さは少なくとも128ビットである必要があります。"
    },
    {
      "indent": 3,
      "text": "Both endpoints use Ka to derive subsequent MAC keys for key confirmation messages. Specifically, KcA and KcB are the MAC keys used by A and B, respectively. A and B compute them as KcA || KcB = KDF(Ka, nil, \"ConfirmationKeys\" || AAD, L), where AAD is the associated data given to each endpoint or AAD is nil if none was provided. The length of each of KcA and KcB is equal to half of the underlying hash output length, e.g., |KcA| = |KcB| = 128 bits for HKDF(SHA256), with L=256 bits.",
      "ja": "両方のエンドポイントは、鍵確認メッセージのための後続のMACキーを導出するためにKaを使用します。具体的には、KcAとKcBは、それぞれAとBが使用するMACキーです。AとBは、KcA || KcB = KDF(Ka, nil, \"ConfirmationKeys\" || AAD, L) として計算します。ここで、AADは各エンドポイントに与えられた関連データであり、提供されていない場合はnilです。KcAとKcBのそれぞれの長さは、基礎となるハッシュ出力長の半分と等しく、たとえば、HKDF(SHA256)の場合、|KcA| = |KcB| = 128ビットであり、L=256ビットです。"
    },
    {
      "indent": 3,
      "text": "The resulting key schedule for this protocol, given transcript TT and AAD, is as follows.",
      "ja": "このプロトコルの結果として得られるキースケジュールは、トランスクリプトTTとAADが与えられた場合、次のようになります。"
    },
    {
      "indent": 7,
      "text": "TT  -> Hash(TT) = Ke || Ka\nAAD -> KDF(Ka, nil, \"ConfirmationKeys\" || AAD) = KcA || KcB",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A and B output Ke as the shared secret from the protocol. Ka and its derived keys are not used for anything except key confirmation.",
      "ja": "AとBはプロトコルから共有秘密としてKeを出力します。Kaとその派生キーは、鍵確認以外には使用されません。"
    },
    {
      "indent": 0,
      "text": "5. Per-User M and N and M=N",
      "section_title": true,
      "ja": "5. ユーザーごとのMとN、およびM=N"
    },
    {
      "indent": 3,
      "text": "To avoid concerns that an attacker needs to solve a single Elliptic Curve Diffie-Hellman (ECDH) instance to break the authentication of SPAKE2, it is possible to vary M and N using [RFC9380] as follows:",
      "ja": "SPAKE2の認証を破るために攻撃者が1つの楕円曲線ディフィー・ヘルマン（ECDH）インスタンスを解決する必要がある懸念を避けるために、MとNを[RFC9380]を使用して変化させることが可能です。"
    },
    {
      "indent": 7,
      "text": "M = hash_to_curve(Hash(\"M SPAKE2\" || len(A) || A || len(B) || B))\nN = hash_to_curve(Hash(\"N SPAKE2\" || len(A) || A || len(B) || B))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "There is also a symmetric variant where M=N. For this variant, we set:",
      "ja": "M=Nの対称的なバリアントもあります。このバリアントでは、次のように設定します："
    },
    {
      "indent": 7,
      "text": "M = hash_to_curve(Hash(\"M AND N SPAKE2\"))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This variant MUST be used when it is not possible to determine whether A or B should use M (or N), due to asymmetries in the protocol flows or the desire to use only a single shared secret with nil identities for authentication. The security of these variants is examined in [MNVAR]. The variant with per-user M and N may not be suitable for protocols that require the initial messages to be generated by each party at the same time and that do not know the exact identity of the parties before the flow begins.",
      "ja": "この変種は、プロトコルフローの非対称性や認証のために nil identities を使用することを望む場合に、A または B が M（または N）を使用すべきかどうかを判断できない場合に使用する必要があります。これらの変種のセキュリティは [MNVAR] で検討されています。ユーザーごとの M と N を使用する変種は、各当事者が同時に初期メッセージを生成する必要があり、かつフロー開始前に当事者の正確なアイデンティティが不明なプロトコルには適していない場合があります。"
    },
    {
      "indent": 0,
      "text": "6. Ciphersuites",
      "section_title": true,
      "ja": "6. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "This section documents SPAKE2 ciphersuite configurations. A ciphersuite indicates a group, cryptographic hash function, and pair of KDF and MAC functions, e.g., SPAKE2-P256-SHA256-HKDF-HMAC. This ciphersuite indicates a SPAKE2 protocol instance over P-256 that uses SHA-256, along with HMAC-based Key Derivation Function (HKDF) [RFC5869] and Hashed Message Authentication Code (HMAC) [RFC2104] for G, Hash, KDF, and MAC functions, respectively. For Ed25519, the compressed encoding is used [RFC8032]; all others use the uncompressed SEC1 encoding.",
      "ja": "このセクションは SPAKE2 暗号スイートの構成を文書化しています。 暗号スイートは、グループ、暗号ハッシュ関数、および KDF と MAC 関数のペアを示します。例：SPAKE2-P256-SHA256-HKDF-HMAC。 この暗号スイートは、P-256 上の SPAKE2 プロトコルインスタンスを示し、SHA-256 を使用し、HMAC ベースの鍵導出関数（HKDF）[RFC5869] およびハッシュメッセージ認証コード（HMAC）[RFC2104] を G、Hash、KDF、および MAC 関数にそれぞれ使用します。 Ed25519 の場合、圧縮エンコーディングが使用されます[RFC8032]。 その他のすべては非圧縮の SEC1 エンコーディングを使用します。"
    },
    {
      "indent": 3,
      "text": "+==============+==================+================+================+\n|      G       |       Hash       |      KDF       |      MAC       |\n+==============+==================+================+================+\n|    P-256     | SHA256 [RFC6234] | HKDF [RFC5869] |      HMAC      |\n|              |                  |                |   [RFC2104]    |\n+--------------+------------------+----------------+----------------+\n|    P-256     | SHA512 [RFC6234] | HKDF [RFC5869] |      HMAC      |\n|              |                  |                |   [RFC2104]    |\n+--------------+------------------+----------------+----------------+\n|    P-384     | SHA256 [RFC6234] | HKDF [RFC5869] |      HMAC      |\n|              |                  |                |   [RFC2104]    |\n+--------------+------------------+----------------+----------------+\n|    P-384     | SHA512 [RFC6234] | HKDF [RFC5869] |      HMAC      |\n|              |                  |                |   [RFC2104]    |\n+--------------+------------------+----------------+----------------+\n|    P-521     | SHA512 [RFC6234] | HKDF [RFC5869] |      HMAC      |\n|              |                  |                |   [RFC2104]    |\n+--------------+------------------+----------------+----------------+\n| edwards25519 | SHA256 [RFC6234] | HKDF [RFC5869] |      HMAC      |\n|  [RFC8032]   |                  |                |   [RFC2104]    |\n+--------------+------------------+----------------+----------------+\n|  edwards448  | SHA512 [RFC6234] | HKDF [RFC5869] |      HMAC      |\n|  [RFC8032]   |                  |                |   [RFC2104]    |\n+--------------+------------------+----------------+----------------+\n|    P-256     | SHA256 [RFC6234] | HKDF [RFC5869] |  CMAC-AES-128  |\n|              |                  |                |   [RFC4493]    |\n+--------------+------------------+----------------+----------------+\n|    P-256     | SHA512 [RFC6234] | HKDF [RFC5869] |  CMAC-AES-128  |\n|              |                  |                |   [RFC4493]    |\n+--------------+------------------+----------------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 1: SPAKE2 Ciphersuites",
      "ja": "表1：SPAKE2サイファースイート"
    },
    {
      "indent": 3,
      "text": "The following points represent permissible point generation seeds for the groups listed in Table 1, using the algorithm presented in Appendix A. These byte strings are compressed points, as in [SEC1], for curves from [SEC1].",
      "ja": "次のポイントは、表1にリストされているグループに対して、付録Aで示されているアルゴリズムを使用して生成される許容されるポイント生成シードを表しています。これらのバイト文字列は、[SEC1]で示されているように、[SEC1]の曲線用の圧縮ポイントです。"
    },
    {
      "indent": 3,
      "text": "For P-256:",
      "ja": "P-256:"
    },
    {
      "indent": 3,
      "text": "M =\n02886e2f97ace46e55ba9dd7242579f2993b64e16ef3dcab95afd497333d8fa12f\nseed: 1.2.840.10045.3.1.7 point generation seed (M)\n\nN =\n03d8bbd6c639c62937b04d997f38c3770719c629d7014d49a24b4f98baa1292b49\nseed: 1.2.840.10045.3.1.7 point generation seed (N)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For P-384:",
      "ja": "P-384:"
    },
    {
      "indent": 3,
      "text": "M =\n030ff0895ae5ebf6187080a82d82b42e2765e3b2f8749c7e05eba366434b363d3dc\n36f15314739074d2eb8613fceec2853\nseed: 1.3.132.0.34 point generation seed (M)\n\nN =\n02c72cf2e390853a1c1c4ad816a62fd15824f56078918f43f922ca21518f9c543bb\n252c5490214cf9aa3f0baab4b665c10\nseed: 1.3.132.0.34 point generation seed (N)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For P-521:",
      "ja": "P-521について:"
    },
    {
      "indent": 3,
      "text": "M =\n02003f06f38131b2ba2600791e82488e8d20ab889af753a41806c5db18d37d85608\ncfae06b82e4a72cd744c719193562a653ea1f119eef9356907edc9b56979962d7aa\nseed: 1.3.132.0.35 point generation seed (M)\n\nN =\n0200c7924b9ec017f3094562894336a53c50167ba8c5963876880542bc669e494b25\n32d76c5b53dfb349fdf69154b9e0048c58a42e8ed04cef052a3bc349d95575cd25\nseed: 1.3.132.0.35 point generation seed (N)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For edwards25519:",
      "ja": "edwards25519:"
    },
    {
      "indent": 3,
      "text": "M =\nd048032c6ea0b6d697ddc2e86bda85a33adac920f1bf18e1b0c6d166a5cecdaf\nseed: edwards25519 point generation seed (M)\n\nN =\nd3bfb518f44f3430f29d0c92af503865a1ed3281dc69b35dd868ba85f886c4ab\nseed: edwards25519 point generation seed (N)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For edwards448:",
      "ja": "edwards448に向けて:"
    },
    {
      "indent": 3,
      "text": "M =\nb6221038a775ecd007a4e4dde39fd76ae91d3cf0cc92be8f0c2fa6d6b66f9a12\n942f5a92646109152292464f3e63d354701c7848d9fc3b8880\nseed: edwards448 point generation seed (M)\n\nN =\n6034c65b66e4cd7a49b0edec3e3c9ccc4588afd8cf324e29f0a84a072531c4db\nf97ff9af195ed714a689251f08f8e06e2d1f24a0ffc0146600\nseed: edwards448 point generation seed (N)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A security proof of SPAKE2 for prime order groups is found in [REF], reducing the security of SPAKE2 to the GDH assumption. Note that the choice of M and N is critical for the security proof. The generation methods specified in this document are designed to eliminate concerns related to knowing discrete logs of M and N.",
      "ja": "SPAKE2の素数次数群に対するセキュリティ証明は[REF]にあり、SPAKE2のセキュリティをGDH仮定に帰着させています。MとNの選択はセキュリティ証明において重要です。この文書で指定された生成方法は、MとNの離散対数が知られていることに関連する懸念を排除するように設計されています。"
    },
    {
      "indent": 3,
      "text": "Elements received from a peer MUST be checked for group membership. Failure to properly deserialize and validate group elements can lead to attacks. An endpoint MUST abort the protocol if any received public value is not a member of G.",
      "ja": "ピアから受信した要素は、グループのメンバーシップを確認する必要があります。グループ要素を適切に逆シリアル化および検証しないと、攻撃が発生する可能性があります。受信した公開値が G のメンバーでない場合、エンドポイントはプロトコルを中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The choices of random numbers MUST be uniform. Randomly generated values, e.g., x and y, MUST NOT be reused; such reuse violates the security assumptions of the protocol and results in significant insecurity. It is RECOMMENDED to generate these uniform numbers using rejection sampling.",
      "ja": "ランダムな数値の選択は一様でなければなりません。生成された値（例：xやy）は再利用してはいけません。そのような再利用はプロトコルのセキュリティの前提を破り、重大な脆弱性を引き起こします。これらの一様な数値を生成する際には、拒絶サンプリングを使用することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Some implementations of elliptic curve multiplication may leak information about the length of the scalar. These MUST NOT be used. All operations on elliptic curve points must take time independent of the inputs. Hashing of the transcript may take time depending only on the length of the transcript but not the contents.",
      "ja": "楕円曲線乗算の一部の実装は、スカラーの長さに関する情報を漏洩する可能性があります。これらは使用してはいけません。楕円曲線上のすべての操作は、入力に依存しない時間で行われなければなりません。トランスクリプトのハッシュ化は、トランスクリプトの長さのみに依存して時間がかかる場合がありますが、内容には依存しません。"
    },
    {
      "indent": 3,
      "text": "SPAKE2 does not support augmentation. As a result, the server has to store a password equivalent. This is considered a significant drawback in some use cases. Applications that need augmented PAKEs should use [CFRG-OPAQUE].",
      "ja": "SPAKE2は増強をサポートしていません。その結果、サーバーはパスワード相当の情報を保存する必要があります。これは一部のユースケースで重大な欠点と見なされています。増強されたPAKEを必要とするアプリケーションは、[CFRG-OPAQUE]を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The HMAC keys in this document are shorter than recommended in [RFC8032]. This is appropriate, as the difficulty of the discrete logarithm problem is comparable with the difficulty of brute forcing the keys.",
      "ja": "このドキュメントのHMACキーは[RFC8032]で推奨されているよりも短くなっています。これは、離散対数問題の難しさがキーを総当たりで解く難しさと同程度であるため適切です。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "この文書にはIANAのアクションはありません。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n           Hashing for Message Authentication\", RFC 2104,\n           DOI 10.17487/RFC2104, February 1997,\n           <https://www.rfc-editor.org/info/rfc2104>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4493]  Song, JH., Poovendran, R., Lee, J., and T. Iwata, \"The\n           AES-CMAC Algorithm\", RFC 4493, DOI 10.17487/RFC4493, June\n           2006, <https://www.rfc-editor.org/info/rfc4493>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,\n           \"Elliptic Curve Cryptography Subject Public Key\n           Information\", RFC 5480, DOI 10.17487/RFC5480, March 2009,\n           <https://www.rfc-editor.org/info/rfc5480>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n           Key Derivation Function (HKDF)\", RFC 5869,\n           DOI 10.17487/RFC5869, May 2010,\n           <https://www.rfc-editor.org/info/rfc5869>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6234]  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n           (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n           DOI 10.17487/RFC6234, May 2011,\n           <https://www.rfc-editor.org/info/rfc6234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7914]  Percival, C. and S. Josefsson, \"The scrypt Password-Based\n           Key Derivation Function\", RFC 7914, DOI 10.17487/RFC7914,\n           August 2016, <https://www.rfc-editor.org/info/rfc7914>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9380]  Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,\n           and C. A. Wood, \"Hashing to Elliptic Curves\", RFC 9380,\n           DOI 10.17487/RFC9380, August 2023,\n           <https://www.rfc-editor.org/info/rfc9380>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CFRG-OPAQUE]\n           Bourdrez, D., Krawczyk, H., Lewi, K., and C. A. Wood, \"The\n           OPAQUE Asymmetric PAKE Protocol\", Work in Progress,\n           Internet-Draft, draft-irtf-cfrg-opaque-11, 8 June 2023,\n           <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-\n           opaque-11>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MNVAR]    Abdalla, M., Barbosa, M., Bradley, T., Jarecki, S., Katz,\n           J., and J. Xu, \"Universally Composable Relaxed Password\n           Authenticated Key Exchange\", in Advances in Cryptology -\n           CRYPTO 2020, Lecture Notes in Computer Science, Volume\n           12170, Springer, DOI 10.1007/978-3-030-56784-2_10, August\n           2020, <https://doi.org/10.1007/978-3-030-56784-2_10>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[NIST.SP.800-56Ar3]\n           National Institute of Standards and Technology,\n           \"Recommendation for Pair-Wise Key-Establishment Schemes\n           Using Discrete Logarithm Cryptography\", Revision 3, NIST\n           Special Publication 800-56A,\n           DOI 10.6028/NIST.SP.800-56Ar3, April 2018,\n           <https://doi.org/10.6028/NIST.SP.800-56Ar3>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[REF]      Abdalla, M. and D. Pointcheval, \"Simple Password-Based\n           Encrypted Key Exchange Protocols\", Cryptography-CT-RSA\n           2005, Lecture Notes in Computer Science, Volume 3376,\n           pages 191-208, Springer, DOI 10.1007/978-3-540-30574-3_14,\n           February 2005,\n           <https://doi.org/10.1007/978-3-540-30574-3_14>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8265]  Saint-Andre, P. and A. Melnikov, \"Preparation,\n           Enforcement, and Comparison of Internationalized Strings\n           Representing Usernames and Passwords\", RFC 8265,\n           DOI 10.17487/RFC8265, October 2017,\n           <https://www.rfc-editor.org/info/rfc8265>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC1]     Standards for Efficient Cryptography Group, \"SEC 1:\n           Elliptic Curve Cryptography\", May 2009.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Algorithm Used for Point Generation",
      "section_title": true,
      "ja": "付録A. ポイント生成に使用されるアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This section describes the algorithm that was used to generate points M and N in Table 1.",
      "ja": "このセクションは、表1で使用された点MとNを生成するために使用されたアルゴリズムを説明しています。"
    },
    {
      "indent": 3,
      "text": "For each curve in Table 1, we construct a string using the curve OID from [RFC5480] (as an ASCII string) or its name, combined with the needed constant, e.g., \"1.3.132.0.35 point generation seed (M)\" for P-521. This string is turned into a series of blocks by hashing with SHA-256 and hashing that output again to generate the next 32 bytes and so on. This pattern is repeated for each group and value, with the string modified appropriately.",
      "ja": "表1の各曲線について、[RFC5480]からの曲線OID（ASCII文字列として）またはその名前を使用し、必要な定数と組み合わせた文字列を構築します。例：P-521の場合、「1.3.132.0.35 point generation seed (M)」。この文字列はSHA-256でハッシュ化され、その出力を再度ハッシュ化して次の32バイトを生成します。このパターンは、文字列を適切に変更しながら、各グループと値に対して繰り返されます。"
    },
    {
      "indent": 3,
      "text": "A byte string of a length equal to that of an encoded group element is constructed by concatenating as many blocks as are required, starting from the first block and truncating to the desired length. The byte string is then formatted as required for the group. In the case of Weierstrass curves, we take the desired length as the length for representing a compressed point (Section 2.3.4 of [SEC1]) and use the low-order bit of the first byte as the sign bit. In order to obtain the correct format, the value of the first byte is set to 0x02 or 0x03 (clearing the first six bits and setting the seventh bit), leaving the sign bit as it was in the byte string constructed by concatenating hash blocks. For the curves in [RFC8032], a different procedure is used. For edwards448, the 57-byte input has the least-significant 7 bits of the last byte set to zero, and for edwards25519, the 32-byte input is not modified. For both the curves in [RFC8032], the (modified) input is then interpreted as the representation of the group element. If this interpretation yields a valid group element with the correct order (p), the (modified) byte string is the output. Otherwise, the initial hash block is discarded and a new byte string is constructed from the remaining hash blocks. The procedure of constructing a byte string of the appropriate length, formatting it as required for the curve, and checking if it is a valid point of the correct order is repeated until a valid element is found.",
      "ja": "エンコードされたグループ要素と同じ長さのバイト文字列が構築され、必要なブロック数だけ連結され、最初のブロックから開始して所望の長さに切り詰められます。次に、バイト文字列はグループに必要な形式に整形されます。ワイエルシュトラス曲線の場合、圧縮された点を表すための長さ（[SEC1]の2.3.4節）を所望の長さとし、最初のバイトの最下位ビットを符号ビットとして使用します。正しい形式を取得するために、最初のバイトの値は0x02または0x03に設定され（最初の6ビットをクリアし、7番目のビットを設定）、符号ビットは、ハッシュブロックを連結して構築されたバイト文字列にあったもののままにします。[RFC8032]の曲線の場合、異なる手順が使用されます。edwards448の場合、57バイトの入力の最下位7ビットがゼロに設定され、edwards25519の場合、32バイトの入力は変更されません。[RFC8032]の両曲線について、（変更された）入力は、その後、グループ要素の表現として解釈されます。この解釈が正しい順序（p）の有効なグループ要素を生成する場合、（変更された）バイト文字列が出力されます。それ以外の場合、最初のハッシュブロックは破棄され、残りのハッシュブロックから新しいバイト文字列が構築されます。適切な長さのバイト文字列を構築し、曲線に必要な形式に整形し、正しい順序の有効な点であるかどうかを確認する手順は、有効な要素が見つかるまで繰り返されます。"
    },
    {
      "indent": 3,
      "text": "The following Python snippet generates the above points, assuming an elliptic curve implementation follows the interface of Edwards25519Point.stdbase() and Edwards448Point.stdbase() in Appendix A of [RFC8032]:",
      "ja": "次のPythonスニペットは、上記の点を生成します。楕円曲線の実装が[RFC8032]の付録AのEdwards25519Point.stdbase()およびEdwards448Point.stdbase()のインターフェースに従っていると仮定しています。"
    },
    {
      "indent": 3,
      "text": "def iterated_hash(seed, n):\n    h = seed\n    for i in range(n):\n        h = hashlib.sha256(h).digest()\n    return h\n\ndef bighash(seed, start, sz):\n    n = -(-sz // 32)\n    hashes = [iterated_hash(seed, i)\n              for i in range(start, start + n)]\n    return b''.join(hashes)[:sz]\n\ndef canon_pointstr(ecname, s):\n    if ecname == 'edwards25519':\n        return s\n    elif ecname == 'edwards448':\n        return s[:-1] + bytes([s[-1] & 0x80])\n    else:\n        return bytes([(s[0] & 1) | 2]) + s[1:]\n\ndef gen_point(seed, ecname, ec):\n    for i in range(1, 1000):\n        hval = bighash(seed, i, len(ec.encode()))\n        pointstr = canon_pointstr(ecname, hval)\n        try:\n            p = ec.decode(pointstr)\n            if p != ec.zero_elem() and p * p.l() == ec.zero_elem():\n                return pointstr, i\n        except Exception:\n            pass",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. SPAKE2 Test Vectors",
      "section_title": true,
      "ja": "付録B. SPAKE2 テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section contains test vectors for SPAKE2, using the P256-SHA256- HKDF-HMAC ciphersuite. (The choice of MHF is omitted, and the values for w, x, and y are provided directly.) All points are encoded using the uncompressed format, i.e., with a 0x04 octet prefix, specified in [SEC1]. A and B identity strings are provided in the protocol invocation.",
      "ja": "このセクションには、P256-SHA256-HKDF-HMACサイファースイートを使用したSPAKE2のテストベクトルが含まれています。（MHFの選択は省略され、w、x、およびyの値が直接提供されます。）すべてのポイントは、非圧縮形式でエンコードされています。つまり、[SEC1]で指定されている0x04オクテット接頭辞を使用しています。プロトコル呼び出しでAおよびBの識別文字列が提供されます。"
    },
    {
      "indent": 3,
      "text": "Line breaks have been added due to line-length limitations.",
      "ja": "行の長さ制限のため、改行が追加されました。"
    },
    {
      "indent": 3,
      "text": "spake2: A='server', B='client'\nw = 0x2ee57912099d31560b3a44b1184b9b4866e904c49d12ac5042c97dca461b1a5f\nx = 0x43dd0fd7215bdcb482879fca3220c6a968e66d70b1356cac18bb26c84a78d729\npA = 0x04a56fa807caaa53a4d28dbb9853b9815c61a411118a6fe516a8798434751470\nf9010153ac33d0d5f2047ffdb1a3e42c9b4e6be662766e1eeb4116988ede5f912c\ny = 0xdcb60106f276b02606d8ef0a328c02e4b629f84f89786af5befb0bc75b6e66be\npB = 0x0406557e482bd03097ad0cbaa5df82115460d951e3451962f1eaf4367a420676\nd09857ccbc522686c83d1852abfa8ed6e4a1155cf8f1543ceca528afb591a1e0b7\nK = 0x0412af7e89717850671913e6b469ace67bd90a4df8ce45c2af19010175e37eed\n69f75897996d539356e2fa6a406d528501f907e04d97515fbe83db277b715d3325\nTT = 0x06000000000000007365727665720600000000000000636c69656e744100000\n00000000004a56fa807caaa53a4d28dbb9853b9815c61a411118a6fe516a8798434751\n470f9010153ac33d0d5f2047ffdb1a3e42c9b4e6be662766e1eeb4116988ede5f912c4\n1000000000000000406557e482bd03097ad0cbaa5df82115460d951e3451962f1eaf43\n67a420676d09857ccbc522686c83d1852abfa8ed6e4a1155cf8f1543ceca528afb591a\n1e0b741000000000000000412af7e89717850671913e6b469ace67bd90a4df8ce45c2a\nf19010175e37eed69f75897996d539356e2fa6a406d528501f907e04d97515fbe83db2\n77b715d332520000000000000002ee57912099d31560b3a44b1184b9b4866e904c49d1\n2ac5042c97dca461b1a5f\nHASH(TT) = 0x0e0672dc86f8e45565d338b0540abe6915bdf72e2b35b5c9e5663168e9\n60a91b\nKe = 0x0e0672dc86f8e45565d338b0540abe69\nKa = 0x15bdf72e2b35b5c9e5663168e960a91b\nKcA = 0x00c12546835755c86d8c0db7851ae86f\nKcB = 0xa9fa3406c3b781b93d804485430ca27a\nA conf = 0x58ad4aa88e0b60d5061eb6b5dd93e80d9c4f00d127c65b3b35b1b5281f\nee38f0\nB conf = 0xd3e2e547f1ae04f2dbdbf0fc4b79f8ecff2dff314b5d32fe9fcef2fb26\ndc459b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "spake2: A='', B='client'\nw = 0x0548d8729f730589e579b0475a582c1608138ddf7054b73b5381c7e883e2efae\nx = 0x403abbe3b1b4b9ba17e3032849759d723939a27a27b9d921c500edde18ed654b\npA = 0x04a897b769e681c62ac1c2357319a3d363f610839c4477720d24cbe32f5fd8\n5f44fb92ba966578c1b712be6962498834078262caa5b441ecfa9d4a9485720e918a\ny = 0x903023b6598908936ea7c929bd761af6039577a9c3f9581064187c3049d87065\npB = 0x04e0f816fd1c35e22065d5556215c097e799390d16661c386e0ecc84593974\na61b881a8c82327687d0501862970c64565560cb5671f696048050ca66ca5f8cc7fc\nK = 0x048f83ec9f6e4f87cc6f9dc740bdc2769725f923364f01c84148c049a39a735e\nbda82eac03e00112fd6a5710682767cff5361f7e819e53d8d3c3a2922e0d837aa6\nTT = 0x00000000000000000600000000000000636c69656e74410000000000000004a\n897b769e681c62ac1c2357319a3d363f610839c4477720d24cbe32f5fd85f44fb92ba9\n66578c1b712be6962498834078262caa5b441ecfa9d4a9485720e918a4100000000000\n00004e0f816fd1c35e22065d5556215c097e799390d16661c386e0ecc84593974a61b8\n81a8c82327687d0501862970c64565560cb5671f696048050ca66ca5f8cc7fc4100000\n000000000048f83ec9f6e4f87cc6f9dc740bdc2769725f923364f01c84148c049a39a7\n35ebda82eac03e00112fd6a5710682767cff5361f7e819e53d8d3c3a2922e0d837aa62\n0000000000000000548d8729f730589e579b0475a582c1608138ddf7054b73b5381c7e\n883e2efae\nHash(TT) = 0x642f05c473c2cd79909f9a841e2f30a70bf89b18180af97353ba198789\nc2b963\nKe = 0x642f05c473c2cd79909f9a841e2f30a7\nKa = 0x0bf89b18180af97353ba198789c2b963\nKcA = 0xc6be376fc7cd1301fd0a13adf3e7bffd\nKcB = 0xb7243f4ae60440a49b3f8cab3c1fba07\nA conf = 0x47d29e6666af1b7dd450d571233085d7a9866e4d49d2645e2df9754895\n21232b\nB conf = 0x3313c5cefc361d27fb16847a91c2a73b766ffa90a4839122a9b70a2f6b\nd1d6df",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "spake2: A='server', B=''\nw = 0x626e0cdc7b14c9db3e52a0b1b3a768c98e37852d5db30febe0497b14eae8c254\nx = 0x07adb3db6bc623d3399726bfdbfd3d15a58ea776ab8a308b00392621291f9633\npA = 0x04f88fb71c99bfffaea370966b7eb99cd4be0ff1a7d335caac4211c4afd855e2\ne15a873b298503ad8ba1d9cbb9a392d2ba309b48bfd7879aefd0f2cea6009763b0\ny = 0xb6a4fc8dbb629d4ba51d6f91ed1532cf87adec98f25dd153a75accafafedec16\npB = 0x040c269d6be017dccb15182ac6bfcd9e2a14de019dd587eaf4bdfd353f031101\ne7cca177f8eb362a6e83e7d5e729c0732e1b528879c086f39ba0f31a9661bd34db\nK = 0x0445ee233b8ecb51ebd6e7da3f307e88a1616bae2166121221fdc0dadb986afa\nf3ec8a988dc9c626fa3b99f58a7ca7c9b844bb3e8dd9554aafc5b53813504c1cbe\nTT = 0x06000000000000007365727665720000000000000000410000000000000004f\n88fb71c99bfffaea370966b7eb99cd4be0ff1a7d335caac4211c4afd855e2e15a873b2\n98503ad8ba1d9cbb9a392d2ba309b48bfd7879aefd0f2cea6009763b04100000000000\n000040c269d6be017dccb15182ac6bfcd9e2a14de019dd587eaf4bdfd353f031101e7c\nca177f8eb362a6e83e7d5e729c0732e1b528879c086f39ba0f31a9661bd34db4100000\n0000000000445ee233b8ecb51ebd6e7da3f307e88a1616bae2166121221fdc0dadb986\nafaf3ec8a988dc9c626fa3b99f58a7ca7c9b844bb3e8dd9554aafc5b53813504c1cbe2\n000000000000000626e0cdc7b14c9db3e52a0b1b3a768c98e37852d5db30febe0497b1\n4eae8c254\nHash(TT) = 0x005184ff460da2ce59062c87733c299c3521297d736598fc0a1127600e\nfa1afb\nKe = 0x005184ff460da2ce59062c87733c299c\nKa = 0x3521297d736598fc0a1127600efa1afb\nKcA = 0xf3da53604f0aeecea5a33be7bddf6edf\nKcB = 0x9e3f86848736f159bd92b6e107ec6799\nA conf = 0xbc9f9bbe99f26d0b2260e6456e05a86196a3307ec6663a18bf6ac8257365\n33b2\nB conf = 0xc2370e1bf813b086dff0d834e74425a06e6390f48f5411900276dcccc5a2\n97ec",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "spake2: A='', B=''\nw = 0x7bf46c454b4c1b25799527d896508afd5fc62ef4ec59db1efb49113063d70cca\nx = 0x8cef65df64bb2d0f83540c53632de911b5b24b3eab6cc74a97609fd659e95473\npA = 0x04a65b367a3f613cf9f0654b1b28a1e3a8a40387956c8ba6063e8658563890f4\n6ca1ef6a676598889fc28de2950ab8120b79a5ef1ea4c9f44bc98f585634b46d66\ny = 0xd7a66f64074a84652d8d623a92e20c9675c61cb5b4f6a0063e4648a2fdc02d53\npB = 0x04589f13218822710d98d8b2123a079041052d9941b9cf88c6617ddb2fcc0494\n662eea8ba6b64692dc318250030c6af045cb738bc81ba35b043c3dcb46adf6f58d\nK = 0x041a3c03d51b452537ca2a1fea6110353c6d5ed483c4f0f86f4492ca3f378d40\na994b4477f93c64d928edbbcd3e85a7c709b7ea73ee97986ce3d1438e135543772\nTT = 0x00000000000000000000000000000000410000000000000004a65b367a3f613\ncf9f0654b1b28a1e3a8a40387956c8ba6063e8658563890f46ca1ef6a676598889fc28\nde2950ab8120b79a5ef1ea4c9f44bc98f585634b46d66410000000000000004589f132\n18822710d98d8b2123a079041052d9941b9cf88c6617ddb2fcc0494662eea8ba6b6469\n2dc318250030c6af045cb738bc81ba35b043c3dcb46adf6f58d4100000000000000041\na3c03d51b452537ca2a1fea6110353c6d5ed483c4f0f86f4492ca3f378d40a994b4477\nf93c64d928edbbcd3e85a7c709b7ea73ee97986ce3d1438e1355437722000000000000\n0007bf46c454b4c1b25799527d896508afd5fc62ef4ec59db1efb49113063d70cca\nHash(TT) = 0xfc6374762ba5cf11f4b2caa08b2cd1b9907ae0e26e8d6234318d91583c\nd74c86\nKe = 0xfc6374762ba5cf11f4b2caa08b2cd1b9\nKa = 0x907ae0e26e8d6234318d91583cd74c86\nKcA = 0x5dbd2f477166b7fb6d61febbd77a5563\nKcB = 0x7689b4654407a5faeffdc8f18359d8a3\nA conf = 0xdfb4db8d48ae5a675963ea5e6c19d98d4ea028d8e898dad96ea19a80ade9\n5dca\nB conf = 0xd0f0609d1613138d354f7e95f19fb556bf52d751947241e8c7118df5ef0a\ne175",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Special thanks to Nathaniel McCallum and Greg Hudson for generating M and N and Chris Wood for generating test vectors. Thanks to Mike Hamburg for advice on how to deal with cofactors. Greg Hudson also suggested the addition of warnings on the reuse of x and y. Thanks to Fedor Brunner, Adam Langley, Liliya Akhmetzyanova, and the members of the CFRG for comments and advice. Thanks to Scott Fluhrer and those Crypto Panel experts involved in the PAKE selection process (https://github.com/cfrg/pake-selection) who have provided valuable comments. Chris Wood contributed substantial text and reformatting to address the excellent review comments from Kenny Paterson.",
      "ja": "Nathaniel McCallumとGreg HudsonにMとNを生成していただいたことに特別な感謝を申し上げます。また、Chris Woodにテストベクトルを生成していただいたことに感謝します。共因子の取り扱いに関するアドバイスをいただいたMike Hamburgに感謝します。Greg Hudsonはxとyの再利用に関する警告の追加を提案してくれました。コメントやアドバイスをくれたFedor Brunner、Adam Langley、Liliya Akhmetzyanova、およびCFRGのメンバーに感謝します。貴重なコメントをいただいた、PAKE選定プロセス（https://github.com/cfrg/pake-selection）に関与したScott FluhrerやCrypto Panelの専門家の皆様に感謝します。Chris WoodはKenny Patersonからの優れたレビューコメントに対処するために、かなりの量のテキストの執筆と再フォーマットを行い、貢献しました。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "section_title": true,
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "Benjamin Kaduk\nAkamai Technologies\nEmail: kaduk@mit.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "section_title": true,
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Watson Ladd\nAkamai Technologies\nEmail: watsonbladd@gmail.com",
      "raw": true,
      "ja": ""
    }
  ]
}