{
  "title": {
    "text": "RFC 9460 - Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records)",
    "ja": "RFC 9460 - DNSを介したサービスのバインディングとパラメーターの仕様（SVCBおよびHTTPSリソースレコード）"
  },
  "number": 9460,
  "created_at": "2024-03-02 11:24:30.433076+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       B. Schwartz\nRequest for Comments: 9460                          Meta Platforms, Inc.\nCategory: Standards Track                                      M. Bishop\nISSN: 2070-1721                                                E. Nygren\n                                                     Akamai Technologies\n                                                           November 2023",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records)",
      "title": true,
      "section_title": true,
      "ja": "DNSを介したサービスのバインディングとパラメーターの仕様（SVCBおよびHTTPSリソースレコード）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies the \"SVCB\" (\"Service Binding\") and \"HTTPS\" DNS resource record (RR) types to facilitate the lookup of information needed to make connections to network services, such as for HTTP origins. SVCB records allow a service to be provided from multiple alternative endpoints, each with associated parameters (such as transport protocol configuration), and are extensible to support future uses (such as keys for encrypting the TLS ClientHello). They also enable aliasing of apex domains, which is not possible with CNAME. The HTTPS RR is a variation of SVCB for use with HTTP (see RFC 9110, \"HTTP Semantics\"). By providing more information to the client before it attempts to establish a connection, these records offer potential benefits to both performance and privacy.",
      "ja": "このドキュメントは、「SVCB」（「サービスバインディング」）および「HTTPS」DNSリソースレコード（RR）タイプを指定して、HTTPオリジンなど、ネットワークサービスに接続するために必要な情報の検索を容易にします。SVCBレコードにより、それぞれに関連付けられたパラメーター（トランスポートプロトコル構成など）を備えた複数の代替エンドポイントからサービスを提供することが可能になり、将来の用途（TLS ClientHelloを暗号化するためのキーなど）をサポートするために拡張可能です。また、CNAMEでは不可能なゾーン頂点（apex）でのエイリアシングも可能にします。HTTPS RRは、HTTPで使用するSVCBのバリエーションです（RFC 9110、「HTTP Semantics」を参照）。接続を確立しようとする前にクライアントにより多くの情報を提供することにより、これらのレコードはパフォーマンスとプライバシーの両方に潜在的な利点を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9460.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9460で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2023 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Goals\n  1.2.  Overview of the SVCB RR\n  1.3.  Terminology\n2.  The SVCB Record Type\n  2.1.  Zone-File Presentation Format\n  2.2.  RDATA Wire Format\n  2.3.  SVCB Query Names\n  2.4.  Interpretation\n    2.4.1.  SvcPriority\n    2.4.2.  AliasMode\n    2.4.3.  ServiceMode\n  2.5.  Special Handling of \".\" in TargetName\n    2.5.1.  AliasMode\n    2.5.2.  ServiceMode\n3.  Client Behavior\n  3.1.  Handling Resolution Failures\n  3.2.  Clients Using a Proxy\n4.  DNS Server Behavior\n  4.1.  Authoritative Servers\n  4.2.  Recursive Resolvers\n    4.2.1.  DNS64\n  4.3.  General Requirements\n  4.4.  EDNS Client Subnet (ECS)\n5.  Performance Optimizations\n  5.1.  Optimistic Pre-connection and Connection Reuse\n  5.2.  Generating and Using Incomplete Responses\n6.  SVCB-Compatible RR Types\n7.  Initial SvcParamKeys\n  7.1.  \"alpn\" and \"no-default-alpn\"\n    7.1.1.  Representation\n    7.1.2.  Use\n  7.2.  \"port\"\n  7.3.  \"ipv4hint\" and \"ipv6hint\"\n  7.4.  \"mandatory\"\n8.  ServiceMode RR Compatibility and Mandatory Keys\n9.  Using Service Bindings with HTTP\n  9.1.  Query Names for HTTPS RRs\n  9.2.  Comparison with Alt-Svc\n    9.2.1.  ALPN Usage\n    9.2.2.  Untrusted Channels\n    9.2.3.  Cache Lifetime\n    9.2.4.  Granularity\n  9.3.  Interaction with Alt-Svc\n  9.4.  Requiring Server Name Indication\n  9.5.  HTTP Strict Transport Security (HSTS)\n  9.6.  Use of HTTPS RRs in Other Protocols\n10. Zone Structures\n  10.1.  Structuring Zones for Flexibility\n  10.2.  Structuring Zones for Performance\n  10.3.  Operational Considerations\n  10.4.  Examples\n    10.4.1.  Protocol Enhancements\n    10.4.2.  Apex Aliasing\n    10.4.3.  Parameter Binding\n    10.4.4.  Multi-CDN Configuration\n    10.4.5.  Non-HTTP Uses\n11. Interaction with Other Standards\n12. Security Considerations\n13. Privacy Considerations\n14. IANA Considerations\n  14.1.  SVCB RR Type\n  14.2.  HTTPS RR Type\n  14.3.  New Registry for Service Parameters\n    14.3.1.  Procedure\n    14.3.2.  Initial Contents\n  14.4.  Other Registry Updates\n15. References\n  15.1.  Normative References\n  15.2.  Informative References\nAppendix A.  Decoding Text in Zone Files\n  A.1.  Decoding a Comma-Separated List\nAppendix B.  HTTP Mapping Summary\nAppendix C.  Comparison with Alternatives\n  C.1.  Differences from the SRV RR Type\n  C.2.  Differences from the Proposed HTTP Record\n  C.3.  Differences from the Proposed ANAME Record\n  C.4.  Comparison with Separate RR Types for AliasMode and\n        ServiceMode\nAppendix D.  Test Vectors\n  D.1.  AliasMode\n  D.2.  ServiceMode\n  D.3.  Failure Cases\nAcknowledgments and Related Proposals\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The SVCB (\"Service Binding\") and HTTPS resource records (RRs) provide clients with complete instructions for access to a service. This information enables improved performance and privacy by avoiding transient connections to a suboptimal default server, negotiating a preferred protocol, and providing relevant public keys.",
      "ja": "SVCB（「サービスバインディング」）およびHTTPSリソースレコード（RR）は、サービスへアクセスするための完全な指示をクライアントに提供します。この情報により、最適ではないデフォルトサーバーへの一時的な接続を回避し、優先プロトコルをネゴシエートし、関連する公開鍵を提供することで、パフォーマンスとプライバシーの向上が可能になります。"
    },
    {
      "indent": 3,
      "text": "For example, HTTP clients currently resolve only A and/or AAAA records for the origin hostname, learning only its IP addresses. If an HTTP client learns more about the origin before connecting, it may be able to upgrade \"http\" URLs to \"https\", enable HTTP/3 or Encrypted ClientHello [ECH], or switch to an operationally preferable endpoint. It is highly desirable to minimize the number of round trips and lookups required to learn this additional information.",
      "ja": "たとえば、HTTPクライアントは現在、オリジンホスト名のAおよび/またはAAAAレコードのみを解決し、IPアドレスのみを学習しています。HTTPクライアントが接続する前にオリジンについてさらに学習した場合、「http」URLを「https」にアップグレードしたり、HTTP/3やEncrypted ClientHello [ECH]を有効にしたり、運用上好ましいエンドポイントに切り替えたりできる場合があります。この追加情報を学習するために必要なラウンドトリップと検索の数を最小限に抑えることが非常に望ましいです。"
    },
    {
      "indent": 3,
      "text": "The SVCB and HTTPS RRs also help when the operator of a service wishes to delegate operational control to one or more other domains, e.g., aliasing the origin \"https://example.com\" to a service operator endpoint at \"svc.example.net\". While this case can sometimes be handled by a CNAME, that does not cover all use cases. CNAME is also inadequate when the service operator needs to provide a bound collection of consistent configuration parameters through the DNS (such as network location, protocol, and keying information).",
      "ja": "SVCBおよびHTTPS RRは、たとえば、オリジン「https://example.com」を「svc.example.net」にあるサービスオペレーターのエンドポイントにエイリアスするなど、サービスのオペレーターが運用管理を1つ以上の他のドメインに委任したい場合にも役立ちます。このケースはCNAMEによって処理される場合がありますが、すべてのユースケースをカバーするわけではありません。また、サービスオペレーターがDNSを介してバインドされた一貫した構成パラメーターのセット（ネットワークの場所、プロトコル、キー情報など）を提供する必要がある場合、CNAMEは不十分です。"
    },
    {
      "indent": 3,
      "text": "This document first describes the SVCB RR as a general-purpose RR that can be applied directly and efficiently to a wide range of services (Section 2). It also describes the rules for defining other SVCB-compatible RR types (Section 6), starting with the HTTPS RR type (Section 9), which provides improved efficiency and convenience with HTTP by avoiding the need for an Attrleaf label [Attrleaf] (Section 9.1).",
      "ja": "このドキュメントでは、最初にSVCB RRを、広範囲のサービスに直接かつ効率的に適用できる汎用RRとして説明します（セクション2）。また、HTTPS RRタイプ（セクション9）をはじめとする、他のSVCB互換RRタイプを定義するためのルールについても説明します（セクション6）。HTTPS RRタイプは、Attrleafラベル[Attrleaf]を不要にすることで、HTTPにおける効率と利便性を向上させます（セクション9.1）。"
    },
    {
      "indent": 3,
      "text": "The SVCB RR has two modes: 1) \"AliasMode\", which simply delegates operational control for a resource and 2) \"ServiceMode\", which binds together configuration information for a service endpoint. ServiceMode provides additional key=value parameters within each RDATA set.",
      "ja": "SVCB RRには2つのモードがあります。1）リソースの運用制御を単に委任する「AliasMode」、および2）サービスエンドポイントの構成情報をバインドする「ServiceMode」です。ServiceModeは、各RDATAセット内に追加のkey=valueパラメーターを提供します。"
    },
    {
      "indent": 0,
      "text": "1.1. Goals",
      "section_title": true,
      "ja": "1.1. 目標"
    },
    {
      "indent": 3,
      "text": "The goal of the SVCB RR is to allow clients to resolve a single additional DNS RR in a way that:",
      "ja": "SVCB RRの目標は、クライアントが次の方法で単一の追加のDNS RRを解決できるようにすることです。"
    },
    {
      "indent": 6,
      "text": "* Provides alternative endpoints that are authoritative for the service, along with parameters associated with each of these endpoints.",
      "ja": "* サービスに対して権威のある代替エンドポイントを、それらの各エンドポイントに関連付けられたパラメーターとともに提供します。"
    },
    {
      "indent": 6,
      "text": "* Does not assume that all alternative endpoints have the same parameters or capabilities, or are even operated by the same entity. This is important, as DNS does not provide any way to tie together multiple RRsets for the same name. For example, if \"www.example.com\" is a CNAME alias that switches between one of three Content Delivery Networks (CDNs) or hosting environments, successive queries for that name may return records that correspond to different environments.",
      "ja": "* すべての代替エンドポイントが同じパラメーターや機能を持っていること、あるいは同じエンティティによって運用されていることさえも想定しません。DNSは同じ名前の複数のRRsetを結び付ける方法を提供しないため、これは重要です。たとえば、「www.example.com」が3つのコンテンツ配信ネットワーク（CDN）またはホスティング環境のいずれかを切り替えるCNAMEエイリアスである場合、その名前の後続のクエリは、異なる環境に対応するレコードを返す可能性があります。"
    },
    {
      "indent": 6,
      "text": "* Enables CNAME-like functionality at a zone apex (such as \"example.com\") for participating protocols and generally enables extending operational authority for a service identified by a domain name to other instances with alternate names.",
      "ja": "* 参加プロトコルに対してゾーン頂点（apex）（「example.com」など）でCNAMEのような機能を有効にし、一般に、ドメイン名で識別されるサービスの運用権限を、別の名前を持つ他のインスタンスに拡張できるようにします。"
    },
    {
      "indent": 3,
      "text": "Additional goals specific to HTTPS RRs and the HTTP use cases include:",
      "ja": "HTTPS RRおよびHTTPユースケースに固有の追加の目標は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* Connecting directly to HTTP/3 (QUIC transport) alternative endpoints [HTTP/3].",
      "ja": "* HTTP/3（QUICトランスポート）の代替エンドポイント[HTTP/3]に直接接続します。"
    },
    {
      "indent": 6,
      "text": "* Supporting non-default TCP and UDP ports.",
      "ja": "* 非デフォルトTCPおよびUDPポートのサポート。"
    },
    {
      "indent": 6,
      "text": "* Enabling SRV-like benefits (e.g., apex aliasing, as mentioned above) for HTTP, where SRV [SRV] has not been widely adopted.",
      "ja": "* SRV [SRV]が広く採用されていないHTTPに対して、SRVのような利点（上記のようなApexエイリアシング（頂点エイリアシング）など）を有効にします。"
    },
    {
      "indent": 6,
      "text": "* Providing an indication signaling that the \"https\" scheme should be used instead of \"http\" for all HTTP requests to this host and port, similar to HTTP Strict Transport Security [HSTS] (see Section 9.5).",
      "ja": "* HTTP Strict Transport Security [HSTS]と同様に、このホストとポートへのすべてのHTTPリクエストに対して、「http」スキームの代わりに「https」スキームを使用する必要があることを示すシグナルを提供します（セクション9.5を参照）。"
    },
    {
      "indent": 6,
      "text": "* Enabling the conveyance of Encrypted ClientHello keys [ECH] associated with an alternative endpoint.",
      "ja": "* 代替エンドポイントに関連付けられたEncrypted ClientHello [ECH] キーの伝達を可能にします。"
    },
    {
      "indent": 0,
      "text": "1.2. Overview of the SVCB RR",
      "section_title": true,
      "ja": "1.2. SVCB RRの概要"
    },
    {
      "indent": 3,
      "text": "This subsection briefly describes the SVCB RR with forward references to the full exposition of each component. (As discussed in Section 6, this all applies equally to the HTTPS RR, which shares the same encoding, format, and high-level semantics.)",
      "ja": "このサブセクションでは、各コンポーネントの詳細な説明への前方参照を用いてSVCB RRについて簡単に説明します。（セクション6で説明したように、これはすべて、同じエンコード、形式、および高レベルのセマンティクスを共有するHTTPS RRに等しく適用されます。）"
    },
    {
      "indent": 3,
      "text": "The SVCB RR has two modes: 1) AliasMode (Section 2.4.2), which aliases a name to another name and 2) ServiceMode (Section 2.4.3), which provides connection information bound to a service endpoint domain. Placing both forms in a single RR type allows clients to fetch the relevant information with a single query (Section 2.3).",
      "ja": "SVCB RRには2つのモードがあります。1）ある名前を別の名前にエイリアスするAliasMode（セクション2.4.2）、および2）サービスエンドポイントドメインにバインドされた接続情報を提供するServiceMode（セクション2.4.3）です。両方の形式を単一のRRタイプに配置することで、クライアントは単一のクエリ（セクション2.3）で関連情報を取得できます。"
    },
    {
      "indent": 3,
      "text": "The SVCB RR has two required fields and one optional field. The fields are:",
      "ja": "SVCB RRには、2つの必須フィールドと1つのオプションフィールドがあります。フィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "SvcPriority (Section 2.4.1):",
      "ja": "SvcPriority（セクション2.4.1）："
    },
    {
      "indent": 12,
      "text": "The priority of this record (relative to others, with lower values preferred). A value of 0 indicates AliasMode.",
      "ja": "このレコードの優先順位（他のレコードと比較して、低い値が好ましい）。0の値は、AliasModeを示します。"
    },
    {
      "indent": 3,
      "text": "TargetName:",
      "ja": "TargetName："
    },
    {
      "indent": 12,
      "text": "The domain name of either the alias target (for AliasMode) or the alternative endpoint (for ServiceMode).",
      "ja": "エイリアスターゲット（AliasModeの場合）または代替エンドポイント（ServiceModeの場合）のドメイン名。"
    },
    {
      "indent": 3,
      "text": "SvcParams (optional):",
      "ja": "SvcParams（オプション）："
    },
    {
      "indent": 12,
      "text": "A list of key=value pairs describing the alternative endpoint at TargetName (only used in ServiceMode and otherwise ignored). SvcParams are described in Section 2.1.",
      "ja": "TargetNameでの代替エンドポイントを説明するkey=valueペアのリスト（ServiceModeでのみ使用され、それ以外の場合は無視されます）。SvcParamsはセクション2.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "Cooperating DNS recursive resolvers will perform subsequent record resolution (for SVCB, A, and AAAA records) and return them in the Additional section of the response (Section 4.2). Clients either use responses included in the Additional section returned by the recursive resolver or perform necessary SVCB, A, and AAAA record resolutions (Section 3). DNS authoritative servers can attach in-bailiwick SVCB, A, AAAA, and CNAME records in the Additional section to responses for a SVCB query (Section 4.1).",
      "ja": "連携するDNS再帰リゾルバーは、後続のレコード解決（SVCB、A、およびAAAAレコードの場合）を実行し、それらを応答のAdditionalセクション（セクション4.2）で返します。クライアントは、再帰リゾルバーによって返されたAdditionalセクションに含まれる応答を使用するか、必要なSVCB、A、およびAAAAレコード解決を実行します（セクション3）。DNS権威サーバーは、SVCBクエリへの応答のAdditionalセクションに、ベイリウィック内（in-bailiwick）のSVCB、A、AAAA、およびCNAMEレコードを添付できます（セクション4.1）。"
    },
    {
      "indent": 3,
      "text": "In ServiceMode, the SvcParams of the SVCB RR provide an extensible data model for describing alternative endpoints that are authoritative for a service, along with parameters associated with each of these alternative endpoints (Section 7).",
      "ja": "ServiceModeでは、SVCB RRのSvcParamsは、これらの各代替エンドポイントに関連付けられたパラメーターとともに、サービスに対して権威のある代替エンドポイントを記述するための拡張可能なデータモデルを提供します（セクション7）。"
    },
    {
      "indent": 3,
      "text": "For HTTP use cases, the HTTPS RR (Section 9) enables many of the benefits of Alt-Svc [AltSvc] without waiting for a full HTTP connection initiation (multiple round trips) before learning of the preferred alternative, and without necessarily revealing the user's intended destination to all entities along the network path.",
      "ja": "HTTPユースケースの場合、HTTPS RR（セクション9）は、優先される代替手段を知る前に完全なHTTP接続開始（複数のラウンドトリップ）を待つことなく、また、ネットワークパスに沿ったすべてのエンティティにユーザーの意図した宛先を必ずしも明らかにすることなく、Alt-Svc [AltSvc]の多くの利点を可能にします。"
    },
    {
      "indent": 0,
      "text": "1.3. Terminology",
      "section_title": true,
      "ja": "1.3. 用語"
    },
    {
      "indent": 3,
      "text": "Terminology in this document is based on the common case where the SVCB record is used to access a resource identified by a URI whose authority field contains a DNS hostname as the host.",
      "ja": "このドキュメントの用語は、SVCBレコードを使用して、authorityフィールドがホストとしてDNSホスト名を含むURIによって識別されるリソースにアクセスするために使用される一般的なケースに基づいています。"
    },
    {
      "indent": 6,
      "text": "* The \"service\" is the information source identified by the authority and scheme of the URI, capable of providing access to the resource. For \"https\" URIs, the \"service\" corresponds to an \"origin\" [RFC6454].",
      "ja": "* 「サービス」は、リソースへのアクセスを提供できるURIのオーソリティとスキームによって識別される情報源です。「https」URIの場合、「サービス」は「オリジン」[RFC6454]に対応します。"
    },
    {
      "indent": 6,
      "text": "* The \"service name\" is the host portion of the authority.",
      "ja": "* 「サービス名」はオーソリティのホスト部分です。"
    },
    {
      "indent": 6,
      "text": "* The \"authority endpoint\" is the authority's hostname and a port number implied by the scheme or specified in the URI.",
      "ja": "* 「オーソリティエンドポイント」は、オーソリティのホスト名と、スキームによって暗示されるかURIで指定されたポート番号です。"
    },
    {
      "indent": 6,
      "text": "* An \"alternative endpoint\" is a hostname, port number, and other associated instructions to the client on how to reach an instance of a service.",
      "ja": "* 「代替エンドポイント」は、サービスのインスタンスに到達する方法に関するホスト名、ポート番号、およびその他の関連する指示です。"
    },
    {
      "indent": 3,
      "text": "Additional DNS terminology intends to be consistent with [DNSTerm].",
      "ja": "追加のDNS用語は、[DNSTerm]と一致することを意図しています。"
    },
    {
      "indent": 3,
      "text": "SVCB is a contraction of \"service binding\". The SVCB RR, HTTPS RR, and future RR types that share SVCB's formats and registry are collectively known as SVCB-compatible RR types. The contraction \"SVCB\" is also used to refer to this system as a whole.",
      "ja": "SVCBは「サービスバインディング」の略称です。SVCBのフォーマットとレジストリを共有するSVCB RR、HTTPS RR、および将来のRRタイプは、総称してSVCB互換RRタイプと呼ばれます。略称「SVCB」は、このシステム全体を指すためにも使用されます。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. The SVCB Record Type",
      "section_title": true,
      "ja": "2. SVCBレコードタイプ"
    },
    {
      "indent": 3,
      "text": "The SVCB DNS RR type (RR type 64) is used to locate alternative endpoints for a service.",
      "ja": "SVCB DNS RRタイプ（RRタイプ64）は、サービスの代替エンドポイントを特定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The algorithm for resolving SVCB records and associated address records is specified in Section 3.",
      "ja": "SVCBレコードと関連するアドレスレコードを解決するためのアルゴリズムは、セクション3で指定されています。"
    },
    {
      "indent": 3,
      "text": "Other SVCB-compatible RR types can also be defined as needed (see Section 6). In particular, the HTTPS RR (RR type 65) provides special handling for the case of \"https\" origins as described in Section 9.",
      "ja": "他のSVCB互換RRタイプも、必要に応じて定義できます（セクション6を参照）。特に、HTTPS RR（RRタイプ65）は、セクション9で説明されている「HTTPS」起源の場合の特別な取り扱いを提供します。"
    },
    {
      "indent": 3,
      "text": "SVCB RRs are extensible by a list of SvcParams, which are pairs consisting of a SvcParamKey and a SvcParamValue. Each SvcParamKey has a presentation name and a registered number. Values are in a format specific to the SvcParamKey. Each SvcParam has a specified presentation format (used in zone files) and wire encoding (e.g., domain names, binary data, or numeric values). The initial SvcParamKeys and their formats are defined in Section 7.",
      "ja": "SVCB RRは、SvcParamKeyとSvcParamValueで構成されるペアであるSvcParamsのリストによって拡張可能です。各SvcParamKeyには、プレゼンテーション名と登録番号があります。値は、SvcParamKeyに固有の形式です。各SvcParamには、指定されたプレゼンテーション形式（ゾーンファイルで使用）とワイヤーエンコード（ドメイン名、バイナリデータ、または数値）があります。最初のSvcParamKeysとその形式は、セクション7で定義されています。"
    },
    {
      "indent": 0,
      "text": "2.1. Zone-File Presentation Format",
      "section_title": true,
      "ja": "2.1. ゾーンファイルのプレゼンテーション形式"
    },
    {
      "indent": 3,
      "text": "The presentation format <RDATA> of the record ([RFC1035], Section 5.1) has the form:",
      "ja": "レコード（[RFC1035]、セクション5.1）のプレゼンテーション形式<rdata>には次の形式があります。"
    },
    {
      "indent": 3,
      "text": "SvcPriority TargetName SvcParams",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SVCB record is defined specifically within the Internet (\"IN\") Class ([RFC1035], Section 3.2.4).",
      "ja": "SVCBレコードは、インターネット（ \"IN\"）クラス（[RFC1035]、セクション3.2.4）内で具体的に定義されています。"
    },
    {
      "indent": 3,
      "text": "SvcPriority is a number in the range 0-65535, TargetName is a <domain-name> ([RFC1035], Section 5.1), and the SvcParams are a whitespace-separated list with each SvcParam consisting of a SvcParamKey=SvcParamValue pair or a standalone SvcParamKey. SvcParamKeys are registered by IANA (Section 14.3).",
      "ja": "SvcPriorityは0〜65535の範囲の数値であり、TargetNameは<domain-name>（[RFC1035]、セクション5.1）であり、SvcParamsは空白区切りのリストであり、各SvcParamはSvcParamKey=SvcParamValueペアまたはスタンドアロンのSvcParamKeyで構成されます。SvcParamKeysはIANAによって登録されています（セクション14.3）。"
    },
    {
      "indent": 3,
      "text": "Each SvcParamKey SHALL appear at most once in the SvcParams. In presentation format, SvcParamKeys are lowercase alphanumeric strings. Key names contain 1-63 characters from the ranges \"a\"-\"z\", \"0\"-\"9\", and \"-\". In ABNF [RFC5234],",
      "ja": "各SvcParamKeyは、SvcParamsに最大1回出現するものとします。プレゼンテーション形式では、SvcParamKeysは小文字の英数字の文字列です。キー名には、「a」〜「z」、「0」〜「9」、および「-」の範囲からの1〜63文字が含まれています。ABNF [RFC5234]では、"
    },
    {
      "indent": 3,
      "text": "alpha-lc      = %x61-7A   ; a-z\nSvcParamKey   = 1*63(alpha-lc / DIGIT / \"-\")\nSvcParam      = SvcParamKey [\"=\" SvcParamValue]\nSvcParamValue = char-string ; See Appendix A.\nvalue         = *OCTET ; Value before key-specific parsing",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The SvcParamValue is parsed using the character-string decoding algorithm (Appendix A), producing a value. The value is then validated and converted into wire format in a manner specific to each key.",
      "ja": "SvcParamValueは、文字列デコードアルゴリズム（付録A）を使用して解析され、値を生成します。次に、値が検証され、各キーに固有の方法でワイヤー形式に変換されます。"
    },
    {
      "indent": 3,
      "text": "When the optional \"=\" and SvcParamValue are omitted, the value is interpreted as empty.",
      "ja": "オプションの \"=\"とSvcParamValueが省略されている場合、値は空であると解釈されます。"
    },
    {
      "indent": 3,
      "text": "Arbitrary keys can be represented using the unknown-key presentation format \"keyNNNNN\" where NNNNN is the numeric value of the key type without leading zeros. A SvcParam in this form SHALL be parsed as specified above, and the decoded value SHALL be used as its wire-format encoding.",
      "ja": "任意のキーは、不明なキープレゼンテーション形式「keyNNNNN」を使用して表現できます。ここで、NNNNNは先頭のゼロなしのキータイプの数値です。この形式のSvcParamは、上記で指定されているように解析され、デコードされた値はそのワイヤー形式のエンコードとして使用するものとします。"
    },
    {
      "indent": 3,
      "text": "For some SvcParamKeys, the value corresponds to a list or set of items. Presentation formats for such keys SHOULD use a comma-separated list (Appendix A.1).",
      "ja": "一部のSvcParamKeysの場合、値はリストまたはアイテムのセットに対応します。このようなキーのプレゼンテーション形式は、コンマ区切りリストを使用する必要があります（付録A.1）。"
    },
    {
      "indent": 3,
      "text": "SvcParams in presentation format MAY appear in any order, but keys MUST NOT be repeated.",
      "ja": "プレゼンテーション形式のSvcParamsは任意の順序で表示される場合がありますが、キーを繰り返してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. RDATA Wire Format",
      "section_title": true,
      "ja": "2.2. rdataワイヤ形式"
    },
    {
      "indent": 3,
      "text": "The RDATA for the SVCB RR consists of:",
      "ja": "SVCB RRのRDATAは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* a 2-octet field for SvcPriority as an integer in network byte order.",
      "ja": "* ネットワークバイト順序での整数としてのSvcPriorityの2オクテットフィールド。"
    },
    {
      "indent": 6,
      "text": "* the uncompressed, fully qualified TargetName, represented as a sequence of length-prefixed labels per Section 3.1 of [RFC1035].",
      "ja": "* [RFC1035]のセクション3.1に従って、長さのプレフィックスが付いた一連のラベルとして表される、圧縮されていない完全修飾ドメイン名（TargetName）。"
    },
    {
      "indent": 6,
      "text": "* the SvcParams, consuming the remainder of the record (so smaller than 65535 octets and constrained by the RDATA and DNS message sizes).",
      "ja": "* SvcParams。レコードの残りの部分を占めます（したがって65535オクテット未満であり、RDATAおよびDNSメッセージサイズによって制約されます）。"
    },
    {
      "indent": 3,
      "text": "When the list of SvcParams is non-empty, it contains a series of SvcParamKey=SvcParamValue pairs, represented as:",
      "ja": "SvcParamsのリストが空でない場合、次のように表される一連のSvcParamKey=SvcParamValueペアが含まれています。"
    },
    {
      "indent": 6,
      "text": "* a 2-octet field containing the SvcParamKey as an integer in network byte order. (See Section 14.3.2 for the defined values.)",
      "ja": "* ネットワークバイトの順序で整数としてSvcParamKeyを含む2オクテットフィールド。（定義された値については、セクション14.3.2を参照してください。）"
    },
    {
      "indent": 6,
      "text": "* a 2-octet field containing the length of the SvcParamValue as an integer between 0 and 65535 in network byte order.",
      "ja": "* ネットワークバイトの順序で0〜65535の間の整数としてSvcParamValueの長さを含む2オクテットのフィールド。"
    },
    {
      "indent": 6,
      "text": "* an octet string of this length whose contents are the SvcParamValue in a format determined by the SvcParamKey.",
      "ja": "* この長さのオクテット文字列は、SvcParamKeyによって決定された形式で内容がSvcParamValueである。"
    },
    {
      "indent": 3,
      "text": "SvcParamKeys SHALL appear in increasing numeric order.",
      "ja": "SvcParamKeysは、数値の昇順で出現するものとします。"
    },
    {
      "indent": 3,
      "text": "Clients MUST consider an RR malformed if:",
      "ja": "クライアントは、次の場合、RRが不正であると見なさなければなりません。"
    },
    {
      "indent": 6,
      "text": "* the end of the RDATA occurs within a SvcParam.",
      "ja": "* RDATAの終端がSvcParam内で発生する場合。"
    },
    {
      "indent": 6,
      "text": "* SvcParamKeys are not in strictly increasing numeric order.",
      "ja": "* SvcParamKeysは、厳密な数値の昇順になっていません。"
    },
    {
      "indent": 6,
      "text": "* the SvcParamValue for a SvcParamKey does not have the expected format.",
      "ja": "* SvcParamKeyのSvcParamValueには、予想される形式がありません。"
    },
    {
      "indent": 3,
      "text": "Note that the second condition implies that there are no duplicate SvcParamKeys.",
      "ja": "2番目の条件は、SvcParamKeysが重複していないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "If any RRs are malformed, the client MUST reject the entire RRset and fall back to non-SVCB connection establishment.",
      "ja": "RRが不正である場合、クライアントはRRset全体を拒否し、非SVCB接続確立にフォールバックする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3. SVCB Query Names",
      "section_title": true,
      "ja": "2.3. SVCBクエリ名"
    },
    {
      "indent": 3,
      "text": "When querying the SVCB RR, a service is translated into a QNAME by prepending the service name with a label indicating the scheme, prefixed with an underscore, resulting in a domain name like \"_examplescheme.api.example.com.\". This follows the Attrleaf naming pattern [Attrleaf], so the scheme MUST be registered appropriately with IANA (see Section 11).",
      "ja": "SVCB RRを問い合わせるとき、サービスは、アンダースコアを接頭辞としたスキームを示すラベルをサービス名の前に付加することでQNAMEに変換され、「_examplescheme.api.example.com.」のようなドメイン名になります。これはAttrleaf命名パターン[Attrleaf]に従うため、スキームはIANAに適切に登録する必要があります（セクション11を参照）。"
    },
    {
      "indent": 3,
      "text": "Protocol mapping documents MAY specify additional underscore-prefixed labels to be prepended. For schemes that specify a port (Section 3.2.3 of [URI]), one reasonable possibility is to prepend the indicated port number if a non-default port number is specified. This document terms this behavior \"Port Prefix Naming\" and uses it in the examples throughout.",
      "ja": "プロトコルマッピングドキュメントでは、前に追加するアンダースコア付きラベルをさらに指定する場合があります。ポート（[URI]のセクション3.2.3）を指定するスキームの場合、非デフォルトのポート番号が指定されている場合、指定されたポート番号を付加することが1つの合理的な可能性です。このドキュメントでは、この動作を「ポートプレフィックスネーミング（Port Prefix Naming）」と呼び、全体を通して例で使用します。"
    },
    {
      "indent": 3,
      "text": "See Section 9.1 for information regarding HTTPS RR behavior.",
      "ja": "HTTPS RRの動作に関する情報については、セクション9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a prior CNAME or SVCB record has aliased to a SVCB record, each RR SHALL be returned under its own owner name, as in ordinary CNAME processing ([RFC1034], Section 3.6.2). For details, see the recommendations regarding aliases for clients (Section 3), servers (Section 4), and zones (Section 10).",
      "ja": "以前のCNAMEまたはSVCBレコードがSVCBレコードにエイリアスされた場合、通常のCNAME処理（[RFC1034]、セクション3.6.2）のように、各RRは独自の所有者名で返されます。詳細については、クライアント（セクション3）、サーバー（セクション4）、ゾーン（セクション10）に関するエイリアスに関する推奨事項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that none of these forms alter the origin or authority for validation purposes. For example, TLS clients MUST continue to validate TLS certificates for the original service name.",
      "ja": "これらのフォームのいずれも、検証目的でオリジンまたは権限を変更しないことに注意してください。たとえば、TLSクライアントは、元のサービス名のTLS証明書を引き続き検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "As an example, the owner of \"example.com\" could publish this record:",
      "ja": "例として、「Example.com」の所有者はこのレコードを公開できます。"
    },
    {
      "indent": 3,
      "text": "_8443._foo.api.example.com. 7200 IN SVCB 0 svc4.example.net.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This record would indicate that \"foo://api.example.com:8443\" is aliased to \"svc4.example.net\". The owner of \"example.net\", in turn, could publish this record:",
      "ja": "このレコードは、「foo：//api.example.com：8443」が「svc4.example.net」にエイリアスされることを示します。「example.net」の所有者は、このレコードを公開できます。"
    },
    {
      "indent": 3,
      "text": "svc4.example.net.  7200  IN SVCB 3 svc4.example.net. (\n    alpn=\"bar\" port=\"8004\" )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This record would indicate that these services are served on port number 8004, which supports the protocol \"bar\" and its associated transport in addition to the default transport protocol for \"foo://\".",
      "ja": "この記録は、これらのサービスがポート番号8004で提供されていることを示しています。これは、「foo：//」のデフォルトの輸送プロトコルに加えて、プロトコル「bar」とその関連するトランスポートをサポートします。"
    },
    {
      "indent": 3,
      "text": "(Parentheses are used to ignore a line break in DNS zone-file presentation format, per Section 5.1 of [RFC1035].)",
      "ja": "（括弧は、[RFC1035]のセクション5.1に従って、DNSゾーンファイルのプレゼンテーション形式のラインブレイクを無視するために使用されます。）"
    },
    {
      "indent": 0,
      "text": "2.4. Interpretation",
      "section_title": true,
      "ja": "2.4. 解釈"
    },
    {
      "indent": 0,
      "text": "2.4.1. SvcPriority",
      "section_title": true,
      "ja": "2.4.1. svcpriority"
    },
    {
      "indent": 3,
      "text": "When SvcPriority is 0, the SVCB record is in AliasMode (Section 2.4.2). Otherwise, it is in ServiceMode (Section 2.4.3).",
      "ja": "SvcPriorityが0の場合、SVCBレコードはAliasModeにあります（セクション2.4.2）。それ以外の場合は、ServiceMode（セクション2.4.3）にあります。"
    },
    {
      "indent": 3,
      "text": "Within a SVCB RRset, all RRs SHOULD have the same mode. If an RRset contains a record in AliasMode, the recipient MUST ignore any ServiceMode records in the set.",
      "ja": "SVCB RRset内では、すべてのRRは同じモードを持つべきです。RRsetにAliasModeのレコードが含まれている場合、受信者はセット内のServiceModeレコードを無視しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "RRsets are explicitly unordered collections, so the SvcPriority field is used to impose an ordering on SVCB RRs. A smaller SvcPriority indicates that the domain owner recommends the use of this record over ServiceMode RRs with a larger SvcPriority value.",
      "ja": "RRsetは明示的に順序付けられていないコレクションであるため、SvcPriorityフィールドはSVCB RRに順序付けを課すために使用されます。SvcPriorityが小さいほど、ドメインの所有者が、SvcPriority値が大きいServiceMode RRよりもこのレコードの使用を推奨することを示しています。"
    },
    {
      "indent": 3,
      "text": "When receiving an RRset containing multiple SVCB records with the same SvcPriority value, clients SHOULD apply a random shuffle within a priority level to the records before using them, to ensure uniform load balancing.",
      "ja": "同じSvcPriority値を持つ複数のSVCBレコードを含むRRsetを受信する場合、クライアントはレコードを使用する前に優先レベル内でランダムシャッフルを適用して、均一な負荷分散を確保する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4.2. AliasMode",
      "section_title": true,
      "ja": "2.4.2. aliAsmode"
    },
    {
      "indent": 3,
      "text": "In AliasMode, the SVCB record aliases a service to a TargetName. SVCB RRsets SHOULD only have a single RR in AliasMode. If multiple AliasMode RRs are present, clients or recursive resolvers SHOULD pick one at random.",
      "ja": "AliasModeでは、SVCBレコードはサービスをTargetNameにエイリアスします。SVCB RRsetには、AliasModeの単一のRRのみが含まれるべきです。複数のAliasMode RRが存在する場合、クライアントまたは再帰リゾルバーはランダムに1つを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "The primary purpose of AliasMode is to allow aliasing at the zone apex, where CNAME is not allowed (see, for example, [RFC1912], Section 2.4). In AliasMode, the TargetName will be the name of a domain that resolves to SVCB, AAAA, and/or A records. (See Section 6 for aliasing of SVCB-compatible RR types.) Unlike CNAME, AliasMode records do not affect the resolution of other RR types and apply only to a specific service, not an entire domain name.",
      "ja": "AliasModeの主な目的は、CNAMEが許可されていないゾーン頂点（apex）でのエイリアシングを許可することです（たとえば、[RFC1912]、セクション2.4を参照）。AliasModeでは、TargetNameはSVCB、AAAA、および/またはAレコードに解決されるドメインの名前になります。（SVCB互換RRタイプのエイリアシングについてはセクション6を参照してください。）CNAMEとは異なり、AliasModeレコードは他のRRタイプの解決に影響を与えず、ドメイン名全体ではなく特定のサービスにのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "The AliasMode TargetName SHOULD NOT be equal to the owner name, as this would result in a loop. In AliasMode, recipients MUST ignore any SvcParams that are present. Zone-file parsers MAY emit a warning if an AliasMode record has SvcParams. The use of SvcParams in AliasMode records is currently not defined, but a future specification could extend AliasMode records to include SvcParams.",
      "ja": "AliasModeのTargetNameは、所有者名と等しくないはずです（SHOULD NOT）。これはループを引き起こすためです。AliasModeでは、受信者は存在するSvcParamsを無視しなければなりません（MUST）。ゾーンファイルパーサーは、AliasModeレコードにSvcParamsがある場合、警告を出してもかまいません（MAY）。AliasModeレコードでのSvcParamsの使用は現在定義されていませんが、将来の仕様では、AliasModeレコードを拡張してSvcParamsを含める可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, the operator of \"foo://example.com:8080\" could point requests to a service operating at \"foosvc.example.net\" by publishing:",
      "ja": "たとえば、「foo://example.com:8080」のオペレーターは、以下を公開することで、「foosvc.example.net」で動作するサービスにリクエストを向けることができます。"
    },
    {
      "indent": 3,
      "text": "_8080._foo.example.com. 3600 IN SVCB 0 foosvc.example.net.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Using AliasMode maintains a separation of concerns: the owner of \"foosvc.example.net\" can add or remove ServiceMode SVCB records without requiring a corresponding change to \"example.com\". Note that if \"foosvc.example.net\" promises to always publish a SVCB record, this AliasMode record can be replaced by a CNAME at the same owner name.",
      "ja": "AliasModeを使用すると、関心の分離が維持されます。「foosvc.example.net」の所有者は、「example.com」への対応する変更を必要とせずにServiceMode SVCBレコードを追加または削除できます。「foosvc.example.net」が常にSVCBレコードを公開することを約束する場合、このAliasModeレコードは同じ所有者名でCNAMEに置き換えることができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "AliasMode is especially useful for SVCB-compatible RR types that do not require an underscore prefix, such as the HTTPS RR type. For example, the operator of \"https://example.com\" could point requests to a server at \"svc.example.net\" by publishing this record at the zone apex:",
      "ja": "AliasModeは、HTTPS RRタイプなどのアンダースコアプレフィックスを必要としないSVCB互換RRタイプに特に役立ちます。たとえば、「https://example.com」のオペレーターは、ゾーン頂点でこのレコードを公開することにより、「svc.example.net」のサーバーにリクエストを向けることができます。"
    },
    {
      "indent": 3,
      "text": "example.com. 3600 IN HTTPS 0 svc.example.net.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the SVCB record's owner name MAY be the canonical name of a CNAME record, and the TargetName MAY be the owner of a CNAME record. Clients and recursive resolvers MUST follow CNAMEs as normal.",
      "ja": "SVCBレコードの所有者名はCNAMEレコードの標準名であり、TargetNameはCNAMEレコードの所有者である可能性があることに注意してください。クライアントと再帰的なリゾルバーは、通常どおりのCNAMEに従わなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "To avoid unbounded alias chains, clients and recursive resolvers MUST impose a limit on the total number of SVCB aliases they will follow for each resolution request. This limit MUST NOT be zero, i.e., implementations MUST be able to follow at least one AliasMode record. The exact value of this limit is left to implementations.",
      "ja": "無制限のエイリアスチェーンを避けるために、クライアントと再帰リゾルバーは、各解決リクエストに対して従うSVCBエイリアスの総数に制限を課す必要があります。この制限はゼロであってはなりません。つまり、実装は少なくとも1つのAliasModeレコードに従うことができなければなりません。この制限の正確な値は、実装に任されています。"
    },
    {
      "indent": 3,
      "text": "Zones that require following multiple AliasMode records could encounter compatibility and performance issues.",
      "ja": "複数のAliasModeレコードをフォローする必要があるゾーンは、互換性とパフォーマンスの問題に遭遇する可能性があります。"
    },
    {
      "indent": 3,
      "text": "As legacy clients will not know to use this record, service operators will likely need to retain fallback AAAA and A records alongside this SVCB record, although in a common case the target of the SVCB record might offer better performance, and therefore would be preferable for clients implementing this specification to use.",
      "ja": "レガシーのクライアントはこのレコードを使用することを知らないため、サービスオペレーターはこのSVCBレコードと一緒にフォールバックAAAAとAレコードを保持する必要がある可能性がありますが、一般的なケースではSVCBレコードのターゲットがより良いパフォーマンスを提供する可能性があり、したがって、この仕様を実装するクライアントが使用することが望ましいでしょう。"
    },
    {
      "indent": 3,
      "text": "AliasMode records only apply to queries for the specific RR type. For example, a SVCB record cannot alias to an HTTPS record or vice versa.",
      "ja": "AliasModeレコードは、特定のRRタイプのクエリにのみ適用されます。たとえば、SVCBレコードはHTTPSレコードにエイリアスすることはできず、その逆も同様です。"
    },
    {
      "indent": 0,
      "text": "2.4.3. ServiceMode",
      "section_title": true,
      "ja": "2.4.3. ServiceMode"
    },
    {
      "indent": 3,
      "text": "In ServiceMode, the TargetName and SvcParams within each RR associate an alternative endpoint for the service with its connection parameters.",
      "ja": "ServiceModeでは、各RR内のTargetNameおよびSvcParamsは、その接続パラメーターを使用して、サービスの代替エンドポイントを関連付けます。"
    },
    {
      "indent": 3,
      "text": "Each protocol scheme that uses SVCB MUST define a protocol mapping that explains how SvcParams are applied for connections of that scheme. Unless specified otherwise by the protocol mapping, clients MUST ignore any SvcParam that they do not recognize.",
      "ja": "SVCBを使用する各プロトコルスキームは、SvcParamsがそのスキームの接続に適用される方法を説明するプロトコルマッピングを定義しなければなりません（MUST）。プロトコルマッピングによって特に指定されていない限り、クライアントは認識していないSvcParamを無視しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "Some SvcParams impose requirements on other SvcParams in the RR. A ServiceMode RR is called \"self-consistent\" if its SvcParams all comply with each other's requirements. Clients MUST reject any RR whose recognized SvcParams are not self-consistent and MAY reject the entire RRset. To help zone operators avoid this condition, zone-file implementations SHOULD enforce self-consistency as well.",
      "ja": "一部のSvcParamsは、RR内の他のSvcParamsに要件を課します。SvcParamsがすべて互いの要件に準拠している場合、ServiceMode RRは「自己整合的」と呼ばれます。クライアントは、認識されたSvcParamsが自己整合的でないRRを拒否しなければならず（MUST）、RRset全体を拒否してもかまいません（MAY）。ゾーンオペレーターがこの状態を回避できるように、ゾーンファイルの実装も自己整合性を強制すべきです（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "2.5. Special Handling of \".\" in TargetName",
      "section_title": true,
      "ja": "2.5. 「」の特別な取り扱い。TargetNameで"
    },
    {
      "indent": 3,
      "text": "If TargetName has the value \".\" (represented in the wire format as a zero-length label), special rules apply.",
      "ja": "TargetNameが値「.」を持つ場合（ワイヤ形式でゼロレングスラベルとして表されています）、特別なルールが適用されます。"
    },
    {
      "indent": 0,
      "text": "2.5.1. AliasMode",
      "section_title": true,
      "ja": "2.5.1. aliAsmode"
    },
    {
      "indent": 3,
      "text": "For AliasMode SVCB RRs, a TargetName of \".\" indicates that the service is not available or does not exist. This indication is advisory: clients encountering this indication MAY ignore it and attempt to connect without the use of SVCB.",
      "ja": "AliasMode SVCB RRの場合、TargetNameが「.」であることは、サービスが利用できないか、存在しないことを示します。この兆候はアドバイザリーです。この兆候に遭遇するクライアントは、それを無視し、SVCBを使用せずに接続しようとする場合があります。"
    },
    {
      "indent": 0,
      "text": "2.5.2. ServiceMode",
      "section_title": true,
      "ja": "2.5.2. ServiceMode"
    },
    {
      "indent": 3,
      "text": "For ServiceMode SVCB RRs, if TargetName has the value \".\", then the owner name of this record MUST be used as the effective TargetName. If the record has a wildcard owner name in the zone file, the recipient SHALL use the response's synthesized owner name as the effective TargetName.",
      "ja": "ServiceMode SVCB RRSの場合、TargetNameが値「.」を持つ場合、このレコードの所有者名は効果的なターゲット名として使用する必要があります。レコードにゾーンファイルにワイルドカードの所有者名がある場合、受信者は、応答の合成された所有者名を効果的なターゲット名として使用するものとします。"
    },
    {
      "indent": 3,
      "text": "Here, for example, \"svc2.example.net\" is the effective TargetName:",
      "ja": "ここで、たとえば、「svc2.example.net」は効果的なターゲット名です。"
    },
    {
      "indent": 3,
      "text": "example.com.      7200  IN HTTPS 0 svc.example.net.\nsvc.example.net.  7200  IN CNAME svc2.example.net.\nsvc2.example.net. 7200  IN HTTPS 1 . port=8002\nsvc2.example.net. 300   IN A     192.0.2.2\nsvc2.example.net. 300   IN AAAA  2001:db8::2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. Client Behavior",
      "section_title": true,
      "ja": "3. クライアントの動作"
    },
    {
      "indent": 3,
      "text": "\"SVCB resolution\" is the process of enumerating and ordering the available endpoints for a service, as performed by the client. SVCB resolution is implemented as follows:",
      "ja": "「SVCB解決」とは、クライアントが実行するように、サービスに使用可能なエンドポイントを列挙して順序付けるプロセスです。SVCB解決は次のように実行されます。"
    },
    {
      "indent": 8,
      "text": "1. Let $QNAME be the service name plus appropriate prefixes for the scheme (see Section 2.3).",
      "ja": "1. $QNAMEを、サービス名にスキームの適切なプレフィックスを加えたものとします（セクション2.3を参照）。"
    },
    {
      "indent": 8,
      "text": "2. Issue a SVCB query for $QNAME.",
      "ja": "2. $QNAMEのSVCBクエリを発行します。"
    },
    {
      "indent": 8,
      "text": "3. If an AliasMode SVCB record is returned for $QNAME (after following CNAMEs as normal), set $QNAME to its TargetName (without additional prefixes) and loop back to Step 2, subject to chain length limits and loop detection heuristics (see Section 3.1).",
      "ja": "3. $QNAMEに対してAliasMode SVCBレコードが返された場合（通常通りCNAMEをたどった後）、$QNAMEをそのTargetName（追加のプレフィックスなし）に設定し、ステップ2に戻ります。ただし、チェーンの長さの制限とループ検出のヒューリスティックに従います（セクション3.1を参照）。"
    },
    {
      "indent": 8,
      "text": "4. If one or more \"compatible\" (Section 8) ServiceMode records are returned, these represent the alternative endpoints. Sort the records by ascending SvcPriority.",
      "ja": "4. 1つ以上の「互換性のある」（セクション8）ServiceModeレコードが返される場合、これらは代替エンドポイントを表します。昇順のSvcPriorityでレコードを並べ替えます。"
    },
    {
      "indent": 8,
      "text": "5. Otherwise, SVCB resolution has failed, and the list of available endpoints is empty.",
      "ja": "5. それ以外の場合、SVCB解決は失敗し、使用可能なエンドポイントのリストが空です。"
    },
    {
      "indent": 3,
      "text": "This procedure does not rely on any recursive or authoritative DNS server to comply with this specification or have any awareness of SVCB.",
      "ja": "この手順は、この仕様に準拠するために、またはSVCBの認識を持つために、再帰的または権威DNSサーバーに依存していません。"
    },
    {
      "indent": 3,
      "text": "A client is called \"SVCB-optional\" if it can connect without the use of ServiceMode records; otherwise, it is called \"SVCB-reliant\". Clients for pre-existing protocols (e.g., HTTP) SHALL implement SVCB-optional behavior (except as noted in Section 3.1 or when modified by future specifications).",
      "ja": "ServiceModeレコードを使用せずに接続できる場合、クライアントは「SVCB-optional（SVCB任意）」と呼ばれます。それ以外の場合は、「SVCB-reliant（SVCB依存）」と呼ばれます。既存のプロトコル（HTTPなど）のクライアントは、SVCB-optionalの動作を実装しなければなりません（SHALL）（セクション3.1または将来の仕様で変更された場合を除く）。"
    },
    {
      "indent": 3,
      "text": "SVCB-optional clients SHOULD issue in parallel any other DNS queries that might be needed for connection establishment if the SVCB record is absent, in order to minimize delay in that case and enable the optimizations discussed in Section 5.",
      "ja": "SVCB-optionalクライアントは、SVCBレコードが存在しない場合、接続確立に必要な他のDNSクエリを並行して発行すべきであり（SHOULD）、その場合の遅延を最小限に抑え、セクション5で説明した最適化を有効にするためです。"
    },
    {
      "indent": 3,
      "text": "Once SVCB resolution has concluded, whether successful or not, if at least one AliasMode record was processed, SVCB-optional clients SHALL append to the list of endpoints an endpoint consisting of the final value of $QNAME, the authority endpoint's port number, and no SvcParams. (This endpoint will be attempted before falling back to non-SVCB connection modes. This ensures that SVCB-optional clients will make use of an AliasMode record whose TargetName has A and/or AAAA records but no SVCB records.)",
      "ja": "SVCB解決が終了した時点で、成功したかどうかにかかわらず、少なくとも1つのAliasModeレコードが処理された場合、SVCB-optionalクライアントは、$QNAMEの最終値、オーソリティエンドポイントのポート番号、およびSvcParamsなしで構成されるエンドポイントをエンドポイントのリストに追加しなければなりません（SHALL）。（このエンドポイントは、非SVCB接続モードにフォールバックする前に試行されます。これにより、SVCB-optionalクライアントが、TargetNameにAおよび/またはAAAAレコードはあるがSVCBレコードがないAliasModeレコードを使用することが保証されます。）"
    },
    {
      "indent": 3,
      "text": "The client proceeds with connection establishment using this list of endpoints. Clients SHOULD try higher-priority alternatives first, with fallback to lower-priority alternatives. Clients resolve AAAA and/or A records for the selected TargetName and MAY choose between them using an approach such as Happy Eyeballs [HappyEyeballsV2].",
      "ja": "クライアントは、このエンドポイントのリストを使用して接続確立を進めます。クライアントは、より低い優先順位の代替品へのフォールバックを使用して、より優先順位の高い代替手段を最初に試してみるべきです（SHOULD）。クライアントは、選択したTargetNameのAAAAおよび/またはAレコードを解決し、Happy Eyeballs [HappyEyeballsV2]などのアプローチを使用してそれらを選択してもかまいません（MAY）。"
    },
    {
      "indent": 3,
      "text": "If the client is SVCB-optional and connecting using this list of endpoints has failed, the client now attempts to use non-SVCB connection modes.",
      "ja": "クライアントがSVCB-optionalであり、エンドポイントのこのリストを使用して接続すると失敗した場合、クライアントは非SVCB接続モードの使用を試みます。"
    },
    {
      "indent": 3,
      "text": "Some important optimizations are discussed in Section 5 to avoid additional latency in comparison to ordinary AAAA/A lookups.",
      "ja": "いくつかの重要な最適化については、通常のAAAA/Aルックアップと比較して追加のレイテンシを回避するために、セクション5で説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Handling Resolution Failures",
      "section_title": true,
      "ja": "3.1. 解決の障害の処理"
    },
    {
      "indent": 3,
      "text": "If DNS responses are cryptographically protected (e.g., using DNSSEC or TLS [DoT] [DoH]) and SVCB resolution fails due to an authentication error, SERVFAIL response, transport error, or timeout, the client SHOULD abandon its attempt to reach the service, even if the client is SVCB-optional. Otherwise, an active attacker could mount a downgrade attack by denying the user access to the SvcParams.",
      "ja": "DNS応答が暗号的に保護されており（例：DNSSECまたはTLS [DoT] [DoH]を使用して）、認証エラー、SERVFAIL応答、トランスポートエラー、またはタイムアウトのためにSVCB解決が失敗した場合、クライアントがSVCB-optionalであっても、クライアントはサービスに到達しようとする試みを放棄すべきです（SHOULD）。それ以外の場合、アクティブな攻撃者は、SvcParamsへのユーザーアクセスを拒否することにより、ダウングレード攻撃を行う可能性があります。"
    },
    {
      "indent": 3,
      "text": "A SERVFAIL error can occur if the domain is DNSSEC-signed, the recursive resolver is DNSSEC-validating, and the attacker is between the recursive resolver and the authoritative DNS server. A transport error or timeout can occur if an active attacker between the client and the recursive resolver is selectively dropping SVCB queries or responses, based on their size or other observable patterns.",
      "ja": "ドメインがDNSSEC署名され、再帰リゾルバーがDNSSEC検証を行っている場合、攻撃者が再帰リゾルバーと権威DNSサーバーの間にあると、SERVFAILエラーが発生する可能性があります。クライアントと再帰リゾルバーの間のアクティブな攻撃者が、サイズまたはその他の観察可能なパターンに基づいてSVCBクエリまたは応答を選択的にドロップしている場合、トランスポートエラーまたはタイムアウトが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the client enforces DNSSEC validation on A/AAAA responses, it SHOULD apply the same validation policy to SVCB. Otherwise, an attacker could defeat the A/AAAA protection by forging SVCB responses that direct the client to other IP addresses.",
      "ja": "クライアントがA/AAAA応答でDNSSEC検証を実施する場合、同じ検証ポリシーをSVCBに適用すべきです（SHOULD）。それ以外の場合、攻撃者は、クライアントを他のIPアドレスに誘導するSVCB応答を偽造することにより、A/AAAA保護を打ち負かす可能性があります。"
    },
    {
      "indent": 3,
      "text": "If DNS responses are not cryptographically protected, clients MAY treat SVCB resolution failure as fatal or nonfatal.",
      "ja": "DNS応答が暗号的に保護されていない場合、クライアントはSVCB解決の障害を致命的または非致命的なものとして扱ってもかまいません（MAY）。"
    },
    {
      "indent": 3,
      "text": "If the client is unable to complete SVCB resolution due to its chain length limit, the client MUST fall back to the authority endpoint, as if the service's SVCB record did not exist.",
      "ja": "クライアントがチェーンの長さの制限のためにSVCB解決を完了できない場合、クライアントは、サービスのSVCBレコードが存在しないかのように、オーソリティエンドポイントにフォールバックしなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "3.2. Clients Using a Proxy",
      "section_title": true,
      "ja": "3.2. プロキシを使用しているクライアント"
    },
    {
      "indent": 3,
      "text": "Clients using a domain-oriented transport proxy like HTTP CONNECT ([RFC7231], Section 4.3.6) or SOCKS5 [RFC1928] have the option of using named destinations, in which case the client does not perform any A or AAAA queries for destination domains. If the client is configured to use named destinations with a proxy that does not provide SVCB query capability (e.g., through an affiliated DNS resolver), the client would have to perform SVCB resolution separately, likely disclosing the destinations to additional parties and not just the proxy. Clients in this configuration SHOULD arrange for a separate SVCB resolution procedure with appropriate privacy properties. If this is not possible, SVCB-optional clients MUST disable SVCB resolution entirely, and SVCB-reliant clients MUST treat the configuration as invalid.",
      "ja": "HTTP CONNECT（[RFC7231]、セクション4.3.6）またはSOCKS5 [RFC1928]などのドメイン指向のトランスポートプロキシを使用しているクライアントには、名前付き宛先を使用するオプションがあります。その場合、クライアントは宛先ドメインに対してAまたはAAAAクエリを実行しません。クライアントが、SVCBクエリ機能を提供しないプロキシ（例：関連DNSリゾルバーを介して）を使用して名前付き宛先を使用するように構成されている場合、クライアントはSVCB解決を個別に実行する必要がありますが、これにより、プロキシだけでなく追加のパーティに宛先が開示される可能性があります。この構成のクライアントは、適切なプライバシープロパティを備えた個別のSVCB解決手順を手配すべきです（SHOULD）。これが不可能な場合、SVCB-optionalクライアントはSVCB解決を完全に無効にしなければならず（MUST）、SVCB-reliantクライアントは構成を無効として扱わなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "If the client does use SVCB and named destinations, the client SHOULD follow the standard SVCB resolution process, selecting the smallest-SvcPriority option that is compatible with the client and the proxy. When connecting using a SVCB record, clients MUST provide the final TargetName and port to the proxy, which will perform any required A and AAAA lookups.",
      "ja": "クライアントがSVCBを使用し、名前付き宛先を使用している場合、クライアントは標準のSVCB解決プロセスに従い、クライアントとプロキシと互換性のある最小のSvcPriorityオプションを選択すべきです（SHOULD）。SVCBレコードを使用して接続する場合、クライアントは最終的なTargetNameとポートをプロキシに提供しなければなりません（MUST）。これにより、必要なAおよびAAAAルックアップが実行されます。"
    },
    {
      "indent": 3,
      "text": "This arrangement has several benefits:",
      "ja": "この構成にはいくつかの利点があります。"
    },
    {
      "indent": 6,
      "text": "* Compared to disabling SVCB:",
      "ja": "* SVCBの無効化と比較して："
    },
    {
      "indent": 12,
      "text": "- It allows the client to use the SvcParams, if present, which are only usable with a specific TargetName. The SvcParams may include information that enhances performance (e.g., supported protocols) and privacy.",
      "ja": "- これにより、クライアントは存在する場合はSvcParamsを使用できます。これは、特定のTargetNameでのみ使用できます。SvcParamsには、パフォーマンス（サポートされているプロトコルなど）とプライバシーを強化する情報が含まれる場合があります。"
    },
    {
      "indent": 12,
      "text": "- It allows a service on an apex domain to use aliasing.",
      "ja": "- Apexドメイン上のサービスがエイリアシングを使用できます。"
    },
    {
      "indent": 6,
      "text": "* Compared to providing the proxy with an IP address:",
      "ja": "* プロキシにIPアドレスを提供するのと比較してください。"
    },
    {
      "indent": 12,
      "text": "- It allows the proxy to select between IPv4 and IPv6 addresses for the server according to its configuration.",
      "ja": "- プロキシは、その構成に応じてサーバーのIPv4アドレスとIPv6アドレスを選択できます。"
    },
    {
      "indent": 12,
      "text": "- It ensures that the proxy receives addresses based on its network geolocation, not the client's.",
      "ja": "- これにより、プロキシは、クライアントのジオロケーションではなく、ネットワークジオロケーションに基づいてアドレスを受信することが保証されます。"
    },
    {
      "indent": 12,
      "text": "- It enables faster fallback for TCP destinations with multiple addresses of the same family.",
      "ja": "- 同じファミリの複数のアドレスを持つTCPの目的地のフォールバックをより速くすることができます。"
    },
    {
      "indent": 0,
      "text": "4. DNS Server Behavior",
      "section_title": true,
      "ja": "4. DNSサーバーの動作"
    },
    {
      "indent": 0,
      "text": "4.1. Authoritative Servers",
      "section_title": true,
      "ja": "4.1. 権威あるサーバー"
    },
    {
      "indent": 3,
      "text": "When replying to a SVCB query, authoritative DNS servers SHOULD return A, AAAA, and SVCB records in the Additional section for any TargetNames that are in the zone. If the zone is signed, the server SHOULD also include DNSSEC records authenticating the existence or nonexistence of these records in the Additional section.",
      "ja": "SVCBクエリに返信する場合、権威DNSサーバーは、ゾーン内にある任意のTargetNameのAdditionalセクションにA、AAAA、およびSVCBレコードを返すべきです（SHOULD）。ゾーンに署名されている場合、サーバーには、Additionalセクションのこれらのレコードの存在または非存在を認証するDNSSECレコードも含めるべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "See Section 4.4 for exceptions.",
      "ja": "例外については、セクション4.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2. Recursive Resolvers",
      "section_title": true,
      "ja": "4.2. 再帰的なリゾルバー"
    },
    {
      "indent": 3,
      "text": "Whether the recursive resolver is aware of SVCB or not, the normal response construction process used for unknown RR types [RFC3597] generates the Answer section of the response. Recursive resolvers that are aware of SVCB SHOULD help the client to execute the procedure in Section 3 with minimum overall latency by incorporating additional useful information into the Additional section of the response as follows:",
      "ja": "再帰リゾルバーがSVCBを認識しているかどうかにかかわらず、不明なRRタイプ[RFC3597]に使用される通常の応答構築プロセスが、応答のAnswerセクションを生成します。SVCBを認識している再帰リゾルバーは、次のように応答のAdditionalセクションに追加の有用な情報を組み込むことにより、クライアントが最小の全体的な遅延でセクション3の手順を実行するのを助けるべきです（SHOULD）。"
    },
    {
      "indent": 8,
      "text": "1. Incorporate the results of SVCB resolution. If the recursive resolver's local chain length limit (which may be different from the client's limit) has been reached, terminate.",
      "ja": "1. SVCB解決の結果を組み込みます。再帰リゾルバーのローカルチェーン長制限（クライアントの制限とは異なる場合がある）に達した場合、終了します。"
    },
    {
      "indent": 8,
      "text": "2. If any of the resolved SVCB records are in AliasMode, choose one of them at random, and resolve SVCB, A, and AAAA records for its TargetName.",
      "ja": "2. 解決されたSVCBレコードのいずれかがAliasModeにある場合は、それらのいずれかをランダムに選択し、そのTargetNameのSVCB、A、およびAAAAレコードを解決します。"
    },
    {
      "indent": 14,
      "text": "* If any SVCB records are resolved, go to Step 1.",
      "ja": "* SVCBレコードが解決された場合は、ステップ1に進みます。"
    },
    {
      "indent": 14,
      "text": "* Otherwise, incorporate the results of A and AAAA resolution, and terminate.",
      "ja": "* それ以外の場合は、AおよびAAAA解決の結果を組み込み、終了します。"
    },
    {
      "indent": 8,
      "text": "3. All the resolved SVCB records are in ServiceMode. Resolve A and AAAA queries for each TargetName (or for the owner name if TargetName is \".\"), incorporate all the results, and terminate.",
      "ja": "3. 解決されたすべてのSVCBレコードはServiceModeにあります。各TargetName（またはTargetNameが「.」の場合は所有者名）のAおよびAAAAクエリを解決し、すべての結果を組み込み、終了します。"
    },
    {
      "indent": 3,
      "text": "In this procedure, \"resolve\" means the resolver's ordinary recursive resolution procedure, as if processing a query for that RRset. This includes following any aliases that the resolver would ordinarily follow (e.g., CNAME, DNAME [DNAME]). Errors or anomalies in obtaining additional records MAY cause this process to terminate but MUST NOT themselves cause the resolver to send a failure response.",
      "ja": "この手順では、「解決」とは、そのRRsetのクエリを処理するかのような、リゾルバーの通常の再帰解決手順を意味します。これには、リゾルバーが通常従うエイリアス（例：CNAME、DNAME [DNAME]）が含まれます。追加のレコードを取得する際のエラーまたは異常は、このプロセスを終了させる可能性がありますが（MAY）、それ自体がリゾルバーに障害応答を送信させてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "See Section 2.4.2 for additional safeguards for recursive resolvers to implement to mitigate loops.",
      "ja": "ループを緩和するために再帰リゾルバーが実装すべき追加の安全策については、セクション2.4.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 5.2 for possible optimizations of this procedure.",
      "ja": "この手順の最適化の可能性については、セクション5.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.1. DNS64",
      "section_title": true,
      "ja": "4.2.1. DNS64"
    },
    {
      "indent": 3,
      "text": "DNS64 resolvers synthesize responses to AAAA queries for names that only have an A record (Section 5.1.7 of [RFC6147]). SVCB-aware DNS64 resolvers SHOULD apply the same synthesis logic when resolving AAAA records for the TargetName for inclusion in the Additional section (Step 2 in Section 4.2) and MAY omit the A records from this section.",
      "ja": "DNS64リゾルバーは、Aレコードのみを持つ名前のAAAAクエリに対する応答を合成します（[RFC6147]のセクション5.1.7）。SVCB対応DNS64リゾルバーは、Additionalセクション（セクション4.2のステップ2）に含めるためにTargetNameのAAAAレコードを解決するときに同じ合成ロジックを適用すべきであり（SHOULD）、このセクションのAレコードを省略してもかまいません（MAY）。"
    },
    {
      "indent": 3,
      "text": "DNS64 resolvers MUST NOT extrapolate the AAAA synthesis logic to the IP hints in the SvcParams (Section 7.3). Modifying the IP hints would break DNSSEC validation for the SVCB record and would not improve performance when the above recommendation is implemented.",
      "ja": "DNS64リゾルバーは、SvcParamsのIPヒントにAAAA合成ロジックを外挿してはなりません（MUST NOT）（セクション7.3）。IPヒントを変更すると、SVCBレコードのDNSSEC検証が破壊され、上記の推奨が実装された場合、パフォーマンスが向上しません。"
    },
    {
      "indent": 0,
      "text": "4.3. General Requirements",
      "section_title": true,
      "ja": "4.3. 一般的な要件"
    },
    {
      "indent": 3,
      "text": "Recursive resolvers MUST be able to convey SVCB records with unrecognized SvcParamKeys. Resolvers MAY accomplish this by treating the entire SvcParams portion of the record as opaque, even if the contents are invalid. If a recognized SvcParamKey is followed by a value that is invalid according to the SvcParam's specification, a recursive resolver MAY report an error such as SERVFAIL instead of returning the record. For complex value types whose interpretation might differ between implementations or have additional future allowed values added (e.g., URIs or \"alpn\"), resolvers SHOULD limit validation to specified constraints.",
      "ja": "再帰的なリゾルバーは、認識されていないSvcParamKeysを持つSVCBレコードを伝達できなければなりません（MUST）。リゾルバーは、内容が無効であっても、レコードのSvcParams部分全体を不透明（opaque）として扱うことにより、これを達成してもかまいません（MAY）。認識されたSvcParamKeyの後に、SvcParamの仕様に従って無効な値が続く場合、再帰的なリゾルバーは、レコードを返す代わりにSERVFAILなどのエラーを報告してもかまいません（MAY）。解釈が実装間で異なるか、将来許可される値が追加される可能性のある複雑な値タイプ（URIや「alpn」など）の場合、リゾルバーは検証を指定された制約に制限すべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "When responding to a query that includes the DNSSEC OK bit [RFC3225], DNSSEC-capable recursive and authoritative DNS servers MUST accompany each RRset in the Additional section with the same DNSSEC-related records that they would send when providing that RRset as an Answer (e.g., RRSIG, NSEC, NSEC3).",
      "ja": "DNSSEC OKビット[RFC3225]を含むクエリに応答する場合、DNSSEC対応の再帰および権威DNSサーバーは、Additionalセクションの各RRsetに、そのRRsetをAnswerとして提供するときに送信するのと同じDNSSEC関連のレコード（例：RRSIG、NSEC、NSEC3）を伴わなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "According to Section 5.4.1 of [RFC2181], \"Unauthenticated RRs received and cached from ... the additional data section ... should not be cached in such a way that they would ever be returned as answers to a received query. They may be returned as additional information where appropriate.\" Recursive resolvers therefore MAY cache records from the Additional section for use in populating Additional section responses and MAY cache them for general use if they are authenticated by DNSSEC.",
      "ja": "[RFC2181]のセクション5.4.1によれば、「受信およびキャッシュされた認証されていないRR ...追加のデータセクション...は、受け取ったクエリへの回答として返されるような方法でキャッシュされるべきではありません。必要に応じて追加情報として返される場合があります。」したがって、再帰的なリゾルバーは、Additionalセクションの応答を生成する際に使用するためにAdditionalセクションからレコードをキャッシュしてもよく（MAY）、DNSSECによって認証されている場合は一般的に使用するためにそれらをキャッシュしてもかまいません（MAY）。"
    },
    {
      "indent": 0,
      "text": "4.4. EDNS Client Subnet (ECS)",
      "section_title": true,
      "ja": "4.4. EDNSクライアントサブネット（ECS）"
    },
    {
      "indent": 3,
      "text": "The EDNS Client Subnet (ECS) option [RFC7871] allows recursive resolvers to request IP addresses that are suitable for a particular client IP range. SVCB records may contain IP addresses (in ipv*hint SvcParams) or direct users to a subnet-specific TargetName, so recursive resolvers SHOULD include the same ECS option in SVCB queries as in A/AAAA queries.",
      "ja": "EDNSクライアントサブネット（ECS）オプション[RFC7871]を使用すると、再帰リゾルバーが特定のクライアントIP範囲に適したIPアドレスを要求することを可能にします。SVCBレコードには、IPアドレス（ipv*hint SvcParams内）が含まれるか、サブネット固有のTargetNameにユーザーを誘導する可能性があるため、再帰的なリゾルバーは、A/AAAAクエリと同様にSVCBクエリに同じECSオプションを含めるべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "According to Section 7.3.1 of [RFC7871], \"Any records from [the Additional section] MUST NOT be tied to a network.\" Accordingly, when processing a response whose QTYPE is SVCB-compatible, resolvers SHOULD treat any records in the Additional section as having SOURCE PREFIX-LENGTH set to zero and SCOPE PREFIX-LENGTH as specified in the ECS option. Authoritative servers MUST omit such records if they are not suitable for use by any stub resolvers that set SOURCE PREFIX-LENGTH to zero. This will cause the resolver to perform a follow-up query that can receive a properly tailored ECS. (This is similar to the usage of CNAME with the ECS option as discussed in [RFC7871], Section 7.2.1.)",
      "ja": "[RFC7871]のセクション7.3.1によると、「[Additionalセクション]からのいかなるレコードもネットワークに結び付けられてはなりません（MUST NOT）。」したがって、QTYPEがSVCB互換である応答を処理する場合、リゾルバーは、Additionalセクションのレコードを、SOURCE PREFIX-LENGTHがゼロに設定され、SCOPE PREFIX-LENGTHがECSオプションで指定されたとおりであるとして扱うべきです（SHOULD）。権威サーバーは、SOURCE PREFIX-LENGTHをゼロに設定するスタブリゾルバーによる使用に適していない場合、そのようなレコードを省略しなければなりません（MUST）。これにより、リゾルバーは適切に調整されたECSを受信できるフォローアップクエリを実行します。（これは、[RFC7871]、セクション7.2.1で説明されているECSオプションを使用したCNAMEの使用に似ています。）"
    },
    {
      "indent": 3,
      "text": "Authoritative servers that omit Additional records can avoid the added latency of a follow-up query by following the advice in Section 10.2.",
      "ja": "Additionalレコードを省略する権威サーバーは、セクション10.2のアドバイスに従ってフォローアップクエリの追加の遅延を回避できます。"
    },
    {
      "indent": 0,
      "text": "5. Performance Optimizations",
      "section_title": true,
      "ja": "5. パフォーマンスの最適化"
    },
    {
      "indent": 3,
      "text": "For optimal performance (i.e., minimum connection setup time), clients SHOULD implement a client-side DNS cache. Responses in the Additional section of a SVCB response SHOULD be placed in cache before performing any follow-up queries. With this behavior, and with conforming DNS servers, using SVCB does not add network latency to connection setup.",
      "ja": "最適なパフォーマンス（つまり、最小接続セットアップ時間）のために、クライアントはクライアント側のDNSキャッシュを実装すべきです（SHOULD）。フォローアップクエリを実行する前に、SVCB応答のAdditionalセクションの応答をキャッシュに配置すべきです（SHOULD）。この動作により、適合するDNSサーバーがあれば、SVCBを使用しても、接続セットアップにネットワークレイテンシが追加されません。"
    },
    {
      "indent": 3,
      "text": "To improve performance when using a non-conforming recursive resolver, clients SHOULD issue speculative A and/or AAAA queries in parallel with each SVCB query, based on a predicted value of TargetName (see Section 10.2).",
      "ja": "不適合な再帰リゾルバーを使用するときにパフォーマンスを改善するには、TargetNameの予測値に基づいて、各SVCBクエリと並行して投機的Aおよび/またはAAAAクエリを発行すべきです（SHOULD）（セクション10.2を参照）。"
    },
    {
      "indent": 3,
      "text": "After a ServiceMode RRset is received, clients MAY try more than one option in parallel and MAY prefetch A and AAAA records for multiple TargetNames.",
      "ja": "ServiceMode RRsetを受信した後、クライアントは複数のオプションを並行して試してもよく（MAY）、複数のTargetNameのAおよびAAAAレコードをプリフェッチしてもかまいません（MAY）。"
    },
    {
      "indent": 0,
      "text": "5.1. Optimistic Pre-connection and Connection Reuse",
      "section_title": true,
      "ja": "5.1. 楽観的な事前接続と接続の再利用"
    },
    {
      "indent": 3,
      "text": "If an address response arrives before the corresponding SVCB response, the client MAY initiate a connection as if the SVCB query returned NODATA but MUST NOT transmit any information that could be altered by the SVCB response until it arrives. For example, future SvcParamKeys could be defined that alter the TLS ClientHello.",
      "ja": "対応するSVCB応答の前にアドレス応答が到着した場合、クライアントはSVCBクエリがNODATAを返したかのように接続を開始してもかまいませんが（MAY）、SVCB応答によって変更される可能性のある情報を、それが到着するまで送信してはなりません（MUST NOT）。たとえば、TLS ClientHelloを変更する将来のSvcParamKeysを定義できます。"
    },
    {
      "indent": 3,
      "text": "Clients implementing this optimization SHOULD wait for 50 milliseconds before starting optimistic pre-connection, as per the guidance in [HappyEyeballsV2].",
      "ja": "[HappyEyeballsV2]のガイダンスに従って、この最適化を実装するクライアントは、楽観的な事前接続を開始する前に50ミリ秒待つべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "A SVCB record is consistent with a connection if the client would attempt an equivalent connection when making use of that record. If a SVCB record is consistent with an active or in-progress connection C, the client MAY prefer that record and use C as its connection. For example, suppose the client receives this SVCB RRset for a protocol that uses TLS over TCP:",
      "ja": "SVCBレコードは、クライアントがそのレコードを使用するときに同等の接続を試みる場合、接続と整合します。SVCBレコードがアクティブまたは進行中の接続Cと整合している場合、クライアントはそのレコードを優先し、Cを接続として使用できます。たとえば、TCPを介してTLSを使用するプロトコルに対して、クライアントがこのSVCB RRsetを受信したとします。"
    },
    {
      "indent": 3,
      "text": "_1234._bar.example.com. 300 IN SVCB 1 svc1.example.net. (\n    ipv6hint=2001:db8::1 port=1234 )\n                               SVCB 2 svc2.example.net. (\n    ipv6hint=2001:db8::2 port=1234 )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the client has an in-progress TCP connection to [2001:db8::2]:1234, it MAY proceed with TLS on that connection, even though the other record in the RRset has higher priority.",
      "ja": "クライアントが[2001:db8::2]:1234への進行中のTCP接続を持っている場合、RRsetの他のレコードの優先度が高いにもかかわらず、その接続でTLSを続行してもかまいません（MAY）。"
    },
    {
      "indent": 3,
      "text": "If none of the SVCB records are consistent with any active or in-progress connection, clients proceed with connection establishment as described in Section 3.",
      "ja": "SVCBレコードがアクティブまたは進行中の接続と整合していない場合、クライアントはセクション3で説明されているように接続確立を進めます。"
    },
    {
      "indent": 0,
      "text": "5.2. Generating and Using Incomplete Responses",
      "section_title": true,
      "ja": "5.2. 不完全な応答を生成および使用します"
    },
    {
      "indent": 3,
      "text": "When following the procedure in Section 4.2, recursive resolvers MAY terminate the procedure early and produce a reply that omits some of the associated RRsets. This is REQUIRED when the chain length limit is reached (Step 1 in Section 4.2) but might also be appropriate when the maximum response size is reached or when responding before fully chasing dependencies would improve performance. When omitting certain RRsets, recursive resolvers SHOULD prioritize information for smaller-SvcPriority records.",
      "ja": "セクション4.2の手順に従う場合、再帰的なリゾルバーは手順を早期に終了し、関連するRRsetの一部を省略する返信を作成してもかまいません（MAY）。これは、チェーンの長さの制限に達したとき（セクション4.2のステップ1）は必須（REQUIRED）ですが、最大応答サイズに到達した場合、または依存関係を完全に追跡する前に応答することでパフォーマンスが向上する場合にも適切である場合があります。特定のRRsetを省略する場合、再帰的なリゾルバーは、より小さなSvcPriorityレコードの情報を優先すべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3, clients MUST be able to fetch additional information that is required to use a SVCB record, if it is not included in the initial response. As a performance optimization, if some of the SVCB records in the response can be used without requiring additional DNS queries, the client MAY prefer those records, regardless of their priorities.",
      "ja": "セクション3で説明したように、クライアントは、最初の応答に含まれていない場合は、SVCBレコードを使用するために必要な追加情報を取得できなければなりません（MUST）。パフォーマンスの最適化として、追加のDNSクエリを必要とせずに応答のSVCBレコードの一部を使用できる場合、クライアントは優先順位に関係なく、それらのレコードを優先してもかまいません（MAY）。"
    },
    {
      "indent": 0,
      "text": "6. SVCB-Compatible RR Types",
      "section_title": true,
      "ja": "6. SVCB互換RRタイプ"
    },
    {
      "indent": 3,
      "text": "An RR type is called \"SVCB-compatible\" if it permits an implementation that is identical to SVCB in its:",
      "ja": "RRタイプは、以下の点においてSVCBと同一の実装を許可する場合、「SVCB互換」と呼ばれます。"
    },
    {
      "indent": 6,
      "text": "* RDATA presentation format",
      "ja": "* RDATAプレゼンテーション形式"
    },
    {
      "indent": 6,
      "text": "* RDATA wire format",
      "ja": "* rdataワイヤ形式"
    },
    {
      "indent": 6,
      "text": "* IANA registry used for SvcParamKeys",
      "ja": "* SvcParamKeysに使用されるIANAレジストリ"
    },
    {
      "indent": 6,
      "text": "* Authoritative server Additional section processing",
      "ja": "* 権威あるサーバーの追加セクション処理"
    },
    {
      "indent": 6,
      "text": "* Recursive resolution process",
      "ja": "* 再帰解決プロセス"
    },
    {
      "indent": 6,
      "text": "* Relevant Class (i.e., Internet (\"IN\") [RFC1035])",
      "ja": "* 関連するクラス（つまり、インターネット（ \"in\"）[RFC1035]）"
    },
    {
      "indent": 3,
      "text": "This allows authoritative and recursive DNS servers to apply identical processing to all SVCB-compatible RR types.",
      "ja": "これにより、権威および再帰DNSサーバーが、すべてのSVCB互換RRタイプに同一の処理を適用できます。"
    },
    {
      "indent": 3,
      "text": "All other behaviors described as applying to the SVCB RR also apply to all SVCB-compatible RR types unless explicitly stated otherwise. When following an AliasMode record (Section 2.4.2) of RR type $T, the follow-up query to the TargetName MUST also be for type $T.",
      "ja": "SVCB RRに適用されると説明されている他のすべての動作は、明示的に記載されていない限り、すべてのSVCB互換RRタイプにも適用されます。RRタイプ$TのAliasModeレコード（セクション2.4.2）に従う場合、TargetNameへのフォローアップクエリもタイプ$Tでなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "This document defines one SVCB-compatible RR type (other than SVCB itself): the HTTPS RR type (Section 9), which avoids Attrleaf label prefixes [Attrleaf] in order to improve compatibility with wildcards and CNAMEs, which are widely used with HTTP.",
      "ja": "このドキュメントでは、1つのSVCB互換RRタイプ（SVCB自体を除く）を定義します。HTTPS RRタイプ（セクション9）は、HTTPと広く使用されているワイルドカードとCNAMEとの互換性を向上させるために、Attrleafラベルのプレフィックス[Attrleaf]を回避します。"
    },
    {
      "indent": 3,
      "text": "Standards authors should consider carefully whether to use SVCB or define a new SVCB-compatible RR type, as this choice cannot easily be reversed after deployment.",
      "ja": "標準の著者は、SVCBを使用するか、新しいSVCB互換RRタイプを定義するかを慎重に検討する必要があります。この選択は、展開後に簡単に変更することはできません。"
    },
    {
      "indent": 0,
      "text": "7. Initial SvcParamKeys",
      "section_title": true,
      "ja": "7. 最初のsvcparamkeys"
    },
    {
      "indent": 3,
      "text": "A few initial SvcParamKeys are defined here. These keys are useful for the \"https\" scheme, and most are expected to be generally applicable to other schemes as well.",
      "ja": "ここでは、いくつかの初期SvcParamKeysが定義されています。これらのキーは「https」スキームに役立ち、ほとんどは一般に他のスキームにも適用できると予想されます。"
    },
    {
      "indent": 3,
      "text": "Each new protocol mapping document MUST specify which keys are applicable and safe to use. Protocol mappings MAY alter the interpretation of SvcParamKeys but MUST NOT alter their presentation or wire formats.",
      "ja": "新しいプロトコルマッピングドキュメントは、どのキーが適用可能で安全に使用できるかを指定しなければなりません（MUST）。プロトコルマッピングは、SvcParamKeysの解釈を変更してもかまいませんが（MAY）、プレゼンテーションまたはワイヤー形式を変更してはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "7.1. \"alpn\" and \"no-default-alpn\"",
      "section_title": true,
      "ja": "7.1. 「alpn」と「no-default-alpn」"
    },
    {
      "indent": 3,
      "text": "The \"alpn\" and \"no-default-alpn\" SvcParamKeys together indicate the set of Application-Layer Protocol Negotiation (ALPN) protocol identifiers [ALPN] and associated transport protocols supported by this service endpoint (the \"SVCB ALPN set\").",
      "ja": "「alpn」および「no-default-alpn」SvcParamKeysは、アプリケーション層プロトコルネゴシエーション（ALPN）プロトコル識別子[ALPN]およびこのサービスエンドポイントでサポートされている関連する輸送プロトコルのセット（「SVCB ALPNセット」）を示しています。"
    },
    {
      "indent": 3,
      "text": "As with Alt-Svc [AltSvc], each ALPN protocol identifier is used to identify the application protocol and associated suite of protocols supported by the endpoint (the \"protocol suite\"). The presence of an ALPN protocol identifier in the SVCB ALPN set indicates that this service endpoint, described by TargetName and the other parameters (e.g., \"port\"), offers service with the protocol suite associated with this ALPN identifier.",
      "ja": "Alt-Svc [AltSvc]と同様に、各ALPNプロトコル識別子を使用して、エンドポイント（「プロトコルスイート」）でサポートされているアプリケーションプロトコルと関連するプロトコルのスイートを識別します。SVCB ALPNセットにALPNプロトコル識別子の存在は、TargetNameおよびその他のパラメーター（「ポート」など）で記述されたこのサービスエンドポイントが、このALPN識別子に関連付けられたプロトコルスイートでサービスを提供することを示しています。"
    },
    {
      "indent": 3,
      "text": "Clients filter the set of ALPN identifiers to match the protocol suites they support, and this informs the underlying transport protocol used (such as QUIC over UDP or TLS over TCP). ALPN protocol identifiers that do not uniquely identify a protocol suite (e.g., an Identification Sequence that can be used with both TLS and DTLS) are not compatible with this SvcParamKey and MUST NOT be included in the SVCB ALPN set.",
      "ja": "クライアントは、ALPN識別子のセットをフィルタリングしてサポートするプロトコルスイートに一致します。これは、使用される基礎となる輸送プロトコル（UDPよりもQUICやTCPよりもTLSなど）を通知します。プロトコルスイートを一意に識別しないALPNプロトコル識別子（たとえば、TLSとDTLSの両方で使用できる識別シーケンス）は、このSvcParamKeyと互換性がなく、SVCB ALPNセットに含めてはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Representation",
      "section_title": true,
      "ja": "7.1.1. 表現"
    },
    {
      "indent": 3,
      "text": "ALPNs are identified by their registered \"Identification Sequence\" (alpn-id), which is a sequence of 1-255 octets.",
      "ja": "ALPNは、登録された「識別シーケンス」（ALPN-ID）によって識別されます。これは、1〜255オクテットのシーケンスです。"
    },
    {
      "indent": 3,
      "text": "alpn-id = 1*255OCTET",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For \"alpn\", the presentation value SHALL be a comma-separated list (Appendix A.1) of one or more alpn-ids. Zone-file implementations MAY disallow the \",\" and \"\\\" characters in ALPN IDs instead of implementing the value-list escaping procedure, relying on the opaque key format (e.g., key1=\\002h2) in the event that these characters are needed.",
      "ja": "「alpn」の場合、プレゼンテーション値は、1つ以上のalpn-idのコンマ区切りリスト（付録A.1）でなければなりません（SHALL）。ゾーンファイルの実装は、値リストのエスケープ手順を実装する代わりに、ALPN ID内の「,」および「\\」文字を許可しなくてもかまいません（MAY）。その場合、これらの文字が必要なときは不透明なキー形式（例：key1=\\002h2）に依存します。"
    },
    {
      "indent": 3,
      "text": "The wire-format value for \"alpn\" consists of at least one alpn-id prefixed by its length as a single octet, and these length-value pairs are concatenated to form the SvcParamValue. These pairs MUST exactly fill the SvcParamValue; otherwise, the SvcParamValue is malformed.",
      "ja": "「alpn」のワイヤー形式値は、その長さによって単一のオクテットとして付けられた少なくとも1つのalpn-idで構成されており、これらの長さと価値のペアは連結されてSvcParamValueを形成します。これらのペアは、SvcParamValueを正確に埋めなければなりません（MUST）。それ以外の場合、SvcParamValueは不正です。"
    },
    {
      "indent": 3,
      "text": "For \"no-default-alpn\", the presentation and wire-format values MUST be empty. When \"no-default-alpn\" is specified in an RR, \"alpn\" must also be specified in order for the RR to be \"self-consistent\" (Section 2.4.3).",
      "ja": "「no-default-alpn」の場合、プレゼンテーションとワイヤー形式の値は空でなければなりません（MUST）。「no-default-alpn」がRRで指定されている場合、RRが「自己整合的」になるためには、「alpn」も指定されなければなりません（セクション2.4.3）。"
    },
    {
      "indent": 3,
      "text": "Each scheme that uses this SvcParamKey defines a \"default set\" of ALPN IDs that are supported by nearly all clients and servers; this set MAY be empty. To determine the SVCB ALPN set, the client starts with the list of alpn-ids from the \"alpn\" SvcParamKey, and it adds the default set unless the \"no-default-alpn\" SvcParamKey is present.",
      "ja": "このSvcParamKeyを使用する各スキームは、ほぼすべてのクライアントとサーバーによってサポートされているALPN IDの「デフォルトセット」を定義します。このセットは空でもかまいません（MAY）。SVCB ALPNセットを決定するために、クライアントは「alpn」SvcParamKeyのalpn-idのリストから開始し、「no-default-alpn」SvcParamKeyが存在しない限りデフォルトセットを追加します。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Use",
      "section_title": true,
      "ja": "7.1.2. 使用"
    },
    {
      "indent": 3,
      "text": "To establish a connection to the endpoint, clients MUST",
      "ja": "エンドポイントへの接続を確立するには、クライアントは以下を行わなければなりません（MUST）。"
    },
    {
      "indent": 8,
      "text": "1. Let SVCB-ALPN-Intersection be the set of protocols in the SVCB ALPN set that the client supports.",
      "ja": "1. SVCB-ALPN-Intersectionを、クライアントがサポートするSVCB ALPNセットのプロトコルのセットとします。"
    },
    {
      "indent": 8,
      "text": "2. Let Intersection-Transports be the set of transports (e.g., TLS, DTLS, QUIC) implied by the protocols in SVCB-ALPN-Intersection.",
      "ja": "2. Intersection-Transportsは、SVCB-ALPN-Intersectionのプロトコルによって暗示される輸送のセット（たとえば、TLS、DTLS、QUIC）のセットとします。"
    },
    {
      "indent": 8,
      "text": "3. For each transport in Intersection-Transports, construct a ProtocolNameList containing the Identification Sequences of all the client's supported ALPN protocols for that transport, without regard to the SVCB ALPN set.",
      "ja": "3. Intersection-Transportsの各トランスポートについて、SVCB ALPNセットに関係なく、そのトランスポート用のすべてのクライアントのサポートされているALPNプロトコルの識別シーケンスを含むProtocolNameListを作成します。"
    },
    {
      "indent": 3,
      "text": "For example, if the SVCB ALPN set is [\"http/1.1\", \"h3\"] and the client supports HTTP/1.1, HTTP/2, and HTTP/3, the client could attempt to connect using TLS over TCP with a ProtocolNameList of [\"http/1.1\", \"h2\"] and could also attempt a connection using QUIC with a ProtocolNameList of [\"h3\"].",
      "ja": "たとえば、SVCB ALPNセットが[\"http/1.1\"、 \"h3\"]の場合、クライアントがHTTP/1.1、HTTP/2、およびHTTP/3をサポートする場合、クライアントはTCP上のTLSを使用して、[\"http/1.1\", \"h2\"]のProtocolNameListで接続を試みることができます。[\"h3\"]のProtocolNameListを使用してQUICを使用して接続を試みることもできます。"
    },
    {
      "indent": 3,
      "text": "Once the client has constructed a ClientHello, protocol negotiation in that handshake proceeds as specified in [ALPN], without regard to the SVCB ALPN set.",
      "ja": "クライアントがClientHelloを構築すると、SVCB ALPNセットに関係なく、[ALPN]で指定されているように、そのハンドシェイクのプロトコル交渉が進行します。"
    },
    {
      "indent": 3,
      "text": "Clients MAY implement a fallback procedure, using a less-preferred transport if more-preferred transports fail to connect. This fallback behavior is vulnerable to manipulation by a network attacker who blocks the more-preferred transports, but it may be necessary for compatibility with existing networks.",
      "ja": "クライアントは、より優先度の高いトランスポートが接続に失敗した場合、より優先度の低いトランスポートを使用して、フォールバック手順を実装してもかまいません（MAY）。このフォールバックの動作は、より優先度の高いトランスポートをブロックするネットワーク攻撃者による操作に対して脆弱ですが、既存のネットワークとの互換性に必要な場合があります。"
    },
    {
      "indent": 3,
      "text": "With this procedure in place, an attacker who can modify DNS and network traffic can prevent a successful transport connection but cannot otherwise interfere with ALPN protocol selection. This procedure also ensures that each ProtocolNameList includes at least one protocol from the SVCB ALPN set.",
      "ja": "この手順を導入すると、DNSとネットワークトラフィックを変更できる攻撃者は、輸送接続の成功を防ぐことができますが、それ以外の場合はALPNプロトコルの選択を妨げることはできません。また、この手順により、各ProtocolNameListには、SVCB ALPNセットからの少なくとも1つのプロトコルが含まれることが保証されます。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT attempt connection to a service endpoint whose SVCB ALPN set does not contain any supported protocols.",
      "ja": "クライアントは、SVCB ALPNセットにサポートされているプロトコルが含まれていないサービスエンドポイントへの接続を試みるべきではありません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "To ensure consistency of behavior, clients MAY reject the entire SVCB RRset and fall back to basic connection establishment if all of the compatible RRs indicate \"no-default-alpn\", even if connection could have succeeded using a non-default ALPN protocol.",
      "ja": "動作の一貫性を確保するために、互換性のあるRRのすべてが「no-default-alpn」を示している場合、非デフォルトのALPNプロトコルを使用して接続が成功した可能性があるとしても、クライアントはSVCB RRset全体を拒否し、基本的な接続確立にフォールバックしてもかまいません（MAY）。"
    },
    {
      "indent": 3,
      "text": "Zone operators SHOULD ensure that at least one RR in each RRset supports the default transports. This enables compatibility with the greatest number of clients.",
      "ja": "ゾーンオペレーターは、各RRSetに少なくとも1つのRRがデフォルトのトランスポートをサポートするようにすべきです（SHOULD）。これにより、最大数のクライアントとの互換性が可能になります。"
    },
    {
      "indent": 0,
      "text": "7.2. \"port\"",
      "section_title": true,
      "ja": "7.2. \"ポート\""
    },
    {
      "indent": 3,
      "text": "The \"port\" SvcParamKey defines the TCP or UDP port that should be used to reach this alternative endpoint. If this key is not present, clients SHALL use the authority endpoint's port number.",
      "ja": "「port」SvcParamKeyは、この代替エンドポイントに到達するために使用する必要があるTCPまたはUDPポートを定義します。このキーが存在しない場合、クライアントはオーソリティエンドポイントのポート番号を使用するものとします（SHALL）。"
    },
    {
      "indent": 3,
      "text": "The presentation value of the SvcParamValue is a single decimal integer between 0 and 65535 in ASCII. Any other value (e.g., an empty value) is a syntax error. To enable simpler parsing, this SvcParamValue MUST NOT contain escape sequences.",
      "ja": "SvcParamValueの表示値は、ASCIIの0〜65535の間の単一の小数整数です。その他の値（空の値など）は構文エラーです。よりシンプルな解析を有効にするために、このSvcParamValueはエスケープシーケンスを含んではなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The wire format of the SvcParamValue is the corresponding 2-octet numeric value in network byte order.",
      "ja": "SvcParamValueのワイヤー形式は、ネットワークバイトの順序で対応する2-OCTET数値です。"
    },
    {
      "indent": 3,
      "text": "If a port-restricting firewall is in place between some client and the service endpoint, changing the port number might cause that client to lose access to the service, so operators should exercise caution when using this SvcParamKey to specify a non-default port.",
      "ja": "一部のクライアントとサービスエンドポイントの間にポート制限ファイアウォールが整っている場合、ポート番号を変更すると、クライアントがサービスへのアクセスを失う可能性があるため、オペレーターはこのSvcParamKeyを使用して非デフォルトポートを指定する場合は注意を払う必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3. \"ipv4hint\" and \"ipv6hint\"",
      "section_title": true,
      "ja": "7.3. 「ipv4hint」と「ipv6hint」"
    },
    {
      "indent": 3,
      "text": "The \"ipv4hint\" and \"ipv6hint\" keys convey IP addresses that clients MAY use to reach the service. If A and AAAA records for TargetName are locally available, the client SHOULD ignore these hints. Otherwise, clients SHOULD perform A and/or AAAA queries for TargetName per Section 3, and clients SHOULD use the IP address in those responses for future connections. Clients MAY opt to terminate any connections using the addresses in hints and instead switch to the addresses in response to the TargetName query. Failure to use A and/or AAAA response addresses could negatively impact load balancing or other geo-aware features and thereby degrade client performance.",
      "ja": "「ipv4hint」および「ipv6hint」キーは、クライアントがサービスに到達するために使用してもよい（MAY）IPアドレスを伝えます。TargetNameのAおよびAAAAレコードがローカルで利用可能な場合、クライアントはこれらのヒントを無視すべきです（SHOULD）。それ以外の場合、クライアントはセクション3に従ってTargetNameのAおよび/またはAAAAクエリを実行すべきであり（SHOULD）、クライアントは将来の接続のためにそれらの応答内のIPアドレスを使用すべきです（SHOULD）。クライアントは、ヒント内のアドレスを使用した接続を終了し、代わりにTargetNameクエリへの応答内のアドレスに切り替えることを選択してもかまいません（MAY）。Aおよび/またはAAAA応答アドレスの使用の失敗は、負荷分散または他の地理認識機能に悪影響を与える可能性があり、それによりクライアントのパフォーマンスを低下させる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The presentation value SHALL be a comma-separated list (Appendix A.1) of one or more IP addresses of the appropriate family in standard textual format [RFC5952] [RFC4001]. To enable simpler parsing, this SvcParamValue MUST NOT contain escape sequences.",
      "ja": "プレゼンテーション値は、標準のテキスト形式[RFC5952] [RFC4001]による、適切なファミリの1つ以上のIPアドレスのコンマ区切りリスト（付録A.1）でなければなりません（SHALL）。よりシンプルな解析を有効にするために、このSvcParamValueはエスケープシーケンスを含んではなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The wire format for each parameter is a sequence of IP addresses in network byte order (for the respective address family). Like an A or AAAA RRset, the list of addresses represents an unordered collection, and clients SHOULD pick addresses to use in a random order. An empty list of addresses is invalid.",
      "ja": "各パラメーターのワイヤー形式は、ネットワークバイト順序の一連のIPアドレスです（それぞれのアドレスファミリ用）。AまたはAAAA RRsetのように、アドレスのリストは順序付けられていないコレクションを表し、クライアントはランダムな順序で使用するアドレスを選択すべきです（SHOULD）。アドレスの空のリストは無効です。"
    },
    {
      "indent": 3,
      "text": "When selecting between IPv4 and IPv6 addresses to use, clients may use an approach such as Happy Eyeballs [HappyEyeballsV2]. When only \"ipv4hint\" is present, NAT64 clients may synthesize IPv6 addresses as specified in [RFC7050] or ignore the \"ipv4hint\" key and wait for AAAA resolution (Section 3). For best performance, server operators SHOULD include an \"ipv6hint\" parameter whenever they include an \"ipv4hint\" parameter.",
      "ja": "使用するIPv4アドレスとIPv6アドレスを選択する場合、クライアントはHappy Eyeballs [HappyEyeballsV2]などのアプローチを使用できます。「ipv4hint」のみが存在する場合、NAT64クライアントは[RFC7050]で指定されているようにIPv6アドレスを合成するか、「ipv4hint」キーを無視してAAAA解決を待ちます（セクション3）。最高のパフォーマンスのために、サーバーオペレーターは「ipv4hint」パラメーターを含めるときはいつでも「ipv6hint」パラメーターを含めるべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "These parameters are intended to minimize additional connection latency when a recursive resolver is not compliant with the requirements in Section 4 and SHOULD NOT be included if most clients are using compliant recursive resolvers. When TargetName is the service name or the owner name (which can be written as \".\"), server operators SHOULD NOT include these hints, because they are unlikely to convey any performance benefit.",
      "ja": "これらのパラメーターは、再帰的なリゾルバーがセクション4の要件に準拠していない場合に追加の接続レイテンシを最小限に抑えることを目的としており、ほとんどのクライアントが準拠した再帰リゾルバーを使用している場合は含めるべきではありません（SHOULD NOT）。TargetNameがサービス名または所有者名（「.」として記述できる）である場合、サーバーオペレーターはこれらのヒントを含めるべきではありません（SHOULD NOT）。パフォーマンスの利点を伝える可能性が低いためです。"
    },
    {
      "indent": 0,
      "text": "7.4. \"mandatory\"",
      "section_title": true,
      "ja": "7.4. \"必須\""
    },
    {
      "indent": 3,
      "text": "See Section 8.",
      "ja": "セクション8を参照してください。"
    },
    {
      "indent": 0,
      "text": "8. ServiceMode RR Compatibility and Mandatory Keys",
      "section_title": true,
      "ja": "8. ServiceMode RR互換性と必須キー"
    },
    {
      "indent": 3,
      "text": "In a ServiceMode RR, a SvcParamKey is considered \"mandatory\" if the RR will not function correctly for clients that ignore this SvcParamKey. Each SVCB protocol mapping SHOULD specify a set of keys that are \"automatically mandatory\", i.e., mandatory if they are present in an RR. The SvcParamKey \"mandatory\" is used to indicate any mandatory keys for this RR, in addition to any automatically mandatory keys that are present.",
      "ja": "ServiceMode RRでは、RRがこのSvcParamKeyを無視するクライアントに対して正しく機能しない場合、SvcParamKeyは「必須」と見なされます。各SVCBプロトコルマッピングは、「自動的に必須」のキーのセットを指定すべきです（SHOULD）。つまり、RRに存在する場合は必須です。SvcParamKeyの「mandatory」は、存在する自動的に必須のキーに加えて、このRRの必須キーを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "A ServiceMode RR is considered \"compatible\" by a client if the client recognizes all the mandatory keys and their values indicate that successful connection establishment is possible. Incompatible RRs are ignored (see step 5 of the procedure defined in Section 3).",
      "ja": "クライアントがすべての必須キーを認識し、その値が成功した接続確立が可能であることを示している場合、ServiceMode RRはクライアントによって「互換性がある」と見なされます。互換性のないRRは無視されます（セクション3で定義されている手順のステップ5を参照）。"
    },
    {
      "indent": 3,
      "text": "The presentation value SHALL be a comma-separated list (Appendix A.1) of one or more valid SvcParamKeys, either by their registered name or in the unknown-key format (Section 2.1). Keys MAY appear in any order but MUST NOT appear more than once. For self-consistency (Section 2.4.3), listed keys MUST also appear in the SvcParams.",
      "ja": "プレゼンテーション値は、登録名または未知のキー形式（セクション2.1）のいずれかによる、1つ以上の有効なSvcParamKeysのコンマ区切りリスト（付録A.1）でなければなりません（SHALL）。キーは任意の順序で表示されてもかまいませんが（MAY）、複数回表示されてはなりません（MUST NOT）。自己整合性（セクション2.4.3）のため、リストされたキーもSvcParamsに表示されなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "To enable simpler parsing, this SvcParamValue MUST NOT contain escape sequences.",
      "ja": "よりシンプルな解析を有効にするために、このSvcParamValueはエスケープシーケンスを含んではなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "For example, the following is a valid list of SvcParams:",
      "ja": "たとえば、以下はsvcparamsの有効なリストです。"
    },
    {
      "indent": 3,
      "text": "ipv6hint=... key65333=ex1 key65444=ex2 mandatory=key65444,ipv6hint",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In wire format, the keys are represented by their numeric values in network byte order, concatenated in strictly increasing numeric order.",
      "ja": "ワイヤー形式では、キーはネットワークバイトの順序で数値で表され、厳密に増加する数値順序で連結されます。"
    },
    {
      "indent": 3,
      "text": "This SvcParamKey is always automatically mandatory and MUST NOT appear in its own value-list. Other automatically mandatory keys SHOULD NOT appear in the list either. (Including them wastes space and otherwise has no effect.)",
      "ja": "このSvcParamKeyは常に自動的に必須であり、それ自体の値リストに表示されてはなりません（MUST NOT）。その他の自動的に必須のキーもリストに表示されるべきではありません（SHOULD NOT）。（それらを含めるとスペースを浪費し、そうでなければ効果はありません。）"
    },
    {
      "indent": 0,
      "text": "9. Using Service Bindings with HTTP",
      "section_title": true,
      "ja": "9. HTTPでサービスバインディングを使用します"
    },
    {
      "indent": 3,
      "text": "The use of any protocol with SVCB requires a protocol-specific mapping specification. This section specifies the mapping for the \"http\" and \"https\" URI schemes [HTTP].",
      "ja": "SVCBでプロトコルを使用するには、プロトコル固有のマッピング仕様が必要です。このセクションでは、「http」および「https」URIスキーム[HTTP]のマッピングを指定します。"
    },
    {
      "indent": 3,
      "text": "To enable special handling for HTTP use cases, the HTTPS RR type is defined as a SVCB-compatible RR type, specific to the \"https\" and \"http\" schemes. Clients MUST NOT perform SVCB queries or accept SVCB responses for \"https\" or \"http\" schemes.",
      "ja": "HTTPユースケースの特別な取り扱いを可能にするために、HTTPS RRタイプは、「https」および「http」スキームに固有のSVCB互換RRタイプとして定義されます。クライアントは、「https」または「http」スキームのSVCBクエリを実行したり、SVCB応答を受け入れたりしてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The presentation format of the record is:",
      "ja": "レコードのプレゼンテーション形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name TTL IN HTTPS SvcPriority TargetName SvcParams",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "All the SvcParamKeys defined in Section 7 are permitted for use in HTTPS RRs. The default set of ALPN IDs is the single value \"http/1.1\". The \"automatically mandatory\" keys (Section 8) are \"port\" and \"no-default-alpn\". (As described in Section 8, clients must either implement these keys or ignore any RR in which they appear.) Clients that restrict the destination port in \"https\" URIs (e.g., using the \"bad ports\" list from [FETCH]) SHOULD apply the same restriction to the \"port\" SvcParam.",
      "ja": "セクション7で定義されているすべてのSvcParamKeysは、HTTPS RRでの使用が許可されています。ALPN IDのデフォルトセットは、単一値「http/1.1」です。「自動的に必須」キー（セクション8）は「port」と「no-default-alpn」です。（セクション8で説明されているように、クライアントはこれらのキーを実装するか、表示されるRRを無視する必要があります。）「https」URIの宛先ポートを制限するクライアント（たとえば、[FETCH]の「bad ports」リストを使用するなど）は、同じ制限を「port」SvcParamに適用すべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The presence of an HTTPS RR for an origin also indicates that clients should connect securely and use the \"https\" scheme, as discussed in Section 9.5. This allows HTTPS RRs to apply to pre-existing \"http\" scheme URLs, while ensuring that the client uses a secure and authenticated connection.",
      "ja": "起源のHTTPS RRの存在は、セクション9.5で説明したように、クライアントが安全に接続し、「HTTPS」スキームを使用する必要があることも示しています。これにより、HTTPS RRSは、クライアントが安全で認証された接続を使用するようにしながら、既存の「HTTP」スキームURLに適用できます。"
    },
    {
      "indent": 3,
      "text": "The HTTPS RR parallels the concepts introduced in \"HTTP Alternative Services\" [AltSvc]. Clients and servers that implement HTTPS RRs are not required to implement Alt-Svc.",
      "ja": "HTTPS RRは、「HTTP Alternative Services」[AltSvc]で導入された概念と類似しています。HTTPS RRを実装するクライアントとサーバーは、Alt-Svcを実装する必要はありません。"
    },
    {
      "indent": 0,
      "text": "9.1. Query Names for HTTPS RRs",
      "section_title": true,
      "ja": "9.1. HTTPS RRSのクエリ名"
    },
    {
      "indent": 3,
      "text": "The HTTPS RR uses Port Prefix Naming (Section 2.3), with one modification: if the scheme is \"https\" and the port is 443, then the client's original QNAME is equal to the service name (i.e., the origin's hostname), without any prefix labels.",
      "ja": "HTTPS RRは、ポートプレフィックスネーミング（セクション2.3）を使用し、1つの変更：スキームが「https」であり、ポートが443の場合、クライアントの元のQNAMEはサービス名（つまり、Originのホスト名）に等しくなります。プレフィックスラベル。"
    },
    {
      "indent": 3,
      "text": "By removing the Attrleaf labels [Attrleaf] used in SVCB, this construction enables offline DNSSEC signing of wildcard domains, which are commonly used with HTTP. Using the service name as the owner name of the HTTPS record, without prefixes, also allows the targets of existing CNAME chains (e.g., CDN hosts) to start returning HTTPS RR responses without requiring origin domains to configure and maintain an additional delegation.",
      "ja": "SVCBで使用されるAttrleafラベル[Attrleaf]を削除することにより、この構造により、HTTPで一般的に使用されるワイルドカードドメインのオフラインDNSSEC署名が可能になります。サービス名をプレフィックスなしでHTTPSレコードの所有者名として使用すると、既存のCNAMEチェーン（CDNホストなど）のターゲットが、オリジンドメインに追加の委任を構成および維持する必要なく、HTTPS RR応答の返却を開始できます。"
    },
    {
      "indent": 3,
      "text": "The procedure for following HTTPS AliasMode RRs and CNAME aliases is unchanged from SVCB (as described in Sections 2.4.2 and 3).",
      "ja": "HTTPS AliASMODE RRSおよびCNAMEエイリアスを追跡する手順は、SVCBから変更されていません（セクション2.4.2および3で説明されています）。"
    },
    {
      "indent": 3,
      "text": "Clients always convert \"http\" URLs to \"https\" before performing an HTTPS RR query using the process described in Section 9.5, so domain owners MUST NOT publish HTTPS RRs with a prefix of \"_http\".",
      "ja": "クライアントは、セクション9.5で説明されているプロセスを使用してHTTPS RRクエリを実行する前に、「http」URLを常に「https」に変換するため、ドメインの所有者は「_http」のプレフィックスでHTTPS RRを公開してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Note that none of these forms alter the HTTPS origin or authority. For example, clients MUST continue to validate TLS certificate hostnames based on the origin.",
      "ja": "これらのフォームのいずれも、HTTPSの起源または権限を変更しないことに注意してください。たとえば、クライアントは、オリジンに基づいてTLS証明書のホスト名を引き続き検証しなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "9.2. Comparison with Alt-Svc",
      "section_title": true,
      "ja": "9.2. Alt-SVCとの比較"
    },
    {
      "indent": 3,
      "text": "Publishing a ServiceMode HTTPS RR in DNS is intended to be similar to transmitting an Alt-Svc field value over HTTP, and receiving an HTTPS RR is intended to be similar to receiving that field value over HTTP. However, there are some differences in the intended client and server behavior.",
      "ja": "DNSでServiceMode HTTPS RRを公開することは、HTTPを介してAlt-SVCフィールド値を送信することと同様であることを目的としており、HTTPS RRを受信することは、HTTPを介してそのフィールド値を受信することに似ていることを目的としています。ただし、意図したクライアントとサーバーの動作にはいくつかの違いがあります。"
    },
    {
      "indent": 0,
      "text": "9.2.1. ALPN Usage",
      "section_title": true,
      "ja": "9.2.1. ALPN使用"
    },
    {
      "indent": 3,
      "text": "Unlike Alt-Svc field values, HTTPS RRs can contain multiple ALPN IDs. The meaning and use of these IDs are discussed in Section 7.1.2.",
      "ja": "Alt-Svcフィールド値とは異なり、HTTPS RRには複数のALPN IDを含めることができます。これらのIDの意味と使用については、セクション7.1.2で説明します。"
    },
    {
      "indent": 0,
      "text": "9.2.2. Untrusted Channels",
      "section_title": true,
      "ja": "9.2.2. 信頼できないチャネル"
    },
    {
      "indent": 3,
      "text": "HTTPS records do not require or provide any assurance of authenticity. (DNSSEC signing and verification, which would provide such assurance, are OPTIONAL.) The DNS resolution process is modeled as an untrusted channel that might be controlled by an attacker, so Alt-Svc parameters that cannot be safely received in this model MUST NOT have a corresponding defined SvcParamKey. For example, there is no SvcParamKey corresponding to the Alt-Svc \"persist\" parameter, because this parameter is not safe to accept over an untrusted channel.",
      "ja": "HTTPSレコードは、信頼性の保証を必要としないか、提供しません。（そのような保証を提供するDNSSECの署名と検証はオプションです。）DNS解決プロセスは、攻撃者によって制御される可能性のある信頼されていないチャネルとしてモデル化されているため、このモデルで安全に受信できないAlt-Svcパラメーターは、対応する定義されたSvcParamKeyを持ってはなりません（MUST NOT）。たとえば、このパラメーターは信頼されていないチャネルで受け入れるのは安全ではないため、Alt-Svcの「persist」パラメーターに対応するSvcParamKeyはありません。"
    },
    {
      "indent": 0,
      "text": "9.2.3. Cache Lifetime",
      "section_title": true,
      "ja": "9.2.3. キャッシュ寿命"
    },
    {
      "indent": 3,
      "text": "There is no SvcParamKey corresponding to the Alt-Svc \"ma\" (max age) parameter. Instead, server operators encode the expiration time in the DNS TTL.",
      "ja": "Alt-Svc \"ma\"（最大年齢）パラメーターに対応するSvcParamKeyはありません。代わりに、サーバーオペレーターはDNS TTLの有効期限をエンコードします。"
    },
    {
      "indent": 3,
      "text": "The appropriate TTL value might be different from the \"ma\" value used for Alt-Svc, depending on the desired efficiency and agility. Some DNS caches incorrectly extend the lifetime of DNS records beyond the stated TTL, so server operators cannot rely on HTTPS RRs expiring on time. Shortening the TTL to compensate for incorrect caching is NOT RECOMMENDED, as this practice impairs the performance of correctly functioning caches and does not guarantee faster expiration from incorrect caches. Instead, server operators SHOULD maintain compatibility with expired records until they observe that nearly all connections have migrated to the new configuration.",
      "ja": "適切なTTL値は、目的の効率と俊敏性に応じて、ALT-SVCに使用される「ma」値とは異なる場合があります。一部のDNSキャッシュは、指定されたTTLを超えてDNSレコードの寿命を誤って延長するため、サーバーオペレーターは時間通りに期限切れになるHTTPS RRに依存することはできません。このプラクティスは正しく機能するキャッシュのパフォーマンスを損ない、誤ったキャッシュからのより速い有効期限を保証するものではないため、誤ったキャッシュを補うためにTTLを短縮することは推奨されません（NOT RECOMMENDED）。代わりに、サーバーオペレーターは、ほとんどすべての接続が新しい構成に移行したことが観察されるまで、期限切れのレコードとの互換性を維持すべきです（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "9.2.4. Granularity",
      "section_title": true,
      "ja": "9.2.4. 粒度"
    },
    {
      "indent": 3,
      "text": "Sending Alt-Svc over HTTP allows the server to tailor the Alt-Svc field value specifically to the client. When using an HTTPS RR, groups of clients will necessarily receive the same SvcParams. Therefore, HTTPS RRs are not suitable for uses that require single-client granularity.",
      "ja": "HTTPを介してAlt-SVCを送信すると、サーバーはALT-SVCフィールド値をクライアントに特別に調整できます。HTTPS RRを使用する場合、クライアントのグループは必然的に同じSVCPARAMSを受け取ります。したがって、HTTPS RRSは、単クライアントの粒度を必要とする使用には適していません。"
    },
    {
      "indent": 0,
      "text": "9.3. Interaction with Alt-Svc",
      "section_title": true,
      "ja": "9.3. Alt-SVCとの相互作用"
    },
    {
      "indent": 3,
      "text": "Clients that implement support for both Alt-Svc and HTTPS records and are making a connection based on a cached Alt-Svc response SHOULD retrieve any HTTPS records for the Alt-Svc alt-authority and ensure that their connection attempts are consistent with both the Alt-Svc parameters and any received HTTPS SvcParams. If present, the HTTPS record's TargetName and port are used for connection establishment (per Section 3). For example, suppose that \"https://example.com\" sends an Alt-Svc field value of:",
      "ja": "Alt-SvcとHTTPSレコードの両方のサポートを実装し、キャッシュされたAlt-Svc応答に基づいて接続を作成しているクライアントは、Alt-Svc alt-authorityのHTTPSレコードを取得し、接続の試みがAlt-Svcパラメーターおよび受信したHTTPS SvcParamsの両方と一致していることを確認すべきです（SHOULD）。存在する場合、HTTPSレコードのTargetNameとポートは、接続確立に使用されます（セクション3ごと）。たとえば、「https://example.com」が次のようなAlt-Svcフィールド値を送信するとします。"
    },
    {
      "indent": 3,
      "text": "Alt-Svc: h2=\"alt.example:443\", h2=\"alt2.example:443\", h3=\":8443\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client would retrieve the following HTTPS records:",
      "ja": "クライアントは、次のHTTPSレコードを取得します。"
    },
    {
      "indent": 3,
      "text": "alt.example.              IN HTTPS 1 . alpn=h2,h3 foo=...\nalt2.example.             IN HTTPS 1 alt2b.example. alpn=h3 foo=...\n_8443._https.example.com. IN HTTPS 1 alt3.example. (\n    port=9443 alpn=h2,h3 foo=... )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Based on these inputs, the following connection attempts would always be allowed:",
      "ja": "これらの入力に基づいて、次の接続の試行は常に許可されます。"
    },
    {
      "indent": 6,
      "text": "* HTTP/2 to alt.example:443",
      "ja": "* http/2 to alt.example：443"
    },
    {
      "indent": 6,
      "text": "* HTTP/3 to alt3.example:9443",
      "ja": "* http/3 to alt3.example：9443"
    },
    {
      "indent": 6,
      "text": "* Fallback to the client's non-Alt-Svc connection behavior",
      "ja": "* クライアントの非ALT-SVC接続動作へのフォールバック"
    },
    {
      "indent": 3,
      "text": "The following connection attempts would not be allowed:",
      "ja": "次の接続試行は許可されません。"
    },
    {
      "indent": 6,
      "text": "* HTTP/3 to alt.example:443 (not consistent with Alt-Svc)",
      "ja": "* http/3 to alt.example：443（alt-svcと一致しない）"
    },
    {
      "indent": 6,
      "text": "* Any connection to alt2b.example (no ALPN ID consistent with both the HTTPS record and Alt-Svc)",
      "ja": "* alt2b.exampleへの接続（HTTPSレコードとALT-SVCの両方と一致するALPN IDはありません）"
    },
    {
      "indent": 6,
      "text": "* HTTPS over TCP to any port on alt3.example (not consistent with Alt-Svc)",
      "ja": "* alt3.exampleの任意のポートにtcpを介してhttps（alt-svcと一致していません）"
    },
    {
      "indent": 3,
      "text": "Suppose that \"foo\" is a SvcParamKey that renders the client SVCB-reliant. The following Alt-Svc-only connection attempts would be allowed only if the client does not support \"foo\", as they rely on SVCB-optional fallback behavior:",
      "ja": "「foo」は、クライアントをSVCB-reliantにするSvcParamKeyであると仮定します。以下のAlt-Svcのみの接続試行は、クライアントがSVCBオプションのフォールバック動作に依存しているため、クライアントが「foo」をサポートしていない場合にのみ許可されます。"
    },
    {
      "indent": 6,
      "text": "* HTTP/2 to alt2.example:443",
      "ja": "* alt2.example:443へのHTTP/2"
    },
    {
      "indent": 6,
      "text": "* HTTP/3 to example.com:8443",
      "ja": "* http/3 to example.com：8443"
    },
    {
      "indent": 3,
      "text": "Alt-authorities SHOULD carry the same SvcParams as the origin unless a deviation is specifically known to be safe. As noted in Section 2.4 of [AltSvc], clients MAY disallow any Alt-Svc connection according to their own criteria, e.g., disallowing Alt-Svc connections that lack support for privacy features that are available on the authority endpoint.",
      "ja": "Alt-authoritiesは、偏差が安全であることが特に知られている場合を除き、オリジンと同じSvcParamsを搭載すべきです（SHOULD）。[AltSvc]のセクション2.4で述べたように、クライアントは、独自の基準に従ってAlt-Svc接続を許可しなくてもかまいません（MAY）。たとえば、オーソリティエンドポイントで利用可能なプライバシー機能のサポートが欠けているAlt-Svc接続を許可しないなどです。"
    },
    {
      "indent": 0,
      "text": "9.4. Requiring Server Name Indication",
      "section_title": true,
      "ja": "9.4. サーバー名の表示が必要です"
    },
    {
      "indent": 3,
      "text": "Clients MUST NOT use an HTTPS RR response unless the client supports the TLS Server Name Indication (SNI) extension and indicates the origin name in the TLS ClientHello (which might be encrypted via a future specification such as [ECH]). This supports the conservation of IP addresses.",
      "ja": "クライアントがTLSサーバー名表示（SNI）拡張機能をサポートし、TLS ClientHelloでオリジン名を示さない限り、クライアントはHTTPS RR応答を使用してはなりません（MUST NOT）。これは、IPアドレスの保存をサポートします。"
    },
    {
      "indent": 3,
      "text": "Note that the TLS SNI (and also the HTTP \"Host\" or \":authority\") will indicate the origin, not the TargetName.",
      "ja": "TLS SNI（およびHTTP \"HOST\"または \"：authority\"）は、ターゲット名ではなく起源を示していることに注意してください。"
    },
    {
      "indent": 0,
      "text": "9.5. HTTP Strict Transport Security (HSTS)",
      "section_title": true,
      "ja": "9.5. HTTP Strict Transport Security（HSTS）"
    },
    {
      "indent": 3,
      "text": "An HTTPS RR directs the client to communicate with this host only over a secure transport, similar to HSTS [HSTS]. Prior to making an \"http\" scheme request, the client SHOULD perform a lookup to determine if any HTTPS RRs exist for that origin. To do so, the client SHOULD construct a corresponding \"https\" URL as follows:",
      "ja": "HTTPS RRは、HSTS [HSTS]と同様に、安全なトランスポート上でのみこのホストと通信するようクライアントに指示します。「http」スキーム要求を作成する前に、クライアントは検索を実行して、そのオリジンに対してHTTPS RRが存在するかどうかを判断すべきです（SHOULD）。そのために、クライアントは次のように対応する「https」URLを構築すべきです（SHOULD）。"
    },
    {
      "indent": 8,
      "text": "1. Replace the \"http\" scheme with \"https\".",
      "ja": "1. 「http」スキームを「https」に置き換えます。"
    },
    {
      "indent": 8,
      "text": "2. If the \"http\" URL explicitly specifies port 80, specify port 443.",
      "ja": "2. 「HTTP」URLがポート80を明示的に指定する場合、ポート443を指定します。"
    },
    {
      "indent": 8,
      "text": "3. Do not alter any other aspect of the URL.",
      "ja": "3. URLの他の側面を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "This construction is equivalent to Section 8.3 of [HSTS], Step 5.",
      "ja": "この構造は、[HSTS]のセクション8.3、ステップ5に相当します。"
    },
    {
      "indent": 3,
      "text": "If an HTTPS RR query for this \"https\" URL returns any AliasMode HTTPS RRs or any compatible ServiceMode HTTPS RRs (see Section 8), the client SHOULD behave as if it has received an HTTP 307 (Temporary Redirect) status code with this \"https\" URL in the \"Location\" field. (Receipt of an incompatible ServiceMode RR does not trigger the redirect behavior.) Because HTTPS RRs are received over an often-insecure channel (DNS), clients MUST NOT place any more trust in this signal than if they had received a 307 (Temporary Redirect) response over cleartext HTTP.",
      "ja": "この「https」URLのHTTPS RRクエリがAliasMode HTTPS RRまたは互換性のあるServiceMode HTTPS RRを返す場合（セクション8を参照）、クライアントはこの「https」URLを「Location」フィールドに持つHTTP 307（Temporary Redirect）ステータスコードを受け取ったかのように動作すべきです（SHOULD）。（互換性のないServiceMode RRの受領は、リダイレクト動作をトリガーしません。）HTTPS RRは、しばしば安全でないチャネル（DNS）で受信されるため、クライアントはクリアテキストHTTPで307（Temporary Redirect）応答を受け取った場合以上にこのシグナルに信頼を置いてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Publishing an HTTPS RR can potentially lead to unexpected results or a loss in functionality in cases where the \"http\" resource neither redirects to the \"https\" resource nor references the same underlying resource.",
      "ja": "HTTPS RRを公開すると、「HTTP」リソースが「HTTPS」リソースにリダイレクトしたり、同じ基礎となるリソースを参照したりしない場合、予期しない結果や機能の損失につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "When an \"https\" connection fails due to an error in the underlying secure transport, such as an error in certificate validation, some clients currently offer a \"user recourse\" that allows the user to bypass the security error and connect anyway. When making an \"https\" scheme request to an origin with an HTTPS RR, either directly or via the above redirect, such a client MAY remove the user recourse option. Origins that publish HTTPS RRs therefore MUST NOT rely on user recourse for access. For more information, see Sections 8.4 and 12.1 of [HSTS].",
      "ja": "証明書の検証のエラーなど、基礎となる安全なトランスポートのエラーにより「https」接続が失敗した場合、一部のクライアントは現在、ユーザーがセキュリティエラーをバイパスしてとにかく接続できる「ユーザーによる回避策」を提供しています。HTTPS RRを使用してOriginに「https」スキームを要求する場合、直接または上記のリダイレクトを介して、そのようなクライアントはユーザーによる回避策のオプションを削除してもかまいません（MAY）。したがって、HTTPS RRを公開するオリジンは、アクセスのためにユーザーによる回避策に依存してはなりません（MUST NOT）。詳細については、[HSTS]のセクション8.4および12.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.6. Use of HTTPS RRs in Other Protocols",
      "section_title": true,
      "ja": "9.6. 他のプロトコルでのHTTPS RRの使用"
    },
    {
      "indent": 3,
      "text": "All HTTP connections to named origins are eligible to use HTTPS RRs, even when HTTP is used as part of another protocol or without an explicit HTTP-related URI scheme (Section 4.2 of [HTTP]). For example, clients that support HTTPS RRs and implement [WebSocket] using the altered opening handshake from [FETCH-WEBSOCKETS] SHOULD use HTTPS RRs for the requestURL.",
      "ja": "名前のオリジンへのすべてのHTTP接続は、HTTPが別のプロトコルの一部として使用されている場合、または明示的なHTTP関連のURIスキーム（[HTTP]のセクション4.2）なしでもHTTPS RRSを使用する資格があります。たとえば、[fetch-websockets]からの変更されたオープニングハンドシェイクを使用してHTTPS RRSをサポートし、[WebSocket]を実装するクライアントは、requestURLにHTTPS RRSを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "When HTTP is used in a context where URLs or redirects are not applicable (e.g., connections to an HTTP proxy), clients that find a corresponding HTTPS RR SHOULD implement security upgrade behavior equivalent to that specified in Section 9.5.",
      "ja": "HTTPがURLまたはリダイレクトが適用されないコンテキスト（HTTPプロキシへの接続など）で使用される場合、対応するHTTPS RRを見つけたクライアントは、セクション9.5で指定されたものに相当するセキュリティアップグレード動作を実装すべきです（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Such protocols MAY define their own SVCB mappings, which MAY be defined to take precedence over HTTPS RRs.",
      "ja": "このようなプロトコルは、独自のSVCBマッピングを定義してもよく（MAY）、それはHTTPS RRよりも優先されるように定義されてもかまいません（MAY）。"
    },
    {
      "indent": 0,
      "text": "10. Zone Structures",
      "section_title": true,
      "ja": "10. ゾーン構造"
    },
    {
      "indent": 0,
      "text": "10.1. Structuring Zones for Flexibility",
      "section_title": true,
      "ja": "10.1. 柔軟性のためにゾーンを構築します"
    },
    {
      "indent": 3,
      "text": "Each ServiceMode RRset can only serve a single scheme. The scheme is indicated by the owner name and the RR type. For the generic SVCB RR type, this means that each owner name can only be used for a single scheme. The underscore prefixing requirement (Section 2.3) ensures that this is true for the initial query, but it is the responsibility of zone owners to choose names that satisfy this constraint when using aliases, including CNAME and AliasMode records.",
      "ja": "各ServiceMode RRsetは、単一のスキームのみを提供できます。スキームは、所有者名とRRタイプで示されます。一般的なSVCB RRタイプの場合、これは各所有者名が単一のスキームにのみ使用できることを意味します。アンダースコアのプレフィックス要件（セクション2.3）は、これが初期クエリに当てはまることを保証しますが、ゾーンオーナーの責任は、CNAMEおよびAliasModeレコードを含むエイリアスを使用するときにこの制約を満たす名前を選択する責任です。"
    },
    {
      "indent": 3,
      "text": "When using the generic SVCB RR type with aliasing, zone owners SHOULD choose alias target names that indicate the scheme in use (e.g., \"foosvc.example.net\" for \"foo\" schemes). This will help to avoid confusion when another scheme needs to be added to the configuration. When multiple port numbers are in use, it may be helpful to repeat the prefix labels in the alias target name (e.g., \"_1234._foo.svc.example.net\").",
      "ja": "エイリアシングで汎用SVCB RRタイプを使用する場合、ゾーンオーナーは、使用中のスキームを示すエイリアスターゲット名を選択すべきです（SHOULD）（たとえば、「foo」スキームの「foosvc.example.net」）。これは、別のスキームを構成に追加する必要がある場合、混乱を避けるのに役立ちます。複数のポート番号が使用されている場合、エイリアスターゲット名でプレフィックスラベルを繰り返すと役立つ場合があります（例： \"_1234._foo.svc.example.net\"）。"
    },
    {
      "indent": 0,
      "text": "10.2. Structuring Zones for Performance",
      "section_title": true,
      "ja": "10.2. パフォーマンスのためのゾーンの構造"
    },
    {
      "indent": 3,
      "text": "To avoid a delay for clients using a non-conforming recursive resolver, domain owners SHOULD minimize the use of AliasMode records and SHOULD choose TargetName according to a predictable convention that is known to the client, so that clients can issue A and/or AAAA queries for TargetName in advance (see Section 5). Unless otherwise specified, the convention is to set TargetName to the service name for an initial ServiceMode record, or to \".\" if it is reached via an alias.",
      "ja": "不適合な再帰リゾルバーを使用しているクライアントの遅延を回避するために、ドメインの所有者はAliasModeレコードの使用を最小限に抑えるべきであり（SHOULD）、クライアントに知られている予測可能な慣習に従ってTargetNameを選択すべきです（SHOULD）。そうすることで、クライアントは事前にTargetNameのAおよび/またはAAAAクエリを発行できます（セクション5を参照）。特に指定されていない限り、コンベンションは、初期ServiceModeレコードのターゲット名をサービス名に設定するか、エイリアスを介して到達した場合は「.」に設定することです。"
    },
    {
      "indent": 3,
      "text": "$ORIGIN example.com. ; Origin\nfoo                  3600 IN CNAME foosvc.example.net.\n_8080._foo.foo       3600 IN CNAME foosvc.example.net.\nbar                   300 IN AAAA 2001:db8::2\n_9090._bar.bar       3600 IN SVCB 1 bar key65444=...\n\n$ORIGIN example.net. ; Service provider zone\nfoosvc               3600 IN SVCB 1 . key65333=...\nfoosvc                300 IN AAAA 2001:db8::1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": " Figure 1: \"foo://foo.example.com:8080\" Is Available at \"foosvc.example.net\", but \"bar://bar.example.com:9090\" Is Served Locally",
      "ja": "図1：「foo：//foo.example.com：8080」は「foosvc.example.net」で入手できますが、「bar：//bar.example.com：9090」が地元で提供されています"
    },
    {
      "indent": 3,
      "text": "Domain owners SHOULD avoid using a TargetName that is below a DNAME, as this is likely unnecessary and makes responses slower and larger. Also, zone structures that require following more than eight aliases (counting both AliasMode and CNAME records) are NOT RECOMMENDED.",
      "ja": "ドメインの所有者は、DNAMEの下にあるTargetNameの使用を避けるべきです（SHOULD）。これは、おそらく不要であり、応答がより遅く、より大きくなるためです。また、8つ以上のエイリアスをフォローする必要があるゾーン構造（AliasModeとCNAMEレコードの両方をカウント）は推奨されません（NOT RECOMMENDED）。"
    },
    {
      "indent": 0,
      "text": "10.3. Operational Considerations",
      "section_title": true,
      "ja": "10.3. 運用上の考慮事項"
    },
    {
      "indent": 3,
      "text": "Some authoritative DNS servers may not allow A or AAAA records on names starting with an underscore (e.g., [BIND-CHECK-NAMES]). This could create an operational issue when the TargetName contains an Attrleaf label, or when using a TargetName of \".\" if the owner name contains an Attrleaf label.",
      "ja": "一部の権威DNSサーバーは、アンダースコア（[BIND-CHECK-NAMES]など）から始まる名前のAまたはAAAAのレコードを許可しない場合があります。これにより、TargetNameにAttrleafラベルが含まれている場合、または所有者名にAttrleafラベルが含まれている場合にTargetNameとして「.」を使用するときに運用上の問題が発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "10.4. Examples",
      "section_title": true,
      "ja": "10.4. 例"
    },
    {
      "indent": 0,
      "text": "10.4.1. Protocol Enhancements",
      "section_title": true,
      "ja": "10.4.1. プロトコルの強化"
    },
    {
      "indent": 3,
      "text": "Consider a simple zone of the form:",
      "ja": "フォームの単純なゾーンを考えてみましょう。"
    },
    {
      "indent": 3,
      "text": "$ORIGIN simple.example. ; Simple example zone\n@ 300 IN A    192.0.2.1\n         AAAA 2001:db8::1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The domain owner could add this record:",
      "ja": "ドメインの所有者はこのレコードを追加できます。"
    },
    {
      "indent": 3,
      "text": "@ 7200 IN HTTPS 1 . alpn=h3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This record would indicate that \"https://simple.example\" supports QUIC in addition to HTTP/1.1 over TLS over TCP (the implicit default). The record could also include other information (e.g., a non-standard port). For \"https://simple.example:8443\", the record would be:",
      "ja": "このレコードは、「https://simple.example」は、TCPを介したTLSよりもHTTP/1.1に加えてQUICをサポートしていることを示します（暗黙的なデフォルト）。レコードには、他の情報（標準以外のポートなど）を含めることもできます。「https://simple.example：8443」の場合、レコードは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "_8443._https 7200 IN HTTPS 1 . alpn=h3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These records also respectively tell clients to replace the scheme with \"https\" when loading \"http://simple.example\" or \"http://simple.example:8443\".",
      "ja": "これらのレコードは、それぞれクライアントに、「http://simple.example」または「http://simple.example：8443」をロードするときに、スキームを「https」に置き換えることを指示します。"
    },
    {
      "indent": 0,
      "text": "10.4.2. Apex Aliasing",
      "section_title": true,
      "ja": "10.4.2. 頂点エイリアシング"
    },
    {
      "indent": 3,
      "text": "Consider a zone that is using CNAME aliasing:",
      "ja": "cnameエイリアシングを使用しているゾーンを検討してください。"
    },
    {
      "indent": 3,
      "text": "$ORIGIN aliased.example. ; A zone that is using a hosting service\n; Subdomain aliased to a high-performance server pool\nwww             7200 IN CNAME pool.svc.example.\n; Apex domain on fixed IPs because CNAME is not allowed at the apex\n@                300 IN A     192.0.2.1\n                     IN AAAA  2001:db8::1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With HTTPS RRs, the owner of aliased.example could alias the apex by adding one additional record:",
      "ja": "HTTPS RRSを使用すると、Alise.exampleの所有者は、1つのレコードを追加することでApexをエイリアスできます。"
    },
    {
      "indent": 3,
      "text": "@               7200 IN HTTPS 0 pool.svc.example.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With this record in place, HTTPS-RR-aware clients will use the same server pool for aliased.example and www.aliased.example. (They will also upgrade \"http://aliased.example/...\" to \"https\".) Non-HTTPS-RR-aware clients will just ignore the new record.",
      "ja": "このレコードを導入すると、https-rr-awareクライアントは、同じサーバープールを使用してairased.exampleとwww.aliade.exampleを使用します。（また、「http://aliased.example/...」に「https」にアップグレードします。）非https-rr-awareクライアントは、新しいレコードを無視するだけです。"
    },
    {
      "indent": 3,
      "text": "Similar to CNAME, HTTPS RRs have no impact on the origin name. When connecting, clients will continue to treat the authoritative origins as \"https://www.aliased.example\" and \"https://aliased.example\", respectively, and will validate TLS server certificates accordingly.",
      "ja": "CNAMEと同様に、HTTPS RRSはオリジン名に影響を与えません。接続すると、クライアントは権威ある起源をそれぞれ「https://www.aliade.example」および「https://aliade.example」として扱い続け、それに応じてTLSサーバー証明書を検証します。"
    },
    {
      "indent": 0,
      "text": "10.4.3. Parameter Binding",
      "section_title": true,
      "ja": "10.4.3. パラメーターバインディング"
    },
    {
      "indent": 3,
      "text": "Suppose that svc.example's primary server pool supports HTTP/3 but its backup server pool does not. This can be expressed in the following form:",
      "ja": "SVC.exampleのプライマリサーバープールがHTTP/3をサポートしているが、そのバックアップサーバープールがサポートしていないと仮定します。これは、次の形式で表現できます。"
    },
    {
      "indent": 3,
      "text": "$ORIGIN svc.example. ; A hosting provider\npool  7200 IN HTTPS 1 . alpn=h2,h3\n              HTTPS 2 backup alpn=h2 port=8443\npool   300 IN A        192.0.2.2\n              AAAA     2001:db8::2\nbackup 300 IN A        192.0.2.3\n              AAAA     2001:db8::3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This configuration is entirely compatible with the \"apex aliasing\" example, whether the client supports HTTPS RRs or not. If the client does support HTTPS RRs, all connections will be upgraded to HTTPS, and clients will use HTTP/3 if they can. Parameters are \"bound\" to each server pool, so each server pool can have its own protocol, port number, etc.",
      "ja": "この構成は、クライアントがHTTPS RRSをサポートするかどうかにかかわらず、「APEXエイリアシング」の例と完全に互換性があります。クライアントがHTTPS RRSをサポートしている場合、すべての接続はHTTPSにアップグレードされ、クライアントはできる場合はHTTP/3を使用します。パラメーターは各サーバープールに「バインド」されるため、各サーバープールには独自のプロトコル、ポート番号などがあります。"
    },
    {
      "indent": 0,
      "text": "10.4.4. Multi-CDN Configuration",
      "section_title": true,
      "ja": "10.4.4. マルチCDN構成"
    },
    {
      "indent": 3,
      "text": "The HTTPS RR is intended to support HTTPS services operated by multiple independent entities, such as different CDNs or different hosting providers. This includes the case where a service is migrated from one operator to another, as well as the case where the service is multiplexed between multiple operators for performance, redundancy, etc.",
      "ja": "HTTPS RRは、異なるCDNや異なるホスティングプロバイダーなど、複数の独立したエンティティが運営するHTTPSサービスをサポートすることを目的としています。これには、サービスがあるオペレーターから別のオペレーターに移行される場合、およびパフォーマンス、冗長性などのために複数のオペレーター間でサービスが多重化される場合が含まれます。"
    },
    {
      "indent": 3,
      "text": "This example shows such a configuration, with www.customer.example having different DNS responses to different queries, either over time or due to logic within the authoritative DNS server:",
      "ja": "この例は、www.customer.exampleが異なるクエリに対して異なるDNS応答を持つような構成を示しています。"
    },
    {
      "indent": 4,
      "text": "; This zone contains/returns different CNAME records\n; at different points in time.  The RRset for \"www\" can\n; only ever contain a single CNAME.\n\n; Sometimes the zone has:\n$ORIGIN customer.example.  ; A multi-CDN customer domain\nwww 900 IN CNAME cdn1.svc1.example.\n\n; and other times it contains:\n$ORIGIN customer.example.\nwww 900 IN CNAME customer.svc2.example.\n\n; and yet other times it contains:\n$ORIGIN customer.example.\nwww 900 IN CNAME cdn3.svc3.example.\n\n; With the following remaining constant and always included:\n$ORIGIN customer.example.  ; A multi-CDN customer domain\n; The apex is also aliased to www to match its configuration.\n@     7200 IN HTTPS 0 www\n; Non-HTTPS-aware clients use non-CDN IPs.\n              A    203.0.113.82\n              AAAA 2001:db8:203::2\n\n; Resolutions following the cdn1.svc1.example\n; path use these records.\n; This CDN uses a different alternative service for HTTP/3.\n$ORIGIN svc1.example.  ; domain for CDN 1\ncdn1     1800 IN HTTPS 1 h3pool alpn=h3\n                 HTTPS 2 . alpn=h2\n                 A    192.0.2.2\n                 AAAA 2001:db8:192::4\nh3pool 300 IN A 192.0.2.3\n           AAAA 2001:db8:192:7::3\n\n; Resolutions following the customer.svc2.example\n; path use these records.\n; Note that this CDN only supports HTTP/2.\n$ORIGIN svc2.example. ; domain operated by CDN 2\ncustomer 300 IN HTTPS 1 . alpn=h2\n          60 IN A    198.51.100.2\n                A    198.51.100.3\n                A    198.51.100.4\n                AAAA 2001:db8:198::7\n                AAAA 2001:db8:198::12\n\n; Resolutions following the cdn3.svc3.example\n; path use these records.\n; Note that this CDN has no HTTPS records.\n$ORIGIN svc3.example. ; domain operated by CDN 3\ncdn3      60 IN A    203.0.113.8\n                AAAA 2001:db8:113::8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that in the above example, the different CDNs have different configurations and different capabilities, but clients will use HTTPS RRs as a bound-together unit.",
      "ja": "上記の例では、異なるCDNには異なる構成と異なる機能がありますが、クライアントはHTTPS RRをバウンドユニットとして使用します。"
    },
    {
      "indent": 3,
      "text": "Domain owners should be cautious when using a multi-CDN configuration, as it introduces a number of complexities highlighted by this example:",
      "ja": "マルチCDN構成を使用する場合、ドメインの所有者は、この例で強調されている多くの複雑さを導入するため、注意する必要があります。"
    },
    {
      "indent": 6,
      "text": "* If CDN 1 supports a desired protocol or feature and CDN 2 does not, the client is vulnerable to downgrade by a network adversary who forces clients to get CDN 2 records.",
      "ja": "* CDN 1が目的のプロトコルまたは機能をサポートし、CDN 2がそうでない場合、クライアントは、クライアントにCDN 2レコードを取得するように強制するネットワーク上の敵対者によるダウングレードに対して脆弱になります。"
    },
    {
      "indent": 6,
      "text": "* Aliasing the apex to its subdomain simplifies the zone file but likely increases resolution latency, especially when using a non-HTTPS-aware recursive resolver. An alternative would be to alias the zone apex directly to a name managed by a CDN.",
      "ja": "* 頂点をサブドメインにエイリアスすると、ゾーンファイルが簡素化されますが、特に非HTTPSを認識していない再帰リゾルバーを使用する場合、解決の遅延が増加する可能性があります。別の方法は、CDNによって管理された名前にゾーンアペックスを直接エイリアスすることです。"
    },
    {
      "indent": 6,
      "text": "* The A, AAAA, and HTTPS resolutions are independent lookups, so resolvers may observe and follow different CNAMEs to different CDNs. Clients may thus find that the A and AAAA responses do not correspond to the TargetName in the HTTPS response; these clients will need to perform additional queries to retrieve the correct IP addresses. Including ipv6hint and ipv4hint will reduce the performance impact of this case.",
      "ja": "* A、AAAA、およびHTTPSの解決は独立したルックアップであるため、リゾルバーは異なるCDNへの異なるCNAMEを観察し、追跡する場合があります。したがって、クライアントは、AおよびAAAA応答がHTTPS応答のターゲット名に対応していないことを発見する場合があります。これらのクライアントは、正しいIPアドレスを取得するために追加のクエリを実行する必要があります。IPv6hintとIPv4hintを含めると、このケースのパフォーマンスへの影響が減ります。"
    },
    {
      "indent": 6,
      "text": "* If not all CDNs publish HTTPS records, clients will sometimes receive NODATA for HTTPS queries (as with cdn3.svc3.example above) but could receive A/AAAA records from a different CDN. Clients will attempt to connect to this CDN without the benefit of its HTTPS records.",
      "ja": "* すべてのCDNがHTTPSレコードを公開しているわけではない場合、クライアントはHTTPSクエリに対してNODATA（上記のcdn3.svc3.exampleのように）を受け取ることがありますが、別のCDNからA/AAAAレコードを受信することがあります。クライアントは、HTTPSレコードの恩恵なしにこのCDNに接続しようとします。"
    },
    {
      "indent": 0,
      "text": "10.4.5. Non-HTTP Uses",
      "section_title": true,
      "ja": "10.4.5. 非HTTPの使用"
    },
    {
      "indent": 3,
      "text": "For protocols other than HTTP, the SVCB RR and an Attrleaf label [Attrleaf] will be used. For example, to reach an example resource of \"baz://api.example.com:8765\", the following SVCB record would be used to alias it to \"svc4-baz.example.net.\", which in turn could return AAAA/A records and/or SVCB records in ServiceMode:",
      "ja": "HTTP以外のプロトコルの場合、SVCB RRとAttreafラベル[アトリーフ]が使用されます。たとえば、「baz：//api.example.com：8765」の例に到達するために、次のSVCBレコードを使用して「svc4-baz.example.net」にエイリアスします。AAAA/Aレコードおよび/またはSVCBレコードのServiceMode："
    },
    {
      "indent": 3,
      "text": "_8765._baz.api.example.com. 7200 IN SVCB 0 svc4-baz.example.net.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HTTPS RRs use similar Attrleaf labels if the origin contains a non-default port.",
      "ja": "HTTPS RRSは、Originに非デフォルトポートが含まれている場合、同様のアトリーフラベルを使用します。"
    },
    {
      "indent": 0,
      "text": "11. Interaction with Other Standards",
      "section_title": true,
      "ja": "11. 他の基準との相互作用"
    },
    {
      "indent": 3,
      "text": "This standard is intended to reduce connection latency and improve user privacy. Server operators implementing this standard SHOULD also implement TLS 1.3 [RFC8446] and Online Certificate Status Protocol (OCSP) Stapling (i.e., Certificate Status Request in Section 8 of [RFC6066]), both of which confer substantial performance and privacy benefits when used in combination with SVCB records.",
      "ja": "この標準は、接続の遅延を減らし、ユーザーのプライバシーを改善することを目的としています。この標準を実装するサーバーオペレーターは、TLS 1.3 [RFC8446]およびオンライン証明書ステータスプロトコル（OCSP）ステープル化（つまり、[RFC6066]のセクション8の証明書ステータス要求）も実装すべきです（SHOULD）。これらはどちらも、SVCBレコードと組み合わせて使用すると、パフォーマンスとプライバシーに大きなメリットをもたらします。"
    },
    {
      "indent": 3,
      "text": "To realize the greatest privacy benefits, this proposal is intended for use over a privacy-preserving DNS transport (like DNS over TLS [DoT] or DNS over HTTPS [DoH]). However, performance improvements, and some modest privacy improvements, are possible without the use of those standards.",
      "ja": "最大のプライバシーメリットを実現するために、この提案は、プライバシーを提供するDNSトランスポート（DNS over TLS [DoT]やDNS over HTTPS [DoH]など）で使用することを目的としています。ただし、パフォーマンスの改善、およびいくつかの控えめなプライバシーの改善は、それらの基準を使用せずに可能です。"
    },
    {
      "indent": 3,
      "text": "Any specification for the use of SVCB with a protocol MUST have an entry for its scheme under the SVCB RR type in the IANA DNS \"Underscored and Globally Scoped DNS Node Names\" registry [Attrleaf]. The scheme MUST have an entry in the \"Uniform Resource Identifier (URI) Schemes\" registry [RFC7595] and MUST have a defined specification for use with SVCB.",
      "ja": "プロトコルでのSVCBの使用に関するいかなる仕様も、IANA DNSの「Underscored and Globally Scoped DNS Node Names」レジストリ[Attrleaf]のSVCB RRタイプの下に、そのスキームのエントリを持たなければなりません（MUST）。スキームは、「Uniform Resource Identifier (URI) Schemes」レジストリ[RFC7595]にエントリを持たなければならず（MUST）、SVCBで使用するための定義された仕様を持たなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "SVCB/HTTPS RRs permit distribution over untrusted channels, and clients are REQUIRED to verify that the alternative endpoint is authoritative for the service (similar to Section 2.1 of [AltSvc]). Therefore, DNSSEC signing and validation are OPTIONAL for publishing and using SVCB and HTTPS RRs.",
      "ja": "SVCB/HTTPS RRは、信頼されていないチャネル上の分布を許可しており、クライアントは、代替エンドポイントがサービスに対して権威があることを確認することが要求されます（REQUIRED）（[AltSvc]のセクション2.1と同様）。したがって、DNSSECの署名と検証は、SVCBおよびHTTPS RRを公開および使用するためにはオプション（OPTIONAL）です。"
    },
    {
      "indent": 3,
      "text": "Clients MUST ensure that their DNS cache is partitioned for each local network, or flushed on network changes, to prevent a local adversary in one network from implanting a forged DNS record that allows them to track users or hinder their connections after they leave that network.",
      "ja": "クライアントは、DNSキャッシュがローカルネットワークごとに分割されるか、ネットワークの変更時にフラッシュされることを保証しなければなりません（MUST）。これは、1つのネットワーク内のローカルの敵対者が偽造されたDNSレコードを埋め込み、ユーザーがそのネットワークを離れた後にユーザーを追跡したり接続を妨害したりするのを防ぐためです。"
    },
    {
      "indent": 3,
      "text": "An attacker who can prevent SVCB resolution can deny clients any associated security benefits. A hostile recursive resolver can always deny service to SVCB queries, but network intermediaries can often prevent resolution as well, even when the client and recursive resolver validate DNSSEC and use a secure transport. These downgrade attacks can prevent the \"https\" upgrade provided by the HTTPS RR (Section 9.5) and can disable any other protections coordinated via SvcParams. To prevent downgrades, Section 3.1 recommends that clients abandon the connection attempt when such an attack is detected.",
      "ja": "SVCBの解決を防ぐことができる攻撃者は、関連するセキュリティ利益をクライアントに拒否できます。敵対的な再帰リゾルバーは、常にSVCBクエリへのサービスを拒否できますが、ネットワーク仲介業者は、クライアントと再帰リゾルバーがDNSSECを検証し、安全なトランスポートを使用する場合でも、解決を防ぐことができます。これらのダウングレード攻撃は、HTTPS RR（セクション9.5）によって提供される「https」アップグレードを防ぎ、SvcParamsを介して調整された他の保護を無効にすることができます。ダウングレードを防ぐために、セクション3.1は、そのような攻撃が検出されたときにクライアントが接続の試みを放棄することを推奨します。"
    },
    {
      "indent": 3,
      "text": "A hostile DNS intermediary might forge AliasMode \".\" records (Section 2.5.1) as a way to block clients from accessing particular services. Such an adversary could already block entire domains by forging erroneous responses, but this mechanism allows them to target particular protocols or ports within a domain. Clients that might be subject to such attacks SHOULD ignore AliasMode \".\" records.",
      "ja": "敵対的なDNS仲介者は、AliasMode \".\"レコード（セクション2.5.1）を偽造して、クライアントが特定のサービスにアクセスするのをブロックする可能性があります。このような敵は、誤った応答を偽造することにより、すでにドメイン全体をブロックする可能性がありますが、このメカニズムにより、ドメイン内の特定のプロトコルまたはポートをターゲットにすることができます。そのような攻撃の対象となる可能性のあるクライアントは、AliasMode \".\"レコードを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "A hostile DNS intermediary or authoritative server can return SVCB records indicating any IP address and port number, including IP addresses inside the local network and port numbers assigned to internal services. If the attacker can influence the client's payload (e.g., TLS session ticket contents) and an internal service has a sufficiently lax parser, the attacker could gain access to the internal service. (The same concerns apply to SRV records, HTTP Alt-Svc, and HTTP redirects.) As a mitigation, SVCB mapping documents SHOULD indicate any port number restrictions that are appropriate for the supported transports.",
      "ja": "敵対的なDNS仲介者または権威サーバーは、ローカルネットワーク内のIPアドレスや内部サービスに割り当てられたポート番号を含むIPアドレスとポート番号を示すSVCBレコードを返すことができます。攻撃者がクライアントのペイロード（TLSセッションチケットのコンテンツなど）に影響を与え、内部サービスが十分に緩いパーサーを持っている場合、攻撃者は内部サービスにアクセスできます。（同じ懸念がSRVレコード、HTTP Alt-Svc、およびHTTPリダイレクトに適用されます。）緩和として、SVCBマッピングドキュメントは、サポートされているトランスポートに適したポート番号の制限を示すべきです（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "13. Privacy Considerations",
      "section_title": true,
      "ja": "13. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Standard address queries reveal the user's intent to access a particular domain. This information is visible to the recursive resolver, and to many other parties when plaintext DNS transport is used. SVCB queries, like queries for SRV records and other specific RR types, additionally reveal the user's intent to use a particular protocol. This is not normally sensitive information, but it should be considered when adding SVCB support in a new context.",
      "ja": "標準アドレスクエリは、特定のドメインにアクセスするユーザーの意図を明らかにしています。この情報は、再帰的なリゾルバー、およびplaintext DNSトランスポートが使用される場合の他の多くの関係者に表示されます。SRVレコードやその他の特定のRRタイプのクエリなど、SVCBクエリは、特定のプロトコルを使用するというユーザーの意図をさらに明らかにします。これは通常、機密情報ではありませんが、新しいコンテキストでSVCBサポートを追加するときに考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "14.1. SVCB RR Type",
      "section_title": true,
      "ja": "14.1. SVCB RRタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following new DNS RR type in the \"Resource Record (RR) TYPEs\" registry on the \"Domain Name System (DNS) Parameters\" page:",
      "ja": "IANAは、「ドメイン名システム（DNS）パラメーター」ページで「リソースレコード（RR）タイプ」レジストリに次の新しいDNS RRタイプを登録しました。"
    },
    {
      "indent": 3,
      "text": "Type:",
      "ja": "タイプ："
    },
    {
      "indent": 12,
      "text": "SVCB",
      "ja": "SVCB"
    },
    {
      "indent": 3,
      "text": "Value:",
      "ja": "値："
    },
    {
      "indent": 12,
      "text": "64",
      "ja": "64"
    },
    {
      "indent": 3,
      "text": "Meaning:",
      "ja": "意味："
    },
    {
      "indent": 12,
      "text": "General-purpose service binding",
      "ja": "汎用サービスバインディング"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9460",
      "ja": "RFC 9460"
    },
    {
      "indent": 0,
      "text": "14.2. HTTPS RR Type",
      "section_title": true,
      "ja": "14.2. HTTPS RRタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following new DNS RR type in the \"Resource Record (RR) TYPEs\" registry on the \"Domain Name System (DNS) Parameters\" page:",
      "ja": "IANAは、「ドメイン名システム（DNS）パラメーター」ページで「リソースレコード（RR）タイプ」レジストリに次の新しいDNS RRタイプを登録しました。"
    },
    {
      "indent": 3,
      "text": "Type:",
      "ja": "タイプ："
    },
    {
      "indent": 12,
      "text": "HTTPS",
      "ja": "https"
    },
    {
      "indent": 3,
      "text": "Value:",
      "ja": "値："
    },
    {
      "indent": 12,
      "text": "65",
      "ja": "65"
    },
    {
      "indent": 3,
      "text": "Meaning:",
      "ja": "意味："
    },
    {
      "indent": 12,
      "text": "SVCB-compatible type for use with HTTP",
      "ja": "HTTPで使用するSVCB互換タイプ"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9460",
      "ja": "RFC 9460"
    },
    {
      "indent": 0,
      "text": "14.3. New Registry for Service Parameters",
      "section_title": true,
      "ja": "14.3. サービスパラメーターの新しいレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"Service Parameter Keys (SvcParamKeys)\" registry in the \"Domain Name System (DNS) Parameters\" category on a new page entitled \"DNS Service Bindings (SVCB)\". This registry defines the namespace for parameters, including string representations and numeric SvcParamKey values. This registry is shared with other SVCB-compatible RR types, such as the HTTPS RR.",
      "ja": "IANAは、「DNS Service Bindings（SVCB）」というタイトルの新しいページに「ドメイン名システム（DNS）パラメーター」カテゴリに「Service Parameter Keys（SVCParamkeys）」レジストリを作成しました。このレジストリは、文字列表現や数値SVCParamkey値を含むパラメーターの名前空間を定義します。このレジストリは、HTTPS RRなどの他のSVCB互換RRタイプと共有されます。"
    },
    {
      "indent": 0,
      "text": "14.3.1. Procedure",
      "section_title": true,
      "ja": "14.3.1. 手順"
    },
    {
      "indent": 3,
      "text": "A registration MUST include the following fields:",
      "ja": "登録には、次のフィールドを含めなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "Number:",
      "ja": "番号："
    },
    {
      "indent": 12,
      "text": "Wire-format numeric identifier (range 0-65535)",
      "ja": "ワイヤ形式の数値識別子（範囲0-65535）"
    },
    {
      "indent": 3,
      "text": "Name:",
      "ja": "名前："
    },
    {
      "indent": 12,
      "text": "Unique presentation name",
      "ja": "ユニークなプレゼンテーション名"
    },
    {
      "indent": 3,
      "text": "Meaning:",
      "ja": "意味："
    },
    {
      "indent": 12,
      "text": "A short description",
      "ja": "簡単な説明"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "Location of specification or registration source",
      "ja": "仕様または登録ソースの場所"
    },
    {
      "indent": 3,
      "text": "Change Controller:",
      "ja": "Change Controller："
    },
    {
      "indent": 12,
      "text": "Person or entity, with contact information if appropriate",
      "ja": "必要に応じて連絡先情報を含む個人またはエンティティ"
    },
    {
      "indent": 3,
      "text": "The characters in the registered Name field entry MUST be lowercase alphanumeric or \"-\" (Section 2.1). The name MUST NOT start with \"key\" or \"invalid\".",
      "ja": "登録名のフィールドエントリの文字は、小文字の英数字または「-」でなければなりません（MUST）（セクション2.1）。名前は、「key」または「invalid」で始まってはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The registration policy for new entries is Expert Review ([RFC8126], Section 4.5). The designated expert MUST ensure that the reference is stable and publicly available and that it specifies how to convert the SvcParamValue's presentation format to wire format. The reference MAY be any individual's Internet-Draft or a document from any other source with similar assurances of stability and availability. An entry MAY specify a reference of the form \"Same as (other key name)\" if it uses the same presentation and wire formats as an existing key.",
      "ja": "新しいエントリの登録ポリシーは、専門家レビュー（[RFC8126]、セクション4.5）です。指名された専門家は、参照が安定して公開されていること、およびSvcParamValueのプレゼンテーション形式をワイヤー形式に変換する方法を指定していることを確認しなければなりません（MUST）。参照は、個人のインターネットドラフト、または安定性と可用性について同様の保証がある他のソースからのドキュメントであってもかまいません（MAY）。エントリは、既存のキーと同じプレゼンテーションとワイヤー形式を使用する場合、「（他のキー名）と同じ」という形式の参照を指定してもかまいません（MAY）。"
    },
    {
      "indent": 3,
      "text": "This arrangement supports the development of new parameters while ensuring that zone files can be made interoperable.",
      "ja": "この取り決めは、ゾーンファイルを相互運用可能にできるようにしながら、新しいパラメーターの開発をサポートします。"
    },
    {
      "indent": 0,
      "text": "14.3.2. Initial Contents",
      "section_title": true,
      "ja": "14.3.2. 初期内容"
    },
    {
      "indent": 3,
      "text": "The \"Service Parameter Keys (SvcParamKeys)\" registry has been populated with the following initial registrations:",
      "ja": "「Service Parameter Keys（svcparamkeys）」レジストリには、以下の初期登録が入力されています。"
    },
    {
      "indent": 0,
      "text": "+===========+=================+================+=========+==========+\n|   Number  | Name            | Meaning        |Reference|Change    |\n|           |                 |                |         |Controller|\n+===========+=================+================+=========+==========+\n|     0     | mandatory       | Mandatory      |RFC 9460,|IETF      |\n|           |                 | keys in this   |Section 8|          |\n|           |                 | RR             |         |          |\n+-----------+-----------------+----------------+---------+----------+\n|     1     | alpn            | Additional     |RFC 9460,|IETF      |\n|           |                 | supported      |Section  |          |\n|           |                 | protocols      |7.1      |          |\n+-----------+-----------------+----------------+---------+----------+\n|     2     | no-default-alpn | No support     |RFC 9460,|IETF      |\n|           |                 | for default    |Section  |          |\n|           |                 | protocol       |7.1      |          |\n+-----------+-----------------+----------------+---------+----------+\n|     3     | port            | Port for       |RFC 9460,|IETF      |\n|           |                 | alternative    |Section  |          |\n|           |                 | endpoint       |7.2      |          |\n+-----------+-----------------+----------------+---------+----------+\n|     4     | ipv4hint        | IPv4 address   |RFC 9460,|IETF      |\n|           |                 | hints          |Section  |          |\n|           |                 |                |7.3      |          |\n+-----------+-----------------+----------------+---------+----------+\n|     5     | ech             | RESERVED       |N/A      |IETF      |\n|           |                 | (held for      |         |          |\n|           |                 | Encrypted      |         |          |\n|           |                 | ClientHello)   |         |          |\n+-----------+-----------------+----------------+---------+----------+\n|     6     | ipv6hint        | IPv6 address   |RFC 9460,|IETF      |\n|           |                 | hints          |Section  |          |\n|           |                 |                |7.3      |          |\n+-----------+-----------------+----------------+---------+----------+\n|65280-65534| N/A             | Reserved for   |RFC 9460 |IETF      |\n|           |                 | Private Use    |         |          |\n+-----------+-----------------+----------------+---------+----------+\n|   65535   | N/A             | Reserved       |RFC 9460 |IETF      |\n|           |                 | (\"Invalid      |         |          |\n|           |                 | key\")          |         |          |\n+-----------+-----------------+----------------+---------+----------+\n\n                               Table 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14.4. Other Registry Updates",
      "section_title": true,
      "ja": "14.4. その他のレジストリの更新"
    },
    {
      "indent": 3,
      "text": "Per [Attrleaf], the following entry has been added to the DNS \"Underscored and Globally Scoped DNS Node Names\" registry:",
      "ja": "[attrleaf]ごとに、次のエントリがDNSに追加されました。"
    },
    {
      "indent": 16,
      "text": "                +=========+============+===========+\n                | RR Type | _NODE NAME | Reference |\n                +=========+============+===========+\n                | HTTPS   | _https     | RFC 9460  |\n                +---------+------------+-----------+\n\n                              Table 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15. 参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ALPN]     Friedl, S., Popov, A., Langley, A., and E. Stephan,\n           \"Transport Layer Security (TLS) Application-Layer Protocol\n           Negotiation Extension\", RFC 7301, DOI 10.17487/RFC7301,\n           July 2014, <https://www.rfc-editor.org/info/rfc7301>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Attrleaf] Crocker, D., \"Scoped Interpretation of DNS Resource\n           Records through \"Underscored\" Naming of Attribute Leaves\",\n           BCP 222, RFC 8552, DOI 10.17487/RFC8552, March 2019,\n           <https://www.rfc-editor.org/info/rfc8552>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DoH]      Hoffman, P. and P. McManus, \"DNS Queries over HTTPS\n           (DoH)\", RFC 8484, DOI 10.17487/RFC8484, October 2018,\n           <https://www.rfc-editor.org/info/rfc8484>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DoT]      Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,\n           and P. Hoffman, \"Specification for DNS over Transport\n           Layer Security (TLS)\", RFC 7858, DOI 10.17487/RFC7858, May\n           2016, <https://www.rfc-editor.org/info/rfc7858>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HappyEyeballsV2]\n           Schinazi, D. and T. Pauly, \"Happy Eyeballs Version 2:\n           Better Connectivity Using Concurrency\", RFC 8305,\n           DOI 10.17487/RFC8305, December 2017,\n           <https://www.rfc-editor.org/info/rfc8305>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP Semantics\", STD 97, RFC 9110,\n           DOI 10.17487/RFC9110, June 2022,\n           <https://www.rfc-editor.org/info/rfc9110>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1034]  Mockapetris, P., \"Domain names - concepts and facilities\",\n           STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987,\n           <https://www.rfc-editor.org/info/rfc1034>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1035]  Mockapetris, P., \"Domain names - implementation and\n           specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035,\n           November 1987, <https://www.rfc-editor.org/info/rfc1035>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1928]  Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and\n           L. Jones, \"SOCKS Protocol Version 5\", RFC 1928,\n           DOI 10.17487/RFC1928, March 1996,\n           <https://www.rfc-editor.org/info/rfc1928>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2181]  Elz, R. and R. Bush, \"Clarifications to the DNS\n           Specification\", RFC 2181, DOI 10.17487/RFC2181, July 1997,\n           <https://www.rfc-editor.org/info/rfc2181>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3225]  Conrad, D., \"Indicating Resolver Support of DNSSEC\",\n           RFC 3225, DOI 10.17487/RFC3225, December 2001,\n           <https://www.rfc-editor.org/info/rfc3225>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3597]  Gustafsson, A., \"Handling of Unknown DNS Resource Record\n           (RR) Types\", RFC 3597, DOI 10.17487/RFC3597, September\n           2003, <https://www.rfc-editor.org/info/rfc3597>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4001]  Daniele, M., Haberman, B., Routhier, S., and J.\n           Schoenwaelder, \"Textual Conventions for Internet Network\n           Addresses\", RFC 4001, DOI 10.17487/RFC4001, February 2005,\n           <https://www.rfc-editor.org/info/rfc4001>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n           Specifications: ABNF\", STD 68, RFC 5234,\n           DOI 10.17487/RFC5234, January 2008,\n           <https://www.rfc-editor.org/info/rfc5234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5952]  Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6\n           Address Text Representation\", RFC 5952,\n           DOI 10.17487/RFC5952, August 2010,\n           <https://www.rfc-editor.org/info/rfc5952>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6066]  Eastlake 3rd, D., \"Transport Layer Security (TLS)\n           Extensions: Extension Definitions\", RFC 6066,\n           DOI 10.17487/RFC6066, January 2011,\n           <https://www.rfc-editor.org/info/rfc6066>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6147]  Bagnulo, M., Sullivan, A., Matthews, P., and I. van\n           Beijnum, \"DNS64: DNS Extensions for Network Address\n           Translation from IPv6 Clients to IPv4 Servers\", RFC 6147,\n           DOI 10.17487/RFC6147, April 2011,\n           <https://www.rfc-editor.org/info/rfc6147>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7050]  Savolainen, T., Korhonen, J., and D. Wing, \"Discovery of\n           the IPv6 Prefix Used for IPv6 Address Synthesis\",\n           RFC 7050, DOI 10.17487/RFC7050, November 2013,\n           <https://www.rfc-editor.org/info/rfc7050>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n           Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n           DOI 10.17487/RFC7231, June 2014,\n           <https://www.rfc-editor.org/info/rfc7231>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7595]  Thaler, D., Ed., Hansen, T., and T. Hardie, \"Guidelines\n           and Registration Procedures for URI Schemes\", BCP 35,\n           RFC 7595, DOI 10.17487/RFC7595, June 2015,\n           <https://www.rfc-editor.org/info/rfc7595>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7871]  Contavalli, C., van der Gaast, W., Lawrence, D., and W.\n           Kumari, \"Client Subnet in DNS Queries\", RFC 7871,\n           DOI 10.17487/RFC7871, May 2016,\n           <https://www.rfc-editor.org/info/rfc7871>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n           Writing an IANA Considerations Section in RFCs\", BCP 26,\n           RFC 8126, DOI 10.17487/RFC8126, June 2017,\n           <https://www.rfc-editor.org/info/rfc8126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[WebSocket]\n           Fette, I. and A. Melnikov, \"The WebSocket Protocol\",\n           RFC 6455, DOI 10.17487/RFC6455, December 2011,\n           <https://www.rfc-editor.org/info/rfc6455>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AltSvc]   Nottingham, M., McManus, P., and J. Reschke, \"HTTP\n           Alternative Services\", RFC 7838, DOI 10.17487/RFC7838,\n           April 2016, <https://www.rfc-editor.org/info/rfc7838>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ANAME-DNS-RR]\n           Finch, T., Hunt, E., van Dijk, P., Eden, A., and W.\n           Mekking, \"Address-specific DNS aliases (ANAME)\", Work in\n           Progress, Internet-Draft, draft-ietf-dnsop-aname-04, 8\n           July 2019, <https://datatracker.ietf.org/doc/html/draft-\n           ietf-dnsop-aname-04>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[BIND-CHECK-NAMES]\n           Internet Systems Consortium, \"BIND v9.19.11 Configuration\n           Reference: \"check-names\"\", September 2023,\n           <https://bind9.readthedocs.io/en/v9.19.11/\n           reference.html#namedconf-statement-check-names>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DNAME]    Rose, S. and W. Wijngaards, \"DNAME Redirection in the\n           DNS\", RFC 6672, DOI 10.17487/RFC6672, June 2012,\n           <https://www.rfc-editor.org/info/rfc6672>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[DNSTerm]  Hoffman, P., Sullivan, A., and K. Fujiwara, \"DNS\n           Terminology\", BCP 219, RFC 8499, DOI 10.17487/RFC8499,\n           January 2019, <https://www.rfc-editor.org/info/rfc8499>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ECH]      Rescorla, E., Oku, K., Sullivan, N., and C. A. Wood, \"TLS\n           Encrypted Client Hello\", Work in Progress, Internet-Draft,\n           draft-ietf-tls-esni-17, 9 October 2023,\n           <https://datatracker.ietf.org/doc/html/draft-ietf-tls-\n           esni-17>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FETCH]    WHATWG, \"Fetch Living Standard\", October 2023,\n           <https://fetch.spec.whatwg.org/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FETCH-WEBSOCKETS]\n           WHATWG, \"WebSockets Living Standard\", September 2023,\n           <https://websockets.spec.whatwg.org/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HSTS]     Hodges, J., Jackson, C., and A. Barth, \"HTTP Strict\n           Transport Security (HSTS)\", RFC 6797,\n           DOI 10.17487/RFC6797, November 2012,\n           <https://www.rfc-editor.org/info/rfc6797>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP-DNS-RR]\n           Bellis, R., \"A DNS Resource Record for HTTP\", Work in\n           Progress, Internet-Draft, draft-bellis-dnsop-http-record-\n           00, 3 November 2018,\n           <https://datatracker.ietf.org/doc/html/draft-bellis-dnsop-\n           http-record-00>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/3]   Bishop, M., Ed., \"HTTP/3\", RFC 9114, DOI 10.17487/RFC9114,\n           June 2022, <https://www.rfc-editor.org/info/rfc9114>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1912]  Barr, D., \"Common DNS Operational and Configuration\n           Errors\", RFC 1912, DOI 10.17487/RFC1912, February 1996,\n           <https://www.rfc-editor.org/info/rfc1912>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6454]  Barth, A., \"The Web Origin Concept\", RFC 6454,\n           DOI 10.17487/RFC6454, December 2011,\n           <https://www.rfc-editor.org/info/rfc6454>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SRV]      Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for\n           specifying the location of services (DNS SRV)\", RFC 2782,\n           DOI 10.17487/RFC2782, February 2000,\n           <https://www.rfc-editor.org/info/rfc2782>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[URI]      Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n           Resource Identifier (URI): Generic Syntax\", STD 66,\n           RFC 3986, DOI 10.17487/RFC3986, January 2005,\n           <https://www.rfc-editor.org/info/rfc3986>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Decoding Text in Zone Files",
      "section_title": true,
      "ja": "付録A. ゾーンファイルのテキストのデコード"
    },
    {
      "indent": 3,
      "text": "DNS zone files are capable of representing arbitrary octet sequences in basic ASCII text, using various delimiters and encodings, according to an algorithm defined in Section 5.1 of [RFC1035]. The following summarizes some allowed inputs to that algorithm, using ABNF:",
      "ja": "DNSゾーンファイルは、[RFC1035]のセクション5.1で定義されているアルゴリズムに従って、さまざまな区切り文字とエンコーディングを使用して、基本的なASCIIテキストの任意のオクテットシーケンスを表すことができます。以下は、ABNFを使用して、そのアルゴリズムへの許可された入力を要約しています。"
    },
    {
      "indent": 3,
      "text": "; non-special is VCHAR minus DQUOTE, \";\", \"(\", \")\", and \"\\\".\nnon-special = %x21 / %x23-27 / %x2A-3A / %x3C-5B / %x5D-7E\n; non-digit is VCHAR minus DIGIT.\nnon-digit   = %x21-2F / %x3A-7E\n; dec-octet is a number 0-255 as a three-digit decimal number.\ndec-octet   = ( \"0\" / \"1\" ) 2DIGIT /\n              \"2\" ( ( %x30-34 DIGIT ) / ( \"5\" %x30-35 ) )\nescaped     = \"\\\" ( non-digit / dec-octet )\ncontiguous  = 1*( non-special / escaped )\nquoted      = DQUOTE *( contiguous / ( [\"\\\"] WSP ) ) DQUOTE\nchar-string = contiguous / quoted",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The decoding algorithm allows char-string to represent any *OCTET, using quoting to group values (e.g., those with internal whitespace), and escaping to represent each non-printable octet as a single escaped sequence. In this document, this algorithm is referred to as \"character-string decoding\", because Section 5.1 of [RFC1035] uses this algorithm to produce a <character-string>. Note that while the length of a <character-string> is limited to 255 octets, the character-string decoding algorithm can produce output of any length.",
      "ja": "デコードアルゴリズムにより、char-stringは任意の *OCTETを表すことができ、引用符はグループ値（例えば、内部の空白のあるもの）に引用を使用し、それぞれの印刷不可能なオクテットを単一のエスケープシーケンスとして表すためにエスケープします。このドキュメントでは、[RFC1035]のセクション5.1がこのアルゴリズムを使用して<character-string>を生成するため、このアルゴリズムは「character-stringデコード」と呼ばれます。<character-string>の長さは255オクテットに制限されていますが、character-stringデコードアルゴリズムは任意の長さの出力を生成できることに注意してください。"
    },
    {
      "indent": 0,
      "text": "A.1. Decoding a Comma-Separated List",
      "section_title": true,
      "ja": "A.1. コンマ分離リストのデコード"
    },
    {
      "indent": 3,
      "text": "In order to represent lists of items in zone files, this specification uses comma-separated lists. When the allowed items in the list cannot contain \",\" or \"\\\", this is trivial. (For simplicity, empty items are not allowed.) A value-list parser that splits on \",\" and prohibits items containing \"\\\" is sufficient to comply with all requirements in this document. This corresponds to the simple-comma-separated syntax:",
      "ja": "ゾーンファイル内のアイテムのリストを表すために、この仕様ではコンマ区切りリストを使用します。リスト内の許可されたアイテムが「、」または「\\」を含めることができない場合、これは些細なことです。（簡単にするために、空のアイテムは許可されていません。）「\\」を含むアイテムを含む項目を禁止するバリューリストパーサーは、このドキュメントのすべての要件を遵守するのに十分です。これは、単純なコマを分離した構文に対応します。"
    },
    {
      "indent": 3,
      "text": "; item-allowed is OCTET minus \",\" and \"\\\".\nitem-allowed           = %x00-2B / %x2D-5B / %x5D-FF\nsimple-item            = 1*item-allowed\nsimple-comma-separated = [simple-item *(\",\" simple-item)]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For implementations that allow \",\" and \"\\\" in item values, the following escaping syntax applies:",
      "ja": "アイテム値に「」、「\\」を許可する実装の場合、次の逃げる構文が適用されます。"
    },
    {
      "indent": 3,
      "text": "item            = 1*OCTET\nescaped-item    = 1*(item-allowed / \"\\,\" / \"\\\\\")\ncomma-separated = [escaped-item *(\",\" escaped-item)]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding of value-lists happens after character-string decoding. For example, consider these char-string SvcParamValues:",
      "ja": "バリューリストのデコードは、文字通りのデコード後に発生します。たとえば、これらのチャーストリングsvcparamvaluesを考慮してください。"
    },
    {
      "indent": 3,
      "text": "\"part1,part2,part3\\\\,part4\\\\\\\\\"\npart1\\,\\p\\a\\r\\t2\\044part3\\092,part4\\092\\\\",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These inputs are equivalent: character-string decoding either of them would produce the same value:",
      "ja": "これらの入力は同等です。文字弦デコードのいずれかが同じ値を生成すると、次の値が生成されます。"
    },
    {
      "indent": 3,
      "text": "part1,part2,part3\\,part4\\\\",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Applying comma-separated list decoding to this value would produce a list of three items:",
      "ja": "この値にコンマ区切りリストのデコードを適用すると、3つの項目のリストが作成されます。"
    },
    {
      "indent": 3,
      "text": "part1\npart2\npart3,part4\\",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. HTTP Mapping Summary",
      "section_title": true,
      "ja": "付録B. HTTPマッピングの概要"
    },
    {
      "indent": 3,
      "text": "This table serves as a non-normative summary of the HTTP mapping for SVCB (Section 9). Future protocol mappings may provide a similar summary table.",
      "ja": "この表は、SVCBのHTTPマッピングの非規範的な要約として機能します（セクション9）。将来のプロトコルマッピングは、同様の要約表を提供する場合があります。"
    },
    {
      "indent": 9,
      "text": "         +--------------------------+----------------------+\n         | *Mapped scheme*          | \"https\"              |\n         +--------------------------+----------------------+\n         | *Other affected schemes* | \"http\", \"wss\", \"ws\", |\n         |                          | (other HTTP-based)   |\n         +--------------------------+----------------------+\n         | *RR type*                | HTTPS (65)           |\n         +--------------------------+----------------------+\n         | *Name prefix*            | None for port 443,   |\n         |                          | else _$PORT._https   |\n         +--------------------------+----------------------+\n         | *Automatically mandatory | port, no-default-    |\n         | keys*                    | alpn                 |\n         +--------------------------+----------------------+\n         | *SvcParam defaults*      | alpn: [\"http/1.1\"]   |\n         +--------------------------+----------------------+\n         | *Special behaviors*      | Upgrade from HTTP to |\n         |                          | HTTPS                |\n         +--------------------------+----------------------+\n         | *Keys that records must  | None                 |\n         | include*                 |                      |\n         +--------------------------+----------------------+\n\n                               Table 3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. Comparison with Alternatives",
      "section_title": true,
      "ja": "付録C. 代替との比較"
    },
    {
      "indent": 3,
      "text": "The SVCB and HTTPS RR types closely resemble, and are inspired by, some existing record types and proposals. One complaint regarding all of the alternatives is that web clients have seemed unenthusiastic about implementing them. The hope here is that an extensible solution that solves multiple problems will overcome this inertia and have a path to achieve client implementation.",
      "ja": "SVCBおよびHTTPS RRタイプは、いくつかの既存のレコードタイプと提案に非常に似ており、触発されています。すべての代替案に関する1つの不満は、Webクライアントがそれらを実装することに熱心に存在していないように見えることです。ここでの希望は、複数の問題を解決する拡張可能なソリューションがこの慣性を克服し、クライアントの実装を達成するための道を持つことです。"
    },
    {
      "indent": 0,
      "text": "C.1. Differences from the SRV RR Type",
      "section_title": true,
      "ja": "C.1. SRV RRタイプとの違い"
    },
    {
      "indent": 3,
      "text": "An SRV record [SRV] can perform a function similar to that of the SVCB record, informing a client to look in a different location for a service. However, there are several differences:",
      "ja": "SRVレコード[SRV]は、SVCBレコードの機能と同様の関数を実行でき、クライアントにサービスの別の場所を調べるように通知できます。ただし、いくつかの違いがあります。"
    },
    {
      "indent": 6,
      "text": "* SRV records are typically mandatory, whereas SVCB is intended to be optional when used with pre-existing protocols.",
      "ja": "* SRVレコードは通常必須ですが、SVCBは既存のプロトコルで使用する場合にオプションになることを目的としています。"
    },
    {
      "indent": 6,
      "text": "* SRV records cannot instruct the client to switch or upgrade protocols, whereas SVCB can signal such an upgrade (e.g., to HTTP/2).",
      "ja": "* SRVレコードは、クライアントにプロトコルを切り替えたりアップグレードしたりするように指示することはできませんが、SVCBはそのようなアップグレード（例：HTTP/2）を信号することができます。"
    },
    {
      "indent": 6,
      "text": "* SRV records are not extensible, whereas SVCB and HTTPS RRs can be extended with new parameters.",
      "ja": "* SRVレコードは拡張できませんが、SVCBおよびHTTPS RRSは新しいパラメーターで拡張できます。"
    },
    {
      "indent": 6,
      "text": "* SRV records specify a \"weight\" for unbalanced randomized load balancing. SVCB only supports balanced randomized load balancing, although weights could be added via a future SvcParam.",
      "ja": "* SRVレコードは、不均衡なランダム化負荷分散の「重み」を指定します。SVCBは、バランスの取れたランダム化負荷分散のみをサポートしますが、将来のSVCparamを介して重みを追加できます。"
    },
    {
      "indent": 0,
      "text": "C.2. Differences from the Proposed HTTP Record",
      "section_title": true,
      "ja": "C.2. 提案されているHTTPレコードとの違い"
    },
    {
      "indent": 3,
      "text": "Unlike [HTTP-DNS-RR], this approach is extensible to cover Alt-Svc and Encrypted ClientHello use cases. Like that proposal, this addresses the zone-apex CNAME challenge.",
      "ja": "[http-dns-rr]とは異なり、このアプローチは、Alt-SVCおよび暗号化されたClientHelloユースケースをカバーするために拡張可能です。その提案のように、これはゾーン頂点CNAMEの課題に対処します。"
    },
    {
      "indent": 3,
      "text": "Like that proposal, it remains necessary to continue to include address records at the zone apex for legacy clients.",
      "ja": "その提案のように、レガシークライアントのゾーンアペックスに住所記録を引き続き含める必要があります。"
    },
    {
      "indent": 0,
      "text": "C.3. Differences from the Proposed ANAME Record",
      "section_title": true,
      "ja": "C.3. 提案されているアナムレコードとの違い"
    },
    {
      "indent": 3,
      "text": "Unlike [ANAME-DNS-RR], this approach is extensible to cover Alt-Svc and Encrypted ClientHello use cases. This approach also does not require any changes or special handling on either authoritative or primary servers, beyond optionally returning in-bailiwick additional records.",
      "ja": "[ANAME-DNS-RR]とは異なり、このアプローチはAlt-SVCおよび暗号化されたClientHelloユースケースをカバーするために拡張可能です。また、このアプローチでは、オプションでバイリウィックの追加レコードを返すことを超えて、権威あるサーバーまたはプライマリサーバーの変更や特別な取り扱いは必要ありません。"
    },
    {
      "indent": 3,
      "text": "Like that proposal, this addresses the zone-apex CNAME challenge for clients that implement this.",
      "ja": "その提案のように、これはこれを実装するクライアントのゾーン頂点CNAMEの課題に対処します。"
    },
    {
      "indent": 3,
      "text": "However, with this SVCB proposal, it remains necessary to continue to include address records at the zone apex for legacy clients. If deployment of this standard is successful, the number of legacy clients will fall over time. As the number of legacy clients declines, the operational effort required to serve these users without the benefit of SVCB indirection should fall. Server operators can easily observe how much traffic reaches this legacy endpoint and may remove the apex's address records if the observed legacy traffic has fallen to negligible levels.",
      "ja": "ただし、このSVCBの提案により、レガシークライアントのゾーンアペックスに住所記録を引き続き含める必要があります。この標準の展開が成功した場合、レガシークライアントの数は時間とともに減少します。レガシークライアントの数が減少するにつれて、SVCBの間接の恩恵を受けることなくこれらのユーザーにサービスを提供するために必要な運用努力が低下するはずです。サーバーオペレーターは、このレガシーエンドポイントに到達するトラフィックの量を簡単に観察でき、観察されたレガシートラフィックが無視できるレベルに低下した場合、Apexのアドレスレコードを削除する場合があります。"
    },
    {
      "indent": 0,
      "text": "C.4. Comparison with Separate RR Types for AliasMode and ServiceMode",
      "section_title": true,
      "ja": "C.4. AliAsmodeおよびServiceModeの個別のRRタイプとの比較"
    },
    {
      "indent": 3,
      "text": "Abstractly, functions of AliasMode and ServiceMode are independent, so it might be tempting to specify them as separate RR types. However, this would result in serious performance impairment, because clients cannot rely on their recursive resolver to follow SVCB aliases (unlike CNAME). Thus, clients would have to issue queries for both RR types in parallel, potentially at each step of the alias chain. Recursive resolvers that implement the specification would, upon receipt of a ServiceMode query, emit both a ServiceMode query and an AliasMode query to the authoritative DNS server. Thus, splitting the RR type would double, or in some cases triple, the load on clients and servers, and would not reduce implementation complexity.",
      "ja": "抽象的には、AliasModeとServiceModeの関数は独立しているため、個別のRRタイプとして指定するのが魅力的かもしれません。ただし、クライアントはSVCBエイリアスを追跡するために再帰的なリゾルバーに依存することはできないため、これは深刻なパフォーマンス障害につながります（CNAMEとは異なります）。したがって、クライアントは両方のRRタイプのクエリを並列で、潜在的にエイリアスチェーンの各ステップで発行する必要があります。仕様を実装する再帰リゾルバーは、ServiceModeクエリを受信すると、ServiceModeクエリとAliasModeクエリの両方を権威あるDNSサーバーに送信します。したがって、RRタイプの分割は、クライアントとサーバーの負荷を2倍にするか、場合によっては3倍になり、実装の複雑さを軽減しません。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Test Vectors",
      "section_title": true,
      "ja": "付録D. テストベクトル"
    },
    {
      "indent": 3,
      "text": "These test vectors only contain the RDATA portion of SVCB/HTTPS records in presentation format, generic format [RFC3597], and wire format. The wire format uses hexadecimal (\\xNN) for each non-ASCII byte. As the wire format is long, it is broken into several lines.",
      "ja": "これらのテストベクトルには、SVCB/HTTPSレコードのRDATA部分のみがプレゼンテーション形式、汎用形式[RFC3597]、およびワイヤ形式のみが含まれています。ワイヤ形式は、各非ASCIIバイトに対して16進数（\\ xnn）を使用します。ワイヤ形式が長いため、いくつかの行に分かれています。"
    },
    {
      "indent": 0,
      "text": "D.1. AliasMode",
      "section_title": true,
      "ja": "D.1. aliAsmode"
    },
    {
      "indent": 3,
      "text": "example.com.   HTTPS   0 foo.example.com.\n\n\\# 19 (\n00 00                                              ; priority\n03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target\n)\n\n\\x00\\x00                                           # priority\n\\x03foo\\x07example\\x03com\\x00                      # target",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Figure 2: AliasMode",
      "ja": "図2：aliAsmode"
    },
    {
      "indent": 0,
      "text": "D.2. ServiceMode",
      "section_title": true,
      "ja": "D.2. ServiceMode"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 .\n\n\\# 3 (\n00 01      ; priority\n00         ; target (root label)\n)\n\n\\x00\\x01   # priority\n\\x00       # target (root label)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Figure 3: TargetName Is \".\"",
      "ja": "図3：TargetNameは「」です。"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   16 foo.example.com. port=53\n\n\\# 25 (\n00 10                                              ; priority\n03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target\n00 03                                              ; key 3\n00 02                                              ; length 2\n00 35                                              ; value\n)\n\n\\x00\\x10                                           # priority\n\\x03foo\\x07example\\x03com\\x00                      # target\n\\x00\\x03                                           # key 3\n\\x00\\x02                                           # length 2\n\\x00\\x35                                           # value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 4: Specifies a Port",
      "ja": "図4：ポートを指定します"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. key667=hello\n\n\\# 28 (\n00 01                                              ; priority\n03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target\n02 9b                                              ; key 667\n00 05                                              ; length 5\n68 65 6c 6c 6f                                     ; value\n)\n\n\\x00\\x01                                           # priority\n\\x03foo\\x07example\\x03com\\x00                      # target\n\\x02\\x9b                                           # key 667\n\\x00\\x05                                           # length 5\nhello                                              # value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 5: A Generic Key and Unquoted Value",
      "ja": "図5：一般的なキーと引用のない値"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. key667=\"hello\\210qoo\"\n\n\\# 32 (\n00 01                                              ; priority\n03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target\n02 9b                                              ; key 667\n00 09                                              ; length 9\n68 65 6c 6c 6f d2 71 6f 6f                         ; value\n)\n\n\\x00\\x01                                           # priority\n\\x03foo\\x07example\\x03com\\x00                      # target\n\\x02\\x9b                                           # key 667\n\\x00\\x09                                           # length 9\nhello\\xd2qoo                                       # value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 6: A Generic Key and Quoted Value with a Decimal Escape",
      "ja": "図6：小数点以下のエスケープを伴う一般的なキーと引用値"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. (\n                      ipv6hint=\"2001:db8::1,2001:db8::53:1\"\n                      )\n\n\\# 55 (\n00 01                                              ; priority\n03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00 ; target\n00 06                                              ; key 6\n00 20                                              ; length 32\n20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01    ; first address\n20 01 0d b8 00 00 00 00 00 00 00 00 00 53 00 01    ; second address\n)\n\n\\x00\\x01                                           # priority\n\\x03foo\\x07example\\x03com\\x00                      # target\n\\x00\\x06                                           # key 6\n\\x00\\x20                                           # length 32\n\\x20\\x01\\x0d\\xb8\\x00\\x00\\x00\\x00\n     \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01              # first address\n\\x20\\x01\\x0d\\xb8\\x00\\x00\\x00\\x00\n     \\x00\\x00\\x00\\x00\\x00\\x53\\x00\\x01              # second address",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 7: Two Quoted IPv6 Hints",
      "ja": "図7：引用された2つのIPv6ヒント"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 example.com. (\n                        ipv6hint=\"2001:db8:122:344::192.0.2.33\"\n                        )\n\\# 35 (\n00 01                                              ; priority\n07 65 78 61 6d 70 6c 65 03 63 6f 6d 00             ; target\n00 06                                              ; key 6\n00 10                                              ; length 16\n20 01 0d b8 01 22 03 44 00 00 00 00 c0 00 02 21    ; address\n)\n\n\\x00\\x01                                           # priority\n\\x07example\\x03com\\x00                             # target\n\\x00\\x06                                           # key 6\n\\x00\\x10                                           # length 16\n\\x20\\x01\\x0d\\xb8\\x01\\x22\\x03\\x44\n     \\x00\\x00\\x00\\x00\\xc0\\x00\\x02\\x21              # address",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 8: An IPv6 Hint Using the Embedded IPv4 Syntax",
      "ja": "図8：埋め込まれたIPv4構文を使用したIPv6ヒント"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   16 foo.example.org. (\n                      alpn=h2,h3-19 mandatory=ipv4hint,alpn\n                      ipv4hint=192.0.2.1\n                      )\n\n\\# 48 (\n00 10                                              ; priority\n03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 6f 72 67 00 ; target\n00 00                                              ; key 0\n00 04                                              ; param length 4\n00 01                                              ; value: key 1\n00 04                                              ; value: key 4\n00 01                                              ; key 1\n00 09                                              ; param length 9\n02                                                 ; alpn length 2\n68 32                                              ; alpn value\n05                                                 ; alpn length 5\n68 33 2d 31 39                                     ; alpn value\n00 04                                              ; key 4\n00 04                                              ; param length 4\nc0 00 02 01                                        ; param value\n)\n\n\\x00\\x10                                           # priority\n\\x03foo\\x07example\\x03org\\x00                      # target\n\\x00\\x00                                           # key 0\n\\x00\\x04                                           # param length 4\n\\x00\\x01                                           # value: key 1\n\\x00\\x04                                           # value: key 4\n\\x00\\x01                                           # key 1\n\\x00\\x09                                           # param length 9\n\\x02                                               # alpn length 2\nh2                                                 # alpn value\n\\x05                                               # alpn length 5\nh3-19                                              # alpn value\n\\x00\\x04                                           # key 4\n\\x00\\x04                                           # param length 4\n\\xc0\\x00\\x02\\x01                                   # param value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 9: SvcParamKey Ordering Is Arbitrary in Presentation Format but Sorted in Wire Format",
      "ja": "図9：SVCParamkeyの注文はプレゼンテーション形式で任意ですが、ワイヤー形式でソートされています"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   16 foo.example.org. alpn=\"f\\\\\\\\oo\\\\,bar,h2\"\nexample.com.   SVCB   16 foo.example.org. alpn=f\\\\\\092oo\\092,bar,h2\n\n\\# 35 (\n00 10                                              ; priority\n03 66 6f 6f 07 65 78 61 6d 70 6c 65 03 6f 72 67 00 ; target\n00 01                                              ; key 1\n00 0c                                              ; param length 12\n08                                                 ; alpn length 8\n66 5c 6f 6f 2c 62 61 72                            ; alpn value\n02                                                 ; alpn length 2\n68 32                                              ; alpn value\n)\n\n\\x00\\x10                                           # priority\n\\x03foo\\x07example\\x03org\\x00                      # target\n\\x00\\x01                                           # key 1\n\\x00\\x0c                                           # param length 12\n\\x08                                               # alpn length 8\nf\\oo,bar                                           # alpn value\n\\x02                                               # alpn length 2\nh2                                                 # alpn value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 10: An \"alpn\" Value with an Escaped Comma and an Escaped Backslash in Two Presentation Formats",
      "ja": "図10：逃げたコンマと2つのプレゼンテーション形式で逃げたバックスラッシュを備えた「ALPN」値"
    },
    {
      "indent": 0,
      "text": "D.3. Failure Cases",
      "section_title": true,
      "ja": "D.3. 障害ケース"
    },
    {
      "indent": 3,
      "text": "This subsection contains test vectors that are not compliant with this document. The various reasons for non-compliance are explained with each example.",
      "ja": "このサブセクションには、このドキュメントに準拠していないテストベクトルが含まれています。コンプライアンス違反のさまざまな理由が、各例で説明されています。"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. (\n                       key123=abc key123=def\n                       )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 11: Multiple Instances of the Same SvcParamKey",
      "ja": "図11：同じsvcparamkeyの複数のインスタンス"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. mandatory\nexample.com.   SVCB   1 foo.example.com. alpn\nexample.com.   SVCB   1 foo.example.com. port\nexample.com.   SVCB   1 foo.example.com. ipv4hint\nexample.com.   SVCB   1 foo.example.com. ipv6hint",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 12: Missing SvcParamValues That Must Be Non-Empty",
      "ja": "図12：空でなければならないsvcparamvaluesの欠落"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. no-default-alpn=abc",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 13: The \"no-default-alpn\" SvcParamKey Value Must Be Empty",
      "ja": "図13：「no-default-alpn」svcparamkey値は空でなければなりません"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. mandatory=key123",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 14: A Mandatory SvcParam Is Missing",
      "ja": "図14：必須のsvcparamがありません"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. mandatory=mandatory",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 15: The \"mandatory\" SvcParamKey Must Not Be Included in the Mandatory List",
      "ja": "図15：「必須」SVCParamkeyを必須リストに含めてはなりません"
    },
    {
      "indent": 3,
      "text": "example.com.   SVCB   1 foo.example.com. (\n                      mandatory=key123,key123 key123=abc\n                      )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 16: Multiple Instances of the Same SvcParamKey in the Mandatory List",
      "ja": "図16：必須リストにある同じsvcparamkeyの複数のインスタンス"
    },
    {
      "indent": 0,
      "text": "Acknowledgments and Related Proposals",
      "section_title": true,
      "ja": "謝辞と関連提案"
    },
    {
      "indent": 3,
      "text": "Over the years, IETF participants have proposed a wide range of solutions to the \"CNAME at the zone apex\" challenge, including [HTTP-DNS-RR], [ANAME-DNS-RR], and others. The authors are grateful for their work to elucidate the problem and identify promising strategies to address it, some of which are reflected in this document.",
      "ja": "長年にわたり、IETFの参加者は、[http-dns-rr]、[aname-dns-rr]などを含む「ゾーンアペックスのCNAME」チャレンジに対する幅広いソリューションを提案してきました。著者は、問題を解明し、それに対処するための有望な戦略を特定する仕事に感謝しています。そのいくつかはこの文書に反映されています。"
    },
    {
      "indent": 3,
      "text": "Thank you to Ian Swett, Ralf Weber, Jon Reed, Martin Thomson, Lucas Pardue, Ilari Liusvaara, Tim Wicinski, Tommy Pauly, Chris Wood, David Benjamin, Mark Andrews, Emily Stark, Eric Orth, Kyle Rose, Craig Taylor, Dan McArdle, Brian Dickson, Willem Toorop, Pieter Lexis, Puneet Sood, Olivier Poitrey, Mashooq Muhaimen, Tom Carpay, and many others for their feedback and suggestions on this document.",
      "ja": "Ian Swett、Ralf Weber、Jon Reed、Martin Thomson、Lucas Pardue、Ilari Liusvaara、Tim Wicinski、Tommy Pauly、Chris Wood、David Benjamin、Mark Andrews、Emily Stark、Eric Orth、Kyle Rose、Craig Taylor、Dan McArdle、ブライアン・ディクソン、ウィレム・トゥーロップ、ピーター・レキス、プニート・スッド、オリビエ・ポイトリー、マッシュー・ムハイメン、トム・カーペイなど、この文書に関するフィードバックと提案について。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ben Schwartz\nMeta Platforms, Inc.\nEmail: ietf@bemasc.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mike Bishop\nAkamai Technologies\nEmail: mbishop@evequefou.be",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Erik Nygren\nAkamai Technologies\nEmail: erik+ietf@nygren.org",
      "raw": true,
      "ja": ""
    }
  ]
}