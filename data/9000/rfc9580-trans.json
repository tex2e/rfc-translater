{
  "title": {
    "text": "RFC 9580 - OpenPGP",
    "ja": "RFC 9580 - OpenPGP"
  },
  "number": 9580,
  "created_at": "2024-08-01 23:24:19.510145+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   P. Wouters, Ed.\nRequest for Comments: 9580                                         Aiven\nObsoletes: 4880, 5581, 6637                                   D. Huigens\nCategory: Standards Track                                      Proton AG\nISSN: 2070-1721                                                J. Winter\n                                                             Sequoia PGP\n                                                                Y. Niibe\n                                                                    FSIJ\n                                                               July 2024",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "OpenPGP",
      "section_title": true,
      "ja": "OpenPGP"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies the message formats used in OpenPGP. OpenPGP provides encryption with public key or symmetric cryptographic algorithms, digital signatures, compression, and key management.",
      "ja": "このドキュメントは、OpenPGPで使用されるメッセージ形式を指定します。OpenPGPは、公開キーまたは対称的な暗号化アルゴリズム、デジタル署名、圧縮、およびキー管理を備えた暗号化を提供します。"
    },
    {
      "indent": 3,
      "text": "This document is maintained in order to publish all necessary information needed to develop interoperable applications based on the OpenPGP format. It is not a step-by-step cookbook for writing an application. It describes only the format and methods needed to read, check, generate, and write conforming packets crossing any network. It does not deal with storage and implementation questions. It does, however, discuss implementation issues necessary to avoid security flaws.",
      "ja": "このドキュメントは、OpenPGP形式に基づいて相互運用可能なアプリケーションを開発するために必要なすべての情報を公開するために維持されます。アプリケーションを作成するための段階的な料理本ではありません。これは、ネットワークを横断する適合パケットの読み取り、チェック、生成、および書き込みに必要な形式とメソッドのみを説明しています。ストレージや実装の質問には対処しません。ただし、セキュリティの欠陥を避けるために必要な実装の問題については議論しています。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFCs 4880 (\"OpenPGP Message Format\"), 5581 (\"The Camellia Cipher in OpenPGP\"), and 6637 (\"Elliptic Curve Cryptography (ECC) in OpenPGP\").",
      "ja": "このドキュメントは、RFCS 4880（ \"OpenPGPメッセージ形式\"）、5581（ \"Camelia cipher in openPGP\"）、および6637（ \"OpenPGPの楕円曲線暗号（ECC）\"））を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9580.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9580で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2024 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2024 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFの貢献からの資料が含まれている場合があります。IETF標準プロセスの外。そのような資料の著作権を制御する人から適切なライセンスを取得しないと、このドキュメントはIETF標準プロセスの外側に変更されない場合があり、その派生作業は、ITF標準プロセスの外側で作成されない場合があります。RFCとしての出版または英語以外の言語に翻訳する。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Terms\n2.  General Functions\n  2.1.  Confidentiality via Encryption\n  2.2.  Authentication via Digital Signature\n  2.3.  Compression\n  2.4.  Conversion to Base64\n  2.5.  Signature-Only Applications\n3.  Data Element Formats\n  3.1.  Scalar Numbers\n  3.2.  Multiprecision Integers\n    3.2.1.  Using MPIs to Encode Other Data\n  3.3.  Key IDs and Fingerprints\n  3.4.  Text\n  3.5.  Time Fields\n  3.6.  Keyrings\n  3.7.  String-to-Key (S2K) Specifier\n    3.7.1.  S2K Specifier Types\n      3.7.1.1.  Simple S2K\n      3.7.1.2.  Salted S2K\n      3.7.1.3.  Iterated and Salted S2K\n      3.7.1.4.  Argon2\n    3.7.2.  S2K Usage\n      3.7.2.1.  Secret Key Encryption\n      3.7.2.2.  Symmetric Key Message Encryption\n4.  Packet Syntax\n  4.1.  Overview\n  4.2.  Packet Headers\n    4.2.1.  OpenPGP Format Packet Lengths\n      4.2.1.1.  1-Octet Lengths\n      4.2.1.2.  2-Octet Lengths\n      4.2.1.3.  5-Octet Lengths\n      4.2.1.4.  Partial Body Lengths\n    4.2.2.  Legacy Format Packet Lengths\n    4.2.3.  Packet Length Examples\n  4.3.  Packet Criticality\n5.  Packet Types\n  5.1.  Public Key Encrypted Session Key Packet (Type ID 1)\n    5.1.1.  Version 3 Public Key Encrypted Session Key Packet\n            Format\n    5.1.2.  Version 6 Public Key Encrypted Session Key Packet\n            Format\n    5.1.3.  Algorithm-Specific Fields for RSA Encryption\n    5.1.4.  Algorithm-Specific Fields for Elgamal Encryption\n    5.1.5.  Algorithm-Specific Fields for ECDH Encryption\n    5.1.6.  Algorithm-Specific Fields for X25519 Encryption\n    5.1.7.  Algorithm-Specific Fields for X448 Encryption\n    5.1.8.  Notes on PKESK\n  5.2.  Signature Packet (Type ID 2)\n    5.2.1.  Signature Types\n      5.2.1.1.  Binary Signature (Type ID 0x00) of a Document\n      5.2.1.2.  Text Signature (Type ID 0x01) of a Canonical\n              Document\n      5.2.1.3.  Standalone Signature (Type ID 0x02)\n      5.2.1.4.  Generic Certification Signature (Type ID 0x10) of a\n              User ID and Public Key Packet\n      5.2.1.5.  Persona Certification Signature (Type ID 0x11) of a\n              User ID and Public Key Packet\n      5.2.1.6.  Casual Certification Signature (Type ID 0x12) of a\n              User ID and Public Key Packet\n      5.2.1.7.  Positive Certification Signature (Type ID 0x13) of\n              a User ID and Public Key Packet\n      5.2.1.8.  Subkey Binding Signature (Type ID 0x18)\n      5.2.1.9.  Primary Key Binding Signature (Type ID 0x19)\n      5.2.1.10. Direct Key Signature (Type ID 0x1F)\n      5.2.1.11. Key Revocation Signature (Type ID 0x20)\n      5.2.1.12. Subkey Revocation Signature (Type ID 0x28)\n      5.2.1.13. Certification Revocation Signature (Type ID 0x30)\n      5.2.1.14. Timestamp Signature (Type ID 0x40)\n      5.2.1.15. Third-Party Confirmation Signature (Type ID 0x50)\n      5.2.1.16. Reserved (Type ID 0xFF)\n    5.2.2.  Version 3 Signature Packet Format\n    5.2.3.  Versions 4 and 6 Signature Packet Formats\n      5.2.3.1.  Algorithm-Specific Fields for RSA Signatures\n      5.2.3.2.  Algorithm-Specific Fields for DSA or ECDSA\n              Signatures\n      5.2.3.3.  Algorithm-Specific Fields for EdDSALegacy\n              Signatures (Deprecated)\n      5.2.3.4.  Algorithm-Specific Fields for Ed25519 Signatures\n      5.2.3.5.  Algorithm-Specific Fields for Ed448 Signatures\n      5.2.3.6.  Notes on Signatures\n      5.2.3.7.  Signature Subpacket Specification\n      5.2.3.8.  Signature Subpacket Types\n      5.2.3.9.  Notes on Subpackets\n      5.2.3.10. Notes on Self-Signatures\n      5.2.3.11. Signature Creation Time\n      5.2.3.12. Issuer Key ID\n      5.2.3.13. Key Expiration Time\n      5.2.3.14. Preferred Symmetric Ciphers for v1 SEIPD\n      5.2.3.15. Preferred AEAD Ciphersuites\n      5.2.3.16. Preferred Hash Algorithms\n      5.2.3.17. Preferred Compression Algorithms\n      5.2.3.18. Signature Expiration Time\n      5.2.3.19. Exportable Certification\n      5.2.3.20. Revocable\n      5.2.3.21. Trust Signature\n      5.2.3.22. Regular Expression\n      5.2.3.23. Revocation Key (Deprecated)\n      5.2.3.24. Notation Data\n      5.2.3.25. Key Server Preferences\n      5.2.3.26. Preferred Key Server\n      5.2.3.27. Primary User ID\n      5.2.3.28. Policy URI\n      5.2.3.29. Key Flags\n      5.2.3.30. Signer's User ID\n      5.2.3.31. Reason for Revocation\n      5.2.3.32. Features\n      5.2.3.33. Signature Target\n      5.2.3.34. Embedded Signature\n      5.2.3.35. Issuer Fingerprint\n      5.2.3.36. Intended Recipient Fingerprint\n    5.2.4.  Computing Signatures\n      5.2.4.1.  Notes about Signature Computation\n    5.2.5.  Malformed and Unknown Signatures\n  5.3.  Symmetric Key Encrypted Session Key Packet (Type ID 3)\n    5.3.1.  Version 4 Symmetric Key Encrypted Session Key Packet\n            Format\n    5.3.2.  Version 6 Symmetric Key Encrypted Session Key Packet\n            Format\n  5.4.  One-Pass Signature Packet (Type ID 4)\n  5.5.  Key Material Packets\n    5.5.1.  Key Packet Variants\n      5.5.1.1.  Public Key Packet (Type ID 6)\n      5.5.1.2.  Public Subkey Packet (Type ID 14)\n      5.5.1.3.  Secret Key Packet (Type ID 5)\n      5.5.1.4.  Secret Subkey Packet (Type ID 7)\n    5.5.2.  Public Key Packet Formats\n      5.5.2.1.  Version 3 Public Keys\n      5.5.2.2.  Version 4 Public Keys\n      5.5.2.3.  Version 6 Public Keys\n    5.5.3.  Secret Key Packet Formats\n    5.5.4.  Key IDs and Fingerprints\n      5.5.4.1.  Version 3 Key ID and Fingerprint\n      5.5.4.2.  Version 4 Key ID and Fingerprint\n      5.5.4.3.  Version 6 Key ID and Fingerprint\n    5.5.5.  Algorithm-Specific Parts of Keys\n      5.5.5.1.  Algorithm-Specific Part for RSA Keys\n      5.5.5.2.  Algorithm-Specific Part for DSA Keys\n      5.5.5.3.  Algorithm-Specific Part for Elgamal Keys\n      5.5.5.4.  Algorithm-Specific Part for ECDSA Keys\n      5.5.5.5.  Algorithm-Specific Part for EdDSALegacy Keys\n              (Deprecated)\n      5.5.5.6.  Algorithm-Specific Part for ECDH Keys\n      5.5.5.7.  Algorithm-Specific Part for X25519 Keys\n      5.5.5.8.  Algorithm-Specific Part for X448 Keys\n      5.5.5.9.  Algorithm-Specific Part for Ed25519 Keys\n      5.5.5.10. Algorithm-Specific Part for Ed448 Keys\n  5.6.  Compressed Data Packet (Type ID 8)\n  5.7.  Symmetrically Encrypted Data Packet (Type ID 9)\n  5.8.  Marker Packet (Type ID 10)\n  5.9.  Literal Data Packet (Type ID 11)\n    5.9.1.  Special Filename _CONSOLE (Deprecated)\n  5.10. Trust Packet (Type ID 12)\n  5.11. User ID Packet (Type ID 13)\n  5.12. User Attribute Packet (Type ID 17)\n    5.12.1.  Image Attribute Subpacket\n  5.13. Symmetrically Encrypted and Integrity Protected Data Packet\n         (Type ID 18)\n    5.13.1.  Version 1 Symmetrically Encrypted and Integrity\n            Protected Data Packet Format\n    5.13.2.  Version 2 Symmetrically Encrypted and Integrity\n            Protected Data Packet Format\n    5.13.3.  EAX Mode\n    5.13.4.  OCB Mode\n    5.13.5.  GCM Mode\n  5.14. Padding Packet (Type ID 21)\n6.  Base64 Conversions\n  6.1.  Optional Checksum\n    6.1.1.  An Implementation of the CRC24 in \"C\"\n  6.2.  Forming ASCII Armor\n    6.2.1.  Armor Header Line\n    6.2.2.  Armor Headers\n      6.2.2.1.  \"Version\" Armor Header\n      6.2.2.2.  \"Comment\" Armor Header\n      6.2.2.3.  \"Hash\" Armor Header\n      6.2.2.4.  \"Charset\" Armor Header\n    6.2.3.  Armor Tail Line\n7.  Cleartext Signature Framework\n  7.1.  Cleartext Signed Message Structure\n  7.2.  Dash-Escaped Text\n  7.3.  Issues with the Cleartext Signature Framework\n8.  Regular Expressions\n9.  Constants\n  9.1.  Public Key Algorithms\n  9.2.  ECC Curves for OpenPGP\n    9.2.1.  Curve-Specific Wire Formats\n  9.3.  Symmetric Key Algorithms\n  9.4.  Compression Algorithms\n  9.5.  Hash Algorithms\n  9.6.  AEAD Algorithms\n10. Packet Sequence Composition\n  10.1.  Transferable Public Keys\n    10.1.1.  OpenPGP Version 6 Certificate Structure\n    10.1.2.  OpenPGP Version 6 Revocation Certificate\n    10.1.3.  OpenPGP Version 4 Certificate Structure\n    10.1.4.  OpenPGP Version 3 Key Structure\n    10.1.5.  Common Requirements\n  10.2.  Transferable Secret Keys\n  10.3.  OpenPGP Messages\n    10.3.1.  Unwrapping Encrypted and Compressed Messages\n    10.3.2.  Additional Constraints on Packet Sequences\n      10.3.2.1.  Packet Versions in Encrypted Messages\n      10.3.2.2.  Packet Versions in Signatures\n  10.4.  Detached Signatures\n11. Elliptic Curve Cryptography\n  11.1.  ECC Curves\n  11.2.  EC Point Wire Formats\n    11.2.1.  SEC1 EC Point Wire Format\n    11.2.2.  Prefixed Native EC Point Wire Format\n    11.2.3.  Notes on EC Point Wire Formats\n  11.3.  EC Scalar Wire Formats\n    11.3.1.  EC Octet String Wire Format\n    11.3.2.  EC Prefixed Octet String Wire Format\n  11.4.  Key Derivation Function\n  11.5.  ECDH Algorithm\n    11.5.1.  ECDH Parameters\n12. Notes on Algorithms\n  12.1.  PKCS#1 Encoding in OpenPGP\n    12.1.1.  EME-PKCS1-v1_5-ENCODE\n    12.1.2.  EME-PKCS1-v1_5-DECODE\n    12.1.3.  EMSA-PKCS1-v1_5\n  12.2.  Symmetric Algorithm Preferences\n    12.2.1.  Plaintext\n  12.3.  Other Algorithm Preferences\n    12.3.1.  Compression Preferences\n      12.3.1.1.  Uncompressed\n    12.3.2.  Hash Algorithm Preferences\n  12.4.  RSA\n  12.5.  DSA\n  12.6.  Elgamal\n  12.7.  EdDSA\n  12.8.  Reserved Algorithm IDs\n  12.9.  CFB Mode\n  12.10. Private or Experimental Parameters\n  12.11. Meta Considerations for Expansion\n13. Security Considerations\n  13.1.  SHA-1 Collision Detection\n  13.2.  Advantages of Salted Signatures\n  13.3.  Elliptic Curve Side Channels\n  13.4.  Risks of a Quick Check Oracle\n  13.5.  Avoiding Leaks from PKCS#1 Errors\n  13.6.  Fingerprint Usability\n  13.7.  Avoiding Ciphertext Malleability\n  13.8.  Secure Use of the v2 SEIPD Session-Key-Reuse Feature\n  13.9.  Escrowed Revocation Signatures\n  13.10. Random Number Generation and Seeding\n  13.11. Traffic Analysis\n  13.12. Surreptitious Forwarding\n  13.13. Hashed vs. Unhashed Subpackets\n  13.14. Malicious Compressed Data\n14. Implementation Considerations\n  14.1.  Constrained Legacy Fingerprint Storage for Version 6 Keys\n15. IANA Considerations\n  15.1.  Renamed Protocol Group\n  15.2.  Renamed and Updated Registries\n  15.3.  Removed Registry\n  15.4.  Added Registries\n  15.5.  Registration Policies\n    15.5.1.  Registries That Use RFC Required\n  15.6.  Designated Experts\n    15.6.1.  Key and Signature Versions\n    15.6.2.  Encryption Versions\n    15.6.3.  Algorithms\n      15.6.3.1.  Elliptic Curve Algorithms\n      15.6.3.2.  Symmetric Key Algorithms\n      15.6.3.3.  Hash Algorithms\n16. References\n  16.1.  Normative References\n  16.2.  Informative References\nAppendix A.  Test Vectors\n  A.1.  Sample Version 4 Ed25519Legacy Key\n  A.2.  Sample Version 4 Ed25519Legacy Signature\n  A.3.  Sample Version 6 Certificate (Transferable Public Key)\n    A.3.1.  Hashed Data Stream for Signature Verification\n  A.4.  Sample Version 6 Secret Key (Transferable Secret Key)\n  A.5.  Sample Locked Version 6 Secret Key (Transferable Secret\n         Key)\n    A.5.1.  Intermediate Data for Locked Primary Key\n    A.5.2.  Intermediate Data for Locked Subkey\n  A.6.  Sample Cleartext Signed Message\n  A.7.  Sample Inline-Signed Message\n  A.8.  Sample X25519-AEAD-OCB Encryption and Decryption\n    A.8.1.  Sample Version 6 Public Key Encrypted Session Key\n            Packet\n    A.8.2.  X25519 Encryption/Decryption of the Session Key\n    A.8.3.  Sample v2 SEIPD Packet\n    A.8.4.  Decryption of Data\n    A.8.5.  Complete X25519-AEAD-OCB Encrypted Packet Sequence\n  A.9.  Sample AEAD-EAX Encryption and Decryption\n    A.9.1.  Sample Version 6 Symmetric Key Encrypted Session Key\n            Packet\n    A.9.2.  Starting AEAD-EAX Decryption of the Session Key\n    A.9.3.  Sample v2 SEIPD Packet\n    A.9.4.  Decryption of Data\n    A.9.5.  Complete AEAD-EAX Encrypted Packet Sequence\n  A.10. Sample AEAD-OCB Encryption and Decryption\n    A.10.1.  Sample Version 6 Symmetric Key Encrypted Session Key\n            Packet\n    A.10.2.  Starting AEAD-OCB Decryption of the Session Key\n    A.10.3.  Sample v2 SEIPD Packet\n    A.10.4.  Decryption of Data\n    A.10.5.  Complete AEAD-OCB Encrypted Packet Sequence\n  A.11. Sample AEAD-GCM Encryption and Decryption\n    A.11.1.  Sample Version 6 Symmetric Key Encrypted Session Key\n            Packet\n    A.11.2.  Starting AEAD-GCM Decryption of the Session Key\n    A.11.3.  Sample v2 SEIPD Packet\n    A.11.4.  Decryption of Data\n    A.11.5.  Complete AEAD-GCM Encrypted Packet Sequence\n  A.12. Sample Messages Encrypted Using Argon2\n    A.12.1.  V4 SKESK Using Argon2 with AES-128\n    A.12.2.  V4 SKESK Using Argon2 with AES-192\n    A.12.3.  V4 SKESK Using Argon2 with AES-256\nAppendix B.  Upgrade Guidance (Adapting Implementations from RFCs\n        4880 and 6637)\n  B.1.  Terminology Changes\nAppendix C.  Errata Addressed by This Document\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document provides information on the message-exchange packet formats used by OpenPGP to provide encryption, decryption, signing, and key management functions. It is a revision of [RFC4880] (\"OpenPGP Message Format\"), which is a revision of [RFC2440], which itself replaces [RFC1991] (\"PGP Message Exchange Formats\").",
      "ja": "このドキュメントは、OpenPGPが暗号化、復号化、署名、および主要な管理機能を提供するために使用されるメッセージ交換パケット形式に関する情報を提供します。これは[RFC4880]（ \"OpenPGPメッセージ形式\"）の改訂であり、[RFC2440]の改訂であり、それ自体が[RFC1991]（「PGPメッセージ交換形式」）に取って代わります。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC4880] (OpenPGP), [RFC5581] (Camellia in OpenPGP), and [RFC6637] (Elliptic Curves in OpenPGP). At the time of writing, this document incorporates all outstanding verified errata, which are listed in Appendix C.",
      "ja": "このドキュメントは、[RFC4880]（OpenPGP）、[RFC5581]（OpenPGPのCamellia）、および[RFC6637]（OpenPGPの楕円曲線）（OpenPGPの楕円曲線）を廃止します。執筆時点で、このドキュメントには、付録Cにリストされているすべての未解決の検証済みの正誤表が組み込まれています。"
    },
    {
      "indent": 3,
      "text": "Software that has already implemented those previous specifications may want to review Appendix B for pointers to what has changed.",
      "ja": "以前の仕様を既に実装しているソフトウェアは、変更されたものへのポインターについては付録Bを確認することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "1.1. Terms",
      "section_title": true,
      "ja": "1.1. 条項"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "「必須」、「必要」、「必須」、「shall」、「shall」、「suff」、 \"not\"、 \"becommended\"、 \"becommented\"、 \"may\"、 \"optional「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The key words \"Private Use\", \"Specification Required\", and \"RFC Required\" that appear in this document when used to describe namespace allocation are to be interpreted as described in [RFC8126].",
      "ja": "名前空間の割り当てを記述するために使用される場合にこのドキュメントに表示される「プライベート使用」、「仕様が必要」、「RFCが必要」のキーワードは、[RFC8126]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Some terminology used in this document has been improved from previous versions of the OpenPGP specification. See Appendix B.1 for more details.",
      "ja": "このドキュメントで使用されたいくつかの用語は、OpenPGP仕様の以前のバージョンから改善されました。詳細については、付録B.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. General Functions",
      "section_title": true,
      "ja": "2. 一般的な機能"
    },
    {
      "indent": 3,
      "text": "OpenPGP provides data confidentiality and integrity for messages and data files by using public key and/or symmetric encryption and digital signatures. It provides formats for encoding and transferring encrypted and/or signed messages. In addition, OpenPGP provides functionality for encoding and transferring keys and certificates, though key storage and management are beyond the scope of this document.",
      "ja": "OpenPGPは、公開キーおよび/または対称的な暗号化およびデジタル署名を使用して、メッセージとデータファイルのデータの機密性と整合性を提供します。暗号化および/または署名されたメッセージをエンコードおよび転送するためのフォーマットを提供します。さらに、OpenPGPは、キーと証明書のエンコードと転送の機能を提供しますが、キーストレージと管理はこのドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "2.1. Confidentiality via Encryption",
      "section_title": true,
      "ja": "2.1. 暗号化による機密性"
    },
    {
      "indent": 3,
      "text": "OpenPGP combines symmetric key encryption and (optionally) public key encryption to provide confidentiality. When using public keys, first the object is encrypted using a symmetric key encryption algorithm. Each symmetric key is used only once, for a single object. A new \"session key\" is generated as a random number for each object (sometimes referred to as a \"session\"). Since it is used only once, the session key is bound to the message and transmitted with it. To protect the key, it is encrypted with the receiver's public key. The sequence is as follows:",
      "ja": "OpenPGPは、対称キー暗号化と（オプションで）公開キー暗号化を組み合わせて、機密性を提供します。パブリックキーを使用する場合、最初にオブジェクトは対称キー暗号化アルゴリズムを使用して暗号化されます。各対称キーは、単一のオブジェクトに対して一度だけ使用されます。新しい「セッションキー」は、各オブジェクトの乱数として生成されます（「セッション」と呼ばれることもあります）。一度だけ使用されるため、セッションキーはメッセージにバインドされ、送信されます。キーを保護するために、受信者の公開キーで暗号化されます。シーケンスは次のとおりです。"
    },
    {
      "indent": 8,
      "text": "1. The sender creates a message.",
      "ja": "1. 送信者はメッセージを作成します。"
    },
    {
      "indent": 8,
      "text": "2. The sending OpenPGP implementation generates a random session key for this message.",
      "ja": "2. OpenPGPの送信の実装は、このメッセージのランダムなセッションキーを生成します。"
    },
    {
      "indent": 8,
      "text": "3. The session key is encrypted using each recipient's public key. These \"encrypted session keys\" start the message.",
      "ja": "3. セッションキーは、各受信者の公開キーを使用して暗号化されます。これらの「暗号化されたセッションキー」はメッセージを開始します。"
    },
    {
      "indent": 8,
      "text": "4. The sending OpenPGP implementation optionally compresses the message and then encrypts it using a message key derived from the session key. The encrypted message forms the remainder of the OpenPGP Message.",
      "ja": "4. [OpenPGPの送信]実装は、オプションでメッセージを圧縮し、セッションキーから派生したメッセージキーを使用して暗号化します。暗号化されたメッセージは、OpenPGPメッセージの残りの部分を形成します。"
    },
    {
      "indent": 8,
      "text": "5. The receiving OpenPGP implementation decrypts the session key using the recipient's private key.",
      "ja": "5. 受信OpenPGP実装は、受信者の秘密鍵を使用してセッションキーを復号化します。"
    },
    {
      "indent": 8,
      "text": "6. The receiving OpenPGP implementation decrypts the message using the message key derived from the session key. If the message was compressed, it will be decompressed.",
      "ja": "6. 受信OpenPGP実装は、セッションキーから派生したメッセージキーを使用してメッセージを復号化します。メッセージが圧縮された場合、それは解凍されます。"
    },
    {
      "indent": 3,
      "text": "When using symmetric key encryption, a similar process as described above is used, but the session key is encrypted with a symmetric algorithm derived from a shared secret.",
      "ja": "対称キー暗号化を使用する場合、上記のような同様のプロセスが使用されますが、セッションキーは共有秘密から派生した対称アルゴリズムで暗号化されます。"
    },
    {
      "indent": 3,
      "text": "Both digital signature and confidentiality services may be applied to the same message. First, a signature is generated for the message and attached to the message. Then, the message plus signature is encrypted using a symmetric message key derived from the session key. Finally, the session key is encrypted using public key encryption and prefixed to the encrypted block.",
      "ja": "デジタル署名と機密保持サービスの両方が同じメッセージに適用される場合があります。まず、メッセージ用の署名が生成され、メッセージに添付されます。次に、メッセージプラス署名は、セッションキーから派生した対称メッセージキーを使用して暗号化されます。最後に、セッションキーは、公開キーの暗号化を使用して暗号化され、暗号化されたブロックに接頭されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Authentication via Digital Signature",
      "section_title": true,
      "ja": "2.2. デジタル署名による認証"
    },
    {
      "indent": 3,
      "text": "The digital signature uses a cryptographic hash function and a public key algorithm capable of signing. The sequence is as follows:",
      "ja": "デジタル署名は、暗号化ハッシュ関数と署名できる公開キーアルゴリズムを使用します。シーケンスは次のとおりです。"
    },
    {
      "indent": 8,
      "text": "1. The sender creates a message.",
      "ja": "1. 送信者はメッセージを作成します。"
    },
    {
      "indent": 8,
      "text": "2. The sending implementation generates a hash digest of the message.",
      "ja": "2. 送信実装は、メッセージのハッシュダイジェストを生成します。"
    },
    {
      "indent": 8,
      "text": "3. The sending implementation generates a signature from the hash digest using the sender's private key.",
      "ja": "3. 送信実装は、送信者の秘密鍵を使用してハッシュダイジェストから署名を生成します。"
    },
    {
      "indent": 8,
      "text": "4. The signature is attached to or transmitted alongside the message.",
      "ja": "4. 署名は、メッセージに沿って添付されるか、送信されます。"
    },
    {
      "indent": 8,
      "text": "5. The receiving implementation obtains a copy of the message and the message signature.",
      "ja": "5. 受信実装は、メッセージのコピーとメッセージ署名を取得します。"
    },
    {
      "indent": 8,
      "text": "6. The receiving implementation generates a new hash digest for the received message and verifies it using the message's signature. If the verification is successful, the message is accepted as authentic.",
      "ja": "6. 受信実装は、受信したメッセージの新しいハッシュダイジェストを生成し、メッセージの署名を使用してそれを検証します。検証が成功した場合、メッセージは本物として受け入れられます。"
    },
    {
      "indent": 0,
      "text": "2.3. Compression",
      "section_title": true,
      "ja": "2.3. 圧縮"
    },
    {
      "indent": 3,
      "text": "An OpenPGP implementation MAY support the compression of data. Many existing OpenPGP Messages are compressed. Implementers, such as those working on constrained implementations that do not want to support compression, might want to consider at least implementing decompression.",
      "ja": "OpenPGP実装は、データの圧縮をサポートする場合があります。多くの既存のOpenPGPメッセージが圧縮されています。圧縮をサポートしたくない制約された実装に取り組んでいるなどの実装者は、少なくとも減圧を実装することを検討したい場合があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Conversion to Base64",
      "section_title": true,
      "ja": "2.4. base64への変換"
    },
    {
      "indent": 3,
      "text": "OpenPGP's underlying representation for encrypted messages, signatures, keys, and certificates is a stream of arbitrary octets. Some systems only permit the use of blocks consisting of 7-bit, printable text. For transporting OpenPGP's raw binary octets through channels that are not safe to transport raw binary data, a printable encoding of these binary octets is defined. The raw 8-bit binary octet stream can be converted to a stream of printable ASCII characters using base64 encoding in a format called \"ASCII Armor\" (see Section 6).",
      "ja": "暗号化されたメッセージ、署名、キー、および証明書のOpenPGPの基礎となる表現は、任意のオクテットのストリームです。一部のシステムでは、7ビットの印刷可能なテキストで構成されるブロックの使用のみが許可されています。OpenPGPの生のバイナリオクテットを、生のバイナリデータの輸送に安全ではないチャネルを介して輸送するために、これらのバイナリオクテットの印刷可能なエンコードが定義されています。生の8ビットバイナリオクテットストリームは、「ASCIIアーマー」と呼ばれる形式でBase64エンコードを使用して、印刷可能なASCII文字のストリームに変換できます（セクション6を参照）。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD support base64 conversions.",
      "ja": "実装は、Base64変換をサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.5. Signature-Only Applications",
      "section_title": true,
      "ja": "2.5. 署名のみのアプリケーション"
    },
    {
      "indent": 3,
      "text": "OpenPGP is designed for applications that use both encryption and signatures, but there are a number of use cases that only require a signature-only implementation. Although this specification requires both encryption and signatures, it is reasonable for there to be subset implementations that are non-conformant only in that they omit encryption support.",
      "ja": "OpenPGPは、暗号化と署名の両方を使用するアプリケーション向けに設計されていますが、署名のみの実装のみを必要とする多くのユースケースがあります。この仕様には暗号化と署名の両方が必要ですが、暗号化サポートを省略するという点でのみ不適合なサブセットの実装があることが合理的です。"
    },
    {
      "indent": 0,
      "text": "3. Data Element Formats",
      "section_title": true,
      "ja": "3. データ要素形式"
    },
    {
      "indent": 3,
      "text": "This section describes the data elements used by OpenPGP.",
      "ja": "このセクションでは、OpenPGPが使用するデータ要素について説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Scalar Numbers",
      "section_title": true,
      "ja": "3.1. スカラー番号"
    },
    {
      "indent": 3,
      "text": "Scalar numbers are unsigned and always stored in big-endian format. Using n[k] to refer to the kth octet being interpreted, the value of a 2-octet scalar is ((n[0] << 8) + n[1]). The value of a 4-octet scalar is ((n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3]).",
      "ja": "スカラー番号は署名されておらず、常に大幅な形式で保存されます。n [k]を使用して解釈されるkthオクテットを参照すると、2-octetスカラーの値は（（n [0] << 8） + n [1]）です。4-OCTETスカラーの値は（（n [0] << 24） +（n [1] << 16） +（n [2] << 8） + n [3]）です。"
    },
    {
      "indent": 0,
      "text": "3.2. Multiprecision Integers",
      "section_title": true,
      "ja": "3.2. 多重化整数"
    },
    {
      "indent": 3,
      "text": "Multiprecision Integers (MPIs) are unsigned integers used to hold large integers such as the ones used in cryptographic calculations.",
      "ja": "Multiprecision Integer（MPI）は、暗号計算で使用されるような大きな整数を保持するために使用される署名されていない整数です。"
    },
    {
      "indent": 3,
      "text": "An MPI consists of two pieces: a 2-octet scalar that is the length of the MPI in bits, followed by a string of octets that contain the actual integer.",
      "ja": "MPIは、ビット中のMPIの長さである2-OCTETスカラーの2つのピースで構成され、その後に実際の整数を含む一連のオクテットが続きます。"
    },
    {
      "indent": 3,
      "text": "These octets form a big-endian number; a big-endian number can be made into an MPI by prefixing it with the appropriate length.",
      "ja": "これらのオクテットは、エンディアンの大物を形成します。エンディアンの数字は、適切な長さでプレフィックスすることにより、MPIにすることができます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "(Note that all numbers in the octet strings identified by square brackets are in hexadecimal.)",
      "ja": "（正方形の括弧で識別されたオクテット文字列のすべての数字は16進んでいることに注意してください。）"
    },
    {
      "indent": 6,
      "text": " The string of octets [00 00] forms an MPI with the value 0.",
      "ja": "オクテット[00 00]の文字列は、値0のMPIを形成します。"
    },
    {
      "indent": 6,
      "text": " The string of octets [00 01 01] forms an MPI with the value 1.",
      "ja": "オクテットの文字列[00 01 01]は、値1を持つMPIを形成します。"
    },
    {
      "indent": 6,
      "text": " The string [00 09 01 FF] forms an MPI with the value 511.",
      "ja": "文字列[00 09 01 ff]は、値511のMPIを形成します。"
    },
    {
      "indent": 3,
      "text": "Additional rules:",
      "ja": "追加のルール："
    },
    {
      "indent": 6,
      "text": "* The size of an MPI is ((MPI.length + 7) / 8) + 2 octets.",
      "ja": "* MPIのサイズは（（mpi.length + 7） / 8） + 2オクテットです。"
    },
    {
      "indent": 6,
      "text": "* The length field of an MPI describes the length starting from its most significant non-zero bit. Thus, the MPI [00 02 01] is not formed correctly. It should be [00 01 01]. When parsing an MPI in a version 6 Key, Signature, or Public Key Encrypted Session Key (PKESK) packet, the implementation MUST check that the encoded length matches the length starting from the most significant non-zero bit; if it doesn't match, reject the packet as malformed.",
      "ja": "* MPIの長さフィールドは、最も重要な非ゼロビットから始まる長さを記述します。したがって、MPI [00 02 01]は正しく形成されません。[00 01 01]でなければなりません。バージョン6キー、署名、または公開キー暗号化セッションキー（PKSK）パケットでMPIを解析する場合、実装は、エンコードされた長さが最も重要な非ゼロビットから始まる長さと一致することを確認する必要があります。一致しない場合は、パケットを奇形として拒否します。"
    },
    {
      "indent": 6,
      "text": "* Unused bits of an MPI MUST be zero.",
      "ja": "* MPIの未使用ビットはゼロでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Using MPIs to Encode Other Data",
      "section_title": true,
      "ja": "3.2.1. MPIを使用して他のデータをエンコードします"
    },
    {
      "indent": 3,
      "text": "Note that in some places, MPIs are used to encode non-integer data, such as an elliptic curve (EC) point (see Section 11.2) or an octet string of known, fixed length (see Section 11.3). The wire representation is the same: 2 octets of length in bits counted from the first non-zero bit, followed by the smallest series of octets that can represent the value while stripping off any leading zero octets.",
      "ja": "一部の場所では、MPIを使用して、楕円曲線（EC）ポイント（セクション11.2を参照）または既知の固定長のオクテット文字列（セクション11.3を参照）などの非整数データをエンコードすることに注意してください。ワイヤ表現は同じです：最初の非ゼロビットからカウントされたビットの長さ2オクテット、続いて、先頭のゼロオクテットを剥がしながら値を表すことができる最小のオクテットが続きます。"
    },
    {
      "indent": 0,
      "text": "3.3. Key IDs and Fingerprints",
      "section_title": true,
      "ja": "3.3. キーIDと指紋"
    },
    {
      "indent": 3,
      "text": "A Key ID is an 8-octet scalar that identifies a key. Implementations SHOULD NOT assume that Key IDs are unique. A fingerprint is more likely to be unique than a Key ID. The fingerprint and Key ID of a key are calculated differently according to the version of the key.",
      "ja": "キーIDは、キーを識別する8オクテットのスカラーです。実装は、キーIDが一意であると想定してはなりません。指紋は、キーIDよりも一意である可能性が高くなります。キーの指紋とキーIDは、キーのバージョンに応じて異なる方法で計算されます。"
    },
    {
      "indent": 3,
      "text": "Section 5.5.4 describes how Key IDs and Fingerprints are formed.",
      "ja": "セクション5.5.4では、キーIDと指紋の形成方法について説明します。"
    },
    {
      "indent": 0,
      "text": "3.4. Text",
      "section_title": true,
      "ja": "3.4. 文章"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified, the character set for text is the UTF-8 [RFC3629] encoding of Unicode [ISO10646].",
      "ja": "特に指定されていない限り、テキストの文字セットはUTF-8 [RFC3629] Unicode [ISO10646]のエンコードです。"
    },
    {
      "indent": 0,
      "text": "3.5. Time Fields",
      "section_title": true,
      "ja": "3.5. 時間フィールド"
    },
    {
      "indent": 3,
      "text": "A time field is an unsigned 4-octet number containing the number of seconds elapsed since midnight, 1 January 1970 UTC.",
      "ja": "タイムフィールドは、1970年1月1日のUTCの真夜中から経過した秒数を含む署名されていない4オクテット数です。"
    },
    {
      "indent": 0,
      "text": "3.6. Keyrings",
      "section_title": true,
      "ja": "3.6. キーリング"
    },
    {
      "indent": 3,
      "text": "A keyring is a collection of one or more keys in a file or database. Typically, a keyring is simply a sequential list of keys, but it may be any suitable database. It is beyond the scope of this specification to discuss the details of keyrings or other databases.",
      "ja": "キーリングとは、ファイルまたはデータベース内の1つ以上のキーのコレクションです。通常、キーリングは単にキーのシーケンシャルリストですが、適切なデータベースである可能性があります。この仕様の範囲を超えて、キーリングやその他のデータベースの詳細について説明します。"
    },
    {
      "indent": 0,
      "text": "3.7. String-to-Key (S2K) Specifier",
      "section_title": true,
      "ja": "3.7. String-to-Key（S2K）仕様"
    },
    {
      "indent": 3,
      "text": "A string-to-key (S2K) Specifier is used to convert a passphrase string into a symmetric key encryption/decryption key. Passphrases requiring use of S2K conversion are currently used in two places: to encrypt the secret part of private keys and for symmetrically encrypted messages.",
      "ja": "文字列間（S2K）仕様は、パスフレーズ文字列を対称キー暗号化/復号化キーに変換するために使用されます。S2K変換の使用を必要とするパスフレーズは、現在、プライベートキーの秘密部分を暗号化するため、および対称的に暗号化されたメッセージの2つの場所で使用されています。"
    },
    {
      "indent": 0,
      "text": "3.7.1. S2K Specifier Types",
      "section_title": true,
      "ja": "3.7.1. S2K仕様タイプ"
    },
    {
      "indent": 3,
      "text": "There are four types of S2K Specifiers currently specified and some reserved values:",
      "ja": "現在指定されているS2K仕様には4つのタイプがあり、いくつかの予約値があります。"
    },
    {
      "indent": 3,
      "text": "+=========+==============+===============+==============+===========+\n|      ID | S2K Type     | S2K Field     | Generate?    | Reference |\n|         |              | Size          |              |           |\n|         |              | (Octets)      |              |           |\n+=========+==============+===============+==============+===========+\n|       0 | Simple S2K   | 2             | No           | Section   |\n|         |              |               |              | 3.7.1.1   |\n+---------+--------------+---------------+--------------+-----------+\n|       1 | Salted S2K   | 10            | Only when    | Section   |\n|         |              |               | string is    | 3.7.1.2   |\n|         |              |               | high entropy |           |\n+---------+--------------+---------------+--------------+-----------+\n|       2 | Reserved     | -             | No           |           |\n|         | value        |               |              |           |\n+---------+--------------+---------------+--------------+-----------+\n|       3 | Iterated and | 11            | Yes          | Section   |\n|         | Salted S2K   |               |              | 3.7.1.3   |\n+---------+--------------+---------------+--------------+-----------+\n|       4 | Argon2       | 20            | Yes          | Section   |\n|         |              |               |              | 3.7.1.4   |\n+---------+--------------+---------------+--------------+-----------+\n| 100-110 | Private or   | -             | As           |           |\n|         | Experimental |               | appropriate  |           |\n|         | Use          |               |              |           |\n+---------+--------------+---------------+--------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Table 1: OpenPGP String-to-Key (S2K) Types Registry",
      "ja": "表1：OpenPGP String-to-Key（S2K）タイプレジストリ"
    },
    {
      "indent": 3,
      "text": "The S2K Specifier Types are described in the subsections below. If \"Yes\" is not present in the \"Generate?\" column, the S2K entry is used only for reading in backward-compatibility mode and SHOULD NOT be used to generate new output.",
      "ja": "S2K仕様タイプは、以下のサブセクションで説明されています。「はい」が「生成」に存在しない場合列、S2Kエントリは、後方互換性モードでの読み取りにのみ使用され、新しい出力を生成するために使用しないでください。"
    },
    {
      "indent": 0,
      "text": "3.7.1.1. Simple S2K",
      "section_title": true,
      "ja": "3.7.1.1. 単純なS2K"
    },
    {
      "indent": 3,
      "text": "Simple S2K directly hashes the string to produce the key data. This hashing is done as shown below.",
      "ja": "単純なS2Kは、文字列を直接ハッシュして重要なデータを生成します。このハッシュは、以下に示すように行われます。"
    },
    {
      "indent": 5,
      "text": "Octet 0:        0x00\nOctet 1:        hash algorithm",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simple S2K hashes the passphrase to produce the session key. The manner in which this is done depends on the size of the session key (which depends on the cipher the session key will be used with) and the size of the hash algorithm's output. If the hash size is greater than the session key size, the high-order (leftmost) octets of the hash are used as the key.",
      "ja": "単純なS2Kはパスフレーズをハッシュしてセッションキーを生成します。これが行われる方法は、セッションキーのサイズ（セッションキーが使用されます）とハッシュアルゴリズムの出力のサイズに依存します。ハッシュサイズがセッションキーサイズよりも大きい場合、ハッシュの高次（左端）オクテットがキーとして使用されます。"
    },
    {
      "indent": 3,
      "text": "If the hash size is less than the key size, multiple instances of the hash context are created -- enough to produce the required key data. These instances are preloaded with 0, 1, 2, ... octets of zeros (that is, the first instance has no preloading, the second gets preloaded with 1 octet of zero, the third is preloaded with 2 octets of zeros, and so forth).",
      "ja": "ハッシュサイズがキーサイズよりも小さい場合、ハッシュコンテキストの複数のインスタンスが作成されます。必要なキーデータを生成するのに十分です。これらのインスタンスは0、1、2、...ゼロのオクテットでプリロードされています（つまり、最初のインスタンスにはプリロードがありません。2番目のインスタンスは1オクテットのゼロでプリロードされ、3番目は2オクテットのゼロでプリロードされます。前方へ）。"
    },
    {
      "indent": 3,
      "text": "As the data is hashed, it is given independently to each hash context. Since the contexts have been initialized differently, they will each produce a different hash output. Once the passphrase is hashed, the output data from the multiple hashes is concatenated, first hash leftmost, to produce the key data, and any excess octets on the right are discarded.",
      "ja": "データがハッシュされているため、各ハッシュコンテキストに独立して与えられます。コンテキストは異なる方法で初期化されているため、それぞれ異なるハッシュ出力が生成されます。パスフレーズがハッシュされると、複数のハッシュからの出力データが連結され、最初のハッシュが左端になり、重要なデータが生成され、右側の過剰なオクテットが破棄されます。"
    },
    {
      "indent": 0,
      "text": "3.7.1.2. Salted S2K",
      "section_title": true,
      "ja": "3.7.1.2. 塩漬けS2K"
    },
    {
      "indent": 3,
      "text": "Salted S2K includes a \"salt\" value in the S2K Specifier -- some arbitrary data -- that gets hashed along with the passphrase string to help prevent dictionary attacks.",
      "ja": "Salted S2Kには、辞書攻撃の防止に役立つパスフレーズ文字列と一緒にハッシュされるS2K仕様（いくつかの任意のデータ）に「塩」値が含まれています。"
    },
    {
      "indent": 5,
      "text": "Octet 0:        0x01\nOctet 1:        hash algorithm\nOctets 2-9:     8-octet salt value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Salted S2K is exactly like Simple S2K, except that the input to the hash function(s) consists of the 8 octets of salt from the S2K Specifier, followed by the passphrase.",
      "ja": "塩漬けS2Kは、ハッシュ関数への入力がS2K仕様の8オクテットの塩で構成され、その後パスフレーズが続くことを除いて、まったく単純なS2Kとまったく同じです。"
    },
    {
      "indent": 0,
      "text": "3.7.1.3. Iterated and Salted S2K",
      "section_title": true,
      "ja": "3.7.1.3. 繰り返して塩漬けS2K"
    },
    {
      "indent": 3,
      "text": "Iterated and Salted S2K includes both a salt and an octet count. The salt is combined with the passphrase, and the resulting value is repeated and then hashed. This further increases the amount of work an attacker must do to try dictionary attacks.",
      "ja": "反復および塩漬けS2Kには、塩とオクテット数の両方が含まれています。塩はパスフレーズと組み合わされ、結果の値が繰り返されてからハッシュされます。これにより、攻撃者が辞書攻撃を試すためにしなければならない仕事の量がさらに増加します。"
    },
    {
      "indent": 5,
      "text": "Octet  0:        0x03\nOctet  1:        hash algorithm\nOctets 2-9:      8-octet salt value\nOctet  10:       count; a 1-octet coded value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The count is coded into a 1-octet number using the following formula:",
      "ja": "カウントは、次の式を使用して1オクテットの数値にコード化されます。"
    },
    {
      "indent": 5,
      "text": "#define EXPBIAS 6\n    count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above formula is described in [C99], where \"Int32\" is a type for a 32-bit integer, and the variable \"c\" is the coded count, octet 10.",
      "ja": "上記の式は[C99]で説明されています。ここで、「int32」は32ビット整数のタイプであり、変数「c」はコード化されたカウントであるオクテット10です。"
    },
    {
      "indent": 3,
      "text": "Iterated and Salted S2K hashes the passphrase and salt data multiple times. The total number of octets to be hashed is specified in the encoded count in the S2K Specifier. Note that the resulting count value is an octet count of how many octets will be hashed, not an iteration count.",
      "ja": "繰り返して塩漬けS2Kは、パスフレーズと塩のデータを複数回ハッシュします。ハッシュするオクテットの総数は、S2K仕様のエンコードされたカウントで指定されています。結果のカウント値は、反復カウントではなく、ハッシュされるオクテットの数のオクテットカウントであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Initially, one or more hash contexts are set up the same as the other S2K algorithms, depending on how many octets of key data are needed. Then the salt, followed by the passphrase data, is repeatedly processed as input to each hash context until the number of octets specified by the octet count has been hashed. The input is truncated to the octet count, except if the octet count is less than the initial size of the salt plus passphrase. That is, at least one copy of the full salt plus passphrase will be provided as input to each hash context regardless of the octet count. After the hashing is done, the key data is produced from the hash digest(s), which is the same way it is produced for the other S2K algorithms.",
      "ja": "最初に、1つのハッシュコンテキストは、キーデータのオクテットの数に応じて、他のS2Kアルゴリズムと同じように設定されます。次に、パスフレーズデータが続く塩は、オクテット数で指定されたオクテットの数がハッシュされるまで、各ハッシュコンテキストへの入力として繰り返し処理されます。オクテット数が塩とパスフレーズの初期サイズよりも少ない場合を除き、入力はオクテット数に切り捨てられます。つまり、オクテット数に関係なく、各ハッシュコンテキストへの入力として、完全な塩プラスパスフレーズの少なくとも1つのコピーが提供されます。ハッシュが完了した後、キーデータはハッシュダイジェストから生成されます。これは、他のS2Kアルゴリズムに対して生成されるのと同じ方法です。"
    },
    {
      "indent": 0,
      "text": "3.7.1.4. Argon2",
      "section_title": true,
      "ja": "3.7.1.4. Argon2"
    },
    {
      "indent": 3,
      "text": "This S2K method hashes the passphrase using Argon2, as specified in [RFC9106]. This provides memory hardness, further protecting the passphrase against brute-force attacks.",
      "ja": "このS2Kメソッドは、[RFC9106]で指定されているように、Argon2を使用してパスフレーズをハッシュします。これにより、記憶の硬度が得られ、ブルートフォース攻撃に対するパスフレーズがさらに保護されます。"
    },
    {
      "indent": 5,
      "text": "Octet  0:        0x04\nOctets 1-16:     16-octet salt value\nOctet  17:       1-octet number of passes t\nOctet  18:       1-octet degree of parallelism p\nOctet  19:       1-octet encoded_m, specifying the exponent of\n                    the memory size",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The salt SHOULD be unique for each passphrase.",
      "ja": "塩は、パスフレーズごとにユニークでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The number of passes t and the degree of parallelism p MUST be non-zero.",
      "ja": "パスTと並列性Pの程度はゼロではない必要があります。"
    },
    {
      "indent": 3,
      "text": "The memory size m is 2^(encoded_m) kibibytes (KiB) of RAM. The encoded memory size MUST be a value from 3+ceil(log_2(p)) to 31, such that the decoded memory size m is a value from 8*p to 2^31. Note that memory-hardness size is indicated in KiB, not octets.",
      "ja": "メモリサイズmは2^（encoded_m）kibibytes（kib）のラムです。エンコードされたメモリサイズは、3+天井（log_2（p））から31までの値である必要があります。そのため、デコードされたメモリサイズmは8*pから2^31までの値です。オクテットではなく、KIBでメモリ - ハードサイズが示されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Argon2 is invoked with the passphrase as P, the salt as S, the values of t, p, and m as described above, the required key size as the tag length T, 0x13 as the version v, and Argon2id as the type.",
      "ja": "Argon2は、PassPhraseでP、SATとしての塩、上記のT、P、およびMの値、タグの長さtとして必要なキーサイズ、バージョンVとして0x13、型としてArgon2IDで呼び出されます。"
    },
    {
      "indent": 3,
      "text": "For the recommended values of t, p, and m, see Section 4 of [RFC9106]. If the recommended value of m for a given application is not a power of 2, it is RECOMMENDED to round up to the next power of 2 if the resulting performance would be acceptable; otherwise, round down (keeping in mind that m must be at least 8*p).",
      "ja": "T、P、およびMの推奨値については、[RFC9106]のセクション4を参照してください。特定のアプリケーションの推奨値が2の電力ではない場合、結果のパフォーマンスが許容される場合は、次のパワー2にまとめることをお勧めします。それ以外の場合は、丸くしてください（Mは少なくとも8*pでなければならないことに留意してください）。"
    },
    {
      "indent": 3,
      "text": "As an example, with the first recommended option (t=1, p=4, m=2^21), the full S2K Specifier would be:",
      "ja": "例として、最初の推奨オプション（t = 1、p = 4、m = 2^21）を使用すると、完全なS2K仕様は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "04 XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX\nXX 01 04 15",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where XX represents a random octet of salt.",
      "ja": "ここで、xxは塩のランダムなオクテットを表します。"
    },
    {
      "indent": 0,
      "text": "3.7.2. S2K Usage",
      "section_title": true,
      "ja": "3.7.2. S2Kの使用"
    },
    {
      "indent": 3,
      "text": "Simple S2K and Salted S2K Specifiers can be brute-forced when used with a low-entropy string, such as those typically provided by users. In addition, the usage of Simple S2K can lead to key and initialization vector (IV) reuse (see Section 5.3). Therefore, when generating an S2K Specifier, an implementation MUST NOT use Simple S2K. Furthermore, an implementation SHOULD NOT generate a Salted S2K unless the implementation knows that the input string is high entropy (for example, it generated the string itself using a known good source of randomness).",
      "ja": "単純なS2Kおよび塩漬けS2K仕様は、ユーザーが通常提供するような低エントロピー文字列で使用すると、ブルート強化できます。さらに、単純なS2Kの使用は、キーおよび初期化ベクトル（IV）の再利用につながる可能性があります（セクション5.3を参照）。したがって、S2K仕様を生成する場合、実装は単純なS2Kを使用してはなりません。さらに、実装は、入力文字列が高いエントロピーであることを実装がわからない限り、塩漬けS2Kを生成してはなりません（たとえば、既知のランダム性の良好なソースを使用して文字列自体を生成しました）。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that implementations use Argon2. If Argon2 is not available, Iterated and Salted S2K MAY be used if care is taken to use a high octet count and a strong passphrase. However, this method does not provide memory hardness, unlike Argon2.",
      "ja": "実装はArgon2を使用することをお勧めします。Argon2が利用できない場合、高オクテットカウントと強力なパスフレーズを使用するように注意が必要な場合、繰り返し塩S2Kを使用できます。ただし、この方法は、Argon2とは異なり、メモリの硬度を提供しません。"
    },
    {
      "indent": 0,
      "text": "3.7.2.1. Secret Key Encryption",
      "section_title": true,
      "ja": "3.7.2.1. シークレットキー暗号化"
    },
    {
      "indent": 3,
      "text": "The first octet following the public key material in a Secret Key packet (Section 5.5.3) indicates whether and how the secret key material is passphrase protected. This first octet is known as the \"S2K usage octet\".",
      "ja": "シークレットキーパケット（セクション5.5.3）の公開キー資料に続く最初のオクテットは、シークレットキーの素材がパスフレーズの保護されているかどうか、どのように保護されているかを示します。この最初のオクテットは、「S2K使用量オクテット」として知られています。"
    },
    {
      "indent": 3,
      "text": "If the S2K usage octet is zero, the secret key data is unprotected. If it is non-zero, it describes how to use a passphrase to unlock the secret key.",
      "ja": "S2Kの使用法がゼロの場合、シークレットキーデータは保護されていません。ゼロ以外の場合、パスフレーズを使用してシークレットキーのロックを解除する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Implementations predating [RFC2440] indicated a protected key by storing a Symmetric Cipher Algorithm ID (see Section 9.3) in the S2K usage octet. In this case, the MD5 hash function was always used to convert the passphrase to a key for the specified cipher algorithm.",
      "ja": "[RFC2440]の前の実装では、S2K使用量Octetに対称暗号アルゴリズムID（セクション9.3を参照）を保存することにより、保護されたキーを示しました。この場合、MD5ハッシュ関数は、指定された暗号アルゴリズムのキーにパスフレーズを変換するために常に使用されました。"
    },
    {
      "indent": 3,
      "text": "Later implementations indicate a protected secret key by storing one of the special values 253 (AEAD), 254 (CFB), or 255 (MalleableCFB) in the S2K usage octet. The S2K usage octet is then followed immediately by a set of fields that describe how to convert a passphrase to a symmetric key that can unlock the secret material, plus other parameters relevant to the type of encryption used.",
      "ja": "後の実装では、S2K使用法のオクテットに特別な値253（AEAD）、254（CFB）、または255（MalleableCFB）のいずれかを保存することにより、保護された秘密の鍵を示します。その後、S2K使用量のオクテットの後に、パスフレーズを秘密の素材のロックを解除できる対称キーに変換する方法と、使用される暗号化のタイプに関連する他のパラメーターに変換する方法を説明する一連のフィールドがすぐに続きます。"
    },
    {
      "indent": 3,
      "text": "The wire format fields also differ based on the version of the enclosing OpenPGP packet. The table below, indexed by the S2K usage octet, summarizes the specifics described in Section 5.5.3.",
      "ja": "ワイヤ形式のフィールドは、copenPGPパケットを囲むバージョンに基づいて異なります。以下の表は、S2K使用量Octetでインデックス付けされており、セクション5.5.3で説明した詳細をまとめたものです。"
    },
    {
      "indent": 3,
      "text": "In the table below, check(x) means the \"2-octet checksum\", which is the sum of all octets in x mod 65536. The info and packetprefix parameters are described in detail in Section 5.5.3. Note that the \"Generate?\" column header has been shortened to \"Gen?\" here.",
      "ja": "以下の表では、（x）をチェックして、「2-OCTETチェックサム」を意味します。これは、X Mod 65536のすべてのオクテットの合計です。「生成？」に注意してください。列ヘッダーは「Gen？」に短縮されました。ここ。"
    },
    {
      "indent": 3,
      "text": "+=========+============+============+==========================+====+\n|S2K Usage|Shorthand   |Encryption  |Encryption                |Gen?|\n|Octet    |            |Parameter   |                          |    |\n|         |            |Fields      |                          |    |\n+=========+============+============+==========================+====+\n|0        |Unprotected |-           |*v3 or v4 keys:*          |Yes |\n|         |            |            |[cleartext secrets ||     |    |\n|         |            |            |check(secrets)]           |    |\n|         |            |            |*v6 keys:* [cleartext     |    |\n|         |            |            |secrets]                  |    |\n+---------+------------+------------+--------------------------+----+\n|Known    |LegacyCFB   |IV          |CFB(MD5(passphrase),      |No  |\n|symmetric|            |            |secrets || check(secrets))|    |\n|cipher   |            |            |                          |    |\n|algo ID  |            |            |                          |    |\n|(see     |            |            |                          |    |\n|Section  |            |            |                          |    |\n|9.3)     |            |            |                          |    |\n+---------+------------+------------+--------------------------+----+\n|253      |AEAD        |params-     |AEAD(HKDF(S2K(passphrase),|Yes |\n|         |            |length      |info), secrets,           |    |\n|         |            |(*v6-only*),|packetprefix)             |    |\n|         |            |cipher-algo,|                          |    |\n|         |            |AEAD-mode,  |                          |    |\n|         |            |S2K-        |                          |    |\n|         |            |specifier-  |                          |    |\n|         |            |length      |                          |    |\n|         |            |(*v6-only*),|                          |    |\n|         |            |S2K-        |                          |    |\n|         |            |specifier,  |                          |    |\n|         |            |nonce       |                          |    |\n+---------+------------+------------+--------------------------+----+\n|254      |CFB         |params-     |CFB(S2K(passphrase),      |Yes |\n|         |            |length      |secrets || SHA1(secrets)) |    |\n|         |            |(*v6-only*),|                          |    |\n|         |            |cipher-algo,|                          |    |\n|         |            |S2K-        |                          |    |\n|         |            |specifier-  |                          |    |\n|         |            |length      |                          |    |\n|         |            |(*v6-only*),|                          |    |\n|         |            |S2K-        |                          |    |\n|         |            |specifier,  |                          |    |\n|         |            |IV          |                          |    |\n+---------+------------+------------+--------------------------+----+\n|255      |MalleableCFB|cipher-algo,|CFB(S2K(passphrase),      |No  |\n|         |            |S2K-        |secrets || check(secrets))|    |\n|         |            |specifier,  |                          |    |\n|         |            |IV          |                          |    |\n+---------+------------+------------+--------------------------+----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Table 2: OpenPGP Secret Key Encryption (S2K Usage Octet) Registry",
      "ja": "表2：OpenPGP Secret Key暗号化（S2K使用量Octet）レジストリ"
    },
    {
      "indent": 3,
      "text": "When emitting a secret key (with or without passphrase protection), an implementation MUST only produce data from a row with \"Generate?\" marked as \"Yes\". Each row with \"Generate?\" marked as \"No\" is described for backward compatibility (for reading version 4 and earlier keys only) and MUST NOT be used to generate new output. Version 6 secret keys using these formats MUST be rejected.",
      "ja": "（パスフレーズ保護の有無にかかわらず）秘密の鍵を放出する場合、実装は「Generate？」で行からデータのみを生成する必要があります。「はい」とマークされています。「生成？」の各行「いいえ」としてマークされているとマークされていることは、後方互換性（バージョン4以前のキー以前のキーのみを読み取るため）について説明しており、新しい出力を生成するために使用してはなりません。これらの形式を使用したバージョン6シークレットキーを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that compared to a version 4 secret key, the parameters of a passphrase-protected version 6 secret key are stored with an additional pair of length counts, each of which is 1 octet wide.",
      "ja": "バージョン4シークレットキーと比較して、パスフレーズ保護バージョン6シークレットキーのパラメーターは、追加のペアの長さカウントで保存されており、それぞれが1オクテットの幅です。"
    },
    {
      "indent": 3,
      "text": "Argon2 is only used with Authenticated Encryption with Associated Data (AEAD) (S2K usage octet 253). An implementation MUST NOT create and MUST reject as malformed any Secret Key packet where the S2K usage octet is not AEAD (253) and the S2K Specifier Type is Argon2.",
      "ja": "Argon2は、関連するデータ（AEAD）を使用した認証された暗号化でのみ使用されます（S2K使用量Octet 253）。実装は、S2Kの使用法がaead（253）であり、S2K仕様タイプがArgon2である秘密のキーパケットを奇形して拒否してはならないため、拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7.2.2. Symmetric Key Message Encryption",
      "section_title": true,
      "ja": "3.7.2.2. 対称キーメッセージ暗号化"
    },
    {
      "indent": 3,
      "text": "OpenPGP can create a Symmetric Key Encrypted Session Key (SKESK) packet at the front of a message. This is used to allow S2K Specifiers to be used for the passphrase conversion or to create messages with a mix of SKESK packets and PKESK packets. This allows a message to be decrypted with either a passphrase or a public key pair.",
      "ja": "OpenPGPは、メッセージの前面に対称キー暗号化セッションキー（SKESK）パケットを作成できます。これは、S2K仕様をPassPhrase変換に使用できるようにするため、またはSkeskパケットとPKSEKパケットの組み合わせでメッセージを作成できるようにします。これにより、メッセージをパスフレーズまたは公開キーペアのいずれかで復号化できます。"
    },
    {
      "indent": 3,
      "text": "Implementations predating [RFC2440] always used the International Data Encryption Algorithm (IDEA) with Simple S2K conversion when encrypting a message with a symmetric algorithm; see Section 5.7. IDEA MUST NOT be generated but MAY be consumed for backward compatibility.",
      "ja": "[RFC2440]の先行性の実装は、対称アルゴリズムでメッセージを暗号化するときに、単純なS2K変換で国際データ暗号化アルゴリズム（IDEA）を常に使用していました。セクション5.7を参照してください。アイデアを生成してはなりませんが、後方互換性のために消費される場合があります。"
    },
    {
      "indent": 0,
      "text": "4. Packet Syntax",
      "section_title": true,
      "ja": "4. パケット構文"
    },
    {
      "indent": 3,
      "text": "This section describes the packets used by OpenPGP.",
      "ja": "このセクションでは、OpenPGPが使用するパケットについて説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Overview",
      "section_title": true,
      "ja": "4.1. 概要"
    },
    {
      "indent": 3,
      "text": "An OpenPGP Message is constructed from a number of records that are typically called packets. A packet is a chunk of data that has a Type ID specifying its meaning. An OpenPGP Message, keyring, certificate, detached signature, and so forth consists of a number of packets. Some of those packets may contain other OpenPGP packets (for example, a compressed data packet, when uncompressed, contains OpenPGP packets).",
      "ja": "OpenPGPメッセージは、通常はパケットと呼ばれる多くのレコードから構築されています。パケットは、その意味を指定するタイプIDを持つデータの塊です。OpenPGPメッセージ、キーリング、証明書、デタッチされた署名などは、多くのパケットで構成されています。これらのパケットの一部には、他のOpenPGPパケットが含まれている場合があります（たとえば、圧縮されていない場合、OpenPGPパケットが含まれています）。"
    },
    {
      "indent": 3,
      "text": "Each packet consists of a packet header, followed by the packet body. The packet header is of variable length.",
      "ja": "各パケットはパケットヘッダーで構成され、その後パケット本体が続きます。パケットヘッダーの長さは可変です。"
    },
    {
      "indent": 3,
      "text": "When handling a stream of packets, the length information in each packet header is the canonical source of packet boundaries. An implementation handling a packet stream that wants to find the next packet MUST look for it at the precise offset indicated in the previous packet header.",
      "ja": "パケットのストリームを処理するとき、各パケットヘッダーの長さ情報は、パケット境界の標準的なソースです。次のパケットを見つけたいパケットストリームを処理する実装は、前のパケットヘッダーに示された正確なオフセットでそれを探す必要があります。"
    },
    {
      "indent": 3,
      "text": "Additionally, some packets contain internal length indicators (for example, a subfield within the packet). In the event that a subfield length indicator within a packet implies inclusion of octets outside the range indicated in the packet header, a parser MUST abort without writing outside the indicated range and MUST treat the packet as malformed and unusable.",
      "ja": "さらに、一部のパケットには、内部長のインジケーター（たとえば、パケット内のサブフィールド）が含まれています。パケット内のサブフィールド長インジケーターがパケットヘッダーに示されている範囲外のオクテットを含めることを意味する場合、パーサーは示された範囲の外側に書き込むことなく中止する必要があり、パケットを奇形で使用できないものとして扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT interpret octets outside the range indicated in the packet header as part of the contents of the packet.",
      "ja": "実装は、パケットヘッダーに示されている範囲外のオクテットをパケットの内容の一部として解釈してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.2. Packet Headers",
      "section_title": true,
      "ja": "4.2. パケットヘッダー"
    },
    {
      "indent": 3,
      "text": "The first octet of the packet denotes the format of the rest of the header, and it encodes the Packet Type ID, indicating the type of the packet (see Section 5). The remainder of the packet header is the length of the packet.",
      "ja": "パケットの最初のオクテットは、ヘッダーの残りの形式を示し、パケットタイプIDをエンコードし、パケットのタイプを示します（セクション5を参照）。パケットヘッダーの残りの部分は、パケットの長さです。"
    },
    {
      "indent": 3,
      "text": "There are two packet formats: 1) the (current) OpenPGP packet format specified by this document and its predecessors [RFC4880] and [RFC2440] and 2) the Legacy packet format as used by implementations predating any IETF specification of OpenPGP.",
      "ja": "2つのパケット形式があります。1）このドキュメントとその前任者[RFC4880]および[RFC2440]および2）OpenPGPのIETF仕様で使用されるレガシーパケット形式で指定された（現在の）openPGPパケット形式。"
    },
    {
      "indent": 3,
      "text": "Note that the most significant bit is the leftmost bit, called \"bit 7\". A mask for this bit is 0x80 in hexadecimal.",
      "ja": "最も重要なビットは、「ビット7」と呼ばれる左端のビットであることに注意してください。このビットのマスクは、16進数で0x80です。"
    },
    {
      "indent": 5,
      "text": "                        +---------------+\nEncoded Packet Type ID: |7 6 5 4 3 2 1 0|\n                        +---------------+\nOpenPGP format:\n  Bit 7 -- always one\n  Bit 6 -- always one\n  Bits 5 to 0 -- Packet Type ID\n\nLegacy format:\n  Bit 7 -- always one\n  Bit 6 -- always zero\n  Bits 5 to 2 -- Packet Type ID\n  Bits 1 to 0 -- length-type",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bit 6 of the first octet of the packet header indicates whether the packet is encoded in the OpenPGP or Legacy packet format. The Legacy packet format MAY be used when consuming packets to facilitate interoperability and accessing archived data. The Legacy packet format SHOULD NOT be used to generate new data, unless the recipient is known to only support the Legacy packet format. This latter case is extremely unlikely, as the Legacy packet format was obsoleted by [RFC2440] in 1998.",
      "ja": "パケットヘッダーの最初のオクテットのビット6は、パケットがOpenPGPまたはレガシーパケット形式でエンコードされているかどうかを示します。レガシーパケット形式は、相互運用性を促進し、アーカイブデータにアクセスするためにパケットを消費するときに使用できます。レガシーパケット形式は、受信者がレガシーパケット形式のみをサポートすることが知られている場合を除き、新しいデータを生成するために使用しないでください。1998年にレガシーパケット形式が[RFC2440]によって廃止されたため、この後者のケースは非常にありそうもない。"
    },
    {
      "indent": 3,
      "text": "An implementation that consumes and redistributes pre-existing OpenPGP data (such as Transferable Public Keys) may encounter packets framed with the Legacy packet format. Such an implementation MAY either redistribute these packets in their Legacy format or transform them to the current OpenPGP packet format before redistribution.",
      "ja": "既存のOpenPGPデータ（転送可能なパブリックキーなど）を消費および再配置する実装は、レガシーパケット形式で囲まれたパケットに遭遇する場合があります。このような実装は、これらのパケットをレガシー形式で再配布するか、再配布前に現在のOpenPGPパケット形式に変換する場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that Legacy format headers only have 4 bits for the Packet Type ID and hence can only encode Packet Type IDs less than 16, whereas the OpenPGP format headers can encode IDs as great as 63.",
      "ja": "レガシー形式のヘッダーにはパケットタイプIDに4ビットしかないため、16未満のパケットタイプIDのみをエンコードできますが、OpenPGP形式のヘッダーは63と大きいIDをエンコードできます。"
    },
    {
      "indent": 0,
      "text": "4.2.1. OpenPGP Format Packet Lengths",
      "section_title": true,
      "ja": "4.2.1. OpenPGP形式のパケット長"
    },
    {
      "indent": 3,
      "text": "OpenPGP format packets have four possible ways of encoding length:",
      "ja": "OpenPGP形式のパケットには、長さをエンコードする4つの可能な方法があります。"
    },
    {
      "indent": 8,
      "text": "1. A 1-octet Body Length header encodes packet lengths of up to 191 octets.",
      "ja": "1. 1-OCTETボディの長さヘッダーは、最大191オクテットのパケット長をエンコードします。"
    },
    {
      "indent": 8,
      "text": "2. A 2-octet Body Length header encodes packet lengths of 192 to 8383 octets.",
      "ja": "2. 2-OCTETボディの長さヘッダーは、192〜8383オクテットのパケット長をエンコードします。"
    },
    {
      "indent": 8,
      "text": "3. A 5-octet Body Length header encodes packet lengths of up to 4,294,967,295 (0xFFFFFFFF) octets in length. (This actually encodes a 4-octet scalar number.)",
      "ja": "3. 5-OCTETボディの長さのヘッダーは、長さが最大4,294,967,295（0xffffffffff）のパケット長をエンコードします。（これは実際に4オクテットのスカラー番号をエンコードします。）"
    },
    {
      "indent": 8,
      "text": "4. When the length of the packet body is not known in advance by the issuer, Partial Body Length headers encode a packet of indeterminate length, effectively making it a stream.",
      "ja": "4. パケット本体の長さが発行者によって事前に知られていない場合、部分的なボディの長さヘッダーは不確定な長さのパケットをエンコードし、効果的にストリームにします。"
    },
    {
      "indent": 0,
      "text": "4.2.1.1. 1-Octet Lengths",
      "section_title": true,
      "ja": "4.2.1.1. 1-オクテットの長さ"
    },
    {
      "indent": 3,
      "text": "A 1-octet Body Length header encodes a length of 0 to 191 octets. This type of length header is recognized because the 1-octet value is less than 192. The body length is equal to:",
      "ja": "1-OCTETボディの長さヘッダーは、0〜191オクテットの長さをエンコードします。このタイプの長さヘッダーは、1-OCTET値が192未満であるために認識されます。体の長さは以下に等しくなります。"
    },
    {
      "indent": 5,
      "text": "bodyLen = 1st_octet;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2.1.2. 2-Octet Lengths",
      "section_title": true,
      "ja": "4.2.1.2. 2-オクテットの長さ"
    },
    {
      "indent": 3,
      "text": "A 2-octet Body Length header encodes a length of 192 to 8383 octets. It is recognized because its first octet is in the range 192 to 223. The body length is equal to:",
      "ja": "2-OCTETボディの長さヘッダーは、192〜8383オクテットの長さをエンコードします。最初のオクテットは192〜223の範囲にあるために認識されています。体の長さは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "bodyLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2.1.3. 5-Octet Lengths",
      "section_title": true,
      "ja": "4.2.1.3. 5-OCTETの長さ"
    },
    {
      "indent": 3,
      "text": "A 5-octet Body Length header consists of a single octet holding the value 255, followed by a 4-octet scalar. The body length is equal to:",
      "ja": "5-OCTETボディの長さヘッダーは、値255を保持する単一のオクテットで構成され、その後4オクテットのスカラーが続きます。体の長さは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "bodyLen = (2nd_octet << 24) | (3rd_octet << 16) |\n          (4th_octet << 8)  | 5th_octet",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This basic set of 1-octet, 2-octet, and 5-octet lengths is also used internally to some packets.",
      "ja": "1-OCTET、2-OCTET、および5オクテットの長さのこの基本セットも、一部のパケットに内部的に使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2.1.4. Partial Body Lengths",
      "section_title": true,
      "ja": "4.2.1.4. 部分的な体の長さ"
    },
    {
      "indent": 3,
      "text": "A Partial Body Length header is 1 octet long and encodes the length of only part of the data packet. This length is a power of 2, from 1 to 1,073,741,824 (2 to the 30th power). It is recognized by its 1-octet value that is greater than or equal to 224, and less than 255. The Partial Body Length is equal to:",
      "ja": "部分的なボディの長さのヘッダーは1オクテットの長さで、データパケットの一部のみの長さをエンコードします。この長さは、1〜1,073,741,824（2〜30パワー）の2のパワーです。これは、224以上、255未満の1オクセット値によって認識されます。部分的な体の長さは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "partialBodyLen = 1 << (1st_octet & 0x1F);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each Partial Body Length header is followed by a portion of the packet body data; the Partial Body Length header specifies this portion's length. Another length header (1-octet, 2-octet, 5-octet, or partial) follows that portion. The last length header in the packet MUST NOT be a Partial Body Length header. Partial Body Length headers may only be used for the non-final parts of the packet.",
      "ja": "各部分ボディの長さヘッダーの後に、パケットボディデータの一部が続きます。部分的な体長ヘッダーは、この部分の長さを指定します。別の長さヘッダー（1-OCTET、2-OCTET、5-OCTET、または部分）がその部分に従います。パケットの最後の長さヘッダーは、部分的なボディの長さヘッダーであってはなりません。部分的なボディの長さヘッダーは、パケットのファイナル以外の部分にのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "Note also that the last Body Length header can be a zero-length header.",
      "ja": "また、最後のボディ長ヘッダーはゼロ長ヘッダーになる可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY use Partial Body Lengths for data packets, whether they are literal, compressed, or encrypted. The first partial length MUST be at least 512 octets long. Partial Body Lengths MUST NOT be used for any other packet types.",
      "ja": "実装は、文字通り、圧縮、または暗号化されているかどうかにかかわらず、データパケットに部分的なボディの長さを使用する場合があります。最初の部分的な長さは、少なくとも512オクテットの長さでなければなりません。部分的なボディの長さは、他のパケットタイプに使用しないでください。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Legacy Format Packet Lengths",
      "section_title": true,
      "ja": "4.2.2. レガシー形式のパケット長"
    },
    {
      "indent": 3,
      "text": "A zero in bit 6 of the first octet of the packet indicates a Legacy packet format. Bits 1 and 0 of the first octet of a Legacy packet are the \"length-type\" field. The meaning of length-type in Legacy format packets is as follows:",
      "ja": "パケットの最初のオクテットのビット6のゼロは、レガシーパケット形式を示します。レガシーパケットの最初のオクテットのビット1と0は、「長さタイプ」フィールドです。レガシー形式のパケットにおける長さタイプの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0",
      "ja": "0"
    },
    {
      "indent": 12,
      "text": "The packet has a 1-octet length. The header is 2 octets long.",
      "ja": "パケットの長さは1-OCTETです。ヘッダーの長さは2オクターです。"
    },
    {
      "indent": 3,
      "text": "1",
      "ja": "1"
    },
    {
      "indent": 12,
      "text": "The packet has a 2-octet length. The header is 3 octets long.",
      "ja": "パケットの長さは2-OCTETです。ヘッダーの長さは3オクターです。"
    },
    {
      "indent": 3,
      "text": "2",
      "ja": "2"
    },
    {
      "indent": 12,
      "text": "The packet has a 4-octet length. The header is 5 octets long.",
      "ja": "パケットの長さは4-OCTETです。ヘッダーの長さは5オクターです。"
    },
    {
      "indent": 3,
      "text": "3",
      "ja": "3"
    },
    {
      "indent": 12,
      "text": "The packet is of indeterminate length. The header is 1 octet long, and the implementation must determine how long the packet is. If the packet is in a file, it means that the packet extends until the end of the file. The OpenPGP format headers have a mechanism for precisely encoding data of indeterminate length. An implementation MUST NOT generate a Legacy format packet with indeterminate length. An implementation MAY interpret an indeterminate length Legacy format packet in order to deal with historic data or data generated by a legacy system that predates support for [RFC2440].",
      "ja": "パケットは不確定な長さです。ヘッダーの長さは1オクターで、実装はパケットの長さを決定する必要があります。パケットがファイルにある場合、パケットがファイルの最後まで拡張されることを意味します。OpenPGP形式のヘッダーには、不定の長さのデータを正確にエンコードするメカニズムがあります。実装は、不定の長さのレガシー形式パケットを生成してはなりません。実装は、[RFC2440]のサポートに先行するレガシーシステムによって生成された歴史的なデータまたはデータに対処するために、不確定な長さのレガシー形式パケットを解釈する場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Packet Length Examples",
      "section_title": true,
      "ja": "4.2.3. パケット長の例"
    },
    {
      "indent": 3,
      "text": "These examples show ways that OpenPGP format packets might encode the packet body lengths.",
      "ja": "これらの例は、OpenPGP形式のパケットがパケットボディの長さをエンコードする方法を示しています。"
    },
    {
      "indent": 6,
      "text": "* A packet body with length 100 may have its length encoded in one octet: 0x64. This is followed by 100 octets of data.",
      "ja": "* 長さ100のパケット本体の長さは、1つのオクテットでエンコードされている場合があります：0x64。これに続いて、100オクテットのデータが続きます。"
    },
    {
      "indent": 6,
      "text": "* A packet body with length 1723 may have its length encoded in two octets: 0xC5, 0xFB. This header is followed by the 1723 octets of data.",
      "ja": "* 長さ1723のパケット本体の長さは、0xc5、0xfbの2つのオクテットでエンコードされている場合があります。このヘッダーの後に、1723年のデータが続きます。"
    },
    {
      "indent": 6,
      "text": "* A packet body with length 100000 may have its length encoded in five octets: 0xFF, 0x00, 0x01, 0x86, 0xA0.",
      "ja": "* 長さ100000のパケット本体の長さは、0xff、0x00、0x01、0x86、0xa0の5オクテットでエンコードされている場合があります。"
    },
    {
      "indent": 3,
      "text": "It might also be encoded in the following octet stream:",
      "ja": "また、次のオクテットストリームでエンコードされる可能性があります。"
    },
    {
      "indent": 6,
      "text": "* 0xEF, first 32768 octets of data;",
      "ja": "* 0xef、最初の32768データのオクテット。"
    },
    {
      "indent": 6,
      "text": "* 0xE1, next 2 octets of data;",
      "ja": "* 0xe1、次の2オクテットのデータ。"
    },
    {
      "indent": 6,
      "text": "* 0xE0, next 1 octet of data;",
      "ja": "* 0xe0、次の1オクテットのデータ。"
    },
    {
      "indent": 6,
      "text": "* 0xF0, next 65536 octets of data; and",
      "ja": "* 0xf0、次の65536データのオクテット。そして"
    },
    {
      "indent": 6,
      "text": "* 0xC5, 0xDD, last 1693 octets of data.",
      "ja": "* 0xc5、0xdd、最後の1693データのオクテット。"
    },
    {
      "indent": 3,
      "text": "This is just one possible encoding, and many variations are possible on the size of the Partial Body Length headers, as long as a regular Body Length header encodes the last portion of the data.",
      "ja": "これは1つの可能なエンコーディングの1つにすぎません。通常の体長ヘッダーがデータの最後の部分をエンコードする限り、部分的な体長ヘッダーのサイズで多くのバリエーションが可能です。"
    },
    {
      "indent": 3,
      "text": "Please note that in all of these explanations, the total length of the packet is the length of the header(s) plus the length of the body.",
      "ja": "これらの説明のすべてにおいて、パケットの全長はヘッダーの長さと体の長さであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3. Packet Criticality",
      "section_title": true,
      "ja": "4.3. パケットクリティカル"
    },
    {
      "indent": 3,
      "text": "The Packet Type ID space is partitioned into critical packets and non-critical packets. If an implementation encounters a critical packet where the packet type is unknown in a packet sequence, it MUST reject the whole packet sequence (see Section 10). On the other hand, an unknown non-critical packet MUST be ignored.",
      "ja": "パケットタイプIDスペースは、重要なパケットと非批判的なパケットに分割されます。実装がパケットタイプがパケットシーケンスで不明な重要なパケットに遭遇する場合、パケットシーケンス全体を拒否する必要があります（セクション10を参照）。一方、未知の非批判的なパケットは無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Packets with Type IDs from 0 to 39 are critical. Packets with Type IDs from 40 to 63 are non-critical.",
      "ja": "0から39のタイプIDを持つパケットが重要です。40から63のタイプIDを持つパケットは、批判的ではありません。"
    },
    {
      "indent": 0,
      "text": "5. Packet Types",
      "section_title": true,
      "ja": "5. パケットタイプ"
    },
    {
      "indent": 3,
      "text": "The defined packet types are as follows:",
      "ja": "定義されたパケットタイプは次のとおりです。"
    },
    {
      "indent": 4,
      "text": "+=======+==========+=====================+===========+===========+\n|    ID | Critical | Packet Type         | Shorthand | Reference |\n|       |          | Description         |           |           |\n+=======+==========+=====================+===========+===========+\n|     0 | Yes      | Reserved - this     |           |           |\n|       |          | Packet Type ID MUST |           |           |\n|       |          | NOT be used         |           |           |\n+-------+----------+---------------------+-----------+-----------+\n|     1 | Yes      | Public Key          | PKESK     | Section   |\n|       |          | Encrypted Session   |           | 5.1       |\n|       |          | Key Packet          |           |           |\n+-------+----------+---------------------+-----------+-----------+\n|     2 | Yes      | Signature Packet    | SIG       | Section   |\n|       |          |                     |           | 5.2       |\n+-------+----------+---------------------+-----------+-----------+\n|     3 | Yes      | Symmetric Key       | SKESK     | Section   |\n|       |          | Encrypted Session   |           | 5.3       |\n|       |          | Key Packet          |           |           |\n+-------+----------+---------------------+-----------+-----------+\n|     4 | Yes      | One-Pass Signature  | OPS       | Section   |\n|       |          | Packet              |           | 5.4       |\n+-------+----------+---------------------+-----------+-----------+\n|     5 | Yes      | Secret Key Packet   | SECKEY    | Section   |\n|       |          |                     |           | 5.5.1.3   |\n+-------+----------+---------------------+-----------+-----------+\n|     6 | Yes      | Public Key Packet   | PUBKEY    | Section   |\n|       |          |                     |           | 5.5.1.1   |\n+-------+----------+---------------------+-----------+-----------+\n|     7 | Yes      | Secret Subkey       | SECSUBKEY | Section   |\n|       |          | Packet              |           | 5.5.1.4   |\n+-------+----------+---------------------+-----------+-----------+\n|     8 | Yes      | Compressed Data     | COMP      | Section   |\n|       |          | Packet              |           | 5.6       |\n+-------+----------+---------------------+-----------+-----------+\n|     9 | Yes      | Symmetrically       | SED       | Section   |\n|       |          | Encrypted Data      |           | 5.7       |\n|       |          | Packet              |           |           |\n+-------+----------+---------------------+-----------+-----------+\n|    10 | Yes      | Marker Packet       | MARKER    | Section   |\n|       |          |                     |           | 5.8       |\n+-------+----------+---------------------+-----------+-----------+\n|    11 | Yes      | Literal Data Packet | LIT       | Section   |\n|       |          |                     |           | 5.9       |\n+-------+----------+---------------------+-----------+-----------+\n|    12 | Yes      | Trust Packet        | TRUST     | Section   |\n|       |          |                     |           | 5.10      |\n+-------+----------+---------------------+-----------+-----------+\n|    13 | Yes      | User ID Packet      | UID       | Section   |\n|       |          |                     |           | 5.11      |\n+-------+----------+---------------------+-----------+-----------+\n|    14 | Yes      | Public Subkey       | PUBSUBKEY | Section   |\n|       |          | Packet              |           | 5.5.1.2   |\n+-------+----------+---------------------+-----------+-----------+\n|    17 | Yes      | User Attribute      | UAT       | Section   |\n|       |          | Packet              |           | 5.12      |\n+-------+----------+---------------------+-----------+-----------+\n|    18 | Yes      | Symmetrically       | SEIPD     | Section   |\n|       |          | Encrypted and       |           | 5.13      |\n|       |          | Integrity Protected |           |           |\n|       |          | Data Packet         |           |           |\n+-------+----------+---------------------+-----------+-----------+\n|    19 | Yes      | Reserved (formerly  |           | Section   |\n|       |          | Modification        |           | 5.13.1    |\n|       |          | Detection Code      |           |           |\n|       |          | Packet)             |           |           |\n+-------+----------+---------------------+-----------+-----------+\n|    20 | Yes      | Reserved            |           |           |\n+-------+----------+---------------------+-----------+-----------+\n|    21 | Yes      | Padding Packet      | PADDING   | Section   |\n|       |          |                     |           | 5.14      |\n+-------+----------+---------------------+-----------+-----------+\n| 22-39 | Yes      | Unassigned Critical |           |           |\n|       |          | Packets             |           |           |\n+-------+----------+---------------------+-----------+-----------+\n| 40-59 | No       | Unassigned Non-     |           |           |\n|       |          | Critical Packets    |           |           |\n+-------+----------+---------------------+-----------+-----------+\n| 60-63 | No       | Private or          |           |           |\n|       |          | Experimental Use    |           |           |\n+-------+----------+---------------------+-----------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 3: OpenPGP Packet Types Registry",
      "ja": "表3：OpenPGPパケットタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "The labels in the \"Shorthand\" column are used for compact reference elsewhere in this document, and they may also be used by implementations that provide debugging or inspection affordances for streams of OpenPGP packets.",
      "ja": "「Shorthand」列のラベルは、このドキュメントの他の場所でコンパクトリファレンスに使用されます。また、OpenPGPパケットのストリームにデバッグまたは検査アフォーダンスを提供する実装によっても使用される場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1. Public Key Encrypted Session Key Packet (Type ID 1)",
      "section_title": true,
      "ja": "5.1. 公開キー暗号化セッションキーパケット（タイプID 1）"
    },
    {
      "indent": 3,
      "text": "Zero or more PKESK packets and/or SKESK packets (Section 5.3) precede an encryption container (that is, a Symmetrically Encrypted and Integrity Protected Data (SEIPD) packet or -- for historic data -- a Symmetrically Encrypted Data (SED) packet), which holds an Encrypted Message. The message is encrypted with the session key, and the session key is itself encrypted and stored in the Encrypted Session Key packet(s). The encryption container is preceded by one Public Key Encrypted Session Key packet for each OpenPGP Key to which the message is encrypted. The recipient of the message finds a session key that is encrypted to their public key, decrypts the session key, and then uses the session key to decrypt the message.",
      "ja": "ゼロ以上のPKSEKパケットおよび/またはSkeskパケット（セクション5.3）は、暗号化コンテナ（つまり、対称的に暗号化された整合性保護データ（SEIPD）パケットまたは - 履歴データの場合 - 対称的に暗号化されたデータ（SED）パケット）の前にあります。、暗号化されたメッセージを保持します。メッセージはセッションキーで暗号化され、セッションキーはそれ自体が暗号化され、暗号化されたセッションキーパケットに保存されます。暗号化コンテナの前には、メッセージが暗号化されているOpenPGPキーごとに1つの公開キー暗号化されたセッションキーパケットがあります。メッセージの受信者は、公開キーに暗号化され、セッションキーを復号化し、セッションキーを使用してメッセージを復号化するセッションキーを見つけます。"
    },
    {
      "indent": 3,
      "text": "The body of this packet starts with a 1-octet number giving the version number of the packet type. The currently defined versions are 3 and 6. The remainder of the packet depends on the version.",
      "ja": "このパケットの本体は、パケットタイプのバージョン番号を与える1オクテット番号から始まります。現在定義されているバージョンは3と6です。パケットの残りの部分はバージョンに依存します。"
    },
    {
      "indent": 3,
      "text": "The versions differ in how they identify the recipient key and in what they encode. The version of the PKESK packet must align with the version of the SEIPD packet (see Section 10.3.2.1). Any new version of the PKESK packet should be registered in the registry established in Section 10.3.2.1.",
      "ja": "バージョンは、受信者キーの識別方法とエンコードの内容が異なります。PKSEKパケットのバージョンは、SEIPDパケットのバージョンと一致する必要があります（セクション10.3.2.1を参照）。PKSEKパケットの新しいバージョンは、セクション10.3.2.1で確立されたレジストリに登録する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Version 3 Public Key Encrypted Session Key Packet Format",
      "section_title": true,
      "ja": "5.1.1. バージョン3公開キー暗号化セッションキーパケット形式"
    },
    {
      "indent": 3,
      "text": "A version 3 PKESK packet precedes a v1 SEIPD packet (see Section 5.13.1). In historic data, it is sometimes found preceding a deprecated SED packet; see Section 5.7. A v3 PKESK packet MUST NOT precede a v2 SEIPD packet (see Section 10.3.2.1).",
      "ja": "バージョン3のPKSEKパケットは、V1 SEIPDパケットの前にあります（セクション5.13.1を参照）。歴史的なデータでは、非推奨のSEDパケットの前にあることがあります。セクション5.7を参照してください。V3 PKSEKパケットは、V2 SEIPDパケットの前にしてはなりません（セクション10.3.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The v3 PKESK packet consists of:",
      "ja": "V3 PKSEKパケットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number with value 3.",
      "ja": "* 値3の1-OCTETバージョン番号。"
    },
    {
      "indent": 6,
      "text": "* An 8-octet number that gives the Key ID of the public key to which the session key is encrypted. If the session key is encrypted to a subkey, then the Key ID of this subkey is used here instead of the Key ID of the primary key. The Key ID may also be all zeros, for an \"anonymous recipient\" (see Section 5.1.8).",
      "ja": "* セッションキーが暗号化されている公開キーのキーIDを与える8オクテット番号。セッションキーがサブキーに暗号化されている場合、このサブキーのキーIDは、プライマリキーのキーIDの代わりにここで使用されます。キーIDは、「匿名の受信者」のすべてのゼロでもあります（セクション5.1.8を参照）。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number giving the public key algorithm used.",
      "ja": "* 使用されている公開キーアルゴリズムを与える1オクターンの番号。"
    },
    {
      "indent": 6,
      "text": "* A series of values comprising the encrypted session key. This is algorithm specific and described below.",
      "ja": "* 暗号化されたセッションキーを含む一連の値。これはアルゴリズム固有であり、以下で説明します。"
    },
    {
      "indent": 3,
      "text": "The public key encryption algorithm (described in subsequent sections) is passed two values:",
      "ja": "公開キー暗号化アルゴリズム（後続のセクションで説明）は、2つの値に渡されます。"
    },
    {
      "indent": 6,
      "text": "* The session key.",
      "ja": "* セッションキー。"
    },
    {
      "indent": 6,
      "text": "* The 1-octet algorithm identifier that specifies the symmetric key encryption algorithm used to encrypt the v1 SEIPD packet described in the following section.",
      "ja": "* 次のセクションで説明するV1 SEIPDパケットを暗号化するために使用される対称キー暗号化アルゴリズムを指定する1-OCTETアルゴリズム識別子。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Version 6 Public Key Encrypted Session Key Packet Format",
      "section_title": true,
      "ja": "5.1.2. バージョン6公開キー暗号化セッションキーパケット形式"
    },
    {
      "indent": 3,
      "text": "A v6 PKESK packet precedes a v2 SEIPD packet (see Section 5.13.2). A v6 PKESK packet MUST NOT precede a v1 SEIPD packet or a deprecated SED packet (see Section 10.3.2.1).",
      "ja": "V6 PKSEKパケットは、V2 SEIPDパケットの前にあります（セクション5.13.2を参照）。V6 PKSEKパケットは、V1 SEIPDパケットまたは非推奨のSEDパケットの前にしてはなりません（セクション10.3.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The v6 PKESK packet consists of the following fields:",
      "ja": "V6 PKSEKパケットは、次のフィールドで構成されています。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number with value 6.",
      "ja": "* 値6の1-OCTETバージョン番号。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet size of the following two fields. This size may be zero, if the key version number field and the fingerprint field are omitted for an \"anonymous recipient\" (see Section 5.1.8).",
      "ja": "* 次の2つのフィールドの1-OCTETサイズ。キーバージョン番号フィールドと指紋フィールドが「匿名の受信者」に対して省略されている場合、このサイズはゼロになる場合があります（セクション5.1.8を参照）。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet key version number.",
      "ja": "* 1-OCTETキーバージョン番号。"
    },
    {
      "indent": 6,
      "text": "* The fingerprint of the public key or subkey to which the session key is encrypted. Note that the length N of the fingerprint for a version 4 key is 20 octets; for a version 6 key, N is 32.",
      "ja": "* セッションキーが暗号化されている公開キーまたはサブキーの指紋。バージョン4キーの指紋の長さNは20オクテットであることに注意してください。バージョン6キーの場合、nは32です。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number giving the public key algorithm used.",
      "ja": "* 使用されている公開キーアルゴリズムを与える1オクターンの番号。"
    },
    {
      "indent": 6,
      "text": "* A series of values comprising the encrypted session key. This is algorithm specific and described below.",
      "ja": "* 暗号化されたセッションキーを含む一連の値。これはアルゴリズム固有であり、以下で説明します。"
    },
    {
      "indent": 3,
      "text": "The session key is encrypted according to the public key algorithm used, as described below. No symmetric key encryption algorithm identifier is passed to the public key algorithm for a v6 PKESK packet, as it is included in the v2 SEIPD packet.",
      "ja": "セッションキーは、以下で説明するように、使用される公開キーアルゴリズムに従って暗号化されます。V2 SEIPDパケットに含まれているため、対称キー暗号化アルゴリズム識別子は、V6 PKSEKパケットの公開キーアルゴリズムに渡されません。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Algorithm-Specific Fields for RSA Encryption",
      "section_title": true,
      "ja": "5.1.3. RSA暗号化のためのアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* MPI of RSA-encrypted value m^e mod n.",
      "ja": "* RSA暗号化値m^e mod nのMPI。"
    },
    {
      "indent": 3,
      "text": "To produce the value \"m\" in the above formula, first concatenate the following values:",
      "ja": "上記の式で値「m」を生成するには、最初に次の値を連結します。"
    },
    {
      "indent": 6,
      "text": "* The 1-octet algorithm identifier, if it was passed (in the case of a v3 PKESK packet).",
      "ja": "* 1-OCTETアルゴリズム識別子は、渡された場合（V3 PKSKパケットの場合）。"
    },
    {
      "indent": 6,
      "text": "* The session key.",
      "ja": "* セッションキー。"
    },
    {
      "indent": 6,
      "text": "* A 2-octet checksum of the session key, equal to the sum of the session key octets, modulo 65536.",
      "ja": "* セッションキーの2オクテットチェックサム、セッションキーオクテットの合計、Modulo 65536。"
    },
    {
      "indent": 3,
      "text": "Then, the above values are encoded using the PKCS#1 block encoding EME-PKCS1-v1_5, as described in Step 2 in Section 7.2.1 of [RFC8017] (see also Section 12.1.1). When decoding \"m\" during decryption, an implementation should follow Step 3 in Section 7.2.2 of [RFC8017] (see also Section 12.1.2).",
      "ja": "次に、上記の値は、[RFC8017]のセクション7.2.1のステップ2で説明されているように、EME-PKCS1-V1_5をエンコードするPKCS＃1ブロックを使用してエンコードされます（セクション12.1.1も参照）。復号化中に「M」を解読する場合、実装は[RFC8017]のセクション7.2.2のステップ3に従う必要があります（セクション12.1.2も参照）。"
    },
    {
      "indent": 3,
      "text": "Note that when an implementation forms several PKESK packets with one session key, forming a message that can be decrypted by several keys, the implementation MUST make a new PKCS#1 encoding for each key. This defends against attacks such as those discussed in [HASTAD].",
      "ja": "実装が1つのセッションキーを備えたいくつかのPKSEKパケットを形成し、複数のキーで復号化できるメッセージを形成する場合、実装は各キーの新しいPKCS＃1エンコードを作成する必要があることに注意してください。これは、[Hastad]で議論されているような攻撃から擁護します。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Algorithm-Specific Fields for Elgamal Encryption",
      "section_title": true,
      "ja": "5.1.4. エルガマル暗号化のためのアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* MPI of Elgamal (Diffie-Hellman) value g^k mod p.",
      "ja": "* エルガマル（diffie-hellman）値G^k mod pのmpi。"
    },
    {
      "indent": 6,
      "text": "* MPI of Elgamal (Diffie-Hellman) value m * y^k mod p.",
      "ja": "* Elgamal（diffie-hellman）価値のmpi m * y^k mod p。"
    },
    {
      "indent": 3,
      "text": "To produce the value \"m\" in the above formula, first concatenate the following values:",
      "ja": "上記の式で値「m」を生成するには、最初に次の値を連結します。"
    },
    {
      "indent": 6,
      "text": "* The 1-octet algorithm identifier, if it was passed (in the case of a v3 PKESK packet).",
      "ja": "* 1-OCTETアルゴリズム識別子は、渡された場合（V3 PKSKパケットの場合）。"
    },
    {
      "indent": 6,
      "text": "* The session key.",
      "ja": "* セッションキー。"
    },
    {
      "indent": 6,
      "text": "* A 2-octet checksum of the session key, equal to the sum of the session key octets, modulo 65536.",
      "ja": "* セッションキーの2オクテットチェックサム、セッションキーオクテットの合計、Modulo 65536。"
    },
    {
      "indent": 3,
      "text": "Then, the above values are encoded using the PKCS#1 block encoding EME-PKCS1-v1_5, as described in Step 2 in Section 7.2.1 of [RFC8017] (see also Section 12.1.1). When decoding \"m\" during decryption, an implementation should follow Step 3 in Section 7.2.2 of [RFC8017] (see also Section 12.1.2).",
      "ja": "次に、上記の値は、[RFC8017]のセクション7.2.1のステップ2で説明されているように、EME-PKCS1-V1_5をエンコードするPKCS＃1ブロックを使用してエンコードされます（セクション12.1.1も参照）。復号化中に「M」を解読する場合、実装は[RFC8017]のセクション7.2.2のステップ3に従う必要があります（セクション12.1.2も参照）。"
    },
    {
      "indent": 3,
      "text": "Note that when an implementation forms several PKESK packets with one session key, forming a message that can be decrypted by several keys, the implementation MUST make a new PKCS#1 encoding for each key. This defends against attacks such as those discussed in [HASTAD].",
      "ja": "実装が1つのセッションキーを備えたいくつかのPKSEKパケットを形成し、複数のキーで復号化できるメッセージを形成する場合、実装は各キーの新しいPKCS＃1エンコードを作成する必要があることに注意してください。これは、[Hastad]で議論されているような攻撃から擁護します。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT generate ElGamal v6 PKESK packets.",
      "ja": "実装では、Elgamal V6 PKSEKパケットを生成してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.5. Algorithm-Specific Fields for ECDH Encryption",
      "section_title": true,
      "ja": "5.1.5. ECDH暗号化のためのアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* MPI of an EC point representing an ephemeral public key in the point format associated with the curve as specified in Section 9.2.",
      "ja": "* セクション9.2で指定されているように、曲線に関連付けられたポイント形式の短命鍵を表すECポイントのMPI。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet size, followed by a symmetric key encoded using the method described in Section 11.5.",
      "ja": "* 1-OCTETサイズ、セクション11.5で説明されているメソッドを使用してエンコードされた対称キーが続きます。"
    },
    {
      "indent": 0,
      "text": "5.1.6. Algorithm-Specific Fields for X25519 Encryption",
      "section_title": true,
      "ja": "5.1.6. x25519暗号化のためのアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* 32 octets representing an ephemeral X25519 public key.",
      "ja": "* 一時的なX25519公開キーを表す32オクテット。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet size of the following fields.",
      "ja": "* 次のフィールドの1-OCTETサイズ。"
    },
    {
      "indent": 6,
      "text": "* The 1-octet algorithm identifier, if it was passed (in the case of a v3 PKESK packet).",
      "ja": "* 1-OCTETアルゴリズム識別子は、渡された場合（V3 PKSKパケットの場合）。"
    },
    {
      "indent": 6,
      "text": "* The encrypted session key.",
      "ja": "* 暗号化されたセッションキー。"
    },
    {
      "indent": 3,
      "text": "See Section 6.1 of [RFC7748] for more details on the computation of the ephemeral public key and the shared secret. The HMAC-based Key Derivation Function (HKDF) [RFC5869] is then used with SHA256 [RFC6234] and an info parameter of \"OpenPGP X25519\" and no salt. The input of HKDF is the concatenation of the following three values:",
      "ja": "はかなか公開鍵と共有秘密の計算の詳細については、[RFC7748]のセクション6.1を参照してください。HMACベースのキー導出関数（HKDF）[RFC5869]は、SHA256 [RFC6234]と「OpenPGP X25519」の情報パラメーターと塩の情報パラメーターで使用されます。HKDFの入力は、次の3つの値の連結です。"
    },
    {
      "indent": 6,
      "text": "* 32 octets of the ephemeral X25519 public key from this packet.",
      "ja": "* このパケットからのはか一方のx25519公開鍵の32オクテット。"
    },
    {
      "indent": 6,
      "text": "* 32 octets of the recipient public key material.",
      "ja": "* 受信者の公開鍵の32オクテット。"
    },
    {
      "indent": 6,
      "text": "* 32 octets of the shared secret.",
      "ja": "* 共有された秘密の32オクテット。"
    },
    {
      "indent": 3,
      "text": "The key produced from HKDF is used to encrypt the session key with AES-128 key wrap, as defined in [RFC3394].",
      "ja": "HKDFから生成されたキーは、[RFC3394]で定義されているように、AES-128キーラップでセッションキーを暗号化するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Note that unlike Elliptic Curve Diffie-Hellman (ECDH), no checksum or padding are appended to the session key before key wrapping. Finally, note that unlike the other public key algorithms, in the case of a v3 PKESK packet, the symmetric algorithm ID is not encrypted. Instead, it is prepended to the encrypted session key in plaintext. In this case, the symmetric algorithm used MUST be AES-128, AES-192, or AES-256 (algorithm IDs 7, 8, or 9, respectively).",
      "ja": "楕円曲線diffie-hellman（ECDH）とは異なり、キーラッピング前にセッションキーにチェックサムやパディングは追加されないことに注意してください。最後に、V3 PKSEKパケットの場合、他の公開キーアルゴリズムとは異なり、対称アルゴリズムIDは暗号化されていないことに注意してください。代わりに、プレーンテキストの暗号化されたセッションキーに加えられます。この場合、使用される対称アルゴリズムは、AES-128、AES-192、またはAES-256（それぞれアルゴリズムIDS 7、8、または9）でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.7. Algorithm-Specific Fields for X448 Encryption",
      "section_title": true,
      "ja": "5.1.7. x448暗号化のためのアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* 56 octets representing an ephemeral X448 public key.",
      "ja": "* 一時的なX448公開キーを表す56オクテット。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet size of the following fields.",
      "ja": "* 次のフィールドの1-OCTETサイズ。"
    },
    {
      "indent": 6,
      "text": "* The 1-octet algorithm identifier, if it was passed (in the case of a v3 PKESK packet).",
      "ja": "* 1-OCTETアルゴリズム識別子は、渡された場合（V3 PKSKパケットの場合）。"
    },
    {
      "indent": 6,
      "text": "* The encrypted session key.",
      "ja": "* 暗号化されたセッションキー。"
    },
    {
      "indent": 3,
      "text": "See Section 6.2 of [RFC7748] for more details on the computation of the ephemeral public key and the shared secret. HKDF [RFC5869] is then used with SHA512 [RFC6234] and an info parameter of \"OpenPGP X448\" and no salt. The input of HKDF is the concatenation of the following three values:",
      "ja": "はかなか公開鍵と共有秘密の計算の詳細については、[RFC7748]のセクション6.2を参照してください。HKDF [RFC5869]は、SHA512 [RFC6234]と「OpenPGP X448」の情報パラメーターと塩の情報パラメーターで使用されます。HKDFの入力は、次の3つの値の連結です。"
    },
    {
      "indent": 6,
      "text": "* 56 octets of the ephemeral X448 public key from this packet.",
      "ja": "* このパケットからのはかないx448公開キーの56オクテット。"
    },
    {
      "indent": 6,
      "text": "* 56 octets of the recipient public key material.",
      "ja": "* 受信者の公開キー資料の56オクテット。"
    },
    {
      "indent": 6,
      "text": "* 56 octets of the shared secret.",
      "ja": "* 共有された秘密の56オクテット。"
    },
    {
      "indent": 3,
      "text": "The key produced from HKDF is used to encrypt the session key with AES-256 key wrap, as defined in [RFC3394].",
      "ja": "HKDFから生成されたキーは、[RFC3394]で定義されているように、AES-256キーラップでセッションキーを暗号化するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Note that unlike ECDH, no checksum or padding are appended to the session key before key wrapping. Finally, note that unlike the other public key algorithms, in the case of a v3 PKESK packet, the symmetric algorithm ID is not encrypted. Instead, it is prepended to the encrypted session key in plaintext. In this case, the symmetric algorithm used MUST be AES-128, AES-192, or AES-256 (algorithm ID 7, 8, or 9).",
      "ja": "ECDHとは異なり、キーラッピングの前にセッションキーにチェックサムやパディングが追加されないことに注意してください。最後に、V3 PKSEKパケットの場合、他の公開キーアルゴリズムとは異なり、対称アルゴリズムIDは暗号化されていないことに注意してください。代わりに、プレーンテキストの暗号化されたセッションキーに加えられます。この場合、使用される対称アルゴリズムは、AES-128、AES-192、またはAES-256（アルゴリズムID 7、8、または9）でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.8. Notes on PKESK",
      "section_title": true,
      "ja": "5.1.8. Pkeskに関するメモ"
    },
    {
      "indent": 3,
      "text": "An implementation MAY accept or use a Key ID of all zeros, or an omitted key fingerprint, to hide the intended decryption key. In this case, the receiving implementation would try all available private keys, checking for a valid decrypted session key. This format helps reduce traffic analysis of messages.",
      "ja": "実装は、すべてのゼロのキーIDまたは省略されたキー指紋を受け入れるか使用して、意図した復号化キーを隠すことができます。この場合、実装を受信すると、利用可能なすべてのプライベートキーを試し、有効な復号化されたセッションキーをチェックします。この形式は、メッセージのトラフィック分析を減らすのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "5.2. Signature Packet (Type ID 2)",
      "section_title": true,
      "ja": "5.2. 署名パケット（タイプID 2）"
    },
    {
      "indent": 3,
      "text": "A Signature packet describes a binding between some public key and some data. The most common signatures are a signature of a file or a block of text and a signature that is a certification of a User ID.",
      "ja": "署名パケットは、一部の公開キーといくつかのデータの間のバインディングを説明します。最も一般的な署名は、ファイルまたはテキストのブロックの署名と、ユーザーIDの認証である署名です。"
    },
    {
      "indent": 3,
      "text": "Three versions of Signature packets are defined. Version 3 provides basic signature information, while versions 4 and 6 provide an expandable format with subpackets that can specify more information about the signature.",
      "ja": "署名パケットの3つのバージョンが定義されています。バージョン3には基本的な署名情報が提供され、バージョン4と6は、署名に関する詳細情報を指定できるサブパケットを備えた拡張可能な形式を提供します。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, versions 1, 2, and 5 of the Signature packet are unspecified. Any new Signature packet version should be registered in the registry established in Section 10.3.2.2.",
      "ja": "歴史的な理由から、署名パケットのバージョン1、2、および5は不特定です。新しい署名パケットバージョンは、セクション10.3.2.2で確立されたレジストリに登録する必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST generate a version 6 signature when signing with a version 6 key. An implementation MUST generate a version 4 signature when signing with a version 4 key. Implementations MUST NOT create version 3 signatures; they MAY accept version 3 signatures. See Section 10.3.2.2 for more details about packet version correspondence between keys and signatures.",
      "ja": "実装は、バージョン6キーに署名するときにバージョン6の署名を生成する必要があります。実装は、バージョン4キーに署名するときにバージョン4の署名を生成する必要があります。実装は、バージョン3の署名を作成してはなりません。バージョン3の署名を受け入れる場合があります。キーと署名の間のパケットバージョンの対応の詳細については、セクション10.3.2.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Signature Types",
      "section_title": true,
      "ja": "5.2.1. 署名タイプ"
    },
    {
      "indent": 3,
      "text": "There are a number of possible meanings for a signature, which are indicated by the Signature Type ID in any given signature. Please note that the vagueness of these meanings is not a flaw but rather a feature of the system. Because OpenPGP places final authority for validity upon the receiver of a signature, it may be that one signer's casual act might be more rigorous than some other authority's positive act. See Section 5.2.4 for detailed information on how to compute and verify signatures of each type.",
      "ja": "特定の署名の署名タイプIDで示される署名には、多くの可能な意味があります。これらの意味のあいまいさは欠陥ではなく、システムの特徴であることに注意してください。OpenPGPは、署名の受信者に有効性の最終的な権限を置いているため、1つの署名者のカジュアルな行為は、他の権限の肯定的な行為よりも厳密である可能性があります。各タイプの署名を計算および検証する方法の詳細については、セクション5.2.4を参照してください。"
    },
    {
      "indent": 5,
      "text": "+======+====================================+==================+\n| ID   | Name                               | Reference        |\n+======+====================================+==================+\n| 0x00 | Binary Signature                   | Section 5.2.1.1  |\n+------+------------------------------------+------------------+\n| 0x01 | Text Signature                     | Section 5.2.1.2  |\n+------+------------------------------------+------------------+\n| 0x02 | Standalone Signature               | Section 5.2.1.3  |\n+------+------------------------------------+------------------+\n| 0x10 | Generic Certification Signature    | Section 5.2.1.4  |\n+------+------------------------------------+------------------+\n| 0x11 | Persona Certification Signature    | Section 5.2.1.5  |\n+------+------------------------------------+------------------+\n| 0x12 | Casual Certification Signature     | Section 5.2.1.6  |\n+------+------------------------------------+------------------+\n| 0x13 | Positive Certification Signature   | Section 5.2.1.7  |\n+------+------------------------------------+------------------+\n| 0x18 | Subkey Binding Signature           | Section 5.2.1.8  |\n+------+------------------------------------+------------------+\n| 0x19 | Primary Key Binding Signature      | Section 5.2.1.9  |\n+------+------------------------------------+------------------+\n| 0x1F | Direct Key Signature               | Section 5.2.1.10 |\n+------+------------------------------------+------------------+\n| 0x20 | Key Revocation Signature           | Section 5.2.1.11 |\n+------+------------------------------------+------------------+\n| 0x28 | Subkey Revocation Signature        | Section 5.2.1.12 |\n+------+------------------------------------+------------------+\n| 0x30 | Certification Revocation Signature | Section 5.2.1.13 |\n+------+------------------------------------+------------------+\n| 0x40 | Timestamp Signature                | Section 5.2.1.14 |\n+------+------------------------------------+------------------+\n| 0x50 | Third-Party Confirmation Signature | Section 5.2.1.15 |\n+------+------------------------------------+------------------+\n| 0xFF | Reserved                           | Section 5.2.1.16 |\n+------+------------------------------------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 4: OpenPGP Signature Types Registry",
      "ja": "表4：OpenPGP署名タイプレジストリ"
    },
    {
      "indent": 3,
      "text": "The meanings of each signature type are described in the subsections below.",
      "ja": "各署名タイプの意味は、以下のサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Binary Signature (Type ID 0x00) of a Document",
      "section_title": true,
      "ja": "5.2.1.1. ドキュメントのバイナリ署名（タイプID 0x00）"
    },
    {
      "indent": 3,
      "text": "This means the signer owns it, created it, or certifies that it has not been modified.",
      "ja": "これは、署名者がそれを所有し、作成した、または変更されていないことを証明することを意味します。"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. Text Signature (Type ID 0x01) of a Canonical Document",
      "section_title": true,
      "ja": "5.2.1.2. 標準文書のテキスト署名（タイプID 0x01）"
    },
    {
      "indent": 3,
      "text": "This means the signer owns it, created it, or certifies that it has not been modified. The signature is calculated over the text data with its line endings converted to <CR><LF>.",
      "ja": "これは、署名者がそれを所有し、作成した、または変更されていないことを証明することを意味します。署名は、<cr> <lf>に変換されたラインエンディングを使用して、テキストデータに対して計算されます。"
    },
    {
      "indent": 0,
      "text": "5.2.1.3. Standalone Signature (Type ID 0x02)",
      "section_title": true,
      "ja": "5.2.1.3. スタンドアロンの署名（タイプID 0x02）"
    },
    {
      "indent": 3,
      "text": "This signature is a signature of only its own subpacket contents. It is calculated identically to a signature over a zero-length binary document. Version 3 Standalone signatures MUST NOT be generated and MUST be ignored.",
      "ja": "この署名は、独自のサブパケットコンテンツのみの署名です。ゼロ長のバイナリドキュメント上の署名と同じように計算されます。バージョン3スタンドアロンの署名は生成されず、無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1.4. Generic Certification Signature (Type ID 0x10) of a User ID and Public Key Packet",
      "section_title": true,
      "ja": "5.2.1.4. ユーザーIDおよび公開キーパケットの汎用認定署名（タイプID 0x10）"
    },
    {
      "indent": 3,
      "text": "The issuer of this certification does not make any particular assertion as to how well the certifier has checked that the owner of the key is in fact the person described by the User ID.",
      "ja": "この認定の発行者は、認証者がキーの所有者が実際にユーザーIDで説明されている人であることを認証者がどの程度チェックしたかについて特別な主張をしません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.5. Persona Certification Signature (Type ID 0x11) of a User ID and Public Key Packet",
      "section_title": true,
      "ja": "5.2.1.5. ユーザーIDおよび公開キーパケットのペルソナ認定署名（タイプID 0x11）"
    },
    {
      "indent": 3,
      "text": "The issuer of this certification has not done any verification of the claim that the owner of this key is the User ID specified.",
      "ja": "この認定の発行者は、このキーの所有者が指定されたユーザーIDであるという請求の検証を行っていません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.6. Casual Certification Signature (Type ID 0x12) of a User ID and Public Key Packet",
      "section_title": true,
      "ja": "5.2.1.6. ユーザーIDおよび公開キーパケットのカジュアル認証署名（タイプID 0x12）"
    },
    {
      "indent": 3,
      "text": "The issuer of this certification has done some casual verification of the claim of identity.",
      "ja": "この認定の発行者は、アイデンティティの請求の偶然の検証を行っています。"
    },
    {
      "indent": 0,
      "text": "5.2.1.7. Positive Certification Signature (Type ID 0x13) of a User ID and Public Key Packet",
      "section_title": true,
      "ja": "5.2.1.7. ユーザーIDおよび公開キーパケットの肯定的な認証署名（タイプID 0x13）"
    },
    {
      "indent": 3,
      "text": "The issuer of this certification has done substantial verification of the claim of identity.",
      "ja": "この認定の発行者は、アイデンティティの請求の実質的な検証を行っています。"
    },
    {
      "indent": 3,
      "text": "Most OpenPGP implementations make their \"key signatures\" as generic (Type ID 0x10) certifications. Some implementations can issue 0x11-0x13 certifications, but few differentiate between the types.",
      "ja": "ほとんどのOpenPGP実装は、「キーシグネチャ」を一般的な（タイプID 0x10）認定として作成します。一部の実装では、0x11-0x13認定を発行できますが、タイプを区別するものはほとんどありません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.8. Subkey Binding Signature (Type ID 0x18)",
      "section_title": true,
      "ja": "5.2.1.8. サブキーバインディングシグネチャ（タイプID 0x18）"
    },
    {
      "indent": 3,
      "text": "This signature is a statement by the top-level signing key, indicating that it owns the subkey. This signature is calculated directly on the primary key and subkey, and not on any User ID or other packets. A signature that binds a signing subkey MUST have an Embedded Signature subpacket in this binding signature that contains a 0x19 signature made by the signing subkey on the primary key and subkey.",
      "ja": "この署名は、トップレベルの署名キーによる声明であり、サブキーを所有していることを示しています。この署名は、ユーザーIDやその他のパケットではなく、プライマリキーとサブキーで直接計算されます。署名サブキーをバインドする署名には、このバインディング署名に埋め込まれた署名サブパケットが必要です。この署名には、主要なキーとサブキーに署名サブキーが作成した0x19の署名が含まれています。"
    },
    {
      "indent": 0,
      "text": "5.2.1.9. Primary Key Binding Signature (Type ID 0x19)",
      "section_title": true,
      "ja": "5.2.1.9. 主キーバインディングシグネチャ（タイプID 0x19）"
    },
    {
      "indent": 3,
      "text": "This signature is a statement by a signing subkey, indicating that it is owned by the primary key. This signature is calculated the same way as a Subkey Binding signature (Type ID 0x18): directly on the primary key and subkey, and not on any User ID or other packets.",
      "ja": "この署名は、署名サブキーによる声明であり、主キーが所有していることを示しています。この署名は、サブキーバインディング署名（タイプID 0x18）と同じ方法で計算されます。これは、ユーザーIDやその他のパケットではなく、プライマリキーとサブキーに直接。"
    },
    {
      "indent": 0,
      "text": "5.2.1.10. Direct Key Signature (Type ID 0x1F)",
      "section_title": true,
      "ja": "5.2.1.10. 直接キー署名（タイプID 0x1F）"
    },
    {
      "indent": 3,
      "text": "This signature is calculated directly on a key. It binds the information in the Signature subpackets to the key and is appropriate to be used for subpackets that provide information about the key, such as the Key Flags subpacket or the (deprecated) Revocation Key subpacket. It is also appropriate for statements that non-self certifiers want to make about the key itself rather than the binding between a key and a name.",
      "ja": "この署名は、キーで直接計算されます。署名サブパケット内の情報をキーにバインドし、キーフラグサブパケットや（廃止された）失効キーサブパケットなど、キーに関する情報を提供するサブパケットに使用するのに適しています。また、非自己証明書者がキーと名前の間のバインディングではなく、キー自体について作りたいという声明にも適しています。"
    },
    {
      "indent": 0,
      "text": "5.2.1.11. Key Revocation Signature (Type ID 0x20)",
      "section_title": true,
      "ja": "5.2.1.11. キー取消し署名（タイプID 0x20）"
    },
    {
      "indent": 3,
      "text": "This signature is calculated directly on the key being revoked. A revoked key is not to be used. Only Revocation Signatures by the key being revoked, or by a (deprecated) Revocation Key, should be considered valid Revocation Signatures.",
      "ja": "この署名は、取り消されるキーで直接計算されます。取り消されたキーは使用されません。取り消されるキーによる失効署名のみ、または（非推奨）失効キーによるものは、有効な取り消し署名と見なされるべきです。"
    },
    {
      "indent": 0,
      "text": "5.2.1.12. Subkey Revocation Signature (Type ID 0x28)",
      "section_title": true,
      "ja": "5.2.1.12. サブキーの取り消し署名（タイプID 0x28）"
    },
    {
      "indent": 3,
      "text": "This signature is calculated directly on the primary key and the subkey being revoked. A revoked subkey is not to be used. Only Revocation Signatures by the top-level signature key that is bound to this subkey, or by a (deprecated) Revocation Key, should be considered valid Revocation Signatures.",
      "ja": "この署名は、プライマリキーで直接計算され、サブキーが取り消されます。取り消されたサブキーは使用されません。このサブキーに縛られているトップレベルの署名キーまたは（控除された）取り消しキーによってのみ取り消し署名は、有効な取り消し署名と見なされるべきです。"
    },
    {
      "indent": 0,
      "text": "5.2.1.13. Certification Revocation Signature (Type ID 0x30)",
      "section_title": true,
      "ja": "5.2.1.13. 認証撤回署名（タイプID 0x30）"
    },
    {
      "indent": 3,
      "text": "This signature revokes an earlier User ID certification signature (Type IDs 0x10 through 0x13) or Direct Key signature (Type ID 0x1F). It should be issued by the same key that issued the revoked signature or by a (deprecated) Revocation Key. The signature is computed over the same data as the certification that it revokes, and it should have a later creation date than that certification.",
      "ja": "この署名は、以前のユーザーID認定署名（タイプ0x10〜0x13）または直接キー署名（タイプID 0x1F）を取り消します。それは、取り消された署名を発行したのと同じキーまたは（非推奨）失効キーによって発行されるべきです。署名は、それが取り消す認定と同じデータで計算され、その認証よりも後の作成日が必要です。"
    },
    {
      "indent": 0,
      "text": "5.2.1.14. Timestamp Signature (Type ID 0x40)",
      "section_title": true,
      "ja": "5.2.1.14. タイムスタンプの署名（タイプID 0x40）"
    },
    {
      "indent": 3,
      "text": "This signature is only meaningful for the timestamp contained in it.",
      "ja": "この署名は、その中に含まれるタイムスタンプにとってのみ意味があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1.15. Third-Party Confirmation Signature (Type ID 0x50)",
      "section_title": true,
      "ja": "5.2.1.15. サードパーティの確認署名（タイプID 0x50）"
    },
    {
      "indent": 3,
      "text": "This signature is a signature over another OpenPGP Signature packet. It is analogous to a notary seal on the signed data. A Third-Party Confirmation signature SHOULD include a Signature Target subpacket that identifies the confirmed signature.",
      "ja": "この署名は、別のOpenPGP署名パケットの署名です。これは、署名されたデータの公証シールに類似しています。サードパーティの確認署名には、確認された署名を識別する署名ターゲットサブパケットを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1.16. Reserved (Type ID 0xFF)",
      "section_title": true,
      "ja": "5.2.1.16. 予約済み（タイプID 0xff）"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT create any signature with this type and MUST NOT validate any signature made with this type. See Section 5.2.4.1 for more details.",
      "ja": "実装は、このタイプで署名を作成してはならず、このタイプで作成された署名を検証してはなりません。詳細については、セクション5.2.4.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Version 3 Signature Packet Format",
      "section_title": true,
      "ja": "5.2.2. バージョン3署名パケット形式"
    },
    {
      "indent": 3,
      "text": "The body of a version 3 Signature packet contains:",
      "ja": "バージョン3の署名パケットの本文には以下が含まれています。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number with value 3.",
      "ja": "* 値3の1-OCTETバージョン番号。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet length of the following hashed material; it MUST be 5:",
      "ja": "* 次のハッシュされた材料の1-OCTETの長さ。それは5でなければなりません："
    },
    {
      "indent": 12,
      "text": "- A 1-octet Signature Type ID.",
      "ja": "- 1-OCTET署名タイプID。"
    },
    {
      "indent": 12,
      "text": "- A 4-octet creation time.",
      "ja": "- 4-OCTET作成時間。"
    },
    {
      "indent": 6,
      "text": "* An 8-octet Key ID of the signer.",
      "ja": "* 署名者の8オクテットキーID。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet public key algorithm.",
      "ja": "* 1-OCTET公開キーアルゴリズム。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet hash algorithm.",
      "ja": "* 1-OCTETハッシュアルゴリズム。"
    },
    {
      "indent": 6,
      "text": "* A 2-octet field holding left 16 bits of the signed hash value.",
      "ja": "* 署名されたハッシュ値の16ビットを左に保持している2-OCTETフィールド。"
    },
    {
      "indent": 6,
      "text": "* One or more MPIs comprising the signature. This portion is algorithm specific, as described below.",
      "ja": "* 署名を含む1つ以上のMPI。この部分は、以下で説明するように、アルゴリズム固有です。"
    },
    {
      "indent": 3,
      "text": "The concatenation of the data to be signed, the signature type, and the creation time from the Signature packet (5 additional octets) is hashed. The resulting hash value is used in the signature algorithm. The high 16 bits (first two octets) of the hash are included in the Signature packet to provide a way to reject some invalid signatures without performing a signature verification.",
      "ja": "署名されるデータの連結、署名タイプ、および署名パケット（5追加オクテット）からの作成時間はハッシュされます。結果のハッシュ値は、署名アルゴリズムで使用されます。ハッシュのハイ16ビット（最初の2オクテット）は、署名パケットに含まれており、署名検証を実行せずにいくつかの無効な署名を拒否する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Algorithm-specific fields for RSA signatures:",
      "ja": "RSA署名のアルゴリズム固有のフィールド："
    },
    {
      "indent": 6,
      "text": "* MPI of RSA signature value m^d mod n.",
      "ja": "* RSA署名値m^d mod nのMPI。"
    },
    {
      "indent": 3,
      "text": "Algorithm-specific fields for DSA signatures:",
      "ja": "DSA署名のアルゴリズム固有のフィールド："
    },
    {
      "indent": 6,
      "text": "* MPI of DSA value r.",
      "ja": "* DSA値rのMPI。"
    },
    {
      "indent": 6,
      "text": "* MPI of DSA value s.",
      "ja": "* DSA値のMPI。"
    },
    {
      "indent": 3,
      "text": "The signature calculation is based on a hash of the signed data, as described above. The details of the calculation are different for DSA signatures than for RSA signatures; see Sections 5.2.3.1 and 5.2.3.2.",
      "ja": "署名計算は、上記のように、署名されたデータのハッシュに基づいています。計算の詳細は、DSA署名の場合はRSA署名とは異なります。セクション5.2.3.1および5.2.3.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Versions 4 and 6 Signature Packet Formats",
      "section_title": true,
      "ja": "5.2.3. バージョン4および6の署名パケット形式"
    },
    {
      "indent": 3,
      "text": "The body of a version 4 or version 6 Signature packet contains:",
      "ja": "バージョン4またはバージョン6の署名パケットの本文には以下が含まれています。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number. This is 4 for version 4 signatures and 6 for version 6 signatures.",
      "ja": "* 1-OCTETバージョン番号。これは、バージョン4の署名の場合は4、バージョン6の署名は6です。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet Signature Type ID.",
      "ja": "* 1-OCTET署名タイプID。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet public key algorithm.",
      "ja": "* 1-OCTET公開キーアルゴリズム。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet hash algorithm.",
      "ja": "* 1-OCTETハッシュアルゴリズム。"
    },
    {
      "indent": 6,
      "text": "* A scalar octet count for the hashed subpacket data that follows this field. For a version 4 signature, this is a 2-octet field. For a version 6 signature, this is a 4-octet field. Note that this is the length in octets of all of the hashed subpackets; an implementation's pointer incremented by this number will skip over the hashed subpackets.",
      "ja": "* このフィールドに続くハッシュされたサブパケットデータのスカラーオクテットカウント。バージョン4の署名の場合、これは2オクテットのフィールドです。バージョン6の署名の場合、これは4オクテットのフィールドです。これは、すべてのハッシュされたサブパケットのオクテットの長さであることに注意してください。この番号によって増加した実装のポインターは、ハッシュされたサブパケットをスキップします。"
    },
    {
      "indent": 6,
      "text": "* A hashed subpacket data set (zero or more subpackets).",
      "ja": "* ハッシュされたサブパケットデータセット（ゼロ以上のサブパケット）。"
    },
    {
      "indent": 6,
      "text": "* A scalar octet count for the unhashed subpacket data that follows this field. For a version 4 signature, this is a 2-octet field. For a version 6 signature, this is a 4-octet field. Note that this is the length in octets of all of the unhashed subpackets; an implementation's pointer incremented by this number will skip over the unhashed subpackets.",
      "ja": "* このフィールドに続く非粉砕されたサブパケットデータのスカラーオクテットカウント。バージョン4の署名の場合、これは2オクテットのフィールドです。バージョン6の署名の場合、これは4オクテットのフィールドです。これは、非粉砕されたサブパケットのすべてのオクテットの長さであることに注意してください。この番号によってインクリメントされた実装のポインターは、非粉砕されたサブパケットをスキップします。"
    },
    {
      "indent": 6,
      "text": "* An unhashed subpacket data set (zero or more subpackets).",
      "ja": "* 非粉砕されたサブパケットデータセット（ゼロ以上のサブパケット）。"
    },
    {
      "indent": 6,
      "text": "* A 2-octet field holding the left 16 bits of the signed hash value.",
      "ja": "* 署名されたハッシュ値の左16ビットを保持している2-OCTETフィールド。"
    },
    {
      "indent": 6,
      "text": "* Only for version 6 signatures, a variable-length field containing:",
      "ja": "* バージョン6の署名の場合のみ、次のような可変長フィールドがあります。"
    },
    {
      "indent": 12,
      "text": "- A 1-octet salt size. The value MUST match the value defined for the hash algorithm as specified in Table 23.",
      "ja": "- 1オクテットの塩のサイズ。値は、表23に指定されているハッシュアルゴリズムの定義された値と一致する必要があります。"
    },
    {
      "indent": 12,
      "text": "- The salt, which is a random value of the specified size.",
      "ja": "- 指定されたサイズのランダムな値である塩。"
    },
    {
      "indent": 6,
      "text": "* One or more MPIs comprising the signature. This portion is algorithm specific.",
      "ja": "* 署名を含む1つ以上のMPI。この部分はアルゴリズム固有です。"
    },
    {
      "indent": 0,
      "text": "5.2.3.1. Algorithm-Specific Fields for RSA Signatures",
      "section_title": true,
      "ja": "5.2.3.1. RSA署名のアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* MPI of RSA signature value m^d mod n.",
      "ja": "* RSA署名値m^d mod nのMPI。"
    },
    {
      "indent": 3,
      "text": "With RSA signatures, the hash value is encoded using PKCS#1 encoding type EMSA-PKCS1-v1_5, as described in Section 9.2 of [RFC8017] (see also Section 12.1.3). This requires inserting the hash value as an octet string into an ASN.1 structure. The object identifier (OID) for the hash algorithm itself is also included in the structure; see the OIDs in Table 24.",
      "ja": "RSA署名を使用すると、[RFC8017]のセクション9.2で説明されているように、ハッシュ値はPKCS＃1エンコードタイプEMSA-PKCS1-V1_5を使用してエンコードされます（セクション12.1.3も参照）。これには、ハッシュ値をオクテット文字列としてasn.1構造に挿入する必要があります。ハッシュアルゴリズム自体のオブジェクト識別子（OID）も構造に含まれています。表24のOIDSを参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3.2. Algorithm-Specific Fields for DSA or ECDSA Signatures",
      "section_title": true,
      "ja": "5.2.3.2. DSAまたはECDSA署名のアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* MPI of DSA or ECDSA value r.",
      "ja": "* DSAまたはECDSA値のMPI r。"
    },
    {
      "indent": 6,
      "text": "* MPI of DSA or ECDSA value s.",
      "ja": "* DSAまたはECDSA値のMPI。"
    },
    {
      "indent": 3,
      "text": "A version 3 signature MUST NOT be created and MUST NOT be used with the Elliptic Curve Digital Signature Algorithm (ECDSA).",
      "ja": "バージョン3の署名は作成されてはならず、Elliptic Curve Digital Signature Algorithm（ECDSA）で使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "A DSA signature MUST use a hash algorithm with a digest size of at least the number of bits of q, the group generated by the DSA key's generator value.",
      "ja": "DSA署名は、DSAキーのジェネレーター値によって生成されるグループであるQのビット数のダイジェストサイズを持つハッシュアルゴリズムを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the output size of the chosen hash is larger than the number of bits of q, the hash result is truncated to fit by taking the number of leftmost bits equal to the number of bits of q. This (possibly truncated) hash function result is treated as a number and used directly in the DSA signature algorithm.",
      "ja": "選択したハッシュの出力サイズがQのビット数よりも大きい場合、ハッシュの結果は、Qのビット数に等しい左端ビットの数を取得することにより適合するように切り捨てられます。この（おそらく切り捨てられた）ハッシュ関数の結果は、数字として扱われ、DSA署名アルゴリズムで直接使用されます。"
    },
    {
      "indent": 3,
      "text": "An ECDSA signature MUST use a hash algorithm with a digest size of at least the curve's \"fsize\" value (see Section 9.2), except in the case of NIST P-521, for which at least a 512-bit hash algorithm MUST be used.",
      "ja": "ECDSAの署名は、少なくとも512ビットハッシュアルゴリズムを使用する必要があるNIST P-521の場合を除き、少なくとも曲線の「fsize」値のダイジェストサイズのハッシュアルゴリズムを使用する必要があります（セクション9.2を参照）。。"
    },
    {
      "indent": 0,
      "text": "5.2.3.3. Algorithm-Specific Fields for EdDSALegacy Signatures (Deprecated)",
      "section_title": true,
      "ja": "5.2.3.3. eddsalegacy署名のためのアルゴリズム固有のフィールド（非推奨）"
    },
    {
      "indent": 6,
      "text": "* Two MPI-encoded values, whose contents and formatting depend on the choice of curve used (see Section 9.2.1).",
      "ja": "* 内容とフォーマットは、使用される曲線の選択に依存する2つのmpiエンコード値（セクション9.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "A version 3 signature MUST NOT be created and MUST NOT be used with EdDSALegacy.",
      "ja": "バージョン3の署名を作成してはならず、Eddsalegacyで使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "An EdDSALegacy signature MUST use a hash algorithm with a digest size of at least the curve's \"fsize\" value (see Section 9.2). A verifying implementation MUST reject any EdDSALegacy signature that uses a hash algorithm with a smaller digest size.",
      "ja": "eddsalegacyの署名は、少なくとも曲線の「fsize」値のダイジェストサイズのハッシュアルゴリズムを使用する必要があります（セクション9.2を参照）。検証する実装は、ダイジェストサイズが小さいハッシュアルゴリズムを使用するEddsalegacyの署名を拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.3.1. Algorithm-Specific Fields for Ed25519Legacy Signatures (Deprecated)",
      "section_title": true,
      "ja": "5.2.3.3.1. ED25519legacy署名のアルゴリズム固有のフィールド（非推奨）"
    },
    {
      "indent": 3,
      "text": "The two MPIs for Ed25519Legacy represent the octet strings R and S of the Edwards-curve Digital Signature Algorithm (EdDSA) described in [RFC8032].",
      "ja": "ED25519legacyの2つのMPIは、[RFC8032]で説明されているEdwards-Curve Digital Signature Algorithm（EDDSA）のOctet Strings RとSを表します。"
    },
    {
      "indent": 6,
      "text": "* MPI of an EC point R, represented as a (non-prefixed) native (little-endian) octet string up to 32 octets.",
      "ja": "* ECポイントRのMPIは、最大32個のオクテットの（エンディアンではない）ネイティブ（リトルエンディアン）オクテット弦として表されます。"
    },
    {
      "indent": 6,
      "text": "* MPI of EdDSA value S, also in (non-prefixed) native (little-endian) format with a length up to 32 octets.",
      "ja": "* EDDSA値のMPI、最大32オクテットの長さの（リトルエンディアン）ネイティブ（リトルエンディアン）形式もあります。"
    },
    {
      "indent": 3,
      "text": "Ed25519Legacy MUST NOT be used in Signature packets version 6 or above.",
      "ja": "ED25519Legacyは、署名パケットバージョン6以降で使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.4. Algorithm-Specific Fields for Ed25519 Signatures",
      "section_title": true,
      "ja": "5.2.3.4. ED25519署名のアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* 64 octets of the native signature.",
      "ja": "* ネイティブ署名の64オクテット。"
    },
    {
      "indent": 3,
      "text": "For more details, see Section 12.7.",
      "ja": "詳細については、セクション12.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "A version 3 signature MUST NOT be created and MUST NOT be used with Ed25519.",
      "ja": "バージョン3の署名を作成してはならず、ED25519で使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "An Ed25519 signature MUST use a hash algorithm with a digest size of at least 256 bits. A verifying implementation MUST reject any Ed25519 signature that uses a hash algorithm with a smaller digest size.",
      "ja": "ED25519署名は、少なくとも256ビットのダイジェストサイズのハッシュアルゴリズムを使用する必要があります。検証の実装は、ダイジェストサイズが小さくなったハッシュアルゴリズムを使用するED25519署名を拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.5. Algorithm-Specific Fields for Ed448 Signatures",
      "section_title": true,
      "ja": "5.2.3.5. ED448署名のアルゴリズム固有のフィールド"
    },
    {
      "indent": 6,
      "text": "* 114 octets of the native signature.",
      "ja": "* ネイティブ署名の114オクテット。"
    },
    {
      "indent": 3,
      "text": "For more details, see Section 12.7.",
      "ja": "詳細については、セクション12.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "A version 3 signature MUST NOT be created and MUST NOT be used with Ed448.",
      "ja": "バージョン3の署名を作成してはならず、ED448で使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "An Ed448 signature MUST use a hash algorithm with a digest size of at least 512 bits. A verifying implementation MUST reject any Ed448 signature that uses a hash algorithm with a smaller digest size.",
      "ja": "ED448署名は、少なくとも512ビットのダイジェストサイズのハッシュアルゴリズムを使用する必要があります。検証実装は、ダイジェストサイズが小さくなったハッシュアルゴリズムを使用するED448署名を拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.6. Notes on Signatures",
      "section_title": true,
      "ja": "5.2.3.6. 署名に関するメモ"
    },
    {
      "indent": 3,
      "text": "The concatenation of the data being signed, the signature data from the version number through the hashed subpacket data (inclusive), and (for signature versions later than 3) a 6-octet trailer (see Section 5.2.4) is hashed. The resulting hash value is what is signed. The high 16 bits (first two octets) of the hash are included in the Signature packet to provide a way to reject some invalid signatures without performing a signature verification. When verifying a version 6 signature, an implementation MUST reject the signature if these octets do not match the first two octets of the computed hash.",
      "ja": "署名されているデータの連結、ハッシュされたサブパケットデータ（包括的）を介したバージョン番号の署名データ、および（3以降の署名バージョンの場合）6オクテットトレーラー（セクション5.2.4を参照）がハッシュされます。結果のハッシュ値は署名されています。ハッシュのハイ16ビット（最初の2オクテット）は、署名パケットに含まれており、署名検証を実行せずにいくつかの無効な署名を拒否する方法を提供します。バージョン6の署名を検証する場合、これらのオクテットが計算されたハッシュの最初の2オクテットと一致しない場合、実装は署名を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "There are two fields consisting of Signature subpackets. The first field is hashed with the rest of the signature data, while the second is not hashed into the signature. The second set of subpackets (the \"unhashed section\") is not cryptographically protected by the signature and should include only advisory information. See Section 13.13 for more information.",
      "ja": "署名サブパケットで構成される2つのフィールドがあります。最初のフィールドは、残りの署名データとハッシュされますが、2番目のフィールドは署名にハッシュされません。サブパケットの2番目のセット（「非粉砕セクション」）は、署名によって暗号化されたものではなく、アドバイザリー情報のみを含める必要があります。詳細については、セクション13.13を参照してください。"
    },
    {
      "indent": 3,
      "text": "The differences between a version 4 and version 6 signature are two-fold: first, a version 6 signature increases the width of the fields that indicate the size of the hashed and unhashed subpackets, making it possible to include significantly more data in subpackets. Second, the hash is salted with random data (see Section 13.2).",
      "ja": "バージョン4とバージョン6の署名の違いは2つあります。最初に、バージョン6の署名は、ハッシュされたサブパッケットと非塗りのサブパケットのサイズを示すフィールドの幅を増加させ、サブパケットに大幅に多くのデータを含めることができるようにします。第二に、ハッシュはランダムデータで塩漬けされています（セクション13.2を参照）。"
    },
    {
      "indent": 3,
      "text": "The algorithms for converting the hash function result to a signature are described in Section 5.2.4.",
      "ja": "ハッシュ関数の結果を署名に変換するためのアルゴリズムは、セクション5.2.4で説明されています。"
    },
    {
      "indent": 0,
      "text": "5.2.3.7. Signature Subpacket Specification",
      "section_title": true,
      "ja": "5.2.3.7. 署名サブパケット仕様"
    },
    {
      "indent": 3,
      "text": "A subpacket data set consists of zero or more Signature subpackets. In Signature packets, the subpacket data set is preceded by a 2-octet (for version 4 signatures) or 4-octet (for version 6 signatures) scalar count of the length in octets of all the subpackets. A pointer incremented by this number will skip over the subpacket data set.",
      "ja": "サブパケットデータセットは、ゼロ以上の署名サブパケットで構成されています。署名パケットでは、サブパケットデータセットの前に、すべてのサブパケットのオクテットの長さの2オクテット（バージョン4署名用）または4オクテット（バージョン6署名用）スカラーカウントがあります。この番号で増加したポインターは、サブパケットデータセットをスキップします。"
    },
    {
      "indent": 3,
      "text": "Each subpacket consists of a subpacket header and a body. The header consists of:",
      "ja": "各サブパケットは、サブパケットヘッダーとボディで構成されています。ヘッダーは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* The encoded subpacket length (1, 2, or 5 octets).",
      "ja": "* エンコードされたサブパケット長（1、2、または5オクテット）。"
    },
    {
      "indent": 6,
      "text": "* The encoded Subpacket Type ID (1 octet).",
      "ja": "* エンコードされたサブパケットタイプID（1オクテット）。"
    },
    {
      "indent": 6,
      "text": "* The subpacket-specific data.",
      "ja": "* サブパケット固有のデータ。"
    },
    {
      "indent": 3,
      "text": "The subpacket length field covers the encoded Subpacket Type ID and the subpacket-specific data, and it does not include the subpacket length field itself. It is encoded similarly to a 1-octet, 2-octet, or 5-octet OpenPGP format packet header. The encoded subpacket length can be decoded as follows:",
      "ja": "サブパケットの長さフィールドは、エンコードされたサブパケットタイプIDとサブパケット固有のデータをカバーし、サブパケットの長さフィールド自体は含まれません。1-OCTET、2-OCTET、または5-OCTET OpenPGP形式のパケットヘッダーと同様にエンコードされています。エンコードされたサブパケットの長さは、次のようにデコードできます。"
    },
    {
      "indent": 3,
      "text": "if the 1st octet <  192, then\n    lengthOfLength = 1\n    subpacketLen = 1st_octet\n\nif the 1st octet >= 192 and < 255, then\n    lengthOfLength = 2\n    subpacketLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192\n\nif the 1st octet = 255, then\n    lengthOfLength = 5\n    subpacket length = [4-octet scalar starting at 2nd_octet]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bit 7 of the encoded Subpacket Type ID is the \"critical\" bit. If set, it denotes that the subpacket is one that is critical for the evaluator of the signature to recognize. If a subpacket is encountered that is marked critical but is unknown to the evaluating implementation, the evaluator SHOULD consider the signature to be in error.",
      "ja": "エンコードされたサブパケットタイプIDのビット7は、「クリティカル」ビットです。設定されている場合、サブパケットは、署名の評価者が認識するために重要なものであることを示します。批判的であるとマークされているが、評価の実装には不明なサブパケットが遭遇した場合、評価者は署名を誤っていると考える必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD ignore any non-critical subpacket of a type that it does not recognize.",
      "ja": "実装では、認識されていないタイプの非批判的なサブパケットを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "An evaluator may \"recognize\" a subpacket but not implement it. The purpose of the critical bit is to allow the signer to tell an evaluator that it would prefer a new, unknown feature to generate an error rather than being ignored.",
      "ja": "評価者は、サブパケットを「認識」しますが、実装しない場合があります。重要なビットの目的は、署名者が評価者に、無視されるのではなくエラーを生成することが新しい未知の機能を好むことを伝えることを許可することです。"
    },
    {
      "indent": 3,
      "text": "The other bits of the encoded Subpacket Type ID (i.e., bits 6-0) contain the Subpacket Type ID.",
      "ja": "エンコードされたサブパケットタイプIDのもう1つのビット（つまり、ビット6-0）には、サブパケットタイプIDが含まれています。"
    },
    {
      "indent": 3,
      "text": "The following signature subpackets are defined:",
      "ja": "次の署名サブパケットが定義されています。"
    },
    {
      "indent": 8,
      "text": "+=========+===========================+==================+\n|      ID | Description               | Reference        |\n+=========+===========================+==================+\n|       0 | Reserved                  |                  |\n+---------+---------------------------+------------------+\n|       1 | Reserved                  |                  |\n+---------+---------------------------+------------------+\n|       2 | Signature Creation Time   | Section 5.2.3.11 |\n+---------+---------------------------+------------------+\n|       3 | Signature Expiration Time | Section 5.2.3.18 |\n+---------+---------------------------+------------------+\n|       4 | Exportable Certification  | Section 5.2.3.19 |\n+---------+---------------------------+------------------+\n|       5 | Trust Signature           | Section 5.2.3.21 |\n+---------+---------------------------+------------------+\n|       6 | Regular Expression        | Section 5.2.3.22 |\n+---------+---------------------------+------------------+\n|       7 | Revocable                 | Section 5.2.3.20 |\n+---------+---------------------------+------------------+\n|       8 | Reserved                  |                  |\n+---------+---------------------------+------------------+\n|       9 | Key Expiration Time       | Section 5.2.3.13 |\n+---------+---------------------------+------------------+\n|      10 | Placeholder for backward  |                  |\n|         | compatibility             |                  |\n+---------+---------------------------+------------------+\n|      11 | Preferred Symmetric       | Section 5.2.3.14 |\n|         | Ciphers for v1 SEIPD      |                  |\n+---------+---------------------------+------------------+\n|      12 | Revocation Key            | Section 5.2.3.23 |\n|         | (deprecated)              |                  |\n+---------+---------------------------+------------------+\n|   13-15 | Reserved                  |                  |\n+---------+---------------------------+------------------+\n|      16 | Issuer Key ID             | Section 5.2.3.12 |\n+---------+---------------------------+------------------+\n|   17-19 | Reserved                  |                  |\n+---------+---------------------------+------------------+\n|      20 | Notation Data             | Section 5.2.3.24 |\n+---------+---------------------------+------------------+\n|      21 | Preferred Hash Algorithms | Section 5.2.3.16 |\n+---------+---------------------------+------------------+\n|      22 | Preferred Compression     | Section 5.2.3.17 |\n|         | Algorithms                |                  |\n+---------+---------------------------+------------------+\n|      23 | Key Server Preferences    | Section 5.2.3.25 |\n+---------+---------------------------+------------------+\n|      24 | Preferred Key Server      | Section 5.2.3.26 |\n+---------+---------------------------+------------------+\n|      25 | Primary User ID           | Section 5.2.3.27 |\n+---------+---------------------------+------------------+\n|      26 | Policy URI                | Section 5.2.3.28 |\n+---------+---------------------------+------------------+\n|      27 | Key Flags                 | Section 5.2.3.29 |\n+---------+---------------------------+------------------+\n|      28 | Signer's User ID          | Section 5.2.3.30 |\n+---------+---------------------------+------------------+\n|      29 | Reason for Revocation     | Section 5.2.3.31 |\n+---------+---------------------------+------------------+\n|      30 | Features                  | Section 5.2.3.32 |\n+---------+---------------------------+------------------+\n|      31 | Signature Target          | Section 5.2.3.33 |\n+---------+---------------------------+------------------+\n|      32 | Embedded Signature        | Section 5.2.3.34 |\n+---------+---------------------------+------------------+\n|      33 | Issuer Fingerprint        | Section 5.2.3.35 |\n+---------+---------------------------+------------------+\n|      34 | Reserved                  |                  |\n+---------+---------------------------+------------------+\n|      35 | Intended Recipient        | Section 5.2.3.36 |\n|         | Fingerprint               |                  |\n+---------+---------------------------+------------------+\n|      37 | Reserved (Attested        |                  |\n|         | Certifications)           |                  |\n+---------+---------------------------+------------------+\n|      38 | Reserved (Key Block)      |                  |\n+---------+---------------------------+------------------+\n|      39 | Preferred AEAD            | Section 5.2.3.15 |\n|         | Ciphersuites              |                  |\n+---------+---------------------------+------------------+\n| 100-110 | Private or Experimental   |                  |\n|         | Use                       |                  |\n+---------+---------------------------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 5: OpenPGP Signature Subpacket Types Registry",
      "ja": "表5：OpenPGP署名サブパケットタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD implement the four preferred algorithm subpackets (11, 21, 22, and 39), as well as the \"Features\" (30) and \"Reason for Revocation\" (29) subpackets. To avoid surreptitious forwarding (see Section 13.12), implementations SHOULD also implement the \"Intended Recipients Fingerprint\" (35) subpacket. Note that if an implementation chooses not to implement some of the preferences subpackets, it MUST default to the mandatory-to-implement algorithms to ensure interoperability. An encrypting implementation that does not implement the \"Features\" (30) subpacket SHOULD select the type of encrypted data format based on the versions of the recipient keys or external inference (see Section 13.7 for more details).",
      "ja": "実装は、4つの優先アルゴリズムサブパケット（11、21、22、および39）と「機能」（30）および「失効の理由」（29）サブパケットを実装する必要があります。秘密の転送を避けるため（セクション13.12を参照）、実装は「意図された受信者指紋」（35）サブパケットも実装する必要があります。実装がいくつかの設定サブパケットを実装しないことを選択した場合、相互運用性を確保するために、義務的なアルゴリズムにデフォルトする必要があることに注意してください。「機能」（30）のサブパケットを実装しない暗号化実装では、受信者キーまたは外部推論のバージョンに基づいて暗号化されたデータ形式のタイプを選択する必要があります（詳細については、セクション13.7を参照）。"
    },
    {
      "indent": 0,
      "text": "5.2.3.8. Signature Subpacket Types",
      "section_title": true,
      "ja": "5.2.3.8. 署名サブパケットタイプ"
    },
    {
      "indent": 3,
      "text": "A number of subpackets are currently defined for OpenPGP signatures. Some subpackets apply to the signature itself and some are attributes of the key. Subpackets that are found on a self-signature are placed on a certification made by the key itself. Note that a key may have more than one User ID and thus may have more than one self-signature and differing subpackets.",
      "ja": "現在、OpenPGP署名用に多くのサブパケットが定義されています。一部のサブパケットは署名自体に適用され、一部はキーの属性です。自己署名に見られるサブパケットは、キー自体によって作成された認証に配置されます。キーには複数のユーザーIDがある可能性があるため、複数の自己署名と異なるサブパケットがある場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A subpacket may be found in either the hashed or the unhashed subpacket sections of a signature. If a subpacket is not hashed, then the information in it cannot be considered definitive because it is not covered by the cryptographic signature. See Section 13.13 for more discussion about hashed and unhashed subpackets.",
      "ja": "サブパケットは、署名のハッシュされたサブパケットセクションのセクションのいずれかにあります。サブパケットがハッシュされていない場合、暗号化の署名でカバーされていないため、その情報を決定的であると見なすことはできません。ハッシュドサブパケットと非塗りのサブパケットに関する詳細については、セクション13.13を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3.9. Notes on Subpackets",
      "section_title": true,
      "ja": "5.2.3.9. サブパケットに関するメモ"
    },
    {
      "indent": 3,
      "text": "It is certainly possible for a signature to contain conflicting information in subpackets. For example, a signature may contain multiple copies of a preference or multiple expiration times. In most cases, an implementation SHOULD use the last subpacket in the hashed section of the signature, but it MAY use any conflict resolution scheme that makes more sense. Please note that conflict resolution is intentionally left to the implementer; most conflicts are simply syntax errors, and the ambiguous language here allows a receiver to be generous in what they accept, while putting pressure on a creator to be stingy in what they generate.",
      "ja": "署名がサブパケットに競合する情報を含めることは確かに可能です。たとえば、署名には、好みの複数のコピーまたは複数の有効期限が含まれる場合があります。ほとんどの場合、実装は署名のハッシュされたセクションの最後のサブパケットを使用する必要がありますが、より理にかなっている競合解決スキームを使用する場合があります。紛争解決は意図的に実装者に任されていることに注意してください。ほとんどの競合は単なる構文エラーであり、ここでのあいまいな言語は、受信者が受け入れるものに寛大になることを可能にし、作成者に生成するものにけちなことに圧力をかけます。"
    },
    {
      "indent": 3,
      "text": "Some apparent conflicts may actually make sense. For example, suppose a keyholder has a version 3 key and a version 4 key that share the same RSA key material. Either of these keys can verify a signature created by the other, and it may be reasonable for a signature to contain an Issuer Key ID subpacket (Section 5.2.3.12) for each key, as a way of explicitly tying those keys to the signature.",
      "ja": "いくつかの明らかな対立は実際に理にかなっているかもしれません。たとえば、キーホルダーにバージョン3キーと、同じRSAキー資料を共有するバージョン4キーがあるとします。これらのキーのいずれかは、他のキーによって作成された署名を検証できます。また、署名が各キーの発行者キーIDサブパケット（セクション5.2.3.12）を署名に明示的に結び付ける方法として、署名が合理的である可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.10. Notes on Self-Signatures",
      "section_title": true,
      "ja": "5.2.3.10. 自己署名に関するメモ"
    },
    {
      "indent": 3,
      "text": "A self-signature is a binding signature made by the key to which the signature refers. There are three types of self-signatures: the certification signatures (Type IDs 0x10-0x13), the Direct Key signature (Type ID 0x1F), and the Subkey Binding signature (Type ID 0x18). A cryptographically valid self-signature should be accepted from any primary key, regardless of what Key Flags (Section 5.2.3.29) apply to the primary key. In particular, a primary key does not need to have 0x01 set in the first octet of the Key Flags order to make a valid self-signature.",
      "ja": "自己署名は、署名が言及する鍵によってなされた拘束力のある署名です。自己署名には、認定署名（タイプID 0x10-0x13）、直接キー署名（タイプID 0x1F）、およびサブキーバインディングシグネチャ（タイプID 0x18）の3つのタイプがあります。キーフラグ（セクション5.2.3.29）が主キーに適用されるかどうかに関係なく、暗号的に有効な自己署名は、任意の主キーから受け入れられるべきです。特に、プライマリキーは、有効な自己署名を作成するために、キーフラグの最初のオクテットに0x01を設定する必要はありません。"
    },
    {
      "indent": 3,
      "text": "For certification self-signatures, each User ID MAY have a self-signature and thus different subpackets in those self-signatures. For Subkey Binding signatures, each subkey MUST have a self-signature. Subpackets that appear in a certification self-signature apply to the User ID, and subpackets that appear in the subkey self-signature apply to the subkey. Lastly, subpackets on the Direct Key signature apply to the entire key.",
      "ja": "認定自己署名の場合、各ユーザーIDには自己署名があり、したがってそれらの自己署名に異なるサブパケットがある場合があります。サブキーバインディングシグネチャの場合、各サブキーには自己署名が必要です。認定自己署名に表示されるサブパケットは、ユーザーIDに適用され、サブキーセルフ署名に表示されるサブパケットがサブキーに適用されます。最後に、直接キー署名のサブパケットがキー全体に適用されます。"
    },
    {
      "indent": 3,
      "text": "An implementation should interpret a self-signature's preference subpackets as narrowly as possible. For example, suppose a key has two user names, Alice and Bob. Suppose that Alice prefers the AEAD ciphersuite AES-256 with OCB, and Bob prefers Camellia-256 with GCM. If the implementation locates this key via Alice's name, then the preferred AEAD ciphersuite is AES-256 with OCB; if the implementation locates the key via Bob's name, then the preferred algorithm is Camellia-256 with GCM. If the key is located by Key ID, the algorithm of the Primary User ID of the key provides the preferred AEAD ciphersuite.",
      "ja": "実装では、自己署名の設定サブパケットをできるだけ狭く解釈する必要があります。たとえば、キーには2つのユーザー名、アリスとボブがあるとします。AliceがOCBを使用してAEAD Ciphersuite AES-256を好むと仮定し、BobはGCMでCamellia-256を好むと仮定します。実装がアリスの名前を介してこのキーを見つけた場合、好ましいAEAD CiphersuiteはOCBを使用してAES-256です。実装がボブの名前でキーを見つけた場合、優先アルゴリズムはGCMを備えたCamellia-256です。キーがキーIDに配置されている場合、キーのプライマリユーザーIDのアルゴリズムは、優先されるAEAD Ciphersuiteを提供します。"
    },
    {
      "indent": 3,
      "text": "Revoking a self-signature or allowing it to expire has a semantic meaning that varies with the signature type. Revoking the self-signature on a User ID effectively retires that user name. The self-signature is a statement, \"My name X is tied to my signing key K\", and it is corroborated by other users' certifications. If another user revokes their certification, they are effectively saying that they no longer believe that name and that key are tied together. Similarly, if the users themselves revoke their self-signature, then the users no longer go by that name, no longer have that email address, etc. Revoking a binding signature effectively retires that subkey. Revoking a Direct Key signature cancels that signature. Please see Section 5.2.3.31 for more relevant details.",
      "ja": "自己署名を取り消すか、それを有効にすることを許可することは、署名タイプによって異なる意味的な意味を持っています。ユーザーIDで自己署名を取り消すことは、そのユーザー名を効果的に廃止します。自己署名は、「私の名前xは私の署名キーKに結び付けられている」という声明であり、他のユーザーの認定によって裏付けられています。別のユーザーが認定を取り消す場合、彼らはその名前とそのキーが結び付けられなくなったとはもう信じていないと効果的に言っています。同様に、ユーザー自身が自己署名を取り消す場合、ユーザーはその名前で行かなく、そのメールアドレスなどをもはや持っていません。直接キーの署名を取り消す署名がキャンセルされます。関連する詳細については、セクション5.2.3.31を参照してください。"
    },
    {
      "indent": 3,
      "text": "Since a self-signature contains important information about the key's use, an implementation SHOULD allow the user to rewrite the self-signature and important information in it, such as preferences and key expiration.",
      "ja": "自己署名にはキーの使用に関する重要な情報が含まれているため、実装により、ユーザーは好みやキーの有効期限など、自己署名とその重要な情報を書き換えることができます。"
    },
    {
      "indent": 3,
      "text": "When an implementation imports a secret key, it SHOULD verify that the key's internal self-signatures do not advertise features or algorithms that the implementation doesn't support. If an implementation observes such a mismatch, it SHOULD warn the user and offer to create new self-signatures that advertise the actual set of features and algorithms supported by the implementation.",
      "ja": "実装がシークレットキーをインポートする場合、キーの内部自己署名が、実装がサポートしていない機能やアルゴリズムを宣伝していないことを確認する必要があります。実装がそのような不一致を観察する場合、ユーザーに警告し、実装によってサポートされている機能とアルゴリズムの実際のセットを宣伝する新しい自己署名を作成することを申し出る必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation that encounters multiple self-signatures on the same object MUST select the most recent valid self-signature and ignore all other self-signatures.",
      "ja": "同じオブジェクトで複数の自己署名に遭遇する実装は、最新の有効な自己署名を選択し、他のすべての自己署名を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "By convention, a version 4 key stores information about the primary Public Key (key flags, key expiration, etc.) and the Transferable Public Key as a whole (features, algorithm preferences, etc.) in a User ID self-signature of type 0x10 or 0x13. To use a version 4 key, some implementations require at least one User ID with a valid self-signature to be present. For this reason, it is RECOMMENDED to include at least one User ID with a self-signature in version 4 keys.",
      "ja": "慣習により、バージョン4のキーは、プライマリ公開キー（キーフラグ、キーの有効期限など）と転送可能な公開キー（機能、アルゴリズムの好みなど）に関する情報を、タイプのユーザーID自己署名に保存します。0x10または0x13。バージョン4キーを使用するには、いくつかの実装では、有効な自己署名が存在する少なくとも1つのユーザーIDが必要です。このため、バージョン4キーに自己署名を備えた少なくとも1つのユーザーIDを含めることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "For version 6 keys, it is RECOMMENDED to store information about the primary Public Key as well as the Transferable Public Key as a whole (key flags, key expiration, features, algorithm preferences, etc.) in a Direct Key signature (Type ID 0x1F) over the Public Key, instead of placing that information in a User ID self-signature. An implementation MUST ensure that a valid Direct Key signature is present before using a version 6 key. This prevents certain attacks where an adversary strips a self-signature specifying a Key Expiration Time or certain preferences.",
      "ja": "バージョン6キーの場合、直接キーの署名（タイプID 0x1Fで、主要な公開キーと転送可能な公開キー（キーフラグ、キーの有効期限、機能、アルゴリズムの設定など）に関する情報を保存することをお勧めします。）その情報をユーザーIDの自己署名に配置する代わりに、公開キーを介して。実装は、バージョン6キーを使用する前に、有効な直接キー署名が存在するようにする必要があります。これにより、敵が重要な有効期限または特定の好みを指定して自己署名をストリップする特定の攻撃を防ぎます。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT require a User ID self-signature to be present in order to consume or use a key, unless the particular use is contingent on the keyholder identifying themselves with the textual label in the User ID. For example, when refreshing a key to learn about changes in expiration, advertised features, algorithm preferences, revocation, subkey rotation, and so forth, there is no need to require a User ID self-signature. On the other hand, when verifying a signature over an email message, an implementation MAY choose to only accept a signature from a key that has a valid self-signature over a User ID that matches the message's From: header, as a way to avoid a signature transplant attack.",
      "ja": "特定の使用がキーホルダーがユーザーIDのテキストラベルで自分自身を識別することを条件としない限り、キーを消費または使用するために、ユーザーIDの自己署名を存在させる必要はありません。たとえば、有効期限の変更、宣伝された機能、アルゴリズムの好み、取り消し、サブキーローテーションなどを学ぶためのキーを更新する場合、ユーザーIDの自己署名を必要とする必要はありません。一方、電子メールメッセージの署名を検証する場合、実装は、メッセージのfromに一致するユーザーIDに有効な自己署名を持つキーからの署名のみを受け入れることを選択できます。署名移植攻撃。"
    },
    {
      "indent": 0,
      "text": "5.2.3.11. Signature Creation Time",
      "section_title": true,
      "ja": "5.2.3.11. 署名作成時間"
    },
    {
      "indent": 3,
      "text": "(4-octet time field)",
      "ja": "（4-OCTETタイムフィールド）"
    },
    {
      "indent": 3,
      "text": "The time the signature was made.",
      "ja": "署名が作られた時間。"
    },
    {
      "indent": 3,
      "text": "This subpacket MUST be present in the hashed area.",
      "ja": "このサブパケットは、ハッシュされた領域に存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "When generating this subpacket, it SHOULD be marked as critical.",
      "ja": "このサブパケットを生成するときは、クリティカルとしてマークする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.12. Issuer Key ID",
      "section_title": true,
      "ja": "5.2.3.12. 発行者キーID"
    },
    {
      "indent": 3,
      "text": "(8-octet Key ID)",
      "ja": "（8-OCTETキーID）"
    },
    {
      "indent": 3,
      "text": "The OpenPGP Key ID of the key issuing the signature. If the version of that key is greater than 4, this subpacket MUST NOT be included in the signature. For these keys, consider the Issuer Fingerprint subpacket (Section 5.2.3.35) instead.",
      "ja": "署名を発行するキーのOpenPGPキーID。そのキーのバージョンが4を超える場合、このサブパケットを署名に含める必要はありません。これらのキーについては、代わりに発行者の指紋サブパケット（セクション5.2.3.35）を検討してください。"
    },
    {
      "indent": 3,
      "text": "Note: in previous versions of this specification, this subpacket was simply known as the \"Issuer\" subpacket.",
      "ja": "注：この仕様の以前のバージョンでは、このサブパケットは単に「発行者」サブパケットとして知られていました。"
    },
    {
      "indent": 0,
      "text": "5.2.3.13. Key Expiration Time",
      "section_title": true,
      "ja": "5.2.3.13. 主要な有効期限"
    },
    {
      "indent": 3,
      "text": "(4-octet time field)",
      "ja": "（4-OCTETタイムフィールド）"
    },
    {
      "indent": 3,
      "text": "The validity period of the key. This is the number of seconds after the key creation time that the key expires. For a direct or certification self-signature, the key creation time is that of the primary key. For a Subkey Binding signature, the key creation time is that of the subkey. If this is not present or has a value of zero, the key never expires. This is found only on a self-signature.",
      "ja": "キーの有効期間。これは、キーが期限切れになったキー作成時間から数秒数です。直接または認証の自己署名の場合、キー作成時間は主キーの時間です。サブキーバインディングシグネチャの場合、主要な作成時間はサブキーの署名です。これが存在しない場合、またはゼロの値がある場合、キーが期限切れになりません。これは、自己署名でのみ見つかります。"
    },
    {
      "indent": 3,
      "text": "When an implementation generates this subpacket, it SHOULD be marked as critical.",
      "ja": "実装がこのサブパケットを生成するとき、それは重要であるとマークする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.14. Preferred Symmetric Ciphers for v1 SEIPD",
      "section_title": true,
      "ja": "5.2.3.14. V1 SEIPDの優先対称暗号"
    },
    {
      "indent": 3,
      "text": "(array of 1-octet values)",
      "ja": "（1-OCTET値の配列）"
    },
    {
      "indent": 3,
      "text": "A series of Symmetric Cipher Algorithm IDs indicating how the keyholder prefers to receive the version 1 Symmetrically Encrypted and Integrity Protected Data packet (Section 5.13.1). The subpacket body is an ordered list of octets with the most preferred listed first. It is assumed that only the algorithms listed are supported by the recipient's implementation. Algorithm IDs are defined in Section 9.3. This is only found on a self-signature.",
      "ja": "キーホルダーがバージョン1を対称的に暗号化し、整合性保護されたデータパケットを受信することを好む方法を示す一連の対称暗号アルゴリズムID（セクション5.13.1）。サブパケット本体は、最初にリストされている最も優先されるオクテットの順序付けられたリストです。リストされているアルゴリズムのみが受信者の実装によってサポートされていると想定されています。アルゴリズムIDは、セクション9.3で定義されています。これは、自己署名でのみ見られます。"
    },
    {
      "indent": 3,
      "text": "When generating a v2 SEIPD packet, this preference list is not relevant. See Section 5.2.3.15 instead.",
      "ja": "V2 SEIPDパケットを生成する場合、この設定リストは関連しません。代わりにセクション5.2.3.15を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3.15. Preferred AEAD Ciphersuites",
      "section_title": true,
      "ja": "5.2.3.15. 好ましいAead Ciphersuites"
    },
    {
      "indent": 3,
      "text": "(array of pairs of octets indicating Symmetric Cipher and AEAD algorithms)",
      "ja": "（対称的な暗号とAEADアルゴリズムを示すオクテットのペアの配列）"
    },
    {
      "indent": 3,
      "text": "A series of paired algorithm IDs indicating how the keyholder prefers to receive the version 2 Symmetrically Encrypted and Integrity Protected Data packet (Section 5.13.2). Each pair of octets indicates a combination of a symmetric cipher and an AEAD mode that the keyholder prefers to use. The Symmetric Cipher Algorithm ID precedes the AEAD algorithm ID in each pair. The subpacket body is an ordered list of pairs of octets with the most preferred algorithm combination listed first.",
      "ja": "キーホルダーがバージョン2を対称的に暗号化し、整合性保護されたデータパケットを受信することを好む方法を示す一連のペアのアルゴリズムID（セクション5.13.2）。オクテットの各ペアは、対称的な暗号と、キーホルダーが使用することを好むAEADモードの組み合わせを示します。対称暗号アルゴリズムIDは、各ペアのAEADアルゴリズムIDに先行します。サブパケット本体は、最初にリストされた最も好ましいアルゴリズムの組み合わせを持つオクテットのペアの順序付けられたリストです。"
    },
    {
      "indent": 3,
      "text": "It is assumed that only the combinations of algorithms listed are supported by the recipient's implementation, with the exception of the mandatory-to-implement combination of AES-128 and OCB. If AES-128 and OCB are not found in the subpacket, it is implicitly listed at the end.",
      "ja": "リストされているアルゴリズムの組み合わせのみが、AES-128とOCBの義務的な実装の組み合わせを除き、受信者の実装によってサポートされると想定されています。AES-128とOCBがサブパケットにない場合、最後に暗黙的にリストされています。"
    },
    {
      "indent": 3,
      "text": "AEAD algorithm IDs are listed in Section 9.6. Symmetric Cipher Algorithm IDs are listed in Section 9.3.",
      "ja": "AEADアルゴリズムIDは、セクション9.6にリストされています。対称暗号アルゴリズムIDは、セクション9.3にリストされています。"
    },
    {
      "indent": 3,
      "text": "For example, a subpacket containing the six octets",
      "ja": "たとえば、6個のオクテットを含むサブパケット"
    },
    {
      "indent": 3,
      "text": "09 02 09 03 13 02",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "indicates that the keyholder prefers to receive v2 SEIPD using AES-256 with OCB, then AES-256 with GCM, then Camellia-256 with OCB, and finally the implicit AES-128 with OCB.",
      "ja": "キーホルダーは、OCBを使用してAES-256を使用してV2 SEIPDを受け取ることを好むことを示します。次にGCMでAES-256、OCBでCamellia-256、そして最後にOCBで暗黙のAES-128を使用することを示します。"
    },
    {
      "indent": 3,
      "text": "Note that support for the version 2 Symmetrically Encrypted and Integrity Protected Data packet (Section 5.13.2) in general is indicated by a Features Flag (Section 5.2.3.32).",
      "ja": "バージョン2の対称的に暗号化され、整合性保護されたデータパケット（セクション5.13.2）のサポートは、機能フラグ（セクション5.2.3.32）で示されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "This subpacket is only found on a self-signature.",
      "ja": "このサブパケットは、自己署名でのみ見つかります。"
    },
    {
      "indent": 3,
      "text": "When generating a v1 SEIPD packet, this preference list is not relevant. See Section 5.2.3.14 instead.",
      "ja": "V1 SEIPDパケットを生成する場合、この設定リストは関連しません。代わりにセクション5.2.3.14を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3.16. Preferred Hash Algorithms",
      "section_title": true,
      "ja": "5.2.3.16. 優先ハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "(array of 1-octet values)",
      "ja": "（1-OCTET値の配列）"
    },
    {
      "indent": 3,
      "text": "Message digest algorithm IDs that indicate which algorithms the keyholder prefers to receive. Like the Preferred AEAD Ciphersuites, the list is ordered. Algorithm IDs are defined in Section 9.5. This is only found on a self-signature.",
      "ja": "キーホルダーが受信することを好むアルゴリズムを示すメッセージダイジェストアルゴリズムID。好ましいAEAD Ciphersuitesと同様に、リストが注文されます。アルゴリズムIDは、セクション9.5で定義されています。これは、自己署名でのみ見られます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.17. Preferred Compression Algorithms",
      "section_title": true,
      "ja": "5.2.3.17. 優先圧縮アルゴリズム"
    },
    {
      "indent": 3,
      "text": "(array of 1-octet values)",
      "ja": "（1-OCTET値の配列）"
    },
    {
      "indent": 3,
      "text": "Compression algorithm IDs that indicate which algorithms the keyholder prefers to use. Like the Preferred AEAD Ciphersuites, the list is ordered. Algorithm IDs are defined in Section 9.4. A zero, or the absence of this subpacket, denotes that uncompressed data is preferred; the keyholder's implementation might have no compression support available. This is only found on a self-signature.",
      "ja": "キーホルダーが使用することを好むアルゴリズムを示す圧縮アルゴリズムID。好ましいAEAD Ciphersuitesと同様に、リストが注文されます。アルゴリズムIDは、セクション9.4で定義されています。ゼロ、またはこのサブパケットがないことは、非圧縮データが推奨されることを示します。キーホルダーの実装には、圧縮サポートが利用できない場合があります。これは、自己署名でのみ見られます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.18. Signature Expiration Time",
      "section_title": true,
      "ja": "5.2.3.18. 署名の有効期限"
    },
    {
      "indent": 3,
      "text": "(4-octet time field)",
      "ja": "（4-OCTETタイムフィールド）"
    },
    {
      "indent": 3,
      "text": "The validity period of the signature. This is the number of seconds after the Signature Creation Time that the signature expires. If this is not present or has a value of zero, it never expires.",
      "ja": "署名の有効期間。これは、署名の作成時間が期限切れになった後の秒数です。これが存在しない場合、またはゼロの値がある場合、有効期限が切れません。"
    },
    {
      "indent": 3,
      "text": "When an implementation generates this subpacket, it SHOULD be marked as critical.",
      "ja": "実装がこのサブパケットを生成するとき、それは重要であるとマークする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.19. Exportable Certification",
      "section_title": true,
      "ja": "5.2.3.19. エクスポート可能な認証"
    },
    {
      "indent": 3,
      "text": "(1 octet of exportability, 0 for not, 1 for exportable)",
      "ja": "（1オクテットの輸出可能性、NOTの場合は0、輸出可能な場合は1）"
    },
    {
      "indent": 3,
      "text": "This subpacket denotes whether a certification signature is \"exportable\"; it is intended for use by users other than the signature's issuer. The packet body contains a Boolean flag indicating whether the signature is exportable. If this packet is not present, the certification is exportable; it is equivalent to a flag containing a 1.",
      "ja": "このサブパケットは、認定署名が「エクスポート可能」であるかどうかを示します。これは、署名の発行者以外のユーザーが使用することを目的としています。パケット本体には、署名がエクスポート可能かどうかを示すブールフラグが含まれています。このパケットが存在しない場合、認定はエクスポート可能です。これは、1を含むフラグに相当します。"
    },
    {
      "indent": 3,
      "text": "Non-exportable, or \"local\", certifications are signatures made by a user to mark a key as valid within that user's implementation only.",
      "ja": "輸出不能、または「ローカル」認定は、ユーザーの実装のみでキーを有効であるとマークするために、ユーザーが作成した署名です。"
    },
    {
      "indent": 3,
      "text": "Thus, when an implementation prepares a user's copy of a key for transport to another user (this is the process of \"exporting\" the key), any local certification signatures are deleted from the key.",
      "ja": "したがって、実装が他のユーザーへのトランスポートのためのキーのユーザーのコピーを準備すると（これはキーを「エクスポート」するプロセスです）、ローカル認定署名はキーから削除されます。"
    },
    {
      "indent": 3,
      "text": "The receiver of a transported key \"imports\" it and likewise trims any local certifications. In normal operation, there won't be any local certifications, assuming the import is performed on an exported key. However, there are instances where this can reasonably happen. For example, if an implementation allows keys to be imported from a key database in addition to an exported key, then this situation can arise.",
      "ja": "輸送されたキーの受信者は、それを「輸入」し、同様にローカル認定をトリミングします。通常の操作では、輸入がエクスポートされたキーで実行されると仮定して、現地認定はありません。ただし、これが合理的に発生する可能性のある事例があります。たとえば、実装により、エクスポートキーに加えてキーデータベースからキーをインポートできる場合、この状況が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some implementations do not represent the interest of a single user (for example, a key server). Such implementations always trim local certifications from any key they handle.",
      "ja": "一部の実装は、単一のユーザー（たとえば、キーサーバーなど）の関心を表していません。このような実装は、常に処理するキーからローカル認定をトリミングします。"
    },
    {
      "indent": 3,
      "text": "When an implementation generates this subpacket and denotes the signature as non-exportable, the subpacket MUST be marked as critical.",
      "ja": "実装がこのサブパケットを生成し、署名が輸出不能であると示される場合、サブパケットは重要であるとマークする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.20. Revocable",
      "section_title": true,
      "ja": "5.2.3.20. 取り消し可能"
    },
    {
      "indent": 3,
      "text": "(1 octet of revocability, 0 for not, 1 for revocable)",
      "ja": "（取り消しの1オクテット、NOTの場合は0、取り消し可能な場合は1）"
    },
    {
      "indent": 3,
      "text": "A Signature's revocability status. The packet body contains a Boolean flag indicating whether the signature is revocable. Signatures that are not revocable ignore any later Revocation Signatures. They represent the signer's commitment that its signature cannot be revoked for the life of its key. If this packet is not present, the signature is revocable.",
      "ja": "シグネチャーの登録ステータス。パケット本体には、署名が取り消されるかどうかを示すブールフラグが含まれています。取り消しできない署名は、後の取り消し署名を無視します。彼らは、その署名を鍵の寿命のために取り消すことはできないという署名者のコミットメントを表しています。このパケットが存在しない場合、署名は取り消し可能です。"
    },
    {
      "indent": 0,
      "text": "5.2.3.21. Trust Signature",
      "section_title": true,
      "ja": "5.2.3.21. 信頼署名"
    },
    {
      "indent": 3,
      "text": "(1 octet \"level\" (depth), 1 octet of trust amount)",
      "ja": "（1オクテット「レベル」（深さ）、1オクテットの信頼額）"
    },
    {
      "indent": 3,
      "text": "The signer asserts that the key is not only valid but also trustworthy at the specified level. Level 0 has the same meaning as an ordinary validity signature. Level 1 means that the signed key is asserted to be a valid trusted introducer, with the 2nd octet of the body specifying the degree of trust. Level 2 means that the signed key is asserted to be trusted to issue level 1 Trust Signatures; that is, the signed key is a \"meta introducer\". Generally, a level n Trust Signature asserts that a key is trusted to issue level n-1 Trust Signatures. The trust amount is in a range from 0-255, interpreted such that values less than 120 indicate partial trust and values of 120 or greater indicate complete trust. Implementations SHOULD emit values of 60 for partial trust and 120 for complete trust.",
      "ja": "署名者は、キーは有効であるだけでなく、指定されたレベルでも信頼できると主張しています。レベル0は、通常の妥当性の署名と同じ意味を持っています。レベル1とは、署名されたキーが有効な信頼できる導入者であると主張され、身体の2番目のオクテットが信頼の程度を指定していることを意味します。レベル2とは、署名されたキーがレベル1の信頼署名を発行すると信頼されると主張されることを意味します。つまり、署名されたキーは「メタ紹介者」です。一般的に、レベルnトラストの署名は、キーがレベルN-1トラストの署名を発行すると信頼されていると主張しています。信頼額は0〜255の範囲であり、120未満の値が部分的な信頼を示し、120以上の値が完全な信頼を示すように解釈されます。実装は、部分的な信頼の場合は60の値を、完全な信頼のために120の値を発する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.22. Regular Expression",
      "section_title": true,
      "ja": "5.2.3.22. 正規表現"
    },
    {
      "indent": 3,
      "text": "(null-terminated UTF-8 encoded Regular Expression)",
      "ja": "（ヌル終端UTF-8エンコードされた正規表現）"
    },
    {
      "indent": 3,
      "text": "Used in conjunction with Trust Signature packets (of level > 0) to limit the scope of trust that is extended. Only signatures by the target key on User IDs that match the Regular Expression in the body of this packet have trust extended by the Trust Signature subpacket. The Regular Expression uses the same syntax as Henry Spencer's \"almost public domain\" Regular Expression [REGEX] package. A description of the syntax is found in Section 8. The Regular Expression matches (or does not match) a sequence of UTF-8-encoded Unicode characters from User IDs. The expression itself is also written with UTF-8 characters.",
      "ja": "拡張された信頼の範囲を制限するために、Trust Signature Packet（レベル> 0）と組み合わせて使用されます。このパケットの本文の正規表現と一致するユーザーIDのターゲットキーによる署名のみが、Trust Signature Subpacketによって拡張されました。正規表現は、ヘンリースペンサーの「ほぼパブリックドメイン」正規表現[Regex]パッケージと同じ構文を使用します。構文の説明は、セクション8にあります。正規表現は、ユーザーIDのUTF-8エンコードされたユニコード文字のシーケンスと一致します（または一致しません）。表現自体は、UTF-8文字でも書かれています。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, this subpacket includes a null character (an octet with value zero) after the Regular Expression. When an implementation parses a Regular Expression subpacket, it MUST remove this octet; if it is not present, it MUST reject the subpacket (i.e., ignore the subpacket if it's non-critical and reject the signature if it's critical). When an implementation generates a Regular Expression subpacket, it MUST include the null terminator.",
      "ja": "歴史的な理由から、このサブパケットには、正規表現後のヌル文字（値ゼロのオクテット）が含まれます。実装が正規表現サブパケットを解析する場合、このオクテットを削除する必要があります。存在しない場合は、サブパケットを拒否する必要があります（つまり、サブパケットが非クリティカルである場合は無視し、重要な場合は署名を拒否します）。実装が正規表現サブパケットを生成する場合、nullターミネーターを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "When generating this subpacket, it SHOULD be marked as critical.",
      "ja": "このサブパケットを生成するときは、クリティカルとしてマークする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.23. Revocation Key (Deprecated)",
      "section_title": true,
      "ja": "5.2.3.23. 取り消しキー（非推奨）"
    },
    {
      "indent": 3,
      "text": "(1 octet of class, 1 octet of public key algorithm ID, 20 octets of version 4 fingerprint)",
      "ja": "（クラスの1オクテット、1オクテットの公開キーアルゴリズムID、バージョン4の指紋の20オクテット）"
    },
    {
      "indent": 3,
      "text": "This mechanism is deprecated. Applications MUST NOT generate such a subpacket.",
      "ja": "このメカニズムは非推奨です。アプリケーションはそのようなサブパケットを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "An application that wants the functionality of delegating revocation can use an escrowed Revocation Signature. See Section 13.9 for more details.",
      "ja": "取り外しの機能を希望するアプリケーションは、エスクローされた取り消し署名を使用できます。詳細については、セクション13.9を参照してください。"
    },
    {
      "indent": 3,
      "text": "The remainder of this section describes how some implementations attempt to interpret this deprecated subpacket.",
      "ja": "このセクションの残りの部分では、いくつかの実装がこの非推奨サブパケットを解釈しようとする方法について説明します。"
    },
    {
      "indent": 3,
      "text": "This packet was intended to authorize the specified key to issue Revocation Signatures for this key. The class octet must have bit 0x80 set. If bit 0x40 is set, it means the revocation information is sensitive. Other bits are for future expansion to other kinds of authorizations. This is only found on a Direct Key self-signature (Type ID 0x1F). The use on other types of self-signatures is unspecified.",
      "ja": "このパケットは、指定されたキーを、このキーの失効署名を発行することを承認することを目的としていました。クラスのオクテットには、ビット0x80セットが必要です。ビット0x40が設定されている場合、取り消し情報が敏感であることを意味します。他のビットは、他の種類の承認への将来の拡張のためです。これは、直接キーの自己署名（タイプID 0x1F）でのみ見つかります。他の種類の自己署名での使用は不特定です。"
    },
    {
      "indent": 3,
      "text": "If the \"sensitive\" flag is set, the keyholder feels this subpacket contains private trust information that describes a real-world sensitive relationship. If this flag is set, implementations SHOULD NOT export this signature to other users except in cases where the data needs to be available, i.e., when the signature is being sent to the designated revoker or when it is accompanied by a Revocation Signature from that revoker. Note that it may be appropriate to isolate this subpacket within a separate signature so that it is not combined with other subpackets that need to be exported.",
      "ja": "「敏感な」フラグが設定されている場合、キーホルダーは、このサブパケットには、実際の敏感な関係を説明するプライベートトラスト情報が含まれていると感じています。このフラグが設定されている場合、実装は、データが利用可能である必要がある場合、つまり署名されたRebokerに送信された場合、またはそのRebokerからの取り消し署名が添付されている場合を除き、この署名を他のユーザーにエクスポートしないでください。。エクスポートする必要がある他のサブパケットと組み合わされないように、このサブパケットを別の署名内に分離することが適切かもしれないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3.24. Notation Data",
      "section_title": true,
      "ja": "5.2.3.24. 表記データ"
    },
    {
      "indent": 3,
      "text": "(4 octets of flags, 2 octets of name length (M), 2 octets of value length (N), M octets of name data, N octets of value data)",
      "ja": "（フラグの4オクテット、名前の長さ2オクテット（m）、値の長さの2オクテット（n）、名前データのmオクテット、値データのnオクテット）"
    },
    {
      "indent": 3,
      "text": "This subpacket describes a \"notation\" on the signature that the issuer wishes to make. The notation has a name and a value, each of which are strings of octets. There may be more than one notation in a signature. Notations can be used for any extension the issuer of the signature cares to make. The \"flags\" field holds 4 octets of flags.",
      "ja": "このサブパケットは、発行者が作りたい署名の「表記」について説明します。表記には名前と値があり、それぞれがオクテットの文字列です。署名には複数の表記がある場合があります。表記は、署名のケアの発行者が作成する任意の拡張に使用できます。「フラグ」フィールドには、4オクテットのフラグがあります。"
    },
    {
      "indent": 3,
      "text": "All undefined flags MUST be zero. Defined flags are as follows:",
      "ja": "未定義のすべてのフラグはゼロでなければなりません。定義されたフラグは次のとおりです。"
    },
    {
      "indent": 8,
      "text": "+=======================+================+================+\n| Flag Position         | Shorthand      | Description    |\n+=======================+================+================+\n| 0x80000000 (first bit | human-readable | Notation value |\n| of the first octet)   |                | is UTF-8 text  |\n+-----------------------+----------------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 6: OpenPGP Signature Notation Data Subpacket Notation Flags Registry",
      "ja": "表6：OpenPGP署名表記データサブパケット表記フラグレジストリ"
    },
    {
      "indent": 3,
      "text": "Notation names are arbitrary strings encoded in UTF-8. They reside in two namespaces: the IETF namespace and the user namespace.",
      "ja": "表記名は、UTF-8でエンコードされた任意の文字列です。それらは、ietFネームスペースとユーザーネームスペースの2つの名前空間に存在します。"
    },
    {
      "indent": 3,
      "text": "The IETF namespace is registered with IANA. These names MUST NOT contain the \"@\" character (0x40). This is a tag for the user namespace.",
      "ja": "IETF名前空間はIANAに登録されています。これらの名前には、「@」文字（0x40）が含まれてはなりません。これは、ユーザーネームスペースのタグです。"
    },
    {
      "indent": 14,
      "text": "+===============+===========+================+\n| Notation Name | Data Type | Allowed Values |\n+===============+===========+================+\n| No registrations at this time.             |\n+============================================+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 7: OpenPGP Signature Notation Data Subpacket Types Registry",
      "ja": "表7：OpenPGP署名表記データサブパケットタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "This registry is initially empty.",
      "ja": "このレジストリは最初は空です。"
    },
    {
      "indent": 3,
      "text": "Names in the user namespace consist of a UTF-8 string tag followed by \"@\", followed by a DNS domain name. Note that the tag MUST NOT contain an \"@\" character. For example, the \"sample\" tag used by Example Corporation could be \"sample@example.com\".",
      "ja": "ユーザー名空間の名前は、UTF-8文字列タグに続いて「@」で構成され、その後にDNSドメイン名が続きます。タグには「@」文字が含まれていないことに注意してください。たとえば、Example Corporationが使用する「サンプル」タグは、「sample@example.com」になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Names in a user space are owned and controlled by the owners of that domain. Obviously, it's bad form to create a new name in a DNS space that you don't own.",
      "ja": "ユーザースペースの名前は、そのドメインの所有者が所有および管理しています。明らかに、あなたが所有していないDNSスペースに新しい名前を作成するのは悪い形です。"
    },
    {
      "indent": 3,
      "text": "Since the user namespace is in the form of an email address, implementers MAY wish to arrange for that address to reach a person who can be consulted about the use of the named tag. Note that due to UTF-8 encoding, not all valid user space name tags are valid email addresses.",
      "ja": "ユーザーの名前空間は電子メールアドレスの形式であるため、実装者は、そのアドレスを手配して、指定されたタグの使用について相談できる人に連絡することをお勧めします。UTF-8エンコードのため、すべての有効なユーザースペース名タグが有効な電子メールアドレスであるわけではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If there is a critical notation, the criticality applies to that specific notation and not to notations in general.",
      "ja": "重要な表記がある場合、重要性はその特定の表記に適用され、一般的な表記には適用されません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.25. Key Server Preferences",
      "section_title": true,
      "ja": "5.2.3.25. 主要なサーバー設定"
    },
    {
      "indent": 3,
      "text": "(N octets of flags)",
      "ja": "（n旗のオクテット）"
    },
    {
      "indent": 3,
      "text": "This is a list of 1-bit flags that indicates preferences that the keyholder has about how the key is handled on a key server. All undefined flags MUST be zero.",
      "ja": "これは、キーホルダーがキーの処理方法についてキーホルダーが持っている好みを示す1ビットフラグのリストです。未定義のすべてのフラグはゼロでなければなりません。"
    },
    {
      "indent": 4,
      "text": "+=========+===========+===========================================+\n| Flag    | Shorthand | Definition                                |\n+=========+===========+===========================================+\n| 0x80... | No-modify | The keyholder requests that this key only |\n|         |           | be modified or updated by the keyholder   |\n|         |           | or an administrator of the key server.    |\n+---------+-----------+-------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 8: OpenPGP Key Server Preference Flags Registry",
      "ja": "表8：OpenPGPキーサーバー優先フラグレジストリ"
    },
    {
      "indent": 3,
      "text": "This is found only on a self-signature.",
      "ja": "これは、自己署名でのみ見つかります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.26. Preferred Key Server",
      "section_title": true,
      "ja": "5.2.3.26. 優先キーサーバー"
    },
    {
      "indent": 3,
      "text": "(String)",
      "ja": "（弦）"
    },
    {
      "indent": 3,
      "text": "This is a URI of a key server that the keyholder prefers be used for updates. Note that keys with multiple User IDs can have a Preferred Key Server for each User ID. Note also that since this is a URI, the key server can actually be a copy of the key retrieved by https, ftp, http, etc.",
      "ja": "これは、キーホルダーが更新に使用することを好むキーサーバーのURIです。複数のユーザーIDを持つキーには、ユーザーIDごとに優先キーサーバーがあることに注意してください。また、これはURIであるため、キーサーバーは実際にはHTTPS、FTP、HTTPなどによって取得されたキーのコピーになる可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3.27. Primary User ID",
      "section_title": true,
      "ja": "5.2.3.27. プライマリユーザーID"
    },
    {
      "indent": 3,
      "text": "(1 octet, Boolean)",
      "ja": "（1オクテット、ブール）"
    },
    {
      "indent": 3,
      "text": "This is a flag in a User ID's self-signature that states whether this User ID is the main User ID for this key. It is reasonable for an implementation to resolve ambiguities in preferences, for example, by referring to the Primary User ID. If this flag is absent, its value is zero. If more than one User ID in a key is marked as primary, the implementation may resolve the ambiguity in any way it sees fit, but it is RECOMMENDED that priority be given to the User ID with the most recent self-signature.",
      "ja": "これは、このユーザーIDがこのキーのメインユーザーIDであるかどうかを示すユーザーIDの自己署名のフラグです。たとえば、プライマリユーザーIDを参照することにより、実装が好みのあいまいさを解決することは合理的です。このフラグがない場合、その値はゼロです。キー内の複数のユーザーIDがプライマリとしてマークされている場合、実装は適切と思われるあらゆる方法で曖昧さを解決する可能性がありますが、最新の自己署名でユーザーIDに優先度を与えることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "When appearing on a self-signature on a User ID packet, this subpacket applies only to User ID packets. When appearing on a self-signature on a User Attribute packet, this subpacket applies only to User Attribute packets. That is, there are two different and independent \"primaries\" -- one for User IDs and one for User Attributes.",
      "ja": "ユーザーIDパケットに自己署名に表示される場合、このサブパケットはユーザーIDパケットにのみ適用されます。ユーザー属性パケットの自己署名に表示される場合、このサブパケットはユーザー属性パケットにのみ適用されます。つまり、2つの異なる独立した「プライマリー」があります。1つはユーザーID用、もう1つはユーザー属性用です。"
    },
    {
      "indent": 0,
      "text": "5.2.3.28. Policy URI",
      "section_title": true,
      "ja": "5.2.3.28. ポリシーURI"
    },
    {
      "indent": 3,
      "text": "(String)",
      "ja": "（弦）"
    },
    {
      "indent": 3,
      "text": "This subpacket contains a URI of a document that describes the policy under which the signature was issued.",
      "ja": "このサブパケットには、署名が発行されたポリシーを説明するドキュメントのURIが含まれています。"
    },
    {
      "indent": 0,
      "text": "5.2.3.29. Key Flags",
      "section_title": true,
      "ja": "5.2.3.29. キーフラグ"
    },
    {
      "indent": 3,
      "text": "(N octets of flags)",
      "ja": "（n旗のオクテット）"
    },
    {
      "indent": 3,
      "text": "This subpacket contains a list of binary flags that hold information about a key. It is a string of octets, and an implementation MUST NOT assume a fixed size, so that it can grow over time. If a list is shorter than an implementation expects, the unstated flags are considered to be zero. The defined flags are as follows:",
      "ja": "このサブパケットには、キーに関する情報を保持するバイナリフラグのリストが含まれています。これはオクテットの文字列であり、実装は固定サイズを想定してはなりません。そうすれば、時間とともに成長することができます。リストが実装が予想するよりも短い場合、未定のフラグはゼロと見なされます。定義されたフラグは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+===========+======================================================+\n| Flag      | Definition                                           |\n+===========+======================================================+\n| 0x01...   | This key may be used to make User ID certifications  |\n|           | (Signature Type IDs 0x10-0x13) or Direct Key         |\n|           | signatures (Signature Type ID 0x1F) over other keys. |\n+-----------+------------------------------------------------------+\n| 0x02...   | This key may be used to sign data.                   |\n+-----------+------------------------------------------------------+\n| 0x04...   | This key may be used to encrypt communications.      |\n+-----------+------------------------------------------------------+\n| 0x08...   | This key may be used to encrypt storage.             |\n+-----------+------------------------------------------------------+\n| 0x10...   | The private component of this key may have been      |\n|           | split by a secret-sharing mechanism.                 |\n+-----------+------------------------------------------------------+\n| 0x20...   | This key may be used for authentication.             |\n+-----------+------------------------------------------------------+\n| 0x80...   | The private component of this key may be in the      |\n|           | possession of more than one person.                  |\n+-----------+------------------------------------------------------+\n| 0x0004... | Reserved (ADSK)                                      |\n+-----------+------------------------------------------------------+\n| 0x0008... | Reserved (timestamping)                              |\n+-----------+------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 9: OpenPGP Key Flags Registry",
      "ja": "表9：OpenPGPキーフラグレジストリ"
    },
    {
      "indent": 3,
      "text": "Usage notes:",
      "ja": "使用法："
    },
    {
      "indent": 3,
      "text": "The flags in this packet may appear in self-signatures or in certification signatures. They mean different things depending on who is making the statement. For example, a certification signature that has the \"sign data\" flag is stating that the certification is for that use. On the other hand, the \"communications encryption\" flag in a self-signature is stating a preference that a given key be used for communications. However, note that determining what is \"communications\" and what is \"storage\" is a thorny issue. This decision is left wholly up to the implementation; the authors of this document do not claim any special wisdom on the issue and realize that accepted opinion may change.",
      "ja": "このパケットのフラグは、自己署名または認定署名に表示される場合があります。誰が声明を出しているかに応じて、異なることを意味します。たとえば、「サインデータ」フラグを持つ認定署名は、認証がその使用のためであると述べています。一方、自己署名の「通信暗号化」フラグは、特定のキーが通信に使用されるという好みを述べています。ただし、「コミュニケーション」と「ストレージ」とは何かを決定することは、厄介な問題であることに注意してください。この決定は、実装に完全に任されています。この文書の著者は、この問題に関する特別な知恵を主張せず、受け入れられた意見が変わる可能性があることを認識しています。"
    },
    {
      "indent": 3,
      "text": "The \"split key\" (0x10) and \"group key\" (0x80) flags are placed on a self-signature only; they are meaningless on a certification signature. They SHOULD be placed only on a Direct Key signature (Type ID 0x1F) or a Subkey Binding signature (Type ID 0x18), one that refers to the key the flag applies to.",
      "ja": "「スプリットキー」（0x10）および「グループキー」（0x80）フラグは、自己署名のみに配置されます。彼らは認定署名で無意味です。それらは、直接キー署名（タイプID 0x1F）またはサブキーバインディングシグネチャ（タイプID 0x18）にのみ配置する必要があります。これは、フラグが適用されるキーを指すものです。"
    },
    {
      "indent": 3,
      "text": "When an implementation generates this subpacket, it SHOULD be marked as critical.",
      "ja": "実装がこのサブパケットを生成するとき、それは重要であるとマークする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.30. Signer's User ID",
      "section_title": true,
      "ja": "5.2.3.30. 署名者のユーザーID"
    },
    {
      "indent": 3,
      "text": "(String)",
      "ja": "（弦）"
    },
    {
      "indent": 3,
      "text": "This subpacket allows a keyholder to state which User ID is responsible for the signing. Many keyholders use a single key for different purposes, such as business communications as well as personal communications. This subpacket allows such a keyholder to state which of their roles is making a signature.",
      "ja": "このサブパケットにより、キーホルダーは署名の責任者をキーホルダーが述べることができます。多くのキーホルダーは、ビジネスコミュニケーションや個人的なコミュニケーションなど、さまざまな目的で単一のキーを使用しています。このサブパケットにより、このようなキーホルダーは、どの役割が署名を作成しているかを述べることができます。"
    },
    {
      "indent": 3,
      "text": "This subpacket is not appropriate to use to refer to a User Attribute packet.",
      "ja": "このサブパケットは、ユーザー属性パケットを参照するために使用するのに適していません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.31. Reason for Revocation",
      "section_title": true,
      "ja": "5.2.3.31. 取り消しの理由"
    },
    {
      "indent": 3,
      "text": "(1 octet of revocation code, N octets of reason string)",
      "ja": "（取り消しコードの1オクテット、nオクテットの理由弦）"
    },
    {
      "indent": 3,
      "text": "This subpacket is used only in Key Revocation and Certification Revocation signatures. It describes the reason why the key or certification was revoked.",
      "ja": "このサブパケットは、主要な取り消しおよび認証取消署名でのみ使用されます。キーまたは認定が取り消された理由を説明しています。"
    },
    {
      "indent": 3,
      "text": "The first octet contains a machine-readable code that denotes the reason for the revocation:",
      "ja": "最初のオクテットには、取り消しの理由を示す機械可読コードが含まれています。"
    },
    {
      "indent": 11,
      "text": "+=========+========================================+\n|    Code | Reason                                 |\n+=========+========================================+\n|       0 | No reason specified (Key Revocation or |\n|         | Certification Revocation signatures)   |\n+---------+----------------------------------------+\n|       1 | Key is superseded (Key Revocation      |\n|         | signatures)                            |\n+---------+----------------------------------------+\n|       2 | Key material has been compromised (Key |\n|         | Revocation signatures)                 |\n+---------+----------------------------------------+\n|       3 | Key is retired and no longer used (Key |\n|         | Revocation signatures)                 |\n+---------+----------------------------------------+\n|      32 | User ID information is no longer valid |\n|         | (Certification Revocation signatures)  |\n+---------+----------------------------------------+\n| 100-110 | Private Use                            |\n+---------+----------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 10: OpenPGP Reason for Revocation (Revocation Octet) Registry",
      "ja": "表10：OpenPGP取り消しの理由（取り消しOctet）レジストリ"
    },
    {
      "indent": 3,
      "text": "Following the revocation code is a string of octets that gives information about the Reason for Revocation in human-readable form (UTF-8). The string may be null (of zero length). The length of the subpacket is the length of the reason string plus one. An implementation SHOULD implement this subpacket, include it in all Revocation Signatures, and interpret revocations appropriately. There are important semantic differences between the reasons, and there are thus important reasons for revoking signatures.",
      "ja": "取り消しコードに従うことは、人間が読み取る形式での取り消しの理由に関する情報を提供する一連のオクテットです（UTF-8）。文字列は（長さゼロの）nullにする場合があります。サブパケットの長さは、Reason String Plus Oneの長さです。実装では、このサブパケットを実装し、すべての取り消し署名にそれを含め、取消しを適切に解釈する必要があります。理由には重要なセマンティックな違いがあり、したがって署名を取り消す重要な理由があります。"
    },
    {
      "indent": 3,
      "text": "If a key has been revoked because of a compromise, all signatures created by that key are suspect. However, if it was merely superseded or retired, old signatures are still valid. If the revoked signature is the self-signature for certifying a User ID, a revocation denotes that that user name is no longer in use. Such a signature revocation SHOULD include a Reason for Revocation subpacket containing code 32.",
      "ja": "妥協のためにキーが取り消された場合、そのキーによって作成されたすべての署名が疑わしいです。ただし、単に置き換えられたり廃止されたりした場合、古い署名は依然として有効です。取り消された署名がユーザーIDを証明するための自己署名である場合、取り消しは、そのユーザー名がもはや使用されていないことを示します。このような署名の取り消しには、コード32を含む取り消しサブパケットの理由を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that any certification may be revoked, including a certification on some other person's key. There are many good reasons for revoking a certification signature, such as the case where the keyholder leaves the employ of a business with an email address. A revoked certification is no longer a part of validity calculations.",
      "ja": "他の人の鍵に関する認定を含む、認定が取り消される場合があることに注意してください。キーホルダーが電子メールアドレスを使用してビジネスの雇用を離れる場合など、認定署名を取り消すための多くの正当な理由があります。取り消された認証は、もはや有効計算の一部ではありません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.32. Features",
      "section_title": true,
      "ja": "5.2.3.32. 特徴"
    },
    {
      "indent": 3,
      "text": "(N octets of flags)",
      "ja": "（n旗のオクテット）"
    },
    {
      "indent": 3,
      "text": "The Features subpacket denotes which advanced OpenPGP features a user's implementation supports. This is so that as features are added to OpenPGP that cannot be backward compatible, a user can state that they can use that feature. The flags are single bits that indicate that a given feature is supported.",
      "ja": "Advanced OpenPGPがユーザーの実装サポートを備えている機能を示しています。これは、機能がbackward互換性を持たないOpenPGPに追加されるため、ユーザーはその機能を使用できると述べることができます。フラグは、特定の機能がサポートされていることを示すシングルビットです。"
    },
    {
      "indent": 3,
      "text": "This subpacket is similar to a preferences subpacket and only appears in a self-signature.",
      "ja": "このサブパケットは、設定サブパケットに似ており、自己署名にのみ表示されます。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT use a feature listed when sending to a user who does not state that they can use it, unless the implementation can infer support for the feature from another implementation-dependent mechanism.",
      "ja": "実装は、実装が別の実装依存メカニズムから機能のサポートを推測できない限り、使用できると述べていないユーザーに送信するときにリストされている機能を使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Defined features are as follows:",
      "ja": "定義された機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "First octet:",
      "ja": "最初のオクテット："
    },
    {
      "indent": 7,
      "text": "+=========+=====================================+===========+\n| Feature | Definition                          | Reference |\n+=========+=====================================+===========+\n| 0x01... | Version 1 Symmetrically Encrypted   | Section   |\n|         | and Integrity Protected Data packet | 5.13.1    |\n+---------+-------------------------------------+-----------+\n| 0x02... | Reserved                            |           |\n+---------+-------------------------------------+-----------+\n| 0x04... | Reserved                            |           |\n+---------+-------------------------------------+-----------+\n| 0x08... | Version 2 Symmetrically Encrypted   | Section   |\n|         | and Integrity Protected Data packet | 5.13.2    |\n+---------+-------------------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 11: OpenPGP Features Flags Registry",
      "ja": "表11：OpenPGPには、フラグレジストリがあります"
    },
    {
      "indent": 3,
      "text": "If an implementation implements any of the defined features, it SHOULD implement the Features subpacket, too.",
      "ja": "実装が定義された機能のいずれかを実装する場合、機能サブパケットも実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "See Section 13.7 for details about how to use the Features subpacket when generating encryption data.",
      "ja": "暗号化データを生成するときに機能を使用する方法の詳細については、セクション13.7を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3.33. Signature Target",
      "section_title": true,
      "ja": "5.2.3.33. 署名ターゲット"
    },
    {
      "indent": 3,
      "text": "(1 octet public key algorithm, 1 octet hash algorithm, N octets hash)",
      "ja": "（1オクテットの公開キーアルゴリズム、1オクテットハッシュアルゴリズム、nオクテットハッシュ）"
    },
    {
      "indent": 3,
      "text": "This subpacket identifies a specific target signature to which a signature refers. For Revocation Signatures, this subpacket provides explicit designation of which signature is being revoked. For a Third-Party Confirmation or Timestamp signature, this designates what signature is signed. All arguments are an identifier of that target signature.",
      "ja": "このサブパケットは、署名が参照する特定のターゲット署名を識別します。取り消し署名の場合、このサブパケットは、どの署名が取り消されているかを明示的に指定します。サードパーティの確認またはタイムスタンプの署名の場合、これは署名されている署名を指定します。すべての引数は、そのターゲット署名の識別子です。"
    },
    {
      "indent": 3,
      "text": "The N octets of hash data MUST be the size of the signature's hash. For example, a target signature with a SHA-1 hash MUST have 20 octets of hash data.",
      "ja": "ハッシュデータのnオクテットは、署名のハッシュのサイズでなければなりません。たとえば、SHA-1ハッシュを使用したターゲット署名には、20オクテットのハッシュデータが必要です。"
    },
    {
      "indent": 0,
      "text": "5.2.3.34. Embedded Signature",
      "section_title": true,
      "ja": "5.2.3.34. 埋め込まれた署名"
    },
    {
      "indent": 3,
      "text": "(1 Signature packet body)",
      "ja": "（1つの署名パケットボディ）"
    },
    {
      "indent": 3,
      "text": "This subpacket contains a complete Signature packet body as specified in Section 5.2. It is useful when one signature needs to refer to, or be incorporated in, another signature.",
      "ja": "このサブパケットには、セクション5.2で指定されている完全な署名パケット本体が含まれています。1つの署名が別の署名を参照するか、組み込む必要がある場合に役立ちます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.35. Issuer Fingerprint",
      "section_title": true,
      "ja": "5.2.3.35. 発行者指紋"
    },
    {
      "indent": 3,
      "text": "(1 octet key version number, N octets of fingerprint)",
      "ja": "（1オクテットのキーバージョン番号、指紋のnオクテット）"
    },
    {
      "indent": 3,
      "text": "The OpenPGP Key fingerprint of the key issuing the signature. This subpacket SHOULD be included in all signatures. If the version of the issuing key is 4 and an Issuer Key ID subpacket (Section 5.2.3.12) is also included in the signature, the Key ID of the Issuer Key ID subpacket MUST match the low 64 bits of the fingerprint.",
      "ja": "署名を発行するキーのOpenPGPキー指紋。このサブパケットは、すべての署名に含める必要があります。発行キーのバージョンが4で、発行者キーIDサブパケット（セクション5.2.3.12）も署名に含まれている場合、発行者キーIDサブパケットのキーIDは、指紋の64ビットと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the length N of the fingerprint for a version 4 key is 20 octets; for a version 6 key, N is 32. Since the version of the signature is bound to the version of the key, the version octet here MUST match the version of the signature. If the version octet does not match the signature version, the receiving implementation MUST treat it as a malformed signature (see Section 5.2.5).",
      "ja": "バージョン4キーの指紋の長さNは20オクテットであることに注意してください。バージョン6キーの場合、nは32です。署名のバージョンはキーのバージョンにバインドされるため、ここのバージョンは署名のバージョンと一致する必要があります。バージョンのオクテットが署名バージョンと一致しない場合、受信実装はそれを奇形の署名として扱う必要があります（セクション5.2.5を参照）。"
    },
    {
      "indent": 0,
      "text": "5.2.3.36. Intended Recipient Fingerprint",
      "section_title": true,
      "ja": "5.2.3.36. 意図された受信者指紋"
    },
    {
      "indent": 3,
      "text": "(1 octet key version number, N octets of fingerprint)",
      "ja": "（1オクテットのキーバージョン番号、指紋のnオクテット）"
    },
    {
      "indent": 3,
      "text": "The OpenPGP Key fingerprint of the intended recipient primary key. If one or more subpackets of this type are included in a signature, it SHOULD be considered valid only in an encrypted context, where the key it was encrypted to is one of the indicated primary keys or one of their subkeys. This can be used to prevent forwarding a signature outside of its intended, encrypted context (see Section 13.12).",
      "ja": "意図した受信者の主キーのOpenPGPキー指紋。このタイプの1つ以上のサブパケットが署名に含まれている場合、暗号化されたコンテキストでのみ有効と見なされる必要があります。暗号化されたキーは、示された主要なキーまたはサブキーの1つです。これは、意図した暗号化されたコンテキストの外側の署名を転送するのを防ぐために使用できます（セクション13.12を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that the length N of the fingerprint for a version 4 key is 20 octets; for a version 6 key, N is 32.",
      "ja": "バージョン4キーの指紋の長さNは20オクテットであることに注意してください。バージョン6キーの場合、nは32です。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD generate this subpacket when creating a signed and encrypted message.",
      "ja": "署名された暗号化されたメッセージを作成するときに、このサブパケットを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "When generating this subpacket in a version 6 signature, it SHOULD be marked as critical.",
      "ja": "バージョン6の署名でこのサブパケットを生成する場合、重要なものとしてマークする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Computing Signatures",
      "section_title": true,
      "ja": "5.2.4. コンピューティング署名"
    },
    {
      "indent": 3,
      "text": "All signatures are formed by producing a hash over the signature data and then using the resulting hash in the signature algorithm.",
      "ja": "すべての署名は、署名データ上にハッシュを生成し、署名アルゴリズムで結果のハッシュを使用することにより形成されます。"
    },
    {
      "indent": 3,
      "text": "When creating or verifying a version 6 signature, the salt is fed into the hash context before any other data.",
      "ja": "バージョン6の署名を作成または検証するとき、塩は他のデータの前にハッシュコンテキストに供給されます。"
    },
    {
      "indent": 3,
      "text": "For binary document signatures (Type ID 0x00), the document data is hashed directly. For text document signatures (Type ID 0x01), the implementation MUST first canonicalize the document by converting line endings to <CR><LF> and encoding it in UTF-8 (see [RFC3629]). The resulting UTF-8 byte stream is hashed.",
      "ja": "バイナリドキュメント署名（タイプID 0x00）の場合、ドキュメントデータは直接ハッシュされます。テキストドキュメントの署名（タイプID 0x01）の場合、実装は最初に行の終わりを<cr> <lf>に変換し、UTF-8でエンコードすることにより、ドキュメントを正規化する必要があります（[RFC3629]を参照）。結果のUTF-8バイトストリームはハッシュされます。"
    },
    {
      "indent": 3,
      "text": "When a version 4 signature is made over a key, the hash data starts with the octet 0x99, followed by a 2-octet length of the key, followed by the body of the key packet. When a version 6 signature is made over a key, the hash data starts with the salt and then octet 0x9B, followed by a 4-octet length of the key, followed by the body of the key packet.",
      "ja": "キー上にバージョン4の署名が作成されると、ハッシュデータはOctet 0x99で始まり、キーの2オクテットの長さが続き、その後にキーパケットの本文が続きます。キー上にバージョン6の署名が作成されると、ハッシュデータは塩から始まり、次にオクテット0x9bで始まり、キーの4オクテットの長さが続き、その後キーパケットの本体が続きます。"
    },
    {
      "indent": 3,
      "text": "A Subkey Binding signature (Type ID 0x18) or Primary Key Binding signature (Type ID 0x19) then hashes the subkey using the same format as the main key (also using 0x99 or 0x9B as the first octet). Primary Key Revocation signatures (Type ID 0x20) hash only the key being revoked. A Subkey Revocation signature (Type ID 0x28) first hashes the primary key and then the subkey being revoked.",
      "ja": "サブキーバインディングシグネチャ（タイプID 0x18）またはプライマリキーバインディング署名（タイプID 0x19）は、メインキーと同じ形式を使用してサブキーをハッシュします（最初のオクテットとして0x99または0x9bを使用）。プライマリキーの取り消し署名（タイプID 0x20）ハッシュは、取り消されているキーのみをハッシュします。サブキーの取り消し署名（タイプID 0x28）が最初に主キーをハッシュし、次にサブキーが取り消されます。"
    },
    {
      "indent": 3,
      "text": "A Certification signature (Type IDs 0x10 through 0x13) hashes the User ID that is bound to the key into the hash context after the above data. A version 3 certification hashes the contents of the User ID or User Attribute packet without the packet header. A version 4 or version 6 certification hashes the constant 0xB4 for User ID certifications or the constant 0xD1 for User Attribute certifications, followed by a 4-octet number giving the length of the User ID or User Attribute data, followed by the User ID or User Attribute data.",
      "ja": "認定署名（タイプIDS 0x10〜0x13）は、上記のデータの後にキーにハッシュコンテキストにバインドされているユーザーIDをハッシュします。バージョン3の認定は、パケットヘッダーなしでユーザーIDまたはユーザー属性パケットの内容をハッシュします。バージョン4またはバージョン6の認証は、ユーザーID認定の定数0xB4またはユーザー属性認証の定数0xD1をハッシュし、その後、ユーザーIDまたはユーザー属性データの長さを与える4オクテット番号が続き、その後にユーザーIDまたはユーザーが続きます。属性データ。"
    },
    {
      "indent": 3,
      "text": "A Third-Party Confirmation signature (Type ID 0x50) hashes the salt (version 6 signatures only), followed by the octet 0x88, followed by the 4-octet length of the signature, and then the body of the Signature packet. (Note that this is a Legacy packet header for a Signature packet with the length-of-length field set to zero.) The unhashed subpacket data of the Signature packet being hashed is not included in the hash, and the unhashed subpacket data length value is set to zero.",
      "ja": "サードパーティの確認署名（タイプID 0x50）は、塩（バージョン6署名のみ）をハッシュし、その後Octet 0x88が続き、その後、署名の4オクテットの長さ、次に署名パケットの本文が続きます。（これは、長さの長さのフィールドがゼロに設定された署名パケットのレガシーパケットヘッダーであることに注意してください。）ハッシュされている署名パケットの未塗りのサブパケットデータは、ハッシュに含まれていません。ゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "Once the data body is hashed, then a trailer is hashed. This trailer depends on the version of the signature.",
      "ja": "データ本体がハッシュされると、トレーラーがハッシュされます。この予告編は、署名のバージョンに依存します。"
    },
    {
      "indent": 6,
      "text": "* A version 3 signature hashes five octets of the packet body, starting from the signature type field. This data is the signature type, followed by the 4-octet Signature Creation Time.",
      "ja": "* バージョン3の署名は、署名タイプフィールドから始まるパケット本体の5オクテットをハッシュします。このデータは署名タイプであり、4オクテットの署名作成時間が続きます。"
    },
    {
      "indent": 6,
      "text": "* A version 4 or version 6 signature hashes the packet body starting from its first field, the version number, through the end of the hashed subpacket data and a final extra trailer. Thus, the hashed fields are:",
      "ja": "* バージョン4またはバージョン6の署名は、ハッシュされたサブパケットデータと最後の追加トレーラーの端から、最初のフィールドであるバージョン番号から始まるパケット本体をハッシュします。したがって、ハッシュされたフィールドは次のとおりです。"
    },
    {
      "indent": 12,
      "text": "- an octet indicating the signature version (0x04 for version 4, and 0x06 for version 6),",
      "ja": "- 署名バージョンを示すオクテット（バージョン4の場合は0x04、バージョン6の場合は0x06）、"
    },
    {
      "indent": 12,
      "text": "- the signature type,",
      "ja": "- 署名タイプ、"
    },
    {
      "indent": 12,
      "text": "- the public key algorithm,",
      "ja": "- 公開キーアルゴリズム、"
    },
    {
      "indent": 12,
      "text": "- the hash algorithm,",
      "ja": "- ハッシュアルゴリズム、"
    },
    {
      "indent": 12,
      "text": "- the hashed subpacket length,",
      "ja": "- ハッシュされたサブパケットの長さ、"
    },
    {
      "indent": 12,
      "text": "- the hashed subpacket body,",
      "ja": "- ハッシュされたサブパケット本体、"
    },
    {
      "indent": 12,
      "text": "- a second version octet (0x04 for version 4, and 0x06 for version 6),",
      "ja": "- 2番目のバージョンOctet（バージョン4の場合は0x04、バージョン6の場合は0x06）、"
    },
    {
      "indent": 12,
      "text": "- a single octet 0xFF, and",
      "ja": "- 単一のオクテット0xff、および"
    },
    {
      "indent": 12,
      "text": "- a number representing the length (in octets) of the hashed data from the Signature packet through the hashed subpacket body. This a 4-octet big-endian unsigned integer of the length modulo 2^32.",
      "ja": "- ハッシュされたサブパケット本体を介した署名パケットからのハッシュされたデータの長さ（オクテット）を表す数字。これは、長さモジュロ2^32の4オクテットのビッグエンディアンの署名されていない整数です。"
    },
    {
      "indent": 3,
      "text": "After all this has been hashed in a single hash context, the resulting hash field is used in the signature algorithm, and its first two octets are placed in the Signature packet, as described in Section 5.2.3.",
      "ja": "すべてが単一のハッシュコンテキストでハッシュされた後、結果のハッシュフィールドが署名アルゴリズムで使用され、セクション5.2.3で説明されているように、最初の2つのオクテットが署名パケットに配置されます。"
    },
    {
      "indent": 3,
      "text": "For worked examples of the data hashed during a signature, see Appendix A.3.1.",
      "ja": "署名中にハッシュされたデータの作業例については、付録A.3.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1. Notes about Signature Computation",
      "section_title": true,
      "ja": "5.2.4.1. 署名計算に関するメモ"
    },
    {
      "indent": 3,
      "text": "The data actually hashed by OpenPGP varies depending on the signature version, in order to ensure that a signature made using one version cannot be repurposed as a signature with a different version over subtly different data. The hashed data streams differ based on their trailer, most critically in the fifth and sixth octets from the end of the stream. In particular:",
      "ja": "実際にOpenPGPによってハッシュされたデータは、署名バージョンによって異なります。1つのバージョンを使用して作成された署名を、微妙に異なるデータよりも異なるバージョンの署名として再利用できないようにします。ハッシュされたデータストリームは、トレーラーに基づいて異なります。これは、ストリームの端から5番目と6番目のオクテットで最も重要です。特に："
    },
    {
      "indent": 6,
      "text": "* A version 3 signature uses the fifth octet from the end to store its Signature Type ID. This MUST NOT be Signature Type ID 0xFF.",
      "ja": "* バージョン3の署名では、署名タイプIDを保存するために、最後から5番目のオクテットを使用します。これは、署名タイプID 0xffであってはなりません。"
    },
    {
      "indent": 6,
      "text": "* All signature versions later than version 3 always use a literal 0xFF in the fifth octet from the end. For these later signature versions, the sixth octet from the end (the octet before the 0xFF) stores the signature version number.",
      "ja": "* バージョン3より後のすべての署名バージョンは、最後から5番目のオクテットでリテラル0xffを常に使用します。これらの後の署名バージョンでは、最後から6番目のオクテット（0xffの前のオクテット）に署名バージョン番号が保存されます。"
    },
    {
      "indent": 0,
      "text": "5.2.5. Malformed and Unknown Signatures",
      "section_title": true,
      "ja": "5.2.5. 奇形および未知の署名"
    },
    {
      "indent": 3,
      "text": "In some cases, a Signature packet (or its corresponding One-Pass Signature packet; see Section 5.4) may be malformed or unknown. For example, it might encounter any of the following problems (this is not an exhaustive list):",
      "ja": "場合によっては、署名パケット（または対応するワンパスシグネチャパケット、セクション5.4を参照）が不正行為または不明である場合があります。たとえば、次の問題のいずれかに遭遇する可能性があります（これは網羅的なリストではありません）："
    },
    {
      "indent": 6,
      "text": "* An unknown signature type",
      "ja": "* 未知の署名タイプ"
    },
    {
      "indent": 6,
      "text": "* An unknown signature version",
      "ja": "* 未知の署名バージョン"
    },
    {
      "indent": 6,
      "text": "* An unsupported signature version",
      "ja": "* サポートされていない署名バージョン"
    },
    {
      "indent": 6,
      "text": "* An unknown \"critical\" subpacket (see Section 5.2.3.7) in the hashed area",
      "ja": "* ハッシュされた領域の未知の「クリティカル」サブパケット（セクション5.2.3.7を参照）"
    },
    {
      "indent": 6,
      "text": "* A subpacket with a length that diverges from the expected length",
      "ja": "* 予想される長さから分岐する長さのサブパケット"
    },
    {
      "indent": 6,
      "text": "* A hashed subpacket area with length that exceeds the length of the Signature packet itself",
      "ja": "* 署名パケット自体の長さを超える長さのハッシュされたサブパケット領域"
    },
    {
      "indent": 6,
      "text": "* A hash algorithm known to be weak (e.g., MD5)",
      "ja": "* 弱いことが知られているハッシュアルゴリズム（例：MD5）"
    },
    {
      "indent": 6,
      "text": "* A mismatch between the expected salt length of the hash algorithm and the actual salt length",
      "ja": "* ハッシュアルゴリズムの予想される塩の長さと実際の塩の長さとの間の不一致"
    },
    {
      "indent": 6,
      "text": "* A mismatch between the One-Pass Signature version and the Signature version (see Section 10.3.2.2)",
      "ja": "* ワンパス署名バージョンと署名バージョンの間の不一致（セクション10.3.2.2を参照）"
    },
    {
      "indent": 6,
      "text": "* A signature with a version other than 6, made by a version 6 key",
      "ja": "* バージョン6キーによって作成された6以外のバージョンを備えた署名"
    },
    {
      "indent": 3,
      "text": "When an implementation encounters such a malformed or unknown signature, it MUST ignore the signature for validation purposes. It MUST NOT indicate a successful signature validation for such a signature. At the same time, it MUST NOT halt processing on the packet stream or reject other signatures in the same packet stream just because an unknown or invalid signature exists.",
      "ja": "実装がそのような奇形または未知の署名に遭遇する場合、検証目的で署名を無視する必要があります。このような署名の署名検証が成功してはなりません。同時に、パケットストリームでの処理を停止したり、同じパケットストリームで他の署名を拒否したりしてはなりません。"
    },
    {
      "indent": 3,
      "text": "This requirement is necessary for forward compatibility. Producing an output that indicates that no successful signatures were found is preferable to aborting processing entirely.",
      "ja": "この要件は、順方向の互換性に必要です。成功した署名が見つからなかったことを示す出力を生成することは、処理を完全に中止するよりも望ましい。"
    },
    {
      "indent": 0,
      "text": "5.3. Symmetric Key Encrypted Session Key Packet (Type ID 3)",
      "section_title": true,
      "ja": "5.3. 対称キー暗号化セッションキーパケット（タイプID 3）"
    },
    {
      "indent": 3,
      "text": "The Symmetric Key Encrypted Session Key (SKESK) packet holds the symmetric key encryption of a session key used to encrypt a message. Zero or more Public Key Encrypted Session Key packets (Section 5.1) and/or Symmetric Key Encrypted Session Key packets precede an encryption container (that is, a Symmetrically Encrypted and Integrity Protected Data packet or -- for historic data -- a Symmetrically Encrypted Data packet) that holds an Encrypted Message. The message is encrypted with a session key, and the session key is itself encrypted and stored in the Encrypted Session Key packet(s).",
      "ja": "対称キー暗号化セッションキー（SKESK）パケットは、メッセージの暗号化に使用されるセッションキーの対称キー暗号化を保持します。ゼロ以上の公開キー暗号化セッションキーパケット（セクション5.1）および/または対称キー暗号化セッションキーパケットは、暗号化コンテナ（つまり、対称的に暗号化された整合性保護データパケットまたは歴史的なデータの場合 - 対称的に暗号化されたデータパケットの前にあります。パケット）暗号化されたメッセージを保持します。メッセージはセッションキーで暗号化され、セッションキーはそれ自体が暗号化され、暗号化されたセッションキーパケットに保存されます。"
    },
    {
      "indent": 3,
      "text": "If the encryption container is preceded by one or more Symmetric Key Encrypted Session Key packets, each specifies a passphrase that may be used to decrypt the message. This allows a message to be encrypted to a number of public keys, and also to one or more passphrases.",
      "ja": "暗号化コンテナの前に、1つ以上の対称キー暗号化セッションキーパケットがある場合、それぞれがメッセージの解読に使用できるパスフレーゼを指定します。これにより、メッセージを多くのパブリックキー、および1つ以上のパスフレーズに暗号化できます。"
    },
    {
      "indent": 3,
      "text": "The body of this packet starts with a 1-octet number giving the version number of the packet type. The currently defined versions are 4 and 6. The remainder of the packet depends on the version.",
      "ja": "このパケットの本体は、パケットタイプのバージョン番号を与える1オクテット番号から始まります。現在定義されているバージョンは4と6です。パケットの残りの部分はバージョンに依存します。"
    },
    {
      "indent": 3,
      "text": "The versions differ in how they encrypt the session key with the passphrase and in what they encode. The version of the SKESK packet must align with the version of the SEIPD packet (see Section 10.3.2.1). Any new version of the SKESK packet should be registered in the registry established in Section 10.3.2.1.",
      "ja": "バージョンは、セッションキーをパスフレーズとエンコードする方法とエンコードする方法が異なります。Skeskパケットのバージョンは、SEIPDパケットのバージョンと一致する必要があります（セクション10.3.2.1を参照）。Skeskパケットの新しいバージョンは、セクション10.3.2.1で確立されたレジストリに登録する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Version 4 Symmetric Key Encrypted Session Key Packet Format",
      "section_title": true,
      "ja": "5.3.1. バージョン4対称キー暗号化セッションキーパケット形式"
    },
    {
      "indent": 3,
      "text": "A v4 SKESK packet precedes a v1 SEIPD (see Section 5.13.1). In historic data, it is sometimes found preceding a deprecated SED packet (see Section 5.7). A v4 SKESK packet MUST NOT precede a v2 SEIPD packet (see Section 10.3.2.1).",
      "ja": "V4 Skeskパケットは、V1 SEIPDの前にあります（セクション5.13.1を参照）。歴史的なデータでは、非推奨のSEDパケットの前に見られることがあります（セクション5.7を参照）。V4 SKESKパケットは、V2 SEIPDパケットの前にいない必要があります（セクション10.3.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "A version 4 Symmetric Key Encrypted Session Key packet consists of:",
      "ja": "バージョン4対称キー暗号化セッションキーパケットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number with value 4.",
      "ja": "* 値4の1-OCTETバージョン番号。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number describing the symmetric algorithm used.",
      "ja": "* 使用される対称アルゴリズムを記述する1オクセット番号。"
    },
    {
      "indent": 6,
      "text": "* An S2K Specifier. The length of the S2K Specifier depends on its type (see Section 3.7.1).",
      "ja": "* S2K仕様。S2K仕様の長さは、そのタイプに依存します（セクション3.7.1を参照）。"
    },
    {
      "indent": 6,
      "text": "* Optionally, the encrypted session key itself, which is decrypted with the S2K object.",
      "ja": "* オプションで、S2Kオブジェクトで復号化された暗号化されたセッションキー自体。"
    },
    {
      "indent": 3,
      "text": "If the encrypted session key is not present (which can be detected on the basis of packet length and S2K Specifier size), then the S2K algorithm applied to the passphrase produces the session key for decrypting the message, using the Symmetric Cipher Algorithm ID from the Symmetric Key Encrypted Session Key packet.",
      "ja": "暗号化されたセッションキーが存在しない場合（これはパケットの長さとS2K仕様サイズに基づいて検出できます）、PassPhraseに適用されるS2Kアルゴリズムは、対称CipherアルゴリズムIDを使用してメッセージを解読するためのセッションキーを生成します。対称キー暗号化セッションキーパケット。"
    },
    {
      "indent": 3,
      "text": "If the encrypted session key is present, the result of applying the S2K algorithm to the passphrase is used to decrypt just that encrypted session key field, using CFB mode with an IV of all zeros. The decryption result consists of a 1-octet algorithm identifier that specifies the symmetric key encryption algorithm used to encrypt the following encryption container, followed by the session key octets themselves.",
      "ja": "暗号化されたセッションキーが存在する場合、S2KアルゴリズムをPassPhraseに適用した結果は、すべてのゼロのIVを使用してCFBモードを使用して、暗号化されたセッションキーフィールドのみを解読するために使用されます。復号化の結果は、次の暗号化コンテナを暗号化するために使用される対称キー暗号化アルゴリズムを指定する1-OCTETアルゴリズム識別子で構成され、セッションキーオクテット自体が続きます。"
    },
    {
      "indent": 3,
      "text": "Note: because an all-zero IV is used for this decryption, the S2K Specifier MUST use a salt value, a Salted S2K, an Iterated and Salted S2K, or Argon2. The salt value will ensure that the decryption key is not repeated even if the passphrase is reused.",
      "ja": "注：この復号化には全ゼロIVが使用されるため、S2K指定器は塩値、塩漬けS2K、反復および塩漬けS2K、またはArgon2を使用する必要があります。塩値は、パスフレーズが再利用されていても、復号化キーが繰り返されないようにします。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Version 6 Symmetric Key Encrypted Session Key Packet Format",
      "section_title": true,
      "ja": "5.3.2. バージョン6対称キー暗号化セッションキーパケット形式"
    },
    {
      "indent": 3,
      "text": "A v6 SKESK packet precedes a v2 SEIPD packet (see Section 5.13.2). A v6 SKESK packet MUST NOT precede a v1 SEIPD packet or a deprecated Symmetrically Encrypted Data packet (see Section 10.3.2.1).",
      "ja": "V6 Skeskパケットは、V2 SEIPDパケットの前にあります（セクション5.13.2を参照）。V6 SKESKパケットは、V1 SEIPDパケットまたは非推定された対称的に暗号化されたデータパケットの前にしてはなりません（セクション10.3.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "A version 6 Symmetric Key Encrypted Session Key packet consists of:",
      "ja": "バージョン6対称キー暗号化セッションキーパケットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number with value 6.",
      "ja": "* 値6の1-OCTETバージョン番号。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet scalar octet count for the 5 fields following this octet.",
      "ja": "* このオクテットに続く5つのフィールドの1-OCTETスカラーオクテットカウント。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet Symmetric Cipher Algorithm ID (from Table 21).",
      "ja": "* 1-OCTET対称暗号アルゴリズムID（表21から）。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet AEAD algorithm identifier (from Table 25).",
      "ja": "* 1-OCTET AEADアルゴリズム識別子（表25から）。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet scalar octet count of the following field.",
      "ja": "* 次のフィールドの1-OCTETスカラーオクテットカウント。"
    },
    {
      "indent": 6,
      "text": "* An S2K Specifier. The length of the S2K Specifier depends on its type (see Section 3.7.1).",
      "ja": "* S2K仕様。S2K仕様の長さは、そのタイプに依存します（セクション3.7.1を参照）。"
    },
    {
      "indent": 6,
      "text": "* A starting IV of the size specified by the AEAD algorithm.",
      "ja": "* AEADアルゴリズムによって指定されたサイズの開始IV。"
    },
    {
      "indent": 6,
      "text": "* The encrypted session key itself.",
      "ja": "* 暗号化されたセッションキー自体。"
    },
    {
      "indent": 6,
      "text": "* An authentication tag for the AEAD mode.",
      "ja": "* AEADモードの認証タグ。"
    },
    {
      "indent": 3,
      "text": "A key-encryption key (KEK) is derived using HKDF [RFC5869] with SHA256 [RFC6234] as the hash algorithm. The Initial Keying Material (IKM) for HKDF is the key derived from S2K. No salt is used. The info parameter is comprised of the Packet Type ID in OpenPGP format encoding (bits 7 and 6 are set, and bits 5-0 carry the Packet Type ID), the packet version, and the cipher-algo and AEAD-mode used to encrypt the key material.",
      "ja": "キー暗号化キー（KEK）は、ハッシュアルゴリズムとしてSHA256 [RFC6234]を使用してHKDF [RFC5869]を使用して導出されます。HKDFの最初のキーイング材料（IKM）は、S2Kから派生したキーです。塩は使用されていません。情報パラメーターは、OpenPGP形式のエンコード（ビット7および6が設定され、5-0がパケットタイプIDを運ぶ）、パケットバージョン、および暗号化に使用されるcipher-algoとAeadモードを5-0でエンコードするパケットタイプIDで構成されています重要な素材。"
    },
    {
      "indent": 3,
      "text": "Then, the session key is encrypted using the resulting key, with the AEAD algorithm specified for the version 2 Symmetrically Encrypted and Integrity Protected Data packet. Note that no chunks are used and that there is only one authentication tag. The Packet Type ID encoded in OpenPGP format (bits 7 and 6 are set, and bits 5-0 carry the Packet Type ID), the packet version number, the cipher algorithm ID, and the AEAD algorithm ID are given as additional data. For example, the additional data used with AES-128 with OCB consists of the octets 0xC3, 0x06, 0x07, and 0x02.",
      "ja": "次に、セッションキーは、結果のキーを使用して暗号化され、バージョン2に対称的に暗号化され、整合性保護されたデータパケットに指定されたAEADアルゴリズムを使用します。チャンクは使用されておらず、認証タグは1つだけであることに注意してください。OpenPGP形式でエンコードされたパケットタイプID（ビット7および6が設定され、ビット5-0がパケットタイプIDを運びます）、パケットバージョン番号、暗号アルゴリズムID、およびAEADアルゴリズムIDが追加データとして与えられます。たとえば、OCBでAES-128で使用される追加データは、オクテット0xc3、0x06、0x07、および0x02で構成されています。"
    },
    {
      "indent": 0,
      "text": "5.4. One-Pass Signature Packet (Type ID 4)",
      "section_title": true,
      "ja": "5.4. ワンパス署名パケット（タイプID 4）"
    },
    {
      "indent": 3,
      "text": "The One-Pass Signature packet precedes the signed data and contains enough information to allow the receiver to begin calculating any hashes needed to verify the signature. It allows the Signature packet to be placed at the end of the message so that the signer can compute the entire signed message in one pass.",
      "ja": "ワンパス署名パケットは、署名されたデータの前に、署名を確認するために必要なハッシュの計算を開始できるようにするのに十分な情報が含まれています。これにより、署名パケットをメッセージの最後に配置して、署名者が1つのパスで署名されたメッセージ全体を計算できるようにします。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number. The currently defined versions are 3 and 6. Any new One-Pass Signature packet version should be registered in the registry established in Section 10.3.2.2.",
      "ja": "* 1-OCTETバージョン番号。現在定義されているバージョンは3と6です。新しい1パス署名パケットバージョンは、セクション10.3.2.2に確立されたレジストリに登録する必要があります。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet Signature Type ID. Signature types are described in Section 5.2.1.",
      "ja": "* 1-OCTET署名タイプID。署名タイプは、セクション5.2.1で説明されています。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number describing the hash algorithm used.",
      "ja": "* 使用されたハッシュアルゴリズムを説明する1オクセット番号。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number describing the public key algorithm used.",
      "ja": "* 使用されている公開キーアルゴリズムを説明する1オクセット番号。"
    },
    {
      "indent": 6,
      "text": "* Only for version 6 packets, a variable-length field containing:",
      "ja": "* バージョン6パケットのみ、次のような可変長フィールドを含む："
    },
    {
      "indent": 12,
      "text": "- A 1-octet salt size. The value MUST match the value defined for the hash algorithm as specified in Table 23.",
      "ja": "- 1オクテットの塩のサイズ。値は、表23に指定されているハッシュアルゴリズムの定義された値と一致する必要があります。"
    },
    {
      "indent": 12,
      "text": "- The salt; a random value of the specified size. The value MUST match the salt field of the corresponding Signature packet.",
      "ja": "- 塩;指定されたサイズのランダム値。値は、対応する署名パケットの塩フィールドと一致する必要があります。"
    },
    {
      "indent": 6,
      "text": "* Only for v3 packets, an 8-octet number holding the Key ID of the signing key.",
      "ja": "* V3パケットのみ、署名キーのキーIDを保持している8オクテット番号。"
    },
    {
      "indent": 6,
      "text": "* Only for version 6 packets, 32 octets of the fingerprint of the signing key. Since a version 6 signature can only be made by a version 6 key, the length of the fingerprint is fixed.",
      "ja": "* バージョン6パケットのみ、署名キーの指紋の32オクテット。バージョン6の署名はバージョン6キーでのみ作成できるため、指紋の長さは固定されています。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number holding a flag showing whether the signature is nested. A zero value indicates that the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.",
      "ja": "* 署名がネストされているかどうかを示すフラグを保持している1-OCTET番号。ゼロ値は、次のパケットが同じメッセージデータに適用される別の署名を説明する別の1パス署名パケットであることを示します。"
    },
    {
      "indent": 3,
      "text": "When generating a one-pass signature, the OPS packet version MUST correspond to the version of the associated Signature packet, except for the historical accident that version 4 keys use a version 3 One-Pass Signature packet (there is no version 4 OPS). See Section 10.3.2.2 for the full correspondence of versions between Keys, Signatures, and One-Pass Signatures.",
      "ja": "ワンパス署名を生成する場合、OPSパケットバージョンは、バージョン4キーがバージョン3のワンパス署名パケットを使用する歴史的事故を除き、関連する署名パケットのバージョンに対応する必要があります（バージョン4 OPSはありません）。キー、署名、およびワンパス署名間のバージョンの完全な対応については、セクション10.3.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that if a message contains more than one one-pass signature, then the Signature packets bracket the message; that is, the first Signature packet after the message corresponds to the last One-Pass Signature packet and the final Signature packet corresponds to the first One-Pass Signature packet.",
      "ja": "メッセージに複数のワンパス署名が含まれている場合、署名パケットがメッセージをブラケットにしていることに注意してください。つまり、メッセージの後の最初の署名パケットは、最後の1パス署名パケットに対応し、最終的な署名パケットは最初のワンパス署名パケットに対応します。"
    },
    {
      "indent": 0,
      "text": "5.5. Key Material Packets",
      "section_title": true,
      "ja": "5.5. キーマテリアルパケット"
    },
    {
      "indent": 3,
      "text": "A key material packet contains all the information about a public or private key. There are four variants of this packet type: two major versions (versions 4 and 6) and two strongly deprecated versions (versions 2 and 3). Consequently, this section is complex.",
      "ja": "キーマテリアルパケットには、パブリックキーまたは秘密鍵に関するすべての情報が含まれています。このパケットタイプには、2つの主要なバージョン（バージョン4および6）と2つの強く非推奨バージョン（バージョン2および3）の4つのバリエーションがあります。その結果、このセクションは複雑です。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, versions 1 and 5 of the key packets are unspecified.",
      "ja": "歴史的な理由から、キーパケットのバージョン1と5は特定されていません。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Key Packet Variants",
      "section_title": true,
      "ja": "5.5.1. キーパケットバリアント"
    },
    {
      "indent": 0,
      "text": "5.5.1.1. Public Key Packet (Type ID 6)",
      "section_title": true,
      "ja": "5.5.1.1. 公開キーパケット（タイプID 6）"
    },
    {
      "indent": 3,
      "text": "A Public Key packet starts a series of packets that forms an OpenPGP Key (sometimes called an OpenPGP certificate).",
      "ja": "公開キーパケットは、OpenPGPキー（OpenPGP証明書と呼ばれることもある）を形成する一連のパケットを開始します。"
    },
    {
      "indent": 0,
      "text": "5.5.1.2. Public Subkey Packet (Type ID 14)",
      "section_title": true,
      "ja": "5.5.1.2. パブリックサブキーパケット（タイプID 14）"
    },
    {
      "indent": 3,
      "text": "A Public Subkey packet (Type ID 14) has exactly the same format as a Public Key packet, but it denotes a subkey. One or more subkeys may be associated with a top-level key. By convention, the top-level key offers certification capability, but it does not provide encryption services, while a dedicated subkey provides encryption (see Section 10.1.5).",
      "ja": "パブリックサブキーパケット（タイプID 14）は、公開キーパケットとまったく同じ形式ですが、サブキーを示します。1つ以上のサブキーがトップレベルのキーに関連付けられている場合があります。慣習により、トップレベルのキーは認証機能を提供しますが、暗号化サービスは提供されませんが、専用のサブキーは暗号化を提供します（セクション10.1.5を参照）。"
    },
    {
      "indent": 0,
      "text": "5.5.1.3. Secret Key Packet (Type ID 5)",
      "section_title": true,
      "ja": "5.5.1.3. シークレットキーパケット（タイプID 5）"
    },
    {
      "indent": 3,
      "text": "A Secret Key packet contains all the information that is found in a Public Key packet, including the public key material, but it also includes the secret key material after all the public key fields.",
      "ja": "シークレットキーパケットには、公開キーの資料を含む公開キーパケットにあるすべての情報が含まれていますが、すべての公開キーフィールドの後のシークレットキー資料も含まれています。"
    },
    {
      "indent": 0,
      "text": "5.5.1.4. Secret Subkey Packet (Type ID 7)",
      "section_title": true,
      "ja": "5.5.1.4. シークレットサブキーパケット（タイプID 7）"
    },
    {
      "indent": 3,
      "text": "A Secret Subkey packet (Type ID 7) is the subkey analog of the Secret Key packet and has exactly the same format.",
      "ja": "Secret Subkeyパケット（タイプID 7）は、Secret Keyパケットのサブキーアナログであり、まったく同じ形式です。"
    },
    {
      "indent": 0,
      "text": "5.5.2. Public Key Packet Formats",
      "section_title": true,
      "ja": "5.5.2. 公開キーパケット形式"
    },
    {
      "indent": 3,
      "text": "There are four versions of key material packets. Versions 2 and 3 have been deprecated since 1998. Version 4 has been deprecated by this document.",
      "ja": "キーマテリアルパケットには4つのバージョンがあります。バージョン2と3は1998年以来非推奨されています。バージョン4はこの文書によって非推奨されています。"
    },
    {
      "indent": 3,
      "text": "OpenPGP implementations SHOULD create keys with version 6 format. Version 4 keys are deprecated; an implementation SHOULD NOT generate a version 4 key but SHOULD accept it. Version 3 keys are deprecated; an implementation MUST NOT generate a version 3 key but MAY accept it. Version 2 keys are deprecated; an implementation MUST NOT generate a version 2 key but MAY accept it.",
      "ja": "OpenPGP実装では、バージョン6形式のキーを作成する必要があります。バージョン4キーは非推奨です。実装はバージョン4キーを生成するものではなく、それを受け入れる必要があります。バージョン3キーは非推奨です。実装はバージョン3キーを生成してはなりませんが、それを受け入れることができます。バージョン2キーは非推奨です。実装はバージョン2キーを生成してはなりませんが、それを受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "Any new Key Version must be registered in the registry established in Section 10.3.2.2.",
      "ja": "新しいキーバージョンは、セクション10.3.2.2に確立されたレジストリに登録する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.2.1. Version 3 Public Keys",
      "section_title": true,
      "ja": "5.5.2.1. バージョン3パブリックキー"
    },
    {
      "indent": 3,
      "text": "Version 2 keys are identical to version 3 keys except for the version number. A version 3 Public Key or Public Subkey packet contains:",
      "ja": "バージョン2のキーは、バージョン番号を除き、バージョン3キーと同じです。バージョン3の公開キーまたはパブリックサブキーパケットには以下が含まれています。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number (3).",
      "ja": "* 1-OCTETバージョン番号（3）。"
    },
    {
      "indent": 6,
      "text": "* A 4-octet number denoting the time that the key was created.",
      "ja": "* キーが作成された時間を示す4-OCTET番号。"
    },
    {
      "indent": 6,
      "text": "* A 2-octet number denoting the time in days that the key is valid. If this number is zero, then it does not expire.",
      "ja": "* キーが有効である日の時間を示す2オクテット数。この数値がゼロの場合、期限切れになりません。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number denoting the public key algorithm of the key.",
      "ja": "* キーの公開キーアルゴリズムを示す1-OCTET番号。"
    },
    {
      "indent": 6,
      "text": "* A series of multiprecision integers comprising the key material:",
      "ja": "* 重要な材料を含む一連の多重整数："
    },
    {
      "indent": 12,
      "text": "- MPI of RSA public modulus n.",
      "ja": "- RSAパブリックモジュラスnのMPI。"
    },
    {
      "indent": 12,
      "text": "- MPI of RSA public encryption exponent e.",
      "ja": "- RSAパブリック暗号化指数eのMPI e。"
    },
    {
      "indent": 3,
      "text": "Version 3 keys are deprecated. They contain three weaknesses. First, it is relatively easy to construct a version 3 key that has the same Key ID as any other key because the Key ID is simply the low 64 bits of the public modulus. Second, because the fingerprint of a version 3 key hashes the key material, but not its length, there is an increased opportunity for fingerprint collisions. Third, there are weaknesses in the MD5 hash algorithm that cause developers to prefer other algorithms. See Section 5.5.4 for a fuller discussion of Key IDs and fingerprints.",
      "ja": "バージョン3キーは非推奨です。それらには3つの弱点が含まれています。まず、キーIDはパブリックモジュラスの64ビットだけであるため、他のキーと同じキーIDを持つバージョン3キーを構築するのは比較的簡単です。第二に、バージョン3のキーの指紋は重要な素材をハッシュしますが、その長さではなく、指紋衝突の機会が増えています。第三に、MD5ハッシュアルゴリズムには、開発者が他のアルゴリズムを好むようにする弱点があります。キーIDと指紋の詳細については、セクション5.5.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.5.2.2. Version 4 Public Keys",
      "section_title": true,
      "ja": "5.5.2.2. バージョン4パブリックキー"
    },
    {
      "indent": 3,
      "text": "The version 4 format is similar to the version 3 format except for the absence of a validity period. This has been moved to the Signature packet. In addition, fingerprints of version 4 keys are calculated differently from version 3 keys, as described in Section 5.5.4.",
      "ja": "バージョン4形式は、有効期間がないことを除き、バージョン3形式に似ています。これは署名パケットに移動されました。さらに、セクション5.5.4で説明されているように、バージョン4キーの指紋はバージョン3キーとは異なる方法で計算されます。"
    },
    {
      "indent": 3,
      "text": "A version 4 packet contains:",
      "ja": "バージョン4パケットには次のものが含まれています。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number (4).",
      "ja": "* 1-OCTETバージョン番号（4）。"
    },
    {
      "indent": 6,
      "text": "* A 4-octet number denoting the time that the key was created.",
      "ja": "* キーが作成された時間を示す4-OCTET番号。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number denoting the public key algorithm of the key.",
      "ja": "* キーの公開キーアルゴリズムを示す1-OCTET番号。"
    },
    {
      "indent": 6,
      "text": "* A series of values comprising the key material. This is algorithm specific and described in Section 5.5.5.",
      "ja": "* 重要な資料を含む一連の値。これはアルゴリズム固有であり、セクション5.5.5で説明されています。"
    },
    {
      "indent": 0,
      "text": "5.5.2.3. Version 6 Public Keys",
      "section_title": true,
      "ja": "5.5.2.3. バージョン6パブリックキー"
    },
    {
      "indent": 3,
      "text": "The version 6 format is similar to the version 4 format except for the addition of a count for the key material. This count helps parsing Secret Key packets (which are an extension of the Public Key packet format) in the case of an unknown algorithm. In addition, fingerprints of version 6 keys are calculated differently from version 4 keys, as described in Section 5.5.4.",
      "ja": "バージョン6形式は、キーマテリアルのカウントを追加することを除き、バージョン4形式に似ています。このカウントは、未知のアルゴリズムの場合、シークレットキーパケット（公開キーパケット形式の拡張）を解析するのに役立ちます。さらに、セクション5.5.4で説明されているように、バージョン6キーの指紋はバージョン4キーとは異なる方法で計算されます。"
    },
    {
      "indent": 3,
      "text": "A version 6 packet contains:",
      "ja": "バージョン6パケットには次のものが含まれています。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number (6).",
      "ja": "* 1-OCTETバージョン番号（6）。"
    },
    {
      "indent": 6,
      "text": "* A 4-octet number denoting the time that the key was created.",
      "ja": "* キーが作成された時間を示す4-OCTET番号。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet number denoting the public key algorithm of the key.",
      "ja": "* キーの公開キーアルゴリズムを示す1-OCTET番号。"
    },
    {
      "indent": 6,
      "text": "* A 4-octet scalar octet count for the public key material specified in the next field.",
      "ja": "* 次のフィールドで指定された公開キー資料の4-OCTETスカラーオクテットカウント。"
    },
    {
      "indent": 6,
      "text": "* A series of values comprising the public key material. This is algorithm specific and described in Section 5.5.5.",
      "ja": "* 公開鍵資料を含む一連の価値。これはアルゴリズム固有であり、セクション5.5.5で説明されています。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Secret Key Packet Formats",
      "section_title": true,
      "ja": "5.5.3. シークレットキーパケットフォーマット"
    },
    {
      "indent": 3,
      "text": "The Secret Key and Secret Subkey packets contain all the data of the Public Key and Public Subkey packets, with additional algorithm-specific secret key data appended, usually in encrypted form.",
      "ja": "Secret KeyとSecret Subkeyパケットには、一般的に暗号化された形式で追加のアルゴリズム固有のシークレットキーデータが追加された、公開キーとパブリックサブキーパケットのすべてのデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "The packet contains:",
      "ja": "パケットには次のものが含まれます。"
    },
    {
      "indent": 6,
      "text": "* The fields of a Public Key or Public Subkey packet, as described above.",
      "ja": "* 上記のように、公開キーまたは公開サブキーパケットのフィールド。"
    },
    {
      "indent": 6,
      "text": "* One octet (the \"S2K usage octet\") indicating whether and how the secret key material is protected by a passphrase. Zero indicates that the secret key data is not encrypted. 253 (AEAD), 254 (CFB), or 255 (MalleableCFB) indicates that an S2K Specifier and other parameters will follow. Any other value is a symmetric key encryption algorithm identifier. A version 6 packet MUST NOT use the value 255 (MalleableCFB).",
      "ja": "* 秘密のキー資料がパスフレーズによって保護されているかどうか、どのように保護されているかを示す1つのオクテット（「S2K使用量オクテット」）。ゼロは、シークレットキーデータが暗号化されていないことを示します。253（AEAD）、254（CFB）、または255（MalleableCFB）は、S2K指定器とその他のパラメーターが続くことを示しています。その他の値は、対称キー暗号化アルゴリズム識別子です。バージョン6パケットは、値255（malleablecfb）を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "* Only for a version 6 packet where the secret key material is encrypted (that is, where the previous octet is not zero), a 1-octet scalar octet count of the cumulative length of all the following conditionally included S2K parameter fields.",
      "ja": "* シークレットキー素材が暗号化されているバージョン6パケット（つまり、前のオクテットがゼロではない場合）の場合のみ、次のすべての条件付きS2Kパラメーターフィールドの累積長さの1オクテットのスカラーオクテットカウント。"
    },
    {
      "indent": 6,
      "text": "* Conditionally included S2K parameter fields:",
      "ja": "* 条件付きで含まれるS2Kパラメーターフィールド："
    },
    {
      "indent": 12,
      "text": "- If the S2K usage octet was 253, 254, or 255, a 1-octet symmetric key encryption algorithm.",
      "ja": "- S2Kの使用法が253、254、または255である場合、1オクテットの対称キー暗号化アルゴリズム。"
    },
    {
      "indent": 12,
      "text": "- If the S2K usage octet was 253 (AEAD), a 1-octet AEAD algorithm.",
      "ja": "- S2K使用法が253（AEAD）である場合、1オクテットのAEADアルゴリズム。"
    },
    {
      "indent": 12,
      "text": "- Only for a version 6 packet, and if the S2K usage octet was 253 or 254, a 1-octet count of the size of the one field following this octet.",
      "ja": "- バージョン6パケットのみであり、S2K使用量のオクテットが253または254の場合、このオクテットに続く1つのフィールドのサイズの1オクタートカウント。"
    },
    {
      "indent": 12,
      "text": "- If the S2K usage octet was 253, 254, or 255, an S2K Specifier. The length of the S2K Specifier depends on its type (see Section 3.7.1).",
      "ja": "- S2Kの使用法が253、254、または255の場合、S2K仕様の場合。S2K仕様の長さは、そのタイプに依存します（セクション3.7.1を参照）。"
    },
    {
      "indent": 12,
      "text": "- If the S2K usage octet was 253 (AEAD), an IV of a size specified by the AEAD algorithm (see Section 5.13.2), which is used as the nonce for the AEAD algorithm.",
      "ja": "- S2K使用量のオクテットが253（AEAD）である場合、AEADアルゴリズムのAEADアルゴリズムで指定されたサイズのIV（AEADアルゴリズムのNonCEとして使用されます。"
    },
    {
      "indent": 12,
      "text": "- If the S2K usage octet was 254, 255, or a cipher algorithm ID (that is, the secret data uses some form of CFB encryption), an IV of the same length as the cipher's block size.",
      "ja": "- S2K使用量のオクテットが254、255、または暗号アルゴリズムID（つまり、秘密データが何らかの形のCFB暗号化を使用する）である場合、暗号のブロックサイズと同じ長さのIVです。"
    },
    {
      "indent": 6,
      "text": "* Plain or encrypted multiprecision integers comprising the secret key data. This is algorithm specific and described in Section 5.5.5. If the S2K usage octet is 253 (AEAD), then an AEAD authentication tag is at the end of that data. If the S2K usage octet is 254 (CFB), a 20-octet SHA-1 hash of the plaintext of the algorithm-specific portion is appended to plaintext and encrypted with it. If the S2K usage octet is 255 (MalleableCFB) or another non-zero value (that is, a symmetric key encryption algorithm identifier), a 2-octet checksum of the plaintext of the algorithm-specific portion (sum of all octets, mod 65536) is appended to plaintext and encrypted with it. (This is deprecated and SHOULD NOT be used; see below.)",
      "ja": "* シークレットキーデータを含むプレーンまたは暗号化された多重化整数。これはアルゴリズム固有であり、セクション5.5.5で説明されています。S2K使用法が253（AEAD）の場合、AEAD認証タグはそのデータの最後にあります。S2K使用量のオクテットが254（CFB）の場合、アルゴリズム固有の部分のプレーンテキストの20オクセットのSHA-1ハッシュがプレーンテキストに追加され、それで暗号化されます。S2K使用量のオクテットが255（malleablecfb）または別の非ゼロ値（つまり、対称キー暗号化アルゴリズム識別子）の場合、アルゴリズム固有の部分の平文の2オクテットのチェックサム（すべてのオクテットの合計、mod 65536）プレーンテキストに追加され、それで暗号化されます。（これは非推奨であり、使用すべきではありません。以下を参照してください。）"
    },
    {
      "indent": 6,
      "text": "* Only for a version 3 or 4 packet where the S2K usage octet is zero, a 2-octet checksum of the algorithm-specific portion (sum of all octets, mod 65536).",
      "ja": "* S2K使用法がゼロであるバージョン3または4パケットのみ、アルゴリズム固有の部分の2オクテットチェックサム（すべてのオクテットの合計、mod 65536）です。"
    },
    {
      "indent": 3,
      "text": "The details about storing algorithm-specific secrets above are summarized in Table 2.",
      "ja": "上記のアルゴリズム固有の秘密の保存に関する詳細を表2にまとめます。"
    },
    {
      "indent": 3,
      "text": "Note that the version 6 packet format adds two count values to help parsing packets with unknown S2K or public key algorithms.",
      "ja": "バージョン6パケット形式は、2つのカウント値を追加して、未知のS2Kまたは公開キーアルゴリズムを持つパケットを解析するのに役立つことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Secret MPI values can be encrypted using a passphrase. If an S2K Specifier is given, it describes the algorithm for converting the passphrase to a key; otherwise, a simple MD5 hash of the passphrase is used. An implementation producing a passphrase-protected Secret Key packet MUST use an S2K Specifier; the simple hash is for read-only backward compatibility, though implementations MAY continue to use existing private keys in the old format. The cipher for encrypting the MPIs is specified in the Secret Key packet.",
      "ja": "秘密のMPI値は、パスフレーズを使用して暗号化できます。S2K仕様が指定されている場合、パスフレーズをキーに変換するためのアルゴリズムを説明します。それ以外の場合、パスフレーズの単純なMD5ハッシュが使用されます。PassPhraseで保護されたSecretキーパケットを作成する実装では、S2K仕様を使用する必要があります。単純なハッシュは、読み取り専用の後方互換性のためのものですが、実装は古い形式で既存のプライベートキーを引き続き使用する場合があります。MPIを暗号化するための暗号は、Secret Keyパケットで指定されています。"
    },
    {
      "indent": 3,
      "text": "Encryption/decryption of the secret data is done using the key created from the passphrase and the IV from the packet. If the S2K usage octet is not 253, CFB mode is used. A different mode is used with version 3 keys (which are only RSA) than with other key formats. With version 3 keys, the MPI bit count prefix (that is, the first two octets) is not encrypted. Only the MPI non-prefix data is encrypted. Furthermore, the CFB state is resynchronized at the beginning of each new MPI value so that the CFB block boundary is aligned with the start of the MPI data.",
      "ja": "秘密データの暗号化/復号化は、パスフレーズから作成されたキーとパケットからIVを使用して行われます。S2K使用量のオクテットが253ではない場合、CFBモードが使用されます。別のモードは、他のキー形式よりもバージョン3キー（RSAのみです）で使用されます。バージョン3キーを使用すると、MPIビットカウントプレフィックス（つまり、最初の2つのオクテット）は暗号化されていません。MPI非Prefixデータのみが暗号化されます。さらに、CFBの状態は、新しいMPI値の開始時に再同期され、CFBブロック境界がMPIデータの開始と整合します。"
    },
    {
      "indent": 3,
      "text": "With version 4 and version 6 keys, a simpler method is used. All secret MPI values are encrypted, including the MPI bit count prefix.",
      "ja": "バージョン4およびバージョン6キーを使用すると、よりシンプルな方法が使用されます。MPIビットカウントプレフィックスを含む、すべての秘密のMPI値は暗号化されています。"
    },
    {
      "indent": 3,
      "text": "If the S2K usage octet is 253, the KEK is derived using HKDF [RFC5869] to provide key separation. SHA256 [RFC6234] is used as the hash algorithm for HKDF. IKM for HKDF is the key derived from S2K. No salt is used. The info parameter is comprised of the Packet Type ID encoded in OpenPGP format (bits 7 and 6 are set, and bits 5-0 carry the Packet Type ID), the packet version, and the cipher-algo and AEAD-mode used to encrypt the key material.",
      "ja": "S2K使用法が253の場合、KEKはHKDF [RFC5869]を使用して導出され、重要な分離が得られます。SHA256 [RFC6234]は、HKDFのハッシュアルゴリズムとして使用されます。HKDFのIKMは、S2Kから派生したキーです。塩は使用されていません。情報パラメーターは、OpenPGP形式でエンコードされたパケットタイプIDで構成されています（ビット7と6が設定され、ビット5-0はパケットタイプID、パケットバージョン、およびエンコリットに使用されるCipher-AlgoとAEADモードを運びます重要な素材。"
    },
    {
      "indent": 3,
      "text": "Then, the encrypted MPI values are encrypted as one combined plaintext using one of the AEAD algorithms specified for the version 2 Symmetrically Encrypted and Integrity Protected Data packet. Note that no chunks are used and that there is only one authentication tag. As additional data, the Packet Type ID in OpenPGP format encoding (bits 7 and 6 are set, and bits 5-0 carry the Packet Type ID), followed by the Public Key packet fields, starting with the packet version number, are passed to the AEAD algorithm. For example, the additional data used with a Secret Key packet of version 4 consists of the octets 0xC5, 0x04, followed by four octets of creation time, one octet denoting the public key algorithm, and the algorithm-specific public key parameters. For a Secret Subkey packet, the first octet would be 0xC7. For a version 6 key packet, the second octet would be 0x06, and the 4-octet octet count of the public key material would be included as well (see Section 5.5.2).",
      "ja": "次に、暗号化されたMPI値は、バージョン2の対称的に暗号化され、整合性保護されたデータパケットに指定されたAEADアルゴリズムの1つを使用して、1つの組み合わせプレーンテキストとして暗号化されます。チャンクは使用されておらず、認証タグは1つだけであることに注意してください。追加データとして、OpenPGP形式のエンコード（ビット7と6が設定され、ビット5-0がパケットタイプIDを運ぶ）のパケットタイプIDは、パケットバージョン番号から始まる公開キーパケットフィールドが続きます。AEADアルゴリズム。たとえば、バージョン4のシークレットキーパケットで使用される追加データは、オクテット0xc5、0x04で構成され、続いて作成時間の4オクテット、1つのオクテットが公開キーアルゴリズムとアルゴリズム固有の公開キーパラメーターを示します。秘密のサブキーパケットの場合、最初のオクテットは0xc7です。バージョン6キーパケットの場合、2番目のオクテットは0x06であり、公開鍵の4-OCTETオクテット数も含まれます（セクション5.5.2を参照）。"
    },
    {
      "indent": 3,
      "text": "The 2-octet checksum that follows the algorithm-specific portion is the algebraic sum, mod 65536, of the plaintext of all the algorithm-specific octets (including the MPI prefix and data). With version 3 keys, the checksum is stored in the clear. With version 4 keys, the checksum is encrypted like the algorithm-specific data. This value is used to check that the passphrase was correct. However, this checksum is deprecated, and an implementation SHOULD NOT use it; instead, an implementation should use the SHA-1 hash denoted with a usage octet of 254. The reason for this is that there are some attacks that involve modifying the secret key undetected. If the S2K usage octet is 253, no checksum or SHA-1 hash is used, but the authentication tag of the AEAD algorithm follows.",
      "ja": "アルゴリズム固有の部分に続く2オクテットのチェックサムは、すべてのアルゴリズム固有のオクテット（MPIプレフィックスとデータを含む）のプレーンテキストの代数和、Mod 65536です。バージョン3キーを使用すると、チェックサムはクリアに保存されます。バージョン4キーを使用すると、チェックサムはアルゴリズム固有のデータのように暗号化されます。この値は、パスフレーズが正しいことを確認するために使用されます。ただし、このチェックサムは非推奨であり、実装はそれを使用すべきではありません。代わりに、実装では、254の使用法で示されたSHA-1ハッシュを使用する必要があります。その理由は、秘密の鍵を検出されない鍵を変更する攻撃があるからです。S2Kの使用法が253の場合、チェックサムまたはSHA-1ハッシュは使用されませんが、AEADアルゴリズムの認証タグは続きます。"
    },
    {
      "indent": 3,
      "text": "When decrypting the secret key material using any of these schemes (that is, where the usage octet is non-zero), the resulting cleartext octet stream must be well formed. In particular, an implementation MUST NOT interpret octets beyond the unwrapped cleartext octet stream as part of any of the unwrapped MPI objects. Furthermore, an implementation MUST reject any secret key material whose cleartext length does not align with the lengths of the unwrapped MPI objects as unusable.",
      "ja": "これらのスキームのいずれかを使用してシークレットキー資料を復号化する場合（つまり、使用法がゼロではない場合）、結果のClearText Octetストリームを適切に形成する必要があります。特に、実装は、包装されていないMPIオブジェクトの一部として、包装されていないClearTextオクテットストリームを超えてオクテットを解釈してはなりません。さらに、実装は、クリアテキストの長さが、包装されていないMPIオブジェクトの長さが使用できないと一致しない秘密の鍵資料を拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.4. Key IDs and Fingerprints",
      "section_title": true,
      "ja": "5.5.4. キーIDと指紋"
    },
    {
      "indent": 3,
      "text": "Every OpenPGP Key has a fingerprint and a Key ID. The computation of these values differs based on the key version. The fingerprint length varies with the key version, but the Key ID (which is only used in v3 PKESK packets; see Section 5.1.1) is always 64 bits. The following registry represents the subsections below:",
      "ja": "すべてのOpenPGPキーには、指紋とキーIDがあります。これらの値の計算は、キーバージョンに基づいて異なります。指紋の長さはキーバージョンによって異なりますが、キーID（V3 PKSEKパケットでのみ使用されます。セクション5.1.1を参照）は常に64ビットです。次のレジストリは、以下のサブセクションを表しています。"
    },
    {
      "indent": 3,
      "text": "+=======+===================+===============+=============+=========+\n|Key    | Fingerprint       | Fingerprint   | Key ID      |Reference|\n|Version|                   | Length        |             |         |\n|       |                   | (Bits)        |             |         |\n+=======+===================+===============+=============+=========+\n|3      | MD5(MPIs without  | 128           | low 64 bits |Section  |\n|       | length octets)    |               | of RSA      |5.5.4.1  |\n|       |                   |               | modulus     |         |\n+-------+-------------------+---------------+-------------+---------+\n|4      | SHA1(normalized   | 160           | last 64     |Section  |\n|       | pubkey packet)    |               | bits of     |5.5.4.2  |\n|       |                   |               | fingerprint |         |\n+-------+-------------------+---------------+-------------+---------+\n|6      | SHA256(normalized | 256           | first 64    |Section  |\n|       | pubkey packet)    |               | bits of     |5.5.4.3  |\n|       |                   |               | fingerprint |         |\n+-------+-------------------+---------------+-------------+---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Table 12: OpenPGP Key IDs and Fingerprints Registry",
      "ja": "表12：OpenPGPキーIDと指紋レジストリ"
    },
    {
      "indent": 0,
      "text": "5.5.4.1. Version 3 Key ID and Fingerprint",
      "section_title": true,
      "ja": "5.5.4.1. バージョン3キーIDと指紋"
    },
    {
      "indent": 3,
      "text": "For a version 3 key, the 8-octet Key ID consists of the low 64 bits of the public modulus of the RSA key.",
      "ja": "バージョン3キーの場合、8-OCTETキーIDは、RSAキーのパブリックモジュラスの64ビットの低いビットで構成されています。"
    },
    {
      "indent": 3,
      "text": "The fingerprint of a version 3 key is formed by hashing the body (but not the 2-octet length) of the MPIs that form the key material (public modulus n, followed by exponent e) with MD5. Note that both version 3 keys and MD5 are deprecated.",
      "ja": "バージョン3キーの指紋は、MPIのボディ（2-OCTETの長さではなく）をハッシュすることにより形成されます。バージョン3キーとMD5の両方が非推奨であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.5.4.2. Version 4 Key ID and Fingerprint",
      "section_title": true,
      "ja": "5.5.4.2. バージョン4キーIDと指紋"
    },
    {
      "indent": 3,
      "text": "A version 4 fingerprint is the 160-bit SHA-1 hash of the octet 0x99, followed by the 2-octet packet length, followed by the entire Public Key packet starting with the version field. The Key ID is the low-order 64 bits of the fingerprint. Here are the fields of the hash material, including an example of an Ed25519 key:",
      "ja": "バージョン4の指紋は、Octet 0x99の160ビットSHA-1ハッシュで、その後2-OCTETパケットの長さが続き、その後、バージョンフィールドから始まる公開キーパケット全体が続きます。キーIDは、指紋の低次の64ビットです。ED25519キーの例を含む、ハッシュ材料のフィールドは次のとおりです。"
    },
    {
      "indent": 12,
      "text": "a.1) 0x99 (1 octet)",
      "ja": "A.1）0x99（1オクテット）"
    },
    {
      "indent": 12,
      "text": "a.2) 2-octet, big-endian scalar octet count of (b)-(e)",
      "ja": "A.2）2-OCTET、（b） - （e）のビッグエンディアンスカラーオクテットカウント"
    },
    {
      "indent": 8,
      "text": "b) version number = 4 (1 octet)",
      "ja": "b) バージョン番号= 4（1オクテット）"
    },
    {
      "indent": 8,
      "text": "c) timestamp of key creation (4 octets)",
      "ja": "c) キー作成のタイムスタンプ（4オクテット）"
    },
    {
      "indent": 8,
      "text": "d) algorithm (1 octet): 27 = Ed25519 (example)",
      "ja": "d) アルゴリズム（1オクテット）：27 = ED25519（例）"
    },
    {
      "indent": 8,
      "text": "e) algorithm-specific fields",
      "ja": "e) アルゴリズム固有のフィールド"
    },
    {
      "indent": 3,
      "text": "Algorithm-specific fields for Ed25519 keys (example):",
      "ja": "ED25519キー用のアルゴリズム固有のフィールド（例）："
    },
    {
      "indent": 12,
      "text": "e.1) 32 octets representing the public key",
      "ja": "E.1）公開キーを表す32オクテット"
    },
    {
      "indent": 0,
      "text": "5.5.4.3. Version 6 Key ID and Fingerprint",
      "section_title": true,
      "ja": "5.5.4.3. バージョン6キーIDと指紋"
    },
    {
      "indent": 3,
      "text": "A version 6 fingerprint is the 256-bit SHA2-256 hash of the octet 0x9B, followed by the 4-octet packet length, followed by the entire Public Key packet starting with the version field. The Key ID is the high-order 64 bits of the fingerprint. Here are the fields of the hash material, including an example of an Ed25519 key:",
      "ja": "バージョン6の指紋は、Octet 0x9Bの256ビットSHA2-256ハッシュで、その後4-OCTETパケットの長さが続き、その後、バージョンフィールドから始まる公開キーパケット全体が続きます。キーIDは、フィンガープリントの高次64ビットです。ED25519キーの例を含む、ハッシュ材料のフィールドは次のとおりです。"
    },
    {
      "indent": 12,
      "text": "a.1) 0x9B (1 octet)",
      "ja": "A.1）0x9b（1オクテット）"
    },
    {
      "indent": 12,
      "text": "a.2) 4-octet scalar octet count of (b)-(f)",
      "ja": "A.2）（b） - （f）の4-OCTETスカラーオクテットカウント"
    },
    {
      "indent": 8,
      "text": "b) version number = 6 (1 octet)",
      "ja": "b) バージョン番号= 6（1オクテット）"
    },
    {
      "indent": 8,
      "text": "c) timestamp of key creation (4 octets)",
      "ja": "c) キー作成のタイムスタンプ（4オクテット）"
    },
    {
      "indent": 8,
      "text": "d) algorithm (1 octet): 27 = Ed25519 (example)",
      "ja": "d) アルゴリズム（1オクテット）：27 = ED25519（例）"
    },
    {
      "indent": 8,
      "text": "e) 4-octet scalar octet count for the key material specified in the next field",
      "ja": "e) 4-次のフィールドで指定されたキー材料の4-OCTETスカラーオクテットカウント"
    },
    {
      "indent": 8,
      "text": "f) algorithm-specific public key material",
      "ja": "f) アルゴリズム固有の公開キー資料"
    },
    {
      "indent": 3,
      "text": "Algorithm-specific fields for Ed25519 keys (example):",
      "ja": "ED25519キー用のアルゴリズム固有のフィールド（例）："
    },
    {
      "indent": 12,
      "text": "f.1) 32 octets representing the public key",
      "ja": "F.1）32公開キーを表すオクテット"
    },
    {
      "indent": 3,
      "text": "Note that it is possible for there to be collisions of Key IDs -- that is, two different keys with the same Key ID. Note that there is a much smaller, but still non-zero, probability that two different keys have the same fingerprint.",
      "ja": "キーIDの衝突、つまり同じキーIDを持つ2つの異なるキーがある可能性があることに注意してください。2つの異なるキーが同じ指紋を持つ可能性は、はるかに小さいが、まだゼロではないが、ゼロではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Also note that if version 3, version 4, and version 6 format keys share the same RSA key material, they will have different Key IDs as well as different fingerprints.",
      "ja": "また、バージョン3、バージョン4、およびバージョン6形式のキーが同じRSAキー資料を共有する場合、異なるキーIDと異なる指紋があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Finally, the Key ID and fingerprint of a subkey are calculated in the same way as for a primary key, including the 0x99 (version 4 key) or 0x9B (version 6 key) as the first octet (even though this is not a valid Packet Type ID for a public subkey).",
      "ja": "最後に、サブキーのキーIDと指紋は、0x99（バージョン4キー）または0x9b（バージョン6キー）を含むプライマリキーと同じ方法で計算されます（これは有効なパケットではありませんが、有効なパケットではありませんがパブリックサブキーのIDを入力します）。"
    },
    {
      "indent": 0,
      "text": "5.5.5. Algorithm-Specific Parts of Keys",
      "section_title": true,
      "ja": "5.5.5. キーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "The public and secret key formats specify algorithm-specific parts of a key. The following sections describe them in detail.",
      "ja": "パブリックおよびシークレットキー形式は、キーのアルゴリズム固有の部分を指定します。次のセクションでは、それらを詳細に説明します。"
    },
    {
      "indent": 0,
      "text": "5.5.5.1. Algorithm-Specific Part for RSA Keys",
      "section_title": true,
      "ja": "5.5.5.1. RSAキーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For RSA keys, the public key consists of this series of multiprecision integers:",
      "ja": "RSAキーの場合、公開キーは、この一連の多重整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* MPI of RSA public modulus n,",
      "ja": "* RSAパブリックモジュラスnのMPI、"
    },
    {
      "indent": 6,
      "text": "* MPI of RSA public encryption exponent e.",
      "ja": "* RSAパブリック暗号化指数eのMPI e。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this series of multiprecision integers:",
      "ja": "秘密の鍵は、この一連の多重レスク整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* MPI of RSA secret exponent d;",
      "ja": "* RSA秘密指数DのMPI;"
    },
    {
      "indent": 6,
      "text": "* MPI of RSA secret prime value p;",
      "ja": "* RSAシークレットプライムバリューPのMPI;"
    },
    {
      "indent": 6,
      "text": "* MPI of RSA secret prime value q (p < q); and",
      "ja": "* RSAシークレットプライムバリューQ（P <Q）のMPI;そして"
    },
    {
      "indent": 6,
      "text": "* MPI of u, the multiplicative inverse of p, mod q.",
      "ja": "* uのmpi、pの乗算的逆、mod q。"
    },
    {
      "indent": 0,
      "text": "5.5.5.2. Algorithm-Specific Part for DSA Keys",
      "section_title": true,
      "ja": "5.5.5.2. DSAキーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For DSA keys, the public key consists of this series of multiprecision integers:",
      "ja": "DSAキーの場合、公開キーは、この一連の多重整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* MPI of DSA prime p;",
      "ja": "* DSAプライムPのMPI;"
    },
    {
      "indent": 6,
      "text": "* MPI of DSA group order q (q is a prime divisor of p-1);",
      "ja": "* DSAグループ注文QのMPI（QはP-1の主要な除数です）;"
    },
    {
      "indent": 6,
      "text": "* MPI of DSA group generator g; and",
      "ja": "* DSAグループジェネレーターGのMPI;そして"
    },
    {
      "indent": 6,
      "text": "* MPI of DSA public key value y (= g^x mod p where x is secret).",
      "ja": "* DSA公開キー値y（= g^x mod Pでxが秘密）のMPI。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single multiprecision integer:",
      "ja": "シークレットキーは、この単一の多重整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* MPI of DSA secret exponent x.",
      "ja": "* DSA Secret Exponent xのMPI。"
    },
    {
      "indent": 0,
      "text": "5.5.5.3. Algorithm-Specific Part for Elgamal Keys",
      "section_title": true,
      "ja": "5.5.5.3. エルガマルキーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For Elgamal keys, the public key consists of this series of multiprecision integers:",
      "ja": "Elgamal Keysの場合、公開鍵は、この一連の多重化整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* MPI of Elgamal prime p;",
      "ja": "* エルガマルプライムPのMPI;"
    },
    {
      "indent": 6,
      "text": "* MPI of Elgamal group generator g; and",
      "ja": "* エルガマルグループジェネレーターGのMPI;そして"
    },
    {
      "indent": 6,
      "text": "* MPI of Elgamal public key value y (= g^x mod p where x is secret).",
      "ja": "* エルガマルの公開鍵値y（= g^x mod pは秘密です）のmpi。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single multiprecision integer:",
      "ja": "シークレットキーは、この単一の多重整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* MPI of Elgamal secret exponent x.",
      "ja": "* Elgamal Secret Exponent xのMPI。"
    },
    {
      "indent": 0,
      "text": "5.5.5.4. Algorithm-Specific Part for ECDSA Keys",
      "section_title": true,
      "ja": "5.5.5.4. ECDSAキーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For ECDSA keys, the public key consists of this series of values:",
      "ja": "ECDSAキーの場合、公開鍵はこの一連の価値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* A variable-length field containing a curve OID, which is formatted as follows:",
      "ja": "* 次のようにフォーマットされている曲線oidを含む可変長さフィールド："
    },
    {
      "indent": 12,
      "text": "- A 1-octet size of the following field; values 0 and 0xFF are reserved for future extensions.",
      "ja": "- 次のフィールドの1-OCTETサイズ。値0および0xffは、将来の拡張機能のために予約されています。"
    },
    {
      "indent": 12,
      "text": "- The octets representing a curve OID, as defined in Section 9.2.",
      "ja": "- セクション9.2で定義されているように、曲線OIDを表すオクテット。"
    },
    {
      "indent": 6,
      "text": "* An MPI of an EC point representing a public key.",
      "ja": "* 公開キーを表すECポイントのMPI。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single multiprecision integer:",
      "ja": "シークレットキーは、この単一の多重整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* An MPI of an integer representing the secret key, which is a scalar of the public EC point.",
      "ja": "* 秘密の鍵を表す整数のMPIは、パブリックエクポイントのスカラーです。"
    },
    {
      "indent": 0,
      "text": "5.5.5.5. Algorithm-Specific Part for EdDSALegacy Keys (Deprecated)",
      "section_title": true,
      "ja": "5.5.5.5. eddsalegacyキーのアルゴリズム固有の部分（非推奨）"
    },
    {
      "indent": 3,
      "text": "For EdDSALegacy keys (deprecated), the public key consists of this series of values:",
      "ja": "Eddsalegacy Keys（廃止）の場合、公開鍵はこの一連の価値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* A variable-length field containing a curve OID, formatted as follows:",
      "ja": "* 次のようにフォーマットされた曲線oidを含む可変長さのフィールド："
    },
    {
      "indent": 12,
      "text": "- A 1-octet size of the following field; values 0 and 0xFF are reserved for future extensions.",
      "ja": "- 次のフィールドの1-OCTETサイズ。値0および0xffは、将来の拡張機能のために予約されています。"
    },
    {
      "indent": 12,
      "text": "- The octets representing a curve OID, as defined in Section 9.2.",
      "ja": "- セクション9.2で定義されているように、曲線OIDを表すオクテット。"
    },
    {
      "indent": 6,
      "text": "* An MPI of an EC point representing a public key Q in prefixed native form (see Section 11.2.2).",
      "ja": "* ネイティブフォームの前に公開キーQを表すECポイントのMPI（セクション11.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single multiprecision integer:",
      "ja": "シークレットキーは、この単一の多重整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* An MPI-encoded octet string representing the native form of the secret key in the curve-specific format, as described in Section 9.2.1.",
      "ja": "* セクション9.2.1で説明されているように、曲線固有の形式の秘密鍵のネイティブ形式を表すMPIエンコードのオクテット文字列。"
    },
    {
      "indent": 3,
      "text": "Note that the native form for an EdDSA secret key is a fixed-width sequence of unstructured random octets, with size corresponding to the specific curve. That sequence of random octets is used with a cryptographic digest to produce both a curve-specific secret scalar and a prefix used when making a signature. See Section 5.1.5 of [RFC8032] for more details about how to use the native octet strings for Ed25519Legacy. The value stored in an OpenPGP EdDSALegacy Secret Key packet is the original sequence of random octets.",
      "ja": "EDDSAシークレットキーのネイティブフォームは、特定の曲線に対応するサイズを持つ非構造化されたランダムオクテットの固定幅シーケンスであることに注意してください。ランダムオクテットのシーケンスは、暗号化されたダイジェストで使用され、曲線固有の秘密スカラーと署名を作成するときに使用されるプレフィックスの両方を生成します。ED25519Legacyのネイティブオクテット弦を使用する方法の詳細については、[RFC8032]のセクション5.1.5を参照してください。OpenPGP EddSalegacy Secret Keyパケットに保存されている値は、ランダムオクテットの元のシーケンスです。"
    },
    {
      "indent": 3,
      "text": "Note that the only curve defined for use with EdDSALegacy is the Ed25519Legacy OID.",
      "ja": "Eddsalegacyで使用するために定義された唯一の曲線は、ED25519Legacy OIDであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.5.5.6. Algorithm-Specific Part for ECDH Keys",
      "section_title": true,
      "ja": "5.5.5.6. ECDHキーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For ECDH keys, the public key consists of this series of values:",
      "ja": "ECDHキーの場合、公開鍵はこの一連の価値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* A variable-length field containing a curve OID, which is formatted as follows:",
      "ja": "* 次のようにフォーマットされている曲線oidを含む可変長さフィールド："
    },
    {
      "indent": 12,
      "text": "- A 1-octet size of the following field; values 0 and 0xFF are reserved for future extensions.",
      "ja": "- 次のフィールドの1-OCTETサイズ。値0および0xffは、将来の拡張機能のために予約されています。"
    },
    {
      "indent": 12,
      "text": "- The octets representing a curve OID, as defined in Section 9.2.",
      "ja": "- セクション9.2で定義されているように、曲線OIDを表すオクテット。"
    },
    {
      "indent": 6,
      "text": "* An MPI of an EC point representing a public key, in the point format associated with the curve, as specified in Section 9.2.1.",
      "ja": "* セクション9.2.1で指定されているように、曲線に関連付けられたポイント形式の公開キーを表すECポイントのMPI。"
    },
    {
      "indent": 6,
      "text": "* A variable-length field containing key derivation function (KDF) parameters, which is formatted as follows:",
      "ja": "* 次のようにフォーマットされているキー誘導関数（KDF）パラメーターを含む可変長いフィールド："
    },
    {
      "indent": 12,
      "text": "- A 1-octet size of the following fields; values 0 and 0xFF are reserved for future extensions.",
      "ja": "- 次のフィールドの1オクテットサイズ。値0および0xffは、将来の拡張機能のために予約されています。"
    },
    {
      "indent": 12,
      "text": "- A 1-octet value 1, reserved for future extensions.",
      "ja": "- 将来のエクステンション用に予約されている1-OCTET値1。"
    },
    {
      "indent": 12,
      "text": "- A 1-octet hash function ID used with a KDF.",
      "ja": "- KDFで使用される1-OCTETハッシュ関数ID。"
    },
    {
      "indent": 12,
      "text": "- A 1-octet algorithm ID for the symmetric algorithm that is used to wrap the symmetric key for message encryption; see Section 11.5 for details.",
      "ja": "- メッセージ暗号化の対称キーをラップするために使用される対称アルゴリズムの1-OCTETアルゴリズムID。詳細については、セクション11.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single multiprecision integer:",
      "ja": "シークレットキーは、この単一の多重整数で構成されています。"
    },
    {
      "indent": 6,
      "text": "* An MPI representing the secret key, in the curve-specific format described in Section 9.2.1.",
      "ja": "* セクション9.2.1で説明されている曲線固有の形式で、シークレットキーを表すMPI。"
    },
    {
      "indent": 0,
      "text": "5.5.5.6.1. ECDH Secret Key Material",
      "section_title": true,
      "ja": "5.5.5.6.1. ECDHシークレットキー資料"
    },
    {
      "indent": 3,
      "text": "When curve NIST P-256, NIST P-384, NIST P-521, brainpoolP256r1, brainpoolP384r1, or brainpoolP512r1 are used in ECDH, their secret keys are represented as a simple integer in standard MPI form. Other curves are presented on the wire differently (though still as a single MPI), as described below and in Section 9.2.1.",
      "ja": "曲線NIST P-256、NIST P-384、NIST P-521、Brainpoolp256R1、Brainpoolp384R1、またはBrainpoolp512R1がECDHで使用されると、それらの秘密キーは標準MPI形式の単純な整数として表されます。他の曲線は、以下とセクション9.2.1で説明されているように、ワイヤー上に異なる方法で表示されます（まだ単一のMPIとして）。"
    },
    {
      "indent": 0,
      "text": "5.5.5.6.1.1. Curve25519Legacy ECDH Secret Key Material (Deprecated)",
      "section_title": true,
      "ja": "5.5.5.6.1.1. Curve25519Legacy ECDHシークレットキー素材（非推奨）"
    },
    {
      "indent": 3,
      "text": "A Curve25519Legacy secret key is stored as a standard integer in big-endian MPI form. Curve25519Legacy MUST NOT be used in key packets version 6 or above. Note that this form is in reverse octet order from the little-endian \"native\" form found in [RFC7748].",
      "ja": "Curve25519Legacy Secret Keyは、Big-Endian MPI形式の標準整数として保存されます。Curve25519Legacyは、キーパケットバージョン6以降で使用してはなりません。このフォームは、[RFC7748]に見られる小さなエンディアンの「ネイティブ」フォームから逆オクテットの順序であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note also that the integer for a Curve25519Legacy secret key for OpenPGP MUST have the appropriate form; that is, it MUST be divisible by 8, MUST be at least 2^254, and MUST be less than 2^255. The length of this MPI in bits is by definition always 255, so the two leading octets of the MPI will always be 00 FF, and reversing the following 32 octets from the wire will produce the \"native\" form.",
      "ja": "また、Curve25519Legacy OpenPGPの秘密鍵の整数には適切な形式が必要であることに注意してください。つまり、それは8までに分割可能でなければならず、少なくとも2^254でなければならず、2^255未満でなければなりません。このMPIのBITSの長さは定義上255であるため、MPIの2つの主要なオクテットは常に00 FFになり、ワイヤから次の32オクテットを逆にすると、「ネイティブ」フォームが生成されます。"
    },
    {
      "indent": 3,
      "text": "When generating a new Curve25519Legacy secret key from 32 fully random octets, the following pseudocode produces the MPI wire format (note the similarity to decodeScalar25519 as described in [RFC7748]):",
      "ja": "32の完全なランダムオクテットから新しい曲線25519Legacyシークレットキーを生成する場合、次の擬似コードはMPIワイヤ形式を生成します（[rfc7748]で説明されているように、decodescalar25519と類似性に注意してください）："
    },
    {
      "indent": 3,
      "text": "def curve25519Legacy_MPI_from_random(octet_list):\n    octet_list[0] &= 248\n    octet_list[31] &= 127\n    octet_list[31] |= 64\n    mpi_header = [ 0x00, 0xFF ]\n    return mpi_header || reversed(octet_list)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.5.5.7. Algorithm-Specific Part for X25519 Keys",
      "section_title": true,
      "ja": "5.5.5.7. x25519キーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For X25519 keys, the public key consists of this single value:",
      "ja": "x25519キーの場合、公開キーはこの単一の値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* 32 octets of the native public key.",
      "ja": "* ネイティブ公開キーの32オクテット。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single value:",
      "ja": "秘密の鍵は、この単一の値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* 32 octets of the native secret key.",
      "ja": "* ネイティブシークレットキーの32オクテット。"
    },
    {
      "indent": 3,
      "text": "See Section 6.1 of [RFC7748] for more details about how to use the native octet strings. The value stored in an OpenPGP X25519 Secret Key packet is the original sequence of random octets. The value stored in an OpenPGP X25519 Public Key packet is the value X25519(secretKey, 9).",
      "ja": "ネイティブのオクテット文字列の使用方法の詳細については、[RFC7748]のセクション6.1を参照してください。OpenPGP x25519 Secret Keyパケットに保存されている値は、ランダムオクテットの元のシーケンスです。OpenPGP x25519公開キーパケットに保存されている値は、値x25519（secretkey、9）です。"
    },
    {
      "indent": 0,
      "text": "5.5.5.8. Algorithm-Specific Part for X448 Keys",
      "section_title": true,
      "ja": "5.5.5.8. x448キーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For X448 keys, the public key consists of this single value:",
      "ja": "x448キーの場合、公開キーはこの単一の値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* 56 octets of the native public key.",
      "ja": "* ネイティブ公開鍵の56オクテット。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single value:",
      "ja": "秘密の鍵は、この単一の値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* 56 octets of the native secret key.",
      "ja": "* ネイティブシークレットキーの56オクテット。"
    },
    {
      "indent": 3,
      "text": "See Section 6.2 of [RFC7748] for more details about how to use the native octet strings. The value stored in an OpenPGP X448 Secret Key packet is the original sequence of random octets. The value stored in an OpenPGP X448 Public Key packet is the value X448(secretKey, 5).",
      "ja": "ネイティブのオクテット文字列の使用方法の詳細については、[RFC7748]のセクション6.2を参照してください。OpenPGP X448 Secret Keyパケットに保存されている値は、ランダムオクテットの元のシーケンスです。OpenPGP x448公開キーパケットに保存されている値は、値x448（SecretKey、5）です。"
    },
    {
      "indent": 0,
      "text": "5.5.5.9. Algorithm-Specific Part for Ed25519 Keys",
      "section_title": true,
      "ja": "5.5.5.9. ED25519キーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For Ed25519 keys, the public key consists of this single value:",
      "ja": "ED25519キーの場合、公開キーはこの単一の値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* 32 octets of the native public key.",
      "ja": "* ネイティブ公開キーの32オクテット。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single value:",
      "ja": "秘密の鍵は、この単一の値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* 32 octets of the native secret key.",
      "ja": "* ネイティブシークレットキーの32オクテット。"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.5 of [RFC8032] for more details about how to use the native octet strings. The value stored in an OpenPGP Ed25519 Secret Key packet is the original sequence of random octets.",
      "ja": "ネイティブのオクテット文字列の使用方法の詳細については、[RFC8032]のセクション5.1.5を参照してください。OpenPGP ED25519シークレットキーパケットに保存されている値は、ランダムオクテットの元のシーケンスです。"
    },
    {
      "indent": 0,
      "text": "5.5.5.10. Algorithm-Specific Part for Ed448 Keys",
      "section_title": true,
      "ja": "5.5.5.10. ED448キーのアルゴリズム固有の部分"
    },
    {
      "indent": 3,
      "text": "For Ed448 keys, the public key consists of this single value:",
      "ja": "ED448キーの場合、公開キーはこの単一の値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* 57 octets of the native public key.",
      "ja": "* ネイティブ公開キーの57オクテット。"
    },
    {
      "indent": 3,
      "text": "The secret key consists of this single value:",
      "ja": "秘密の鍵は、この単一の値で構成されています。"
    },
    {
      "indent": 6,
      "text": "* 57 octets of the native secret key.",
      "ja": "* ネイティブシークレットキーの57オクテット。"
    },
    {
      "indent": 3,
      "text": "See Section 5.2.5 of [RFC8032] for more details about how to use the native octet strings. The value stored in an OpenPGP Ed448 Secret Key packet is the original sequence of random octets.",
      "ja": "ネイティブのオクテット文字列の使用方法の詳細については、[RFC8032]のセクション5.2.5を参照してください。OpenPGP ED448 Secret Keyパケットに保存されている値は、ランダムオクテットの元のシーケンスです。"
    },
    {
      "indent": 0,
      "text": "5.6. Compressed Data Packet (Type ID 8)",
      "section_title": true,
      "ja": "5.6. 圧縮データパケット（タイプID 8）"
    },
    {
      "indent": 3,
      "text": "The Compressed Data packet contains compressed data. Typically, this packet is found as the contents of an encrypted packet, or following a Signature or One-Pass Signature packet, and contains a Literal Data packet.",
      "ja": "圧縮データパケットには圧縮データが含まれています。通常、このパケットは、暗号化されたパケットの内容として、または署名またはワンパスの署名パケットに従っていて、リテラルデータパケットが含まれています。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* One octet specifying the algorithm used to compress the packet.",
      "ja": "* パケットを圧縮するために使用されるアルゴリズムを指定する1つのオクテット。"
    },
    {
      "indent": 6,
      "text": "* Compressed data, which makes up the remainder of the packet.",
      "ja": "* パケットの残りを構成する圧縮データ。"
    },
    {
      "indent": 3,
      "text": "A Compressed Data packet's body contains data that is a compression of a series of OpenPGP packets. See Section 10 for details on how messages are formed.",
      "ja": "圧縮データパケットの本体には、一連のOpenPGPパケットの圧縮であるデータが含まれています。メッセージの形成方法の詳細については、セクション10を参照してください。"
    },
    {
      "indent": 3,
      "text": "A ZIP-compressed series of packets is compressed into raw DEFLATE blocks [RFC1951].",
      "ja": "ジップ圧縮された一連のパケットは、生のデフレートブロック[RFC1951]に圧縮されます。"
    },
    {
      "indent": 3,
      "text": "A ZLIB-compressed series of packets is compressed with raw ZLIB-style blocks [RFC1950].",
      "ja": "ZLIBが圧縮された一連のパケットは、生のZlibスタイルのブロック[RFC1950]で圧縮されています。"
    },
    {
      "indent": 3,
      "text": "A BZip2-compressed series of packets is compressed using the BZip2 [BZ2] algorithm.",
      "ja": "BZIP2-圧縮された一連のパケットは、BZIP2 [BZ2]アルゴリズムを使用して圧縮されます。"
    },
    {
      "indent": 3,
      "text": "An implementation that generates a Compressed Data packet MUST use the OpenPGP format for packet framing (see Section 4.2.1). It MUST NOT generate a Compressed Data packet with Legacy format (Section 4.2.2).",
      "ja": "圧縮データパケットを生成する実装では、パケットフレーミングにOpenPGP形式を使用する必要があります（セクション4.2.1を参照）。レガシー形式で圧縮データパケットを生成してはなりません（セクション4.2.2）。"
    },
    {
      "indent": 3,
      "text": "An implementation that deals with either historic data or data generated by legacy implementations predating support for [RFC2440] MAY interpret Compressed Data packets that use the Legacy format for packet framing.",
      "ja": "[RFC2440]の前にサポートされるレガシーの実装によって生成された歴史的なデータまたはデータのいずれかを扱う実装は、パケットフレーミングにレガシー形式を使用する圧縮データパケットを解釈する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.7. Symmetrically Encrypted Data Packet (Type ID 9)",
      "section_title": true,
      "ja": "5.7. 対称的に暗号化されたデータパケット（タイプID 9）"
    },
    {
      "indent": 3,
      "text": "The Symmetrically Encrypted Data packet contains data encrypted with a symmetric key algorithm. When it has been decrypted, it contains other packets (usually a Literal Data packet or compressed data packet, but in theory, it could be another sequence of packets that forms a valid OpenPGP Message).",
      "ja": "対称的に暗号化されたデータパケットには、対称キーアルゴリズムで暗号化されたデータが含まれています。復号化された場合、他のパケット（通常、リテラルデータパケットまたは圧縮データパケットが含まれていますが、理論的には、有効なOpenPGPメッセージを形成する別のパケットのシーケンスになる可能性があります）。"
    },
    {
      "indent": 3,
      "text": "This packet is obsolete. An implementation MUST NOT create this packet. An implementation SHOULD reject such a packet and stop processing the message. If an implementation chooses to process the packet anyway, it MUST return a clear warning that a non-integrity-protected packet has been processed.",
      "ja": "このパケットは時代遅れです。実装はこのパケットを作成してはなりません。実装はそのようなパケットを拒否し、メッセージの処理を停止する必要があります。実装がとにかくパケットを処理することを選択した場合、非統合保護されたパケットが処理されたという明確な警告を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "This packet format is impossible to handle safely in general because the ciphertext it provides is malleable. See Section 13.7 about selecting a better OpenPGP encryption container that does not have this flaw.",
      "ja": "このパケット形式は、それが提供する暗号文は順応性があるため、一般的に安全に処理することは不可能です。この欠陥がないより良いOpenPGP暗号化コンテナの選択については、セクション13.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A random prefix, containing block-size random octets (for example, 16 octets for a 128-bit block length) followed by a copy of the last two octets, encrypted together using Cipher Feedback (CFB) mode, with an IV of all zeros.",
      "ja": "* ブロックサイズのランダムオクテット（たとえば、128ビットブロックの長さの16オクテット）を含むランダムなプレフィックスに続いて、最後の2オクテットのコピーが続きます。。"
    },
    {
      "indent": 6,
      "text": "* Data encrypted using CFB mode, with the last block-size octets of the first ciphertext as the IV.",
      "ja": "* CFBモードを使用して暗号化されたデータ。最初の暗号文の最後のブロックサイズのオクテットをIVとして。"
    },
    {
      "indent": 3,
      "text": "The symmetric cipher used may be specified in a Public Key or Symmetric Key Encrypted Session Key packet that precedes the Symmetrically Encrypted Data packet. In that case, the cipher algorithm ID is prefixed to the session key before it is encrypted. If no packets of these types precede the encrypted data, the IDEA algorithm is used with the session key calculated as the MD5 hash of the passphrase, though this use is deprecated.",
      "ja": "使用される対称暗号は、対称的に暗号化されたデータパケットの前にある公開キーまたは対称キー暗号化セッションキーパケットで指定できます。その場合、暗号アルゴリズムIDは、暗号化される前にセッションキーの前に付けられます。これらのタイプのパケットが暗号化されたデータに先行していない場合、この使用は非推奨ですが、PassPhraseのMD5ハッシュとして計算されたセッションキーでアイデアアルゴリズムが使用されます。"
    },
    {
      "indent": 3,
      "text": "The data is encrypted in CFB mode (see Section 12.9). For the random prefix, the IV is specified as all zeros. Instead of achieving randomized encryption through an IV, a string of length equal to the block size of the cipher plus two is encrypted for this purpose. The first block-size octets (for example, 16 octets for a 128-bit block length) are random, and the following two octets are copies of the last two octets of the first block-size random octets. For example, for a 16-octet block length, octet 17 is a copy of octet 15, and octet 18 is a copy of octet 16. For a cipher of block length 8, octet 9 is a copy of octet 7, and octet 10 is a copy of octet 8. (In both of these examples, we consider the first octet to be numbered 1.)",
      "ja": "データはCFBモードで暗号化されています（セクション12.9を参照）。ランダムプレフィックスの場合、IVはすべてのゼロとして指定されています。IVを介してランダム化された暗号化を達成する代わりに、この目的のために、暗号と2のブロックサイズに等しい長さの長さが暗号化されます。最初のブロックサイズのオクテット（たとえば、128ビットブロックの長さの16オクテット）はランダムであり、次の2つのオクテットは、最初のブロックサイズのランダムオクテットの最後の2オクテットのコピーです。たとえば、16オクテットのブロック長の場合、Octet 17はOctet 15のコピーであり、Octet 18はOctet 16のコピーです。ブロック長8の暗号では、Octet 9はOctet 7のコピーとOctet 10のコピーです。Octet 8のコピーです（これらの例の両方で、最初のオクテットに番号が付けられていると考えています。）"
    },
    {
      "indent": 3,
      "text": "After encrypting these block-size-plus-two octets, a new CFB context is created for the encryption of the data, with the last block-size octets of the first ciphertext as the IV. (Alternatively and equivalently, the CFB state is resynchronized: the last block-size octets of ciphertext are passed through the cipher, and the block boundary is reset.)",
      "ja": "これらのブロックサイズプラス2オクテットを暗号化した後、データの暗号化のために新しいCFBコンテキストが作成され、最初の暗号文の最後のブロックサイズのオクテットがIVとして作成されます。（代わりに、同等に、CFB状態は再同期されます。暗号文の最後のブロックサイズのオクテットが暗号に渡され、ブロック境界がリセットされます。）"
    },
    {
      "indent": 3,
      "text": "The repetition of two octets in the random prefix allows the receiver to immediately check whether the session key is incorrect. See Section 13.4 for hints on the proper use of this \"quick check\".",
      "ja": "ランダムなプレフィックスで2つのオクテットを繰り返すことで、受信機はセッションキーが正しくないかどうかをすぐに確認できます。この「クイックチェック」の適切な使用に関するヒントについては、セクション13.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8. Marker Packet (Type ID 10)",
      "section_title": true,
      "ja": "5.8. マーカーパケット（タイプID 10）"
    },
    {
      "indent": 3,
      "text": "The body of the Marker packet consists of:",
      "ja": "マーカーパケットの本体は以下で構成されています。"
    },
    {
      "indent": 6,
      "text": "* The three octets 0x50, 0x47, 0x50 (which spell \"PGP\" in UTF-8).",
      "ja": "* 3オクテット0x50、0x47、0x50（UTF-8で「PGP」を綴ります）。"
    },
    {
      "indent": 3,
      "text": "Such a packet MUST be ignored when received.",
      "ja": "このようなパケットは、受け取ったときに無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.9. Literal Data Packet (Type ID 11)",
      "section_title": true,
      "ja": "5.9. リテラルデータパケット（タイプID 11）"
    },
    {
      "indent": 3,
      "text": "A Literal Data packet contains the body of a message; that is, data that is not to be further interpreted.",
      "ja": "リテラルデータパケットには、メッセージの本文が含まれています。つまり、さらに解釈されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet field that describes how the data is formatted.",
      "ja": "* データのフォーマット方法を説明する1-OCTETフィールド。"
    },
    {
      "indent": 10,
      "text": "If it is a b (0x62), then the Literal Data packet contains binary data. If it is a u (0x75), then the Literal Data packet contains UTF-8-encoded text data and thus may need line ends converted to local form or other text mode changes.",
      "ja": "a b（0x62）の場合、リテラルデータパケットにはバイナリデータが含まれています。U（0x75）の場合、リテラルデータパケットにはUTF-8エンコードされたテキストデータが含まれているため、ローカルフォームまたは他のテキストモードの変更に変換される行端が必要になる場合があります。"
    },
    {
      "indent": 10,
      "text": "Previous versions of the OpenPGP specification used t (0x74) to indicate textual data but did not specify the character encoding. Implementations SHOULD NOT emit this value. An implementation that receives a Literal Data packet with this value in the format field SHOULD interpret the packet data as UTF-8 encoded text, unless reliable (not attacker-controlled) context indicates a specific alternate text encoding. This mode is deprecated due to its ambiguity.",
      "ja": "OpenPGP仕様の以前のバージョンは、T（0x74）を使用してテキストデータを示しましたが、文字エンコードを指定しませんでした。実装はこの値を発してはなりません。フォーマットフィールドのこの値を使用してリテラルデータパケットを受信する実装は、信頼できる（攻撃者制御されていない）コンテキストが特定の代替テキストエンコーディングを示す場合を除き、PacketデータをUTF-8エンコードテキストとして解釈する必要があります。このモードは、その曖昧さのために非推奨です。"
    },
    {
      "indent": 10,
      "text": "Some implementations predating [RFC2440] also defined a value of l as a \"local\" mode for machine-local conversions. [RFC1991] incorrectly states that this local mode flag is 1 (ASCII numeral one). Both of these local modes are deprecated.",
      "ja": "[RFC2440]以前のいくつかの実装では、Lの値をマシンローカル変換の「ローカル」モードとして定義しました。[RFC1991]は、このローカルモードフラグが1（ASCII数字のフラグ）であると誤って述べています。これらのローカルモードはどちらも非推奨です。"
    },
    {
      "indent": 6,
      "text": "* The file name as a string (1-octet length, followed by a file name). This may be a zero-length string. Commonly, if the source of the encrypted data is a file, it will be the name of the encrypted file. An implementation MAY consider the file name in the Literal Data packet to be a more authoritative name than the actual file name.",
      "ja": "* ファイル名は文字列として（1-OCTETの長さ、その後にファイル名）。これはゼロ長さの文字列かもしれません。一般的に、暗号化されたデータのソースがファイルである場合、暗号化されたファイルの名前になります。実装では、リテラルデータパケットのファイル名が実際のファイル名よりも権威ある名前であると考える場合があります。"
    },
    {
      "indent": 6,
      "text": "* A 4-octet number that indicates a date associated with the literal data. Commonly, the date might be the modification date of a file, or the time the packet was created, or a zero that indicates no specific time.",
      "ja": "* リテラルデータに関連付けられた日付を示す4オクテット番号。一般的に、日付はファイルの変更日、またはパケットが作成された時間、または特定の時間を示さないゼロである可能性があります。"
    },
    {
      "indent": 6,
      "text": "* The remainder of the packet is literal data.",
      "ja": "* パケットの残りの部分はリテラルデータです。"
    },
    {
      "indent": 10,
      "text": "Text data MUST be encoded with UTF-8 (see [RFC3629]) and stored with <CR><LF> text endings (that is, network-normal line endings). These should be converted to native line endings by the receiving implementation.",
      "ja": "テキストデータは、UTF-8（[RFC3629]を参照）でエンコードし、<cr> <lf>テキストエンディング（つまり、ネットワーク通常のラインエンディング）で保存する必要があります。これらは、受信実装によりネイティブラインエンディングに変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that OpenPGP signatures do not include the formatting octet, the file name, and the date field of the Literal Data packet in a signature hash; therefore, those fields are not protected against tampering in a signed document. A receiving implementation MUST NOT treat those fields as though they were cryptographically secured by the surrounding signature when either representing them to the user or acting on them.",
      "ja": "OpenPGP署名には、署名ハッシュのリテラルデータパケットのフォーマットオクテット、ファイル名、および日付フィールドは含まれていないことに注意してください。したがって、これらのフィールドは、署名されたドキュメントの改ざんから保護されていません。受信する実装は、これらのフィールドを、ユーザーに表現するか、それらに基づいて行動するときに、周囲の署名によって暗号化されたものであるかのように扱ってはなりません。"
    },
    {
      "indent": 3,
      "text": "Due to their inherent malleability, an implementation that generates a Literal Data packet SHOULD avoid storing any significant data in these fields. If the implementation is certain that the data is textual and is encoded with UTF-8 (for example, if it will follow this Literal Data packet with a Signature packet of type 0x01 (see Section 5.2.1), it MAY set the format octet to u. Otherwise, it MUST set the format octet to b. It SHOULD set the filename to the empty string (encoded as a single zero octet) and the timestamp to zero (encoded as four zero octets).",
      "ja": "それらの固有の順応性により、リテラルデータパケットを生成する実装は、これらのフィールドに重要なデータの保存を避ける必要があります。実装がデータがテキストであり、UTF-8でエンコードされていることが確実である場合（たとえば、タイプ0x01の署名パケットを使用してこのリテラルデータパケットに従う場合（セクション5.2.1を参照）、Octetの形式を設定する場合がありますそれ以外の場合は、フォーマットをbに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "An application that wishes to include such filesystem metadata within a signature is advised to sign an encapsulated archive (for example, [PAX]).",
      "ja": "このようなファイルシステムメタデータを署名内に含めたいアプリケーションは、カプセル化されたアーカイブ（[Pax]）に署名することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "An implementation that generates a Literal Data packet MUST use the OpenPGP format for packet framing (see Section 4.2.1). It MUST NOT generate a Literal Data packet with Legacy format (Section 4.2.2).",
      "ja": "リテラルデータパケットを生成する実装では、パケットフレーミングにOpenPGP形式を使用する必要があります（セクション4.2.1を参照）。レガシー形式（セクション4.2.2）を備えたリテラルデータパケットを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "An implementation that deals with either historic data or data generated by an implementation that predates support for [RFC2440] MAY interpret Literal Data packets that use the Legacy format for packet framing.",
      "ja": "[RFC2440]のサポートに先行する実装によって生成された履歴データまたはデータのいずれかを扱う実装は、パケットフレーミングにレガシー形式を使用するリテラルデータパケットを解釈する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.9.1. Special Filename _CONSOLE (Deprecated)",
      "section_title": true,
      "ja": "5.9.1. 特別なファイル名_console（非推奨）"
    },
    {
      "indent": 3,
      "text": "The Literal Data packet's filename field has a historical special case for the special name _CONSOLE. When the filename field is _CONSOLE, the message is considered to be \"for your eyes only\". This advises that the message data is unusually sensitive, and the receiving program should process it more carefully, perhaps avoiding storing the received data to disk, for example.",
      "ja": "リテラルデータパケットのファイル名フィールドには、特別名_consoleの歴史的な特別ケースがあります。Filenameフィールドが_ Consoleの場合、メッセージは「目のみ」と見なされます。これは、メッセージデータが異常に感度が高いことをアドバイスし、受信プログラムはそれをより慎重に処理する必要があり、おそらく受信データをディスクに保存することを避ける必要があります。"
    },
    {
      "indent": 3,
      "text": "An OpenPGP deployment that generates Literal Data packets MUST NOT depend on this indicator being honored in any particular way. It cannot be enforced, and the field itself is not covered by any cryptographic signature.",
      "ja": "文字通りのデータパケットを生成するOpenPGP展開は、特定の方法で尊重されるこのインジケーターに依存してはなりません。強制することはできず、フィールド自体は暗号化の署名でカバーされません。"
    },
    {
      "indent": 3,
      "text": "It is NOT RECOMMENDED to use this special filename in a newly generated Literal Data packet.",
      "ja": "新しく生成されたリテラルデータパケットでこの特別なファイル名を使用することはお勧めしません。"
    },
    {
      "indent": 0,
      "text": "5.10. Trust Packet (Type ID 12)",
      "section_title": true,
      "ja": "5.10. 信頼パケット（タイプID 12）"
    },
    {
      "indent": 3,
      "text": "The Trust packet is used only within keyrings and is not normally exported. Trust packets contain data that record the user's specifications of which keyholders are trustworthy introducers, along with other information that implementation uses for trust information. The format of Trust packets is defined by a given implementation.",
      "ja": "トラストパケットはキーリング内でのみ使用され、通常はエクスポートされません。トラストパケットには、キーホルダーが信頼できる紹介者であるユーザーの仕様を記録するデータと、実装が信頼情報に使用する他の情報が含まれています。信頼パケットの形式は、特定の実装によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Trust packets SHOULD NOT be emitted to output streams that are transferred to other users, and they SHOULD be ignored on any input other than local keyring files.",
      "ja": "トラストパケットは、他のユーザーに転送される出力ストリームに放出されるべきではなく、ローカルキーリングファイル以外の入力で無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.11. User ID Packet (Type ID 13)",
      "section_title": true,
      "ja": "5.11. ユーザーIDパケット（タイプID 13）"
    },
    {
      "indent": 3,
      "text": "A User ID packet consists of UTF-8 text that is intended to represent the name and email address of the keyholder. By convention, it includes a mail name-addr as described in [RFC2822], but there are no restrictions on its content. The packet length in the header specifies the length of the User ID.",
      "ja": "ユーザーIDパケットは、キーホルダーの名前と電子メールアドレスを表すことを目的としたUTF-8テキストで構成されています。慣習により、[RFC2822]に記載されているように、メール名-ADDRが含まれていますが、コンテンツに制限はありません。ヘッダーのパケット長は、ユーザーIDの長さを指定します。"
    },
    {
      "indent": 0,
      "text": "5.12. User Attribute Packet (Type ID 17)",
      "section_title": true,
      "ja": "5.12. ユーザー属性パケット（タイプID 17）"
    },
    {
      "indent": 3,
      "text": "The User Attribute packet is a variation of the User ID packet. It is capable of storing more types of data than the User ID packet, which is limited to text. Like the User ID packet, a User Attribute packet may be certified by the key owner (\"self-signed\") or any other key owner who cares to certify it. Except as noted, a User Attribute packet may be used anywhere that a User ID packet may be used.",
      "ja": "ユーザー属性パケットは、ユーザーIDパケットのバリエーションです。テキストに限定されているユーザーIDパケットよりも多くの種類のデータを保存できます。ユーザーIDパケットと同様に、ユーザー属性パケットは、キーオーナー（「自己署名」）またはそれを認証したいと思う他のキーオーナーによって認定される場合があります。予定されている場合を除き、ユーザーIDパケットを使用できる場所でユーザー属性パケットを使用できます。"
    },
    {
      "indent": 3,
      "text": "While User Attribute packets are not a required part of the OpenPGP specification, implementations SHOULD provide at least enough compatibility to properly handle a certification signature on the User Attribute packet. A simple way to do this is by treating the User Attribute packet as a User ID packet with opaque contents, but an implementation may use any method desired.",
      "ja": "ユーザー属性パケットはOpenPGP仕様の必須部分ではありませんが、実装は、ユーザー属性パケットの認定署名を適切に処理するのに少なくとも十分な互換性を提供する必要があります。これを行う簡単な方法は、ユーザー属性パケットを不透明なコンテンツを持つユーザーIDパケットとして扱うことですが、実装は必要な方法を使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "The User Attribute packet is made up of one or more attribute subpackets. Each subpacket consists of a subpacket header and a body. The header consists of:",
      "ja": "ユーザー属性パケットは、1つ以上の属性サブパケットで構成されています。各サブパケットは、サブパケットヘッダーとボディで構成されています。ヘッダーは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* the subpacket length (1, 2, or 5 octets)",
      "ja": "* サブパケット長（1、2、または5オクテット）"
    },
    {
      "indent": 6,
      "text": "* the Subpacket Type ID (1 octet)",
      "ja": "* サブパケットタイプID（1オクテット）"
    },
    {
      "indent": 3,
      "text": "and is followed by the subpacket specific data.",
      "ja": "その後、サブパケット固有のデータが続きます。"
    },
    {
      "indent": 3,
      "text": "The following table lists the currently known subpackets:",
      "ja": "次の表には、現在既知のサブパケットを示します。"
    },
    {
      "indent": 8,
      "text": "+=========+=============================+================+\n|      ID | Attribute Subpacket         | Reference      |\n+=========+=============================+================+\n|       0 | Reserved                    |                |\n+---------+-----------------------------+----------------+\n|       1 | Image Attribute Subpacket   | Section 5.12.1 |\n+---------+-----------------------------+----------------+\n| 100-110 | Private or Experimental Use |                |\n+---------+-----------------------------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Table 13: OpenPGP User Attribute Subpacket Types Registry",
      "ja": "表13：OpenPGPユーザー属性サブパケットタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD ignore any subpacket of a type that it does not recognize.",
      "ja": "実装では、認識されていないタイプのサブパケットを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.12.1. Image Attribute Subpacket",
      "section_title": true,
      "ja": "5.12.1. 画像属性サブパケット"
    },
    {
      "indent": 3,
      "text": "The Image Attribute subpacket is used to encode an image, presumably (but not required to be) that of the key owner.",
      "ja": "画像属性サブパケットは、おそらくキー所有者の画像のエンコードに使用されます（おそらく必要ではありません）。"
    },
    {
      "indent": 3,
      "text": "The Image Attribute subpacket begins with an image header. The first two octets of the image header contain the length of the image header. Note that unlike other multi-octet numerical values in this document, due to a historical accident, this value is encoded as a little-endian number. The image header length is followed by a single octet for the image header version. The only currently defined version of the image header is 1, which is a 16-octet image header. The first three octets of a version 1 image header are thus 0x10, 0x00, 0x01.",
      "ja": "画像属性サブパケットは、画像ヘッダーから始まります。画像ヘッダーの最初の2オクテットには、画像ヘッダーの長さが含まれています。このドキュメントの他のマルチオクテット数値値とは異なり、歴史的な事故のため、この値は小さなエンディアン数としてエンコードされていることに注意してください。画像ヘッダーの長さの後に、画像ヘッダーバージョンの単一のオクテットが続きます。イメージヘッダーの唯一の定義バージョンは1で、16オクテットの画像ヘッダーです。したがって、バージョン1画像ヘッダーの最初の3オクテットは、0x10、0x00、0x01です。"
    },
    {
      "indent": 23,
      "text": "+=========+================+\n| Version | Reference      |\n+=========+================+\n|       1 | Section 5.12.1 |\n+---------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Table 14: OpenPGP Image Attribute Versions Registry",
      "ja": "表14：OpenPGP Image属性バージョンレジストリ"
    },
    {
      "indent": 3,
      "text": "The fourth octet of a version 1 image header designates the encoding format of the image. The only currently defined encoding format is the value 1 to indicate JPEG. Image format IDs 100 through 110 are reserved for Private or Experimental Use. The rest of the version 1 image header is made up of 12 reserved octets, all of which MUST be set to 0.",
      "ja": "バージョン1画像ヘッダーの4番目のオクテットは、画像のエンコード形式を指定します。現在定義されている唯一のエンコード形式は、JPEGを示す値1です。画像形式IDS 100〜110は、プライベートまたは実験的使用のために予約されています。バージョン1の画像ヘッダーの残りの部分は、12の予約済みオクテットで構成されており、そのすべてを0に設定する必要があります。"
    },
    {
      "indent": 17,
      "text": "+=========+=============================+\n|      ID | Encoding                    |\n+=========+=============================+\n|       0 | Reserved                    |\n+---------+-----------------------------+\n|       1 | JPEG [JFIF]                 |\n+---------+-----------------------------+\n| 100-110 | Private or Experimental Use |\n+---------+-----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 15: OpenPGP Image Attribute Encoding Format Registry",
      "ja": "表15：OpenPGP画像属性エンコードフォーマットレジストリ"
    },
    {
      "indent": 3,
      "text": "The rest of the image subpacket contains the image itself. As the only currently defined image type is JPEG, the image is encoded in the JPEG File Interchange Format (JFIF), a standard file format for JPEG images [JFIF].",
      "ja": "画像サブパケットの残りの部分には、画像自体が含まれています。現在定義されている唯一の画像タイプはJPEGであるため、画像はJPEG画像[JFIF]の標準ファイル形式であるJPEGファイルインターチェンジ形式（JFIF）にエンコードされています。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY try to determine the type of an image by examination of the image data if it is unable to handle a particular version of the image header or if a specified encoding format value is not recognized.",
      "ja": "実装は、画像ヘッダーの特定のバージョンを処理できない場合、または指定されたエンコード形式値が認識されない場合、画像データを調べて画像のタイプを決定しようとする場合があります。"
    },
    {
      "indent": 0,
      "text": "5.13. Symmetrically Encrypted and Integrity Protected Data Packet (Type ID 18)",
      "section_title": true,
      "ja": "5.13. 対称的に暗号化され、整合性保護されたデータパケット（タイプID 18）"
    },
    {
      "indent": 3,
      "text": "The SEIPD packet contains integrity-protected and encrypted data. When it has been decrypted, it will contain other packets forming an OpenPGP Message (see Section 10.3).",
      "ja": "SEIPDパケットには、整合性と暗号化されたデータが含まれています。復号化された場合、OpenPGPメッセージを形成する他のパケットが含まれます（セクション10.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The first octet of this packet is always used to indicate the version number, but different versions contain ciphertext that is structured differently. Version 1 of this packet contains data encrypted with a symmetric key algorithm and is thus protected against modification by the SHA-1 hash algorithm. This mechanism was introduced in [RFC4880] and offers some protections against ciphertext malleability.",
      "ja": "このパケットの最初のオクテットは常にバージョン番号を示すために使用されますが、異なるバージョンには、構造化されている暗号文が含まれています。このパケットのバージョン1には、対称キーアルゴリズムで暗号化されたデータが含まれているため、SHA-1ハッシュアルゴリズムによる変更から保護されています。このメカニズムは[RFC4880]で導入され、暗号文化順応性に対するいくつかの保護を提供します。"
    },
    {
      "indent": 3,
      "text": "Version 2 of this packet contains data encrypted with an AEAD construction. This offers a more cryptographically rigorous defense against ciphertext malleability. See Section 13.7 for more details on choosing between these formats.",
      "ja": "このパケットのバージョン2には、AEAD構造で暗号化されたデータが含まれています。これは、暗号文化障害に対するより暗号化的に厳密な防御を提供します。これらの形式の選択の詳細については、セクション13.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Any new version of the SEIPD packet should be registered in the registry established in Section 10.3.2.1.",
      "ja": "SEIPDパケットの新しいバージョンは、セクション10.3.2.1で確立されたレジストリに登録する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.13.1. Version 1 Symmetrically Encrypted and Integrity Protected Data Packet Format",
      "section_title": true,
      "ja": "5.13.1. バージョン1対称的に暗号化され、整合性保護されたデータパケット形式"
    },
    {
      "indent": 3,
      "text": "A version 1 Symmetrically Encrypted and Integrity Protected Data packet consists of:",
      "ja": "対称的に暗号化され、整合性保護されたデータパケットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number with value 1.",
      "ja": "* 値1の1-OCTETバージョン番号。"
    },
    {
      "indent": 6,
      "text": "* Encrypted data -- the output of the selected symmetric key cipher operating in CFB mode.",
      "ja": "* 暗号化されたデータ -  CFBモードで動作する選択された対称キー暗号の出力。"
    },
    {
      "indent": 3,
      "text": "The symmetric cipher used MUST be specified in a Public Key or Symmetric Key Encrypted Session Key packet that precedes the Symmetrically Encrypted and Integrity Protected Data packet. In either case, the cipher algorithm ID is prefixed to the session key before it is encrypted.",
      "ja": "使用される対称暗号は、対称的に暗号化され、整合性保護されたデータパケットに先行する公開キーまたは対称キー暗号化セッションキーパケットで指定する必要があります。どちらの場合でも、暗号アルゴリズムIDは、暗号化される前にセッションキーに接頭辞が付けられます。"
    },
    {
      "indent": 3,
      "text": "The data is encrypted in CFB mode (see Section 12.9). The IV is specified as all zeros. Instead of achieving randomized encryption through an IV, OpenPGP prefixes an octet string to the data before it is encrypted for this purpose. The length of the octet string equals the block size of the cipher in octets, plus two. The first octets in the group, of length equal to the block size of the cipher, are random; the last two octets are each copies of their 2nd preceding octet. For example, with a cipher whose block size is 128 bits or 16 octets, the prefix data will contain 16 random octets, then two more octets, which are copies of the 15th and 16th octets, respectively. Unlike the deprecated Symmetrically Encrypted Data packet (Section 5.7), this prefix data is encrypted in the same CFB context, and no special CFB resynchronization is done.",
      "ja": "データはCFBモードで暗号化されています（セクション12.9を参照）。IVはすべてのゼロとして指定されています。IVを介してランダム化された暗号化を達成する代わりに、OpenPGPはこの目的のために暗号化される前にデータにOctet文字列をプレフィックスします。オクテット文字列の長さは、オクテットの暗号のブロックサイズと2つに2つに等しくなります。グループの最初のオクテットは、暗号のブロックサイズに等しい長さのランダムです。最後の2つのオクテットは、それぞれ2番目のオクテットのコピーです。たとえば、ブロックサイズが128ビットまたは16オクテットの暗号を使用すると、プレフィックスデータには16のランダムオクテット、さらに2つのオクテットが含まれます。非推定された対称的に暗号化されたデータパケット（セクション5.7）とは異なり、このプレフィックスデータは同じCFBコンテキストで暗号化されており、特別なCFB再同期は行われません。"
    },
    {
      "indent": 3,
      "text": "The repetition of 16 bits in the random data prefixed to the message allows the receiver to immediately check whether the session key is incorrect. See Section 13.4 for hints on the proper use of this \"quick check\".",
      "ja": "メッセージに付けられたランダムデータの16ビットの繰り返しにより、受信者はセッションキーが正しくないかどうかをすぐに確認できます。この「クイックチェック」の適切な使用に関するヒントについては、セクション13.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Two constant octets with the values 0xD3 and 0x14 are appended to the plaintext. Then, the plaintext of the data to be encrypted is passed through the SHA-1 hash function. The input to the hash function is comprised of the prefix data described above and all of the plaintext, including the trailing constant octets 0xD3, 0x14. The 20 octets of the SHA-1 hash are then appended to the plaintext (after the constant octets 0xD3, 0x14) and encrypted along with the plaintext using the same CFB context. This trailing checksum is known as the Modification Detection Code (MDC).",
      "ja": "値0xD3と0x14を持つ2つの定数オクテットがプレーンテキストに追加されます。次に、暗号化されるデータのプレーンテキストは、SHA-1ハッシュ関数に渡されます。ハッシュ関数への入力は、上記のプレフィックスデータと、末尾の定数オクテット0xd3、0x14を含むすべてのプレーンテキストで構成されています。SHA-1ハッシュの20オクテットは、プレーンテキストに追加され（一定のオクテット0xD3、0x14の後）、同じCFBコンテキストを使用してプレーンテキストとともに暗号化されます。この後続のチェックサムは、修正検出コード（MDC）として知られています。"
    },
    {
      "indent": 3,
      "text": "During decryption, the plaintext data should be hashed with SHA-1, including the prefix data as well as the trailing constant octets 0xD3, 0x14, but excluding the last 20 octets containing the SHA-1 hash. The computed SHA-1 hash is then compared with the last 20 octets of plaintext. A mismatch of the hash indicates that the message has been modified and MUST be treated as a security problem. Any failure SHOULD be reported to the user.",
      "ja": "復号化中、プレーンテキストデータは、プレフィックスデータと、末尾の定数オクテット0xd3、0x14を含むが、SHA-1ハッシュを含む最後の20オクテットを除外するSHA-1でハッシュする必要があります。計算されたSHA-1ハッシュは、プレーンテキストの最後の20オクテットと比較されます。ハッシュの不一致は、メッセージが変更されており、セキュリティ問題として扱わなければならないことを示します。失敗はユーザーに報告する必要があります。"
    },
    {
      "indent": 3,
      "text": " NON-NORMATIVE EXPLANATION",
      "ja": "非規範的な説明"
    },
    {
      "indent": 3,
      "text": " The MDC system, as the integrity protection mechanism of the version 1 Symmetrically Encrypted and Integrity Protected Data packet is called, was created to provide an integrity mechanism that is less strong than a signature, yet stronger than bare CFB encryption.",
      "ja": "MDCシステムは、バージョン1の対称的に暗号化され、整合性保護されたデータパケットの整合性保護メカニズムが呼び出され、署名よりも強いが裸のCFB暗号化よりも強い整合性メカニズムを提供するために作成されました。"
    },
    {
      "indent": 3,
      "text": " CFB encryption has a limitation as damage to the ciphertext will corrupt the affected cipher blocks and the block following. Additionally, if data is removed from the end of a CFB-encrypted block, that removal is undetectable. (Note also that CBC mode has a similar limitation, but data removed from the front of the block is undetectable.)",
      "ja": "CFB暗号化には、影響を受ける暗号ブロックとブロックのフォローが破損するため、CFB暗号化には制限があります。さらに、CFB暗号化されたブロックの端からデータが削除された場合、その削除は検出できません。（CBCモードにも同様の制限がありますが、ブロックの前面から削除されたデータは検出できません。）"
    },
    {
      "indent": 3,
      "text": " The obvious way to protect or authenticate an encrypted block is to digitally sign it. However, many people do not wish to habitually sign data for a large number of reasons that are beyond the scope of this document. Suffice it to say that many people consider properties such as deniability to be as valuable as integrity.",
      "ja": "暗号化されたブロックを保護または認証する明白な方法は、デジタルで署名することです。ただし、多くの人々は、このドキュメントの範囲を超えた多くの理由で習慣的にデータに署名することを望んでいません。多くの人々が、否定性などの特性を誠実さと同じくらい価値があると考えていると言うだけで十分です。"
    },
    {
      "indent": 3,
      "text": " OpenPGP addresses this desire to have more security than raw encryption and yet preserve deniability with the MDC system. An MDC is intentionally not a Message Authentication Code (MAC). Its name was not selected by accident. It is analogous to a checksum.",
      "ja": "OpenPGPは、生の暗号化よりも多くのセキュリティを持ちたいというこの欲求に対処し、MDCシステムで否定を維持します。MDCは、意図的にメッセージ認証コード（MAC）ではありません。その名前は偶然に選択されませんでした。チェックサムに似ています。"
    },
    {
      "indent": 3,
      "text": " Despite the fact that it is a relatively modest system, it has proved itself in the real world. It is an effective defense to several attacks that have surfaced since it has been created. It has met its modest goals admirably.",
      "ja": "それは比較的控えめなシステムであるという事実にもかかわらず、それは現実の世界で証明されています。これは、作成されてから浮上してきたいくつかの攻撃に対する効果的な防御です。それは控えめな目標を見事に満たしています。"
    },
    {
      "indent": 3,
      "text": " Consequently, because it is a modest security system, it has modest requirements on the hash function(s) it employs. It does not rely on a hash function being collision-free; it relies on a hash function being one-way. If a forger, Frank, wishes to send Alice a (digitally) unsigned message that says, \"I've always secretly loved you, signed Bob\", it is far easier for him to construct a new message than it is to modify anything intercepted from Bob. (Note also that if Bob wishes to communicate secretly with Alice, but without authentication or identification and with a threat model that includes forgers, he has a problem that transcends mere cryptography.)",
      "ja": "その結果、それは控えめなセキュリティシステムであるため、使用するハッシュ関数に関する控えめな要件があります。衝突のないハッシュ関数に依存していません。ハッシュ関数が一方向であることに依存しています。ForgerのFrankが、「私はいつもあなたを愛していて、ボブに署名した」と言っている（デジタル）非署名メッセージを送信したい場合、傍受されるものを変更するよりも新しいメッセージを作成する方がはるかに簡単ですボブから。（ボブがアリスとひそかにコミュニケーションをとりたいが、認証や識別がなく、偽造者を含む脅威モデルとのコミュニケーションを望んでいる場合、彼は単なる暗号を超越する問題があることに注意してください。）"
    },
    {
      "indent": 3,
      "text": " Note also that unlike nearly every other OpenPGP subsystem, there are no parameters in the MDC system. It hard-defines SHA-1 as its hash function. This is not an accident. It is an intentional choice to avoid downgrade and cross-grade attacks while making a simple, fast system. (A downgrade attack is an attack that would replace SHA2-256 with SHA-1, for example. A cross-grade attack would replace SHA-1 with another 160-bit hash, such as RIPEMD-160, for example.)",
      "ja": "また、他のほぼすべてのOpenPGPサブシステムとは異なり、MDCシステムにパラメーターはないことに注意してください。Hash関数としてSha-1を固定します。これは事故ではありません。シンプルで高速なシステムを作成しながら、ダウングレード攻撃やクロスグレードの攻撃を避けることは意図的な選択です。（ダウングレード攻撃は、たとえばSHA2-256をSHA-1に置き換える攻撃です。たとえば、クロスグレードの攻撃は、SHA-1をRipemd-160などの別の160ビットハッシュに置き換えます。）"
    },
    {
      "indent": 3,
      "text": " However, no update will be needed because the MDC has been replaced by the AEAD encryption described in this document.",
      "ja": "ただし、MDCがこのドキュメントで説明されているAEAD暗号化に置き換えられているため、更新は必要ありません。"
    },
    {
      "indent": 0,
      "text": "5.13.2. Version 2 Symmetrically Encrypted and Integrity Protected Data Packet Format",
      "section_title": true,
      "ja": "5.13.2. バージョン2対称的に暗号化され、整合性保護されたデータパケット形式"
    },
    {
      "indent": 3,
      "text": "A version 2 Symmetrically Encrypted and Integrity Protected Data packet consists of:",
      "ja": "対称的に暗号化され、整合性保護されたデータパケットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet version number with value 2.",
      "ja": "* 値2の1-OCTETバージョン番号。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet cipher algorithm ID.",
      "ja": "* 1-OCTET暗号アルゴリズムID。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet AEAD algorithm identifier.",
      "ja": "* 1-OCTET AEADアルゴリズム識別子。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet chunk size.",
      "ja": "* 1-OCTETチャンクサイズ。"
    },
    {
      "indent": 6,
      "text": "* 32 octets of salt. The salt is used to derive the message key and MUST be securely generated (see Section 13.10).",
      "ja": "* 32オクテットの塩。塩はメッセージキーを導出するために使用され、安全に生成する必要があります（セクション13.10を参照）。"
    },
    {
      "indent": 6,
      "text": "* Encrypted data; that is, the output of the selected symmetric key cipher operating in the given AEAD mode.",
      "ja": "* 暗号化されたデータ。つまり、特定のAEADモードで動作する選択された対称キー暗号の出力です。"
    },
    {
      "indent": 6,
      "text": "* A final summary authentication tag for the AEAD mode.",
      "ja": "* AEADモードの最終要約認証タグ。"
    },
    {
      "indent": 3,
      "text": "The decrypted session key and the salt are used to derive an M-bit message key and N-64 bits used as the IV, where M is the key size of the symmetric algorithm and N is the nonce size of the AEAD algorithm. M + N - 64 bits are derived using HKDF (see [RFC5869]). The leftmost M bits are used as a symmetric algorithm key, and the remaining N - 64 bits are used as an IV. HKDF is used with SHA256 [RFC6234] as hash algorithm. The session key is used as IKM and the salt as salt. The Packet Type ID in OpenPGP format encoding (bits 7 and 6 are set, and bits 5-0 carry the Packet Type ID), version number, cipher algorithm ID, AEAD algorithm ID, and chunk size octet are used as info parameter.",
      "ja": "復号化されたセッションキーと塩は、MビットメッセージキーとIVとして使用されるN-64ビットを導出するために使用されます。ここで、Mは対称アルゴリズムのキーサイズ、NはAEADアルゴリズムの非CEサイズです。M + N -64ビットはHKDFを使用して導出されます（[RFC5869]を参照）。左端のMビットは対称アルゴリズムキーとして使用され、残りのn -64ビットはIVとして使用されます。HKDFは、HashアルゴリズムとしてSHA256 [RFC6234]で使用されます。セッションキーはIKMとして、塩は塩として使用されます。OpenPGP形式のエンコード（ビット7および6が設定されており、ビット5-0がパケットタイプIDを運ぶ）、バージョン番号、暗号アルゴリズムID、AEADアルゴリズムID、およびチャンクサイズのオクテットが情報パラメーターとして使用されます。"
    },
    {
      "indent": 3,
      "text": "The KDF mechanism provides key separation between cipher and AEAD algorithms. Furthermore, an implementation can securely reply to a message even if a recipient's certificate is unknown by reusing the Encrypted Session Key packets and replying with a different salt that yields a new, unique message key. See Section 13.8 for guidance on how applications can securely implement this feature.",
      "ja": "KDFメカニズムは、CipherとAEADアルゴリズムの重要な分離を提供します。さらに、暗号化されたセッションキーパケットを再利用し、新しいユニークなメッセージキーを生成する別の塩で返信することにより、受信者の証明書が不明であっても、実装はメッセージに安全に返信できます。アプリケーションがこの機能を安全に実装する方法についてのガイダンスについては、セクション13.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "A v2 SEIPD packet consists of one or more chunks of data. The plaintext of each chunk is of a size specified by the chunk size octet using the method specified below.",
      "ja": "V2 SEIPDパケットは、1つ以上のデータの塊で構成されています。各チャンクの平文は、以下に指定された方法を使用して、チャンクサイズのオクテットで指定されたサイズです。"
    },
    {
      "indent": 3,
      "text": "The encrypted data consists of the encryption of each chunk of plaintext, followed immediately by the relevant authentication tag. If the last chunk of plaintext is smaller than the chunk size, the ciphertext for that data may be shorter; nevertheless, it is followed by a full authentication tag.",
      "ja": "暗号化されたデータは、プレーンテキストの各チャンクの暗号化で構成され、すぐに関連する認証タグが続きます。平文の最後のチャンクがチャンクサイズよりも小さい場合、そのデータの暗号文は短くなる可能性があります。それにもかかわらず、完全な認証タグが続きます。"
    },
    {
      "indent": 3,
      "text": "For each chunk, the AEAD construction is given the Packet Type ID encoded in OpenPGP format (bits 7 and 6 are set, and bits 5-0 carry the Packet Type ID), version number, cipher algorithm ID, AEAD algorithm ID, and chunk size octet as additional data. For example, the additional data of the first chunk using EAX and AES-128 with a chunk size of 2^22 octets consists of the octets 0xD2, 0x02, 0x07, 0x01, and 0x10.",
      "ja": "各チャンクについて、AEAD構造には、OpenPGP形式でエンコードされたパケットタイプIDが与えられます（ビット7と6が設定され、ビット5-0がパケットタイプIDを運びます）、バージョン番号、暗号アルゴリズムID、AEADアルゴリズムID、およびChunk追加データとしてオクテットのサイズ。たとえば、2^22オクテットのチャンクサイズを持つEAXとAES-128を使用した最初のチャンクの追加データは、オクテット0xd2、0x02、0x07、0x01、および0x10で構成されています。"
    },
    {
      "indent": 3,
      "text": "After the final chunk, the AEAD algorithm is used to produce a final authentication tag encrypting the empty string. This AEAD instance is given the additional data specified above, plus an 8-octet, big-endian value specifying the total number of plaintext octets encrypted. This allows detection of a truncated ciphertext.",
      "ja": "最後のチャンクの後、AEADアルゴリズムを使用して、空の文字列を暗号化する最終認証タグを作成します。このAEADインスタンスには、上記で指定された追加データに加えて、暗号化されたプレーンテキストオクテットの総数を指定する8オクテットのビッグエンディアン値が与えられます。これにより、切り捨てられた暗号文の検出が可能になります。"
    },
    {
      "indent": 3,
      "text": "The chunk size octet specifies the size of chunks using the following formula (in C [C99]), where c is the chunk size octet:",
      "ja": "チャンクサイズのオクテットは、次の式（C [C99]）を使用してチャンクのサイズを指定します。ここで、Cはチャンクサイズのオクテットです。"
    },
    {
      "indent": 5,
      "text": "chunk_size = (uint32_t) 1 << (c + 6)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An implementation MUST accept chunk size octets with values from 0 to 16. An implementation MUST NOT create data with a chunk size octet value larger than 16 (4 MiB chunks).",
      "ja": "実装は、0から16の値でチャンクサイズのオクテットを受け入れる必要があります。実装は、16（4 MIBチャンク）を大きいチャンクサイズのオクテット値でデータを作成してはなりません。"
    },
    {
      "indent": 3,
      "text": "The nonce for AEAD mode consists of two parts. Let N be the size of the nonce. The leftmost N - 64 bits are the IV derived using HKDF. The rightmost 64 bits are the chunk index as a big-endian value. The index of the first chunk is zero.",
      "ja": "AEADモードのNonCEは2つの部分で構成されています。nをノンセのサイズとします。左n -64ビットは、HKDFを使用して派生したIVです。右端の64ビットは、ビッグエンディアンの価値としてチャンクインデックスです。最初のチャンクのインデックスはゼロです。"
    },
    {
      "indent": 0,
      "text": "5.13.3. EAX Mode",
      "section_title": true,
      "ja": "5.13.3. EAXモード"
    },
    {
      "indent": 3,
      "text": "The EAX AEAD algorithm used in this document is defined in [EAX].",
      "ja": "このドキュメントで使用されているEAX AEADアルゴリズムは、[EAX]で定義されています。"
    },
    {
      "indent": 3,
      "text": "The EAX algorithm can only use block ciphers with 16-octet blocks. The nonce is 16 octets long. EAX authentication tags are 16 octets long.",
      "ja": "EAXアルゴリズムは、16オクテットのブロックを持つブロック暗号のみを使用できます。NonCeの長さは16オクテットです。EAX認証タグの長さは16オクターです。"
    },
    {
      "indent": 0,
      "text": "5.13.4. OCB Mode",
      "section_title": true,
      "ja": "5.13.4. OCBモード"
    },
    {
      "indent": 3,
      "text": "The OCB AEAD algorithm used in this document is defined in [RFC7253].",
      "ja": "このドキュメントで使用されているOCB AEADアルゴリズムは、[RFC7253]で定義されています。"
    },
    {
      "indent": 3,
      "text": "The OCB algorithm can only use block ciphers with 16-octet blocks. The nonce is 15 octets long. OCB authentication tags are 16 octets long.",
      "ja": "OCBアルゴリズムは、16オクテットのブロックを持つブロック暗号のみを使用できます。NonCeの長さは15オクテットです。OCB認証タグの長さは16オクターです。"
    },
    {
      "indent": 0,
      "text": "5.13.5. GCM Mode",
      "section_title": true,
      "ja": "5.13.5. GCMモード"
    },
    {
      "indent": 3,
      "text": "The GCM AEAD algorithm used in this document is defined in [SP800-38D].",
      "ja": "このドキュメントで使用されているGCM AEADアルゴリズムは、[SP800-38D]で定義されています。"
    },
    {
      "indent": 3,
      "text": "The GCM algorithm can only use block ciphers with 16-octet blocks. The nonce is 12 octets long. GCM authentication tags are 16 octets long.",
      "ja": "GCMアルゴリズムは、16オクテットのブロックを持つブロック暗号のみを使用できます。Nonceの長さは12オクテットです。GCM認証タグの長さは16オクターです。"
    },
    {
      "indent": 0,
      "text": "5.14. Padding Packet (Type ID 21)",
      "section_title": true,
      "ja": "5.14. パディングパケット（タイプID 21）"
    },
    {
      "indent": 3,
      "text": "The Padding packet contains random data and can be used to defend against traffic analysis (see Section 13.11) on v2 SEIPD messages (see Section 5.13.2) and Transferable Public Keys (see Section 10.1).",
      "ja": "パディングパケットにはランダムデータが含まれており、V2 SEIPDメッセージ（セクション5.13.2を参照）および転送可能なパブリックキー（セクション10.1を参照）のトラフィック分析（セクション13.11を参照）を防御するために使用できます（セクション5.13.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Such a packet MUST be ignored when received.",
      "ja": "このようなパケットは、受け取ったときに無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Its contents SHOULD be random octets to make the length obfuscation it provides more robust even when compressed.",
      "ja": "その内容は、圧縮されたときでもより堅牢な長さの難読化を行うためにランダムなオクテットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "An implementation adding padding to an OpenPGP stream SHOULD place such a packet:",
      "ja": "OpenPGPストリームにパディングを追加する実装は、そのようなパケットを配置する必要があります。"
    },
    {
      "indent": 6,
      "text": "* At the end of a version 6 Transferable Public Key that is transferred over an encrypted channel (see Section 10.1).",
      "ja": "* 暗号化されたチャネルに転送されるバージョン6転送可能な公開キーの最後に（セクション10.1を参照）。"
    },
    {
      "indent": 6,
      "text": "* As the last packet of an Optionally Padded Message within a version 2 Symmetrically Encrypted and Integrity Protected Data packet (see Section 10.3.1).",
      "ja": "* バージョン2内のオプションでパッド入りのメッセージの最後のパケットとして、対称的に暗号化され、整合性保護されたデータパケット（セクション10.3.1を参照）。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST be able to process Padding packets anywhere else in an OpenPGP stream so that future revisions of this document may specify further locations for padding.",
      "ja": "実装は、OpenPGPストリームの他の場所でパディングパケットを処理できる必要があります。これにより、このドキュメントの将来の改訂により、パディング用のさらなる場所が指定される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Policy about how large to make such a packet to defend against traffic analysis is beyond the scope of this document.",
      "ja": "トラフィック分析を防御するためにこのようなパケットを作成する大きさに関するポリシーは、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "6. Base64 Conversions",
      "section_title": true,
      "ja": "6. base64変換"
    },
    {
      "indent": 3,
      "text": "As stated in the introduction, OpenPGP's underlying representation for objects is a stream of arbitrary octets, and some systems desire these objects to be immune to damage caused by character set translation, data conversions, etc.",
      "ja": "導入部で述べたように、OpenPGPのオブジェクトの根本的な表現は任意のオクテットの流れであり、一部のシステムは、これらのオブジェクトが文字セットの翻訳、データ変換などによって引き起こされる損傷の免疫を望んでいることを望んでいます。"
    },
    {
      "indent": 3,
      "text": "In principle, any printable encoding scheme that met the requirements of the unsafe channel would suffice, since it would not change the underlying binary bit streams of the OpenPGP data structures. The OpenPGP specification specifies one such printable encoding scheme to ensure interoperability; see Section 6.2.",
      "ja": "原則として、安全でないチャネルの要件を満たす印刷可能なエンコードスキームでは、OpenPGPデータ構造の基礎となるバイナリビットストリームを変更しないため、十分であれば十分です。OpenPGP仕様は、相互運用性を確保するために、そのような印刷可能なエンコードスキームの1つを指定します。セクション6.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The encoding is composed of two parts: a base64 encoding of the binary data and an optional checksum. The base64 encoding used is described in Section 4 of [RFC4648], and it is wrapped into lines of no more than 76 characters each.",
      "ja": "エンコーディングは、2つの部分の2つの部分で構成されています。バイナリデータのBase64エンコードとオプションのチェックサムです。使用されるbase64エンコーディングは[RFC4648]のセクション4で説明されており、それぞれ76文字以下の線に包まれています。"
    },
    {
      "indent": 3,
      "text": "When decoding base64, an OpenPGP implementation MUST ignore all whitespace.",
      "ja": "Base64をデコードする場合、OpenPGPの実装はすべての空白を無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Optional Checksum",
      "section_title": true,
      "ja": "6.1. オプションのチェックサム"
    },
    {
      "indent": 3,
      "text": "The optional checksum is a 24-bit Cyclic Redundancy Check (CRC) converted to four characters of base64 encoding by the same MIME base64 transformation, preceded by an equal sign (=). The CRC is computed by using the generator 0x864CFB and an initialization of 0xB704CE. The accumulation is done on the data before it is converted to base64 rather than on the converted data. A sample implementation of this algorithm is in Section 6.1.1.",
      "ja": "オプションのチェックサムは、同じMIME Base64変換によってベース64エンコードの4つの文字に変換された24ビットの環状冗長チェック（CRC）であり、その前に等記号（=）があります。CRCは、発電機0x864CFBと0xB704ceの初期化を使用して計算されます。蓄積は、変換されたデータではなく、base64に変換される前にデータに対して行われます。このアルゴリズムのサンプル実装は、セクション6.1.1にあります。"
    },
    {
      "indent": 3,
      "text": "If present, the checksum with its leading equal sign MUST appear on the next line after the base64-encoded data.",
      "ja": "存在する場合、base64がエンコードされたデータの後、その先行標識を持つチェックサムが次の行に表示される必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT reject an OpenPGP object when the CRC24 footer is present, missing, malformed, or disagrees with the computed CRC24 sum. When forming ASCII Armor, the CRC24 footer SHOULD NOT be generated, unless interoperability with implementations that require the CRC24 footer to be present is a concern.",
      "ja": "CRC24フッターが存在し、欠落、奇形、または計算されたCRC24合計と同意しない場合、実装はOpenPGPオブジェクトを拒否してはなりません。ASCIIアーマーを形成する場合、CRC24フッターの存在を必要とする実装との相互運用性が懸念事項でない限り、CRC24フッターを生成する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The CRC24 footer MUST NOT be generated if it can be determined by the context or by the OpenPGP object being encoded that the consuming implementation accepts base64-encoded blocks without a CRC24 footer. Notably:",
      "ja": "CRC24フッターは、コンテキストによって決定される場合、または消費される実装がCRC24フッターなしでBase64エンコードブロックを受け入れることをエンコードするオープンPGPオブジェクトによって決定できない場合は生成する必要はありません。特に："
    },
    {
      "indent": 6,
      "text": "* An ASCII-armored Encrypted Message packet sequence that ends in a v2 SEIPD packet MUST NOT contain a CRC24 footer.",
      "ja": "* V2 SEIPDパケットで終了するASCII-armoredの暗号化されたメッセージパケットシーケンスは、CRC24フッターを含めてはなりません。"
    },
    {
      "indent": 6,
      "text": "* An ASCII-armored sequence of Signature packets that only includes version 6 Signature packets MUST NOT contain a CRC24 footer.",
      "ja": "* バージョン6の署名パケットのみを含む署名パケットのAscii-armoredシーケンスは、CRC24フッターを含めてはなりません。"
    },
    {
      "indent": 6,
      "text": "* An ASCII-armored Transferable Public Key packet sequence of a version 6 key MUST NOT contain a CRC24 footer.",
      "ja": "* バージョン6キーのAscii-armored転送可能な公開キーパケットシーケンスには、CRC24フッターを含めてはなりません。"
    },
    {
      "indent": 6,
      "text": "* An ASCII-armored keyring consisting of only version 6 keys MUST NOT contain a CRC24 footer.",
      "ja": "* バージョン6キーのみで構成されるAscii-armoredキーリングには、CRC24フッターを含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "Rationale: Previous draft versions of this document stated that the CRC24 footer is optional, but the text was ambiguous. In practice, very few implementations require the CRC24 footer to be present. Computing the CRC24 incurs a significant cost, while providing no meaningful integrity protection. Therefore, generating it is now discouraged.",
      "ja": "理論的根拠：このドキュメントの以前のドラフトバージョンは、CRC24フッターはオプションであるが、テキストはあいまいだったと述べました。実際には、CRC24フッターを存在させる必要がある実装はほとんどありません。CRC24を計算すると、意味のある整合性保護を提供しながら、かなりのコストがかかります。したがって、それを生成することは今では落胆しています。"
    },
    {
      "indent": 0,
      "text": "6.1.1. An Implementation of the CRC24 in \"C\"",
      "section_title": true,
      "ja": "6.1.1. 「C」でのCRC24の実装"
    },
    {
      "indent": 3,
      "text": "The following code is written in [C99].",
      "ja": "次のコードは[C99]に記述されています。"
    },
    {
      "indent": 3,
      "text": "#define CRC24_INIT 0xB704CEL\n#define CRC24_GENERATOR 0x864CFBL\n\ntypedef unsigned long crc24;\ncrc24 crc_octets(unsigned char *octets, size_t len)\n{\n    crc24 crc = CRC24_INIT;\n    int i;\n    while (len--) {\n        crc ^= (*octets++) << 16;\n        for (i = 0; i < 8; i++) {\n            crc <<= 1;\n            if (crc & 0x1000000) {\n                crc &= 0XFFFFFF; /* Clear bit 25 to avoid overflow */\n                crc ^= CRC24_GENERATOR;\n            }\n        }\n    }\n    return crc & 0xFFFFFFL;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. Forming ASCII Armor",
      "section_title": true,
      "ja": "6.2. ASCIIアーマーの形成"
    },
    {
      "indent": 3,
      "text": "When OpenPGP encodes data into ASCII Armor, it puts specific headers around the base64-encoded data, so OpenPGP can reconstruct the data later. An OpenPGP implementation MAY use ASCII Armor to protect raw binary data. OpenPGP informs the user what kind of data is encoded in the ASCII Armor through the use of the headers.",
      "ja": "OpenPGPがデータをASCIIアーマーにエンコードすると、Base64エンコードデータの周りに特定のヘッダーを配置するため、OpenPGPは後でデータを再構築できます。OpenPGP実装は、ASCIIアーマーを使用して生のバイナリデータを保護する場合があります。OpenPGPは、ヘッダーを使用してASCIIアーマーでエンコードされるデータの種類をユーザーに通知します。"
    },
    {
      "indent": 3,
      "text": "Concatenating the following data creates ASCII Armor:",
      "ja": "次のデータを連結すると、ASCIIアーマーが作成されます。"
    },
    {
      "indent": 6,
      "text": "* An Armor Header Line, appropriate for the type of data",
      "ja": "* データの種類に適したアーマーヘッダーライン"
    },
    {
      "indent": 6,
      "text": "* Armor Headers",
      "ja": "* アーマーヘッダー"
    },
    {
      "indent": 6,
      "text": "* A blank (zero length or containing only whitespace) line",
      "ja": "* ブランク（長さゼロまたはホワイトスペースのみを含む）ライン"
    },
    {
      "indent": 6,
      "text": "* The ASCII-Armored data",
      "ja": "* Ascii-Amoredデータ"
    },
    {
      "indent": 6,
      "text": "* An optional Armor Checksum (discouraged; see Section 6.1)",
      "ja": "* オプションのアーマーチェックサム（落胆;セクション6.1を参照）"
    },
    {
      "indent": 6,
      "text": "* The Armor Tail, which depends on the Armor Header Line",
      "ja": "* アーマーヘッダーラインに依存する鎧の尾"
    },
    {
      "indent": 0,
      "text": "6.2.1. Armor Header Line",
      "section_title": true,
      "ja": "6.2.1. アーマーヘッダーライン"
    },
    {
      "indent": 3,
      "text": "An Armor Header Line consists of the appropriate header line text surrounded by five (5) dashes (-, 0x2D) on either side of the header line text. The header line text is chosen based on the type of data being encoded in Armor and how it is being encoded. Header line texts include the following strings:",
      "ja": "アーマーヘッダーラインは、ヘッダーラインテキストの両側に5つのダッシュ（ - 、0x2d）に囲まれた適切なヘッダーラインテキストで構成されています。ヘッダーラインのテキストは、アーマーでエンコードされているデータのタイプとエンコードの方法に基づいて選択されます。ヘッダーラインテキストには、次の文字列が含まれます。"
    },
    {
      "indent": 4,
      "text": "+===================+============================================+\n| Armor Header      | Use                                        |\n+===================+============================================+\n| BEGIN PGP MESSAGE | Used for signed, encrypted, or compressed  |\n|                   | files.                                     |\n+-------------------+--------------------------------------------+\n| BEGIN PGP PUBLIC  | Used for armoring public keys.             |\n| KEY BLOCK         |                                            |\n+-------------------+--------------------------------------------+\n| BEGIN PGP PRIVATE | Used for armoring private keys.            |\n| KEY BLOCK         |                                            |\n+-------------------+--------------------------------------------+\n| BEGIN PGP         | Used for detached signatures, OpenPGP/MIME |\n| SIGNATURE         | signatures, and cleartext signatures.      |\n+-------------------+--------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 16: OpenPGP Armor Header Lines Registry",
      "ja": "表16：OpenPGPアーマーヘッダーラインレジストリ"
    },
    {
      "indent": 3,
      "text": "Note that all of these Armor Header Lines are to consist of a complete line. Therefore, the header lines MUST start at the beginning of a line and MUST NOT have text other than whitespace following them on the same line.",
      "ja": "これらのアーマーヘッダーラインはすべて、完全なラインで構成されることに注意してください。したがって、ヘッダーラインは行の先頭から開始する必要があり、同じ行でそれらをフォローする空白以外のテキストを持たないでください。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Armor Headers",
      "section_title": true,
      "ja": "6.2.2. アーマーヘッダー"
    },
    {
      "indent": 3,
      "text": "The Armor Headers are pairs of strings that can give the user or the receiving OpenPGP implementation some information about how to decode or use the message. The Armor Headers are a part of the armor, not the message, and hence are not protected by any signatures applied to the message.",
      "ja": "アーマーヘッダーは、ユーザーまたは受信しているOpenPGP実装にメッセージをデコードまたは使用する方法に関する情報を提供できる文字列のペアです。アーマーヘッダーはメッセージではなく鎧の一部であるため、メッセージに適用される署名によって保護されていません。"
    },
    {
      "indent": 3,
      "text": "The format of an Armor Header is that of a key-value pair. A colon (: 0x3A) and a single space (0x20) separate the key and value. An OpenPGP implementation may consider improperly formatted Armor Headers to be a corruption of the ASCII Armor, but it SHOULD make an effort to recover. Unknown keys should be silently ignored, and an OpenPGP implementation SHOULD continue to process the message.",
      "ja": "アーマーヘッダーの形式は、キー価値ペアの形式です。コロン（：0x3a）と単一のスペース（0x20）がキーと値を分離します。OpenPGPの実装では、不適切にフォーマットされたアーマーヘッダーがASCIIアーマーの腐敗であると考える場合がありますが、回復する努力をするはずです。未知のキーは静かに無視する必要があり、OpenPGPの実装はメッセージの処理を続ける必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that some transport methods are sensitive to line length. For example, the SMTP protocol that transports email messages has a line length limit of 998 characters (see Section 2.1.1 of [RFC5322]).",
      "ja": "一部の輸送方法は、ラインの長さに敏感であることに注意してください。たとえば、電子メールメッセージを輸送するSMTPプロトコルのライン長い制限は998文字です（[RFC5322]のセクション2.1.1を参照）。"
    },
    {
      "indent": 3,
      "text": "While there is a limit of 76 characters for the base64 data (Section 6), there is no limit for the length of Armor Headers. Care should be taken to ensure that the Armor Headers are short enough to survive transport. One way to do this is to repeat an Armor Header Key multiple times with different values for each so that no one line is overly long.",
      "ja": "Base64データ（セクション6）には76文字の制限がありますが、鎧ヘッダーの長さに制限はありません。鎧のヘッダーが輸送を生き残るのに十分な短いことを保証するように注意する必要があります。これを行う1つの方法は、1つのラインが過度に長くないように、それぞれに異なる値で複数回アーマーヘッダーキーを繰り返すことです。"
    },
    {
      "indent": 3,
      "text": "Currently defined Armor Header Keys are as follows:",
      "ja": "現在定義されているアーマーヘッダーキーは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "+=========+==============================+=================+\n| Key     | Summary                      | Reference       |\n+=========+==============================+=================+\n| Version | Implementation information   | Section 6.2.2.1 |\n+---------+------------------------------+-----------------+\n| Comment | Arbitrary text               | Section 6.2.2.2 |\n+---------+------------------------------+-----------------+\n| Hash    | Hash algorithms used in some | Section 6.2.2.3 |\n|         | v4 cleartext signed messages |                 |\n+---------+------------------------------+-----------------+\n| Charset | Character set                | Section 6.2.2.4 |\n+---------+------------------------------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Table 17: OpenPGP Armor Header Keys Registry",
      "ja": "表17：OpenPGPアーマーヘッダーキーレジストリ"
    },
    {
      "indent": 0,
      "text": "6.2.2.1. \"Version\" Armor Header",
      "section_title": true,
      "ja": "6.2.2.1. 「バージョン」アーマーヘッダー"
    },
    {
      "indent": 3,
      "text": "The Armor Header Key Version describes the OpenPGP implementation and version used to encode the message. To minimize metadata, implementations SHOULD NOT emit this key and its corresponding value except for debugging purposes with explicit user consent.",
      "ja": "Armor Headerキーバージョンは、メッセージのエンコードに使用されるOpenPGPの実装とバージョンについて説明します。メタデータを最小限に抑えるために、実装は、明示的なユーザー同意を伴うデバッグ目的を除いて、このキーとその対応する値を発してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.2.2. \"Comment\" Armor Header",
      "section_title": true,
      "ja": "6.2.2.2. 「コメント」アーマーヘッダー"
    },
    {
      "indent": 3,
      "text": "The Armor Header Key Comment supplies a user-defined comment. OpenPGP defines all text to be in UTF-8. A comment may be any UTF-8 string. However, the whole point of armoring is to provide 7-bit clean data. Consequently, if a comment has characters that are outside the ASCII range of UTF-8, they may very well not survive transport.",
      "ja": "Armor Header Keyコメントは、ユーザー定義のコメントを提供します。OpenPGPは、すべてのテキストをUTF-8に定義します。コメントは、任意のUTF-8文字列である場合があります。ただし、装甲の全体的なポイントは、7ビットのクリーンデータを提供することです。その結果、コメントにUTF-8のASCII範囲の外側にある文字がある場合、それらは輸送に耐えられない可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.2.2.3. \"Hash\" Armor Header",
      "section_title": true,
      "ja": "6.2.2.3. 「ハッシュ」アーマーヘッダー"
    },
    {
      "indent": 3,
      "text": "The Armor Header Key Hash is deprecated, but some older implementations expect it in messages using the Cleartext Signature Framework (Section 7). When present, this Armor Header Key contains a comma-separated list of hash algorithms used in the signatures on message, with digest names as specified in the \"Text Name\" column in Table 23. These headers SHOULD NOT be emitted unless:",
      "ja": "アーマーヘッダーキーハッシュは非推奨ですが、一部の古い実装は、ClearText署名フレームワーク（セクション7）を使用したメッセージでそれを期待しています。存在する場合、このアーマーヘッダーキーには、メッセージの署名で使用されるハッシュアルゴリズムのコンマ区切りリストが含まれています。表23の「テキスト名」列で指定されているダイジェスト名が含まれています。"
    },
    {
      "indent": 6,
      "text": "* the cleartext signed message contains a version 4 signature made using a SHA2-based digest (SHA224, SHA256, SHA384, or SHA512), and",
      "ja": "* ClearText署名されたメッセージには、SHA2ベースのダイジェスト（SHA224、SHA256、SHA384、またはSHA512）を使用して作成されたバージョン4の署名が含まれています。"
    },
    {
      "indent": 6,
      "text": "* the cleartext signed message might be verified by a legacy OpenPGP implementation that requires this header.",
      "ja": "* ClearText署名されたメッセージは、このヘッダーを必要とするレガシーOpenPGP実装によって検証される場合があります。"
    },
    {
      "indent": 3,
      "text": "A verifying application MUST decline to validate any signature in a message with a non-conformant Hash header (that is, a Hash header that contains anything other than a comma-separated list of hash algorithms). When a conformant Hash header is present, a verifying application MUST ignore its contents, deferring to the hash algorithm indicated in the Embedded Signature.",
      "ja": "検証アプリケーションは、非変理剤ハッシュヘッダー（つまり、ハッシュアルゴリズムのコンマ分離リスト以外のものを含むハッシュヘッダー）を使用してメッセージ内の署名を検証することを拒否する必要があります。コンフォーマントハッシュヘッダーが存在する場合、検証アプリケーションはその内容を無視する必要があり、埋め込まれた署名に示されているハッシュアルゴリズムに繰り返します。"
    },
    {
      "indent": 0,
      "text": "6.2.2.4. \"Charset\" Armor Header",
      "section_title": true,
      "ja": "6.2.2.4. 「チャーセット」アーマーヘッダー"
    },
    {
      "indent": 3,
      "text": "The Armor Header Key Charset contains a description of the character set that the plaintext is in (see [RFC2978]). Please note that OpenPGP defines text to be in UTF-8. An implementation will get the best results by translating into and out of UTF-8. However, there are many instances where this is easier said than done. Also, there are communities of users who have no need for UTF-8 because they are all happy with a character set like ISO Latin-5 or a Japanese character set. In such instances, an implementation MAY override the UTF-8 default by using this header key. An implementation MAY implement this key and any translations it cares to; an implementation MAY ignore it and assume all text is UTF-8.",
      "ja": "アーマーヘッダーキーチャーセットには、プレーンテキストがある文字セットの説明が含まれています（[RFC2978]を参照）。OpenPGPは、テキストがUTF-8にあると定義することに注意してください。実装は、UTF-8に翻訳して出入りすることにより、最良の結果を得ることができます。ただし、これが言うよりも簡単な多くの例があります。また、UTF-8を必要としないユーザーのコミュニティがあります。なぜなら、彼らはすべて、ISOラテン-5や日本のキャラクターセットなどのキャラクターセットに満足しているからです。そのような場合、このヘッダーキーを使用して、実装がUTF-8のデフォルトをオーバーライドする場合があります。実装は、このキーとそれが気にする翻訳を実装する場合があります。実装はそれを無視し、すべてのテキストがUTF-8であると仮定する場合があります。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Armor Tail Line",
      "section_title": true,
      "ja": "6.2.3. アーマーテールライン"
    },
    {
      "indent": 3,
      "text": "The Armor Tail Line is composed in the same manner as the Armor Header Line, except the string \"BEGIN\" is replaced by the string \"END\".",
      "ja": "鎧のテールラインは、弦のヘッダーラインと同じ方法で構成されています。ただし、文字列「begin」が文字列「端」に置き換えられます。"
    },
    {
      "indent": 0,
      "text": "7. Cleartext Signature Framework",
      "section_title": true,
      "ja": "7. ClearText署名フレームワーク"
    },
    {
      "indent": 3,
      "text": "It is desirable to be able to sign a textual octet stream without ASCII armoring the stream itself, so the signed text is still readable with any tool capable of rendering text. In order to bind a signature to such a cleartext, the Cleartext Signature Framework is used, which follows the same basic format and restrictions as the ASCII armoring described in Section 6.2. (Note that this framework is not intended to be reversible. [RFC3156] defines another way to sign cleartext messages for environments that support MIME.)",
      "ja": "ASCIIがストリーム自体を装甲することなくテキストのオクテットストリームに署名できることが望ましいので、署名されたテキストは、テキストをレンダリングできるツールでまだ読みやすくなります。このようなクリアテキストに署名をバインドするために、ClearText署名フレームワークが使用されます。これは、セクション6.2で説明したASCII装甲と同じ基本形式と制限に従います。（このフレームワークは、可逆的であることを意図していないことに注意してください。[RFC3156]は、MIMEをサポートする環境のクリアテキストメッセージに署名する別の方法を定義します。）"
    },
    {
      "indent": 0,
      "text": "7.1. Cleartext Signed Message Structure",
      "section_title": true,
      "ja": "7.1. ClearText署名されたメッセージ構造"
    },
    {
      "indent": 3,
      "text": "An OpenPGP cleartext signed message consists of:",
      "ja": "OpenPGP ClearText署名されたメッセージは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* The cleartext header -----BEGIN PGP SIGNED MESSAGE----- on a single line.",
      "ja": "* ClearTextヘッダー----- PGP署名されたメッセージを開始します-----単一行で。"
    },
    {
      "indent": 6,
      "text": "* One or more legacy Hash Armor Headers that MAY be included by some implementations and MUST be ignored when well formed (see Section 6.2.2.3).",
      "ja": "* いくつかの実装に含まれる可能性のある1つまたは複数のレガシーハッシュアーマーヘッダー。適切に形成された場合は無視する必要があります（セクション6.2.2.3を参照）。"
    },
    {
      "indent": 6,
      "text": "* An empty line (not included in the message digest).",
      "ja": "* 空の行（メッセージダイジェストには含まれていません）。"
    },
    {
      "indent": 6,
      "text": "* The dash-escaped cleartext.",
      "ja": "* ダッシュエスケープのクリアテキスト。"
    },
    {
      "indent": 6,
      "text": "* A line ending separating the cleartext and following armored signature (not included in the message digest).",
      "ja": "* クリアテキストを分離し、次の装甲署名（メッセージダイジェストに含まれていない）を終了するライン。"
    },
    {
      "indent": 6,
      "text": "* The ASCII-armored signature(s), including the -----BEGIN PGP SIGNATURE----- Armor Header and Armor Tail Lines.",
      "ja": "* Ascii-armoredの署名------開始PGP署名------アーマーヘッダーとアーマーテールラインを含む。"
    },
    {
      "indent": 3,
      "text": "As with any other Text signature (Section 5.2.1.2), a cleartext signature is calculated on the text using canonical <CR><LF> line endings. As described above, the line ending before the -----BEGIN PGP SIGNATURE----- Armor Header Line of the armored signature is not considered part of the signed text.",
      "ja": "他のテキスト署名（セクション5.2.1.2）と同様に、Canonical <cr> <lf>行のエンディングを使用して、テキストでクリアテキスト署名が計算されます。上記のように、-----開始PGP署名の前に終わる行-----装甲署名の鎧ヘッダーラインは、署名されたテキストの一部とは見なされません。"
    },
    {
      "indent": 3,
      "text": "Also, any trailing whitespace -- spaces (0x20) and tabs (0x09) -- at the end of any line is removed before signing or verifying a cleartext signed message.",
      "ja": "また、任意のラインの最後に、任意のラインの最後に、片側の空間（0x20）とタブ（0x09）が削除される前に、クリアテキストの署名されたメッセージの検証が削除されます。"
    },
    {
      "indent": 3,
      "text": "Between the -----BEGIN PGP SIGNED MESSAGE----- line and the first empty line, the only Armor Header permitted is a well-formed Hash Armor Header (see Section 6.2.2.3). To reduce the risk of confusion about what has been signed, a verifying implementation MUST decline to validate any signature in a cleartext message if that message has any other Armor Header present in this location.",
      "ja": "-----開始PGP署名されたメッセージ-----ラインと最初の空の行の間で、許可されている唯一の鎧ヘッダーは、よく形成されたハッシュアーマーヘッダーです（セクション6.2.2.3を参照）。署名されたものに関する混乱のリスクを減らすために、検証する実装は、この場所に他のアーマーヘッダーが存在する場合、クリアテキストメッセージの署名を検証するために拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2. Dash-Escaped Text",
      "section_title": true,
      "ja": "7.2. ダッシュエスケープテキスト"
    },
    {
      "indent": 3,
      "text": "The cleartext content of the message must also be dash-escaped.",
      "ja": "メッセージのClearTextコンテンツもDash-Escapedでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Dash-escaped cleartext is the ordinary cleartext where every line starting with a \"-\" (HYPHEN-MINUS, U+002D) is prefixed by the sequence \"-\" (HYPHEN-MINUS, U+002D) and \" \" (SPACE, U+0020). This prevents the parser from recognizing Armor Headers of the cleartext itself. An implementation MAY dash-escape any line, SHOULD dash-escape lines commencing in \"From\" followed by a space, and MUST dash-escape any line commencing in a dash. The message digest is computed using the cleartext itself, not the dash-escaped form.",
      "ja": "Dash-Escaped ClearTextは、「 - 」（Hyphen-Minus、U+002d）で始まるすべての行がシーケンス「 - 」（Hyphen-Minus、U+002d）と \"（Space、U）で前に付けられている通常のクリアテキストです。+0020）。これにより、パーサーがクリアテキスト自体の鎧ヘッダーを認識できなくなります。実装では、「from」で開始されたラインをダッシュエスケープ行で、任意のラインを破る場合があり、ダッシュで開始されるラインをダッシュエスケープする必要があります。メッセージダイジェストは、ダッシュエスケープフォームではなく、クリアテキスト自体を使用して計算されます。"
    },
    {
      "indent": 3,
      "text": "When reversing dash-escaping, an implementation MUST strip the string - if it occurs at the beginning of a line, and it SHOULD provide a warning for - and any character other than a space at the beginning of a line.",
      "ja": "ダッシュエスケープを逆転させるとき、実装は、文字列を除去する必要があります - それが行の先頭に発生した場合、そしてそれは警告を提供する必要があります - および行の先頭にあるスペース以外のキャラクター。"
    },
    {
      "indent": 0,
      "text": "7.3. Issues with the Cleartext Signature Framework",
      "section_title": true,
      "ja": "7.3. ClearText署名フレームワークの問題"
    },
    {
      "indent": 3,
      "text": "Since creating a cleartext signed message involves trimming trailing whitespace on every line, the Cleartext Signature Framework will fail to safely round-trip any textual stream that may include semantically meaningful whitespace.",
      "ja": "ClearText署名付きメッセージを作成するには、すべての行でトレーリングホワイトスペースをトリミングすることが含まれているため、ClearTextの署名フレームワークは、意味的に意味のある白文学を含む可能性のあるテキストストリームを安全に往復させることができません。"
    },
    {
      "indent": 3,
      "text": "For example, the Unified Diff format [UNIFIED-DIFF] contains semantically meaningful whitespace: an empty line of context will consist of a line with a single \" \" (SPACE, U+0020) character, and any line that has trailing whitespace added or removed will represent such a change with semantically meaningful whitespace.",
      "ja": "たとえば、Unified Diffフォーマット[Unified-diff]には、意味的に意味のある白文字が含まれています。空のコンテキストは、単一の「」（Space、U+0020）文字を持つ線で構成されます。削除されたものは、意味的に意味のある空白によるこのような変化を表します。"
    },
    {
      "indent": 3,
      "text": "Furthermore, a Cleartext Signature Framework message that is very large is unlikely to work well. In particular, it will be difficult for any human reading the message to know which part is covered by the signature because they can't understand the whole message at once, especially in the case where an Armor Header line is placed somewhere in the body. And, very large Cleartext Signature Framework messages cannot be processed in a single pass, since the signature salt and digest algorithms are only discovered at the end.",
      "ja": "さらに、非常に大きいClearText Signature Frameworkメッセージは、うまく機能する可能性は低いです。特に、人間がメッセージを読んで、どの部分が署名でカバーされているかを知ることは困難です。特に、鎧ヘッダーラインが体内のどこかに配置されている場合には、メッセージ全体を一度に理解できないためです。また、非常に大きなClearText署名フレームワークメッセージは、署名の塩および消化アルゴリズムが最後にのみ発見されるため、単一のパスで処理することはできません。"
    },
    {
      "indent": 3,
      "text": "An implementation that knows it is working with a textual stream with any of the above characteristics SHOULD NOT use the Cleartext Signature Framework. Safe alternatives for a semantically meaningful OpenPGP signature over such a file format are:",
      "ja": "上記の特性のいずれかを備えたテキストストリームで動作していることを知っている実装は、ClearText署名フレームワークを使用してはなりません。このようなファイル形式に対する意味的に意味のあるOpenPGP署名の安全な代替は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A signed message, as described in Section 10.3.",
      "ja": "* セクション10.3で説明されているように、署名されたメッセージ。"
    },
    {
      "indent": 6,
      "text": "* A detached signature, as described in Section 10.4.",
      "ja": "* セクション10.4で説明されているように、分離された署名。"
    },
    {
      "indent": 3,
      "text": "Either of these alternatives may be ASCII-armored (see Section 6.2) if they need to be transmitted across a text-only (or 7-bit clean) channel.",
      "ja": "これらの代替案のいずれかが、テキストのみ（または7ビットクリーン）チャネルを介して送信する必要がある場合は、Ascii-armord（セクション6.2を参照）にすることができます。"
    },
    {
      "indent": 3,
      "text": "Finally, when a Cleartext Signature Framework message is presented to the user as is, an attacker can include additional text in the Hash header, which may mislead the user into thinking it is part of the signed text. The signature validation constraints described in Sections 6.2.2.3 and 7.1 help to mitigate the risk of arbitrary or misleading text in the Armor Headers.",
      "ja": "最後に、ClearText Signature Frameworkメッセージがユーザーに表示されると、攻撃者はハッシュヘッダーに追加のテキストを含めることができます。セクション6.2.2.3および7.1で説明されている署名検証の制約は、アーマーヘッダーのarbitrary意的または誤解を招くテキストのリスクを軽減するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "8. Regular Expressions",
      "section_title": true,
      "ja": "8. 正規表現"
    },
    {
      "indent": 3,
      "text": "This section describes Regular Expressions.",
      "ja": "このセクションでは、正規表現について説明します。"
    },
    {
      "indent": 3,
      "text": "Regular Expression:",
      "ja": "正規表現："
    },
    {
      "indent": 12,
      "text": "Zero or more branches, separated by |. It matches anything that matches one of the branches.",
      "ja": "ゼロ以上の枝、|で区切られています。ブランチの1つに一致するものはすべて一致します。"
    },
    {
      "indent": 3,
      "text": "Branch:",
      "ja": "支店："
    },
    {
      "indent": 12,
      "text": "Zero or more pieces, concatenated. It matches a match for the first, followed by a match for the second, etc.",
      "ja": "ゼロ以上の部分、連結。1枚目の試合にマッチし、2番目の試合などが続きます。"
    },
    {
      "indent": 3,
      "text": "Piece:",
      "ja": "ピース："
    },
    {
      "indent": 12,
      "text": "An atom possibly followed by *, +, or ?. An atom followed by * matches a sequence of 0 or more matches of the atom. An atom followed by + matches a sequence of 1 or more matches of the atom. An atom followed by ? matches a match of the atom or the null string.",
      "ja": "おそらく *、 +、または？それに続く原子 *は、原子の0以上の一致のシーケンスと一致します。それに続く原子は、原子の1つ以上の一致のシーケンスと一致します。それに続く原子？原子またはヌル文字列の一致を一致させます。"
    },
    {
      "indent": 3,
      "text": "Atom:",
      "ja": "原子："
    },
    {
      "indent": 12,
      "text": "A Regular Expression in parentheses (matching a match for the Regular Expression), a range (see below), a . (matching any single Unicode character), a ^ (matching the null string at the beginning of the input string), a $ (matching the null string at the end of the input string), a \\ followed by a single Unicode character (matching that character), or a single Unicode character with no other significance (matching that character).",
      "ja": "括弧内の正規表現（正規表現の一致を一致させる）、範囲（以下を参照）、a。（単一のユニコード文字を一致）、a ^（入力文字列の先頭にあるヌル文字列を一致）、$（入力文字列の端にあるヌル文字列を一致させる）、\\に続いて単一のユニコード文字（一致するそのキャラクター）、または他の重要性のない単一のユニコード文字（そのキャラクターに一致します）。"
    },
    {
      "indent": 3,
      "text": "Range:",
      "ja": "範囲："
    },
    {
      "indent": 12,
      "text": "A sequence of characters enclosed in []. It normally matches any single character from the sequence. If the sequence begins with ^, it matches any single Unicode character not from the rest of the sequence. If two characters in the sequence are separated by -, this is shorthand for the full list of Unicode characters between them in codepoint order (for example, [0-9] matches any decimal digit). To include a literal ] in the sequence, make it the first character (following a possible ^). To include a literal -, make it the first or last character.",
      "ja": "[]に囲まれた一連の文字。通常、シーケンスの単一文字と一致します。シーケンスが ^で始まる場合、シーケンスの残りの部分からではなく、単一のユニコード文字と一致します。シーケンス内の2つの文字が分離されている場合 - これは、コードポイント順序でユニコード文字の完全なリストの速記です（たとえば、[0-9]は任意の10進数と一致します）。リテラルを順番に含めるには、最初のキャラクターにします（可能な ^に続いて）。リテラルを含めるには、最初のキャラクターまたは最後のキャラクターにします。"
    },
    {
      "indent": 0,
      "text": "9. Constants",
      "section_title": true,
      "ja": "9. 定数"
    },
    {
      "indent": 3,
      "text": "This section describes the constants used in OpenPGP.",
      "ja": "このセクションでは、OpenPGPで使用される定数について説明します。"
    },
    {
      "indent": 3,
      "text": "Note that these tables are not exhaustive lists; an implementation MAY implement an algorithm that is not on these lists, as long as the algorithm IDs are chosen from the Private or Experimental Use algorithm range.",
      "ja": "これらのテーブルは網羅的なリストではないことに注意してください。実装は、アルゴリズムIDがプライベートまたは実験的使用アルゴリズムの範囲から選択されている限り、これらのリストにないアルゴリズムを実装する場合があります。"
    },
    {
      "indent": 3,
      "text": "See Section 12 for more discussion of the algorithms.",
      "ja": "アルゴリズムの詳細については、セクション12を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. Public Key Algorithms",
      "section_title": true,
      "ja": "9.1. 公開鍵アルゴリズム"
    },
    {
      "indent": 3,
      "text": "+===+==============+=========+============+===========+=============+\n| ID| Algorithm    |Public   | Secret Key | Signature | PKESK       |\n|   |              |Key      | Format     | Format    | Format      |\n|   |              |Format   |            |           |             |\n+===+==============+=========+============+===========+=============+\n|  0| Reserved     |         |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+\n|  1| RSA (Encrypt |MPI(n),  | MPI(d),    | MPI(m^d   | MPI(m^e     |\n|   | or Sign)     |MPI(e)   | MPI(p),    | mod n)    | mod n)      |\n|   | [FIPS186]    |[Section | MPI(q),    | [Section  | [Section    |\n|   |              |5.5.5.1] | MPI(u)     | 5.2.3.1]  | 5.1.3]      |\n+---+--------------+---------+------------+-----------+-------------+\n|  2| RSA Encrypt- |MPI(n),  | MPI(d),    | N/A       | MPI(m^e     |\n|   | Only         |MPI(e)   | MPI(p),    |           | mod n)      |\n|   | [FIPS186]    |[Section | MPI(q),    |           | [Section    |\n|   |              |5.5.5.1] | MPI(u)     |           | 5.1.3]      |\n+---+--------------+---------+------------+-----------+-------------+\n|  3| RSA Sign-    |MPI(n),  | MPI(d),    | MPI(m^d   | N/A         |\n|   | Only         |MPI(e)   | MPI(p),    | mod n)    |             |\n|   | [FIPS186]    |[Section | MPI(q),    | [Section  |             |\n|   |              |5.5.5.1] | MPI(u)     | 5.2.3.1]  |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 16| Elgamal      |MPI(p),  | MPI(x)     | N/A       | MPI(g^k     |\n|   | (Encrypt-    |MPI(g),  |            |           | mod p),     |\n|   | Only)        |MPI(y)   |            |           | MPI(m *     |\n|   | [ELGAMAL]    |[Section |            |           | y^k mod     |\n|   |              |5.5.5.3] |            |           | p)          |\n|   |              |         |            |           | [Section    |\n|   |              |         |            |           | 5.1.4]      |\n+---+--------------+---------+------------+-----------+-------------+\n| 17| DSA (Digital |MPI(p),  | MPI(x)     | MPI(r),   | N/A         |\n|   | Signature    |MPI(q),  |            | MPI(s)    |             |\n|   | Algorithm)   |MPI(g),  |            | [Section  |             |\n|   | [FIPS186]    |MPI(y)   |            | 5.2.3.2]  |             |\n|   |              |[Section |            |           |             |\n|   |              |5.5.5.2] |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 18| ECDH public  |OID,     | MPI(value  | N/A       | MPI(point   |\n|   | key          |MPI(point| in curve-  |           | in curve-   |\n|   | algorithm    |in curve-| specific   |           | specific    |\n|   |              |specific | format)    |           | point       |\n|   |              |point    | [Section   |           | format),    |\n|   |              |format), | 9.2.1]     |           | size        |\n|   |              |KDFParams|            |           | octet,      |\n|   |              |[Sections|            |           | encoded     |\n|   |              |9.2.1 and|            |           | key         |\n|   |              |5.5.5.6] |            |           | [Sections   |\n|   |              |         |            |           | 9.2.1,      |\n|   |              |         |            |           | 5.1.5,      |\n|   |              |         |            |           | and 11.5]   |\n+---+--------------+---------+------------+-----------+-------------+\n| 19| ECDSA public |OID,     | MPI(value) | MPI(r),   | N/A         |\n|   | key          |MPI(point|            | MPI(s)    |             |\n|   | algorithm    |in SEC1  |            | [Section  |             |\n|   | [FIPS186]    |format)  |            | 5.2.3.2]  |             |\n|   |              |[Section |            |           |             |\n|   |              |5.5.5.4] |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 20| Reserved     |         |            |           |             |\n|   | (formerly    |         |            |           |             |\n|   | Elgamal      |         |            |           |             |\n|   | Encrypt or   |         |            |           |             |\n|   | Sign)        |         |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 21| Reserved for |         |            |           |             |\n|   | Diffie-      |         |            |           |             |\n|   | Hellman      |         |            |           |             |\n|   | (X9.42, as   |         |            |           |             |\n|   | defined for  |         |            |           |             |\n|   | IETF-S/MIME) |         |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 22| EdDSALegacy  |OID,     | MPI(value  | MPI, MPI  | N/A         |\n|   | (deprecated) |MPI(point| in curve-  | [Sections |             |\n|   |              |in       | specific   | 9.2.1 and |             |\n|   |              |prefixed | format)    | 5.2.3.3]  |             |\n|   |              |native   | [Section   |           |             |\n|   |              |format)  | 9.2.1]     |           |             |\n|   |              |[Sections|            |           |             |\n|   |              |11.2.2   |            |           |             |\n|   |              |and      |            |           |             |\n|   |              |5.5.5.5] |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 23| Reserved     |         |            |           |             |\n|   | (AEDH)       |         |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 24| Reserved     |         |            |           |             |\n|   | (AEDSA)      |         |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 25| X25519       |32 octets| 32 octets  | N/A       | 32          |\n|   |              |[Section |            |           | octets,     |\n|   |              |5.5.5.7] |            |           | size        |\n|   |              |         |            |           | octet,      |\n|   |              |         |            |           | encoded     |\n|   |              |         |            |           | key         |\n|   |              |         |            |           | [Section    |\n|   |              |         |            |           | 5.1.6]      |\n+---+--------------+---------+------------+-----------+-------------+\n| 26| X448         |56 octets| 56 octets  | N/A       | 56          |\n|   |              |[Section |            |           | octets,     |\n|   |              |5.5.5.8] |            |           | size        |\n|   |              |         |            |           | octet,      |\n|   |              |         |            |           | encoded     |\n|   |              |         |            |           | key         |\n|   |              |         |            |           | [Section    |\n|   |              |         |            |           | 5.1.7]      |\n+---+--------------+---------+------------+-----------+-------------+\n| 27| Ed25519      |32 octets| 32 octets  | 64 octets |             |\n|   |              |[Section |            | [Section  |             |\n|   |              |5.5.5.9] |            | 5.2.3.4]  |             |\n+---+--------------+---------+------------+-----------+-------------+\n| 28| Ed448        |57 octets| 57 octets  | 114       |             |\n|   |              |[Section |            | octets    |             |\n|   |              |5.5.5.10]|            | [Section  |             |\n|   |              |         |            | 5.2.3.5]  |             |\n+---+--------------+---------+------------+-----------+-------------+\n|100| Private or   |         |            |           |             |\n| to| Experimental |         |            |           |             |\n|110| Use          |         |            |           |             |\n+---+--------------+---------+------------+-----------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 18: OpenPGP Public Key Algorithms Registry",
      "ja": "表18：openPGP公開キーアルゴリズムレジストリ"
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement Ed25519 (27) for signatures and X25519 (25) for encryption. Implementations SHOULD implement Ed448 (28) and X448 (26).",
      "ja": "実装は、署名の場合はED25519（27）、暗号化にはx25519（25）を実装する必要があります。実装では、ED448（28）およびX448（26）を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "RSA (1) keys are deprecated and SHOULD NOT be generated but may be interpreted. RSA Encrypt-Only (2) and RSA Sign-Only (3) are deprecated and MUST NOT be generated (see Section 12.4). Elgamal (16) keys are deprecated and MUST NOT be generated (see Section 12.6). DSA (17) keys are deprecated and MUST NOT be generated (see Section 12.5). For notes on Elgamal Encrypt or Sign (20) and X9.42 (21), see Section 12.8. Implementations MAY implement any other algorithm.",
      "ja": "RSA（1）キーは非推奨であり、生成されるべきではありませんが、解釈される場合があります。RSA暗号化のみ（2）およびRSAサインのみ（3）は非推奨であり、生成してはなりません（セクション12.4を参照）。エルガマル（16）キーは非推奨であり、生成してはなりません（セクション12.6を参照）。DSA（17）キーは非推奨であり、生成してはなりません（セクション12.5を参照）。エルガマルの暗号化または署名（20）およびx9.42（21）に関するメモについては、セクション12.8を参照してください。実装は、他のアルゴリズムを実装する場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that an implementation conforming to the previous version of this specification [RFC4880] has only DSA (17) and Elgamal (16) as the algorithms that MUST be implemented.",
      "ja": "この仕様[RFC4880]の以前のバージョンに準拠した実装には、実装する必要があるアルゴリズムとしてのDSA（17）とElgamal（16）のみがあることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A compatible specification of ECDSA is given in [RFC6090] (as \"KT-I Signatures\") and in [SEC1]; ECDH is defined in Section 11.5 of this document.",
      "ja": "ECDSAの互換性のある仕様は、[rfc6090]（「kt-i signatures」として）および[sec1]に与えられます。ECDHは、このドキュメントのセクション11.5で定義されています。"
    },
    {
      "indent": 0,
      "text": "9.2. ECC Curves for OpenPGP",
      "section_title": true,
      "ja": "9.2. OpenPGPのECC曲線"
    },
    {
      "indent": 3,
      "text": "The parameter curve OID is an array of octets that defines a named curve.",
      "ja": "パラメーター曲線oidは、名前付き曲線を定義するオクテットの配列です。"
    },
    {
      "indent": 3,
      "text": "The table below specifies the exact sequence of octets for each named curve referenced in this document. It also specifies which public key algorithms the curve can be used with, as well as the size of expected elements in octets. Note that there is a break in \"EdDSALegacy\" for display purposes only.",
      "ja": "以下の表は、このドキュメントで参照されている各名前の曲線のオクテットの正確なシーケンスを指定します。また、曲線を使用できる公開キーアルゴリズムと、オクテットの予想される要素のサイズも指定します。ディスプレイ目的でのみ「eddsalegacy」が破損していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "+======================+===+========+================+======+=======+\n|ASN.1 Object          |OID| Curve  |Curve Name      |Usage |Field  |\n|Identifier            |Len| OID    |                |      |Size   |\n|                      |   | Octets |                |      |(fsize)|\n+======================+===+========+================+======+=======+\n|1.2.840.10045.3.1.7   |8  | 2A 86  |NIST P-256      |ECDSA,|32     |\n|                      |   | 48 CE  |                |ECDH  |       |\n|                      |   | 3D 03  |                |      |       |\n|                      |   | 01 07  |                |      |       |\n+----------------------+---+--------+----------------+------+-------+\n|1.3.132.0.34          |5  | 2B 81  |NIST P-384      |ECDSA,|48     |\n|                      |   | 04 00  |                |ECDH  |       |\n|                      |   | 22     |                |      |       |\n+----------------------+---+--------+----------------+------+-------+\n|1.3.132.0.35          |5  | 2B 81  |NIST P-521      |ECDSA,|66     |\n|                      |   | 04 00  |                |ECDH  |       |\n|                      |   | 23     |                |      |       |\n+----------------------+---+--------+----------------+------+-------+\n|1.3.36.3.3.2.8.1.1.7  |9  | 2B 24  |brainpoolP256r1 |ECDSA,|32     |\n|                      |   | 03 03  |                |ECDH  |       |\n|                      |   | 02 08  |                |      |       |\n|                      |   | 01 01  |                |      |       |\n|                      |   | 07     |                |      |       |\n+----------------------+---+--------+----------------+------+-------+\n|1.3.36.3.3.2.8.1.1.11 |9  | 2B 24  |brainpoolP384r1 |ECDSA,|48     |\n|                      |   | 03 03  |                |ECDH  |       |\n|                      |   | 02 08  |                |      |       |\n|                      |   | 01 01  |                |      |       |\n|                      |   | 0B     |                |      |       |\n+----------------------+---+--------+----------------+------+-------+\n|1.3.36.3.3.2.8.1.1.13 |9  | 2B 24  |brainpoolP512r1 |ECDSA,|64     |\n|                      |   | 03 03  |                |ECDH  |       |\n|                      |   | 02 08  |                |      |       |\n|                      |   | 01 01  |                |      |       |\n|                      |   | 0D     |                |      |       |\n+----------------------+---+--------+----------------+------+-------+\n|1.3.6.1.4.1.11591.15.1|9  | 2B 06  |Ed25519Legacy   |EdDSA |32     |\n|                      |   | 01 04  |                |Legacy|       |\n|                      |   | 01 DA  |                |      |       |\n|                      |   | 47 0F  |                |      |       |\n|                      |   | 01     |                |      |       |\n+----------------------+---+--------+----------------+------+-------+\n|1.3.6.1.4.1.3029.1.5.1|10 | 2B 06  |Curve25519Legacy|ECDH  |32     |\n|                      |   | 01 04  |                |      |       |\n|                      |   | 01 97  |                |      |       |\n|                      |   | 55 01  |                |      |       |\n|                      |   | 05 01  |                |      |       |\n+----------------------+---+--------+----------------+------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Table 19: OpenPGP ECC Curve OIDs and Usage Registry",
      "ja": "表19：OpenPGP ECC Curve OIDおよび使用レジストリ"
    },
    {
      "indent": 3,
      "text": "The \"Field Size (fsize)\" column represents the field size of the group in number of octets, rounded up, such that x or y coordinates for a point on the curve or native point representations for the curve can be represented in that many octets. The curves specified here, and scalars such as the base point order and the private key, can be represented in fsize octets. However, note that curves exist outside this specification where the representation of scalars requires an additional octet.",
      "ja": "「フィールドサイズ（fsize）」列は、丸められたオクテット数のグループのフィールドサイズを表します。これにより、曲線上のポイントまたはyが曲線のネイティブポイント表現のxまたはy座標は、多くのオクテットで表現できます。。ここで指定された曲線、およびベースポイント順序や秘密鍵などのスカラーは、FSIZEオクテットで表現できます。ただし、スカラーの表現には追加のオクテットが必要なこの仕様の外側に曲線が存在することに注意してください。"
    },
    {
      "indent": 3,
      "text": "The sequence of octets in the third column is the result of applying the Distinguished Encoding Rules (DER) to the ASN.1 Object Identifier with subsequent truncation. The truncation removes the two fields of encoded Object Identifier. The first omitted field is 1 octet representing the Object Identifier tag, and the second omitted field is the length of the Object Identifier body. For example, the complete ASN.1 DER encoding for the NIST P-256 curve OID is \"06 08 2A 86 48 CE 3D 03 01 07\", from which the first entry in the table above is constructed by omitting the first two octets. Only the truncated sequence of octets is the valid representation of a curve OID.",
      "ja": "3番目の列のオクテットのシーケンスは、際立ったエンコードルール（der）をASN.1オブジェクト識別子に後続の切り捨てで適用した結果です。切り捨てにより、エンコードされたオブジェクト識別子の2つのフィールドが削除されます。最初に省略されたフィールドは、オブジェクト識別子タグを表す1オクテットで、2番目の省略されたフィールドはオブジェクト識別子本体の長さです。たとえば、NIST P-256曲線OIDの完全なASN.1 derエンコードは「06 08 2A 86 48 CE 3D 03 01 07」です。上の表の最初のエントリは、最初の2つのオクテットを省略して構築されます。オクテットの切り捨てられたシーケンスのみが、曲線oidの有効な表現です。"
    },
    {
      "indent": 3,
      "text": "The deprecated OIDs for Ed25519Legacy and Curve25519Legacy are used only in version 4 keys and signatures. Implementations MAY implement these variants for compatibility with existing version 4 key material and signatures. Implementations MUST NOT accept or generate version 6 key material using the deprecated OIDs.",
      "ja": "ED25519LegacyとCurve25519Legacyの偏向OIDは、バージョン4キーと署名でのみ使用されます。実装は、既存のバージョン4の主要な資料と署名との互換性のためにこれらのバリアントを実装する場合があります。実装は、非推奨のOIDを使用して、バージョン6の重要な資料を受け入れたり生成したりしてはなりません。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Curve-Specific Wire Formats",
      "section_title": true,
      "ja": "9.2.1. 曲線固有のワイヤ形式"
    },
    {
      "indent": 3,
      "text": "Some elliptic curve public key algorithms use different conventions for specific fields depending on the curve in use. Each field is always formatted as an MPI, but with a curve-specific framing. This table summarizes those distinctions.",
      "ja": "一部の楕円曲線公開キーアルゴリズムの一部は、使用中の曲線に応じて特定のフィールドに異なる規則を使用します。各フィールドは常にMPIとしてフォーマットされますが、曲線固有のフレーミングがあります。この表は、これらの区別を要約しています。"
    },
    {
      "indent": 3,
      "text": "+================+========+============+=======+=========+==========+\n|Curve           |ECDH    |ECDH Secret |EdDSA  |EdDSA    |EdDSA     |\n|                |Point   |Key MPI     |Secret |Signature|Signature |\n|                |Format  |            |Key MPI|first MPI|second    |\n|                |        |            |       |         |MPI       |\n+================+========+============+=======+=========+==========+\n|NIST P-256      |SEC1    |integer     |N/A    |N/A      |N/A       |\n+----------------+--------+------------+-------+---------+----------+\n|NIST P-384      |SEC1    |integer     |N/A    |N/A      |N/A       |\n+----------------+--------+------------+-------+---------+----------+\n|NIST P-521      |SEC1    |integer     |N/A    |N/A      |N/A       |\n+----------------+--------+------------+-------+---------+----------+\n|brainpoolP256r1 |SEC1    |integer     |N/A    |N/A      |N/A       |\n+----------------+--------+------------+-------+---------+----------+\n|brainpoolP384r1 |SEC1    |integer     |N/A    |N/A      |N/A       |\n+----------------+--------+------------+-------+---------+----------+\n|brainpoolP512r1 |SEC1    |integer     |N/A    |N/A      |N/A       |\n+----------------+--------+------------+-------+---------+----------+\n|Ed25519Legacy   |N/A     |N/A         |32     |32 octets|32 octets |\n|                |        |            |octets |of R     |of S      |\n|                |        |            |of     |         |          |\n|                |        |            |secret |         |          |\n+----------------+--------+------------+-------+---------+----------+\n|Curve25519Legacy|prefixed|integer     |N/A    |N/A      |N/A       |\n|                |native  |(Section    |       |         |          |\n|                |        |5.5.5.6.1.1)|       |         |          |\n+----------------+--------+------------+-------+---------+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Table 20: OpenPGP ECC Curve-Specific Wire Formats Registry",
      "ja": "表20：OpenPGP ECC曲線固有のワイヤ形式レジストリ"
    },
    {
      "indent": 3,
      "text": "For the native octet-string forms of Ed25519Legacy values, see [RFC8032]. For the native octet-string forms of Curve25519Legacy secret scalars and points, see [RFC7748].",
      "ja": "ED25519レガシー値のネイティブオクテットストリング型については、[RFC8032]を参照してください。曲線25519のネイティブオクテットストリング形式のレガシーシークレットスカラーとポイントについては、[RFC7748]を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.3. Symmetric Key Algorithms",
      "section_title": true,
      "ja": "9.3. 対称キーアルゴリズム"
    },
    {
      "indent": 9,
      "text": "+=========+============================================+\n|      ID | Algorithm                                  |\n+=========+============================================+\n|       0 | Plaintext or unencrypted data              |\n+---------+--------------------------------------------+\n|       1 | IDEA [IDEA]                                |\n+---------+--------------------------------------------+\n|       2 | TripleDES (or DES-EDE) [SP800-67] with     |\n|         | 168-bit key derived from 192               |\n+---------+--------------------------------------------+\n|       3 | CAST5 with 128-bit key [RFC2144]           |\n+---------+--------------------------------------------+\n|       4 | Blowfish with 128-bit key, 16 rounds       |\n|         | [BLOWFISH]                                 |\n+---------+--------------------------------------------+\n|       5 | Reserved                                   |\n+---------+--------------------------------------------+\n|       6 | Reserved                                   |\n+---------+--------------------------------------------+\n|       7 | AES with 128-bit key [AES]                 |\n+---------+--------------------------------------------+\n|       8 | AES with 192-bit key                       |\n+---------+--------------------------------------------+\n|       9 | AES with 256-bit key                       |\n+---------+--------------------------------------------+\n|      10 | Twofish with 256-bit key [TWOFISH]         |\n+---------+--------------------------------------------+\n|      11 | Camellia with 128-bit key [RFC3713]        |\n+---------+--------------------------------------------+\n|      12 | Camellia with 192-bit key                  |\n+---------+--------------------------------------------+\n|      13 | Camellia with 256-bit key                  |\n+---------+--------------------------------------------+\n| 100-110 | Private or Experimental Use                |\n+---------+--------------------------------------------+\n| 253-255 | Reserved to avoid collision with Secret    |\n|         | Key Encryption (Table 2 and Section 5.5.3) |\n+---------+--------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 21: OpenPGP Symmetric Key Algorithms Registry",
      "ja": "表21：OpenPGP対称キーアルゴリズムレジストリ"
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement AES-128. Implementations SHOULD implement AES-256. Implementations MUST NOT encrypt data with IDEA, TripleDES, or CAST5. Implementations MAY decrypt data that uses IDEA, TripleDES, or CAST5 for the sake of reading older messages or new messages from implementations predating support for [RFC2440]. An Implementation that decrypts data using IDEA, TripleDES, or CAST5 SHOULD generate a deprecation warning about the symmetric algorithm, indicating that message confidentiality is suspect. Implementations MAY implement any other algorithm.",
      "ja": "実装はAES-128を実装する必要があります。実装はAES-256を実装する必要があります。実装は、アイデア、3倍、またはCAST5を使用してデータを暗号化してはなりません。実装では、[RFC2440]のサポートに先行する実装からの古いメッセージまたは新しいメッセージを読むために、アイデア、3倍、またはCAST5を使用するデータを復号化する場合があります。Idea、Tripledes、またはCAST5を使用してデータを復号化する実装は、対称アルゴリズムに関する非推奨警告を生成し、メッセージの機密性が疑わしいことを示しています。実装は、他のアルゴリズムを実装する場合があります。"
    },
    {
      "indent": 0,
      "text": "9.4. Compression Algorithms",
      "section_title": true,
      "ja": "9.4. 圧縮アルゴリズム"
    },
    {
      "indent": 17,
      "text": "+=========+=============================+\n|      ID | Algorithm                   |\n+=========+=============================+\n|       0 | Uncompressed                |\n+---------+-----------------------------+\n|       1 | ZIP [RFC1951]               |\n+---------+-----------------------------+\n|       2 | ZLIB [RFC1950]              |\n+---------+-----------------------------+\n|       3 | BZip2 [BZ2]                 |\n+---------+-----------------------------+\n| 100-110 | Private or Experimental Use |\n+---------+-----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 22: OpenPGP Compression Algorithms Registry",
      "ja": "表22：OpenPGP圧縮アルゴリズムレジストリ"
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement uncompressed data. Implementations SHOULD implement ZLIB. For interoperability reasons, implementations SHOULD be able to decompress using ZIP. Implementations MAY implement any other algorithm.",
      "ja": "実装は、非圧縮データを実装する必要があります。実装はZLIBを実装する必要があります。相互運用性の理由により、実装はZIPを使用して減圧できる必要があります。実装は、他のアルゴリズムを実装する場合があります。"
    },
    {
      "indent": 0,
      "text": "9.5. Hash Algorithms",
      "section_title": true,
      "ja": "9.5. ハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "+=========+==================+=============+========================+\n|      ID | Algorithm        | Text Name   | V6 Signature           |\n|         |                  |             | Salt Size              |\n+=========+==================+=============+========================+\n|       0 | Reserved         |             |                        |\n+---------+------------------+-------------+------------------------+\n|       1 | MD5 [RFC1321]    | \"MD5\"       | N/A                    |\n+---------+------------------+-------------+------------------------+\n|       2 | SHA-1 [FIPS180]  | \"SHA1\"      | N/A                    |\n+---------+------------------+-------------+------------------------+\n|       3 | RIPEMD-160       | \"RIPEMD160\" | N/A                    |\n|         | [RIPEMD-160]     |             |                        |\n+---------+------------------+-------------+------------------------+\n|       4 | Reserved         |             |                        |\n+---------+------------------+-------------+------------------------+\n|       5 | Reserved         |             |                        |\n+---------+------------------+-------------+------------------------+\n|       6 | Reserved         |             |                        |\n+---------+------------------+-------------+------------------------+\n|       7 | Reserved         |             |                        |\n+---------+------------------+-------------+------------------------+\n|       8 | SHA2-256         | \"SHA256\"    | 16                     |\n|         | [FIPS180]        |             |                        |\n+---------+------------------+-------------+------------------------+\n|       9 | SHA2-384         | \"SHA384\"    | 24                     |\n|         | [FIPS180]        |             |                        |\n+---------+------------------+-------------+------------------------+\n|      10 | SHA2-512         | \"SHA512\"    | 32                     |\n|         | [FIPS180]        |             |                        |\n+---------+------------------+-------------+------------------------+\n|      11 | SHA2-224         | \"SHA224\"    | 16                     |\n|         | [FIPS180]        |             |                        |\n+---------+------------------+-------------+------------------------+\n|      12 | SHA3-256         | \"SHA3-256\"  | 16                     |\n|         | [FIPS202]        |             |                        |\n+---------+------------------+-------------+------------------------+\n|      13 | Reserved         |             |                        |\n+---------+------------------+-------------+------------------------+\n|      14 | SHA3-512         | \"SHA3-512\"  | 32                     |\n|         | [FIPS202]        |             |                        |\n+---------+------------------+-------------+------------------------+\n| 100-110 | Private or       |             |                        |\n|         | Experimental Use |             |                        |\n+---------+------------------+-------------+------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 23: OpenPGP Hash Algorithms Registry",
      "ja": "表23：OpenPGPハッシュアルゴリズムレジストリ"
    },
    {
      "indent": 4,
      "text": "+============+=========================+=========================+\n| Hash       | OID                     | Full Hash Prefix        |\n| Algorithm  |                         |                         |\n+============+=========================+=========================+\n| MD5        | 1.2.840.113549.2.5      | 0x30, 0x20, 0x30, 0x0C, |\n|            |                         | 0x06, 0x08, 0x2A, 0x86, |\n|            |                         | 0x48, 0x86, 0xF7, 0x0D, |\n|            |                         | 0x02, 0x05, 0x05, 0x00, |\n|            |                         | 0x04, 0x10              |\n+------------+-------------------------+-------------------------+\n| SHA-1      | 1.3.14.3.2.26           | 0x30, 0x21, 0x30, 0x09, |\n|            |                         | 0x06, 0x05, 0x2B, 0x0E, |\n|            |                         | 0x03, 0x02, 0x1A, 0x05, |\n|            |                         | 0x00, 0x04, 0x14        |\n+------------+-------------------------+-------------------------+\n| RIPEMD-160 | 1.3.36.3.2.1            | 0x30, 0x21, 0x30, 0x09, |\n|            |                         | 0x06, 0x05, 0x2B, 0x24, |\n|            |                         | 0x03, 0x02, 0x01, 0x05, |\n|            |                         | 0x00, 0x04, 0x14        |\n+------------+-------------------------+-------------------------+\n| SHA2-256   | 2.16.840.1.101.3.4.2.1  | 0x30, 0x31, 0x30, 0x0D, |\n|            |                         | 0x06, 0x09, 0x60, 0x86, |\n|            |                         | 0x48, 0x01, 0x65, 0x03, |\n|            |                         | 0x04, 0x02, 0x01, 0x05, |\n|            |                         | 0x00, 0x04, 0x20        |\n+------------+-------------------------+-------------------------+\n| SHA2-384   | 2.16.840.1.101.3.4.2.2  | 0x30, 0x41, 0x30, 0x0D, |\n|            |                         | 0x06, 0x09, 0x60, 0x86, |\n|            |                         | 0x48, 0x01, 0x65, 0x03, |\n|            |                         | 0x04, 0x02, 0x02, 0x05, |\n|            |                         | 0x00, 0x04, 0x30        |\n+------------+-------------------------+-------------------------+\n| SHA2-512   | 2.16.840.1.101.3.4.2.3  | 0x30, 0x51, 0x30, 0x0D, |\n|            |                         | 0x06, 0x09, 0x60, 0x86, |\n|            |                         | 0x48, 0x01, 0x65, 0x03, |\n|            |                         | 0x04, 0x02, 0x03, 0x05, |\n|            |                         | 0x00, 0x04, 0x40        |\n+------------+-------------------------+-------------------------+\n| SHA2-224   | 2.16.840.1.101.3.4.2.4  | 0x30, 0x2D, 0x30, 0x0D, |\n|            |                         | 0x06, 0x09, 0x60, 0x86, |\n|            |                         | 0x48, 0x01, 0x65, 0x03, |\n|            |                         | 0x04, 0x02, 0x04, 0x05, |\n|            |                         | 0x00, 0x04, 0x1C        |\n+------------+-------------------------+-------------------------+\n| SHA3-256   | 2.16.840.1.101.3.4.2.8  | 0x30, 0x31, 0x30, 0x0D, |\n|            |                         | 0x06, 0x09, 0x60, 0x86, |\n|            |                         | 0x48, 0x01, 0x65, 0x03, |\n|            |                         | 0x04, 0x02, 0x08, 0x05, |\n|            |                         | 0x00, 0x04, 0x20        |\n+------------+-------------------------+-------------------------+\n| SHA3-512   | 2.16.840.1.101.3.4.2.10 | 0x30, 0x51, 0x30, 0x0D, |\n|            |                         | 0x06, 0x09, 0x60, 0x86, |\n|            |                         | 0x48, 0x01, 0x65, 0x03, |\n|            |                         | 0x04, 0x02, 0x0a, 0x05, |\n|            |                         | 0x00, 0x04, 0x40        |\n+------------+-------------------------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 24: OpenPGP Hash Algorithm Identifiers for RSA Signatures' Use of EMSA-PKCS1-v1_5 Padding Registry",
      "ja": "表24：RSA SignaturesのEMSA-PKCS1-V1_5パディングレジストリの使用のOpenPGPハッシュアルゴリズム識別子識別子"
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement SHA2-256. Implementations SHOULD implement SHA2-384 and SHA2-512. Implementations MAY implement other algorithms. Implementations SHOULD NOT create messages that require the use of SHA-1, with the exception of computing version 4 key fingerprints for purposes of the MDC in version 1 Symmetrically Encrypted and Integrity Protected Data packets. Implementations MUST NOT generate signatures with MD5, SHA-1, or RIPEMD-160. Implementations MUST NOT use MD5, SHA-1, or RIPEMD-160 as a hash function in an ECDH KDF. Implementations MUST NOT generate packets using MD5, SHA-1, or RIPEMD-160 as a hash function in an S2K KDF. Implementations MUST NOT decrypt a secret using MD5, SHA-1, or RIPEMD-160 as a hash function in an S2K KDF in a version 6 (or later) packet. Implementations MUST NOT validate any recent signature that depends on MD5, SHA-1, or RIPEMD-160. Implementations SHOULD NOT validate any old signature that depends on MD5, SHA-1, or RIPEMD-160 unless the signature's creation date predates known weakness of the algorithm used, and the implementation is confident that the message has been in the secure custody of the user the whole time.",
      "ja": "実装はSHA2-256を実装する必要があります。実装では、SHA2-384およびSHA2-512を実装する必要があります。実装は、他のアルゴリズムを実装する場合があります。実装は、バージョン1の主要な指紋を除き、SHA-1の使用を必要とするメッセージを作成してはなりません。バージョン1の対称的に暗号化された、整合性保護されたデータパケットのMDCの目的のために、バージョン4のキーフィンガープリントを除きます。実装は、MD5、SHA-1、またはRIPEMD-160で署名を生成してはなりません。実装は、ECDH KDFのハッシュ関数としてMD5、SHA-1、またはRIPEMD-160を使用しないでください。実装は、S2K KDFのハッシュ関数としてMD5、SHA-1、またはRIPEMD-160を使用してパケットを生成してはなりません。実装は、MD5、SHA-1、またはRIPEMD-160を使用して、バージョン6（または後で）パケットのS2K KDFのハッシュ関数として秘密を解読してはなりません。実装は、MD5、SHA-1、またはRIPEMD-160に依存する最近の署名を検証してはなりません。実装は、署名の作成日が使用されているアルゴリズムの既知の弱点を前にしていない限り、MD5、SHA-1、またはRIPEMD-160に依存する古い署名を検証すべきではありません。ずっと。"
    },
    {
      "indent": 0,
      "text": "9.6. AEAD Algorithms",
      "section_title": true,
      "ja": "9.6. AEADアルゴリズム"
    },
    {
      "indent": 4,
      "text": "+=========+==================+==============+====================+\n|      ID | Name             | Nonce Length | Authentication Tag |\n|         |                  | (Octets)     | Length (Octets)    |\n+=========+==================+==============+====================+\n|       0 | Reserved         |              |                    |\n+---------+------------------+--------------+--------------------+\n|       1 | EAX [EAX]        | 16           | 16                 |\n+---------+------------------+--------------+--------------------+\n|       2 | OCB [RFC7253]    | 15           | 16                 |\n+---------+------------------+--------------+--------------------+\n|       3 | GCM [SP800-38D]  | 12           | 16                 |\n+---------+------------------+--------------+--------------------+\n| 100-110 | Private or       |              |                    |\n|         | Experimental Use |              |                    |\n+---------+------------------+--------------+--------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 25: OpenPGP AEAD Algorithms Registry",
      "ja": "表25：OpenPGP AEADアルゴリズムレジストリ"
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement OCB. Implementations MAY implement EAX, GCM, and other algorithms.",
      "ja": "実装はOCBを実装する必要があります。実装は、EAX、GCM、およびその他のアルゴリズムを実装する場合があります。"
    },
    {
      "indent": 0,
      "text": "10. Packet Sequence Composition",
      "section_title": true,
      "ja": "10. パケットシーケンス構成"
    },
    {
      "indent": 3,
      "text": "OpenPGP packets are assembled into sequences in order to create messages and to transfer keys. Not all possible packet sequences are meaningful and correct. This section describes the rules for how packets should be placed into sequences.",
      "ja": "OpenPGPパケットは、メッセージを作成し、キーを転送するためにシーケンスに組み立てられます。すべての可能なパケットシーケンスが意味があり正しいわけではありません。このセクションでは、パケットをシーケンスに配置する方法のルールについて説明します。"
    },
    {
      "indent": 3,
      "text": "There are three distinct sequences of packets:",
      "ja": "パケットには3つの異なるシーケンスがあります。"
    },
    {
      "indent": 6,
      "text": "* Transferable Public Keys (Section 10.1) and their close counterpart, Transferable Secret Keys (Section 10.2)",
      "ja": "* 転送可能なパブリックキー（セクション10.1）とそれらの密接なカウンターパート、転送可能な秘密キー（セクション10.2）"
    },
    {
      "indent": 6,
      "text": "* OpenPGP Messages (Section 10.3)",
      "ja": "* OpenPGPメッセージ（セクション10.3）"
    },
    {
      "indent": 6,
      "text": "* Detached Signatures (Section 10.4)",
      "ja": "* 分離した署名（セクション10.4）"
    },
    {
      "indent": 3,
      "text": "Each sequence has an explicit grammar of what packet types (Table 3) can appear in what place. The presence of an unknown critical packet, or a known but unexpected packet, is a critical error, invalidating the entire sequence (see Section 4.3). On the other hand, unknown non-critical packets can appear anywhere within any sequence. This provides a structured way to introduce new packets into OpenPGP, while making sure that certain packets will be handled strictly.",
      "ja": "各シーケンスには、パケットタイプ（表3）がどの場所に表示できるかについての明示的な文法があります。未知の批判的パケットの存在、または既知のが予期しないパケットは、シーケンス全体を無効にする重要なエラーです（セクション4.3を参照）。一方、不明な非クリティカルなパケットは、任意のシーケンス内にどこにでも表示できます。これにより、特定のパケットが厳密に処理されるようにしながら、新しいパケットをOpenPGPに導入する構造化された方法が提供されます。"
    },
    {
      "indent": 3,
      "text": "An implementation may \"recognize\" a packet but not implement it. The purpose of Packet Criticality is to allow the producer to tell the consumer whether it would prefer a new, unknown packet to generate an error or be ignored.",
      "ja": "実装では、パケットを「認識」しますが、実装しない場合があります。パケットの重要性の目的は、プロデューサーが消費者に、新しい未知のパケットがエラーを生成するのか無視されるかを好むかどうかを伝えることです。"
    },
    {
      "indent": 3,
      "text": "Note that previous versions of this document did not have a concept of Packet Criticality and did not give clear guidance on what to do when unknown packets are encountered. Therefore, implementations of the previous versions may reject unknown non-critical packets or accept unknown critical packets.",
      "ja": "このドキュメントの以前のバージョンには、パケットの臨界性の概念がなく、不明なパケットが発生したときに何をすべきかについて明確なガイダンスを提供しなかったことに注意してください。したがって、以前のバージョンの実装は、未知の非批判的なパケットを拒否するか、未知の重要なパケットを受け入れる場合があります。"
    },
    {
      "indent": 3,
      "text": "When generating a sequence of OpenPGP packets according to one of the three grammars, an implementation MUST NOT inject a critical packet of a type that does not adhere to the grammar.",
      "ja": "3つの文法のいずれかに従ってOpenPGPパケットのシーケンスを生成する場合、実装は文法に付着しないタイプの重要なパケットを注入してはなりません。"
    },
    {
      "indent": 3,
      "text": "When consuming a sequence of OpenPGP packets, if an implementation encounters a critical packet of an inappropriate type according to the relevant grammar, the implementation MUST reject the sequence with an error.",
      "ja": "OpenPGPパケットのシーケンスを消費する場合、実装が関連する文法に従って不適切なタイプの重要なパケットに遭遇する場合、実装はエラーでシーケンスを拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.1. Transferable Public Keys",
      "section_title": true,
      "ja": "10.1. 転送可能なパブリックキー"
    },
    {
      "indent": 3,
      "text": "OpenPGP users may transfer public keys. This section describes the structure of public keys in transit to ensure interoperability. An OpenPGP Transferable Public Key is also known as an OpenPGP certificate, in order to distinguish it from both its constituent Public Key packets (Sections 5.5.1.1 and 5.5.1.2) and the underlying cryptographic key material.",
      "ja": "OpenPGPユーザーは、パブリックキーを転送できます。このセクションでは、相互運用性を確保するために、輸送中のパブリックキーの構造について説明します。OpenPGP転送可能な公開キーは、OpenPGP証明書とも呼ばれます。これは、構成要素の公開キーパケット（セクション5.5.1.1および5.5.1.2）と基礎となる暗号化キー素材の両方と区別するためです。"
    },
    {
      "indent": 0,
      "text": "10.1.1. OpenPGP Version 6 Certificate Structure",
      "section_title": true,
      "ja": "10.1.1. OpenPGPバージョン6証明書構造"
    },
    {
      "indent": 3,
      "text": "The format of an OpenPGP version 6 certificate is as follows. Entries in square brackets are optional and ellipses indicate repetition.",
      "ja": "OpenPGPバージョン6証明書の形式は次のとおりです。四角い括弧内のエントリはオプションであり、楕円は繰り返しを示します。"
    },
    {
      "indent": 3,
      "text": "Primary Key\n   [Revocation Signature...]\n    Direct Key Signature...\n   [User ID or User Attribute\n           [Certification Revocation Signature...]\n           [Certification Signature...]]...\n   [Subkey [Subkey Revocation Signature...]\n           Subkey Binding Signature...]...\n   [Padding]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In addition to these rules, a Marker packet (Section 5.8) can appear anywhere in the sequence.",
      "ja": "これらのルールに加えて、マーカーパケット（セクション5.8）は、シーケンス内のどこにでも表示できます。"
    },
    {
      "indent": 3,
      "text": "Note that a version 6 key uses a self-signed Direct Key signature to store algorithm preferences.",
      "ja": "バージョン6キーは、自己署名の直接キー署名を使用してアルゴリズムの設定を保存することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Every subkey for a version 6 primary key MUST be a version 6 subkey. Every subkey MUST have at least one Subkey Binding signature. Every Subkey Binding signature MUST be a self-signature (that is, made by the version 6 primary key). Like all other signatures, every self-signature made by a version 6 key MUST be a version 6 signature.",
      "ja": "バージョン6プライマリキーのすべてのサブキーは、バージョン6サブキーでなければなりません。すべてのサブキーには、少なくとも1つのサブキーバインディングシグネチャが必要です。すべてのサブキーバインディングシグネチャは、自己署名（つまり、バージョン6プライマリキーによって作成された）でなければなりません。他のすべての署名と同様に、バージョン6キーによって作成されたすべての自己署名は、バージョン6の署名でなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.1.2. OpenPGP Version 6 Revocation Certificate",
      "section_title": true,
      "ja": "10.1.2. OpenPGPバージョン6失効証明書"
    },
    {
      "indent": 3,
      "text": "When a primary version 6 Public Key is revoked, it is sometimes distributed with only the Revocation Signature:",
      "ja": "プライマリバージョン6の公開キーが取り消された場合、それは時々取り消し署名のみで配布されます："
    },
    {
      "indent": 3,
      "text": "Primary Key\n    Revocation Signature",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this case, the Direct Key signature is no longer necessary, since the primary key itself has been marked as unusable.",
      "ja": "この場合、主キー自体が使用できないとマークされているため、直接キーの署名はもはや必要ありません。"
    },
    {
      "indent": 0,
      "text": "10.1.3. OpenPGP Version 4 Certificate Structure",
      "section_title": true,
      "ja": "10.1.3. OpenPGPバージョン4証明書構造"
    },
    {
      "indent": 3,
      "text": "The format of an OpenPGP version 4 key is as follows.",
      "ja": "OpenPGPバージョン4キーの形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Primary Key\n   [Revocation Signature]\n   [Direct Key Signature...]\n   [User ID or User Attribute [Signature...]]...\n   [Subkey [Subkey Revocation Signature...]\n           Subkey Binding Signature...]...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In addition to these rules, a Marker packet (Section 5.8) can appear anywhere in the sequence.",
      "ja": "これらのルールに加えて、マーカーパケット（セクション5.8）は、シーケンス内のどこにでも表示できます。"
    },
    {
      "indent": 3,
      "text": "A subkey always has at least one Subkey Binding signature after it that is issued using the primary key to tie the two keys together. These binding signatures may be in either version 3 or version 4 format, but they SHOULD be in version 4 format. Subkeys that can issue signatures MUST have a version 4 binding signature due to the REQUIRED embedded Primary Key Binding signature.",
      "ja": "サブキーは、プライマリキーを使用して2つのキーを結び付けるために発行された後、少なくとも1つのサブキーバインディングシグネチャを常に持っています。これらのバインディング署名は、バージョン3またはバージョン4形式のいずれかですが、バージョン4形式である必要があります。署名を発行できるサブキーには、必要な埋め込みプライマリキーバインディング署名があるため、バージョン4のバインディングシグネチャが必要です。"
    },
    {
      "indent": 3,
      "text": "Every subkey for a version 4 primary key MUST be a version 4 subkey.",
      "ja": "バージョン4プライマリキーのすべてのサブキーは、バージョン4サブキーでなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a primary version 4 Public Key is revoked, the Revocation Signature is sometimes distributed by itself, without the primary key packet it applies to. This is referred to as a \"revocation certificate\". Instead, a version 6 revocation certificate MUST include the primary key packet, as described in Section 10.1.2.",
      "ja": "プライマリバージョン4の公開キーが取り消されると、取り消し署名は、適用されるプライマリキーパケットなしで、それ自体で分配されることがあります。これは「取り消し証明書」と呼ばれます。代わりに、セクション10.1.2で説明されているように、バージョン6の失効証明書には、プライマリキーパケットを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "10.1.4. OpenPGP Version 3 Key Structure",
      "section_title": true,
      "ja": "10.1.4. OpenPGPバージョン3キー構造"
    },
    {
      "indent": 3,
      "text": "The format of an OpenPGP version 3 key is as follows.",
      "ja": "OpenPGPバージョン3キーの形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "RSA Public Key\n   [Revocation Signature]\n    User ID [Signature...]\n   [User ID [Signature...]]...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In addition to these rules, a Marker packet (Section 5.8) can appear anywhere in the sequence.",
      "ja": "これらのルールに加えて、マーカーパケット（セクション5.8）は、シーケンス内のどこにでも表示できます。"
    },
    {
      "indent": 3,
      "text": "Each signature certifies the RSA public key and the preceding User ID. The RSA public key can have many User IDs, and each User ID can have many signatures. Version 3 keys are deprecated. Implementations MUST NOT generate new version 3 keys but MAY continue to use existing ones.",
      "ja": "各署名は、RSA公開キーと上記のユーザーIDを証明します。RSAの公開キーには多くのユーザーIDがあり、各ユーザーIDには多くの署名があります。バージョン3キーは非推奨です。実装は新しいバージョン3キーを生成してはなりませんが、既存のキーを引き続き使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "Version 3 keys MUST NOT have subkeys.",
      "ja": "バージョン3キーにはサブキーが必要です。"
    },
    {
      "indent": 0,
      "text": "10.1.5. Common Requirements",
      "section_title": true,
      "ja": "10.1.5. 一般的な要件"
    },
    {
      "indent": 3,
      "text": "The Public Key packet occurs first.",
      "ja": "公開キーパケットが最初に発生します。"
    },
    {
      "indent": 3,
      "text": "The primary key MUST be an algorithm capable of making signatures (that is, not an encryption-only algorithm). This is because the primary key needs to be able to create self-signatures (see Section 5.2.3.10). The subkeys may be keys of any type. For example, there may be a single-key RSA key, an Ed25519 primary key with an RSA encryption subkey, an Ed25519 primary key with an X25519 subkey, etc.",
      "ja": "主キーは、署名を作成できるアルゴリズムでなければなりません（つまり、暗号化のみのアルゴリズムではありません）。これは、主キーが自己署名を作成できる必要があるためです（セクション5.2.3.10を参照）。サブキーは、あらゆるタイプのキーである場合があります。たとえば、シングルキーRSAキー、RSA暗号化サブキーを備えたED25519プライマリキー、X25519サブキーを備えたED25519プライマリキーなどがあります。"
    },
    {
      "indent": 3,
      "text": "Each of the following User ID packets provides the identity of the owner of this public key. If there are multiple User ID packets, this corresponds to multiple means of identifying the same unique individual user; for example, a user may have more than one email address and construct a User ID for each one. A Transferable Public Key SHOULD include at least one User ID packet unless storage requirements prohibit this.",
      "ja": "次の各ユーザーIDパケットは、この公開キーの所有者の身元を提供します。複数のユーザーIDパケットがある場合、これは同じ一意の個々のユーザーを識別する複数の手段に対応します。たとえば、ユーザーは複数の電子メールアドレスを持ち、それぞれのユーザーIDを作成することができます。転送可能な公開キーには、ストレージ要件がこれを禁止しない限り、少なくとも1つのユーザーIDパケットを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Immediately following each User ID packet, there are zero or more Signature packets. Each Signature packet is calculated on the immediately preceding User ID packet and the initial Public Key packet. The signature serves to certify the corresponding public key and User ID. In effect, the signer is testifying to the belief that this public key belongs to the user identified by this User ID.",
      "ja": "各ユーザーIDパケットの直後に、ゼロ以上の署名パケットがあります。各署名パケットは、直前のユーザーIDパケットと最初の公開キーパケットで計算されます。署名は、対応する公開キーとユーザーIDを証明するのに役立ちます。実際、署名者は、この公開鍵はこのユーザーIDによって識別されたユーザーに属しているという信念を証明しています。"
    },
    {
      "indent": 3,
      "text": "Within the same section as the User ID packets, there are zero or more User Attribute packets. Like the User ID packets, a User Attribute packet is followed by zero or more Signature packets calculated on the immediately preceding User Attribute packet and the initial Public Key packet.",
      "ja": "ユーザーIDパケットと同じセクション内に、ゼロ以上のユーザー属性パケットがあります。ユーザーIDパケットと同様に、ユーザー属性パケットの後に、直前のユーザー属性パケットと最初の公開キーパケットで計算されたゼロ以上の署名パケットが続きます。"
    },
    {
      "indent": 3,
      "text": "User Attribute packets and User ID packets may be freely intermixed in this section, as long as the signatures that follow them are maintained on the proper User Attribute or User ID packet.",
      "ja": "ユーザー属性パケットとユーザーIDパケットは、適切なユーザー属性またはユーザーIDパケットに維持されている限り、このセクションでは自由に混合される場合があります。"
    },
    {
      "indent": 3,
      "text": "After the sequence of User ID packets and Attribute packets and their associated signatures, zero or more Subkey packets follow, each with their own signatures. In general, subkeys are provided in cases where the top-level public key is a certification-only key. However, any version 4 or version 6 key may have subkeys, and the subkeys may be encryption keys, signing keys, authentication keys, etc. It is good practice to use separate subkeys for every operation (i.e., signature-only, encryption-only, authentication-only keys, etc.).",
      "ja": "ユーザーIDパケットと属性パケットのシーケンスとそれに関連する署名の後、それぞれが独自の署名を備えたゼロ以上のサブキーパケットが続きます。一般に、サブキーは、トップレベルの公開キーが認定のみのキーである場合に提供されます。ただし、バージョン4またはバージョン6キーにはサブキーがあり、サブキーは暗号化キー、署名キー、認証キーなどである場合があります。、認証のみのキーなど）。"
    },
    {
      "indent": 3,
      "text": "Each Subkey packet MUST be followed by one Signature packet, which should be a Subkey Binding signature issued by the top-level key. For subkeys that can issue signatures, the Subkey Binding signature MUST contain an Embedded Signature subpacket with a Primary Key Binding signature (Type ID 0x19) issued by the subkey on the top-level key.",
      "ja": "各サブキーパケットの後に、1つの署名パケットが必要です。これは、トップレベルキーによって発行されたサブキーバインディングシグネチャーである必要があります。署名を発行できるサブキーの場合、サブキーバインディングシグネチャ（タイプID 0x19）がトップレベルキーに発行されたプライマリキーバインディングシグネチャ（タイプID 0x19）を備えたサブキーバインディング署名には、サブキーバインディング署名が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "Subkey and Key packets may each be followed by a Revocation Signature packet to indicate that the key is revoked. Revocation Signatures are only accepted if they are issued by the key itself or by a key that is authorized to issue revocations via a Revocation Key subpacket in a self-signature by the top-level key.",
      "ja": "サブキーとキーパケットの後に、キーが取り消されていることを示す取り消し署名パケットが続く場合があります。取り消し署名は、キー自体によって発行された場合、またはトップレベルのキーによって自己署名の取り消しキーサブパケットを介して取消しを発行することを許可されているキーによってのみ受け入れられます。"
    },
    {
      "indent": 3,
      "text": "The optional trailing Padding packet is a mechanism to defend against traffic analysis (see Section 13.11). For maximum interoperability, if the Public Key packet is a version 4 key, the optional Padding packet SHOULD NOT be present unless the recipient has indicated that they are capable of ignoring it successfully. An implementation that is capable of receiving a Transferable Public Key with a version 6 Public Key primary key MUST be able to accept (and ignore) the trailing optional Padding packet.",
      "ja": "オプションのトレーリングパディングパケットは、トラフィック分析から防御するメカニズムです（セクション13.11を参照）。相互運用性を最大限にするために、公開キーパケットがバージョン4キーである場合、受信者がそれを正常に無視できることを示していない限り、オプションのパディングパケットは存在しないでください。バージョン6の公開キーのプライマリキーを使用して転送可能な公開キーを受信できる実装は、後続のオプションのパディングパケットを受け入れる（および無視）することができなければなりません。"
    },
    {
      "indent": 3,
      "text": "Transferable Public Key packet sequences may be concatenated to allow transferring multiple public keys in one operation (see Section 3.6).",
      "ja": "転送可能な公開キーパケットシーケンスを連結して、1つの操作で複数のパブリックキーを転送できるようにすることができます（セクション3.6を参照）。"
    },
    {
      "indent": 0,
      "text": "10.2. Transferable Secret Keys",
      "section_title": true,
      "ja": "10.2. 転送可能なシークレットキー"
    },
    {
      "indent": 3,
      "text": "OpenPGP users may transfer secret keys. The format of a Transferable Secret Key is the same as a Transferable Public Key except that Secret Key and Secret Subkey packets can be used in addition to the Public Key and Public Subkey packets. If a single Secret Key or Secret Subkey packet is included in a packet sequence, it is a Transferable Secret Key and should be handled and marked as such (see Section 6.2.1). An implementation SHOULD include self-signatures on any User IDs and subkeys, as this allows for a complete public key to be automatically extracted from the Transferable Secret Key. An implementation MAY choose to omit the self-signatures, especially if a Transferable Public Key accompanies the Transferable Secret Key.",
      "ja": "OpenPGPユーザーは秘密のキーを転送できます。転送可能なシークレットキーの形式は、公開キーとパブリックサブキーパケットに加えて、シークレットキーとシークレットサブキーパケットを使用できることを除いて、転送可能な公開キーと同じです。単一のシークレットキーまたはシークレットサブキーパケットがパケットシーケンスに含まれている場合、それは転送可能なシークレットキーであり、そのように処理してマークする必要があります（セクション6.2.1を参照）。実装には、ユーザーIDおよびサブキーの自己署名を含める必要があります。これにより、完全な公開キーを転送可能な秘密キーから自動的に抽出できるようにするためです。実装は、特に転送可能な公開キーが転送可能な秘密キーに付随する場合、自己署名を省略することを選択する場合があります。"
    },
    {
      "indent": 0,
      "text": "10.3. OpenPGP Messages",
      "section_title": true,
      "ja": "10.3. OpenPGPメッセージ"
    },
    {
      "indent": 3,
      "text": "An OpenPGP Message is a packet or sequence of packets that adheres to the following grammatical rules (a comma (,) represents sequential composition, and a vertical bar (|) separates alternatives):",
      "ja": "OpenPGPメッセージは、次の文法ルールを順守するパケットまたはシーケンスのパケットまたはシーケンスです（Comma（）はシーケンシャル構成を表し、垂直バー（|）は代替を分離します）。"
    },
    {
      "indent": 3,
      "text": "OpenPGP Message:",
      "ja": "OpenPGPメッセージ："
    },
    {
      "indent": 12,
      "text": "Encrypted Message | Signed Message | Compressed Message | Literal Message.",
      "ja": "暗号化されたメッセージ|署名されたメッセージ|圧縮メッセージ|リテラルメッセージ。"
    },
    {
      "indent": 3,
      "text": "Compressed Message:",
      "ja": "圧縮メッセージ："
    },
    {
      "indent": 12,
      "text": "Compressed Data Packet.",
      "ja": "圧縮データパケット。"
    },
    {
      "indent": 3,
      "text": "Literal Message:",
      "ja": "リテラルメッセージ："
    },
    {
      "indent": 12,
      "text": "Literal Data Packet.",
      "ja": "リテラルデータパケット。"
    },
    {
      "indent": 3,
      "text": "ESK:",
      "ja": "ESK:"
    },
    {
      "indent": 12,
      "text": "Public Key Encrypted Session Key Packet | Symmetric Key Encrypted Session Key Packet.",
      "ja": "公開キー暗号化セッションキーパケット|対称キー暗号化セッションキーパケット。"
    },
    {
      "indent": 3,
      "text": "ESK Sequence:",
      "ja": "ESKシーケンス："
    },
    {
      "indent": 12,
      "text": "ESK | ESK Sequence, ESK.",
      "ja": "esk |ESKシーケンス、ESK。"
    },
    {
      "indent": 3,
      "text": "Encrypted Data:",
      "ja": "暗号化されたデータ："
    },
    {
      "indent": 12,
      "text": "Symmetrically Encrypted Data Packet | Symmetrically Encrypted and Integrity Protected Data Packet.",
      "ja": "対称的に暗号化されたデータパケット|対称的に暗号化され、完全性保護されたデータパケット。"
    },
    {
      "indent": 3,
      "text": "Encrypted Message:",
      "ja": "暗号化されたメッセージ："
    },
    {
      "indent": 12,
      "text": "Encrypted Data | ESK Sequence, Encrypted Data.",
      "ja": "暗号化されたデータ|ESKシーケンス、暗号化されたデータ。"
    },
    {
      "indent": 3,
      "text": "One-Pass Signed Message:",
      "ja": "ワンパス署名されたメッセージ："
    },
    {
      "indent": 12,
      "text": "One-Pass Signature Packet, OpenPGP Message, Corresponding Signature Packet.",
      "ja": "ワンパス署名パケット、OpenPGPメッセージ、対応する署名パケット。"
    },
    {
      "indent": 3,
      "text": "Signed Message:",
      "ja": "署名されたメッセージ："
    },
    {
      "indent": 12,
      "text": "Signature Packet, OpenPGP Message | One-Pass Signed Message.",
      "ja": "署名パケット、OpenPGPメッセージ|ワンパスサイン付きメッセージ。"
    },
    {
      "indent": 3,
      "text": "Optionally Padded Message:",
      "ja": "オプションでパッド入りのメッセージ："
    },
    {
      "indent": 12,
      "text": "OpenPGP Message | OpenPGP Message, Padding Packet.",
      "ja": "OpenPGPメッセージ|OpenPGPメッセージ、パディングパケット。"
    },
    {
      "indent": 3,
      "text": "In addition to these rules, a Marker packet (Section 5.8) can appear anywhere in the sequence.",
      "ja": "これらのルールに加えて、マーカーパケット（セクション5.8）は、シーケンス内のどこにでも表示できます。"
    },
    {
      "indent": 0,
      "text": "10.3.1. Unwrapping Encrypted and Compressed Messages",
      "section_title": true,
      "ja": "10.3.1. 暗号化されたメッセージと圧縮メッセージの開始"
    },
    {
      "indent": 3,
      "text": "In addition to the above grammar, certain messages can be \"unwrapped\" to yield new messages. In particular:",
      "ja": "上記の文法に加えて、特定のメッセージを「包装」して新しいメッセージを生成できます。特に："
    },
    {
      "indent": 6,
      "text": "* Decrypting a version 2 Symmetrically Encrypted and Integrity Protected Data packet MUST yield a valid Optionally Padded Message.",
      "ja": "* バージョン2を対称的に暗号化し、整合性保護されたデータパケットを復号化すると、有効なオプションのパッド入りメッセージが生成される必要があります。"
    },
    {
      "indent": 6,
      "text": "* Decrypting a version 1 Symmetrically Encrypted and Integrity Protected Data packet or -- for historic data -- a Symmetrically Encrypted Data packet MUST yield a valid OpenPGP Message.",
      "ja": "* バージョン1を対称的に暗号化および整合性保護されたデータパケットを復号化するか、歴史的なデータの場合、対称的に暗号化されたデータパケットは、有効なOpenPGPメッセージを生成する必要があります。"
    },
    {
      "indent": 6,
      "text": "* Decompressing a Compressed Data packet MUST also yield a valid OpenPGP Message.",
      "ja": "* 圧縮データパケットを減圧すると、有効なOpenPGPメッセージも生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "When any unwrapping is performed, the resulting stream of octets is parsed into a series of OpenPGP packets like any other stream of octets. The packet boundaries found in the series of octets are expected to align with the length of the unwrapped octet stream. An implementation MUST NOT interpret octets beyond the boundaries of the unwrapped octet stream as part of any OpenPGP packet. If an implementation encounters a packet whose header length indicates that it would extend beyond the boundaries of the unwrapped octet stream, the implementation MUST reject that packet as malformed and unusable.",
      "ja": "アンラップが実行されると、結果のオクテットのストリームは、他のオクテットのストリームと同様に一連のopenPGPパケットに解析されます。一連のオクテットに見られるパケットの境界は、包装されていないオクテットストリームの長さと整列すると予想されます。実装は、オープンPGPパケットの一部として、アンラップされていないオクテットストリームの境界を越えてオクテットを解釈してはなりません。実装がヘッダーの長さが、包装されていないOctetストリームの境界を越えて拡張されることを示すパケットに遭遇する場合、実装はそのパケットを奇形で使用できないものとして拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.2. Additional Constraints on Packet Sequences",
      "section_title": true,
      "ja": "10.3.2. パケットシーケンスの追加の制約"
    },
    {
      "indent": 3,
      "text": "Note that some subtle combinations that are formally acceptable by this grammar are nonetheless unacceptable.",
      "ja": "この文法で正式に受け入れられる微妙な組み合わせは、それでも受け入れられないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "10.3.2.1. Packet Versions in Encrypted Messages",
      "section_title": true,
      "ja": "10.3.2.1. 暗号化されたメッセージのパケットバージョン"
    },
    {
      "indent": 3,
      "text": "As noted above, an Encrypted Message is a sequence of zero or more PKESK packets (Section 5.1) and SKESK packets (Section 5.3), followed by an SEIPD (Section 5.13) payload. In some historic data, the payload may be a deprecated SED packet (Section 5.7) instead of SEIPD, though implementations MUST NOT generate SED packets (see Section 13.7). The versions of the preceding ESK packets within an Encrypted Message MUST align with the version of the payload SEIPD packet, as described in this section.",
      "ja": "上記のように、暗号化されたメッセージは、ゼロ以上のPKSEKパケット（セクション5.1）とSkeskパケット（セクション5.3）のシーケンスであり、その後にSEIPD（セクション5.13）ペイロードが続きます。一部の歴史的なデータでは、ペイロードはSEIPDの代わりに非推奨SEDパケット（セクション5.7）である場合がありますが、実装はSEDパケットを生成してはなりません（セクション13.7を参照）。暗号化されたメッセージ内の前述のESKパケットのバージョンは、このセクションで説明されているように、ペイロードSEIPDパケットのバージョンと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "v3 PKESK and v4 SKESK packets both contain the Symmetric Cipher Algorithm ID and the session key for the subsequent SEIPD packet in their cleartext. Since a v1 SEIPD does not contain a symmetric algorithm ID, all ESK packets preceding a v1 SEIPD payload MUST be either v3 PKESK or v4 SKESK.",
      "ja": "V3 PKSEKおよびV4 Skeskパケットには、両方とも対称暗号アルゴリズムIDと、その後のSEIPDパケットのClearTextのセッションキーが含まれています。V1 SEIPDには対称アルゴリズムIDが含まれていないため、V1 SEIPDペイロードに先行するすべてのESKパケットはV3 PKESKまたはV4 Skeskのいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "On the other hand, the cleartext of the v6 ESK packets (either PKESK or SKESK) do not contain a Symmetric Cipher Algorithm ID, so they cannot be used in combination with a v1 SEIPD payload. The payload following any v6 PKESK or v6 SKESK packet MUST be a v2 SEIPD.",
      "ja": "一方、V6 ESKパケットのクリアテキスト（PKESKまたはSKESKのいずれか）には、対称的な暗号アルゴリズムIDが含まれていないため、V1 SEIPDペイロードと組み合わせて使用することはできません。V6 PKESKまたはV6 Skeskパケットに続くペイロードは、V2 SEIPDでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Additionally, to avoid potentially conflicting cipher algorithm IDs, and for simplicity, implementations MUST NOT precede a v2 SEIPD payload with either v3 PKESK or v4 SKESK packets.",
      "ja": "さらに、潜在的に矛盾する暗号アルゴリズムIDを回避し、簡単にするために、実装はV3 PKESKまたはV4 Skeskパケットのいずれかを使用してV2 SEIPDペイロードに先行してはなりません。"
    },
    {
      "indent": 3,
      "text": "The versions of packets found in an Encrypted Message are summarized in the following table. An implementation MUST only generate an Encrypted Message using packet versions that match a row with \"Yes\" in the \"Generate?\" column. Other rows are provided for the purpose of historic interoperability. A conforming implementation MUST only generate an Encrypted Message using packets whose versions correspond to a single row.",
      "ja": "暗号化されたメッセージにあるパケットのバージョンを次の表にまとめます。実装は、行を「はい」と「generate？」と一致させるパケットバージョンを使用して、暗号化されたメッセージを生成する必要があります。カラム。他の行は、歴史的な相互運用性を目的として提供されます。適合実装は、バージョンが単一の行に対応するパケットを使用して暗号化されたメッセージのみを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "+==============+=====================+==================+===========+\n| Version of   | Version of          | Version of       | Generate? |\n| Encrypted    | Preceding Symmetric | Preceding        |           |\n| Data Payload | Key ESK (If Any)    | Public Key       |           |\n|              |                     | ESK (If Any)     |           |\n+==============+=====================+==================+===========+\n| SED (Section | -                   | v2 PKESK         | No        |\n| 5.7)         |                     | [RFC2440]        |           |\n+--------------+---------------------+------------------+-----------+\n| SED (Section | v4 SKESK            | v3 PKESK         | No        |\n| 5.7)         | (Section 5.3.1)     | (Section         |           |\n|              |                     | 5.1.1)           |           |\n+--------------+---------------------+------------------+-----------+\n| v1 SEIPD     | v4 SKESK            | v3 PKESK         | Yes       |\n| (Section     | (Section 5.3.1)     | (Section         |           |\n| 5.13.1)      |                     | 5.1.1)           |           |\n+--------------+---------------------+------------------+-----------+\n| v2 SEIPD     | v6 SKESK            | v6 PKESK         | Yes       |\n| (Section     | (Section 5.3.2)     | (Section         |           |\n| 5.13.2)      |                     | 5.1.2)           |           |\n+--------------+---------------------+------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Table 26: OpenPGP Encrypted Message Packet Versions Registry",
      "ja": "表26：OpenPGP暗号化されたメッセージパケットバージョンレジストリ"
    },
    {
      "indent": 3,
      "text": "An implementation processing an Encrypted Message MUST discard any preceding ESK packet with a version that does not align with the version of the payload.",
      "ja": "実装処理暗号化されたメッセージは、Payloadのバージョンと一致しないバージョンを使用して、前のESKパケットを破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.2.2. Packet Versions in Signatures",
      "section_title": true,
      "ja": "10.3.2.2. 署名のパケットバージョン"
    },
    {
      "indent": 3,
      "text": "OpenPGP Key packets and Signature packets are also versioned. The version of a Signature typically matches the version of the signing key. When a version 6 key produces a Signature packet, it MUST produce a version 6 Signature packet, regardless of the Signature packet type. When a message is signed or verified using the one-pass construction, the version of the One-Pass Signature packet (Section 5.4) should also be aligned to the other versions.",
      "ja": "OpenPGPキーパケットと署名パケットもバージョンにされています。署名のバージョンは通常、署名キーのバージョンと一致します。バージョン6キーが署名パケットを作成する場合、署名パケットタイプに関係なく、バージョン6の署名パケットを作成する必要があります。ワンパス構造を使用してメッセージに署名または検証された場合、ワンパスシグネチャパケット（セクション5.4）のバージョンも他のバージョンに合わせる必要があります。"
    },
    {
      "indent": 3,
      "text": "Some legacy implementations have produced unaligned signature versions for older key material, which are also described in the table below for the purpose of historic interoperability. A conforming implementation MUST only generate Signature packets with version numbers matching rows with \"Yes\" in the \"Generate?\" column.",
      "ja": "一部のレガシーの実装では、古いキーマテリアル向けに整理されていない署名バージョンが作成されています。これは、歴史的な相互運用性を目的として以下の表にも説明されています。適合実装では、「generate？」の「はい」と行列を一致させるバージョン番号を持つ署名パケットのみを生成する必要があります。カラム。"
    },
    {
      "indent": 5,
      "text": "+=====================+================+============+===========+\n| Signing Key Version | Signature      | OPS Packet | Generate? |\n|                     | Packet Version | Version    |           |\n+=====================+================+============+===========+\n| 3 (Section 5.5.2.1) | 3 (Section     | 3 (Section | No        |\n|                     | 5.2.2)         | 5.4)       |           |\n+---------------------+----------------+------------+-----------+\n| 4 (Section 5.5.2.2) | 3 (Section     | 3 (Section | No        |\n|                     | 5.2.2)         | 5.4)       |           |\n+---------------------+----------------+------------+-----------+\n| 4 (Section 5.5.2.2) | 4 (Section     | 3 (Section | Yes       |\n|                     | 5.2.3)         | 5.4)       |           |\n+---------------------+----------------+------------+-----------+\n| 6 (Section 5.5.2.3) | 6 (Section     | 6 (Section | Yes       |\n|                     | 5.2.3)         | 5.4)       |           |\n+---------------------+----------------+------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 27: OpenPGP Key and Signature Versions Registry",
      "ja": "表27：OpenPGPキーおよび署名バージョンレジストリ"
    },
    {
      "indent": 3,
      "text": "Note, however, that a version mismatch between these packets does not invalidate the packet sequence as a whole; it merely invalidates the signature, as a signature with an unknown version SHOULD be discarded (see Section 5.2.5).",
      "ja": "ただし、これらのパケット間のバージョンの不一致は、全体としてパケットシーケンスを無効にしないことに注意してください。未知のバージョンの署名を破棄する必要があるため、署名を単に無効にします（セクション5.2.5を参照）。"
    },
    {
      "indent": 0,
      "text": "10.4. Detached Signatures",
      "section_title": true,
      "ja": "10.4. 分離した署名"
    },
    {
      "indent": 3,
      "text": "Some OpenPGP applications use so-called \"detached signatures\". For example, a program bundle may contain a file, and with it a second file that is a detached signature of the first file. These detached signatures are simply one or more Signature packets stored separately from the data for which they are a signature.",
      "ja": "一部のOpenPGPアプリケーションでは、いわゆる「デタッチされた署名」を使用しています。たとえば、プログラムバンドルにはファイルが含まれている場合があります。これには、最初のファイルの署名が分離された2番目のファイルが含まれます。これらの分離された署名は、署名であるデータとは別に保存された1つまたは複数の署名パケットです。"
    },
    {
      "indent": 3,
      "text": "In addition, a Marker packet (Section 5.8) and a Padding packet (Section 5.14) can appear anywhere in the sequence.",
      "ja": "さらに、マーカーパケット（セクション5.8）とパディングパケット（セクション5.14）は、シーケンス内のどこにでも表示できます。"
    },
    {
      "indent": 0,
      "text": "11. Elliptic Curve Cryptography",
      "section_title": true,
      "ja": "11. 楕円曲線暗号化"
    },
    {
      "indent": 3,
      "text": "This section describes algorithms and parameters used with Elliptic Curve Cryptography (ECC) keys. A thorough introduction to ECC can be found in [KOBLITZ]. Refer to [FIPS186], Appendix B.4, for the methods to generate a uniformly distributed ECC private key.",
      "ja": "このセクションでは、楕円曲線暗号化（ECC）キーで使用されるアルゴリズムとパラメーターについて説明します。ECCの徹底的な紹介は[Koblitz]にあります。[FIPS186]、付録B.4を参照してください。均一に分布したECC秘密キーを生成する方法については。"
    },
    {
      "indent": 3,
      "text": "None of the ECC methods described in this document are allowed with deprecated version 3 keys.",
      "ja": "このドキュメントで説明されているECCメソッドはいずれも、非推奨バージョン3キーで許可されていません。"
    },
    {
      "indent": 0,
      "text": "11.1. ECC Curves",
      "section_title": true,
      "ja": "11.1. ECC曲線"
    },
    {
      "indent": 3,
      "text": "This document references three named prime field curves defined in [FIPS186] as \"Curve P-256\", \"Curve P-384\", and \"Curve P-521\" and three named prime field curves defined in [RFC5639] as \"brainpoolP256r1\", \"brainpoolP384r1\", and \"brainpoolP512r1\". All six curves can be used with ECDSA and ECDH public key algorithms. They are referenced using a sequence of octets, referred to as the curve OID. Section 9.2 describes in detail how this sequence of octets is formed.",
      "ja": "このドキュメントは、[FIPS186]で定義された3つの名前付きプライムフィールド曲線を「曲線P-256」、「曲線P-384」、および「曲線P-521」として参照し、[RFC5639]で定義された3つの名前付きプライムフィールド曲線を「BrainPoolp256R1」として参照してください。、「BrainPoolP384R1」、および「BrainPoolp512R1」。6つの曲線はすべて、ECDSAおよびECDH公開キーアルゴリズムで使用できます。それらは、曲線oidと呼ばれる一連のオクテットを使用して参照されます。セクション9.2では、このオクテットのシーケンスがどのように形成されるかを詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "Separate algorithms are also defined for the use of X25519 and X448 [RFC7748] and Ed25519 and Ed448 [RFC8032]. Additionally, legacy OIDs are defined for \"Curve25519Legacy\" (for encryption using the ECDH algorithm) and \"Ed25519Legacy\" (for signing using the EdDSALegacy algorithm).",
      "ja": "x25519およびx448 [RFC7748]およびED25519およびED448 [RFC8032]を使用するために、個別のアルゴリズムも定義されています。さらに、レガシーOIDは、「Curve25519Legacy」（ECDHアルゴリズムを使用した暗号化用）および「ED25519Legacy」（Eddsalegacyアルゴリズムを使用して署名する場合）で定義されます。"
    },
    {
      "indent": 0,
      "text": "11.2. EC Point Wire Formats",
      "section_title": true,
      "ja": "11.2. ECポイントワイヤ形式"
    },
    {
      "indent": 3,
      "text": "A point on an elliptic curve will always be represented on the wire as an MPI. Each curve uses a specific point format for the data within the MPI itself. Each format uses a designated prefix octet to ensure that the high octet has at least 1 bit set to make the MPI a constant size.",
      "ja": "楕円曲線のポイントは、常にMPIとしてワイヤー上に表されます。各曲線は、MPI自体内のデータに対して特定のポイント形式を使用します。各フォーマットは、指定されたプレフィックスオクテットを使用して、高オクテットに少なくとも1ビットが設定されてMPIを一定のサイズにすることを確認します。"
    },
    {
      "indent": 11,
      "text": "+=================+================+================+\n|            Name | Wire Format    | Reference      |\n+=================+================+================+\n|            SEC1 | 0x04 || x || y | Section 11.2.1 |\n+-----------------+----------------+----------------+\n| Prefixed native | 0x40 || native | Section 11.2.2 |\n+-----------------+----------------+----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 28: OpenPGP Elliptic Curve Point Wire Formats Registry",
      "ja": "表28：OpenPGP楕円曲線ポイントワイヤーフォーマットレジストリ"
    },
    {
      "indent": 0,
      "text": "11.2.1. SEC1 EC Point Wire Format",
      "section_title": true,
      "ja": "11.2.1. SEC1 ECポイントワイヤ形式"
    },
    {
      "indent": 3,
      "text": "For a SEC1-encoded (uncompressed) point, the content of the MPI is:",
      "ja": "SEC1エンコード（非圧縮）ポイントの場合、MPIの内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "B = 04 || x || y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where x and y are coordinates of the point P = (x, y), and each is encoded in the big-endian format and zero-padded to the adjusted underlying field size. The adjusted underlying field size is the underlying field size rounded up to the nearest 8-bit boundary, as noted in the \"fsize\" column in Section 9.2. This encoding is compatible with the definition given in [SEC1].",
      "ja": "ここで、xとyはポイントp =（x、y）の座標であり、それぞれがビッグエンディアン形式でエンコードされ、調整された基礎となるフィールドサイズにゼロパッドされます。調整された基礎となるフィールドサイズは、セクション9.2の「fsize」列に記載されているように、最も近い8ビット境界まで丸められた基礎となるフィールドサイズです。このエンコードは、[SEC1]で与えられた定義と互換性があります。"
    },
    {
      "indent": 0,
      "text": "11.2.2. Prefixed Native EC Point Wire Format",
      "section_title": true,
      "ja": "11.2.2. 接頭辞ネイティブECポイントワイヤ形式"
    },
    {
      "indent": 3,
      "text": "For a custom compressed point, the content of the MPI is:",
      "ja": "カスタム圧縮ポイントの場合、MPIの内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "B = 40 || p",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where p is the public key of the point encoded using the rules defined for the specified curve. This format is used for ECDH keys based on curves expressed in Montgomery form and for points when using EdDSA.",
      "ja": "ここで、Pは指定された曲線に対して定義されたルールを使用してエンコードされたポイントの公開キーです。この形式は、モンゴメリー形式で表現された曲線に基づいたECDHキーとEDDSAを使用する際のポイントに使用されます。"
    },
    {
      "indent": 0,
      "text": "11.2.3. Notes on EC Point Wire Formats",
      "section_title": true,
      "ja": "11.2.3. ECポイントワイヤ形式に関するメモ"
    },
    {
      "indent": 3,
      "text": "Given the above definitions, the exact size of the MPI payload for an encoded point is 515 bits for both NIST P-256 and brainpoolP256r1, 771 for both NIST P-384 and brainpoolP384r1, 1059 for NIST P-521, 1027 for brainpoolP512r1, and 263 for both Curve25519Legacy and Ed25519Legacy. For example, the length of an EdDSALegacy public key for the curve Ed25519Legacy is 263 bits: 7 bits to represent the 0x40 prefix octet and 32 octets for the native value of the public key.",
      "ja": "上記の定義を考慮すると、エンコードされたポイントのMPIペイロードの正確なサイズは、NIST P-256とBrainpoolp256R1の両方で515ビット、NIST P-384とBrainpoolp384R1の両方で771、NIST P-521、Brainpoolp512R1および1027の両方で1059であり、263 Curve25519LegacyとED25519Legacyの両方。たとえば、曲線のEddsalegacyの公開鍵の長さED25519legacyは263ビットです：7ビットは、公開キーのネイティブ値の0x40プレフィックスオクテットと32オクテットを表す7ビットです。"
    },
    {
      "indent": 3,
      "text": "Even though the zero point (also called the \"point at infinity\") may occur as a result of arithmetic operations on points of an elliptic curve, it SHALL NOT appear in data structures defined in this document.",
      "ja": "ゼロポイント（「インフィニティのポイント」とも呼ばれます）は、楕円曲線のポイント上の算術操作の結果として発生する可能性がありますが、このドキュメントで定義されているデータ構造には表示されません。"
    },
    {
      "indent": 3,
      "text": "Each particular curve uses a designated wire format for the point found in its public key or ECDH data structure. An implementation MUST NOT use a different wire format for a point other than the wire format associated with the curve.",
      "ja": "各特定の曲線は、公開キーまたはECDHデータ構造にあるポイントに指定されたワイヤ形式を使用します。実装は、曲線に関連付けられたワイヤ形式以外のポイントに対して、別のワイヤ形式を使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "11.3. EC Scalar Wire Formats",
      "section_title": true,
      "ja": "11.3. ECスカラーワイヤ形式"
    },
    {
      "indent": 3,
      "text": "Some non-curve values in elliptic curve cryptography (for example, secret keys and signature components) are not points on a curve, but they are also encoded on the wire in OpenPGP as an MPI.",
      "ja": "楕円曲線暗号化（たとえば、シークレットキーや署名コンポーネントなど）の一部の非曲線値は、曲線上のポイントではありませんが、MPIとしてOpenPGPのワイヤー上にエンコードされています。"
    },
    {
      "indent": 3,
      "text": "Because of different patterns of deployment, some curves treat these values as opaque bit strings with the high bit set, while others are treated as actual integers, encoded in the standard OpenPGP big-endian form. The choice of encoding is specific to the public key algorithm in use.",
      "ja": "展開のパターンが異なるため、一部の曲線は、これらの値をハイビットセットの不透明なビット文字列として扱いますが、他の曲線は実際の整数として扱われ、標準のOpenPGPのビッグエンディアン形式でエンコードされています。エンコーディングの選択は、使用中の公開キーアルゴリズムに固有です。"
    },
    {
      "indent": 3,
      "text": "+==========+===========================================+===========+\n| Type     | Description                               | Reference |\n+==========+===========================================+===========+\n| integer  | An integer encoded in big-endian format   | Section   |\n|          | as a standard OpenPGP MPI                 | 3.2       |\n+----------+-------------------------------------------+-----------+\n| octet    | An octet string of fixed length that may  | Section   |\n| string   | be shorter on the wire due to leading     | 11.3.1    |\n|          | zeros being stripped by the MPI encoding  |           |\n|          | and may need to be zero-padded before use |           |\n+----------+-------------------------------------------+-----------+\n| prefixed | An octet string of fixed length N,        | Section   |\n| N octets | prefixed with octet 0x40 to ensure no     | 11.3.2    |\n|          | leading zero octet                        |           |\n+----------+-------------------------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Table 29: OpenPGP Elliptic Curve Scalar Encodings Registry",
      "ja": "表29：OpenPGP楕円曲線スカラーエンコーディングレジストリ"
    },
    {
      "indent": 0,
      "text": "11.3.1. EC Octet String Wire Format",
      "section_title": true,
      "ja": "11.3.1. ECオクテットストリングワイヤ形式"
    },
    {
      "indent": 3,
      "text": "Some opaque strings of octets are represented on the wire as an MPI by simply stripping the leading zeros and counting the remaining bits. These strings are of known, fixed length. They are represented in this document as MPI(N octets of X), where N is the expected length in octets of the octet string.",
      "ja": "オクテットの不透明な文字列は、単に主要なゼロを剥ぎ取り、残りのビットをカウントすることにより、MPIとしてワイヤー上に表されます。これらの文字列は、既知の固定長です。このドキュメントでは、MPI（Xのnオクテット）として表されます。ここで、nはオクテット弦のオクテットの予想される長さです。"
    },
    {
      "indent": 3,
      "text": "For example, a 5-octet opaque string (MPI(5 octets of X)) where X has the value 00 02 EE 19 00 would be represented on the wire as an MPI like so: 00 1A 02 EE 19 00.",
      "ja": "たとえば、xが値00 02 ee 19 00を持っている5-OCTET不透明な文字列（MPI（Xの5オクテット））は、そのようなMPIとしてワイヤに表されます：00 1A 02 EE 19 00。"
    },
    {
      "indent": 3,
      "text": "To encode X to the wire format, set the MPI's 2-octet bit counter to the value of the highest set bit (bit 26, or 0x001A), and do not transfer the leading all-zero octet to the wire.",
      "ja": "Xをワイヤ形式にエンコードするには、MPIの2-OCTETビットカウンターを最高のセットビット（ビット26、または0x001a）の値に設定し、先頭の全ゼロオクテットをワイヤーに転送しないでください。"
    },
    {
      "indent": 3,
      "text": "To reverse the process, an implementation can take the following steps, if it knows that X has an expected length of, for example, 5 octets:",
      "ja": "プロセスを逆転させるために、xが予想される長さの5オクテットを持っていることがわかっている場合、実装は次の手順を実行できます。"
    },
    {
      "indent": 6,
      "text": "* Ensure that the MPI's 2-octet bit count is less than or equal to 40 (5 octets of 8 bits)",
      "ja": "* MPIの2-OCTETビットカウントが40（8ビットの5オクテット）以下であることを確認してください"
    },
    {
      "indent": 6,
      "text": "* Allocate 5 octets, setting all to zero initially",
      "ja": "* 5オクテットを割り当て、最初にすべてをゼロに設定します"
    },
    {
      "indent": 6,
      "text": "* Copy the MPI data octets (without the two count octets) into the lower octets of the allocated space",
      "ja": "* MPIデータオクテット（2つのカウントオクテットなし）を割り当てられたスペースの下部オクテットにコピーします"
    },
    {
      "indent": 0,
      "text": "11.3.2. EC Prefixed Octet String Wire Format",
      "section_title": true,
      "ja": "11.3.2. ECプレフィックスされたOctet Stringワイヤ形式"
    },
    {
      "indent": 3,
      "text": "Another way to ensure that a fixed-length bytes string is encoded simply to the wire while remaining in MPI format is to prefix the byte string with a dedicated non-zero octet. This specification uses 0x40 as the prefix octet. This is represented in this specification as MPI(prefixed N octets of X), where N is the known byte string length.",
      "ja": "MPI形式のままにしている間に、固定長バイト文字列が単にワイヤにエンコードされることを確認する別の方法は、専用の非ゼロオクテットでバイト文字列に接頭することです。この仕様では、0x40をプレフィックスオクテットとして使用します。これは、この仕様ではMPI（Xの接頭辞Nオクテット）として表されます。ここで、nは既知のバイト文字列長です。"
    },
    {
      "indent": 3,
      "text": "For example, a 5-octet opaque string using MPI(prefixed 5 octets of X) where X has the value 00 02 EE 19 00 would be written to the wire form as: 00 2F 40 00 02 EE 19 00.",
      "ja": "たとえば、MPI（Xの5オクテット5オクテット）を使用した5オクテットの不透明な文字列は、xが値00 02 EE 19 00を使用して、00 2f 40 00 02 EE 19 00としてワイヤフォームに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "To encode the string, prefix it with the octet 0x40 (whose 7th bit is set), and then set the MPI's 2-octet bit counter to 47 (0x002F -- 7 bits for the prefix octet and 40 bits for the string).",
      "ja": "文字列をエンコードするには、Octet 0x40（7番目のビットが設定されている）で接頭辞を付け、MPIの2-OCTETビットを47に設定します（プレフィックスオクテットでは0x002F-7ビット、文字列の40ビット）。"
    },
    {
      "indent": 3,
      "text": "To decode the string from the wire, an implementation that knows that the variable is formed in this way can:",
      "ja": "ワイヤーから文字列をデコードするには、この方法で変数が形成されることを知っている実装は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* ensure that the first three octets of the MPI (the 2-bit count octets plus the prefix octet) are 00 2F 40, and",
      "ja": "* MPIの最初の3オクテット（2ビットカウントオクテットとプレフィックスオクテット）が00 2f 40であることを確認し、"
    },
    {
      "indent": 6,
      "text": "* use the remainder of the MPI directly off the wire.",
      "ja": "* MPIの残りを直接ワイヤーから使用します。"
    },
    {
      "indent": 3,
      "text": "Note that this is a similar approach to that used in the EC point encodings found in Section 11.2.2.",
      "ja": "これは、セクション11.2.2で見つかったECポイントエンコーディングで使用されるアプローチと同様のアプローチであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "11.4. Key Derivation Function",
      "section_title": true,
      "ja": "11.4. キー派生関数"
    },
    {
      "indent": 3,
      "text": "A key derivation function (KDF) is necessary to implement EC encryption. The Concatenation Key Derivation Function (Approved Alternative 1) [SP800-56A] with the KDF hash function that is SHA2-256 [FIPS180] or stronger is REQUIRED.",
      "ja": "EC暗号化を実装するには、キー派生関数（KDF）が必要です。SHA2-256 [FIPS180]またはより強力なKDFハッシュ関数を使用した、連結キー導出関数（承認された代替1）[SP800-56A]が必要です。"
    },
    {
      "indent": 3,
      "text": "For convenience, the synopsis of the encoding method is given below with significant simplifications attributable to the restricted choice of hash functions in this document. However, [SP800-56A] is the normative source of the definition.",
      "ja": "便利なため、エンコード法の概要は、このドキュメントのハッシュ関数の制限された選択に起因する重要な単純化を備えています。ただし、[SP800-56A]は定義の規範的なソースです。"
    },
    {
      "indent": 3,
      "text": "//   Implements KDF( X, oBits, Param );\n//   Input: point X = (x,y)\n//   oBits - the desired size of output\n//   hBits - the size of output of hash function Hash\n//   Param - octets representing the parameters\n//   Assumes that oBits <= hBits\n// Convert the point X to the octet string:\n//   ZB' = 04 || x || y\n// and extract the x portion from ZB'\nZB = x;\nMB = Hash ( 00 || 00 || 00 || 01 || ZB || Param );\nreturn oBits leftmost bits of MB.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that ZB in the KDF description above is the compact representation of X as defined in Section 4.2 of [RFC6090].",
      "ja": "上記のKDF説明のZBは、[RFC6090]のセクション4.2で定義されているXのコンパクトな表現であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "11.5. ECDH Algorithm",
      "section_title": true,
      "ja": "11.5. ECDHアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This section describes the One-Pass Diffie-Hellman method, which is a combination of the ECC Diffie-Hellman method that establishes a shared secret and the key derivation method that processes the shared secret into a derived key. Additionally, this section describes a key wrapping method that uses the derived key to protect a session key used to encrypt a message.",
      "ja": "このセクションでは、1パスDiffie-Hellmanメソッドについて説明します。これは、共有秘密を確立するECC Diffie-Hellmanメソッドと、共有秘密を派生キーに処理するキー派生方法を確立する組み合わせです。さらに、このセクションでは、派生キーを使用してメッセージを暗号化するために使用されるセッションキーを保護するキーラッピング方法について説明します。"
    },
    {
      "indent": 3,
      "text": "The One-Pass Diffie-Hellman method C(1, 1, ECC CDH) [SP800-56A] MUST be implemented with the following restrictions: the ECC Cofactor Diffie-Hellman (CDH) primitive employed by this method is modified to always assume the cofactor is 1, the KDF specified in Section 11.4 is used, and the KDF parameters specified below are used.",
      "ja": "ワンパスdiffie-hellmanメソッドC（1、1、ECC CDH）[SP800-56A]は、次の制限で実装する必要があります。補因子は1で、セクション11.4で指定されたKDFが使用され、以下に指定されたKDFパラメーターが使用されます。"
    },
    {
      "indent": 3,
      "text": "The KDF parameters are encoded as a concatenation of the following 5 variable-length and fixed-length fields, which are compatible with the definition of the OtherInfo bit string [SP800-56A]:",
      "ja": "KDFパラメーターは、次の5つの可変長および固定長フィールドの連結としてエンコードされており、他のビット文字列[SP800-56A]の定義と互換性があります。"
    },
    {
      "indent": 6,
      "text": "* A variable-length field containing a curve OID, which is formatted as follows:",
      "ja": "* 次のようにフォーマットされている曲線oidを含む可変長さフィールド："
    },
    {
      "indent": 12,
      "text": "- A 1-octet size of the following field.",
      "ja": "- 次のフィールドの1-OCTETサイズ。"
    },
    {
      "indent": 12,
      "text": "- The octets representing a curve OID, as defined in Section 9.2.",
      "ja": "- セクション9.2で定義されているように、曲線OIDを表すオクテット。"
    },
    {
      "indent": 6,
      "text": "* A 1-octet public key algorithm ID, as defined in Section 9.1.",
      "ja": "* セクション9.1で定義されている1-OCTET公開キーアルゴリズムID。"
    },
    {
      "indent": 6,
      "text": "* A variable-length field containing KDF parameters, which are identical to the corresponding field in the ECDH public key and formatted as follows:",
      "ja": "* ECDH公開キーの対応するフィールドと同一であり、次のようにフォーマットされたKDFパラメーターを含む可変長さのフィールド："
    },
    {
      "indent": 12,
      "text": "- A 1-octet size of the following fields; values 0 and 0xFF are reserved for future extensions.",
      "ja": "- 次のフィールドの1オクテットサイズ。値0および0xffは、将来の拡張機能のために予約されています。"
    },
    {
      "indent": 12,
      "text": "- A 1-octet value 0x01, reserved for future extensions.",
      "ja": "- 将来の拡張用に予約されている1-OCTET値0x01。"
    },
    {
      "indent": 12,
      "text": "- A 1-octet hash function ID used with the KDF.",
      "ja": "- KDFで使用される1-OCTETハッシュ関数ID。"
    },
    {
      "indent": 12,
      "text": "- A 1-octet algorithm ID for the symmetric algorithm that is used to wrap the symmetric key for message encryption; see Section 11.5 for details.",
      "ja": "- メッセージ暗号化の対称キーをラップするために使用される対称アルゴリズムの1-OCTETアルゴリズムID。詳細については、セクション11.5を参照してください。"
    },
    {
      "indent": 6,
      "text": "* 20 octets representing the UTF-8 encoding of the string \"Anonymous Sender\" padded at the end with spaces (0x20) to 20 octets, which is the octet sequence 41 6E 6F 6E 79 6D 6F 75 73 20 53 65 6E 64 65 72 20 20 20 20.",
      "ja": "* 20オクテットは、端にスペース（0x20）から20オクテットでパディングされた文字列「匿名送信者」のUTF-8エンコードを表します。20 20 20。"
    },
    {
      "indent": 6,
      "text": "* A variable-length field containing the fingerprint of the recipient encryption subkey identifying the key material that is needed for decryption. For version 4 keys, this field is 20 octets. For version 6 keys, this field is 32 octets.",
      "ja": "* 復号化に必要な重要な材料を識別する、受信者暗号化のサブキーの指紋を含む可変長さのフィールド。バージョン4キーの場合、このフィールドは20オクテットです。バージョン6キーの場合、このフィールドは32オクテットです。"
    },
    {
      "indent": 3,
      "text": "The size in octets of the KDF parameters sequence, as defined above, for encrypting to a version 4 key is 54 for curve NIST P-256; 51 for curves NIST P-384 and NIST P-521; 55 for curves brainpoolP256r1, brainpoolP384r1, and brainpoolP512r1; or 56 for Curve25519Legacy. For encrypting to a version 6 key, the size of the sequence is 66 for curve NIST P-256; 63 for curves NIST P-384 and NIST P-521; or 67 for curves brainpoolP256r1, brainpoolP384r1, and brainpoolP512r1.",
      "ja": "バージョン4キーに暗号化するためのKDFパラメーターシーケンスのオクテットのサイズは、曲線NIST P-256の場合は54です。51カーブの場合、NIST P-384およびNIST P-521。55 Brainpoolp256R1、Brainpoolp384r1、およびBrainpoolp512R1の場合。またはCurve25519Legacyの場合は56。バージョン6キーに暗号化する場合、シーケンスのサイズは、曲線NIST P-256の場合は66です。63曲線NIST P-384およびNIST P-521の場合。または、曲線の67 Brainpoolp256R1、Brainpoolp384R1、およびBrainpoolp512R1の場合。"
    },
    {
      "indent": 3,
      "text": "The key wrapping method is described in [RFC3394]. The KDF produces a symmetric key that is used as a KEK as specified in [RFC3394]. Refer to Section 11.5.1 for the details regarding the choice of the KEK algorithm, which SHOULD be one of the three AES algorithms. Key wrapping and unwrapping is performed with the default initial value of [RFC3394].",
      "ja": "重要なラッピング方法は[RFC3394]で説明されています。KDFは、[RFC3394]で指定されているようにKEKとして使用される対称キーを生成します。Kekアルゴリズムの選択に関する詳細については、セクション11.5.1を参照してください。これは、3つのAESアルゴリズムの1つである必要があります。[RFC3394]のデフォルトの初期値でキーラッピングとアンラッピングが実行されます。"
    },
    {
      "indent": 3,
      "text": "To produce the input to the key wrapping method, first concatenate the following values:",
      "ja": "主要なラッピング方法への入力を生成するには、最初に次の値を連結します。"
    },
    {
      "indent": 6,
      "text": "* The 1-octet algorithm identifier, if it was passed (in the case of a v3 PKESK packet).",
      "ja": "* 1-OCTETアルゴリズム識別子は、渡された場合（V3 PKSKパケットの場合）。"
    },
    {
      "indent": 6,
      "text": "* The session key.",
      "ja": "* セッションキー。"
    },
    {
      "indent": 6,
      "text": "* A 2-octet checksum of the session key, equal to the sum of the session key octets, modulo 65536.",
      "ja": "* セッションキーの2オクテットチェックサム、セッションキーオクテットの合計、Modulo 65536。"
    },
    {
      "indent": 3,
      "text": "Then, the above values are padded to an 8-octet granularity using the method described in [RFC8018].",
      "ja": "次に、上記の値は、[RFC8018]で説明されている方法を使用して、8オクテットの粒度にパッドで埋められます。"
    },
    {
      "indent": 3,
      "text": "For example, in a version 3 Public Key Encrypted Session Key packet, an AES-256 session key is encoded as follows, forming a 40-octet sequence:",
      "ja": "たとえば、バージョン3の公開キー暗号化セッションキーパケットでは、AES-256セッションキーが次のようにエンコードされ、40オクテットシーケンスが形成されます。"
    },
    {
      "indent": 3,
      "text": "09 k0 k1 ... k31 s0 s1 05 05 05 05 05",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The octets k0 to k31 above denote the session key, and the octets s0 and s1 denote the checksum of the session key octets. This encoding allows the sender to obfuscate the size of the symmetric encryption key used to encrypt the data. For example, assuming that an AES algorithm is used for the session key, the sender MAY use 21, 13, and 5 octets of padding for AES-128, AES-192, and AES-256, respectively, to provide the same number of octets, 40 total, as an input to the key wrapping method.",
      "ja": "上記のオクテットk0からk31はセッションキーを示し、オクテットS0とS1はセッションキーオクテットのチェックサムを示します。このエンコードにより、送信者はデータの暗号化に使用される対称暗号化キーのサイズを難読化できます。たとえば、AESアルゴリズムがセッションキーに使用されていると仮定すると、送信者は、それぞれAES-128、AES-192、およびAES-256に21、13、および5オクツーのパディングを使用して、同じ数のものを提供することができます。キーラッピング方法への入力としてのオクテット、合計40。"
    },
    {
      "indent": 3,
      "text": "In a version 6 Public Key Encrypted Session Key packet, the symmetric algorithm is not included, as described in Section 5.1. For example, an AES-256 session key would be composed as follows:",
      "ja": "セクション5.1で説明されているように、バージョン6の公開キー暗号化セッションキーパケットでは、対称アルゴリズムは含まれていません。たとえば、AES-256セッションキーは次のように構成されます。"
    },
    {
      "indent": 3,
      "text": "k0 k1 ... k31 s0 s1 06 06 06 06 06 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The octets k0 to k31 above again denote the session key, and the octets s0 and s1 denote the checksum. In this case, assuming that an AES algorithm is used for the session key, the sender MAY use 22, 14, and 6 octets of padding for AES-128, AES-192, and AES-256, respectively, to provide the same number of octets, 40 total, as an input to the key wrapping method.",
      "ja": "上記のOctets K0からK31は再びセッションキーを示し、Octets S0とS1はチェックサムを示します。この場合、AESアルゴリズムがセッションキーに使用されていると仮定すると、送信者は、それぞれAES-128、AES-192、およびAES-256に22、14、および6オクツーのパディングを使用して、同じ数を提供することができます。キーラッピング方法への入力として、合計40のオクテットの。"
    },
    {
      "indent": 3,
      "text": "The output of the method consists of two fields. The first field is the MPI containing the ephemeral key used to establish the shared secret. The second field is composed of the following two subfields:",
      "ja": "メソッドの出力は、2つのフィールドで構成されています。最初のフィールドは、共有秘密を確立するために使用される一時的な鍵を含むMPIです。2番目のフィールドは、次の2つのサブフィールドで構成されています。"
    },
    {
      "indent": 6,
      "text": "* One octet encoding the size in octets of the result of the key wrapping method; the value 255 is reserved for future extensions.",
      "ja": "* 主要なラッピング方法の結果のオクテットのサイズをコードする1つのオクテット。値255は、将来の拡張機能のために予約されています。"
    },
    {
      "indent": 6,
      "text": "* Up to 254 octets representing the result of the key wrapping method, applied to the 8-octet padded session key, as described above.",
      "ja": "* 上記のように、8オクテットのパッド入りセッションキーに適用されるキーラッピング方法の結果を表す最大254オクテット。"
    },
    {
      "indent": 3,
      "text": "Note that for session key sizes 128, 192, and 256 bits, the size of the result of the key wrapping method is, respectively, 32, 40, and 48 octets, unless size obfuscation is used.",
      "ja": "セッションキーサイズ128、192、および256ビットの場合、サイズの難読化を使用しない限り、キーラッピング方法の結果のサイズはそれぞれ32、40、および48オクテットであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For convenience, the synopsis of the encoding method is given below; however, this section, [SP800-56A], and [RFC3394] are the normative sources of the definition.",
      "ja": "便宜上、エンコード方法の概要を以下に示します。ただし、このセクション[SP800-56A]、および[RFC3394]は、定義の規範的なソースです。"
    },
    {
      "indent": 6,
      "text": "* Obtain the authenticated recipient public key R",
      "ja": "* 認証された受信者の公開キーrを取得します"
    },
    {
      "indent": 6,
      "text": "* Generate an ephemeral, single-use key pair {v, V=vG}",
      "ja": "* はかない、使い捨てのキーペアを生成{v、v = vg}"
    },
    {
      "indent": 6,
      "text": "* Compute the shared point S = vR",
      "ja": "* 共有ポイントs = vrを計算します"
    },
    {
      "indent": 6,
      "text": "* m = symm_alg_ID || session key || checksum || pkcs5_padding",
      "ja": "* m = symm_alg_id ||セッションキー||チェックサム||PKCS5_PADDING"
    },
    {
      "indent": 6,
      "text": "* curve_OID_len = (octet)len(curve_OID)",
      "ja": "* curve_oid_len =（octet）len（curve_oid）"
    },
    {
      "indent": 6,
      "text": "* Param = curve_OID_len || curve_OID || public_key_alg_ID || 03 || 01 || KDF_hash_ID || KEK_alg_ID for AESKeyWrap || 41 6E 6F 6E 79 6D 6F 75 73 20 53 65 6E 64 65 72 20 20 20 20 || recipient_fingerprint",
      "ja": "* param = curve_oid_len ||curve_oid ||public_key_alg_id ||03 ||01 ||kdf_hash_id ||kek_alg_id for aeskeywrap ||41 6E 6F 6E 79 6D 6F 75 73 20 53 65 6E 64 65 72 20 20 20 20 ||reciontient_fingerprint"
    },
    {
      "indent": 6,
      "text": "* Z_len = the key size for the KEK_alg_ID used with AESKeyWrap",
      "ja": "* z_len = aeskeywrapで使用されるkek_alg_idのキーサイズ"
    },
    {
      "indent": 6,
      "text": "* Compute Z = KDF( S, Z_len, Param )",
      "ja": "* z = kdf（s、z_len、param）を計算する"
    },
    {
      "indent": 6,
      "text": "* Compute C = AESKeyWrap( Z, m ) (per [RFC3394])",
      "ja": "* c = aeskeywrap（z、m）（[rfc3394]ごと）を計算する"
    },
    {
      "indent": 6,
      "text": "* Wipe the memory that contained S, v, and Z to avoid leaking ephemeral secrets",
      "ja": "* 一時的な秘密の漏れを避けるために、s、v、zを含むメモリを拭きます"
    },
    {
      "indent": 6,
      "text": "* VB = convert point V to the octet string",
      "ja": "* VB =ポイントvをオクテット文字列に変換します"
    },
    {
      "indent": 6,
      "text": "* Output (MPI(VB) || len(C) || C)",
      "ja": "* 出力（MPI（VB）|| len（c）|| c）"
    },
    {
      "indent": 3,
      "text": "The decryption is the inverse of the method given. Note that the recipient with key pair (r,R) obtains the shared secret by calculating:",
      "ja": "復号化は、与えられた方法の逆です。キーペア（r、r）を持つ受信者は、計算して共有秘密を取得することに注意してください。"
    },
    {
      "indent": 3,
      "text": "S = rV = rvG",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.5.1. ECDH Parameters",
      "section_title": true,
      "ja": "11.5.1. ECDHパラメーター"
    },
    {
      "indent": 3,
      "text": "ECDH keys have a hash algorithm parameter for key derivation and a symmetric algorithm for key encapsulation.",
      "ja": "ECDHキーには、キー導入のためのハッシュアルゴリズムパラメーターと、キーカプセル化の対称アルゴリズムがあります。"
    },
    {
      "indent": 3,
      "text": "For version 6 keys, the following algorithms MUST be used depending on the curve. An implementation MUST NOT generate a version 6 ECDH key over any listed curve that uses different KDF or KEK parameters. An implementation MUST NOT encrypt any message to a version 6 ECDH key over a listed curve that announces a different KDF or KEK parameter.",
      "ja": "バージョン6キーの場合、曲線に応じて次のアルゴリズムを使用する必要があります。実装は、異なるKDFまたはKEKパラメーターを使用するリストされた曲線上にバージョン6 ECDHキーを生成してはなりません。実装は、異なるKDFまたはKEKパラメーターを発表するリストされた曲線を介して、バージョン6 ECDHキーにメッセージを暗号化してはなりません。"
    },
    {
      "indent": 3,
      "text": "For version 4 keys, the following algorithms SHOULD be used depending on the curve. An implementation SHOULD only use an AES algorithm as a KEK algorithm.",
      "ja": "バージョン4キーの場合、曲線に応じて次のアルゴリズムを使用する必要があります。実装では、AESアルゴリズムをKEKアルゴリズムとしてのみ使用する必要があります。"
    },
    {
      "indent": 8,
      "text": "+==================+================+=====================+\n| Curve            | Hash Algorithm | Symmetric Algorithm |\n+==================+================+=====================+\n| NIST P-256       | SHA2-256       | AES-128             |\n+------------------+----------------+---------------------+\n| NIST P-384       | SHA2-384       | AES-192             |\n+------------------+----------------+---------------------+\n| NIST P-521       | SHA2-512       | AES-256             |\n+------------------+----------------+---------------------+\n| brainpoolP256r1  | SHA2-256       | AES-128             |\n+------------------+----------------+---------------------+\n| brainpoolP384r1  | SHA2-384       | AES-192             |\n+------------------+----------------+---------------------+\n| brainpoolP512r1  | SHA2-512       | AES-256             |\n+------------------+----------------+---------------------+\n| Curve25519Legacy | SHA2-256       | AES-128             |\n+------------------+----------------+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 30: OpenPGP ECDH KDF and KEK Parameters Registry",
      "ja": "表30：OpenPGP ECDH KDFおよびKEKパラメータレジストリ"
    },
    {
      "indent": 0,
      "text": "12. Notes on Algorithms",
      "section_title": true,
      "ja": "12. アルゴリズムに関するメモ"
    },
    {
      "indent": 0,
      "text": "12.1. PKCS#1 Encoding in OpenPGP",
      "section_title": true,
      "ja": "12.1. PKCS＃1 OpenPGPでのエンコード"
    },
    {
      "indent": 3,
      "text": "This specification makes use of the PKCS#1 functions EME-PKCS1-v1_5 and EMSA-PKCS1-v1_5. However, the calling conventions of these functions have changed in the past. To avoid potential confusion and interoperability problems, we are including local copies in this document, adapted from those in PKCS#1 v2.1 [RFC8017]. [RFC8017] should be treated as the ultimate authority on PKCS#1 for OpenPGP. Nonetheless, we believe that there is value in having a self-contained document that avoids problems in the future with needed changes in the conventions.",
      "ja": "この仕様では、PKCS＃1関数EME-PKCS1-V1_5およびEMSA-PKCS1-V1_5を使用します。ただし、これらの機能の呼び出し条約は過去に変化しています。潜在的な混乱と相互運用性の問題を回避するために、このドキュメントには、PKCS＃1 V2.1 [RFC8017]のものから適応されたローカルコピーを含めています。[RFC8017]は、OpenPGPのPKCS＃1の究極の権限として扱われるべきです。それにもかかわらず、私たちは、慣習に必要な変更が必要な将来の問題を回避する自己完結型のドキュメントを持つことには価値があると考えています。"
    },
    {
      "indent": 0,
      "text": "12.1.1. EME-PKCS1-v1_5-ENCODE",
      "section_title": true,
      "ja": "12.1.1. EME-PKCS1-V1_5-ENCODE"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "k =",
      "ja": "k ="
    },
    {
      "indent": 12,
      "text": "key modulus length in octets.",
      "ja": "オクテットのキー率の長さ。"
    },
    {
      "indent": 3,
      "text": "M =",
      "ja": "m ="
    },
    {
      "indent": 12,
      "text": "message to be encoded; an octet string of length mLen, where mLen <= k - 11.",
      "ja": "エンコードされるメッセージ;長さmlenのオクテット文字列、mlen <= k -11。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "EM =",
      "ja": "em ="
    },
    {
      "indent": 12,
      "text": "encoded message; an octet string of length k.",
      "ja": "エンコードされたメッセージ;長さkのオクテット文字列。"
    },
    {
      "indent": 3,
      "text": "Error: \"message too long\".",
      "ja": "エラー：「メッセージが長すぎる」。"
    },
    {
      "indent": 8,
      "text": "1. Length checking: If mLen > k - 11, output \"message too long\" and stop.",
      "ja": "1. 長さのチェック：mlen> k -11の場合、「メッセージが長すぎる」出力を出力して停止します。"
    },
    {
      "indent": 8,
      "text": "2. Generate an octet string PS of length k - mLen - 3 consisting of pseudorandomly generated non-zero octets. The length of PS will be at least 8 octets.",
      "ja": "2. 長さk -mlen -3のオクテット文字列psを生成します。PSの長さは少なくとも8オクテットになります。"
    },
    {
      "indent": 8,
      "text": "3. Concatenate PS, the message M, and other padding to form an encoded message EM of length k octets as",
      "ja": "3. PS、メッセージM、およびその他のパディングを連結して、長さkオクテットのエンコードされたメッセージEMを形成します"
    },
    {
      "indent": 3,
      "text": "EM = 0x00 || 0x02 || PS || 0x00 || M.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "4. Output EM.",
      "ja": "4. 出力em。"
    },
    {
      "indent": 0,
      "text": "12.1.2. EME-PKCS1-v1_5-DECODE",
      "section_title": true,
      "ja": "12.1.2. EME-PKCS1-V1_5-DECODE"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "EM =",
      "ja": "em ="
    },
    {
      "indent": 12,
      "text": "encoded message; an octet string.",
      "ja": "エンコードされたメッセージ;オクテット文字列。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "M =",
      "ja": "m ="
    },
    {
      "indent": 12,
      "text": "decoded message; an octet string.",
      "ja": "デコードされたメッセージ;オクテット文字列。"
    },
    {
      "indent": 3,
      "text": "Error: \"decryption error\".",
      "ja": "エラー：「復号化エラー」。"
    },
    {
      "indent": 3,
      "text": "To decode an EME-PKCS1_v1_5 message, separate the encoded message EM into an octet string PS consisting of non-zero octets and a message M as follows",
      "ja": "EME-PKCS1_V1_5メッセージをデコードするには、エンコードされたメッセージEMを、以外のゼロオクテットとメッセージmで構成されるオクテット文字列PSに分離します。"
    },
    {
      "indent": 5,
      "text": "EM = 0x00 || 0x02 || PS || 0x00 || M.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the first octet of EM does not have hexadecimal value 0x00, the second octet of EM does not have hexadecimal value 0x02, there is no octet with hexadecimal value 0x00 to separate PS from M, or the length of PS is less than 8 octets, output \"decryption error\" and stop. See also Section 13.5 regarding differences in reporting between a decryption error and a padding error.",
      "ja": "EMの最初のオクテットに16進価値0x00を持たない場合、EMの2番目のオクテットには16進価値0x02がありません。16進数0x00のオクテットはMからPSを分離するか、PSの長さは8オクテット未満です。出力「復号化エラー」と停止。復号化エラーとパディングエラーのレポートの違いについては、セクション13.5も参照してください。"
    },
    {
      "indent": 0,
      "text": "12.1.3. EMSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "12.1.3. EMSA-PKCS1-V1_5"
    },
    {
      "indent": 3,
      "text": "This encoding method is deterministic and only has an encoding operation.",
      "ja": "このエンコード方法は決定論的であり、エンコード操作のみがあります。"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "Hash =",
      "ja": "ハッシュ="
    },
    {
      "indent": 12,
      "text": "hash function to be used.",
      "ja": "使用するハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "M =",
      "ja": "m ="
    },
    {
      "indent": 12,
      "text": "message to be encoded.",
      "ja": "エンコードされるメッセージ。"
    },
    {
      "indent": 3,
      "text": "emLen =",
      "ja": "emlen ="
    },
    {
      "indent": 12,
      "text": "intended length of the encoded message in octets, at least tLen + 11, where tLen is the octet length of the DER encoding T of a certain value computed during the encoding operation.",
      "ja": "オクテットのエンコードされたメッセージの長さ、少なくともtlen + 11。ここで、tlenはエンコード操作中に計算された特定の値のderエンコードtのオクテット長です。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "EM =",
      "ja": "em ="
    },
    {
      "indent": 12,
      "text": "encoded message; an octet string of length emLen.",
      "ja": "エンコードされたメッセージ;長さエムレンのオクテット文字列。"
    },
    {
      "indent": 3,
      "text": "Errors: \"message too long\"; \"intended encoded message length too short\".",
      "ja": "エラー：「メッセージが長すぎる」;「エンコードされたメッセージの長さが短すぎる」。"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 8,
      "text": "1. Apply the hash function to the message M to produce hash value H:",
      "ja": "1. ハッシュ関数をメッセージmに適用して、ハッシュ値hを生成します。"
    },
    {
      "indent": 12,
      "text": "H = Hash(M).",
      "ja": "H =ハッシュ（M）。"
    },
    {
      "indent": 12,
      "text": "If the hash function outputs \"message too long,\" output \"message too long\" and stop.",
      "ja": "ハッシュ関数が「メッセージが長すぎるメッセージを出力すると、「メッセージ」出力が長すぎて停止します。"
    },
    {
      "indent": 8,
      "text": "2. Let T be the Full Hash Prefix from Table 24 for the given hash function, concatenated with the hash digest H (representing an ASN.1 DER value for the hash function used and the hash digest). Let tLen be the length in octets of T.",
      "ja": "2. 与えられたハッシュ関数の表24からの完全なハッシュプレフィックスを、ハッシュダイジェストH（使用するハッシュ関数のASN.1 der値とハッシュダイジェストを表す）と連結します。TlenをTのオクテットの長さとします。"
    },
    {
      "indent": 8,
      "text": "3. If emLen < tLen + 11, output \"intended encoded message length too short\" and stop.",
      "ja": "3. emlen <tlen + 11の場合、出力は「エンコードされたメッセージの長さが短すぎる」と停止します。"
    },
    {
      "indent": 8,
      "text": "4. Generate an octet string PS consisting of emLen - tLen - 3 octets with hexadecimal value 0xFF. The length of PS will be at least 8 octets.",
      "ja": "4. Emlen -Tlen -3オクテットで構成されるOctet String PSを生成します。PSの長さは少なくとも8オクテットになります。"
    },
    {
      "indent": 8,
      "text": "5. Concatenate PS, the hash prefix T, and other padding to form the encoded message EM as",
      "ja": "5. エンコードされたメッセージemを形成するために、PS、ハッシュプレフィックスT、およびその他のパディングを連結します"
    },
    {
      "indent": 3,
      "text": "EM = 0x00 || 0x01 || PS || 0x00 || T.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "6. Output EM.",
      "ja": "6. 出力em。"
    },
    {
      "indent": 0,
      "text": "12.2. Symmetric Algorithm Preferences",
      "section_title": true,
      "ja": "12.2. 対称アルゴリズムの好み"
    },
    {
      "indent": 3,
      "text": "The symmetric algorithm preference is an ordered list of algorithms that the keyholder accepts. Since it is found on a self-signature, it is possible that a keyholder may have multiple, different preferences. For example, Alice may have AES-128 only specified for \"alice@work.com\" but Camellia-256, Twofish, and AES-128 specified for \"alice@home.org\". Note that it is also possible for preferences to be in a subkey's binding signature.",
      "ja": "対称アルゴリズムの優先度は、キーホルダーが受け入れるアルゴリズムの順序付けられたリストです。それは自己署名に見られるため、キーホルダーが複数の異なる好みを持っている可能性があります。たとえば、アリスは「alice@work.com」にのみ指定されているAES-128を持っているかもしれませんが、Camellia-256、Twofish、およびAES-128は「alice@home.org」に指定されています。また、好みがサブキーの拘束力のある署名にあることも可能であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Since AES-128 is the algorithm that MUST be implemented, if it is not explicitly in the list, it is tacitly at the end. However, it is good form to place it there explicitly. Note also that if an implementation does not implement the preference, then it is implicitly an AES-128-only implementation. Furthermore, note that implementations conforming to the previous version of this specification [RFC4880] have TripleDES as the only algorithm that MUST be implemented.",
      "ja": "AES-128は実装する必要があるアルゴリズムであるため、リストに明示的にない場合は、最後に暗黙のです。ただし、そこに明示的に配置するのは良い形です。また、実装が優先権を実装しない場合、それは暗黙的にAES-128のみの実装であることに注意してください。さらに、この仕様[RFC4880]の以前のバージョンに準拠した実装には、実装する必要がある唯一のアルゴリズムとして3倍があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT use a symmetric algorithm that is not in the recipient's preference list. When encrypting to more than one recipient, the implementation finds a suitable algorithm by taking the intersection of the preferences of the recipients. Note that since the AES-128 algorithm MUST be implemented, the intersection is guaranteed to be non-empty.",
      "ja": "実装は、受信者の設定リストにない対称アルゴリズムを使用してはなりません。複数の受信者に暗号化するとき、実装は受信者の好みの交差点を取ることにより、適切なアルゴリズムを見つけます。AES-128アルゴリズムを実装する必要があるため、交差点は空ではないことが保証されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If an implementation can decrypt a message that a keyholder doesn't have in their preferences, the implementation SHOULD decrypt the message anyway, but it MUST warn the keyholder. For example, suppose that Alice (above) has an implementation that implements all algorithms in this specification. Nonetheless, she prefers subsets for work or home. If she is sent a message encrypted with IDEA, which is not in her preferences, the implementation warns her that someone sent an IDEA-encrypted message, but it would ideally decrypt it anyway.",
      "ja": "実装がキーホルダーが好みに備えていないメッセージを解読できる場合、実装はとにかくメッセージを解読する必要がありますが、キーホルダーに警告する必要があります。たとえば、Alice（上記）には、この仕様のすべてのアルゴリズムを実装する実装があるとします。それにもかかわらず、彼女は仕事や家のためにサブセットを好む。彼女が自分の好みではないアイデアで暗号化されたメッセージを送信した場合、実装は誰かがアイデア暗号化されたメッセージを送信したことを彼女に警告しますが、それはとにかくそれを理想的にはそれを解読するでしょう。"
    },
    {
      "indent": 0,
      "text": "12.2.1. Plaintext",
      "section_title": true,
      "ja": "12.2.1. プレーンテキスト"
    },
    {
      "indent": 3,
      "text": "Algorithm 0, \"plaintext\", may only be used to denote secret keys that are stored in the clear. An implementation MUST NOT use algorithm 0 as the indicated symmetric cipher for an encrypted data packet (Sections 5.7 or 5.13); it can use a Literal Data packet (Section 5.9) to encode unencrypted literal data.",
      "ja": "アルゴリズム0、「Plantext」は、クリアに保存されている秘密のキーを示すためにのみ使用できます。実装は、暗号化されたデータパケットの指定された対称暗号としてアルゴリズム0を使用してはなりません（セクション5.7または5.13）。リテラルデータパケット（セクション5.9）を使用して、暗号化されていないリテラルデータをエンコードできます。"
    },
    {
      "indent": 0,
      "text": "12.3. Other Algorithm Preferences",
      "section_title": true,
      "ja": "12.3. その他のアルゴリズムの好み"
    },
    {
      "indent": 3,
      "text": "Other algorithm preferences work similarly to the symmetric algorithm preference in that they specify which algorithms the keyholder accepts. There are two interesting cases in which further comments are needed: the compression preferences and the hash preferences.",
      "ja": "他のアルゴリズムの好みは、キーホルダーが受け入れるアルゴリズムを指定するという点で、対称アルゴリズムの好みと同様に機能します。さらなるコメントが必要な2つの興味深いケースがあります：圧縮選好とハッシュ選好。"
    },
    {
      "indent": 0,
      "text": "12.3.1. Compression Preferences",
      "section_title": true,
      "ja": "12.3.1. 圧縮選好"
    },
    {
      "indent": 3,
      "text": "Like the algorithm preferences, an implementation MUST NOT use an algorithm that is not in the preference vector. If Uncompressed (0) is not explicitly in the list, it is tacitly at the end. That is, uncompressed messages may always be sent.",
      "ja": "アルゴリズムの好みと同様に、実装は優先ベクトルにないアルゴリズムを使用してはなりません。非圧縮（0）がリストに明示的にない場合、それは最後に暗黙のです。つまり、非圧縮メッセージは常に送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that earlier implementations may assume that the absence of compression preferences means that [ZIP(1), Uncompressed(0)] are preferred, and default to ZIP compression. Therefore, an implementation that prefers uncompressed data SHOULD explicitly state this in the Preferred Compression Algorithms.",
      "ja": "以前の実装は、圧縮選好の欠如が[zip（1）、非圧縮（0）]が優先され、デフォルトでzip圧縮を行うことを意味することに注意するかもしれないことに注意してください。したがって、非圧縮データを好む実装は、優先圧縮アルゴリズムにこれを明示的に述べる必要があります。"
    },
    {
      "indent": 0,
      "text": "12.3.1.1. Uncompressed",
      "section_title": true,
      "ja": "12.3.1.1. 圧迫されていません"
    },
    {
      "indent": 3,
      "text": "Algorithm 0, \"uncompressed\", may only be used to denote a preference for uncompressed data. An implementation MUST NOT use algorithm 0 as the indicated compression algorithm in a Compressed Data packet (Section 5.6); it can use a Literal Data packet (Section 5.9) to encode uncompressed literal data.",
      "ja": "アルゴリズム0「非圧縮」は、非圧縮データの好みを示すためにのみ使用できます。実装は、圧縮データパケットの指定された圧縮アルゴリズムとしてアルゴリズム0を使用してはなりません（セクション5.6）。リテラルデータパケット（セクション5.9）を使用して、非圧縮リテラルデータをエンコードできます。"
    },
    {
      "indent": 0,
      "text": "12.3.2. Hash Algorithm Preferences",
      "section_title": true,
      "ja": "12.3.2. ハッシュアルゴリズムの好み"
    },
    {
      "indent": 3,
      "text": "Typically, the signer chooses which hash algorithm to use, rather than the verifier, because a signer rarely knows who is going to be verifying the signature. This preference allows a protocol based upon digital signatures ease in negotiation.",
      "ja": "通常、署名者は、検証剤ではなく使用するハッシュアルゴリズムを選択します。これは、署名者が誰が署名を検証するのかはめったに知らないためです。この好みにより、デジタル署名が交渉を容易にすることに基づいたプロトコルが可能になります。"
    },
    {
      "indent": 3,
      "text": "Thus, if Alice is authenticating herself to Bob with a signature, it makes sense for her to use a hash algorithm that Bob's implementation uses. This preference allows Bob to state which algorithms Alice may use in his key.",
      "ja": "したがって、アリスが署名でボブに自分自身を認証している場合、ボブの実装が使用するハッシュアルゴリズムを使用することは理にかなっています。この好みにより、ボブはアリスが自分のキーで使用できるアルゴリズムを述べることができます。"
    },
    {
      "indent": 3,
      "text": "Since SHA2-256 is the hash algorithm that MUST be implemented, if it is not explicitly in the list, it is tacitly at the end. However, it is good form to place it there explicitly.",
      "ja": "SHA2-256は実装する必要があるハッシュアルゴリズムであるため、リストに明示的にない場合は、最後にあります。ただし、そこに明示的に配置するのは良い形です。"
    },
    {
      "indent": 0,
      "text": "12.4. RSA",
      "section_title": true,
      "ja": "12.4. RSA"
    },
    {
      "indent": 3,
      "text": "The PKCS1-v1_5 padding scheme, used by the RSA algorithms defined in this document, is no longer recommended, and its use is deprecated by [SP800-131A]. Therefore, an implementation SHOULD NOT generate RSA keys.",
      "ja": "このドキュメントで定義されているRSAアルゴリズムで使用されるPKCS1-V1_5パディングスキームは、もはや推奨されず、その使用は[SP800-131A]によって非推奨されます。したがって、実装はRSAキーを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "There are algorithm types for RSA Sign-Only and RSA Encrypt-Only keys. These types are deprecated in favor of the Key Flags signature subpacket. An implementation MUST NOT create such a key, but it MAY interpret it.",
      "ja": "RSA SignのみおよびRSA暗号化のみのキーには、アルゴリズムタイプがあります。これらのタイプは、キーフラグの署名サブパケットを支持して非推奨されています。実装はそのようなキーを作成してはなりませんが、解釈する場合があります。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT generate RSA keys of a size less than 3072 bits. An implementation SHOULD NOT encrypt, sign, or verify using RSA keys of a size less than 3072 bits. An implementation MUST NOT encrypt, sign, or verify using RSA keys of a size less than 2048 bits. An implementation that decrypts a message using an RSA secret key of a size less than 3072 bits SHOULD generate a deprecation warning that the key is too weak for modern use.",
      "ja": "実装は、3072ビット未満のサイズのRSAキーを生成してはなりません。実装は、3072ビット未満のサイズのRSAキーを使用して暗号化、署名、または検証しないでください。実装は、2048ビット未満のサイズのRSAキーを使用して、暗号化、署名、または検証してはなりません。3072ビット未満のサイズのRSAシークレットキーを使用してメッセージを復号化する実装は、キーが最新の使用には弱すぎるという非推奨警告を生成するはずです。"
    },
    {
      "indent": 0,
      "text": "12.5. DSA",
      "section_title": true,
      "ja": "12.5. DSA"
    },
    {
      "indent": 3,
      "text": "DSA is no longer recommended. It has also been deprecated in [FIPS186]. Therefore, an implementation MUST NOT generate DSA keys.",
      "ja": "DSAは推奨されなくなりました。また、[FIPS186]で非推奨されています。したがって、実装はDSAキーを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT sign or verify using DSA keys.",
      "ja": "実装は、DSAキーを使用して署名または検証してはなりません。"
    },
    {
      "indent": 0,
      "text": "12.6. Elgamal",
      "section_title": true,
      "ja": "12.6. エルガマル"
    },
    {
      "indent": 3,
      "text": "The PKCS1-v1_5 padding scheme, used by the Elgamal algorithm defined in this document, is no longer recommended, and its use is deprecated by [SP800-131A]. Therefore, an implementation MUST NOT generate Elgamal keys.",
      "ja": "このドキュメントで定義されているエルガマルアルゴリズムで使用されるPKCS1-V1_5パディングスキームは、もはや推奨されず、その使用は[SP800-131A]によって非推奨されます。したがって、実装はエルガマルキーを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT encrypt using Elgamal keys. An implementation that decrypts a message using an Elgamal secret key SHOULD generate a deprecation warning that the key is too weak for modern use.",
      "ja": "実装は、エルガマルキーを使用して暗号化してはなりません。Elgamal Secretキーを使用してメッセージを復号化する実装は、キーが最新の使用には弱すぎるという非推奨警告を生成するはずです。"
    },
    {
      "indent": 0,
      "text": "12.7. EdDSA",
      "section_title": true,
      "ja": "12.7. eddsa"
    },
    {
      "indent": 3,
      "text": "Although the EdDSA algorithm allows arbitrary data as input, its use with OpenPGP requires that a digest of the message be used as input (pre-hashed). See Section 5.2.4 for details. Truncation of the resulting digest is never applied; the resulting digest value is used verbatim as input to the EdDSA algorithm.",
      "ja": "EDDSAアルゴリズムは任意のデータを入力として許可していますが、OpenPGPでの使用では、メッセージのダイジェストを入力として使用する必要があります（事前にかけて）。詳細については、セクション5.2.4を参照してください。得られたダイジェストの切り捨ては決して適用されません。結果のダイジェスト値は、EDDSAアルゴリズムへの入力として逐語的に使用されます。"
    },
    {
      "indent": 3,
      "text": "For clarity: while [RFC8032] describes different variants of EdDSA, OpenPGP uses the \"pure\" variant (PureEdDSA). The hashing that happens with OpenPGP is done as part of the standard OpenPGP signature process, and that hash itself is fed as the input message to the PureEdDSA algorithm.",
      "ja": "明確性について：[RFC8032]はEDDSAのさまざまなバリエーションを説明していますが、OpenPGPは「純粋な」バリアント（PureEddsa）を使用します。OpenPGPで発生するハッシュは、標準のOpenPGP署名プロセスの一部として行われ、Hash自体はPureEddsaアルゴリズムへの入力メッセージとして供給されます。"
    },
    {
      "indent": 3,
      "text": "As specified in [RFC8032], Ed448 also expects a \"context string\". In OpenPGP, Ed448 is used with the empty string as a context string.",
      "ja": "[RFC8032]で指定されているように、ED448は「コンテキスト文字列」も期待しています。OpenPGPでは、ED448は空の文字列とともにコンテキスト文字列として使用されます。"
    },
    {
      "indent": 0,
      "text": "12.8. Reserved Algorithm IDs",
      "section_title": true,
      "ja": "12.8. 予約されたアルゴリズムID"
    },
    {
      "indent": 3,
      "text": "A number of algorithm IDs have been reserved for algorithms that would be useful to use in an OpenPGP implementation, yet there are issues that prevent an implementer from actually implementing the algorithm. These are marked as reserved in Section 9.1.",
      "ja": "OpenPGP実装で使用するのに役立つアルゴリズムのために、多くのアルゴリズムIDが予約されていますが、実装者が実際にアルゴリズムを実装できないことを妨げる問題があります。これらは、セクション9.1に予約されているとマークされています。"
    },
    {
      "indent": 3,
      "text": "The reserved public key algorithm X9.42 (21) does not have the necessary parameters, parameter order, or semantics defined. The same is currently true for reserved public key algorithms AEDH (23) and AEDSA (24).",
      "ja": "予約された公開キーアルゴリズムX9.42（21）には、必要なパラメーター、パラメーターの順序、またはセマンティクスが定義されていません。現在、予約された公開キーアルゴリズムAEDH（23）およびAEDSA（24）にも同じことが当てはまります。"
    },
    {
      "indent": 3,
      "text": "Previous versions of the OpenPGP specification permitted Elgamal [ELGAMAL] signatures with a public key algorithm ID of 20. These are no longer permitted. An implementation MUST NOT generate such keys. An implementation MUST NOT generate Elgamal signatures; see [BLEICHENBACHER].",
      "ja": "OpenPGP仕様の以前のバージョンでは、20の公開キーアルゴリズムIDを持つElgamal [Elgamal]署名が許可されています。これらは許可されなくなりました。実装はそのようなキーを生成してはなりません。実装は、エルガマルの署名を生成してはなりません。[Bleichenbacher]を参照してください。"
    },
    {
      "indent": 0,
      "text": "12.9. CFB Mode",
      "section_title": true,
      "ja": "12.9. CFBモード"
    },
    {
      "indent": 3,
      "text": "The Cipher Feedback (CFB) mode used in this document is defined in Section 6.3 of [SP800-38A].",
      "ja": "このドキュメントで使用されている暗号フィードバック（CFB）モードは、[SP800-38A]のセクション6.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "The CFB segment size s is equal to the block size of the cipher (i.e., n-bit CFB mode, where n is the block size used).",
      "ja": "CFBセグメントサイズsは、暗号のブロックサイズに等しくなります（つまり、nビットCFBモード、nは使用されるブロックサイズ）。"
    },
    {
      "indent": 0,
      "text": "12.10. Private or Experimental Parameters",
      "section_title": true,
      "ja": "12.10. プライベートまたは実験的パラメーター"
    },
    {
      "indent": 3,
      "text": "S2K Specifiers, Signature Subpacket Type IDs, User Attribute Subpacket Type IDs, image format IDs, and the various algorithm IDs described in Section 9 all reserve the range 100 to 110 for Private and Experimental Use. Packet Type IDs reserve the range 60 to 63 for Private and Experimental Use. These are intentionally managed by the Private Use and Experimental Use policies, as described in [RFC8126].",
      "ja": "S2K仕様、署名サブパケットタイプID、ユーザー属性サブパケットタイプID、イメージ形式ID、およびセクション9で説明されているさまざまなアルゴリズムIDはすべて、プライベートおよび実験用に100〜110の範囲を予約します。パケットタイプIDは、プライベートおよび実験的な使用のために60〜63の範囲を予約します。これらは、[RFC8126]に記載されているように、私的使用および実験的使用ポリシーによって意図的に管理されています。"
    },
    {
      "indent": 3,
      "text": "However, implementations need to be careful with these and promote them to full IANA-managed parameters when they grow beyond the original, limited system.",
      "ja": "ただし、実装はこれらに注意し、元の限られたシステムを超えて成長するときに、IANAが管理する完全なパラメーターにそれらを促進する必要があります。"
    },
    {
      "indent": 0,
      "text": "12.11. Meta Considerations for Expansion",
      "section_title": true,
      "ja": "12.11. 拡張に関するメタ考慮事項"
    },
    {
      "indent": 3,
      "text": "If OpenPGP is extended in a way that is not backward compatible, meaning that old implementations will not gracefully handle their absence of a new feature, the extension proposal can be declared in the keyholder's self-signature as part of the Features signature subpacket.",
      "ja": "OpenPGPが後方互換性のない方法で拡張されている場合、古い実装は新しい機能の欠如を優雅に処理しないことを意味します。拡張提案は、機能署名サブパケットの一部としてキーホルダーの自己署名で宣言できます。"
    },
    {
      "indent": 3,
      "text": "We cannot state definitively what extensions will not be forward compatible, but typically new algorithms are forward compatible, whereas new packets are not.",
      "ja": "どの拡張機能が転送されないかを明確に述べることはできませんが、通常、新しいアルゴリズムはフォワード互換性がありますが、新しいパケットは互換性がありません。"
    },
    {
      "indent": 3,
      "text": "If an extension proposal does not update the Features system, it SHOULD include an explanation of why this is unnecessary. If the proposal contains neither an extension to the Features system nor an explanation of why such an extension is unnecessary, the proposal SHOULD be rejected.",
      "ja": "拡張提案が機能システムを更新しない場合、これが不要な理由の説明を含める必要があります。提案に機能システムへの拡張機能も含まれていない場合も、そのような拡張が不要な理由の説明も含まれていない場合、提案は拒否されるべきです。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13. セキュリティに関する考慮事項"
    },
    {
      "indent": 6,
      "text": "* As with any technology involving cryptography, implementers should check the current literature to determine if any algorithms used here have been found to be vulnerable to an attack. If so, implementers should consider disallowing such algorithms for new data and warning the end user, or preventing use, when they are trying to consume data protected by such algorithms that are now vulnerable.",
      "ja": "* 暗号化を含む他の技術と同様に、実装者は現在の文献をチェックして、ここで使用されているアルゴリズムが攻撃に対して脆弱であることがわかっているかどうかを判断する必要があります。その場合、実装者は、新しいデータに対してそのようなアルゴリズムを拒否し、エンドユーザーに警告することを検討する必要があります。または、現在脆弱なアルゴリズムによって保護されているデータを消費しようとしている場合、使用を防止する必要があります。"
    },
    {
      "indent": 6,
      "text": "* This specification uses Public Key Cryptography technologies. It is assumed that the private key portion of a public-private key pair is controlled and secured by the proper party or parties.",
      "ja": "* この仕様では、公開キー暗号化技術を使用しています。官民キーペアの秘密のキー部分は、適切な当事者または当事者によって制御および保護されていると想定されています。"
    },
    {
      "indent": 6,
      "text": "* The MD5 and SHA-1 hash algorithms have been found to have weaknesses, with collisions found in a number of cases. MD5 and SHA-1 are deprecated for use in OpenPGP (see Section 9.5).",
      "ja": "* MD5およびSHA-1ハッシュアルゴリズムには弱点があることがわかっており、多くのケースで衝突が見つかりました。MD5とSHA-1は、OpenPGPで使用するために非推奨です（セクション9.5を参照）。"
    },
    {
      "indent": 6,
      "text": "* Many security protocol designers think that it is a bad idea to use a single key for both privacy (encryption) and integrity (signatures). In fact, this was one of the motivating forces behind the version 4 key format with separate signature and encryption keys. Using a single key for encrypting and signing is discouraged.",
      "ja": "* 多くのセキュリティプロトコル設計者は、プライバシー（暗号化）と整合性（署名）の両方に単一のキーを使用することは悪い考えであると考えています。実際、これは、個別の署名キーと暗号化キーを備えたバージョン4キー形式の背後にある動機付けの力の1つでした。暗号化と署名に単一のキーを使用することは落胆します。"
    },
    {
      "indent": 6,
      "text": "* The DSA algorithm will work with any hash, but it is sensitive to the quality of the hash algorithm. Verifiers should be aware that even if the signer used a strong hash, an attacker could have modified the signature to use a weak one. Only signatures using acceptably strong hash algorithms should be accepted as valid.",
      "ja": "* DSAアルゴリズムは任意のハッシュで動作しますが、ハッシュアルゴリズムの品質に敏感です。Verifiersは、署名者が強いハッシュを使用したとしても、攻撃者が署名を変更して弱いものを使用する可能性があることに注意する必要があります。容認できる強力なハッシュアルゴリズムを使用する署名のみを有効として受け入れる必要があります。"
    },
    {
      "indent": 6,
      "text": "* As OpenPGP combines many different asymmetric, symmetric, and hash algorithms, each with different measures of strength, care should be taken to ensure that the weakest element of an OpenPGP Message is still sufficiently strong for the purpose at hand. While consensus about the strength of a given algorithm may evolve, NIST Special Publication 800-57 [SP800-57] contains recommendations (current at the time of this publication) about equivalent security levels of different algorithms.",
      "ja": "* OpenPGPは多くの異なる非対称、対称、およびハッシュアルゴリズムを組み合わせているため、それぞれが強度の測定値が異なるため、OpenPGPメッセージの最も弱い要素が手元の目的で十分に強いことを確認するように注意する必要があります。特定のアルゴリズムの強度に関するコンセンサスは進化する可能性がありますが、NIST Special Publication 800-57 [SP800-57]には、異なるアルゴリズムの同等のセキュリティレベルに関する推奨事項（この出版物の時点）が含まれています。"
    },
    {
      "indent": 6,
      "text": "* There is a somewhat-related potential security problem in signatures. If an attacker can find a message that hashes to the same hash with a different algorithm, a bogus signature structure can be constructed that evaluates correctly.",
      "ja": "* 署名にはやや関連する潜在的なセキュリティ問題があります。攻撃者が異なるアルゴリズムで同じハッシュにハッシュするメッセージを見つけることができる場合、正しく評価する偽の署名構造を構築できます。"
    },
    {
      "indent": 10,
      "text": "For example, suppose Alice DSA-signs message M using hash algorithm H. Suppose that Mallet finds a message M' that has the same hash value as M with H'. Mallet can then construct a signature block that verifies as Alice's signature of M' with H'. However, this would also constitute a weakness in either H or H', or both. Should this ever occur, a revision will have to be made to this document to revise the allowed hash algorithms.",
      "ja": "たとえば、HashアルゴリズムHを使用してAlice DSA-Signsメッセージmを使用してください。MalletがMと同じハッシュ値を持つメッセージM 'を見つけたと仮定します。Malletは、AliceのM 'with H'の署名として検証する署名ブロックを構築できます。ただし、これはH 'またはH'、またはその両方の弱点も構成します。これが発生した場合、許可されたハッシュアルゴリズムを改訂するために、このドキュメントに改訂を行う必要があります。"
    },
    {
      "indent": 6,
      "text": "* If you are building an authentication system, the recipient may specify a preferred signing algorithm. However, the signer would be foolish to use a weak algorithm simply because the recipient requests it.",
      "ja": "* 認証システムを構築している場合、受信者は優先署名アルゴリズムを指定する場合があります。ただし、署名者は、受信者がそれを要求するという理由だけで、弱いアルゴリズムを使用するのは愚かです。"
    },
    {
      "indent": 6,
      "text": "* Some of the encryption algorithms mentioned in this document have been analyzed less than others. For example, although TWOFISH is presently considered reasonably strong, it has been analyzed much less than AES. Other algorithms may have other concerns surrounding them.",
      "ja": "* このドキュメントで言及されている暗号化アルゴリズムの一部は、他のドキュメントよりも分析されていません。たとえば、Twofishは現在合理的に強いと考えられていますが、AEよりもはるかに少ない分析があります。他のアルゴリズムには、それらを取り巻く他の懸念がある場合があります。"
    },
    {
      "indent": 6,
      "text": "* In late summer 2002, Jallad, Katz, and Schneier published an interesting attack on previous versions of the OpenPGP specification and some of its implementations [JKS02]. In this attack, the attacker modifies a message and sends it to a user who then returns the erroneously decrypted message to the attacker. The attacker is thus using the user as a decryption oracle and can often decrypt the message. This attack is a particular form of ciphertext malleability. See Section 13.7 for information on how to defend against such an attack using more recent versions of OpenPGP.",
      "ja": "* 2002年夏の終わりに、Jallad、Katz、およびSchneierは、OpenPGP仕様の以前のバージョンとその実装の一部に対する興味深い攻撃を発表しました[JKS02]。この攻撃では、攻撃者はメッセージを変更し、ユーザーに送信し、ユーザーは誤って復号化されたメッセージを攻撃者に返します。したがって、攻撃者はユーザーを復号化オラクルとして使用しており、多くの場合、メッセージを復号化できます。この攻撃は、特定の形式の暗号文脈順位です。OpenPGPのより最近のバージョンを使用して、このような攻撃を防御する方法については、セクション13.7を参照してください。"
    },
    {
      "indent": 0,
      "text": "13.1. SHA-1 Collision Detection",
      "section_title": true,
      "ja": "13.1. SHA-1衝突検出"
    },
    {
      "indent": 3,
      "text": "As described in [SHAMBLES], the SHA-1 digest algorithm is not collision resistant. However, an OpenPGP implementation cannot completely discard the SHA-1 algorithm, because it is required for implementing version 4 public keys. In particular, the version 4 fingerprint derivation uses SHA-1. So as long as an OpenPGP implementation supports version 4 public keys, it will need to implement SHA-1 in at least some scenarios.",
      "ja": "[シャンブルズ]で説明されているように、SHA-1ダイジェストアルゴリズムは衝突抵抗性ではありません。ただし、OpenPGPの実装は、バージョン4のパブリックキーを実装するために必要であるため、SHA-1アルゴリズムを完全に破棄することはできません。特に、バージョン4の指紋派生はSHA-1を使用します。したがって、OpenPGP実装がバージョン4パブリックキーをサポートしている限り、少なくともいくつかのシナリオでSHA-1を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "To avoid the risk of uncertain breakage from a maliciously introduced SHA-1 collision, an OpenPGP implementation MAY attempt to detect when a hash input is likely from a known collision attack and then either reject the hash input deliberately or modify the hash output. This should convert an uncertain breakage (where it is unclear what the effect of a collision will be) to an explicit breakage, which is more desirable for a robust implementation.",
      "ja": "悪意のあるSHA-1衝突による不確実な破損のリスクを回避するために、OpenPGPの実装は、ハッシュ入力が既知の衝突攻撃からの可能性が高い時期を検出し、ハッシュ入力を故意に拒否するか、ハッシュ出力を変更する場合があります。これにより、不確実な破損（衝突の効果がどうなるかは不明な場合）を明示的な破損に変換するはずです。これは、堅牢な実装により望ましいものです。"
    },
    {
      "indent": 3,
      "text": "[STEVENS2013] describes a method for detecting indicators of well-known SHA-1 collision attacks. Some example C code implementing this technique can be found at [SHA1CD].",
      "ja": "[Stevens2013]は、よく知られているSHA-1衝突攻撃の指標を検出する方法を説明しています。この手法を実装するCコードの例は、[sha1cd]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "13.2. Advantages of Salted Signatures",
      "section_title": true,
      "ja": "13.2. 塩漬けの署名の利点"
    },
    {
      "indent": 3,
      "text": "Version 6 signatures include a salt that is hashed first, and it's size depends on the hashing algorithm. This makes version 6 OpenPGP signatures non-deterministic and protects against a broad class of attacks that depend on creating a signature over a predictable message. By selecting a new random salt for each signature made, the signed hashes and the signatures are not predictable.",
      "ja": "バージョン6の署名には、最初にハッシュされた塩が含まれ、サイズはハッシュアルゴリズムに依存します。これにより、バージョン6のOpenPGP署名が非決定的であり、予測可能なメッセージよりも署名の作成に依存する幅広い攻撃から保護します。作成された各署名に新しいランダム塩を選択することにより、署名されたハッシュと署名は予測できません。"
    },
    {
      "indent": 3,
      "text": "While the material to be signed could be attacker controlled, hashing the salt first means that there is no attacker-controlled hashed prefix. An example of this kind of attack is described in the paper \"SHA-1 is a Shambles\" [SHAMBLES], which leverages a chosen prefix collision attack against SHA-1. This means that an adversary carrying out a chosen-message attack will not be able to control the hash that is being signed and will need to break second-preimage resistance instead of the simpler collision resistance to create two messages having the same signature. The size of the salt is bound to the hash function to match the expected collision-resistance level and is at least 16 octets.",
      "ja": "署名する材料は攻撃者の制御である可能性がありますが、塩をハッシュすることは、最初に攻撃者制御のハッシュプレフィックスがないことを意味します。この種の攻撃の例は、「Sha-1は修羅場です」[Sha-1に対する接頭辞衝突攻撃を活用する論文で説明されています。これは、選ばれた攻撃を実行する敵が署名されているハッシュを制御できず、同じ署名を持つ2つのメッセージを作成するために、より単純な衝突抵抗の代わりに2番目のプレイマージ抵抗を破る必要があることを意味します。塩のサイズは、予想される衝突耐性レベルに一致するようにハッシュ関数に結合し、少なくとも16オクテットです。"
    },
    {
      "indent": 3,
      "text": "In some cases, an attacker may be able to induce a signature to be made, even if they do not control the content of the message. In some scenarios, a repeated signature over the exact same message may risk leakage of part or all of the signing key; for example, see discussion of hardware faults over EdDSA and deterministic ECDSA in [PSSLR17]. Choosing a new random salt for each signature ensures that no repeated signatures are produced, which mitigates this risk.",
      "ja": "場合によっては、攻撃者がメッセージのコンテンツを制御しなくても、署名を誘導することができる場合があります。いくつかのシナリオでは、まったく同じメッセージで繰り返される署名が、署名キーの一部またはすべての漏れを危険にさらす可能性があります。たとえば、[PSSLR17]のEDDSAおよび決定論的ECDSAに関するハードウェア障害の議論を参照してください。各署名に新しいランダム塩を選択すると、繰り返される署名が生成されないことが保証され、このリスクが軽減されます。"
    },
    {
      "indent": 0,
      "text": "13.3. Elliptic Curve Side Channels",
      "section_title": true,
      "ja": "13.3. 楕円曲線サイドチャネル"
    },
    {
      "indent": 3,
      "text": "Side-channel attacks are a concern when a compliant application's use of the OpenPGP format can be modeled by a decryption or signing oracle, for example, when an application is a network service performing decryption to unauthenticated remote users. ECC scalar multiplication operations used in ECDSA and ECDH are vulnerable to side-channel attacks. Countermeasures can often be taken at the higher protocol level, such as limiting the number of allowed failures or time-blinding the operations associated with each network interface. Mitigations at the scalar multiplication level seek to eliminate any measurable distinction between the ECC point addition and doubling operations.",
      "ja": "サイドチャネル攻撃は、準拠したアプリケーションのOpenPGP形式の使用を復号化または署名によってモデル化できる場合、たとえば、アプリケーションが認証されていないリモートユーザーに復号化を実行するネットワークサービスである場合、Oracleの署名によってモデル化できる場合です。ECDSAおよびECDHで使用されるECCスカラー乗算操作は、サイドチャネル攻撃に対して脆弱です。多くの場合、対策は、許可された障害の数を制限したり、各ネットワークインターフェイスに関連付けられている操作をタイムブリンディングするなど、より高いプロトコルレベルで実行できます。スカラー乗算レベルでの軽減により、ECCポイントの追加と倍増操作との測定可能な区別を排除しようとします。"
    },
    {
      "indent": 0,
      "text": "13.4. Risks of a Quick Check Oracle",
      "section_title": true,
      "ja": "13.4. クイックチェックオラクルのリスク"
    },
    {
      "indent": 3,
      "text": "In winter 2005, Serge Mister and Robert Zuccherato from Entrust released a paper describing a way that the \"quick check\" in v1 SEIPD and SED packets can be used as an oracle to decrypt two octets of every cipher block [MZ05]. This check was intended for early detection of session key decryption errors, particularly to detect a wrong passphrase, since v4 SKESK packets do not include an integrity check.",
      "ja": "2005年冬に、Serge MisterとRobert Zuccheratoは、V1 SEIPDおよびSEDパケットの「クイックチェック」をOracleとして使用して、すべての暗号ブロック[MZ05]の2オクテットを復号化できる方法を説明する論文をリリースしました。このチェックは、V4 Skeskパケットには整合性チェックが含まれていないため、特に間違ったパスフレーズを検出するために、セッションキー復号化エラーの早期検出を目的としています。"
    },
    {
      "indent": 3,
      "text": "There is a danger when using the quick check if timing or error information about the check can be exposed to an attacker, particularly via an automated service that allows rapidly repeated queries.",
      "ja": "特に迅速に繰り返されるクエリを可能にする自動化されたサービスを介して、チェックに関するタイミングまたはエラー情報が攻撃者にさらされる可能性がある場合、クイックチェックを使用する場合、危険があります。"
    },
    {
      "indent": 3,
      "text": "Disabling the quick check prevents the attack.",
      "ja": "クイックチェックを無効にすると、攻撃が防止されます。"
    },
    {
      "indent": 3,
      "text": "For very large encrypted data whose session key is protected by a passphrase using a v4 SKESK, the quick check may be convenient to the user by informing them early that they typed the wrong passphrase. But the implementation should use the quick check with care. The recommended approach for secure and early detection of decryption failure is to encrypt data using v2 SEIPD. If the session key is public key encrypted, the quick check is not useful as the public key encryption of the session key should guarantee that it is the right session key.",
      "ja": "セッションキーがV4 Skeskを使用してパスフレーズによって保護されている非常に大きな暗号化されたデータの場合、クイックチェックは、間違ったパスフレーズを入力したことを早期に通知することでユーザーに便利になる場合があります。ただし、実装では、慎重にクイックチェックを使用する必要があります。復号化障害の安全で早期に検出するための推奨アプローチは、V2 SEIPDを使用してデータを暗号化することです。セッションキーが公開キーの暗号化されている場合、セッションキーの公開キーの暗号化は正しいセッションキーであることを保証するため、クイックチェックは役に立ちません。"
    },
    {
      "indent": 3,
      "text": "The quick check oracle attack is a particular type of attack that exploits ciphertext malleability. For information about other similar attacks, see Section 13.7.",
      "ja": "クイックチェックのOracle攻撃は、暗号文化障害を悪用する特定のタイプの攻撃です。他の同様の攻撃については、セクション13.7を参照してください。"
    },
    {
      "indent": 0,
      "text": "13.5. Avoiding Leaks from PKCS#1 Errors",
      "section_title": true,
      "ja": "13.5. PKCS＃1エラーからのリークを回避します"
    },
    {
      "indent": 3,
      "text": "The PKCS#1 padding (used in RSA-encrypted and ElGamal-encrypted PKESK) has been found to be vulnerable to attacks in which a system that allows distinguishing padding errors from other decryption errors can act as a decryption and/or signing oracle that can leak the session key or allow signing arbitrary data, respectively [BLEICHENBACHER-PKCS1]. The number of queries required to carry out an attack can range from thousands to millions, depending on how strict and careful an implementation is in processing the padding.",
      "ja": "PKCS＃1パディング（RSA暗号化およびエルガマル暗号化されたPKESKで使用）は、他の復号化エラーからパディングエラーを区別することを可能にするシステムが、飾り付けおよび/または署名のオラクルとして作用するシステムが機能する攻撃に対して脆弱であることがわかっています。セッションキーをリークするか、それぞれ任意のデータに署名します[Bleichenbacher-PKCS1]。攻撃を実行するために必要なクエリの数は、パディングの処理において実装がどれほど厳しく慎重であるかに応じて、数千から数百万の範囲です。"
    },
    {
      "indent": 3,
      "text": "To make the attack more difficult, an implementation SHOULD implement strict, robust, and constant time padding checks.",
      "ja": "攻撃をより困難にするために、実装は厳格で堅牢で、一定のタイムパディングチェックを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "To prevent the attack, in settings where the attacker does not have access to timing information concerning message decryption, the simplest solution is to report a single error code for all variants of PKESK processing errors as well as SEIPD integrity errors (this also includes session key parsing errors, such as on an invalid cipher algorithm for v3 PKESK, or a session key size mismatch for v6 PKESK). If the attacker may have access to timing information, then a constant time solution is also needed. This requires careful design, especially for v3 PKESK, where session key size and cipher information is typically not known in advance, as it is part of the PKESK encrypted payload.",
      "ja": "攻撃を防ぐために、攻撃者がメッセージの復号化に関するタイミング情報にアクセスできない設定で、最も簡単な解決策は、PKSK処理エラーのすべてのバリエーションとSEIPDの整合性エラーの単一エラーコードを報告することです（これにはセッションキーも含まれますV3 PKESKの無効な暗号アルゴリズム、またはV6 PKESKのセッションキーサイズの不一致などの解析エラー。攻撃者がタイミング情報にアクセスできる場合は、一定の時間解決も必要です。これには、特にV3 PKSEKの場合、セッションキーサイズと暗号情報が通常事前に知られていないため、慎重に設計する必要があります。これは、PKSEK暗号化されたペイロードの一部であるためです。"
    },
    {
      "indent": 0,
      "text": "13.6. Fingerprint Usability",
      "section_title": true,
      "ja": "13.6. 指紋の使いやすさ"
    },
    {
      "indent": 3,
      "text": "This specification uses fingerprints in several places on the wire (e.g., Sections 5.2.3.23, 5.2.3.35, and 5.2.3.36) and in processing (e.g., in ECDH KDF Section 11.5). An implementation may also use the fingerprint internally, for example, as an index to a keystore.",
      "ja": "この仕様では、ワイヤー上のいくつかの場所（セクション5.2.3.23、5.2.3.35、および5.2.3.36など）および処理（ECDH KDFセクション11.5で）の指紋を使用します。実装は、たとえば、キーストアのインデックスとして、内部で指紋を内部で使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "Additionally, some OpenPGP users have historically used manual fingerprint comparison to verify the public key of a peer. For a version 4 fingerprint, this has typically been done with the fingerprint represented as 40 hexadecimal digits, often broken into groups of four digits with whitespace between each group.",
      "ja": "さらに、一部のOpenPGPユーザーは、ピアの公開鍵を検証するために、歴史的に手動指紋比較を使用してきました。バージョン4の指紋の場合、これは通常、40匹の16進数桁として表される指紋で行われ、多くの場合、各グループの間に空白がある4桁のグループに分かれています。"
    },
    {
      "indent": 3,
      "text": "When a human is actively involved, the result of such a verification is dubious. There is little evidence that most humans are good at precise comparison of high-entropy data, particularly when that data is represented in compact textual form like a hexadecimal [USENIX-STUDY].",
      "ja": "人間が積極的に関与している場合、そのような検証の結果は疑わしいです。特にそのデータが16進数[Usenix-study]のようなコンパクトなテキスト形式で表されている場合、ほとんどの人間が高エントロピーデータの正確な比較に優れているという証拠はほとんどありません。"
    },
    {
      "indent": 3,
      "text": "The version 6 fingerprint makes the challenge for a human verifier even worse. At 256 bits (compared to version 4's 160-bit fingerprint), a version 6 fingerprint is even harder for a human to successfully compare.",
      "ja": "バージョン6の指紋は、人間の検証者にとってさらに悪化します。256ビット（バージョン4の160ビット指紋と比較）では、バージョン6の指紋は、人間が正常に比較するのがさらに難しくなります。"
    },
    {
      "indent": 3,
      "text": "An OpenPGP implementation should prioritize mechanical fingerprint transfer and comparison where possible and SHOULD NOT promote manual transfer or comparison of full fingerprints by a human unless there is no other way to achieve the desired result.",
      "ja": "OpenPGPの実装は、可能であれば、機械的指紋の転送と比較に優先順位を付け、目的の結果を達成する他の方法がない限り、人間によるフルフィンガープリントの手動転送または比較を促進すべきではありません。"
    },
    {
      "indent": 3,
      "text": "While this subsection acknowledges existing practice for human-representable version 4 fingerprints, this document does not attempt to standardize any specific human-readable form of version 6 fingerprint for this discouraged use case.",
      "ja": "このサブセクションは、人間の代表性バージョン4フィンガープリントの既存の慣行を認めていますが、このドキュメントは、この落胆したユースケースのために、特定の人間読み取り可能なバージョン6フィンガープリントを標準化しようとはしていません。"
    },
    {
      "indent": 3,
      "text": "NOTE: the topic of interoperable human-in-the-loop key verification needs more work, which will be done in a separate document.",
      "ja": "注：相互運用可能な人間のループのキー検証のトピックには、さらに作業が必要になります。これは、別のドキュメントで行われます。"
    },
    {
      "indent": 0,
      "text": "13.7. Avoiding Ciphertext Malleability",
      "section_title": true,
      "ja": "13.7. 暗号文化障害の回避"
    },
    {
      "indent": 3,
      "text": "If ciphertext can be modified by an attacker but still subsequently decrypted to some new plaintext, it is considered \"malleable\". A number of attacks can arise in any cryptosystem that uses malleable encryption, so [RFC4880] and later versions of OpenPGP offer mechanisms to defend against it. However, OpenPGP data may have been created before these defense mechanisms were available. Because OpenPGP implementations deal with historic stored data, they may encounter malleable ciphertexts.",
      "ja": "Ciphertextを攻撃者によって変更できるが、それでもいくつかの新しいプレーンテキストに復号化された場合、「順応性」と見なされます。順応性暗号化を使用するすべての暗号システムでは、多くの攻撃が発生する可能性があるため、[RFC4880]およびOpenPGPの後のバージョンは、それを防御するメカニズムを提供します。ただし、これらの防御メカニズムが利用可能になる前に、OpenPGPデータが作成された可能性があります。OpenPGP実装は歴史的な保存データを扱うため、順応性のある暗号文に遭遇する可能性があります。"
    },
    {
      "indent": 3,
      "text": "When an OpenPGP implementation discovers that it is decrypting data that appears to be malleable, it MUST generate a clear error message that indicates the integrity of the message is suspect, it SHOULD NOT attempt to parse nor release decrypted data to the user, and it SHOULD halt with an error. Parsing or releasing decrypted data before having confirmed its integrity can leak the decrypted data [EFAIL] [MRLG15].",
      "ja": "OpenPGPの実装で、順応性があると思われるデータの復号化データであることが発見された場合、メッセージの整合性が疑わしいことを示す明確なエラーメッセージを生成する必要があります。エラーで停止します。復号化されたデータを解析または解放する前に、その整合性が復号化されたデータをリークできることを確認する前に[efail] [MRLG15]。"
    },
    {
      "indent": 3,
      "text": "In the case of AEAD encrypted data, if the authentication tag fails to verify, the implementation MUST NOT attempt to parse nor release decrypted data to the user, and it MUST halt with an error.",
      "ja": "AEAD暗号化されたデータの場合、認証タグが検証に失敗した場合、実装は復号化されたデータをユーザーに解析またはリリースしようとしてはならず、エラーで停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation that encounters malleable ciphertext MAY choose to release cleartext to the user if it is not encrypted using AEAD, it is known to be dealing with historic archived legacy data, and the user is aware of the risks.",
      "ja": "順応性のある暗号文に遭遇する実装は、AEADを使用して暗号化されていない場合、ユーザーにClearTextをリリースすることを選択できます。これは、歴史的なアーカイブされたレガシーデータを扱っていることが知られており、ユーザーはリスクを認識しています。"
    },
    {
      "indent": 3,
      "text": "In the case of AEAD encrypted messages, if the message is truncated, i.e., the final zero-octet chunk and possibly (part of) some chunks before it are missing, the implementation MAY choose to release cleartext from the fully authenticated chunks before it to the user if it is operating in a streaming fashion, but it MUST indicate a clear error message as soon as the truncation is detected.",
      "ja": "AEADの暗号化されたメッセージの場合、メッセージが切り捨てられている場合、つまり最終的なゼロオクテットチャンクと、おそらく（の一部）が欠落する前に（一部）、実装は完全に認証されたチャンクからクリアテキストをリリースすることを選択する場合があります。ユーザーはストリーミング方法で動作している場合は、切り捨てが検出されるとすぐに明確なエラーメッセージを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Any of the following OpenPGP data elements indicate that malleable ciphertext is present:",
      "ja": "次のOpenPGPデータ要素のいずれかが、順応性のある暗号文が存在することを示しています。"
    },
    {
      "indent": 6,
      "text": "* All Symmetrically Encrypted Data packets (Section 5.7).",
      "ja": "* すべて対称的に暗号化されたデータパケット（セクション5.7）。"
    },
    {
      "indent": 6,
      "text": "* Within any encrypted container, any Compressed Data packet (Section 5.6) where there is a decompression failure.",
      "ja": "* 暗号化されたコンテナ内では、減圧障害がある圧縮データパケット（セクション5.6）。"
    },
    {
      "indent": 6,
      "text": "* Any version 1 Symmetrically Encrypted and Integrity Protected Data packet (Section 5.13.1) where the internal Modification Detection Code does not validate.",
      "ja": "* 内部変更検出コードが検証しない場合、バージョン1は対称的に暗号化され、整合性と整合性の保護データパケット（セクション5.13.1）。"
    },
    {
      "indent": 6,
      "text": "* Any version 2 Symmetrically Encrypted and Integrity Protected Data packet (Section 5.13.2) where the authentication tag of any chunk fails or where there is no final zero-octet chunk.",
      "ja": "* 任意のバージョン2は、チャンクの認証タグが失敗した場合、または最終的なゼロオクテットチャンクがない場合、対称的に暗号化され、整合性と整合性の保護データパケット（セクション5.13.2）。"
    },
    {
      "indent": 6,
      "text": "* Any Secret-Key packet with encrypted secret key material (Section 3.7.2.1) where there is an integrity failure, based on the value of the secret key protection octet:",
      "ja": "* 暗号化されたシークレットキー資料を備えた秘密のキーパケット（セクション3.7.2.1）。秘密の鍵保護の価値に基づいて、整合性障害があります。"
    },
    {
      "indent": 12,
      "text": "- Value 253 (AEAD): where the AEAD authentication tag is invalid.",
      "ja": "- 値253（AEAD）：AEAD認証タグが無効です。"
    },
    {
      "indent": 12,
      "text": "- Value 254 (CFB): where the SHA1 checksum is mismatched.",
      "ja": "- 値254（CFB）：SHA1チェックサムが不一致になる場所。"
    },
    {
      "indent": 12,
      "text": "- Value 255 (MalleableCFB) or raw cipher algorithm: where the trailing 2-octet checksum does not match.",
      "ja": "- 値255（malleablecfb）または生の暗号アルゴリズム：後続の2-OCTETチェックサムが一致しない場合。"
    },
    {
      "indent": 3,
      "text": "To avoid these circumstances, an implementation that generates OpenPGP encrypted data SHOULD select the encrypted container format with the most robust protections that can be handled by the intended recipients. In particular:",
      "ja": "これらの状況を回避するために、OpenPGP暗号化されたデータを生成する実装では、意図した受信者が処理できる最も堅牢な保護を備えた暗号化されたコンテナ形式を選択する必要があります。特に："
    },
    {
      "indent": 6,
      "text": "* The SED packet is deprecated and MUST NOT be generated.",
      "ja": "* SEDパケットは非推奨であり、生成してはなりません。"
    },
    {
      "indent": 6,
      "text": "* When encrypting to one or more public keys:",
      "ja": "* 1つ以上のパブリックキーに暗号化するとき："
    },
    {
      "indent": 12,
      "text": "- If all recipient keys indicate support for a version 2 Symmetrically Encrypted and Integrity Protected Data packet in their Features signature subpacket (Section 5.2.3.32), if all recipient keys are version 6 keys without a Features signature subpacket, or the implementation can otherwise infer that all recipients support v2 SEIPD packets, the implementation SHOULD encrypt using a v2 SEIPD packet.",
      "ja": "- すべての受信者キーがバージョン2の対称的に暗号化され、整合性保護されたデータパケットのサポートが機能の署名サブパケット（セクション5.2.3.32）のサポートを示している場合、すべての受信者キーが特徴のないバージョン6キーである場合、または実装はそれ以外の場合は実装が推測できます。すべての受信者はV2 SEIPDパケットをサポートしており、実装はV2 SEIPDパケットを使用して暗号化する必要があります。"
    },
    {
      "indent": 12,
      "text": "- If one of the recipients does not support v2 SEIPD packets, then the message generator MAY use a v1 SEIPD packet instead.",
      "ja": "- 受信者の1人がV2 SEIPDパケットをサポートしていない場合、メッセージジェネレーターは代わりにV1 SEIPDパケットを使用できます。"
    },
    {
      "indent": 6,
      "text": "* Passphrase-protected secret key material in a version 6 Secret Key or version 6 Secret Subkey packet SHOULD be protected with AEAD encryption (S2K usage octet 253) unless it will be transferred to an implementation that is known to not support AEAD. An implementation should be aware that, in scenarios where an attacker has write access to encrypted private keys, CFB-encrypted keys (S2K usage octet 254 or 255) are vulnerable to corruption attacks that can cause leakage of secret data when the secret key is used [KOPENPGP] [KR02].",
      "ja": "* バージョン6シークレットキーまたはバージョン6シークレットサブキーパケットのパスフレーズ保護されたシークレットキー資料は、AEADをサポートしないことが知られている実装に転送されない限り、AEAD暗号化（S2K使用法Octet 253）で保護する必要があります。実装は、攻撃者が暗号化されたプライベートキーへの書き込みアクセスを持っているシナリオでは、CFB暗号化されたキー（S2K使用法Octet 254または255）は、秘密の鍵が使用されるときに秘密のデータの漏れを引き起こす可能性のある汚職攻撃に対して脆弱であることに注意する必要があります。[kopenpgp] [kr02]。"
    },
    {
      "indent": 3,
      "text": "Implementers should implement AEAD (v2 SEIPD and S2K usage octet 253) promptly and encourage its spread.",
      "ja": "実装者は、AEAD（V2 SEIPDおよびS2K使用量Octet 253）を迅速に実装し、その拡散を奨励する必要があります。"
    },
    {
      "indent": 3,
      "text": "Users are RECOMMENDED to migrate to AEAD.",
      "ja": "ユーザーはAEADに移行することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "13.8. Secure Use of the v2 SEIPD Session-Key-Reuse Feature",
      "section_title": true,
      "ja": "13.8. V2 SEIPDセッションキーリューズ機能の安全な使用"
    },
    {
      "indent": 3,
      "text": "The salted key derivation of v2 SEIPD packets (Section 5.13.2) allows the recipient of an encrypted message to reply to the sender and all other recipients without needing their public keys but by using the same v6 PKESK packets it received and a different random salt value. This ensures a secure mechanism on the cryptographic level that enables the use of message encryption in cases where a sender does not have a copy of an encryption-capable certificate for one or more participants in the conversation and thus can enhance the overall security of an application. However, care must be taken when using this mechanism not to create security vulnerabilities, such as the following:",
      "ja": "V2 SEIPDパケット（セクション5.13.2）の塩漬けキーの導出により、暗号化されたメッセージの受信者は、公開キーを必要とせずに送信者や他のすべての受信者に返信することができますが、受け取った同じV6 PKSEKパケットと異なるランダムソルトを使用して価値。これにより、送信者が会話の1人以上の参加者のための暗号化対応証明書のコピーを持っていない場合にメッセージ暗号化の使用を可能にする暗号化レベルでの安全なメカニズムが保証され、したがってアプリケーションの全体的なセキュリティを強化できます。ただし、このメカニズムを使用して、次のようなセキュリティの脆弱性を作成しないように注意する必要があります。"
    },
    {
      "indent": 6,
      "text": "* Replying to only a subset of the original recipients and the original sender by use of the session-key-reuse feature would mean that the remaining recipients (including the sender) of the original message could read the encrypted reply message, too.",
      "ja": "* セッションキーリーズ機能を使用して元の受信者のサブセットと元の送信者のみに返信すると、元のメッセージの残りの受信者（送信者を含む）が暗号化された返信メッセージを読み取ることができることを意味します。"
    },
    {
      "indent": 6,
      "text": "* Adding a further recipient to the reply that is encrypted using the session-key-reuse feature gives that further recipient also cryptographic access to the original message that is being replied to (and potentially to a longer history of previous messages).",
      "ja": "* セッションキーリューズ機能を使用して暗号化された返信にさらに受信者を追加すると、そのさらなる受信者が、返信されている元のメッセージへの暗号化アクセス（および以前のメッセージのより長い履歴にも）になります。"
    },
    {
      "indent": 6,
      "text": "* A modification of the list of recipients addressed in the above points also needs to be safeguarded when a message is initially composed as a reply with session-key reuse but then is stored (e.g., as a draft) and later reopened for further editing and to be finally sent.",
      "ja": "* 上記のポイントでアドレス指定された受信者のリストの変更は、メッセージが最初にセッションキーの再利用とともに返信として構成されているが、その後保存され（例えば、ドラフトとして）、さらに編集のために再開され、最終的に送信されます。"
    },
    {
      "indent": 6,
      "text": "* There is the potential threat that an attacker with network or mailbox access, who is at the same time a recipient of the original message, silently removes themselves from the message before the victim's client receives it. The victim's client that then uses the mechanism for replying with session-key reuse would unknowingly compose an encrypted message that could be read by the attacker. Implementations are encouraged to use the Intended Recipient Fingerprint subpacket (Section 5.2.3.36) when composing messages and checking the consistency of the set of recipients of a message before replying to it with session-key reuse.",
      "ja": "* ネットワークまたはメールボックスアクセスを備えた攻撃者が、元のメッセージの受信者と同時に、被害者のクライアントが受信する前に静かにメッセージから自分自身を削除する潜在的な脅威があります。その後、セッションキーの再利用で返信するためにメカニズムを使用する被害者のクライアントは、攻撃者が読むことができる暗号化されたメッセージを無意識のうちに作成します。実装は、メッセージを作成し、セッションキーの再利用で返信する前に、メッセージの受信者のセットの一貫性をチェックするときに、意図した受信者指紋サブパケット（セクション5.2.3.36）を使用することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "* When using the session-key-reuse feature in any higher-layer protocol, care should be taken to ensure that there is no other potentially interfering practice of session-key reuse established in that protocol. Such interfering session-key reuse could, for instance, be given -- if an initial message is already composed -- by reusing the session key of an existing encrypted file that may have been shared among a group of users already. Using the session-key-reuse feature to compose an encrypted reply to such a message would unknowingly give this whole group of users cryptographic access to the encrypted message.",
      "ja": "* 高レイヤープロトコルでセッションキーリューズ機能を使用する場合、そのプロトコルで確立されたセッションキーの再利用の潜在的に干渉する練習がないことを確認するように注意する必要があります。このような干渉セッションキーの再利用は、たとえば、すでにユーザーのグループ間で共有されている可能性のある既存の暗号化されたファイルのセッションキーを再利用することにより、最初のメッセージが既に構成されている場合、与えられる可能性があります。Session-Key-Reuse機能を使用して、そのようなメッセージへの暗号化された返信を作成すると、このグループのグループ全体が暗号化されたメッセージへの暗号化アクセスを無意識のうちに提供します。"
    },
    {
      "indent": 6,
      "text": "* Generally, the use of the session-key-reuse feature should be under the control of the user. Specifically, care should be taken so that this feature is not silently used when the user assumes that proper public key encryption is used. This can be the case, for instance, when the public key of one of the recipients of the reply is known but has expired. Special care should be taken to ensure that users do not get caught in continued use of the session-key reuse unknowingly but instead receive the chance to switch to proper fresh public key encryption as soon as possible.",
      "ja": "* 一般に、セッションキーリーズ機能の使用は、ユーザーの制御下にある必要があります。具体的には、ユーザーが適切な公開キーの暗号化が使用されると想定したときに、この機能が静かに使用されないように注意する必要があります。これは、たとえば、返信の受信者の1人の公開鍵が知られているが期限が切れている場合に当てはまります。ユーザーが無意識のうちにセッションキーの再利用の継続的な使用に巻き込まれないようにするために特別な注意を払う必要があります。"
    },
    {
      "indent": 6,
      "text": "* Whenever possible, a client should prefer a fresh public key encryption over the session-key reuse.",
      "ja": "* 可能な限り、クライアントはセッションキーの再利用よりも新鮮な公開キーの暗号化を好む必要があります。"
    },
    {
      "indent": 3,
      "text": "Even though this is not necessarily a security aspect, note that initially composing an encrypted reply using the session-key-reuse feature on one client and then storing it (e.g., as a draft) and later reopening the stored unfinished reply with another client that does not support the session-key-reuse feature may lead to interoperability problems.",
      "ja": "これは必ずしもセキュリティの側面ではありませんが、最初に1つのクライアントにセッションキーリューズ機能を使用して暗号化された返信を構成し、それを保存（ドラフトとして）保存し、後に保存された未定の返信を別のクライアントと再開することに注意してください。セッションキーリューズ機能をサポートしていない可能性があり、相互運用性の問題につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Avoiding the pitfalls described above requires context-specific expertise. An implementation should only make use of the session-key-reuse feature in any particular application layer when it can follow reasonable documentation about how to deploy the feature safely in the specific application. At the time of this writing, there is no known documentation about safe reuse of OpenPGP session keys for any specific context. An implementer that intends to make use of this feature should publish their own proposed guidance for others to review.",
      "ja": "上記の落とし穴を回避するには、コンテキスト固有の専門知識が必要です。実装は、特定のアプリケーションで機能を安全に展開する方法に関する合理的なドキュメントに従うことができる場合にのみ、特定のアプリケーションレイヤーでセッションキーリーズ機能を使用する必要があります。この執筆時点では、特定のコンテキストのOpenPGPセッションキーの安全な再利用に関する既知のドキュメントはありません。この機能を使用する予定の実装者は、他の人がレビューするために独自の提案されたガイダンスを公開する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.9. Escrowed Revocation Signatures",
      "section_title": true,
      "ja": "13.9. エスクローされた取り消し署名"
    },
    {
      "indent": 3,
      "text": "A keyholder, Alice, may wish to designate a third party to be able to revoke her own key.",
      "ja": "キーホルダーのアリスは、自分の鍵を取り消すことができるように第三者を指定したいと考えています。"
    },
    {
      "indent": 3,
      "text": "The preferred way for Alice to do this is to produce a specific Revocation Signature (Signature Type ID 0x20, 0x28, or 0x30) and distribute it securely to a preferred revoker who can hold it in escrow. The preferred revoker can then publish the escrowed Revocation Signature at whatever time is deemed appropriate rather than generating the Revocation Signature themselves.",
      "ja": "アリスがこれを行うための好ましい方法は、特定の取り消し署名（署名タイプID 0x20、0x28、または0x30）を作成し、それをエスクローに保持できる優先リバーカーにしっかりと配布することです。希望するリバーカーは、取り消し署名を自分で生成するのではなく、適切とみなされる時点で、エスクローされた取り消し署名を公開できます。"
    },
    {
      "indent": 3,
      "text": "There are multiple advantages of using an escrowed Revocation Signature over the deprecated Revocation Key subpacket (Section 5.2.3.23):",
      "ja": "非推奨の取り消しキーサブパケット（セクション5.2.3.23）にエスクローされた失効署名を使用することには、複数の利点があります。"
    },
    {
      "indent": 6,
      "text": "* The keyholder can constrain what types of revocation the preferred revoker can issue, by only escrowing those specific signatures.",
      "ja": "* キーホルダーは、これらの特定の署名のみを展開するだけで、優先されるリバーカーが発行できる失効の種類を制約することができます。"
    },
    {
      "indent": 6,
      "text": "* There is no public/visible linkage between the keyholder and the preferred revoker.",
      "ja": "* キーホルダーと優先リバッカーの間には、公開/目に見えるリンケージはありません。"
    },
    {
      "indent": 6,
      "text": "* Third parties can verify the revocation without needing to find the key of the preferred revoker.",
      "ja": "* 第三者は、優先されたリバーカーの鍵を見つける必要なく、取り消しを検証できます。"
    },
    {
      "indent": 6,
      "text": "* The preferred revoker doesn't even need to have a public OpenPGP Key if some other secure transport is possible between them and the keyholder.",
      "ja": "* 優先されたリバーカーは、他の安全なトランスポートがそれらとキーホルダーの間で可能な場合、公開OpenPGPキーを持つ必要さえありません。"
    },
    {
      "indent": 6,
      "text": "* Implementation support for enforcing a revocation from an authorized Revocation Key subpacket is uneven and unreliable.",
      "ja": "* 承認された取り消しキーサブパケットからの取り消しを実施するための実装サポートは不均一で信頼できません。"
    },
    {
      "indent": 6,
      "text": "* If the fingerprint mechanism suffers a cryptanalytic flaw, the escrowed Revocation Signature is not affected.",
      "ja": "* 指紋メカニズムが暗号化の欠陥に苦しむ場合、エスクローされた失効署名は影響を受けません。"
    },
    {
      "indent": 3,
      "text": "A Revocation Signature may also be split up into shares and distributed among multiple parties, requiring some subset of those parties to collaborate before the escrowed Revocation Signature is recreated.",
      "ja": "また、取り消し署名は株式に分割され、複数の当事者間で分配される場合があります。これは、エスクローされた取り消し署名が再作成される前に、これらの当事者のサブセットを協力することを要求することができます。"
    },
    {
      "indent": 0,
      "text": "13.10. Random Number Generation and Seeding",
      "section_title": true,
      "ja": "13.10. 乱数の生成と播種"
    },
    {
      "indent": 3,
      "text": "OpenPGP requires a cryptographically secure pseudorandom number generator (CSPRNG). In most cases, the operating system provides an appropriate facility such as a getrandom() syscall on Linux or BSD, which should be used absent other (for example, performance) concerns. It is RECOMMENDED to use an existing CSPRNG implementation as opposed to crafting a new one. Many adequate cryptographic libraries are already available under favorable license terms. Should those prove unsatisfactory, [RFC4086] provides guidance on the generation of random values.",
      "ja": "OpenPGPには、暗号化された擬似ランダム数ジェネレーター（CSPRNG）が必要です。ほとんどの場合、オペレーティングシステムは、LinuxまたはBSDのgetRandom（）Syscallなどの適切な施設を提供します。新しいものを作成するのではなく、既存のCSPRNG実装を使用することをお勧めします。多くの適切な暗号化ライブラリは、有利なライセンス条件の下ですでに利用可能です。それらが不満足であることが証明された場合、[RFC4086]はランダム値の生成に関するガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "OpenPGP uses random data with three different levels of visibility:",
      "ja": "OpenPGPは、3つの異なるレベルの可視性を持つランダムデータを使用します。"
    },
    {
      "indent": 6,
      "text": "* In publicly visible fields such as nonces, IVs, public padding material, or salts.",
      "ja": "* Nonces、IV、Public Padding Material、または塩などの公開されているフィールド。"
    },
    {
      "indent": 6,
      "text": "* In shared-secret values, such as session keys for encrypted data or padding material within an encrypted packet.",
      "ja": "* 暗号化されたデータのセッションキーや、暗号化されたパケット内のパディング材料などの共有秘密値。"
    },
    {
      "indent": 6,
      "text": "* In entirely private data, such as asymmetric key generation.",
      "ja": "* 非対称キー生成など、完全にプライベートデータ。"
    },
    {
      "indent": 3,
      "text": "With a properly functioning CSPRNG, this range of visibility does not present a security problem, as it is not feasible to determine the CSPRNG state from its output. However, with a broken CSPRNG, it may be possible for an attacker to use visible output to determine the CSPRNG internal state and thereby predict less-visible data like keying material, as documented in [CHECKOWAY].",
      "ja": "適切に機能するCSPRNGでは、この視界の範囲は、CSPRNG状態をその出力から決定することができないため、セキュリティの問題を提示しません。ただし、CSPRNGが壊れた場合、攻撃者は可視出力を使用してCSPRNG内部状態を決定し、それにより[CheckoWay]で文書化されているように、キーイング素材のような可視性の低いデータを予測できる可能性があります。"
    },
    {
      "indent": 3,
      "text": "An implementation can provide extra security against this form of attack by using separate CSPRNGs to generate random data with different levels of visibility.",
      "ja": "実装は、個別のCSPRNGを使用して異なるレベルの可視性を持つランダムデータを生成することにより、この形式の攻撃に対して追加のセキュリティを提供できます。"
    },
    {
      "indent": 0,
      "text": "13.11. Traffic Analysis",
      "section_title": true,
      "ja": "13.11. トラフィック分析"
    },
    {
      "indent": 3,
      "text": "When sending OpenPGP data through the network, the size of the data may leak information to an attacker. There are circumstances where such a leak could be unacceptable from a security perspective.",
      "ja": "ネットワークを介してOpenPGPデータを送信すると、データのサイズが攻撃者に情報をリークする場合があります。このようなリークがセキュリティの観点から受け入れられない可能性がある状況があります。"
    },
    {
      "indent": 3,
      "text": "For example, if possible cleartext messages for a given protocol are known to be either yes (3 octets) or no (2 octets) and the messages are sent within a Symmetrically Encrypted and Integrity Protected Data packet, the length of the encrypted message will reveal the contents of the cleartext.",
      "ja": "たとえば、可能であれば、特定のプロトコルのクリアテキストメッセージは、はい（3オクテット）またはNO（2オクテット）のいずれかであることが知られており、メッセージは対称的に暗号化された整合性保護データパケット内で送信されます。暗号化されたメッセージの長さは明らかになりますClearTextの内容。"
    },
    {
      "indent": 3,
      "text": "In another example, sending an OpenPGP Transferable Public Key over an encrypted network connection might reveal the length of the certificate. Since the length of an OpenPGP certificate varies based on the content, an external observer interested in metadata (e.g., which individual is trying to contact another individual) may be able to guess the identity of the certificate sent, if its length is unique.",
      "ja": "別の例では、暗号化されたネットワーク接続の上にOpenPGP転送可能な公開キーを送信すると、証明書の長さが明らかになる場合があります。OpenPGP証明書の長さはコンテンツに基づいて異なるため、メタデータに関心のある外部オブザーバー（たとえば、個人が別の個人に連絡しようとしている）は、その長さが一意である場合、送信された証明書の身元を推測できる場合があります。"
    },
    {
      "indent": 3,
      "text": "In both cases, an implementation can adjust the size of the compound structure by including a Padding packet (see Section 5.14).",
      "ja": "どちらの場合も、実装はパディングパケットを含めることにより、化合物構造のサイズを調整できます（セクション5.14を参照）。"
    },
    {
      "indent": 0,
      "text": "13.12. Surreptitious Forwarding",
      "section_title": true,
      "ja": "13.12. 秘密の転送"
    },
    {
      "indent": 3,
      "text": "When an attacker obtains a signature for some text, e.g., by receiving a signed message, they may be able to use that signature maliciously by sending a message purporting to come from the original sender, with the same body and signature, to a different recipient. To prevent this, an implementation SHOULD implement the Intended Recipient Fingerprint subpacket (Section 5.2.3.36).",
      "ja": "攻撃者がいくつかのテキストの署名を取得する場合、たとえば署名されたメッセージを受信することにより、同じ本文と署名を持つ元の送信者から来るように主張するメッセージを別の受信者に送信することにより、その署名を悪意を持って使用できる場合があります。。これを防ぐために、実装では、意図した受信者指紋サブパケット（セクション5.2.3.36）を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.13. Hashed vs. Unhashed Subpackets",
      "section_title": true,
      "ja": "13.13. ハッシュされたサブパケットと非粉砕されたサブパケット"
    },
    {
      "indent": 3,
      "text": "Each OpenPGP signature can have subpackets in two different sections. The first set of subpackets (the \"hashed section\") is covered by the signature itself. The second set has no cryptographic protections and is used for advisory material only, including locally stored annotations about the signature.",
      "ja": "各OpenPGP署名は、2つの異なるセクションにサブパケットを持つことができます。サブパケットの最初のセット（「ハッシュセクション」）は、署名自体で覆われています。2番目のセットには暗号化保護がなく、署名に関するローカルに保存された注釈を含むアドバイザリー資料のみに使用されます。"
    },
    {
      "indent": 3,
      "text": "For example, consider an implementation working with a specific signature that happens to know that the signature was made by a certain key, even though the signature contains no Issuer Fingerprint subpacket (Section 5.2.3.35) in the hashed section. That implementation MAY synthesize an Issuer Fingerprint subpacket and store it in the unhashed section so that it will be able to recall which key issued the signature in the future.",
      "ja": "たとえば、署名にはハッシュセクションに発行者の指紋サブパケット（セクション5.2.3.35）が含まれていない場合でも、署名が特定のキーによって作成されたことを知っている特定の署名を使用して動作する実装を検討してください。その実装は、発行者の指紋サブパケットを統合し、非粉砕セクションに保存して、将来どのキーが署名を発行したかを思い出すことができるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "Some subpackets are only useful when they are in the hashed section, and an implementation SHOULD ignore them when they are found with unknown provenance in the unhashed section. For example, a Preferred AEAD Ciphersuites subpacket (Section 5.2.3.15) in a Direct Key self-signature indicates the preferences of the keyholder when encrypting v2 SEIPD data to the key. An implementation that observes such a subpacket found in the unhashed section would open itself to an attack where the recipient's certificate is tampered with to encourage the use of a specific cipher or mode of operation.",
      "ja": "一部のサブパケットは、ハッシュされたセクションにある場合にのみ便利であり、実装は、非粉砕セクションで不明な出所で見つかった場合にそれらを無視する必要があります。たとえば、直接キーの自己署名の優先されるAEAD Ciphersuitesサブパケット（セクション5.2.3.15）は、V2 SEIPDデータをキーに暗号化するときのキーホルダーの好みを示します。非粉砕セクションにあるこのようなサブパケットを観察する実装は、特定の暗号または操作モードの使用を促進するために、受信者の証明書が改ざんされている攻撃にそれ自体を開きます。"
    },
    {
      "indent": 0,
      "text": "13.14. Malicious Compressed Data",
      "section_title": true,
      "ja": "13.14. 悪意のある圧縮データ"
    },
    {
      "indent": 3,
      "text": "It is possible to form a compression quine that produces itself upon decompression, leading to infinite regress in any implementation willing to parse arbitrary numbers of layers of compression. This could cause resource exhaustion, which itself could lead to termination by the operating system. If the operating system creates a \"crash report\", that report could contain confidential information.",
      "ja": "減圧時にそれ自体を生成する圧縮クインを形成することが可能です。これにより、リソースの疲労が生じる可能性があり、それ自体がオペレーティングシステムによる終了につながる可能性があります。オペレーティングシステムが「クラッシュレポート」を作成した場合、そのレポートには機密情報が含まれる可能性があります。"
    },
    {
      "indent": 3,
      "text": "An OpenPGP implementation SHOULD limit the number of layers of compression it is willing to decompress in a single message.",
      "ja": "OpenPGPの実装は、単一のメッセージで減圧することをいとわない圧縮の層の数を制限するはずです。"
    },
    {
      "indent": 0,
      "text": "14. Implementation Considerations",
      "section_title": true,
      "ja": "14. 実装の考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is a collection of comments to help an implementer who has a particular interest in backward compatibility. Often the differences are small, but small differences are frequently more vexing than large differences. Thus, this is a non-comprehensive list of potential problems and gotchas for a developer who is trying to achieve backward compatibility.",
      "ja": "このセクションは、後方互換性に特に関心を持っている実装者を支援するためのコメントのコレクションです。多くの場合、違いは小さくなりますが、小さな違いは大きな違いよりも厄介です。したがって、これは、潜在的な問題の非包括的なリストであり、後方互換性を達成しようとしている開発者のためのGotchasです。"
    },
    {
      "indent": 6,
      "text": "* There are many possible ways for two keys to have the same key material but different fingerprints (and thus different Key IDs). For example, since a version 4 fingerprint is constructed by hashing the key creation time along with other things, two version 4 keys created at different times yet with the same key material will have different fingerprints.",
      "ja": "* 2つのキーが同じキーマテリアルを持っているが、異なる指紋（したがって異なるキーID）を持つための多くの方法があります。たとえば、バージョン4の指紋は、キー作成時間を他のものと一緒にハッシュすることによって構築されるため、同じキーマテリアルで作成された2つのバージョン4キーは異なる指紋を持ちます。"
    },
    {
      "indent": 6,
      "text": "* OpenPGP does not put limits on the size of public keys. However, larger keys are not necessarily better keys. Larger keys take more computation time to use, and this can quickly become impractical. Different OpenPGP implementations may also use different upper bounds for public key sizes, so care should be taken when choosing sizes to maintain interoperability.",
      "ja": "* OpenPGPは、パブリックキーのサイズに制限を設けません。ただし、大きなキーは必ずしもより良いキーではありません。より大きなキーは使用するのにより多くの計算時間がかかり、これはすぐに非現実的になる可能性があります。異なるOpenPGPの実装は、公開キーのサイズに異なる上限を使用する可能性があるため、相互運用性を維持するためにサイズを選択する場合は注意が必要です。"
    },
    {
      "indent": 6,
      "text": "* ASCII Armor is an optional feature of OpenPGP. The OpenPGP Working Group strives for a minimal set of mandatory-to-implement features, and since there could be useful implementations that only use binary object formats, this is not a \"MUST\" feature for an implementation. For example, an implementation that is using OpenPGP as a mechanism for file signatures may find ASCII Armor unnecessary. OpenPGP permits an implementation to declare what features it does and does not support, but ASCII Armor is not one of these. Since most implementations allow binary and armored objects to be used indiscriminately, an implementation that does not implement ASCII Armor may find itself with compatibility issues with general-purpose implementations. Moreover, implementations of OpenPGP-MIME [RFC3156] already have a requirement for ASCII Armor, so those implementations will necessarily have support.",
      "ja": "* ASCIIアーマーは、OpenPGPのオプション機能です。OpenPGPのワーキンググループは、最小限の必須の機能の機能を求めて努力しており、バイナリオブジェクト形式のみを使用する便利な実装がある可能性があるため、これは実装の「必須」機能ではありません。たとえば、ファイル署名のメカニズムとしてOpenPGPを使用している実装では、ASCIIアーマーが不要になる場合があります。OpenPGPは、実装がそれがどのような機能をサポートしていないかを宣言することを許可しますが、ASCIIアーマーはこれらの1つではありません。ほとんどの実装により、バイナリおよび装甲オブジェクトを無差別に使用することができるため、ASCIIアーマーを実装していない実装は、汎用実装との互換性の問題を抱えている可能性があります。さらに、OpenPGP-Mime [RFC3156]の実装には、ASCIIアーマーの要件がすでにあるため、これらの実装には必然的にサポートがあります。"
    },
    {
      "indent": 6,
      "text": "* What this document calls the \"Legacy packet format\" (Section 4.2.2) is what older documents called the \"old packet format\". It is the packet format used by implementations predating [RFC2440]. The current \"OpenPGP packet format\" (Section 4.2.1) was called the \"new packet format\" by older RFCs. This is the format introduced in [RFC2440] and maintained through [RFC4880] to this document.",
      "ja": "* このドキュメントが「レガシーパケット形式」（セクション4.2.2）と呼ぶものは、「古いパケット形式」と呼ばれる古いドキュメントです。これは、[RFC2440]の前の実装で使用されるパケット形式です。現在の「OpenPGPパケット形式」（セクション4.2.1）は、古いRFCSによって「新しいパケット形式」と呼ばれていました。これは、[RFC2440]で導入され、[RFC4880]を介してこのドキュメントに維持されている形式です。"
    },
    {
      "indent": 0,
      "text": "14.1. Constrained Legacy Fingerprint Storage for Version 6 Keys",
      "section_title": true,
      "ja": "14.1. バージョン6キー用の制約付きレガシー指紋ストレージ"
    },
    {
      "indent": 3,
      "text": "Some OpenPGP implementations have fixed length constraints for key fingerprint storage that will not fit all 32 octets of a version 6 fingerprint. For example, [OPENPGPCARD] reserves 20 octets for each stored fingerprint.",
      "ja": "一部のOpenPGP実装には、バージョン6フィンガープリントの32オクテットすべてに適合しない主要な指紋ストレージの固定長の制約があります。たとえば、[OpenPGPCard]は、保存されている各指紋に対して20個のオクテットを予約します。"
    },
    {
      "indent": 3,
      "text": "An OpenPGP implementation MUST NOT attempt to map any part of a version 6 fingerprint to such a constrained field unless the relevant specification for the constrained environment has explicit guidance for storing a version 6 fingerprint that distinguishes it from a version 4 fingerprint. An implementation interacting with such a constrained field SHOULD directly calculate the version 6 fingerprint from public key material and associated metadata instead of relying on the constrained field.",
      "ja": "OpenPGPの実装は、制約された環境の関連する仕様に、バージョン4の指紋を区別するバージョン6指紋を保存するための明示的なガイダンスがない限り、バージョン6の指紋の一部をそのような制約されたフィールドにマッピングしようとしてはなりません。このような制約されたフィールドと対話する実装は、制約されたフィールドに依存するのではなく、公開キー資料と関連するメタデータからバージョン6フィンガープリントを直接計算する必要があります。"
    },
    {
      "indent": 0,
      "text": "15. IANA Considerations",
      "section_title": true,
      "ja": "15. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC4880]. IANA has updated all registration information that references [RFC4880] to reference this RFC instead.",
      "ja": "この文書は廃止[RFC4880]。IANAは、[RFC4880]を参照するすべての登録情報を更新して、代わりにこのRFCを参照しています。"
    },
    {
      "indent": 0,
      "text": "15.1. Renamed Protocol Group",
      "section_title": true,
      "ja": "15.1. 改名されたプロトコルグループ"
    },
    {
      "indent": 3,
      "text": "IANA bundles a set of registries associated with a particular protocol into a \"protocol group\". IANA has updated the name of the \"Pretty Good Privacy (PGP)\" protocol group (i.e., the group of registries described at <https://www.iana.org/assignments/pgp-parameters>) to \"OpenPGP\". IANA has arranged a permanent redirect from the existing URL to the new URL for the registries in this protocol group. All further updates specified below are for registries within this same OpenPGP protocol group.",
      "ja": "IANAは、特定のプロトコルに関連付けられた一連のレジストリを「プロトコルグループ」にバンドルします。IANAは、「Pretty Good Privacy（PGP）」プロトコルグループ（すなわち、<https://www.iana.org/assignments/pgp-parameters>）に「OpenPGP」に記載されているレジストリのグループの名前を更新しました。IANAは、このプロトコルグループのレジストリの既存のURLから新しいURLへの永続的なリダイレクトを配置しました。以下に指定されたすべての更新は、この同じOpenPGPプロトコルグループ内のレジストリ用です。"
    },
    {
      "indent": 0,
      "text": "15.2. Renamed and Updated Registries",
      "section_title": true,
      "ja": "15.2. 改名および更新されたレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"PGP String-to-Key (S2K)\" registry to \"OpenPGP String-to-Key (S2K) Types\" and updated its contents as shown in Table 1.",
      "ja": "IANAは、「PGP String-to-Key（S2K）」レジストリに「OpenPGP String-to-Key（S2K）タイプ」に名前を変更し、表1に示すようにその内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"PGP Packet Types/Tags\" registry to \"OpenPGP Packet Types\" and updated its contents as shown in Table 3.",
      "ja": "IANAは、「PGPパケットタイプ/タグ」レジストリに「OpenPGPパケットタイプ」に名前を変更し、表3に示すようにその内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Signature Subpacket Types\" registry to \"OpenPGP Signature Subpacket Types\" and updated its contents as shown in Table 5.",
      "ja": "IANAは、「署名サブパケットタイプ」レジストリを「OpenPGP署名サブパケットタイプ」に変更し、表5に示すようにその内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Key Server Preference Extensions\" registry to \"OpenPGP Key Server Preference Flags\" and updated its contents as shown in Table 8.",
      "ja": "IANAは、表8に示すように、「キーサーバー優先拡張機能」レジストリを「OpenPGPキーサーバー優先フラグ」に変更し、その内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Key Flags Extensions\" registry to \"OpenPGP Key Flags\" and updated its contents as shown in Table 9.",
      "ja": "IANAは、表9に示すように、「キーフラグ拡張機能」レジストリを「OpenPGPキーフラグ」に変更し、その内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Reason for Revocation Extensions\" registry to \"OpenPGP Reason for Revocation (Revocation Octet)\" and updated its contents as shown in Table 10.",
      "ja": "IANAは、「取り消し拡張の理由」レジストリを「OpenPGP Reaste of Reaste of Reaste of Regoncocation（Rococation Octet）」に改名し、表10に示すように内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Implementation Features\" registry to \"OpenPGP Features Flags\" and updated its contents as shown in Table 11.",
      "ja": "IANAは、「実装機能」レジストリを「OpenPGP機能フラグ」に変更し、表11に示すようにその内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"PGP User Attribute Types\" registry to \"OpenPGP User Attribute Subpacket Types\" and updated its contents as shown in Table 13.",
      "ja": "IANAは、「PGPユーザー属性タイプ」レジストリを「OpenPGPユーザー属性サブパケットタイプ」に変更し、表13に示すようにその内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Image Format Subpacket Types\" registry to \"OpenPGP Image Attribute Encoding Format\" and updated its contents as shown in Table 15.",
      "ja": "IANAは、表15に示すように、「画像形式のサブパケットタイプ」レジストリに「OpenPGP Image属性エンコード形式」に変更し、その内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Public Key Algorithms\" registry to \"OpenPGP Public Key Algorithms\" and updated its contents as shown in Table 18.",
      "ja": "IANAは、「公開キーアルゴリズム」レジストリを「OpenPGP公開キーアルゴリズム」に変更し、表18に示すようにその内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Symmetric Key Algorithms\" registry to \"OpenPGP Symmetric Key Algorithms\" and updated its contents as shown in Table 21.",
      "ja": "IANAは、「対称キーアルゴリズム」レジストリを「OpenPGP対称キーアルゴリズム」に変更し、表21に示すようにその内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Compression Algorithms\" registry to \"OpenPGP Compression Algorithms\" and updated its contents as shown in Table 22.",
      "ja": "IANAは、「圧縮アルゴリズム」レジストリを「OpenPGP圧縮アルゴリズム」に変更し、表22に示すようにその内容を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has renamed the \"Hash Algorithms\" registry to \"OpenPGP Hash Algorithms\" and updated its contents as shown in Table 23.",
      "ja": "IANAは、表23に示すように、「ハッシュアルゴリズム」レジストリを「OpenPGPハッシュアルゴリズム」に変更し、その内容を更新しました。"
    },
    {
      "indent": 0,
      "text": "15.3. Removed Registry",
      "section_title": true,
      "ja": "15.3. レジストリを削除しました"
    },
    {
      "indent": 3,
      "text": "IANA has marked the empty \"New Packet Versions\" registry as OBSOLETE.",
      "ja": "IANAは、空の「新しいパケットバージョン」レジストリを時代遅れとしてマークしました。"
    },
    {
      "indent": 3,
      "text": "A tombstone note has been added to the OpenPGP protocol group with the following content:",
      "ja": "Tombstoneノートは、次のコンテンツを使用してOpenPGPプロトコルグループに追加されました。"
    },
    {
      "indent": 0,
      "text": "Those wishing to use the removed \"New Packet Versions\" registry should instead register new versions of the relevant packets in the \"OpenPGP Key and Signature Versions\", \"OpenPGP Key IDs and Fingerprints\", and \"OpenPGP Encrypted Message Packet Versions\" registries.",
      "ja": "削除された「新しいパケットバージョン」レジストリを使用したい場合は、代わりに「OpenPGPキーおよび署名バージョン」、「OpenPGPキーIDと指紋」、および「OpenPGP暗号化されたメッセージパケットバージョン」レジストリに関連するパケットの新しいバージョンを登録する必要があります。"
    },
    {
      "indent": 0,
      "text": "15.4. Added Registries",
      "section_title": true,
      "ja": "15.4. レジストリを追加しました"
    },
    {
      "indent": 3,
      "text": "IANA has added the following registries in the OpenPGP protocol group. Note that the initial contents of each registry is shown in the corresponding table.",
      "ja": "IANAは、OpenPGPプロトコルグループに次のレジストリを追加しました。各レジストリの初期内容は、対応する表に示されていることに注意してください。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Secret Key Encryption (S2K Usage Octet)\" (Table 2).",
      "ja": "* 「OpenPGP Secret Key暗号化（S2K使用量Octet）」（表2）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Signature Types\" (Table 4).",
      "ja": "* 「OpenPGP署名タイプ」（表4）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Signature Notation Data Subpacket Notation Flags\" (Table 6).",
      "ja": "* 「OpenPGP署名表記データサブパケット表記フラグ」（表6）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Signature Notation Data Subpacket Types\" (Table 7).",
      "ja": "* 「OpenPGP署名表記データサブパケットタイプ」（表7）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Key IDs and Fingerprints\" (Table 12).",
      "ja": "* 「OpenPGPキーIDと指紋」（表12）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Image Attribute Versions\" (Table 14).",
      "ja": "* 「OpenPGP画像属性バージョン」（表14）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Armor Header Lines\" (Table 16).",
      "ja": "* 「OpenPGPアーマーヘッダーライン」（表16）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Armor Header Keys\" (Table 17).",
      "ja": "* 「OpenPGPアーマーヘッダーキー」（表17）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP ECC Curve OIDs and Usage\" (Table 19).",
      "ja": "* 「OpenPGP ECC Curve OIDと使用量」（表19）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP ECC Curve-Specific Wire Formats\" (Table 20).",
      "ja": "* 「OpenPGP ECC曲線固有のワイヤ形式」（表20）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Hash Algorithm Identifiers for RSA Signatures' Use of EMSA-PKCS1-v1_5 Padding\" (Table 24).",
      "ja": "* 「RSA署名のEMSA-PKCS1-V1_5パディングの使用のOpenPGPハッシュアルゴリズム識別子」（表24）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP AEAD Algorithms\" (Table 25).",
      "ja": "* 「OpenPGP AEADアルゴリズム」（表25）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Encrypted Message Packet Versions\" (Table 26).",
      "ja": "* 「OpenPGP暗号化されたメッセージパケットバージョン」（表26）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Key and Signature Versions\" (Table 27).",
      "ja": "* 「OpenPGPキーおよび署名バージョン」（表27）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Elliptic Curve Point Wire Formats\" (Table 28).",
      "ja": "* 「OpenPGP楕円曲線ポイントワイヤ形式」（表28）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Elliptic Curve Scalar Encodings\" (Table 29).",
      "ja": "* 「OpenPGP楕円曲線スカラーエンコーディング」（表29）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP ECDH KDF and KEK Parameters\" (Table 30).",
      "ja": "* 「OpenPGP ECDH KDFおよびKEKパラメーター」（表30）。"
    },
    {
      "indent": 0,
      "text": "15.5. Registration Policies",
      "section_title": true,
      "ja": "15.5. 登録ポリシー"
    },
    {
      "indent": 3,
      "text": "All registries within the OpenPGP protocol group, with the exception of the registries listed in Section 15.5.1, use the Specification Required registration policy; see Section 4.6 of [RFC8126]. This policy means that review and approval by a designated expert is required and that the IDs and their meanings must be documented in a permanent and readily available public specification, in sufficient detail, so that interoperability between independent implementations is possible.",
      "ja": "セクション15.5.1にリストされているレジストリを除き、OpenPGPプロトコルグループ内のすべてのレジストリは、登録ポリシーの仕様を使用します。[RFC8126]のセクション4.6を参照してください。このポリシーは、指定された専門家によるレビューと承認が必要であり、独立した実装間の相互運用性が可能であるため、IDSとその意味を十分に詳細に、恒久的で容易に利用できるパブリック仕様で文書化する必要があることを意味します。"
    },
    {
      "indent": 0,
      "text": "15.5.1. Registries That Use RFC Required",
      "section_title": true,
      "ja": "15.5.1. RFCを使用するレジストリが必要です"
    },
    {
      "indent": 3,
      "text": "The following registries use the RFC Required registration policy, as described in Section 4.7 of [RFC8126]:",
      "ja": "次のレジストリは、[RFC8126]のセクション4.7で説明されているように、RFCが必要とする登録ポリシーを使用しています。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Packet Types\" (Table 3).",
      "ja": "* 「OpenPGPパケットタイプ」（表3）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Key IDs and Fingerprints\" (Table 12).",
      "ja": "* 「OpenPGPキーIDと指紋」（表12）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Encrypted Message Packet Versions\" (Table 26).",
      "ja": "* 「OpenPGP暗号化されたメッセージパケットバージョン」（表26）。"
    },
    {
      "indent": 6,
      "text": "* \"OpenPGP Key and Signature Versions\" (Table 27).",
      "ja": "* 「OpenPGPキーおよび署名バージョン」（表27）。"
    },
    {
      "indent": 0,
      "text": "15.6. Designated Experts",
      "section_title": true,
      "ja": "15.6. 指定された専門家"
    },
    {
      "indent": 3,
      "text": "The designated experts will determine whether the new registrations retain the security properties that are expected by the base implementation and whether these new registrations do not cause interoperability issues with existing implementations, other than not producing or consuming the IDs associated with these new registrations. Registration proposals that fail to meet these criteria could instead be proposed as new work items for the OpenPGP Working Group or its successor.",
      "ja": "指定された専門家は、新しい登録が基本実装によって予想されるセキュリティプロパティを保持しているかどうか、およびこれらの新しい登録が、これらの新しい登録に関連するIDを作成または消費しないことを除いて、既存の実装で相互運用性の問題を引き起こさないかどうかを決定します。代わりに、これらの基準を満たさない登録提案は、OpenPGPワーキンググループまたはその後継者の新しい作業項目として提案できます。"
    },
    {
      "indent": 3,
      "text": "The subsections below describe specific guidance for classes of registry updates that a designated expert will consider.",
      "ja": "以下のサブセクションでは、指定された専門家が考慮するレジストリアップデートのクラスの特定のガイダンスについて説明します。"
    },
    {
      "indent": 3,
      "text": "The designated experts should also consider Section 12.11 when reviewing proposed additions to the OpenPGP protocol group.",
      "ja": "指定された専門家は、OpenPGPプロトコルグループへの提案された追加をレビューする際には、セクション12.11も考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "15.6.1. Key and Signature Versions",
      "section_title": true,
      "ja": "15.6.1. キーおよび署名バージョン"
    },
    {
      "indent": 3,
      "text": "When defining a new version of OpenPGP Keys or Signatures, the \"OpenPGP Key and Signature Versions\" registry (Table 27) should be updated. When a new version of OpenPGP Key is defined, the \"OpenPGP Key IDs and Fingerprints\" registry (Table 12) should also be updated.",
      "ja": "OpenPGPキーまたは署名の新しいバージョンを定義する場合、「OpenPGPキーおよび署名バージョン」レジストリ（表27）を更新する必要があります。OpenPGPキーの新しいバージョンが定義されている場合、「OpenPGPキーIDと指紋」レジストリ（表12）も更新する必要があります。"
    },
    {
      "indent": 0,
      "text": "15.6.2. Encryption Versions",
      "section_title": true,
      "ja": "15.6.2. 暗号化バージョン"
    },
    {
      "indent": 3,
      "text": "When defining a new version of the Symmetrically Encrypted and Integrity Protected Data packet (Section 5.13), Public Key Encrypted Session Key packet (Section 5.1), and/or Symmetric Key Encrypted Session Key packet (Section 5.3), the \"OpenPGP Encrypted Message Packet Versions\" registry (Table 26) should be updated. When the SEIPD is updated, consider also adding a corresponding flag to the \"OpenPGP Features Flags\" registry (Table 11).",
      "ja": "対称的に暗号化され、整合性保護されたデータパケット（セクション5.13）、公開キー暗号化セッションキーパケット（セクション5.1）、および/または対称キー暗号化セッションキーパケット（セクション5.3）の新しいバージョンを定義する場合、「OpenPGP暗号化されたメッセージパケットパケットバージョン「レジストリ（表26）を更新する必要があります。SEIPDが更新されたら、「OpenPGP機能フラグ」レジストリに対応するフラグを追加することも検討してください（表11）。"
    },
    {
      "indent": 0,
      "text": "15.6.3. Algorithms",
      "section_title": true,
      "ja": "15.6.3. アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 9 lists the cryptographic and compression algorithms that OpenPGP uses. Adding new algorithms is usually simple; in some cases, allocating an ID and pointing to a reference is only needed. But some algorithm registries require some subtle additional details when a new algorithm is introduced.",
      "ja": "セクション9には、OpenPGPが使用する暗号化および圧縮アルゴリズムを示します。新しいアルゴリズムの追加は通常簡単です。場合によっては、IDを割り当てて参照を指すことが必要です。ただし、一部のアルゴリズムレジストリには、新しいアルゴリズムが導入された場合、微妙な追加の詳細が必要です。"
    },
    {
      "indent": 0,
      "text": "15.6.3.1. Elliptic Curve Algorithms",
      "section_title": true,
      "ja": "15.6.3.1. 楕円曲線アルゴリズム"
    },
    {
      "indent": 3,
      "text": "To register a new elliptic curve for use with OpenPGP, its OID needs to be registered in the \"OpenPGP ECC Curve OIDs and Usage\" registry (Table 19), its wire format needs to be documented in the \"OpenPGP ECC Curve-Specific Wire Formats\" registry (Table 20), and if used for ECDH, its KDF and KEK parameters must be populated in the \"OpenPGP ECDH KDF and KEK Parameters\" registry (Table 30). If the wire format(s) used is not already defined in the \"OpenPGP Elliptic Curve Point Wire Formats\" (Table 28) or \"OpenPGP Elliptic Curve Scalar Encodings\" (Table 29) registries, they should be defined there as well.",
      "ja": "OpenPGPで使用するための新しい楕円曲線を登録するには、そのOIDを「OpenPGP ECC Curve OIDと使用量」レジストリ（表19）に登録する必要があります。「レジストリ（表20）、およびECDHに使用する場合、そのKDFおよびKEKパラメーターは、「OpenPGP ECDH KDFおよびKEKパラメーター」レジストリに入力する必要があります（表30）。使用されるワイヤ形式が「OpenPGP楕円曲線ポイントワイヤ形式」（表28）または「OpenPGP楕円曲線スカラーエンコーディング」（表29）レジストリでまだ定義されていない場合、それらも定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "15.6.3.2. Symmetric Key Algorithms",
      "section_title": true,
      "ja": "15.6.3.2. 対称キーアルゴリズム"
    },
    {
      "indent": 3,
      "text": "When registering a new symmetric cipher with a block size of 64 or 128 bits and a key size that is a multiple of 64 bits, no new considerations are needed.",
      "ja": "64ビットまたは128ビットのブロックサイズと64ビットの倍数のキーサイズの新しい対称暗号を登録する場合、新しい考慮事項は必要ありません。"
    },
    {
      "indent": 3,
      "text": "If the new cipher has a different block size, there needs to be additional documentation describing how to use the cipher in CFB mode.",
      "ja": "新しい暗号のブロックサイズが異なる場合、CFBモードで暗号を使用する方法を説明する追加のドキュメントが必要です。"
    },
    {
      "indent": 3,
      "text": "If the new cipher has an unusual key size, then padding needs to be considered for X25519 and X448 key wrapping, which currently needs no padding.",
      "ja": "新しい暗号に異常なキーサイズがある場合、X25519およびX448キーラッピングのパディングを検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "15.6.3.3. Hash Algorithms",
      "section_title": true,
      "ja": "15.6.3.3. ハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "When registering a new hash algorithm in the \"OpenPGP Hash Algorithms\" registry (Table 23), if the algorithm is also to be used with RSA signing schemes, it must also have an entry in the \"OpenPGP Hash Algorithm Identifiers for RSA Signatures' Use of EMSA-PKCS1-v1_5 Padding\" registry (Table 24).",
      "ja": "「OpenPGPハッシュアルゴリズム」レジストリ（表23）に新しいハッシュアルゴリズムを登録する場合、アルゴリズムがRSA署名スキームでも使用される場合、「RSA署名」の「OpenPGPハッシュアルゴリズム識別子」のエントリも必要でなければなりません。EMSA-PKCS1-V1_5パディング」レジストリ（表24）。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16. 参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[AES]      NIST, \"Advanced Encryption Standard (AES)\", Updated May\n           2023, FIPS PUB 197, DOI 10.6028/NIST.FIPS.197-upd1,\n           November 2001, <https://nvlpubs.nist.gov/nistpubs/FIPS/\n           NIST.FIPS.197-upd1.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[BLOWFISH] Schneier, B., \"Description of a New Variable-Length Key,\n           64-Bit Block Cipher (Blowfish)\", Fast Software Encryption,\n           Cambridge Security Workshop Proceedings, pp. 191-204,\n           December 1993,\n           <https://www.schneier.com/academic/archives/1994/09/\n           description_of_a_new.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[BZ2]      bzip2, \"bzip2 and libbzip2\", 2010,\n           <https://sourceware.org/bzip2/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[EAX]      Bellare, M., Rogaway, P., and D. Wagner, \"A Conventional\n           Authenticated-Encryption Mode\", April 2003,\n           <https://seclab.cs.ucdavis.edu/papers/eax.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ELGAMAL]  Elgamal, T., \"A Public Key Cryptosystem and a Signature\n           Scheme Based on Discrete Logarithms\", IEEE Transactions on\n           Information Theory, Vol. 31, Issue 4, pp. 469-472,\n           DOI 10.1109/TIT.1985.1057074, July 1985,\n           <https://doi.org/10.1109/TIT.1985.1057074>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FIPS180]  NIST, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4,\n           DOI 10.6028/NIST.FIPS.180-4, August 2015,\n           <https://nvlpubs.nist.gov/nistpubs/fips/\n           nist.fips.180-4.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FIPS186]  NIST, \"Digital Signature Standard (DSS)\", FIPS PUB 186-5,\n           DOI 10.6028/NIST.FIPS.186-5, February 2023,\n           <https://nvlpubs.nist.gov/nistpubs/FIPS/\n           NIST.FIPS.186-5.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FIPS202]  NIST, \"SHA-3 Standard: Permutation-Based Hash and\n           Extendable-Output Functions\", FIPS PUB 202,\n           DOI 10.6028/NIST.FIPS.202, August 2015,\n           <https://nvlpubs.nist.gov/nistpubs/fips/\n           nist.fips.202.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IDEA]     Lai, X. and J. L. Massey, \"A Proposal for a New Block\n           Encryption Standard\", Advances in Cryptology - EUROCRYPT\n           '90, Vol. 473, pp. 389-404, DOI 10.1007/3-540-46877-3_35,\n           January 1991, <https://link.springer.com/\n           chapter/10.1007/3-540-46877-3_35>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ISO10646] ISO, \"Information technology - Universal coded character\n           set (UCS)\", ISO/IEC 10646:2020, December 2020,\n           <https://www.iso.org/standard/76835.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[JFIF]     ITU-T, \"Information technology - Digital compression and\n           coding of continuous-tone still images: JPEG File\n           Interchange Format (JFIF)\", Recommendation ITU-T T.871,\n           May 2011, <https://www.itu.int/rec/T-REC-T.871-201105-I>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1321]  Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n           DOI 10.17487/RFC1321, April 1992,\n           <https://www.rfc-editor.org/info/rfc1321>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1950]  Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format\n           Specification version 3.3\", RFC 1950,\n           DOI 10.17487/RFC1950, May 1996,\n           <https://www.rfc-editor.org/info/rfc1950>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1951]  Deutsch, P., \"DEFLATE Compressed Data Format Specification\n           version 1.3\", RFC 1951, DOI 10.17487/RFC1951, May 1996,\n           <https://www.rfc-editor.org/info/rfc1951>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2144]  Adams, C., \"The CAST-128 Encryption Algorithm\", RFC 2144,\n           DOI 10.17487/RFC2144, May 1997,\n           <https://www.rfc-editor.org/info/rfc2144>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2822]  Resnick, P., Ed., \"Internet Message Format\", RFC 2822,\n           DOI 10.17487/RFC2822, April 2001,\n           <https://www.rfc-editor.org/info/rfc2822>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3156]  Elkins, M., Del Torto, D., Levien, R., and T. Roessler,\n           \"MIME Security with OpenPGP\", RFC 3156,\n           DOI 10.17487/RFC3156, August 2001,\n           <https://www.rfc-editor.org/info/rfc3156>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3394]  Schaad, J. and R. Housley, \"Advanced Encryption Standard\n           (AES) Key Wrap Algorithm\", RFC 3394, DOI 10.17487/RFC3394,\n           September 2002, <https://www.rfc-editor.org/info/rfc3394>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n           10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n           2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3713]  Matsui, M., Nakajima, J., and S. Moriai, \"A Description of\n           the Camellia Encryption Algorithm\", RFC 3713,\n           DOI 10.17487/RFC3713, April 2004,\n           <https://www.rfc-editor.org/info/rfc3713>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n           \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n           DOI 10.17487/RFC4086, June 2005,\n           <https://www.rfc-editor.org/info/rfc4086>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n           Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006,\n           <https://www.rfc-editor.org/info/rfc4648>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5322]  Resnick, P., Ed., \"Internet Message Format\", RFC 5322,\n           DOI 10.17487/RFC5322, October 2008,\n           <https://www.rfc-editor.org/info/rfc5322>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6234]  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n           (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n           DOI 10.17487/RFC6234, May 2011,\n           <https://www.rfc-editor.org/info/rfc6234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7253]  Krovetz, T. and P. Rogaway, \"The OCB Authenticated-\n           Encryption Algorithm\", RFC 7253, DOI 10.17487/RFC7253, May\n           2014, <https://www.rfc-editor.org/info/rfc7253>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n           for Security\", RFC 7748, DOI 10.17487/RFC7748, January\n           2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n           \"PKCS #1: RSA Cryptography Specifications Version 2.2\",\n           RFC 8017, DOI 10.17487/RFC8017, November 2016,\n           <https://www.rfc-editor.org/info/rfc8017>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8018]  Moriarty, K., Ed., Kaliski, B., and A. Rusch, \"PKCS #5:\n           Password-Based Cryptography Specification Version 2.1\",\n           RFC 8018, DOI 10.17487/RFC8018, January 2017,\n           <https://www.rfc-editor.org/info/rfc8018>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n           Writing an IANA Considerations Section in RFCs\", BCP 26,\n           RFC 8126, DOI 10.17487/RFC8126, June 2017,\n           <https://www.rfc-editor.org/info/rfc8126>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9106]  Biryukov, A., Dinu, D., Khovratovich, D., and S.\n           Josefsson, \"Argon2 Memory-Hard Function for Password\n           Hashing and Proof-of-Work Applications\", RFC 9106,\n           DOI 10.17487/RFC9106, September 2021,\n           <https://www.rfc-editor.org/info/rfc9106>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RIPEMD-160]\n           ISO, \"Information technology - Security techniques - Hash-\n           functions - Part 3: Dedicated hash-functions\", ISO/\n           IEC 10118-3:1998, May 1998.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-38A]\n           NIST, \"Recommendation for Block Cipher Modes of Operation:\n           Methods and Techniques\", NIST Special Publication 800-38A,\n           DOI 10.6028/NIST.SP.800-38A, December 2001,\n           <https://nvlpubs.nist.gov/nistpubs/legacy/sp/\n           nistspecialpublication800-38a.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-38D]\n           NIST, \"Recommendation for Block Cipher Modes of Operation:\n           Galois/Counter Mode (GCM) and GMAC\", NIST Special\n           Publication 800-38D, DOI 10.6028/NIST.SP.800-38D, November\n           2007, <https://nvlpubs.nist.gov/nistpubs/legacy/sp/\n           nistspecialpublication800-38d.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-56A]\n           NIST, \"Recommendation for Pair-Wise Key Establishment\n           Schemes Using Discrete Logarithm Cryptography\", NIST\n           Special Publication 800-56A Revision 3,\n           DOI 10.6028/NIST.SP.800-56Ar, April 2018,\n           <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n           nist.sp.800-56Ar3.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-67] NIST, \"Recommendation for the Triple Data Encryption\n           Algorithm (TDEA) Block Cipher\", NIST Special\n           Publication 800-67 Revision 2,\n           DOI 10.6028/NIST.SP.800-67r2, November 2017,\n           <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n           NIST.SP.800-67r2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TWOFISH]  Schneier, B., Kelsey, J., Whiting, D., Wagner, D., Hall,\n           C., and N. Ferguson, \"Twofish: A 128-Bit Block Cipher\",\n           June 1998, <https://www.schneier.com/wp-\n           content/uploads/2016/02/paper-twofish-paper.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BLEICHENBACHER]\n           Bleichenbacher, D., \"Generating ElGamal Signatures Without\n           Knowing the Secret Key\", EUROCRYPT'96: International\n           Conference on the Theory and Applications of Cryptographic\n           Techniques Proceedings, Vol. 1070, pp. 10-18, May 1996.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[BLEICHENBACHER-PKCS1]\n           Bleichenbacher, D., \"Chosen Ciphertext Attacks Against\n           Protocols Based on the RSA Encryption Standard PKCS #1\",\n           CRYPTO '98: International Cryptology Conference\n           Proceedings, Vol. 1462, pp. 1-12, August 1998,\n           <http://archiv.infsec.ethz.ch/education/fs08/secsem/\n           Bleichenbacher98.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[C99]      ISO, \"Information technology - Programming languages: C\",\n           ISO/IEC 9899:2018, June 2018,\n           <https://www.iso.org/standard/74528.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CHECKOWAY]\n           Checkoway, S., Maskiewicz, J., Garman, C., Fried, J.,\n           Cohney, S., Green, M., Heninger, N., Weinmann, RP.,\n           Rescorla, E., and H. Shacham, \"A Systematic Analysis of\n           the Juniper Dual EC Incident\", Proceedings of the 2016 ACM\n           SIGSAC Conference on Computer and Communications Security,\n           DOI 10.1145/2976749.2978395, October 2016,\n           <https://doi.org/10.1145/2976749.2978395>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[EFAIL]    Poddebniak, D., Dresen, C., Müller, J., Ising, F.,\n           Schinzel, S., Friedberger, S., Somorovsky, J., and J.\n           Schwenk, \"Efail: Breaking S/MIME and OpenPGP Email\n           Encryption using Exfiltration Channels\", Proceedings of\n           the 27th USENIX Security Symposium, August 2018,\n           <https://www.usenix.org/system/files/conference/\n           usenixsecurity18/sec18-poddebniak.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2199]\n           RFC Errata, Erratum ID 2199, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2199>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2200]\n           RFC Errata, Erratum ID 2200, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2200>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2206]\n           RFC Errata, Erratum ID 2206, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2206>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2208]\n           RFC Errata, Erratum ID 2208, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2208>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2214]\n           RFC Errata, Erratum ID 2214, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2214>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2216]\n           RFC Errata, Erratum ID 2216, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2216>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2219]\n           RFC Errata, Erratum ID 2219, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2219>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2222]\n           RFC Errata, Erratum ID 2222, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2222>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2226]\n           RFC Errata, Erratum ID 2226, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2226>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2234]\n           RFC Errata, Erratum ID 2234, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2235]\n           RFC Errata, Erratum ID 2235, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2235>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2236]\n           RFC Errata, Erratum ID 2236, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2236>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2238]\n           RFC Errata, Erratum ID 2238, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2238>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2240]\n           RFC Errata, Erratum ID 2240, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2240>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2242]\n           RFC Errata, Erratum ID 2242, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2242>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2243]\n           RFC Errata, Erratum ID 2243, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2243>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2270]\n           RFC Errata, Erratum ID 2270, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2270>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-2271]\n           RFC Errata, Erratum ID 2271, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid2271>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-3298]\n           RFC Errata, Erratum ID 3298, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid3298>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-5491]\n           RFC Errata, Erratum ID 5491, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid5491>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-7545]\n           RFC Errata, Erratum ID 7545, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid7545>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Errata-7889]\n           RFC Errata, Erratum ID 7889, RFC 4880,\n           <https://www.rfc-editor.org/errata/eid7889>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HASTAD]   Hastad, J., \"Solving Simultaneous Modular Equations of Low\n           Degree\", DOI 10.1137/0217019, April 1988,\n           <https://doi.org/10.1137/0217019>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[JKS02]    Jallad, K., Katz, J., and B. Schneier, \"Implementation of\n           Chosen-Ciphertext Attacks against PGP and GnuPG\",\n           DOI 0.1007/3-540-45811-5_7, September 2002,\n           <https://www.schneier.com/academic/archives/2002/01/\n           implementation_of_ch.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[KOBLITZ]  Koblitz, N., \"A course in number theory and cryptography\",\n           Chapter VI: Elliptic Curves, DOI 10.2307/3618498, 1997,\n           <https://doi.org/10.2307/3618498>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[KOPENPGP] Bruseghini, L., Paterson, K. G., and D. Huigens, \"Victory\n           by KO: Attacking OpenPGP Using Key Overwriting\",\n           Proceedings of the ACM SIGSAC Conference on Computer and\n           Communications Security, pp. 411-423,\n           DOI 10.1145/3548606.3559363, November 2022,\n           <https://dl.acm.org/doi/10.1145/3548606.3559363>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[KR02]     Klíma, V. and T. Rosa, \"Attack on Private Signature Keys\n           of the OpenPGP Format, PGP(TM) Programs and Other\n           Applications Compatible with OpenPGP\", Cryptology ePrint\n           Archive, Paper 2002/076, March 2001,\n           <https://eprint.iacr.org/2002/076>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MRLG15]   Maury, F., Reinhard, JR., Levillain, O., and H. Gilbert,\n           \"Format Oracles on OpenPGP\", Topics in Cryptology -- CT-\n           RSA 2015, Vol. 9048, pp. 220-236,\n           DOI 10.1007/978-3-319-16715-2_12, January 2015,\n           <https://doi.org/10.1007/978-3-319-16715-2_12>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MZ05]     Mister, S. and R. Zuccherato, \"An Attack on CFB Mode\n           Encryption As Used By OpenPGP\", Cryptology ePrint Archive,\n           Paper 2005/033, February 2005,\n           <http://eprint.iacr.org/2005/033>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[OPENPGPCARD]\n           Pietig, A., \"Functional Specification of the OpenPGP\n           application on ISO Smart Card Operating Systems\", Version\n           3.4.1, March 2020, <https://gnupg.org/ftp/specs/OpenPGP-\n           smart-card-application-3.4.1.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PAX]      The Open Group, \"The Open Group Base Specifications\", 'pax\n           - portable archive interchange', Issue 7, 2018 Edition,\n           IEEE Std 1003.1-2017, 2018,\n           <https://pubs.opengroup.org/onlinepubs/9699919799/\n           utilities/pax.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PSSLR17]  Poddebniak, D., Somorovsky, J., Schinzel, S., Lochter, M.,\n           and P. Rösler, \"Attacking Deterministic Signature Schemes\n           using Fault Attacks\", Cryptology ePrint Archive, Paper\n           2017/1014, October 2017,\n           <https://eprint.iacr.org/2017/1014>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[REGEX]    regex, \"Henry Spencer's regular expression libraries\",\n           <https://garyhouston.github.io/regex/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1991]  Atkins, D., Stallings, W., and P. Zimmermann, \"PGP Message\n           Exchange Formats\", RFC 1991, DOI 10.17487/RFC1991, August\n           1996, <https://www.rfc-editor.org/info/rfc1991>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2440]  Callas, J., Donnerhacke, L., Finney, H., and R. Thayer,\n           \"OpenPGP Message Format\", RFC 2440, DOI 10.17487/RFC2440,\n           November 1998, <https://www.rfc-editor.org/info/rfc2440>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2978]  Freed, N. and J. Postel, \"IANA Charset Registration\n           Procedures\", BCP 19, RFC 2978, DOI 10.17487/RFC2978,\n           October 2000, <https://www.rfc-editor.org/info/rfc2978>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4880]  Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R.\n           Thayer, \"OpenPGP Message Format\", RFC 4880,\n           DOI 10.17487/RFC4880, November 2007,\n           <https://www.rfc-editor.org/info/rfc4880>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5581]  Shaw, D., \"The Camellia Cipher in OpenPGP\", RFC 5581,\n           DOI 10.17487/RFC5581, June 2009,\n           <https://www.rfc-editor.org/info/rfc5581>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5639]  Lochter, M. and J. Merkle, \"Elliptic Curve Cryptography\n           (ECC) Brainpool Standard Curves and Curve Generation\",\n           RFC 5639, DOI 10.17487/RFC5639, March 2010,\n           <https://www.rfc-editor.org/info/rfc5639>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n           Key Derivation Function (HKDF)\", RFC 5869,\n           DOI 10.17487/RFC5869, May 2010,\n           <https://www.rfc-editor.org/info/rfc5869>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6090]  McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic\n           Curve Cryptography Algorithms\", RFC 6090,\n           DOI 10.17487/RFC6090, February 2011,\n           <https://www.rfc-editor.org/info/rfc6090>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6637]  Jivsov, A., \"Elliptic Curve Cryptography (ECC) in\n           OpenPGP\", RFC 6637, DOI 10.17487/RFC6637, June 2012,\n           <https://www.rfc-editor.org/info/rfc6637>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC1]     Standards for Efficient Cryptography Group, \"SEC 1:\n           Elliptic Curve Cryptography\", May 2009,\n           <https://www.secg.org/sec1-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SHA1CD]   \"sha1collisiondetection\", commit b4a7b0b, December 2020,\n           <https://github.com/cr-marcstevens/\n           sha1collisiondetection>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SHAMBLES] Leurent, G. and T. Peyrin, \"Sha-1 is a shambles: first\n           chosen-prefix collision on sha-1 and application to the\n           PGP web of trust\", August 2020,\n           <https://dl.acm.org/doi/abs/10.5555/3489212.3489316/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-131A]\n           NIST, \"Transitioning the Use of Cryptographic Algorithms\n           and Key Lengths\", NIST Special Publication 800-131A,\n           Revision 2, DOI 10.6028/NIST.SP.800-131Ar2, March 2019,\n           <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n           NIST.SP.800-131Ar2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SP800-57] NIST, \"Recommendation for Key Management: Part 1 -\n           General\", NIST Special Publication 800-57 Part 1, Revision\n           5, DOI 10.6028/NIST.SP.800-57pt1r5, May 2020,\n           <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n           NIST.SP.800-57pt1r5.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[STEVENS2013]\n           Stevens, M., \"Counter-cryptanalysis\", Cryptology ePrint\n           Archive, Paper 2013/358, June 2013,\n           <https://eprint.iacr.org/2013/358>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[UNIFIED-DIFF]\n           Free Software Foundation, \"Comparing and Merging Files\",\n           'Detailed Description of Unified Format', Section 2.2.2.2,\n           January 2021,\n           <https://www.gnu.org/software/diffutils/manual/html_node/\n           Detailed-Unified.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[USENIX-STUDY]\n           Dechand, S., Schürmann, D., Busse, K., Acar, Y., Fahl, S.,\n           and M. Smith, \"An Empirical Study of Textual Key-\n           Fingerprint Representations\", ISBN 978-1-931971-32-4,\n           August 2016,\n           <https://www.usenix.org/system/files/conference/\n           usenixsecurity16/sec16_paper_dechand.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Test Vectors",
      "section_title": true,
      "ja": "付録A. テストベクトル"
    },
    {
      "indent": 3,
      "text": "To help with the implementation of this specification, a set of non-normative examples follow.",
      "ja": "この仕様の実装を支援するために、非規範的な例のセットが続きます。"
    },
    {
      "indent": 0,
      "text": "A.1. Sample Version 4 Ed25519Legacy Key",
      "section_title": true,
      "ja": "A.1. サンプルバージョン4 ED25519Legacyキー"
    },
    {
      "indent": 3,
      "text": "The secret key used for this example is:",
      "ja": "この例で使用される秘密の鍵は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "D: 1a8b1ff05ded48e18bf50166c664ab023ea70003d78d9e41f5758a91d850f8d2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that this is the raw secret key used as input to the EdDSA signing operation. The key was created on 2014-08-19 14:28:27 and thus the fingerprint of the OpenPGP Key is:",
      "ja": "これは、EDDSA署名操作への入力として使用される生の秘密鍵であることに注意してください。キーは2014-08-19 14:28:27に作成されたため、OpenPGPキーの指紋は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "C959 BDBA FA32 A2F8 9A15  3B67 8CFD E121 9796 5A9A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The algorithm-specific input parameters without the MPI length headers are:",
      "ja": "MPI長ヘッダーのないアルゴリズム固有の入力パラメーターは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "oid: 2b06010401da470f01\n\nq: 403f098994bdd916ed4053197934e4a87c80733a1280d62f8010992e43ee3b2406",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The entire Public Key packet is thus:",
      "ja": "したがって、公開キーのパケット全体は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "98 33 04 53 f3 5f 0b 16  09 2b 06 01 04 01 da 47\n0f 01 01 07 40 3f 09 89  94 bd d9 16 ed 40 53 19\n79 34 e4 a8 7c 80 73 3a  12 80 d6 2f 80 10 99 2e\n43 ee 3b 24 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same packet represented in ASCII-armored form is:",
      "ja": "Ascii-Amoredの形で表される同じパケットは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxjMEU/NfCxYJKwYBBAHaRw8BAQdAPwmJlL3ZFu1AUxl5NOSofIBzOhKA1i+AEJku\nQ+47JAY=\n-----END PGP PUBLIC KEY BLOCK-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. Sample Version 4 Ed25519Legacy Signature",
      "section_title": true,
      "ja": "A.2. サンプルバージョン4 ED25519LEGACY署名"
    },
    {
      "indent": 3,
      "text": "The signature is created using the sample key over the input data \"OpenPGP\" on 2015-09-16 12:24:53 UTC and thus the input to the hash function is:",
      "ja": "署名は、2015-09-16 12:24:53 UTCの入力データ「OpenPGP」上のサンプルキーを使用して作成されるため、ハッシュ関数への入力は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "m: 4f70656e504750040016080006050255f95f9504ff0000000c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Using the SHA2-256 hash algorithm yields the digest:",
      "ja": "SHA2-256ハッシュアルゴリズムを使用すると、ダイジェストが得られます。"
    },
    {
      "indent": 3,
      "text": "d: f6220a3f757814f4c2176ffbb68b00249cd4ccdc059c4b34ad871f30b1740280",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "which is fed into the EdDSA signature function and yields the following signature:",
      "ja": "EDDSA署名関数に供給され、次の署名が得られます。"
    },
    {
      "indent": 3,
      "text": "r: 56f90cca98e2102637bd983fdb16c131dfd27ed82bf4dde5606e0d756aed3366\n\ns: d09c4fa11527f038e0f57f2201d82f2ea2c9033265fa6ceb489e854bae61b404",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The entire Signature packet is thus:",
      "ja": "したがって、署名パケット全体は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "88 5e 04 00 16 08 00 06  05 02 55 f9 5f 95 00 0a\n09 10 8c fd e1 21 97 96  5a 9a f6 22 00 ff 56 f9\n0c ca 98 e2 10 26 37 bd  98 3f db 16 c1 31 df d2\n7e d8 2b f4 dd e5 60 6e  0d 75 6a ed 33 66 01 00\nd0 9c 4f a1 15 27 f0 38  e0 f5 7f 22 01 d8 2f 2e\na2 c9 03 32 65 fa 6c eb  48 9e 85 4b ae 61 b4 04",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same packet represented in ASCII-armored form is:",
      "ja": "Ascii-Amoredの形で表される同じパケットは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP SIGNATURE-----\n\niF4EABYIAAYFAlX5X5UACgkQjP3hIZeWWpr2IgD/VvkMypjiECY3vZg/2xbBMd/S\nftgr9N3lYG4NdWrtM2YBANCcT6EVJ/A44PV/IgHYLy6iyQMyZfps60iehUuuYbQE\n-----END PGP SIGNATURE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. Sample Version 6 Certificate (Transferable Public Key)",
      "section_title": true,
      "ja": "A.3. サンプルバージョン6証明書（転送可能な公開鍵）"
    },
    {
      "indent": 3,
      "text": "Here is a Transferable Public Key consisting of:",
      "ja": "以下は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A version 6 Ed25519 Public Key packet",
      "ja": "* バージョン6 ED25519公開キーパケット"
    },
    {
      "indent": 6,
      "text": "* A version 6 Direct Key self-signature",
      "ja": "* バージョン6ダイレクトキーの自己署名"
    },
    {
      "indent": 6,
      "text": "* A version 6 X25519 Public Subkey packet",
      "ja": "* バージョン6 x25519パブリックサブキーパケット"
    },
    {
      "indent": 6,
      "text": "* A version 6 Subkey Binding signature",
      "ja": "* バージョン6サブキーバインディング署名"
    },
    {
      "indent": 3,
      "text": "The primary key has the following fingerprint:",
      "ja": "主キーには次の指紋があります。"
    },
    {
      "indent": 3,
      "text": "CB186C4F0609A697E4D52DFA6C722B0C1F1E27C18A56708F6525EC27BAD9ACC9",
      "ja": "CB186C4F0609A697E4D52DFA6C722B0C1F1E27C18A56708F6525EC27BAD9ACC9"
    },
    {
      "indent": 3,
      "text": "The subkey has the following fingerprint:",
      "ja": "サブキーには次の指紋があります。"
    },
    {
      "indent": 3,
      "text": "12C83F1E706F6308FE151A417743A1F033790E93E9978488D1DB378DA9930885",
      "ja": "12C83F1E706F6308FE151A417743A1F033790E93E9978488D1DB378DA9930885"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxioGY4d/4xsAAAAg+U2nu0jWCmHlZ3BqZYfQMxmZu52JGggkLq2EVD34laPCsQYf\nGwoAAABCBYJjh3/jAwsJBwUVCg4IDAIWAAKbAwIeCSIhBssYbE8GCaaX5NUt+mxy\nKwwfHifBilZwj2Ul7Ce62azJBScJAgcCAAAAAK0oIBA+LX0ifsDm185Ecds2v8lw\ngyU2kCcUmKfvBXbAf6rhRYWzuQOwEn7E/aLwIwRaLsdry0+VcallHhSu4RN6HWaE\nQsiPlR4zxP/TP7mhfVEe7XWPxtnMUMtf15OyA51YBM4qBmOHf+MZAAAAIIaTJINn\n+eUBXbki+PSAld2nhJh/LVmFsS+60WyvXkQ1wpsGGBsKAAAALAWCY4d/4wKbDCIh\nBssYbE8GCaaX5NUt+mxyKwwfHifBilZwj2Ul7Ce62azJAAAAAAQBIKbpGG2dWTX8\nj+VjFM21J0hqWlEg+bdiojWnKfA5AQpWUWtnNwDEM0g12vYxoWM8Y81W+bHBw805\nI8kWVkXU6vFOi+HWvv/ira7ofJu16NnoUkhclkUrk0mXubZvyl4GBg==\n-----END PGP PUBLIC KEY BLOCK-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The corresponding Transferable Secret Key can be found in Appendix A.4.",
      "ja": "対応する転送可能な秘密鍵は、付録A.4にあります。"
    },
    {
      "indent": 0,
      "text": "A.3.1. Hashed Data Stream for Signature Verification",
      "section_title": true,
      "ja": "A.3.1. 署名検証のためにデータストリームをハッシュします"
    },
    {
      "indent": 3,
      "text": "The Direct Key self-signature in the certificate in Appendix A.3 is made over the following sequence of data:",
      "ja": "付録A.3の証明書の直接的なキーの自己署名は、次のデータシーケンスにわたって作成されています。"
    },
    {
      "indent": 3,
      "text": "0x0000  10 3e 2d 7d 22 7e c0 e6\n0x0008  d7 ce 44 71 db 36 bf c9\n0x0010  70 83 25 36 90 27 14 98\n0x0018  a7 ef 05 76 c0 7f aa e1\n0x0020  9b 00 00 00 2a 06 63 87\n0x0028  7f e3 1b 00 00 00 20 f9\n0x0030  4d a7 bb 48 d6 0a 61 e5\n0x0038  67 70 6a 65 87 d0 33 19\n0x0040  99 bb 9d 89 1a 08 24 2e\n0x0048  ad 84 54 3d f8 95 a3 06\n0x0050  1f 1b 0a 00 00 00 42 05\n0x0058  82 63 87 7f e3 03 0b 09\n0x0060  07 05 15 0a 0e 08 0c 02\n0x0068  16 00 02 9b 03 02 1e 09\n0x0070  22 21 06 cb 18 6c 4f 06\n0x0078  09 a6 97 e4 d5 2d fa 6c\n0x0080  72 2b 0c 1f 1e 27 c1 8a\n0x0088  56 70 8f 65 25 ec 27 ba\n0x0090  d9 ac c9 05 27 09 02 07\n0x0098  02 06 ff 00 00 00 4a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  10 3e 2d 7d 22 7e c0 e6  salt\n0x0008  d7 ce 44 71 db 36 bf c9\n0x0010  70 83 25 36 90 27 14 98\n0x0018  a7 ef 05 76 c0 7f aa e1\n        [ pubkey begins ]\n0x0020  9b                       key packet\n0x0021     00 00 00 2a           pubkey length\n0x0025                 06        pubkey version\n0x0026                    63 87  creation time\n0x0028  7f e3                      (2022-11-30T16:08:03Z)\n0x002a        1b                 key algo: Ed25519\n0x002b           00 00 00 20     key length\n0x002f                       f9  Ed25519 public key\n0x0030  4d a7 bb 48 d6 0a 61 e5\n0x0038  67 70 6a 65 87 d0 33 19\n0x0040  99 bb 9d 89 1a 08 24 2e\n0x0048  ad 84 54 3d f8 95 a3\n         [ trailer begins ]\n0x004f                       06  sig version 6\n0x0050  1f                       sig type: Direct Key signature\n0x0051     1b                    sig algo: Ed25519\n0x0052        0a                 hash ago: SHA2-512\n0x0053           00 00 00 42     hashed subpackets length\n0x0057                       05  subpkt length\n0x0058  82                       critical subpkt: Sig Creation Time\n0x0059     63 87 7f e3           Signature Creation Time\n0x005d                 03        subpkt length\n0x005e                    0b     subpkt type: Pref. v1 SEIPD Ciphers\n0x005f                       09  Ciphers: [AES256 AES128]\n0x0060  07\n0x0061     05                    subpkt length\n0x0062        15                 subpkt type: Pref. Hash Algorithms\n0x0063           0a 0e           Hashes: [SHA2-512 SHA3-512\n0x0065                 08 0c              SHA2-256 SHA3-256]\n0x0067                       02  subpkt length\n0x0068  16                       subpkt type: Pref. Compression\n0x0069     00                    Compression: [none]\n0x006a        02                 subpkt length\n0x006b           9b              critical subpkt: Key Flags\n0x006c              03           Key Flags: {certify, sign}\n0x006d                 02        subpkt length\n0x006e                    1e     subpkt type: Features\n0x006f                       09  Features: {v1SEIPD, v2SEIPD}\n0x0070  22                       subpkt length\n0x0071     21                    subpkt type: Issuer Fingerprint\n0x0072        06                 Fingerprint version 6\n0x0073           cb 18 6c 4f 06  Fingerprint\n0x0078  09 a6 97 e4 d5 2d fa 6c\n0x0080  72 2b 0c 1f 1e 27 c1 8a\n0x0088  56 70 8f 65 25 ec 27 ba\n0x0090  d9 ac c9\n0x0093           05              subpkt length\n0x0094              27           subpkt type: Pref. AEAD Ciphersuites\n0x0095                 09 02 07  Ciphersuites:\n0x0098  02                         [ AES256-OCB, AES128-OCB ]\n0x0099     06                    sig version 6\n0x009a        ff                 sentinel octet\n0x009b           00 00 00 4a     trailer length",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Subkey Binding signature in Appendix A.3 is made over the following sequence of data:",
      "ja": "付録A.3のサブキーバインディングシグネチャは、次のデータシーケンスに基づいて作成されています。"
    },
    {
      "indent": 3,
      "text": "0x0000  a6 e9 18 6d 9d 59 35 fc\n0x0008  8f e5 63 14 cd b5 27 48\n0x0010  6a 5a 51 20 f9 b7 62 a2\n0x0018  35 a7 29 f0 39 01 0a 56\n0x0020  9b 00 00 00 2a 06 63 87\n0x0028  7f e3 1b 00 00 00 20 f9\n0x0030  4d a7 bb 48 d6 0a 61 e5\n0x0038  67 70 6a 65 87 d0 33 19\n0x0040  99 bb 9d 89 1a 08 24 2e\n0x0048  ad 84 54 3d f8 95 a3 9b\n0x0050  00 00 00 2a 06 63 87 7f\n0x0058  e3 19 00 00 00 20 86 93\n0x0060  24 83 67 f9 e5 01 5d b9\n0x0068  22 f8 f4 80 95 dd a7 84\n0x0070  98 7f 2d 59 85 b1 2f ba\n0x0078  d1 6c af 5e 44 35 06 18\n0x0080  1b 0a 00 00 00 2c 05 82\n0x0088  63 87 7f e3 02 9b 0c 22\n0x0090  21 06 cb 18 6c 4f 06 09\n0x0098  a6 97 e4 d5 2d fa 6c 72\n0x00a0  2b 0c 1f 1e 27 c1 8a 56\n0x00a8  70 8f 65 25 ec 27 ba d9\n0x00b0  ac c9 06 ff 00 00 00 34",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  a6 e9 18 6d 9d 59 35 fc  salt\n0x0008  8f e5 63 14 cd b5 27 48\n0x0010  6a 5a 51 20 f9 b7 62 a2\n0x0018  35 a7 29 f0 39 01 0a 56\n      [ primary pubkey begins ]\n0x0020  9b                       key packet\n0x0021     00 00 00 2a           pubkey length\n0x0025                 06        pubkey version\n0x0026                    63 87  creation time\n0x0028  7f e3                      (2022-11-30T16:08:03Z)\n0x002a        1b                 key algo: Ed25519\n0x002b           00 00 00 20     key length\n0x002f                       f9  Ed25519 public key\n0x0030  4d a7 bb 48 d6 0a 61 e5\n0x0038  67 70 6a 65 87 d0 33 19\n0x0040  99 bb 9d 89 1a 08 24 2e\n0x0048  ad 84 54 3d f8 95 a3\n      [ subkey pubkey begins ]\n0x004f                       9b  key packet\n0x0050  00 00 00 2a              pubkey length\n0x0054              06           pubkey version\n0x0055                 63 87 7f  creation time (2022-11-30T16:08:03Z)\n0x0058  e3\n0x0059     19                    key algo: X25519\n0x005a        00 00 00 20        key length\n0x005e                    86 93  X25519 public key\n0x0060  24 83 67 f9 e5 01 5d b9\n0x0068  22 f8 f4 80 95 dd a7 84\n0x0070  98 7f 2d 59 85 b1 2f ba\n0x0078  d1 6c af 5e 44 35\n       [ trailer begins ]\n0x007e                    06     sig version 6\n0x007f                       18  sig type: Subkey Binding sig\n0x0080  1b                       sig algo Ed25519\n0x0081     0a                    hash algo: SHA2-512\n0x0082        00 00 00 2c        hashed subpackets length\n0x0086                    05     subpkt length\n0x0087                       82  critical subpkt: Sig Creation Time\n0x0088  63 87 7f e3              Signature Creation Time\n0x008c              02           subpkt length\n0x008d                 9b        critical subpkt: Key Flags\n0x008e                    0c     Key Flags: {EncComms, EncStorage}\n0x008f                       22  subpkt length\n0x0090  21                       subpkt type: Issuer Fingerprint\n0x0091     06                    Fingerprint version 6\n0x0092        cb 18 6c 4f 06 09  Fingerprint\n0x0098  a6 97 e4 d5 2d fa 6c 72\n0x00a0  2b 0c 1f 1e 27 c1 8a 56\n0x00a8  70 8f 65 25 ec 27 ba d9\n0x00b0  ac c9\n0x00b2        06                 sig version 6\n0x00b3           ff              sentinel octet\n0x00b4              00 00 00 34  trailer length",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. Sample Version 6 Secret Key (Transferable Secret Key)",
      "section_title": true,
      "ja": "A.4. サンプルバージョン6シークレットキー（転送可能なシークレットキー）"
    },
    {
      "indent": 3,
      "text": "Here is a Transferable Secret Key consisting of:",
      "ja": "以下は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* A version 6 Ed25519 Secret Key packet",
      "ja": "* バージョン6 ED25519シークレットキーパケット"
    },
    {
      "indent": 6,
      "text": "* A version 6 Direct Key self-signature",
      "ja": "* バージョン6ダイレクトキーの自己署名"
    },
    {
      "indent": 6,
      "text": "* A version 6 X25519 Secret Subkey packet",
      "ja": "* バージョン6 x25519シークレットサブキーパケット"
    },
    {
      "indent": 6,
      "text": "* A version 6 Subkey Binding signature",
      "ja": "* バージョン6サブキーバインディング署名"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxUsGY4d/4xsAAAAg+U2nu0jWCmHlZ3BqZYfQMxmZu52JGggkLq2EVD34laMAGXKB\nexK+cH6NX1hs5hNhIB00TrJmosgv3mg1ditlsLfCsQYfGwoAAABCBYJjh3/jAwsJ\nBwUVCg4IDAIWAAKbAwIeCSIhBssYbE8GCaaX5NUt+mxyKwwfHifBilZwj2Ul7Ce6\n2azJBScJAgcCAAAAAK0oIBA+LX0ifsDm185Ecds2v8lwgyU2kCcUmKfvBXbAf6rh\nRYWzuQOwEn7E/aLwIwRaLsdry0+VcallHhSu4RN6HWaEQsiPlR4zxP/TP7mhfVEe\n7XWPxtnMUMtf15OyA51YBMdLBmOHf+MZAAAAIIaTJINn+eUBXbki+PSAld2nhJh/\nLVmFsS+60WyvXkQ1AE1gCk95TUR3XFeibg/u/tVY6a//1q0NWC1X+yui3O24wpsG\nGBsKAAAALAWCY4d/4wKbDCIhBssYbE8GCaaX5NUt+mxyKwwfHifBilZwj2Ul7Ce6\n2azJAAAAAAQBIKbpGG2dWTX8j+VjFM21J0hqWlEg+bdiojWnKfA5AQpWUWtnNwDE\nM0g12vYxoWM8Y81W+bHBw805I8kWVkXU6vFOi+HWvv/ira7ofJu16NnoUkhclkUr\nk0mXubZvyl4GBg==\n-----END PGP PRIVATE KEY BLOCK-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The corresponding Transferable Public Key can be found in Appendix A.3.",
      "ja": "対応する転送可能な公開キーは、付録A.3に記載されています。"
    },
    {
      "indent": 0,
      "text": "A.5. Sample Locked Version 6 Secret Key (Transferable Secret Key)",
      "section_title": true,
      "ja": "A.5. サンプルロックされたバージョン6シークレットキー（転送可能なシークレットキー）"
    },
    {
      "indent": 3,
      "text": "Here is the same secret key as in Appendix A.4, but the secret key material is locked with a passphrase using AEAD and Argon2.",
      "ja": "付録A.4と同じ秘密の鍵は次のとおりですが、秘密の鍵素材は、AEADとArgon2を使用したパスフレーズでロックされています。"
    },
    {
      "indent": 3,
      "text": "The passphrase is the ASCII string:",
      "ja": "パスフレーズはASCII文字列です。"
    },
    {
      "indent": 3,
      "text": "correct horse battery staple",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxYIGY4d/4xsAAAAg+U2nu0jWCmHlZ3BqZYfQMxmZu52JGggkLq2EVD34laP9JgkC\nFARdb9ccngltHraRe25uHuyuAQQVtKipJ0+r5jL4dacGWSAheCWPpITYiyfyIOPS\n3gIDyg8f7strd1OB4+LZsUhcIjOMpVHgmiY/IutJkulneoBYwrEGHxsKAAAAQgWC\nY4d/4wMLCQcFFQoOCAwCFgACmwMCHgkiIQbLGGxPBgmml+TVLfpscisMHx4nwYpW\ncI9lJewnutmsyQUnCQIHAgAAAACtKCAQPi19In7A5tfORHHbNr/JcIMlNpAnFJin\n7wV2wH+q4UWFs7kDsBJ+xP2i8CMEWi7Ha8tPlXGpZR4UruETeh1mhELIj5UeM8T/\n0z+5oX1RHu11j8bZzFDLX9eTsgOdWATHggZjh3/jGQAAACCGkySDZ/nlAV25Ivj0\ngJXdp4SYfy1ZhbEvutFsr15ENf0mCQIUBA5hhGgp2oaavg6mFUXcFMwBBBUuE8qf\n9Ock+xwusd+GAglBr5LVyr/lup3xxQvHXFSjjA2haXfoN6xUGRdDEHI6+uevKjVR\nv5oAxgu7eJpaXNjCmwYYGwoAAAAsBYJjh3/jApsMIiEGyxhsTwYJppfk1S36bHIr\nDB8eJ8GKVnCPZSXsJ7rZrMkAAAAABAEgpukYbZ1ZNfyP5WMUzbUnSGpaUSD5t2Ki\nNacp8DkBClZRa2c3AMQzSDXa9jGhYzxjzVb5scHDzTkjyRZWRdTq8U6L4da+/+Kt\nruh8m7Xo2ehSSFyWRSuTSZe5tm/KXgYG\n-----END PGP PRIVATE KEY BLOCK-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.1. Intermediate Data for Locked Primary Key",
      "section_title": true,
      "ja": "A.5.1. ロックされたプライマリキーの中間データ"
    },
    {
      "indent": 3,
      "text": "The S2K-derived material for the primary key is:",
      "ja": "主キーのS2K由来の材料は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "832bd2662a5c2b251ee3fc82aec349a766ca539015880133002e5a21960b3bcf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "After HKDF, the symmetric key used for AEAD encryption of the primary key is:",
      "ja": "HKDFの後、主キーのAEAD暗号化に使用される対称キーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "9e37cb26787f37e18db172795c4c297550d39ac82511d9af4c8706db6a77fd51",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The additional data for AEAD for the primary key is:",
      "ja": "主キーのAEADの追加データは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "c50663877fe31b00000020f94da7bb48d60a61e567706a6587d0331999bb9d89\n1a08242ead84543df895a3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5.2. Intermediate Data for Locked Subkey",
      "section_title": true,
      "ja": "A.5.2. ロックされたサブキーの中間データ"
    },
    {
      "indent": 3,
      "text": "The S2K-derived key material for the subkey is:",
      "ja": "サブキーのS2K由来の重要な資料は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "f74a6ce873a089ef13a3da9ac059777bb22340d15eaa6c9dc0f8ef09035c67cd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "After HKDF, the symmetric key used for AEAD encryption of the subkey is:",
      "ja": "HKDFの後、サブキーのAEAD暗号化に使用される対称キーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "3c60cb63285f62f4c3de49835786f011cf6f4c069f61232cd7013ff5fd31e603",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The additional data for AEAD for the subkey is:",
      "ja": "サブキーのAEADの追加データは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "c70663877fe319000000208693248367f9e5015db922f8f48095dda784987f2d\n5985b12fbad16caf5e4435",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.6. Sample Cleartext Signed Message",
      "section_title": true,
      "ja": "A.6. サンプルClearText署名されたメッセージ"
    },
    {
      "indent": 3,
      "text": "Here is a signed message that uses the Cleartext Signature Framework (Section 7). It can be verified with the certificate from Appendix A.3.",
      "ja": "ClearText署名フレームワーク（セクション7）を使用する署名されたメッセージを次に示します。付録A.3の証明書で検証できます。"
    },
    {
      "indent": 3,
      "text": "Note that this message makes use of dash-escaping (Section 7.2) due to its contents.",
      "ja": "このメッセージは、その内容によりダッシュエスケープ（セクション7.2）を使用していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP SIGNED MESSAGE-----\n\nWhat we need from the grocery store:\n\n- - tofu\n- - vegetables\n- - noodles\n\n-----BEGIN PGP SIGNATURE-----\n\nwpgGARsKAAAAKQWCY5ijYyIhBssYbE8GCaaX5NUt+mxyKwwfHifBilZwj2Ul7Ce6\n2azJAAAAAGk2IHZJX1AhiJD39eLuPBgiUU9wUA9VHYblySHkBONKU/usJ9BvuAqo\n/FvLFuGWMbKAdA+epq7V4HOtAPlBWmU8QOd6aud+aSunHQaaEJ+iTFjP2OMW0KBr\nNK2ay45cX1IVAQ==\n-----END PGP SIGNATURE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Signature packet here is:",
      "ja": "ここの署名パケットは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  c2                       packet type: Signature\n0x0001     98                    packet length\n0x0002        06                 sig version 6\n0x0003           01              sig type: Canonical Text\n0x0004              1b           pubkey algorithm: Ed25519\n0x0005                 0a        hash algorithm used: SHA2-512\n0x0006                    00 00  hashed subpackets length: 41\n0x0008  00 29\n0x000a        05                 subpkt length\n0x000b           82              critical subpkt: Sig Creation Time\n0x000c              63 98 a3 63   (2022-12-13T16:08:03Z)\n0x0010  22                       subpkt length\n0x0011     21                    subpkt type: Issuer Fingerprint\n0x0012        06                 Fingerprint version 6\n0x0013           cb 18 6c 4f 06  Fingerprint\n0x001a  09 a6 97 e4 d5 2d fa 6c\n0x0020  72 2b 0c 1f 1e 27 c1 8a\n0x0028  56 70 8f 65 25 ec 27 ba\n0x0030  d9 ac c9\n0x0033           00 00 00 00     unhashed subpackets length: 0\n0x0037                       69  left 16 bits of signed hash\n0x0038  36\n0x0039     20                    salt length\n0x003a        76 49 5f 50 21 88  salt\n0x0040  90 f7 f5 e2 ee 3c 18 22\n0x0048  51 4f 70 50 0f 55 1d 86\n0x0050  e5 c9 21 e4 04 e3 4a 53\n0x0058  fb ac\n0x005a        27 d0 6f b8 0a a8  Ed25519 signature\n0x0060  fc 5b cb 16 e1 96 31 b2\n0x0068  80 74 0f 9e a6 ae d5 e0\n0x0070  73 ad 00 f9 41 5a 65 3c\n0x0078  40 e7 7a 6a e7 7e 69 2b\n0x0080  a7 1d 06 9a 10 9f a2 4c\n0x0088  58 cf d8 e3 16 d0 a0 6b\n0x0090  34 ad 9a cb 8e 5c 5f 52\n0x0098  15 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The signature is made over the following data:",
      "ja": "署名は、次のデータに対して行われます。"
    },
    {
      "indent": 3,
      "text": "0x0000  76 49 5f 50 21 88 90 f7\n0x0008  f5 e2 ee 3c 18 22 51 4f\n0x0010  70 50 0f 55 1d 86 e5 c9\n0x0018  21 e4 04 e3 4a 53 fb ac\n0x0020  57 68 61 74 20 77 65 20\n0x0028  6e 65 65 64 20 66 72 6f\n0x0030  6d 20 74 68 65 20 67 72\n0x0038  6f 63 65 72 79 20 73 74\n0x0040  6f 72 65 3a 0d 0a 0d 0a\n0x0048  2d 20 74 6f 66 75 0d 0a\n0x0050  2d 20 76 65 67 65 74 61\n0x0058  62 6c 65 73 0d 0a 2d 20\n0x0060  6e 6f 6f 64 6c 65 73 0d\n0x0068  0a 06 01 1b 0a 00 00 00\n0x0070  29 05 82 63 98 a3 63 22\n0x0078  21 06 cb 18 6c 4f 06 09\n0x0080  a6 97 e4 d5 2d fa 6c 72\n0x0088  2b 0c 1f 1e 27 c1 8a 56\n0x0090  70 8f 65 25 ec 27 ba d9\n0x0098  ac c9 06 ff 00 00 00 31",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  76 49 5f 50 21 88 90 f7  salt\n0x0008  f5 e2 ee 3c 18 22 51 4f\n0x0010  70 50 0f 55 1d 86 e5 c9\n0x0018  21 e4 04 e3 4a 53 fb ac\n      [ message begins ]\n0x0020  57 68 61 74 20 77 65 20  canonicalized message\n0x0028  6e 65 65 64 20 66 72 6f\n0x0030  6d 20 74 68 65 20 67 72\n0x0038  6f 63 65 72 79 20 73 74\n0x0040  6f 72 65 3a 0d 0a 0d 0a\n0x0048  2d 20 74 6f 66 75 0d 0a\n0x0050  2d 20 76 65 67 65 74 61\n0x0058  62 6c 65 73 0d 0a 2d 20\n0x0060  6e 6f 6f 64 6c 65 73 0d\n0x0068  0a\n      [ trailer begins ]\n0x0069     06                    sig version 6\n0x006a        01                 sig type: Canonical Text\n0x006b           1b              pubkey algorithm: Ed25519\n0x006c              0a           hash algorithm: SHA2-512\n0x006d                 00 00 00  hashed subpackets length\n0x0070  29\n0x0071     05                    subpacket length\n0x0072        82                 critical subpkt: Sig Creation Time\n0x0073           63 98 a3 63       (2022-12-13T16:08:03Z)\n0x0077                       22  subpkt length\n0x0078  21                       subpkt type: Issuer Fingerprint\n0x0079     06                    Fingerprint version 6\n0x007a        cb 18 6c 4f 06 09  Fingerprint\n0x0080  a6 97 e4 d5 2d fa 6c 72\n0x0088  2b 0c 1f 1e 27 c1 8a 56\n0x0090  70 8f 65 25 ec 27 ba d9\n0x0098  ac c9\n0x009a        06                 sig version 6\n0x009b           ff              sentinel octet\n0x009c              00 00 00 31  trailer length",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The calculated SHA2-512 hash digest over this data is:",
      "ja": "このデータ上の計算されたSHA2-512ハッシュダイジェストは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "69365bf44a97af1f0844f1f6ab83fdf6b36f26692efaa621a8aac91c4e29ea07\ne894cabc6e2f20eedfce6c03b89141a2cc7cbe245e6e7a5654addbec5000b89b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.7. Sample Inline-Signed Message",
      "section_title": true,
      "ja": "A.7. インライン署名メッセージのサンプル"
    },
    {
      "indent": 3,
      "text": "This is the same message and signature as in Appendix A.6 but as an inline-signed message. The hashed data is exactly the same, and all intermediate values and annotated hex dumps are also applicable.",
      "ja": "これは、付録A.6と同じメッセージと署名ですが、インライン署名メッセージとしてです。ハッシュされたデータはまったく同じであり、すべての中間値と注釈付きヘックスダンプも適用されます。"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\n\nxEYGAQobIHZJX1AhiJD39eLuPBgiUU9wUA9VHYblySHkBONKU/usyxhsTwYJppfk\n1S36bHIrDB8eJ8GKVnCPZSXsJ7rZrMkBy0p1AAAAAABXaGF0IHdlIG5lZWQgZnJv\nbSB0aGUgZ3JvY2VyeSBzdG9yZToKCi0gdG9mdQotIHZlZ2V0YWJsZXMKLSBub29k\nbGVzCsKYBgEbCgAAACkFgmOYo2MiIQbLGGxPBgmml+TVLfpscisMHx4nwYpWcI9l\nJewnutmsyQAAAABpNiB2SV9QIYiQ9/Xi7jwYIlFPcFAPVR2G5ckh5ATjSlP7rCfQ\nb7gKqPxbyxbhljGygHQPnqau1eBzrQD5QVplPEDnemrnfmkrpx0GmhCfokxYz9jj\nFtCgazStmsuOXF9SFQE=\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.8. Sample X25519-AEAD-OCB Encryption and Decryption",
      "section_title": true,
      "ja": "A.8. サンプルX25519-AEAD-OCB暗号化と復号化"
    },
    {
      "indent": 3,
      "text": "This example encrypts the cleartext string Hello, world! for the sample cert (see Appendix A.3), using AES-128 with AEAD-OCB encryption.",
      "ja": "この例は、ClearText文字列こんにちは、世界を暗号化します！サンプル証明書（付録A.3を参照）については、AES-128を使用してAEAD-OCB暗号化を使用します。"
    },
    {
      "indent": 0,
      "text": "A.8.1. Sample Version 6 Public Key Encrypted Session Key Packet",
      "section_title": true,
      "ja": "A.8.1. サンプルバージョン6公開キー暗号化セッションキーパケット"
    },
    {
      "indent": 3,
      "text": "This packet contains the following series of octets:",
      "ja": "このパケットには、次のシリーズのオクテットが含まれています。"
    },
    {
      "indent": 3,
      "text": "0x0000  c1 5d 06 21 06 12 c8 3f\n0x0008  1e 70 6f 63 08 fe 15 1a\n0x0010  41 77 43 a1 f0 33 79 0e\n0x0018  93 e9 97 84 88 d1 db 37\n0x0020  8d a9 93 08 85 19 87 cf\n0x0028  18 d5 f1 b5 3f 81 7c ce\n0x0030  5a 00 4c f3 93 cc 89 58\n0x0038  bd dc 06 5f 25 f8 4a f5\n0x0040  09 b1 7d d3 67 64 18 de\n0x0048  a3 55 43 79 56 61 79 01\n0x0050  e0 69 57 fb ca 8a 6a 47\n0x0058  a5 b5 15 3e 8d 3a b7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  c1                       packet type: PKESK\n0x0001     5d                    packet length\n0x0002        06                 v6 PKESK\n0x0003           21              length of fingerprint\n0x0004              06           Key version 6\n0x0005                 12 c8 3f  Key fingerprint\n0x0008  1e 70 6f 63 08 fe 15 1a\n0x0010  41 77 43 a1 f0 33 79 0e\n0x0018  93 e9 97 84 88 d1 db 37\n0x0020  8d a9 93 08 85\n0x0025                 19        algorithm: X25519\n0x0026                    87 cf  Ephemeral key\n0x0028  18 d5 f1 b5 3f 81 7c ce\n0x0030  5a 00 4c f3 93 cc 89 58\n0x0038  bd dc 06 5f 25 f8 4a f5\n0x0040  09 b1 7d d3 67 64\n0x0046                    18     ESK length\n0x0047                       de  ESK\n0x0048  a3 55 43 79 56 61 79 01\n0x0050  e0 69 57 fb ca 8a 6a 47\n0x0058  a5 b5 15 3e 8d 3a b7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.8.2. X25519 Encryption/Decryption of the Session Key",
      "section_title": true,
      "ja": "A.8.2. x25519セッションキーの暗号化/復号化"
    },
    {
      "indent": 3,
      "text": "Ephemeral key:",
      "ja": "一時的な鍵："
    },
    {
      "indent": 5,
      "text": "87 cf 18 d5 f1 b5 3f 81 7c ce 5a 00 4c f3 93 cc\n89 58 bd dc 06 5f 25 f8 4a f5 09 b1 7d d3 67 64",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This ephemeral key is derived from the following ephemeral secret key material, which is never placed on the wire:",
      "ja": "このはかない鍵は、次の一時的なシークレットキーの素材から派生しています。"
    },
    {
      "indent": 5,
      "text": "af 1e 43 c0 d1 23 ef e8 93 a7 d4 d3 90 f3 a7 61\ne3 fa c3 3d fc 7f 3e da a8 30 c9 01 13 52 c7 79",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Public key from the target certificate (see Appendix A.3):",
      "ja": "ターゲット証明書からの公開鍵（付録A.3を参照）："
    },
    {
      "indent": 5,
      "text": "86 93 24 83 67 f9 e5 01 5d b9 22 f8 f4 80 95 dd\na7 84 98 7f 2d 59 85 b1 2f ba d1 6c af 5e 44 35",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The corresponding long-lived X25519 private key material (see Appendix A.4):",
      "ja": "対応する長寿命X25519秘密鍵素材（付録A.4を参照）："
    },
    {
      "indent": 5,
      "text": "4d 60 0a 4f 79 4d 44 77 5c 57 a2 6e 0f ee fe d5\n58 e9 af ff d6 ad 0d 58 2d 57 fb 2b a2 dc ed b8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Shared point:",
      "ja": "共有ポイント："
    },
    {
      "indent": 5,
      "text": "67 e3 0e 69 cd c7 ba b2 a2 68 0d 78 ac a4 6a 2f\n8b 6e 2a e4 4d 39 8b dc 6f 92 c5 ad 4a 49 25 14",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF output:",
      "ja": "HKDF出力："
    },
    {
      "indent": 5,
      "text": "f6 6d ad cf f6 45 92 23 9b 25 45 39 b6 4f f6 07",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decrypted session key:",
      "ja": "復号化されたセッションキー："
    },
    {
      "indent": 5,
      "text": "dd 70 8f 6f a1 ed 65 11 4d 68 d2 34 3e 7c 2f 1d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.8.3. Sample v2 SEIPD Packet",
      "section_title": true,
      "ja": "A.8.3. サンプルV2 SEIPDパケット"
    },
    {
      "indent": 3,
      "text": "This packet contains the following series of octets:",
      "ja": "このパケットには、次のシリーズのオクテットが含まれています。"
    },
    {
      "indent": 3,
      "text": "0x0000  d2 69 02 07 02 06 61 64\n0x0008  16 53 5b e0 b0 71 6d 60\n0x0010  e0 52 a5 6c 4c 40 7f 9e\n0x0018  b3 6b 0e fa fe 9a d0 a0\n0x0020  df 9b 03 3c 69 a2 1b a9\n0x0028  eb d2 c0 ec 95 bf 56 9d\n0x0030  25 c9 99 ee 4a 3d e1 70\n0x0038  58 f4 0d fa 8b 4c 68 2b\n0x0040  e3 fb bb d7 b2 7e b0 f5\n0x0048  9b b5 00 5f 80 c7 c6 f4\n0x0050  03 88 c3 0a d4 06 ab 05\n0x0058  13 dc d6 f9 fd 73 76 56\n0x0060  28 6e 11 77 d0 0f 88 8a\n0x0068  db 31 c4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  d2                       packet type: SEIPD\n0x0001     69                    packet length\n0x0002        02                 v2 SEIPD\n0x0003           07              cipher: AES128\n0x0004              02           AEAD mode: OCB\n0x0005                 06        chunk size (2^12 octets)\n0x0006                    61 64  salt\n0x0008  16 53 5b e0 b0 71 6d 60\n0x0010  e0 52 a5 6c 4c 40 7f 9e\n0x0018  b3 6b 0e fa fe 9a d0 a0\n0x0020  df 9b 03 3c 69 a2\n0x0026                    1b a9  chunk #0 encrypted data\n0x0028  eb d2 c0 ec 95 bf 56 9d\n0x0030  25 c9 99 ee 4a 3d e1 70\n0x0038  58 f4 0d fa 8b 4c 68 2b\n0x0040  e3 fb bb d7 b2 7e b0 f5\n0x0048  9b b5 00\n0x004b           5f 80 c7 c6 f4  chunk #0 AEAD tag\n0x0050  03 88 c3 0a d4 06 ab 05\n0x0058  13 dc d6\n0x005b           f9 fd 73 76 56  final AEAD tag (#1)\nS0x0060  28 6e 11 77 d0 0f 88 8a\n0x0068  db 31 c4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.8.4. Decryption of Data",
      "section_title": true,
      "ja": "A.8.4. データの復号化"
    },
    {
      "indent": 3,
      "text": "Starting AEAD-OCB decryption of data, using the session key.",
      "ja": "セッションキーを使用して、データのAEAD-OCB復号化を開始します。"
    },
    {
      "indent": 3,
      "text": "HKDF info:",
      "ja": "HKDF情報："
    },
    {
      "indent": 5,
      "text": "d2 02 07 02 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF output:",
      "ja": "HKDF出力："
    },
    {
      "indent": 5,
      "text": "45 12 f7 14 9d 86 33 41 52 7c 65 67 d5 bf fc 42\n5f af 32 50 21 2f f9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message key:",
      "ja": "メッセージキー："
    },
    {
      "indent": 5,
      "text": "45 12 f7 14 9d 86 33 41 52 7c 65 67 d5 bf fc 42",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Initialization vector:",
      "ja": "初期化ベクトル："
    },
    {
      "indent": 5,
      "text": "5f af 32 50 21 2f f9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk #0:",
      "ja": "チャンク＃0："
    },
    {
      "indent": 3,
      "text": "Nonce:",
      "ja": "ノンセ："
    },
    {
      "indent": 5,
      "text": "5f af 32 50 21 2f f9 00 00 00 00 00 00 00 00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Additional authenticated data:",
      "ja": "追加の認証データ："
    },
    {
      "indent": 5,
      "text": "d2 02 07 02 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Encrypted data chunk:",
      "ja": "暗号化されたデータチャンク："
    },
    {
      "indent": 5,
      "text": "1b a9 eb d2 c0 ec 95 bf 56 9d 25 c9 99 ee 4a 3d\ne1 70 58 f4 0d fa 8b 4c 68 2b e3 fb bb d7 b2 7e\nb0 f5 9b b5 00 5f 80 c7 c6 f4 03 88 c3 0a d4 06\nab 05 13 dc d6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decrypted chunk #0.",
      "ja": "復号化されたチャンク＃0。"
    },
    {
      "indent": 3,
      "text": "Literal Data packet with the string contents Hello, world!:",
      "ja": "文字列コンテンツを備えたリテラルデータパケットこんにちは、world！："
    },
    {
      "indent": 5,
      "text": "cb 13 62 00 00 00 00 00 48 65 6c 6c 6f 2c 20 77\n6f 72 6c 64 21",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Padding packet:",
      "ja": "パディングパケット："
    },
    {
      "indent": 5,
      "text": "d5 0e c5 a2 93 07 29 91 62 81 47 d7 2c 8f 86 b7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Authenticating final tag:",
      "ja": "最終タグの認証："
    },
    {
      "indent": 3,
      "text": "Final nonce:",
      "ja": "最終的な非CE："
    },
    {
      "indent": 5,
      "text": "5f af 32 50 21 2f f9 00 00 00 00 00 00 00 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Final additional authenticated data:",
      "ja": "最終的な追加の認証データ："
    },
    {
      "indent": 5,
      "text": "d2 02 07 02 06 00 00 00 00 00 00 00 25",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.8.5. Complete X25519-AEAD-OCB Encrypted Packet Sequence",
      "section_title": true,
      "ja": "A.8.5. 完全なX25519-AEAD-OCB暗号化されたパケットシーケンス"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\n\nwV0GIQYSyD8ecG9jCP4VGkF3Q6HwM3kOk+mXhIjR2zeNqZMIhRmHzxjV8bU/gXzO\nWgBM85PMiVi93AZfJfhK9QmxfdNnZBjeo1VDeVZheQHgaVf7yopqR6W1FT6NOrfS\naQIHAgZhZBZTW+CwcW1g4FKlbExAf56zaw76/prQoN+bAzxpohup69LA7JW/Vp0l\nyZnuSj3hcFj0DfqLTGgr4/u717J+sPWbtQBfgMfG9AOIwwrUBqsFE9zW+f1zdlYo\nbhF30A+IitsxxA==\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.9. Sample AEAD-EAX Encryption and Decryption",
      "section_title": true,
      "ja": "A.9. サンプルAEAD-EAX暗号化と復号化"
    },
    {
      "indent": 3,
      "text": "This example encrypts the cleartext string Hello, world! with the passphrase password, using AES-128 with AEAD-EAX encryption.",
      "ja": "この例は、ClearText文字列こんにちは、世界を暗号化します！PassPhraseパスワードを使用して、AEAD-EAX暗号化でAES-128を使用します。"
    },
    {
      "indent": 0,
      "text": "A.9.1. Sample Version 6 Symmetric Key Encrypted Session Key Packet",
      "section_title": true,
      "ja": "A.9.1. サンプルバージョン6対称キー暗号化セッションキーパケット"
    },
    {
      "indent": 3,
      "text": "This packet contains the following series of octets:",
      "ja": "このパケットには、次のシリーズのオクテットが含まれています。"
    },
    {
      "indent": 3,
      "text": "0x0000  c3 40 06 1e 07 01 0b 03\n0x0008  08 a5 ae 57 9d 1f c5 d8\n0x0010  2b ff 69 22 4f 91 99 93\n0x0018  b3 50 6f a3 b5 9a 6a 73\n0x0020  cf f8 c5 ef c5 f4 1c 57\n0x0028  fb 54 e1 c2 26 81 5d 78\n0x0030  28 f5 f9 2c 45 4e b6 5e\n0x0038  be 00 ab 59 86 c6 8e 6e\n0x0040  7c 55",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  c3                       packet type: SKESK\n0x0001     40                    packet length\n0x0002        06                 v6 SKESK\n0x0003           1e              length through end of AEAD nonce\n0x0004              07           cipher: AES128\n0x0005                 01        AEAD mode: EAX\n0x0006                    0b     length of S2K\n0x0007                       03  S2K type: iterated+salted\n0x0008  08                       S2K hash: SHA2-256\n0x0009     a5 ae 57 9d 1f c5 d8  S2K salt\n0x0010  2b\n0x0011     ff                    S2K iterations (65011712 octets)\n0x0012        69 22 4f 91 99 93  AEAD nonce\n0x0018  b3 50 6f a3 b5 9a 6a 73\n0x0020  cf f8\n0x0022        c5 ef c5 f4 1c 57  encrypted session key\n0x0028  fb 54 e1 c2 26 81 5d 78\n0x0030  28 f5\n0x0032        f9 2c 45 4e b6 5e  AEAD tag\n0x0038  be 00 ab 59 86 c6 8e 6e\n0x0040  7c 55",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.9.2. Starting AEAD-EAX Decryption of the Session Key",
      "section_title": true,
      "ja": "A.9.2. セッションキーのAEAD-EAX復号化の開始"
    },
    {
      "indent": 3,
      "text": "The derived key is:",
      "ja": "派生キーは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "15 49 67 e5 90 aa 1f 92 3e 1c 0a c6 4c 88 f2 3d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF info:",
      "ja": "HKDF情報："
    },
    {
      "indent": 5,
      "text": "c3 06 07 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF output:",
      "ja": "HKDF出力："
    },
    {
      "indent": 5,
      "text": "2f ce 33 1f 39 dd 95 5c c4 1e 95 d8 70 c7 21 39",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Authenticated Data:",
      "ja": "認証されたデータ："
    },
    {
      "indent": 5,
      "text": "c3 06 07 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nonce:",
      "ja": "ノンセ："
    },
    {
      "indent": 5,
      "text": "69 22 4f 91 99 93 b3 50 6f a3 b5 9a 6a 73 cf f8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decrypted session key:",
      "ja": "復号化されたセッションキー："
    },
    {
      "indent": 5,
      "text": "38 81 ba fe 98 54 12 45 9b 86 c3 6f 98 cb 9a 5e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.9.3. Sample v2 SEIPD Packet",
      "section_title": true,
      "ja": "A.9.3. サンプルV2 SEIPDパケット"
    },
    {
      "indent": 3,
      "text": "This packet contains the following series of octets:",
      "ja": "このパケットには、次のシリーズのオクテットが含まれています。"
    },
    {
      "indent": 3,
      "text": "0x0000  d2 69 02 07 01 06 9f f9\n0x0008  0e 3b 32 19 64 f3 a4 29\n0x0010  13 c8 dc c6 61 93 25 01\n0x0018  52 27 ef b7 ea ea a4 9f\n0x0020  04 c2 e6 74 17 5d 4a 3d\n0x0028  22 6e d6 af cb 9c a9 ac\n0x0030  12 2c 14 70 e1 1c 63 d4\n0x0038  c0 ab 24 1c 6a 93 8a d4\n0x0040  8b f9 9a 5a 99 b9 0b ba\n0x0048  83 25 de 61 04 75 40 25\n0x0050  8a b7 95 9a 95 ad 05 1d\n0x0058  da 96 eb 15 43 1d fe f5\n0x0060  f5 e2 25 5c a7 82 61 54\n0x0068  6e 33 9a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  d2                       packet type: SEIPD\n0x0001     69                    packet length\n0x0002        02                 v2 SEIPD\n0x0003           07              cipher: AES128\n0x0004              01           AEAD mode: EAX\n0x0005                 06        chunk size (2^12 octets)\n0x0005                    9f f9  salt\n0x0008  0e 3b 32 19 64 f3 a4 29\n0x0010  13 c8 dc c6 61 93 25 01\n0x0018  52 27 ef b7 ea ea a4 9f\n0x0020  04 c2 e6 74 17 5d\n0x0026                    4a 3d  chunk #0 encrypted data\n0x0028  22 6e d6 af cb 9c a9 ac\n0x0030  12 2c 14 70 e1 1c 63 d4\n0x0038  c0 ab 24 1c 6a 93 8a d4\n0x0040  8b f9 9a 5a 99 b9 0b ba\n0x0048  83 25 de\n0x004b           61 04 75 40 25  chunk #0 AEAD tag\n0x0050  8a b7 95 9a 95 ad 05 1d\n0x0058  da 96 eb\n0x005b           15 43 1d fe f5  final AEAD tag (#1)\n0x0060  f5 e2 25 5c a7 82 61 54\n0x0068  6e 33 9a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.9.4. Decryption of Data",
      "section_title": true,
      "ja": "A.9.4. データの復号化"
    },
    {
      "indent": 3,
      "text": "Starting AEAD-EAX decryption of data, using the session key.",
      "ja": "セッションキーを使用して、データのAEAD-EAX復号化を開始します。"
    },
    {
      "indent": 3,
      "text": "HKDF info:",
      "ja": "HKDF情報："
    },
    {
      "indent": 5,
      "text": "d2 02 07 01 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF output:",
      "ja": "HKDF出力："
    },
    {
      "indent": 5,
      "text": "b5 04 22 ac 1c 26 be 9d dd 83 1d 5b bb 36 b6 4f\n78 b8 33 f2 e9 4a 60 c0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message key:",
      "ja": "メッセージキー："
    },
    {
      "indent": 5,
      "text": "b5 04 22 ac 1c 26 be 9d dd 83 1d 5b bb 36 b6 4f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Initialization vector:",
      "ja": "初期化ベクトル："
    },
    {
      "indent": 5,
      "text": "78 b8 33 f2 e9 4a 60 c0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk #0:",
      "ja": "チャンク＃0："
    },
    {
      "indent": 3,
      "text": "Nonce:",
      "ja": "ノンセ："
    },
    {
      "indent": 5,
      "text": "78 b8 33 f2 e9 4a 60 c0 00 00 00 00 00 00 00 00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Additional authenticated data:",
      "ja": "追加の認証データ："
    },
    {
      "indent": 5,
      "text": "d2 02 07 01 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decrypted chunk #0.",
      "ja": "復号化されたチャンク＃0。"
    },
    {
      "indent": 3,
      "text": "Literal Data packet with the string contents Hello, world!:",
      "ja": "文字列コンテンツを備えたリテラルデータパケットこんにちは、world！："
    },
    {
      "indent": 5,
      "text": "cb 13 62 00 00 00 00 00 48 65 6c 6c 6f 2c 20 77\n6f 72 6c 64 21",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Padding packet:",
      "ja": "パディングパケット："
    },
    {
      "indent": 5,
      "text": "d5 0e ae 5b f0 cd 67 05 50 03 55 81 6c b0 c8 ff",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Authenticating final tag:",
      "ja": "最終タグの認証："
    },
    {
      "indent": 3,
      "text": "Final nonce:",
      "ja": "最終的な非CE："
    },
    {
      "indent": 5,
      "text": "78 b8 33 f2 e9 4a 60 c0 00 00 00 00 00 00 00 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Final additional authenticated data:",
      "ja": "最終的な追加の認証データ："
    },
    {
      "indent": 5,
      "text": "d2 02 07 01 06 00 00 00 00 00 00 00 25",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.9.5. Complete AEAD-EAX Encrypted Packet Sequence",
      "section_title": true,
      "ja": "A.9.5. 完全なAEAD-EAX暗号化されたパケットシーケンス"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\n\nw0AGHgcBCwMIpa5XnR/F2Cv/aSJPkZmTs1Bvo7WaanPP+MXvxfQcV/tU4cImgV14\nKPX5LEVOtl6+AKtZhsaObnxV0mkCBwEGn/kOOzIZZPOkKRPI3MZhkyUBUifvt+rq\npJ8EwuZ0F11KPSJu1q/LnKmsEiwUcOEcY9TAqyQcapOK1Iv5mlqZuQu6gyXeYQR1\nQCWKt5Wala0FHdqW6xVDHf719eIlXKeCYVRuM5o=\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.10. Sample AEAD-OCB Encryption and Decryption",
      "section_title": true,
      "ja": "A.10. サンプルAEAD-OCB暗号化と復号化"
    },
    {
      "indent": 3,
      "text": "This example encrypts the cleartext string Hello, world! with the passphrase password, using AES-128 with AEAD-OCB encryption.",
      "ja": "この例は、ClearText文字列こんにちは、世界を暗号化します！PassPhraseパスワードを使用して、AES-OCB暗号化を備えたAES-128を使用します。"
    },
    {
      "indent": 0,
      "text": "A.10.1. Sample Version 6 Symmetric Key Encrypted Session Key Packet",
      "section_title": true,
      "ja": "A.10.1. サンプルバージョン6対称キー暗号化セッションキーパケット"
    },
    {
      "indent": 3,
      "text": "This packet contains the following series of octets:",
      "ja": "このパケットには、次のシリーズのオクテットが含まれています。"
    },
    {
      "indent": 3,
      "text": "0x0000  c3 3f 06 1d 07 02 0b 03\n0x0008  08 56 a2 98 d2 f5 e3 64\n0x0010  53 ff cf cc 5c 11 66 4e\n0x0018  db 9d b4 25 90 d7 dc 46\n0x0020  b0 72 41 b6 12 c3 81 2c\n0x0028  ff fb ea 00 f2 34 7b 25\n0x0030  64 11 23 f8 87 ae 60 d4\n0x0038  fd 61 4e 08 37 d8 19 d3\n0x0040  6c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  c3                       packet type: SKESK\n0x0001     3f                    packet length\n0x0002        06                 v6 SKESK\n0x0003           1d              length through end of AEAD nonce\n0x0004              07           cipher: AES128\n0x0005                 02        AEAD mode: OCB\n0x0006                    0b     length of S2K\n0x0007                       03  S2K type: iterated+salted\n0x0008  08                       S2K hash: SHA2-256\n0x0009     56 a2 98 d2 f5 e3 64  S2K salt\n0x0010  53\n0x0011    ff                     S2K iterations (65011712 octets)\n0x0012        cf cc 5c 11 66 4e  AEAD nonce\n0x0018  db 9d b4 25 90 d7 dc 46\n0x0020  b0\n0x0021     72 41 b6 12 c3 81 2c  encrypted session key\n0x0028  ff fb ea 00 f2 34 7b 25\n0x0030  64\n0x0031     11 23 f8 87 ae 60 d4  AEAD tag\n0x0038  fd 61 4e 08 37 d8 19 d3\n0x0040  6c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.10.2. Starting AEAD-OCB Decryption of the Session Key",
      "section_title": true,
      "ja": "A.10.2. セッションキーのAEAD-OCB復号化の開始"
    },
    {
      "indent": 3,
      "text": "The derived key is:",
      "ja": "派生キーは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "e8 0d e2 43 a3 62 d9 3b 9d c6 07 ed e9 6a 73 56",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF info:",
      "ja": "HKDF情報："
    },
    {
      "indent": 5,
      "text": "c3 06 07 02",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF output:",
      "ja": "HKDF出力："
    },
    {
      "indent": 5,
      "text": "38 a9 b3 45 b5 68 0b b6 1b b6 5d 73 ee c7 ec d9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Authenticated Data:",
      "ja": "認証されたデータ："
    },
    {
      "indent": 5,
      "text": "c3 06 07 02",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nonce:",
      "ja": "ノンセ："
    },
    {
      "indent": 5,
      "text": "cf cc 5c 11 66 4e db 9d b4 25 90 d7 dc 46 b0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decrypted session key:",
      "ja": "復号化されたセッションキー："
    },
    {
      "indent": 5,
      "text": "28 e7 9a b8 23 97 d3 c6 3d e2 4a c2 17 d7 b7 91",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.10.3. Sample v2 SEIPD Packet",
      "section_title": true,
      "ja": "A.10.3. サンプルV2 SEIPDパケット"
    },
    {
      "indent": 3,
      "text": "This packet contains the following series of octets:",
      "ja": "このパケットには、次のシリーズのオクテットが含まれています。"
    },
    {
      "indent": 3,
      "text": "0x0000  d2 69 02 07 02 06 20 a6\n0x0008  61 f7 31 fc 9a 30 32 b5\n0x0010  62 33 26 02 7e 3a 5d 8d\n0x0018  b5 74 8e be ff 0b 0c 59\n0x0020  10 d0 9e cd d6 41 ff 9f\n0x0028  d3 85 62 75 80 35 bc 49\n0x0030  75 4c e1 bf 3f ff a7 da\n0x0038  d0 a3 b8 10 4f 51 33 cf\n0x0040  42 a4 10 0a 83 ee f4 ca\n0x0048  1b 48 01 a8 84 6b f4 2b\n0x0050  cd a7 c8 ce 9d 65 e2 12\n0x0058  f3 01 cb cd 98 fd ca de\n0x0060  69 4a 87 7a d4 24 73 23\n0x0068  f6 e8 57",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  d2                       packet type: SEIPD\n0x0001     69                    packet length\n0x0002        02                 v2 SEIPD\n0x0003           07              cipher: AES128\n0x0004              02           AEAD mode: OCB\n0x0005                 06        chunk size (2^12 octets)\n0x0006                    20 a6  salt\n0x0008  61 f7 31 fc 9a 30 32 b5\n0x0010  62 33 26 02 7e 3a 5d 8d\n0x0018  b5 74 8e be ff 0b 0c 59\n0x0020  10 d0 9e cd d6 41\n0x0026                    ff 9f  chunk #0 encrypted data\n0x0028  d3 85 62 75 80 35 bc 49\n0x0030  75 4c e1 bf 3f ff a7 da\n0x0038  d0 a3 b8 10 4f 51 33 cf\n0x0040  42 a4 10 0a 83 ee f4 ca\n0x0048  1b 48 01\n0x004b           a8 84 6b f4 2b  chunk #0 authentication tag\n0x0050  cd a7 c8 ce 9d 65 e2 12\n0x0058  f3 01 cb\n0x005b           cd 98 fd ca de  final AEAD tag (#1)\n0x0060  69 4a 87 7a d4 24 73 23\n0x0068  f6 e8 57",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.10.4. Decryption of Data",
      "section_title": true,
      "ja": "A.10.4. データの復号化"
    },
    {
      "indent": 3,
      "text": "Starting AEAD-OCB decryption of data, using the session key.",
      "ja": "セッションキーを使用して、データのAEAD-OCB復号化を開始します。"
    },
    {
      "indent": 3,
      "text": "HKDF info:",
      "ja": "HKDF情報："
    },
    {
      "indent": 5,
      "text": "d2 02 07 02 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF output:",
      "ja": "HKDF出力："
    },
    {
      "indent": 5,
      "text": "71 66 2a 11 ee 5b 4e 08 14 4e 6d e8 83 a0 09 99\neb de 12 bb 57 0d cf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message key:",
      "ja": "メッセージキー："
    },
    {
      "indent": 5,
      "text": "71 66 2a 11 ee 5b 4e 08 14 4e 6d e8 83 a0 09 99",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Initialization vector:",
      "ja": "初期化ベクトル："
    },
    {
      "indent": 5,
      "text": "eb de 12 bb 57 0d cf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk #0:",
      "ja": "チャンク＃0："
    },
    {
      "indent": 3,
      "text": "Nonce:",
      "ja": "ノンセ："
    },
    {
      "indent": 5,
      "text": "eb de 12 bb 57 0d cf 00 00 00 00 00 00 00 00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Additional authenticated data:",
      "ja": "追加の認証データ："
    },
    {
      "indent": 5,
      "text": "d2 02 07 02 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decrypted chunk #0.",
      "ja": "復号化されたチャンク＃0。"
    },
    {
      "indent": 3,
      "text": "Literal Data packet with the string contents Hello, world!:",
      "ja": "文字列コンテンツを備えたリテラルデータパケットこんにちは、world！："
    },
    {
      "indent": 5,
      "text": "cb 13 62 00 00 00 00 00 48 65 6c 6c 6f 2c 20 77\n6f 72 6c 64 21",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Padding packet:",
      "ja": "パディングパケット："
    },
    {
      "indent": 5,
      "text": "d5 0e ae 6a a1 64 9b 56 aa 83 5b 26 13 90 2b d2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Authenticating final tag:",
      "ja": "最終タグの認証："
    },
    {
      "indent": 3,
      "text": "Final nonce:",
      "ja": "最終的な非CE："
    },
    {
      "indent": 5,
      "text": "eb de 12 bb 57 0d cf 00 00 00 00 00 00 00 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Final additional authenticated data:",
      "ja": "最終的な追加の認証データ："
    },
    {
      "indent": 5,
      "text": "d2 02 07 02 06 00 00 00 00 00 00 00 25",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.10.5. Complete AEAD-OCB Encrypted Packet Sequence",
      "section_title": true,
      "ja": "A.10.5. 完全なAEAD-OCB暗号化されたパケットシーケンス"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\n\nwz8GHQcCCwMIVqKY0vXjZFP/z8xcEWZO2520JZDX3EawckG2EsOBLP/76gDyNHsl\nZBEj+IeuYNT9YU4IN9gZ02zSaQIHAgYgpmH3MfyaMDK1YjMmAn46XY21dI6+/wsM\nWRDQns3WQf+f04VidYA1vEl1TOG/P/+n2tCjuBBPUTPPQqQQCoPu9MobSAGohGv0\nK82nyM6dZeIS8wHLzZj9yt5pSod61CRzI/boVw==\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.11. Sample AEAD-GCM Encryption and Decryption",
      "section_title": true,
      "ja": "A.11. サンプルAEAD-GCM暗号化と復号化"
    },
    {
      "indent": 3,
      "text": "This example encrypts the cleartext string Hello, world! with the passphrase password, using AES-128 with AEAD-GCM encryption.",
      "ja": "この例は、ClearText文字列こんにちは、世界を暗号化します！PassPhraseパスワードを使用して、AES-GCM暗号化を備えたAES-128を使用します。"
    },
    {
      "indent": 0,
      "text": "A.11.1. Sample Version 6 Symmetric Key Encrypted Session Key Packet",
      "section_title": true,
      "ja": "A.11.1. サンプルバージョン6対称キー暗号化セッションキーパケット"
    },
    {
      "indent": 3,
      "text": "This packet contains the following series of octets:",
      "ja": "このパケットには、次のシリーズのオクテットが含まれています。"
    },
    {
      "indent": 3,
      "text": "0x0000  c3 3c 06 1a 07 03 0b 03\n0x0008  08 e9 d3 97 85 b2 07 00\n0x0010  08 ff b4 2e 7c 48 3e f4\n0x0018  88 44 57 cb 37 26 b9 b3\n0x0020  db 9f f7 76 e5 f4 d9 a4\n0x0028  09 52 e2 44 72 98 85 1a\n0x0030  bf ff 75 26 df 2d d5 54\n0x0038  41 75 79 a7 79 9f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  c3                       packet type: SKESK\n0x0001     3c                    packet length\n0x0002        06                 v6 SKESK\n0x0003           1a              length through end of AEAD nonce\n0x0004              07           cipher: AES128\n0x0005                 03        AEAD mode: GCM\n0x0006                    0b     length of S2K\n0x0007                       03  S2K type: iterated+salted\n0x0008  08                       S2K hash: SHA2-256\n0x0009     e9 d3 97 85 b2 07 00  S2K salt\n0x0010  08\n0x0011     ff                    S2K iterations (65011712 octets)\n0x0012        b4 2e 7c 48 3e f4  AEAD nonce\n0x0018  88 44 57 cb 37 26\n0x001e                    b9 b3  encrypted session key\n0x0020  db 9f f7 76 e5 f4 d9 a4\n0x0028  09 52 e2 44 72 98\n0x002e                     85 1a  AEAD tag\n0x0030  bf ff 75 26 df 2d d5 54\n0x0038  41 75 79 a7 79 9f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.11.2. Starting AEAD-GCM Decryption of the Session Key",
      "section_title": true,
      "ja": "A.11.2. セッションキーのAEAD-GCM復号化の開始"
    },
    {
      "indent": 3,
      "text": "The derived key is:",
      "ja": "派生キーは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "25 02 81 71 5b ba 78 28 ef 71 ef 64 c4 78 47 53",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF info:",
      "ja": "HKDF情報："
    },
    {
      "indent": 5,
      "text": "c3 06 07 03",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF output:",
      "ja": "HKDF出力："
    },
    {
      "indent": 5,
      "text": "7a 6f 9a b7 f9 9f 7e f8 db ef 84 1c 65 08 00 f5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Authenticated Data:",
      "ja": "認証されたデータ："
    },
    {
      "indent": 5,
      "text": "c3 06 07 03",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nonce:",
      "ja": "ノンセ："
    },
    {
      "indent": 5,
      "text": "b4 2e 7c 48 3e f4 88 44 57 cb 37 26",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decrypted session key:",
      "ja": "復号化されたセッションキー："
    },
    {
      "indent": 5,
      "text": "19 36 fc 85 68 98 02 74 bb 90 0d 83 19 36 0c 77",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.11.3. Sample v2 SEIPD Packet",
      "section_title": true,
      "ja": "A.11.3. サンプルV2 SEIPDパケット"
    },
    {
      "indent": 3,
      "text": "This packet contains the following series of octets, is:",
      "ja": "このパケットには、次のシリーズのオクテットが含まれています。"
    },
    {
      "indent": 3,
      "text": "0x0000  d2 69 02 07 03 06 fc b9\n0x0008  44 90 bc b9 8b bd c9 d1\n0x0010  06 c6 09 02 66 94 0f 72\n0x0018  e8 9e dc 21 b5 59 6b 15\n0x0020  76 b1 01 ed 0f 9f fc 6f\n0x0028  c6 d6 5b bf d2 4d cd 07\n0x0030  90 96 6e 6d 1e 85 a3 00\n0x0038  53 78 4c b1 d8 b6 a0 69\n0x0040  9e f1 21 55 a7 b2 ad 62\n0x0048  58 53 1b 57 65 1f d7 77\n0x0050  79 12 fa 95 e3 5d 9b 40\n0x0058  21 6f 69 a4 c2 48 db 28\n0x0060  ff 43 31 f1 63 29 07 39\n0x0068  9e 6f f9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The same data, broken out by octet and semantics, is:",
      "ja": "OctetとSemanticsによって分割された同じデータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x0000  d2                       packet type: SEIPD\n0x0001     69                    packet length\n0x0002        02                 v2 SEIPD\n0x0003           07              cipher: AES128\n0x0004              03           AEAD mode: GCM\n0x0005                 06        chunk size (2^12 octets)\n0x0006                    fc b9  salt\n0x0008  44 90 bc b9 8b bd c9 d1\n0x0010  06 c6 09 02 66 94 0f 72\n0x0018  e8 9e dc 21 b5 59 6b 15\n0x0020  76 b1 01 ed 0f 9f\n0x0026                    fc 6f  chunk #0 encrypted data\n0x0028  c6 d6 5b bf d2 4d cd 07\n0x0030  90 96 6e 6d 1e 85 a3 00\n0x0038  53 78 4c b1 d8 b6 a0 69\n0x0040  9e f1 21 55 a7 b2 ad 62\n0x0048  58 53 1b\n0x004b           57 65 1f d7 77  chunk #0 authentication tag\n0x0050  79 12 fa 95 e3 5d 9b 40\n0x0058  21 6f 69\n0x005b           a4 c2 48 db 28  final AEAD tag (#1)\n0x0060  ff 43 31 f1 63 29 07 39\n0x0068  9e 6f f9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.11.4. Decryption of Data",
      "section_title": true,
      "ja": "A.11.4. データの復号化"
    },
    {
      "indent": 3,
      "text": "Starting AEAD-GCM decryption of data, using the session key.",
      "ja": "セッションキーを使用して、データのAEAD-GCM復号化を開始します。"
    },
    {
      "indent": 3,
      "text": "HKDF info:",
      "ja": "HKDF情報："
    },
    {
      "indent": 5,
      "text": "d2 02 07 03 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "HKDF output:",
      "ja": "HKDF出力："
    },
    {
      "indent": 5,
      "text": "ea 14 38 80 3c b8 a4 77 40 ce 9b 54 c3 38 77 8d\n4d 2b dc 2b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message key:",
      "ja": "メッセージキー："
    },
    {
      "indent": 5,
      "text": "ea 14 38 80 3c b8 a4 77 40 ce 9b 54 c3 38 77 8d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Initialization vector:",
      "ja": "初期化ベクトル："
    },
    {
      "indent": 5,
      "text": "4d 2b dc 2b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chunk #0:",
      "ja": "チャンク＃0："
    },
    {
      "indent": 3,
      "text": "Nonce:",
      "ja": "ノンセ："
    },
    {
      "indent": 5,
      "text": "4d 2b dc 2b 00 00 00 00 00 00 00 00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Additional authenticated data:",
      "ja": "追加の認証データ："
    },
    {
      "indent": 5,
      "text": "d2 02 07 03 06",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decrypted chunk #0.",
      "ja": "復号化されたチャンク＃0。"
    },
    {
      "indent": 3,
      "text": "Literal Data packet with the string contents Hello, world!:",
      "ja": "文字列コンテンツを備えたリテラルデータパケットこんにちは、world！："
    },
    {
      "indent": 5,
      "text": "cb 13 62 00 00 00 00 00 48 65 6c 6c 6f 2c 20 77\n6f 72 6c 64 21",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Padding packet:",
      "ja": "パディングパケット："
    },
    {
      "indent": 5,
      "text": "d5 0e 1c e2 26 9a 9e dd ef 81 03 21 72 b7 ed 7c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Authenticating final tag:",
      "ja": "最終タグの認証："
    },
    {
      "indent": 3,
      "text": "Final nonce:",
      "ja": "最終的な非CE："
    },
    {
      "indent": 5,
      "text": "4d 2b dc 2b 00 00 00 00 00 00 00 01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Final additional authenticated data:",
      "ja": "最終的な追加の認証データ："
    },
    {
      "indent": 5,
      "text": "d2 02 07 03 06 00 00 00 00 00 00 00 25",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.11.5. Complete AEAD-GCM Encrypted Packet Sequence",
      "section_title": true,
      "ja": "A.11.5. 完全なAEAD-GCM暗号化されたパケットシーケンス"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\n\nwzwGGgcDCwMI6dOXhbIHAAj/tC58SD70iERXyzcmubPbn/d25fTZpAlS4kRymIUa\nv/91Jt8t1VRBdXmneZ/SaQIHAwb8uUSQvLmLvcnRBsYJAmaUD3LontwhtVlrFXax\nAe0Pn/xvxtZbv9JNzQeQlm5tHoWjAFN4TLHYtqBpnvEhVaeyrWJYUxtXZR/Xd3kS\n+pXjXZtAIW9ppMJI2yj/QzHxYykHOZ5v+Q==\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.12. Sample Messages Encrypted Using Argon2",
      "section_title": true,
      "ja": "A.12. Argon2を使用して暗号化されたサンプルメッセージ"
    },
    {
      "indent": 3,
      "text": "These messages are the literal data Hello, world! encrypted using v1 SEIPD, with Argon2 and the passphrase \"password\", using different session key sizes. In each example, the choice of symmetric cipher is the same in both the v4 SKESK packet and v1 SEIPD packet. In all cases, the Argon2 parameters are t = 1, p = 4, and m = 21.",
      "ja": "これらのメッセージは、文字通りのデータハロー、ワールドです！V1 SEIPDを使用して暗号化され、Argon2とPassPhraseの「パスワード」を使用して、異なるセッションキーサイズを使用します。それぞれの例では、対称暗号の選択は、V4 SkeskパケットとV1 SEIPDパケットの両方で同じです。すべての場合において、argon2パラメーターはt = 1、p = 4、およびm = 21です。"
    },
    {
      "indent": 0,
      "text": "A.12.1. V4 SKESK Using Argon2 with AES-128",
      "section_title": true,
      "ja": "A.12.1. AES-128でArgon2を使用したV4 Skesk"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\nComment: Encrypted using AES with 128-bit key\nComment: Session key: 01FE16BBACFD1E7B78EF3B865187374F\n\nwycEBwScUvg8J/leUNU1RA7N/zE2AQQVnlL8rSLPP5VlQsunlO+ECxHSPgGYGKY+\nYJz4u6F+DDlDBOr5NRQXt/KJIf4m4mOlKyC/uqLbpnLJZMnTq3o79GxBTdIdOzhH\nXfA3pqV4mTzF\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.12.2. V4 SKESK Using Argon2 with AES-192",
      "section_title": true,
      "ja": "A.12.2. AES-192でArgon2を使用したV4 Skesk"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\nComment: Encrypted using AES with 192-bit key\nComment: Session key: 27006DAE68E509022CE45A14E569E91001C2955...\nComment: Session key: ...AF8DFE194\n\nwy8ECAThTKxHFTRZGKli3KNH4UP4AQQVhzLJ2va3FG8/pmpIPd/H/mdoVS5VBLLw\nF9I+AdJ1Sw56PRYiKZjCvHg+2bnq02s33AJJoyBexBI4QKATFRkyez2gldJldRys\nLVg77Mwwfgl2n/d572WciAM=\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.12.3. V4 SKESK Using Argon2 with AES-256",
      "section_title": true,
      "ja": "A.12.3. AES-256でArgon2を使用したV4 Skesk"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\nComment: Encrypted using AES with 256-bit key\nComment: Session key: BBEDA55B9AAE63DAC45D4F49D89DACF4AF37FEF...\nComment: Session key: ...C13BAB2F1F8E18FB74580D8B0\n\nwzcECQS4eJUgIG/3mcaILEJFpmJ8AQQVnZ9l7KtagdClm9UaQ/Z6M/5roklSGpGu\n623YmaXezGj80j4B+Ku1sgTdJo87X1Wrup7l0wJypZls21Uwd67m9koF60eefH/K\n95D1usliXOEm8ayQJQmZrjf6K6v9PWwqMQ==\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Upgrade Guidance (Adapting Implementations from RFCs 4880 and 6637)",
      "section_title": true,
      "ja": "付録B. アップグレードガイダンス（RFCS 4880および6637からの実装の適応）"
    },
    {
      "indent": 3,
      "text": "This subsection offers a concise, non-normative summary of the substantial additions to and departures from [RFC4880] and [RFC6637]. It is intended to help implementers who are augmenting an existing implementation from those specifications to comply with this specification. Cryptographic algorithms marked with \"MTI\" are mandatory to implement.",
      "ja": "このサブセクションは、[RFC4880]および[RFC6637]への大幅な追加と出発の簡潔で非規範的な要約を提供します。これは、これらの仕様から既存の実装を強化している実装者が、この仕様に準拠するのを支援することを目的としています。「MTI」でマークされた暗号化アルゴリズムは、実装するのに必須です。"
    },
    {
      "indent": 6,
      "text": "* Public Key Signing Algorithms:",
      "ja": "* 公開鍵署名アルゴリズム："
    },
    {
      "indent": 12,
      "text": "- Ed25519 (Sections 5.5.5.9 and 5.2.3.4) -- MTI",
      "ja": "- ED25519（セクション5.5.5.9および5.2.3.4）-MTI"
    },
    {
      "indent": 12,
      "text": "- Ed448 (Sections 5.5.5.10 and 5.2.3.5)",
      "ja": "- ED448（セクション5.5.5.10および5.2.3.5）"
    },
    {
      "indent": 12,
      "text": "- EdDSALegacy with Ed25519Legacy (Sections 5.5.5.5 and 5.2.3.3)",
      "ja": "- ED25519LEGACYとのeddsalegacy（セクション5.5.5.5および5.2.3.3）"
    },
    {
      "indent": 12,
      "text": "- ECDSA with Brainpool curves (Section 9.2)",
      "ja": "- Brainpool曲線を備えたECDSA（セクション9.2）"
    },
    {
      "indent": 6,
      "text": "* Public Key Encryption Algorithms:",
      "ja": "* 公開キー暗号化アルゴリズム："
    },
    {
      "indent": 12,
      "text": "- X25519 (Sections 5.5.5.7 and 5.1.6) -- MTI",
      "ja": "- X25519（セクション5.5.5.7および5.1.6）-MTI"
    },
    {
      "indent": 12,
      "text": "- X448 (Sections 5.5.5.8 and 5.1.7)",
      "ja": "- X448（セクション5.5.5.8および5.1.7）"
    },
    {
      "indent": 12,
      "text": "- ECDH with Curve25519Legacy (Section 9.2)",
      "ja": "- Curve25519LegacyのECDH（セクション9.2）"
    },
    {
      "indent": 12,
      "text": "- ECDH with Brainpool curves (Section 9.2)",
      "ja": "- Brainpool Curvesを備えたECDH（セクション9.2）"
    },
    {
      "indent": 6,
      "text": "* AEAD Encryption:",
      "ja": "* AEAD暗号化："
    },
    {
      "indent": 12,
      "text": "- V2 SEIPD (Section 5.13.2)",
      "ja": "- V2 SEIPD（セクション5.13.2）"
    },
    {
      "indent": 12,
      "text": "- AEAD modes:",
      "ja": "- AEADモード："
    },
    {
      "indent": 18,
      "text": "o OCB mode (Section 5.13.4) -- MTI",
      "ja": "o OCBモード（セクション5.13.4）-MTI"
    },
    {
      "indent": 18,
      "text": "o EAX mode (Section 5.13.3)",
      "ja": "o EAXモード（セクション5.13.3）"
    },
    {
      "indent": 18,
      "text": "o GCM mode (Section 5.13.5)",
      "ja": "o GCMモード（セクション5.13.5）"
    },
    {
      "indent": 12,
      "text": "- V6 PKESK (Section 5.1.2)",
      "ja": "- V6 PKSEK（セクション5.1.2）"
    },
    {
      "indent": 12,
      "text": "- V6 SKESK (Section 5.3.2)",
      "ja": "- V6 Skesk（セクション5.3.2）"
    },
    {
      "indent": 12,
      "text": "- Features signature subpacket: add flag for v2 SEIPD (Section 5.2.3.32)",
      "ja": "- 特徴署名サブパケット：V2 SEIPDのフラグを追加します（セクション5.2.3.32）"
    },
    {
      "indent": 12,
      "text": "- Signature Subpacket: Preferred AEAD Ciphersuites (Section 5.2.3.15)",
      "ja": "- 署名サブパケット：好ましいAEAD Ciphersuites（セクション5.2.3.15）"
    },
    {
      "indent": 12,
      "text": "- Secret key encryption: AEAD \"S2K usage octet\" (Sections 3.7.2 and 5.5.3)",
      "ja": "- シークレットキー暗号化：AEAD「S2K使用量オクテット」（セクション3.7.2および5.5.3）"
    },
    {
      "indent": 6,
      "text": "* Version 6 Keys and Signatures:",
      "ja": "* バージョン6キーと署名："
    },
    {
      "indent": 12,
      "text": "- Version 6 Public Keys (Section 5.5.2.3)",
      "ja": "- バージョン6パブリックキー（セクション5.5.2.3）"
    },
    {
      "indent": 12,
      "text": "- Version 6 Fingerprint and Key ID (Section 5.5.4.3)",
      "ja": "- バージョン6指紋とキーID（セクション5.5.4.3）"
    },
    {
      "indent": 12,
      "text": "- Version 6 Secret Keys (Section 5.5.3)",
      "ja": "- バージョン6シークレットキー（セクション5.5.3）"
    },
    {
      "indent": 12,
      "text": "- Version 6 Signatures (Section 5.2.3)",
      "ja": "- バージョン6署名（セクション5.2.3）"
    },
    {
      "indent": 12,
      "text": "- Version 6 One-Pass Signatures (Section 5.4)",
      "ja": "- バージョン6ワンパス署名（セクション5.4）"
    },
    {
      "indent": 6,
      "text": "* Certificate (Transferable Public Key) Structure:",
      "ja": "* 証明書（移転可能な公開鍵）構造："
    },
    {
      "indent": 12,
      "text": "- Preferences subpackets in Direct Key signatures (Section 5.2.3.10)",
      "ja": "- 直接キーシグネチャの設定サブパケット（セクション5.2.3.10）"
    },
    {
      "indent": 12,
      "text": "- Self-verifying revocation certificate (Section 10.1.2)",
      "ja": "- 自己検証の取り消し証明書（セクション10.1.2）"
    },
    {
      "indent": 12,
      "text": "- User ID is explicitly optional (Section 10.1.1)",
      "ja": "- ユーザーIDは明示的にオプションです（セクション10.1.1）"
    },
    {
      "indent": 6,
      "text": "* S2K: Argon2 (Section 3.7.1.4)",
      "ja": "* S2K：Argon2（セクション3.7.1.4）"
    },
    {
      "indent": 6,
      "text": "* Subpacket: Intended Recipient Fingerprint (Section 5.2.3.36)",
      "ja": "* サブパケット：意図された受信者指紋（セクション5.2.3.36）"
    },
    {
      "indent": 6,
      "text": "* Digest Algorithms: SHA3-256 and SHA3-512 (Section 9.5)",
      "ja": "* ダイジェストアルゴリズム：SHA3-256およびSHA3-512（セクション9.5）"
    },
    {
      "indent": 6,
      "text": "* Packet: Padding (Section 5.14)",
      "ja": "* パケット：パディング（セクション5.14）"
    },
    {
      "indent": 6,
      "text": "* Message Structure: Packet Criticality (Section 4.3)",
      "ja": "* メッセージ構造：パケットクリティカル（セクション4.3）"
    },
    {
      "indent": 6,
      "text": "* Deprecations:",
      "ja": "* 非難："
    },
    {
      "indent": 12,
      "text": "- Public Key Algorithms:",
      "ja": "- 公開鍵アルゴリズム："
    },
    {
      "indent": 18,
      "text": "o Avoid RSA weak keys (Section 12.4)",
      "ja": "o RSA弱いキーを避ける（セクション12.4）"
    },
    {
      "indent": 18,
      "text": "o Avoid DSA (Section 12.5)",
      "ja": "o DSAを避ける（セクション12.5）"
    },
    {
      "indent": 18,
      "text": "o Avoid ElGamal (Sections 12.6 and 5.1.4)",
      "ja": "o エルガマルを避けてください（セクション12.6および5.1.4）"
    },
    {
      "indent": 18,
      "text": "o For Version 6 Keys: Avoid EdDSA25519Legacy and Curve25519Legacy (Section 9.2)",
      "ja": "o バージョン6キーの場合：EDDSA25519LEGACYとCARVE25519LEGACYを回避します（セクション9.2）"
    },
    {
      "indent": 12,
      "text": "- Digest Algorithms:",
      "ja": "- ダイジェストアルゴリズム："
    },
    {
      "indent": 18,
      "text": "o Avoid MD5, SHA1, and RIPEMD160 (Section 9.5)",
      "ja": "o MD5、SHA1、およびRIPEMD160を避けてください（セクション9.5）"
    },
    {
      "indent": 12,
      "text": "- Symmetric Key Algorithms:",
      "ja": "- 対称キーアルゴリズム："
    },
    {
      "indent": 18,
      "text": "o Avoid IDEA, TripleDES, and CAST5 (Section 9.3)",
      "ja": "o アイデア、3倍、CAST5を避けてください（セクション9.3）"
    },
    {
      "indent": 12,
      "text": "- S2K Specifier:",
      "ja": "- S2K仕様："
    },
    {
      "indent": 18,
      "text": "o Avoid Simple S2K (Section 3.7.1.1)",
      "ja": "o 簡単なS2Kを避けてください（セクション3.7.1.1）"
    },
    {
      "indent": 12,
      "text": "- Secret Key Protections (a.k.a. S2K Usage):",
      "ja": "- シークレットキー保護（別名S2K使用）："
    },
    {
      "indent": 18,
      "text": "o Avoid MalleableCFB (Section 3.7.2.1)",
      "ja": "o malleablecfbを避けます（セクション3.7.2.1）"
    },
    {
      "indent": 12,
      "text": "- Packet Types:",
      "ja": "- パケットタイプ："
    },
    {
      "indent": 18,
      "text": "o Avoid Symmetrically Encrypted Data (Sections 5.7 and 13.7)",
      "ja": "o 対称的に暗号化されたデータを避けます（セクション5.7および13.7）"
    },
    {
      "indent": 12,
      "text": "- Literal Data Packet Metadata:",
      "ja": "- リテラルデータパケットメタデータ："
    },
    {
      "indent": 18,
      "text": "o Avoid Filename and Date fields (Section 5.9)",
      "ja": "o ファイル名と日付フィールドを避けます（セクション5.9）"
    },
    {
      "indent": 18,
      "text": "o Avoid Special _CONSOLE \"filename\" (Section 5.9.1)",
      "ja": "o 特別な_console \"filename\"を避けてください（セクション5.9.1）"
    },
    {
      "indent": 12,
      "text": "- Packet Versions:",
      "ja": "- パケットバージョン："
    },
    {
      "indent": 18,
      "text": "o Avoid Version 3 Public Keys (Section 5.5.2.1)",
      "ja": "o バージョン3のパブリックキーを避けます（セクション5.5.2.1）"
    },
    {
      "indent": 18,
      "text": "o Avoid Version 3 Signatures (Section 5.2)",
      "ja": "o バージョン3の署名を避けます（セクション5.2）"
    },
    {
      "indent": 12,
      "text": "- Signature Types:",
      "ja": "- 署名タイプ："
    },
    {
      "indent": 18,
      "text": "o Avoid Reserved Signature Type ID 0xFF (Sections 5.2.1.16 and 5.2.4.1)",
      "ja": "o 予約された署名タイプID 0xff（セクション5.2.1.16および5.2.4.1）を避けます"
    },
    {
      "indent": 12,
      "text": "- Signature Subpackets:",
      "ja": "- 署名サブパケット："
    },
    {
      "indent": 18,
      "text": "o For Version 6 Signatures: Avoid Issuer Key ID (Section 5.2.3.12)",
      "ja": "o バージョン6の署名の場合：発行者キーIDを避けます（セクション5.2.3.12）"
    },
    {
      "indent": 18,
      "text": "o Avoid Revocation Key (Section 5.2.3.23)",
      "ja": "o 取り消しキーを避ける（セクション5.2.3.23）"
    },
    {
      "indent": 12,
      "text": "- ASCII Armor:",
      "ja": "- ASCIIアーマー："
    },
    {
      "indent": 18,
      "text": "o Ignore; do not emit CRC (Section 6.1)",
      "ja": "o 無視する;CRCを放出しないでください（セクション6.1）"
    },
    {
      "indent": 18,
      "text": "o Do not emit \"Version\" Armor Header (Section 6.2.2.1)",
      "ja": "o 「バージョン」アーマーヘッダーを放出しないでください（セクション6.2.2.1）"
    },
    {
      "indent": 12,
      "text": "- Cleartext Signature Framework:",
      "ja": "- ClearText署名フレームワーク："
    },
    {
      "indent": 18,
      "text": "o Ignore; avoid emitting unnecessary Hash: headers (Section 6.2.2.3)",
      "ja": "o 無視する;不要なハッシュを放出しないでください：ヘッダー（セクション6.2.2.3）"
    },
    {
      "indent": 18,
      "text": "o Reject Cleartext Signature Framework signatures with invalid Hash: headers (Section 6.2.2.3) or any other Armor Header (Section 7.1)",
      "ja": "o 無効なハッシュ：ヘッダー（セクション6.2.2.3）またはその他のアーマーヘッダー（セクション7.1）を使用したクリアテキスト署名フレームワークの署名を拒否します"
    },
    {
      "indent": 0,
      "text": "B.1. Terminology Changes",
      "section_title": true,
      "ja": "B.1. 用語の変更"
    },
    {
      "indent": 3,
      "text": "Note that some of the words used in previous versions of the OpenPGP specification have been improved in this document.",
      "ja": "OpenPGP仕様の以前のバージョンで使用された単語の一部がこのドキュメントで改善されたことに注意してください。"
    },
    {
      "indent": 3,
      "text": "In previous versions, the following terms were used:",
      "ja": "以前のバージョンでは、次の用語が使用されました。"
    },
    {
      "indent": 6,
      "text": "* \"Radix-64\" was used to refer to OpenPGP's ASCII Armor base64 encoding (Section 6).",
      "ja": "* 「RADIX-64」を使用して、OpenPGPのASCIIアーマーベース64エンコーディングを参照しました（セクション6）。"
    },
    {
      "indent": 6,
      "text": "* \"Old packet format\" was used to refer to the Legacy packet format (Section 4.2.2) predating [RFC2440].",
      "ja": "* 「古いパケット形式」を使用して、レガシーパケット形式（セクション4.2.2）を指す[RFC2440]。"
    },
    {
      "indent": 6,
      "text": "* \"New packet format\" was used to refer to the OpenPGP packet format (Section 4.2.1) introduced in [RFC2440].",
      "ja": "* 「新しいパケット形式」を使用して、[RFC2440]で導入されたOpenPGPパケット形式（セクション4.2.1）を参照しました。"
    },
    {
      "indent": 6,
      "text": "* \"Certificate\" was used ambiguously to mean multiple things. In this document, it means \"Transferable Public Key\" exclusively.",
      "ja": "* 「証明書」は、複数のことを意味するために曖昧に使用されました。このドキュメントでは、「移転可能な公開鍵」を独占的に意味します。"
    },
    {
      "indent": 6,
      "text": "* \"Preferred Symmetric Algorithms\" was the old name for the \"Preferred Symmetric Ciphers for v1 SEIPD\" subpacket (Section 5.2.3.14).",
      "ja": "* 「優先対称アルゴリズム」は、「V1 SEIPDの優先対称暗号」サブパケットの古い名前でした（セクション5.2.3.14）。"
    },
    {
      "indent": 6,
      "text": "* \"Modification Detection Code\" or \"MDC\" was originally described as a distinct packet (Packet Type ID 19), and its corresponding flag in the Features signature subpacket (Section 5.2.3.32) was known as \"Modification Detection\". It is now described as an intrinsic part of v1 SEIPD (Section 5.13.1), and the same corresponding flag is known as \"Version 1 Symmetrically Encrypted and Integrity Protected Data packet\".",
      "ja": "* 「修正検出コード」または「MDC」はもともと別個のパケット（パケットタイプID 19）として説明されており、特徴の署名サブパケット（セクション5.2.3.32）の対応するフラグは「修正検出」として知られていました。現在、V1 SEIPDの本質的な部分（セクション5.13.1）として説明されており、同じ対応するフラグは「バージョン1対称暗号化され、完全性保護データパケット」として知られています。"
    },
    {
      "indent": 6,
      "text": "* \"Packet Tag\" was used to refer to the Packet Type ID (Section 5) or sometimes to the encoded Packet Type ID (Section 4.2).",
      "ja": "* 「パケットタグ」を使用して、パケットタイプID（セクション5）またはエンコードされたパケットタイプID（セクション4.2）を参照しました。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Errata Addressed by This Document",
      "section_title": true,
      "ja": "付録C. このドキュメントでアドレス指定されたerrata"
    },
    {
      "indent": 3,
      "text": "The following verified errata have been incorporated or are otherwise resolved by this document:",
      "ja": "次の検証済みの正誤表は組み込まれているか、このドキュメントによって解決されています。"
    },
    {
      "indent": 6,
      "text": "* [Errata-2199] - S2K hash/cipher octet correction",
      "ja": "* [Errata -2199] -S2Kハッシュ/暗号オクテット補正"
    },
    {
      "indent": 6,
      "text": "* [Errata-2200] - No implicit use of IDEA correction",
      "ja": "* [errata -2200]  - アイデア補正の暗黙の使用はありません"
    },
    {
      "indent": 6,
      "text": "* [Errata-2206] - PKESK acronym expansion",
      "ja": "* [Errata -2206] -PKESK頭字語の拡張"
    },
    {
      "indent": 6,
      "text": "* [Errata-2208] - Signature key owner clarification",
      "ja": "* [errata -2208]  - 署名キー所有者の明確化"
    },
    {
      "indent": 6,
      "text": "* [Errata-2214] - Signature hashing clarification",
      "ja": "* [errata -2214]  - 署名ハッシュの明確化"
    },
    {
      "indent": 6,
      "text": "* [Errata-2216] - Self-signature applies to user ID correction",
      "ja": "* [Errata-2216]  - ユーザーID修正に自己署名が適用されます"
    },
    {
      "indent": 6,
      "text": "* [Errata-2219] - Session key encryption storage clarification",
      "ja": "* [errata -2219]  - セッションキー暗号化ストレージの明確化"
    },
    {
      "indent": 6,
      "text": "* [Errata-2222] - Simple hash MUST/MAY clarification",
      "ja": "* [errata -2222]  - 単純なハッシュマスト/可能な明確化"
    },
    {
      "indent": 6,
      "text": "* [Errata-2226] - Native line endings SHOULD clarification",
      "ja": "* [errata -2226]  - ネイティブのラインエンディングは明確にする必要があります"
    },
    {
      "indent": 6,
      "text": "* [Errata-2234] - Radix-64/base64 clarification",
      "ja": "* [errata-2234] -radix-64/base64の明確化"
    },
    {
      "indent": 6,
      "text": "* [Errata-2235] - ASCII/UTF-8 collation sequence clarification",
      "ja": "* [Errata-2235] -ASCII/UTF-8照合シーケンスの明確化"
    },
    {
      "indent": 6,
      "text": "* [Errata-2236] - Packet Composition is a sequence clarification",
      "ja": "* [errata -2236]  - パケット構成はシーケンスの明確化です"
    },
    {
      "indent": 6,
      "text": "* [Errata-2238] - Subkey packets come after all User ID packets clarification",
      "ja": "* [errata -2238]  - サブキーパケットは、すべてのユーザーIDパケットの明確化の後に来ます"
    },
    {
      "indent": 6,
      "text": "* [Errata-2240] - Subkey removal clarification",
      "ja": "* [errata -2240]  - サブキー除去の説明"
    },
    {
      "indent": 6,
      "text": "* [Errata-2242] - mL/emLen variable correction",
      "ja": "* [Errata -2242] -ML/Emlen可変補正"
    },
    {
      "indent": 6,
      "text": "* [Errata-2243] - CFB mode initialization vector (IV) clarification",
      "ja": "* [errata -2243] -CFBモード初期化ベクトル（iv）明確化"
    },
    {
      "indent": 6,
      "text": "* [Errata-2270] - SHA-224 octet sequence correction",
      "ja": "* [Errata-2270] -Sha-224オクテットシーケンス補正"
    },
    {
      "indent": 6,
      "text": "* [Errata-2271] - Radix-64 correction",
      "ja": "* [errata-2271] -radix-64補正"
    },
    {
      "indent": 6,
      "text": "* [Errata-3298] - Key Revocation signatures correction",
      "ja": "* [errata -3298]  - 重要な取り消し署名修正"
    },
    {
      "indent": 6,
      "text": "* [Errata-5491] - C code fix for CRC24_POLY define",
      "ja": "* [errata -5491] -c crc24_polyのcコード修正定義"
    },
    {
      "indent": 6,
      "text": "* [Errata-7545] - Armor Header colon hex fix",
      "ja": "* [errata -7545]  - アーマーヘッダーコロンヘックス固定"
    },
    {
      "indent": 6,
      "text": "* [Errata-7889] - Signature/certification correction",
      "ja": "* [Errata -7889]  - 署名/認証修正"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to the OpenPGP Design Team for working on this document and preparing it for working group consumption: Stephen Farrell, Daniel Kahn Gillmor, Daniel Huigens, Jeffrey Lau, Yutaka Niibe, Justus Winter, and Paul Wouters.",
      "ja": "このドキュメントに取り組み、ワーキンググループの消費の準備をしてくれたOpenPGPデザインチームに感謝します：Stephen Farrell、Daniel Kahn Gillmor、Daniel Huigens、Jeffrey Lau、Yutaka Niibe、Justus Winter、Paul Wuters。"
    },
    {
      "indent": 3,
      "text": "Thanks to Werner Koch for the early work on rfc4880bis and Andrey Jivsov for the work on [RFC6637].",
      "ja": "RFC4880BISの初期の研究と、[RFC6637]の作業についてはAndrey JivsovのWerner Kochに感謝します。"
    },
    {
      "indent": 3,
      "text": "This document also draws on much previous work from a number of other authors including Derek Atkins, Charles Breed, Dave Del Torto, Marc Dyksterhouse, Gail Haspert, Gene Hoffman, Paul Hoffman, Ben Laurie, Raph Levien, Colin Plumb, Will Price, Daphne Shaw, William Stallings, Mark Weaver, and Philip R. Zimmermann.",
      "ja": "この文書は、デレク・アトキンス、チャールズ・ブリード、デイブ・デル・トルト、マーク・ダイクスターハウス、ゲイル・ハスパート、ジーン・ホフマン、ポール・ホフマン、ベン・ローリー、ラフ・レヴィエン、コリン・プランブ、ウィル・価格、ダフネを含む多くの他の著者からの以前の多くの作品についても引き出していますショー、ウィリアム・スタリングス、マーク・ウィーバー、フィリップ・R・ジマーマン。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Paul Wouters (editor)\nAiven\nEmail: paul.wouters@aiven.io",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Daniel Huigens\nProton AG\nEmail: d.huigens@protonmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Justus Winter\nSequoia PGP\nEmail: justus@sequoia-pgp.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Yutaka Niibe\nFSIJ\nEmail: gniibe@fsij.org",
      "raw": true,
      "ja": ""
    }
  ]
}