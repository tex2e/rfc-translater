{
  "title": {
    "text": "RFC 9591 - The Flexible Round-Optimized Schnorr Threshold (FROST) Protocol for Two‑Round Schnorr Signatures",
    "ja": "RFC 9591 - 2 ラウンド Schnorr 署名用の柔軟な Round-Optimized Schnorr Threshold (FROST) プロトコル"
  },
  "number": 9591,
  "created_at": "2025-10-13 19:48:25.836526+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          D. Connolly\nRequest for Comments: 9591                              Zcash Foundation\nCategory: Informational                                         C. Komlo\nISSN: 2070-1721                 University of Waterloo, Zcash Foundation\n                                                             I. Goldberg\n                                                  University of Waterloo\n                                                              C. A. Wood\n                                                              Cloudflare\n                                                               June 2024",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "The Flexible Round-Optimized Schnorr Threshold (FROST) Protocol for Two-Round Schnorr Signatures",
      "section_title": true,
      "ja": "2 ラウンド Schnorr 署名用の柔軟な Round-Optimized Schnorr Threshold (FROST) プロトコル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies the Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. FROST signatures can be issued after a threshold number of entities cooperate to compute a signature, allowing for improved distribution of trust and redundancy with respect to a secret key. FROST depends only on a prime-order group and cryptographic hash function. This document specifies a number of ciphersuites to instantiate FROST using different prime-order groups and hash functions. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.",
      "ja": "この文書では、Flexible Round-Optimized Schnorr Threshold (FROST) 署名プロトコルを指定します。FROST 署名は、しきい値数のエンティティが協力して署名を計算した後に発行できるため、秘密キーに関する信頼性と冗長性の分散が改善されます。FROST は、素数順序群と暗号化ハッシュ関数のみに依存します。この文書では、さまざまな素数グループとハッシュ関数を使用して FROST をインスタンス化するためのいくつかの暗号スイートを指定します。この文書は、IRTF の暗号フォーラム研究グループ (CFRG) の成果物です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書は Internet Standards Track 仕様ではありません。情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は Internet Research Task Force (IRTF) の成果物です。IRTF は、インターネット関連の研究開発活動の結果を公開しています。これらの結果は、展開には適していない可能性があります。この RFC は、インターネット研究タスクフォース (IRTF) の暗号フォーラム研究グループの合意を表しています。IRSG によって公開が承認された文書は、どのレベルのインターネット標準の候補でもありません。RFC 7841 のセクション 2 を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9591.",
      "ja": "この文書の現在のステータス、正誤表、およびそれに対するフィードバックの提供方法に関する情報は、https://www.rfc-editor.org/info/rfc9591 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2024 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright (c) 2024 IETF Trust および文書の著者として特定された人物。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、BCP 78 およびこの文書の発行日に有効な IETF 文書に関する IETF トラストの法的規定 (https://trustee.ietf.org/license-info) の対象となります。これらの文書には、この文書に関するお客様の権利と制限が記載されているため、注意深くお読みください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Conventions and Definitions\n3.  Cryptographic Dependencies\n  3.1.  Prime-Order Group\n  3.2.  Cryptographic Hash Function\n4.  Helper Functions\n  4.1.  Nonce Generation\n  4.2.  Polynomials\n  4.3.  List Operations\n  4.4.  Binding Factors Computation\n  4.5.  Group Commitment Computation\n  4.6.  Signature Challenge Computation\n5.  Two-Round FROST Signing Protocol\n  5.1.  Round One - Commitment\n  5.2.  Round Two - Signature Share Generation\n  5.3.  Signature Share Aggregation\n  5.4.  Identifiable Abort\n6.  Ciphersuites\n  6.1.  FROST(Ed25519, SHA-512)\n  6.2.  FROST(ristretto255, SHA-512)\n  6.3.  FROST(Ed448, SHAKE256)\n  6.4.  FROST(P-256, SHA-256)\n  6.5.  FROST(secp256k1, SHA-256)\n  6.6.  Ciphersuite Requirements\n7.  Security Considerations\n  7.1.  Side-Channel Mitigations\n  7.2.  Optimizations\n  7.3.  Nonce Reuse Attacks\n  7.4.  Protocol Failures\n  7.5.  Removing the Coordinator Role\n  7.6.  Input Message Hashing\n  7.7.  Input Message Validation\n8.  IANA Considerations\n9.  References\n  9.1.  Normative References\n  9.2.  Informative References\nAppendix A.  Schnorr Signature Encoding\nAppendix B.  Schnorr Signature Generation and Verification for\n        Prime-Order Groups\nAppendix C.  Trusted Dealer Key Generation\n  C.1.  Shamir Secret Sharing\n    C.1.1.  Additional Polynomial Operations\n  C.2.  Verifiable Secret Sharing\nAppendix D.  Random Scalar Generation\n  D.1.  Rejection Sampling\n  D.2.  Wide Reduction\nAppendix E.  Test Vectors\n  E.1.  FROST(Ed25519, SHA-512)\n  E.2.  FROST(Ed448, SHAKE256)\n  E.3.  FROST(ristretto255, SHA-512)\n  E.4.  FROST(P-256, SHA-256)\n  E.5.  FROST(secp256k1, SHA-256)\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Unlike signatures in a single-party setting, threshold signatures require cooperation among a threshold number of signing participants, each holding a share of a common private key. The security of threshold schemes in general assumes that an adversary can corrupt strictly fewer than a threshold number of signer participants.",
      "ja": "単一当事者設定での署名とは異なり、しきい値署名では、共通の秘密鍵の共有を保持するしきい値数の署名参加者間の協力が必要です。しきい値スキームのセキュリティは、一般に、敵対者が不正にアクセスできる署名者参加者の数がしきい値よりも厳密に少ないことを前提としています。"
    },
    {
      "indent": 3,
      "text": "This document specifies the Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol based on the original work in [FROST20]. FROST reduces network overhead during threshold signing operations while employing a novel technique to protect against forgery attacks applicable to prior Schnorr-based threshold signature constructions. FROST requires two rounds to compute a signature. Single-round signing variants based on [FROST20] are out of scope.",
      "ja": "この文書は、[FROST20] のオリジナルの作業に基づいた Flexible Round-Optimized Schnorr Threshold (FROST) 署名プロトコルを指定します。FROST は、以前の Schnorr ベースのしきい値署名構造に適用できる偽造攻撃から保護する新しい技術を採用しながら、しきい値署名操作中のネットワーク オーバーヘッドを削減します。FROST では、署名の計算に 2 ラウンドが必要です。[FROST20] に基づくシングルラウンド署名のバリアントは範囲外です。"
    },
    {
      "indent": 3,
      "text": "FROST depends only on a prime-order group and cryptographic hash function. This document specifies a number of ciphersuites to instantiate FROST using different prime-order groups and hash functions. Two ciphersuites can be used to produce signatures that are compatible with Edwards-Curve Digital Signature Algorithm (EdDSA) variants Ed25519 and Ed448 as specified in [RFC8032], i.e., the signatures can be verified with a verifier that is compliant with [RFC8032]. However, unlike EdDSA, the signatures produced by FROST are not deterministic, since deriving nonces deterministically allows for a complete key-recovery attack in multi-party, discrete logarithm-based signatures.",
      "ja": "FROST は、素数順序群と暗号化ハッシュ関数のみに依存します。この文書では、さまざまな素数順序グループとハッシュ関数を使用して FROST をインスタンス化するためのいくつかの暗号スイートを指定します。2 つの暗号スイートを使用して、[RFC8032] で指定されている Edwards-Curve Digital Signature Algorithm (EdDSA) バリアント Ed25519 および Ed448 と互換性のある署名を生成できます。つまり、署名は [RFC8032] に準拠した検証器で検証できます。ただし、EdDSA とは異なり、FROST によって生成される署名は決定論的ではありません。ノンスを決定論的に導出することにより、マルチパーティの離散対数ベースの署名での完全なキー回復攻撃が可能になるためです。"
    },
    {
      "indent": 3,
      "text": "Key generation for FROST signing is out of scope for this document. However, for completeness, key generation with a trusted dealer is specified in Appendix C.",
      "ja": "FROST 署名のための鍵の生成は、このドキュメントの範囲外です。ただし、完全を期すため、信頼できるディーラーによる鍵の生成については付録 C に記載されています。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Crypto Forum Research Group (CFRG). It is not an IETF product and is not a standard.",
      "ja": "この文書は、Crypto Forum Research Group (CFRG) の総意を表しています。これは IETF 製品ではなく、標準でもありません。"
    },
    {
      "indent": 0,
      "text": "2. Conventions and Definitions",
      "section_title": true,
      "ja": "2. 規則と定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "このドキュメント内のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、ここに示すようにすべて大文字で表示されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The following notation is used throughout the document.",
      "ja": "この文書全体で次の表記が使用されます。"
    },
    {
      "indent": 3,
      "text": "byte:",
      "ja": "バイト："
    },
    {
      "indent": 12,
      "text": "A sequence of eight bits.",
      "ja": "8 ビットのシーケンス。"
    },
    {
      "indent": 3,
      "text": "random_bytes(n):",
      "ja": "ランダムバイト(n):"
    },
    {
      "indent": 12,
      "text": "Outputs n bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG).",
      "ja": "暗号的に安全な擬似乱数生成器 (CSPRNG) を使用して、均一にランダムにサンプリングされた n バイトを出力します。"
    },
    {
      "indent": 3,
      "text": "count(i, L):",
      "ja": "カウント(i, L):"
    },
    {
      "indent": 12,
      "text": "Outputs the number of times the element i is represented in the list L.",
      "ja": "要素 i がリスト L 内で表現される回数を出力します。"
    },
    {
      "indent": 3,
      "text": "len(l):",
      "ja": "レン(l):"
    },
    {
      "indent": 12,
      "text": "Outputs the length of list l, e.g., len([1,2,3]) = 3.",
      "ja": "リスト l の長さを出力します (例: len([1,2,3]) = 3)。"
    },
    {
      "indent": 3,
      "text": "reverse(l):",
      "ja": "逆(l):"
    },
    {
      "indent": 12,
      "text": "Outputs the list l in reverse order, e.g., reverse([1,2,3]) = [3,2,1].",
      "ja": "リスト l を逆順で出力します (例: reverse([1,2,3]) = [3,2,1])。"
    },
    {
      "indent": 3,
      "text": "range(a, b):",
      "ja": "範囲(a, b):"
    },
    {
      "indent": 12,
      "text": "Outputs a list of integers from a to b-1 in ascending order, e.g., range(1, 4) = [1,2,3].",
      "ja": "a から b-1 までの整数のリストを昇順で出力します (例: range(1, 4) = [1,2,3])。"
    },
    {
      "indent": 3,
      "text": "pow(a, b):",
      "ja": "pow(a, b):"
    },
    {
      "indent": 12,
      "text": "Outputs the result, a Scalar, of a to the power of b, e.g., pow(2, 3) = 8 modulo the relevant group order p.",
      "ja": "a の b 乗の結果、スカラーを出力します。たとえば、関連するグループ次数 p を法とする pow(2, 3) = 8 です。"
    },
    {
      "indent": 3,
      "text": "||:",
      "ja": "||:"
    },
    {
      "indent": 12,
      "text": "Denotes concatenation of byte strings, i.e., x || y denotes the byte string x, immediately followed by the byte string y, with no extra separator, yielding xy.",
      "ja": "バイト文字列の連結を示します。つまり、x ||y はバイト文字列 x を表し、その直後に余分な区切り文字なしでバイト文字列 y が続き、xy が生成されます。"
    },
    {
      "indent": 3,
      "text": "nil:",
      "ja": "nil:"
    },
    {
      "indent": 12,
      "text": "Denotes an empty byte string.",
      "ja": "空のバイト列を表します。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise stated, we assume that secrets are sampled uniformly at random using a CSPRNG; see [RFC4086] for additional guidance on the generation of random numbers.",
      "ja": "特に明記されていない限り、シークレットは CSPRNG を使用して均一にランダムにサンプリングされると想定します。乱数の生成に関する追加のガイダンスについては、[RFC4086] を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Cryptographic Dependencies",
      "section_title": true,
      "ja": "3. 暗号化の依存関係"
    },
    {
      "indent": 3,
      "text": "FROST signing depends on the following cryptographic constructs:",
      "ja": "FROST 署名は、次の暗号構造に依存します。"
    },
    {
      "indent": 6,
      "text": "* Prime-order group (Section 3.1)",
      "ja": "* 素数グループ (セクション 3.1)"
    },
    {
      "indent": 6,
      "text": "* Cryptographic hash function (Section 3.2)",
      "ja": "* 暗号化ハッシュ関数 (セクション 3.2)"
    },
    {
      "indent": 3,
      "text": "The following sections describe these constructs in more detail.",
      "ja": "次のセクションでは、これらの構造について詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Prime-Order Group",
      "section_title": true,
      "ja": "3.1. プライムオーダーグループ"
    },
    {
      "indent": 3,
      "text": "FROST depends on an abelian group of prime order p. We represent this group as the object G that additionally defines helper functions described below. The group operation for G is addition + with identity element I. For any elements A and B of the group G, A + B = B + A is also a member of G. Also, for any A in G, there exists an element -A such that A + (-A) = (-A) + A = I. For convenience, we use - to denote subtraction, e.g., A - B = A + (-B). Integers, taken modulo the group order p, are called \"Scalars\"; arithmetic operations on Scalars are implicitly performed modulo p. Since p is prime, Scalars form a finite field. Scalar multiplication is equivalent to the repeated application of the group operation on an element A with itself r-1 times, denoted as ScalarMult(A, r). We denote the sum, difference, and product of two Scalars using the +, -, and * operators, respectively. (Note that this means + may refer to group element addition or Scalar addition, depending on the type of the operands.) For any element A, ScalarMult(A, p) = I. We denote B as a fixed generator of the group. Scalar base multiplication is equivalent to the repeated application of the group operation on B with itself r-1 times, denoted as ScalarBaseMult(r). The set of Scalars corresponds to GF(p), which we refer to as the Scalar field. It is assumed that group element addition, negation, and equality comparison can be efficiently computed for arbitrary group elements.",
      "ja": "FROST は素数次数 p のアーベル群に依存します。このグループを、以下で説明するヘルパー関数を追加定義するオブジェクト G として表します。G の群演算は、恒等要素 I を伴う加算 + です。群 G の要素 A および B については、A + B = B + A も G のメンバーです。また、G 内の任意の A については、A + (-A) = (-A) + A = I となる要素 -A が存在します。便宜上、減算を示すために - を使用します (例: A - B = A + (-B))。群次数 p を法として取得される整数は、「スカラー」と呼ばれます。スカラーの算術演算は、p を法として暗黙的に実行されます。p は素数であるため、スカラーは有限体を形成します。スカラー乗算は、ScalarMult(A, r) として示される、要素 A に対するグループ演算をそれ自体を r-1 回繰り返し適用することと等価です。2 つのスカラーの和、差、積をそれぞれ +、-、および * 演算子を使用して表します。(これは、オペランドのタイプに応じて、+ がグループ要素の加算またはスカラー加算を参照する可能性があることを意味します。) 任意の要素 A について、ScalarMult(A, p) = I。B をグループの固定ジェネレータとして示します。スカラー基底乗算は、ScalarBaseMult(r) として示される、B に対するグループ演算をそれ自体で r-1 回繰り返し適用することと等価です。スカラーのセットは GF(p) に対応し、これをスカラー フィールドと呼びます。グループ要素の加算、否定、等価比較は、任意のグループ要素に対して効率的に計算できると仮定します。"
    },
    {
      "indent": 3,
      "text": "This document uses types Element and Scalar to denote elements of the group G and its set of Scalars, respectively. We denote Scalar(x) as the conversion of integer input x to the corresponding Scalar value with the same numeric value. For example, Scalar(1) yields a Scalar representing the value 1. Moreover, we use the type NonZeroScalar to denote a Scalar value that is not equal to zero, i.e., Scalar(0). We denote equality comparison of these types as == and assignment of values by =. When comparing Scalar values, e.g., for the purposes of sorting lists of Scalar values, the least nonnegative representation mod p is used.",
      "ja": "このドキュメントでは、Element 型と Scalar 型を使用して、グループ G の要素とそのスカラーのセットをそれぞれ示します。Scalar(x) は、整数入力 x を、同じ数値を持つ対応するスカラー値に変換することとして表します。たとえば、Scalar(1) は値 1 を表す Scalar を生成します。さらに、NonZeroScalar 型を使用して、ゼロに等しくない Scalar 値、つまり Scalar(0) を示します。これらのタイプの等価比較を == で表し、値の割り当てを = で表します。スカラー値を比較する場合、たとえばスカラー値のリストをソートする目的で、最小の非負表現 mod p が使用されます。"
    },
    {
      "indent": 3,
      "text": "We now detail a number of member functions that can be invoked on G.",
      "ja": "ここで、G で呼び出すことができる多数のメンバー関数について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 12,
      "text": "Outputs the order of G (i.e., p).",
      "ja": "G (つまり p) の次数を出力します。"
    },
    {
      "indent": 3,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 12,
      "text": "Outputs the identity Element of the group (i.e., I).",
      "ja": "グループのアイデンティティ要素 (つまり、I) を出力します。"
    },
    {
      "indent": 3,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 12,
      "text": "Outputs a random Scalar element in GF(p), i.e., a random Scalar in [0, p - 1].",
      "ja": "GF(p) のランダムなスカラー要素、つまり [0, p - 1] のランダムなスカラー要素を出力します。"
    },
    {
      "indent": 3,
      "text": "ScalarMult(A, k):",
      "ja": "ScalarMult(A, k):"
    },
    {
      "indent": 12,
      "text": "Outputs the Scalar multiplication between Element A and Scalar k.",
      "ja": "要素 A とスカラー k の間のスカラー乗算を出力します。"
    },
    {
      "indent": 3,
      "text": "ScalarBaseMult(k):",
      "ja": "ScalarBaseMult(k):"
    },
    {
      "indent": 12,
      "text": "Outputs the Scalar multiplication between Scalar k and the group generator B.",
      "ja": "スカラー k とグループ ジェネレーター B の間のスカラー乗算を出力します。"
    },
    {
      "indent": 3,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 12,
      "text": "Maps an Element A to a canonical byte array buf of fixed length Ne. This function raises an error if A is the identity element of the group.",
      "ja": "要素 A を固定長 Ne の正規バイト配列 buf にマップします。A がグループの単位要素である場合、この関数はエラーを生成します。"
    },
    {
      "indent": 3,
      "text": "DeserializeElement(buf):",
      "ja": "要素の逆シリアル化 (バグ):"
    },
    {
      "indent": 12,
      "text": "Attempts to map a byte array buf to an Element A and fails if the input is not the valid canonical byte representation of an element of the group. This function raises an error if deserialization fails or if A is the identity element of the group; see Section 6 for group-specific input validation steps.",
      "ja": "バイト配列 buf を要素 A にマップしようとしますが、入力がグループの要素の有効な正規バイト表現でない場合は失敗します。逆シリアル化が失敗した場合、または A がグループの ID 要素である場合、この関数はエラーを生成します。グループ固有の入力検証手順については、セクション 6 を参照してください。"
    },
    {
      "indent": 3,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar:"
    },
    {
      "indent": 12,
      "text": "Maps a Scalar s to a canonical byte array buf of fixed length Ns.",
      "ja": "Scalar s を固定長 Ns の標準バイト配列 buf にマップします。"
    },
    {
      "indent": 3,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 12,
      "text": "Attempts to map a byte array buf to a Scalar s. This function raises an error if deserialization fails; see Section 6 for group-specific input validation steps.",
      "ja": "バイト配列 buf を Scalar にマップしようとします。逆シリアル化が失敗した場合、この関数はエラーを生成します。グループ固有の入力検証手順については、セクション 6 を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2. Cryptographic Hash Function",
      "section_title": true,
      "ja": "3.2. 暗号化ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "FROST requires the use of a cryptographically secure hash function, generically written as H, which is modeled as a random oracle in security proofs for the protocol (see [FROST20] and [StrongerSec22]). For concrete recommendations on hash functions that SHOULD be used in practice, see Section 6. Using H, we introduce distinct domain-separated hashes H1, H2, H3, H4, and H5:",
      "ja": "FROST は、暗号的に安全なハッシュ関数 (一般に H と書かれます) の使用を必要とします。これは、プロトコルのセキュリティ証明におけるランダム オラクルとしてモデル化されています ([FROST20] および [StrongerSec22] を参照)。実際に使用すべきハッシュ関数に関する具体的な推奨事項については、セクション 6 を参照してください。 H を使用して、ドメインで区切られた個別のハッシュ H1、H2、H3、H4、および H5 を導入します。"
    },
    {
      "indent": 6,
      "text": "* H1, H2, and H3 map arbitrary byte strings to Scalar elements associated with the prime-order group.",
      "ja": "* H1、H2、および H3 は、任意のバイト文字列を素数順序グループに関連付けられたスカラー要素にマップします。"
    },
    {
      "indent": 6,
      "text": "* H4 and H5 are aliases for H with distinct domain separators.",
      "ja": "* H4 と H5 は、異なるドメイン区切り文字を持つ H のエイリアスです。"
    },
    {
      "indent": 3,
      "text": "The details of H1, H2, H3, H4, and H5 vary based on the ciphersuite used. See Section 6 for more details about each.",
      "ja": "H1、H2、H3、H4、および H5 の詳細は、使用される暗号スイートによって異なります。それぞれの詳細については、セクション 6 を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. Helper Functions",
      "section_title": true,
      "ja": "4. ヘルパー関数"
    },
    {
      "indent": 3,
      "text": "Beyond the core dependencies, the protocol in this document depends on the following helper operations:",
      "ja": "コアの依存関係を超えて、このドキュメントのプロトコルは次のヘルパー操作に依存します。"
    },
    {
      "indent": 6,
      "text": "* Nonce generation (Section 4.1);",
      "ja": "* ノンスの生成 (セクション 4.1)。"
    },
    {
      "indent": 6,
      "text": "* Polynomials (Section 4.2);",
      "ja": "* 多項式 (セクション 4.2);"
    },
    {
      "indent": 6,
      "text": "* List operations (Section 4.3);",
      "ja": "* リスト操作 (セクション 4.3)。"
    },
    {
      "indent": 6,
      "text": "* Binding factors computation (Section 4.4);",
      "ja": "* 結合因子の計算 (セクション 4.4)。"
    },
    {
      "indent": 6,
      "text": "* Group commitment computation (Section 4.5); and",
      "ja": "* グループコミットメントの計算 (セクション 4.5)。そして"
    },
    {
      "indent": 6,
      "text": "* Signature challenge computation (Section 4.6).",
      "ja": "* 署名チャレンジの計算 (セクション 4.6)。"
    },
    {
      "indent": 3,
      "text": "The following sections describe these operations in more detail.",
      "ja": "次のセクションでは、これらの操作について詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Nonce Generation",
      "section_title": true,
      "ja": "4.1. ノンス生成"
    },
    {
      "indent": 3,
      "text": "To hedge against a bad random number generator (RNG) that outputs predictable values, nonces are generated with the nonce_generate function by combining fresh randomness with the secret key as input to a domain-separated hash function built from the ciphersuite hash function H. This domain-separated hash function is denoted as H3. This function always samples 32 bytes of fresh randomness to ensure that the probability of nonce reuse is at most 2^-128 as long as no more than 2^64 signatures are computed by a given signing participant.",
      "ja": "予測可能な値を出力する不正な乱数生成器 (RNG) を回避するために、nonce_generate 関数を使用して、暗号スイート ハッシュ関数 H から構築されたドメイン分離ハッシュ関数への入力として新鮮なランダム性と秘密キーを組み合わせてノンスが生成されます。このドメイン分離ハッシュ関数は H3 として示されます。この関数は常に 32 バイトの新しいランダム性をサンプリングして、特定の署名参加者によって 2^64 以下の署名が計算される限り、ノンス再利用の確率が最大 2^-128 であることを保証します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- secret, a Scalar.\n\nOutputs:\n- nonce, a Scalar.\n\ndef nonce_generate(secret):\n  random_bytes = random_bytes(32)\n  secret_enc = G.SerializeScalar(secret)\n  return H3(random_bytes || secret_enc)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. Polynomials",
      "section_title": true,
      "ja": "4.2. 多項式"
    },
    {
      "indent": 3,
      "text": "This section defines polynomials over Scalars that are used in the main protocol. A polynomial of maximum degree t is represented as a list of t+1 coefficients, where the constant term of the polynomial is in the first position and the highest-degree coefficient is in the last position. For example, the polynomial x^2 + 2x + 3 has degree 2 and is represented as a list of three coefficients [3, 2, 1]. A point on the polynomial f is a tuple (x, y), where y = f(x).",
      "ja": "このセクションでは、メイン プロトコルで使用されるスカラー上の多項式を定義します。最大次数 t の多項式は、t+1 個の係数のリストとして表されます。多項式の定数項が最初の位置にあり、最高次数の係数が最後の位置にあります。たとえば、多項式 x^2 + 2x + 3 は次数 2 を持ち、3 つの係数 [3, 2, 1] のリストとして表されます。多項式 f 上の点はタプル (x, y) であり、y = f(x) となります。"
    },
    {
      "indent": 3,
      "text": "The function derive_interpolating_value derives a value that is used for polynomial interpolation. It is provided a list of x-coordinates as input, each of which cannot equal 0.",
      "ja": "関数derive_interpolating_valueは、多項式補間に使用される値を導出します。入力として x 座標のリストが提供されますが、それぞれを 0 に等しくすることはできません。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- L, the list of x-coordinates, each a NonZeroScalar.\n- x_i, an x-coordinate contained in L, a NonZeroScalar.\n\nOutputs:\n- value, a Scalar.\n\nErrors:\n- \"invalid parameters\", if 1) x_i is not in L, or if 2) any\n  x-coordinate is represented more than once in L.\n\ndef derive_interpolating_value(L, x_i):\n  if x_i not in L:\n    raise \"invalid parameters\"\n  for x_j in L:\n    if count(x_j, L) > 1:\n      raise \"invalid parameters\"\n\n  numerator = Scalar(1)\n  denominator = Scalar(1)\n  for x_j in L:\n    if x_j == x_i: continue\n    numerator *= x_j\n    denominator *= x_j - x_i\n\n  value = numerator / denominator\n  return value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3. List Operations",
      "section_title": true,
      "ja": "4.3. リスト操作"
    },
    {
      "indent": 3,
      "text": "This section describes helper functions that work on lists of values produced during the FROST protocol. The following function encodes a list of participant commitments into a byte string for use in the FROST protocol.",
      "ja": "このセクションでは、FROST プロトコル中に生成される値のリストに対して動作するヘルパー関数について説明します。次の関数は、FROST プロトコルで使用できるように、参加者のコミットメントのリストをバイト文字列にエンコードします。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n\nOutputs:\n- encoded_group_commitment, the serialized representation of\n  commitment_list, a byte string.\n\ndef encode_group_commitment_list(commitment_list):\n  encoded_group_commitment = nil\n  for (identifier, hiding_nonce_commitment,\n       binding_nonce_commitment) in commitment_list:\n    encoded_commitment = (\n        G.SerializeScalar(identifier) ||\n        G.SerializeElement(hiding_nonce_commitment) ||\n        G.SerializeElement(binding_nonce_commitment))\n    encoded_group_commitment = (\n        encoded_group_commitment ||\n        encoded_commitment)\n  return encoded_group_commitment",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following function is used to extract identifiers from a commitment list.",
      "ja": "次の関数は、コミットメント リストから識別子を抽出するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n\nOutputs:\n- identifiers, a list of NonZeroScalar values.\n\ndef participants_from_commitment_list(commitment_list):\n  identifiers = []\n  for (identifier, _, _) in commitment_list:\n    identifiers.append(identifier)\n  return identifiers",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following function is used to extract a binding factor from a list of binding factors.",
      "ja": "次の関数は、結合因子のリストから結合因子を抽出するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- binding_factor_list = [(i, binding_factor), ...],\n  a list of binding factors for each participant, where each element\n  in the list indicates a NonZeroScalar identifier i and Scalar\n  binding factor.\n- identifier, participant identifier, a NonZeroScalar.\n\nOutputs:\n- binding_factor, a Scalar.\n\nErrors:\n- \"invalid participant\", when the designated participant is\n  not known.\n\ndef binding_factor_for_participant(binding_factor_list, identifier):\n  for (i, binding_factor) in binding_factor_list:\n    if identifier == i:\n      return binding_factor\n  raise \"invalid participant\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4. Binding Factors Computation",
      "section_title": true,
      "ja": "4.4. 結合因子の計算"
    },
    {
      "indent": 3,
      "text": "This section describes the subroutine for computing binding factors based on the participant commitment list, message to be signed, and group public key.",
      "ja": "このセクションでは、参加者コミットメント リスト、署名されるメッセージ、およびグループ公開鍵に基づいて結合係数を計算するサブルーチンについて説明します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- group_public_key, the public key corresponding to the group signing\n  key, an Element.\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n- msg, the message to be signed.\n\nOutputs:\n- binding_factor_list, a list of (NonZeroScalar, Scalar) tuples\n  representing the binding factors.\n\ndef compute_binding_factors(group_public_key, commitment_list, msg):\n  group_public_key_enc = G.SerializeElement(group_public_key)\n  // Hashed to a fixed length.\n  msg_hash = H4(msg)\n  // Hashed to a fixed length.\n  encoded_commitment_hash =\n      H5(encode_group_commitment_list(commitment_list))\n  // The encoding of the group public key is a fixed length\n  // within a ciphersuite.\n  rho_input_prefix = group_public_key_enc || msg_hash ||\n   encoded_commitment_hash\n\n  binding_factor_list = []\n  for (identifier, hiding_nonce_commitment,\n       binding_nonce_commitment) in commitment_list:\n    rho_input = rho_input_prefix || G.SerializeScalar(identifier)\n    binding_factor = H1(rho_input)\n    binding_factor_list.append((identifier, binding_factor))\n  return binding_factor_list",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.5. Group Commitment Computation",
      "section_title": true,
      "ja": "4.5. グループコミットメントの計算"
    },
    {
      "indent": 3,
      "text": "This section describes the subroutine for creating the group commitment from a commitment list.",
      "ja": "このセクションでは、コミットメント リストからグループ コミットメントを作成するサブルーチンについて説明します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n- binding_factor_list = [(i, binding_factor), ...],\n  a list of (NonZeroScalar, Scalar) tuples representing the binding\n  factor Scalar for the given identifier.\n\nOutputs:\n- group_commitment, an Element.\n\ndef compute_group_commitment(commitment_list, binding_factor_list):\n  group_commitment = G.Identity()\n  for (identifier, hiding_nonce_commitment,\n       binding_nonce_commitment) in commitment_list:\n    binding_factor = binding_factor_for_participant(\n        binding_factor_list, identifier)\n    binding_nonce = G.ScalarMult(\n        binding_nonce_commitment,\n        binding_factor)\n    group_commitment = (\n        group_commitment +\n        hiding_nonce_commitment +\n        binding_nonce)\n  return group_commitment",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the performance of this algorithm is defined naively and scales linearly relative to the number of signers. For improved performance, the group commitment can be computed using multi-exponentiation techniques such as Pippinger's algorithm; see [MultExp] for more details.",
      "ja": "このアルゴリズムのパフォーマンスは素朴に定義されており、署名者の数に対して線形にスケールすることに注意してください。パフォーマンスを向上させるために、Pippinger のアルゴリズムなどの多重累乗手法を使用してグループ コミットメントを計算できます。詳細については、[MultExp] を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.6. Signature Challenge Computation",
      "section_title": true,
      "ja": "4.6. 署名チャレンジの計算"
    },
    {
      "indent": 3,
      "text": "This section describes the subroutine for creating the per-message challenge.",
      "ja": "このセクションでは、メッセージごとのチャレンジを作成するためのサブルーチンについて説明します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- group_commitment, the group commitment, an Element.\n- group_public_key, the public key corresponding to the group signing\n  key, an Element.\n- msg, the message to be signed, a byte string.\n\nOutputs:\n- challenge, a Scalar.\n\ndef compute_challenge(group_commitment, group_public_key, msg):\n  group_comm_enc = G.SerializeElement(group_commitment)\n  group_public_key_enc = G.SerializeElement(group_public_key)\n  challenge_input = group_comm_enc || group_public_key_enc || msg\n  challenge = H2(challenge_input)\n  return challenge",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Two-Round FROST Signing Protocol",
      "section_title": true,
      "ja": "5. 2 ラウンドの FROST 署名プロトコル"
    },
    {
      "indent": 3,
      "text": "This section describes the two-round FROST signing protocol for producing Schnorr signatures. The protocol is configured to run with a selection of NUM_PARTICIPANTS signer participants and a Coordinator. NUM_PARTICIPANTS is a positive and non-zero integer that MUST be at least MIN_PARTICIPANTS, but MUST NOT be larger than MAX_PARTICIPANTS, where MIN_PARTICIPANTS <= MAX_PARTICIPANTS and MIN_PARTICIPANTS is a positive and non-zero integer. Additionally, MAX_PARTICIPANTS MUST be a positive integer less than the group order. A signer participant, or simply \"participant\", is an entity that is trusted to hold and use a signing key share. The Coordinator is an entity with the following responsibilities:",
      "ja": "このセクションでは、Schnorr 署名を生成するための 2 ラウンドの FROST 署名プロトコルについて説明します。このプロトコルは、選択した NUM_PARTICIPANTS の署名者参加者とコーディネーターで実行されるように構成されています。NUM_PARTICIPANTS はゼロ以外の正の整数であり、少なくとも MIN_PARTICIPANTS である必要がありますが、MAX_PARTICIPANTS より大きくてはなりません。MIN_PARTICIPANTS <= MAX_PARTICIPANTS であり、MIN_PARTICIPANTS は正のゼロ以外の整数です。さらに、MAX_PARTICIPANTS はグループの順序より小さい正の整数でなければなりません。署名者参加者、または単に「参加者」は、署名鍵共有を保持および使用することが信頼されているエンティティです。コーディネーターは次の責任を持つ組織です。"
    },
    {
      "indent": 8,
      "text": "1. Determining the participants that will participate (at least MIN_PARTICIPANTS in number);",
      "ja": "1. 参加する参加者を決定します (少なくとも MIN_PARTICIPANTS 人の数)。"
    },
    {
      "indent": 8,
      "text": "2. Coordinating rounds (receiving and forwarding inputs among participants);",
      "ja": "2. ラウンドの調整（参加者間でのインプットの受信と転送）。"
    },
    {
      "indent": 8,
      "text": "3. Aggregating signature shares output by each participant; and",
      "ja": "3. 各参加者が出力した署名シェアを集約する。そして"
    },
    {
      "indent": 8,
      "text": "4. Publishing the resulting signature.",
      "ja": "4. 結果の署名を公開します。"
    },
    {
      "indent": 3,
      "text": "FROST assumes that the Coordinator and the set of signer participants are chosen externally to the protocol. Note that it is possible to deploy the protocol without designating a single Coordinator; see Section 7.5 for more information.",
      "ja": "FROST は、コーディネーターと署名者参加者のセットがプロトコルの外部で選択されることを前提としています。単一のコーディネーターを指定せずにプロトコルを展開できることに注意してください。詳細については、セクション 7.5 を参照してください。"
    },
    {
      "indent": 3,
      "text": "FROST produces signatures that can be verified as if they were produced from a single signer using a signing key s with corresponding public key PK, where s is a Scalar value and PK = G.ScalarBaseMult(s). As a threshold signing protocol, the group signing key s is Shamir secret-shared amongst each of the MAX_PARTICIPANTS participants and is used to produce signatures; see Appendix C.1 for more information about Shamir secret sharing. In particular, FROST assumes each participant is configured with the following information:",
      "ja": "FROST は、署名鍵 s と対応する公開鍵 PK を使用して、単一の署名者から生成されたかのように検証できる署名を生成します。ここで、s はスカラー値、PK = G.ScalarBaseMult(s) です。しきい値署名プロトコルとして、グループ署名鍵 s は MAX_PARTICIPANTS の各参加者間でシャミール秘密共有され、署名の生成に使用されます。Shamir 秘密共有の詳細については、付録 C.1 を参照してください。特に、FROST は、各参加者が次の情報を使用して構成されていることを前提としています。"
    },
    {
      "indent": 6,
      "text": "* An identifier, which is a NonZeroScalar value denoted as i in the range [1, MAX_PARTICIPANTS] and MUST be distinct from the identifier of every other participant.",
      "ja": "* 識別子は、範囲 [1, MAX_PARTICIPANTS] 内の i として示される NonZeroScalar 値であり、他のすべての参加者の識別子とは区別されなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "* A signing key sk_i, which is a Scalar value representing the i-th Shamir secret share of the group signing key s. In particular, sk_i is the value f(i) on a secret polynomial f of degree (MIN_PARTICIPANTS - 1), where s is f(0). The public key corresponding to this signing key share is PK_i = G.ScalarBaseMult(sk_i).",
      "ja": "* 署名鍵 sk_i。グループ署名鍵 s の i 番目のシャミア秘密共有を表すスカラー値です。特に、sk_i は、次数 (MIN_PARTICIPANTS - 1) の秘密多項式 f の値 f(i) であり、s は f(0) です。この署名鍵共有に対応する公開鍵は、PK_i = G.ScalarBaseMult(sk_i) です。"
    },
    {
      "indent": 3,
      "text": "Additionally, the Coordinator and each participant are configured with common group information, denoted as \"group info,\" which consists of the following:",
      "ja": "さらに、コーディネーターと各参加者は、「グループ情報」と呼ばれる共通のグループ情報を使用して構成されます。これは次の内容で構成されます。"
    },
    {
      "indent": 6,
      "text": "* Group public key, which is an Element in G denoted as PK.",
      "ja": "* グループ公開キー。PK として示される G の要素です。"
    },
    {
      "indent": 6,
      "text": "* Public keys PK_i for each participant, which are Element values in G denoted as PK_i for each i in [1, MAX_PARTICIPANTS].",
      "ja": "* 各参加者の公開鍵 PK_i。これは、[1, MAX_PARTICIPANTS] の各 i の PK_i として示される G の要素値です。"
    },
    {
      "indent": 3,
      "text": "This document does not specify how this information, including the signing key shares, are configured and distributed to participants. In general, two configuration mechanisms are possible: one that requires a single trusted dealer and one that requires performing a distributed key generation protocol. We highlight the key generation mechanism by a trusted dealer in Appendix C for reference.",
      "ja": "この文書では、署名鍵共有を含むこの情報がどのように構成され、参加者に配布されるかについては規定されていません。一般に、2 つの構成メカニズムが可能です。1 つは単一の信頼できるディーラーを必要とするもの、もう 1 つは分散キー生成プロトコルの実行を必要とするものです。付録 C では、参考として信頼できるディーラーによる鍵生成メカニズムを強調表示しています。"
    },
    {
      "indent": 3,
      "text": "FROST requires two rounds to complete. In the first round, participants generate and publish one-time-use commitments to be used in the second round. In the second round, each participant produces a share of the signature over the Coordinator-chosen message and the other participant commitments. After the second round is completed, the Coordinator aggregates the signature shares to produce a final signature. The Coordinator SHOULD abort the protocol if the signature is invalid; see Section 5.4 for more information about dealing with invalid signatures and misbehaving participants. This complete interaction (without being aborted) is shown in Figure 1.",
      "ja": "FROST を完了するには 2 ラウンドが必要です。最初のラウンドでは、参加者は第 2 ラウンドで使用する 1 回限りの利用コミットメントを生成して公開します。第 2 ラウンドでは、各参加者は、コーディネーターが選択したメッセージと他の参加者のコミットメントに対する署名のシェアを作成します。第 2 ラウンドが完了すると、コーディネーターは署名シェアを集約して最終署名を生成します。署名が無効な場合、コーディネーターはプロトコルを中止すべきです(SHOULD)。無効な署名や不正行為を行う参加者への対処の詳細については、セクション 5.4 を参照してください。この完全な対話 (中断なし) を図 1 に示します。"
    },
    {
      "indent": 3,
      "text": "        (group info)            (group info,     (group info,\n            |               signing key share)   signing key share)\n            |                         |                |\n            v                         v                v\n        Coordinator               Signer-1   ...   Signer-n\n    ------------------------------------------------------------\n   signing request\n------------>\n            |\n      == Round 1 (Commitment) ==\n            | participant commitment |                 |\n            |<-----------------------+                 |\n            |          ...                             |\n            | participant commitment            (commit state) ==\\\n            |<-----------------------------------------+         |\n                                                                 |\n      == Round 2 (Signature Share Generation) ==                 |\n   message\n------------>\n            |                                                    |\n            |   participant input    |                 |         |\n            +------------------------>                 |         |\n            |     signature share    |                 |         |\n            |<-----------------------+                 |         |\n            |          ...                             |         |\n            |    participant input                     |         |\n            +------------------------------------------>         /\n            |     signature share                      |<=======/\n            <------------------------------------------+\n            |\n      == Aggregation ==\n            |\n  signature |\n<-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 1: FROST Protocol Overview",
      "ja": "図 1: FROST プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "Details for round one are described in Section 5.1 and details for round two are described in Section 5.2. Note that each participant persists some state between the two rounds; this state is deleted as described in Section 5.2. The final Aggregation step is described in Section 5.3.",
      "ja": "ラウンド 1 の詳細はセクション 5.1 で説明され、ラウンド 2 の詳細はセクション 5.2 で説明されます。各参加者は 2 つのラウンドの間で何らかの状態を保持することに注意してください。この状態はセクション 5.2 で説明されているように削除されます。最後の集計ステップについては、セクション 5.3 で説明します。"
    },
    {
      "indent": 3,
      "text": "FROST assumes that all inputs to each round, especially those that are received over the network, are validated before use. In particular, this means that any value of type Element or Scalar received over the network MUST be deserialized using DeserializeElement and DeserializeScalar, respectively, as these functions perform the necessary input validation steps. Additionally, all messages sent over the wire MUST be encoded using their respective functions, e.g., Scalars and Elements are encoded using SerializeScalar and SerializeElement.",
      "ja": "FROST は、各ラウンドへのすべての入力、特にネットワーク経由で受信した入力が使用前に検証されることを前提としています。特に、これは、ネットワーク経由で受信したタイプ Element または Scalar の値は、それぞれ DeserializeElement および DeserializeScalar を使用して逆シリアル化する必要があることを意味します。これらの関数は、必要な入力検証手順を実行するためです。さらに、ネットワーク経由で送信されるすべてのメッセージは、それぞれの関数を使用してエンコードされなければなりません (MUST)。たとえば、スカラーと要素は SerializeScalar と SerializeElement を使用してエンコードされます。"
    },
    {
      "indent": 3,
      "text": "FROST assumes reliable message delivery between the Coordinator and participants in order for the protocol to complete. An attacker masquerading as another participant will result only in an invalid signature; see Section 7. However, in order to identify misbehaving participants, we assume that the network channel is additionally authenticated; confidentiality is not required.",
      "ja": "FROST は、プロトコルを完了するために、コーディネーターと参加者の間で信頼性の高いメッセージ配信が行われることを前提としています。攻撃者が別の参加者になりすましても、無効な署名が生成されるだけです。セクション 7 を参照してください。ただし、不正行為を行っている参加者を特定するために、ネットワーク チャネルが追加で認証されていると仮定します。秘密保持は必要ありません。"
    },
    {
      "indent": 0,
      "text": "5.1. Round One - Commitment",
      "section_title": true,
      "ja": "5.1. ラウンド 1 - コミットメント"
    },
    {
      "indent": 3,
      "text": "Round one involves each participant generating nonces and their corresponding public commitments. A nonce is a pair of Scalar values, and a commitment is a pair of Element values. Each participant's behavior in this round is described by the commit function below. Note that this function invokes nonce_generate twice, once for each type of nonce produced. The output of this function is a pair of secret nonces (hiding_nonce, binding_nonce) and their corresponding public commitments (hiding_nonce_commitment, binding_nonce_commitment).",
      "ja": "ラウンド 1 では、各参加者がナンスとそれに対応するパブリック コミットメントを生成します。ノンスはスカラー値のペアであり、コミットメントは要素値のペアです。このラウンドにおける各参加者の行動は、以下の commit 関数によって記述されます。この関数は、生成される nonce のタイプごとに 1 回ずつ、nonce_generate を 2 回呼び出します。この関数の出力は、秘密のノンス (hiding_nonce、binding_nonce) のペアと、それらに対応するパブリック コミットメント (hiding_nonce_commitment、binding_nonce_commitment) です。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- sk_i, the secret key share, a Scalar.\n\nOutputs:\n- (nonce, comm), a tuple of nonce and nonce commitment pairs,\n  where each value in the nonce pair is a Scalar and each value in\n  the nonce commitment pair is an Element.\n\ndef commit(sk_i):\n  hiding_nonce = nonce_generate(sk_i)\n  binding_nonce = nonce_generate(sk_i)\n  hiding_nonce_commitment = G.ScalarBaseMult(hiding_nonce)\n  binding_nonce_commitment = G.ScalarBaseMult(binding_nonce)\n  nonces = (hiding_nonce, binding_nonce)\n  comms = (hiding_nonce_commitment, binding_nonce_commitment)\n  return (nonces, comms)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The outputs nonce and comm from participant P_i are both stored locally and kept for use in the second round. The nonce value is secret and MUST NOT be shared, whereas the public output comm is sent to the Coordinator. The nonce values produced by this function MUST NOT be used in more than one invocation of sign, and the nonces MUST be generated from a source of secure randomness.",
      "ja": "参加者 P_i からの出力 nonce と comm は両方ともローカルに保存され、第 2 ラウンドで使用するために保持されます。nonce 値は秘密であり、共有してはなりませんが、パブリック出力通信はコーディネーターに送信されます。この関数によって生成された nonce 値は、sign の複数の呼び出しで使用されてはならず、安全なランダム性のソースから nonce が生成されなければなりません (MUST)。"
    },
    {
      "indent": 0,
      "text": "5.2. Round Two - Signature Share Generation",
      "section_title": true,
      "ja": "5.2. ラウンド 2 - 署名シェアの生成"
    },
    {
      "indent": 3,
      "text": "In round two, the Coordinator is responsible for sending the message to be signed and choosing the participants that will participate (a number of at least MIN_PARTICIPANTS). Signers additionally require locally held data, specifically their private key and the nonces corresponding to their commitment issued in round one.",
      "ja": "ラウンド 2 では、コーディネーターは、署名されるメッセージを送信し、参加する参加者 (少なくとも MIN_PARTICIPANTS の数) を選択する責任があります。署名者はさらに、ローカルに保持されているデータ、特に秘密鍵とラウンド 1 で発行されたコミットメントに対応するノンスを必要とします。"
    },
    {
      "indent": 3,
      "text": "The Coordinator begins by sending each participant the message to be signed along with the set of signing commitments for all participants in the participant list. Each participant MUST validate the inputs before processing the Coordinator's request. In particular, the signer MUST validate commitment_list, deserializing each group Element in the list using DeserializeElement from Section 3.1. If deserialization fails, the signer MUST abort the protocol. Moreover, each participant MUST ensure that its identifier and commitments (from the first round) appear in commitment_list. Applications that restrict participants from processing arbitrary input messages are also required to perform relevant application-layer input validation checks; see Section 7.7 for more details.",
      "ja": "コーディネーターは、参加者リスト内のすべての参加者に対する一連の署名コミットメントとともに、署名されるメッセージを各参加者に送信することから始めます。各参加者は、コーディネーターのリクエストを処理する前に入力を検証しなければなりません。特に、署名者は、セクション 3.1 の DeserializeElement を使用して、リスト内の各グループ要素を逆シリアル化し、commitment_list を検証しなければなりません (MUST)。逆シリアル化が失敗した場合、署名者はプロトコルを中止しなければなりません (MUST)。さらに、各参加者は、その識別子と（最初のラウンドからの）コミットメントが commit_list に表示されていることを確認しなければなりません（MUST）。参加者による任意の入力メッセージの処理を制限するアプリケーションは、関連するアプリケーション層の入力検証チェックを実行することも必要です。詳細については、セクション 7.7 を参照してください。"
    },
    {
      "indent": 3,
      "text": "Upon receipt and successful input validation, each signer then runs the following procedure to produce its own signature share.",
      "ja": "受信して入力検証が成功すると、各署名者は次の手順を実行して独自の署名共有を作成します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- identifier, identifier i of the participant, a NonZeroScalar.\n- sk_i, signer secret key share, a Scalar.\n- group_public_key, public key corresponding to the group signing\n  key, an Element.\n- nonce_i, pair of Scalar values (hiding_nonce, binding_nonce)\n  generated in round one.\n- msg, the message to be signed, a byte string.\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n\n\nOutputs:\n- sig_share, a signature share, a Scalar.\n\ndef sign(identifier, sk_i, group_public_key,\n         nonce_i, msg, commitment_list):\n  # Compute the binding factor(s)\n  binding_factor_list = compute_binding_factors(group_public_key,\n   commitment_list, msg)\n  binding_factor = binding_factor_for_participant(\n      binding_factor_list, identifier)\n\n  # Compute the group commitment\n  group_commitment = compute_group_commitment(\n      commitment_list, binding_factor_list)\n\n  # Compute the interpolating value\n  participant_list = participants_from_commitment_list(\n      commitment_list)\n  lambda_i = derive_interpolating_value(participant_list, identifier)\n\n  # Compute the per-message challenge\n  challenge = compute_challenge(\n      group_commitment, group_public_key, msg)\n\n  # Compute the signature share\n  (hiding_nonce, binding_nonce) = nonce_i\n  sig_share = hiding_nonce + (binding_nonce * binding_factor) +\n      (lambda_i * sk_i * challenge)\n\n  return sig_share",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The output of this procedure is a signature share. Each participant sends these shares back to the Coordinator. Each participant MUST delete the nonce and corresponding commitment after completing sign and MUST NOT use the nonce as input more than once to sign.",
      "ja": "この手順の出力は署名共有です。各参加者はこれらの共有をコーディネーターに送り返します。各参加者は、署名を完了した後、ノンスと対応するコミットメントを削除しなければならず (MUST)、署名のための入力としてノンスを複数回使用してはなりません (MUST NOT)。"
    },
    {
      "indent": 3,
      "text": "Note that the lambda_i value derived during this procedure does not change across FROST signing operations for the same signing group. As such, participants can compute it once and store it for reuse across signing sessions.",
      "ja": "この手順中に導出された lambda_i 値は、同じ署名グループに対する FROST 署名操作全体で変更されないことに注意してください。そのため、参加者はそれを一度計算して保存し、署名セッション全体で再利用できます。"
    },
    {
      "indent": 0,
      "text": "5.3. Signature Share Aggregation",
      "section_title": true,
      "ja": "5.3. 署名共有の集約"
    },
    {
      "indent": 3,
      "text": "After participants perform round two and send their signature shares to the Coordinator, the Coordinator aggregates each share to produce a final signature. Before aggregating, the Coordinator MUST validate each signature share using DeserializeScalar. If validation fails, the Coordinator MUST abort the protocol, as the resulting signature will be invalid. If all signature shares are valid, the Coordinator aggregates them to produce the final signature using the following procedure.",
      "ja": "参加者がラウンド 2 を実行し、署名シェアをコーディネーターに送信した後、コーディネーターは各シェアを集約して最終署名を作成します。集約する前に、コーディネーターは DeserializeScalar を使用して各署名共有を検証しなければなりません (MUST)。検証が失敗した場合、結果として得られる署名は無効になるため、コーディネーターはプロトコルを中止しなければなりません(MUST)。すべての署名共有が有効な場合、コーディネーターは次の手順を使用してそれらを集約し、最終的な署名を生成します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n- msg, the message to be signed, a byte string.\n- group_public_key, public key corresponding to the group signing\n  key, an Element.\n- sig_shares, a set of signature shares z_i, Scalar values, for each\n  participant, of length NUM_PARTICIPANTS, where\n  MIN_PARTICIPANTS <= NUM_PARTICIPANTS <= MAX_PARTICIPANTS.\n\nOutputs:\n- (R, z), a Schnorr signature consisting of an Element R and\n  Scalar z.\n\ndef aggregate(commitment_list, msg, group_public_key, sig_shares):\n  # Compute the binding factors\n  binding_factor_list = compute_binding_factors(group_public_key,\n   commitment_list, msg)\n\n  # Compute the group commitment\n  group_commitment = compute_group_commitment(\n      commitment_list, binding_factor_list)\n\n  # Compute aggregated signature\n  z = Scalar(0)\n  for z_i in sig_shares:\n    z = z + z_i\n  return (group_commitment, z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The output from the aggregation step is the output signature (R, z). The canonical encoding of this signature is specified in Section 6.",
      "ja": "集約ステップからの出力は、出力署名 (R, z) です。この署名の正規のエンコーディングはセクション 6 で指定されています。"
    },
    {
      "indent": 3,
      "text": "The Coordinator SHOULD verify this signature using the group public key before publishing or releasing the signature. Signature verification is as specified for the corresponding ciphersuite; see Section 6 for details. The aggregate signature will verify successfully if all signature shares are valid. Moreover, subsets of valid signature shares will not yield a valid aggregate signature themselves.",
      "ja": "コーディネーターは、署名を公開または解放する前に、グループ公開鍵を使用してこの署名を検証する必要があります (SHOULD)。署名検証は、対応する暗号スイートに指定されているとおりです。詳細についてはセクション 6 を参照してください。すべての署名共有が有効であれば、集約署名は正常に検証されます。さらに、有効な署名共有のサブセット自体は、有効な集約署名を生成しません。"
    },
    {
      "indent": 3,
      "text": "If the aggregate signature verification fails, the Coordinator MAY verify each signature share individually to identify and act on misbehaving participants. The mechanism for acting on a misbehaving participant is out of scope for this specification; see Section 5.4 for more information about dealing with invalid signatures and misbehaving participants.",
      "ja": "集約された署名検証が失敗した場合、コーディネーターは、不正行為を行っている参加者を特定し、対処するために各署名共有を個別に検証してもよい(MAY)。不正行為を行う参加者に対処するメカニズムは、この仕様の範囲外です。無効な署名や不正行為を行う参加者への対処の詳細については、セクション 5.4 を参照してください。"
    },
    {
      "indent": 3,
      "text": "The function for verifying a signature share, denoted as verify_signature_share, is described below. Recall that the Coordinator is configured with \"group info\" that contains the group public key PK and public keys PK_i for each participant. The group_public_key and PK_i function arguments MUST come from that previously stored group info.",
      "ja": "verify_signature_share として示される署名共有を検証する関数については、以下で説明します。コーディネーターは、グループ公開鍵 PK と各参加者の公開鍵 PK_i を含む「グループ情報」を使用して構成されていることを思い出してください。group_public_key および PK_i 関数の引数は、以前に保存されたグループ情報から取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- identifier, identifier i of the participant, a NonZeroScalar.\n- PK_i, the public key for the i-th participant, where\n  PK_i = G.ScalarBaseMult(sk_i), an Element.\n- comm_i, pair of Element values in G\n  (hiding_nonce_commitment, binding_nonce_commitment) generated in\n  round one from the i-th participant.\n- sig_share_i, a Scalar value indicating the signature share as\n  produced in round two from the i-th participant.\n- commitment_list = [(i, hiding_nonce_commitment_i,\n  binding_nonce_commitment_i), ...], a list of commitments issued by\n  each participant, where each element in the list indicates a\n  NonZeroScalar identifier i and two commitment Element values\n  (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list\n  MUST be sorted in ascending order by identifier.\n- group_public_key, public key corresponding to the group signing\n  key, an Element.\n- msg, the message to be signed, a byte string.\n\nOutputs:\n- True if the signature share is valid, and False otherwise.\n\ndef verify_signature_share(\n        identifier, PK_i, comm_i, sig_share_i, commitment_list,\n        group_public_key, msg):\n  # Compute the binding factors\n  binding_factor_list = compute_binding_factors(group_public_key,\n   commitment_list, msg)\n  binding_factor = binding_factor_for_participant(\n      binding_factor_list, identifier)\n\n  # Compute the group commitment\n  group_commitment = compute_group_commitment(\n      commitment_list, binding_factor_list)\n\n  # Compute the commitment share\n  (hiding_nonce_commitment, binding_nonce_commitment) = comm_i\n  comm_share = hiding_nonce_commitment + G.ScalarMult(\n      binding_nonce_commitment, binding_factor)\n\n  # Compute the challenge\n  challenge = compute_challenge(\n      group_commitment, group_public_key, msg)\n\n  # Compute the interpolating value\n  participant_list = participants_from_commitment_list(\n      commitment_list)\n  lambda_i = derive_interpolating_value(participant_list, identifier)\n\n  # Compute relation values\n  l = G.ScalarBaseMult(sig_share_i)\n  r = comm_share + G.ScalarMult(PK_i, challenge * lambda_i)\n\n  return l == r",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Coordinator can verify each signature share before aggregating and verifying the signature under the group public key. However, since the aggregate signature is valid if all signature shares are valid, this order of operations is more expensive if the signature is valid.",
      "ja": "コーディネーターは、グループ公開鍵の下で署名を集約して検証する前に、各署名共有を検証できます。ただし、すべての署名共有が有効であれば集約署名も有効であるため、署名が有効であればこの順序の操作のコストが高くなります。"
    },
    {
      "indent": 0,
      "text": "5.4. Identifiable Abort",
      "section_title": true,
      "ja": "5.4. 識別可能なアボート"
    },
    {
      "indent": 3,
      "text": "FROST does not provide robustness; i.e, all participants are required to complete the protocol honestly in order to generate a valid signature. When the signing protocol does not produce a valid signature, the Coordinator SHOULD abort; see Section 7 for more information about FROST's security properties and the threat model.",
      "ja": "FROST は堅牢性を提供しません。つまり、有効な署名を生成するには、すべての参加者が正直にプロトコルを完了する必要があります。署名プロトコルが有効な署名を生成しない場合、コーディネーターは中止すべきである(SHOULD)。FROST のセキュリティ特性と脅威モデルの詳細については、セクション 7 を参照してください。"
    },
    {
      "indent": 3,
      "text": "As a result of this property, a misbehaving participant can cause a denial of service (DoS) on the signing protocol by contributing malformed signature shares or refusing to participate. Identifying misbehaving participants that produce invalid shares can be done by checking signature shares from each participant using verify_signature_share as described in Section 5.3. FROST assumes the network channel is authenticated to identify the signer that misbehaved. FROST allows for identifying misbehaving participants that produce invalid signature shares as described in Section 5.3. FROST does not provide accommodations for identifying participants that refuse to participate, though applications are assumed to detect when participants fail to engage in the signing protocol.",
      "ja": "この特性の結果、不正行為を行う参加者は、不正な形式の署名共有を提供したり、参加を拒否したりすることで、署名プロトコル上でサービス拒否 (DoS) を引き起こす可能性があります。無効な共有を生成する不正な参加者を特定するには、セクション 5.3 で説明されている verify_signature_share を使用して各参加者からの署名共有を確認します。FROST は、不正行為を行った署名者を識別するためにネットワーク チャネルが認証されていると想定します。FROST を使用すると、セクション 5.3 で説明されているように、無効な署名共有を生成する不正な参加者を特定できます。FROST は、参加を拒否する参加者を特定するための機能を提供しませんが、参加者が署名プロトコルに参加しなかった場合はアプリケーションが検出すると想定されています。"
    },
    {
      "indent": 3,
      "text": "In both cases, preventing this type of attack requires the Coordinator to identify misbehaving participants such that applications can take corrective action. The mechanism for acting on misbehaving participants is out of scope for this specification. However, one reasonable approach would be to remove the misbehaving participant from the set of allowed participants in future runs of FROST.",
      "ja": "どちらの場合も、このタイプの攻撃を防ぐには、コーディネーターが不正行為を行っている参加者を特定し、アプリケーションが修正措置を講じることができるようにする必要があります。不正行為を行う参加者に対処するメカニズムは、この仕様の範囲外です。ただし、合理的なアプローチの 1 つは、今後の FROST の実行で、不正行為を行った参加者を許可された参加者のセットから削除することです。"
    },
    {
      "indent": 0,
      "text": "6. Ciphersuites",
      "section_title": true,
      "ja": "6. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "A FROST ciphersuite must specify the underlying prime-order group details and cryptographic hash function. Each ciphersuite is denoted as (Group, Hash), e.g., (ristretto255, SHA-512). This section contains some ciphersuites. Each ciphersuite also includes a context string, denoted as contextString, which is an ASCII string literal (with no terminating NUL character).",
      "ja": "FROST 暗号スイートでは、基礎となる素数順序グループの詳細と暗号化ハッシュ関数を指定する必要があります。各暗号スイートは、(グループ、ハッシュ) (例: (ristretto255、SHA-512)) として示されます。このセクションにはいくつかの暗号スイートが含まれています。各暗号スイートには、contextString として示されるコンテキスト文字列も含まれています。これは、ASCII 文字列リテラル (終端 NUL 文字なし) です。"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED ciphersuite is (ristretto255, SHA-512) as described in Section 6.2. The (Ed25519, SHA-512) and (Ed448, SHAKE256) ciphersuites are included for compatibility with Ed25519 and Ed448 as defined in [RFC8032].",
      "ja": "セクション 6.2 で説明されているように、推奨される暗号スイートは (ristretto255、SHA-512) です。(Ed25519、SHA-512) および (Ed448、SHAKE256) 暗号スイートは、[RFC8032] で定義されている Ed25519 および Ed448 との互換性のために含まれています。"
    },
    {
      "indent": 3,
      "text": "The DeserializeElement and DeserializeScalar functions instantiated for a particular prime-order group corresponding to a ciphersuite MUST adhere to the description in Section 3.1. Validation steps for these functions are described for each of the ciphersuites below. Future ciphersuites MUST describe how input validation is done for DeserializeElement and DeserializeScalar.",
      "ja": "暗号スイートに対応する特定の素数順序グループに対してインスタンス化された DeserializeElement 関数と DeserializeScalar 関数は、セクション 3.1 の説明に従わなければなりません (MUST)。これらの関数の検証手順は、以下の暗号スイートごとに説明されています。将来の暗号スイートでは、DeserializeElement と DeserializeScalar の入力検証がどのように行われるかを記述しなければなりません (MUST)。"
    },
    {
      "indent": 3,
      "text": "Each ciphersuite includes explicit instructions for verifying signatures produced by FROST. Note that these instructions are equivalent to those produced by a single participant.",
      "ja": "各暗号スイートには、FROST によって生成された署名を検証するための明示的な命令が含まれています。これらの指示は 1 人の参加者によって作成された指示と同等であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Each ciphersuite adheres to the requirements in Section 6.6. Future ciphersuites MUST also adhere to these requirements.",
      "ja": "各暗号スイートはセクション 6.6 の要件に準拠しています。将来の暗号スイートもこれらの要件に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.1. FROST(Ed25519, SHA-512)",
      "section_title": true,
      "ja": "6.1. フロスト(Ed25519、SHA-512)"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses edwards25519 for the Group and SHA-512 for the hash function H meant to produce Ed25519-compliant signatures as specified in Section 5.1 of [RFC8032]. The value of the contextString parameter is \"FROST-ED25519-SHA512-v1\".",
      "ja": "この暗号スイートは、グループに edwards25519 を使用し、[RFC8032] のセクション 5.1 で指定されているように Ed25519 準拠の署名を生成することを目的としたハッシュ関数 H に SHA-512 を使用します。contextString パラメータの値は「FROST-ED25519-SHA512-v1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "edwards25519 [RFC8032], where Ne = 32 and Ns = 32.",
      "ja": "edwards25519 [RFC 8032]、Ne = 32 番目、Ns = 32。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 2^252 + 27742317777372353535851937790883648493 (see [RFC7748]).",
      "ja": "2^252 + 27742317777372353535851937790883648493 を返します ([RFC7748] を参照)。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RFC7748].",
      "ja": "[RFC7748]で定義されているとおり。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented as specified in [RFC8032], Section 5.1.2. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[RFC8032]、セクション 5.1.2 の規定に従って実装されます。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "要素の逆シリアル化 (バグ):"
    },
    {
      "indent": 15,
      "text": "Implemented as specified in [RFC8032], Section 5.1.3. Additionally, this function validates that the resulting element is not the group identity element and is in the prime-order subgroup. If any of these checks fail, deserialization returns an error. The latter check can be implemented by multiplying the resulting point by the order of the group and checking that the result is the identity element. Note that optimizations for this check exist; see [Pornin22].",
      "ja": "[RFC8032]、セクション 5.1.3 の規定に従って実装されます。さらに、この関数は、結果の要素がグループ単位要素ではなく、素数順序サブグループ内にあることを検証します。これらのチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。後者のチェックは、結果の点にグループの次数を乗算し、その結果が単位要素であることをチェックすることによって実装できます。このチェックには最適化が存在することに注意してください。[Pornin22] を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar:"
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian 32-byte encoding of the Scalar value with the top three bits set to zero.",
      "ja": "上位 3 ビットを 0 に設定して、スカラー値のリトル エンディアン 32 バイト エンコードを出力することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.",
      "ja": "リトルエンディアンの 32 バイト文字列からスカラーを逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。これは、入力の上位 3 ビットがゼロでなければならないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ(H):"
    },
    {
      "indent": 12,
      "text": "SHA-512, which has an output of 64 bytes.",
      "ja": "SHA-512。64 バイトの出力があります。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"rho\" || m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.",
      "ja": "H(contextString || \"rho\" || m) を計算し、64 バイトのダイジェストをリトル エンディアン整数として解釈し、結果の整数を 2^252 + 27742317777372353535851937790883648493 で除算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.",
      "ja": "H(m) を計算し、64 バイトのダイジェストをリトル エンディアン整数として解釈し、結果の整数を 2^252 + 27742317777372353535851937790883648493 で除算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"nonce\" || m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.",
      "ja": "H(contextString || \"nonce\" || m) を計算し、64 バイトのダイジェストをリトル エンディアン整数として解釈し、結果の整数を 2^252 + 27742317777372353535851937790883648493 で除算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "高さ4(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "H(contextString || \"msg\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "高さ5(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "H(contextString || \"com\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Normally, H2 would also include a domain separator; however, for compatibility with [RFC8032], it is omitted.",
      "ja": "通常、H2 にはドメイン区切り文字も含まれます。ただし、[RFC8032]との互換性を考慮して省略されています。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Section 5.1.7 of [RFC8032] with the constraint that implementations MUST check the group equation [8][z]B = [8]R + [8][c]PK (changed to use the notation in this document).",
      "ja": "署名検証は、[RFC8032] のセクション 5.1.7 に規定されているとおりですが、実装は群方程式 [8][z]B = [8]R + [8][c]PK (この文書での表記を使用するように変更されました) をチェックしなければならないという制約があります。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "正規の署名エンコーディングは付録 A で指定されているとおりです。"
    },
    {
      "indent": 0,
      "text": "6.2. FROST(ristretto255, SHA-512)",
      "section_title": true,
      "ja": "6.2. FROST(リストレット255、SHA-512)"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses ristretto255 for the Group and SHA-512 for the hash function H. The value of the contextString parameter is \"FROST-RISTRETTO255-SHA512-v1\".",
      "ja": "この暗号スイートは、グループに ristretto255 を使用し、ハッシュ関数 H に SHA-512 を使用します。 contextString パラメーターの値は「FROST-RISTRETTO255-SHA512-v1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "ristretto255 [RISTRETTO], where Ne = 32 and Ns = 32.",
      "ja": "ristretto255 [リストレット]、Ne = 32、Ns = 32。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 2^252 + 27742317777372353535851937790883648493 (see [RISTRETTO]).",
      "ja": "2^252 + 27742317777372353535851937790883648493 を返します ([RISTRETTO] を参照)。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RISTRETTO].",
      "ja": "[RISTRETTO]で定義されているとおり。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented using the \"Encode\" function from [RISTRETTO]. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[RISTRETTO]の「Encode」機能を利用して実装しました。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "要素の逆シリアル化 (バグ):"
    },
    {
      "indent": 15,
      "text": "Implemented using the \"Decode\" function from [RISTRETTO]. Additionally, this function validates that the resulting element is not the group identity element. If either the \"Decode\" function or the check fails, deserialization returns an error.",
      "ja": "[RISTRETTO]の「デコード」機能を利用して実装しました。さらに、この関数は、結果の要素がグループ ID 要素ではないことを検証します。「デコード」機能またはチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar:"
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian 32-byte encoding of the Scalar value with the top three bits set to zero.",
      "ja": "上位 3 ビットを 0 に設定して、スカラー値のリトル エンディアン 32 バイト エンコードを出力することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.",
      "ja": "リトルエンディアンの 32 バイト文字列からスカラーを逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。これは、入力の上位 3 ビットがゼロでなければならないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ(H):"
    },
    {
      "indent": 12,
      "text": "SHA-512, which has 64 bytes of output.",
      "ja": "SHA-512。64 バイトの出力があります。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"rho\" || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.",
      "ja": "[RISTRETTO] セクション 4.4 で説明されているように、H(contextString || \"rho\" || m) を計算し、出力をスカラーにマッピングすることによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"chal\" || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.",
      "ja": "[RISTRETTO] セクション 4.4 で説明されているように、H(contextString || \"chal\" || m) を計算し、出力をスカラーにマッピングすることによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"nonce\" || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.",
      "ja": "[RISTRETTO] セクション 4.4 で説明されているように、H(contextString || \"nonce\" || m) を計算し、出力をスカラーにマッピングすることによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "高さ4(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "H(contextString || \"msg\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "高さ5(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "H(contextString || \"com\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Appendix B.",
      "ja": "署名検証は付録 B に規定されているとおりです。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "正規の署名エンコーディングは付録 A で指定されているとおりです。"
    },
    {
      "indent": 0,
      "text": "6.3. FROST(Ed448, SHAKE256)",
      "section_title": true,
      "ja": "6.3. フロスト(Ed448、SHAKE256)"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses edwards448 for the Group and SHAKE256 for the hash function H meant to produce Ed448-compliant signatures as specified in Section 5.2 of [RFC8032]. Unlike Ed448 in [RFC8032], this ciphersuite does not allow applications to specify a context string and always sets the context of [RFC8032] to the empty string. Note that this ciphersuite does not allow applications to specify a context string as is allowed for Ed448 in [RFC8032], and always sets the [RFC8032] context string to the empty string. The value of the (internal to FROST) contextString parameter is \"FROST-ED448-SHAKE256-v1\".",
      "ja": "この暗号スイートは、[RFC8032] のセクション 5.2 で指定されているように、Ed448 準拠の署名を生成することを目的として、グループに edwards448 を使用し、ハッシュ関数 H に SHAKE256 を使用します。[RFC8032] の Ed448 とは異なり、この暗号スイートではアプリケーションがコンテキスト文字列を指定することはできず、[RFC8032] のコンテキストは常に空の文字列に設定されます。この暗号スイートでは、[RFC8032] の Ed448 で許可されているようにアプリケーションがコンテキスト文字列を指定することはできず、[RFC8032] コンテキスト文字列は常に空の文字列に設定されることに注意してください。(FROST への内部) contextString パラメーターの値は、「FROST-ED448-SHAKE256-v1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "edwards448 [RFC8032], where Ne = 57 and Ns = 57.",
      "ja": "edwards448 [RFC8032]、Ne = 57、Ns = 57。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 2^446 - 13818066809895115352007386748515426880336 692474882178609894547503885.",
      "ja": "2^446 - 13818066809895115352007386748515426880336 692474882178609894547503885 を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [RFC7748].",
      "ja": "[RFC7748]で定義されているとおり。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented as specified in [RFC8032], Section 5.2.2. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[RFC8032]、セクション 5.2.2 の規定に従って実装されます。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "要素の逆シリアル化 (バグ):"
    },
    {
      "indent": 15,
      "text": "Implemented as specified in [RFC8032], Section 5.2.3. Additionally, this function validates that the resulting element is not the group identity element and is in the prime-order subgroup. If any of these checks fail, deserialization returns an error. The latter check can be implemented by multiplying the resulting point by the order of the group and checking that the result is the identity element. Note that optimizations for this check exist; see [Pornin22].",
      "ja": "[RFC8032]、セクション 5.2.3 の規定に従って実装されます。さらに、この関数は、結果の要素がグループ単位要素ではなく、素数順序サブグループ内にあることを検証します。これらのチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。後者のチェックは、結果の点にグループの次数を乗算し、その結果が単位要素であることをチェックすることによって実装できます。このチェックには最適化が存在することに注意してください。[Pornin22] を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar:"
    },
    {
      "indent": 15,
      "text": "Implemented by outputting the little-endian 57-byte encoding of the Scalar value.",
      "ja": "スカラー値のリトルエンディアン 57 バイト エンコードを出力することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a little-endian 57-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "リトルエンディアンの 57 バイト文字列からスカラーを逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ(H):"
    },
    {
      "indent": 12,
      "text": "SHAKE256 with 114 bytes of output.",
      "ja": "114 バイトの出力を持つ SHAKE256。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"rho\" || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.",
      "ja": "H(contextString || \"rho\" || m) を計算し、114 バイトのダイジェストをリトルエンディアン整数として解釈し、結果の整数を 2^446 - 1381806680989 を法として減算することによって実装されます。\n\n5115352007386748515426880336692474882178609894547503885。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(\"SigEd448\" || 0 || 0 || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.",
      "ja": "H(\"SigEd448\" || 0 || 0 || m) を計算し、114 バイトのダイジェストをリトルエンディアン整数として解釈し、結果の整数を 2^446 - 1381806680989 を法として減算することによって実装されます。\n\n5115352007386748515426880336692474882178609894547503885。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"nonce\" || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.",
      "ja": "H(contextString || \"nonce\" || m) を計算し、114 バイトのダイジェストをリトルエンディアン整数として解釈し、結果の整数を 2^446 - 1381806680989 を法として減算することによって実装されます。\n\n5115352007386748515426880336692474882178609894547503885。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "高さ4(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "H(contextString || \"msg\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "高さ5(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "H(contextString || \"com\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Normally, H2 would also include a domain separator. However, it is omitted for compatibility with [RFC8032].",
      "ja": "通常、H2 にはドメイン区切り文字も含まれます。ただし、[RFC8032]との互換性のために省略されています。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Section 5.2.7 of [RFC8032] with the constraint that implementations MUST check the group equation [4][z]B = [4]R + [4][c]PK (changed to use the notation in this document).",
      "ja": "署名検証は [RFC8032] のセクション 5.2.7 に規定されているとおりですが、実装は群方程式 [4][z]B = [4]R + [4][c]PK (この文書での表記を使用するように変更されました) をチェックしなければならないという制約があります。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "正規の署名エンコーディングは付録 A で指定されているとおりです。"
    },
    {
      "indent": 0,
      "text": "6.4. FROST(P-256, SHA-256)",
      "section_title": true,
      "ja": "6.4. フロスト(P-256、SHA-256)"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses P-256 for the Group and SHA-256 for the hash function H. The value of the contextString parameter is \"FROST-P256-SHA256-v1\".",
      "ja": "この暗号スイートは、グループに P-256 を使用し、ハッシュ関数 H に SHA-256 を使用します。 contextString パラメータの値は「FROST-P256-SHA256-v1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "P-256 (secp256r1) [x9.62], where Ne = 33 and Ns = 32.",
      "ja": "P-256 (secp256r1) [x9.62]、Ne = 33、Ns = 32。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551.",
      "ja": "0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551 を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [x9.62].",
      "ja": "[x9.62] で定義されているとおり。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1], yielding a 33-byte output. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[SEC1] に従って圧縮された Elliptic-Curve-Point-to-Octet-String メソッドを使用して実装され、33 バイトの出力が生成されます。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "要素の逆シリアル化 (バグ):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing public key validation as defined in Section 3.2.2.1 of [SEC1]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. (As noted in the specification, validation of the point order is not required since the cofactor is 1.) If any of these checks fail, deserialization returns an error.",
      "ja": "[SEC1] に従って圧縮された Octet-String-to-Elliptic-Curve-Point メソッドを使用して 33 バイトの入力文字列を公開鍵に逆シリアル化することを試み、その後、[SEC1] のセクション 3.2.2.1 で定義されている公開鍵検証を実行することによって実装されます。これには、結果の点の座標が正しい範囲内にあること、点が曲線上にあること、および点が無限遠点ではないことのチェックが含まれます。(仕様に記載されているように、余因子が 1 であるため、ポイント順序の検証は必要ありません。) これらのチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar:"
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1].",
      "ja": "[SEC1] に従ってフィールド要素からオクテット文字列への変換を使用して実装されます。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1] の Octet-String-to-Field-Element を使用して、32 バイト文字列から Scalar を逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ(H):"
    },
    {
      "indent": 12,
      "text": "SHA-256, which has 32 bytes of output.",
      "ja": "SHA-256。32 バイトの出力があります。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"rho\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。\"rho\"、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2(m):"
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"chal\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。\"chal\"、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"nonce\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。\"nonce\"、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "高さ4(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "H(contextString || \"msg\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "高さ5(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "H(contextString || \"com\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Appendix B.",
      "ja": "署名検証は付録 B に規定されているとおりです。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "正規の署名エンコーディングは付録 A で指定されているとおりです。"
    },
    {
      "indent": 0,
      "text": "6.5. FROST(secp256k1, SHA-256)",
      "section_title": true,
      "ja": "6.5. FROST(secp256k1、SHA-256)"
    },
    {
      "indent": 3,
      "text": "This ciphersuite uses secp256k1 for the Group and SHA-256 for the hash function H. The value of the contextString parameter is \"FROST-secp256k1-SHA256-v1\".",
      "ja": "この暗号スイートは、グループに secp256k1 を使用し、ハッシュ関数 H に SHA-256 を使用します。 contextString パラメーターの値は「FROST-secp256k1-SHA256-v1」です。"
    },
    {
      "indent": 3,
      "text": "Group:",
      "ja": "グループ："
    },
    {
      "indent": 12,
      "text": "secp256k1 [SEC2], where Ne = 33 and Ns = 32.",
      "ja": "secp256k1 [SEC2]、Ne = 33、Ns = 32。"
    },
    {
      "indent": 6,
      "text": "Order():",
      "ja": "注文（）："
    },
    {
      "indent": 15,
      "text": "Return 0xfffffffffffffffffffffffffffffffebaaedce6af48a03 bbfd25e8cd0364141.",
      "ja": "0xfffffffffffffffffffffffffffffffffebaaedce6af48a03 bbfd25e8cd0364141 を返します。"
    },
    {
      "indent": 6,
      "text": "Identity():",
      "ja": "身元（）："
    },
    {
      "indent": 15,
      "text": "As defined in [SEC2].",
      "ja": "[SEC2] で定義されている通り。"
    },
    {
      "indent": 6,
      "text": "RandomScalar():",
      "ja": "RandomScalar():"
    },
    {
      "indent": 15,
      "text": "Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.",
      "ja": "[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。"
    },
    {
      "indent": 6,
      "text": "SerializeElement(A):",
      "ja": "SerializeElement(A):"
    },
    {
      "indent": 15,
      "text": "Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1], yielding a 33-byte output. Additionally, this function validates that the input element is not the group identity element.",
      "ja": "[SEC1] に従って圧縮された Elliptic-Curve-Point-to-Octet-String メソッドを使用して実装され、33 バイトの出力が生成されます。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。"
    },
    {
      "indent": 6,
      "text": "DeserializeElement(buf):",
      "ja": "要素の逆シリアル化 (バグ):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing public key validation as defined in Section 3.2.2.1 of [SEC1]. This includes checking that the coordinates of the resulting point are in the correct range, the point is on the curve, and the point is not the point at infinity. (As noted in the specification, validation of the point order is not required since the cofactor is 1.) If any of these checks fail, deserialization returns an error.",
      "ja": "[SEC1] に従って圧縮された Octet-String-to-Elliptic-Curve-Point メソッドを使用して 33 バイトの入力文字列を公開鍵に逆シリアル化することを試み、その後、[SEC1] のセクション 3.2.2.1 で定義されている公開鍵検証を実行することによって実装されます。これには、結果の点の座標が正しい範囲内にあること、点が曲線上にあること、および点が無限遠点ではないことを確認することが含まれます。(仕様に記載されているように、余因子が 1 であるため、ポイント順序の検証は必要ありません。) これらのチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。"
    },
    {
      "indent": 6,
      "text": "SerializeScalar(s):",
      "ja": "SerializeScalar:"
    },
    {
      "indent": 15,
      "text": "Implemented using the Field-Element-to-Octet-String conversion according to [SEC1].",
      "ja": "[SEC1] に従ってフィールド要素からオクテット文字列への変換を使用して実装されます。"
    },
    {
      "indent": 6,
      "text": "DeserializeScalar(buf):",
      "ja": "DeserializeScalar(buf):"
    },
    {
      "indent": 15,
      "text": "Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].",
      "ja": "[SEC1] の Octet-String-to-Field-Element を使用して、32 バイト文字列から Scalar を逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Hash (H):",
      "ja": "ハッシュ(H):"
    },
    {
      "indent": 12,
      "text": "SHA-256, which has 32 bytes of output.",
      "ja": "SHA-256。32 バイトの出力があります。"
    },
    {
      "indent": 6,
      "text": "H1(m):",
      "ja": "H1(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"rho\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。\"rho\"、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。"
    },
    {
      "indent": 6,
      "text": "H2(m):",
      "ja": "H2(m):"
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"chal\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。\"chal\"、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。"
    },
    {
      "indent": 6,
      "text": "H3(m):",
      "ja": "H3(メートル):"
    },
    {
      "indent": 15,
      "text": "Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || \"nonce\", F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.",
      "ja": "DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。\"nonce\"、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。"
    },
    {
      "indent": 6,
      "text": "H4(m):",
      "ja": "高さ4(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"msg\" || m).",
      "ja": "H(contextString || \"msg\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "H5(m):",
      "ja": "高さ5(m):"
    },
    {
      "indent": 15,
      "text": "Implemented by computing H(contextString || \"com\" || m).",
      "ja": "H(contextString || \"com\" || m) を計算することによって実装されます。"
    },
    {
      "indent": 3,
      "text": "Signature verification is as specified in Appendix B.",
      "ja": "署名検証は付録 B に規定されているとおりです。"
    },
    {
      "indent": 3,
      "text": "Canonical signature encoding is as specified in Appendix A.",
      "ja": "正規の署名エンコーディングは付録 A で指定されているとおりです。"
    },
    {
      "indent": 0,
      "text": "6.6. Ciphersuite Requirements",
      "section_title": true,
      "ja": "6.6. 暗号スイートの要件"
    },
    {
      "indent": 3,
      "text": "Future documents that introduce new ciphersuites MUST adhere to the following requirements.",
      "ja": "新しい暗号スイートを導入する将来の文書は、次の要件に従わなければなりません。"
    },
    {
      "indent": 8,
      "text": "1. H1, H2, and H3 all have output distributions that are close to (indistinguishable from) the uniform distribution.",
      "ja": "1. H1、H2、および H3 はすべて、一様分布に近い (区別できない) 出力分布を持ちます。"
    },
    {
      "indent": 8,
      "text": "2. All hash functions MUST be domain-separated with a per-suite context string. Note that the FROST(Ed25519, SHA-512) ciphersuite does not adhere to this requirement for H2 alone in order to maintain compatibility with [RFC8032].",
      "ja": "2. すべてのハッシュ関数は、スイートごとのコンテキスト文字列を使用してドメインで区切る必要があります。FROST(Ed25519, SHA-512) 暗号スイートは、[RFC8032] との互換性を維持するために、H2 単独についてはこの要件に準拠していないことに注意してください。"
    },
    {
      "indent": 8,
      "text": "3. The group MUST be of prime order and all deserialization functions MUST output elements that belong to their respective sets of Elements or Scalars, or else fail.",
      "ja": "3. グループは素数順序でなければならず、すべての逆シリアル化関数はそれぞれの要素またはスカラーのセットに属する要素を出力しなければなりません。そうでない場合は失敗します。"
    },
    {
      "indent": 8,
      "text": "4. The canonical signature encoding details are clearly specified.",
      "ja": "4. 正規の署名エンコーディングの詳細は明確に指定されています。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A security analysis of FROST is documented in [FROST20] and [StrongerSec22]. At a high level, FROST provides security against Existential Unforgeability Under Chosen Message Attacks (EUF-CMA) as defined in [StrongerSec22]. To satisfy this requirement, the ciphersuite needs to adhere to the requirements in Section 6.6 and the following assumptions must hold.",
      "ja": "FROST のセキュリティ分析は [FROST20] および [StrongerSec22] に文書化されています。高レベルでは、FROST は [StrongerSec22] で定義されている Existential Unforgeability Under Chosen Message Attacks (EUF-CMA) に対するセキュリティを提供します。この要件を満たすには、暗号スイートはセクション 6.6 の要件に準拠する必要があり、次の前提が当てはまります。"
    },
    {
      "indent": 6,
      "text": "* The signer key shares are generated and distributed securely, e.g., via a trusted dealer that performs key generation (see Appendix C.2) or through a distributed key generation protocol.",
      "ja": "* 署名者の鍵共有は、鍵生成を実行する信頼できるディーラー (付録 C.2 を参照) または分散鍵生成プロトコルなどを通じて、安全に生成および配布されます。"
    },
    {
      "indent": 6,
      "text": "* The Coordinator and at most (MIN_PARTICIPANTS-1) participants may be corrupted.",
      "ja": "* コーディネーターと最大 (MIN_PARTICIPANTS-1) 人の参加者が破損している可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that the Coordinator is not trusted with any private information, and communication at the time of signing can be performed over a public channel as long as it is authenticated and reliable.",
      "ja": "コーディネーターはいかなる個人情報も信頼されておらず、認証され信頼できる限り、署名時の通信はパブリック チャネル経由で実行できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "FROST provides security against DoS attacks under the following assumptions:",
      "ja": "FROST は、次の前提のもとで DoS 攻撃に対するセキュリティを提供します。"
    },
    {
      "indent": 6,
      "text": "* The Coordinator does not perform a DoS attack.",
      "ja": "* コーディネーターは DoS 攻撃を実行しません。"
    },
    {
      "indent": 6,
      "text": "* The Coordinator identifies misbehaving participants such that they can be removed from future invocations of FROST. The Coordinator may also abort upon detecting a misbehaving participant to ensure that invalid signatures are not produced.",
      "ja": "* コーディネーターは、不正行為を行っている参加者を特定し、今後の FROST の呼び出しから削除できるようにします。コーディネーターは、無効な署名が生成されないようにするために、不正行為を行っている参加者を検出すると中断することもあります。"
    },
    {
      "indent": 3,
      "text": "FROST does not aim to achieve the following goals:",
      "ja": "FROST は次の目標を達成することを目的としていません。"
    },
    {
      "indent": 6,
      "text": "* Post-quantum security. FROST, like plain Schnorr signatures, requires the hardness of the Discrete Logarithm Problem.",
      "ja": "* ポスト量子セキュリティ。FROST は、単純な Schnorr 署名と同様に、離散対数問題の難易度を必要とします。"
    },
    {
      "indent": 6,
      "text": "* Robustness. Preventing DoS attacks against misbehaving participants requires the Coordinator to identify and act on misbehaving participants; see Section 5.4 for more information. While FROST does not provide robustness, [ROAST] is a wrapper protocol around FROST that does.",
      "ja": "* 堅牢性。不正行為を行う参加者に対する DoS 攻撃を防ぐには、コーディネーターが不正行為を行う参加者を特定し、対処する必要があります。詳細については、セクション 5.4 を参照してください。FROST は堅牢性を提供しませんが、[ROAST] は堅牢性を提供する FROST のラッパー プロトコルです。"
    },
    {
      "indent": 6,
      "text": "* Downgrade prevention. All participants in the protocol are assumed to agree on which algorithms to use.",
      "ja": "* ダウングレードの防止。プロトコルの参加者全員が、使用するアルゴリズムに同意するものと想定されます。"
    },
    {
      "indent": 6,
      "text": "* Metadata protection. If protection for metadata is desired, a higher-level communication channel can be used to facilitate key generation and signing.",
      "ja": "* メタデータの保護。メタデータの保護が必要な場合は、より高いレベルの通信チャネルを使用してキーの生成と署名を容易にすることができます。"
    },
    {
      "indent": 3,
      "text": "The rest of this section documents issues particular to implementations or deployments.",
      "ja": "このセクションの残りの部分では、実装または展開に特有の問題について説明します。"
    },
    {
      "indent": 0,
      "text": "7.1. Side-Channel Mitigations",
      "section_title": true,
      "ja": "7.1. サイドチャネルの軽減策"
    },
    {
      "indent": 3,
      "text": "Several routines process secret values (nonces, signing keys / shares), and depending on the implementation and deployment environment, mitigating side-channels may be pertinent. Mitigating these side-channels requires implementing G.ScalarMult(), G.ScalarBaseMult(), G.SerializeScalar(), and G.DeserializeScalar() in constant (value-independent) time. The various ciphersuites lend themselves differently to specific implementation techniques and ease of achieving side-channel resistance, though ultimately avoiding value-dependent computation or branching is the goal.",
      "ja": "いくつかのルーチンはシークレット値 (ノンス、署名キー/共有) を処理し、実装および展開環境によっては、サイドチャネルの軽減が適切になる場合があります。これらのサイドチャネルを軽減するには、G.ScalarMult()、G.ScalarBaseMult()、G.SerializeScalar()、および G.DeserializeScalar() を一定の (値に依存しない) 時間で実装する必要があります。さまざまな暗号スイートは、特定の実装技術やサイドチャネル耐性の達成の容易さにそれぞれ異なった形で適していますが、最終的には値に依存する計算や分岐を回避することが目標です。"
    },
    {
      "indent": 0,
      "text": "7.2. Optimizations",
      "section_title": true,
      "ja": "7.2. 最適化"
    },
    {
      "indent": 3,
      "text": "[StrongerSec22] presented an optimization to FROST that reduces the total number of Scalar multiplications from linear in the number of signing participants to a constant. However, as described in [StrongerSec22], this optimization removes the guarantee that the set of signer participants that started round one of the protocol is the same set of signing participants that produced the signature output by round two. As such, the optimization is NOT RECOMMENDED and is not covered in this document.",
      "ja": "[StrongerSec22] は、スカラー乗算の総数を署名参加者の数の線形から定数に減らす FROST の最適化を提示しました。ただし、[StrongerSec22] で説明されているように、この最適化により、プロトコルのラウンド 1 で開始した署名参加者のセットが、ラウンド 2 で署名出力を生成した署名参加者のセットと同じであるという保証が削除されます。そのため、最適化は推奨されず、このドキュメントでは取り上げません。"
    },
    {
      "indent": 0,
      "text": "7.3. Nonce Reuse Attacks",
      "section_title": true,
      "ja": "7.3. ノンス再利用攻撃"
    },
    {
      "indent": 3,
      "text": "Section 4.1 describes the procedure that participants use to produce nonces during the first round of signing. The randomness produced in this procedure MUST be sampled uniformly at random. The resulting nonces produced via nonce_generate are indistinguishable from values sampled uniformly at random. This requirement is necessary to avoid replay attacks initiated by other participants that allow for a complete key-recovery attack. The Coordinator MAY further hedge against nonce reuse attacks by tracking participant nonce commitments used for a given group key at the cost of additional state.",
      "ja": "セクション 4.1 では、最初の署名ラウンドで参加者が nonce を生成するために使用する手順について説明します。この手順で生成されるランダム性は、均一にランダムにサンプリングされなければなりません。nonce_generate によって生成されたノンスは、均一にランダムにサンプリングされた値と区別できません。この要件は、完全なキー回復攻撃を可能にする他の参加者によって開始されるリプレイ攻撃を回避するために必要です。コーディネーターは、追加の状態を犠牲にして、特定のグループ鍵に使用される参加者のノンスコミットメントを追跡することによって、ノンス再利用攻撃をさらに回避してもよい(MAY)。"
    },
    {
      "indent": 0,
      "text": "7.4. Protocol Failures",
      "section_title": true,
      "ja": "7.4. プロトコルの失敗"
    },
    {
      "indent": 3,
      "text": "We do not specify what implementations should do when the protocol fails other than requiring the protocol to abort. Examples of viable failures include when a verification check returns invalid or the underlying transport failed to deliver the required messages.",
      "ja": "プロトコルの中止を要求すること以外に、プロトコルが失敗したときに実装が何をすべきかについては指定していません。実行可能な失敗の例には、検証チェックで無効が返された場合や、基礎となるトランスポートが必要なメッセージの配信に失敗した場合などがあります。"
    },
    {
      "indent": 0,
      "text": "7.5. Removing the Coordinator Role",
      "section_title": true,
      "ja": "7.5. コーディネーターの役割の削除"
    },
    {
      "indent": 3,
      "text": "In some settings, it may be desirable to omit the role of the Coordinator entirely. Doing so does not change the security implications of FROST; instead, it simply requires each participant to communicate with all other participants. We loosely describe how to perform FROST signing among participants without this coordinator role. We assume that every participant receives a message to be signed from an external source as input prior to performing the protocol.",
      "ja": "設定によっては、コーディネーターの役割を完全に省略することが望ましい場合があります。そうしても、FROST のセキュリティへの影響は変わりません。代わりに、各参加者が他のすべての参加者と通信する必要があるだけです。このコーディネーターの役割を持たずに参加者間で FROST 署名を実行する方法を大まかに説明します。すべての参加者は、プロトコルを実行する前に、外部ソースから署名されるメッセージを入力として受信すると想定します。"
    },
    {
      "indent": 3,
      "text": "Every participant begins by performing commit() as is done in the setting where a Coordinator is used. However, instead of sending the commitment to the Coordinator, every participant will publish this commitment to every other participant. In the second round, participants will already have sufficient information to perform signing, and they will directly perform sign(). All participants will then publish their signature shares to one another. After having received all signature shares from all other participants, each participant will then perform verify_signature_share and then aggregate directly.",
      "ja": "すべての参加者は、コーディネーターが使用される設定で行われるように commit() を実行することから始まります。ただし、コミットメントをコーディネーターに送信する代わりに、すべての参加者はこのコミットメントを他のすべての参加者に公開します。2 番目のラウンドでは、参加者は署名を実行するのに十分な情報をすでに持っているため、sign() を直接実行します。その後、すべての参加者が自分の署名共有を相互に公開します。他のすべての参加者からすべての署名共有を受信した後、各参加者は verify_signature_share を実行し、直接集約します。"
    },
    {
      "indent": 3,
      "text": "The requirements for the underlying network channel remain the same in the setting where all participants play the role of the Coordinator, in that all exchanged messages are public and the channel must be reliable. However, in the setting where a player attempts to split the view of all other players by sending disjoint values to a subset of players, the signing operation will output an invalid signature. To avoid this DoS, implementations may wish to define a mechanism where messages are authenticated so that cheating players can be identified and excluded.",
      "ja": "基礎となるネットワーク チャネルの要件は、すべての参加者がコーディネーターの役割を果たす設定でも同じであり、交換されるメッセージはすべてパブリックであり、チャネルが信頼できる必要があります。ただし、プレーヤーがプレーヤーのサブセットに素の値を送信して他のすべてのプレーヤーのビューを分割しようとする設定では、署名操作により無効な署名が出力されます。この DoS を回避するために、実装では、不正行為を行ったプレイヤーを特定して除外できるように、メッセージが認証されるメカニズムを定義することが必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "7.6. Input Message Hashing",
      "section_title": true,
      "ja": "7.6. 入力メッセージのハッシュ化"
    },
    {
      "indent": 3,
      "text": "FROST signatures do not pre-hash message inputs. This means that the entire message must be known in advance of invoking the signing protocol. Applications can apply pre-hashing in settings where storing the full message is prohibitively expensive. In such cases, pre-hashing MUST use a collision-resistant hash function with a security level commensurate with the security inherent to the ciphersuite chosen. For applications that choose to apply pre-hashing, it is RECOMMENDED that they use the hash function (H) associated with the chosen ciphersuite in a manner similar to how H4 is defined. In particular, a different prefix SHOULD be used to differentiate this pre-hash from H4. For example, if a fictional protocol Quux decided to pre-hash its input messages, one possible way to do so is via H(contextString || \"Quux-pre-hash\" || m).",
      "ja": "FROST 署名はメッセージ入力を事前ハッシュしません。これは、署名プロトコルを呼び出す前にメッセージ全体を知っておく必要があることを意味します。アプリケーションは、完全なメッセージの保存に法外なコストがかかる設定で事前ハッシュを適用できます。このような場合、事前ハッシュでは、選択した暗号スイートに固有のセキュリティに見合ったセキュリティ レベルを持つ衝突耐性のあるハッシュ関数を使用しなければなりません (MUST)。事前ハッシュの適用を選択したアプリケーションの場合、H4 の定義方法と同様の方法で、選択した暗号スイートに関連付けられたハッシュ関数 (H) を使用することが推奨されます。特に、このプレハッシュを H4 と区別するには、異なるプレフィックスを使用する必要があります (SHOULD)。たとえば、架空のプロトコル Quux が入力メッセージを事前ハッシュすることを決定した場合、考えられる方法の 1 つは H(contextString || \"Quux-pre-hash\" || m) を使用することです。"
    },
    {
      "indent": 0,
      "text": "7.7. Input Message Validation",
      "section_title": true,
      "ja": "7.7. 入力メッセージの検証"
    },
    {
      "indent": 3,
      "text": "Message validation varies by application. For example, some applications may require that participants only process messages of a certain structure. In digital currency applications, wherein multiple participants may collectively sign a transaction, it is reasonable to require each participant to check that the input message is a syntactically valid transaction.",
      "ja": "メッセージの検証はアプリケーションによって異なります。たとえば、アプリケーションによっては、参加者が特定の構造のメッセージのみを処理することを要求する場合があります。デジタル通貨アプリケーションでは、複数の参加者が集合的にトランザクションに署名する可能性があるため、各参加者に入力メッセージが構文的に有効なトランザクションであることを確認するよう要求するのが合理的です。"
    },
    {
      "indent": 3,
      "text": "As another example, some applications may require that participants only process messages with permitted content according to some policy. In digital currency applications, this might mean that a transaction being signed is allowed and intended by the relevant stakeholders. Another instance of this type of message validation is in the context of [TLS], wherein implementations may use threshold signing protocols to produce signatures of transcript hashes. In this setting, signing participants might require the raw TLS handshake messages to validate before computing the transcript hash that is signed.",
      "ja": "別の例として、一部のアプリケーションでは、参加者が何らかのポリシーに従って許可されたコンテンツを含むメッセージのみを処理することを要求する場合があります。デジタル通貨アプリケーションでは、これは、署名されるトランザクションが関連する利害関係者によって許可され、意図されていることを意味する場合があります。このタイプのメッセージ検証の別の例は [TLS] のコンテキストにあり、実装ではしきい値署名プロトコルを使用してトランスクリプト ハッシュの署名を生成できます。この設定では、署名参加者は、署名されたトランスクリプト ハッシュを計算する前に、生の TLS ハンドシェイク メッセージを検証する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "In general, input message validation is an application-specific consideration that varies based on the use case and threat model. However, it is RECOMMENDED that applications take additional precautions and validate inputs so that participants do not operate as signing oracles for arbitrary messages.",
      "ja": "一般に、入力メッセージの検証はアプリケーション固有の考慮事項であり、ユースケースと脅威モデルに応じて異なります。ただし、参加者が任意のメッセージの署名オラクルとして動作しないように、アプリケーションは追加の予防措置を講じ、入力を検証することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "この文書には IANA のアクションはありません。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[HASH-TO-CURVE]\n           Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,\n           and C. A. Wood, \"Hashing to Elliptic Curves\", RFC 9380,\n           DOI 10.17487/RFC9380, August 2023,\n           <https://www.rfc-editor.org/info/rfc9380>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RISTRETTO]\n           de Valence, H., Grigg, J., Hamburg, M., Lovecruft, I.,\n           Tankersley, G., and F. Valsorda, \"The ristretto255 and\n           decaf448 Groups\", RFC 9496, DOI 10.17487/RFC9496, December\n           2023, <https://www.rfc-editor.org/info/rfc9496>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC1]     Standards for Efficient Cryptography, \"SEC 1: Elliptic\n           Curve Cryptography\", Version 2.0, May 2009,\n           <https://secg.org/sec1-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEC2]     Standards for Efficient Cryptography, \"SEC 2: Recommended\n           Elliptic Curve Domain Parameters\", Version 2.0, January\n           2010, <https://secg.org/sec2-v2.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[x9.62]    American National Standards Institute, \"Public Key\n           Cryptography for the Financial Services Industry: the\n           Elliptic Curve Digital Signature Algorithm (ECDSA)\",\n           ANSI X9.62-2005, November 2005.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[FeldmanSecretSharing]\n           Feldman, P., \"A practical scheme for non-interactive\n           verifiable secret sharing\", IEEE, 28th Annual Symposium on\n           Foundations of Computer Science (sfcs 1987),\n           DOI 10.1109/sfcs.1987.4, October 1987,\n           <https://doi.org/10.1109/sfcs.1987.4>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FROST20]  Komlo, C. and I. Goldberg, \"FROST: Flexible Round-\n           Optimized Schnorr Threshold Signatures\", December 2020,\n           <https://eprint.iacr.org/2020/852.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MultExp]  Connolly, D. and C. Gouvea, \"Speeding up FROST with multi-\n           scalar multiplication\", June 2023, <https://zfnd.org/\n           speeding-up-frost-with-multi-scalar-multiplication/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Pornin22] Pornin, T., \"Point-Halving and Subgroup Membership in\n           Twisted Edwards Curves\", September 2022,\n           <https://eprint.iacr.org/2022/1164.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n           \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n           DOI 10.17487/RFC4086, June 2005,\n           <https://www.rfc-editor.org/info/rfc4086>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7748]  Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n           for Security\", RFC 7748, DOI 10.17487/RFC7748, January\n           2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ROAST]    Ruffing, T., Ronge, V., Jin, E., Schneider-Bensch, J., and\n           D. Schröder, \"ROAST: Robust Asynchronous Schnorr Threshold\n           Signatures\", Paper 2022/550, DOI 10.1145/3548606, November\n           2022, <https://eprint.iacr.org/2022/550>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ShamirSecretSharing]\n           Shamir, A., \"How to share a secret\", Association for\n           Computing Machinery (ACM), Communications of the ACM, Vol.\n           22, Issue 11, pp. 612-613, DOI 10.1145/359168.359176,\n           November 1979, <https://doi.org/10.1145/359168.359176>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[StrongerSec22]\n           Bellare, M., Crites, E., Komlo, C., Maller, M., Tessaro,\n           S., and C. Zhu, \"Better than Advertised Security for Non-\n           interactive Threshold Signatures\",\n           DOI 10.1007/978-3-031-15985-5_18, August 2022,\n           <https://crypto.iacr.org/2022/\n           papers/538806_1_En_18_Chapter_OnlinePDF.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TLS]      Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Schnorr Signature Encoding",
      "section_title": true,
      "ja": "付録A. Schnorr 署名エンコーディング"
    },
    {
      "indent": 3,
      "text": "This section describes one possible canonical encoding of FROST signatures. Using notation from Section 3 of [TLS], the encoding of a FROST signature (R, z) is as follows:",
      "ja": "このセクションでは、FROST 署名の可能な正規エンコーディングの 1 つについて説明します。[TLS] のセクション 3 の表記を使用すると、FROST 署名 (R, z) のエンコーディングは次のようになります。"
    },
    {
      "indent": 5,
      "text": "struct {\n  opaque R_encoded[Ne];\n  opaque z_encoded[Ns];\n} Signature;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where Signature.R_encoded is G.SerializeElement(R), Signature.z_encoded is G.SerializeScalar(z), and G is determined by ciphersuite.",
      "ja": "ここで、Signature.R_encoded は G.SerializeElement(R)、Signature.z_encoded は G.SerializeScalar(z)、G は暗号スイートによって決定されます。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Schnorr Signature Generation and Verification for Prime- Order Groups",
      "section_title": true,
      "ja": "付録B. Prime-Order グループの Schnorr 署名の生成と検証"
    },
    {
      "indent": 3,
      "text": "This section contains descriptions of functions for generating and verifying Schnorr signatures. It is included to complement the routines present in [RFC8032] for prime-order groups, including ristretto255, P-256, and secp256k1. The functions for generating and verifying signatures are prime_order_sign and prime_order_verify, respectively.",
      "ja": "このセクションでは、Schnorr 署名を生成および検証するための関数について説明します。これは、ristretto255、P-256、secp256k1 などの素数順序グループ用の [RFC8032] に存在するルーチンを補完するために含まれています。署名を生成および検証する関数は、それぞれ prime_order_sign および prime_order_verify です。"
    },
    {
      "indent": 3,
      "text": "The function prime_order_sign produces a Schnorr signature over a message given a full secret signing key as input (as opposed to a key share).",
      "ja": "関数 prime_order_sign は、(鍵共有ではなく) 入力として完全な秘密署名鍵が与えられたメッセージに対して Schnorr 署名を生成します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- msg, message to sign, a byte string.\n- sk, secret key, a Scalar.\n\nOutputs:\n- (R, z), a Schnorr signature consisting of an Element R and\n  Scalar z.\n\ndef prime_order_sign(msg, sk):\n  r = G.RandomScalar()\n  R = G.ScalarBaseMult(r)\n  PK = G.ScalarBaseMult(sk)\n  comm_enc = G.SerializeElement(R)\n  pk_enc = G.SerializeElement(PK)\n  challenge_input = comm_enc || pk_enc || msg\n  c = H2(challenge_input)\n  z = r + (c * sk) // Scalar addition and multiplication\n  return (R, z)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function prime_order_verify verifies Schnorr signatures with validated inputs. Specifically, it assumes that the signature R component and public key belong to the prime-order group.",
      "ja": "関数 prime_order_verify は、検証された入力を使用して Schnorr 署名を検証します。具体的には、署名 R コンポーネントと公開鍵が素数群に属すると仮定します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- msg, signed message, a byte string.\n- sig, a tuple (R, z) output from signature generation.\n- PK, public key, an Element.\n\nOutputs:\n- True if signature is valid, and False otherwise.\n\ndef prime_order_verify(msg, sig = (R, z), PK):\n  comm_enc = G.SerializeElement(R)\n  pk_enc = G.SerializeElement(PK)\n  challenge_input = comm_enc || pk_enc || msg\n  c = H2(challenge_input)\n\n  l = G.ScalarBaseMult(z)\n  r = R + G.ScalarMult(PK, c)\n  return l == r",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix C. Trusted Dealer Key Generation",
      "section_title": true,
      "ja": "付録C. 信頼できるディーラーのキーの生成"
    },
    {
      "indent": 3,
      "text": "One possible key generation mechanism is to depend on a trusted dealer, wherein the dealer generates a group secret s uniformly at random and uses Shamir and Verifiable Secret Sharing [ShamirSecretSharing] as described in Appendices C.1 and C.2 to create secret shares of s, denoted as s_i for i = 1, ..., MAX_PARTICIPANTS, to be sent to all MAX_PARTICIPANTS participants. This operation is specified in the trusted_dealer_keygen algorithm. The mathematical relation between the secret key s and the MAX_PARTICIPANTS secret shares is formalized in the secret_share_combine(shares) algorithm, defined in Appendix C.1.",
      "ja": "考えられる鍵生成メカニズムの 1 つは、信頼できるディーラーに依存することです。この場合、ディーラーはグループ秘密 s を均一にランダムに生成し、付録 C.1 および C.2 で説明されているようにシャミアおよび検証可能な秘密共有 [ShamirSecretSharing] を使用して、i = 1, ..., MAX_PARTICIPANTS の場合は s_i として示される s の秘密共有を作成し、すべての MAX_PARTICIPANTS 参加者に送信します。この操作は、trusted_dealer_keygen アルゴリズムで指定されます。秘密鍵 s と MAX_PARTICIPANTS 秘密共有の間の数学的関係は、付録 C.1 で定義されている Secret_share_combine(shares) アルゴリズムで形式化されます。"
    },
    {
      "indent": 3,
      "text": "The dealer that performs trusted_dealer_keygen is trusted to 1) generate good randomness, 2) delete secret values after distributing shares to each participant, and 3) keep secret values confidential.",
      "ja": "Trusted_dealer_keygen を実行するディーラーは、1) 適切なランダム性を生成し、2) 各参加者にシェアを配布した後にシークレット値を削除し、3) シークレット値を機密に保つことを信頼されています。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- secret_key, a group secret, a Scalar, that MUST be derived from at\n  least Ns bytes of entropy.\n- MAX_PARTICIPANTS, the number of shares to generate, an integer.\n- MIN_PARTICIPANTS, the threshold of the secret sharing scheme,\n  an integer.\n\nOutputs:\n- participant_private_keys, MAX_PARTICIPANTS shares of the secret\n  key s, each a tuple consisting of the participant identifier\n  (a NonZeroScalar) and the key share (a Scalar).\n- group_public_key, public key corresponding to the group signing\n  key, an Element.\n- vss_commitment, a vector commitment of Elements in G, to each of\n  the coefficients in the polynomial defined by secret_key_shares and\n  whose first element is G.ScalarBaseMult(s).\n\ndef trusted_dealer_keygen(\n        secret_key, MAX_PARTICIPANTS, MIN_PARTICIPANTS):\n  # Generate random coefficients for the polynomial\n  coefficients = []\n  for i in range(0, MIN_PARTICIPANTS - 1):\n    coefficients.append(G.RandomScalar())\n  participant_private_keys, coefficients = secret_share_shard(\n      secret_key, coefficients, MAX_PARTICIPANTS)\n  vss_commitment = vss_commit(coefficients):\n  return participant_private_keys, vss_commitment[0], vss_commitment",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It is assumed that the dealer then sends one secret key share to each of the NUM_PARTICIPANTS participants, along with vss_commitment. After receiving their secret key share and vss_commitment, participants MUST abort if they do not have the same view of vss_commitment. The dealer can use a secure broadcast channel to ensure each participant has a consistent view of this commitment. Furthermore, each participant MUST perform vss_verify(secret_key_share_i, vss_commitment) and abort if the check fails. The trusted dealer MUST delete the secret_key and secret_key_shares upon completion.",
      "ja": "次に、ディーラーは、vss_commitment とともに、NUM_PARTICIPANTS 人の参加者のそれぞれに 1 つの秘密鍵共有を送信すると想定されます。秘密鍵の共有と vss_commitment を受け取った後、vss_commitment について同じビューを持っていない場合、参加者は中止しなければなりません (MUST)。ディーラーは安全なブロードキャスト チャネルを使用して、各参加者がこのコミットメントについて一貫した見解を確実に得られるようにすることができます。さらに、各参加者は vss_verify(secret_key_share_i, vss_commitment) を実行し、チェックが失敗した場合は中止しなければなりません (MUST)。信頼できるディーラーは、完了時に Secret_key と Secret_key_shares を削除しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Use of this method for key generation requires a mutually authenticated secure channel between the dealer and participants to send secret key shares, wherein the channel provides confidentiality and integrity. Mutually authenticated TLS is one possible deployment option.",
      "ja": "鍵生成にこの方法を使用するには、秘密鍵共有を送信するためにディーラーと参加者の間で相互認証された安全なチャネルが必要です。このチャネルは機密性と完全性を提供します。相互認証された TLS は、可能な展開オプションの 1 つです。"
    },
    {
      "indent": 0,
      "text": "C.1. Shamir Secret Sharing",
      "section_title": true,
      "ja": "C.1. シャミールの秘密の共有"
    },
    {
      "indent": 3,
      "text": "In Shamir secret sharing, a dealer distributes a secret Scalar s to n participants in such a way that any cooperating subset of at least MIN_PARTICIPANTS participants can recover the secret. There are two basic steps in this scheme: 1) splitting a secret into multiple shares and 2) combining shares to reveal the resulting secret.",
      "ja": "Shamir 秘密共有では、ディーラーは、少なくとも MIN_PARTICIPANTS 参加者の協力するサブセットが秘密を回復できるような方法で、秘密のスカラーを n 人の参加者に配布します。このスキームには 2 つの基本的な手順があります。1) シークレットを複数のシェアに分割し、2) シェアを結合して結果のシークレットを明らかにします。"
    },
    {
      "indent": 3,
      "text": "This secret sharing scheme works over any field F. In this specification, F is the Scalar field of the prime-order group G.",
      "ja": "この秘密分散スキームは、任意の体 F に対して機能します。この仕様では、F は素数次数群 G のスカラー体です。"
    },
    {
      "indent": 3,
      "text": "The procedure for splitting a secret into shares is as follows. The algorithm polynomial_evaluate is defined in Appendix C.1.1.",
      "ja": "シークレットを株式に分割する手順は次のとおりです。アルゴリズム Polynomial_evaluate は付録 C.1.1 で定義されています。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- s, secret value to be shared, a Scalar.\n- coefficients, an array of size MIN_PARTICIPANTS - 1 with randomly\n  generated Scalars, not including the 0th coefficient of the\n  polynomial.\n- MAX_PARTICIPANTS, the number of shares to generate, an integer less\n  than the group order.\n\nOutputs:\n- secret_key_shares, A list of MAX_PARTICIPANTS number of secret\n  shares, each a tuple consisting of the participant identifier\n  (a NonZeroScalar) and the key share (a Scalar).\n- coefficients, a vector of MIN_PARTICIPANTS coefficients which\n  uniquely determine a polynomial f.\n\ndef secret_share_shard(s, coefficients, MAX_PARTICIPANTS):\n  # Prepend the secret to the coefficients\n  coefficients = [s] + coefficients\n\n  # Evaluate the polynomial for each point x=1,...,n\n  secret_key_shares = []\n  for x_i in range(1, MAX_PARTICIPANTS + 1):\n    y_i = polynomial_evaluate(Scalar(x_i), coefficients)\n    secret_key_share_i = (x_i, y_i)\n    secret_key_shares.append(secret_key_share_i)\n  return secret_key_shares, coefficients",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Let points be the output of this function. The i-th element in points is the share for the i-th participant, which is the randomly generated polynomial evaluated at coordinate i. We denote a secret share as the tuple (i, points[i]) and the list of these shares as shares. i MUST never equal 0; recall that f(0) = s, where f is the polynomial defined in a Shamir secret sharing operation.",
      "ja": "ポイントをこの関数の出力とします。ポイント単位の i 番目の要素は、i 番目の参加者のシェアであり、座標 i で評価されるランダムに生成された多項式です。秘密共有をタプル (i, Points[i]) として表し、これらの共有のリストを共有として表します。i は決して 0 になってはなりません。f(0) = s であることを思い出してください。ここで、f はシャミア秘密分散演算で定義された多項式です。"
    },
    {
      "indent": 3,
      "text": "The procedure for combining a shares list of length MIN_PARTICIPANTS to recover the secret s is as follows; the algorithm polynomial_interpolate_constant is defined in Appendix C.1.1.",
      "ja": "長さ MIN_PARTICIPANTS の共有リストを結合してシークレット を回復する手順は次のとおりです。アルゴリズム Polynomial_interpolate_constant は付録 C.1.1 で定義されています。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- shares, a list of at minimum MIN_PARTICIPANTS secret shares, each a\n  tuple (i, f(i)) where i and f(i) are Scalars.\n\nOutputs:\n- s, the resulting secret that was previously split into shares,\n  a Scalar.\n\nErrors:\n- \"invalid parameters\", if fewer than MIN_PARTICIPANTS input shares\n  are provided.\n\ndef secret_share_combine(shares):\n  if len(shares) < MIN_PARTICIPANTS:\n    raise \"invalid parameters\"\n  s = polynomial_interpolate_constant(shares)\n  return s",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.1.1. Additional Polynomial Operations",
      "section_title": true,
      "ja": "C.1.1. 追加の多項式演算"
    },
    {
      "indent": 3,
      "text": "This section describes two functions. One function, denoted as polynomial_evaluate, is for evaluating a polynomial f(x) at a particular point x using Horner's method, i.e., computing y = f(x). The other function, polynomial_interpolate_constant, is for recovering the constant term of an interpolating polynomial defined by a set of points.",
      "ja": "このセクションでは 2 つの機能について説明します。Polynomial_evaluate として示される 1 つの関数は、ホーナー法を使用して特定の点 x における多項式 f(x) を評価するためのものです。つまり、y = f(x) を計算します。もう 1 つの関数、polynomial_interpolate_constant は、点のセットによって定義される補間多項式の定数項を回復するためのものです。"
    },
    {
      "indent": 3,
      "text": "The function polynomial_evaluate is defined as follows.",
      "ja": "関数polynomial_evaluateは次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- x, input at which to evaluate the polynomial, a Scalar\n- coeffs, the polynomial coefficients, a list of Scalars\n\nOutputs: Scalar result of the polynomial evaluated at input x\n\ndef polynomial_evaluate(x, coeffs):\n  value = Scalar(0)\n  for coeff in reverse(coeffs):\n    value *= x\n    value += coeff\n  return value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The function polynomial_interpolate_constant is defined as follows.",
      "ja": "関数polynomial_interpolate_constantは次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- points, a set of t points with distinct x coordinates on\n  a polynomial f, each a tuple of two Scalar values representing the\n  x and y coordinates.\n\nOutputs:\n- f_zero, the constant term of f, i.e., f(0), a Scalar.\n\ndef polynomial_interpolate_constant(points):\n  x_coords = []\n  for (x, y) in points:\n    x_coords.append(x)\n\n  f_zero = Scalar(0)\n  for (x, y) in points:\n    delta = y * derive_interpolating_value(x_coords, x)\n    f_zero += delta\n\n  return f_zero",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.2. Verifiable Secret Sharing",
      "section_title": true,
      "ja": "C.2. 検証可能な秘密の共有"
    },
    {
      "indent": 3,
      "text": "Feldman's Verifiable Secret Sharing (VSS) [FeldmanSecretSharing] builds upon Shamir secret sharing, adding a verification step to demonstrate the consistency of a participant's share with a public commitment to the polynomial f for which the secret s is the constant term. This check ensures that all participants have a point (their share) on the same polynomial, ensuring that they can reconstruct the correct secret later.",
      "ja": "Feldman の Verifiable Secret Sharing (VSS) [FeldmanSecretSharing] は Shamir 秘密共有に基づいて構築されており、秘密 s が定数項である多項式 f に対する参加者の共有と公開コミットメントとの一貫性を実証するための検証ステップが追加されています。このチェックにより、すべての参加者が同じ多項式上の点 (共有) を持っていることが保証され、後で正しい秘密を再構築できることが保証されます。"
    },
    {
      "indent": 3,
      "text": "The procedure for committing to a polynomial f of degree at most MIN_PARTICIPANTS-1 is as follows.",
      "ja": "最大 MIN_PARTICIPANTS-1 次の多項式 f にコミットする手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- coeffs, a vector of the MIN_PARTICIPANTS coefficients that\n  uniquely determine a polynomial f.\n\nOutputs:\n- vss_commitment, a vector commitment to each of the coefficients in\n  coeffs, where each item of the vector commitment is an Element.\n\ndef vss_commit(coeffs):\n  vss_commitment = []\n  for coeff in coeffs:\n    A_i = G.ScalarBaseMult(coeff)\n    vss_commitment.append(A_i)\n  return vss_commitment",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The procedure for verification of a participant's share is as follows. If vss_verify fails, the participant MUST abort the protocol, and the failure should be investigated out of band.",
      "ja": "参加者の取り分を確認する手順は次のとおりです。vss_verify が失敗した場合、参加者はプロトコルを中止しなければならず、失敗は帯域外で調査される必要があります。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- share_i: A tuple of the form (i, sk_i), where i indicates the\n  participant identifier (a NonZeroScalar), and sk_i the\n  participant's secret key, a secret share of the constant term of f,\n  where sk_i is a Scalar.\n- vss_commitment, a VSS commitment to a secret polynomial f, a vector\n  commitment to each of the coefficients in coeffs, where each\n  element of the vector commitment is an Element.\n\nOutputs:\n- True if sk_i is valid, and False otherwise.\n\ndef vss_verify(share_i, vss_commitment)\n  (i, sk_i) = share_i\n  S_i = G.ScalarBaseMult(sk_i)\n  S_i' = G.Identity()\n  for j in range(0, MIN_PARTICIPANTS):\n    S_i' += G.ScalarMult(vss_commitment[j], pow(i, j))\n  return S_i == S_i'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We now define how the Coordinator and participants can derive group info, which is an input into the FROST signing protocol.",
      "ja": "次に、コーディネーターと参加者が FROST 署名プロトコルへの入力であるグループ情報を取得する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Inputs:\n- MAX_PARTICIPANTS, the number of shares to generate, an integer.\n- MIN_PARTICIPANTS, the threshold of the secret sharing scheme,\n  an integer.\n- vss_commitment, a VSS commitment to a secret polynomial f, a vector\n  commitment to each of the coefficients in coeffs, where each\n  element of the vector commitment is an Element.\n\nOutputs:\n- PK, the public key representing the group, an Element.\n- participant_public_keys, a list of MAX_PARTICIPANTS public keys\n  PK_i for i=1,...,MAX_PARTICIPANTS, where each PK_i is the public\n  key, an Element, for participant i.\n\ndef derive_group_info(MAX_PARTICIPANTS, MIN_PARTICIPANTS,\n vss_commitment):\n  PK = vss_commitment[0]\n  participant_public_keys = []\n  for i in range(1, MAX_PARTICIPANTS+1):\n    PK_i = G.Identity()\n    for j in range(0, MIN_PARTICIPANTS):\n      PK_i += G.ScalarMult(vss_commitment[j], pow(i, j))\n    participant_public_keys.append(PK_i)\n  return PK, participant_public_keys",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix D. Random Scalar Generation",
      "section_title": true,
      "ja": "付録D. ランダムなスカラー生成"
    },
    {
      "indent": 3,
      "text": "Two popular algorithms for generating a random integer uniformly distributed in the range [0, G.Order() -1] are described in the sections that follow.",
      "ja": "[0, G.Order() -1] の範囲に均一に分布するランダムな整数を生成するための 2 つの一般的なアルゴリズムについて、以降のセクションで説明します。"
    },
    {
      "indent": 0,
      "text": "D.1. Rejection Sampling",
      "section_title": true,
      "ja": "D.1. 拒否サンプリング"
    },
    {
      "indent": 3,
      "text": "Generate a random byte array with Ns bytes and attempt to map to a Scalar by calling DeserializeScalar in constant time. If it succeeds, return the result. If it fails, try again with another random byte array, until the procedure succeeds. Failure to implement DeserializeScalar in constant time can leak information about the underlying corresponding Scalar.",
      "ja": "Ns バイトのランダムなバイト配列を生成し、定数時間で DeserializeScalar を呼び出して Scalar へのマッピングを試みます。成功した場合は結果を返します。失敗した場合は、手順が成功するまで、別のランダムなバイト配列を使用して再試行します。DeserializeScalar を一定時間内に実装できないと、基礎となる対応する Scalar に関する情報が漏洩する可能性があります。"
    },
    {
      "indent": 3,
      "text": "As an optimization, if the group order is very close to a power of 2, it is acceptable to omit the rejection test completely. In particular, if the group order is p and there is an integer b such that |p - 2^b| is less than 2^(b/2), then RandomScalar can simply return a uniformly random integer of at most b bits.",
      "ja": "最適化として、グループ次数が 2 の累乗に非常に近い場合は、棄却テストを完全に省略しても問題ありません。特に、グループ次数が p で、|p - 2^b| のような整数 b がある場合、が 2^(b/2) 未満の場合、RandomScalar は単純に最大 b ビットの一様にランダムな整数を返すことができます。"
    },
    {
      "indent": 0,
      "text": "D.2. Wide Reduction",
      "section_title": true,
      "ja": "D.2. ワイドリダクション"
    },
    {
      "indent": 3,
      "text": "Generate a random byte array with l = ceil(((3 * ceil(log2(G.Order()))) / 2) / 8) bytes and interpret it as an integer; reduce the integer modulo G.Order() and return the result. See Section 5 of [HASH-TO-CURVE] for the underlying derivation of l.",
      "ja": "l = ceil(((3 * ceil(log2(G.Order()))) / 2) / 8) バイトのランダムなバイト配列を生成し、それを整数として解釈します。G.Order() を法とする整数を減算し、結果を返します。l の基礎となる導出については、[HASH-TO-CURVE] のセクション 5 を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Test Vectors",
      "section_title": true,
      "ja": "付録E. テストベクター"
    },
    {
      "indent": 3,
      "text": "This section contains test vectors for all ciphersuites listed in Section 6. All Element and Scalar values are represented in serialized form and encoded in hexadecimal strings. Signatures are represented as the concatenation of their constituent parts. The input message to be signed is also encoded as a hexadecimal string.",
      "ja": "このセクションには、セクション 6 にリストされているすべての暗号スイートのテスト ベクトルが含まれています。すべての要素値とスカラー値はシリアル化された形式で表され、16 進文字列でエンコードされます。署名は、その構成部分の連結として表現されます。署名される入力メッセージも 16 進文字列としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Each test vector consists of the following information.",
      "ja": "各テスト ベクトルは次の情報で構成されます。"
    },
    {
      "indent": 6,
      "text": "* Configuration. This lists the fixed parameters for the particular instantiation of FROST, including MAX_PARTICIPANTS, MIN_PARTICIPANTS, and NUM_PARTICIPANTS.",
      "ja": "* 構成。これには、MAX_PARTICIPANTS、MIN_PARTICIPANTS、NUM_PARTICIPANTS など、FROST の特定のインスタンス化の固定パラメーターがリストされます。"
    },
    {
      "indent": 6,
      "text": "* Group input parameters. This lists the group secret key and shared public key, generated by a trusted dealer as described in Appendix C, as well as the input message to be signed. The randomly generated coefficients produced by the trusted dealer to share the group signing secret are also listed. Each coefficient is identified by its index, e.g., share_polynomial_coefficients[1] is the coefficient of the first term in the polynomial. Note that the 0-th coefficient is omitted, as this is equal to the group secret key. All values are encoded as hexadecimal strings.",
      "ja": "* グループ入力パラメータ。これには、付録 C で説明されているように信頼できるディーラーによって生成されたグループ秘密鍵と共有公開鍵、および署名される入力メッセージがリストされます。グループ署名秘密を共有するために信頼できるディーラーによって生成されたランダムに生成された係数もリストされます。各係数はインデックスによって識別されます。たとえば、share_polynomial_coefficients[1] は多項式の最初の項の係数です。なお、0番目の係数はグループ秘密鍵と等しいため省略されています。すべての値は 16 進文字列としてエンコードされます。"
    },
    {
      "indent": 6,
      "text": "* Signer input parameters. This lists the signing key share for each of the NUM_PARTICIPANTS participants.",
      "ja": "* 署名者の入力パラメータ。これには、NUM_PARTICIPANTS 人の各参加者の署名キーの共有がリストされます。"
    },
    {
      "indent": 6,
      "text": "* Round one parameters and outputs. This lists the NUM_PARTICIPANTS participants engaged in the protocol, identified by their NonZeroScalar identifier, and the following for each participant: the hiding and binding commitment values produced in Section 5.1; the randomness values used to derive the commitment nonces in nonce_generate; the resulting group binding factor input computed in part from the group commitment list encoded as described in Section 4.3; and the group binding factor as computed in Section 5.2.",
      "ja": "* パラメーターと出力を丸めます。これには、プロトコルに参加している NUM_PARTICIPANTS 人の参加者 (NonZeroScalar 識別子によって識別される) と、各参加者の以下がリストされます。セクション 5.1 で生成された非表示およびバインディングのコミットメント値。nonce_generate でコミットメント nonce を導出するために使用されるランダム値。セクション 4.3 で説明されているようにエンコードされたグループコミットメントリストから部分的に計算された結果のグループ結合因子入力。およびセクション 5.2 で計算されたグループ結合係数。"
    },
    {
      "indent": 6,
      "text": "* Round two parameters and outputs. This lists the NUM_PARTICIPANTS participants engaged in the protocol, identified by their NonZeroScalar identifier, along with their corresponding output signature share as produced in Section 5.2.",
      "ja": "* 2 つのパラメーターと出力を丸めます。これには、プロトコルに参加している NUM_PARTICIPANTS 人の参加者 (NonZeroScalar 識別子によって識別される) が、セクション 5.2 で生成された対応する出力署名共有とともにリストされます。"
    },
    {
      "indent": 6,
      "text": "* Final output. This lists the aggregate signature as produced in Section 5.3.",
      "ja": "* 最終出力。これは、セクション 5.3 で生成された集約署名をリストします。"
    },
    {
      "indent": 0,
      "text": "E.1. FROST(Ed25519, SHA-512)",
      "section_title": true,
      "ja": "E.1. フロスト(Ed25519、SHA-512)"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 7b1c33d3f5291d85de664833beb1ad469f7fb6025a0ec78b3a7\n90c6e13a98304\ngroup_public_key: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3faf66040\nd380fb9738673\nmessage: 74657374\nshare_polynomial_coefficients[1]: 178199860edd8c62f5212ee91eff1295d0d\n670ab4ed4506866bae57e7030b204\n\n// Signer input parameters\nP1 participant_share: 929dcc590407aae7d388761cddb0c0db6f5627aea8e217f\n4a033f2ec83d93509\nP2 participant_share: a91e66e012e4364ac9aaa405fcafd370402d9859f7b6685\nc07eed76bf409e80d\nP3 participant_share: d3cb090a075eb154e82fdb4b3cb507f110040905468bb9c\n46da8bdea643a9a02\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: 0fd2e39e111cdc266f6c0f4d0fd45c947761f1f5d\n3cb583dfcb9bbaf8d4c9fec\nP1 binding_nonce_randomness: 69cd85f631d5f7f2721ed5e40519b1366f340a87\nc2f6856363dbdcda348a7501\nP1 hiding_nonce: 812d6104142944d5a55924de6d49940956206909f2acaeedecda\n2b726e630407\nP1 binding_nonce: b1110165fc2334149750b28dd813a39244f315cff14d4e89e61\n42f262ed83301\nP1 hiding_nonce_commitment: b5aa8ab305882a6fc69cbee9327e5a45e54c08af6\n1ae77cb8207be3d2ce13de3\nP1 binding_nonce_commitment: 67e98ab55aa310c3120418e5050c9cf76cf387cb\n20ac9e4b6fdb6f82a469f932\nP1 binding_factor_input: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3f\naf66040d380fb9738673504df914fa965023fb75c25ded4bb260f417de6d32e5c442c\n6ba313791cc9a4948d6273e8d3511f93348ea7a708a9b862bc73ba2a79cfdfe07729a\n193751cbc973af46d8ac3440e518d4ce440a0e7d4ad5f62ca8940f32de6d8dc00fc12\nc660b817d587d82f856d277ce6473cae6d2f5763f7da2e8b4d799a3f3e725d4522ec7\n0100000000000000000000000000000000000000000000000000000000000000\nP1 binding_factor: f2cb9d7dd9beff688da6fcc83fa89046b3479417f47f55600b\n106760eb3b5603\nP3 hiding_nonce_randomness: 86d64a260059e495d0fb4fcc17ea3da7452391baa\n494d4b00321098ed2a0062f\nP3 binding_nonce_randomness: 13e6b25afb2eba51716a9a7d44130c0dbae0004a\n9ef8d7b5550c8a0e07c61775\nP3 hiding_nonce: c256de65476204095ebdc01bd11dc10e57b36bc96284595b8215\n222374f99c0e\nP3 binding_nonce: 243d71944d929063bc51205714ae3c2218bd3451d0214dfb5ae\nec2a90c35180d\nP3 hiding_nonce_commitment: cfbdb165bd8aad6eb79deb8d287bcc0ab6658ae57\nfdcc98ed12c0669e90aec91\nP3 binding_nonce_commitment: 7487bc41a6e712eea2f2af24681b58b1cf1da278\nea11fe4e8b78398965f13552\nP3 binding_factor_input: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3f\naf66040d380fb9738673504df914fa965023fb75c25ded4bb260f417de6d32e5c442c\n6ba313791cc9a4948d6273e8d3511f93348ea7a708a9b862bc73ba2a79cfdfe07729a\n193751cbc973af46d8ac3440e518d4ce440a0e7d4ad5f62ca8940f32de6d8dc00fc12\nc660b817d587d82f856d277ce6473cae6d2f5763f7da2e8b4d799a3f3e725d4522ec7\n0300000000000000000000000000000000000000000000000000000000000000\nP3 binding_factor: b087686bf35a13f3dc78e780a34b0fe8a77fef1b9938c563f5\n573d71d8d7890f\n\n// Signer round two outputs\nP1 sig_share: 001719ab5a53ee1a12095cd088fd149702c0720ce5fd2f29dbecf24\nb7281b603\nP3 sig_share: bd86125de990acc5e1f13781d8e32c03a9bbd4c53539bbc106058bf\nd14326007\n\nsig: 36282629c383bb820a88b71cae937d41f2f2adfcc3d02e55507e2fb9e2dd3cbe\nbd9d2b0844e49ae0f3fa935161e1419aab7b47d21a37ebeae1f17d4987b3160b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.2. FROST(Ed448, SHAKE256)",
      "section_title": true,
      "ja": "E.2. フロスト(Ed448、SHAKE256)"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 6298e1eef3c379392caaed061ed8a31033c9e9e3420726f23b4\n04158a401cd9df24632adfe6b418dc942d8a091817dd8bd70e1c72ba52f3c00\ngroup_public_key: 3832f82fda00ff5365b0376df705675b63d2a93c24c6e81d408\n01ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b000\nmessage: 74657374\nshare_polynomial_coefficients[1]: dbd7a514f7a731976620f0436bd135fe8dd\ndc3fadd6e0d13dbd58a1981e587d377d48e0b7ce4e0092967c5e85884d0275a7a740b\n6abdcd0500\n\n// Signer input parameters\nP1 participant_share: 4a2b2f5858a932ad3d3b18bd16e76ced3070d72fd79ae44\n02df201f525e754716a1bc1b87a502297f2a99d89ea054e0018eb55d39562fd0100\nP2 participant_share: 2503d56c4f516444a45b080182b8a2ebbe4d9b2ab509f25\n308c88c0ea7ccdc44e2ef4fc4f63403a11b116372438a1e287265cadeff1fcb0700\nP3 participant_share: 00db7a8146f995db0a7cf844ed89d8e94c2b5f259378ff6\n6e39d172828b264185ac4decf7219e4aa4478285b9c0eef4fccdf3eea69dd980d00\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: 9cda90c98863ef3141b75f09375757286b4bc323d\nd61aeb45c07de45e4937bbd\nP1 binding_nonce_randomness: 781bf4881ffe1aa06f9341a747179f07a49745f8\ncd37d4696f226aa065683c0a\nP1 hiding_nonce: f922beb51a5ac88d1e862278d89e12c05263b945147db04b9566\nacb2b5b0f7422ccea4f9286f4f80e6b646e72143eeaecc0e5988f8b2b93100\nP1 binding_nonce: 1890f16a120cdeac092df29955a29c7cf29c13f6f7be60e63d6\n3f3824f2d37e9c3a002dfefc232972dc08658a8c37c3ec06a0c5dc146150500\nP1 hiding_nonce_commitment: 3518c2246c874569e54ab254cb1da666ca30f7879\n605cc43b4d2c47a521f8b5716080ab723d3a0cd04b7e41f3cc1d3031c94ccf3829b23\nfe80\nP1 binding_nonce_commitment: 11b3d5220c57d02057497de3c4eebab384900206\n592d877059b0a5f1d5250d002682f0e22dff096c46bb81b46d60fcfe7752ed47cea76\nc3900\nP1 binding_factor_input: 3832f82fda00ff5365b0376df705675b63d2a93c24c6\ne81d40801ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b00\n0e9a0f30b97fe77ef751b08d4e252a3719ae9135e7f7926f7e3b7dd6656b27089ca35\n4997fe5a633aa0946c89f022462e7e9d50fd6ef313f72d956ea4571089427daa1862f\n623a41625177d91e4a8f350ce9c8bd3bc7c766515dc1dd3a0eab93777526b616cccb1\n48fe1e5992dc1ae705c8ba2f97ca8983328d41d375ed1e5fde5c9d672121c9e8f177f\n4a1a9b2575961531b33f054451363c8f27618382cd66ce14ad93b68dac6a09f5edcbc\ncc813906b3fc50b8fef1cc09757b06646f38ceed1674cd6ced28a59c93851b325c6a9\nef6a4b3b88860b7138ee246034561c7460db0b3fae501000000000000000000000000\n000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000\nP1 binding_factor: 71966390dfdbed73cf9b79486f3b70e23b243e6c40638fb559\n98642a60109daecbfcb879eed9fe7dbbed8d9e47317715a5740f772173342e00\nP3 hiding_nonce_randomness: b3adf97ceea770e703ab295babf311d77e956a20d\n3452b4b3344aa89a828e6df\nP3 binding_nonce_randomness: 81dbe7742b0920930299197322b255734e52bbb9\n1f50cfe8ce689f56fadbce31\nP3 hiding_nonce: ccb5c1e82f23e0a4b966b824dbc7b0ef1cc5f56eeac2a4126e2b\n2143c5f3a4d890c52d27803abcf94927faf3fc405c0b2123a57a93cefa3b00\nP3 binding_nonce: e089df9bf311cf711e2a24ea27af53e07b846d09692fe11035a\n1112f04d8b7462a62f34d8c01493a22b57a1cbf1f0a46c77d64d46449a90100\nP3 hiding_nonce_commitment: 1254546d7d104c04e4fbcf29e05747e2edd392f67\n87d05a6216f3713ef859efe573d180d291e48411e5e3006e9f90ee986ccc26b7a4249\n0b80\nP3 binding_nonce_commitment: 3ef0cec20be15e56b3ddcb6f7b956fca0c8f7199\n0f45316b537b4f64c5e8763e6629d7262ff7cd0235d0781f23be97bf8fa8817643ea1\n9cd00\nP3 binding_factor_input: 3832f82fda00ff5365b0376df705675b63d2a93c24c6\ne81d40801ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b00\n0e9a0f30b97fe77ef751b08d4e252a3719ae9135e7f7926f7e3b7dd6656b27089ca35\n4997fe5a633aa0946c89f022462e7e9d50fd6ef313f72d956ea4571089427daa1862f\n623a41625177d91e4a8f350ce9c8bd3bc7c766515dc1dd3a0eab93777526b616cccb1\n48fe1e5992dc1ae705c8ba2f97ca8983328d41d375ed1e5fde5c9d672121c9e8f177f\n4a1a9b2575961531b33f054451363c8f27618382cd66ce14ad93b68dac6a09f5edcbc\ncc813906b3fc50b8fef1cc09757b06646f38ceed1674cd6ced28a59c93851b325c6a9\nef6a4b3b88860b7138ee246034561c7460db0b3fae503000000000000000000000000\n000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000\nP3 binding_factor: 236a6f7239ac2019334bad21323ec93bef2fead37bd5511435\n6419f3fc1fb59f797f44079f28b1a64f51dd0a113f90f2c3a1c27d2faa4f1300\n\n// Signer round two outputs\nP1 sig_share: e1eb9bfbef792776b7103891032788406c070c5c315e3bf5d64acd4\n6ea8855e85b53146150a09149665cbfec71626810b575e6f4dbe9ba3700\nP3 sig_share: 815434eb0b9f9242d54b8baf2141fe28976cabe5f441ccfcd5ee7cd\nb4b52185b02b99e6de28e2ab086c7764068c5a01b5300986b9f084f3e00\n\nsig: cd642cba59c449dad8e896a78a60e8edfcbd9040df524370891ff8077d47ce72\n1d683874483795f0d85efcbd642c4510614328605a19c6ed806ffb773b6956419537c\ndfdb2b2a51948733de192dcc4b82dc31580a536db6d435e0cb3ce322fbcf9ec23362d\nda27092c08767e607bf2093600",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.3. FROST(ristretto255, SHA-512)",
      "section_title": true,
      "ja": "E.3. FROST(リストレット255、SHA-512)"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 1b25a55e463cfd15cf14a5d3acc3d15053f08da49c8afcf3ab2\n65f2ebc4f970b\ngroup_public_key: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3dd9c3c0d\n05083c7254f57\nmessage: 74657374\nshare_polynomial_coefficients[1]: 410f8b744b19325891d73736923525a4f59\n6c805d060dfb9c98009d34e3fec02\n\n// Signer input parameters\nP1 participant_share: 5c3430d391552f6e60ecdc093ff9f6f4488756aa6cebdba\nd75a768010b8f830e\nP2 participant_share: b06fc5eac20b4f6e1b271d9df2343d843e1e1fb03c4cbb6\n73f2872d459ce6f01\nP3 participant_share: f17e505f0e2581c6acfe54d3846a622834b5e7b50cad9a2\n109a97ba7a80d5c04\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: f595a133b4d95c6e1f79887220c8b275ce6277e7f\n68a6640e1e7140f9be2fb5c\nP1 binding_nonce_randomness: 34dd1001360e3513cb37bebfabe7be4a32c5bb91\nba19fbd4360d039111f0fbdc\nP1 hiding_nonce: 214f2cabb86ed71427ea7ad4283b0fae26b6746c801ce824b83c\neb2b99278c03\nP1 binding_nonce: c9b8f5e16770d15603f744f8694c44e335e8faef00dad182b8d\n7a34a62552f0c\nP1 hiding_nonce_commitment: 965def4d0958398391fc06d8c2d72932608b1e625\n5226de4fb8d972dac15fd57\nP1 binding_nonce_commitment: ec5170920660820007ae9e1d363936659ef622f9\n9879898db86e5bf1d5bf2a14\nP1 binding_factor_input: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3d\nd9c3c0d05083c7254f572889dde2854e26377a16caf77dfee5f6be8fe5b4c80318da8\n4698a4161021b033911db5ef8205362701bc9ecd983027814abee94f46d094943a2f4\nb79a6e4d4603e52c435d8344554942a0a472d8ad84320585b8da3ae5b9ce31cd1903f\n795c1af66de22af1a45f652cd05ee446b1b4091aaccc91e2471cd18a85a659cecd11f\n0100000000000000000000000000000000000000000000000000000000000000\nP1 binding_factor: 8967fd70fa06a58e5912603317fa94c77626395a695a0e4e4e\nfc4476662eba0c\nP3 hiding_nonce_randomness: daa0cf42a32617786d390e0c7edfbf2efbd428037\n069357b5173ae61d6dd5d5e\nP3 binding_nonce_randomness: b4387e72b2e4108ce4168931cc2c7fcce5f345a5\n297368952c18b5fc8473f050\nP3 hiding_nonce: 3f7927872b0f9051dd98dd73eb2b91494173bbe0feb65a3e7e58\nd3e2318fa40f\nP3 binding_nonce: ffd79445fb8030f0a3ddd3861aa4b42b618759282bfe24f1f93\n04c7009728305\nP3 hiding_nonce_commitment: 480e06e3de182bf83489c45d7441879932fd7b434\na26af41455756264fbd5d6e\nP3 binding_nonce_commitment: 3064746dfd3c1862ef58fc68c706da287dd92506\n6865ceacc816b3a28c7b363b\nP3 binding_factor_input: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3d\nd9c3c0d05083c7254f572889dde2854e26377a16caf77dfee5f6be8fe5b4c80318da8\n4698a4161021b033911db5ef8205362701bc9ecd983027814abee94f46d094943a2f4\nb79a6e4d4603e52c435d8344554942a0a472d8ad84320585b8da3ae5b9ce31cd1903f\n795c1af66de22af1a45f652cd05ee446b1b4091aaccc91e2471cd18a85a659cecd11f\n0300000000000000000000000000000000000000000000000000000000000000\nP3 binding_factor: f2c1bb7c33a10511158c2f1766a4a5fadf9f86f2a92692ed33\n3128277cc31006\n\n// Signer round two outputs\nP1 sig_share: 9285f875923ce7e0c491a592e9ea1865ec1b823ead4854b48c8a462\n87749ee09\nP3 sig_share: 7cb211fe0e3d59d25db6e36b3fb32344794139602a7b24f1ae0dc4e\n26ad7b908\n\nsig: fc45655fbc66bbffad654ea4ce5fdae253a49a64ace25d9adb62010dd9fb2555\n2164141787162e5b4cab915b4aa45d94655dbb9ed7c378a53b980a0be220a802",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.4. FROST(P-256, SHA-256)",
      "section_title": true,
      "ja": "E.4. フロスト(P-256、SHA-256)"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 8ba9bba2e0fd8c4767154d35a0b7562244a4aaf6f36c8fb8735\nfa48b301bd8de\ngroup_public_key: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99cfbd02b4\ndc00585ec45ab70\nmessage: 74657374\nshare_polynomial_coefficients[1]: 80f25e6c0709353e46bfbe882a11bdbb1f8\n097e46340eb8673b7e14556e6c3a4\n\n// Signer input parameters\nP1 participant_share: 0c9c1a0fe806c184add50bbdcac913dda73e482daf95dcb\n9f35dbb0d8a9f7731\nP2 participant_share: 8d8e787bef0ff6c2f494ca45f4dad198c6bee01212d6c84\n067159c52e1863ad5\nP3 participant_share: 0e80d6e8f6192c003b5488ce1eec8f5429587d48cf00154\n1e713b2d53c09d928\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: ec4c891c85fee802a9d757a67d1252e7f4e5efb8a\n538991ac18fbd0e06fb6fd3\nP1 binding_nonce_randomness: 9334e29d09061223f69a09421715a347e4e6deba\n77444c8f42b0c833f80f4ef9\nP1 hiding_nonce: 9f0542a5ba879a58f255c09f06da7102ef6a2dec6279700c656d\n58394d8facd4\nP1 binding_nonce: 6513dfe7429aa2fc972c69bb495b27118c45bbc6e654bb9dc9b\ne55385b55c0d7\nP1 hiding_nonce_commitment: 0213b3e6298bf8ad46fd5e9389519a8665d63d98f\n4ec6a1fcca434e809d2d8070e\nP1 binding_nonce_commitment: 02188ff1390bf69374d7b272e454b1878ef10a6b\n6ea3ff36f114b300b4dbd5233b\nP1 binding_factor_input: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99c\nfbd02b4dc00585ec45ab70825371853e974bc30ac5b947b216d70461919666584c70c\n51f9f56f117736c5d178dd0b521ad9c1abe98048419cbdec81504c85e12eb40e3bcb6\nec73d3fc4afd000000000000000000000000000000000000000000000000000000000\n0000001\nP1 binding_factor: 7925f0d4693f204e6e59233e92227c7124664a99739d2c06b8\n1cf64ddf90559e\nP3 hiding_nonce_randomness: c0451c5a0a5480d6c1f860e5db7d655233dca2669\nfd90ff048454b8ce983367b\nP3 binding_nonce_randomness: 2ba5f7793ae700e40e78937a82f407dd35e847e3\n3d1e607b5c7eb6ed2a8ed799\nP3 hiding_nonce: f73444a8972bcda9e506bbca3d2b1c083c10facdf4bb5d47fef7\nc2dc1d9f2a0d\nP3 binding_nonce: 44c6a29075d6e7e4f8b97796205f9e22062e7835141470afe94\n17fd317c1c303\nP3 hiding_nonce_commitment: 033ac9a5fe4a8b57316ba1c34e8a6de453033b750\ne8984924a984eb67a11e73a3f\nP3 binding_nonce_commitment: 03a7a2480ee16199262e648aea3acab628a53e9b\n8c1945078f2ddfbdc98b7df369\nP3 binding_factor_input: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99c\nfbd02b4dc00585ec45ab70825371853e974bc30ac5b947b216d70461919666584c70c\n51f9f56f117736c5d178dd0b521ad9c1abe98048419cbdec81504c85e12eb40e3bcb6\nec73d3fc4afd000000000000000000000000000000000000000000000000000000000\n0000003\nP3 binding_factor: e10d24a8a403723bcb6f9bb4c537f316593683b472f7a89f16\n6630dde11822c4\n\n// Signer round two outputs\nP1 sig_share: 400308eaed7a2ddee02a265abe6a1cfe04d946ee8720768899619cf\nabe7a3aeb\nP3 sig_share: 561da3c179edbb0502d941bb3e3ace3c37d122aaa46fb54499f15f3\na3331de44\n\nsig: 026d8d434874f87bdb7bc0dfd239b2c00639044f9dcb195e9a04426f70bfa4b7\n0d9620acac6767e8e3e3036815fca4eb3a3caa69992b902bcd3352fc34f1ac192f",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.5. FROST(secp256k1, SHA-256)",
      "section_title": true,
      "ja": "E.5. FROST(secp256k1、SHA-256)"
    },
    {
      "indent": 3,
      "text": "// Configuration information\nMAX_PARTICIPANTS: 3\nMIN_PARTICIPANTS: 2\nNUM_PARTICIPANTS: 2\n\n// Group input parameters\nparticipant_list: 1,3\ngroup_secret_key: 0d004150d27c3bf2a42f312683d35fac7394b1e9e318249c1bf\ne7f0795a83114\ngroup_public_key: 02f37c34b66ced1fb51c34a90bdae006901f10625cc06c4f646\n63b0eae87d87b4f\nmessage: 74657374\nshare_polynomial_coefficients[1]: fbf85eadae3058ea14f19148bb72b45e439\n9c0b16028acaf0395c9b03c823579\n\n// Signer input parameters\nP1 participant_share: 08f89ffe80ac94dcb920c26f3f46140bfc7f95b493f8310\nf5fc1ea2b01f4254c\nP2 participant_share: 04f0feac2edcedc6ce1253b7fab8c86b856a797f44d83d8\n2a385554e6e401984\nP3 participant_share: 00e95d59dd0d46b0e303e500b62b7ccb0e555d49f5b849f\n5e748c071da8c0dbc\n\n// Signer round one outputs\nP1 hiding_nonce_randomness: 7ea5ed09af19f6ff21040c07ec2d2adbd35b759da\n5a401d4c99dd26b82391cb2\nP1 binding_nonce_randomness: 47acab018f116020c10cb9b9abdc7ac10aae1b48\nca6e36dc15acb6ec9be5cdc5\nP1 hiding_nonce: 841d3a6450d7580b4da83c8e618414d0f024391f2aeb511d7579\n224420aa81f0\nP1 binding_nonce: 8d2624f532af631377f33cf44b5ac5f849067cae2eacb88680a\n31e77c79b5a80\nP1 hiding_nonce_commitment: 03c699af97d26bb4d3f05232ec5e1938c12f1e6ae\n97643c8f8f11c9820303f1904\nP1 binding_nonce_commitment: 02fa2aaccd51b948c9dc1a325d77226e98a5a3fe\n65fe9ba213761a60123040a45e\nP1 binding_factor_input: 02f37c34b66ced1fb51c34a90bdae006901f10625cc0\n6c4f64663b0eae87d87b4fff9b5210ffbb3c07a73a7c8935be4a8c62cf015f6cf7ade\n6efac09a6513540fc3f5a816aaebc2114a811a415d7a55db7c5cbc1cf27183e79dd9d\nef941b5d4801000000000000000000000000000000000000000000000000000000000\n0000001\nP1 binding_factor: 3e08fe561e075c653cbfd46908a10e7637c70c74f0a77d5fd4\n5d1a750c739ec6\nP3 hiding_nonce_randomness: e6cc56ccbd0502b3f6f831d91e2ebd01c4de0479e\n0191b66895a4ffd9b68d544\nP3 binding_nonce_randomness: 7203d55eb82a5ca0d7d83674541ab55f6e76f1b8\n5391d2c13706a89a064fd5b9\nP3 hiding_nonce: 2b19b13f193f4ce83a399362a90cdc1e0ddcd83e57089a7af0bd\nca71d47869b2\nP3 binding_nonce: 7a443bde83dc63ef52dda354005225ba0e553243402a4705ce2\n8ffaafe0f5b98\nP3 hiding_nonce_commitment: 03077507ba327fc074d2793955ef3410ee3f03b82\nb4cdc2370f71d865beb926ef6\nP3 binding_nonce_commitment: 02ad53031ddfbbacfc5fbda3d3b0c2445c8e3e99\ncbc4ca2db2aa283fa68525b135\nP3 binding_factor_input: 02f37c34b66ced1fb51c34a90bdae006901f10625cc0\n6c4f64663b0eae87d87b4fff9b5210ffbb3c07a73a7c8935be4a8c62cf015f6cf7ade\n6efac09a6513540fc3f5a816aaebc2114a811a415d7a55db7c5cbc1cf27183e79dd9d\nef941b5d4801000000000000000000000000000000000000000000000000000000000\n0000003\nP3 binding_factor: 93f79041bb3fd266105be251adaeb5fd7f8b104fb554a4ba9a\n0becea48ddbfd7\n\n// Signer round two outputs\nP1 sig_share: c4fce1775a1e141fb579944166eab0d65eefe7b98d480a569bbbfcb\n14f91c197\nP3 sig_share: 0160fd0d388932f4826d2ebcd6b9eaba734f7c71cf25b4279a4ca25\n81e47b18d\n\nsig: 0205b6d04d3774c8929413e3c76024d54149c372d57aae62574ed74319b5ea14\nd0c65dde8492a7471437e6c2fe3da49b90d23f642b5c6dbe7e36089f096dd97324",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document was improved based on input and contributions by the Zcash Foundation engineering team. In addition, the authors of this document would like to thank Isis Lovecruft, Alden Torres, T. Wilson-Brown, and Conrado Gouvea for their input and contributions.",
      "ja": "このドキュメントは、Zcash Foundation エンジニアリング チームによる入力と貢献に基づいて改良されました。さらに、この文書の著者は、Isis Lovecruft 氏、Alden Torres 氏、T. Wilson-Brown 氏、および Conrado Gouvea 氏の意見と貢献に感謝の意を表します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Deirdre Connolly\nZcash Foundation\nEmail: durumcrustulum@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chelsea Komlo\nUniversity of Waterloo, Zcash Foundation\nEmail: ckomlo@uwaterloo.ca",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ian Goldberg\nUniversity of Waterloo\nEmail: iang@uwaterloo.ca",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood\nCloudflare\nEmail: caw@heapingbits.net",
      "raw": true,
      "ja": ""
    }
  ]
}