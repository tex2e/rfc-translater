{
  "title": {
    "text": "RFC 9729 - The Concealed HTTP Authentication Scheme",
    "ja": "RFC 9729 - 隠されたHTTP認証スキーム"
  },
  "number": 9729,
  "created_at": "2025-02-16 23:24:06.731061+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       D. Schinazi\nRequest for Comments: 9729                                    Google LLC\nCategory: Standards Track                                      D. Oliver\nISSN: 2070-1721                                         Guardian Project\n                                                              J. Hoyland\n                                                         Cloudflare Inc.\n                                                           February 2025",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "The Concealed HTTP Authentication Scheme",
      "section_title": true,
      "ja": "隠されたHTTP認証スキーム"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Most HTTP authentication schemes are probeable in the sense that it is possible for an unauthenticated client to probe whether an origin serves resources that require authentication. It is possible for an origin to hide the fact that it requires authentication by not generating Unauthorized status codes; however, that only works with non-cryptographic authentication schemes: cryptographic signatures require a fresh nonce to be signed. Prior to this document, there was no existing way for the origin to share such a nonce without exposing the fact that it serves resources that require authentication. This document defines a new non-probeable cryptographic authentication scheme.",
      "ja": "ほとんどのHTTP認証スキームは、オリジンが認証を必要とするリソースを提供するかどうかを証明していないクライアントがプローブすることが可能であるという意味で進められます。不正なステータスコードを生成しないことにより、認証が必要であるという事実を非表示にすることができます。ただし、それは非暗号化認証スキームでのみ機能します。暗号化署名には、新たな非CEが署名する必要があります。このドキュメントの前に、認証を必要とするリソースを提供するという事実を公開せずに、そのようなノンセを共有する既存の方法はありませんでした。このドキュメントでは、新しい非難可能な暗号化認証スキームを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9729.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9729で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2025 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2025 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Conventions and Definitions\n2.  The Concealed HTTP Authentication Scheme\n3.  Client Handling\n  3.1.  Key Exporter Context\n    3.1.1.  Public Key Encoding\n  3.2.  Key Exporter Output\n  3.3.  Signature Computation\n4.  Authentication Parameters\n  4.1.  The k Parameter\n  4.2.  The a Parameter\n  4.3.  The p Parameter\n  4.4.  The s Parameter\n  4.5.  The v Parameter\n5.  Example\n6.  Server Handling\n  6.1.  Frontend Handling\n  6.2.  Communication Between Frontend and Backend\n  6.3.  Backend Handling\n  6.4.  Non-Probeable Server Handling\n7.  Requirements on TLS Usage\n8.  Security Considerations\n9.  IANA Considerations\n  9.1.  HTTP Authentication Schemes Registry\n  9.2.  TLS Keying Material Exporter Labels\n  9.3.  HTTP Field Name\n10. References\n  10.1.  Normative References\n  10.2.  Informative References\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP authentication schemes (see Section 11 of [HTTP]) allow origins to restrict access for some resources to only authenticated requests. While these schemes commonly involve a challenge where the origin asks the client to provide authentication information, it is possible for clients to send such information unprompted. This is particularly useful in cases where an origin wants to offer a service or capability only to \"those who know\", while all others are given no indication the service or capability exists. Such designs rely on an externally defined mechanism by which keys are distributed. For example, a company might offer remote employee access to company services directly via its website using their employee credentials or offer access to limited special capabilities for specific employees while making discovering (or probing for) such capabilities difficult. As another example, members of less well-defined communities might use more ephemeral keys to acquire access to geography- or capability-specific resources, as issued by an entity whose user base is larger than the available resources can support (by having that entity metering the availability of keys temporally or geographically).",
      "ja": "HTTP認証スキーム（[http]のセクション11を参照）により、Originsは、一部のリソースのアクセスを認証されたリクエストのみに制限できます。これらのスキームには一般に、オリジンがクライアントに認証情報を提供するよう求める課題が含まれますが、クライアントはそのような情報を採用されていない情報を送信することが可能です。これは、オリジンが「知っている人」にのみサービスまたは機能を提供したい場合に特に役立ちますが、他のすべてのものはサービスまたは機能が存在することを示していません。このような設計は、キーが分布する外部から定義されたメカニズムに依存しています。たとえば、企業は、従業員の資格を使用してウェブサイトを介して企業サービスへの遠隔地に直接アクセスするか、特定の従業員に限られた特別な機能へのアクセスを提供しながら、そのような機能を発見（または調査する）ことが困難です。別の例として、明確に定義されていないコミュニティのメンバーは、利用可能なリソースがサポートできるよりも大きいエンティティによって発行されたエンティティによって発行された地理的または能力固有のリソースへのアクセスを獲得するために、より短命キーを使用する可能性があります（そのエンティティメータリングを使用することにより一時的または地理的にキーの可用性）。"
    },
    {
      "indent": 3,
      "text": "While digital-signature-based HTTP authentication schemes already exist (e.g., [HOBA]), they rely on the origin explicitly sending a fresh challenge to the client, to ensure that the signature input is fresh. That makes the origin probeable as it sends the challenge to unauthenticated clients. This document defines a new signature-based authentication scheme that is not probeable.",
      "ja": "デジタル署名ベースのHTTP認証スキームはすでに存在していますが（例：[HOBA]）、署名入力が新鮮であることを確認するために、クライアントに新たな課題を明示的に送信する原点に依存しています。これにより、オリジンは、認定されていないクライアントに課題を送信するため、進められます。このドキュメントでは、調査されていない新しい署名ベースの認証スキームを定義します。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions and Definitions",
      "section_title": true,
      "ja": "1.1. 慣習と定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "このドキュメント内のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、ここに示すようにすべて大文字で表示されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses the notation from Section 1.3 of [QUIC].",
      "ja": "このドキュメントでは、[quic]のセクション1.3の表記を使用しています。"
    },
    {
      "indent": 3,
      "text": "Various examples in this document contain long lines that may be folded, as described in [RFC8792].",
      "ja": "このドキュメントのさまざまな例には、[RFC8792]で説明されているように、折り畳まれる可能性のある長い行が含まれています。"
    },
    {
      "indent": 0,
      "text": "2. The Concealed HTTP Authentication Scheme",
      "section_title": true,
      "ja": "2. 隠されたHTTP認証スキーム"
    },
    {
      "indent": 3,
      "text": "This document defines the \"Concealed\" HTTP authentication scheme. It uses asymmetric cryptography. Clients possess a key ID and a public/ private key pair, and origin servers maintain a mapping of authorized key IDs to associated public keys.",
      "ja": "このドキュメントは、「隠された」HTTP認証スキームを定義します。非対称の暗号化を使用します。クライアントはキーIDとパブリック/プライベートキーペアを所有しており、Origin Serversは、関連するパブリックキーへの承認されたキーIDのマッピングを維持しています。"
    },
    {
      "indent": 3,
      "text": "The client uses a TLS keying material exporter to generate data to be signed (see Section 3) then sends the signature using the Authorization (or Proxy-Authorization) header field (see Section 11 of [HTTP]). The signature and additional information are exchanged using authentication parameters (see Section 4). Once the server receives these, it can check whether the signature validates against an entry in its database of known keys. The server can then use the validation result to influence its response to the client, for example, by restricting access to certain resources.",
      "ja": "クライアントは、TLSキーイングマテリアルエクスポーターを使用して署名するデータを生成し（セクション3を参照）、承認（またはプロキシ承認）ヘッダーフィールドを使用して署名を送信します（[http]のセクション11を参照）。署名および追加情報は、認証パラメーターを使用して交換されます（セクション4を参照）。サーバーがこれらを受信すると、既知のキーのデータベースのエントリに対して署名が検証されるかどうかを確認できます。サーバーは、特定のリソースへのアクセスを制限することにより、検証結果を使用してクライアントへの応答に影響を与えることができます。"
    },
    {
      "indent": 0,
      "text": "3. Client Handling",
      "section_title": true,
      "ja": "3. クライアントの取り扱い"
    },
    {
      "indent": 3,
      "text": "When a client wishes to use the Concealed HTTP authentication scheme with a request, it SHALL compute the authentication proof using a TLS keying material exporter with the following parameters:",
      "ja": "クライアントがリクエストで隠されたHTTP認証スキームを使用したい場合、次のパラメーターを使用してTLSキーイング材料輸出国を使用して認証証明を計算するものとします。"
    },
    {
      "indent": 6,
      "text": "* The label is set to \"EXPORTER-HTTP-Concealed-Authentication\".",
      "ja": "* ラベルは「Exporter-HTTP-Concealed-authentication」に設定されています。"
    },
    {
      "indent": 6,
      "text": "* The context is set to the structure described in Section 3.1.",
      "ja": "* コンテキストは、セクション3.1で説明されている構造に設定されます。"
    },
    {
      "indent": 6,
      "text": "* The exporter output length is set to 48 bytes (see Section 3.2).",
      "ja": "* 輸出者出力の長さは48バイトに設定されています（セクション3.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that TLS 1.3 keying material exporters are defined in Section 7.5 of [TLS], while TLS 1.2 keying material exporters are defined in [KEY-EXPORT].",
      "ja": "TLS 1.3キーイングマテリアル輸出業者は[TLS]のセクション7.5で定義されており、TLS 1.2キーイング材料輸出業者は[key-export]で定義されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1. Key Exporter Context",
      "section_title": true,
      "ja": "3.1. 主要な輸出国のコンテキスト"
    },
    {
      "indent": 3,
      "text": "The TLS key exporter context is described in Figure 1, using the notation from Section 1.3 of [QUIC]:",
      "ja": "TLSキーエクスポートのコンテキストは、[QUIC]のセクション1.3の表記法を使用して、図1で説明されています。"
    },
    {
      "indent": 5,
      "text": "Signature Algorithm (16),\nKey ID Length (i),\nKey ID (..),\nPublic Key Length (i),\nPublic Key (..),\nScheme Length (i),\nScheme (..),\nHost Length (i),\nHost (..),\nPort (16),\nRealm Length (i),\nRealm (..),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 1: Key Exporter Context Format",
      "ja": "図1：キーエクスポートコンテキスト形式"
    },
    {
      "indent": 3,
      "text": "The key exporter context contains the following fields:",
      "ja": "主要な輸出国のコンテキストには、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "Signature Algorithm:",
      "ja": "署名アルゴリズム："
    },
    {
      "indent": 12,
      "text": "The signature scheme sent in the s Parameter (see Section 4.4).",
      "ja": "Sパラメーターで送信された署名スキーム（セクション4.4を参照）。"
    },
    {
      "indent": 3,
      "text": "Key ID:",
      "ja": "キーID："
    },
    {
      "indent": 12,
      "text": "The key ID sent in the k Parameter (see Section 4.1).",
      "ja": "Kパラメーターに送信されたキーID（セクション4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Public Key:",
      "ja": "公開鍵："
    },
    {
      "indent": 12,
      "text": "The public key used by the server to validate the signature provided by the client. Its encoding is described in Section 3.1.1.",
      "ja": "サーバーがクライアントが提供する署名を検証するために使用される公開キー。そのエンコードは、セクション3.1.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "Scheme:",
      "ja": "スキーム："
    },
    {
      "indent": 12,
      "text": "The scheme for this request, encoded using the format of the scheme portion of a URI as defined in Section 3.1 of [URI].",
      "ja": "[URI]のセクション3.1で定義されているように、URIのスキーム部分の形式を使用してエンコードされたこの要求のスキーム。"
    },
    {
      "indent": 3,
      "text": "Host:",
      "ja": "ホスト："
    },
    {
      "indent": 12,
      "text": "The host for this request, encoded using the format of the host portion of a URI as defined in Section 3.2.2 of [URI].",
      "ja": "[URI]のセクション3.2.2で定義されているように、URIのホスト部分の形式を使用してエンコードされたこのリクエストのホスト。"
    },
    {
      "indent": 3,
      "text": "Port:",
      "ja": "ポート："
    },
    {
      "indent": 12,
      "text": "The port for this request, encoded in network byte order. Note that the port is either included in the URI or is the default port for the scheme in use; see Section 3.2.3 of [URI].",
      "ja": "ネットワークバイトの順序でエンコードされたこのリクエストのポート。ポートはURIに含まれているか、使用中のスキームのデフォルトポートであることに注意してください。[URI]のセクション3.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Realm:",
      "ja": "レルム："
    },
    {
      "indent": 12,
      "text": "The realm of authentication that is sent in the realm authentication parameter (see Section 11.5 of [HTTP]). If the realm authentication parameter is not present, this SHALL be empty. This document does not define a means for the origin to communicate a realm to the client. If a client is not configured to use a specific realm, it SHALL use an empty realm and SHALL NOT send the realm authentication parameter.",
      "ja": "レルム認証パラメーターで送信される認証の領域（[HTTP]のセクション11.5を参照）。レルム認証パラメーターが存在しない場合、これは空になります。このドキュメントは、オリジンがクライアントに領域を通信する手段を定義するものではありません。クライアントが特定のレルを使用するように構成されていない場合、空のレルムを使用し、レルム認証パラメーターを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "The Signature Algorithm and Port fields are encoded as unsigned 16-bit integers in network byte order. The Key ID, Public Key, Scheme, Host, and Realm fields are length-prefixed strings; they are preceded by a Length field that represents their length in bytes. These length fields are encoded using the variable-length integer encoding from Section 16 of [QUIC] and MUST be encoded in the minimum number of bytes necessary.",
      "ja": "署名アルゴリズムとポートフィールドは、ネットワークバイトの順序で署名されていない16ビット整数としてエンコードされます。キーID、公開キー、スキーム、ホスト、およびレルムフィールドは、長さが固定された文字列です。それらの前には、バイトの長さを表す長さフィールドがあります。これらの長さフィールドは、[QUIC]のセクション16からエンコードされる可変長整数を使用してエンコードされており、必要な最小バイト数でエンコードする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Public Key Encoding",
      "section_title": true,
      "ja": "3.1.1. 公開鍵エンコーディング"
    },
    {
      "indent": 3,
      "text": "Both the \"Public Key\" field of the TLS key exporter context (see above) and the a Parameter (see Section 4.2) carry the same public key. The encoding of the public key is determined by the signature algorithm in use as follows:",
      "ja": "TLSキーエクスポートコンテキスト（上記参照）の「公開キー」フィールドとAパラメーター（セクション4.2を参照）の両方に同じ公開キーがあります。公開キーのエンコードは、次のように使用されている署名アルゴリズムによって決定されます。"
    },
    {
      "indent": 3,
      "text": "RSASSA-PSS algorithms:",
      "ja": "rsassa-pssアルゴリズム："
    },
    {
      "indent": 12,
      "text": "The public key is an RSAPublicKey structure [PKCS1] encoded in DER [X.690]. BER encodings that are not DER MUST be rejected.",
      "ja": "公開鍵は、der [x.690]でエンコードされたrsapublickey構造[PKCS1]です。DERではないBERエンコーディングは拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "ECDSA algorithms:",
      "ja": "ECDSAアルゴリズム："
    },
    {
      "indent": 12,
      "text": "The public key is an UncompressedPointRepresentation structure defined in Section 4.2.8.2 of [TLS], using the curve specified by the SignatureScheme.",
      "ja": "公開鍵は、SignaturesChemeで指定された曲線を使用して、[TLS]のセクション4.2.8.2で定義されている圧縮されていない誘惑構造です。"
    },
    {
      "indent": 3,
      "text": "EdDSA algorithms:",
      "ja": "eddsaアルゴリズム："
    },
    {
      "indent": 12,
      "text": "The public key is the byte string encoding defined in [EdDSA].",
      "ja": "公開キーは、[eddsa]で定義されたバイト文字列です。"
    },
    {
      "indent": 3,
      "text": "This document does not define the public key encodings for other algorithms. In order for a SignatureScheme to be usable with the Concealed HTTP authentication scheme, its public key encoding needs to be defined in a corresponding document.",
      "ja": "このドキュメントは、他のアルゴリズムの公開キーエンコーディングを定義しません。SignatureSchemeが隠されたHTTP認証スキームで使用可能になるためには、その公開キーエンコードを対応するドキュメントで定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Key Exporter Output",
      "section_title": true,
      "ja": "3.2. キーエクスポート出力"
    },
    {
      "indent": 3,
      "text": "The key exporter output is 48 bytes long. Of those, the first 32 bytes are part of the input to the signature and the next 16 bytes are sent alongside the signature. This allows the recipient to confirm that the exporter produces the right values. This is described in Figure 2, using the notation from Section 1.3 of [QUIC]:",
      "ja": "キーエクスポート出力の長さは48バイトです。そのうち、最初の32バイトは署名への入力の一部であり、次の16バイトは署名とともに送信されます。これにより、受信者は輸出国が適切な値を生成することを確認できます。これは、[quic]のセクション1.3の表記を使用して、図2で説明します。"
    },
    {
      "indent": 5,
      "text": "Signature Input (256),\nVerification (128),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 2: Key Exporter Output Format",
      "ja": "図2：キーエクスポート出力形式"
    },
    {
      "indent": 3,
      "text": "The key exporter output contains the following fields:",
      "ja": "キーエクスポート出力には、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "Signature Input:",
      "ja": "署名入力："
    },
    {
      "indent": 12,
      "text": "This is part of the data signed using the client's chosen asymmetric private key (see Section 3.3).",
      "ja": "これは、クライアントが選択した非対称秘密鍵を使用して署名されたデータの一部です（セクション3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Verification:",
      "ja": "検証："
    },
    {
      "indent": 12,
      "text": "The verification is transmitted to the server using the v Parameter (see Section 4.5).",
      "ja": "検証は、Vパラメーターを使用してサーバーに送信されます（セクション4.5を参照）。"
    },
    {
      "indent": 0,
      "text": "3.3. Signature Computation",
      "section_title": true,
      "ja": "3.3. 署名計算"
    },
    {
      "indent": 3,
      "text": "Once the Signature Input has been extracted from the key exporter output (see Section 3.2), it is prefixed with static data before being signed. The signature is computed over the concatenation of:",
      "ja": "主要な輸出国出力から署名入力が抽出されると（セクション3.2を参照）、署名される前に静的データが付いています。署名は、次のように連結して計算されます。"
    },
    {
      "indent": 6,
      "text": "* A string that consists of octet 32 (0x20) repeated 64 times",
      "ja": "* 64回繰り返されたオクテット32（0x20）で構成される文字列"
    },
    {
      "indent": 6,
      "text": "* The context string \"HTTP Concealed Authentication\"",
      "ja": "* コンテキスト文字列「HTTP Concealed Authentication」"
    },
    {
      "indent": 6,
      "text": "* A single 0 byte that serves as a separator",
      "ja": "* セパレーターとして機能する単一の0バイト"
    },
    {
      "indent": 6,
      "text": "* The Signature Input extracted from the key exporter output (see Section 3.2)",
      "ja": "* 主要な輸出国出力から抽出された署名入力（セクション3.2を参照）"
    },
    {
      "indent": 3,
      "text": "For example, if the Signature Input has all its 32 bytes set to 01, the content covered by the signature (in hexadecimal format) would be:",
      "ja": "たとえば、署名入力にすべての32バイトが01に設定されている場合、署名（16進形式）でカバーされているコンテンツは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "2020202020202020202020202020202020202020202020202020202020202020\n2020202020202020202020202020202020202020202020202020202020202020\n48545450205369676E61747572652041757468656E7469636174696F6E\n00\n0101010101010101010101010101010101010101010101010101010101010101",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 3: Example Content Covered by Signature",
      "ja": "図3：署名でカバーされているコンテンツの例"
    },
    {
      "indent": 3,
      "text": "The purpose of this static prefix is to mitigate issues that could arise if authentication asymmetric keys were accidentally reused across protocols (even though this is forbidden, see Section 8). This construction mirrors that of the TLS 1.3 CertificateVerify message defined in Section 4.4.3 of [TLS].",
      "ja": "この静的プレフィックスの目的は、認証の非対称キーがプロトコル全体で誤って再利用された場合に発生する可能性のある問題を軽減することです（これは禁止されていますが、セクション8を参照）。この構造は、[TLS]のセクション4.4.3で定義されているTLS 1.3のCerimateVerifyメッセージの構造を反映しています。"
    },
    {
      "indent": 3,
      "text": "The resulting signature is then transmitted to the server using the p Parameter (see Section 4.3).",
      "ja": "結果の署名は、Pパラメーターを使用してサーバーに送信されます（セクション4.3を参照）。"
    },
    {
      "indent": 0,
      "text": "4. Authentication Parameters",
      "section_title": true,
      "ja": "4. 認証パラメーター"
    },
    {
      "indent": 3,
      "text": "This specification defines the following authentication parameters.",
      "ja": "この仕様は、次の認証パラメーターを定義します。"
    },
    {
      "indent": 3,
      "text": "All of the byte sequences below are encoded using base64url (see Section 5 of [BASE64]) without quotes and without padding. In other words, the values of these byte-sequence authentication parameters MUST NOT include any characters other than ASCII letters, digits, dash, and underscore.",
      "ja": "以下のすべてのバイトシーケンスは、引用符なしでパディングなしでbase64url（[base64]のセクション5を参照）を使用してエンコードされます。言い換えれば、これらのバイトシーケンス認証パラメーターの値には、ASCII文字、数字、ダッシュ、アンダースコア以外の文字を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The integer below is encoded without a minus and without leading zeroes. In other words, the value of this integer authentication parameter MUST NOT include any characters other than digits and MUST NOT start with a zero unless the full value is \"0\".",
      "ja": "以下の整数は、マイナスなしで、先行ゼロなしでエンコードされます。言い換えれば、この整数認証パラメーターの値には、数字以外の文字を含める必要はなく、完全な値が「0」でない限り、ゼロで開始してはなりません。"
    },
    {
      "indent": 3,
      "text": "Using the syntax from [ABNF]:",
      "ja": "[abnf]の構文を使用する："
    },
    {
      "indent": 3,
      "text": "concealed-byte-sequence-param-value = *( ALPHA / DIGIT / \"-\" / \"_\" )\nconcealed-integer-param-value =  %x31-39 1*4( DIGIT ) / \"0\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 4: Authentication Parameter Value ABNF",
      "ja": "図4：認証パラメーター値ABNF"
    },
    {
      "indent": 0,
      "text": "4.1. The k Parameter",
      "section_title": true,
      "ja": "4.1. Kパラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"k\" (key ID) Parameter is a byte sequence that identifies which key the client wishes to use to authenticate. This is used by the backend to point to an entry in a server-side database of known keys (see Section 6.3).",
      "ja": "必要な「k」（キーID）パラメーターは、クライアントが認証に使用したいキーを識別するバイトシーケンスです。これは、既知のキーのサーバー側データベースのエントリを指すためにバックエンドで使用されます（セクション6.3を参照）。"
    },
    {
      "indent": 0,
      "text": "4.2. The a Parameter",
      "section_title": true,
      "ja": "4.2. パラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"a\" (public key) Parameter is a byte sequence that specifies the public key used by the server to validate the signature provided by the client. This avoids key confusion issues (see [SEEMS-LEGIT]). The encoding of the public key is described in Section 3.1.1.",
      "ja": "必要な「A」（公開キー）パラメーターは、クライアントが提供する署名を検証するためにサーバーが使用する公開キーを指定するバイトシーケンスです。これにより、主要な混乱の問題が回避されます（[regit]を参照）。公開キーのエンコードについては、セクション3.1.1で説明しています。"
    },
    {
      "indent": 0,
      "text": "4.3. The p Parameter",
      "section_title": true,
      "ja": "4.3. Pパラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"p\" (proof) Parameter is a byte sequence that specifies the proof that the client provides to attest to possessing the credential that matches its key ID.",
      "ja": "必要な「P」（証明）パラメーターは、キーIDに一致する資格情報を所有することを証明するためにクライアントが提供する証明を指定するバイトシーケンスです。"
    },
    {
      "indent": 0,
      "text": "4.4. The s Parameter",
      "section_title": true,
      "ja": "4.4. Sパラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"s\" (signature scheme) Parameter is an integer that specifies the signature scheme used to compute the proof transmitted in the p Parameter. Its value is an integer between 0 and 65535 inclusive from the IANA \"TLS SignatureScheme\" registry maintained at <https://www.iana.org/assignments/tls-parameters>.",
      "ja": "必要な「S」（署名スキーム）パラメーターは、Pパラメーターに送信される証明を計算するために使用される署名スキームを指定する整数です。その値は、<https://www.iana.org/assignments/tls-parameters>に維持されているIANA \"TLS SignatureScheme\"レジストリから包括的0から65535の間の整数です。"
    },
    {
      "indent": 0,
      "text": "4.5. The v Parameter",
      "section_title": true,
      "ja": "4.5. Vパラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"v\" (verification) Parameter is a byte sequence that specifies the verification that the client provides to attest to possessing the key exporter output (see Section 3.2 for details). This avoids issues with signature schemes where certain keys can generate signatures that are valid for multiple inputs (see [SEEMS-LEGIT]).",
      "ja": "必要な「V」（検証）パラメーターは、クライアントが主要な輸出入出力の所有を証明するために提供する検証を指定するバイトシーケンスです（詳細についてはセクション3.2を参照）。これにより、特定のキーが複数の入力に有効な署名を生成できる署名スキームの問題が回避されます（[regit]を参照）。"
    },
    {
      "indent": 0,
      "text": "5. Example",
      "section_title": true,
      "ja": "5. 例"
    },
    {
      "indent": 3,
      "text": "For example, a client using the key ID \"basement\" and the signature algorithm Ed25519 [ED25519] could produce the following header field:",
      "ja": "たとえば、キーID「地下室」と署名アルゴリズムED25519 [ED25519]を使用しているクライアントは、次のヘッダーフィールドを生成できます。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nAuthorization: Concealed \\\n  k=YmFzZW1lbnQ, \\\n  a=VGhpcyBpcyBh-HB1YmxpYyBrZXkgaW4gdXNl_GhlcmU, \\\n  s=2055, \\\n  v=dmVyaWZpY2F0aW9u_zE2Qg, \\\n  p=QzpcV2luZG93c_xTeXN0ZW0zMlxkcml2ZXJz-ENyb3dkU\\\n    3RyaWtlXEMtMDAwMDAwMDAyOTEtMD-wMC0w_DAwLnN5cw",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 5: Example Header Field",
      "ja": "図5：ヘッダーフィールドの例"
    },
    {
      "indent": 0,
      "text": "6. Server Handling",
      "section_title": true,
      "ja": "6. サーバーの取り扱い"
    },
    {
      "indent": 3,
      "text": "In this section, we subdivide the server role in two:",
      "ja": "このセクションでは、2つのサーバーの役割を細分化します。"
    },
    {
      "indent": 6,
      "text": "* The \"frontend\" runs in the HTTP server that terminates the TLS or QUIC connection created by the client.",
      "ja": "* 「フロントエンド」は、クライアントが作成したTLSまたはQUIC接続を終了するHTTPサーバーで実行されます。"
    },
    {
      "indent": 6,
      "text": "* The \"backend\" runs in the HTTP server that has access to the database of accepted key identifiers and public keys.",
      "ja": "* 「バックエンド」は、受け入れられたキー識別子とパブリックキーのデータベースにアクセスできるHTTPサーバーで実行されます。"
    },
    {
      "indent": 3,
      "text": "In most deployments, we expect both the frontend and backend roles to be implemented in a single HTTP origin server (as defined in Section 3.6 of [HTTP]). However, these roles can be split such that the frontend is an HTTP gateway (as defined in Section 3.7 of [HTTP]) and the backend is an HTTP origin server.",
      "ja": "ほとんどの展開では、フロントエンドとバックエンドの両方のロールが単一のHTTP Originサーバー（[HTTP]のセクション3.6で定義されている）に実装されると予想されます。ただし、これらの役割は、フロントエンドがHTTPゲートウェイ（[HTTP]のセクション3.7で定義されている）であり、バックエンドがHTTP Originサーバーであるように分割することができます。"
    },
    {
      "indent": 0,
      "text": "6.1. Frontend Handling",
      "section_title": true,
      "ja": "6.1. フロントエンド処理"
    },
    {
      "indent": 3,
      "text": "If a frontend is configured to check the Concealed HTTP authentication scheme, it will parse the Authorization (or Proxy-Authorization) header field. If the authentication scheme is set to \"Concealed\", the frontend MUST validate that all the required authentication parameters are present and can be parsed correctly as defined in Section 4. If any parameter is missing or fails to parse, the frontend MUST ignore the entire Authorization (or Proxy-Authorization) header field.",
      "ja": "フロントエンドが隠されたHTTP認証スキームをチェックするように構成されている場合、認証（またはプロキシ承認）ヘッダーフィールドを解析します。認証スキームが「隠されている」ように設定されている場合、フロントエンドは、必要なすべての認証パラメーターが存在することを検証する必要があり、セクション4で定義されているように正しく解析できます。承認（またはプロキシ - 承認）ヘッダーフィールド。"
    },
    {
      "indent": 3,
      "text": "The frontend then uses the data from these authentication parameters to compute the key exporter output, as defined in Section 3.2. The frontend then shares the header field and the key exporter output with the backend.",
      "ja": "FrontEndは、セクション3.2で定義されているように、これらの認証パラメーターのデータを使用して、主要な輸出業者出力を計算します。Frontendは、バックエンドでヘッダーフィールドとキーエクスポート出力を共有します。"
    },
    {
      "indent": 0,
      "text": "6.2. Communication Between Frontend and Backend",
      "section_title": true,
      "ja": "6.2. フロントエンドとバックエンドの間の通信"
    },
    {
      "indent": 3,
      "text": "If the frontend and backend roles are implemented in the same machine, this can be handled by a simple function call.",
      "ja": "フロントエンドとバックエンドの役割が同じマシンに実装されている場合、これは単純な関数呼び出しで処理できます。"
    },
    {
      "indent": 3,
      "text": "If the roles are split between two separate HTTP servers, then the backend won't be able to directly access the TLS keying material exporter from the TLS connection between the client and frontend, so the frontend needs to explicitly send it. This document defines the \"Concealed-Auth-Export\" request header field for this purpose. The Concealed-Auth-Export header field's value is a Structured Field Byte Sequence (see Section 3.3.5 of [STRUCTURED-FIELDS]) that contains the 48-byte key exporter output (see Section 3.2), without any parameters. Note that Structured Field Byte Sequences are encoded using the non-URL-safe variant of base64. For example:",
      "ja": "ロールが2つの個別のHTTPサーバー間で分割されている場合、バックエンドはクライアントとフロントエンドの間のTLS接続からTLSキーイング材料輸出者に直接アクセスできないため、フロントエンドは明示的に送信する必要があります。このドキュメントでは、この目的のために「隠されたAuth-Export」要求ヘッダーフィールドを定義します。隠されたAuth-Exportヘッダーフィールドの値は、パラメーターなしで48バイトのキーエクスポート出力（セクション3.2を参照）を含む構造化されたフィールドバイトシーケンス（[構造化場]のセクション3.3.5を参照）です。構造化されたフィールドバイトシーケンスは、Base64の非URLセーフバリアントを使用してエンコードされていることに注意してください。例えば："
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nConcealed-Auth-Export: :VGhpc+BleGFtcGxlIFRMU/BleHBvcn\\\n  Rlc+BvdXRwdXQ/aXMgNDggYnl0ZXMgI/+h:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 6: Example Concealed-Auth-Export Header Field",
      "ja": "図6：隠されたAuth-Exportヘッダーフィールドの例"
    },
    {
      "indent": 3,
      "text": "The frontend SHALL forward the HTTP request to the backend, including the original unmodified Authorization (or Proxy-Authorization) header field and the newly added Concealed-Auth-Export header field.",
      "ja": "FrontEndは、元の未修正承認（またはプロキシ承認）ヘッダーフィールドと、新しく追加された隠されたAuth-Exportヘッダーフィールドを含む、HTTPリクエストをバックエンドに転送するものとします。"
    },
    {
      "indent": 3,
      "text": "Note that, since the security of this mechanism requires the key exporter output to be correct, backends need to trust frontends to send it truthfully. This trust relationship is common because the frontend already needs access to the TLS certificate private key in order to respond to requests. HTTP servers that parse the Concealed-Auth-Export header field MUST ignore it unless they have already established that they trust the sender. Similarly, frontends that send the Concealed-Auth-Export header field MUST ensure that they do not forward any Concealed-Auth-Export header field received from the client.",
      "ja": "このメカニズムのセキュリティには、主要な輸出国出力が正しいために必要なため、バックエンドはフロントエンドを信頼して真実に送信する必要があることに注意してください。この信頼関係は一般的です。なぜなら、フロントエンドはリクエストに応答するためにTLS証明書の秘密鍵にすでにアクセスする必要があるためです。隠されたAuth-Exportヘッダーフィールドを解析するHTTPサーバーは、彼らが送信者を信頼することをすでに確立していない限り、それを無視する必要があります。同様に、隠されたAuth-Exportヘッダーフィールドを送信するフロントエンドは、クライアントから受け取った隠されたAuth-Exportヘッダーフィールドを転送しないようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Backend Handling",
      "section_title": true,
      "ja": "6.3. バックエンド処理"
    },
    {
      "indent": 3,
      "text": "Once the backend receives the Authorization (or Proxy-Authorization) header field and the key exporter output, it looks up the key ID in its database of public keys. The backend SHALL then perform the following checks:",
      "ja": "バックエンドが承認（またはプロキシ承認）ヘッダーフィールドとキーエクスポート出力を受信すると、パブリックキーのデータベースでキーIDを調べます。バックエンドは次のチェックを実行するものとします。"
    },
    {
      "indent": 6,
      "text": "* validate that all the required authentication parameters are present and can be parsed correctly as defined in Section 4",
      "ja": "* 必要なすべての認証パラメーターが存在し、セクション4で定義されているように正しく解析できることを確認します"
    },
    {
      "indent": 6,
      "text": "* ensure the key ID is present in the backend's database and maps to a corresponding public key",
      "ja": "* キーIDがバックエンドのデータベースに存在し、対応する公開キーにマップされていることを確認します"
    },
    {
      "indent": 6,
      "text": "* validate that the public key from the database is equal to the one in the Authorization (or Proxy-Authorization) header field",
      "ja": "* データベースからの公開キーが認証（またはプロキシ承認）ヘッダーフィールドに等しいことを確認する"
    },
    {
      "indent": 6,
      "text": "* validate that the verification field from the Authorization (or Proxy-Authorization) header field matches the one extracted from the key exporter output",
      "ja": "* 承認（またはプロキシと承認）ヘッダーフィールドからの検証フィールドが、主要な輸出国出力から抽出されたものと一致することを検証する"
    },
    {
      "indent": 6,
      "text": "* verify the cryptographic signature as defined in Section 3.3",
      "ja": "* セクション3.3で定義されているように、暗号化署名を確認します"
    },
    {
      "indent": 3,
      "text": "If all of these checks succeed, the backend can consider the request to be properly authenticated and can reply accordingly (the backend can also forward the request to another HTTP server).",
      "ja": "これらのチェックがすべて成功した場合、バックエンドはリクエストを適切に認証することを検討し、それに応じて返信することができます（バックエンドは別のHTTPサーバーにリクエストを転送することもできます）。"
    },
    {
      "indent": 3,
      "text": "If any of the above checks fail, the backend MUST treat it as if the Authorization (or Proxy-Authorization) header field was missing.",
      "ja": "上記のチェックのいずれかが失敗した場合、バックエンドは、承認（またはプロキシ承認）ヘッダーフィールドが欠落しているかのように扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4. Non-Probeable Server Handling",
      "section_title": true,
      "ja": "6.4. 非難するサーバーの取り扱い"
    },
    {
      "indent": 3,
      "text": "Servers that wish to introduce resources whose existence cannot be probed need to ensure that they do not reveal any information about those resources to unauthenticated clients. In particular, such servers MUST respond to authentication failures with the exact same response that they would have used for nonexistent resources. For example, this can mean using HTTP status code 404 (Not Found) instead of 401 (Unauthorized).",
      "ja": "存在を調査できないリソースを導入したいサーバーは、これらのリソースに関する情報を認識していないクライアントに明らかにしないようにする必要があります。特に、このようなサーバーは、存在しないリソースに使用したのとまったく同じ応答で認証障害に応答する必要があります。たとえば、これは、401（許可されていない）ではなく、HTTPステータスコード404（発見されていない）を使用することを意味します。"
    },
    {
      "indent": 3,
      "text": "The authentication checks described above can take time to compute, and an attacker could detect use of this mechanism if that time is observable by comparing the timing of a request for a known nonexistent resource to the timing of a request for a potentially authenticated resource. Servers can mitigate this observability by slightly delaying responses to some nonexistent resources such that the timing of the authentication verification is not observable. This delay needs to be carefully considered to avoid having the delay itself leak the fact that this origin uses this mechanism at all.",
      "ja": "上記の認証チェックは計算に時間がかかる可能性があり、攻撃者は、既知の非存在しないリソースのリクエストのタイミングを、潜在的に認証されたリソースのリクエストのタイミングのタイミングと比較することにより、このメカニズムの使用を検出できます。サーバーは、認証検証のタイミングが観察できないように、いくつかの存在しないリソースへの応答をわずかに遅らせることにより、この観察性を軽減できます。この起源がこのメカニズムをまったく使用しているという事実を漏らすことを避けるために、この遅延は慎重に考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Non-probeable resources also need to be non-discoverable for unauthenticated users. For example, if a server operator wishes to hide an authenticated resource by pretending it does not exist to unauthenticated users, then the server operator needs to ensure there are no unauthenticated pages with links to that resource and no other out-of-band ways for unauthenticated users to discover this resource.",
      "ja": "不可能なリソースも、認定されていないユーザーにとって免責されない必要があります。たとえば、サーバーオペレーターが認証されたリソースを認証されていないユーザーに存在しないふりをしたい場合、サーバーオペレーターは、そのリソースへのリンクがあり、その他の帯域外の方法がないことを確認する必要があります。このリソースを発見するために、認識されていないユーザー。"
    },
    {
      "indent": 0,
      "text": "7. Requirements on TLS Usage",
      "section_title": true,
      "ja": "7. TLS使用に関する要件"
    },
    {
      "indent": 3,
      "text": "This authentication scheme is only defined for uses of HTTP with TLS [TLS]. This includes any use of HTTP over TLS as typically used for HTTP/2 [HTTP/2], or HTTP/3 [HTTP/3] where the transport protocol uses TLS as its authentication and key exchange mechanism [QUIC-TLS].",
      "ja": "この認証スキームは、TLS [TLS]を使用したHTTPの使用に対してのみ定義されます。これには、HTTP/2 [HTTP/2]に通常使用されるTLSを介したHTTPの使用、または輸送プロトコルがTLSを認証およびキー交換メカニズム[QUIC-TLS]として使用するHTTP/3 [HTTP/3]の使用が含まれます。"
    },
    {
      "indent": 3,
      "text": "Because the TLS keying material exporter is only secure for authentication when it is uniquely bound to the TLS session [RFC7627], the Concealed authentication scheme requires either one of the following properties:",
      "ja": "TLSキーイングマテリアルエクスポーターは、TLSセッション[RFC7627]に一意に拘束されている場合にのみ認証が安全であるため、隠された認証スキームには、次のプロパティのいずれかが必要です。"
    },
    {
      "indent": 6,
      "text": "* The TLS version in use is greater than or equal to 1.3 [TLS].",
      "ja": "* 使用中のTLSバージョンは、1.3 [TLS]以上です。"
    },
    {
      "indent": 6,
      "text": "* The TLS version in use is 1.2, and the extended master secret extension [RFC7627] has been negotiated.",
      "ja": "* 使用中のTLSバージョンは1.2で、拡張マスターシークレットエクステンション[RFC7627]が交渉されました。"
    },
    {
      "indent": 3,
      "text": "Clients MUST NOT use the Concealed HTTP authentication scheme on connections that do not meet one of the two properties above. If a server receives a request that uses this authentication scheme on a connection that meets neither of the above properties, the server MUST treat the request as if the authentication were not present.",
      "ja": "クライアントは、上記の2つのプロパティのいずれかを満たしていない接続に隠されたHTTP認証スキームを使用してはなりません。上記のプロパティのいずれも満たさない接続でこの認証スキームを使用するリクエストをサーバーが受信した場合、サーバーは認証が存在しないかのようにリクエストを扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The Concealed HTTP authentication scheme allows a client to authenticate to an origin server while guaranteeing freshness and without the need for the server to transmit a nonce to the client. This allows the server to accept authenticated clients without revealing that it supports or expects authentication for some resources. It also allows authentication without the client leaking the presence of authentication to observers due to cleartext TLS Client Hello extensions.",
      "ja": "隠されたHTTP認証スキームにより、クライアントは新鮮さを保証しながら、クライアントに非CEをクライアントに送信する必要がないことを保証しながら、オリジンサーバーに認証することができます。これにより、サーバーは、一部のリソースの認証をサポートまたは期待することを明らかにすることなく、認証されたクライアントを受け入れることができます。また、クライアントTLSクライアントのHello Extensionsのために、クライアントがオブザーバーに認証の存在を漏らすことなく認証を許可します。"
    },
    {
      "indent": 3,
      "text": "Since the freshness described above is provided by a TLS key exporter, it can be as old as the underlying TLS connection. Servers can require better freshness by forcing clients to create new connections using mechanisms such as the GOAWAY frame (see Section 5.2 of [HTTP/3]).",
      "ja": "上記の新鮮さはTLSキーエクスポートによって提供されるため、基礎となるTLS接続と同じくらい古い場合があります。サーバーは、Goawayフレームなどのメカニズムを使用してクライアントに新しい接続を作成することにより、より良い新鮮さを必要とする可能性があります（[http/3]のセクション5.2を参照）。"
    },
    {
      "indent": 3,
      "text": "The authentication proofs described in this document are not bound to individual HTTP requests; if the key is used for authentication proofs on multiple requests on the same connection, they will all be identical. This allows for better compression when sending over the wire, but it implies that client implementations that multiplex different security contexts over a single HTTP connection need to ensure that those contexts cannot read each other's header fields. Otherwise, one context would be able to replay the Authorization header field of another. This constraint is met by modern web browsers. If an attacker were to compromise the browser such that it could access another context's memory, the attacker might also be able to access the corresponding key, so binding authentication to requests would not provide much benefit in practice.",
      "ja": "このドキュメントで説明されている認証証明は、個々のHTTP要求に拘束されません。キーが同じ接続の複数のリクエストで認証証明に使用される場合、それらはすべて同一になります。これにより、ワイヤーを送信するときにより良い圧縮が可能になりますが、単一のHTTP接続上の異なるセキュリティコンテキストを多重化するクライアントの実装が、それらのコンテキストが互いのヘッダーフィールドを読み取れないようにする必要があることを意味します。それ以外の場合、あるコンテキストは、別のコンテキストの承認ヘッダーフィールドを再生できます。この制約は、最新のWebブラウザーによって満たされます。攻撃者が別のコンテキストのメモリにアクセスできるようにブラウザを妥協した場合、攻撃者は対応するキーにアクセスできる可能性があるため、リクエストへの拘束力のある認証は実際にはあまり利益をもたらさないでしょう。"
    },
    {
      "indent": 3,
      "text": "Authentication asymmetric keys used for the Concealed HTTP authentication scheme MUST NOT be reused in other protocols. Even though we attempt to mitigate these issues by adding a static prefix to the signed data (see Section 3.3), reusing keys could undermine the security guarantees of the authentication.",
      "ja": "隠されたHTTP認証スキームに使用される認証非対称キーは、他のプロトコルで再利用してはなりません。署名されたデータに静的プレフィックスを追加することでこれらの問題を軽減しようとしますが（セクション3.3を参照）、キーを再利用すると、認証のセキュリティ保証が損なわれる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Origins offering this scheme can link requests that use the same key. However, requests are not linkable across origins if the keys used are specific to the individual origins using this scheme.",
      "ja": "このスキームを提供するOriginsは、同じキーを使用するリクエストをリンクできます。ただし、使用されるキーがこのスキームを使用して個々の起源に固有の場合、リクエストはオリジン間でリンクできません。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. HTTP Authentication Schemes Registry",
      "section_title": true,
      "ja": "9.1. HTTP認証スキームレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following entry in the \"HTTP Authentication Schemes\" registry maintained at <https://www.iana.org/assignments/ http-authschemes>:",
      "ja": "IANAは、「http認証スキーム」レジストリに次のエントリを登録しました。"
    },
    {
      "indent": 3,
      "text": "Authentication Scheme Name:",
      "ja": "認証スキーム名："
    },
    {
      "indent": 12,
      "text": "Concealed",
      "ja": "隠された"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9729",
      "ja": "RFC 9729"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "注："
    },
    {
      "indent": 12,
      "text": "None",
      "ja": "なし"
    },
    {
      "indent": 0,
      "text": "9.2. TLS Keying Material Exporter Labels",
      "section_title": true,
      "ja": "9.2. TLSキーイングマテリアルエクスポーターラベル"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following entry in the \"TLS Exporter Labels\" registry maintained at <https://www.iana.org/assignments/tls-parameters>:",
      "ja": "IANAは、<https://www.iana.org/assignments/tls-parameters>に維持されている「TLS Exporter Labels」レジストリに次のエントリを登録しました。"
    },
    {
      "indent": 3,
      "text": "Value:",
      "ja": "値："
    },
    {
      "indent": 12,
      "text": "EXPORTER-HTTP-Concealed-Authentication",
      "ja": "Exporter-HTTP-Concealed-authentication"
    },
    {
      "indent": 3,
      "text": "DTLS-OK:",
      "ja": "DTLS-OK："
    },
    {
      "indent": 12,
      "text": "N",
      "ja": "n"
    },
    {
      "indent": 3,
      "text": "Recommended:",
      "ja": "推奨："
    },
    {
      "indent": 12,
      "text": "Y",
      "ja": "y"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9729",
      "ja": "RFC 9729"
    },
    {
      "indent": 0,
      "text": "9.3. HTTP Field Name",
      "section_title": true,
      "ja": "9.3. HTTPフィールド名"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following entry in the \"Hypertext Transfer Protocol (HTTP) Field Name Registry\" maintained at <https://www.iana.org/assignments/http-fields>:",
      "ja": "IANAは、<https://www.iana.org/assignments/http-fields>に維持されている「HyperText Transfer Protocol（HTTP）フィールド名レジストリ」に次のエントリを登録しました。"
    },
    {
      "indent": 3,
      "text": "Field Name:",
      "ja": "フィールド名："
    },
    {
      "indent": 12,
      "text": "Concealed-Auth-Export",
      "ja": "隠されたauth-export"
    },
    {
      "indent": 3,
      "text": "Status:",
      "ja": "状態："
    },
    {
      "indent": 12,
      "text": "permanent",
      "ja": "永続"
    },
    {
      "indent": 3,
      "text": "Structured Type:",
      "ja": "構造化されたタイプ："
    },
    {
      "indent": 12,
      "text": "Item",
      "ja": "アイテム"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9729",
      "ja": "RFC 9729"
    },
    {
      "indent": 3,
      "text": "Comments:",
      "ja": "コメント："
    },
    {
      "indent": 12,
      "text": "None",
      "ja": "なし"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ABNF]     Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n           Specifications: ABNF\", STD 68, RFC 5234,\n           DOI 10.17487/RFC5234, January 2008,\n           <https://www.rfc-editor.org/info/rfc5234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[BASE64]   Josefsson, S., \"The Base16, Base32, and Base64 Data\n           Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006,\n           <https://www.rfc-editor.org/info/rfc4648>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[EdDSA]    Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP Semantics\", STD 97, RFC 9110,\n           DOI 10.17487/RFC9110, June 2022,\n           <https://www.rfc-editor.org/info/rfc9110>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[KEY-EXPORT]\n           Rescorla, E., \"Keying Material Exporters for Transport\n           Layer Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705,\n           March 2010, <https://www.rfc-editor.org/info/rfc5705>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PKCS1]    Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n           \"PKCS #1: RSA Cryptography Specifications Version 2.2\",\n           RFC 8017, DOI 10.17487/RFC8017, November 2016,\n           <https://www.rfc-editor.org/info/rfc8017>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[QUIC]     Iyengar, J., Ed. and M. Thomson, Ed., \"QUIC: A UDP-Based\n           Multiplexed and Secure Transport\", RFC 9000,\n           DOI 10.17487/RFC9000, May 2021,\n           <https://www.rfc-editor.org/info/rfc9000>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,\n           Langley, A., and M. Ray, \"Transport Layer Security (TLS)\n           Session Hash and Extended Master Secret Extension\",\n           RFC 7627, DOI 10.17487/RFC7627, September 2015,\n           <https://www.rfc-editor.org/info/rfc7627>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8792]  Watsen, K., Auerswald, E., Farrel, A., and Q. Wu,\n           \"Handling Long Lines in Content of Internet-Drafts and\n           RFCs\", RFC 8792, DOI 10.17487/RFC8792, June 2020,\n           <https://www.rfc-editor.org/info/rfc8792>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[STRUCTURED-FIELDS]\n           Nottingham, M. and P. Kamp, \"Structured Field Values for\n           HTTP\", RFC 9651, DOI 10.17487/RFC9651, September 2024,\n           <https://www.rfc-editor.org/info/rfc9651>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TLS]      Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[URI]      Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n           Resource Identifier (URI): Generic Syntax\", STD 66,\n           RFC 3986, DOI 10.17487/RFC3986, January 2005,\n           <https://www.rfc-editor.org/info/rfc3986>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[X.690]    ITU-T, \"Information technology - ASN.1 encoding Rules:\n           Specification of Basic Encoding Rules (BER), Canonical\n           Encoding Rules (CER) and Distinguished Encoding Rules\n           (DER)\", ITU-T Recommendation X690, ISO/IEC 8825-1:2021,\n           February 2021, <https://www.itu.int/rec/T-REC-X.690>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ED25519]  Josefsson, S. and J. Schaad, \"Algorithm Identifiers for\n           Ed25519, Ed448, X25519, and X448 for Use in the Internet\n           X.509 Public Key Infrastructure\", RFC 8410,\n           DOI 10.17487/RFC8410, August 2018,\n           <https://www.rfc-editor.org/info/rfc8410>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HOBA]     Farrell, S., Hoffman, P., and M. Thomas, \"HTTP Origin-\n           Bound Authentication (HOBA)\", RFC 7486,\n           DOI 10.17487/RFC7486, March 2015,\n           <https://www.rfc-editor.org/info/rfc7486>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/2]   Thomson, M., Ed. and C. Benfield, Ed., \"HTTP/2\", RFC 9113,\n           DOI 10.17487/RFC9113, June 2022,\n           <https://www.rfc-editor.org/info/rfc9113>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/3]   Bishop, M., Ed., \"HTTP/3\", RFC 9114, DOI 10.17487/RFC9114,\n           June 2022, <https://www.rfc-editor.org/info/rfc9114>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MASQUE-ORIGINAL]\n           Schinazi, D., \"The MASQUE Protocol\", Work in Progress,\n           Internet-Draft, draft-schinazi-masque-00, 28 February\n           2019, <https://datatracker.ietf.org/doc/html/draft-\n           schinazi-masque-00>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[QUIC-TLS] Thomson, M., Ed. and S. Turner, Ed., \"Using TLS to Secure\n           QUIC\", RFC 9001, DOI 10.17487/RFC9001, May 2021,\n           <https://www.rfc-editor.org/info/rfc9001>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEEMS-LEGIT]\n           Jackson, D., Cremers, C., Cohn-Gordon, K., and R. Sasse,\n           \"Seems Legit: Automated Analysis of Subtle Attacks on\n           Protocols That Use Signatures\", CCS '19: Proceedings of\n           the 2019 ACM SIGSAC Conference on Computer and\n           Communications Security, pp. 2165-2180,\n           DOI 10.1145/3319535.3339813, November 2019,\n           <https://doi.org/10.1145/3319535.3339813>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank many members of the IETF community, as this document is the fruit of many hallway conversations. In particular, the authors would like to thank David Benjamin, Reese Enghardt, Nick Harper, Dennis Jackson, Ilari Liusvaara, François Michel, Lucas Pardue, Justin Richer, Ben Schwartz, Martin Thomson, and Chris A. Wood for their reviews and contributions. The mechanism described in this document was originally part of the first iteration of MASQUE [MASQUE-ORIGINAL].",
      "ja": "著者は、IETFコミュニティの多くのメンバーに感謝したいと思います。この文書は多くの廊下の会話の成果であるためです。特に、著者は、デビッド・ベンジャミン、リース・エンガルト、ニック・ハーパー、デニス・ジャクソン、イラリ・リウウスヴァーラ、フランソワ・ミシェル、ルーカス・パルドー、ジャスティン・リッチャー、ベン・シュワルツ、マーティン・トムソン、クリス・A・ウッドのレビューと貢献に感謝したいと思います。このドキュメントで説明されているメカニズムは、もともとマスク[マスクオリジナル]の最初の反復の一部でした。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David Schinazi\nGoogle LLC\n1600 Amphitheatre Parkway\nMountain View, CA 94043\nUnited States of America\nEmail: dschinazi.ietf@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David M. Oliver\nGuardian Project\nEmail: david@guardianproject.info\nURI:   https://guardianproject.info",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jonathan Hoyland\nCloudflare Inc.\nEmail: jonathan.hoyland@gmail.com",
      "raw": true,
      "ja": ""
    }
  ]
}