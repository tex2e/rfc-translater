{
  "title": {
    "text": "RFC 9729 - The Concealed HTTP Authentication Scheme",
    "ja": "RFC 9729 - 隠蔽されたHTTP認証スキーム"
  },
  "number": 9729,
  "created_at": "2025-02-16 23:24:06.731061+09:00",
  "updated_by": "自動生成＆有志による翻訳・編集",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       D. Schinazi\nRequest for Comments: 9729                                    Google LLC\nCategory: Standards Track                                      D. Oliver\nISSN: 2070-1721                                         Guardian Project\n                                                              J. Hoyland\n                                                         Cloudflare Inc.\n                                                           February 2025",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "The Concealed HTTP Authentication Scheme",
      "section_title": true,
      "ja": "隠蔽されたHTTP認証スキーム"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Most HTTP authentication schemes are probeable in the sense that it is possible for an unauthenticated client to probe whether an origin serves resources that require authentication. It is possible for an origin to hide the fact that it requires authentication by not generating Unauthorized status codes; however, that only works with non-cryptographic authentication schemes: cryptographic signatures require a fresh nonce to be signed. Prior to this document, there was no existing way for the origin to share such a nonce without exposing the fact that it serves resources that require authentication. This document defines a new non-probeable cryptographic authentication scheme.",
      "ja": "ほとんどのHTTP認証スキームは、未認証のクライアントが、オリジンが認証を必要とするリソースを提供しているかどうかをプローブ（探索）可能であるという意味で、プローブ可能です。Unauthorizedステータスコードを生成しないことで、認証が必要であるという事実を隠すことは可能です。しかし、それは非暗号化認証スキームでのみ機能します。暗号化署名には、署名するための新しいナンスが必要だからです。このドキュメント以前には、認証を必要とするリソースを提供しているという事実を公開せずに、そのようなナンスを共有する既存の方法はありませんでした。このドキュメントでは、新しいプローブ不可能な暗号化認証スキームを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force (IETF) の成果物です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、Internet Engineering Steering Group (IESG) によって公開が承認されています。インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9729.",
      "ja": "このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https://www.rfc-editor.org/info/rfc9729 で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2025 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright (c) 2025 IETF Trust および文書の著者として特定された人物。All rights reserved."
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78および、このドキュメントの発行日に有効なIETFドキュメントに関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、トラスト法的規定のセクション4.eに記載されている改訂BSDライセンスのテキストを含める必要があり、改訂BSDライセンスに記載されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Conventions and Definitions\n2.  The Concealed HTTP Authentication Scheme\n3.  Client Handling\n  3.1.  Key Exporter Context\n    3.1.1.  Public Key Encoding\n  3.2.  Key Exporter Output\n  3.3.  Signature Computation\n4.  Authentication Parameters\n  4.1.  The k Parameter\n  4.2.  The a Parameter\n  4.3.  The p Parameter\n  4.4.  The s Parameter\n  4.5.  The v Parameter\n5.  Example\n6.  Server Handling\n  6.1.  Frontend Handling\n  6.2.  Communication Between Frontend and Backend\n  6.3.  Backend Handling\n  6.4.  Non-Probeable Server Handling\n7.  Requirements on TLS Usage\n8.  Security Considerations\n9.  IANA Considerations\n  9.1.  HTTP Authentication Schemes Registry\n  9.2.  TLS Keying Material Exporter Labels\n  9.3.  HTTP Field Name\n10. References\n  10.1.  Normative References\n  10.2.  Informative References\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP authentication schemes (see Section 11 of [HTTP]) allow origins to restrict access for some resources to only authenticated requests. While these schemes commonly involve a challenge where the origin asks the client to provide authentication information, it is possible for clients to send such information unprompted. This is particularly useful in cases where an origin wants to offer a service or capability only to \"those who know\", while all others are given no indication the service or capability exists. Such designs rely on an externally defined mechanism by which keys are distributed. For example, a company might offer remote employee access to company services directly via its website using their employee credentials or offer access to limited special capabilities for specific employees while making discovering (or probing for) such capabilities difficult. As another example, members of less well-defined communities might use more ephemeral keys to acquire access to geography- or capability-specific resources, as issued by an entity whose user base is larger than the available resources can support (by having that entity metering the availability of keys temporally or geographically).",
      "ja": "HTTP認証スキーム（[HTTP]のセクション11を参照）により、オリジンは一部のリソースへのアクセスを認証されたリクエストのみに制限できます。これらのスキームには通常、オリジンがクライアントに認証情報の提供を求めるチャレンジが含まれますが、クライアントがそのような情報を自発的に送信することも可能です。これは、オリジンが「知っている人」にのみサービスや機能を提供し、他の人にはそのサービスや機能が存在することさえ示したくない場合に特に役立ちます。このような設計は、鍵が配布される外部で定義されたメカニズムに依存しています。たとえば、企業は、従業員の資格情報を使用してWebサイト経由で企業サービスへのリモートアクセスを直接提供したり、特定の従業員に限られた特別な機能へのアクセスを提供しながら、そのような機能の発見（またはプローブ）を困難にしたりする場合があります。別の例として、あまり明確に定義されていないコミュニティのメンバーが、地理的または機能固有のリソースへのアクセスを取得するために、より短命な鍵を使用する場合があります。これらの鍵は、利用可能なリソースがサポートできる数よりも多くのユーザーベースを持つエンティティによって発行されます（そのエンティティが鍵の可用性を時間的または地理的に調整することによって）。"
    },
    {
      "indent": 3,
      "text": "While digital-signature-based HTTP authentication schemes already exist (e.g., [HOBA]), they rely on the origin explicitly sending a fresh challenge to the client, to ensure that the signature input is fresh. That makes the origin probeable as it sends the challenge to unauthenticated clients. This document defines a new signature-based authentication scheme that is not probeable.",
      "ja": "デジタル署名ベースのHTTP認証スキームはすでに存在していますが（例：[HOBA]）、署名入力が新鮮であることを確認するために、オリジンがクライアントに新しいチャレンジを明示的に送信することに依存しています。これにより、オリジンは未認証のクライアントにチャレンジを送信するため、プローブ可能になります。このドキュメントでは、プローブ不可能な新しい署名ベースの認証スキームを定義します。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions and Definitions",
      "section_title": true,
      "ja": "1.1. 表記規則と定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "このドキュメント内のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、ここに示すようにすべて大文字で表示されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses the notation from Section 1.3 of [QUIC].",
      "ja": "このドキュメントでは、[QUIC]のセクション1.3の表記を使用しています。"
    },
    {
      "indent": 3,
      "text": "Various examples in this document contain long lines that may be folded, as described in [RFC8792].",
      "ja": "このドキュメントのさまざまな例には、[RFC8792]で説明されているように、折り畳まれる可能性のある長い行が含まれています。"
    },
    {
      "indent": 0,
      "text": "2. The Concealed HTTP Authentication Scheme",
      "section_title": true,
      "ja": "2. 隠蔽されたHTTP認証スキーム"
    },
    {
      "indent": 3,
      "text": "This document defines the \"Concealed\" HTTP authentication scheme. It uses asymmetric cryptography. Clients possess a key ID and a public/ private key pair, and origin servers maintain a mapping of authorized key IDs to associated public keys.",
      "ja": "このドキュメントでは、「Concealed」HTTP認証スキームを定義します。これは非対称暗号を使用します。クライアントはキーIDと公開鍵/秘密鍵のペアを所有し、オリジンサーバーは許可されたキーIDとそれに関連付けられた公開鍵のマッピングを保持します。"
    },
    {
      "indent": 3,
      "text": "The client uses a TLS keying material exporter to generate data to be signed (see Section 3) then sends the signature using the Authorization (or Proxy-Authorization) header field (see Section 11 of [HTTP]). The signature and additional information are exchanged using authentication parameters (see Section 4). Once the server receives these, it can check whether the signature validates against an entry in its database of known keys. The server can then use the validation result to influence its response to the client, for example, by restricting access to certain resources.",
      "ja": "クライアントは、TLSキーイングマテリアルエクスポーターを使用して署名するデータを生成し（セクション3を参照）、Authorization（または Proxy-Authorization）ヘッダーフィールドを使用して署名を送信します（[HTTP]のセクション11を参照）。署名と追加情報は、認証パラメーターを使用して交換されます（セクション4を参照）。サーバーはこれらを受け取ると、既知のキーのデータベース内のエントリに対して署名が検証できるかを確認できます。サーバーは、特定のリソースへのアクセスを制限するなど、検証結果を使用してクライアントへの応答に影響を与えることができます。"
    },
    {
      "indent": 0,
      "text": "3. Client Handling",
      "section_title": true,
      "ja": "3. クライアントの処理"
    },
    {
      "indent": 3,
      "text": "When a client wishes to use the Concealed HTTP authentication scheme with a request, it SHALL compute the authentication proof using a TLS keying material exporter with the following parameters:",
      "ja": "クライアントがリクエストで Concealed HTTP 認証スキームを使用したい場合、次のパラメーターを持つTLSキーイングマテリアルエクスポーターを使用して認証証明を計算しなければなりません（SHALL）。"
    },
    {
      "indent": 6,
      "text": "* The label is set to \"EXPORTER-HTTP-Concealed-Authentication\".",
      "ja": "* ラベルは \"EXPORTER-HTTP-Concealed-Authentication\" に設定されます。"
    },
    {
      "indent": 6,
      "text": "* The context is set to the structure described in Section 3.1.",
      "ja": "* コンテキストは、セクション3.1で説明されている構造に設定されます。"
    },
    {
      "indent": 6,
      "text": "* The exporter output length is set to 48 bytes (see Section 3.2).",
      "ja": "* エクスポーター出力の長さは48バイトに設定されます（セクション3.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that TLS 1.3 keying material exporters are defined in Section 7.5 of [TLS], while TLS 1.2 keying material exporters are defined in [KEY-EXPORT].",
      "ja": "TLS 1.3キーイングマテリアルエクスポーターは [TLS] のセクション7.5で定義されており、TLS 1.2キーイングマテリアルエクスポーターは [KEY-EXPORT] で定義されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1. Key Exporter Context",
      "section_title": true,
      "ja": "3.1. キーエクスポーターコンテキスト"
    },
    {
      "indent": 3,
      "text": "The TLS key exporter context is described in Figure 1, using the notation from Section 1.3 of [QUIC]:",
      "ja": "TLSキーエクスポーターコンテキストは、[QUIC] のセクション1.3の表記法を使用して、図1のように記述されます。"
    },
    {
      "indent": 5,
      "text": "Signature Algorithm (16),\nKey ID Length (i),\nKey ID (..),\nPublic Key Length (i),\nPublic Key (..),\nScheme Length (i),\nScheme (..),\nHost Length (i),\nHost (..),\nPort (16),\nRealm Length (i),\nRealm (..),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Figure 1: Key Exporter Context Format",
      "ja": "図1：キーエクスポートコンテキスト形式"
    },
    {
      "indent": 3,
      "text": "The key exporter context contains the following fields:",
      "ja": "キーエクスポーターコンテキストには、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "Signature Algorithm:",
      "ja": "署名アルゴリズム："
    },
    {
      "indent": 12,
      "text": "The signature scheme sent in the s Parameter (see Section 4.4).",
      "ja": "s パラメーターで送信された署名スキーム（セクション4.4を参照）。"
    },
    {
      "indent": 3,
      "text": "Key ID:",
      "ja": "キーID："
    },
    {
      "indent": 12,
      "text": "The key ID sent in the k Parameter (see Section 4.1).",
      "ja": "k パラメーターで送信されたキーID（セクション4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Public Key:",
      "ja": "公開鍵："
    },
    {
      "indent": 12,
      "text": "The public key used by the server to validate the signature provided by the client. Its encoding is described in Section 3.1.1.",
      "ja": "クライアントが提供する署名を検証するためにサーバーが使用する公開鍵。そのエンコーディングはセクション3.1.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "Scheme:",
      "ja": "スキーム："
    },
    {
      "indent": 12,
      "text": "The scheme for this request, encoded using the format of the scheme portion of a URI as defined in Section 3.1 of [URI].",
      "ja": "[URI] のセクション3.1で定義されているように、URIのスキーム部分の形式を使用してエンコードされたこのリクエストのスキーム。"
    },
    {
      "indent": 3,
      "text": "Host:",
      "ja": "ホスト："
    },
    {
      "indent": 12,
      "text": "The host for this request, encoded using the format of the host portion of a URI as defined in Section 3.2.2 of [URI].",
      "ja": "[URI] のセクション3.2.2で定義されているように、URIのホスト部分の形式を使用してエンコードされたこのリクエストのホスト。"
    },
    {
      "indent": 3,
      "text": "Port:",
      "ja": "ポート："
    },
    {
      "indent": 12,
      "text": "The port for this request, encoded in network byte order. Note that the port is either included in the URI or is the default port for the scheme in use; see Section 3.2.3 of [URI].",
      "ja": "ネットワークバイトオーダーでエンコードされたこのリクエストのポート。ポートはURIに含まれているか、使用中のスキームのデフォルトポートであることに注意してください。[URI] のセクション3.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Realm:",
      "ja": "レルム："
    },
    {
      "indent": 12,
      "text": "The realm of authentication that is sent in the realm authentication parameter (see Section 11.5 of [HTTP]). If the realm authentication parameter is not present, this SHALL be empty. This document does not define a means for the origin to communicate a realm to the client. If a client is not configured to use a specific realm, it SHALL use an empty realm and SHALL NOT send the realm authentication parameter.",
      "ja": "レルム認証パラメーターで送信される認証のレルム（[HTTP] のセクション11.5を参照）。レルム認証パラメーターが存在しない場合、これは空でなければなりません（SHALL）。このドキュメントは、オリジンがクライアントにレルムを通知する手段を定義しません。クライアントが特定のレルムを使用するように構成されていない場合、クライアントは空のレルムを使用しなければならず（SHALL）、レルム認証パラメーターを送信してはなりません（SHALL NOT）。"
    },
    {
      "indent": 3,
      "text": "The Signature Algorithm and Port fields are encoded as unsigned 16-bit integers in network byte order. The Key ID, Public Key, Scheme, Host, and Realm fields are length-prefixed strings; they are preceded by a Length field that represents their length in bytes. These length fields are encoded using the variable-length integer encoding from Section 16 of [QUIC] and MUST be encoded in the minimum number of bytes necessary.",
      "ja": "Signature Algorithm および Port フィールドは、ネットワークバイトオーダーの符号なし16ビット整数としてエンコードされます。Key ID、Public Key、Scheme、Host、および Realm フィールドは、長さプレフィックス付きの文字列です。それらの前には、バイト単位の長さを表す Length フィールドがあります。これらの長さフィールドは、[QUIC] のセクション16の可変長整数エンコーディングを使用してエンコードされ、必要な最小バイト数でエンコードされなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Public Key Encoding",
      "section_title": true,
      "ja": "3.1.1. 公開鍵エンコーディング"
    },
    {
      "indent": 3,
      "text": "Both the \"Public Key\" field of the TLS key exporter context (see above) and the a Parameter (see Section 4.2) carry the same public key. The encoding of the public key is determined by the signature algorithm in use as follows:",
      "ja": "TLSキーエクスポーターコンテキスト（上記参照）の「Public Key」フィールドと a パラメーター（セクション4.2を参照）の両方が、同じ公開鍵を運びます。公開鍵のエンコーディングは、次のように使用されている署名アルゴリズムによって決定されます。"
    },
    {
      "indent": 3,
      "text": "RSASSA-PSS algorithms:",
      "ja": "RSASSA-PSSアルゴリズム："
    },
    {
      "indent": 12,
      "text": "The public key is an RSAPublicKey structure [PKCS1] encoded in DER [X.690]. BER encodings that are not DER MUST be rejected.",
      "ja": "公開鍵は、DER [X.690] でエンコードされた RSAPublicKey 構造 [PKCS1] です。DERではないBERエンコーディングは拒否しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "ECDSA algorithms:",
      "ja": "ECDSAアルゴリズム："
    },
    {
      "indent": 12,
      "text": "The public key is an UncompressedPointRepresentation structure defined in Section 4.2.8.2 of [TLS], using the curve specified by the SignatureScheme.",
      "ja": "公開鍵は、SignatureScheme で指定された曲線を使用した、[TLS] のセクション4.2.8.2で定義されている UncompressedPointRepresentation 構造です。"
    },
    {
      "indent": 3,
      "text": "EdDSA algorithms:",
      "ja": "EdDSAアルゴリズム："
    },
    {
      "indent": 12,
      "text": "The public key is the byte string encoding defined in [EdDSA].",
      "ja": "公開鍵は、[EdDSA] で定義されたバイト文字列エンコーディングです。"
    },
    {
      "indent": 3,
      "text": "This document does not define the public key encodings for other algorithms. In order for a SignatureScheme to be usable with the Concealed HTTP authentication scheme, its public key encoding needs to be defined in a corresponding document.",
      "ja": "このドキュメントは、他のアルゴリズムの公開鍵エンコーディングを定義しません。SignatureScheme が Concealed HTTP 認証スキームで使用可能になるためには、その公開鍵エンコーディングを対応するドキュメントで定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Key Exporter Output",
      "section_title": true,
      "ja": "3.2. キーエクスポーター出力"
    },
    {
      "indent": 3,
      "text": "The key exporter output is 48 bytes long. Of those, the first 32 bytes are part of the input to the signature and the next 16 bytes are sent alongside the signature. This allows the recipient to confirm that the exporter produces the right values. This is described in Figure 2, using the notation from Section 1.3 of [QUIC]:",
      "ja": "キーエクスポーター出力の長さは48バイトです。そのうち、最初の32バイトは署名への入力の一部であり、次の16バイトは署名とともに送信されます。これにより、受信者はエクスポーターが適切な値を生成していることを確認できます。これは、[QUIC] のセクション1.3の表記法を使用して、図2で説明されています。"
    },
    {
      "indent": 5,
      "text": "Signature Input (256),\nVerification (128),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 2: Key Exporter Output Format",
      "ja": "図2：キーエクスポート出力形式"
    },
    {
      "indent": 3,
      "text": "The key exporter output contains the following fields:",
      "ja": "キーエクスポーター出力には、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "Signature Input:",
      "ja": "署名入力："
    },
    {
      "indent": 12,
      "text": "This is part of the data signed using the client's chosen asymmetric private key (see Section 3.3).",
      "ja": "これは、クライアントが選択した非対称秘密鍵を使用して署名されたデータの一部です（セクション3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Verification:",
      "ja": "検証："
    },
    {
      "indent": 12,
      "text": "The verification is transmitted to the server using the v Parameter (see Section 4.5).",
      "ja": "検証（verification）は、v パラメーターを使用してサーバーに送信されます（セクション4.5を参照）。"
    },
    {
      "indent": 0,
      "text": "3.3. Signature Computation",
      "section_title": true,
      "ja": "3.3. 署名計算"
    },
    {
      "indent": 3,
      "text": "Once the Signature Input has been extracted from the key exporter output (see Section 3.2), it is prefixed with static data before being signed. The signature is computed over the concatenation of:",
      "ja": "キーエクスポーター出力から Signature Input（署名入力）が抽出されると（セクション3.2を参照）、署名される前に静的データがプレフィックスとして付加されます。署名は、以下の連結に対して計算されます。"
    },
    {
      "indent": 6,
      "text": "* A string that consists of octet 32 (0x20) repeated 64 times",
      "ja": "* 64回繰り返されたオクテット32 (0x20) で構成される文字列"
    },
    {
      "indent": 6,
      "text": "* The context string \"HTTP Concealed Authentication\"",
      "ja": "* コンテキスト文字列 \"HTTP Concealed Authentication\""
    },
    {
      "indent": 6,
      "text": "* A single 0 byte that serves as a separator",
      "ja": "* セパレーターとして機能する単一の0バイト"
    },
    {
      "indent": 6,
      "text": "* The Signature Input extracted from the key exporter output (see Section 3.2)",
      "ja": "* キーエクスポーター出力から抽出された Signature Input（セクション3.2を参照）"
    },
    {
      "indent": 3,
      "text": "For example, if the Signature Input has all its 32 bytes set to 01, the content covered by the signature (in hexadecimal format) would be:",
      "ja": "たとえば、Signature Input の32バイトすべてが01に設定されている場合、署名対象のコンテンツ（16進形式）は次のようになります。"
    },
    {
      "indent": 3,
      "text": "2020202020202020202020202020202020202020202020202020202020202020\n2020202020202020202020202020202020202020202020202020202020202020\n48545450205369676E61747572652041757468656E7469636174696F6E\n00\n0101010101010101010101010101010101010101010101010101010101010101",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 3: Example Content Covered by Signature",
      "ja": "図3：署名でカバーされているコンテンツの例"
    },
    {
      "indent": 3,
      "text": "The purpose of this static prefix is to mitigate issues that could arise if authentication asymmetric keys were accidentally reused across protocols (even though this is forbidden, see Section 8). This construction mirrors that of the TLS 1.3 CertificateVerify message defined in Section 4.4.3 of [TLS].",
      "ja": "この静的プレフィックスの目的は、認証用非対称鍵がプロトコル間で誤って再利用された場合に発生する可能性のある問題を軽減することです（これは禁止されていますが、セクション8を参照）。この構造は、[TLS] のセクション4.4.3で定義されている TLS 1.3 CertificateVerify メッセージの構造を反映しています。"
    },
    {
      "indent": 3,
      "text": "The resulting signature is then transmitted to the server using the p Parameter (see Section 4.3).",
      "ja": "結果の署名は、p パラメーターを使用してサーバーに送信されます（セクション4.3を参照）。"
    },
    {
      "indent": 0,
      "text": "4. Authentication Parameters",
      "section_title": true,
      "ja": "4. 認証パラメーター"
    },
    {
      "indent": 3,
      "text": "This specification defines the following authentication parameters.",
      "ja": "この仕様は、次の認証パラメーターを定義します。"
    },
    {
      "indent": 3,
      "text": "All of the byte sequences below are encoded using base64url (see Section 5 of [BASE64]) without quotes and without padding. In other words, the values of these byte-sequence authentication parameters MUST NOT include any characters other than ASCII letters, digits, dash, and underscore.",
      "ja": "以下のすべてのバイトシーケンスは、引用符なし、パディングなしで base64url（[BASE64] のセクション5を参照）を使用してエンコードされます。つまり、これらのバイトシーケンス認証パラメーターの値には、ASCII文字、数字、ダッシュ、アンダースコア以外の文字を含めてはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "The integer below is encoded without a minus and without leading zeroes. In other words, the value of this integer authentication parameter MUST NOT include any characters other than digits and MUST NOT start with a zero unless the full value is \"0\".",
      "ja": "以下の整数は、マイナス記号なし、先行ゼロなしでエンコードされます。つまり、この整数認証パラメーターの値には、数字以外の文字を含めてはならず（MUST NOT）、完全な値が \"0\" でない限り、ゼロで開始してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Using the syntax from [ABNF]:",
      "ja": "[ABNF]の構文を使用する："
    },
    {
      "indent": 3,
      "text": "concealed-byte-sequence-param-value = *( ALPHA / DIGIT / \"-\" / \"_\" )\nconcealed-integer-param-value =  %x31-39 1*4( DIGIT ) / \"0\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 4: Authentication Parameter Value ABNF",
      "ja": "図4：認証パラメーター値ABNF"
    },
    {
      "indent": 0,
      "text": "4.1. The k Parameter",
      "section_title": true,
      "ja": "4.1. k パラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"k\" (key ID) Parameter is a byte sequence that identifies which key the client wishes to use to authenticate. This is used by the backend to point to an entry in a server-side database of known keys (see Section 6.3).",
      "ja": "必須の \"k\" (key ID) パラメーターは、クライアントが認証に使用したいキーを識別するバイトシーケンスです。これは、既知のキーのサーバー側データベースのエントリを指すためにバックエンドで使用されます（セクション6.3を参照）。"
    },
    {
      "indent": 0,
      "text": "4.2. The a Parameter",
      "section_title": true,
      "ja": "4.2. a パラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"a\" (public key) Parameter is a byte sequence that specifies the public key used by the server to validate the signature provided by the client. This avoids key confusion issues (see [SEEMS-LEGIT]). The encoding of the public key is described in Section 3.1.1.",
      "ja": "必須の \"a\" (public key) パラメーターは、クライアントが提供する署名を検証するためにサーバーが使用する公開鍵を指定するバイトシーケンスです。これにより、鍵の取り違え（key confusion）の問題が回避されます（[SEEMS-LEGIT]を参照）。公開鍵のエンコーディングについては、セクション3.1.1で説明されています。"
    },
    {
      "indent": 0,
      "text": "4.3. The p Parameter",
      "section_title": true,
      "ja": "4.3. p パラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"p\" (proof) Parameter is a byte sequence that specifies the proof that the client provides to attest to possessing the credential that matches its key ID.",
      "ja": "必須の \"p\" (proof) パラメーターは、キーIDに一致する資格情報を所有していることを証明するためにクライアントが提供する証明（proof）を指定するバイトシーケンスです。"
    },
    {
      "indent": 0,
      "text": "4.4. The s Parameter",
      "section_title": true,
      "ja": "4.4. s パラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"s\" (signature scheme) Parameter is an integer that specifies the signature scheme used to compute the proof transmitted in the p Parameter. Its value is an integer between 0 and 65535 inclusive from the IANA \"TLS SignatureScheme\" registry maintained at <https://www.iana.org/assignments/tls-parameters>.",
      "ja": "必須の \"s\" (signature scheme) パラメーターは、p パラメーターで送信される証明を計算するために使用される署名スキームを指定する整数です。その値は、<https://www.iana.org/assignments/tls-parameters> で管理されている IANA \"TLS SignatureScheme\" レジストリの 0 から 65535 までの整数です。"
    },
    {
      "indent": 0,
      "text": "4.5. The v Parameter",
      "section_title": true,
      "ja": "4.5. v パラメーター"
    },
    {
      "indent": 3,
      "text": "The REQUIRED \"v\" (verification) Parameter is a byte sequence that specifies the verification that the client provides to attest to possessing the key exporter output (see Section 3.2 for details). This avoids issues with signature schemes where certain keys can generate signatures that are valid for multiple inputs (see [SEEMS-LEGIT]).",
      "ja": "必須の \"v\" (verification) パラメーターは、クライアントがキーエクスポーター出力を所有していることを証明するために提供する検証（verification）を指定するバイトシーケンスです（詳細はセクション3.2を参照）。これにより、特定のキーが複数の入力に対して有効な署名を生成できる署名スキームの問題が回避されます（[SEEMS-LEGIT]を参照）。"
    },
    {
      "indent": 0,
      "text": "5. Example",
      "section_title": true,
      "ja": "5. 例"
    },
    {
      "indent": 3,
      "text": "For example, a client using the key ID \"basement\" and the signature algorithm Ed25519 [ED25519] could produce the following header field:",
      "ja": "たとえば、キーID \"basement\" と署名アルゴリズム Ed25519 [ED25519] を使用しているクライアントは、次のヘッダーフィールドを生成できます。"
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nAuthorization: Concealed \\\n  k=YmFzZW1lbnQ, \\\n  a=VGhpcyBpcyBh-HB1YmxpYyBrZXkgaW4gdXNl_GhlcmU, \\\n  s=2055, \\\n  v=dmVyaWZpY2F0aW9u_zE2Qg, \\\n  p=QzpcV2luZG93c_xTeXN0ZW0zMlxkcml2ZXJz-ENyb3dkU\\\n    3RyaWtlXEMtMDAwMDAwMDAyOTEtMD-wMC0w_DAwLnN5cw",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 5: Example Header Field",
      "ja": "図5：ヘッダーフィールドの例"
    },
    {
      "indent": 0,
      "text": "6. Server Handling",
      "section_title": true,
      "ja": "6. サーバーの処理"
    },
    {
      "indent": 3,
      "text": "In this section, we subdivide the server role in two:",
      "ja": "このセクションでは、サーバーの役割を2つに細分化します。"
    },
    {
      "indent": 6,
      "text": "* The \"frontend\" runs in the HTTP server that terminates the TLS or QUIC connection created by the client.",
      "ja": "* 「フロントエンド」は、クライアントによって作成されたTLSまたはQUIC接続を終端するHTTPサーバーで実行されます。"
    },
    {
      "indent": 6,
      "text": "* The \"backend\" runs in the HTTP server that has access to the database of accepted key identifiers and public keys.",
      "ja": "* 「バックエンド」は、受け入れられたキー識別子と公開鍵のデータベースにアクセスできるHTTPサーバーで実行されます。"
    },
    {
      "indent": 3,
      "text": "In most deployments, we expect both the frontend and backend roles to be implemented in a single HTTP origin server (as defined in Section 3.6 of [HTTP]). However, these roles can be split such that the frontend is an HTTP gateway (as defined in Section 3.7 of [HTTP]) and the backend is an HTTP origin server.",
      "ja": "ほとんどの展開では、フロントエンドとバックエンドの両方の役割が単一のHTTPオリジンサーバー（[HTTP]のセクション3.6で定義）に実装されると予想されます。ただし、これらの役割は、フロントエンドがHTTPゲートウェイ（[HTTP]のセクション3.7で定義）であり、バックエンドがHTTPオリジンサーバーであるように分割することもできます。"
    },
    {
      "indent": 0,
      "text": "6.1. Frontend Handling",
      "section_title": true,
      "ja": "6.1. フロントエンド処理"
    },
    {
      "indent": 3,
      "text": "If a frontend is configured to check the Concealed HTTP authentication scheme, it will parse the Authorization (or Proxy-Authorization) header field. If the authentication scheme is set to \"Concealed\", the frontend MUST validate that all the required authentication parameters are present and can be parsed correctly as defined in Section 4. If any parameter is missing or fails to parse, the frontend MUST ignore the entire Authorization (or Proxy-Authorization) header field.",
      "ja": "フロントエンドが Concealed HTTP 認証スキームをチェックするように構成されている場合、Authorization（または Proxy-Authorization）ヘッダーフィールドを解析します。認証スキームが \"Concealed\" に設定されている場合、フロントエンドは、必須の認証パラメーターがすべて存在し、セクション4で定義されているように正しく解析できることを検証しなければなりません（MUST）。パラメーターが欠落しているか、解析に失敗した場合、フロントエンドは Authorization（または Proxy-Authorization）ヘッダーフィールド全体を無視しなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "The frontend then uses the data from these authentication parameters to compute the key exporter output, as defined in Section 3.2. The frontend then shares the header field and the key exporter output with the backend.",
      "ja": "次に、フロントエンドは、セクション3.2で定義されているように、これらの認証パラメーターのデータを使用してキーエクスポーター出力を計算します。そして、フロントエンドはヘッダーフィールドとキーエクスポーター出力をバックエンドと共有します。"
    },
    {
      "indent": 0,
      "text": "6.2. Communication Between Frontend and Backend",
      "section_title": true,
      "ja": "6.2. フロントエンドとバックエンドの間の通信"
    },
    {
      "indent": 3,
      "text": "If the frontend and backend roles are implemented in the same machine, this can be handled by a simple function call.",
      "ja": "フロントエンドとバックエンドの役割が同じマシンに実装されている場合、これは単純な関数呼び出しで処理できます。"
    },
    {
      "indent": 3,
      "text": "If the roles are split between two separate HTTP servers, then the backend won't be able to directly access the TLS keying material exporter from the TLS connection between the client and frontend, so the frontend needs to explicitly send it. This document defines the \"Concealed-Auth-Export\" request header field for this purpose. The Concealed-Auth-Export header field's value is a Structured Field Byte Sequence (see Section 3.3.5 of [STRUCTURED-FIELDS]) that contains the 48-byte key exporter output (see Section 3.2), without any parameters. Note that Structured Field Byte Sequences are encoded using the non-URL-safe variant of base64. For example:",
      "ja": "役割が2つの別々のHTTPサーバー間で分割されている場合、バックエンドはクライアントとフロントエンド間のTLS接続からTLSキーイングマテリアルエクスポーターに直接アクセスできないため、フロントエンドが明示的に送信する必要があります。このドキュメントでは、この目的のために \"Concealed-Auth-Export\" リクエストヘッダーフィールドを定義します。Concealed-Auth-Export ヘッダーフィールドの値は、パラメーターなしで48バイトのキーエクスポーター出力（セクション3.2を参照）を含む構造化フィールドバイトシーケンス（[STRUCTURED-FIELDS] のセクション3.3.5を参照）です。構造化フィールドバイトシーケンスは、base64の非URLセーフバリアントを使用してエンコードされていることに注意してください。たとえば："
    },
    {
      "indent": 3,
      "text": "NOTE: '\\' line wrapping per RFC 8792\n\nConcealed-Auth-Export: :VGhpc+BleGFtcGxlIFRMU/BleHBvcn\\\n  Rlc+BvdXRwdXQ/aXMgNDggYnl0ZXMgI/+h:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 6: Example Concealed-Auth-Export Header Field",
      "ja": "図6：Concealed-Auth-Export ヘッダーフィールドの例"
    },
    {
      "indent": 3,
      "text": "The frontend SHALL forward the HTTP request to the backend, including the original unmodified Authorization (or Proxy-Authorization) header field and the newly added Concealed-Auth-Export header field.",
      "ja": "フロントエンドは、元の変更されていない Authorization（または Proxy-Authorization）ヘッダーフィールドと、新しく追加された Concealed-Auth-Export ヘッダーフィールドを含むHTTPリクエストをバックエンドに転送しなければなりません（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Note that, since the security of this mechanism requires the key exporter output to be correct, backends need to trust frontends to send it truthfully. This trust relationship is common because the frontend already needs access to the TLS certificate private key in order to respond to requests. HTTP servers that parse the Concealed-Auth-Export header field MUST ignore it unless they have already established that they trust the sender. Similarly, frontends that send the Concealed-Auth-Export header field MUST ensure that they do not forward any Concealed-Auth-Export header field received from the client.",
      "ja": "このメカニズムのセキュリティはキーエクスポーター出力が正しいことを必要とするため、バックエンドはフロントエンドがそれを正しく送信することを信頼する必要があることに注意してください。この信頼関係は一般的です。なぜなら、フロントエンドはリクエストに応答するためにTLS証明書の秘密鍵にすでにアクセスする必要があるためです。Concealed-Auth-Export ヘッダーフィールドを解析するHTTPサーバーは、送信者を信頼することをすでに確立していない限り、それを無視しなければなりません（MUST）。同様に、Concealed-Auth-Export ヘッダーフィールドを送信するフロントエンドは、クライアントから受け取った Concealed-Auth-Export ヘッダーフィールドを転送しないようにしなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "6.3. Backend Handling",
      "section_title": true,
      "ja": "6.3. バックエンド処理"
    },
    {
      "indent": 3,
      "text": "Once the backend receives the Authorization (or Proxy-Authorization) header field and the key exporter output, it looks up the key ID in its database of public keys. The backend SHALL then perform the following checks:",
      "ja": "バックエンドが Authorization（または Proxy-Authorization）ヘッダーフィールドとキーエクスポーター出力を受信すると、公開鍵のデータベースでキーIDを検索します。バックエンドは、以下のチェックを実行しなければなりません（SHALL）。"
    },
    {
      "indent": 6,
      "text": "* validate that all the required authentication parameters are present and can be parsed correctly as defined in Section 4",
      "ja": "* 必須の認証パラメーターがすべて存在し、セクション4で定義されているように正しく解析できることを検証する"
    },
    {
      "indent": 6,
      "text": "* ensure the key ID is present in the backend's database and maps to a corresponding public key",
      "ja": "* キーIDがバックエンドのデータベースに存在し、対応する公開鍵にマップされていることを確認する"
    },
    {
      "indent": 6,
      "text": "* validate that the public key from the database is equal to the one in the Authorization (or Proxy-Authorization) header field",
      "ja": "* データベースからの公開鍵が Authorization（または Proxy-Authorization）ヘッダーフィールドのものと等しいことを検証する"
    },
    {
      "indent": 6,
      "text": "* validate that the verification field from the Authorization (or Proxy-Authorization) header field matches the one extracted from the key exporter output",
      "ja": "* Authorization（または Proxy-Authorization）ヘッダーフィールドの verification フィールドが、キーエクスポーター出力から抽出されたものと一致することを検証する"
    },
    {
      "indent": 6,
      "text": "* verify the cryptographic signature as defined in Section 3.3",
      "ja": "* セクション3.3で定義されているように、暗号化署名を検証する"
    },
    {
      "indent": 3,
      "text": "If all of these checks succeed, the backend can consider the request to be properly authenticated and can reply accordingly (the backend can also forward the request to another HTTP server).",
      "ja": "これらのチェックがすべて成功した場合、バックエンドはリクエストが適切に認証されたと見なすことができ、それに応じて応答できます（バックエンドは別のHTTPサーバーにリクエストを転送することもできます）。"
    },
    {
      "indent": 3,
      "text": "If any of the above checks fail, the backend MUST treat it as if the Authorization (or Proxy-Authorization) header field was missing.",
      "ja": "上記のチェックのいずれかが失敗した場合、バックエンドは、Authorization（または Proxy-Authorization）ヘッダーフィールドが欠落しているかのように扱わなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "6.4. Non-Probeable Server Handling",
      "section_title": true,
      "ja": "6.4. プローブ不可能なサーバーの処理"
    },
    {
      "indent": 3,
      "text": "Servers that wish to introduce resources whose existence cannot be probed need to ensure that they do not reveal any information about those resources to unauthenticated clients. In particular, such servers MUST respond to authentication failures with the exact same response that they would have used for nonexistent resources. For example, this can mean using HTTP status code 404 (Not Found) instead of 401 (Unauthorized).",
      "ja": "存在をプローブできないリソースを導入したいサーバーは、未認証のクライアントに対してそれらのリソースに関する情報を一切明らかにしないようにする必要があります。特に、そのようなサーバーは、認証の失敗に対して、存在しないリソースに使用するのとまったく同じ応答で応答しなければなりません（MUST）。たとえば、これは 401 (Unauthorized) の代わりに HTTP ステータスコード 404 (Not Found) を使用することを意味します。"
    },
    {
      "indent": 3,
      "text": "The authentication checks described above can take time to compute, and an attacker could detect use of this mechanism if that time is observable by comparing the timing of a request for a known nonexistent resource to the timing of a request for a potentially authenticated resource. Servers can mitigate this observability by slightly delaying responses to some nonexistent resources such that the timing of the authentication verification is not observable. This delay needs to be carefully considered to avoid having the delay itself leak the fact that this origin uses this mechanism at all.",
      "ja": "上記の認証チェックは計算に時間がかかる可能性があり、攻撃者が既知の存在しないリソースへのリクエストのタイミングと、潜在的に認証されたリソースへのリクエストのタイミングを比較してその時間を観測できる場合、このメカニズムの使用を検出できる可能性があります。サーバーは、いくつかの存在しないリソースへの応答をわずかに遅らせて、認証検証のタイミングを観測できないようにすることで、この観測可能性を軽減できます。この遅延自体が、このオリジンがこのメカニズムを使用しているという事実を漏らさないように、遅延は慎重に検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "Non-probeable resources also need to be non-discoverable for unauthenticated users. For example, if a server operator wishes to hide an authenticated resource by pretending it does not exist to unauthenticated users, then the server operator needs to ensure there are no unauthenticated pages with links to that resource and no other out-of-band ways for unauthenticated users to discover this resource.",
      "ja": "プローブ不可能なリソースは、未認証のユーザーにとって発見不可能である必要もあります。たとえば、サーバー管理者が認証されたリソースを未認証のユーザーに対して存在しないふりをして隠したい場合、サーバー管理者は、そのリソースへのリンクを含む未認証ページが存在しないこと、および未認証ユーザーがこのリソースを発見するための他の帯域外の方法がないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Requirements on TLS Usage",
      "section_title": true,
      "ja": "7. TLS使用に関する要件"
    },
    {
      "indent": 3,
      "text": "This authentication scheme is only defined for uses of HTTP with TLS [TLS]. This includes any use of HTTP over TLS as typically used for HTTP/2 [HTTP/2], or HTTP/3 [HTTP/3] where the transport protocol uses TLS as its authentication and key exchange mechanism [QUIC-TLS].",
      "ja": "この認証スキームは、TLS [TLS] を使用したHTTPの使用に対してのみ定義されます。これには、HTTP/2 [HTTP/2] で通常使用されるTLS上のHTTPの使用、またはトランスポートプロトコルが認証および鍵交換メカニズムとしてTLSを使用する HTTP/3 [HTTP/3]（[QUIC-TLS]）が含まれます。"
    },
    {
      "indent": 3,
      "text": "Because the TLS keying material exporter is only secure for authentication when it is uniquely bound to the TLS session [RFC7627], the Concealed authentication scheme requires either one of the following properties:",
      "ja": "TLSキーイングマテリアルエクスポーターは、TLSセッション [RFC7627] に一意にバインドされている場合にのみ認証に対して安全であるため、Concealed 認証スキームには次のいずれかのプロパティが必要です。"
    },
    {
      "indent": 6,
      "text": "* The TLS version in use is greater than or equal to 1.3 [TLS].",
      "ja": "* 使用中のTLSバージョンが 1.3 [TLS] 以上である。"
    },
    {
      "indent": 6,
      "text": "* The TLS version in use is 1.2, and the extended master secret extension [RFC7627] has been negotiated.",
      "ja": "* 使用中のTLSバージョンが 1.2 であり、Extended Master Secret 拡張 [RFC7627] がネゴシエートされている。"
    },
    {
      "indent": 3,
      "text": "Clients MUST NOT use the Concealed HTTP authentication scheme on connections that do not meet one of the two properties above. If a server receives a request that uses this authentication scheme on a connection that meets neither of the above properties, the server MUST treat the request as if the authentication were not present.",
      "ja": "クライアントは、上記の2つのプロパティのいずれかを満たさない接続で Concealed HTTP 認証スキームを使用してはなりません（MUST NOT）。上記のプロパティのいずれも満たさない接続でこの認証スキームを使用するリクエストをサーバーが受信した場合、サーバーは認証が存在しないかのようにリクエストを扱わなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The Concealed HTTP authentication scheme allows a client to authenticate to an origin server while guaranteeing freshness and without the need for the server to transmit a nonce to the client. This allows the server to accept authenticated clients without revealing that it supports or expects authentication for some resources. It also allows authentication without the client leaking the presence of authentication to observers due to cleartext TLS Client Hello extensions.",
      "ja": "Concealed HTTP 認証スキームにより、クライアントは新鮮さ（freshness）を保証しながら、サーバーがクライアントにナンスを送信する必要なく、オリジンサーバーに対して認証を行うことができます。これにより、サーバーは、一部のリソースに対して認証をサポートまたは期待していることを明らかにすることなく、認証されたクライアントを受け入れることができます。また、平文の TLS Client Hello 拡張によってクライアントがオブザーバーに認証の存在を漏らすことなく、認証を行うことができます。"
    },
    {
      "indent": 3,
      "text": "Since the freshness described above is provided by a TLS key exporter, it can be as old as the underlying TLS connection. Servers can require better freshness by forcing clients to create new connections using mechanisms such as the GOAWAY frame (see Section 5.2 of [HTTP/3]).",
      "ja": "上記の新鮮さはTLSキーエクスポーターによって提供されるため、基礎となるTLS接続と同じくらい古い可能性があります。サーバーは、GOAWAYフレーム（[HTTP/3]のセクション5.2を参照）などのメカニズムを使用してクライアントに新しい接続を作成させることで、より高い新鮮さを要求できます。"
    },
    {
      "indent": 3,
      "text": "The authentication proofs described in this document are not bound to individual HTTP requests; if the key is used for authentication proofs on multiple requests on the same connection, they will all be identical. This allows for better compression when sending over the wire, but it implies that client implementations that multiplex different security contexts over a single HTTP connection need to ensure that those contexts cannot read each other's header fields. Otherwise, one context would be able to replay the Authorization header field of another. This constraint is met by modern web browsers. If an attacker were to compromise the browser such that it could access another context's memory, the attacker might also be able to access the corresponding key, so binding authentication to requests would not provide much benefit in practice.",
      "ja": "このドキュメントで説明されている認証証明は、個々のHTTPリクエストにバインドされません。同じ接続上の複数のリクエストで認証証明に鍵が使用される場合、それらはすべて同一になります。これにより、通信路上で送信する際の圧縮効率が向上しますが、単一のHTTP接続上で異なるセキュリティコンテキストを多重化するクライアント実装は、それらのコンテキストが互いのヘッダーフィールドを読み取れないようにする必要があることを意味します。そうでない場合、あるコンテキストが別のコンテキストの Authorization ヘッダーフィールドをリプレイできる可能性があります。この制約は、最新のWebブラウザによって満たされています。攻撃者がブラウザを侵害して別のコンテキストのメモリにアクセスできるようになった場合、攻撃者は対応する鍵にもアクセスできる可能性があるため、認証をリクエストにバインドしても実際にはあまり利点はありません。"
    },
    {
      "indent": 3,
      "text": "Authentication asymmetric keys used for the Concealed HTTP authentication scheme MUST NOT be reused in other protocols. Even though we attempt to mitigate these issues by adding a static prefix to the signed data (see Section 3.3), reusing keys could undermine the security guarantees of the authentication.",
      "ja": "Concealed HTTP 認証スキームに使用される認証用非対称鍵は、他のプロトコルで再利用してはなりません（MUST NOT）。署名されたデータに静的プレフィックスを追加することでこれらの問題を軽減しようとしていますが（セクション3.3を参照）、鍵を再利用すると、認証のセキュリティ保証が損なわれる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Origins offering this scheme can link requests that use the same key. However, requests are not linkable across origins if the keys used are specific to the individual origins using this scheme.",
      "ja": "このスキームを提供するオリジンは、同じ鍵を使用するリクエストをリンク（紐付け）できます。ただし、使用される鍵がこのスキームを使用する個々のオリジンに固有である場合、リクエストはオリジン間でリンクできません。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. HTTP Authentication Schemes Registry",
      "section_title": true,
      "ja": "9.1. HTTP認証スキームレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following entry in the \"HTTP Authentication Schemes\" registry maintained at <https://www.iana.org/assignments/ http-authschemes>:",
      "ja": "IANAは、「HTTP認証スキーム」レジストリに次のエントリを登録しました。"
    },
    {
      "indent": 3,
      "text": "Authentication Scheme Name:",
      "ja": "認証スキーム名："
    },
    {
      "indent": 12,
      "text": "Concealed",
      "ja": "Concealed"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9729",
      "ja": "RFC 9729"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "注："
    },
    {
      "indent": 12,
      "text": "None",
      "ja": "なし"
    },
    {
      "indent": 0,
      "text": "9.2. TLS Keying Material Exporter Labels",
      "section_title": true,
      "ja": "9.2. TLSキーイングマテリアルエクスポーターラベル"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following entry in the \"TLS Exporter Labels\" registry maintained at <https://www.iana.org/assignments/tls-parameters>:",
      "ja": "IANAは、<https://www.iana.org/assignments/tls-parameters>に維持されている「TLS Exporter Labels」レジストリに次のエントリを登録しました。"
    },
    {
      "indent": 3,
      "text": "Value:",
      "ja": "値："
    },
    {
      "indent": 12,
      "text": "EXPORTER-HTTP-Concealed-Authentication",
      "ja": "EXPORTER-HTTP-Concealed-Authentication"
    },
    {
      "indent": 3,
      "text": "DTLS-OK:",
      "ja": "DTLS-OK："
    },
    {
      "indent": 12,
      "text": "N",
      "ja": "N"
    },
    {
      "indent": 3,
      "text": "Recommended:",
      "ja": "推奨："
    },
    {
      "indent": 12,
      "text": "Y",
      "ja": "Y"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9729",
      "ja": "RFC 9729"
    },
    {
      "indent": 0,
      "text": "9.3. HTTP Field Name",
      "section_title": true,
      "ja": "9.3. HTTPフィールド名"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following entry in the \"Hypertext Transfer Protocol (HTTP) Field Name Registry\" maintained at <https://www.iana.org/assignments/http-fields>:",
      "ja": "IANAは、<https://www.iana.org/assignments/http-fields>に維持されている「HyperText Transfer Protocol（HTTP）フィールド名レジストリ」に次のエントリを登録しました。"
    },
    {
      "indent": 3,
      "text": "Field Name:",
      "ja": "フィールド名："
    },
    {
      "indent": 12,
      "text": "Concealed-Auth-Export",
      "ja": "Concealed-Auth-Export"
    },
    {
      "indent": 3,
      "text": "Status:",
      "ja": "状態："
    },
    {
      "indent": 12,
      "text": "permanent",
      "ja": "永続"
    },
    {
      "indent": 3,
      "text": "Structured Type:",
      "ja": "構造化されたタイプ："
    },
    {
      "indent": 12,
      "text": "Item",
      "ja": "アイテム"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9729",
      "ja": "RFC 9729"
    },
    {
      "indent": 3,
      "text": "Comments:",
      "ja": "コメント："
    },
    {
      "indent": 12,
      "text": "None",
      "ja": "なし"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[ABNF]     Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n           Specifications: ABNF\", STD 68, RFC 5234,\n           DOI 10.17487/RFC5234, January 2008,\n           <https://www.rfc-editor.org/info/rfc5234>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[BASE64]   Josefsson, S., \"The Base16, Base32, and Base64 Data\n           Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006,\n           <https://www.rfc-editor.org/info/rfc4648>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[EdDSA]    Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n           Signature Algorithm (EdDSA)\", RFC 8032,\n           DOI 10.17487/RFC8032, January 2017,\n           <https://www.rfc-editor.org/info/rfc8032>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n           Ed., \"HTTP Semantics\", STD 97, RFC 9110,\n           DOI 10.17487/RFC9110, June 2022,\n           <https://www.rfc-editor.org/info/rfc9110>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[KEY-EXPORT]\n           Rescorla, E., \"Keying Material Exporters for Transport\n           Layer Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705,\n           March 2010, <https://www.rfc-editor.org/info/rfc5705>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[PKCS1]    Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n           \"PKCS #1: RSA Cryptography Specifications Version 2.2\",\n           RFC 8017, DOI 10.17487/RFC8017, November 2016,\n           <https://www.rfc-editor.org/info/rfc8017>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[QUIC]     Iyengar, J., Ed. and M. Thomson, Ed., \"QUIC: A UDP-Based\n           Multiplexed and Secure Transport\", RFC 9000,\n           DOI 10.17487/RFC9000, May 2021,\n           <https://www.rfc-editor.org/info/rfc9000>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,\n           Langley, A., and M. Ray, \"Transport Layer Security (TLS)\n           Session Hash and Extended Master Secret Extension\",\n           RFC 7627, DOI 10.17487/RFC7627, September 2015,\n           <https://www.rfc-editor.org/info/rfc7627>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8792]  Watsen, K., Auerswald, E., Farrel, A., and Q. Wu,\n           \"Handling Long Lines in Content of Internet-Drafts and\n           RFCs\", RFC 8792, DOI 10.17487/RFC8792, June 2020,\n           <https://www.rfc-editor.org/info/rfc8792>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[STRUCTURED-FIELDS]\n           Nottingham, M. and P. Kamp, \"Structured Field Values for\n           HTTP\", RFC 9651, DOI 10.17487/RFC9651, September 2024,\n           <https://www.rfc-editor.org/info/rfc9651>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[TLS]      Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[URI]      Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n           Resource Identifier (URI): Generic Syntax\", STD 66,\n           RFC 3986, DOI 10.17487/RFC3986, January 2005,\n           <https://www.rfc-editor.org/info/rfc3986>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[X.690]    ITU-T, \"Information technology - ASN.1 encoding Rules:\n           Specification of Basic Encoding Rules (BER), Canonical\n           Encoding Rules (CER) and Distinguished Encoding Rules\n           (DER)\", ITU-T Recommendation X690, ISO/IEC 8825-1:2021,\n           February 2021, <https://www.itu.int/rec/T-REC-X.690>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考参考文献"
    },
    {
      "indent": 3,
      "text": "[ED25519]  Josefsson, S. and J. Schaad, \"Algorithm Identifiers for\n           Ed25519, Ed448, X25519, and X448 for Use in the Internet\n           X.509 Public Key Infrastructure\", RFC 8410,\n           DOI 10.17487/RFC8410, August 2018,\n           <https://www.rfc-editor.org/info/rfc8410>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HOBA]     Farrell, S., Hoffman, P., and M. Thomas, \"HTTP Origin-\n           Bound Authentication (HOBA)\", RFC 7486,\n           DOI 10.17487/RFC7486, March 2015,\n           <https://www.rfc-editor.org/info/rfc7486>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/2]   Thomson, M., Ed. and C. Benfield, Ed., \"HTTP/2\", RFC 9113,\n           DOI 10.17487/RFC9113, June 2022,\n           <https://www.rfc-editor.org/info/rfc9113>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HTTP/3]   Bishop, M., Ed., \"HTTP/3\", RFC 9114, DOI 10.17487/RFC9114,\n           June 2022, <https://www.rfc-editor.org/info/rfc9114>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MASQUE-ORIGINAL]\n           Schinazi, D., \"The MASQUE Protocol\", Work in Progress,\n           Internet-Draft, draft-schinazi-masque-00, 28 February\n           2019, <https://datatracker.ietf.org/doc/html/draft-\n           schinazi-masque-00>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[QUIC-TLS] Thomson, M., Ed. and S. Turner, Ed., \"Using TLS to Secure\n           QUIC\", RFC 9001, DOI 10.17487/RFC9001, May 2021,\n           <https://www.rfc-editor.org/info/rfc9001>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[SEEMS-LEGIT]\n           Jackson, D., Cremers, C., Cohn-Gordon, K., and R. Sasse,\n           \"Seems Legit: Automated Analysis of Subtle Attacks on\n           Protocols That Use Signatures\", CCS '19: Proceedings of\n           the 2019 ACM SIGSAC Conference on Computer and\n           Communications Security, pp. 2165-2180,\n           DOI 10.1145/3319535.3339813, November 2019,\n           <https://doi.org/10.1145/3319535.3339813>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank many members of the IETF community, as this document is the fruit of many hallway conversations. In particular, the authors would like to thank David Benjamin, Reese Enghardt, Nick Harper, Dennis Jackson, Ilari Liusvaara, François Michel, Lucas Pardue, Justin Richer, Ben Schwartz, Martin Thomson, and Chris A. Wood for their reviews and contributions. The mechanism described in this document was originally part of the first iteration of MASQUE [MASQUE-ORIGINAL].",
      "ja": "著者は、IETFコミュニティの多くのメンバーに感謝したいと思います。この文書は多くの廊下の会話の成果であるためです。特に、著者は、デビッド・ベンジャミン、リース・エンガルト、ニック・ハーパー、デニス・ジャクソン、イラリ・リウウスヴァーラ、フランソワ・ミシェル、ルーカス・パルドー、ジャスティン・リッチャー、ベン・シュワルツ、マーティン・トムソン、クリス・A・ウッドのレビューと貢献に感謝したいと思います。このドキュメントで説明されているメカニズムは、もともと MASQUE [MASQUE-ORIGINAL] の最初の反復の一部でした。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David Schinazi\nGoogle LLC\n1600 Amphitheatre Parkway\nMountain View, CA 94043\nUnited States of America\nEmail: dschinazi.ietf@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David M. Oliver\nGuardian Project\nEmail: david@guardianproject.info\nURI:   https://guardianproject.info",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jonathan Hoyland\nCloudflare Inc.\nEmail: jonathan.hoyland@gmail.com",
      "raw": true,
      "ja": ""
    }
  ]
}