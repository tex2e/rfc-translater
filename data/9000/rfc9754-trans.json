{
  "title": {
    "text": "RFC 9754 - Extensions for Opening and Delegating Files in NFSv4.2",
    "ja": "RFC 9754 - nfsv4.2でファイルを開設および委任するための拡張機能"
  },
  "number": 9754,
  "created_at": "2025-04-12 23:24:06.357156+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         T. Haynes\nRequest for Comments: 9754                                  T. Myklebust\nCategory: Standards Track                                    Hammerspace\nISSN: 2070-1721                                               March 2025",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Extensions for Opening and Delegating Files in NFSv4.2",
      "section_title": true,
      "ja": "nfsv4.2でファイルを開設および委任するための拡張機能"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Network File System v4 (NFSv4) allows a client to both open a file and be granted a delegation of that file. This delegation provides the client the right to authoritatively cache metadata on the file locally. This document presents several extensions for both opening the file and delegating it to the client. This document extends NFSv4.2 (see RFC 7863).",
      "ja": "ネットワークファイルシステムV4（NFSV4）により、クライアントはファイルを開き、そのファイルの委任を許可できます。この代表団は、クライアントに、ファイル上のメタデータをローカルにキャッシュする権利を提供します。このドキュメントでは、ファイルを開いてクライアントに委任するためのいくつかの拡張機能を提示します。このドキュメントはNFSV4.2を拡張します（RFC 7863を参照）。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9754.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9754で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2025 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2025 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Definitions\n  1.2.  Requirements Language\n2.  Offline Files\n  2.1.  XDR for the Offline Attribute\n3.  Determining OPEN Feature Support\n  3.1.  XDR for Open Arguments\n4.  OPEN Grants Either an Open or a Delegation Stateid\n  4.1.  Implementation Experience\n5.  Proxying of Times\n  5.1.  Use Case for NFSv3 Client Proxy\n  5.2.  XDR for Proxying of Times\n6.  Extraction of XDR\n7.  Security Considerations\n8.  IANA Considerations\n9.  Normative References\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In the Network File System version 4 (NFSv4), a client may be granted a delegation for a file (see Section 1.8.4 of [RFC8881]). This allows the client to act as the authority for the file's data and metadata. This document presents a number of extensions that enhance the functionality of opens and delegations. These allow the client to:",
      "ja": "ネットワークファイルシステムバージョン4（NFSV4）では、クライアントにファイルの代表団が付与される場合があります（[RFC8881]のセクション1.8.4を参照）。これにより、クライアントはファイルのデータとメタデータの権限として行動することができます。このドキュメントでは、オープンと委任の機能を強化する多くの拡張機能を示しています。これらはクライアントが次のことを可能にします："
    },
    {
      "indent": 6,
      "text": "* detect an offline file, which may require significant effort to obtain;",
      "ja": "* オフラインファイルを検出します。これには、取得するために多大な努力が必要になる場合があります。"
    },
    {
      "indent": 6,
      "text": "* determine which extensions of OPEN flags are supported by the server;",
      "ja": "* サーバーによってサポートされているオープンフラグの拡張機能を決定します。"
    },
    {
      "indent": 6,
      "text": "* retrieve either the open or delegation stateid, but not both simultaneously, during the OPEN procedure; and",
      "ja": "* オープンプロシージャ中に、両方のオープンまたは代表団のいずれかを同時に取得します。そして"
    },
    {
      "indent": 6,
      "text": "* cache both the access and modify timestamps, thereby reducing the frequency with which the client must query the server for this information.",
      "ja": "* アクセスと変更の両方をキャッシュして、クライアントがこの情報をサーバーに照会する必要がある頻度を減らします。"
    },
    {
      "indent": 3,
      "text": "Using the process detailed in [RFC8178], the revisions in this document become an extension of NFSv4.2 [RFC7862]. They are built on top of the External Data Representation (XDR) [RFC4506] generated from [RFC7863].",
      "ja": "[RFC8178]で詳述されているプロセスを使用して、このドキュメントの改訂はNFSV4.2 [RFC7862]の拡張になります。[RFC7863]から生成された外部データ表現（XDR）[RFC4506]の上に構築されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Definitions",
      "section_title": true,
      "ja": "1.1. 定義"
    },
    {
      "indent": 3,
      "text": "This document uses the following terminology:",
      "ja": "このドキュメントでは、次の用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "offline file:",
      "ja": "オフラインファイル："
    },
    {
      "indent": 12,
      "text": "A file that exists on a device that is not connected to the server. There is typically a cost associated with bringing the file to an online status. Historically, this would be a file on tape media, and the cost would have been finding and loading the tape. A more modern interpretation is that the file is in the cloud, and the cost is a monetary one in downloading the file.",
      "ja": "サーバーに接続されていないデバイスに存在するファイル。通常、ファイルをオンラインステータスにすることに関連するコストがあります。歴史的に、これはテープメディアのファイルであり、コストはテープを見つけてロードしていたでしょう。より近代的な解釈は、ファイルがクラウドにあることであり、コストはファイルのダウンロードにおける金銭的なものです。"
    },
    {
      "indent": 3,
      "text": "proxy:",
      "ja": "プロキシ："
    },
    {
      "indent": 12,
      "text": "The proxying of attributes occurs when a client has the authority, as granted by the appropriate delegation, to represent the attributes normally maintained by the server. For read attributes, this occurs when the client has either a read or write delegation for the file. For write attributes, this occurs when the client has a write delegation for the file. The client having this authority is the \"proxy\" for those attributes.",
      "ja": "属性のプロキシは、クライアントが適切な代表団によって付与されているように、サーバーが通常維持する属性を表す権限を持っているときに発生します。読み取り属性の場合、これは、クライアントがファイルの読み取りまたは書き込みのいずれかを持っているときに発生します。書き込み属性の場合、これはクライアントがファイルの委任を書き込むときに発生します。この権限を持っているクライアントは、それらの属性の「プロキシ」です。"
    },
    {
      "indent": 3,
      "text": "Further, the definitions of the following terms are referenced as follows:",
      "ja": "さらに、次の用語の定義は次のように参照されます。"
    },
    {
      "indent": 6,
      "text": "* CB_GETATTR (Section 20.1 of [RFC8881])",
      "ja": "* CB_GETATTR（[RFC8881]のセクション20.1）"
    },
    {
      "indent": 6,
      "text": "* change (Section 5.8.1.4 of [RFC8881])",
      "ja": "* 変更（[RFC8881]のセクション5.8.1.4）"
    },
    {
      "indent": 6,
      "text": "* CLOSE (Section 18.2 of [RFC8881])",
      "ja": "* 閉じる（[RFC8881]のセクション18.2）"
    },
    {
      "indent": 6,
      "text": "* compound (Section 2.3 of [RFC8881])",
      "ja": "* 化合物（[RFC8881]のセクション2.3）"
    },
    {
      "indent": 6,
      "text": "* DELEGRETURN (Section 18.6 of [RFC8881])",
      "ja": "* Delegreturn（[RFC8881]のセクション18.6）"
    },
    {
      "indent": 6,
      "text": "* GETATTR (Section 18.7 of [RFC8881])",
      "ja": "* getattr（[RFC8881]のセクション18.7）"
    },
    {
      "indent": 6,
      "text": "* LAYOUTGET (Section 18.43 of [RFC8881])",
      "ja": "* レイアウトゲット（[RFC8881]のセクション18.43）"
    },
    {
      "indent": 6,
      "text": "* LOCK (Section 18.10 of [RFC8881])",
      "ja": "* ロック（[RFC8881]のセクション18.10）"
    },
    {
      "indent": 6,
      "text": "* NFS4ERR_DELAY (Section 15.1.1.3 of [RFC8881])",
      "ja": "* nfs4err_delay（[rfc8881]のセクション15.1.1.3）"
    },
    {
      "indent": 6,
      "text": "* OPEN (Section 18.16 of [RFC8881])",
      "ja": "* Open（[RFC8881]のセクション18.16）"
    },
    {
      "indent": 6,
      "text": "* open_delegation_type4 (Section 18.16.1 of [RFC8881])",
      "ja": "* open_delegation_type4（[rfc8881]のセクション18.16.1）"
    },
    {
      "indent": 6,
      "text": "* READ (Section 18.22 of [RFC8881])",
      "ja": "* 読む（[RFC8881]のセクション18.22）"
    },
    {
      "indent": 6,
      "text": "* READDIR (Section 18.23 of [RFC8881])",
      "ja": "* Readdir（[RFC8881]のセクション18.23）"
    },
    {
      "indent": 6,
      "text": "* SETATTR (Section 18.30 of [RFC8881])",
      "ja": "* Setattr（[RFC8881]のセクション18.30）"
    },
    {
      "indent": 6,
      "text": "* stateid (Section 8.2 of [RFC8881])",
      "ja": "* StateID（[RFC8881]のセクション8.2）"
    },
    {
      "indent": 6,
      "text": "* time_access (Section 5.8.2.37 of [RFC8881])",
      "ja": "* time_access（[rfc8881]のセクション5.8.2.37）"
    },
    {
      "indent": 6,
      "text": "* time_metadata (Section 5.8.2.42 of [RFC8881])",
      "ja": "* time_metadata（[RFC8881]のセクション5.8.2.42）"
    },
    {
      "indent": 6,
      "text": "* time_modify (Section 5.8.2.43 of [RFC8881])",
      "ja": "* time_modify（[rfc8881]のセクション5.8.2.43）"
    },
    {
      "indent": 6,
      "text": "* WRITE (Section 18.32 of [RFC8881])",
      "ja": "* 書き込み（[rfc8881]のセクション18.32）"
    },
    {
      "indent": 0,
      "text": "1.2. Requirements Language",
      "section_title": true,
      "ja": "1.2. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "このドキュメント内のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、ここに示すようにすべて大文字で表示されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Offline Files",
      "section_title": true,
      "ja": "2. オフラインファイル"
    },
    {
      "indent": 3,
      "text": "If a file is offline, then the server has immediate high-performance access to the file's attributes, but not to the file's content. The action of retrieving the data content is expensive, to the extent that the content should only be retrieved if it is going to be used. For example, a graphical file manager (such as Finder in Mac OS X) may want to access the beginning of the file to preview it for a user who is hovering their pointer over the file name and not accessing it otherwise. If the file is retrieved, it will most likely be either immediately thrown away or returned.",
      "ja": "ファイルがオフラインの場合、サーバーはファイルの属性への即時の高性能アクセスを備えていますが、ファイルのコンテンツには即座にアクセスできません。データコンテンツを取得するアクションは、コンテンツを使用する場合にのみ取得する必要がある限り、高価です。たとえば、グラフィカルファイルマネージャー（Mac OS XのFinderなど）は、ファイルの先頭にアクセスして、ファイル名の上にポインターをホバリングし、それ以外の場合はアクセスしないユーザーのプレビューを行うことをお勧めします。ファイルが取得された場合、それはおそらくすぐに捨てられるか、返されます。"
    },
    {
      "indent": 3,
      "text": "A compound with a GETATTR or READDIR can report the file's attributes without bringing the file online. However, either an OPEN or a LAYOUTGET might cause the file server to retrieve the archived data contents, bringing the file online. For non-parallel NFS systems (see Section 12 of [RFC8881]), the OPEN operation requires a filehandle to retrieve the data content. For parallel NFS (pNFS) systems, the filehandle retrieved from an OPEN need not cause the data content to be retrieved. However, when the LAYOUTGET operation is processed, a layout-type-specific mapping will cause the data content to be retrieved from offline storage.",
      "ja": "getattrまたはreaddirを備えた化合物は、ファイルをオンラインにすることなく、ファイルの属性を報告できます。ただし、オープンまたはレイアウトゲットのいずれかにより、ファイルサーバーがアーカイブされたデータコンテンツを取得して、ファイルをオンラインにする可能性があります。非平行NFSシステム（[RFC8881]のセクション12を参照）の場合、オープン操作では、データコンテンツを取得するためにファイルハンドルが必要です。並列NFS（PNFS）システムの場合、オープンから取得されたファイルハンドルは、データコンテンツを取得する必要はありません。ただし、レイアウトゲット操作が処理されると、レイアウトタイプ固有のマッピングにより、データコンテンツがオフラインストレージから取得されます。"
    },
    {
      "indent": 3,
      "text": "If the client is not aware that the file is offline, it might inadvertently open the file to determine what type of file it is accessing. By interrogating the new attribute fattr4_offline, a client can predetermine the availability of the file, avoiding the need to open it at all. Being offline might also involve situations in which the file is archived in the cloud, i.e., there can be an expense in both retrieving the file to bring it online and in sending the file back to offline status.",
      "ja": "クライアントがファイルがオフラインであることを認識していない場合、ファイルを誤って開き、アクセスするファイルのタイプを決定する可能性があります。新しい属性fattr4_offlineに尋問することにより、クライアントはファイルの可用性を事前に決定し、それを開く必要性を避けることができます。オフラインであることには、ファイルがクラウドにアーカイブされる状況も含まれます。つまり、ファイルを取得するためにオンラインでファイルを取得し、ファイルをオフラインステータスに送信するための費用がかかる場合があります。"
    },
    {
      "indent": 0,
      "text": "2.1. XDR for the Offline Attribute",
      "section_title": true,
      "ja": "2.1. オフライン属性のXDR"
    },
    {
      "indent": 3,
      "text": "///\n/// typedef bool            fattr4_offline;\n///\n///\n/// const FATTR4_OFFLINE            = 83;\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. Determining OPEN Feature Support",
      "section_title": true,
      "ja": "3. オープン機能サポートの決定"
    },
    {
      "indent": 3,
      "text": "Section 4.4.2 of [RFC8178] allows for extending a particular minor version of the NFSv4 protocol without requiring the definition of a new minor version. The client can probe the capabilities of the server and, based on the result, determine if both it and the server support optional features not previously specified as part of the minor version.",
      "ja": "[RFC8178]のセクション4.4.2では、新しいマイナーバージョンの定義を必要とせずに、NFSV4プロトコルの特定のマイナーバージョンを拡張することができます。クライアントは、サーバーの機能をプローブでき、結果に基づいて、それとサーバーの両方がマイナーバージョンの一部として以前に指定されていなかったオプション機能をサポートするかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "The fattr4_open_arguments attribute is a new XDR extension that provides helpful support when the OPEN procedure is extended in such a fashion. It models all of the parameters via bitmap4 data structures, which allows for the addition of a new flag to any of the OPEN arguments. The scope of this attribute applies to all objects with a matching fsid.",
      "ja": "fattr4_open_arguments属性は、オープン手順がこのような方法で拡張された場合に有用なサポートを提供する新しいXDR拡張機能です。BITMAP4データ構造を介してすべてのパラメーターをモデル化するため、オープンな引数のいずれかに新しいフラグを追加できます。この属性の範囲は、一致するFSIDを持つすべてのオブジェクトに適用されます。"
    },
    {
      "indent": 3,
      "text": "Two new flags are provided:",
      "ja": "2つの新しいフラグが提供されています。"
    },
    {
      "indent": 6,
      "text": "* OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION (see Section 4)",
      "ja": "* open4_share_access_want_open_xor_delegation（セクション4を参照）"
    },
    {
      "indent": 6,
      "text": "* OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS (see Section 5)",
      "ja": "* open4_share_access_want_deleg_timestamps（セクション5を参照）"
    },
    {
      "indent": 3,
      "text": "Subsequent extensions can use this framework when introducing new OPTIONAL functionality to OPEN by creating a new flag for each OPTIONAL parameter.",
      "ja": "後続の拡張機能は、各オプションパラメーターの新しいフラグを作成することにより、新しいオプション機能を導入するときにこのフレームワークを使用できます。"
    },
    {
      "indent": 3,
      "text": "Since fattr4_open_arguments is a RECOMMENDED attribute, if the server informs the client via NFS4ERR_ATTRNOTSUPP that it does not support this new attribute, the client MUST take this to mean that the additional new OPTIONAL functionality to OPEN is also not supported.",
      "ja": "fattr4_open_argumentsは推奨属性であるため、サーバーがこの新しい属性をサポートしていないことをサーバーがクライアントに通知する場合、クライアントはこれを実行して開くための追加の新しいオプション機能もサポートされていないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Some other concerns are how to process both currently REQUIRED flags and OPTIONAL flags that become REQUIRED in the future. The server MUST mark REQUIRED flags as being supported. Note that these flags MUST only change from OPTIONAL to REQUIRED when the NFSv4 minor version is incremented.",
      "ja": "その他の懸念は、現在必要なフラグと将来必要になるオプションのフラグの両方を処理する方法です。サーバーは、必要なフラグをサポートされているとマークする必要があります。これらのフラグは、NFSV4マイナーバージョンが増加した場合にのみ、オプションから必要に変更する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1. XDR for Open Arguments",
      "section_title": true,
      "ja": "3.1. オープン引数のためのXDR"
    },
    {
      "indent": 3,
      "text": "///\n/// struct open_arguments4 {\n///   bitmap4  oa_share_access;\n///   bitmap4  oa_share_deny;\n///   bitmap4  oa_share_access_want;\n///   bitmap4  oa_open_claim;\n///   bitmap4  oa_create_mode;\n/// };\n///\n///\n/// enum open_args_share_access4 {\n///    OPEN_ARGS_SHARE_ACCESS_READ  = 1,\n///    OPEN_ARGS_SHARE_ACCESS_WRITE = 2,\n///    OPEN_ARGS_SHARE_ACCESS_BOTH  = 3\n/// };\n///\n///\n/// enum open_args_share_deny4 {\n///    OPEN_ARGS_SHARE_DENY_NONE  = 0,\n///    OPEN_ARGS_SHARE_DENY_READ  = 1,\n///    OPEN_ARGS_SHARE_DENY_WRITE = 2,\n///    OPEN_ARGS_SHARE_DENY_BOTH  = 3\n/// };\n///\n///\n/// enum open_args_share_access_want4 {\n///    OPEN_ARGS_SHARE_ACCESS_WANT_ANY_DELEG           = 3,\n///    OPEN_ARGS_SHARE_ACCESS_WANT_NO_DELEG            = 4,\n///    OPEN_ARGS_SHARE_ACCESS_WANT_CANCEL              = 5,\n///    OPEN_ARGS_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL\n///                                                    = 17,\n///    OPEN_ARGS_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED\n///                                                    = 18,\n///    OPEN_ARGS_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS    = 20,\n///    OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION = 21\n/// };\n///\n///\n/// enum open_args_open_claim4 {\n///    OPEN_ARGS_OPEN_CLAIM_NULL          = 0,\n///    OPEN_ARGS_OPEN_CLAIM_PREVIOUS      = 1,\n///    OPEN_ARGS_OPEN_CLAIM_DELEGATE_CUR  = 2,\n///    OPEN_ARGS_OPEN_CLAIM_DELEGATE_PREV = 3,\n///    OPEN_ARGS_OPEN_CLAIM_FH            = 4,\n///    OPEN_ARGS_OPEN_CLAIM_DELEG_CUR_FH  = 5,\n///    OPEN_ARGS_OPEN_CLAIM_DELEG_PREV_FH = 6\n/// };\n///\n///\n/// enum open_args_createmode4 {\n///    OPEN_ARGS_CREATEMODE_UNCHECKED4     = 0,\n///    OPEN_ARGS_CREATE_MODE_GUARDED       = 1,\n///    OPEN_ARGS_CREATEMODE_EXCLUSIVE4     = 2,\n///    OPEN_ARGS_CREATE_MODE_EXCLUSIVE4_1  = 3\n/// };\n///\n///\n/// typedef open_arguments4 fattr4_open_arguments;\n///\n///\n/// %/*\n/// % * Determine what OPEN supports.\n/// % */\n/// const FATTR4_OPEN_ARGUMENTS     = 86;\n///\n///\n/// const OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION = 0x200000;\n///\n///\n/// const OPEN4_RESULT_NO_OPEN_STATEID = 0x00000010;\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. OPEN Grants Either an Open or a Delegation Stateid",
      "section_title": true,
      "ja": "4. オープンオープンまたは代表団のいずれかを付与します"
    },
    {
      "indent": 3,
      "text": "The OPEN procedure returns an open stateid to the client to reference the state of the file. The client could also request a delegation stateid in the OPEN arguments. The file can be considered open for the client as long as the count of open and delegated stateids is greater than 0. Either type of stateid is sufficient to enable the server to treat the file as if it were open, which allows READ, WRITE, LOCK, and LAYOUTGET operations to proceed. If the client gets both an open and a delegation stateid as part of the OPEN, then it has to return them both to the server. A further consideration is that during each operation, the client can send a costly GETATTR.",
      "ja": "オープン手順では、オープンステートインドをクライアントに返して、ファイルの状態を参照します。また、クライアントは、開かれた引数で委任Stateidを要求することもできます。オープンおよび委任されたStateIDSのカウントが0より大きい限り、ファイルはクライアントのオープンと見なすことができます。どちらのタイプのStateIDで、サーバーがオープンであるかのように扱うことができます。クライアントがオープンの一部としてオープンと代表団の両方を取得する場合、それらを両方のサーバーに返す必要があります。さらに考慮して、各操作中に、クライアントが高価なgetattrを送信できることです。"
    },
    {
      "indent": 3,
      "text": "If the client knows that the server supports the OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION flag (as determined by an earlier GETATTR operation that queried for the fattr4_open_arguments attribute), then the client can supply that flag during the OPEN and get either an open or a delegation stateid.",
      "ja": "クライアントがサーバーがopen4_share_access_want_open_xor_deLegationフラグをサポートしていることを知っている場合（fattr4_open_arguments属性を照会した以前のgetattr操作によって決定されたように）、クライアントはオープン中にそのフラグを提供し、オープンステートステートまたはオープンステートのいずれかを取得できます。"
    },
    {
      "indent": 3,
      "text": "The client is already prepared to not get a delegation stateid, even if requested. In order to not send an open stateid, the server MUST indicate that fact with the result flag of OPEN4_RESULT_NO_OPEN_STATEID. The open stateid field, OPEN4resok.stateid, MUST be set to the special all-zero stateid in this case.",
      "ja": "クライアントは、たとえ要求されたとしても、代表団のStateIDを取得しないように既に準備されています。Open StateIDを送信しないために、サーバーはOpen4_Result_NO_OPEN_STATEIDの結果フラグを使用してその事実を示す必要があります。Open StateIDフィールド、Open4Resok.StateIDは、この場合、特別な全ゼロStateIDに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION flag is a hint. The server might return both stateids. Consider the scenario in which the client opens a file for read-only (with OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION set) and only gets an open stateid. If the client then opens the file for read-write (with OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION set), the server can return one of the following three options:",
      "ja": "open4_share_access_want_open_xor_delegationフラグはヒントであることに注意してください。サーバーは両方のSTATEIDを返す場合があります。クライアントが読み取り専用のファイル（Open4_Share_access_want_open_xor_delegationセット）のファイルを開くシナリオを考えてみてください。クライアントがRead-Writeのファイルを開いた場合（open4_share_access_want_open_xor_delegationセット）、サーバーは次の3つのオプションのいずれかを返すことができます。"
    },
    {
      "indent": 8,
      "text": "1. Only an open stateid with the correct seqid.",
      "ja": "1. 正しいSeqidを持つ開いたStateidのみ。"
    },
    {
      "indent": 8,
      "text": "2. Only a delegation stateid with the open stateid now having an incorrect seqid as it needs to be upgraded.",
      "ja": "2. Open StateIDを持つStateIDのみが、アップグレードする必要があるため、現在誤ったSQIDを持っています。"
    },
    {
      "indent": 8,
      "text": "3. Both an open stateid (which will be upgraded) and a delegation stateid.",
      "ja": "3. 開いたStateID（アップグレードされる）と代表団StateIDの両方。"
    },
    {
      "indent": 3,
      "text": "In this scenario, returning just a delegation stateid would hide information from the client. If the client already has an open stateid, then the server SHOULD ignore the OPEN4_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION flag and return both the open and delegation stateids.",
      "ja": "このシナリオでは、代表団のStateIDだけを返すと、クライアントからの情報が隠されます。クライアントが既にオープンStateIDを持っている場合、サーバーはOpen4_Share_Access_Want_open_xor_delegationフラグを無視し、OpenとDelegation Stateidsの両方を返します。"
    },
    {
      "indent": 0,
      "text": "4.1. Implementation Experience",
      "section_title": true,
      "ja": "4.1. 実装エクスペリエンス"
    },
    {
      "indent": 3,
      "text": "The CLOSE operation neither explicitly nor implicitly releases any delegation stateids. This is not symmetrical with the OPEN operation, which can grant both an open and a delegation stateid. This specification could have tried to extend the CLOSE operation to release both stateids, but implementation experience shows that is more costly than the approach that has been proposed.",
      "ja": "緊密な操作は、明示的にも暗黙的にも代表団のStateidsをリリースしません。これは、オープン操作と代表団の両方を付与することができるオープン操作と対称ではありません。この仕様は、両方のStateIDSをリリースするために緊密な操作を拡張しようとした可能性がありますが、実装エクスペリエンスは、提案されているアプローチよりも費用がかかることを示しています。"
    },
    {
      "indent": 3,
      "text": "Consider a small workload of creating a file with content. This involves three synchronous operations and one asynchronous operation with existing implementations:",
      "ja": "コンテンツを含むファイルを作成する小さなワークロードを検討してください。これには、3つの同期操作と、既存の実装を使用した1つの非同期操作が含まれます。"
    },
    {
      "indent": 6,
      "text": "* The first synchronous operation has to OPEN the file.",
      "ja": "* 最初の同期操作はファイルを開く必要があります。"
    },
    {
      "indent": 6,
      "text": "* The second synchronous operation performs the WRITE to the file.",
      "ja": "* 2番目の同期操作は、ファイルに書き込みを実行します。"
    },
    {
      "indent": 6,
      "text": "* The third synchronous operation has to CLOSE the file.",
      "ja": "* 3番目の同期操作では、ファイルを閉じる必要があります。"
    },
    {
      "indent": 6,
      "text": "* The asynchronous operation uses DELEGRETURN to return the delegation stateid.",
      "ja": "* 非同期操作は、Delegreturnを使用して、Delegation StateIDを返します。"
    },
    {
      "indent": 9,
      "text": "SEQ PUTFH OPEN GETFH GETATTR\nSEQ PUTFH WRITE GETATTR\nSEQ PUTFH CLOSE\n...\nSEQ PUTFH DELEGRETURN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With the proposed approach of setting the OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION flag during the OPEN, the number of operations is always three. The first two compounds are still synchronous, but the last is asynchronous. That is, since the client no longer has to send a CLOSE operation, it can delay the DELEGRETURN until either the server requests it back via delegation recall or garbage collection causes the client to return the stateid.",
      "ja": "OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATIONフラグをOPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR FLAGATIONの設定するアプローチがあるため、操作の数は常に3です。最初の2つの化合物はまだ同期していますが、最後は非同期です。つまり、クライアントは緊密な操作を送信する必要がなくなるため、サーバーが代表団のリコールを介してそれをリクエストするか、ガベージコレクションがクライアントにStateIDを返すまで削除を遅らせる可能性があります。"
    },
    {
      "indent": 9,
      "text": "SEQ PUTFH OPEN(OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION)\n    GETFH GETATTR\nSEQ PUTFH WRITE GETATTR\n...\nSEQ PUTFH DELEGRETURN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This approach reduces the cost of synchronous operations by 33% and the total number of operations by 25%. Contrast that with the alternative proposal of having CLOSE return both stateids, which would not reduce the number of synchronous operations.",
      "ja": "このアプローチにより、同期操作のコストが33％削減され、操作の総数が25％削減されます。それとは対照的に、同期操作の数を減らすことはできません。"
    },
    {
      "indent": 0,
      "text": "5. Proxying of Times",
      "section_title": true,
      "ja": "5. 時代のプロキシ"
    },
    {
      "indent": 3,
      "text": "When a client is granted a write delegation on a file, it becomes the authority for the file contents and associated attributes. If the server queries the client as to the state of the file via a CB_GETATTR, then according to the unextended NFSv4 protocol, it can only determine the size of the file and the change attribute. In the case of the client holding the delegation, it has the current values of the access and modify times. There is no way that other clients can have access to these values. To notify the server of the proxied values, the client could send a compound of the form SEQ, PUTFH, SETATTR (time_modify | time_access), DELEGRETURN; however, the SETATTR operation would cause either or both of the change attribute or time_metadata attribute to be modified to the current time on the server. There is no current provision to obtain these values before delegation return using CB_GETATTR. As a result, it cannot pass on these times to an application expecting POSIX compliance, as is often necessary for correct operation.",
      "ja": "クライアントがファイルに書き込み代表団を許可されると、ファイルの内容と関連属性の権限になります。サーバーがCB_GETATTRを介してファイルの状態についてクライアントをクエリする場合、Unexted NFSV4プロトコルに従って、ファイルのサイズと変更属性のみを決定することができます。代表団を保持しているクライアントの場合、アクセス時間と変更時間の現在の値があります。他のクライアントがこれらの値にアクセスできる方法はありません。サーバーにproxied値を通知するために、クライアントはフォームseq、putfh、setattr（time_modify | time_access）、delegreturnの化合物を送信できます。ただし、SetATTR操作により、変更属性またはTime_Metadata属性のいずれかまたは両方がサーバー上の現在の時刻に変更されます。CB_GetAttrを使用して委任が返される前に、これらの値を取得するための現在の規定はありません。その結果、正しい操作に必要なことがよくあるように、POSIXコンプライアンスを期待するアプリケーションにこれらの時間を渡すことはできません。"
    },
    {
      "indent": 3,
      "text": "With the addition of the new OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS flag, the client and server can negotiate that the client will be the authority for these values, and upon return of the delegation stateid via a DELEGRETURN, the times will be passed back to the server. If the server is queried by another client for either the size or the times, it will need to use a CB_GETATTR to query the client that holds the delegation.",
      "ja": "新しいopen4_share_access_want_deleg_timestampsフラグが追加されると、クライアントとサーバーは、クライアントがこれらの値の権限となることを交渉できます。サーバーがサイズまたは時間のいずれかについて別のクライアントによって照会されている場合、cb_getattrを使用して、代表団を保持しているクライアントを照会する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server informs the client via the fattr4_open_arguments attribute that it supports OPEN_ARGS_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS and it returns a valid delegation stateid for an OPEN operation that sets the OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS flag, then it MUST query the client via a CB_GETATTR for the fattr4_time_deleg_access attribute (see Section 5.2) and the fattr4_time_deleg_modify attribute (see Section 5.2). (Note that the change time can be derived from the modify time.) Further, when a server gets a SETATTR with those attributes set, then it MUST accept those changes in the fattr4_time_deleg_access and fattr4_time_deleg_modify attributes and derive the change time, or it MUST reject the changes with NFS4ERR_DELAY.",
      "ja": "サーバーがfattr4_open_arguments属性を介してクライアントに通知している場合、open_args_share_access_want_deleg_timestampsをサポートし、open4_share_access_want_want_deleg_timestamsを設定するOpen4_share_acses_want_deleg_timestamsを設定するオープンオペレーションのために有効な代表団Stateidを返します。FATTR4_TIME_DELEG_ACCESS属性（セクション5.2を参照）およびFATTR4_TIME_DELEG_MODIFY属性（セクション5.2を参照）。（変更時間は変更時間から導出できることに注意してください。）さらに、サーバーがそれらの属性を設定してsetATTRを取得すると、FATTR4_TIME_DELEG_ACCESSおよびFATTR4_TIME_DELEG_MODIFY属性の変更を受け入れ、変更時間を導き出す必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server grants a delegation stateid, it MUST inform the client by setting the appropriate flag in the open_delegation_type4 response. The server MUST set OPEN_DELEGATE_READ_ATTRS_DELEG when it grants a read attribute delegation and MUST set OPEN_DELEGATE_WRITE_ATTRS_DELEG when it grants a write attribute delegation.",
      "ja": "サーバーが代表団StateIDを付与する場合、Open_Delegation_Type4応答に適切なフラグを設定してクライアントに通知する必要があります。サーバーは、読み取り属性委任を許可し、open_delegate_write_attrs_delegをwrite属性代表団を付与するときにopen_delegate_read_attrs_delegを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "These new attributes are invalid to be used with GETATTR, VERIFY, and NVERIFY, and they can only be used with CB_GETATTR and SETATTR by a client holding an appropriate delegation. The SETATTR SHOULD be either 1) in a separate compound before the one containing the DELEGRETURN or 2) in the same compound as an operation before the DELEGRETURN. Failure to properly sequence the operations may lead to race conditions.",
      "ja": "これらの新しい属性は、getATTR、検証、およびnVerifyで使用されることが無効であり、適切な代表団を保持しているクライアントによってCB_GETATTRとSetATTRでのみ使用できます。Setattrは、1）削除を含む前の別の化合物のいずれか、2）削除前の操作と同じ化合物にある必要があります。操作を適切にシーケンスしないと、人種条件につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "A key prerequisite of this approach is that the server and client are in time synchronization with each other. Note that while the base NFSv4.2 does not require such synchronization, the use of RPCSEC_GSS typically makes such a requirement. When the client presents either the fattr4_time_deleg_access or the fattr4_time_deleg_modify attribute to the server, the server MUST decide for both of them whether the time presented is:",
      "ja": "このアプローチの重要な前提条件は、サーバーとクライアントが互いに時間内に同期していることです。ベースNFSV4.2にはそのような同期は必要ありませんが、RPCSEC_GSSを使用すると、そのような要件が必要になることに注意してください。クライアントがFATTR4_TIME_DELEG_ACCESSまたはFATTR4_TIME_DELEG_MODIFY属性をサーバーに提示する場合、サーバーは、提示された時間が次のかどうかを両方に決定する必要があります。"
    },
    {
      "indent": 6,
      "text": "* before the corresponding time_access attribute or time_modify attribute on the file, or",
      "ja": "* 対応するtime_access属性またはtime_modify属性の前に、または"
    },
    {
      "indent": 6,
      "text": "* past the current server time.",
      "ja": "* 現在のサーバー時間を超えて。"
    },
    {
      "indent": 3,
      "text": "When the time presented is before the original time, then the update is ignored. When the time presented is in the future, the server can either clamp the new time to the current time or return NFS4ERR_DELAY to the client, allowing it to retry. Note that if the clock skew is large, the delay approach would result in access to the file being denied until the clock skew is exceeded.",
      "ja": "提示された時間が元の時間の前にある場合、更新は無視されます。提示された時間が将来的になる場合、サーバーは現在の時間に新しい時間をクランプするか、nfs4err_delayをクライアントに返すことができ、再試行を可能にします。クロックスキューが大きい場合、遅延アプローチは、クロックスキューを超えるまでファイルにアクセスされるようになることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A change in the access time MUST NOT advance the change time, also known as the time_metadata attribute. However, a change in the modify time might advance the change time (and in turn, the change attribute). If the modify time is greater than the change time and before the current time, then the change time is adjusted to the modify time and not the current time (as is most likely done on most SETATTR calls that change the metadata). If the modify time is in the future, it will be clamped to the current time.",
      "ja": "アクセス時間の変更は、Time_metadata属性とも呼ばれる変更時間を前進させてはなりません。ただし、変更時間の変更は、変更時間を前進させる可能性があります（そして、変更属性）。変更時間が変更時間よりも大きい場合、現在の時間より前に、変更時間は現在の時間ではなく変更時間に調整されます（メタデータを変更するほとんどのSetATTRコールで行われる可能性が最も高い）。変更時間が将来的にある場合、現在の時間に固定されます。"
    },
    {
      "indent": 3,
      "text": "Note that each of the possible times (access, modify, and change) are compared to the current time. They should all be compared against the same time value for the current time (i.e., they do not retrieve a different value of the current time for each calculation).",
      "ja": "可能な時間（アクセス、変更、変更）のそれぞれが現在の時間と比較されることに注意してください。それらはすべて、現在の時間の同じ時間値と比較する必要があります（つまり、各計算の現在の時間の異なる値を取得しません）。"
    },
    {
      "indent": 3,
      "text": "If the client sets the OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS flag in an OPEN operation, then it MUST support the fattr4_time_deleg_access and fattr4_time_deleg_modify attributes in both the CB_GETATTR and SETATTR operations.",
      "ja": "クライアントがOpen4_Share_Access_Want_DELEG_TIMESTAMPSフラグをオープンオペレーションで設定する場合、CB_GetATTRとSetATTR操作の両方でfattr4_time_deleg_accessとfattr4_time_deleg_modify属性をサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1. Use Case for NFSv3 Client Proxy",
      "section_title": true,
      "ja": "5.1. NFSV3クライアントプロキシのユースケース"
    },
    {
      "indent": 3,
      "text": "Consider an NFSv3 client that wants to access data on a server that only supports NFSv4.2. An implementation may introduce an NFSv3 server that functions as an NFSv4.2 client, serving as a gateway between the two otherwise incompatible systems. As NFSv3 is a stateless protocol, the state is not kept on the client, but rather on the NFSv3 server. As the NFSv3 server is already managing the state, it can proxy file delegations to avoid spurious GETATTRs. That is, as the client queries the NFSv3 server for the attributes, they can be served without the NFSv3 server sending a GETATTR to the NFSv4.2 server.",
      "ja": "NFSV4.2のみをサポートするサーバー上のデータにアクセスしたいNFSV3クライアントを検討してください。実装により、NFSV4.2クライアントとして機能するNFSV3サーバーが導入される場合があり、それ以外の場合は互換性のない2つのシステム間のゲートウェイとして機能します。NFSV3はステートレスプロトコルであるため、状態はクライアントではなく、むしろNFSV3サーバーに保持されます。NFSV3サーバーはすでに状態を管理しているため、偽のgetattrsを避けるために委任をプロキシできます。つまり、クライアントが属性のNFSV3サーバーを照会するため、NFSV4.2サーバーにgetATTRを送信するNFSV3サーバーなしで提供できます。"
    },
    {
      "indent": 0,
      "text": "5.2. XDR for Proxying of Times",
      "section_title": true,
      "ja": "5.2. 時間のプロキシのためのXDR"
    },
    {
      "indent": 3,
      "text": "///\n/// /*\n///  * attributes for the delegation times being\n///  * cached and served by the \"client\"\n///  */\n/// typedef nfstime4        fattr4_time_deleg_access;\n/// typedef nfstime4        fattr4_time_deleg_modify;\n///\n///\n/// %/*\n/// % * New RECOMMENDED Attribute for\n/// % * delegation caching of times\n/// % */\n/// const FATTR4_TIME_DELEG_ACCESS  = 84;\n/// const FATTR4_TIME_DELEG_MODIFY  = 85;\n///\n///\n/// const OPEN4_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS = 0x100000;\n///\n/// enum open_delegation_type4 {\n///        OPEN_DELEGATE_NONE                  = 0,\n///        OPEN_DELEGATE_READ                  = 1,\n///        OPEN_DELEGATE_WRITE                 = 2,\n///        OPEN_DELEGATE_NONE_EXT              = 3, /* new to v4.1 */\n///        OPEN_DELEGATE_READ_ATTRS_DELEG      = 4,\n///        OPEN_DELEGATE_WRITE_ATTRS_DELEG     = 5\n/// };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Extraction of XDR",
      "section_title": true,
      "ja": "6. XDRの抽出"
    },
    {
      "indent": 3,
      "text": "This document contains the XDR [RFC4506] description of the new open flags for delegating the file to the client. The XDR description is embedded in this document in a way that makes it simple for the reader to extract into a ready-to-compile form. The reader can feed this document into the following shell script to produce the machine-readable XDR description of the new flags:",
      "ja": "このドキュメントには、ファイルをクライアントに委任するための新しいオープンフラグのXDR [RFC4506]の説明が含まれています。XDRの説明は、このドキュメントに埋め込まれており、読者がすぐにコンパイルできるフォームに抽出できるようにします。読者は、このドキュメントを次のシェルスクリプトにフィードして、新しいフラグの機械可読XDR説明を作成できます。"
    },
    {
      "indent": 3,
      "text": "#!/bin/sh\ngrep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "That is, if the above script is stored in a file called \"extract.sh\" and this document is in a file called \"spec.txt\", then the reader can do the following:",
      "ja": "つまり、上記のスクリプトが「extract.sh」というファイルに保存され、このドキュメントが「spec.txt」というファイルにある場合、読者は次のことを行うことができます。"
    },
    {
      "indent": 3,
      "text": "sh extract.sh < spec.txt > delstid_prot.x",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The effect of the script is to remove leading blank space from each line, plus a sentinel sequence of \"///\". XDR descriptions with the sentinel sequence are embedded throughout the document.",
      "ja": "スクリプトの効果は、各ラインから先頭の空白スペースを削除することと、「///」のセンチネルシーケンスを削除することです。センチネルシーケンスを使用したXDRの説明は、ドキュメント全体に埋め込まれています。"
    },
    {
      "indent": 3,
      "text": "Note that the XDR code contained in this document depends on types from the NFSv4.2 nfs4_prot.x file (generated from [RFC7863]). This includes both nfs types that end with a 4 (such as offset4 and length4) as well as more generic types (such as uint32_t and uint64_t).",
      "ja": "このドキュメントに含まれるXDRコードは、NFSV4.2 NFS4_PROT.Xファイル（[RFC7863]から生成）のタイプに依存することに注意してください。これには、4（Offset4やLength4など）とより一般的なタイプ（UINT32_TやUINT64_Tなど）で終了するNFSタイプの両方が含まれます。"
    },
    {
      "indent": 3,
      "text": "While the XDR can be appended to that from [RFC7863], the various code snippets belong in their respective areas of that XDR.",
      "ja": "XDRは[RFC7863]からそれに追加できますが、さまざまなコードスニペットはそのXDRのそれぞれの領域に属します。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "While this document extends some capabilities for client delegation, there are no new security concerns. The client cannot be queried by other clients as to the cached attributes. The client could report false data for the cached attributes, but it already has this ability via a SETATTR operation.",
      "ja": "このドキュメントは、クライアントの委任のためのいくつかの機能を拡張しますが、新しいセキュリティの懸念はありません。クライアントは、キャッシュされた属性に関して他のクライアントが照会することはできません。クライアントは、キャッシュされた属性の誤ったデータを報告することができますが、SetATTR操作を介してすでにこの機能を備えています。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 0,
      "text": "9. Normative References",
      "section_title": true,
      "ja": "9. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4506]  Eisler, M., Ed., \"XDR: External Data Representation\n           Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May\n           2006, <https://www.rfc-editor.org/info/rfc4506>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7862]  Haynes, T., \"Network File System (NFS) Version 4 Minor\n           Version 2 Protocol\", RFC 7862, DOI 10.17487/RFC7862,\n           November 2016, <https://www.rfc-editor.org/info/rfc7862>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7863]  Haynes, T., \"Network File System (NFS) Version 4 Minor\n           Version 2 External Data Representation Standard (XDR)\n           Description\", RFC 7863, DOI 10.17487/RFC7863, November\n           2016, <https://www.rfc-editor.org/info/rfc7863>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8178]  Noveck, D., \"Rules for NFSv4 Extensions and Minor\n           Versions\", RFC 8178, DOI 10.17487/RFC8178, July 2017,\n           <https://www.rfc-editor.org/info/rfc8178>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8881]  Noveck, D., Ed. and C. Lever, \"Network File System (NFS)\n           Version 4 Minor Version 1 Protocol\", RFC 8881,\n           DOI 10.17487/RFC8881, August 2020,\n           <https://www.rfc-editor.org/info/rfc8881>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Trond Myklebust, Tom Haynes, and David Flynn all worked on the prototype at Hammerspace.",
      "ja": "Trond Myklebust、Tom Haynes、およびDavid Flynnはすべて、Hammerspaceのプロトタイプに取り組んでいました。"
    },
    {
      "indent": 3,
      "text": "Dave Noveck, Chuck Lever, Rick Macklem, and Zaheduzzaman Sarker provided reviews of the document.",
      "ja": "Dave Noveck、Chuck Lever、Rick Macklem、およびZaheduzzaman Sarkerがドキュメントのレビューを提供しました。"
    },
    {
      "indent": 3,
      "text": "Jeff Layton provided experience from an implementation he authored.",
      "ja": "ジェフ・レイトンは、彼が執筆した実装から経験を提供しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Thomas Haynes\nHammerspace\nEmail: loghyr@hammerspace.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Trond Myklebust\nHammerspace\nEmail: trondmy@hammerspace.com",
      "raw": true,
      "ja": ""
    }
  ]
}