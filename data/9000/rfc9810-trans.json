{
  "title": {
    "text": "RFC 9810 - Internet X.509 Public Key Infrastructure -- Certificate Management Protocol (CMP)",
    "ja": "RFC 9810 - インターネットX.509公開キーインフラストラクチャ - 証明書管理プロトコル（CMP）"
  },
  "number": 9810,
  "created_at": "2025-07-31 23:24:09.191354+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                      H. Brockhaus\nRequest for Comments: 9810                                 D. von Oheimb\nObsoletes: 4210, 9480                                            Siemens\nUpdates: 5912                                               M. Ounsworth\nCategory: Standards Track                                        J. Gray\nISSN: 2070-1721                                                  Entrust\n                                                               July 2025",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Internet X.509 Public Key Infrastructure -- Certificate Management Protocol (CMP)",
      "section_title": true,
      "ja": "インターネットX.509公開キーインフラストラクチャ - 証明書管理プロトコル（CMP）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "section_title": true,
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Internet X.509 Public Key Infrastructure (PKI) Certificate Management Protocol (CMP). Protocol messages are defined for X.509v3 certificate creation and management. CMP provides interactions between client systems and PKI components such as a Registration Authority (RA) and a Certification Authority (CA).",
      "ja": "このドキュメントでは、インターネットX.509公開キーインフラストラクチャ（PKI）証明書管理プロトコル（CMP）について説明しています。プロトコルメッセージは、x.509v3証明書の作成と管理に対して定義されます。CMPは、クライアントシステムと登録機関（RA）や認定機関（CA）などのPKIコンポーネントとの相互作用を提供します。"
    },
    {
      "indent": 3,
      "text": "This document adds support for management of certificates containing a Key Encapsulation Mechanism (KEM) public key and uses EnvelopedData instead of EncryptedValue. This document also includes the updates specified in Section 2 and Appendix A.2 of RFC 9480.",
      "ja": "このドキュメントは、キーカプセル化メカニズム（KEM）の公開キーを含む証明書の管理のサポートを追加し、暗号化されたバリューではなく封筒を使用します。このドキュメントには、RFC 9480のセクション2および付録A.2で指定された更新も含まれています。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 4210, and together with RFC 9811, it also obsoletes RFC 9480. Appendix F of this document updates Section 9 of RFC 5912.",
      "ja": "このドキュメントはRFC 4210を廃止し、RFC 9811とともに、RFC 9480を廃止します。このドキュメントの付録Fは、RFC 5912のセクション9を更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "section_title": true,
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9810.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https://www.rfc-editor.org/info/rfc9810で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "section_title": true,
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2025 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2025 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、改訂されたBSDライセンスで説明されている保証なしで提供されるように、改訂されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "section_title": true,
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Changes Made by RFC 4210\n  1.2.  Updates Made by RFC 9480\n  1.3.  Changes Made by This Document\n2.  Terminology and Abbreviations\n3.  PKI Management Overview\n  3.1.  PKI Management Model\n    3.1.1.  Definitions of PKI Entities\n      3.1.1.1.  Subjects and End Entities\n      3.1.1.2.  Certification Authority\n      3.1.1.3.  Registration Authority\n      3.1.1.4.  Key Generation Authority\n    3.1.2.  PKI Management Requirements\n    3.1.3.  PKI Management Operations\n4.  Assumptions and Restrictions\n  4.1.  End Entity Initialization\n  4.2.  Initial Registration/Certification\n    4.2.1.  Criteria Used\n      4.2.1.1.  Initiation of Registration/Certification\n      4.2.1.2.  End Entity Message Origin Authentication\n      4.2.1.3.  Location of Key Generation\n      4.2.1.4.  Confirmation of Successful Certification\n    4.2.2.  Initial Registration/Certification Schemes\n      4.2.2.1.  Centralized Scheme\n      4.2.2.2.  Basic Authenticated Scheme\n  4.3.  POP of Private Key\n    4.3.1.  Signature Keys\n    4.3.2.  Encryption Keys\n    4.3.3.  Key Agreement Keys\n    4.3.4.  KEM Keys\n  4.4.  Root CA Key Update\n    4.4.1.  CA Operator Actions\n    4.4.2.  Verifying Certificates\n      4.4.2.1.  Verification in Cases 1 and 4\n      4.4.2.2.  Verification in Case 2\n      4.4.2.3.  Verification in Case 3\n    4.4.3.  Revocation - Change of the CA Key\n  4.5.  EKU for PKI Entities\n5.  Data Structures\n  5.1.  Overall PKI Message\n    5.1.1.  PKI Message Header\n      5.1.1.1.  ImplicitConfirm\n      5.1.1.2.  ConfirmWaitTime\n      5.1.1.3.  OrigPKIMessage\n      5.1.1.4.  CertProfile\n      5.1.1.5.  KemCiphertextInfo\n    5.1.2.  PKI Message Body\n    5.1.3.  PKI Message Protection\n      5.1.3.1.  Shared Secret Information\n      5.1.3.2.  DH Key Pairs\n      5.1.3.3.  Signature\n      5.1.3.4.  Key Encapsulation\n      5.1.3.5.  Multiple Protection\n  5.2.  Common Data Structures\n    5.2.1.  Requested Certificate Contents\n    5.2.2.  Encrypted Values\n    5.2.3.  Status Codes and Failure Information for PKI Messages\n    5.2.4.  Certificate Identification\n    5.2.5.  Out-of-Band Root CA Public Key\n    5.2.6.  Archive Options\n    5.2.7.  Publication Information\n    5.2.8.  POP Structures\n      5.2.8.1.  raVerified\n      5.2.8.2.  POPOSigningKey Structure\n      5.2.8.3.  POPOPrivKey Structure\n      5.2.8.4.  Summary of POP Options\n    5.2.9.  GeneralizedTime\n  5.3.  Operation-Specific Data Structures\n    5.3.1.  Initialization Request\n    5.3.2.  Initialization Response\n    5.3.3.  Certification Request\n    5.3.4.  Certification Response\n    5.3.5.  Key Update Request Content\n    5.3.6.  Key Update Response Content\n    5.3.7.  Key Recovery Request Content\n    5.3.8.  Key Recovery Response Content\n    5.3.9.  Revocation Request Content\n    5.3.10. Revocation Response Content\n    5.3.11. Cross-Certification Request Content\n    5.3.12. Cross-Certification Response Content\n    5.3.13. CA Key Update Announcement Content\n    5.3.14. Certificate Announcement\n    5.3.15. Revocation Announcement\n    5.3.16. CRL Announcement\n    5.3.17. PKI Confirmation Content\n    5.3.18. Certificate Confirmation Content\n    5.3.19. PKI General Message Content\n      5.3.19.1.  CA Protocol Encryption Certificate\n      5.3.19.2.  Signing Key Pair Types\n      5.3.19.3.  Encryption / Key Agreement Key Pair Types\n      5.3.19.4.  Preferred Symmetric Algorithm\n      5.3.19.5.  Updated CA Key Pair\n      5.3.19.6.  CRL\n      5.3.19.7.  Unsupported Object Identifiers\n      5.3.19.8.  Key Pair Parameters\n      5.3.19.9.  Revocation Passphrase\n      5.3.19.10. ImplicitConfirm\n      5.3.19.11. ConfirmWaitTime\n      5.3.19.12. Original PKIMessage\n      5.3.19.13. Supported Language Tags\n      5.3.19.14. CA Certificates\n      5.3.19.15. Root CA Update\n      5.3.19.16. Certificate Request Template\n      5.3.19.17. CRL Update Retrieval\n      5.3.19.18. KEM Ciphertext\n    5.3.20. PKI General Response Content\n    5.3.21. Error Message Content\n    5.3.22. Polling Request and Response\n6.  Mandatory PKI Management Functions\n  6.1.  Root CA Initialization\n  6.2.  Root CA Key Update\n  6.3.  Subordinate CA Initialization\n  6.4.  CRL Production\n  6.5.  PKI Information Request\n  6.6.  Cross-Certification\n    6.6.1.  One-Way Request-Response Scheme\n  6.7.  End Entity Initialization\n    6.7.1.  Acquisition of PKI Information\n    6.7.2.  Out-of-Band Verification of the Root CA Key\n  6.8.  Certificate Request\n  6.9.  Key Update\n7.  Version Negotiation\n  7.1.  Supporting RFC 2510 Implementations\n    7.1.1.  Clients Talking to RFC 2510 Servers\n    7.1.2.  Servers Receiving Version cmp1999 PKIMessages\n8.  Security Considerations\n  8.1.  On the Necessity of POP\n  8.2.  POP with a Decryption Key\n  8.3.  POP by Exposing the Private Key\n  8.4.  Attack Against DH Key Exchange\n  8.5.  Perfect Forward Secrecy\n  8.6.  Private Keys for Certificate Signing and CMP Message\n         Protection\n  8.7.  Entropy of Random Numbers, Key Pairs, and Shared Secret\n         Information\n  8.8.  Recurring Usage of KEM Keys for Message Protection\n  8.9.  Trust Anchor Provisioning Using CMP Messages\n  8.10. Authorizing Requests for Certificates with Specific EKUs\n  8.11. Usage of CT Logs\n9.  IANA Considerations\n10. References\n  10.1.  Normative References\n  10.2.  Informative References\nAppendix A.  Reasons for the Presence of RAs\nAppendix B.  The Use of Revocation Passphrase\nAppendix C.  PKI Management Message Profiles (REQUIRED)\n  C.1.  General Rules for Interpretation of These Profiles\n  C.2.  Algorithm Use Profile\n  C.3.  POP Profile\n  C.4.  Initial Registration/Certification (Basic Authenticated\n        Scheme)\n  C.5.  Certificate Request\n  C.6.  Key Update Request\nAppendix D.  PKI Management Message Profiles (OPTIONAL)\n  D.1.  General Rules for Interpretation of These Profiles\n  D.2.  Algorithm Use Profile\n  D.3.  Self-Signed Certificates\n  D.4.  Root CA Key Update\n  D.5.  PKI Information Request/Response\n  D.6.  Cross-Certification Request/Response (1-way)\n  D.7.  In-Band Initialization Using External Identity Certificate\nAppendix E.  Variants of Using KEM Keys for PKI Message Protection\nAppendix F.  Compilable ASN.1 Definitions\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the Internet X.509 PKI CMP. Protocol messages are defined for certificate creation and management. The term \"certificate\" in this document refers to an X.509v3 certificate as defined in [RFC5280].",
      "ja": "このドキュメントでは、インターネットx.509 PKI CMPについて説明しています。プロトコルメッセージは、証明書の作成と管理のために定義されています。このドキュメントの「証明書」という用語は、[RFC5280]で定義されているX.509V3証明書を指します。"
    },
    {
      "indent": 0,
      "text": "1.1. Changes Made by RFC 4210",
      "section_title": true,
      "ja": "1.1. RFC 4210による変更"
    },
    {
      "indent": 3,
      "text": "[RFC4210] differs from [RFC2510] in the following areas:",
      "ja": "[RFC4210]は、次の領域で[RFC2510]とは異なります。"
    },
    {
      "indent": 6,
      "text": "* The PKI management message profile section is split to two appendices: the required profile and the optional profile. Some of the formerly mandatory functionality is moved to the optional profile.",
      "ja": "* PKI管理メッセージプロファイルセクションは、必要なプロファイルとオプションプロファイルの2つの付録に分割されます。以前の必須機能の一部は、オプションのプロファイルに移動されます。"
    },
    {
      "indent": 6,
      "text": "* The message confirmation mechanism has changed substantially.",
      "ja": "* メッセージ確認メカニズムは大幅に変化しました。"
    },
    {
      "indent": 6,
      "text": "* A new polling mechanism is introduced, deprecating the old polling method at the CMP transport level.",
      "ja": "* CMP輸送レベルで古いポーリング方法を非難し、新しいポーリングメカニズムが導入されています。"
    },
    {
      "indent": 6,
      "text": "* The CMP transport protocol issues are handled in a separate document [RFC6712], thus the \"Transports\" section is removed.",
      "ja": "* CMPトランスポートプロトコルの問題は、別のドキュメント[RFC6712]で処理されるため、「輸送」セクションが削除されます。"
    },
    {
      "indent": 6,
      "text": "* A new implicit confirmation method is introduced to reduce the number of protocol messages exchanged in a transaction.",
      "ja": "* トランザクションで交換されるプロトコルメッセージの数を減らすために、新しい暗黙の確認方法が導入されています。"
    },
    {
      "indent": 6,
      "text": "* The new specification contains some less prominent protocol enhancements and improved explanatory text on several issues.",
      "ja": "* 新しい仕様には、いくつかの顕著なプロトコルの強化といくつかの問題に関する説明テキストが改善されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Updates Made by RFC 9480",
      "section_title": true,
      "ja": "1.2. RFC 9480が作成した更新"
    },
    {
      "indent": 3,
      "text": "CMP Updates [RFC9480] and CMP Algorithms [RFC9481] updated [RFC4210], supporting the PKI management operations specified in the Lightweight CMP Profile [RFC9483], in the following areas:",
      "ja": "CMPは[RFC9480]およびCMPアルゴリズム[RFC9481]を更新し、[RFC4210]を更新し、次の領域で軽量CMPプロファイル[RFC9483]で指定されたPKI管理操作をサポートします。"
    },
    {
      "indent": 6,
      "text": "* Added new extended key usages (EKUs) for various CMP server types, e.g., RA and CA, to express the authorization of the certificate holder that acts as the indicated type of PKI management entity.",
      "ja": "* さまざまなCMPサーバータイプ、たとえばRAやCAの新しい拡張キー使用法（EKU）を追加して、指定されたタイプのPKI管理エンティティとして機能する証明書所有者の承認を表明しました。"
    },
    {
      "indent": 6,
      "text": "* Extended the description of multiple protection to cover additional use cases, e.g., batch processing of messages.",
      "ja": "* 追加のユースケース、たとえばメッセージのバッチ処理をカバーするために、複数の保護の説明を拡張しました。"
    },
    {
      "indent": 6,
      "text": "* Used the Cryptographic Message Syntax (CMS) [RFC5652] type EnvelopedData as the preferred choice instead of EncryptedValue to better support crypto agility in CMP.",
      "ja": "* 暗号化されたメッセージの構文（CMS）[RFC5652]を使用して、CMPの暗号性の俊敏性をより適切にサポートするために、暗号化されたバリューの代わりに、封筒として優先選択としてタイプを使用しました。"
    },
    {
      "indent": 10,
      "text": "For reasons of completeness and consistency, the type EncryptedValue has been exchanged in all occurrences. This includes the protection of centrally generated private keys, encryption of certificates, Proof-of-Possession (POP) methods, and protection of revocation passphrases. To properly differentiate the support of EnvelopedData instead of EncryptedValue, CMP version 3 is introduced in case a transaction is supposed to use EnvelopedData.",
      "ja": "完全性と一貫性の理由により、タイプの暗号化されたバリューはすべての出来事で交換されています。これには、中央に生成されたプライベートキーの保護、証明書の暗号化、所有証明（POP）方法、および取り消しパスフレーゼの保護が含まれます。暗号化されたValueの代わりにEnvelopedDataのサポートを適切に区別するために、CMPバージョン3は、トランザクションがEnvelopedDataを使用することになっている場合に導入されます。"
    },
    {
      "indent": 10,
      "text": "Note: According to point 9 in Section 2.1 of [RFC4211], the use of the EncryptedValue structure has been deprecated in favor of the EnvelopedData structure. [RFC4211] offers the EncryptedKey structure a choice of EncryptedValue and EnvelopedData for migration to EnvelopedData.",
      "ja": "注：[RFC4211]のセクション2.1のポイント9によると、暗号化された値構造の使用は、封筒構造を支持して非推奨されています。[RFC4211]は、暗号化されたキー構造に、暗号化されたバリューと封筒の選択の選択を提供します。"
    },
    {
      "indent": 6,
      "text": "* Offered an optional hashAlg field in CertStatus supporting cases when a certificate needs to be confirmed, but the certificate was signed using a signature algorithm that does not indicate a specific hash algorithm to use for computing the certHash. This is also in preparation for upcoming post-quantum algorithms.",
      "ja": "* 証明書を確認する必要がある場合、証明書をサポートするケースをサポートするcertStatusでオプションのハスハルグフィールドを提供しましたが、証明書は、Certhashの計算に使用する特定のハッシュアルゴリズムを示さない署名アルゴリズムを使用して署名されました。これは、今後のQuantum後のアルゴリズムにも備えています。"
    },
    {
      "indent": 6,
      "text": "* Added new general message types to request CA certificates, a root CA update, a certificate request template, or Certificate Revocation List (CRL) updates.",
      "ja": "* CA証明書、ルートCAアップデート、証明書リクエストテンプレート、または証明書の取り消しリスト（CRL）アップデートを要求する新しい一般的なメッセージタイプが追加されました。"
    },
    {
      "indent": 6,
      "text": "* Extended the use of polling to p10cr, certConf, rr, genm, and error messages.",
      "ja": "* ポーリングの使用をP10CR、CERTCONF、RR、GENM、およびエラーメッセージに拡張しました。"
    },
    {
      "indent": 6,
      "text": "* Deleted the mandatory algorithm profile in Appendix C.2 and instead referred to Section 7 of [RFC9481].",
      "ja": "* 付録C.2の必須アルゴリズムプロファイルを削除し、代わりに[RFC9481]のセクション7を参照しました。"
    },
    {
      "indent": 6,
      "text": "* Added Sections 8.6, 8.7, 8.9, and 8.10 to the security considerations.",
      "ja": "* セキュリティ上の考慮事項にセクション8.6、8.7、8.9、および8.10を追加しました。"
    },
    {
      "indent": 0,
      "text": "1.3. Changes Made by This Document",
      "section_title": true,
      "ja": "1.3. このドキュメントによって行われた変更"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC4210] and [RFC9480].",
      "ja": "この文書は、[RFC4210]および[RFC9480]を廃止します。"
    },
    {
      "indent": 3,
      "text": "Backward compatibility with CMP version 2 is maintained wherever possible. Updates to CMP version 2 improve crypto agility, extend the polling mechanism, add new general message types, and add EKUs to identify special CMP server authorizations. CMP version 3 is introduced for changes to the ASN.1 syntax, which support EnvelopedData, certConf with hashAlg, POPOPrivKey with agreeMAC, and RootCaKeyUpdateContent in ckuann messages.",
      "ja": "CMPバージョン2との後方互換性は、可能な限り維持されます。CMPバージョン2の更新は、暗号の俊敏性を改善し、ポーリングメカニズムを拡張し、新しい一般的なメッセージタイプを追加し、EKUを追加して特別なCMPサーバーの認可を特定します。CMPバージョン3は、asn.1の構文の変更について導入されます。これは、封筒、hashalgを備えた証明書、ckuannメッセージのrootcakeyupdatecontentをサポートします。"
    },
    {
      "indent": 3,
      "text": "The updates made in this document include the changes specified by Section 2 and Appendix A.2 of [RFC9480] as described in Section 1.2. Additionally, this document updates the content of [RFC4210] in the following areas:",
      "ja": "このドキュメントで行われた更新には、セクション1.2で説明されている[RFC9480]のセクション2および付録A.2で指定された変更が含まれます。さらに、このドキュメントは、次の領域の[RFC4210]のコンテンツを更新します。"
    },
    {
      "indent": 6,
      "text": "* Added Section 3.1.1.4 introducing the Key Generation Authority (KGA).",
      "ja": "* セクション3.1.1.4を追加して、主要生成局（KGA）を紹介しました。"
    },
    {
      "indent": 6,
      "text": "* Extended Section 3.1.2 regarding use of Certificate Transparency (CT) logs.",
      "ja": "* 証明書の透明性（CT）ログの使用に関するセクション3.1.2拡張。"
    },
    {
      "indent": 6,
      "text": "* Updated Section 4.4 introducing RootCaKeyUpdateContent as an alternative to using a repository to acquire new root CA certificates.",
      "ja": "* 更新されたセクション4.4 rootcakeyupdatecontentの導入リポジトリを使用して新しいルートCA証明書を取得する代わりに。"
    },
    {
      "indent": 6,
      "text": "* Added Section 5.1.1.3 containing a description of origPKIMessage content, moved here from Section 5.1.3.4.",
      "ja": "* セクション5.1.3.4からここに移動したOrigpKimessageコンテンツの説明を含むセクション5.1.1.3を追加しました。"
    },
    {
      "indent": 6,
      "text": "* Added support for KEM keys for POP to Sections 4.3 and 5.2.8, for message protection to Sections 5.1.1 and 5.1.3.4 and Appendix E, and for usage with CMS EnvelopedData to Section 5.2.2.",
      "ja": "* セクション4.3および5.2.8へのPOPのKEMキーのサポートを追加し、セクション5.1.1および5.1.3.4および付録Eへのメッセージ保護、およびCMS EnvelopedDataでのセクション5.2.2の使用のためのサポートを追加しました。"
    },
    {
      "indent": 6,
      "text": "* Deprecated CAKeyUpdAnnContent in favor of RootCaKeyUpdateContent.",
      "ja": "* rootcakeyupdatecontentを支持して、cakeyupdanncontentを非推奨。"
    },
    {
      "indent": 6,
      "text": "* Incorporated the request message behavioral clarifications from Appendix C of [RFC4210] to Section 5. The definition of altCertTemplate was incorporated into Section 5.2.1, and the clarification on POPOSigningKey and on POPOPrivKey was incorporated into Section 5.2.8.",
      "ja": "* [RFC4210]の付録Cから[RFC4210]の付録Cからセクション5までのリクエストメッセージの動作の明確化を組み込みました。AltCertTemplateの定義はセクション5.2.1に組み込まれ、PoposimingKeyおよびPopoprivkeyの明確化がセクション5.2.8に組み込まれました。"
    },
    {
      "indent": 6,
      "text": "* Added support for CMS EnvelopedData to different POP methods for transferring encrypted private keys, certificates, and challenges to Section 5.2.8.",
      "ja": "* CMS EnvelopedDataのサポートが、暗号化されたプライベートキー、証明書、およびセクション5.2.8に課題を転送するためのさまざまなPOPメソッドに追加されました。"
    },
    {
      "indent": 6,
      "text": "* Added Sections 8.1, 8.5, 8.8, and 8.11 to the security considerations.",
      "ja": "* セキュリティ上の考慮事項にセクション8.1、8.5、8.8、および8.11を追加しました。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Abbreviations",
      "section_title": true,
      "ja": "2. 用語と略語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "このドキュメント内のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、ここに示すようにすべて大文字で表示されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document relies on the terminology defined in [RFC5280]. The most important abbreviations are listed below:",
      "ja": "このドキュメントは、[RFC5280]で定義されている用語に依存しています。最も重要な略語を以下に示します。"
    },
    {
      "indent": 3,
      "text": "CA:",
      "ja": "CA:"
    },
    {
      "indent": 12,
      "text": "Certification Authority",
      "ja": "認証機関"
    },
    {
      "indent": 3,
      "text": "CMP:",
      "ja": "CMP:"
    },
    {
      "indent": 12,
      "text": "Certificate Management Protocol",
      "ja": "証明書管理プロトコル"
    },
    {
      "indent": 3,
      "text": "CMS:",
      "ja": "CMS:"
    },
    {
      "indent": 12,
      "text": "Cryptographic Message Syntax",
      "ja": "暗号化メッセージ構文"
    },
    {
      "indent": 3,
      "text": "CRL:",
      "ja": "CRL:"
    },
    {
      "indent": 12,
      "text": "Certificate Revocation List",
      "ja": "証明書の取り消しリスト"
    },
    {
      "indent": 3,
      "text": "CRMF:",
      "ja": "CRMF："
    },
    {
      "indent": 12,
      "text": "Certificate Request Message Format",
      "ja": "証明書リクエストメッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "KEM:",
      "ja": "KEM:"
    },
    {
      "indent": 12,
      "text": "Key Encapsulation Mechanism",
      "ja": "キーカプセル化メカニズム"
    },
    {
      "indent": 3,
      "text": "KGA:",
      "ja": "KGA:"
    },
    {
      "indent": 12,
      "text": "Key Generation Authority",
      "ja": "主要な世代の権限"
    },
    {
      "indent": 3,
      "text": "LRA:",
      "ja": "LRA:"
    },
    {
      "indent": 12,
      "text": "Local Registration Authority",
      "ja": "地方登録機関"
    },
    {
      "indent": 3,
      "text": "MAC:",
      "ja": "MAC:"
    },
    {
      "indent": 12,
      "text": "Message Authentication Code",
      "ja": "メッセージ認証コード"
    },
    {
      "indent": 3,
      "text": "PKI:",
      "ja": "PKI:"
    },
    {
      "indent": 12,
      "text": "Public Key Infrastructure",
      "ja": "公開鍵インフラストラクチャ"
    },
    {
      "indent": 3,
      "text": "POP:",
      "ja": "POP:"
    },
    {
      "indent": 12,
      "text": "Proof-of-Possession",
      "ja": "所有の証明"
    },
    {
      "indent": 3,
      "text": "RA:",
      "ja": "RA:"
    },
    {
      "indent": 12,
      "text": "Registration Authority",
      "ja": "登録機関"
    },
    {
      "indent": 3,
      "text": "TEE:",
      "ja": "TEE:"
    },
    {
      "indent": 12,
      "text": "Trusted Execution Environment",
      "ja": "信頼できる実行環境"
    },
    {
      "indent": 0,
      "text": "3. PKI Management Overview",
      "section_title": true,
      "ja": "3. PKI管理の概要"
    },
    {
      "indent": 3,
      "text": "The PKI must be structured to be consistent with the types of individuals who must administer it. Providing such administrators with unbounded choices not only complicates the software required but also increases the chances that a subtle mistake by an administrator or software developer will result in broader compromise. Similarly, restricting administrators with cumbersome mechanisms will cause them not to use the PKI.",
      "ja": "PKIは、それを管理しなければならない個人のタイプと一致するように構成する必要があります。このような管理者に無制限の選択肢を提供することは、必要なソフトウェアを複雑にするだけでなく、管理者またはソフトウェア開発者による微妙な間違いがより広範な妥協をもたらす可能性を高めます。同様に、管理者を扱いにくいメカニズムで制限すると、PKIを使用しません。"
    },
    {
      "indent": 3,
      "text": "Management protocols are REQUIRED to support online interactions between PKI components. For example, a management protocol might be used between a CA and a client system with which a key pair is associated or between two CAs that issue cross-certificates for each other.",
      "ja": "PKIコンポーネント間のオンラインインタラクションをサポートするには、管理プロトコルが必要です。たとえば、管理プロトコルは、CAとキーペアが関連付けられているクライアントシステムの間で使用される場合があります。"
    },
    {
      "indent": 0,
      "text": "3.1. PKI Management Model",
      "section_title": true,
      "ja": "3.1. PKI管理モデル"
    },
    {
      "indent": 3,
      "text": "Before specifying particular message formats and procedures, we first define the entities involved in PKI management and their interactions (in terms of the PKI management functions required). We then group these functions in order to accommodate different identifiable types of end entities.",
      "ja": "特定のメッセージ形式と手順を指定する前に、まずPKI管理に関与するエンティティとその相互作用を定義します（必要なPKI管理機能の観点から）。次に、さまざまな識別可能なタイプのエンティティに対応するために、これらの関数をグループ化します。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Definitions of PKI Entities",
      "section_title": true,
      "ja": "3.1.1. PKIエンティティの定義"
    },
    {
      "indent": 3,
      "text": "The entities involved in PKI management include the end entity (i.e., the entity to whom the certificate is issued) and the CA (i.e., the entity that issues the certificate). An RA might also be involved in PKI management.",
      "ja": "PKI管理に関与するエンティティには、最終エンティティ（つまり、証明書が発行されるエンティティ）とCA（つまり、証明書を発行するエンティティ）が含まれます。RAはPKI管理にも関与している可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1. Subjects and End Entities",
      "section_title": true,
      "ja": "3.1.1.1. 主題とエンティティ"
    },
    {
      "indent": 3,
      "text": "The term \"subject\" is used here to refer to the entity to whom the certificate is issued, typically named in the subject or subjectAltName field of a certificate. When we wish to distinguish the tools and/or software used by the subject (e.g., a local certificate management module), we will use the term \"subject equipment\". In general, the term \"end entity\", rather than \"subject\", is preferred in order to avoid confusion with the field name. It is important to note that the end entities here will include not only human users of applications but also applications themselves (e.g., for Internet Key Exchange Protocol (IKE) / IPsec) or devices (e.g., routers or industrial control systems). This factor influences the protocols that the PKI management operations use; for example, application software is far more likely to know exactly which certificate extensions are required than are human users. PKI management entities are also end entities in the sense that they are sometimes named in the subject or subjectAltName field of a certificate or cross-certificate. Where appropriate, the term \"end entity\" will be used to refer to end entities who are not PKI management entities.",
      "ja": "「件名」という用語は、証明書が発行されるエンティティを指すために使用されます。主題が使用するツールやソフトウェア（現地証明書管理モジュールなど）を区別したい場合は、「主題機器」という用語を使用します。一般に、フィールド名との混乱を避けるために、「主題」よりも「終了エンティティ」という用語が好まれます。ここの最終エンティティには、アプリケーションの人間ユーザーだけでなく、アプリケーション自体（たとえば、インターネットキーエクスチェンジプロトコル（IKE） / IPSEC）またはデバイス（ルーターや産業制御システムなど）も含まれることに注意することが重要です。この要因は、PKI管理操作が使用するプロトコルに影響を与えます。たとえば、アプリケーションソフトウェアは、人間のユーザーよりもどの証明書拡張機能が必要かを正確に知る可能性がはるかに高くなります。PKI管理エンティティは、証明書またはクロス認証の主題またはsubjectnameフィールドで時々命名されるという意味で、エンティティも終了します。必要に応じて、「終了エンティティ」という用語は、PKI管理エンティティではないエンディティを指すために使用されます。"
    },
    {
      "indent": 3,
      "text": "All end entities require secure local access to some information -- at a minimum, their own name and private key, the name of a CA that is directly trusted by this entity, and that CA's public key (or a fingerprint of the public key where a self-certified version is available elsewhere). Implementations MAY use secure local storage for more than this minimum (e.g., the end entity's own certificates or application-specific information). The form of storage will also vary -- from files to tamper-resistant cryptographic tokens. The information stored in such local, trusted storage is referred to here as the end entity's TEE, also known as Personal Security Environment (PSE).",
      "ja": "すべてのエンティティには、少なくとも独自の名前、秘密鍵、このエンティティから直接信頼されているCAの名前、およびCAの公開鍵（または自己認証バージョンが他の場所で利用可能な公開鍵の指紋）の名前を安全にアクセスする必要があります。実装は、この最小限よりも安全なローカルストレージを使用する場合があります（例：End Entity独自の証明書またはアプリケーション固有の情報）。ストレージの形式も異なります - ファイルから抵抗性のある暗号化トークンまで。このようなローカルで信頼できるストレージに保存されている情報は、ここでは、個人セキュリティ環境（PSE）としても知られている最終エンティティのティーと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Though TEE formats are beyond the scope of this document (they are very dependent on equipment, et cetera), a generic interchange format for TEEs is defined here: a certification response message (see Section 5.3.4) MAY be used.",
      "ja": "TEE形式はこのドキュメントの範囲を超えていますが（機器などに非常に依存しています）、TEEの一般的な交換形式はここで定義されています。認定応答メッセージ（セクション5.3.4を参照）を使用できます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.2. Certification Authority",
      "section_title": true,
      "ja": "3.1.1.2. 認証機関"
    },
    {
      "indent": 3,
      "text": "The CA may or may not actually be a real \"third party\" from the end entity's point of view. Quite often, the CA will actually belong to the same organization as the end entities it supports.",
      "ja": "CAは、実際には、エンティティの視点から実際に「サードパーティ」である場合があります。多くの場合、CAは実際にサポートする最終エンティティと同じ組織に属します。"
    },
    {
      "indent": 3,
      "text": "Again, we use the term \"CA\" to refer to the entity named in the issuer field of a certificate. When it is necessary to distinguish the software or hardware tools used by the CA, we use the term \"CA equipment\".",
      "ja": "繰り返しますが、「CA」という用語を使用して、証明書の発行者フィールドで指定されたエンティティを参照します。CAが使用するソフトウェアまたはハードウェアツールを区別する必要がある場合は、「CA機器」という用語を使用します。"
    },
    {
      "indent": 3,
      "text": "The CA equipment will often include both an \"offline\" component and an \"online\" component, with the CA private key only available to the \"offline\" component. This is, however, a matter for implementers (though it is also relevant as a policy issue).",
      "ja": "CA機器には、多くの場合、「オフライン」コンポーネントと「オンライン」コンポーネントの両方が含まれ、CAの秘密鍵は「オフライン」コンポーネントのみが利用できます。ただし、これは実装者にとっての問題です（ただし、ポリシーの問題としても関連しています）。"
    },
    {
      "indent": 3,
      "text": "We use the term \"root CA\" to indicate a CA that is directly trusted by an end entity; that is, securely acquiring the value of a root CA public key requires some out-of-band step(s). This term is not meant to imply that a root CA is necessarily at the top of any hierarchy, simply that the CA in question is trusted directly. The \"root CA\" may provide its trust anchor information with or without using a certificate. In some circumstances, such a certificate may be self-signed, but in other circumstances, it may be cross-signed, signed by a peer, signed by a superior CA, or unsigned.",
      "ja": "「ルートCA」という用語を使用して、最終エンティティによって直接信頼されるCAを示します。つまり、ルートCAの公開キーの価値を安全に取得するには、バンド外のステップが必要です。この用語は、ルートCAが必然的に階層の一番上にあることを意味するものではなく、問題のCAが直接信頼されていることを意味します。「ルートCA」は、証明書の有無にかかわらず、信頼のアンカー情報を提供する場合があります。状況によっては、そのような証明書は自己署名されている場合がありますが、他の状況では、それはクロス署名、ピアによって署名されたり、優れたCAによって署名されたり、署名されていない場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that other documents like [X509.2019] and [RFC5280] use the term \"trusted CA\" or \"trust anchor\" instead of \"root CA\". This document continues using \"root CA\" based on the above definition because it is also present in the ASN.1 syntax that cannot be changed easily.",
      "ja": "[X509.2019]や[RFC5280]などの他のドキュメントは、「ルートCA」ではなく「信頼できるCA」または「信頼アンカー」という用語を使用していることに注意してください。このドキュメントは、上記の定義に基づいて「ルートCA」を使用しています。これは、簡単に変更できないASN.1構文にも存在するためです。"
    },
    {
      "indent": 3,
      "text": "A \"subordinate CA\" is one that is not a root CA for the end entity in question. Often, a subordinate CA will not be a root CA for any entity, but this is not mandatory.",
      "ja": "「下位CA」は、問題の最終エンティティのルートCAではないものです。多くの場合、下位CAはどのエンティティにとってもルートCAではありませんが、これは必須ではありません。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3. Registration Authority",
      "section_title": true,
      "ja": "3.1.1.3. 登録機関"
    },
    {
      "indent": 3,
      "text": "In addition to end entities and CAs, many environments call for the existence of an RA separate from the CA. The functions that the RA may carry out will vary from case to case but MAY include identity checking, token distribution, checking certificate requests and authentication of their origin, revocation reporting, name assignment, archival of key pairs, et cetera.",
      "ja": "エンディティとCAに加えて、多くの環境では、CAとは別のRAの存在が必要です。RAが実行する可能性のある機能は、ケースごとに異なりますが、身元確認、トークン分布、オリジンの認証と認証、取り消し報告、名前の割り当て、キーペアのアーカイブ、ET CETERAが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "This document views the RA as an OPTIONAL component: When it is not present, the CA is assumed to be able to carry out the RA's functions so that the PKI management protocols are the same from the end entity's point of view.",
      "ja": "このドキュメントでは、RAをオプションのコンポーネントと見なします。それが存在しない場合、CAはRAの関数を実行できると想定されているため、PKI管理プロトコルがエンティティの視点から同じになります。"
    },
    {
      "indent": 3,
      "text": "Again, we distinguish, where necessary, between the RA and the tools used (the \"RA equipment\").",
      "ja": "繰り返しますが、必要に応じて、使用されたRAと使用されたツール（「RA装置」）を区別します。"
    },
    {
      "indent": 3,
      "text": "Note that an RA is itself an end entity. We further assume that all RAs are in fact certified end entities and that RAs have private keys that are usable for signing. How a particular CA equipment identifies some end entities as RAs is an implementation issue (i.e., this document specifies no special RA certification operation). We do not mandate that the RA is certified by the CA with which it is interacting at the moment (so one RA may work with more than one CA whilst only being certified once).",
      "ja": "RAはそれ自体が最終エンティティであることに注意してください。さらに、すべてのRAが実際に認定された最終エンティティであり、RAには署名に使用できるプライベートキーがあると仮定します。RASが実装の問題であるため、特定のCA機器がいくつかのエンティティを識別する方法（つまり、このドキュメントは特別なRA認証操作を指定していません）。RAが現時点で相互作用しているCAによって認定されていることを義務付けません（したがって、1つのRAは1回しか認定されていないが、複数のCAで動作する可能性があります）。"
    },
    {
      "indent": 3,
      "text": "In some circumstances, end entities will communicate directly with a CA even where an RA is present. For example, for initial registration and/or certification, the end entity may use its RA but communicate directly with the CA in order to refresh its certificate.",
      "ja": "状況によっては、最終エンティティはRAが存在する場合でもCAと直接通信します。たとえば、初期登録および/または認定の場合、最終エンティティはRAを使用する場合がありますが、証明書を更新するためにCAと直接通信します。"
    },
    {
      "indent": 0,
      "text": "3.1.1.4. Key Generation Authority",
      "section_title": true,
      "ja": "3.1.1.4. 主要な世代の権限"
    },
    {
      "indent": 3,
      "text": "A KGA is a PKI management entity generating key pairs on behalf of an end entity. As the KGA generates the key pair, it knows the public and the private part.",
      "ja": "KGAは、終了エンティティに代わってキーペアを生成するPKI管理エンティティです。KGAがキーペアを生成すると、公衆と私的部分を知っています。"
    },
    {
      "indent": 3,
      "text": "This document views the KGA as an OPTIONAL component. When it is not present and central key generation is needed, the CA is assumed to be able to carry out the KGA's functions so that the PKI management protocol messages are the same from the end entity's point of view. If certain tasks of a CA are delegated to other components, this delegation needs authorization, which can be indicated by EKUs (see Section 4.5).",
      "ja": "このドキュメントでは、KGAをオプションのコンポーネントと見なしています。PKI管理プロトコルメッセージが終了エンティティの観点から同じになるように、CAは存在しない場合、CAはKGAの機能を実行できると想定されています。CAの特定のタスクが他のコンポーネントに委任された場合、この代表団はEKUで示される可能性があります（セクション4.5を参照）。"
    },
    {
      "indent": 3,
      "text": "Note: When doing central generation of key pairs, implementers should consider the implications of server-side retention on the overall security of the system; in some cases, retention is good, for example, for escrow reasons, but in other cases, the server should clear its copy after delivery to the end entity.",
      "ja": "注：重要なペアの中央生成を行う場合、実装者は、システムの全体的なセキュリティに対するサーバー側の保持の意味を考慮する必要があります。場合によっては、例えばエスクロー上の理由で保持が良好ですが、他の場合には、サーバーはエンティティへの配信後にコピーをクリアする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: If the CA delegates key generation to a KGA, the KGA can be collocated with the RA.",
      "ja": "注：CAがKGAにキージェネレーションを代表する場合、KGAをRAと協力できます。"
    },
    {
      "indent": 0,
      "text": "3.1.2. PKI Management Requirements",
      "section_title": true,
      "ja": "3.1.2. PKI管理要件"
    },
    {
      "indent": 3,
      "text": "The protocols given here meet the following requirements on PKI management",
      "ja": "ここで与えられたプロトコルは、PKI管理に関する次の要件を満たしています"
    },
    {
      "indent": 10,
      "text": "1. PKI management must conform to the ISO/IEC 9594-8/ITU-T X.509 standards, in particular [X509.2019].",
      "ja": "1. PKI管理は、特に[X509.2019]、ISO/IEC 9594-8/ITU-T X.509標準に準拠する必要があります。"
    },
    {
      "indent": 10,
      "text": "2. It must be possible to regularly update any key pair without affecting any other key pair.",
      "ja": "2. 他のキーペアに影響を与えることなく、キーペアを定期的に更新することが可能である必要があります。"
    },
    {
      "indent": 10,
      "text": "3. The use of confidentiality in PKI management protocols must be kept to a minimum in order to ease acceptance in environments where strong confidentiality might cause regulatory problems.",
      "ja": "3. PKI管理プロトコルでの機密性の使用は、強力な機密性が規制上の問題を引き起こす可能性のある環境での受け入れを容易にするために、最小限に抑える必要があります。"
    },
    {
      "indent": 10,
      "text": "4. PKI management protocols must allow the use of different industry-standard cryptographic algorithms (see CMP Algorithms [RFC9481]). This means that any given CA, RA, or end entity may, in principle, use whichever algorithms suit it for its own key pair(s).",
      "ja": "4. PKI管理プロトコルは、さまざまな業界標準の暗号化アルゴリズムの使用を許可する必要があります（CMPアルゴリズム[RFC9481]を参照）。これは、特定のCA、RA、またはENDエンティティが、原則として、独自のキーペアに合わせてどのアルゴリズムを使用するかを使用することを意味します。"
    },
    {
      "indent": 10,
      "text": "5. PKI management protocols must not preclude the generation of key pairs by the end entity concerned, by a KGA, or by a CA. Key generation may also occur elsewhere, but for the purposes of PKI management, we can regard key generation as occurring wherever the key is first present at an end entity, KGA, or CA.",
      "ja": "5. PKI管理プロトコルは、関係するエンティティ、KGA、またはCAによって、主要ペアの生成を排除してはなりません。キー生成も他の場所で発生する可能性がありますが、PKI管理の目的のために、キー生成は、キーが終了エンティティ、KGA、またはCAで最初に存在する場合でも発生すると見なすことができます。"
    },
    {
      "indent": 10,
      "text": "6. PKI management protocols must support the publication of certificates by the end entity concerned, by an RA, or by a CA. Different implementations and different environments may choose any of the above approaches.",
      "ja": "6. PKI管理プロトコルは、関係するエンティティ、RA、またはCAによって証明書の公開をサポートする必要があります。さまざまな実装とさまざまな環境が、上記のアプローチのいずれかを選択する場合があります。"
    },
    {
      "indent": 10,
      "text": "7. PKI management protocols must support the production of Certificate Revocation Lists (CRLs) by allowing certified end entities to make requests for the revocation of certificates. This must be done in such a way that the denial-of-service attacks, which are possible, are not made simpler.",
      "ja": "7. PKI管理プロトコルは、認定エンティティが証明書の取り消しの要求を行うことを許可することにより、証明書取消リスト（CRL）の作成をサポートする必要があります。これは、可能なサービス拒否攻撃がより単純にならないように行う必要があります。"
    },
    {
      "indent": 10,
      "text": "8. PKI management protocols must be usable over a variety of \"transport\" mechanisms, specifically including email, Hypertext Transfer Protocol (HTTP), Message Queuing Telemetry Transport (MQTT), Constrained Application Protocol (CoAP), and various offline and non-networked file transfer methods.",
      "ja": "8. PKI管理プロトコルは、具体的には電子メール、ハイパーテキスト転送プロトコル（HTTP）、メッセージキューイングテレメトリートランスポート（MQTT）、制約付きアプリケーションプロトコル（COAP）、およびさまざまなオフラインおよび非ネットワーク化されたファイル転送方法を含む、さまざまな「輸送」メカニズムで使用できる必要があります。"
    },
    {
      "indent": 10,
      "text": "9. Final authority for certification creation rests with the CA. No RA or end entity equipment can assume that any certificate issued by a CA will contain what was requested; a CA may alter certificate field values or may add, delete, or alter extensions according to its operating policy. In other words, all PKI entities (end entities, RAs, KGAs, and CAs) must be capable of handling responses to requests for certificates in which the actual certificate issued is different from that requested (for example, a CA may shorten the validity period requested). Note that policy may dictate that the CA must not publish or otherwise distribute the certificate until the requesting entity has reviewed and accepted the newly created certificate or the POP is completed. In case of publication of the certificate (when using indirect POP, see Section 8.11) or a precertificate in a CT log [RFC9162], the certificate must be revoked if it was not accepted by the end entity or the POP could not be completed.",
      "ja": "9. 認証作成の最終的な権限はCAにかかっています。CAが発行した証明書には、要求されたものが含まれていると想定することはできません。CAは、証明書のフィールド値を変更したり、その運用ポリシーに従って拡張機能を追加、削除、または変更する場合があります。言い換えれば、すべてのPKIエンティティ（END ENTITIES、RAS、KGAS、およびCAS）は、発行された実際の証明書が要求された証明書とは異なる証明書の要求に対する応答を処理できる必要があります（たとえば、CAは要求された有効期間を短くすることができます）。リクエストエンティティが新しく作成された証明書を確認および受け入れるか、POPが完了するまで、CAが証明書を公開またはその他の方法で配布してはならないことをポリシーが指示する場合があることに注意してください。証明書の公開（間接POPを使用する場合は、セクション8.11を参照）またはCTログ[RFC9162]の事前認証の場合、最終エンティティによって受け入れられなかった場合、またはPOPが完了できなかった場合、証明書を取り消す必要があります。"
    },
    {
      "indent": 10,
      "text": "10. A graceful, scheduled changeover from one non-compromised CA key pair to the next (CA key update) must be supported (note that if the CA key is compromised, re-initialization must be performed for all entities in the domain of that CA). An end entity whose TEE contains the new CA public key (following a CA key update) may also need to be able to verify certificates verifiable using the old public key. End entities who directly trust the old CA key pair may also need to be able to verify certificates signed using the new CA private key (required for situations where the old CA public key is \"hardwired\" into the end entity's cryptographic equipment).",
      "ja": "10. 1つの非競合化されていないCAキーペアから次の（CAキーアップデート）への優雅なスケジュールされた切り替えをサポートする必要があります（CAキーが侵害された場合、そのCAのドメイン内のすべてのエンティティに対して再目立化を実行する必要があることに注意してください）。TEEに新しいCA公開キー（CAキーの更新に続く）が含まれているエンドエンティティは、古い公開キーを使用して検証可能な証明書を検証できる必要がある場合があります。古いCAキーペアを直接信頼するエンディティは、新しいCAの秘密鍵を使用して署名された証明書を検証できる必要がある場合があります（古いCAの公開キーが最終エンティティの暗号化機器に「ハードワイヤード」である状況に必要です）。"
    },
    {
      "indent": 10,
      "text": "11. The functions of an RA may, in some implementations or environments, be carried out by the CA itself. The protocols must be designed so that end entities will use the same protocol regardless of whether the communication is with an RA or CA. Naturally, the end entity must use the correct RA or CA public key to verify the protection of the communication.",
      "ja": "11. RAの機能は、いくつかの実装または環境で、CA自体によって実行される場合があります。プロトコルは、通信がRAまたはCAにあるかどうかに関係なく、エンディティが同じプロトコルを使用するように設計する必要があります。当然、最終エンティティは正しいRAまたはCAの公開キーを使用して、通信の保護を検証する必要があります。"
    },
    {
      "indent": 10,
      "text": "12. Where an end entity requests a certificate containing a given public key value, the end entity must be ready to demonstrate possession of the corresponding private key value. This may be accomplished in various ways, depending on the type of certification request. See Section 4.3 for details of the in-band methods defined for the PKIX-CMP (i.e., CMP) messages.",
      "ja": "12. 終了エンティティが特定の公開キー値を含む証明書を要求する場合、最終エンティティは、対応する秘密キー値の所有を実証する準備ができている必要があります。これは、認証要求の種類に応じて、さまざまな方法で達成できます。PKIX-CMP（つまり、CMP）メッセージに対して定義された帯域内のメソッドの詳細については、セクション4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.3. PKI Management Operations",
      "section_title": true,
      "ja": "3.1.3. PKI管理操作"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the relationship between the entities defined above in terms of the PKI management operations. The letters in the diagram indicate \"protocols\" in the sense that a defined set of PKI management messages can be sent along each of the lettered lines.",
      "ja": "次の図は、PKI管理操作に関して上記のエンティティ間の関係を示しています。図の文字は、定義されたPKI管理メッセージのセットを各文字行に沿って送信できるという意味で「プロトコル」を示しています。"
    },
    {
      "indent": 5,
      "text": "+---+     cert. publish        +------------+      j\n|   |  <---------------------  | End Entity | <-------\n| C |             g            +------------+      \"out-of-band\"\n| e |                            | ^                loading\n| r |                            | |      initial\n| t |                          a | | b     registration/\n|   |                            | |       certification\n| / |                            | |      key pair recovery\n|   |                            | |      key pair update\n| C |                            | |      certificate update\n| R |  PKI \"USERS\"               V |      revocation request\n| L | -------------------+-+-----+-+------+-+-------------------\n|   |  PKI MANAGEMENT    | ^              | ^\n|   |    ENTITIES      a | | b          a | | b\n| R |                    V |              | |\n| e |             g   +------+    d       | |\n| p |   <------------ | RA   | <-----+    | |\n| o |      cert.      |      | ----+ |    | |\n| s |       publish   +------+   c | |    | |\n| i |                              | |    | |\n| t |                              V |    V |\n| o |          g                 +------------+   i\n| r |   <------------------------|     CA     |------->\n| y |          h                 +------------+  \"out-of-band\"\n|   |      cert. publish              | ^         publication\n|   |      CRL publish                | |\n+---+                                 | |    cross-certification\n                                    e | | f  cross-certificate\n                                      | |       update\n                                      | |\n                                      V |\n                                    +------+\n                                    | CA-2 |\n                                    +------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 1: PKI Entities",
      "ja": "図1：PKIエンティティ"
    },
    {
      "indent": 3,
      "text": "At a high level, the set of operations for which management messages are defined can be grouped as follows.",
      "ja": "高レベルでは、管理メッセージが定義される一連の操作を次のようにグループ化できます。"
    },
    {
      "indent": 8,
      "text": "1. CA establishment: When establishing a new CA, certain steps are required (e.g., production of initial CRLs and export of CA public key).",
      "ja": "1. CA設立：新しいCAを確立するとき、特定の手順が必要です（例：初期CRLの生産とCA公開鍵の輸出）。"
    },
    {
      "indent": 8,
      "text": "2. End entity initialization: This includes importing a root CA public key and requesting information about the options supported by a PKI management entity.",
      "ja": "2. End Entityの初期化：これには、ルートCAの公開キーのインポートと、PKI管理エンティティによってサポートされているオプションに関する情報の要求が含まれます。"
    },
    {
      "indent": 8,
      "text": "3. Certification: Various operations result in the creation of new certificates:",
      "ja": "3. 認定：さまざまな操作により、新しい証明書が作成されます。"
    },
    {
      "indent": 16,
      "text": "a. initial registration/certification: This is the process whereby an end entity first makes itself known to a CA or RA, prior to the CA issuing a certificate or certificates for that end entity. The end result of this process (when it is successful) is that a CA issues a certificate for an end entity's public key and returns that certificate to the end entity and/or posts that certificate in a repository. This process may, and typically will, involve multiple \"steps\", possibly including an initialization of the end entity's equipment. For example, the end entity's equipment must be securely initialized with the public key of a CA, e.g., using zero-touch methods like Bootstrapping Remote Secure Key Infrastructure (BRSKI) [RFC8995] or Secure Zero Touch Provisioning (SZTP) [RFC8572], to be used in validating certificate paths. Furthermore, an end entity typically needs to be initialized with its own key pair(s).",
      "ja": "a. 初期登録/認証：これは、CAがその最終エンティティの証明書または証明書を発行する前に、最終エンティティが最初にCAまたはRAに自分自身を知られるプロセスです。このプロセスの最終結果（成功した場合）は、CAがEnd End Entityの公開キーの証明書を発行し、その証明書をEnd Entityおよび/またはその証明書にリポジトリに投稿することです。このプロセスは、最終エンティティの機器の初期化を含む、複数の「ステップ」が含まれる場合があります。たとえば、End Entityの機器は、CAの公開鍵で安全に初期化する必要があります。たとえば、リモートセキュアなキーインフラストラクチャ（BRSKI）[RFC8995] [RFC8995]またはセキュアゼロタッチプロビジョニング（SZTP）[RFC8572]などのゼロタッチメソッドを使用して、証明書パスを確認するために使用します。さらに、最終エンティティは通常、独自のキーペアで初期化する必要があります。"
    },
    {
      "indent": 16,
      "text": "b. key pair update: Every key pair needs to be updated regularly (i.e., replaced with a new key pair), and a new certificate needs to be issued.",
      "ja": "b. キーペアの更新：すべてのキーペアを定期的に更新する必要があり（つまり、新しいキーペアに置き換えられます）、新しい証明書を発行する必要があります。"
    },
    {
      "indent": 16,
      "text": "c. certificate update: As certificates expire, they may be \"refreshed\" if nothing relevant in the environment has changed.",
      "ja": "c. 証明書の更新：証明書が期限切れになると、環境に関連するものが変更されていない場合、「リフレッシュ」される可能性があります。"
    },
    {
      "indent": 16,
      "text": "d. CA key pair update: As with end entities, CA key pairs need to be updated regularly; however, different mechanisms are required.",
      "ja": "d. CAキーペアの更新：END ENTITIESと同様に、CAキーペアを定期的に更新する必要があります。ただし、さまざまなメカニズムが必要です。"
    },
    {
      "indent": 16,
      "text": "e. cross-certification request: One CA requests issuance of a cross-certificate from another CA. For the purposes of this standard, the following terms are defined. A \"cross-certificate\" is a certificate in which the subject CA and the issuer CA are distinct and SubjectPublicKeyInfo contains a verification key (i.e., the certificate has been issued for the subject CA's signing key pair). When it is necessary to distinguish more finely, the following terms may be used: A cross-certificate is called an \"inter-domain cross-certificate\" if the subject and issuer CAs belong to different administrative domains; it is called an \"intra-domain cross-certificate\" otherwise.",
      "ja": "e. 相互認証要求：あるCAは、別のCAから相互認証の発行を要求します。この基準の目的のために、次の用語が定義されています。「クロス認証」は、対象CAおよび発行者CAが明確であり、件名PublicKeyInfoが検証キーを含む証明書です（つまり、被験者のCAの署名キーペアに対して証明書が発行されました）。より細かく区別する必要がある場合、次の用語を使用できます。クロス認証は、被験者と発行者CAが異なる管理ドメインに属している場合、「ドメイン間の相互認証」と呼ばれます。それ以外の場合は、「ドメイン内クロス認証」と呼ばれます。"
    },
    {
      "indent": 34,
      "text": "Note 1: The above definition of \"cross-certificate\" aligns with the defined term \"CA-certificate\" in X.509. Note that this term is not to be confused with the X.500 \"cACertificate\" attribute type, which is unrelated.",
      "ja": "注1：上記の「クロス認証」の定義は、X.509の定義された用語「Ca certificate」と一致します。この用語は、無関係のX.500 \"cacertificate\"属性タイプと混同しないことに注意してください。"
    },
    {
      "indent": 34,
      "text": "Note 2: In many environments, the term \"cross-certificate\", unless further qualified, will be understood to be synonymous with \"inter-domain cross-certificate\" as defined above.",
      "ja": "注2：多くの環境では、「クロス認証」という用語は、さらに資格を与えない限り、上記のように「ドメイン間の相互認証」と同義であると理解されます。"
    },
    {
      "indent": 34,
      "text": "Note 3: Issuance of cross-certificates may be, but is not necessarily, mutual; that is, two CAs may issue cross-certificates for each other.",
      "ja": "注3：クロス認証の発行は、必ずしも相互にあるとは限りません。つまり、2つのCASが相互に相互に認証される可能性があります。"
    },
    {
      "indent": 16,
      "text": "f. cross-certificate update: Similar to a normal certificate update but involving a cross-certificate.",
      "ja": "f. クロス認証の更新：通常の証明書の更新と同様ですが、クロス認証が含まれます。"
    },
    {
      "indent": 8,
      "text": "4. Certificate/CRL discovery operations: Some PKI management operations result in the publication of certificates or CRLs:",
      "ja": "4. 証明書/CRL発見操作：一部のPKI管理操作により、証明書またはCRLの公開が発生します。"
    },
    {
      "indent": 16,
      "text": "a. certificate publication: Having gone to the trouble of producing a certificate, some means for publishing may be needed. The \"means\" defined in PKIX MAY involve the messages specified in Sections 5.3.13 to 5.3.16 or MAY involve other methods (for example, Lightweight Directory Access Protocol (LDAP)) as described in [RFC4511] or [RFC2585] (the \"Operational Protocols\" documents of the PKIX series of specifications).",
      "ja": "a. 証明書の公開：証明書を作成する問題に取り組んだ場合、公開のための何らかの手段が必要になる場合があります。PKIXで定義されている「平均」には、セクション5.3.13から5.3.16で指定されたメッセージが含まれる場合があります。または、[RFC4511]または[RFC2585]に記載されているように、他の方法（たとえば、軽量ディレクトリアクセスプロトコル（LDAP））を含む場合があります。"
    },
    {
      "indent": 16,
      "text": "b. CRL publication: As for certificate publication.",
      "ja": "b. CRLの公開：証明書の公開について。"
    },
    {
      "indent": 8,
      "text": "5. Recovery operations: Some PKI management operations are used when an end entity has \"lost\" its TEE:",
      "ja": "5. 回復操作：一部のPKI管理操作は、最終エンティティがティーを「失った」ときに使用されます。"
    },
    {
      "indent": 16,
      "text": "a. key pair recovery: As an option, user client key materials (e.g., a user's private key used for decryption purposes) MAY be backed up by a CA, an RA, or a key backup system associated with a CA or RA. If an entity needs to recover these backed up key materials (e.g., as a result of a forgotten password or a lost key chain file), a protocol exchange may be needed to support such recovery.",
      "ja": "a. キーペアの回復：オプションとして、ユーザークライアントのキー資料（たとえば、復号化目的で使用されるユーザーの秘密鍵）は、CA、RA、またはCAまたはRAに関連するキーバックアップシステムによってバックアップされる場合があります。エンティティがこれらのバックアップされた主要な資料を回復する必要がある場合（たとえば、忘れられたパスワードまたは失われたキーチェーンファイルの結果として）、そのような回復をサポートするためにプロトコル交換が必要になる場合があります。"
    },
    {
      "indent": 8,
      "text": "6. Revocation operations: Some PKI management operations result in the creation of new CRL entries and/or new CRLs:",
      "ja": "6. 取り消し操作：一部のPKI管理操作により、新しいCRLエントリおよび/または新しいCRLが作成されます。"
    },
    {
      "indent": 16,
      "text": "a. revocation request: An authorized person advises a CA of an abnormal situation requiring certificate revocation.",
      "ja": "a. 取り消しリクエスト：認定者は、CAに証明書の取り消しを必要とする異常な状況を助言します。"
    },
    {
      "indent": 8,
      "text": "7. TEE operations: Whilst the definition of TEE operations (e.g., moving a TEE, changing a PIN, etc.) are beyond the scope of this specification, we do define a PKIMessage (CertRepMessage) that can form the basis of such operations.",
      "ja": "7. TEE操作：TEE操作の定義（たとえば、Tシャツの移動、ピンの変更など）はこの仕様の範囲を超えていますが、そのような操作の基礎を形成できるpkimessage（certrepmessage）を定義します。"
    },
    {
      "indent": 3,
      "text": "Note that online protocols are not the only way of implementing the above operations. For all operations, there are offline methods of achieving the same result, and this specification does not mandate use of online protocols. For example, when hardware tokens are used, many of the operations MAY be achieved as part of the physical token delivery.",
      "ja": "オンラインプロトコルは、上記の操作を実装する唯一の方法ではないことに注意してください。すべての操作について、同じ結果を達成するオフラインの方法があり、この仕様はオンラインプロトコルの使用を義務付けていません。たとえば、ハードウェアトークンを使用すると、物理トークン配信の一部として多くの操作が達成される場合があります。"
    },
    {
      "indent": 3,
      "text": "Later sections define a set of standard messages supporting the above operations. Transfer protocols for conveying these exchanges in various environments (e.g., offline: file-based; online: email, HTTP [RFC9811], MQTT, and CoAP [RFC9482]) are beyond the scope of this document and must be specified separately. Appropriate transfer protocols MUST be capable of delivering the CMP messages reliably.",
      "ja": "後のセクションでは、上記の操作をサポートする一連の標準メッセージを定義します。さまざまな環境でこれらの交換を伝えるためのプロトコル（例：オフライン：ファイルベース;オンライン：電子メール、HTTP [RFC9811]、MQTT、およびCOAP [RFC9482]）は、このドキュメントの範囲を超えており、別々に指定する必要があります。適切な転送プロトコルは、CMPメッセージを確実に配信できる必要があります。"
    },
    {
      "indent": 3,
      "text": "CMP provides inbuilt integrity protection and authentication. The information communicated unencrypted in CMP messages does not contain sensitive information endangering the security of the PKI when intercepted. However, it might be possible for an eavesdropper to utilize the available information to gather confidential technical or business-critical information. Therefore, users should consider protection of confidentiality on lower levels of the protocol stack, e.g., by using TLS [RFC8446], DTLS [RFC9147], or IPsec [RFC7296][RFC4303].",
      "ja": "CMPは、組み込みの整合性の保護と認証を提供します。CMPメッセージで暗号化されていない情報には、傍受されたときにPKIのセキュリティを危険にさらす機密情報が含まれていません。ただし、盗聴者が利用可能な情報を利用して、機密の技術的またはビジネス上の情報を収集することが可能かもしれません。したがって、ユーザーは、TLS [RFC8446]、DTLS [RFC9147]、またはIPSEC [RFC7296] [RFC4303]を使用して、プロトコルスタックのより低いレベルの機密性の保護を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Assumptions and Restrictions",
      "section_title": true,
      "ja": "4. 仮定と制限"
    },
    {
      "indent": 0,
      "text": "4.1. End Entity Initialization",
      "section_title": true,
      "ja": "4.1. エンティティの初期化を終了します"
    },
    {
      "indent": 3,
      "text": "The first step for an end entity in dealing with PKI management entities is to request information about the PKI functions supported and to securely acquire a copy of the relevant root CA public key(s).",
      "ja": "PKI管理エンティティを扱う最終エンティティの最初のステップは、サポートされているPKI関数に関する情報を要求し、関連するルートCA公開キーのコピーを安全に取得することです。"
    },
    {
      "indent": 0,
      "text": "4.2. Initial Registration/Certification",
      "section_title": true,
      "ja": "4.2. 初期登録/認定"
    },
    {
      "indent": 3,
      "text": "There are many schemes that can be used to achieve initial registration and certification of end entities. No one method is suitable for all situations due to the range of policies that a CA may implement and the variation in the types of end entity that can occur.",
      "ja": "最終エンティティの初期登録と認証を実現するために使用できる多くのスキームがあります。CAが実装する可能性のあるポリシーの範囲と発生する可能性のあるエンティティのタイプの変動により、すべての状況に適した方法はありません。"
    },
    {
      "indent": 3,
      "text": "However, we can classify the initial registration/certification schemes that are supported by this specification. Note that the word \"initial\", above, is crucial: We are dealing with the situation where the end entity in question has had no previous contact with the PKI, except having received the root CA certificate of that PKI by some zero-touch method like BRSKI [RFC8995] [RFC9733] or SZTP [RFC8572]. In case the end entity already possesses certified keys, then some simplifications/alternatives are possible.",
      "ja": "ただし、この仕様でサポートされている最初の登録/認証スキームを分類できます。上記の「初期」という言葉が重要であることに注意してください。BRSKI[RFC8995] [RFC9733]またはSZTP [RFC8572]のようなゼロタッチ法でそのPKIのルートCA証明書を受け取ったことを除いて、問題の最終エンティティがPKIと以前に接触していない状況を扱っています。終了エンティティがすでに認定キーを持っている場合、いくつかの単純化/代替案が可能です。"
    },
    {
      "indent": 3,
      "text": "Having classified the schemes that are supported by this specification, we can then specify some as mandatory and some as optional. The goal is that the mandatory schemes cover a sufficient number of the cases that will arise in real use, whilst the optional schemes are available for special cases that arise less frequently. In this way, we achieve a balance between flexibility and ease of implementation.",
      "ja": "この仕様でサポートされているスキームを分類した後、一部は必須でオプションとして指定できます。目標は、必須のスキームが実際の使用で発生する十分な数のケースをカバーしているのに対し、オプションのスキームはあまり頻繁に発生する特別なケースで利用できることです。このようにして、実装の柔軟性と容易さのバランスをとっています。"
    },
    {
      "indent": 3,
      "text": "Further classification of mandatory and optional schemes addressing different environments is available, e.g., in Appendices C and D of this specification on managing human user certificates as well as in the Lightweight CMP Profile [RFC9483] on fully automating certificate management in a machine-to-machine and Internet of Things (IoT) environment. Industry standards such as [ETSI-3GPP.33.310] for mobile networks and [UNISIG.Subset-137] for railroad automation have adopted CMP and defined a series of mandatory schemes for their use cases.",
      "ja": "さまざまな環境に対処する必須およびオプションのスキームのさらなる分類は、たとえば、人間のユーザー証明書の管理に関するこの仕様の付録CおよびDで、および機械からマシンとモノのインターネット（IoT）環境での証明書管理を完全に自動化するための軽量CMPプロファイル[RFC9483]で利用可能です。モバイルネットワークの[ETSI-3GPP.33.310]や鉄道自動化の[Unisig.subset-137]などの業界標準は、CMPを採用し、ユースケースの一連の必須スキームを定義しました。"
    },
    {
      "indent": 3,
      "text": "We will now describe the classification of initial registration/ certification schemes.",
      "ja": "ここで、初期登録/認証スキームの分類について説明します。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Criteria Used",
      "section_title": true,
      "ja": "4.2.1. 使用される基準"
    },
    {
      "indent": 0,
      "text": "4.2.1.1. Initiation of Registration/Certification",
      "section_title": true,
      "ja": "4.2.1.1. 登録/認証の開始"
    },
    {
      "indent": 3,
      "text": "In terms of the PKI messages that are produced, we can regard the initiation of the initial registration/certification exchanges as occurring wherever the first PKI message relating to the end entity is produced. Note that the real-world initiation of the registration/certification procedure may occur elsewhere (e.g., a personnel department may telephone an RA operator or use zero-touch methods like BRSKI [RFC8995] or SZTP [RFC8572]).",
      "ja": "作成されたPKIメッセージに関しては、終了エンティティに関連する最初のPKIメッセージが作成されている場合でも発生する最初の登録/認証交換の開始を考慮することができます。登録/認証手順の実際の開始は他の場所で発生する可能性があることに注意してください（たとえば、人事部門はRAオペレーターに電話するか、BRSKI [RFC8995]やSZTP [RFC8572]などのゼロタッチメソッドを使用できます）。"
    },
    {
      "indent": 3,
      "text": "The possible locations are at the end entity, an RA, or a CA.",
      "ja": "考えられる場所は、終了エンティティ、RA、またはCAです。"
    },
    {
      "indent": 0,
      "text": "4.2.1.2. End Entity Message Origin Authentication",
      "section_title": true,
      "ja": "4.2.1.2. End EntityメッセージOrigin Authentication"
    },
    {
      "indent": 3,
      "text": "The online messages produced by the end entity that requires a certificate may be authenticated or not. The requirement here is to authenticate the origin of any messages from the end entity to the PKI (CA/RA).",
      "ja": "証明書を必要とするEnd Entityによって作成されたオンラインメッセージは、認証されるかどうか。ここでの要件は、最終エンティティからPKI（CA/RA）へのメッセージの原点を認証することです。"
    },
    {
      "indent": 3,
      "text": "In this specification, such authentication is achieved by two different means:",
      "ja": "この仕様では、このような認証は2つの異なる手段によって達成されます。"
    },
    {
      "indent": 6,
      "text": "* symmetric: The PKI (CA/RA) issuing the end entity with a secret value (initial authentication key) and reference value (used to identify the secret value) via some out-of-band means. The initial authentication key can then be used to protect relevant PKI messages.",
      "ja": "* 対称：PKI（CA/RA）は、帯域外の平均を介して秘密値（初期認証キー）と基準値（秘密値を識別するために使用）を備えた最終エンティティを発行します。その後、初期認証キーを使用して、関連するPKIメッセージを保護できます。"
    },
    {
      "indent": 6,
      "text": "* asymmetric: Using a private key and certificate issued by another PKI trusted for initial authentication, e.g., an Initial Device Identifier (IDevID) IEEE 802.1AR [IEEE.802.1AR-2018]. The trust establishment in this external PKI is out of scope of this document.",
      "ja": "* 非対称：初期認証のために信頼された別のPKIによって発行された秘密鍵と証明書を使用します。この外部PKIの信託施設は、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Thus, we can classify the initial registration/certification scheme according to whether or not the online 'end entity -> PKI management entity' messages are authenticated or not.",
      "ja": "したがって、オンラインの「End Entity-> PKI Management Entity」メッセージが認証されているかどうかに応じて、初期登録/認証スキームを分類できます。"
    },
    {
      "indent": 18,
      "text": "Note 1: We do not discuss the authentication of the 'PKI management entity -> end entity' messages here, as this is always REQUIRED. In any case, it can be achieved simply once the root-CA public key has been installed at the end entity's equipment or it can be based on the initial authentication key.",
      "ja": "注1：これが常に必要なため、ここでは「PKI管理エンティティ - > End Entity」メッセージの認証については説明しません。いずれにせよ、それは単にルートCAの公開キーがEnd Entityの機器にインストールされた後に達成するか、初期認証キーに基づいていることができます。"
    },
    {
      "indent": 18,
      "text": "Note 2: An initial registration/certification procedure can be secure where the messages from the end entity are authenticated via some out-of-band means (e.g., a subsequent visit).",
      "ja": "注2：初期登録/認証手順は、最終エンティティからのメッセージが帯域外の手段を介して認証される場合（例：その後の訪問）を保護できます。"
    },
    {
      "indent": 0,
      "text": "4.2.1.3. Location of Key Generation",
      "section_title": true,
      "ja": "4.2.1.3. キー生成の場所"
    },
    {
      "indent": 3,
      "text": "In this specification, \"key generation\" is regarded as occurring wherever either the public or private component of a key pair first occurs in a PKIMessage. Note that this does not preclude a centralized key generation service by a KGA; the actual key pair MAY have been generated elsewhere and transported to the end entity, RA, or CA using a (proprietary or standardized) key generation request/ response protocol (outside the scope of this specification).",
      "ja": "この仕様では、「キー生成」は、キーペアのパブリックまたはプライベートコンポーネントが最初にpkimessageで発生する場合でも発生すると見なされます。これは、KGAによる集中型キージェネレーションサービスを排除しないことに注意してください。実際のキーペアは他の場所で生成され、（独自または標準化された）キー生成要求/応答プロトコル（この仕様の範囲外）を使用して、最終エンティティ、RA、またはCAに輸送された可能性があります。"
    },
    {
      "indent": 3,
      "text": "Thus, there are three possibilities for the location of \"key generation\": the end entity, a KGA, or a CA.",
      "ja": "したがって、「キー生成」の場所には3つの可能性があります。最終エンティティ、KGA、またはCA。"
    },
    {
      "indent": 0,
      "text": "4.2.1.4. Confirmation of Successful Certification",
      "section_title": true,
      "ja": "4.2.1.4. 成功した認定の確認"
    },
    {
      "indent": 3,
      "text": "Following the creation of a certificate for an end entity, additional assurance can be gained by having the end entity explicitly confirm successful receipt of the message containing (or indicating the creation of) the certificate. Naturally, this confirmation message must be protected (based on the initial symmetric or asymmetric authentication key or other means).",
      "ja": "終了エンティティの証明書の作成に続いて、証明書を含む（または作成を示す）メッセージの受信を成功させる（または証明書の作成を示す）エンティティが明示的に確認されることにより、追加の保証を得ることができます。当然、この確認メッセージは保護する必要があります（初期対称または非対称認証キーまたはその他の手段に基づいています）。"
    },
    {
      "indent": 3,
      "text": "This gives two further possibilities: confirmed or not.",
      "ja": "これにより、さらに2つの可能性が得られます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Initial Registration/Certification Schemes",
      "section_title": true,
      "ja": "4.2.2. 初期登録/認定スキーム"
    },
    {
      "indent": 3,
      "text": "The criteria above allow for a large number of initial registration/ certification schemes. Examples of possible initial registration/ certification schemes can be found in the following subsections. An entity may support other schemes specified in profiles of PKIX-CMP, such as Appendices C and D or [RFC9483].",
      "ja": "上記の基準により、多数の初期登録/認証スキームが可能になります。可能な初期登録/認証スキームの例は、次のサブセクションにあります。エンティティは、付録CやDまたは[RFC9483]など、PKIX-CMPのプロファイルで指定された他のスキームをサポートする場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Centralized Scheme",
      "section_title": true,
      "ja": "4.2.2.1. 集中スキーム"
    },
    {
      "indent": 3,
      "text": "In terms of the classification above, this scheme is, in some ways, the simplest possible, where:",
      "ja": "上記の分類に関しては、このスキームは、可能な限り最も単純なものです。"
    },
    {
      "indent": 6,
      "text": "* initiation occurs at the certifying CA;",
      "ja": "* 認定CAで開始が発生します。"
    },
    {
      "indent": 6,
      "text": "* no online message authentication is required;",
      "ja": "* オンラインメッセージ認証は必要ありません。"
    },
    {
      "indent": 6,
      "text": "* \"key generation\" occurs at the certifying CA (see Section 4.2.1.3); and",
      "ja": "* 「キー生成」は、認定CAで発生します（セクション4.2.1.3を参照）。そして"
    },
    {
      "indent": 6,
      "text": "* no confirmation message is required.",
      "ja": "* 確認メッセージは必要ありません。"
    },
    {
      "indent": 3,
      "text": "In terms of message flow, this scheme means that the only message required is sent from the CA to the end entity. The message must contain the entire TEE for the end entity. Some out-of-band means must be provided to allow the end entity to authenticate the message received and to decrypt any encrypted values.",
      "ja": "メッセージフローに関して、このスキームは、必要なメッセージのみがCAからEnd Entityに送信されることを意味します。メッセージには、終了エンティティのティー全体が含まれている必要があります。最終エンティティが受信したメッセージを認証し、暗号化された値を復号化できるようにするために、いくつかの帯域外の手段を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Basic Authenticated Scheme",
      "section_title": true,
      "ja": "4.2.2.2. 基本的な認証されたスキーム"
    },
    {
      "indent": 3,
      "text": "In terms of the classification above, this scheme is where:",
      "ja": "上記の分類に関しては、このスキームは次の場所です。"
    },
    {
      "indent": 6,
      "text": "* initiation occurs at the end entity;",
      "ja": "* 終了エンティティで開始が発生します。"
    },
    {
      "indent": 6,
      "text": "* message authentication is required;",
      "ja": "* メッセージ認証が必要です。"
    },
    {
      "indent": 6,
      "text": "* \"key generation\" occurs at the end entity (see Section 4.2.1.3); and",
      "ja": "* 「キー生成」は、最後のエンティティで発生します（セクション4.2.1.3を参照）。そして"
    },
    {
      "indent": 6,
      "text": "* a confirmation message is recommended.",
      "ja": "* 確認メッセージが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Note: An Initial Authentication Key (IAK) can be either a symmetric key or an asymmetric private key with a certificate issued by another PKI trusted for this purpose. The establishment of such trust is out of scope of this document.",
      "ja": "注：初期認証キー（IAK）は、対称キーまたは非対称の秘密鍵のいずれかで、この目的で信頼されている別のPKIが発行した証明書を備えています。このような信頼の確立は、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "In terms of message flow, the basic authenticated scheme is as follows:",
      "ja": "メッセージフローに関しては、基本的な認証されたスキームは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "End Entity                                              RA/CA\n==========                                      =============\n     out-of-band distribution of Initial Authentication\n     Key (IAK) and reference value (RA/CA -> end entity)\nKey generation\nCreation of certification request\nProtect request with IAK\n              -----> certification request ----->\n                                               verify request\n                                               process request\n                                               create response\n              <----- certification response <-----\nhandle response\ncreate confirmation\n              -----> cert conf message      ----->\n                                               verify confirmation\n                                               create response\n              <----- conf ack (optional)    <-----\nhandle response",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: Where verification of the cert confirmation message fails, the RA/CA MUST revoke the newly issued certificate if it has been published or otherwise made available.",
      "ja": "注：証明書確認メッセージの検証が失敗した場合、RA/CAは、公開されているか、その他の方法で利用可能になった場合、新しく発行された証明書を取り消す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. POP of Private Key",
      "section_title": true,
      "ja": "4.3. 秘密鍵のポップ"
    },
    {
      "indent": 3,
      "text": "POP is where a PKI management entity (CA/RA) verifies if an end entity has access to the private key corresponding to a given public key. The question of whether, and in what circumstances, POPs add value to a PKI is a debate as old as PKI itself! See Section 8.1 for a further discussion on the necessity of POP in PKI.",
      "ja": "POPは、特定の公開キーに対応する秘密鍵に終了エンティティがアクセスできる場合、PKI管理エンティティ（CA/RA）が検証する場所です。PKIに価値を追加するのは、PKI自体と同じくらい古い議論であるかどうか、そしてどのような状況でどのような状況にあるかという問題！PKIのPOPの必要性に関する詳細については、セクション8.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The PKI management operations specified here make it possible for an end entity to prove to a CA/RA that it has possession of (i.e., is able to use) the private key corresponding to the public key for which a certificate is requested (see Section 5.2.8 for different POP methods). A given CA/RA is free to choose how to enforce POP (e.g., out-of-band procedural means versus PKIX-CMP in-band messages) in its certification exchanges (i.e., this may be a policy issue). However, it is REQUIRED that CAs/RAs MUST enforce POP by some means because there are currently many non-PKIX operational protocols in use (various electronic mail protocols are one example) that do not explicitly check the binding between the end entity and the private key. Until operational protocols that do verify the binding (for signature, encryption, key agreement, and KEM key pairs) exist, and are ubiquitous, this binding can only be assumed to have been verified by the CA/RA. Therefore, if the binding is not verified by the CA/RA, certificates in the Internet PKI end up being somewhat less meaningful.",
      "ja": "ここで指定されたPKI管理操作により、最終エンティティがCA/RAに所有している（つまり、使用できる）ことを証明することが可能になります。特定のCA/RAは、認定交換でPOP（たとえば、帯域外の手続き的平均とPKIX-CMPインバンドメッセージ）を強制する方法を自由に選択できます（つまり、これはポリシーの問題かもしれません）。ただし、現在使用されている非PKIX運用プロトコル（さまざまな電子メールプロトコルが1つの例）があるため、CAS/RASが何らかの手段でPOPを実施する必要があります。バインディング（署名、暗号化、主要な合意、およびKEMキーペアの場合）を検証する運用プロトコルが存在し、ユビキタスであるまで、この結合はCA/RAによって検証されたとのみ想定できます。したがって、拘束力がCA/RAによって検証されていない場合、インターネットPKIの証明書はやや意味が低くなります。"
    },
    {
      "indent": 3,
      "text": "POP is accomplished in different ways depending upon the type of key for which a certificate is requested. If a key can be used for multiple purposes (e.g., an RSA key), then any appropriate method MAY be used (e.g., a key that may be used for signing, as well as other purposes, MUST NOT be sent to the CA/RA in order to prove possession unless archival of the private key is explicitly desired).",
      "ja": "POPは、証明書が要求されるキーのタイプに応じて、さまざまな方法で達成されます。キーを複数の目的（RSAキーなど）に使用できる場合、適切な方法を使用できます（たとえば、署名に使用される可能性のあるキー、およびその他の目的は、秘密鍵のアーカイブが明示的に望ましい場合を除き、所有権を証明するためにCA/RAに送信してはなりません）。"
    },
    {
      "indent": 3,
      "text": "This specification explicitly allows for cases where an end entity supplies the relevant proof to an RA and the RA subsequently attests to the CA that the required proof has been received (and validated!). For example, an end entity wishing to have a signing key certified could send the appropriate signature to the RA, which then simply notifies the relevant CA that the end entity has supplied the required proof. Of course, such a situation may be disallowed by some policies (e.g., CAs may be the only entities permitted to verify POP during certification).",
      "ja": "この仕様により、最終エンティティが関連する証明をRAに供給し、その後RAが必要な証明を受け取った（および検証された！）CAに明示的に可能にします。たとえば、署名キーの認定を希望するエンティティは、適切な署名をRAに送信することができます。これにより、関連するCAが必要な証明を提供したことを単純に通知します。もちろん、このような状況は、いくつかのポリシーによって許可されている可能性があります（たとえば、CASは、認証中にPOPを検証することを許可されている唯一のエンティティである可能性があります）。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Signature Keys",
      "section_title": true,
      "ja": "4.3.1. 署名キー"
    },
    {
      "indent": 3,
      "text": "For signature keys, the end entity can sign a value to prove possession of the private key; see Section 5.2.8.2.",
      "ja": "署名キーの場合、最終エンティティは秘密鍵の所有を証明するために値に署名できます。セクション5.2.8.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Encryption Keys",
      "section_title": true,
      "ja": "4.3.2. 暗号化キー"
    },
    {
      "indent": 3,
      "text": "For encryption keys, the end entity can provide the private key to the CA/RA (e.g., for archiving), see Section 5.2.8.3.1, or can be required to decrypt a value in order to prove possession of the private key. Decrypting a value can be achieved either directly (see Section 5.2.8.3.3) or indirectly (see Section 5.2.8.3.2).",
      "ja": "暗号化キーの場合、最終エンティティはCA/RAの秘密鍵を提供します（たとえば、アーカイブの場合）、セクション5.2.8.3.1を参照するか、秘密鍵の所有を証明するために値を解読するために必要です。値を復号化することは、直接（セクション5.2.8.3.3を参照）または間接的に達成できます（セクション5.2.8.3.2を参照）。"
    },
    {
      "indent": 3,
      "text": "The direct method is for the RA/CA to issue a random challenge to which an immediate response by the end entity is required.",
      "ja": "直接的な方法は、RA/CAが最終エンティティによる即時の応答が必要なランダムな課題を発行することです。"
    },
    {
      "indent": 3,
      "text": "The indirect method is to issue a certificate that is encrypted for the end entity (and have the end entity demonstrate its ability to decrypt this certificate in the confirmation message). This allows a CA to issue a certificate in a form that can only be used by the intended end entity.",
      "ja": "間接的な方法は、最終エンティティに対して暗号化された証明書を発行することです（そして、エンティティが確認メッセージでこの証明書を復号化する能力を実証します）。これにより、CAは、意図した最終エンティティによってのみ使用できるフォームで証明書を発行できます。"
    },
    {
      "indent": 3,
      "text": "This specification encourages use of the indirect method because it requires no extra messages to be sent (i.e., the proof can be demonstrated using the {request, response, confirmation} triple of messages).",
      "ja": "この仕様は、送信する余分なメッセージを必要としないため、間接的な方法の使用を促進します（つまり、{要求、応答、確認}メッセージのトリプルを使用して証明を実証できます）。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Key Agreement Keys",
      "section_title": true,
      "ja": "4.3.3. キー契約キー"
    },
    {
      "indent": 3,
      "text": "For key agreement keys, the end entity and the PKI management entity (i.e., CA or RA) must establish a shared secret key in order to prove that the end entity has possession of the private key.",
      "ja": "キー契約キーの場合、最終エンティティとPKI管理エンティティ（つまり、CAまたはRA）は、最終エンティティが秘密鍵を所有していることを証明するために、共有秘密の鍵を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that this need not impose any restrictions on the keys that can be certified by a given CA. In particular, for Diffie-Hellman (DH) keys, the end entity may freely choose its algorithm parameters provided that the CA can generate a short-term (or one-time) key pair with the appropriate parameters when necessary.",
      "ja": "これにより、特定のCAによって認証できるキーに制限を課す必要はないことに注意してください。特に、Diffie-Hellman（DH）キーの場合、最終エンティティは、CAが必要に応じて適切なパラメーターを使用して短期（または1回限りの）キーペアを生成できる場合、そのアルゴリズムパラメーターを自由に選択できます。"
    },
    {
      "indent": 0,
      "text": "4.3.4. KEM Keys",
      "section_title": true,
      "ja": "4.3.4. Kem Keys"
    },
    {
      "indent": 3,
      "text": "For KEM keys, the end entity can provide the private key to the CA/RA (e.g., for archiving), see Section 5.2.8.3.1, or can be required to decrypt a value in order to prove possession of the private key. Decrypting a value can be achieved either directly (see Section 5.2.8.3.3) or indirectly (see Section 5.2.8.3.2).",
      "ja": "KEMキーの場合、最終エンティティはCA/RAの秘密鍵を提供することができます（たとえば、アーカイブの場合）、セクション5.2.8.3.1を参照するか、秘密鍵の所有を証明するために値を解読する必要があります。値を復号化することは、直接（セクション5.2.8.3.3を参照）または間接的に達成できます（セクション5.2.8.3.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Note: A definition of KEMs can be found in Section 1 of [RFC9629].",
      "ja": "注：KEMの定義は、[RFC9629]のセクション1に記載されています。"
    },
    {
      "indent": 3,
      "text": "The direct method is for the RA/CA to issue a random challenge to which an immediate response by the end entity is required.",
      "ja": "直接的な方法は、RA/CAが最終エンティティによる即時の応答が必要なランダムな課題を発行することです。"
    },
    {
      "indent": 3,
      "text": "The indirect method is to issue a certificate that is encrypted for the end entity using a shared secret key derived from a key encapsulated using the public key (and have the end entity demonstrate its ability to use its private key for decapsulation of the KEM ciphertext, derive the shared secret key, decrypt this certificate, and provide a hash of the certificate in the confirmation message). This allows a CA to issue a certificate in a form that can only be used by the intended end entity.",
      "ja": "間接的な方法は、公開鍵を使用してカプセル化されたキーから派生した共有シークレットキーを使用して、最終エンティティに対して暗号化された証明書を発行することです（そして、エンティティはKEM暗号文の脱カプセル化のためにその秘密鍵を使用する能力を実証し、共有秘密の鍵を導き出し、この証明書を導き、確認メッセージのハスを提供します）。これにより、CAは、意図した最終エンティティによってのみ使用できるフォームで証明書を発行できます。"
    },
    {
      "indent": 3,
      "text": "This specification encourages use of the indirect method because it requires no extra messages to be sent (i.e., the proof can be demonstrated using the {request, response, confirmation} triple of messages).",
      "ja": "この仕様は、送信する余分なメッセージを必要としないため、間接的な方法の使用を促進します（つまり、{要求、応答、確認}メッセージのトリプルを使用して証明を実証できます）。"
    },
    {
      "indent": 3,
      "text": "A certification request message for a KEM certificate SHALL use POPOPrivKey by using the keyEncipherment choice of ProofOfPossession (see Section 5.2.8) in the popo field of CertReqMsg as long as no KEM-specific choice is available.",
      "ja": "KEM証明書の認定要求メッセージは、KEM固有の選択肢がない限り、CertreQMSGのPOPOフィールドにあるProofofPossessionのkeyencypherment選択（セクション5.2.8を参照）を使用してPopoprivkeyを使用するものとします。"
    },
    {
      "indent": 0,
      "text": "4.4. Root CA Key Update",
      "section_title": true,
      "ja": "4.4. ルートCAキーアップデート"
    },
    {
      "indent": 3,
      "text": "This discussion only applies to CAs that are directly trusted by some end entities. Recognizing whether a self-signed or non-self-signed CA is supposed to be directly trusted for some end entities is a matter of CA policy and end entity configuration. Thus, this is beyond the scope of this document.",
      "ja": "この議論は、一部の最終エンティティから直接信頼されるCAにのみ適用されます。いくつかの最終エンティティに対して自己署名または非自己署名のCAが直接信頼されるかどうかを認識することは、CAポリシーと最終エンティティの構成の問題です。したがって、これはこのドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "The basis of the procedure described here is that the CA protects its new public key using its previous private key and vice versa. Thus, when a CA updates its key pair, it may generate two link certificates: \"old with new\" and \"new with old\".",
      "ja": "ここで説明する手順の基礎は、CAが以前の秘密鍵を使用して新しい公開キーを保護し、その逆も同様です。したがって、CAがキーペアを更新すると、「古い」、「古いものと新しい」という2つのリンク証明書が生成される場合があります。"
    },
    {
      "indent": 3,
      "text": "Note: The usage of link certificates has been shown to be very specific for each use case, and no assumptions are done on this aspect. RootCaKeyUpdateContent is updated to specify these link certificates as optional.",
      "ja": "注：リンク証明書の使用は、各ユースケースに対して非常に具体的であることが示されており、この側面に関する仮定は行われていません。rootcakeyupdateContentが更新され、これらのリンク証明書をオプションとして指定します。"
    },
    {
      "indent": 3,
      "text": "Note: When an LDAP directory is used to publish root CA updates, the old and new root CA certificates together with the two link certificates are stored as cACertificate attribute values.",
      "ja": "注：LDAPディレクトリを使用してルートCAの更新を公開する場合、2つのリンク証明書と一緒に古いルートCA証明書と新しいルートCA証明書がcacertificate属性値として保存されます。"
    },
    {
      "indent": 3,
      "text": "When a CA changes its key pair, those entities who have acquired the old CA public key via \"out-of-band\" means are most affected. These end entities need to acquire the new CA public key in a trusted way. This may be achieved \"out-of-band\" by using a repository or by using online messages also containing the link certificates \"new with old\". Once the end entity acquired and properly verified the new CA public key, it must load the new trust anchor information into its trusted store.",
      "ja": "CAがキーペアを変更すると、「帯域外」平均を介して古いCAの公開キーを取得したエンティティが最も影響を受けます。これらの最終エンティティは、信頼できる方法で新しいCA公開キーを取得する必要があります。これは、リポジトリを使用するか、リンク証明書を含むオンラインメッセージを使用することにより、「バンド外」を実現できます。最終エンティティが取得し、新しいCA公開キーを適切に検証したら、新しいトラストアンカー情報を信頼できるストアにロードする必要があります。"
    },
    {
      "indent": 3,
      "text": "The data structure used to protect the new and old CA public keys is typically a standard X.509v3 certificate (which may also contain extensions). There are no new data structures required.",
      "ja": "新しいおよび古いCAパブリックキーを保護するために使用されるデータ構造は、通常、標準x.509v3証明書です（拡張機能も含まれている場合があります）。新しいデータ構造は必要ありません。"
    },
    {
      "indent": 3,
      "text": "Note: Sometimes self-signed root CA certificates do not make use of X.509v3 extensions and may be X.509v1 certificates. Therefore, a root CA key update must be able to work for version 1 certificates. The use of the X.509v3 KeyIdentifier extension is recommended for easier path building.",
      "ja": "注：自己署名のルートCA証明書がX.509V3拡張機能を使用せず、X.509V1証明書を使用しない場合があります。したがって、ルートCAキーアップデートは、バージョン1の証明書で動作できる必要があります。X.509V3 KeyIdentifier拡張機能の使用は、パス構築を容易にするために推奨されます。"
    },
    {
      "indent": 3,
      "text": "Note: While the scheme could be generalized to cover cases where the CA updates its key pair more than once during the validity period of one of its end entities' certificates, this generalization seems of dubious value. Not having this generalization simply means that the validity periods of certificates issued with the old CA key pair cannot exceed the end of the \"old with new\" certificate validity period.",
      "ja": "注：スキームは、CAがその最終エンティティの証明書の1つの有効期間中にキーペアを複数回更新するケースをカバーするために一般化できますが、この一般化は疑わしい価値のようです。この一般化を持たないことは、単に古いCAキーペアで発行された証明書の有効期間が、「新しい」証明書の有効期間の「古い」の終わりを超えることができないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Note: This scheme offers a mechanism to ensures that end entities will acquire the new CA public key, at the latest by the expiry of the last certificate they owned that was signed with the old CA private key. Certificate and/or key update operations occurring at other times do not necessarily require this (depending on the end entity's equipment).",
      "ja": "注：このスキームは、最新のエンティティが新しいCAの公開キーを取得することを保証するメカニズムを提供します。他の場合に発生する証明書および/または主要な更新操作は、必ずしもこれを必要とするわけではありません（エンティティのエンティティの機器に応じて）。"
    },
    {
      "indent": 3,
      "text": "Note: In practice, a new root CA may have a slightly different subject Distinguished Name (DN), e.g., indicating a generation identifier like the year of issuance or a version number, for instance, in an Organizational Unit (OU) element. How to bridge trust to the new root CA certificate in a CA DN change or a cross-certificate scenario is out of scope for this document.",
      "ja": "注：実際には、新しいルートCAには、わずかに異なる被験者の著名な名前（DN）がある場合があります。たとえば、発行年のような生成識別子や、たとえば組織単位（OU）要素のバージョン番号などの生成識別子を示しています。このドキュメントのCA DNの変更または相互公認シナリオで、CA DNの変更またはクロス認証シナリオで新しいルートCA証明書に信頼を橋渡しする方法。"
    },
    {
      "indent": 0,
      "text": "4.4.1. CA Operator Actions",
      "section_title": true,
      "ja": "4.4.1. CAオペレーターアクション"
    },
    {
      "indent": 3,
      "text": "To change the key of the CA, the CA operator does the following:",
      "ja": "CAのキーを変更するには、CAオペレーターが次のことを行います。"
    },
    {
      "indent": 8,
      "text": "1. Generate a new key pair.",
      "ja": "1. 新しいキーペアを生成します。"
    },
    {
      "indent": 8,
      "text": "2. Create a certificate containing the new CA public key signed with the new private key or by the private key of some other CA (the \"new with new\" certificate).",
      "ja": "2. 新しい秘密鍵で署名された新しいCA公開キーまたは他のCAの秘密鍵（「新しい」証明書を「新しい」証明書）で構成する証明書を作成します。"
    },
    {
      "indent": 8,
      "text": "3. Optionally: Create a link certificate containing the new CA public key signed with the old private key (the \"new with old\" certificate).",
      "ja": "3. オプションでは、古い秘密鍵（「古い」証明書を「新しい」証明書）に署名した新しいCA公開キーを含むリンク証明書を作成します。"
    },
    {
      "indent": 8,
      "text": "4. Optionally: Create a link certificate containing the old CA public key signed with the new private key (the \"old with new\" certificate).",
      "ja": "4. オプション：新しい秘密鍵（「新しい」証明書を持つ古い証明書）に署名された古いCA公開キーを含むリンク証明書を作成します。"
    },
    {
      "indent": 8,
      "text": "5. Publish these new certificates so that end entities may acquire it, e.g., using a repository or RootCaKeyUpdateContent.",
      "ja": "5. これらの新しい証明書を公開して、エンティティがリポジトリまたはrootcakeyUpDatententを使用してそれを取得できるようにします。"
    },
    {
      "indent": 3,
      "text": "The old CA private key is then no longer required when the validity of the \"old with old\" certificate ended. However, the old CA public key will remain in use for validating the \"new with old\" link certificate until the new CA public key is loaded into the trusted store. The old CA public key is no longer required (other than for non-repudiation) when all end entities of this CA have securely acquired and stored the new CA public key.",
      "ja": "「古い」証明書の有効性が終了した場合、古いCAの秘密鍵は不要になります。ただし、古いCAの公開キーは、新しいCA公開キーが信頼できるストアにロードされるまで、「古い」リンク証明書を検証するために使用され続けます。このCAのすべての最終エンティティが新しいCA公開キーを安全に取得して保存した場合、古いCAの公開キーは（非repudiation以外）必要ありません。"
    },
    {
      "indent": 3,
      "text": "The \"new with new\" certificate must have a validity period with a notBefore time that is before the notAfter time of the \"old with old\" certificate and a notAfter time that is after the notBefore time of the next update of this certificate.",
      "ja": "「新しい」証明書には、「古い」証明書のすぐ前の時間の前にある時間前に、この証明書の次の更新の前にある時間の後の時間の前にある有効期間がなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"new with old\" certificate must have a validity period with the same notBefore time as the \"new with new\" certificate and a notAfter time by which all end entities of this CA will securely possess the new CA public key (at the latest, at the notAfter time of the \"old with old\" certificate).",
      "ja": "「新しい」証明書は、「新しい」証明書と同じではなく、このCAのすべての最終エンティティが新しいCA公開鍵を安全に所有すると同じ時間と同じである有効期間を持たなければなりません（最新の「古い」証明書のノートの時間に）。"
    },
    {
      "indent": 3,
      "text": "The \"old with new\" certificate must have a validity period with the same notBefore and notAfter time as the \"old with old\" certificate.",
      "ja": "「古い」証明書には、「古い」証明書と同じであり、その前に時間がかかる有効期間がなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Further operational considerations on transition from one root CA self-signed certificate to the next is available in Section 5 of [RFC8649].",
      "ja": "注：1つのルートCAの自己署名証明書から次の証明書への移行に関するさらなる運用上の考慮事項は、[RFC8649]のセクション5で利用できます。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Verifying Certificates",
      "section_title": true,
      "ja": "4.4.2. 証明書の検証"
    },
    {
      "indent": 3,
      "text": "Normally when verifying a signature, the verifier verifies (among other things) the certificate containing the public key of the signer. However, once a CA is allowed to update its key, there are a range of new possibilities. These are shown in the table below.",
      "ja": "通常、署名を検証するとき、検証者は（とりわけ）署名者の公開鍵を含む証明書を（特に）検証します。ただし、CAがキーを更新することが許可されると、さまざまな新しい可能性があります。これらを下の表に示します。"
    },
    {
      "indent": 0,
      "text": "+======================+======================+=====================+\n|                      | Verifier's TEE       | Verifier's TEE      |\n|                      | contains NEW public  | contains OLD        |\n|                      | key                  | public key          |\n+======================+======================+=====================+\n| Signer's certificate | Case 1: The verifier | Case 2: The         |\n| is protected using   | can directly verify  | verifier is         |\n| NEW key pair         | the certificate.     | missing the NEW     |\n|                      |                      | public key.         |\n+======================+----------------------+---------------------+\n| Signer's certificate | Case 3: The verifier | Case 4: The         |\n| is protected using   | is missing the OLD   | verifier can        |\n| OLD key pair         | public key.          | directly verify     |\n|                      |                      | the certificate.    |\n+======================+----------------------+---------------------+\n\n                               Table 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.2.1. Verification in Cases 1 and 4",
      "section_title": true,
      "ja": "4.4.2.1. ケース1および4の検証"
    },
    {
      "indent": 3,
      "text": "In these cases, the verifier has a local copy of the CA public key that can be used to verify the certificate directly. This is the same as the situation where no key change has occurred.",
      "ja": "これらの場合、検証者には、証明書を直接検証するために使用できるCA公開キーのローカルコピーがあります。これは、重要な変更が発生していない状況と同じです。"
    },
    {
      "indent": 0,
      "text": "4.4.2.2. Verification in Case 2",
      "section_title": true,
      "ja": "4.4.2.2. ケース2の検証"
    },
    {
      "indent": 3,
      "text": "In case 2, the verifier must get access to the new public key of the CA. Case 2 will arise when the CA operator has issued the verifier's certificate, then changed the CA's key, and then issued the signer's certificate; so it is quite a typical case.",
      "ja": "ケース2では、検証者はCAの新しい公開鍵にアクセスする必要があります。CAオペレーターがVerifierの証明書を発行し、CAのキーを変更してから署名者の証明書を発行したときに、ケース2が発生します。したがって、それは非常に典型的なケースです。"
    },
    {
      "indent": 3,
      "text": "The verifier does the following:",
      "ja": "検証者は次のことを行います。"
    },
    {
      "indent": 8,
      "text": "1. Get the \"new with new\" and \"new with old\" certificates. The location of where to retrieve these certificates may be available in the authority information access extension of the \"old with old\" certificate (see the access method for caIssuers in Section 4.2.2.1 of [RFC5280]), or it may be locally configured.",
      "ja": "1. 「新しい」と「古い」証明書を取得します。これらの証明書を取得する場所の場所は、「古い」証明書の権限情報アクセス拡張で利用可能になる場合があります（[RFC5280]のセクション4.2.2.1のCaissuersのアクセス方法を参照）、または局所的に構成されている場合があります。"
    },
    {
      "indent": 16,
      "text": "a. If a repository is available, look up the certificates in the caCertificate attribute.",
      "ja": "a. リポジトリが利用可能な場合は、cacertificate属性の証明書を調べます。"
    },
    {
      "indent": 16,
      "text": "b. If an HTTP or FTP server is available, pick the certificates from the \"certs-only\" CMS message.",
      "ja": "b. HTTPまたはFTPサーバーが利用可能な場合は、「CERTSのみの」CMSメッセージから証明書を選択します。"
    },
    {
      "indent": 16,
      "text": "c. If a CMP server is available, request the certificates using the root CA update the general message (see Section 5.3.19.15).",
      "ja": "c. CMPサーバーが使用可能な場合は、ルートCAを使用して証明書に一般的なメッセージを更新します（セクション5.3.19.15を参照）。"
    },
    {
      "indent": 16,
      "text": "d. Otherwise, get the certificates \"out-of-band\" using any trustworthy mechanism.",
      "ja": "d. それ以外の場合は、信頼できるメカニズムを使用して「バンド外」の証明書を取得します。"
    },
    {
      "indent": 8,
      "text": "2. If the certificates are received, check that the validity periods and the subject and issuer fields match. Verify the signatures using the old root CA key (which the verifier has locally).",
      "ja": "2. 証明書を受け取った場合は、有効期間と被験者と発行者のフィールドが一致することを確認します。古いルートCAキー（検証者にローカルにある）を使用して署名を確認します。"
    },
    {
      "indent": 8,
      "text": "3. If all checks are successful, securely store the new trust anchor information and validate the signer's certificate.",
      "ja": "3. すべてのチェックが成功した場合は、新しいトラストアンカー情報を安全に保存し、署名者の証明書を検証します。"
    },
    {
      "indent": 0,
      "text": "4.4.2.3. Verification in Case 3",
      "section_title": true,
      "ja": "4.4.2.3. ケース3の検証"
    },
    {
      "indent": 3,
      "text": "In case 3, the verifier must get access to the old public key of the CA. Case 3 will arise when the CA operator has issued the signer's certificate, then changed the key, and then issued the verifier's certificate.",
      "ja": "ケース3では、検証者はCAの古い公開鍵にアクセスする必要があります。CAオペレーターが署名者の証明書を発行し、キーを変更してからVerifierの証明書を発行したときに、ケース3が発生します。"
    },
    {
      "indent": 3,
      "text": "The verifier does the following:",
      "ja": "検証者は次のことを行います。"
    },
    {
      "indent": 8,
      "text": "1. Get the \"old with new\" certificate. The location of where to retrieve these certificates may be available in the authority information access extension of the \"new with new\" certificate (see caIssuers access method in Section 4.2.2.1 of [RFC5280]), or it may be locally configured.",
      "ja": "1. 「新しい」証明書を取得します。これらの証明書を取得する場所の場所は、「新しい」証明書（[RFC5280]のセクション4.2.2.1のCAISSUERSアクセス方法を参照）の権限情報アクセス拡張で利用できる場合があります。"
    },
    {
      "indent": 16,
      "text": "a. If a repository is available, look up the certificate in the caCertificate attribute.",
      "ja": "a. リポジトリが利用可能な場合は、cacertificate属性の証明書を調べます。"
    },
    {
      "indent": 16,
      "text": "b. If an HTTP or FTP server is available, pick the certificate from the \"certs-only\" CMS message.",
      "ja": "b. HTTPまたはFTPサーバーが利用可能な場合は、「CERTSのみの」CMSメッセージから証明書を選択します。"
    },
    {
      "indent": 16,
      "text": "c. If a CMP server and an untrusted copy of the old root CA certificate are available (e.g., the signer provided it in-band in the CMP extraCerts filed), request the certificate using the root CA update the general message (see Section 5.3.19.15).",
      "ja": "c. CMPサーバーと古いルートCA証明書の信頼できないコピーが利用可能である場合（たとえば、署名者は、提出されたCMPエクストラメートで帯域内を提供しました）、ルートCAを使用して一般的なメッセージを更新して証明書を要求します（セクション5.3.19.15を参照）。"
    },
    {
      "indent": 16,
      "text": "d. Otherwise, get the certificate \"out-of-band\" using any trustworthy mechanism.",
      "ja": "d. それ以外の場合は、信頼できるメカニズムを使用して証明書を「バンド外」に入手します。"
    },
    {
      "indent": 8,
      "text": "2. If the certificate is received, check that the validity periods and the subject and issuer fields match. Verify the signatures using the new root CA key (which the verifier has locally).",
      "ja": "2. 証明書を受け取った場合は、有効期間と被験者と発行者のフィールドが一致することを確認します。新しいルートCAキー（検証者がローカルに持っている）を使用して署名を確認します。"
    },
    {
      "indent": 8,
      "text": "3. If all checks were successful, securely store the old trust anchor information and validate the signer's certificate.",
      "ja": "3. すべてのチェックが成功した場合は、古いトラストアンカー情報を安全に保存し、署名者の証明書を検証します。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Revocation - Change of the CA Key",
      "section_title": true,
      "ja": "4.4.3. 取り消し -  CAキーの変更"
    },
    {
      "indent": 3,
      "text": "As we saw above, the verification of a certificate becomes more complex once the CA is allowed to change its key. This is also true for revocation checks, as the CA may have signed the CRL using a newer private key than the one within the user's TEE.",
      "ja": "上で見たように、CAがキーを変更することが許可されると、証明書の検証がより複雑になります。これは、CAがユーザーのティー内の秘密キーよりも新しい秘密鍵を使用してCRLに署名した可能性があるため、取り消しチェックにも当てはまります。"
    },
    {
      "indent": 3,
      "text": "The analysis of the alternatives is the same as for certificate verification.",
      "ja": "代替案の分析は、証明書の検証と同じです。"
    },
    {
      "indent": 0,
      "text": "4.5. EKU for PKI Entities",
      "section_title": true,
      "ja": "4.5. PKIエンティティのEKU"
    },
    {
      "indent": 3,
      "text": "The EKU extension indicates the purposes for which the certified key pair may be used. Therefore, it restricts the use of a certificate to specific applications.",
      "ja": "EKU拡張機能は、認定されたキーペアを使用できる目的を示します。したがって、特定のアプリケーションへの証明書の使用を制限します。"
    },
    {
      "indent": 3,
      "text": "A CA may want to delegate parts of its duties to other PKI management entities. This section provides a mechanism to both prove this delegation and enable automated means for checking the authorization of this delegation. Such delegation may also be expressed by other means, e.g., explicit configuration.",
      "ja": "CAは、その義務の一部を他のPKI管理エンティティに委任したい場合があります。このセクションは、この委任を証明するメカニズムを提供し、この委任の認可をチェックするための自動化された手段を可能にします。このような委任は、例えば明示的な構成など、他の手段によって表現される場合があります。"
    },
    {
      "indent": 3,
      "text": "To offer automatic validation for the delegation of a role by a CA to another entity, the certificates used for CMP message protection or signed data for central key generation MUST be issued by the delegating CA and MUST contain the respective EKUs. This proves that the delegating CA authorized this entity to act in the given role, as described below.",
      "ja": "CAによる役割の委任のための自動検証を別のエンティティに提供するには、CMPメッセージ保護または中央キー生成の署名データに使用される証明書を委任CAによって発行する必要があり、それぞれのEKUを含める必要があります。これは、以下に説明するように、委任CAがこのエンティティが与えられた役割で行動することを許可したことを証明しています。"
    },
    {
      "indent": 3,
      "text": "The OIDs to be used for these EKUs are:",
      "ja": "これらのEKUに使用されるOIDは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "id-kp-cmcCA OBJECT IDENTIFIER ::= {\n   iso(1) identified-organization(3) dod(6) internet(1)\n   security(5) mechanisms(5) pkix(7) kp(3) 27 }\n\nid-kp-cmcRA OBJECT IDENTIFIER ::= {\n   iso(1) identified-organization(3) dod(6) internet(1)\n   security(5) mechanisms(5) pkix(7) kp(3) 28 }\n\nid-kp-cmKGA OBJECT IDENTIFIER ::= {\n   iso(1) identified-organization(3) dod(6) internet(1)\n   security(5) mechanisms(5) pkix(7) kp(3) 32 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: Section 2.10 of [RFC6402] specifies OIDs for a Certificate Management over CMS (CMC) CA and a CMC RA. As the functionality of a CA and RA is not specific to any protocol used for managing certificates (such as CMC or CMP), these EKUs are reused by CMP.",
      "ja": "注：[RFC6402]のセクション2.10は、CMS（CMC）CAおよびCMC RAを介した証明書管理のOIDを指定しています。CAとRAの機能は、証明書の管理（CMCやCMPなど）の管理に使用されるプロトコルに固有のものではないため、これらのEKUはCMPによって再利用されます。"
    },
    {
      "indent": 3,
      "text": "The meaning of the id-kp-cmKGA EKU is as follows:",
      "ja": "ID-KP-CMKGA EKUの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "CMP KGA:",
      "ja": "CMP KGA："
    },
    {
      "indent": 12,
      "text": "CMP KGAs are CAs or are identified by the id-kp-cmKGA EKU. The CMP KGA knows the private key it generated on behalf of the end entity. This is a very sensitive service and needs specific authorization, which by default is with the CA certificate itself. The CA may delegate its authorization by placing the id-kp-cmKGA EKU in the certificate used to authenticate the origin of the generated private key. The authorization may also be determined through local configuration of the end entity.",
      "ja": "CMP KGAはCASであるか、ID-KP-CMKGA EKUによって識別されます。CMP KGAは、最終エンティティに代わって生成された秘密鍵を知っています。これは非常にデリケートなサービスであり、特定の承認が必要であり、デフォルトではCA証明書自体にあります。CAは、生成された秘密鍵の原点を認証するために使用される証明書にID-KP-CMKGA EKUを証明書に配置することにより、承認を委任することができます。承認は、最終エンティティのローカル構成によっても決定される場合があります。"
    },
    {
      "indent": 0,
      "text": "5. Data Structures",
      "section_title": true,
      "ja": "5. データ構造"
    },
    {
      "indent": 3,
      "text": "This section contains descriptions of the data structures required for PKI management messages. Section 6 describes constraints on their values and the sequence of events for each of the various PKI management operations.",
      "ja": "このセクションには、PKI管理メッセージに必要なデータ構造の説明が含まれています。セクション6では、さまざまなPKI管理操作のそれぞれの値と一連のイベントに関する制約について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Overall PKI Message",
      "section_title": true,
      "ja": "5.1. 全体的なPKIメッセージ"
    },
    {
      "indent": 3,
      "text": "All of the messages used in this specification for the purposes of PKI management use the following structure:",
      "ja": "PKI管理の目的でこの仕様で使用されるすべてのメッセージは、次の構造を使用します。"
    },
    {
      "indent": 5,
      "text": "PKIMessage ::= SEQUENCE {\n   header           PKIHeader,\n   body             PKIBody,\n   protection   [0] PKIProtection OPTIONAL,\n   extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                     OPTIONAL\n}\n\nPKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The PKIHeader contains information that is common to many PKI messages.",
      "ja": "PKIHeaderには、多くのPKIメッセージに共通の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The PKIBody contains message-specific information.",
      "ja": "pkibodyにはメッセージ固有の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The PKIProtection, when used, contains bits that protect the PKI message.",
      "ja": "PKIPROTECTIONは、使用すると、PKIメッセージを保護するビットが含まれています。"
    },
    {
      "indent": 3,
      "text": "The extraCerts field can contain certificates that may be useful to the recipient. For example, this can be used by a CA or RA to present an end entity with certificates that it needs to verify its own new certificate (for example, if the CA that issued the end entity's certificate is not a root CA for the end entity). Note that this field does not necessarily contain a certification path; the recipient may have to sort, select from, or otherwise process the extra certificates in order to use them.",
      "ja": "Extracertsフィールドには、受信者に役立つ可能性のある証明書を含めることができます。たとえば、これはCAまたはRAが使用して、独自の新しい証明書を検証する必要がある証明書を終了エンティティに提示することができます（たとえば、エンティティの証明書を発行したCAが終了エンティティのルートCAではない場合）。このフィールドには必ずしも認証パスが含まれているわけではないことに注意してください。受信者は、使用するために追加の証明書を並べ替え、選択、または処理する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. PKI Message Header",
      "section_title": true,
      "ja": "5.1.1. PKIメッセージヘッダー"
    },
    {
      "indent": 3,
      "text": "All PKI messages require some header information for addressing and transaction identification. Some of this information will also be present in a transport-specific envelope. However, if the PKI message is protected, then this information is also protected (i.e., we make no assumption about secure transport).",
      "ja": "すべてのPKIメッセージには、アドレス指定とトランザクション識別のためのヘッダー情報が必要です。この情報の一部は、輸送固有のエンベロープにも存在します。ただし、PKIメッセージが保護されている場合、この情報も保護されています（つまり、安全な輸送について仮定しません）。"
    },
    {
      "indent": 3,
      "text": "The following data structure is used to contain this information:",
      "ja": "次のデータ構造は、この情報を抑えるために使用されます。"
    },
    {
      "indent": 5,
      "text": "PKIHeader ::= SEQUENCE {\n   pvno                INTEGER     { cmp1999(1), cmp2000(2),\n                                     cmp2021(3) },\n   sender              GeneralName,\n   recipient           GeneralName,\n   messageTime     [0] GeneralizedTime         OPTIONAL,\n   protectionAlg   [1] AlgorithmIdentifier{ALGORITHM, {...}}\n                       OPTIONAL,\n   senderKID       [2] KeyIdentifier           OPTIONAL,\n   recipKID        [3] KeyIdentifier           OPTIONAL,\n   transactionID   [4] OCTET STRING            OPTIONAL,\n   senderNonce     [5] OCTET STRING            OPTIONAL,\n   recipNonce      [6] OCTET STRING            OPTIONAL,\n   freeText        [7] PKIFreeText             OPTIONAL,\n   generalInfo     [8] SEQUENCE SIZE (1..MAX) OF\n                       InfoTypeAndValue     OPTIONAL\n}\n\nPKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The usage of the protocol version number (pvno) is described in Section 7.",
      "ja": "プロトコルバージョン番号（PVNO）の使用については、セクション7で説明されています。"
    },
    {
      "indent": 3,
      "text": "The sender field contains the name of the sender of the PKIMessage. This name (in conjunction with senderKID, if supplied) should be sufficient to indicate the key to use to verify the protection on the message. If nothing about the sender is known to the sending entity (e.g., in the initial request message, where the end entity may not know its own DN, email name, IP address, etc.), then the \"sender\" field MUST contain a \"NULL-DN\" value in the directoryName choice. A \"NULL-DN\" is a SEQUENCE OF relative DNs of zero length and is encoded as 0x3000. In such a case, the senderKID field MUST hold an identifier (i.e., a reference number) that indicates to the receiver the appropriate shared secret information to use to verify the message.",
      "ja": "送信者フィールドには、pkimessageの送信者の名前が含まれています。この名前（供給されている場合は、senderkidと併せて）は、メッセージの保護を検証するために使用する鍵を示すのに十分でなければなりません。送信者について送信エンティティに知られていない場合（例：最終エンティティが独自のDN、電子メール名、IPアドレスなどを知らない最初の要求メッセージで）、「送信者」フィールドには、ディレクトリ名の選択に「null-dn」値を含める必要があります。「null-dn」は、長さがゼロの相対DNSのシーケンスであり、0x3000としてエンコードされます。そのような場合、SenderKidフィールドは、メッセージを検証するために使用する適切な共有秘密情報を受信者に示す識別子（つまり、参照番号）を保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "The recipient field contains the name of the recipient of the PKIMessage. This name (in conjunction with recipKID, if supplied) should be usable to verify the protection on the message.",
      "ja": "受信フィールドには、pkimessageの受信者の名前が含まれています。この名前（Recistkidと併せて、提供される場合）は、メッセージの保護を検証するために使用できる必要があります。"
    },
    {
      "indent": 3,
      "text": "The protectionAlg field specifies the algorithm used to protect the message. If no protection bits are supplied (note that PKIProtection is OPTIONAL), then this field MUST be omitted; if protection bits are supplied, then this field MUST be supplied.",
      "ja": "Protectionalgフィールドは、メッセージを保護するために使用されるアルゴリズムを指定します。保護ビットが供給されない場合（pkiprotectionがオプションであることに注意してください）、このフィールドは省略する必要があります。保護ビットが供給される場合は、このフィールドに供給する必要があります。"
    },
    {
      "indent": 3,
      "text": "senderKID and recipKID are usable to indicate which keys have been used to protect the message (recipKID will normally only be required where protection of the message uses DH or Elliptic Curve Diffie-Hellman (ECDH) keys). These fields MUST be used if required to uniquely identify a key (e.g., if more than one key is associated with a given sender name). The senderKID SHOULD be used in any case.",
      "ja": "SenderKidとRecipkidは、メッセージを保護するために使用されたキーを示すために使用可能です（通常、メッセージの保護がDHまたはElliptic Curve Diffie-Hellman（ECDH）キーを使用する場合にのみ必要です）。これらのフィールドは、キーをユニークに識別するために必要な場合に使用する必要があります（たとえば、特定の送信者名に複数のキーが関連付けられている場合）。SenderKidは、いずれにしても使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The recommendation of using senderKID has changed since [RFC4210], where it was recommended to be omitted if not needed to identify the protection key.",
      "ja": "注：SenderKidの使用の推奨事項は、[RFC4210]以来変更されました。これは、保護キーを特定するために必要でない場合は省略することをお勧めしました。"
    },
    {
      "indent": 3,
      "text": "The transactionID field within the message header is to be used to allow the recipient of a message to correlate this with an ongoing transaction. This is needed for all transactions that consist of more than just a single request/response pair. For transactions that consist of a single request/response pair, the rules are as follows. A client MUST populate the transactionID field if the message contains an infoValue of type KemCiphertextInfo (see Section 5.1.3.4). In all other cases, the client MAY populate the transactionID field of the request. If a server receives such a request that has the transactionID field set, then it MUST set the transactionID field of the response to the same value. If a server receives such request with a missing transactionID field, then it MUST populate the transactionID field if the message contains a KemCiphertextInfo field. In all other cases, the server MAY set the transactionID field of the response.",
      "ja": "メッセージヘッダー内のTransactionIDフィールドを使用して、メッセージの受信者がこれを継続的なトランザクションと相関させることができます。これは、単一のリクエスト/応答ペア以上のもので構成されるすべてのトランザクションに必要です。単一のリクエスト/応答ペアで構成されるトランザクションの場合、ルールは次のとおりです。メッセージにタイプKemciphertextinfoの情報値が含まれている場合、クライアントはTransactionIDフィールドに入力する必要があります（セクション5.1.3.4を参照）。他のすべての場合において、クライアントはリクエストのTransactionIDフィールドに入力する場合があります。サーバーがTransactionIDフィールドセットを備えたそのような要求を受信した場合、同じ値への応答のTransactionIDフィールドを設定する必要があります。サーバーが不足しているTransactionIDフィールドでそのような要求を受信した場合、メッセージにKemciphertextinfoフィールドが含まれている場合、TransactionIDフィールドに入力する必要があります。他のすべての場合、サーバーは応答のトランザクションIDフィールドを設定する場合があります。"
    },
    {
      "indent": 3,
      "text": "For transactions that consist of more than just a single request/ response pair, the rules are as follows. If the message contains an infoValue of type KemCiphertextInfo, the client MUST generate a transactionID; otherwise, the client SHOULD generate a transactionID for the first request. If a server receives such a request that has the transactionID field set, then it MUST set the transactionID field of the response to the same value. If a server receives such request with a missing transactionID field, then it MUST populate the transactionID field of the response with a server-generated ID. Subsequent requests and responses MUST all set the transactionID field to the thus established value. In all cases where a transactionID is being used, a given client MUST NOT have more than one transaction with the same transactionID in progress at any time (to a given server). Servers are free to require uniqueness of the transactionID or not, as long as they are able to correctly associate messages with the corresponding transaction. Typically, this means that a server will require the {client, transactionID} tuple to be unique, or even the transactionID alone to be unique, if it cannot distinguish clients based on any transport-level information. A server receiving the first message of a transaction (which requires more than a single request/response pair) that contains a transactionID that does not allow it to meet the above constraints (typically because the transactionID is already in use) MUST send back an ErrorMsgContent with a PKIFailureInfo of transactionIdInUse. It is RECOMMENDED that the clients fill the transactionID field with 128 bits of (pseudo-)random data for the start of a transaction to reduce the probability of having the transactionID in use at the server.",
      "ja": "単一のリクエスト/応答ペア以上のもので構成されるトランザクションの場合、ルールは次のとおりです。メッセージにkemciphertextinfoのタイプの情報が含まれている場合、クライアントはトランザクションIDを生成する必要があります。それ以外の場合、クライアントは最初のリクエストのためにトランザクションIDを生成する必要があります。サーバーがTransactionIDフィールドセットを備えたそのような要求を受信した場合、同じ値への応答のTransactionIDフィールドを設定する必要があります。サーバーが不足しているTransactionIDフィールドでそのような要求を受信した場合、サーバーで生成されたIDを使用して、応答のトランザクションIDフィールドに設置する必要があります。その後のリクエストと応答はすべて、TransactionIDフィールドをこのように確立された値に設定する必要があります。TransactionIDが使用されているすべての場合において、特定のクライアントは、いつでも（特定のサーバーに）進行中の同じトランザクションIDを使用して複数のトランザクションを持っている必要があります。サーバーは、対応するトランザクションにメッセージを正しく関連付けることができる限り、TransactionIDの独自性を自由に必要とします。通常、これは、サーバーが{クライアント、トランザクションID}タプルが一意であることを要求することを意味します。または、トランスポートレベルの情報に基づいてクライアントを区別できない場合は、トランザクションIDだけであることが一意であることを意味します。トランザクションの最初のメッセージ（単一のリクエスト/応答ペアを必要とする）を受信するサーバーは、上記の制約を満たさないトランザクションID（通常、トランザクションIDがすでに使用されているため）を含む必要があります。クライアントは、トランザクションの開始時にTransactionIDフィールドを128ビットの（擬似）ランダムデータで埋めて、サーバーでTransactionIDを使用する可能性を減らすことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The senderNonce and recipNonce fields protect the PKIMessage against replay attacks. The senderNonce will typically be 128 bits of (pseudo-)random data generated by the sender, whereas the recipNonce is copied from the senderNonce field of the previous message in the transaction.",
      "ja": "SendernonceとRecistnonceフィールドは、リプレイ攻撃からPkimessageを保護します。Sendernonceは通常、送信者によって生成された128ビットの（擬似）ランダムデータになりますが、Recipnonceはトランザクションの前のメッセージのSendernonceフィールドからコピーされます。"
    },
    {
      "indent": 3,
      "text": "The messageTime field contains the time at which the sender created the message. This may be useful to allow end entities to correct/ check their local time for consistency with the time on a central system.",
      "ja": "Messagetimeフィールドには、送信者がメッセージを作成する時間が含まれています。これは、最終エンティティが中央システムの時間との一貫性について現地時間を修正/確認できるようにするのに役立つ場合があります。"
    },
    {
      "indent": 3,
      "text": "The freeText field may be used to send a human-readable message to the recipient (in any number of languages). Each UTF8String MAY include a language tag [RFC5646] to indicate the language of the contained text. The first language used in this sequence indicates the desired language for replies.",
      "ja": "フリーテキストフィールドを使用して、人間の読み取り可能なメッセージを受信者に（任意の数の言語で）送信することができます。各UTF8STRINGには、含まれるテキストの言語を示す言語タグ[RFC5646]が含まれる場合があります。このシーケンスで使用される第一言語は、返信に望ましい言語を示します。"
    },
    {
      "indent": 3,
      "text": "The generalInfo field may be used to send machine-processable additional data to the recipient. The following generalInfo extensions are defined and MAY be supported.",
      "ja": "GeneralInfoフィールドを使用して、マシン処理可能な追加データを受信者に送信できます。以下のgeneralInfo拡張機能が定義されており、サポートされる場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1.1. ImplicitConfirm",
      "section_title": true,
      "ja": "5.1.1.1. 暗黙的なこと"
    },
    {
      "indent": 3,
      "text": "This is used by the end entity to inform the CA or RA that it does not wish to send a certificate confirmation for issued certificates.",
      "ja": "これは、終了エンティティによって使用されて、発行された証明書の証明書確認を送信したくないことをCAまたはRAに通知します。"
    },
    {
      "indent": 5,
      "text": "id-it-implicitConfirm OBJECT IDENTIFIER ::= {id-it 13}\nImplicitConfirmValue ::= NULL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the CA grants the request to the end entity, it MUST put the same extension in the PKIHeader of the response. If the end entity does not find the extension in the response, it MUST send the certificate confirmation.",
      "ja": "CAが最終エンティティへの要求を付与する場合、同じ拡張機能を応答のpkiheaderに配置する必要があります。終了エンティティが応答に拡張機能を見つけられない場合、証明書の確認を送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1.2. ConfirmWaitTime",
      "section_title": true,
      "ja": "5.1.1.2. 確認waittime"
    },
    {
      "indent": 3,
      "text": "This is used by the CA or RA to inform the end entity how long it intends to wait for the certificate confirmation before revoking the certificate and deleting the transaction.",
      "ja": "これは、CAまたはRAによって使用されて、証明書を取り消してトランザクションを削除する前に証明書確認を待つ予定であるエンティティを通知します。"
    },
    {
      "indent": 5,
      "text": "id-it-confirmWaitTime OBJECT IDENTIFIER ::= {id-it 14}\nConfirmWaitTimeValue ::= GeneralizedTime",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.1.1.3. OrigPKIMessage",
      "section_title": true,
      "ja": "5.1.1.3. origpkimessage"
    },
    {
      "indent": 3,
      "text": "An RA MAY include the original PKIMessage from the end entity in the generalInfo field of the PKIHeader of a PKIMessage. This is used by the RA to inform the CA of the original PKIMessage that it received from the end entity and modified in some way (e.g., added or modified particular field values or added new extensions) before forwarding the new PKIMessage. This accommodates, for example, cases in which the CA wishes to check the message origin, the POP, or other information on the original end entity message.",
      "ja": "RAには、pkimessageのpkiheaderのGeneralInfoフィールドにある最終エンティティからの元のpkimessageが含まれる場合があります。これはRAで使用され、CAに最終エンティティから受け取った元の潜水積を通知し、新しいpkimessageを転送する前に何らかの方法で変更され（たとえば、特定のフィールド値または追加された新しい拡張機能を追加または変更した）ことを通知します。これは、たとえば、CAがメッセージの原点、POP、または元のEndエンティティメッセージのその他の情報を確認したい場合に対応します。"
    },
    {
      "indent": 3,
      "text": "Note: If the changes made by the RA to the original PKIMessage break the POP of a certificate request, the RA can set the popo field of the new PKIMessage to raVerified (see Section 5.2.8.4).",
      "ja": "注：RAが元のPkimessageに加えた変更が証明書リクエストのポップを破壊すると、RAは新しいPkimessageのPopoフィールドをラバイ化に設定できます（セクション5.2.8.4を参照）。"
    },
    {
      "indent": 3,
      "text": "Unless the OrigPKIMessage infoValue is in the header of a nested message, it MUST contain exactly one PKIMessage. The contents of OrigPKIMessage infoValue in the header of a nested message MAY contain multiple PKIMessage structures, which MUST be in the same order as the PKIMessage structures in PKIBody.",
      "ja": "OrigpKimessage InfoValueがネストされたメッセージのヘッダーにある場合を除き、正確に1つのpkimessageを含める必要があります。ネストされたメッセージのヘッダーにあるOrigpKimessage InfoValueの内容には、複数のpkimessage構造が含まれている場合があります。これは、pkibodyのpkimessage構造と同じ順序でなければなりません。"
    },
    {
      "indent": 5,
      "text": "id-it-origPKIMessage OBJECT IDENTIFIER ::= {id-it 15}\nOrigPKIMessageValue ::= PKIMessages",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.1.1.4. CertProfile",
      "section_title": true,
      "ja": "5.1.1.4. certprofile"
    },
    {
      "indent": 3,
      "text": "This is used by the end entity to indicate specific certificate profiles, e.g., when requesting a new certificate or a certificate request template (see Section 5.3.19.16).",
      "ja": "これは、新しい証明書プロファイルを示すために最終エンティティによって使用されます。たとえば、新しい証明書または証明書要求テンプレートを要求する場合（セクション5.3.19.16を参照）。"
    },
    {
      "indent": 5,
      "text": "id-it-certProfile OBJECT IDENTIFIER ::= {id-it 21}\nCertProfileValue ::= SEQUENCE SIZE (1..MAX) OF UTF8String",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When used in a p10cr message, the CertProfileValue sequence MUST NOT contain multiple certificate profile names. When used in an ir/cr/kur/genm message, the CertProfileValue sequence MUST NOT contain more certificate profile names than the number of CertReqMsg or GenMsgContent InfoTypeAndValue elements contained in the message body.",
      "ja": "P10CRメッセージで使用する場合、certProfilevalueシーケンスには複数の証明書プロファイル名を含めてはなりません。IR/CR/KUR/GENMメッセージで使用する場合、certProfilevalueシーケンスには、メッセージ本文に含まれるcertreqmsgまたはgenmsgcontent infotypeandvalue要素の数よりも多くの証明書プロファイル名を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "The certificate profile names in the CertProfileValue sequence relate to the CertReqMsg or GenMsgContent InfoTypeAndValue elements in the given order. An empty string means no certificate profile name is associated with the respective CertReqMsg or GenMsgContent InfoTypeAndValue element. If the CertProfileValue sequence contains less certificate profile entries than CertReqMsg or GenMsgContent InfoTypeAndValue elements, the remaining CertReqMsg or GenMsgContent InfoTypeAndValue elements have no profile name associated with them.",
      "ja": "CertProfileValueシーケンスの証明書プロファイル名は、指定された順序でcertreqMSGまたはgenmsgContentインフォタイプアンドバリュー要素に関連しています。空の文字列は、証明書プロファイル名がそれぞれのcertreqmsgまたはgenmsgcontent infotypeandValue要素に関連付けられていないことを意味します。CertProfileValueシーケンスにCertreQMSGまたはGenmsgContent InfotypeandValue要素よりも少ない証明書プロファイルエントリが含まれている場合、残りのCertreQMSGまたはGenmsgContent InfotypeandValue要素には、それらに関連するプロファイル名がありません。"
    },
    {
      "indent": 0,
      "text": "5.1.1.5. KemCiphertextInfo",
      "section_title": true,
      "ja": "5.1.1.5. kemciphertextinfo"
    },
    {
      "indent": 3,
      "text": "A PKI entity MAY provide the KEM ciphertext for MAC-based message protection using KEM (see Section 5.1.3.4) in the generalInfo field of a request message to a PKI management entity if it knows that the PKI management entity uses a KEM key pair and has its public key.",
      "ja": "PKIエンティティは、PKI管理エンティティがKEMキーペアを使用し、公開キーを持っていることを知っている場合、PKI管理エンティティへの要求メッセージの一般的なフィールドのKEM（セクション5.1.3.4を参照）を使用して、Macベースのメッセージ保護用のKEM Ciphertextを提供できます。"
    },
    {
      "indent": 5,
      "text": "id-it-KemCiphertextInfo OBJECT IDENTIFIER ::= { id-it 24 }\nKemCiphertextInfoValue ::= KemCiphertextInfo",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For more details of KEM-based message protection, see Section 5.1.3.4. See Section 5.3.19.18 for the definition of {id-it 24}.",
      "ja": "KEMベースのメッセージ保護の詳細については、セクション5.1.3.4を参照してください。{id-it 24}の定義については、セクション5.3.19.18を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.1.2. PKI Message Body",
      "section_title": true,
      "ja": "5.1.2. PKIメッセージ本文"
    },
    {
      "indent": 5,
      "text": "PKIBody ::= CHOICE {\n   ir       [0]  CertReqMessages,        --Initialization Req\n   ip       [1]  CertRepMessage,         --Initialization Resp\n   cr       [2]  CertReqMessages,        --Certification Req\n   cp       [3]  CertRepMessage,         --Certification Resp\n   p10cr    [4]  CertificationRequest,   --PKCS #10 Cert.  Req.\n   popdecc  [5]  POPODecKeyChallContent, --pop Challenge\n   popdecr  [6]  POPODecKeyRespContent,  --pop Response\n   kur      [7]  CertReqMessages,        --Key Update Request\n   kup      [8]  CertRepMessage,         --Key Update Response\n   krr      [9]  CertReqMessages,        --Key Recovery Req\n   krp      [10] KeyRecRepContent,       --Key Recovery Resp\n   rr       [11] RevReqContent,          --Revocation Request\n   rp       [12] RevRepContent,          --Revocation Response\n   ccr      [13] CertReqMessages,        --Cross-Cert.  Request\n   ccp      [14] CertRepMessage,         --Cross-Cert.  Resp\n   ckuann   [15] CAKeyUpdContent,        --CA Key Update Ann.\n   cann     [16] CertAnnContent,         --Certificate Ann.\n   rann     [17] RevAnnContent,          --Revocation Ann.\n   crlann   [18] CRLAnnContent,          --CRL Announcement\n   pkiconf  [19] PKIConfirmContent,      --Confirmation\n   nested   [20] NestedMessageContent,   --Nested Message\n   genm     [21] GenMsgContent,          --General Message\n   genp     [22] GenRepContent,          --General Response\n   error    [23] ErrorMsgContent,        --Error Message\n   certConf [24] CertConfirmContent,     --Certificate Confirm\n   pollReq  [25] PollReqContent,         --Polling Request\n   pollRep  [26] PollRepContent          --Polling Response\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The specific types are described in Section 5.3 below.",
      "ja": "特定のタイプについては、以下のセクション5.3で説明します。"
    },
    {
      "indent": 0,
      "text": "5.1.3. PKI Message Protection",
      "section_title": true,
      "ja": "5.1.3. PKIメッセージ保護"
    },
    {
      "indent": 3,
      "text": "Some PKI messages will be protected for integrity.",
      "ja": "一部のPKIメッセージは、完全性のために保護されます。"
    },
    {
      "indent": 3,
      "text": "Note: If an asymmetric algorithm is used to protect a message and the relevant public component has been certified already, then the origin of the message can also be authenticated. On the other hand, if the public component is uncertified, then the message origin cannot be automatically authenticated but may be authenticated via out-of-band means.",
      "ja": "注：非対称アルゴリズムを使用してメッセージを保護し、関連するパブリックコンポーネントがすでに認定されている場合、メッセージの起源も認証できます。一方、パブリックコンポーネントが認証されていない場合、メッセージの原点は自動的に認証されることはできませんが、帯域外の手段を介して認証される場合があります。"
    },
    {
      "indent": 3,
      "text": "When protection is applied, the following structure is used:",
      "ja": "保護が適用されると、次の構造が使用されます。"
    },
    {
      "indent": 5,
      "text": "PKIProtection ::= BIT STRING",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The input to the calculation of PKIProtection is the DER encoding of the following data structure:",
      "ja": "pkiprotectionの計算への入力は、次のデータ構造のderエンコードです。"
    },
    {
      "indent": 5,
      "text": "ProtectedPart ::= SEQUENCE {\n   header    PKIHeader,\n   body      PKIBody\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "There MAY be cases in which the PKIProtection BIT STRING is deliberately not used to protect a message (i.e., this OPTIONAL field is omitted) because other protection, external to PKIX, will be applied instead. Such a choice is explicitly allowed in this specification. Examples of such external protection include CMS [RFC5652] and Security Multiparts [RFC1847] encapsulation of the PKIMessage (or simply the PKIBody (omitting the CHOICE tag), if the relevant PKIHeader information is securely carried in the external mechanism). It is noted, however, that many such external mechanisms require that the end entity already possesses a public-key certificate, a unique DN, and/or other such infrastructure-related information. Thus, they may not be appropriate for initial registration, key-recovery, or any other process with \"bootstrapping\" characteristics. For those cases, it may be necessary that the PKIProtection parameter be used. In the future, if/when external mechanisms are modified to accommodate bootstrapping scenarios, the use of PKIProtection may become rare or non-existent.",
      "ja": "PKIXの外部である他の保護が代わりに適用されるため、メッセージを保護するためにPKIPROTECTION BIT文字列が意図的に使用されない場合があります（つまり、このオプションフィールドは省略されます）。このような選択は、この仕様で明示的に許可されています。このような外部保護の例には、関連するpkiheader情報が外部メカニズムで安全に運ばれる場合、CMS [RFC5652]およびセキュリティマルチパート[RFC1847]のカプセル化（または単にpkibody（選択タグを省略））のカプセル化が含まれます。ただし、そのような外部メカニズムの多くは、最終エンティティがすでに公開キー証明書、一意のDN、および/またはその他のインフラストラクチャ関連情報を所有していることを要求していることに注意してください。したがって、最初の登録、キー回復、または「ブートストラップ」特性を備えたその他のプロセスには適していない場合があります。これらの場合には、pkiprotectionパラメーターを使用する必要がある場合があります。将来的には、ブートストラップシナリオに対応するために外部メカニズムが変更された場合、PKIPROTECTIONの使用はまれまたは存在しない場合があります。"
    },
    {
      "indent": 3,
      "text": "Depending on the circumstances, the PKIProtection bits may contain a MAC or signature. Only the following cases can occur:",
      "ja": "状況に応じて、PKIPROTECTIONビットにはMACまたは署名が含まれる場合があります。次のケースのみが発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.1.3.1. Shared Secret Information",
      "section_title": true,
      "ja": "5.1.3.1. 共有秘密情報"
    },
    {
      "indent": 3,
      "text": "In this case, the sender and recipient share secret information with sufficient entropy (established via out-of-band means). PKIProtection will contain a MAC value, and the protectionAlg MAY be one of the options described in Section 6.1 of CMP Algorithms [RFC9481].",
      "ja": "この場合、送信者と受信者は、十分なエントロピー（帯域外の手段を介して確立された）で秘密情報を共有します。PKIPROTECTIONにはMAC値が含まれ、保護物はCMPアルゴリズム[RFC9481]のセクション6.1で説明されているオプションの1つである可能性があります。"
    },
    {
      "indent": 3,
      "text": "The algorithm identifier id-PasswordBasedMac is defined in Section 4.4 of [RFC4211] and updated by [RFC9045]. It is mentioned in Section 6.1.1 of [RFC9481] for backward compatibility. More modern alternatives are listed in Section 6.1 of [RFC9481].",
      "ja": "アルゴリズム識別子ID-PassWordBasedMacは、[RFC4211]のセクション4.4で定義され、[RFC9045]によって更新されます。後方互換性については、[RFC9481]のセクション6.1.1で言及されています。[RFC9481]のセクション6.1に、より近代的な代替品がリストされています。"
    },
    {
      "indent": 5,
      "text": "id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}\nPBMParameter ::= SEQUENCE {\n   salt                OCTET STRING,\n   owf                 AlgorithmIdentifier,\n   iterationCount      INTEGER,\n   mac                 AlgorithmIdentifier\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following text gives a method of key expansion to be used when the MAC algorithm requires an input length that is larger than the size of the one-way function (OWF).",
      "ja": "次のテキストは、MACアルゴリズムが一方向関数（OWF）のサイズよりも大きい入力長を必要とする場合に使用する重要な拡張の方法を示します。"
    },
    {
      "indent": 3,
      "text": "Note: Section 4.4 of [RFC4211] and [RFC9045] do not mention this key expansion method or give an example using HMAC algorithms where key expansion is not needed. It is recognized that this omission in [RFC4211] can lead to confusion and possible incompatibility if key expansion [RFC4210] is not used when needed. Therefore, when key expansion is required (when K > H), the key expansion defined in the following text MUST be used.",
      "ja": "注：[RFC4211]および[RFC9045のセクション4.4]は、この重要な拡張方法に言及したり、キー拡張が不要なHMACアルゴリズムを使用して例を挙げたりしません。[RFC4211]でのこの省略は、必要に応じて主要な拡張[RFC4210]が使用されない場合、混乱と非互換性につながる可能性があることが認識されています。したがって、キー拡張が必要な場合（K> Hの場合）、次のテキストで定義されているキー拡張を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the above protectionAlg, the salt value is appended to the shared secret input. The OWF is then applied iterationCount times, where the salted secret is the input to the first iteration and, for each successive iteration, the input is set to be the output of the previous iteration. The output of the final iteration (called \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used to form the symmetric key. If the MAC algorithm requires a K-bit key and K <= H, then the most significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is used for the most significant H bits of the key, OWF(\"1\" || BASEKEY) is used for the next most significant H bits of the key, OWF(\"2\" || BASEKEY) is used for the next most significant H bits of the key, and so on, until all K bits have been derived. [Here \"N\" is the ASCII byte encoding the number N and \"||\" represents concatenation.]",
      "ja": "上記の保護では、塩値は共有秘密の入力に追加されます。その後、OWFは反復時間を適用します。ここで、塩漬けの秘密は最初の反復への入力であり、連続する各反復に対して、入力は前の反復の出力に設定されます。最終的な反復の出力（参照を容易にするための「basekey」と呼ばれ、「H」のサイズのサイズ）は、対称キーを形成するために使用されるものです。MacアルゴリズムにKビットキーとk <= hが必要な場合、ベースキーの最も重要なKビットが使用されます。k> hの場合、すべてのBaseKeyがキーの最も重要なHビットに使用される場合、OWF（ \"1\" || baseKey）がキーの次の重要なHビットに使用されます。OWF（ \"2\" || basekey）は、すべてのKビットが導出されるまで次の最も重要なHビットなどに使用されます。[ここでは、 \"n\"はnと「||」をエンコードするASCIIバイトです。連結を表します。]"
    },
    {
      "indent": 3,
      "text": "Note: It is RECOMMENDED that the fields of PBMParameter remain constant throughout the messages of a single transaction (e.g., ir/ip/certConf/pkiConf) to reduce the overhead associated with PasswordBasedMac computation.",
      "ja": "注：PBMParameterのフィールドは、パスワードベースMAC計算に関連するオーバーヘッドを減らすために、単一のトランザクション（例：IR/IP/CERTCONF/PKICONF）のメッセージ全体で一定のままでいることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5.1.3.2. DH Key Pairs",
      "section_title": true,
      "ja": "5.1.3.2. DHキーペア"
    },
    {
      "indent": 3,
      "text": "Where the sender and receiver possess finite-field or elliptic-curve-based DH certificates with compatible DH parameters in order to protect the message, the end entity must generate a symmetric key based on its private DH key value and the DH public key of the recipient of the PKI message. PKIProtection will contain a MAC value keyed with this derived symmetric key, and the protectionAlg will be the following:",
      "ja": "送信者とレシーバーが、互換性のあるDHパラメーターを備えた有限フィールドまたは楕円曲線ベースのDH証明書をメッセージを保護するために持っている場合、最終エンティティは、プライベートDHキー値とPKIメッセージの受信者のDH公開キーに基づいて対称キーを生成する必要があります。PKIPROTECTIONには、この派生した対称キーでキー付きMAC値が含まれ、保護は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}\n\nDHBMParameter ::= SEQUENCE {\n   owf                 AlgorithmIdentifier,\n   -- AlgId for an OWF\n   mac                 AlgorithmIdentifier\n   -- the MAC AlgId\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the above protectionAlg, OWF is applied to the result of the DH computation. The OWF output (called \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used to form the symmetric key. If the MAC algorithm requires a K-bit key and K <= H, then the most significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is used for the most significant H bits of the key, OWF(\"1\" || BASEKEY) is used for the next most significant H bits of the key, OWF(\"2\" || BASEKEY) is used for the next most significant H bits of the key, and so on, until all K bits have been derived. [Here \"N\" is the ASCII byte encoding the number N and \"||\" represents concatenation.]",
      "ja": "上記の保護物では、OWFがDH計算の結果に適用されます。OWF出力（「H」のサイズを備えた参照のための「ベースキー」と呼ばれる）は、対称キーを形成するために使用されるものです。MacアルゴリズムにKビットキーとk <= hが必要な場合、ベースキーの最も重要なKビットが使用されます。k> hの場合、すべてのBaseKeyがキーの最も重要なHビットに使用される場合、OWF（ \"1\" || baseKey）がキーの次の重要なHビットに使用されます。OWF（ \"2\" || basekey）は、すべてのKビットが導出されるまで次の最も重要なHビットなどに使用されます。[ここでは、 \"n\"はnと「||」をエンコードするASCIIバイトです。連結を表します。]"
    },
    {
      "indent": 3,
      "text": "Note: Hash algorithms that can be used as OWFs are listed in Section 2 of CMP Algorithms [RFC9481].",
      "ja": "注：OWFとして使用できるハッシュアルゴリズムは、CMPアルゴリズム[RFC9481]のセクション2にリストされています。"
    },
    {
      "indent": 0,
      "text": "5.1.3.3. Signature",
      "section_title": true,
      "ja": "5.1.3.3. サイン"
    },
    {
      "indent": 3,
      "text": "In this case, the sender possesses a signature key pair and simply signs the PKI message. PKIProtection will contain the signature value and the protectionAlg will be an AlgorithmIdentifier for a digital signature, which MAY be one of the options described in Section 3 of CMP Algorithms [RFC9481].",
      "ja": "この場合、送信者は署名キーペアを所有し、PKIメッセージに単純に署名します。PKIPROTECTIONには署名値が含まれ、PrittionalGはデジタル署名のアルゴリズムのIndidifierになります。これは、CMPアルゴリズム[RFC9481]のセクション3で説明されているオプションの1つである可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.1.3.4. Key Encapsulation",
      "section_title": true,
      "ja": "5.1.3.4. キーカプセル化"
    },
    {
      "indent": 3,
      "text": "In case the sender of a message has a KEM key pair, it can be used to establish a shared secret key for MAC-based message protection. This can be used for message authentication.",
      "ja": "メッセージの送信者がKEMキーペアを持っている場合、Macベースのメッセージ保護の共有シークレットキーを確立するために使用できます。これは、メッセージ認証に使用できます。"
    },
    {
      "indent": 3,
      "text": "This approach uses the definition of KEM algorithm functions in Section 1 of [RFC9629] as follows:",
      "ja": "このアプローチでは、次のように[RFC9629]のセクション1のKEMアルゴリズム関数の定義を使用します。"
    },
    {
      "indent": 3,
      "text": "A KEM algorithm provides three functions:",
      "ja": "KEMアルゴリズムは3つの関数を提供します。"
    },
    {
      "indent": 8,
      "text": "1. KeyGen() -> (pk, sk): Generate a public key (pk) and a private (secret) key (sk).",
      "ja": "1. keygen（） - >（PK、SK）：公開キー（PK）とプライベート（秘密）キー（SK）を生成します。"
    },
    {
      "indent": 8,
      "text": "2. Encapsulate(pk) -> (ct, ss): Given the public key (pk), produce a ciphertext (ct) and a shared secret (ss).",
      "ja": "2. cancapsulate（pk） - >（ct、ss）：公開鍵（PK）が与えられた場合、暗号文（CT）と共有秘密（SS）を生成します。"
    },
    {
      "indent": 8,
      "text": "3. Decapsulate(sk, ct) -> (ss): Given the private key (sk) and the ciphertext (ct), produce the shared secret (ss).",
      "ja": "3. Decapsulate（SK、CT） - >（SS）：秘密鍵（SK）と暗号文（CT）を与えられた場合、共有秘密（SS）を生成します。"
    },
    {
      "indent": 3,
      "text": "To support a particular KEM algorithm, the PKI entity that possesses a KEM key pair and wishes to use it for MAC-based message protection MUST support the KEM Decapsulate() function. The PKI entity that wishes to verify the MAC-based message protection MUST support the KEM Encapsulate() function. The respective public KEM key is usually carried in a certificate [ML-KEM].",
      "ja": "特定のKEMアルゴリズムをサポートするには、KEMキーペアを所有し、MACベースのメッセージ保護に使用したいPKIエンティティは、KEM Decapsulate（）関数をサポートする必要があります。Macベースのメッセージ保護を確認したいPKIエンティティは、KEM cankapsulate（）関数をサポートする必要があります。それぞれの公開KEMキーは通常、証明書[ML-KEM]に携帯されています。"
    },
    {
      "indent": 3,
      "text": "Note: Both PKI entities send and receive messages in a PKI management operation. Both PKI entities may independently wish to protect messages using their KEM key pairs. For ease of explanation, we use the terms \"Alice\" to denote the PKI entity possessing the KEM key pair and who wishes to provide MAC-based message protection and \"Bob\" to denote the PKI entity having Alice's authentic public KEM key and who needs to verify the MAC-based protection provided by Alice.",
      "ja": "注：両方のPKIエンティティは、PKI管理操作でメッセージを送信および受信します。両方のPKIエンティティは、KEMキーペアを使用してメッセージを独立して保護したい場合があります。説明のために、「アリス」という用語を使用して、KEMキーペアを所有するPKIエンティティを示し、Macベースのメッセージ保護と「ボブ」を提供して、Aliceの本物の公開KEMキーを有するPKIエンティティを示し、Aliceが提供するMacベースの保護を検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Assuming Bob has Alice's KEM public key, he generates the ciphertext using KEM encapsulation and transfers it to Alice in an InfoTypeAndValue structure. Alice then retrieves the KEM shared secret from the ciphertext using KEM decapsulation and the associated KEM private key. Using a key derivation function (KDF), Alice derives a shared secret key from the KEM shared secret and other data sent by Bob. PKIProtection will contain a MAC value calculated using that shared secret key, and the protectionAlg will be the following:",
      "ja": "ボブにアリスのKEMの公開鍵があると仮定すると、彼はKEMカプセル化を使用して暗号文を生成し、インフォタイプと値の構造でアリスに転送します。その後、アリスは、KEMの脱カプセル化と関連するKEM秘密鍵を使用して、暗号文からKEM共有秘密を回収します。キー派生関数（KDF）を使用して、アリスは、KEM共有秘密とボブが送信したその他のデータから共有された秘密の鍵を導き出します。pkiprotectionには、その共有秘密の鍵を使用して計算されたMAC値が含まれ、保護は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "id-KemBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 16}\n\nKemBMParameter ::= SEQUENCE {\n  kdf              AlgorithmIdentifier{KEY-DERIVATION, {...}},\n  kemContext   [0] OCTET STRING OPTIONAL,\n  len              INTEGER (1..MAX),\n  mac              AlgorithmIdentifier{MAC-ALGORITHM, {...}}\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: The OID for id-KemBasedMac was assigned on the private-use arc { iso(1) member-body(2) us(840) nortelnetworks(113533) entrust(7) } and not assigned on an IANA-owned arc because the authors wished to place it on the same branch as the existing OIDs for id-PasswordBasedMac and id-DHBasedMac.",
      "ja": "注：ID-KembasedMacのOIDは、個人用アークに割り当てられました{ISO（1）メンバーボディ（2）US（840）nortelnetworks（113533）は（113533）委任状（7）}を委任し、著者がIDの既存のoidmacのために既存のoidmacのためにIDパスのために既存のoidmacのために既存のoidmacのために同じブランチに配置することを望んでいたため、IANAが所有するアークに割り当てられていません。"
    },
    {
      "indent": 3,
      "text": "kdf is the algorithm identifier of the chosen KDF, and any associated parameters, used to derive the shared secret key.",
      "ja": "KDFは、選択されたKDFのアルゴリズム識別子であり、共有シークレットキーを導出するために使用される関連パラメーターです。"
    },
    {
      "indent": 3,
      "text": "kemContext MAY be used to transfer additional algorithm-specific context information (see also the definition of ukm in Section 3 of [RFC9629]).",
      "ja": "KemContextは、追加のアルゴリズム固有のコンテキスト情報を転送するために使用できます（[RFC9629]のセクション3のUKMの定義も参照）。"
    },
    {
      "indent": 3,
      "text": "len is the output length of the KDF and MUST be the desired size of the key to be used for MAC-based message protection.",
      "ja": "LENはKDFの出力長であり、Macベースのメッセージ保護に使用するキーの望ましいサイズでなければなりません。"
    },
    {
      "indent": 3,
      "text": "mac is the algorithm identifier of the chosen MAC algorithm, and any associated parameters, used to calculate the MAC value.",
      "ja": "Macは、選択したMacアルゴリズムのアルゴリズム識別子であり、Mac値の計算に使用される関連するパラメーターです。"
    },
    {
      "indent": 3,
      "text": "The KDF and MAC algorithms MAY be chosen from the options in CMP Algorithms [RFC9481].",
      "ja": "KDFおよびMACアルゴリズムは、CMPアルゴリズム[RFC9481]のオプションから選択できます。"
    },
    {
      "indent": 3,
      "text": "The InfoTypeAndValue transferring the KEM ciphertext uses OID id-it-KemCiphertextInfo. It contains a KemCiphertextInfo structure, as defined in Section 5.3.19.18.",
      "ja": "KEM Ciphertextを転送するInfotypeandValueは、OID ID-IT-KEMCIPHERTEXTINFOを使用します。セクション5.3.19.18で定義されているように、Kemciphertextinfo構造が含まれています。"
    },
    {
      "indent": 3,
      "text": "Note: This InfoTypeAndValue can be carried in a genm/genp message body, as specified in Section 5.3.19.18, or in the generalInfo field of PKIHeader in messages of other types (see Section 5.1.1.5).",
      "ja": "注：このinfotypeandValueは、セクション5.3.19.18で指定されているように、他のタイプのメッセージでpkiheaderのgeneralInfoフィールドで指定されているように、Genm/genpメッセージ本文で運ぶことができます（セクション5.1.1.5を参照）。"
    },
    {
      "indent": 3,
      "text": "In the following, a generic message flow for MAC-based protection using KEM is specified in more detail. It is assumed that Bob possesses Alice's public KEM key. Alice can be the initiator of a PKI management operation or the responder. For more detailed figures, see Appendix E.",
      "ja": "以下では、KEMを使用したMACベースの保護の汎用メッセージフローが詳細に指定されています。ボブはアリスの公開Kemキーを所有していると想定されています。アリスは、PKI管理操作またはレスポンダーのイニシエーターになることができます。より詳細な図については、付録Eを参照してください。"
    },
    {
      "indent": 3,
      "text": "Generic Message Flow:",
      "ja": "一般的なメッセージフロー："
    },
    {
      "indent": 3,
      "text": "Step# Alice                                Bob\n---------------------------------------------------------------------\n  1                                        perform KEM Encapsulate\n                      <-- KEM Ciphertext <--\n  2   perform KEM Decapsulate,\n        perform key derivation,\n        format message with\n        MAC-based protection\n                      -->    message     -->\n  3                                        perform key derivation,\n                                             verify MAC-based\n                                             protection\n-------------------  Alice authenticated by Bob  --------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 2: Generic Message Flow When Alice Has a KEM Key Pair",
      "ja": "図2：アリスがKEMキーペアを持っているときの一般的なメッセージフロー"
    },
    {
      "indent": 8,
      "text": "1. Bob needs to possess Alice's authentic public KEM key (pk), for instance, contained in a KEM certificate that was received and successfully validated by Bob beforehand.",
      "ja": "1. たとえば、ボブは、Aliceの本物の公開KEMキー（PK）を所有している必要があります。たとえば、BOBが事前に受け取って正常に検証したKEM証明書に含まれています。"
    },
    {
      "indent": 12,
      "text": "Bob generates a shared secret (ss) and the associated ciphertext (ct) using the KEM Encapsulate function with Alice's public KEM key (pk). Bob MUST NOT reuse the ss and ct for other PKI management operations. From this data, Bob produces a KemCiphertextInfo structure, including the KEM algorithm identifier and the ciphertext (ct) and sends it to Alice in an InfoTypeAndValue structure, as defined in Section 5.3.19.18.",
      "ja": "Bob generates a shared secret (ss) and the associated ciphertext (ct) using the KEM Encapsulate function with Alice's public KEM key (pk).Bob MUST NOT reuse the ss and ct for other PKI management operations.このデータから、BobはKEMCIPHERTEXTINFO構造を生成し、KEMアルゴリズム識別子とciphertext（CT）を含み、セクション5.3.19.18で定義されているように、InfotypeandValue構造でアリスに送信します。"
    },
    {
      "indent": 12,
      "text": " Encapsulate(pk) -> (ct, ss)",
      "ja": "cancapsulate（pk） - >（ct、ss）"
    },
    {
      "indent": 8,
      "text": "2. Alice decapsulates the shared secret (ss) from the ciphertext (ct) using the KEM Decapsulate function and its private KEM key (sk).",
      "ja": "2. アリスは、KEM脱カプセル化関数とそのプライベートKEMキー（SK）を使用して、暗号文（CT）から共有秘密（SS）を脱カプセル化します。"
    },
    {
      "indent": 12,
      "text": " Decapsulate(ct, sk) -> (ss)",
      "ja": "Decapsulate（CT、SK） - >（SS）"
    },
    {
      "indent": 12,
      "text": "If the decapsulation operation outputs an error, any failInfo field in an error response message SHALL contain the value badMessageCheck and the PKI management operation SHALL be terminated.",
      "ja": "カプセル化操作がエラーを出力する場合、エラー応答メッセージの故障フィールドには値が含まれ、PKI管理操作が終了するものとします。"
    },
    {
      "indent": 12,
      "text": "Alice derives the shared secret key (ssk) using a KDF. The shared secret (ss) is used as input key material for the KDF, and the value len is the desired output length of the KDF as required by the MAC algorithm to be used for message protection. KDF, len, and MAC will be transferred to Bob in the protectionAlg KemBMParameter. The DER-encoded KemOtherInfo structure, as defined below, is used as context for the KDF.",
      "ja": "アリスは、KDFを使用して共有シークレットキー（SSK）を導き出します。Shared Secret（SS）はKDFの入力キー資料として使用され、値lenはメッセージ保護に使用されるMACアルゴリズムで必要とされるKDFの望ましい出力長です。KDF、LEN、およびMACは、Protectiong KembmparameterでBoBに転送されます。以下に定義するDer-Encoded Kemotherinfo構造は、KDFのコンテキストとして使用されます。"
    },
    {
      "indent": 12,
      "text": " KDF(ss, len, context)->(ssk)",
      "ja": "kdf（ss、len、context） - >（ssk）"
    },
    {
      "indent": 12,
      "text": "The shared secret key (ssk) is used for MAC-based protection by Alice.",
      "ja": "共有シークレットキー（SSK）は、アリスによるMacベースの保護に使用されます。"
    },
    {
      "indent": 8,
      "text": "3. Bob derives the same shared secret key (ssk) using the KDF. Also here, the shared secret (ss) is used as input key material for the KDF, the value len is the desired output length for the KDF, and the DER-encoded KemOtherInfo structure constructed in the same way as on Alice's side is used as context for the KDF.",
      "ja": "3. ボブは、KDFを使用して同じ共有シークレットキー（SSK）を導き出します。また、ここでは、共有秘密（SS）はKDFの入力キー材料として使用され、値lenはKDFの希望の出力長であり、アリス側と同じ方法で構築されたderエンコードされたkemotherinfo構造がKDFのコンテキストとして使用されます。"
    },
    {
      "indent": 12,
      "text": " KDF(ss, len, context)->(ssk)",
      "ja": "kdf（ss、len、context） - >（ssk）"
    },
    {
      "indent": 12,
      "text": "Bob uses the shared secret key (ssk) for verifying the MAC-based protection of the message received and in this way authenticates Alice.",
      "ja": "ボブは、共有Secret Key（SSK）を使用して、受信したメッセージのMacベースの保護を確認し、このようにアリスを認証します。"
    },
    {
      "indent": 3,
      "text": "This shared secret key (ssk) can be reused by Alice for MAC-based protection of further messages sent to Bob within the current PKI management operation.",
      "ja": "この共有シークレットキー（SSK）は、現在のPKI管理操作内でBOBに送信されたさらなるメッセージのMACベースの保護のために、Aliceが再利用できます。"
    },
    {
      "indent": 3,
      "text": "This approach employs the notation of KDF(IKM, L, info) as described in Section 5 of [RFC9629] with the following changes:",
      "ja": "このアプローチは、[RFC9629]のセクション5で説明されているように、KDF（IKM、L、情報）の表記を採用しています。"
    },
    {
      "indent": 6,
      "text": "* IKM is the input key material. It is the symmetric secret called \"ss\" resulting from the KEM.",
      "ja": "* IKMは入力キー資料です。これは、KEMから生じる「SS」と呼ばれる対称的な秘密です。"
    },
    {
      "indent": 6,
      "text": "* L is dependent of the MAC algorithm that is used with the shared secret key for CMP message protection and is called \"len\" in this document.",
      "ja": "* Lは、CMPメッセージ保護の共有シークレットキーで使用され、このドキュメントでは「len」と呼ばれるMacアルゴリズムに依存します。"
    },
    {
      "indent": 6,
      "text": "* info is an additional input to the KDF, is called \"context\" in this document, and contains the DER-encoded KemOtherInfo structure defined as:",
      "ja": "* 情報はKDFへの追加の入力であり、このドキュメントの「コンテキスト」と呼ばれ、次のように定義されたderエンコードされたkemothorinfo構造が含まれています。"
    },
    {
      "indent": 5,
      "text": "KemOtherInfo ::= SEQUENCE {\n  staticString      PKIFreeText,\n  transactionID     OCTET STRING,\n  kemContext    [0] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "staticString MUST be \"CMP-KEM\".",
      "ja": "スタチックストリングは「CMP-KEM」でなければなりません。"
    },
    {
      "indent": 10,
      "text": "transactionID MUST be the value from the message containing the ciphertext (ct) in KemCiphertextInfo.",
      "ja": "TransactionIDは、kemciphertextinfoのciphertext（ct）を含むメッセージからの値である必要があります。"
    },
    {
      "indent": 10,
      "text": "Note: The transactionID is used to ensure domain separation of the derived shared secret key between different PKI management operations. For all PKI management operations with more than one exchange, the transactionID MUST be set anyway (see Section 5.1.1). In case Bob provided an infoValue of type KemCiphertextInfo to Alice in the initial request message (see Figure 4 of Appendix E), the transactionID MUST be set by Bob.",
      "ja": "注：TransactionIDは、異なるPKI管理操作間で派生した共有シークレットキーのドメイン分離を確保するために使用されます。複数のExchangeを使用したすべてのPKI管理操作については、とにかくTransactionIDを設定する必要があります（セクション5.1.1を参照）。ボブが最初のリクエストメッセージでkemciphertextinfoのタイプの情報値をアリスに提供した場合（付録Eの図4を参照）、トランザクションIDはBOBによって設定する必要があります。"
    },
    {
      "indent": 10,
      "text": "kemContext MAY contain additional algorithm-specific context information.",
      "ja": "KemContextには、追加のアルゴリズム固有のコンテキスト情報が含まれる場合があります。"
    },
    {
      "indent": 6,
      "text": "* OKM is the output keying material of the KDF used for MAC-based message protection of length len and is called \"ssk\" in this document.",
      "ja": "* OKMは、長さLENのMacベースのメッセージ保護に使用されるKDFの出力キーイング材料であり、このドキュメントでは「SSK」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "There are various ways that Alice can request and Bob can provide the KEM ciphertext (see Appendix E for details). The KemCiphertextInfo can be requested using PKI general messages, as described in Section 5.3.19.18. Alternatively, the generalInfo field of the PKIHeader can be used to convey the same request and response InfoTypeAndValue structures, as described in Section 5.1.1.5. The procedure also works without Alice explicitly requesting the KEM ciphertext in case Bob knows one of Alice's KEM keys beforehand and can expect that she is ready to use it.",
      "ja": "アリスが要求し、ボブがKEM Ciphertextを提供できるさまざまな方法があります（詳細については、付録Eを参照）。セクション5.3.19.18で説明されているように、KemciphertextinfoはPKI一般メッセージを使用して要求できます。あるいは、PKIHEADERの一般的なフィールドを使用して、セクション5.1.1.5で説明されているように、同じ要求と応答のインフォマチーアンド値構造を伝えることができます。また、この手順は、アリスのKemキーの1つを事前に知っており、彼女がそれを使用する準備ができていることを期待できる場合に備えて、AliceがKem Ciphertextを明示的に要求せずに機能しません。"
    },
    {
      "indent": 3,
      "text": "If both the initiator and responder in a PKI management operation have KEM key pairs, this procedure can be applied by both entities independently, establishing and using different shared secret keys for either direction.",
      "ja": "PKI管理操作のイニシエーターとレスポンダーの両方がKEMキーペアを持っている場合、この手順は両方のエンティティによって独立して適用され、どちらの方向にも異なる共有シークレットキーを確立および使用できます。"
    },
    {
      "indent": 0,
      "text": "5.1.3.5. Multiple Protection",
      "section_title": true,
      "ja": "5.1.3.5. 複数の保護"
    },
    {
      "indent": 3,
      "text": "When receiving a protected PKI message, a PKI management entity, such as an RA, MAY forward that message adding its own protection. Additionally, multiple PKI messages MAY be aggregated. There are several use cases for such messages.",
      "ja": "保護されたPKIメッセージを受信すると、RAなどのPKI管理エンティティは、独自の保護を追加するメッセージを転送する場合があります。さらに、複数のPKIメッセージが集約される場合があります。そのようなメッセージにはいくつかのユースケースがあります。"
    },
    {
      "indent": 6,
      "text": "* The RA confirms having validated and authorized a message and forwards the original message unchanged.",
      "ja": "* RAは、メッセージを検証および承認したことを確認し、元のメッセージを変更せずに転送します。"
    },
    {
      "indent": 6,
      "text": "* A PKI management entity collects several messages that are to be forwarded in the same direction and forwards them in a batch. Request messages can be transferred as a batch upstream (towards the CA); response or announce messages can be transferred as a batch downstream (towards an RA but not to the end entity). For instance, this can be used when bridging an offline connection between two PKI management entities.",
      "ja": "* PKI管理エンティティは、同じ方向に転送されるメッセージを収集し、それらをバッチに転送します。リクエストメッセージは、上流のバッチとして（CAに向かって）転送できます。応答またはアナウンスメッセージは、下流のバッチとして転送できます（RAに向かって、最終エンティティではありません）。たとえば、これは、2つのPKI管理エンティティ間のオフライン接続を橋渡しするときに使用できます。"
    },
    {
      "indent": 3,
      "text": "These use cases are accomplished by nesting the messages within a new PKI message. The structure used is as follows:",
      "ja": "これらのユースケースは、新しいPKIメッセージ内でメッセージをネストすることによって達成されます。使用される構造は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "NestedMessageContent ::= PKIMessages",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In case an RA needs to modify a request message, it MAY include the original PKIMessage in the generalInfo field of the modified message, as described in Section 5.1.1.3.",
      "ja": "RAがリクエストメッセージを変更する必要がある場合、セクション5.1.1.3で説明されているように、変更されたメッセージの一般的なフィールドに元のpkimessageを含めることができます。"
    },
    {
      "indent": 0,
      "text": "5.2. Common Data Structures",
      "section_title": true,
      "ja": "5.2. 一般的なデータ構造"
    },
    {
      "indent": 3,
      "text": "Before specifying the specific types that may be placed in a PKIBody, we define some data structures that are used in more than one case.",
      "ja": "pkibodyに配置される可能性のある特定のタイプを指定する前に、複数のケースで使用されるいくつかのデータ構造を定義します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Requested Certificate Contents",
      "section_title": true,
      "ja": "5.2.1. 要求された証明書の内容"
    },
    {
      "indent": 3,
      "text": "Various PKI management messages require that the originator of the message indicate some of the fields that are required to be present in a certificate. The CertTemplate structure allows entities requesting a certificate to specify the data fields that they want to be included. Typically, they are required to provide at least the publicKey field. A CertTemplate structure is identical to a TBSCertificate structure (see [RFC5280]) but with all fields optional/situational.",
      "ja": "さまざまなPKI管理メッセージには、メッセージの発信者が証明書に存在する必要があるフィールドの一部を示す必要があります。CERTTEMPLATE構造により、証明書を要求するエンティティが含まれているデータフィールドを指定することができます。通常、少なくともパブリックキーフィールドを提供する必要があります。証明書構造は、TBSCertificate構造と同一です（[RFC5280]を参照）が、すべてのフィールドがオプション/状況に伴います。"
    },
    {
      "indent": 3,
      "text": "Note: Even if the originator completely specifies the contents of a certificate it requires, a CA is free to modify fields within the certificate actually issued. If the modified certificate is unacceptable to the requester, the requester MUST send back a certConf message that either does not include this certificate (via a CertHash) or does include this certificate (via a CertHash) along with a status of \"rejected\". See Section 5.3.18 for the definition and use of CertHash and the certConf message.",
      "ja": "注：発信者が必要な証明書の内容を完全に指定したとしても、CAは実際に発行された証明書内のフィールドを自由に変更できます。修正された証明書が要求者に受け入れられない場合、リクエスターは、この証明書を（Certhashを介して）含めないか、この証明書（Certhashを介して）を「拒否」のステータスとともに含める証明書を送信する必要があります。CerthashおよびCertConfメッセージの定義と使用については、セクション5.3.18を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note: Before requesting a new certificate, an end entity can request a certTemplate structure as a kind of certificate request blueprint in order to learn which data the CA expects to be present in the certificate request (see Section 5.3.19.16).",
      "ja": "注：新しい証明書を要求する前に、End Entityは、CAが証明書リクエストに存在すると予想されるデータを学習するために、証明書リクエストの青写真の一種としてCertTemplate構造を要求できます（セクション5.3.19.16を参照）。"
    },
    {
      "indent": 3,
      "text": "See CRMF [RFC4211] for CertTemplate syntax.",
      "ja": "CERTTEMPLATE構文については、CRMF [RFC4211]を参照してください。"
    },
    {
      "indent": 3,
      "text": "If certTemplate is an empty SEQUENCE (i.e., all fields omitted), then the controls field in the CertRequest structure MAY contain the id-regCtrl-altCertTemplate control, specifying a template for a certificate other than an X.509v3 public-key certificate. Conversely, if certTemplate is not empty (i.e., at least one field is present), then controls MUST NOT contain id-regCtrl-altCertTemplate. The new control is defined as follows:",
      "ja": "CertTemplateが空のシーケンス（つまり、すべてのフィールドが省略されている）である場合、certrequest構造のコントロールフィールドには、x.509v3パブリックキー証明書以外の証明書のテンプレートを指定して、id-regctrl-altcerttemplateコントロールを含める場合があります。逆に、certtemplateが空でない場合（つまり、少なくとも1つのフィールドが存在する）、コントロールにはID-regctrl-altcerttemplateを含めてはなりません。新しいコントロールは次のように定義されています。"
    },
    {
      "indent": 5,
      "text": "id-regCtrl-altCertTemplate OBJECT IDENTIFIER ::= { iso(1)\n   identified-organization(3) dod(6) internet(1) security(5)\n   mechanisms(5) pkix(7) pkip(5) regCtrl(1) 7}\n\nAltCertTemplate ::= AttributeTypeAndValue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Also see [RFC4212] for more details on how to manage certificates in alternative formats using CRMF [RFC4211] syntax.",
      "ja": "また、CRMF [RFC4211]構文を使用して、代替形式で証明書を管理する方法の詳細については、[RFC4212]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Encrypted Values",
      "section_title": true,
      "ja": "5.2.2. 暗号化された値"
    },
    {
      "indent": 3,
      "text": "When encrypted data like a private key, certificate, POP challenge, or revocation passphrase is sent in PKI messages, it is RECOMMENDED to use the EnvelopedData structure. In some cases, this is accomplished by using the EncryptedKey data structure instead of EncryptedValue.",
      "ja": "秘密鍵、証明書、ポップチャレンジ、または撤回パスフレーズなどの暗号化されたデータがPKIメッセージで送信される場合、EnvelopedData構造を使用することをお勧めします。場合によっては、これは、暗号化されたValueの代わりに暗号化されたデータ構造を使用することによって実現されます。"
    },
    {
      "indent": 5,
      "text": "EncryptedKey ::= CHOICE {\n   encryptedValue       EncryptedValue, -- deprecated\n   envelopedData    [0] EnvelopedData }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "See Certificate Request Message Format (CRMF) [RFC4211] for EncryptedKey and EncryptedValue syntax and Cryptographic Message Syntax (CMS) [RFC5652] for EnvelopedData syntax. Using the EncryptedKey data structure offers the choice to either use EncryptedValue (for backward compatibility only) or EnvelopedData. The use of the EncryptedValue structure has been deprecated in favor of the EnvelopedData structure. Therefore, it is RECOMMENDED to use EnvelopedData.",
      "ja": "EnvelopedData Syntaxについては、証明書要求メッセージフォーマット（CRMF）[RFC4211]を参照してください。暗号化されたKeyデータ構造を使用すると、暗号化されたValue（後方互換のみ）またはEnvelopedDataを使用する選択を提供します。暗号化されたバリュー構造の使用は、封筒構造を支持して非推奨されています。したがって、EnvelopedDataを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Note: The EncryptedKey structure defined in CRMF [RFC4211] is used here, which makes the update backward compatible. Using the new syntax with the untagged default choice EncryptedValue is bits-on-the-wire compatible with the old syntax.",
      "ja": "注：CRMF [RFC4211]で定義されている暗号化されたキー構造はここで使用されているため、更新を後方に互換性のあるものにします。Untagged Default Choice EncryptedValueを使用して新しい構文を使用すると、古い構文と互換性があります。"
    },
    {
      "indent": 3,
      "text": "To indicate support for EnvelopedData, the pvno cmp2021 has been introduced. Details on the usage of the protocol version number are described in Section 7.",
      "ja": "EnvelopedDataのサポートを示すために、PVNO CMP2021が導入されました。プロトコルバージョン番号の使用に関する詳細については、セクション7で説明します。"
    },
    {
      "indent": 3,
      "text": "The EnvelopedData structure is RECOMMENDED to be used in CMP to transport a private key, certificate, POP challenge, or revocation passphrase in encrypted form as follows:",
      "ja": "EnvelopedData構造は、CMPで使用して、次のように暗号化された形式で秘密鍵、証明書、ポップチャレンジ、または取り消しパスフレーズを輸送することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "* It contains only one RecipientInfo structure because the content is encrypted only for one recipient.",
      "ja": "* コンテンツは1人の受信者に対してのみ暗号化されているため、1つのRecipientIntInfo構造が含まれています。"
    },
    {
      "indent": 6,
      "text": "* It may contain a private key in the AsymmetricKeyPackage structure (which is placed in the encryptedContentInfo field), as defined in [RFC5958], that is wrapped in a SignedData structure, as specified in Section 5 of [RFC5652] and [RFC8933], signed by the KGA or CA.",
      "ja": "* [RFC5958]で定義されているように、[RFC5652]および[RFC8933のセクション5で指定されているように、SignedData構造に包まれているように、非対称Keypackage構造（暗号化されたContentInfoフィールドに配置されている）の秘密鍵が含まれている場合があります。"
    },
    {
      "indent": 6,
      "text": "* It may contain a certificate, POP challenge, or revocation passphrase directly in the encryptedContent field.",
      "ja": "* 暗号化されたコンテンツフィールドに直接、証明書、ポップチャレンジ、または取り消しパスフレーズが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "The content of the EnvelopedData structure, as specified in Section 6 of [RFC5652], MUST be encrypted using a newly generated symmetric content-encryption key. This content-encryption key MUST be securely provided to the recipient using one of four key management techniques.",
      "ja": "[RFC5652]のセクション6で指定されているように、封筒構造の内容は、新しく生成された対称コンテンツ暗号化キーを使用して暗号化する必要があります。このコンテンツ暗号化キーは、4つの主要な管理手法のいずれかを使用して、受信者に安全に提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "The choice of the key management technique to be used by the sender depends on the credential available at the recipient:",
      "ja": "送信者が使用する重要な管理手法の選択は、受信者で利用可能な資格情報によって異なります。"
    },
    {
      "indent": 6,
      "text": "* recipient's certificate with an algorithm identifier and a public key that supports key transport and where any given key usage extension allows keyEncipherment: The content-encryption key will be protected using the key transport key management technique, as specified in Section 6.2.1 of [RFC5652].",
      "ja": "* アルゴリズムの識別子とキー輸送をサポートするアルゴリズムの証明書と、特定のキー使用拡張により、キーエンファイメントが許可される場合の公開キー：[RFC5652]のセクション6.2.1で指定されているキートランスポートキー管理手法を使用して、コンテンツ - 暗号化キーは保護されます。"
    },
    {
      "indent": 6,
      "text": "* recipient's certificate with an algorithm identifier and a public key that supports key agreement and where any given key usage extension allows keyAgreement: The content-encryption key will be protected using the key agreement key management technique, as specified in Section 6.2.2 of [RFC5652].",
      "ja": "* アルゴリズムの識別子とキー契約をサポートするアルゴリズムの証明書と、特定のキーの使用拡張によりキーアグメントが許可される公開キー：[RFC5652]のセクション6.2.2で指定されているキー契約キー管理手法を使用して、コンテンツ暗号化キーは保護されます。"
    },
    {
      "indent": 6,
      "text": "* a password or shared secret: The content-encryption key will be protected using the password-based key management technique, as specified in Section 6.2.4 of [RFC5652].",
      "ja": "* パスワードまたは共有秘密：[RFC5652]のセクション6.2.4で指定されているように、パスワードベースのキー管理手法を使用して、コンテンツ暗号化キーは保護されます。"
    },
    {
      "indent": 6,
      "text": "* recipient's certificate with an algorithm identifier and a public key that supports KEM and where any given key usage extension allows keyEncipherment: The content-encryption key will be protected using the key management technique for KEM keys, as specified in [RFC9629].",
      "ja": "* [RFC9629]で指定されているように、KEMのキー管理手法を使用して、Algorithm IdentifierとKEMをサポートし、特定のキー使用拡張機能をサポートする公開キーを使用したレシピエントの証明書と、特定のキーの使用拡張機能が可能な場合、コンテンツ - 結晶化キーは保護されます。"
    },
    {
      "indent": 3,
      "text": "Note: There are cases where the algorithm identifier, the type of the public key, and the key usage extension will not be sufficient to decide on the key management technique to use, e.g., when rsaEncryption is the algorithm identifier. In such cases, it is a matter of local policy to decide.",
      "ja": "注：アルゴリズム識別子、公開キーのタイプ、およびキーの使用法拡張機能が、たとえば、rsaencryptionがアルゴリズム識別子である場合に使用するキー管理手法を決定するのに十分ではない場合があります。そのような場合、決定するのは現地の方針の問題です。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Status Codes and Failure Information for PKI Messages",
      "section_title": true,
      "ja": "5.2.3. PKIメッセージのステータスコードと障害情報"
    },
    {
      "indent": 3,
      "text": "All response messages will include some status information. The following values are defined.",
      "ja": "すべての応答メッセージには、いくつかのステータス情報が含まれます。次の値が定義されています。"
    },
    {
      "indent": 5,
      "text": "PKIStatus ::= INTEGER {\n   accepted               (0),\n   grantedWithMods        (1),\n   rejection              (2),\n   waiting                (3),\n   revocationWarning      (4),\n   revocationNotification (5),\n   keyUpdateWarning       (6)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Responders may use the following syntax to provide more information about failure cases.",
      "ja": "レスポンダーは、次の構文を使用して、故障ケースに関する詳細情報を提供する場合があります。"
    },
    {
      "indent": 5,
      "text": "PKIFailureInfo ::= BIT STRING {\n   badAlg                 (0),\n   badMessageCheck        (1),\n   badRequest             (2),\n   badTime                (3),\n   badCertId              (4),\n   badDataFormat          (5),\n   wrongAuthority         (6),\n   incorrectData          (7),\n   missingTimeStamp       (8),\n   badPOP                 (9),\n   certRevoked            (10),\n   certConfirmed          (11),\n   wrongIntegrity         (12),\n   badRecipientNonce      (13),\n   timeNotAvailable       (14),\n   unacceptedPolicy       (15),\n   unacceptedExtension    (16),\n   addInfoNotAvailable    (17),\n   badSenderNonce         (18),\n   badCertTemplate        (19),\n   signerNotTrusted       (20),\n   transactionIdInUse     (21),\n   unsupportedVersion     (22),\n   notAuthorized          (23),\n   systemUnavail          (24),\n   systemFailure          (25),\n   duplicateCertReq       (26)\n}\n\nPKIStatusInfo ::= SEQUENCE {\n   status        PKIStatus,\n   statusString  PKIFreeText     OPTIONAL,\n   failInfo      PKIFailureInfo  OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2.4. Certificate Identification",
      "section_title": true,
      "ja": "5.2.4. 証明書識別"
    },
    {
      "indent": 3,
      "text": "In order to identify particular certificates, the CertId data structure is used.",
      "ja": "特定の証明書を特定するために、CertIDデータ構造が使用されます。"
    },
    {
      "indent": 3,
      "text": "See [RFC4211] for CertId syntax.",
      "ja": "CertID構文については[RFC4211]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.5. Out-of-Band Root CA Public Key",
      "section_title": true,
      "ja": "5.2.5. バンド外のルートCA公開キー"
    },
    {
      "indent": 3,
      "text": "Each root CA that provides a self-signed certificate must be able to publish its current public key via some \"out-of-band\" means or together with the respective link certificate using an online mechanism. While such mechanisms are beyond the scope of this document, we define data structures that can support such mechanisms.",
      "ja": "自己署名証明書を提供する各ルートCAは、オンラインメカニズムを使用して、いくつかの「帯域外」平均を介して、またはそれぞれのリンク証明書を使用して現在の公開キーを公開できる必要があります。このようなメカニズムはこのドキュメントの範囲を超えていますが、そのようなメカニズムをサポートできるデータ構造を定義します。"
    },
    {
      "indent": 3,
      "text": "There are generally two methods available: Either the CA directly publishes its self-signed certificate, or this information is available via the directory (or equivalent) and the CA publishes a hash of this value to allow verification of its integrity before use.",
      "ja": "通常、2つの方法があります。CAは、自己署名証明書を直接公開するか、この情報がディレクトリ（または同等）を介して利用可能であり、CAはこの値のハッシュを公開して、使用前にその完全性の検証を可能にします。"
    },
    {
      "indent": 3,
      "text": "Note: As an alternative to out-of-band distribution of root CA public keys, the CA can provide the self-signed certificate together with link certificates, e.g., using RootCaKeyUpdateContent (Section 5.3.19.15).",
      "ja": "注：ルートCAパブリックキーのバンド外配布の代替として、CAは、rootcakeyupdatecontent（セクション5.3.19.15）を使用して、リンク証明書と一緒に自己署名証明書をリンク証明書とともに提供できます。"
    },
    {
      "indent": 5,
      "text": "OOBCert ::= Certificate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields within this certificate are restricted as follows:",
      "ja": "この証明書内のフィールドは、次のように制限されています。"
    },
    {
      "indent": 6,
      "text": "* The certificate MUST be self-signed (i.e., the signature must be verifiable using the SubjectPublicKeyInfo field);",
      "ja": "* 証明書は自己署名する必要があります（つまり、署名はsubjectpublickeyinfoフィールドを使用して検証可能でなければなりません）。"
    },
    {
      "indent": 6,
      "text": "* The subject and issuer fields MUST be identical;",
      "ja": "* 主題と発行者のフィールドは同一でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the subject field contains a \"NULL-DN\", then both subjectAltNames and issuerAltNames extensions MUST be present and have exactly the same value; and",
      "ja": "* サブジェクトフィールドに「null-dn」が含まれている場合、subjectaltnamesとissueraltnames拡張機能の両方が存在し、まったく同じ値を持つ必要があります。そして"
    },
    {
      "indent": 6,
      "text": "* The values of all other extensions must be suitable for a self-signed certificate (e.g., key identifiers for the subject and issuer must be the same).",
      "ja": "* 他のすべての拡張機能の値は、自己署名証明書に適している必要があります（たとえば、被験者と発行者のキー識別子は同じでなければなりません）。"
    },
    {
      "indent": 5,
      "text": "OOBCertHash ::= SEQUENCE {\n   hashAlg     [0] AlgorithmIdentifier     OPTIONAL,\n   certId      [1] CertId                  OPTIONAL,\n   hashVal         BIT STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The intention of the hash value is that anyone who has securely received the hash value (via the out-of-band means) can verify a self-signed certificate for that CA.",
      "ja": "ハッシュ値の意図は、（帯域外の手段を介して）ハッシュ値を安全に受け取った人なら誰でも、そのCAの自己署名証明書を検証できることです。"
    },
    {
      "indent": 0,
      "text": "5.2.6. Archive Options",
      "section_title": true,
      "ja": "5.2.6. アーカイブオプション"
    },
    {
      "indent": 3,
      "text": "Requesters may indicate that they wish the PKI to archive a private key value using the PKIArchiveOptions structure.",
      "ja": "要求者は、PKIがPKIarchiveoptions構造を使用して秘密キー値をアーカイブすることを望んでいることを示す場合があります。"
    },
    {
      "indent": 3,
      "text": "See [RFC4211] for PKIArchiveOptions syntax.",
      "ja": "pkiarchiveoptions構文については[RFC4211]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.7. Publication Information",
      "section_title": true,
      "ja": "5.2.7. 出版情報"
    },
    {
      "indent": 3,
      "text": "Requesters may indicate that they wish the PKI to publish a certificate using the PKIPublicationInfo structure.",
      "ja": "要求者は、PKIがPKIPUBLICITIONINFO構造を使用して証明書を公開することを望んでいることを示している場合があります。"
    },
    {
      "indent": 3,
      "text": "See [RFC4211] for PKIPublicationInfo syntax.",
      "ja": "pkipublicationinfo構文については[RFC4211]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.8. POP Structures",
      "section_title": true,
      "ja": "5.2.8. ポップ構造"
    },
    {
      "indent": 3,
      "text": "The POP structure used is indicated in the popo field of type ProofOfPossession in the CertReqMsg sequence (see Section 4 of [RFC4211]).",
      "ja": "使用されるPOP構造は、CertreQMSGシーケンスのタイプ証明のPOPOフィールドに示されています（[RFC4211]のセクション4を参照）。"
    },
    {
      "indent": 6,
      "text": "ProofOfPossession ::= CHOICE {\n   raVerified      [0] NULL,\n   signature       [1] POPOSigningKey,\n   keyEncipherment [2] POPOPrivKey,\n   keyAgreement    [3] POPOPrivKey\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2.8.1. raVerified",
      "section_title": true,
      "ja": "5.2.8.1. ラヴェリッド"
    },
    {
      "indent": 3,
      "text": "An end entity MUST NOT use raVerified. If an RA performs changes to a certification request breaking the provided POP, or if the RA requests a certificate on behalf of an end entity and cannot provide the POP itself, the RA MUST use raVerified. Otherwise, it SHOULD NOT use raVerified.",
      "ja": "最終エンティティは、raverifiedを使用してはなりません。RAが提供されたPOPを破壊する認定リクエストの変更を実行する場合、またはRAがEnd Entityに代わって証明書を要求し、POP自体を提供できない場合、RAはRaverifiedを使用する必要があります。それ以外の場合は、raverifiedを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "When introducing raVerified, the RA MUST check the existing POP, or it MUST ensure by other means that the end entity is the holder of the private key. The RA MAY provide the original message containing the POP in the generalInfo field using the id-it-origPKIMessage (see Section 5.1.1.3) enabling the CA to verify it.",
      "ja": "Raverifiedを導入する場合、RAは既存のPOPをチェックする必要があります。または、他の手段で最終エンティティが秘密鍵の所有者であることを確認する必要があります。RAは、CAがそれを検証できるようにするID-IT-OrigpKimessage（セクション5.1.1.3を参照）を使用して、GeneralInfoフィールドのPOPを含む元のメッセージを提供する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.2.8.2. POPOSigningKey Structure",
      "section_title": true,
      "ja": "5.2.8.2. PoposigningKey構造"
    },
    {
      "indent": 3,
      "text": "If the certification request is for a key pair that supports signing (i.e., a request for a verification certificate), then the POP of the private key is demonstrated through use of the POPOSigningKey structure; for details, see Section 4.1 of [RFC4211].",
      "ja": "認定要求が、署名をサポートするキーペア（つまり、検証証明書のリクエスト）の場合、秘密鍵のポップがポポジンキー構造を使用して実証されます。詳細については、[RFC4211]のセクション4.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "POPOSigningKey ::= SEQUENCE {\n   poposkInput [0] POPOSigningKeyInput OPTIONAL,\n   algorithmIdentifier AlgorithmIdentifier,\n   signature BIT STRING\n}\n\nPOPOSigningKeyInput ::= SEQUENCE {\n   authInfo CHOICE {\n      sender [0] GeneralName,\n      publicKeyMAC PKMACValue\n   },\n   publicKey SubjectPublicKeyInfo\n}\n\nPKMACValue ::= SEQUENCE {\n   algId AlgorithmIdentifier,\n   value BIT STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: For the purposes of this specification, the ASN.1 comment given in Appendix C of [RFC4211] pertains not only to certTemplate but also to the altCertTemplate control, as defined in Section 5.2.1.",
      "ja": "注：この仕様の目的のために、[RFC4211]の付録Cに記載されているASN.1コメントは、セクション5.2.1で定義されているように、証明書だけでなくAltCertTemplateコントロールにも関係しています。"
    },
    {
      "indent": 3,
      "text": "If certTemplate (or the altCertTemplate control) contains the subject and publicKey values, then poposkInput MUST be omitted and the signature MUST be computed on the DER-encoded value of the certReq field of the CertReqMsg (or the DER-encoded value of AltCertTemplate). If certTemplate/altCertTemplate does not contain both the subject and public key values (i.e., if it contains only one of these or neither), then poposkInput MUST be present and the signature MUST be computed on the DER-encoded value of poposkInput (i.e., the \"value\" OCTETs of the POPOSigningKeyInput DER).",
      "ja": "certtemplate（またはaltcerttemplateコントロール）にサブジェクト値とpublicKey値が含まれている場合、poposkinpupを省略し、署名をcertreqmsgのcertreqフィールドのderエンコード値（またはaltcertttemplateのderエンコード値）で計算する必要があります。certtemplate/altcertTemplateに、サブジェクトと公開の両方の値（つまり、これらの1つのみが含まれている場合、またはどちらも含まれていない場合）の両方が含まれていない場合、ポポスキンが存在する必要があり、署名はポポスキンプットのderエンコード値（すなわち、ポポスキーインプットderの「値」オクターセット）に計算する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the special case that the CA/RA has a DH certificate that is known to the end entity and the certification request is for a key agreement key pair, the end entity can also use the POPOSigningKey structure (where the algorithmIdentifier field is DHBasedMAC and the signature field is the MAC) for demonstrating POP.",
      "ja": "CA/RAが最終エンティティで知られているDH証明書を持っており、認証要求はキー契約のキーペアに対して既知のDH証明書を持っているという特別なケースでは、End EntityはPopoSigingKey構造（AlgorithmididentifierフィールドがDHBasedMacであり、署名フィールドはMACです）を使用することもできます。"
    },
    {
      "indent": 0,
      "text": "5.2.8.3. POPOPrivKey Structure",
      "section_title": true,
      "ja": "5.2.8.3. Popoprivkey構造"
    },
    {
      "indent": 3,
      "text": "If the certification request is for a key pair that does not support signing (i.e., a request for an encryption or key agreement certificate), then the POP of the private key is demonstrated through use of the POPOPrivKey structure in one of the following three ways; for details see Sections 4.2 and 4.3 in [RFC4211].",
      "ja": "認定リクエストが、署名をサポートしないキーペア（つまり、暗号化またはキー契約証明書のリクエスト）の場合、秘密鍵のPOPは、次の3つの方法のいずれかでPopOprivkey構造を使用することで実証されます。詳細については、[RFC4211]のセクション4.2および4.3を参照してください。"
    },
    {
      "indent": 6,
      "text": "POPOPrivKey ::= CHOICE {\n   thisMessage [0] BIT STRING, -- deprecated\n   subsequentMessage [1] SubsequentMessage,\n   dhMAC [2] BIT STRING, -- deprecated\n   agreeMAC [3] PKMACValue,\n   encryptedKey [4] EnvelopedData\n}\n\nSubsequentMessage ::= INTEGER {\n   encrCert (0),\n   challengeResp (1)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When using agreeMAC or encryptedKey choices, the pvno cmp2021(3) MUST be used. Details on the usage of the protocol version number are described in Section 7.",
      "ja": "AmmareMacまたは暗号化された選択の選択を使用する場合、PVNO CMP2021（3）を使用する必要があります。プロトコルバージョン番号の使用に関する詳細については、セクション7で説明します。"
    },
    {
      "indent": 0,
      "text": "5.2.8.3.1. Inclusion of the Private Key",
      "section_title": true,
      "ja": "5.2.8.3.1. 秘密鍵を含める"
    },
    {
      "indent": 3,
      "text": "This method mentioned previously in Section 4.3 demonstrates POP of the private key by including the encrypted private key in the CertRequest in the POPOPrivKey structure or in the PKIArchiveOptions control structure. This method SHALL only be used if archival of the private key is desired.",
      "ja": "セクション4.3で前述したこの方法は、ポポプリフキー構造またはpkiarchiveoptionsコントロール構造のcertrequestに暗号化された秘密鍵を含めることにより、秘密鍵のPOPを示しています。この方法は、秘密鍵のアーカイブが必要な場合にのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "For a certification request message indicating cmp2021(3) in the pvno field of the PKIHeader, the encrypted private key MUST be transferred in the encryptedKey choice of POPOPrivKey (or within the PKIArchiveOptions control) in a CMS EnvelopedData structure, as defined in Section 5.2.2.",
      "ja": "PKIHeaderのPVNOフィールドでCMP2021（3）を示す認定要求メッセージの場合、暗号化された秘密鍵は、セクション5.2.2で定義されているCMSエンベロープデタ構造のポポプリブキーの暗号化されたキーの選択肢（またはPKIarchiveoptionsコントロール内）で転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The thisMessage choice has been deprecated in favor of encryptedKey. When using cmp2000(2) in the certification request message header for backward compatibility, the thisMessage choice of POPOPrivKey is used containing the encrypted private key in an EncryptedValue structure wrapped in a BIT STRING. This allows the necessary conveyance and protection of the private key while maintaining bits-on-the-wire compatibility with [RFC4211].",
      "ja": "注：ThisMessageの選択は、暗号化されたKeyを支持して非推奨されています。後方互換性のために認定要求メッセージヘッダーでCMP2000（2）を使用する場合、Popoprivkeyのこのメッサージの選択は、ビット文字列に包まれた暗号化されたバリュー構造に暗号化された秘密鍵を含む使用されます。これにより、[RFC4211]とのワイヤーの互換性を維持しながら、秘密鍵の必要な伝達と保護が可能になります。"
    },
    {
      "indent": 0,
      "text": "5.2.8.3.2. Indirect Method - Encrypted Certificate",
      "section_title": true,
      "ja": "5.2.8.3.2. 間接メソッド - 暗号化された証明書"
    },
    {
      "indent": 3,
      "text": "The indirect method mentioned previously in Section 4.3 demonstrates POP of the private key by having the CA return the requested certificate in encrypted form (see Section 5.2.2). This method is indicated in the CertRequest by requesting the encrCert option in the subsequentMessage choice of POPOPrivKey.",
      "ja": "セクション4.3で前述した間接的な方法は、CAに暗号化されたフォームで要求された証明書を返すことにより、秘密鍵のPOPを示しています（セクション5.2.2を参照）。この方法は、PopOprivkeyの後続のメッサージの選択でENCRCERTオプションを要求することにより、CertRequestに示されています。"
    },
    {
      "indent": 11,
      "text": "end entity                         RA/CA\n         ----       req        ---->\n         <---  rep (enc cert)  -----\n         ---- conf (cert hash) ---->\n         <---       ack        -----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The end entity proves knowledge of the private key to the CA by providing the correct CertHash for this certificate in the certConf message. This demonstrates POP because the end entity can only compute the correct CertHash if it is able to recover the encrypted certificate, and it can only recover the certificate if it is able to obtain the symmetric key using the required private key. Clearly, for this to work, the CA MUST NOT publish the certificate until the certConf message arrives (when certHash is to be used to demonstrate POP). See Section 5.3.18 for further details, and see Section 8.11 for security considerations regarding use of CT logs.",
      "ja": "End Entityは、CERTCONFメッセージでこの証明書の正しいCerthashを提供することにより、CAの秘密鍵の知識を証明します。これは、暗号化された証明書を回復できる場合にのみ正しいCerthashを計算できるため、POPを示し、必要な秘密鍵を使用して対称キーを取得できる場合にのみ証明書を回復できるためです。明らかに、これが機能するためには、CAがCERTCONFメッセージが到着するまで証明書を公開してはなりません（CerthashがPOPを実証するために使用する場合）。詳細については、セクション5.3.18を参照してください。CTログの使用に関するセキュリティに関する考慮事項については、セクション8.11を参照してください。"
    },
    {
      "indent": 3,
      "text": "The recipient SHOULD maintain a context of the PKI management operation, e.g., using transactionID and certReqId, to identify the private key to use when decrypting the EnvelopedData containing the newly issued certificate. The recipient may be unable to use the RecipientInfo structure as it refers to the certificate that is still encrypted. The sender MUST populate the rid field as specified by CMS, and the client MAY ignore it.",
      "ja": "受信者は、PKI管理操作のコンテキストを維持する必要があります。たとえば、TransactionIDおよびCertreQIDを使用して、新しく発行された証明書を含む封筒を復号化するときに使用する秘密鍵を特定する必要があります。受信者は、まだ暗号化されている証明書を指すため、受信者の構造を使用できない場合があります。送信者は、CMSで指定されているようにRIDフィールドに入力する必要があり、クライアントはそれを無視する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.2.8.3.3. Direct Method - Challenge-Response Protocol",
      "section_title": true,
      "ja": "5.2.8.3.3. 直接メソッド - チャレンジ応答プロトコル"
    },
    {
      "indent": 3,
      "text": "The direct method mentioned previously in Section 4.3 demonstrates POP of the private key by having the end entity engage in a challenge-response protocol (using the messages popdecc of type POPODecKeyChall and popdecr of type POPODecKeyResp; see below) between CertReqMessages and CertRepMessage. This method is indicated in the CertRequest by requesting the challengeResp option in the subsequentMessage choice of POPOPrivKey.",
      "ja": "セクション4.3で前述した直接的な方法は、最終エンティティにチャレンジ応答プロトコルに従事させることにより、秘密鍵のPOPを示しています（型PopodeckeyChallのメッセージPopDeccと型PopodeckeyRespのPopDecrを使用して、以下を参照）certreqmessagesとcertrepmessageの間。この方法は、PopoPrivkeyの後続のメッサージ選択でChallengerespオプションを要求することにより、Certrequestで示されます。"
    },
    {
      "indent": 3,
      "text": "Note: This method would typically be used in an environment in which an RA verifies POP and then makes a certification request to the CA on behalf of the end entity. In such a scenario, the CA trusts the RA to have done POP correctly before the RA requests a certificate for the end entity.",
      "ja": "注：この方法は通常、RAがPOPを検証し、最終エンティティに代わってCAに認証要求を行う環境で使用されます。このようなシナリオでは、CAは、RAが終了エンティティの証明書を要求する前に、RAが正しくポップしたと信頼しています。"
    },
    {
      "indent": 3,
      "text": "The complete protocol then looks as follows (note that req' does not necessarily encapsulate req as a nested message):",
      "ja": "完全なプロトコルは次のように見えます（Req 'は必ずしもネストされたメッセージとしてReqをカプセル化するわけではないことに注意してください）："
    },
    {
      "indent": 11,
      "text": "end entity            RA            CA\n         ---- req ---->\n         <--- chall ---\n         ---- resp --->\n                       ---- req' --->\n                       <--- rep -----\n                       ---- conf --->\n                       <--- ack -----\n         <--- rep -----\n         ---- conf --->\n         <--- ack -----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This protocol is obviously much longer than the exchange given in Section 5.2.8.3.2 above but allows a Local Registration Authority (LRA) to be involved and has the property that the certificate itself is not actually created until the POP is complete. In some environments, a different order of the above messages may be required, such as the following (this may be determined by policy):",
      "ja": "このプロトコルは明らかに上記のセクション5.2.8.3.2で与えられた交換よりもはるかに長いが、ローカル登録機関（LRA）が関与することを可能にし、POPが完了するまで証明書自体が実際に作成されないというプロパティを持っています。一部の環境では、次のような上記のメッセージの異なる順序が必要になる場合があります（これはポリシーによって決定される場合があります）。"
    },
    {
      "indent": 11,
      "text": "end entity            RA            CA\n         ---- req ---->\n         <--- chall ---\n         ---- resp --->\n                       ---- req' --->\n                       <--- rep -----\n         <--- rep -----\n         ---- conf --->\n                       ---- conf --->\n                       <--- ack -----\n         <--- ack -----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The challenge-response messages for POP of a private key are specified as follows (for decryption keys, see [MvOV97], p.404 for details). This challenge-response exchange is associated with the preceding certification request message (and subsequent certification response and confirmation messages) by the transactionID used in the PKIHeader and by the protection applied to the PKIMessage.",
      "ja": "秘密キーのPOPの課題応答メッセージは、次のように指定されています（復号化キーについては、[MVOV97]、p.404を参照してください）。この課題反応交換は、PKIHeaderで使用されたTransactionIDおよびPKIMESSAGEに適用される保護によって、前の認定要求メッセージ（およびその後の認証応答と確認メッセージ）に関連付けられています。"
    },
    {
      "indent": 6,
      "text": "POPODecKeyChallContent ::= SEQUENCE OF Challenge\n\nChallenge ::= SEQUENCE {\n   owf AlgorithmIdentifier OPTIONAL,\n   witness OCTET STRING,\n   challenge OCTET STRING, -- deprecated\n   encryptedRand [0] EnvelopedData OPTIONAL\n}\n\nRand ::= SEQUENCE {\n   int INTEGER,\n   sender GeneralName\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "More details on the fields in this syntax are available in Appendix F.",
      "ja": "この構文のフィールドの詳細については、付録Fをご覧ください。"
    },
    {
      "indent": 3,
      "text": "For a popdecc message indicating cmp2021(3) in the pvno field of the PKIHeader, the encryption of Rand MUST be transferred in the encryptedRand field in a CMS EnvelopedData structure as defined in Section 5.2.2. The challenge field MUST contain an empty OCTET STRING.",
      "ja": "PKIHEADERのPVNOフィールドでCMP2021（3）を示すPOPDECCメッセージの場合、RANDの暗号化は、セクション5.2.2で定義されているCMS封筒構造の暗号化されたフィールドに転送する必要があります。チャレンジフィールドには、空のオクテット文字列が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "The recipient SHOULD maintain a context of the PKI management operation, e.g., using transactionID and certReqId, to identify the private key to use when decrypting encryptedRand. The sender MUST populate the rid field in the EnvelopedData sequence using the issuerAndSerialNumber choice containing a NULL-DN as issuer and the certReqId as serialNumber. The client MAY ignore the rid field.",
      "ja": "受信者は、PKI管理操作のコンテキストを維持する必要があります。たとえば、TransactionIDおよびCertreQIDを使用して、暗号化された暗号化時に使用する秘密鍵を特定する必要があります。送信者は、発行者としてnull-dnを含む発行者およびcertreqidをserialnumberとして含む発行者およびsserialnumber選択を使用して、封筒のシーケンスでRIDフィールドを埋める必要があります。クライアントは、RIDフィールドを無視する場合があります。"
    },
    {
      "indent": 3,
      "text": "Note: The challenge field has been deprecated in favor of encryptedRand. When using cmp2000(2) in the popdecc message header for backward compatibility, the challenge field MUST contain the encryption (involving the public key for which the certification request is being made) of Rand and encryptedRand MUST be omitted. Using challenge (omitting the optional encryptedRand field) is bit-compatible with [RFC4210]. Note that the size of Rand, when used with challenge, needs to be appropriate for encryption, involving the public key of the requester. If, in some environment, names are so long that they cannot fit (e.g., very long DNs), then whatever portion will fit should be used (as long as it includes at least the common name, and as long as the receiver is able to deal meaningfully with the abbreviation).",
      "ja": "注：チャレンジフィールドは、暗号化されたエンサイプドランドを支持して廃止されました。後方互換性のためにPOPDECCメッセージヘッダーでCMP2000（2）を使用する場合、チャレンジフィールドには、RANDおよび暗号化されたエンサイプランドの暗号化（認証要求が行われている公開鍵を含む）を省略する必要があります。[rfc4210]では、[オプションの暗号化]フィールドを除外すること（オプションの暗号化されたフィールドを省略）を使用することができます。RANDのサイズは、チャレンジで使用する場合、要求者の公開鍵を含む暗号化に適している必要があることに注意してください。一部の環境では、名前が非常に長いため、適合できない場合（たとえば、非常に長いDNS）、適合する部分を使用する必要があります（少なくとも共通名が含まれている限り、レシーバーが略語に有意義に対処できる限り）。"
    },
    {
      "indent": 6,
      "text": "POPODecKeyRespContent ::= SEQUENCE OF INTEGER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "On receiving the popdecc message, the end entity decrypts all included challenges and responds with a popdecr message containing the decrypted integer values in the same order.",
      "ja": "POPDECCメッセージを受信すると、End Entityはすべて課題を復活させ、同じ順序で復号化された整数値を含むPOPDECRメッセージで応答します。"
    },
    {
      "indent": 0,
      "text": "5.2.8.4. Summary of POP Options",
      "section_title": true,
      "ja": "5.2.8.4. ポップオプションの概要"
    },
    {
      "indent": 3,
      "text": "The text in this section provides several options with respect to POP techniques. Using \"SK\" for \"signing key\", \"EK\" for \"encryption key\", \"KAK\" for \"key agreement key\", and \"KEMK\" for \"key encapsulation mechanism key\", the techniques may be summarized as follows:",
      "ja": "このセクションのテキストは、ポップテクニックに関するいくつかのオプションを提供します。「キーに署名する」に「SK」、「暗号化キー」の「EK」、「キー契約キー」の「KAK」、および「キーカプセル化メカニズムキー」の「KEMK」を使用すると、テクニックは次のように要約できます。"
    },
    {
      "indent": 6,
      "text": " RAVerified;",
      "ja": "raverified;"
    },
    {
      "indent": 6,
      "text": " SKPOP;",
      "ja": "skpop;"
    },
    {
      "indent": 6,
      "text": " EKPOPThisMessage; -- deprecated",
      "ja": "ekpopthismessage;- 非推奨"
    },
    {
      "indent": 6,
      "text": " KAKPOPThisMessage; -- deprecated",
      "ja": "kakpopthismessage;- 非推奨"
    },
    {
      "indent": 6,
      "text": " EKPOPEncryptedKey;",
      "ja": "ekpopencryptedKey;"
    },
    {
      "indent": 6,
      "text": " KAKPOPEncryptedKey;",
      "ja": "kakpopencryptedkey;"
    },
    {
      "indent": 6,
      "text": " KEMKPOPEncryptedKey;",
      "ja": "kemkpopencryptedkey;"
    },
    {
      "indent": 6,
      "text": " KAKPOPThisMessageDHMAC;",
      "ja": "kakpopthismessagedhmac;"
    },
    {
      "indent": 6,
      "text": " EKPOPEncryptedCert;",
      "ja": "ekpopencryptedcert;"
    },
    {
      "indent": 6,
      "text": " KAKPOPEncryptedCert;",
      "ja": "kakpopencryptedcert;"
    },
    {
      "indent": 6,
      "text": " KEMKPOPEncryptedCert;",
      "ja": "kemkpopencryptedcert;"
    },
    {
      "indent": 6,
      "text": " EKPOPChallengeResp;",
      "ja": "ekpopchallengeresp;"
    },
    {
      "indent": 6,
      "text": " KAKPOPChallengeResp; and",
      "ja": "Kakpopchallengeresp;そして"
    },
    {
      "indent": 6,
      "text": " KEMKPOPChallengeResp.",
      "ja": "kemkpopchallengeresp。"
    },
    {
      "indent": 3,
      "text": "Given this array of options, it is natural to ask how an end entity can know what is supported by the CA/RA (i.e., which options it may use when requesting certificates). The following guidelines should clarify this situation for end entity implementers.",
      "ja": "この一連のオプションを考えると、最終エンティティがCA/RAによってサポートされているものをどのように知ることができるかを尋ねるのは自然です（つまり、証明書を要求するときに使用するオプション）。次のガイドラインは、エンディティの実装者のこの状況を明確にする必要があります。"
    },
    {
      "indent": 6,
      "text": "* RAVerified: This is not an end entity decision; the RA uses this if and only if it has verified POP before forwarding the request on to the CA, so it is not possible for the end entity to choose this technique.",
      "ja": "* raverified：これは最終エンティティの決定ではありません。RAは、リクエストをCAに転送する前にPOPを検証した場合にのみこれを使用しているため、最終エンティティがこの手法を選択することはできません。"
    },
    {
      "indent": 6,
      "text": "* SKPOP: If the end entity has a signing key pair, this is the only POP method specified for use in the request for a corresponding certificate.",
      "ja": "* Skpop：End Entityに署名キーペアがある場合、これは対応する証明書の要求で使用するために指定された唯一のPOPメソッドです。"
    },
    {
      "indent": 6,
      "text": "* EKPOPThisMessage (deprecated), KAKPOPThisMessage (deprecated), EKPOPEncryptedKey, KAKPOPEncryptedKey, KEMKPOPEncryptedKey: Whether or not to give up its private key to the CA/RA is an end entity decision. If the end entity decides to reveal its key, then these are the only POP methods available in this specification to achieve this (and the key pair type and protocol version used will determine which of these methods to use). The reason for deprecating EKPOPThisMessage and KAKPOPThisMessage options has been given in Section 5.2.8.3.1.",
      "ja": "* ekpopthismessage（削除）、kakpopthismessage（deprecated）、ekpopencryptedkey、kakpopencryptedkey、kemkpopencryptedkey：ca/raの秘密鍵を放棄するかどうかは最終エンティティの決定です。End Entityがそのキーを明らかにすることを決定した場合、これらはこの仕様で使用できる唯一のPOPメソッドです（および使用するキーペアのタイプとプロトコルバージョンは、これらの使用方法のどれを決定します）。ekpopthismessageとKakpopthissageのオプションを非難する理由は、セクション5.2.8.3.1に記載されています。"
    },
    {
      "indent": 6,
      "text": "* KAKPOPThisMessageDHMAC: The end entity can only use this method if (1) the CA/RA has a DH certificate available for this purpose and (2) the end entity already has a copy of this certificate. If both these conditions hold, then this technique is clearly supported and may be used by the end entity, if desired.",
      "ja": "* kakpopthismessagedhmac：最終エンティティは、（1）CA/RAにこの目的で利用可能なDH証明書がある場合にのみこの方法を使用できます。これらの両方の条件が保持されている場合、この手法は明確にサポートされており、必要に応じて最終エンティティで使用される場合があります。"
    },
    {
      "indent": 6,
      "text": "* EKPOPEncryptedCert, KAKPOPEncryptedCert, KEMKPOPEncryptedCert, EKPOPChallengeResp, KAKPOPChallengeResp, and KEMKPOPChallengeResp: The end entity picks one of these (in the subsequentMessage field) in the request message, depending upon preference and key pair type. The end entity is not doing POP at this point; it is simply indicating which method it wants to use. Therefore, if the CA/RA replies with a \"badPOP\" error, the end entity can re-request using the other POP method chosen in subsequentMessage. Note, however, that this specification encourages the use of the EncryptedCert choice and, furthermore, says that the challenge-response would typically be used when an RA is involved and doing POP verification. Thus, the end entity should be able to make an intelligent decision regarding which of these POP methods to choose in the request message.",
      "ja": "* ekpopencryptedcert、kakpopencryptedcert、kemkpopencryptedcert、ekpopchallengeresp、kakpopchallengeresp、およびkemkpopchallengeresp：kemkpopchallengeresp：エンディティは、リクエストメッセージとキーペアのタイプに応じて、リクエストメッセージにおいてこれらの1つ（後続のメッシャーフィールド）を選択します。最終エンティティはこの時点でポップを行っていません。使用したい方法を単に示しているだけです。したがって、CA/RAが「バッドポップ」エラーで応答する場合、End Entityは、後続のメッセージで選択された他のPOPメソッドを使用して再リケストできます。ただし、この仕様は暗号化された選択の選択の使用を促進し、さらに、RAが関与してポップ検証を行うときにチャレンジ応答が使用されると述べていることに注意してください。したがって、最終エンティティは、リクエストメッセージでこれらのポップメソッドのどれを選択するかについて、インテリジェントな決定を下すことができるはずです。"
    },
    {
      "indent": 0,
      "text": "5.2.9. GeneralizedTime",
      "section_title": true,
      "ja": "5.2.9. 一般化された時間"
    },
    {
      "indent": 3,
      "text": "GeneralizedTime is a standard ASN.1 type and SHALL be used as specified in Section 4.1.2.5.2 of [RFC5280].",
      "ja": "GeneralizedTimeは標準のASN.1タイプであり、[RFC5280]のセクション4.1.2.5.2で指定されているように使用するものとします。"
    },
    {
      "indent": 0,
      "text": "5.3. Operation-Specific Data Structures",
      "section_title": true,
      "ja": "5.3. 操作固有のデータ構造"
    },
    {
      "indent": 0,
      "text": "5.3.1. Initialization Request",
      "section_title": true,
      "ja": "5.3.1. 初期化リクエスト"
    },
    {
      "indent": 3,
      "text": "An Initialization request message contains as the PKIBody a CertReqMessages data structure, which specifies the requested certificate(s). Typically, SubjectPublicKeyInfo, KeyId, and Validity are the template fields that may be supplied for each certificate requested (see the profiles defined in Section 4.1.1 of [RFC9483] and Appendices C.4 and D.7 for further information). This message is intended to be used for entities when first initializing into the PKI.",
      "ja": "初期化要求メッセージには、pkibodyとしてCertreqMessagesデータ構造として含まれています。これは、要求された証明書を指定します。通常、subjectpublickeyinfo、keyID、および有効性は、要求された各証明書に対して提供される可能性のあるテンプレートフィールドです（詳細については、[RFC9483]のセクション4.1.1および付録C.4およびD.7で定義されているプロファイルを参照）。このメッセージは、最初にPKIに初期化するときにエンティティに使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "See Section 5.2.1 and [RFC4211] for CertReqMessages syntax.",
      "ja": "CertreqMessagesの構文については、セクション5.2.1および[RFC4211]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Initialization Response",
      "section_title": true,
      "ja": "5.3.2. 初期化応答"
    },
    {
      "indent": 3,
      "text": "An Initialization response message contains as the PKIBody a CertRepMessage data structure, which has for each certificate requested a PKIStatusInfo field, a subject certificate, and possibly a private key (normally encrypted using EnvelopedData; see Section 4.1.6 of [RFC9483] for further information).",
      "ja": "初期化応答メッセージには、pkibodyとしてCertrepmessageデータ構造として含まれています。各証明書には、pkistatusinfoフィールド、サブジェクト証明書、および場合によっては秘密鍵（通常は封筒を使用して暗号化されています。詳細については[RFC9483]のセクション4.1.6を参照）が含まれています。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax. Note that if the PKI message protection is \"shared secret information\" (see Section 5.1.3.1), then any certificate transported in the caPubs field may be directly trusted as a root CA certificate by the initiator.",
      "ja": "CertrePmessageの構文については、セクション5.3.4を参照してください。PKIメッセージ保護が「共有秘密情報」である場合（セクション5.1.3.1を参照）、Capubsフィールドで輸送される証明書は、イニシエーターによってルートCA証明書として直接信頼される場合があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Certification Request",
      "section_title": true,
      "ja": "5.3.3. 認定リクエスト"
    },
    {
      "indent": 3,
      "text": "A Certification request message contains as the PKIBody a CertReqMessages data structure, which specifies the requested certificates (see the profiles defined in Section 4.1.2 of [RFC9483] and Appendix C.2 for further information). This message is intended to be used for existing PKI entities who wish to obtain additional certificates.",
      "ja": "認定要求メッセージには、PKIBODY A CertreQMessagesデータ構造として含まれています。これは、要求された証明書を指定します（詳細については、[RFC9483]のセクション4.1.2で定義されているプロファイルを参照）。このメッセージは、追加の証明書を取得したい既存のPKIエンティティに使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "See Section 5.2.1 and [RFC4211] for CertReqMessages syntax.",
      "ja": "CertreqMessagesの構文については、セクション5.2.1および[RFC4211]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Alternatively, the PKIBody MAY be a CertificationRequest (this structure is fully specified by the ASN.1 structure CertificationRequest given in [RFC2986]; see the profiles defined in Section 4.1.4 of [RFC9483] for further information). This structure may be required for certificate requests for signing key pairs when interoperation with legacy systems is desired, but its use is strongly discouraged whenever not absolutely necessary.",
      "ja": "あるいは、PKIBODYは認証リケストである可能性があります（この構造は、[RFC2986]に与えられたASN.1構造認証再クエストによって完全に指定されています。詳細については、[RFC9483]のセクション4.1.4で定義されているプロファイルを参照してください）。この構造は、レガシーシステムとの相互操作が望まれている場合、キーペアに署名するための証明書リクエストに必要な場合がありますが、その使用は絶対に必要ではない場合は強く落胆します。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Certification Response",
      "section_title": true,
      "ja": "5.3.4. 認定応答"
    },
    {
      "indent": 3,
      "text": "A Certification response message contains as the PKIBody a CertRepMessage data structure, which has a status value for each certificate requested and optionally has a CA public key, failure information, a subject certificate, and an encrypted private key.",
      "ja": "認証応答メッセージには、PKIBODYとしてCertrePmessageデータ構造が含まれています。これには、各証明書のステータス値が要求され、オプションでCAの公開キー、障害情報、件名証明書、暗号化された秘密鍵が含まれています。"
    },
    {
      "indent": 5,
      "text": "CertRepMessage ::= SEQUENCE {\n   caPubs          [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                       OPTIONAL,\n   response            SEQUENCE OF CertResponse\n}\n\nCertResponse ::= SEQUENCE {\n   certReqId           INTEGER,\n   status              PKIStatusInfo,\n   certifiedKeyPair    CertifiedKeyPair     OPTIONAL,\n   rspInfo             OCTET STRING         OPTIONAL\n   -- analogous to the id-regInfo-utf8Pairs string defined\n   -- for regInfo in CertReqMsg [RFC4211]\n}\n\nCertifiedKeyPair ::= SEQUENCE {\n   certOrEncCert       CertOrEncCert,\n   privateKey      [0] EncryptedKey         OPTIONAL,\n   -- See [RFC4211] for comments on encoding.\n   publicationInfo [1] PKIPublicationInfo   OPTIONAL\n}\n\nCertOrEncCert ::= CHOICE {\n   certificate     [0] CMPCertificate,\n   encryptedCert   [1] EncryptedKey\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A p10cr message contains exactly one CertificationRequestInfo data structure, as specified in PKCS #10 [RFC2986], but no certReqId. Therefore, the certReqId in the corresponding Certification Response (cp) message MUST be set to -1.",
      "ja": "P10CRメッセージには、PKCS＃10 [RFC2986]で指定されているように、Certreqidはありませんが、Certreqidは1つあります。したがって、対応する認証応答（CP）メッセージのCertreQIDは-1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Only one of the failInfo (in PKIStatusInfo) and certificate (in CertifiedKeyPair) fields can be present in each CertResponse (depending on the status). For some status values (e.g., waiting), neither of the optional fields will be present.",
      "ja": "FailInfo（pkistatusinfoで）と証明書（認定Keypair）の1つのみが、各Certresponse（ステータスに応じて）に存在する可能性があります。一部のステータス値（待機）の場合、オプションのフィールドはどちらも存在しません。"
    },
    {
      "indent": 3,
      "text": "Given an EncryptedCert and the relevant decryption key, the certificate may be obtained. The purpose of this is to allow a CA to return the value of a certificate but with the constraint that only the intended recipient can obtain the actual certificate. The benefit of this approach is that a CA may reply with a certificate even in the absence of proof that the requester is the end entity that can use the relevant private key (note that the proof is not obtained until the certConf message is received by the CA). Thus, the CA will not have to revoke that certificate in the event that something goes wrong with the POP (but MAY do so anyway, depending upon policy).",
      "ja": "暗号化された暗号化と関連する復号化キーを考えると、証明書が取得される場合があります。これの目的は、CAが証明書の値を返すことを許可することですが、意図した受信者のみが実際の証明書を取得できるという制約があります。このアプローチの利点は、CAが関連する秘密鍵を使用できる最終エンティティであるという証明がない場合でも証明書に返信できることです（CARがCARTCONFメッセージを受信するまで証明は取得されないことに注意してください）。したがって、CAは、POPに何か問題が発生した場合にその証明書を取り消す必要はありません（ただし、とにかく、ポリシーに応じてそうすることができます）。"
    },
    {
      "indent": 3,
      "text": "The use of EncryptedKey is described in Section 5.2.2.",
      "ja": "暗号化されたキーの使用については、セクション5.2.2で説明しています。"
    },
    {
      "indent": 3,
      "text": "Note: To indicate support for EnvelopedData, the pvno cmp2021 has been introduced. Details on the usage of different protocol version numbers are described in Section 7.",
      "ja": "注：EnvelopedDataのサポートを示すために、PVNO CMP2021が導入されました。さまざまなプロトコルバージョン番号の使用に関する詳細については、セクション7で説明します。"
    },
    {
      "indent": 0,
      "text": "5.3.5. Key Update Request Content",
      "section_title": true,
      "ja": "5.3.5. キーアップデートリクエストコンテンツ"
    },
    {
      "indent": 3,
      "text": "For key update requests, the CertReqMessages syntax is used. Typically, SubjectPublicKeyInfo, KeyId, and Validity are the template fields that may be supplied for each key to be updated (see the profiles defined in Section 4.1.3 of [RFC9483] and Appendix C.6 for further information). This message is intended to be used to request updates to existing (non-revoked and non-expired) certificates (therefore, it is sometimes referred to as a \"Certificate Update\" operation). An update is a replacement certificate containing either a new subject public key or the current subject public key (although the latter practice may not be appropriate for some environments).",
      "ja": "キーアップデートリクエストには、CertreQMessages構文が使用されます。通常、subjectpublickeyinfo、keyID、および有効性は、更新する各キーに提供されるテンプレートフィールドです（詳細については[RFC9483]のセクション4.1.3および付録C.6で定義されているプロファイルを参照）。このメッセージは、既存の（非回転および非走行されていない）証明書の更新をリクエストするために使用することを目的としています（したがって、「証明書更新」操作と呼ばれることもあります）。更新は、新しい件名の公開キーまたは現在の件名の公開キーのいずれかを含む交換証明書です（ただし、後者のプラクティスは環境には適切ではない場合があります）。"
    },
    {
      "indent": 3,
      "text": "See Section 5.2.1 and [RFC4211] for CertReqMessages syntax.",
      "ja": "CertreqMessagesの構文については、セクション5.2.1および[RFC4211]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.6. Key Update Response Content",
      "section_title": true,
      "ja": "5.3.6. 主要な更新応答コンテンツ"
    },
    {
      "indent": 3,
      "text": "For key update responses, the CertRepMessage syntax is used. The response is identical to the initialization response.",
      "ja": "主要な更新応答には、certrepmessage構文が使用されます。応答は、初期化応答と同じです。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax.",
      "ja": "CertrePmessageの構文については、セクション5.3.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.7. Key Recovery Request Content",
      "section_title": true,
      "ja": "5.3.7. キーリカバリリクエストコンテンツ"
    },
    {
      "indent": 3,
      "text": "For key recovery requests, the syntax used is identical to the initialization request CertReqMessages. Typically, SubjectPublicKeyInfo and KeyId are the template fields that may be used to supply a signature public key for which a certificate is required.",
      "ja": "キーリカバリリクエストの場合、使用される構文は初期化リクエストCertreQMessagesと同じです。通常、subjectpublickeyinfoとkeyIDは、証明書が必要な署名公開鍵を提供するために使用できるテンプレートフィールドです。"
    },
    {
      "indent": 3,
      "text": "See Section 5.2.1 and [RFC4211] for CertReqMessages syntax. Note that if a key history is required, the requester must supply a protocol encryption key control in the request message.",
      "ja": "CertreqMessagesの構文については、セクション5.2.1および[RFC4211]を参照してください。重要な履歴が必要な場合、要求者はリクエストメッセージにプロトコル暗号化キーコントロールを提供する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.3.8. Key Recovery Response Content",
      "section_title": true,
      "ja": "5.3.8. キーリカバリ応答コンテンツ"
    },
    {
      "indent": 3,
      "text": "For key recovery responses, the following syntax is used. For some status values (e.g., waiting), none of the optional fields will be present.",
      "ja": "主要な回復応答には、次の構文が使用されます。一部のステータス値（待機）の場合、オプションのフィールドは存在しません。"
    },
    {
      "indent": 5,
      "text": "KeyRecRepContent ::= SEQUENCE {\n   status            PKIStatusInfo,\n   newSigCert    [0] Certificate                 OPTIONAL,\n   caCerts       [1] SEQUENCE SIZE (1..MAX) OF\n                                Certificate      OPTIONAL,\n   keyPairHist   [2] SEQUENCE SIZE (1..MAX) OF\n                                CertifiedKeyPair OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.9. Revocation Request Content",
      "section_title": true,
      "ja": "5.3.9. 取り消し要求コンテンツ"
    },
    {
      "indent": 3,
      "text": "When requesting revocation of a certificate (or several certificates), the following data structure is used (see the profiles defined in Section 4.2 of [RFC9483] for further information). The name of the requester is present in the PKIHeader structure.",
      "ja": "証明書（または複数の証明書）の取り消しを要求する場合、次のデータ構造が使用されます（詳細については、[RFC9483]のセクション4.2で定義されているプロファイルを参照）。要求者の名前は、pkiheader構造に存在します。"
    },
    {
      "indent": 5,
      "text": "RevReqContent ::= SEQUENCE OF RevDetails\n\nRevDetails ::= SEQUENCE {\n   certDetails         CertTemplate,\n   crlEntryDetails     Extensions       OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.10. Revocation Response Content",
      "section_title": true,
      "ja": "5.3.10. 取り消し応答コンテンツ"
    },
    {
      "indent": 3,
      "text": "The revocation response is the response to the above message. If produced, this is sent to the requester of the revocation. (A separate revocation announcement message MAY be sent to the subject of the certificate for which revocation was requested.)",
      "ja": "取り消し応答は、上記のメッセージに対する応答です。作成された場合、これは取り消しの要求者に送信されます。（失効が要求された証明書の主題に送信される可能性があります。）"
    },
    {
      "indent": 5,
      "text": "RevRepContent ::= SEQUENCE {\n   status        SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,\n   revCerts  [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,\n   crls      [1] SEQUENCE SIZE (1..MAX) OF CertificateList\n                 OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.11. Cross-Certification Request Content",
      "section_title": true,
      "ja": "5.3.11. 相互認定要求コンテンツ"
    },
    {
      "indent": 3,
      "text": "Cross-certification requests use the same syntax (CertReqMessages) as normal certification requests, with the restriction that the key pair MUST have been generated by the requesting CA and the private key MUST NOT be sent to the responding CA (see the profiles defined in Appendix D.6 for further information). This request MAY also be used by subordinate CAs to get their certificates signed by the parent CA.",
      "ja": "相互認証要求は、通常の認証要求と同じ構文（certreqmessages）を使用します。キーペアが要求CAによって生成された必要があるという制限は、応答CAに送信されてはなりません（詳細については、付録D.6で定義されているプロファイルを参照）。このリクエストは、親CAが署名した証明書を取得するために、下位CASによっても使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "See Section 5.2.1 and [RFC4211] for CertReqMessages syntax.",
      "ja": "CertreqMessagesの構文については、セクション5.2.1および[RFC4211]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.12. Cross-Certification Response Content",
      "section_title": true,
      "ja": "5.3.12. 相互認定応答コンテンツ"
    },
    {
      "indent": 3,
      "text": "Cross-certification responses use the same syntax (CertRepMessage) as normal certification responses, with the restriction that no encrypted private key can be sent.",
      "ja": "相互認証応答は、通常の認証応答と同じ構文（certrepmessage）を使用します。暗号化された秘密鍵を送信できないという制限があります。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax.",
      "ja": "CertrePmessageの構文については、セクション5.3.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.13. CA Key Update Announcement Content",
      "section_title": true,
      "ja": "5.3.13. CAキーアップデートアナウンスコンテンツ"
    },
    {
      "indent": 3,
      "text": "When a CA updates its own key pair, the following data structure MAY be used to announce this event.",
      "ja": "CAが独自の重要なペアを更新すると、次のデータ構造を使用してこのイベントを発表できます。"
    },
    {
      "indent": 3,
      "text": "  RootCaKeyUpdateContent ::= SEQUENCE {\n     newWithNew              CMPCertificate,\n     newWithOld          [0] CMPCertificate OPTIONAL,\n     oldWithNew          [1] CMPCertificate OPTIONAL\n  }\n\nCAKeyUpdContent ::= CHOICE {\n    cAKeyUpdAnnV2      CAKeyUpdAnnContent, -- deprecated\n    cAKeyUpdAnnV3  [0] RootCaKeyUpdateContent\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When using RootCaKeyUpdateContent in the ckuann message, the pvno cmp2021 MUST be used. Details on the usage of the protocol version number are described in Section 7.",
      "ja": "ckuannメッセージでrootcakeyupdatecontentを使用する場合、PVNO CMP2021を使用する必要があります。プロトコルバージョン番号の使用に関する詳細については、セクション7で説明します。"
    },
    {
      "indent": 3,
      "text": "In contrast to CAKeyUpdAnnContent as supported with cmp2000, RootCaKeyUpdateContent offers omitting newWithOld and oldWithNew, depending on the needs of the end entity.",
      "ja": "CMP2000でサポートされているCakeYupDannContentとは対照的に、RootCakeyUpDateContentは、最終エンティティのニーズに応じて、NewWitholdとOldwithNewを省略しています。"
    },
    {
      "indent": 0,
      "text": "5.3.14. Certificate Announcement",
      "section_title": true,
      "ja": "5.3.14. 証明書の発表"
    },
    {
      "indent": 3,
      "text": "This structure MAY be used to announce the existence of certificates.",
      "ja": "この構造は、証明書の存在を発表するために使用できます。"
    },
    {
      "indent": 3,
      "text": "Note that this message is intended to be used for those cases (if any) where there is no pre-existing method for publication of certificates; it is not intended to be used where, for example, X.500 is the method for publication of certificates.",
      "ja": "このメッセージは、証明書の公開のための既存の方法がない場合（もしあれば）（ある場合）に使用することを目的としていることに注意してください。たとえば、X.500が証明書の公開方法である場合、使用することを意図していません。"
    },
    {
      "indent": 5,
      "text": "CertAnnContent ::= Certificate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.15. Revocation Announcement",
      "section_title": true,
      "ja": "5.3.15. 取り消しの発表"
    },
    {
      "indent": 3,
      "text": "When a CA has revoked, or is about to revoke, a particular certificate, it MAY issue an announcement of this (possibly upcoming) event.",
      "ja": "CAが特定の証明書を取り消した、または取り消そうとしている場合、この（おそらく今後の）イベントの発表を発行する可能性があります。"
    },
    {
      "indent": 5,
      "text": "RevAnnContent ::= SEQUENCE {\n   status              PKIStatus,\n   certId              CertId,\n   willBeRevokedAt     GeneralizedTime,\n   badSinceDate        GeneralizedTime,\n   crlDetails          Extensions  OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A CA MAY use such an announcement to warn (or notify) a subject that its certificate is about to be (or has been) revoked. This would typically be used where the request for revocation did not come from the subject concerned.",
      "ja": "CAは、そのような発表を使用して、その証明書が取り消されようとしている（または取り消された）主題に警告する（または通知）することができます。これは通常、取り消しの要求が関係する主題から得られなかった場合に使用されます。"
    },
    {
      "indent": 3,
      "text": "The willBeRevokedAt field contains the time at which a new entry will be added to the relevant CRLs.",
      "ja": "Willberevokedatフィールドには、関連するCRLに新しいエントリが追加される時間が含まれています。"
    },
    {
      "indent": 0,
      "text": "5.3.16. CRL Announcement",
      "section_title": true,
      "ja": "5.3.16. CRLの発表"
    },
    {
      "indent": 3,
      "text": "When a CA issues a new CRL (or set of CRLs), the following data structure MAY be used to announce this event.",
      "ja": "CAが新しいCRL（またはCRLのセット）を発行すると、次のデータ構造を使用してこのイベントを発表できます。"
    },
    {
      "indent": 5,
      "text": "CRLAnnContent ::= SEQUENCE OF CertificateList",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.17. PKI Confirmation Content",
      "section_title": true,
      "ja": "5.3.17. PKI確認コンテンツ"
    },
    {
      "indent": 3,
      "text": "This data structure is used in the protocol exchange as the final PKIMessage. Its content is the same in all cases -- actually, there is no content since the PKIHeader carries all the required information.",
      "ja": "このデータ構造は、プロトコル交換で最終的なpkimessageとして使用されます。そのコンテンツはすべての場合に同じです。実際、PKIHeaderには必要なすべての情報が含まれているため、コンテンツはありません。"
    },
    {
      "indent": 5,
      "text": "PKIConfirmContent ::= NULL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Use of this message for certificate confirmation is NOT RECOMMENDED; certConf SHOULD be used instead. Upon receiving a pkiconf for a certificate response, the recipient MAY treat it as a certConf with all certificates being accepted.",
      "ja": "証明書確認のためにこのメッセージを使用することは推奨されません。代わりにCERTCONFを使用する必要があります。証明書の応答のためにPKICONFを受け取ると、受信者はそれをすべての証明書が受け入れられ、それを証明書作成者として扱うことができます。"
    },
    {
      "indent": 0,
      "text": "5.3.18. Certificate Confirmation Content",
      "section_title": true,
      "ja": "5.3.18. 証明書確認コンテンツ"
    },
    {
      "indent": 3,
      "text": "This data structure is used by the client to send a confirmation to the CA/RA to accept or reject certificates.",
      "ja": "このデータ構造は、クライアントがCA/RAに確認を送信して証明書を受け入れるか拒否するために使用されます。"
    },
    {
      "indent": 5,
      "text": "CertConfirmContent ::= SEQUENCE OF CertStatus\n\nCertStatus ::= SEQUENCE {\n   certHash    OCTET STRING,\n   certReqId   INTEGER,\n   statusInfo  PKIStatusInfo OPTIONAL,\n   hashAlg [0] AlgorithmIdentifier{DIGEST-ALGORITHM, {...}}\n               OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The hashAlg field SHOULD be used only in exceptional cases where the signatureAlgorithm of the certificate to be confirmed does not specify a hash algorithm in the OID or in the parameters or no hash algorithm is specified for hashing certificates signed using the signatureAlgorithm. Note that for EdDSA, a hash algorithm is specified in Section 3.3 of [RFC9481], such that the hashAlg field is not needed for EdDSA. Otherwise, the certHash value SHALL be computed using the same hash algorithm as used to create and verify the certificate signature or as specified for hashing certificates signed using the signatureAlgorithm. If hashAlg is used, the CMP version indicated by the certConf message header must be cmp2021(3).",
      "ja": "Hashalgフィールドは、確認される証明書のSignaturealGorithmがOIDまたはパラメーターまたはHashアルゴリズムなしでHashアルゴリズムを指定しない例外的な場合にのみ使用する必要があります。EDDSAの場合、Hashアルゴリズムが[RFC9481]のセクション3.3で指定されているため、HashalgフィールドはEDDSAに必要ではないことに注意してください。それ以外の場合、Certhash値は、証明書の署名の作成と検証に使用されるのと同じハッシュアルゴリズムを使用して、またはSignatureAlgorithmを使用して署名されたハッシュ証明書に指定されている場合に計算するものとします。Hashalgを使用する場合、CERTCONFメッセージヘッダーで示されるCMPバージョンはCMP2021（3）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "For any particular CertStatus, omission of the statusInfo field indicates acceptance of the specified certificate. Alternatively, explicit status details (with respect to acceptance or rejection) MAY be provided in the statusInfo field, perhaps for auditing purposes at the CA/RA.",
      "ja": "特定の証明書については、StatusInfoフィールドの省略は、指定された証明書の受け入れを示します。あるいは、おそらくCA/RAでの監査目的で、StatusInfoフィールドで明示的なステータスの詳細を（受け入れまたは拒否に関して）提供することができます。"
    },
    {
      "indent": 3,
      "text": "Within CertConfirmContent, omission of a CertStatus structure corresponding to a certificate supplied in the previous response message indicates rejection of the certificate. Thus, an empty CertConfirmContent (a zero-length SEQUENCE) MAY be used to indicate rejection of all supplied certificates. See Section 5.2.8.3.2 for a discussion of the certHash field with respect to POP.",
      "ja": "CertConfirmContentでは、以前の応答メッセージで提供された証明書に対応する証明書構造の省略は、証明書の拒否を示しています。したがって、空のcertconfirmcontent（ゼロ長のシーケンス）を使用して、すべての供給された証明書の拒否を示すことができます。POPに関するCerthashフィールドの議論については、セクション5.2.8.3.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19. PKI General Message Content",
      "section_title": true,
      "ja": "5.3.19. PKI一般的なメッセージコンテンツ"
    },
    {
      "indent": 5,
      "text": "InfoTypeAndValue ::= SEQUENCE {\n   infoType               OBJECT IDENTIFIER,\n   infoValue              ANY DEFINED BY infoType  OPTIONAL\n}\n\n-- where {id-it} = {id-pkix 4} = {1 3 6 1 5 5 7 4}\nGenMsgContent ::= SEQUENCE OF InfoTypeAndValue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.1. CA Protocol Encryption Certificate",
      "section_title": true,
      "ja": "5.3.19.1. CAプロトコル暗号化証明書"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the end entity to get a certificate from the CA to use to protect sensitive information during the protocol.",
      "ja": "これは、プロトコル中に機密情報を保護するために使用するためにCAから証明書を取得するために最終エンティティによって使用される場合があります。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 1}, < absent >\nGenRep:    {id-it 1}, Certificate | < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "End entities MUST ensure that the correct certificate is used for this purpose.",
      "ja": "エンティティは、この目的のために正しい証明書が使用されることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.19.2. Signing Key Pair Types",
      "section_title": true,
      "ja": "5.3.19.2. キーペアの種類に署名します"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the end entity to get the list of signature algorithms whose subject public key values the CA is willing to certify.",
      "ja": "これは、CAがCAが認証する意思があると主張する署名アルゴリズムのリストを取得するために、End Entityによって使用される場合があります。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 2}, < absent >\nGenRep:    {id-it 2}, SEQUENCE SIZE (1..MAX) OF\n                        AlgorithmIdentifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: For the purposes of this exchange, rsaEncryption and sha256WithRSAEncryption, for example, are considered to be equivalent; the question being asked is, \"Is the CA willing to certify an RSA public key?\"",
      "ja": "注：この交換の目的のために、たとえば、rsaEcnecryptionとsha256 -withrsaencryptionは同等であると見なされます。尋ねられる質問は、「CAはRSAの公開鍵を認定することをいとわないのですか？」です。"
    },
    {
      "indent": 3,
      "text": "Note: In case several elliptic curves are supported, several id-ecPublicKey elements as defined in [RFC5480] need to be given, one per named curve.",
      "ja": "注：いくつかの楕円曲線がサポートされている場合、[RFC5480]で定義されているいくつかのID-EcpublicKey要素を指定された曲線ごとに与えられる必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.19.3. Encryption / Key Agreement Key Pair Types",
      "section_title": true,
      "ja": "5.3.19.3. 暗号化 /キー契約キーペアタイプ"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get the list of encryption / key agreement algorithms whose subject public key values the CA is willing to certify.",
      "ja": "これは、CAがCAが認定する意思があると主題と評価する暗号化 /キー契約アルゴリズムのリストを取得するためにクライアントが使用することができます。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 3}, < absent >\nGenRep:    {id-it 3}, SEQUENCE SIZE (1..MAX) OF\n                        AlgorithmIdentifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: In case several elliptic curves are supported, several id-ecPublicKey elements as defined in [RFC5480] need to be given, one per named curve.",
      "ja": "注：いくつかの楕円曲線がサポートされている場合、[RFC5480]で定義されているいくつかのID-EcpublicKey要素を指定された曲線ごとに与えられる必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.19.4. Preferred Symmetric Algorithm",
      "section_title": true,
      "ja": "5.3.19.4. 優先対称アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get the CA-preferred symmetric encryption algorithm for any confidential information that needs to be exchanged between the end entity and the CA (for example, if the end entity wants to send its private decryption key to the CA for archival purposes).",
      "ja": "これは、クライアントが使用して、最終エンティティとCAの間で交換する必要がある機密情報に対してCA優先対称暗号化アルゴリズムを取得することができます（たとえば、最終エンティティがアーカイブの目的でCAにプライベート復号化キーを送信したい場合）。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 4}, < absent >\nGenRep:    {id-it 4}, AlgorithmIdentifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.5. Updated CA Key Pair",
      "section_title": true,
      "ja": "5.3.19.5. CAキーペアを更新しました"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the CA to announce a CA key update event.",
      "ja": "これは、CAによってCAキーアップデートイベントを発表するために使用できます。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 18}, RootCaKeyUpdateValue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "See Section 5.3.13 for details of CA key update announcements.",
      "ja": "CAキーアップデートアナウンスの詳細については、セクション5.3.13を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.6. CRL",
      "section_title": true,
      "ja": "5.3.19.6. CRL"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get a copy of the latest CRL.",
      "ja": "これは、クライアントが最新のCRLのコピーを取得するために使用できます。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 6}, < absent >\nGenRep:    {id-it 6}, CertificateList",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.7. Unsupported Object Identifiers",
      "section_title": true,
      "ja": "5.3.19.7. サポートされていないオブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "This is used by the server to return a list of object identifiers that it does not recognize or support from the list submitted by the client.",
      "ja": "これは、クライアントが提出したリストから認識またはサポートしていないオブジェクト識別子のリストを返すためにサーバーによって使用されます。"
    },
    {
      "indent": 5,
      "text": "GenRep:    {id-it 7}, SEQUENCE SIZE (1..MAX) OF OBJECT IDENTIFIER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.8. Key Pair Parameters",
      "section_title": true,
      "ja": "5.3.19.8. キーペアパラメーター"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the end entity to request the domain parameters to use for generating the key pair for certain public-key algorithms. It can be used, for example, to request the appropriate P, Q, and G to generate the DH/DSA key or to request a set of well-known elliptic curves.",
      "ja": "これは、特定のパブリックキーアルゴリズムのキーペアを生成するために使用するドメインパラメーターを要求するために、End Entityによって使用される場合があります。たとえば、適切なp、q、gを要求してDH/DSAキーを生成するか、よく知られている楕円曲線のセットを要求するために使用できます。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 10}, OBJECT IDENTIFIER -- (Algorithm object-id)\nGenRep:    {id-it 11}, AlgorithmIdentifier | < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An absent infoValue in the GenRep indicates that the algorithm specified in GenMsg is not supported.",
      "ja": "GenRepに存在しない情報値は、GenMSGで指定されたアルゴリズムがサポートされていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "End entities MUST ensure that the parameters are acceptable to it and that the GenRep message is authenticated (to avoid substitution attacks).",
      "ja": "最終エンティティは、パラメーターがそれに受け入れられ、GenRepメッセージが認証されていることを確認する必要があります（代替攻撃を避けるため）。"
    },
    {
      "indent": 0,
      "text": "5.3.19.9. Revocation Passphrase",
      "section_title": true,
      "ja": "5.3.19.9. 取り消しパスフレーズ"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the end entity to send a passphrase to a CA/RA for the purpose of authenticating a later revocation request (in the case that the appropriate signing private key is no longer available to authenticate the request). See Appendix B for further details on the use of this mechanism.",
      "ja": "これは、後の取り消し要求を認証する目的で、パスフレーズをCA/RAに送信するためにEndエンティティによって使用される場合があります（適切な署名秘密キーがリクエストを認証するためにもはや利用できなくなる場合）。このメカニズムの使用に関する詳細については、付録Bを参照してください。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 12}, EncryptedKey\nGenRep:    {id-it 12}, < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The use of EncryptedKey is described in Section 5.2.2.",
      "ja": "暗号化されたキーの使用については、セクション5.2.2で説明しています。"
    },
    {
      "indent": 0,
      "text": "5.3.19.10. ImplicitConfirm",
      "section_title": true,
      "ja": "5.3.19.10. 暗黙的なこと"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.1.1 for the definition and use of {id-it 13}.",
      "ja": "{id-it 13}の定義と使用については、セクション5.1.1.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.11. ConfirmWaitTime",
      "section_title": true,
      "ja": "5.3.19.11. 確認waittime"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.1.2 for the definition and use of {id-it 14}.",
      "ja": "{id-it 14}の定義と使用については、セクション5.1.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.12. Original PKIMessage",
      "section_title": true,
      "ja": "5.3.19.12. オリジナルのpkimessage"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.1.3 for the definition and use of {id-it 15}.",
      "ja": "{id-it 15}の定義と使用については、セクション5.1.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.13. Supported Language Tags",
      "section_title": true,
      "ja": "5.3.19.13. サポートされている言語タグ"
    },
    {
      "indent": 3,
      "text": "This MAY be used to determine the appropriate language tag [RFC5646] to use in subsequent messages. The sender sends its list of supported languages (in order of most to least preferred); the receiver returns the one it wishes to use. (Note: Each UTF8String MUST include a language tag.) If none of the offered tags are supported, an error MUST be returned.",
      "ja": "これは、後続のメッセージで使用する適切な言語タグ[RFC5646]を決定するために使用できます。送信者は、サポートされている言語のリストを送信します（最大の順に最小限の順に）。レシーバーは、使用したいものを返します。（注：各UTF8STRINGには言語タグを含める必要があります。）提供されたタグがサポートされていない場合、エラーを返す必要があります。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 16}, SEQUENCE SIZE (1..MAX) OF UTF8String\nGenRep:    {id-it 16}, SEQUENCE SIZE (1) OF UTF8String",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.14. CA Certificates",
      "section_title": true,
      "ja": "5.3.19.14. CA証明書"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get CA certificates.",
      "ja": "これは、CA証明書を取得するためにクライアントが使用できます。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 17}, < absent >\nGenRep:    {id-it 17}, SEQUENCE SIZE (1..MAX) OF\n                         CMPCertificate | < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.15. Root CA Update",
      "section_title": true,
      "ja": "5.3.19.15. ルートCAアップデート"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get an update of a root CA certificate, which is provided in the body of the request message. In contrast to the ckuann message, this approach follows the request/ response model.",
      "ja": "これは、クライアントがリクエストメッセージの本文で提供されるルートCA証明書の更新を取得するために使用できます。ckuannメッセージとは対照的に、このアプローチはリクエスト/応答モデルに従います。"
    },
    {
      "indent": 3,
      "text": "The end entity SHOULD reference its current trust anchor in RootCaCertValue in the request body, giving the root CA certificate if available.",
      "ja": "End Entityは、リクエスト本体のrootCaCertValueの現在の信頼アンカーを参照し、利用可能な場合はルートCA証明書を提供する必要があります。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 20}, RootCaCertValue | < absent >\nGenRep:    {id-it 18}, RootCaKeyUpdateValue | < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "RootCaCertValue ::= CMPCertificate\n\nRootCaKeyUpdateValue ::= RootCaKeyUpdateContent\n\nRootCaKeyUpdateContent ::= SEQUENCE {\n   newWithNew              CMPCertificate,\n   newWithOld          [0] CMPCertificate OPTIONAL,\n   oldWithNew          [1] CMPCertificate OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: In contrast to CAKeyUpdAnnContent (which was deprecated with pvno cmp2021), RootCaKeyUpdateContent offers omitting newWithOld and oldWithNew, depending on the needs of the end entity.",
      "ja": "注：cakeyupdanncontent（PVNO CMP2021で非推奨）とは対照的に、rootcakeyupdateContentは、最終エンティティのニーズに応じて、NewWitholdとOldwithNewを省略します。"
    },
    {
      "indent": 0,
      "text": "5.3.19.16. Certificate Request Template",
      "section_title": true,
      "ja": "5.3.19.16. 証明書リクエストテンプレート"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get a template containing requirements for certificate request attributes and extensions. The controls id-regCtrl-algId and id-regCtrl-rsaKeyLen MAY contain details on the types of subject public keys the CA is willing to certify.",
      "ja": "これは、クライアントが証明書要求属性と拡張機能の要件を含むテンプレートを取得するために使用できます。CONTROLSS ID-REGCTRL-ALGIDおよびID-REGCTRL-RSAKEYLENには、CAが認定する意思がある対象のパブリックキーの種類に関する詳細が含まれている場合があります。"
    },
    {
      "indent": 3,
      "text": "The id-regCtrl-algId control MAY be used to identify a cryptographic algorithm (see Section 4.1.2.7 of [RFC5280]) other than rsaEncryption. The algorithm field SHALL identify a cryptographic algorithm. The contents of the optional parameters field will vary according to the algorithm identified. For example, when the algorithm is set to id-ecPublicKey, the parameters identify the elliptic curve to be used; see [RFC5480].",
      "ja": "ID-regctrl-algidコントロールを使用して、rsaencryption以外の暗号化アルゴリズム（[RFC5280]のセクション4.1.2.7を参照）を識別できます。アルゴリズムフィールドは、暗号化アルゴリズムを特定するものとします。オプションのパラメーターフィールドの内容は、特定されたアルゴリズムによって異なります。たとえば、アルゴリズムがid-ecpublickeyに設定されている場合、パラメーターは使用する楕円曲線を識別します。[RFC5480]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note: The client may specify a profile name in the certProfile field (see Section 5.1.1.4).",
      "ja": "注：クライアントは、CertProfileフィールドにプロファイル名を指定できます（セクション5.1.1.4を参照）。"
    },
    {
      "indent": 3,
      "text": "The id-regCtrl-rsaKeyLen control SHALL be used for algorithm rsaEncryption and SHALL contain the intended modulus bit length of the RSA key.",
      "ja": "Id-regctrl-rsakeylenコントロールは、アルゴリズムrsaencryptionに使用され、RSAキーの意図した弾性弾性ビット長を含めるものとします。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 19}, < absent >\nGenRep:    {id-it 19}, CertReqTemplateContent | < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertReqTemplateValue  ::= CertReqTemplateContent\n\nCertReqTemplateContent ::= SEQUENCE {\n   certTemplate           CertTemplate,\n   keySpec                Controls OPTIONAL }\n\nControls  ::= SEQUENCE SIZE (1..MAX) OF AttributeTypeAndValue\n\nid-regCtrl-algId OBJECT IDENTIFIER ::= { iso(1)\n   identified-organization(3) dod(6) internet(1) security(5)\n   mechanisms(5) pkix(7) pkip(5) regCtrl(1) 11 }\n\nAlgIdCtrl ::= AlgorithmIdentifier{ALGORITHM, {...}}\n\nid-regCtrl-rsaKeyLen OBJECT IDENTIFIER ::= { iso(1)\n   identified-organization(3) dod(6) internet(1) security(5)\n   mechanisms(5) pkix(7) pkip(5) regCtrl(1) 12 }\n\nRsaKeyLenCtrl ::= INTEGER (1..MAX)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The CertReqTemplateValue contains the prefilled certTemplate to be used for a future certificate request. The publicKey field in the certTemplate MUST NOT be used. In case the PKI management entity wishes to specify supported public-key algorithms, the keySpec field MUST be used. One AttributeTypeAndValue per supported algorithm or RSA key length MUST be used.",
      "ja": "certreqTemplateValueには、将来の証明書リクエストに使用される事前に済む証明書が含まれています。CERTTEMPLATE内のPublicKeyフィールドを使用してはなりません。PKI管理エンティティがサポートされているパブリックキーアルゴリズムの指定を希望する場合は、キーセペックフィールドを使用する必要があります。サポートされているアルゴリズムまたはRSAキーの長さごとに1つの属性タイプアンドバリューを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The controls for an ASN.1 type are defined in Section 6 of CRMF [RFC4211].",
      "ja": "注：ASN.1タイプのコントロールは、CRMF [RFC4211]のセクション6で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.3.19.17. CRL Update Retrieval",
      "section_title": true,
      "ja": "5.3.19.17. CRL更新検索"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get new CRLs, specifying the source of the CRLs and the thisUpdate value of the latest CRL it already has, if available. A CRL source is given either by a DistributionPointName or the GeneralNames of the issuing CA. The DistributionPointName should be treated as an internal pointer to identify a CRL that the server already has and not as a way to ask the server to fetch CRLs from external locations. The server SHALL only provide those CRLs that are more recent than the ones indicated by the client.",
      "ja": "これは、クライアントが新しいCRLSを取得するために使用する場合があり、CRLSのソースと、利用可能な場合は既に持っている最新のCRLのThisupDate値を指定できます。CRLソースは、DistributionPointNameまたは発行の一般名のいずれかによって与えられます。DistributionPointNameは、サーバーが既に持っているCRLを識別するための内部ポインターとして扱われ、サーバーに外部の場所からCRLを取得するように依頼する方法としてではありません。サーバーは、クライアントが示すものよりも最近のCRLのみを提供するものとします。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 22}, SEQUENCE SIZE (1..MAX) OF CRLStatus\nGenRep:    {id-it 23}, SEQUENCE SIZE (1..MAX) OF\n                         CertificateList  |  < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CRLSource ::= CHOICE {\n   dpn          [0] DistributionPointName,\n   issuer       [1] GeneralNames }\n\nCRLStatus ::= SEQUENCE {\n   source       CRLSource,\n   thisUpdate   Time OPTIONAL }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.18. KEM Ciphertext",
      "section_title": true,
      "ja": "5.3.19.18. Kem ciphertext"
    },
    {
      "indent": 3,
      "text": "This MAY be used by a PKI entity to get the KEM ciphertext for MAC-based message protection using KEM (see Section 5.1.3.4).",
      "ja": "これは、KEMを使用したMacベースのメッセージ保護用のKEM Ciphertextを取得するためにPKIエンティティによって使用される場合があります（セクション5.1.3.4を参照）。"
    },
    {
      "indent": 3,
      "text": "The PKI entity that possesses a KEM key pair can request the ciphertext by sending an InfoTypeAndValue structure of type KemCiphertextInfo where the infoValue is absent. The ciphertext can be provided in the following genp message with an InfoTypeAndValue structure of the same type.",
      "ja": "KEMキーペアを所有するPKIエンティティは、情報バリューが存在しない場合にkemciphertextinfoのタイプのインフォタイプアンドバリュー構造を送信することにより、ciphertextを要求できます。暗号文は、同じタイプのInfotypeandValue構造を持つ次のGenpメッセージで提供できます。"
    },
    {
      "indent": 5,
      "text": "GenMsg:    {id-it 24}, < absent >\nGenRep:    {id-it 24}, KemCiphertextInfo",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "KemCiphertextInfo ::= SEQUENCE {\n  kem              AlgorithmIdentifier{KEM-ALGORITHM, {...}},\n  ct               OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "kem is the algorithm identifier of the KEM algorithm, and any associated parameters, used to generate the ciphertext (ct).",
      "ja": "KEMは、kemアルゴリズムのアルゴリズム識別子であり、関連するパラメーターであり、ciphertext（CT）を生成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "ct is the ciphertext output from the KEM Encapsulate function.",
      "ja": "CTは、KEM Encapsulate関数からの暗号文の出力です。"
    },
    {
      "indent": 3,
      "text": "Note: These InfoTypeAndValue structures can also be transferred in the generalInfo field of the PKIHeader in messages of other types (see Section 5.1.1.5).",
      "ja": "注：これらのInfotypeandValue構造は、他のタイプのメッセージでPKIHeaderのGeneralINFOフィールドでも転送することができます（セクション5.1.1.5を参照）。"
    },
    {
      "indent": 0,
      "text": "5.3.20. PKI General Response Content",
      "section_title": true,
      "ja": "5.3.20. PKI一般応答コンテンツ"
    },
    {
      "indent": 5,
      "text": "GenRepContent ::= SEQUENCE OF InfoTypeAndValue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Examples of GenReps that MAY be supported include those listed in the subsections of Section 5.3.19.",
      "ja": "サポートできるGenRepsの例には、セクション5.3.19のサブセクションにリストされている例が含まれます。"
    },
    {
      "indent": 0,
      "text": "5.3.21. Error Message Content",
      "section_title": true,
      "ja": "5.3.21. エラーメッセージコンテンツ"
    },
    {
      "indent": 3,
      "text": "This data structure MAY be used by an end entity, CA, or RA to convey error information and by a PKI management entity to initiate delayed delivery of responses.",
      "ja": "このデータ構造は、エラー情報を伝えるためにエンドエンティティ、CA、またはRAによって、およびPKI管理エンティティが応答の遅延配信を開始するために使用できます。"
    },
    {
      "indent": 5,
      "text": "ErrorMsgContent ::= SEQUENCE {\n   pKIStatusInfo          PKIStatusInfo,\n   errorCode              INTEGER           OPTIONAL,\n   errorDetails           PKIFreeText       OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This message MAY be generated at any time during a PKI transaction. If the client sends this request, the server MUST respond with a pkiconf response or another error message if any part of the header is not valid.",
      "ja": "このメッセージは、PKIトランザクション中にいつでも生成される場合があります。クライアントがこのリクエストを送信した場合、ヘッダーの一部が無効である場合、サーバーはPKICONF応答または別のエラーメッセージで応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "In case a PKI management entity sends an error message to the end entity with the pKIStatusInfo field containing the status \"waiting\", the end entity SHOULD initiate polling as described in Section 5.3.22. If the end entity does not initiate polling, both sides MUST treat this message as the end of the transaction (if a transaction is in progress).",
      "ja": "PKI管理エンティティがステータス「待機」を含むPkistatusInfoフィールドを使用してエラーエンティティにエラーメッセージを送信した場合、最終エンティティはセクション5.3.22で説明されているようにポーリングを開始する必要があります。最終エンティティが投票を開始しない場合、双方はこのメッセージをトランザクションの終わりとして扱う必要があります（トランザクションが進行中の場合）。"
    },
    {
      "indent": 3,
      "text": "If protection is desired on the message, the client MUST protect it using the same technique (i.e., signature or MAC) as the starting message of the transaction. The CA MUST always sign it with a signature key.",
      "ja": "メッセージに保護が必要な場合、クライアントは、トランザクションの開始メッセージと同じ手法（つまり、署名またはMac）を使用してそれを保護する必要があります。CAは常に署名キーで署名する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.22. Polling Request and Response",
      "section_title": true,
      "ja": "5.3.22. ポーリングリクエストと応答"
    },
    {
      "indent": 3,
      "text": "This pair of messages is intended to handle scenarios in which the client needs to poll the server to determine the status of an outstanding response (i.e., when the \"waiting\" PKIStatus has been received).",
      "ja": "このメッセージのペアは、クライアントがサーバーを投票して未解決の応答のステータスを決定する必要があるシナリオを処理することを目的としています（つまり、「待機」Pkistatusが受信されたとき）。"
    },
    {
      "indent": 5,
      "text": "PollReqContent ::= SEQUENCE OF SEQUENCE {\n   certReqId    INTEGER }\n\nPollRepContent ::= SEQUENCE OF SEQUENCE {\n   certReqId    INTEGER,\n   checkAfter   INTEGER,  -- time in seconds\n   reason       PKIFreeText OPTIONAL }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unless implicit confirmation has been requested and granted, in response to an ir, cr, p10cr, kur, krr, or ccr request message, polling is initiated with an ip, cp, kup, krp, or ccp response message containing status \"waiting\". For any type of request message, polling can be initiated with an error response message with status \"waiting\". The following clauses describe how polling messages are used. It is assumed that multiple certConf messages can be sent during transactions. There will be one sent in response to each ip, cp, kup, krp, or ccp that contains a CertStatus for an issued certificate.",
      "ja": "IR、CR、P10CR、KUR、KRR、またはCCRリクエストメッセージに応じて、暗黙の確認が要求され、付与されていない限り、IP、CP、KUP、KRP、またはCCP応答メッセージを「待機」を含むCCP応答メッセージでポーリングが開始されます。あらゆるタイプのリクエストメッセージの場合、ステータス「待機」を備えたエラー応答メッセージでポーリングを開始できます。次の条項では、ポーリングメッセージの使用方法について説明します。トランザクション中に複数のCERTCONFメッセージを送信できると想定されています。発行された証明書の証明書を含む各IP、CP、KUP、KRP、またはCCPに応答して送信されます。"
    },
    {
      "indent": 8,
      "text": "1. In response to an ip, cp, kup, krp, or ccp message, an end entity will send a certConf for all issued certificates and expect a pkiconf for each certConf. An end entity will send a pollReq message in response to each CertResponse element of an ip, cp, or kup message with status \"waiting\" and in response to an error message with status \"waiting\". Its certReqId MUST be either the index of a CertResponse data structure with status \"waiting\" or -1 referring to the complete response.",
      "ja": "1. IP、CP、KUP、KRP、またはCCPメッセージに応じて、終了エンティティはすべての発行された証明書にCERTCONFを送信し、各CERTCONFにPKICONFを期待します。End Entityは、IP、CP、またはKUPメッセージの各Certresponse要素に応答して、「待機」を伴うPollReqメッセージを送信し、ステータス「待機」を持つエラーメッセージに応答します。そのcertreqidは、ステータス「待機」を伴うcertresponseデータ構造のインデックスまたは完全な応答を指す-1でなければなりません。"
    },
    {
      "indent": 8,
      "text": "2. In response to a pollReq, a CA/RA will return an ip, cp, kup, krp, or ccp if one or more of the still pending requested certificates are ready or the final response to some other type of request is available; otherwise, it will return a pollRep.",
      "ja": "2. Pollreqに応じて、CA/RAは、保留中の要求された証明書の1つ以上が準備ができている場合、または他のタイプのリクエストに対する最終的な応答が利用可能な場合、CA/RAはIP、CP、KUP、KRP、またはCCPを返します。それ以外の場合は、Pollrepを返します。"
    },
    {
      "indent": 8,
      "text": "3. If the end entity receives a pollRep, it will wait for at least the number of seconds given in the checkAfter field before sending another pollReq.",
      "ja": "3. End EntityがPollrepを受信した場合、別のPollreqを送信する前に、Checkafterフィールドで与えられた少なくとも秒数を待ちます。"
    },
    {
      "indent": 12,
      "text": "Note that the checkAfter value heavily depends on the certificate management environment. There are different possible reasons for a delayed delivery of response messages, e.g., high load on the server's backend, offline transfer of messages between two PKI management entities, or required RA operator approval. Therefore, the checkAfter time can vary greatly. This should also be considered by the transfer protocol.",
      "ja": "Checkafter値は、証明書管理環境に大きく依存することに注意してください。応答メッセージの配信が遅れた理由は、サーバーのバックエンドの高負荷、2つのPKI管理エンティティ間のメッセージのオフライン転送、または必要なRAオペレーターの承認など、さまざまな理由があります。したがって、チェックアフター時間は大きく異なる場合があります。これは、転送プロトコルでも考慮する必要があります。"
    },
    {
      "indent": 8,
      "text": "4. If the end entity receives an ip, cp, kup, krp, or ccp, then it will be treated in the same way as the initial response; if it receives any other response, then this will be treated as the final response to the original request.",
      "ja": "4. 最終エンティティがIP、CP、KUP、KRP、またはCCPを受信すると、初期応答と同じ方法で扱われます。他の応答を受信した場合、これは元のリクエストに対する最終的な応答として扱われます。"
    },
    {
      "indent": 3,
      "text": "The following client-side state machine describes polling for individual CertResponse elements at the example of an ir request message.",
      "ja": "次のクライアント側の状態マシンでは、IRリクエストメッセージの例で個々のcertresponse要素のポーリングについて説明しています。"
    },
    {
      "indent": 4,
      "text": "                           START\n                             |\n                             v\n                          Send ir\n                             | ip\n                             v\n                        Check status\n                        of returned <------------------------+\n                           certs                             |\n                             |                               |\n   +------------------------>|<------------------+           |\n   |                         |                   |           |\n   |        (issued)         v       (waiting)   |           |\n Add to <----------- Check CertResponse ------> Add to       |\nconf list           for each certificate      pending list   |\n                            / \\                              |\n                           /   \\  (empty conf list)          |\n              (conf list) /     \\                            |\n                         /       \\              ip           |\n                        /         \\        +-----------------+\n  (empty pending list) V           V       |    pollRep\n    END <---- Send certConf        Send pollReq---------->Wait\n                     |                 ^   ^               |\n                     |                 |   |               |\n                     +-----------------+   +---------------+\n                        (pending list)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the following exchange, the end entity is enrolling for two certificates in one request.",
      "ja": "次の交換では、最終エンティティは1つのリクエストで2つの証明書に登録しています。"
    },
    {
      "indent": 3,
      "text": "Step# End entity                       PKI\n---------------------------------------------------------------------\n  1   format ir\n  2                   --> ir       -->\n  3                                    handle ir\n  4                                    manual intervention is\n                                         required for both certs\n  5                   <-- ip       <--\n  6   process ip\n  7   format pollReq\n  8                   --> pollReq  -->\n  9                                    check status of cert requests,\n                                         certificates not ready\n 10                                    format pollRep\n 11                   <-- pollRep  <--\n 12   wait\n 13   format pollReq\n 14                   --> pollReq  -->\n 15                                    check status of cert requests,\n                                         one certificate is ready\n 16                                    format ip\n 17                   <-- ip       <--\n 18   handle ip\n 19   format certConf\n 20                   --> certConf -->\n 21                                    handle certConf\n 22                                    format ack\n 23                   <-- pkiconf  <--\n 24   format pollReq\n 25                   --> pollReq  -->\n 26                                    check status of certificate,\n                                         certificate is ready\n 27                                    format ip\n 28                   <-- ip       <--\n 29   handle ip\n 30   format certConf\n 31                   --> certConf -->\n 32                                    handle certConf\n 33                                    format ack\n 34                   <-- pkiconf  <--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following client-side state machine describes polling for a complete response message.",
      "ja": "次のクライアント側の状態マシンは、完全な応答メッセージのポーリングについて説明しています。"
    },
    {
      "indent": 4,
      "text": "                               Start\n                                 |\n                                 | Send request\n                                 v\n            +----------- Receive response ------------+\n            |                                         |\n            | ip/cp/kup/krp/ccp/error with            | other\n            | status \"waiting\"                        | response\n            |                                         |\n            v                                         |\n+------> Polling                                      |\n|           |                                         |\n|           | Send pollReq                            |\n|           | Receive response                        |\n|           |                                         |\n|           v                                         |\n+-----------+------------------->+<-------------------+\n    pollRep   other response     |\n                                 v\n                           Handle response\n                                 |\n                                 v\n                                End",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the following exchange, the end entity is sending a general message request, and the response is delayed by the server.",
      "ja": "次の交換では、最終エンティティが一般的なメッセージ要求を送信しており、応答はサーバーによって遅れます。"
    },
    {
      "indent": 3,
      "text": "Step# End entity                       PKI\n---------------------------------------------------------------------\n  1   format genm\n  2                  --> genm    -->\n  3                                 handle genm\n  4                                 delay in response is necessary\n  5                                 format error message \"waiting\"\n                                      with certReqId set to -1\n  6                  <-- error   <--\n  7   process error\n  8   format pollReq\n  9                  --> pollReq -->\n 10                                 check status of original request,\n                                      general message response not\n                                      ready\n 11                                 format pollRep\n 12                  <-- pollRep <--\n 13   wait\n 14   format pollReq\n 15                  --> pollReq -->\n 16                                 check status of original request,\n                                      general message response is\n                                      ready\n 17                                 format genp\n 18                  <-- genp    <--\n 19   handle genp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Mandatory PKI Management Functions",
      "section_title": true,
      "ja": "6. 必須のPKI管理機能"
    },
    {
      "indent": 3,
      "text": "Some of the PKI management functions outlined in Section 3.1 are described in this section.",
      "ja": "セクション3.1で概説されているPKI管理関数の一部は、このセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "This section deals with functions that are \"mandatory\" in the sense that all end entity and CA/RA implementations MUST be able to provide the functionality described. This part is effectively the profile of the PKI management functionality that MUST be supported. Note, however, that the management functions described in this section do not need to be accomplished using the PKI messages defined in Section 5 if alternate means are suitable for a given environment. See Section 7 of [RFC9483] and Appendix C for profiles of the PKIMessage structures that MUST be supported for specific use cases.",
      "ja": "このセクションでは、すべての最終エンティティとCA/RAの実装が説明されている機能を提供できる必要があるという意味で、「必須」の関数を扱います。この部分は、効果的にサポートする必要があるPKI管理機能のプロファイルです。ただし、このセクションで説明した管理機能は、特定の環境に適している場合、セクション5で定義されたPKIメッセージを使用して達成する必要はないことに注意してください。特定のユースケースでサポートする必要があるpkimessage構造のプロファイルについては、[RFC9483]のセクション7および付録Cを参照してください。"
    },
    {
      "indent": 0,
      "text": "6.1. Root CA Initialization",
      "section_title": true,
      "ja": "6.1. ルートCA初期化"
    },
    {
      "indent": 3,
      "text": "[See Section 3.1.1.2 for this document's definition of \"root CA\".]",
      "ja": "[このドキュメントの「ルートCA」の定義については、セクション3.1.1.2を参照してください。]"
    },
    {
      "indent": 3,
      "text": "If a newly created root CA is at the top of a PKI hierarchy, it usually produces a \"self-certificate\", which is a certificate structure with the profile defined for the \"newWithNew\" certificate issued following a root CA key update.",
      "ja": "新しく作成されたルートCAがPKI階層の上部にある場合、通常、「自己認証」を生成します。これは、ルートCAキーアップデートに続いて発行された「NewWithNew」証明書のプロファイルを持つ証明書構造です。"
    },
    {
      "indent": 3,
      "text": "In order to make the CA's self-certificate useful to end entities that do not acquire the self-certificate via \"out-of-band\" means, the CA must also produce a fingerprint for its certificate. End entities that acquire this fingerprint securely via some \"out-of-band\" means can then verify the CA's self-certificate and, hence, the other attributes contained therein.",
      "ja": "CAの自己認証を有用にするためには、「帯域外」平均を介して自己認証を取得しないエンティティを終了するために、CAは証明書の指紋を作成する必要があります。いくつかの「帯域外」手段を介してこの指紋を安全に取得するエンティティは、CAの自己認証、したがって、そこに含まれる他の属性を検証できます。"
    },
    {
      "indent": 3,
      "text": "The data structure used to carry the fingerprint may be the OOBCertHash (see Section 5.2.5).",
      "ja": "指紋を運ぶために使用されるデータ構造は、obcerthashである可能性があります（セクション5.2.5を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2. Root CA Key Update",
      "section_title": true,
      "ja": "6.2. ルートCAキーアップデート"
    },
    {
      "indent": 3,
      "text": "CA keys (as all other keys) have a finite lifetime and will have to be updated on a periodic basis. The certificates NewWithNew, NewWithOld, and OldWithNew (see Section 4.4.1) MAY be issued by the CA to aid existing end entities who hold the current root CA certificate (OldWithOld) to transition securely to the new root CA certificate (NewWithNew) and to aid new end entities who will hold NewWithNew to acquire OldWithOld securely for verification of existing data.",
      "ja": "CAキー（他のすべてのキーとして）には有限の寿命があり、定期的に更新する必要があります。NewWithNew、NewWithold、およびOldwithNew（セクション4.4.1を参照）は、現在のルートCA証明書（OldWithold）を保持している既存のエンティティ（NewWithnew）にしっかりと移行し、NewWithold Securelyの既存のデータを獲得するためにNewWithold Securelyのためにnewithold Securelyを取得するためにNewWithold Securelyの獲得を支援する既存の最終エンティティを支援するために、CAによって発行される場合があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Subordinate CA Initialization",
      "section_title": true,
      "ja": "6.3. 下位CA初期化"
    },
    {
      "indent": 3,
      "text": "[See Section 3.1.1.2 for this document's definition of \"subordinate CA\".]",
      "ja": "[このドキュメントの「下位CA」の定義については、セクション3.1.1.2を参照してください。]"
    },
    {
      "indent": 3,
      "text": "From the perspective of PKI management protocols, the initialization of a subordinate CA is the same as the initialization of an end entity. The only difference is that the subordinate CA must also produce an initial revocation list.",
      "ja": "PKI管理プロトコルの観点から見ると、下位CAの初期化は終了エンティティの初期化と同じです。唯一の違いは、下位CAが最初の取り消しリストも作成する必要があることです。"
    },
    {
      "indent": 0,
      "text": "6.4. CRL Production",
      "section_title": true,
      "ja": "6.4. CRL生産"
    },
    {
      "indent": 3,
      "text": "Before issuing any certificates, a newly established CA (which issues CRLs) must produce \"empty\" versions of each CRL, which are to be periodically produced.",
      "ja": "証明書を発行する前に、新しく確立されたCA（CRLを発行する）は、定期的に作成される各CRLの「空の」バージョンを作成する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5. PKI Information Request",
      "section_title": true,
      "ja": "6.5. PKI情報リクエスト"
    },
    {
      "indent": 3,
      "text": "When a PKI entity (CA, RA, or end entity) wishes to acquire information about the current status of a CA, it MAY send that CA a request for such information.",
      "ja": "PKIエンティティ（CA、RA、またはENDエンティティ）がCAの現在のステータスに関する情報を取得したい場合、CAのCAにそのような情報のリクエストを送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "The CA MUST respond to the request by providing (at least) all of the information requested by the requester. If some of the information cannot be provided, then an error must be conveyed to the requester.",
      "ja": "CAは、要求者が要求したすべての情報を（少なくとも）提供することにより、要求に応答する必要があります。情報の一部を提供できない場合は、リクエスターにエラーを伝える必要があります。"
    },
    {
      "indent": 3,
      "text": "If PKIMessages are used to request and supply this PKI information, then the request MUST be the GenMsg message, the response MUST be the GenRep message, and the error MUST be the Error message. These messages are protected using a MAC based on shared secret information (e.g., password-based MAC; see Section 6.1 of \"CMP Algorithms\" [RFC9481]) or using any asymmetric authentication means such as a signature (if the end entity has an existing certificate).",
      "ja": "このPKI情報を要求して提供するためにpkimessagesを使用している場合、リクエストはGenmsgメッセージでなければならず、応答はGenRepメッセージでなければならず、エラーはエラーメッセージでなければなりません。これらのメッセージは、共有された秘密情報（パスワードベースのMAC、「CMPアルゴリズム」のセクション6.1を参照[RFC9481]を参照）に基づいてMACを使用して保護されます。"
    },
    {
      "indent": 0,
      "text": "6.6. Cross-Certification",
      "section_title": true,
      "ja": "6.6. 相互認証"
    },
    {
      "indent": 3,
      "text": "The requester CA is the CA that will become the subject of the cross-certificate; the responder CA will become the issuer of the cross-certificate.",
      "ja": "リクエスターCAは、クロス認証の対象となるCAです。Responder CAは、クロス認証の発行者になります。"
    },
    {
      "indent": 3,
      "text": "The requester CA must be \"up and running\" before initiating the cross-certification operation.",
      "ja": "リクエスターCAは、相互認定操作を開始する前に「上昇している」必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.1. One-Way Request-Response Scheme",
      "section_title": true,
      "ja": "6.6.1. 一元配置リクエスト応答スキーム"
    },
    {
      "indent": 3,
      "text": "The cross-certification scheme is essentially a one-way operation; that is, when successful, this operation results in the creation of one new cross-certificate. If the requirement is that cross-certificates be created in \"both directions\", then each CA, in turn, must initiate a cross-certification operation (or use another scheme).",
      "ja": "相互認証スキームは、本質的に一方向の操作です。つまり、成功すると、この操作により、1つの新しいクロス認証が作成されます。要件が「両方方向」にクロス認証が作成される場合、各CAは、相互認定操作を開始する（または別のスキームを使用）する必要があります。"
    },
    {
      "indent": 3,
      "text": "This scheme is suitable where the two CAs in question can already verify each other's signatures (they have some common points of trust) or where there is an out-of-band verification of the origin of the certification request.",
      "ja": "このスキームは、問題の2つのCAが互いの署名（いくつかの共通の信頼ポイントがある）をすでに検証できる場合、または認証要求の起源の帯域外検証がある場合に適しています。"
    },
    {
      "indent": 3,
      "text": "Detailed Description:",
      "ja": "詳細な説明："
    },
    {
      "indent": 3,
      "text": " Cross-certification is initiated at one CA known as the responder. The CA administrator for the responder identifies the CA it wants to cross-certify and the responder CA equipment generates an authorization code. The responder CA administrator passes this authorization code by out-of-band means to the requester CA administrator. The requester CA administrator enters the authorization code at the requester CA in order to initiate the online exchange.",
      "ja": "相互認証は、レスポンダーとして知られる1つのCAで開始されます。ResponderのCA管理者は、相互認定を取得するCAを識別し、Responder CA機器が認証コードを生成します。Responder CA管理者は、この承認コードを帯域外の手段でリクエスターCA管理者に渡します。Requester CA管理者は、オンライン交換を開始するために、Requester CAに承認コードを入力します。"
    },
    {
      "indent": 3,
      "text": " The authorization code is used for authentication and integrity purposes. This is done by generating a symmetric key based on the authorization code and using the symmetric key for generating MACs on all messages exchanged. (Authentication may alternatively be done using signatures instead of MACs, if the CAs are able to retrieve and validate the required public keys by some means, such as an out-of-band hash comparison.)",
      "ja": "認証コードは、認証と整合性の目的で使用されます。これは、承認コードに基づいて対称キーを生成し、交換されたすべてのメッセージでMACを生成するための対称キーを使用することによって行われます。（CASが帯域外ハッシュ比較など、必要なパブリックキーを何らかの手段で取得および検証できる場合、認証はMacの代わりに署名を使用して行われる場合があります。）"
    },
    {
      "indent": 3,
      "text": " The requester CA initiates the exchange by generating a cross-certification request (ccr) with a fresh random number (requester random number). The requester CA then sends the ccr message to the responder CA. The fields in this message are protected from modification with a MAC based on the authorization code.",
      "ja": "リクエスターCAは、新鮮な乱数（要求者乱数）で相互認証要求（CCR）を生成することにより、交換を開始します。リクエスターCAは、CCRメッセージをレスポンダーCAに送信します。このメッセージのフィールドは、承認コードに基づいてMACを使用して変更から保護されています。"
    },
    {
      "indent": 3,
      "text": " Upon receipt of the ccr message, the responder CA validates the message and the MAC, saves the requester random number, and generates its own random number (responder random number). It then generates (and archives, if desired) a new requester certificate that contains the requester CA public key and is signed with the responder CA signature private key. The responder CA responds with the cross-certification response (ccp) message. The fields in this message are protected from modification with a MAC based on the authorization code.",
      "ja": "CCRメッセージを受信すると、Responder CAはメッセージとMACを検証し、リクエスターの乱数を保存し、独自の乱数（Responder乱数）を生成します。次に、要求者CAの公開キーを含み、Responder CAの署名秘密鍵で署名された新しい要求者証明書を生成（および必要に応じて）生成します（必要に応じて）生成します。Responder CAは、相互認証応答（CCP）メッセージで応答します。このメッセージのフィールドは、承認コードに基づいてMACを使用して変更から保護されています。"
    },
    {
      "indent": 3,
      "text": " Upon receipt of the ccp message, the requester CA validates the message (including the received random numbers) and the MAC. The requester CA responds with the certConf message. The fields in this message are protected from modification with a MAC based on the authorization code. The requester CA MAY write the requester certificate to the Repository as an aid to later certificate path construction.",
      "ja": "CCPメッセージを受信すると、Requester CAはメッセージ（受信した乱数を含む）とMACを検証します。Requester CAは、CERTCONFメッセージで応答します。このメッセージのフィールドは、承認コードに基づいてMACを使用して変更から保護されています。リクエスターCAは、後の証明書パス構築への援助として、リクエスター証明書をリポジトリに書き込むことができます。"
    },
    {
      "indent": 3,
      "text": " Upon receipt of the certConf message, the responder CA validates the message and the MAC and sends back an acknowledgement using the pkiconf message. It MAY also publish the requester certificate as an aid to later path construction.",
      "ja": "CERTCONFメッセージを受信すると、Responder CAはメッセージとMACを検証し、PKICONFメッセージを使用して確認を送信します。また、後のパス構築への援助として、リクエスター証明書を公開することもできます。"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "注："
    },
    {
      "indent": 8,
      "text": "1. The ccr message must contain a \"complete\" certification request; that is, all fields except the serial number (including, e.g., a BasicConstraints extension) must be specified by the requester CA.",
      "ja": "1. CCRメッセージには、「完全な」認定リクエストが含まれている必要があります。つまり、シリアル番号を除くすべてのフィールド（たとえば、基本的な構成拡張を含む）は、リクエスターCAによって指定する必要があります。"
    },
    {
      "indent": 8,
      "text": "2. The ccp message SHOULD contain the verification certificate of the responder CA; if present, the requester CA must then verify this certificate (for example, via the \"out-of-band\" mechanism).",
      "ja": "2. CCPメッセージには、レスポンダーCAの検証証明書を含める必要があります。存在する場合、要求者CAはこの証明書を検証する必要があります（たとえば、「帯域外」メカニズムを介して）。"
    },
    {
      "indent": 3,
      "text": "(A simpler, non-interactive model of cross-certification may also be envisioned, in which the issuing CA acquires the subject CA's public key from some repository, verifies it via some out-of-band mechanism, and creates and publishes the cross-certificate without the subject CA's explicit involvement. This model may be perfectly legitimate for many environments, but since it does not require any protocol message exchanges, its detailed description is outside the scope of this specification.)",
      "ja": "相互認証のよりシンプルで非相互作用しない非対話的モデルも想定される可能性があります。発行CAは、発行CAが被験者CAの公開キーをいくつかのリポジトリから取得し、帯域外メカニズムからいくつかの帯域外のメカニズムを介して検証し、対象CAの明示的な関与なしにクロス認証を作成および公開します。仕様。）"
    },
    {
      "indent": 0,
      "text": "6.7. End Entity Initialization",
      "section_title": true,
      "ja": "6.7. エンティティの初期化を終了します"
    },
    {
      "indent": 3,
      "text": "As with CAs, end entities must be initialized. Initialization of end entities requires at least two steps:",
      "ja": "CASと同様に、最終エンティティを初期化する必要があります。ENDエンティティの初期化には、少なくとも2つのステップが必要です。"
    },
    {
      "indent": 6,
      "text": "* acquisition of PKI information",
      "ja": "* PKI情報の取得"
    },
    {
      "indent": 6,
      "text": "* out-of-band verification of one root-CA public key",
      "ja": "* 1つのルートCA公開キーのバンド外の検証"
    },
    {
      "indent": 3,
      "text": "(Other possible steps include the retrieval of trust condition information and/or out-of-band verification of other CA public keys.)",
      "ja": "（他の考えられる手順には、信頼状態情報の検索および/または他のCAパブリックキーの帯域外検証が含まれます。）"
    },
    {
      "indent": 0,
      "text": "6.7.1. Acquisition of PKI Information",
      "section_title": true,
      "ja": "6.7.1. PKI情報の取得"
    },
    {
      "indent": 3,
      "text": "The information REQUIRED is:",
      "ja": "必要な情報は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* the current root-CA public key",
      "ja": "* 現在のルートCA公開キー"
    },
    {
      "indent": 6,
      "text": "* (if the certifying CA is not a root-CA) the certification path from the root CA to the certifying CA together with appropriate revocation lists",
      "ja": "* （認定CAがルートCAではない場合）適切な取り消しリストと一緒に、ルートCAから認証CAへの認証パス"
    },
    {
      "indent": 6,
      "text": "* the algorithms and algorithm parameters that the certifying CA supports for each relevant usage",
      "ja": "* 認証CAが関連する使用ごとにサポートするアルゴリズムとアルゴリズムパラメーター"
    },
    {
      "indent": 3,
      "text": "Additional information could be required (e.g., supported extensions or CA policy information) in order to produce a certification request that will be successful. However, for simplicity, we do not mandate that the end entity acquires this information via the PKI messages. The end result is simply that some certification requests may fail (e.g., if the end entity wants to generate its own encryption key, but the CA doesn't allow that).",
      "ja": "成功する認定要求を作成するために、追加情報（サポートされている拡張情報やCAポリシー情報など）が必要になる場合があります。ただし、簡単にするために、最終エンティティがPKIメッセージを介してこの情報を取得することを義務付けていません。最終結果は、一部の認証要求が失敗する可能性があることです（たとえば、最終エンティティが独自の暗号化キーを生成したいが、CAはそれを許可しない場合）。"
    },
    {
      "indent": 3,
      "text": "The required information MAY be acquired as described in Section 6.5.",
      "ja": "セクション6.5で説明されているように、必要な情報を取得できます。"
    },
    {
      "indent": 0,
      "text": "6.7.2. Out-of-Band Verification of the Root CA Key",
      "section_title": true,
      "ja": "6.7.2. ルートCAキーのバンド外の検証"
    },
    {
      "indent": 3,
      "text": "An end entity must securely possess the public key of its root CA. One method to achieve this is to provide the end entity with the CA's self-certificate fingerprint via some secure \"out-of-band\" means. The end entity can then securely use the CA's self-certificate.",
      "ja": "最終エンティティは、ルートCAの公開鍵を安全に所有する必要があります。これを達成する1つの方法は、安全な「帯域外」平均を介してCAの自己認証指紋を最終エンティティに提供することです。最終エンティティは、CAの自己認証を安全に使用できます。"
    },
    {
      "indent": 3,
      "text": "See Section 6.1 for further details.",
      "ja": "詳細については、セクション6.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.8. Certificate Request",
      "section_title": true,
      "ja": "6.8. 証明書リクエスト"
    },
    {
      "indent": 3,
      "text": "An initialized end entity MAY request an additional certificate at any time (for any purpose). This request will be made using the certification request (cr) message. If the end entity already possesses a signing key pair (with a corresponding verification certificate), then this cr message will typically be protected by the entity's digital signature. The CA returns the new certificate (if the request is successful) in a CertRepMessage.",
      "ja": "初期化された終了エンティティは、いつでも追加の証明書を要求する場合があります（いかなる目的でも）。このリクエストは、認定リクエスト（CR）メッセージを使用して行われます。End Entityがすでに署名キーペアを持っている場合（対応する検証証明書を使用）、このCRメッセージは通常、エンティティのデジタル署名によって保護されます。CAは、certrepmessageで新しい証明書（リクエストが成功した場合）を返します。"
    },
    {
      "indent": 0,
      "text": "6.9. Key Update",
      "section_title": true,
      "ja": "6.9. キーアップデート"
    },
    {
      "indent": 3,
      "text": "When a key pair is due to expire, the relevant end entity MAY request a key update; that is, it MAY request that the CA issue a new certificate for a new key pair (or, in certain circumstances, a new certificate for the same key pair). The request is made using a key update request (kur) message (referred to, in some environments, as a \"Certificate Update\" operation). If the end entity already possesses a signing key pair (with a corresponding verification certificate), then this message will typically be protected by the entity's digital signature. The CA returns the new certificate (if the request is successful) in a key update response (kup) message, which is syntactically identical to a CertRepMessage.",
      "ja": "キーペアの有効期限が切れる場合、関連する最終エンティティはキーアップデートを要求する場合があります。つまり、CAが新しいキーペアの新しい証明書を発行することを要求する場合があります（または、特定の状況では、同じキーペアの新しい証明書）。リクエストは、キーアップデートリクエスト（KUR）メッセージ（一部の環境では、「証明書の更新」操作と呼ばれます）を使用して行われます。End Entityが既に署名キーペアを持っている場合（対応する検証証明書を使用）、このメッセージは通常、エンティティのデジタル署名によって保護されます。CAは、CertrePmessageと構文的に同一のキーアップデート応答（KUP）メッセージで新しい証明書（リクエストが成功した場合）を返します。"
    },
    {
      "indent": 0,
      "text": "7. Version Negotiation",
      "section_title": true,
      "ja": "7. バージョンの交渉"
    },
    {
      "indent": 3,
      "text": "This section defines the version negotiation used to support older protocols between clients and servers.",
      "ja": "このセクションでは、クライアントとサーバー間の古いプロトコルをサポートするために使用されるバージョンのネゴシエーションを定義します。"
    },
    {
      "indent": 3,
      "text": "If a client knows the protocol version(s) supported by the server (e.g., from a previous PKIMessage exchange or via some out-of-band means), then it MUST send a PKIMessage with the highest version supported by both it and the server. If a client does not know what version(s) the server supports, then it MUST send a PKIMessage using the highest version it supports with the following exception: Version cmp2021 SHOULD only be used if cmp2021 syntax is needed for the request being sent or for the expected response.",
      "ja": "クライアントがサーバーでサポートされているプロトコルバージョンを知っている場合（たとえば、以前のPkimessage Exchangeから、またはいくつかの帯域外の手段による）、ITとサーバーの両方でサポートされている最高バージョンでpkimessageを送信する必要があります。クライアントがサーバーがサポートするバージョンがわからない場合、次の例外を除いてサポートする最高版を使用してPKIMESSAGEを送信する必要があります。バージョンCMP2021は、リクエストが送信されるか、予想される応答に必要な場合にのみ使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Using cmp2000 as the default pvno value is done to avoid extra message exchanges for version negotiation and to foster compatibility with cmp2000 implementations. Version cmp2021 syntax is only needed if a message exchange uses EnvelopedData, hashAlg (in CertStatus), POPOPrivKey with agreeMAC, or ckuann with RootCaKeyUpdateContent.",
      "ja": "注：デフォルトのPVNO値としてCMP2000を使用することは、バージョンの交渉のための追加のメッセージ交換を回避し、CMP2000の実装との互換性を促進するために行われます。バージョンCMP2021構文は、メッセージ交換がEnvelopedData、Hashalg（certStatus）、AmmaryとPopoprivkey、またはrootcakeyupdatecontentを使用したckuannを使用する場合にのみ必要です。"
    },
    {
      "indent": 3,
      "text": "If a server receives a message with a version that it supports, then the version of the response message MUST be the same as the received version. If a server receives a message with a version higher or lower than it supports, then it MUST send back an ErrorMsg with the unsupportedVersion bit set (in the failureInfo field of the pKIStatusInfo). If the received version is higher than the highest supported version, then the version in the error message MUST be the highest version the server supports; if the received version is lower than the lowest supported version, then the version in the error message MUST be the lowest version the server supports.",
      "ja": "サーバーがサポートするバージョンを使用してメッセージを受信した場合、応答メッセージのバージョンは受信バージョンと同じでなければなりません。サーバーがサポートよりも高いまたは低いバージョンのメッセージを受信する場合、サポートされていないバージョンビットセットを使用してErrorMSGを送信する必要があります（pkistatusinfoの故障フィールド）。受信バージョンが最高のサポートバージョンよりも高い場合、エラーメッセージのバージョンはサーバーがサポートする最高版でなければなりません。受信したバージョンが最低サポートバージョンよりも低い場合、エラーメッセージのバージョンはサーバーがサポートする最低バージョンでなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a client gets back an ErrorMsgContent with the unsupportedVersion bit set and a version it supports, then it MAY retry the request with that version.",
      "ja": "クライアントが、サポートされていないバージョンビットセットとサポートするバージョンを使用してErrorMSGContentを取り戻すと、そのバージョンでリクエストを再試行する場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1. Supporting RFC 2510 Implementations",
      "section_title": true,
      "ja": "7.1. RFC 2510実装のサポート"
    },
    {
      "indent": 3,
      "text": "[RFC2510] did not specify the behavior of implementations receiving versions they did not understand since there was only one version in existence. With the introduction of the revision in [RFC4210], the following versioning behavior is recommended.",
      "ja": "[RFC2510]は、存在するバージョンが1つしかなかったため、理解できなかったバージョンを受信する実装の動作を指定しませんでした。[RFC4210]での改訂の導入により、次のバージョン化動作が推奨されます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Clients Talking to RFC 2510 Servers",
      "section_title": true,
      "ja": "7.1.1. RFC 2510サーバーと話しているクライアント"
    },
    {
      "indent": 3,
      "text": "If, after sending a message with a pvno value higher than cmp1999, a client receives an ErrorMsgContent with a version of cmp1999, then it MUST abort the current transaction.",
      "ja": "CMP1999よりも高いPVNO値を持つメッセージを送信した後、クライアントはCMP1999のバージョンでERRORMSGCONTENTを受信した場合、現在のトランザクションを中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client receives a non-error PKIMessage with a version of cmp1999, then it MAY decide to continue the transaction (if the transaction hasn't finished) using the semantics described in [RFC2510]. If it does not choose to do so and the transaction is not finished, then it MUST abort the transaction and send an ErrorMsgContent with a version of cmp1999.",
      "ja": "クライアントがCMP1999のバージョンを使用して非誤差pkimessageを受信した場合、[RFC2510]で説明されているセマンティクスを使用して、トランザクション（トランザクションが終了していない場合）を継続することを決定する場合があります。そうすることを選択しておらず、トランザクションが終了していない場合は、トランザクションを中止し、CMP1999のバージョンでErrormsgContentを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Servers Receiving Version cmp1999 PKIMessages",
      "section_title": true,
      "ja": "7.1.2. バージョンを受信するサーバーCMP1999 pkimessages"
    },
    {
      "indent": 3,
      "text": "If a server receives a version cmp1999 message, it MAY revert to the behavior described in [RFC2510] and respond with version cmp1999 messages. If it does not choose to do so, then it MUST send back an ErrorMsgContent as described above in Section 7.",
      "ja": "サーバーがバージョンCMP1999メッセージを受信した場合、[RFC2510]で説明されている動作に戻り、バージョンCMP1999メッセージで応答する場合があります。そうすることを選択しない場合は、上記のセクション7で説明したように、ErrormSgContentを送り返す必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. On the Necessity of POP",
      "section_title": true,
      "ja": "8.1. ポップの必要性について"
    },
    {
      "indent": 3,
      "text": "It is well established that the role of a CA is to verify that the name and public key belong to the end entity prior to issuing a certificate. If an entity holding a private key obtains a certificate containing the corresponding public key issued for a different entity, it can authenticate as the entity named in the certificate. This facilitates masquerading. It is not entirely clear what security guarantees are lost if an end entity is able to obtain a certificate containing a public key that they do not possess the corresponding private key for. There are some scenarios, described as \"forwarding attacks\" in Appendix A of [Gueneysu], in which this can lead to protocol attacks against a naively implemented sign-then-encrypt protocol, but in general, it merely results in the end entity obtaining a certificate that they cannot use.",
      "ja": "CAの役割は、証明書を発行する前に名前と公開鍵が最終エンティティに属していることを確認することであることが十分に確立されています。秘密鍵を保持しているエンティティが、別のエンティティに発行された対応する公開キーを含む証明書を取得した場合、証明書に名前が付けられたエンティティとして認証できます。これにより、仮面舞踏会が容易になります。最終エンティティが対応する秘密鍵を所有していない公開キーを含む証明書を取得できる場合、セキュリティ保証が失われるものは完全には明らかではありません。[Gueneysu]の付録Aに「転送攻撃」と呼ばれるいくつかのシナリオがあります。これにより、これは、単純に実装されたSign-Then-Incryptプロトコルに対するプロトコル攻撃につながる可能性がありますが、一般的に、使用できない証明書を取得するエンティティが得られるだけです。"
    },
    {
      "indent": 0,
      "text": "8.2. POP with a Decryption Key",
      "section_title": true,
      "ja": "8.2. 復号化キーでポップします"
    },
    {
      "indent": 3,
      "text": "Some cryptographic considerations are worth explicitly spelling out. In the protocols specified above, when an end entity is required to prove possession of a decryption key, it is effectively challenged to decrypt something (its own certificate). This scheme (and many others!) could be vulnerable to an attack if the possessor of the decryption key in question could be fooled into decrypting an arbitrary challenge and returning the cleartext to an attacker. Although in this specification a number of other failures in security are required in order for this attack to succeed, it is conceivable that some future services (e.g., notary, trusted time) could potentially be vulnerable to such attacks. For this reason, we reiterate the general rule that implementations should be very careful about decrypting arbitrary \"ciphertext\" and revealing recovered \"plaintext\" since such a practice can lead to serious security vulnerabilities.",
      "ja": "いくつかの暗号化の考慮事項は、明示的に綴る価値があります。上記のプロトコルでは、復号化キーの所有を証明するために終了エンティティが必要な場合、何か（独自の証明書）を復号化することは事実上挑戦します。このスキーム（および他の多くのもの！）は、問題の復号化キーの所有者が任意の課題を解読し、攻撃者にクリアテキストを返すことにだまされる可能性がある場合、攻撃に対して脆弱になる可能性があります。この仕様では、この攻撃が成功するためにはセキュリティの他の多くの失敗が必要ですが、将来のサービス（例えば、公証人、信頼できる時間など）がそのような攻撃に対して脆弱である可能性があると考えられます。このため、任意の「暗号文」を復号化し、そのようなプラクティスが深刻なセキュリティの脆弱性につながる可能性があるため、実装が任意の「暗号文」を復号化し、回復した「プレーンテキスト」を明らかにすることに非常に注意する必要があるという一般的なルールを繰り返します。"
    },
    {
      "indent": 3,
      "text": "The client MUST return the decrypted values only if they match the expected content type. In an indirect method, the decrypted value MUST be a valid certificate, and in a direct method, the decrypted value MUST be a Rand as defined in Section 5.2.8.3.3.",
      "ja": "クライアントは、予想されるコンテンツタイプと一致する場合にのみ、復号化された値を返す必要があります。間接的な方法では、復号化された値は有効な証明書でなければならず、直接的な方法では、復号化された値はセクション5.2.8.3.3で定義されているRANDでなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.3. POP by Exposing the Private Key",
      "section_title": true,
      "ja": "8.3. 秘密鍵を公開してポップします"
    },
    {
      "indent": 3,
      "text": "Note also that exposing a private key to the CA/RA as a POP technique can carry some security risks (depending upon whether or not the CA/ RA can be trusted to handle such material appropriately). Implementers are advised to:",
      "ja": "また、POPテクニックとしてCA/ RAに秘密鍵を公開すると、セキュリティリスクがあることに注意してください（CA/ RAがそのような資料を適切に処理すると信頼できるかどうかに応じて）。実装者には次のようにアドバイスされています。"
    },
    {
      "indent": 6,
      "text": "* Exercise caution in selecting and using this particular POP mechanism.",
      "ja": "* この特定のポップメカニズムの選択と使用に注意してください。"
    },
    {
      "indent": 6,
      "text": "* Only use this POP mechanism if archival of the private key is desired.",
      "ja": "* 秘密鍵のアーカイブが必要な場合にのみ、このポップメカニズムを使用してください。"
    },
    {
      "indent": 6,
      "text": "* When appropriate, have the user of the application explicitly state that they are willing to trust the CA/RA to have a copy of their private key before proceeding to reveal the private key.",
      "ja": "* 必要に応じて、アプリケーションのユーザーに、秘密鍵を明らかにするために進む前に、CA/RAが秘密鍵のコピーを持っていると信頼する意思があると明示的に述べてください。"
    },
    {
      "indent": 0,
      "text": "8.4. Attack Against DH Key Exchange",
      "section_title": true,
      "ja": "8.4. DHキー交換に対する攻撃"
    },
    {
      "indent": 3,
      "text": "A small subgroup attack during a DH key exchange may be carried out as follows. A malicious end entity may deliberately choose DH parameters that enable it to derive (a significant number of bits of) the DH private key of the CA during a key archival or key recovery operation. Armed with this knowledge, the end entity would then be able to retrieve the decryption private key of another unsuspecting end entity, EE2, during EE2's legitimate key archival or key recovery operation with that CA. In order to avoid the possibility of such an attack, two courses of action are available. (1) The CA may generate a fresh DH key pair to be used as a protocol encryption key pair for each end entity with which it interacts. (2) The CA may enter into a key validation protocol (not specified in this document) with each requesting end entity to ensure that the end entity's protocol encryption key pair will not facilitate this attack. Option (1) is clearly simpler (requiring no extra protocol exchanges from either party) and is therefore RECOMMENDED.",
      "ja": "DHキー交換中の小さなサブグループ攻撃は、次のように実行できます。悪意のある最終エンティティは、キーアーカイブまたはキーリカバリ操作中にCAのDH秘密鍵を（かなりの数のビット）導出できるようにするDHパラメーターを意図的に選択できます。この知識で武装して、最終エンティティは、EE2の合法的なキーアーカイブまたはキーリカバリ操作中に、疑いを持たないエンティティEE2の復号化の秘密鍵を取得できるようになります。このような攻撃の可能性を回避するために、2つのアクションコースが利用可能です。（1）CAは、それが相互作用する各エンティティのプロトコル暗号化キーペアとして使用する新しいDHキーペアを生成する場合があります。（2）CAは、各エンティティのプロトコル暗号化キーペアがこの攻撃を容易にしないことを確認するために、各エンティティを要求する各要求エンティティでキー検証プロトコル（このドキュメントで指定されていない）を入力することができます。オプション（1）は明らかに単純で（どちらの当事者からの追加のプロトコル交換を必要としない）ため、推奨されます。"
    },
    {
      "indent": 0,
      "text": "8.5. Perfect Forward Secrecy",
      "section_title": true,
      "ja": "8.5. 完全なフォワードの秘密"
    },
    {
      "indent": 3,
      "text": "Long-term security typically requires perfect forward secrecy (pfs). When transferring encrypted long-term confidential values such as centrally generated private keys or revocation passphrases, pfs is likely important. Yet, it is not needed for CMP message protection providing integrity and authenticity because transfer of PKI messages is usually completed in very limited time. For the same reason, it is not typically required for the indirect method to provide a POP (Section 5.2.8.3.2) delivering the newly issued certificate in encrypted form.",
      "ja": "通常、長期的なセキュリティには、完全なフォワード秘密（PFS）が必要です。中央に生成されたプライベートキーや取り消しパスフレーズなど、暗号化された長期の機密値を転送する場合、PFSが重要です。しかし、PKIメッセージの転送は通常非常に限られた時間で完了するため、CMPメッセージ保護を整合性と信頼性を提供するためには必要ありません。同じ理由で、間接的な方法がPOP（セクション5.2.8.3.2）を提供するためには、暗号化された形式で新たに発行された証明書を提供することは通常必要ではありません。"
    },
    {
      "indent": 3,
      "text": "Encrypted values (Section 5.2.2) are transferred using CMS EnvelopedData [RFC5652], which does not offer pfs. In cases where long-term security is needed, CMP messages SHOULD be transferred over a mechanism that provides pfs, such as TLS with appropriate cipher suites selected.",
      "ja": "暗号化された値（セクション5.2.2）は、PFSを提供しないCMS EnvelopedData [RFC5652]を使用して転送されます。長期的なセキュリティが必要な場合、CMPメッセージは、適切な暗号スイートを選択したTLSなどのPFSを提供するメカニズムを介して転送する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.6. Private Keys for Certificate Signing and CMP Message Protection",
      "section_title": true,
      "ja": "8.6. 証明書署名およびCMPメッセージ保護のためのプライベートキー"
    },
    {
      "indent": 3,
      "text": "A CA should not reuse its certificate signing key for other purposes, such as protecting CMP responses and TLS connections. This way, exposure to other parts of the system and the number of uses of this particularly critical key are reduced to a minimum.",
      "ja": "CAは、CMP応答やTLS接続の保護など、他の目的で証明書署名キーを再利用しないでください。このようにして、システムの他の部分への露出とこの特に重要なキーの使用数は最小限に抑えられます。"
    },
    {
      "indent": 0,
      "text": "8.7. Entropy of Random Numbers, Key Pairs, and Shared Secret Information",
      "section_title": true,
      "ja": "8.7. 乱数、重要なペア、共有された秘密情報のエントロピー"
    },
    {
      "indent": 3,
      "text": "Implementations must generate nonces and private keys from random input. The use of inadequate pseudorandom number generators (PRNGs) to generate cryptographic keys can result in little or no security. An attacker may find it much easier to reproduce the PRNG environment that produced the keys and to search the resulting small set of possibilities than brute-force searching the whole key space. As an example of predictable random numbers, see [CVE-2008-0166]; consequences of low-entropy random numbers are discussed in Mining Your Ps and Qs [MiningPsQs]. The generation of quality random numbers is difficult. ISO/IEC 20543:2019 [ISO.20543-2019], NIST SP 800-90A Rev.1 [NIST.SP.800_90Ar1], BSI AIS 31 V2.0 [AIS31], and other specifications offer valuable guidance in this area.",
      "ja": "実装は、ランダム入力からNONCESとプライベートキーを生成する必要があります。暗号化キーを生成するために不十分な擬似ランダム数ジェネレーター（PRNGS）を使用すると、セキュリティがほとんどまたはまったくなりません。攻撃者は、キーを生成したPRNG環境を再現し、キー空間全体を検索するブルートフォースよりも、結果として生じる小さな可能性のセットを検索する方がはるかに簡単になる場合があります。予測可能な乱数の例として、[CVE-2008-0166]を参照してください。低エントロピー乱数の結果は、PSおよびQS [MiningPsQS]をマイニングする際に議論されています。品質の乱数の生成は困難です。ISO/IEC 20543：2019 [ISO.20543-2019]、Nist SP 800-90A Rev.1 [nist.sp.800_90AR1]、BSI AIS 31 V2.0 [AIS31]、およびその他の仕様は、この分野で貴重なガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "If shared secret information is generated by a cryptographically secure random number generator (CSRNG), it is safe to assume that the entropy of the shared secret information equals its bit length. If no CSRNG is used, the entropy of shared secret information depends on the details of the generation process and cannot be measured securely after it has been generated. If user-generated passwords are used as shared secret information, their entropy cannot be measured. Passwords generated from user-supplied entropy are typically insufficient for protected delivery of centrally generated keys or trust anchors.",
      "ja": "共有秘密情報が暗号化された安全な乱数ジェネレーター（CSRNG）によって生成される場合、共有された秘密情報のエントロピーがビットの長さに等しいと仮定することは安全です。CSRNGが使用されない場合、共有された秘密情報のエントロピーは、生成プロセスの詳細に依存し、生成後に安全に測定することはできません。ユーザー生成されたパスワードが共有秘密情報として使用される場合、それらのエントロピーを測定することはできません。ユーザーがサポートしたエントロピーから生成されたパスワードは、通常、中央で生成されたキーまたは信頼アンカーの保護された配信には不十分です。"
    },
    {
      "indent": 3,
      "text": "If the entropy of shared secret information protecting the delivery of a centrally generated key pair is known, it should not be less than the security strength of that key pair; if the shared secret information is reused for different key pairs, the security of the shared secret information should exceed the security strength of each individual key pair.",
      "ja": "中央に生成されたキーペアの配信を保護する共有秘密情報のエントロピーがわかっている場合、そのキーペアのセキュリティ強度よりも少ないはずです。共有された秘密情報が異なるキーペアに対して再利用される場合、共有された秘密情報のセキュリティは、個々のキーペアのセキュリティ強度を超える必要があります。"
    },
    {
      "indent": 3,
      "text": "For the case of a PKI management operation that delivers a new trust anchor (e.g., a root CA certificate), using caPubs or genp that is (a) not concluded in a timely manner or (b) where the shared secret information is reused for several key management operations, the entropy of the shared secret information, if known, should not be less than the security strength of the trust anchor being managed by the operation. The shared secret information should have an entropy that at least matches the security strength of the key material being managed by the operation. Certain use cases may require shared secret information that may be of a low security strength, e.g., a human-generated password. It is RECOMMENDED that such secret information be limited to a single PKI management operation.",
      "ja": "（a）タイムリーな方法で結論付けられていないカプブまたはGenpを使用して、新しいトラストアンカー（例：ルートCA証明書）を提供するPKI管理操作の場合、または共有された秘密情報がいくつかの重要な管理操作のために再利用される場合、共有された秘密情報のエントロピーが既知である場合は、操業を管理するための信頼のセキュリティ強度よりも少ない場合はありません。共有された秘密情報には、少なくとも操作によって管理されている重要な資料のセキュリティ強度に一致するエントロピーが必要です。特定のユースケースには、セキュリティ強度が低い場合がある共有秘密情報が必要になる場合があります。たとえば、人間で生成されたパスワードなどです。このような秘密情報を単一のPKI管理操作に限定することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Importantly for this section, further information about algorithm use profiles and their security strength is available in Section 7 of CMP Algorithms [RFC9481].",
      "ja": "このセクションでは、アルゴリズムに関する詳細情報はプロファイルを使用し、そのセキュリティ強度はCMPアルゴリズム[RFC9481]のセクション7で利用できます。"
    },
    {
      "indent": 0,
      "text": "8.8. Recurring Usage of KEM Keys for Message Protection",
      "section_title": true,
      "ja": "8.8. メッセージ保護のためのKEMキーの繰り返しの使用"
    },
    {
      "indent": 3,
      "text": "For each PKI management operation using MAC-based message protection involving KEM (see Section 5.1.3.4), the KEM Encapsulate() function, providing a fresh KEM ciphertext (ct) and shared secret (ss), MUST be invoked.",
      "ja": "KEMを含むMACベースのメッセージ保護を使用した各PKI管理操作（セクション5.1.3.4を参照）、KEM encapsulate（）関数は、新鮮なKEM Ciphertext（CT）と共有Secret（SS）を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the overall data size of the CMP messages in a PKI management operation protected by a single shared secret key is small enough not to introduce extra security risks.",
      "ja": "単一の共有シークレットキーによって保護されているPKI管理操作のCMPメッセージの全体的なデータサイズは、追加のセキュリティリスクを導入しないほど小さいと想定されています。"
    },
    {
      "indent": 3,
      "text": "To be appropriate for use with this specification, the KEM algorithm MUST explicitly be designed to be secure when the public key is used many times. For example, a KEM algorithm with a single-use public key is not appropriate because the public key is expected to be carried in a long-lived certificate [RFC5280] and used over and over. Thus, KEM algorithms that offer indistinguishability under adaptive chosen ciphertext attack (IND-CCA2) security are appropriate. A common design pattern for obtaining IND-CCA2 security with public key reuse is to apply the Fujisaki-Okamoto (FO) transform [Fujisaki] or a variant of the FO transform [Hofheinz].",
      "ja": "この仕様で使用するのに適しているため、公開キーを何度も使用する場合、KEMアルゴリズムを明示的に安全にするように設計する必要があります。たとえば、公開キーは長寿命の証明書[RFC5280]に携帯され、何度も使用されると予想されるため、単一使用の公開キーを持つKEMアルゴリズムは適切ではありません。したがって、適応的に選択されたCiphertext攻撃（IND-CCA2）セキュリティの下で区別不可能を提供するKEMアルゴリズムが適切です。公開キーの再利用を使用してIND-CCA2セキュリティを取得するための一般的な設計パターンは、富士キサキオカモト（FO）変換[藤崎]またはFO変換[Hofheinz]のバリアントを適用することです。"
    },
    {
      "indent": 3,
      "text": "Therefore, given a long-term public key using an IND-CCA2-secure KEM algorithm, there is no limit to the number of CMP messages that can be authenticated using KEM keys for MAC-based message protection.",
      "ja": "したがって、IND-CCA2-Secure KEMアルゴリズムを使用した長期的な公開キーを考えると、Macベースのメッセージ保護のためにKEMキーを使用して認証できるCMPメッセージの数に制限はありません。"
    },
    {
      "indent": 0,
      "text": "8.9. Trust Anchor Provisioning Using CMP Messages",
      "section_title": true,
      "ja": "8.9. CMPメッセージを使用したアンカープロビジョニングを信頼します"
    },
    {
      "indent": 3,
      "text": "A provider of trust anchors, which may be an RA involved in configuration management of its clients, MUST NOT include to-be-trusted CA certificates in a CMP message unless the specific deployment scenario can ensure that it is adequate that the receiving end entity trusts these certificates, e.g., by loading them into its trust store.",
      "ja": "クライアントの構成管理に関与するRAである可能性のあるトラストアンカーのプロバイダーは、特定の展開シナリオが受信エンティティがこれらの証明書を信頼していることを確実に保証できない限り、CMPメッセージに、実証されたCA証明書をCMPメッセージに含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Whenever an end entity receives in a CMP message a CA certificate to be used as a trust anchor (for example, in the caPubs field of a certificate response or in a general response), it MUST properly authenticate the message sender with existing trust anchors without requiring new trust anchor information included in the message.",
      "ja": "End EntityがCMPメッセージでTrustアンカーとして使用するCA証明書を受信するときはいつでも（たとえば、証明書応答のカプブフィールドまたは一般的な応答のフィールドで）、メッセージに含まれる新しいトラストアンカー情報を必要とせずに既存のトラストアンカーでメッセージ送信者を適切に認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Additionally, the end entity MUST verify that the sender is an authorized source of trust anchors. This authorization is governed by local policy and typically indicated using shared secret information or with a signature-based message protection using a certificate issued by a PKI that is explicitly authorized for this purpose.",
      "ja": "さらに、最終エンティティは、送信者が信頼のアンカーの承認されたソースであることを確認する必要があります。この許可は、ローカルポリシーに準拠しており、通常、共有された秘密情報を使用して、またはこの目的のために明示的に承認されたPKIによって発行された証明書を使用して署名ベースのメッセージ保護を使用して示されます。"
    },
    {
      "indent": 0,
      "text": "8.10. Authorizing Requests for Certificates with Specific EKUs",
      "section_title": true,
      "ja": "8.10. 特定のEKUを使用して証明書のリクエストを承認します"
    },
    {
      "indent": 3,
      "text": "When a CA issues a certificate containing EKU extensions as defined in Section 4.5, this expresses delegation of an authorization that originally is only with the CA certificate itself. Such delegation is a very sensitive action in a PKI, and therefore, special care must be taken when approving such certificate requests to ensure that only legitimate entities receive a certificate containing such an EKU.",
      "ja": "CAがセクション4.5で定義されているようにEKU拡張機能を含む証明書を発行する場合、これは元々CA証明書自体のみにある認可の委任を表します。このような委任はPKIで非常に敏感なアクションであるため、正当なエンティティのみがそのようなEKUを含む証明書を受け取ることを確認するために、そのような証明書リクエストを承認する際には特別な注意を払わなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.11. Usage of CT Logs",
      "section_title": true,
      "ja": "8.11. CTログの使用"
    },
    {
      "indent": 3,
      "text": "CAs that support indirect POP MUST NOT also publish final certificates to CT logs [RFC9162] before having received the certConf message containing the certHash of that certificate to complete the POP. The risk is that a malicious actor could fetch the final certificate from the CT log and use that to spoof a response to the implicit POP challenge via a certConf response. This risk does not apply to CT precertificates, so those are OK to publish.",
      "ja": "間接POPをサポートするCASは、POPを完了するためにその証明書のCerthashを含むCertConfメッセージを受信する前に、CTログ[RFC9162]に最終証明書を公開してはなりません。リスクは、悪意のあるアクターがCTログから最終証明書を取得し、それを使用して、CertConf応答を介して暗黙のPOPチャレンジへの応答をスプーフィングできることです。このリスクはCTの既製のものには適用されないため、公開することは問題ありません。"
    },
    {
      "indent": 3,
      "text": "If a certificate or its precertificate was published in a CT log, it must be revoked if a required certConf message could not be verified, especially when the implicit POP was used.",
      "ja": "証明書またはその教員がCTログに公開された場合、特に暗黙のポップが使用された場合、必要なCERTCONFメッセージを検証できなかった場合は取り消す必要があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document updates the ASN.1 modules in Appendix A.2 of CMP Updates [RFC9480]. The OID 116 (id-mod-cmp2023-02) was registered in the \"SMI Security for PKIX Module Identifier\" registry to identify the updated ASN.1 module.",
      "ja": "このドキュメントは、CMP更新[RFC9480]の付録A.2のASN.1モジュールを更新します。OID 116（ID-MOD-CMP2023-02）は、「PKIXモジュール識別子のSMIセキュリティ」レジストリに登録され、更新されたASN.1モジュールを識別しました。"
    },
    {
      "indent": 3,
      "text": "IANA has added the following entry in the \"SMI Security for PKIX CMP Information Types\" registry within the SMI Numbers registry group (see <https://www.iana.org/assignments/smi-numbers>) [RFC7299]:",
      "ja": "IANAは、SMI番号レジストリグループ内の「PKIX CMP情報タイプのSMIセキュリティ」レジストリに次のエントリを追加しました（<https://www.iana.org/assignments/smi-numbers>）[RFC7299]："
    },
    {
      "indent": 3,
      "text": "Decimal:",
      "ja": "小数："
    },
    {
      "indent": 12,
      "text": "24",
      "ja": "24"
    },
    {
      "indent": 3,
      "text": "Description:",
      "ja": "説明："
    },
    {
      "indent": 12,
      "text": "id-it-KemCiphertextInfo",
      "ja": "is-it-kem ciphertext情報"
    },
    {
      "indent": 3,
      "text": "Reference:",
      "ja": "参照："
    },
    {
      "indent": 12,
      "text": "RFC 9810",
      "ja": "RFC 9810"
    },
    {
      "indent": 3,
      "text": "Note that the new OID 1.2.840.113533.7.66.16 was registered by Entrust, and not by IANA, for id-KemBasedMac in the arc 1.2.840.113533.7.66. This was done to match the previous registrations for id-PasswordBasedMac and id-DHBasedMac, which are also on the Entrust private arc.",
      "ja": "新しいOID 1.2.840.113533.7.66.16は、ARC 1.2.840.113533.7.66のID-KembasedMacについて、IANAではなく委任によって登録されたことに注意してください。これは、ID-PassWordBasedMacおよびID-DHBasedMacの以前の登録と一致するために行われました。"
    },
    {
      "indent": 3,
      "text": "All existing references to [RFC2510], [RFC4210], and [RFC9480] at <https://www.iana.org/assignments/smi-numbers> except those in the \"SMI Security for PKIX Module Identifier\" registry have been replaced with references to this document.",
      "ja": "[rfc2510]、[rfc4210]、[rfc9480]、<https://www.iana.org/assignments/smi-numbers>のすべての既存の参照は、「pkixモジュール識別子識別子識別子のSMIセキュリティ」レジストリを除き、この文書への参照に置き換えられています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[MvOV97]   Menezes, A., van Oorschot, P., and S. Vanstone, \"Handbook\n           of Applied Cryptography\", CRC Press ISBN 0-8493-8523-7,\n           1996, <https://cacr.uwaterloo.ca/hac/>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119,\n           DOI 10.17487/RFC2119, March 1997,\n           <https://www.rfc-editor.org/info/rfc2119>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2985]  Nystrom, M. and B. Kaliski, \"PKCS #9: Selected Object\n           Classes and Attribute Types Version 2.0\", RFC 2985,\n           DOI 10.17487/RFC2985, November 2000,\n           <https://www.rfc-editor.org/info/rfc2985>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2986]  Nystrom, M. and B. Kaliski, \"PKCS #10: Certification\n           Request Syntax Specification Version 1.7\", RFC 2986,\n           DOI 10.17487/RFC2986, November 2000,\n           <https://www.rfc-editor.org/info/rfc2986>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n           10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n           2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4211]  Schaad, J., \"Internet X.509 Public Key Infrastructure\n           Certificate Request Message Format (CRMF)\", RFC 4211,\n           DOI 10.17487/RFC4211, September 2005,\n           <https://www.rfc-editor.org/info/rfc4211>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n           Housley, R., and W. Polk, \"Internet X.509 Public Key\n           Infrastructure Certificate and Certificate Revocation List\n           (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008,\n           <https://www.rfc-editor.org/info/rfc5280>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,\n           \"Elliptic Curve Cryptography Subject Public Key\n           Information\", RFC 5480, DOI 10.17487/RFC5480, March 2009,\n           <https://www.rfc-editor.org/info/rfc5480>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5646]  Phillips, A., Ed. and M. Davis, Ed., \"Tags for Identifying\n           Languages\", BCP 47, RFC 5646, DOI 10.17487/RFC5646,\n           September 2009, <https://www.rfc-editor.org/info/rfc5646>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5652]  Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70,\n           RFC 5652, DOI 10.17487/RFC5652, September 2009,\n           <https://www.rfc-editor.org/info/rfc5652>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5958]  Turner, S., \"Asymmetric Key Packages\", RFC 5958,\n           DOI 10.17487/RFC5958, August 2010,\n           <https://www.rfc-editor.org/info/rfc5958>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6402]  Schaad, J., \"Certificate Management over CMS (CMC)\n           Updates\", RFC 6402, DOI 10.17487/RFC6402, November 2011,\n           <https://www.rfc-editor.org/info/rfc6402>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n           2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n           May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8933]  Housley, R., \"Update to the Cryptographic Message Syntax\n           (CMS) for Algorithm Identifier Protection\", RFC 8933,\n           DOI 10.17487/RFC8933, October 2020,\n           <https://www.rfc-editor.org/info/rfc8933>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9045]  Housley, R., \"Algorithm Requirements Update to the\n           Internet X.509 Public Key Infrastructure Certificate\n           Request Message Format (CRMF)\", RFC 9045,\n           DOI 10.17487/RFC9045, June 2021,\n           <https://www.rfc-editor.org/info/rfc9045>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9481]  Brockhaus, H., Aschauer, H., Ounsworth, M., and J. Gray,\n           \"Certificate Management Protocol (CMP) Algorithms\",\n           RFC 9481, DOI 10.17487/RFC9481, November 2023,\n           <https://www.rfc-editor.org/info/rfc9481>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9629]  Housley, R., Gray, J., and T. Okubo, \"Using Key\n           Encapsulation Mechanism (KEM) Algorithms in the\n           Cryptographic Message Syntax (CMS)\", RFC 9629,\n           DOI 10.17487/RFC9629, August 2024,\n           <https://www.rfc-editor.org/info/rfc9629>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AIS31]    Killmann, W. and W. Schindler, \"A proposal for:\n           Functionality classes for random number generators -\n           Version 2.0\", Federal Office for Information Security\n           (BSI), September 2011,\n           <https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/\n           Zertifizierung/Interpretationen/AIS_31_Functionality_class\n           es_for_random_number_generators_e.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[CVE-2008-0166]\n           National Institute of Science and Technology (NIST),\n           \"National Vulnerability Database - CVE-2008-0166\", May\n           2008, <https://nvd.nist.gov/vuln/detail/CVE-2008-0166>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ETSI-3GPP.33.310]\n           3GPP, \"Network Domain Security (NDS); Authentication\n           Framework (AF)\", 3GPP TS 33.310 16.6.0, December 2020,\n           <http://www.3gpp.org/ftp/Specs/html-info/33310.htm>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Fujisaki] Fujisaki, E. and T. Okamoto, \"Secure Integration of\n           Asymmetric and Symmetric Encryption Schemes\", Journal of\n           Cryptology, vol. 26, no. 1, pp. 80-101,\n           DOI 10.1007/s00145-011-9114-1, December 2011,\n           <https://doi.org/10.1007/s00145-011-9114-1>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Gueneysu] Gueneysu, T., Hodges, P., Land, G., Ounsworth, M.,\n           Stebila, D., and G. Zaverucha, \"Proof-of-possession for\n           KEM certificates using verifiable generation\", Cryptology\n           ePrint Archive, Paper 2022/703, 2022,\n           <https://eprint.iacr.org/2022/703>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Hofheinz] Hofheinz, D., Hövelmanns, K., and E. Kiltz, \"A Modular\n           Analysis of the Fujisaki-Okamoto Transformation\", Theory\n           of Cryptography (TCC 2017), Lecture Notes in Computer\n           Science, vol. 10677, pp. 341-371,\n           DOI 10.1007/978-3-319-70500-2_12, November 2017,\n           <https://doi.org/10.1007/978-3-319-70500-2_12>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IEEE.802.1AR-2018]\n           IEEE, \"IEEE Standard for Local and Metropolitan Area\n           Networks - Secure Device Identity\", IEEE Std 802.1AR-2018,\n           DOI 10.1109/ieeestd.2018.8423794, August 2018,\n           <https://doi.org/10.1109/ieeestd.2018.8423794>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ISO.20543-2019]\n           ISO/IEC, \"Information technology -- Security techniques --\n           Test and analysis methods for random bit generators within\n           ISO/IEC 19790 and ISO/IEC 15408\", ISO/IEC 20543:2019,\n           October 2019, <https://www.iso.org/standard/68296.html>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MiningPsQs]\n           Heninger, N., Durumeric, Z., Wustrow, E., and J. A.\n           Halderman, \"Mining Your Ps and Qs: Detection of Widespread\n           Weak Keys in Network Devices\", 21st USENIX Security\n           Symposium (USENIX Security 12), August 2012,\n           <https://www.usenix.org/conference/usenixsecurity12/\n           technical-sessions/presentation/heninger>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ML-KEM]   Turner, S., Kampanakis, P., Massimo, J., and B.\n           Westerbaan, \"Internet X.509 Public Key Infrastructure -\n           Algorithm Identifiers for the Module-Lattice-Based Key-\n           Encapsulation Mechanism (ML-KEM)\", Work in Progress,\n           Internet-Draft, draft-ietf-lamps-kyber-certificates-11, 22\n           July 2025, <https://datatracker.ietf.org/doc/html/draft-\n           ietf-lamps-kyber-certificates-11>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[NIST.SP.800_90Ar1]\n           Barker, E. B. and J. M. Kelsey, \"Recommendation for Random\n           Number Generation Using Deterministic Random Bit\n           Generators\", NIST SP 800-90Ar1,\n           DOI 10.6028/NIST.SP.800-90Ar1, June 2015,\n           <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n           NIST.SP.800-90Ar1.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1847]  Galvin, J., Murphy, S., Crocker, S., and N. Freed,\n           \"Security Multiparts for MIME: Multipart/Signed and\n           Multipart/Encrypted\", RFC 1847, DOI 10.17487/RFC1847,\n           October 1995, <https://www.rfc-editor.org/info/rfc1847>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2510]  Adams, C. and S. Farrell, \"Internet X.509 Public Key\n           Infrastructure Certificate Management Protocols\",\n           RFC 2510, DOI 10.17487/RFC2510, March 1999,\n           <https://www.rfc-editor.org/info/rfc2510>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2585]  Housley, R. and P. Hoffman, \"Internet X.509 Public Key\n           Infrastructure Operational Protocols: FTP and HTTP\",\n           RFC 2585, DOI 10.17487/RFC2585, May 1999,\n           <https://www.rfc-editor.org/info/rfc2585>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4210]  Adams, C., Farrell, S., Kause, T., and T. Mononen,\n           \"Internet X.509 Public Key Infrastructure Certificate\n           Management Protocol (CMP)\", RFC 4210,\n           DOI 10.17487/RFC4210, September 2005,\n           <https://www.rfc-editor.org/info/rfc4210>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4212]  Blinov, M. and C. Adams, \"Alternative Certificate Formats\n           for the Public-Key Infrastructure Using X.509 (PKIX)\n           Certificate Management Protocols\", RFC 4212,\n           DOI 10.17487/RFC4212, October 2005,\n           <https://www.rfc-editor.org/info/rfc4212>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4303]  Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n           RFC 4303, DOI 10.17487/RFC4303, December 2005,\n           <https://www.rfc-editor.org/info/rfc4303>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC4511]  Sermersheim, J., Ed., \"Lightweight Directory Access\n           Protocol (LDAP): The Protocol\", RFC 4511,\n           DOI 10.17487/RFC4511, June 2006,\n           <https://www.rfc-editor.org/info/rfc4511>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC5912]  Hoffman, P. and J. Schaad, \"New ASN.1 Modules for the\n           Public Key Infrastructure Using X.509 (PKIX)\", RFC 5912,\n           DOI 10.17487/RFC5912, June 2010,\n           <https://www.rfc-editor.org/info/rfc5912>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6268]  Schaad, J. and S. Turner, \"Additional New ASN.1 Modules\n           for the Cryptographic Message Syntax (CMS) and the Public\n           Key Infrastructure Using X.509 (PKIX)\", RFC 6268,\n           DOI 10.17487/RFC6268, July 2011,\n           <https://www.rfc-editor.org/info/rfc6268>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC6712]  Kause, T. and M. Peylo, \"Internet X.509 Public Key\n           Infrastructure -- HTTP Transfer for the Certificate\n           Management Protocol (CMP)\", RFC 6712,\n           DOI 10.17487/RFC6712, September 2012,\n           <https://www.rfc-editor.org/info/rfc6712>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n           Kivinen, \"Internet Key Exchange Protocol Version 2\n           (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296, October\n           2014, <https://www.rfc-editor.org/info/rfc7296>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC7299]  Housley, R., \"Object Identifier Registry for the PKIX\n           Working Group\", RFC 7299, DOI 10.17487/RFC7299, July 2014,\n           <https://www.rfc-editor.org/info/rfc7299>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n           Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n           <https://www.rfc-editor.org/info/rfc8446>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8572]  Watsen, K., Farrer, I., and M. Abrahamsson, \"Secure Zero\n           Touch Provisioning (SZTP)\", RFC 8572,\n           DOI 10.17487/RFC8572, April 2019,\n           <https://www.rfc-editor.org/info/rfc8572>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8649]  Housley, R., \"Hash Of Root Key Certificate Extension\",\n           RFC 8649, DOI 10.17487/RFC8649, August 2019,\n           <https://www.rfc-editor.org/info/rfc8649>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC8995]  Pritikin, M., Richardson, M., Eckert, T., Behringer, M.,\n           and K. Watsen, \"Bootstrapping Remote Secure Key\n           Infrastructure (BRSKI)\", RFC 8995, DOI 10.17487/RFC8995,\n           May 2021, <https://www.rfc-editor.org/info/rfc8995>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9147]  Rescorla, E., Tschofenig, H., and N. Modadugu, \"The\n           Datagram Transport Layer Security (DTLS) Protocol Version\n           1.3\", RFC 9147, DOI 10.17487/RFC9147, April 2022,\n           <https://www.rfc-editor.org/info/rfc9147>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9162]  Laurie, B., Messeri, E., and R. Stradling, \"Certificate\n           Transparency Version 2.0\", RFC 9162, DOI 10.17487/RFC9162,\n           December 2021, <https://www.rfc-editor.org/info/rfc9162>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9480]  Brockhaus, H., von Oheimb, D., and J. Gray, \"Certificate\n           Management Protocol (CMP) Updates\", RFC 9480,\n           DOI 10.17487/RFC9480, November 2023,\n           <https://www.rfc-editor.org/info/rfc9480>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9482]  Sahni, M., Ed. and S. Tripathi, Ed., \"Constrained\n           Application Protocol (CoAP) Transfer for the Certificate\n           Management Protocol\", RFC 9482, DOI 10.17487/RFC9482,\n           November 2023, <https://www.rfc-editor.org/info/rfc9482>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9483]  Brockhaus, H., von Oheimb, D., and S. Fries, \"Lightweight\n           Certificate Management Protocol (CMP) Profile\", RFC 9483,\n           DOI 10.17487/RFC9483, November 2023,\n           <https://www.rfc-editor.org/info/rfc9483>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9733]  von Oheimb, D., Ed., Fries, S., and H. Brockhaus, \"BRSKI\n           with Alternative Enrollment (BRSKI-AE)\", RFC 9733,\n           DOI 10.17487/RFC9733, March 2025,\n           <https://www.rfc-editor.org/info/rfc9733>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC9811]  Brockhaus, H., von Oheimb, D., Ounsworth, M., and J. Gray,\n           \"Internet X.509 Public Key Infrastructure -- HTTP Transfer\n           for the Certificate Management Protocol (CMP)\", RFC 9811,\n           July 2025, <https://www.rfc-editor.org/info/rfc9811>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[UNISIG.Subset-137]\n           UNISIG, \"ERTMS/ETCS On-line Key Management FFFIS\", Subset-\n           137, V1.0.0, December 2015,\n           <https://www.era.europa.eu/system/files/2023-01/\n           sos3_index083_-_subset-137_v100.pdf>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[X509.2019]\n           ITU-T, \"Information technology - Open Systems\n           Interconnection - The Directory: Public-key and attribute\n           certificate frameworks\", ITU-T Recommendation X.509\n           (10/2019), October 2019,\n           <https://handle.itu.int/11.1002/1000/14033>.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix A. Reasons for the Presence of RAs",
      "section_title": true,
      "ja": "付録A. RASの存在の理由"
    },
    {
      "indent": 3,
      "text": "The reasons that justify the presence of an RA can be split into those that are due to technical factors and those that are organizational in nature. Technical reasons include the following.",
      "ja": "RAの存在を正当化する理由は、技術的要因と本質的に組織的な要因によるものに分割される可能性があります。技術的な理由には、以下が含まれます。"
    },
    {
      "indent": 6,
      "text": "* If hardware tokens are in use, then not all end entities will have the equipment needed to initialize these; the RA equipment can include the necessary functionality (this may also be a matter of policy).",
      "ja": "* ハードウェアトークンが使用されている場合、すべてのエンティティがこれらを初期化するために必要な機器を持っているわけではありません。RA機器には、必要な機能を含めることができます（これはポリシーの問題でもあります）。"
    },
    {
      "indent": 6,
      "text": "* Some end entities may not have the capability to publish certificates; again, the RA may be suitably placed for this.",
      "ja": "* 一部のエンティティには、証明書を公開する機能がない場合があります。繰り返しますが、RAはこれに適した場所に配置される可能性があります。"
    },
    {
      "indent": 6,
      "text": "* The RA will be able to issue signed revocation requests on behalf of end entities associated with it, whereas the end entity may not be able to do this (if the key pair is completely lost).",
      "ja": "* RAは、それに関連するエンディティに代わって署名された失効リクエストを発行することができますが、最終エンティティはこれを行うことができない場合があります（キーペアが完全に失われた場合）。"
    },
    {
      "indent": 3,
      "text": "Some of the organizational reasons that argue for the presence of an RA are the following.",
      "ja": "RAの存在を主張する組織の理由のいくつかは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* It may be more cost effective to concentrate functionality in the RA equipment than to supply functionality to all end entities (especially if special token initialization equipment is to be used).",
      "ja": "* すべての最終エンティティに機能を供給するよりも、RA機器に機能を集中させる方が費用対効果が高い場合があります（特に特別なトークン初期化機器を使用する場合）。"
    },
    {
      "indent": 6,
      "text": "* Establishing RAs within an organization can reduce the number of CAs required, which is sometimes desirable.",
      "ja": "* 組織内でRASを確立すると、必要なCAの数を減らすことができますが、これは望ましいこともあります。"
    },
    {
      "indent": 6,
      "text": "* RAs may be better placed to identify people with their \"electronic\" names, especially if the CA is physically remote from the end entity.",
      "ja": "* RAは、特にCAが最終エンティティから物理的にリモートである場合、「電子」名を持つ人々を識別するために配置される可能性があります。"
    },
    {
      "indent": 6,
      "text": "* For many applications, there will already be some administrative structure in place so that candidates for the role of RA are easy to find (which may not be true of the CA).",
      "ja": "* 多くのアプリケーションでは、RAの役割の候補者が簡単に見つけることができるように、すでに何らかの管理構造が整っています（CAには当てはまらないかもしれません）。"
    },
    {
      "indent": 3,
      "text": "Further reasons relevant for automated machine-to-machine certificate lifecycle management are available in the Lightweight CMP Profile [RFC9483].",
      "ja": "自動化されたマシンからマシンまでの証明書のライフサイクル管理に関連するさらなる理由は、軽量CMPプロファイル[RFC9483]で利用できます。"
    },
    {
      "indent": 0,
      "text": "Appendix B. The Use of Revocation Passphrase",
      "section_title": true,
      "ja": "付録B. 取り消しパスフレーズの使用"
    },
    {
      "indent": 3,
      "text": "A revocation request must incorporate suitable security mechanisms, including proper authentication, in order to reduce the probability of successful denial-of-service attacks. A digital signature or DH/ KEM-based message protection on the request -- REQUIRED to support within this specification depending on the key type used if revocation requests are supported -- can provide the authentication required, but there are circumstances under which an alternative mechanism may be desirable (e.g., when the private key is no longer accessible and the entity wishes to request a revocation prior to re-certification of another key pair). In order to accommodate such circumstances, a password-based MAC (see Section 6.1 of CMP Algorithms [RFC9481]) on the request is also REQUIRED to support within this specification (subject to local security policy for a given environment) if revocation requests are supported and if shared secret information can be established between the requester and the responder prior to the need for revocation.",
      "ja": "取り消し要求には、サービス拒否攻撃を成功させる確率を減らすために、適切な認証を含む適切なセキュリティメカニズムを組み込む必要があります。デジタル署名またはDH/ KEMベースのリクエスト保護 - 取り消し要求がサポートされている場合に使用されるキータイプに応じてこの仕様内でサポートするために必要な認証を提供することができますが、代替メカニズムが望ましい状況があります（たとえば、プライベートキーがもはや別のキーペアの再認証のための採点を要求したい場合）。このような状況に対応するために、この仕様内でサポートするパスワードベースのMAC（CMPアルゴリズム[RFC9481]のセクション6.1 [RFC9481]を参照）も必要です（特定の環境の現地セキュリティポリシーの対象となります）。"
    },
    {
      "indent": 3,
      "text": "A mechanism that has seen use in some environments is \"revocation passphrase\", in which a value of sufficient entropy (i.e., a relatively long passphrase rather than a short password) is shared between (only) the entity and the CA/RA at some point prior to revocation; this value is later used to authenticate the revocation request.",
      "ja": "一部の環境で使用されているメカニズムは「取り消しパスフレーズ」です。このメカニズムでは、十分なエントロピーの値（つまり、短いパスワードではなく比較的長いパスフレーズ）が、取り消し前のある時点でエンティティとCA/RAの間で（のみ）共有されます。この値は、後で取り消し要求を認証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "In this specification, the following technique to establish shared secret information (i.e., a revocation passphrase) is OPTIONAL to support. Its precise use in CMP messages is as follows.",
      "ja": "この仕様では、共有された秘密情報（つまり、取り消しパスフレーズ）を確立するための次の手法がオプションをサポートするためにオプションです。CMPメッセージでのその正確な使用は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* The OID and value specified in Section 5.3.19.9 MAY be sent in a GenMsg message at any time or MAY be sent in the generalInfo field of the PKIHeader of any PKIMessage at any time. (In particular, the EncryptedKey structure as described in Section 5.2.2 may be sent in the header of the certConf message that confirms acceptance of certificates requested in an initialization request or certificate request message.) This conveys a revocation passphrase chosen by the entity to the relevant CA/RA. When EnvelopedData is used, this is in the decrypted bytes of the encryptedContent field. When EncryptedValue is used, this is in the decrypted bytes of the encValue field. Furthermore, the transfer is accomplished with appropriate confidentiality characteristics.",
      "ja": "* セクション5.3.19.9で指定されているOIDと値は、いつでもGENMSGメッセージで送信されるか、いつでもpkimessageのpkiheaderの一般的なフィールドで送信される場合があります。（特に、セクション5.2.2で説明されている暗号化されたキー構造は、初期化要求または証明書リクエストメッセージで要求された証明書の受け入れを確認するCERTCONFメッセージのヘッダーに送信される場合があります。）これは、エンティティによって選択されたCA/RAに選択された取り消しパスフレーズを伝えます。EnvelopedDataを使用すると、これは暗号化されたコンテンツフィールドの復号化されたバイトにあります。暗号化されたValueを使用すると、これはエンクバリューフィールドの復号化されたバイトにあります。さらに、転送は適切な機密性の特性で達成されます。"
    },
    {
      "indent": 6,
      "text": "* If a CA/RA receives the revocation passphrase (OID and value specified in Section 5.3.19.9) in a GenMsg, it MUST construct and send a GenRep message that includes the OID (with absent value) specified in Section 5.3.19.9. If the CA/RA receives the revocation passphrase in the generalInfo field of a PKIHeader of any PKIMessage, it MUST include the OID (with absent value) in the generalInfo field of the PKIHeader of the corresponding response PKIMessage. If the CA/RA is unable to return the appropriate response message for any reason, it MUST send an error message with a status of \"rejection\" and, optionally, a failInfo reason set.",
      "ja": "* CA/RAがGENMSGでCA/RAが取り消しパスフレーズ（OIDおよび値5.3.19.9で指定されている値）を受信した場合、セクション5.3.19.9で指定されているOID（存在しない値を持つ）を含むGenRepメッセージを構築および送信する必要があります。CA/RAが、pkimessageのpkiheaderのGeneralInfoフィールドで取り消しパスフレーズを受信した場合、対応する応答pkimessageのpkiheaderのGeneralInfoフィールドにoid（価値がない）を含める必要があります。CA/RAが何らかの理由で適切な応答メッセージを返すことができない場合、「拒否」のステータス、およびオプションではfailinfo理由セットのエラーメッセージを送信する必要があります。"
    },
    {
      "indent": 6,
      "text": "* Either the localKeyId attribute of EnvelopedData as specified in [RFC2985] or the valueHint field of EncryptedValue MAY contain a key identifier (chosen by the entity, along with the passphrase itself) to assist in later retrieval of the correct passphrase (e.g., when the revocation request is constructed by the end entity and received by the CA/RA).",
      "ja": "* [RFC2985]で指定されているEnvelopedDataのLocalKeyID属性または暗号化されたバリューのValueHintフィールドには、キー識別子（エンティティによって選択され、パスフレーズ自体とともに選択）が含まれている場合があります。"
    },
    {
      "indent": 6,
      "text": "* The revocation request message is protected by a password-based MAC (see Section 6.1 of \"CMP Algorithms\" [RFC9481]) with the revocation passphrase as the key. If appropriate, the senderKID field in the PKIHeader MAY contain the value previously transmitted in localKeyId or valueHint.",
      "ja": "* 取り消し要求メッセージは、パスワードベースのMAC（「CMPアルゴリズム」のセクション6.1を参照[RFC9481]）によって保護されており、撤回パスフレーズはキーです。必要に応じて、pkiheaderのsenderkidフィールドには、localkeyidまたはvaluehintで以前に送信された値が含まれている場合があります。"
    },
    {
      "indent": 3,
      "text": "Note: For a message transferring a revocation passphrase indicating cmp2021(3) in the pvno field of the PKIHeader, the encrypted passphrase MUST be transferred in the envelopedData choice of EncryptedKey as defined in Section 5.2.2. When using cmp2000(2) in the message header for backward compatibility, the encryptedValue is used. This allows the necessary conveyance and protection of the passphrase while maintaining bits-on-the-wire compatibility with [RFC4210]. The encryptedValue choice has been deprecated in favor of encryptedData.",
      "ja": "注：PKIHeaderのPVNOフィールドでCMP2021（3）を示す取り消しパスフレーズを転送するメッセージの場合、セクション5.2.2で定義されている暗号化された暗号化されたKeyの選択肢で暗号化されたパスフレーズを転送する必要があります。後方互換性のためにメッセージヘッダーでCMP2000（2）を使用する場合、暗号化されたバリューが使用されます。これにより、[RFC4210]とワイヤーのビット互換性を維持しながら、必要な輸送とパスフレーズの保護が可能になります。暗号化されたバリューの選択は、暗号化されたDataを支持して廃止されました。"
    },
    {
      "indent": 3,
      "text": "Using the technique specified above, the revocation passphrase may be initially established and updated at any time without requiring extra messages or out-of-band exchanges. For example, the revocation request message itself (protected and authenticated through a MAC that uses the revocation passphrase as a key) may contain, in the PKIHeader, a new revocation passphrase to be used for authenticating future revocation requests for any of the entity's other certificates. In some environments, this may be preferable to mechanisms that reveal the passphrase in the revocation request message, since this can allow a denial-of-service attack in which the revealed passphrase is used by an unauthorized third party to authenticate revocation requests on the entity's other certificates. However, because the passphrase is not revealed in the request message, there is no requirement that the passphrase must always be updated when a revocation request is made (that is, the same passphrase MAY be used by an entity to authenticate revocation requests for different certificates at different times).",
      "ja": "上記で指定された手法を使用すると、取り消しパスフレーズは、追加のメッセージや帯域外の交換を必要とせずに、いつでもいつでも確立および更新できます。たとえば、取り消しリクエストメッセージ自体（失効パスフレーズをキーとして使用するMACを介して保護および認証された）には、PKIHeaderには、エンティティの他の証明書の将来の取り消し要求を認証するために使用される新しい取り消しパスフレーズが含まれている場合があります。一部の環境では、これは取り消しリクエストメッセージのパスフレーズを明らかにするメカニズムよりも好ましい場合があります。これにより、明らかにされたパスフレーズが不正な第三者が使用するサービス拒否攻撃が可能であるため、エンティティの他の証明書の取り消し要求を認証することができます。ただし、パスフレーズはリクエストメッセージで明らかにされていないため、失効リクエストが行われたときにパスフレーズを常に更新する必要はありません（つまり、同じパスフレーズをエンティティが使用して、異なる時期に異なる証明書のリクエストを認証することができます）。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the above technique can provide strong cryptographic protection over the entire revocation request message even when a digital signature is not used. Techniques that do authentication of the revocation request by simply revealing the revocation passphrase typically do not provide cryptographic protection over the fields of the request message (so that a request for revocation of one certificate may be modified by an unauthorized third party to a request for revocation of another certificate for that entity).",
      "ja": "さらに、上記の手法は、デジタル署名が使用されていない場合でも、取り消し要求メッセージ全体で強力な暗号化保護を提供できます。取り消しパスフレーズを明らかにするだけで取り消し要求の認証を行う手法は、通常、要求メッセージのフィールドに暗号化保護を提供しません（そのため、1つの証明書の取り消しの要求は、そのエンティティの別の証明書の取り消し要求のために不正な第三者によって変更される可能性があります）。"
    },
    {
      "indent": 0,
      "text": "Appendix C. PKI Management Message Profiles (REQUIRED)",
      "section_title": true,
      "ja": "付録C. PKI管理メッセージプロファイル（必須）"
    },
    {
      "indent": 3,
      "text": "This appendix contains detailed profiles for those PKIMessages that MUST be supported by conforming implementations (see Section 6).",
      "ja": "この付録には、実装を適合させることでサポートする必要があるこれらのpkimessageの詳細なプロファイルが含まれています（セクション6を参照）。"
    },
    {
      "indent": 3,
      "text": "Note: Appendices C and D focus on PKI management operations managing certificates for human end entities. In contrast, the Lightweight CMP Profile [RFC9483] focuses on typical use cases of industrial and IoT scenarios supporting highly automated certificate lifecycle management scenarios.",
      "ja": "注：付録CおよびDは、人間の最終エンティティの証明書を管理するPKI管理操作に焦点を当てています。対照的に、軽量CMPプロファイル[RFC9483]は、高度に自動化された証明書ライフサイクル管理シナリオをサポートする産業およびIoTシナリオの典型的なユースケースに焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "Profiles for the PKIMessages used in the following PKI management operations are provided:",
      "ja": "次のPKI管理操作で使用されるPKIMESSAGEのプロファイルが提供されます。"
    },
    {
      "indent": 6,
      "text": "* initial registration/certification",
      "ja": "* 初期登録/認定"
    },
    {
      "indent": 6,
      "text": "* basic authenticated scheme",
      "ja": "* 基本的な認証されたスキーム"
    },
    {
      "indent": 6,
      "text": "* certificate request",
      "ja": "* 証明書リクエスト"
    },
    {
      "indent": 6,
      "text": "* key update",
      "ja": "* キーアップデート"
    },
    {
      "indent": 0,
      "text": "C.1. General Rules for Interpretation of These Profiles",
      "section_title": true,
      "ja": "C.1. これらのプロファイルの解釈に関する一般的なルール"
    },
    {
      "indent": 8,
      "text": "1. Where OPTIONAL or DEFAULT fields are not mentioned in individual profiles, they SHOULD be absent from the relevant message (i.e., a receiver can validly reject a message containing such fields as being syntactically incorrect). Mandatory fields are not mentioned if they have an obvious value. The protocol version number MUST be set as specified in Section 7).",
      "ja": "1. 個々のプロファイルでオプションまたはデフォルトのフィールドが言及されていない場合、関連するメッセージに存在しないはずです（つまり、受信者は、このフィールドを含むメッセージを構文的に間違っていることを有効に拒否できます）。必須のフィールドは、明らかな値を持っている場合、言及されていません。プロトコルバージョン番号は、セクション7で指定されているように設定する必要があります。"
    },
    {
      "indent": 8,
      "text": "2. Where structures occur in more than one message, they are separately profiled as appropriate.",
      "ja": "2. 構造が複数のメッセージで発生する場合、必要に応じて個別にプロファイルされます。"
    },
    {
      "indent": 8,
      "text": "3. The algorithmIdentifiers from PKIMessage structures are profiled separately.",
      "ja": "3. pkimessage構造からのアルゴリズムのdididifiersは、個別にプロファイルされています。"
    },
    {
      "indent": 8,
      "text": "4. A \"special\" X.500 DN is called the \"NULL-DN\"; this means a DN containing a zero-length SEQUENCE OF RelativeDistinguishedNames (its DER encoding is then '3000'H).",
      "ja": "4. 「特別な」X.500 DNは「null-dn」と呼ばれます。これは、relativedististinguednamesのゼロ長シーケンスを含むDNを意味します（そのderエンコーディングは '3000'h）。"
    },
    {
      "indent": 8,
      "text": "5. Where a GeneralName is required for a field, but no suitable value is available (e.g., an end entity produces a request before knowing its name), then the GeneralName is to be an X.500 NULL-DN (i.e., the Name field of the CHOICE is to contain a NULL-DN).",
      "ja": "5. フィールドには一般名が必要ですが、適切な値が利用できない場合（たとえば、エンティティはその名前を知る前にリクエストを生成します）、一般名はx.500 null-dnになります（つまり、選択の名前フィールドはnull-dnを含むことです）。"
    },
    {
      "indent": 8,
      "text": "6. Where a profile omits to specify the value for a GeneralName, then the NULL-DN value is to be present in the relevant PKIMessage field. This occurs with the sender field of the PKIHeader for some messages.",
      "ja": "6. プロファイルが省略して一般名の値を指定する場合、null-dn値は関連するpkimessageフィールドに存在します。これは、一部のメッセージに対してPKIHeaderの送信者フィールドで発生します。"
    },
    {
      "indent": 8,
      "text": "7. Where any ambiguity arises due to naming of fields, the profile names these using a \"dot\" notation (e.g., \"certTemplate.subject\" means the subject field within a field called certTemplate).",
      "ja": "7. フィールドの命名によりあいまいさが生じる場合、プロファイルは「ドット」表記（「certtemplate.subject」を意味する」を使用してこれらに名前を付けます。"
    },
    {
      "indent": 8,
      "text": "8. Where a \"SEQUENCE OF types\" is part of a message, a zero-based array notation is used to describe fields within the SEQUENCE OF (e.g., crm[0].certReq.certTemplate.subject refers to a subfield of the first CertReqMsg contained in a request message).",
      "ja": "8. 「タイプのシーケンス」がメッセージの一部である場合、ゼロベースの配列表記を使用して、一連のシーケンス内のフィールドを記述します（例えば、CRM [0] .Certreq.CertTemplate.Subjectは、リクエストメッセージに含まれる最初のcertreqMSGのサブフィールドを指します）。"
    },
    {
      "indent": 8,
      "text": "9. All PKI message exchanges in Appendices C.4 to C.6 require a certConf message to be sent by the initiating entity and a pkiconf message to be sent by the responding entity. The pkiconf is not included in some of the profiles given since its body is NULL and its header contents are clear from the context. Any authenticated means can be used for the protectionAlg (e.g., password-based MAC, if shared secret information is known, or signature).",
      "ja": "9. 付録C.4からC.6のすべてのPKIメッセージ交換では、開始エンティティによって送信されるCERTCONFメッセージと、応答エンティティによって送信されるPKICONFメッセージが必要です。PKICONFは、その体がヌルであり、そのヘッダーの内容がコンテキストから明確であるため、与えられたいくつかのプロファイルには含まれていません。認証された手段は、保護物に使用できます（たとえば、共有された秘密情報がわかっている場合、または署名）。"
    },
    {
      "indent": 0,
      "text": "C.2. Algorithm Use Profile",
      "section_title": true,
      "ja": "C.2. アルゴリズムはプロファイルを使用します"
    },
    {
      "indent": 3,
      "text": "For specifications of algorithm identifiers and respective conventions for conforming implementations, please refer to Section 7.1 of CMP Algorithms [RFC9481].",
      "ja": "アルゴリズム識別子の仕様と、実装を適合させるためのそれぞれの規則については、CMPアルゴリズム[RFC9481]のセクション7.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "C.3. POP Profile",
      "section_title": true,
      "ja": "C.3. ポッププロファイル"
    },
    {
      "indent": 3,
      "text": "The table below describes the POP fields for use (in signature field of pop field of ProofOfPossession structure) when proving possession of a private signing key that corresponds to a public verification key for which a certificate has been requested.",
      "ja": "以下の表は、証明書が要求されている公開検証キーに対応するプライベート署名キーの所有を証明する際の使用のためのポップフィールド（POPPOSSESTION構造のポップフィールドの署名フィールド）について説明しています。"
    },
    {
      "indent": 2,
      "text": "  +=====================+=============+===========================+\n  | Field               | Value       | Comment                   |\n  +=====================+=============+===========================+\n  | algorithmIdentifier | MSG_SIG_ALG | only signature protection |\n  |                     |             | is allowed for this proof |\n  +---------------------+-------------+---------------------------+\n  | signature           | present     | bits calculated using     |\n  |                     |             | MSG_SIG_ALG               |\n  +---------------------+-------------+---------------------------+\n\n                               Table 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: For examples of MSG_SIG_ALG OIDs, see Section 3 of CMP Algorithms [RFC9481].",
      "ja": "注：MSG_SIG_ALG OIDSの例については、CMPアルゴリズム[RFC9481]のセクション3を参照してください。"
    },
    {
      "indent": 3,
      "text": "POP of a private decryption key that corresponds to a public encryption key for which a certificate has been requested does not use this profile; the CertHash field of the certConf message is used instead.",
      "ja": "証明書が要求されたパブリック暗号化キーに対応するプライベート復号化キーのポップは、このプロファイルを使用しません。代わりに、CERTCONFメッセージのCerthashフィールドが使用されます。"
    },
    {
      "indent": 3,
      "text": "Not every CA/RA will do POP (of signing key, decryption key, or key agreement key) in the PKIX-CMP in-band certification request protocol (how POP is done MAY ultimately be a policy issue that is made explicit for any given CA in its publicized Policy OID and Certification Practice Statement). However, this specification mandates that CA/RA entities MUST do POP (by some means) as part of the certification process. All end entities MUST be prepared to provide POP (i.e., these components of the PKIX-CMP protocol MUST be supported).",
      "ja": "すべてのCA/RAが、PKIX-CMPインバンド認定リクエストプロトコルで（署名キー、復号化キー、またはキー契約キー）を（署名キー、復号化キー、またはキー契約キーの）POPを実行するわけではありません（最終的に行われる方法は、公表されたポリシーOIDおよび認定慣行声明の任意のCAに対して明示されるポリシーの問題である可能性があります）。ただし、この仕様は、CA/RAエンティティが認証プロセスの一部として（何らかの方法で）POPを行う必要があることを義務付けています。すべてのエンティティをPOPを提供するために準備する必要があります（つまり、PKIX-CMPプロトコルのこれらのコンポーネントをサポートする必要があります）。"
    },
    {
      "indent": 0,
      "text": "C.4. Initial Registration/Certification (Basic Authenticated Scheme)",
      "section_title": true,
      "ja": "C.4. 初期登録/認定（基本認証スキーム）"
    },
    {
      "indent": 3,
      "text": "An (uninitialized) end entity requests a (first) certificate from a CA. When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA sends a pkiconf message back, closing the transaction. All messages are authenticated.",
      "ja": "（非初期化されていない）エンティティは、caから（最初の）証明書を要求します。CAが証明書を含むメッセージで応答すると、End Entityは証明書の確認で応答します。CAはPKICONFメッセージを送り返し、トランザクションを閉じます。すべてのメッセージは認証されています。"
    },
    {
      "indent": 3,
      "text": "This scheme allows the end entity to request certification of a locally generated public key (typically a signature key). The end entity MAY also choose to request the centralized generation and certification of another key pair (typically an encryption key pair).",
      "ja": "このスキームにより、エンティティはローカルに生成された公開キー（通常は署名キー）の認証を要求できます。End Entityは、別のキーペアの集中生成と認証を要求することもできます（通常、暗号化キーペア）。"
    },
    {
      "indent": 3,
      "text": "Certification may only be requested for one locally generated public key (for more, use separate PKIMessages).",
      "ja": "認定は、1つのローカルで生成された公開キーに対してのみ要求される場合があります（詳細については、個別のpkimessageを使用してください）。"
    },
    {
      "indent": 3,
      "text": "The end entity MUST support POP of the private key associated with the locally generated public key.",
      "ja": "最終エンティティは、ローカルに生成された公開キーに関連付けられている秘密鍵のPOPをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 8,
      "text": "1. The end entity can authenticate the CA's signature based on out-of-band means.",
      "ja": "1. 最終エンティティは、帯域外の平均に基づいてCAの署名を認証できます。"
    },
    {
      "indent": 8,
      "text": "2. The end entity and the CA share a symmetric MACing key.",
      "ja": "2. End EntityとCAは、対称マッキングキーを共有します。"
    },
    {
      "indent": 3,
      "text": "Message Flow:",
      "ja": "メッセージフロー："
    },
    {
      "indent": 3,
      "text": "Step# End entity                           PKI\n---------------------------------------------------------------------\n  1   format ir\n  2                     -->   ir      -->\n  3                                        handle ir\n  4                                        format ip\n  5                     <--   ip      <--\n  6   handle ip\n  7   format certConf\n  8                     -->  certConf -->\n  9                                        handle certConf\n 10                                        format pkiconf\n 11                     <--  pkiconf  <--\n 12   handle pkiconf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For this profile, we mandate that the end entity MUST include all (i.e., one or two) CertReqMsg in a single PKIMessage and that the PKI (CA) MUST produce a single response PKIMessage that contains the complete response (i.e., including the OPTIONAL second key pair, if it was requested and if centralized key generation is supported). For simplicity, we also mandate that this message MUST be the final one (i.e., no use of \"waiting\" status value).",
      "ja": "このプロファイルでは、最終エンティティには1つのpkimessageにすべて（1つまたは2つの）certreqmsgを含める必要があり、PKI（CA）は、完全な応答を含む単一の応答pkimessageを作成する必要があることを義務付けています。簡単にするために、このメッセージが最後のものでなければならないことを義務付けています（つまり、「待機」ステータス値を使用しない）。"
    },
    {
      "indent": 3,
      "text": "The end entity has an out-of-band interaction with the CA/RA. This transaction established the shared secret, the referenceNumber, and optionally the DN used for both the sender and subject name in the certificate template. See Section 8.7 for security considerations on quality of shared secret information.",
      "ja": "End Entityには、CA/RAとの外れの相互作用があります。このトランザクションは、共有秘密、ReferenCeNumber、およびオプションでは、証明書テンプレートの送信者と件名名の両方に使用されるDNを確立しました。共有された秘密情報の品質に関するセキュリティに関する考慮事項については、セクション8.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Initialization Request -- ir",
      "ja": "初期化リクエスト-IR"
    },
    {
      "indent": 3,
      "text": "Field                Value\n\nrecipient            CA name\n  -- the name of the CA who is being asked to produce a certificate\nprotectionAlg        MSG_MAC_ALG\n  -- only MAC protection is allowed for this request, based\n  -- on initial authentication key\nsenderKID            referenceNum\n  -- the reference number that the CA has previously issued\n  -- to the end entity (together with the MACing key)\ntransactionID        present\n  -- implementation-specific value, meaningful to end\n  -- entity.\n  -- [If already in use at the CA, then a rejection message MUST\n  -- be produced by the CA]\n\nsenderNonce          present\n  -- 128 (pseudo-)random bits\nfreeText             any valid value\nbody                 ir (CertReqMessages)\n                     only one or two CertReqMsg\n                     are allowed\n  -- if more certificates are required, requests MUST be\n  -- packaged in separate PKIMessages\n\nCertReqMsg           one or two present\n  -- see below for details, note: crm[0] means the first\n  -- (which MUST be present), crm[1] means the second (which\n  -- is OPTIONAL, and used to ask for a centrally generated key)\n\ncrm[0].certReq.      fixed value of zero\n   certReqId\n  -- this is the index of the template within the message\ncrm[0].certReq       present\n   certTemplate\n  -- MUST include subject public key value, otherwise unconstrained\ncrm[0].pop...        optionally present if public key\n   POPOSigningKey    from crm[0].certReq.certTemplate is\n                     a signing key\n  -- POP MAY be required in this exchange\n  -- (see Appendix D.3 for details)\ncrm[0].certReq.      optionally present\n   controls.archiveOptions\n  -- the end entity MAY request that the locally generated\n  -- private key be archived\n\ncrm[0].certReq.      optionally present\n   controls.publicationInfo\n  -- the end entity MAY ask for publication of resulting cert.\n\ncrm[1].certReq       fixed value of one\n      certReqId\n     -- the index of the template within the message\n   crm[1].certReq       present\n      certTemplate\n      -- MUST NOT include actual public key bits, otherwise\n      -- unconstrained (e.g., the names need not be the same as in\n      -- crm[0]).  Note that subjectPublicKeyInfo MAY be present\n      -- and contain an AlgorithmIdentifier followed by a\n      -- zero-length BIT STRING for the subjectPublicKey if it is\n      -- desired to inform the CA/RA of algorithm and parameter\n      -- preferences regarding the to-be-generated key pair.\n\n   crm[1].certReq.      present [object identifier MUST be\n                                 PROT_ENC_ALG]\n\n      controls.protocolEncrKey\n     -- if centralized key generation is supported by this CA,\n     -- this short-term asymmetric encryption key (generated by\n     -- the end entity) will be used by the CA to encrypt (a\n     -- symmetric key used to encrypt) a private key generated by\n     -- the CA on behalf of the end entity\n\ncrm[1].certReq.      optionally present\n   controls.archiveOptions\ncrm[1].certReq.      optionally present\n   controls.publicationInfo\nprotection           present\n  -- bits calculated using MSG_MAC_ALG",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Initialization Response -- ip",
      "ja": "初期化応答-IP"
    },
    {
      "indent": 3,
      "text": "Field                Value\n\nsender               CA name\n  -- the name of the CA who produced the message\nmessageTime          present\n  -- time at which CA produced message\nprotectionAlg        MSG_MAC_ALG\n  -- only MAC protection is allowed for this response\nsenderKID             referenceNum\n  -- the reference number that the CA has previously issued to the\n  -- end entity (together with the MACing key)\ntransactionID        present\n  -- value from corresponding ir message\nsenderNonce          present\n  -- 128 (pseudo-)random bits\nrecipNonce           present\n  -- value from senderNonce in corresponding ir message\nfreeText             any valid value\nbody                 ip (CertRepMessage)\n                     contains exactly one response\n                     for each request\n  -- The PKI (CA) responds to either one or two requests as\n  -- appropriate.  crc[0] denotes the first (always present);\n  -- crc[1] denotes the second (only present if the ir message\n  -- contained two requests and if the CA supports centralized\n  -- key generation).\ncrc[0].              fixed value of zero\n   certReqId\n  -- MUST contain the response to the first request in the\n  -- corresponding ir message\ncrc[0].status.       present, positive values allowed:\n   status               \"accepted\", \"grantedWithMods\"\n                     negative values allowed:\n                        \"rejection\"\ncrc[0].status.       present if and only if\n   failInfo          crc[0].status.status is \"rejection\"\ncrc[0].              present if and only if\n   certifiedKeyPair  crc[0].status.status is\n                        \"accepted\" or \"grantedWithMods\"\ncertificate          present unless end entity's public\n                     key is an encryption key and POP\n                     is done in this in-band exchange\nencryptedCert        present if and only if end entity's\n                     public key is an encryption key and\n                     POP done in this in-band exchange\npublicationInfo      optionally present\n\n  -- indicates where certificate has been published (present\n  -- at discretion of CA)\n\ncrc[1].              fixed value of one\n   certReqId\n  -- MUST contain the response to the second request in the\n  -- corresponding ir message\ncrc[1].status.       present, positive values allowed:\n   status               \"accepted\", \"grantedWithMods\"\n                     negative values allowed:\n                        \"rejection\"\ncrc[1].status.       present if and only if\n   failInfo          crc[0].status.status is \"rejection\"\ncrc[1].              present if and only if\n   certifiedKeyPair  crc[0].status.status is \"accepted\"\n                     or \"grantedWithMods\"\ncertificate          present\nprivateKey           present\n  -- Use EnvelopedData; if backward compatibility is required,\n  -- use EncryptedValue, see Section 5.2.2\npublicationInfo      optionally present\n  -- indicates where certificate has been published (present\n  -- at discretion of CA)\n\nprotection           present\n  -- bits calculated using MSG_MAC_ALG\nextraCerts           optionally present\n  -- the CA MAY provide additional certificates to the end\n  -- entity",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Certificate confirm -- certConf",
      "ja": "証明書確認-CERTCONF"
    },
    {
      "indent": 3,
      "text": "Field                Value\n\nsender               present\n  -- same as in ir\nrecipient            CA name\n  -- the name of the CA who was asked to produce a certificate\ntransactionID        present\n  -- value from corresponding ir and ip messages\nsenderNonce          present\n  -- 128 (pseudo-)random bits\nrecipNonce           present\n  -- value from senderNonce in corresponding ip message\nprotectionAlg        MSG_MAC_ALG\n  -- only MAC protection is allowed for this message.  The\n  -- MAC is based on the initial authentication key shared\n  -- between the end entity and the CA.\n\nsenderKID            referenceNum\n  -- the reference number that the CA has previously issued\n  -- to the end entity (together with the MACing key)\n\nbody                 certConf\n  -- see Section 5.3.18, \"PKI Confirmation Content\", for the\n  -- contents of the certConf fields.\n  -- Note: two CertStatus structures are required if both an\n  -- encryption and a signing certificate were sent.\n\nprotection           present\n  -- bits calculated using MSG_MAC_ALG",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Confirmation -- pkiconf",
      "ja": "確認-PKICONF"
    },
    {
      "indent": 3,
      "text": "Field                Value\n\nsender               present\n  -- same as in ip\nrecipient            present\n  -- sender name from certConf\ntransactionID        present\n  -- value from certConf message\nsenderNonce          present\n  -- 128 (pseudo-)random bits\nrecipNonce           present\n  -- value from senderNonce from certConf message\nprotectionAlg        MSG_MAC_ALG\n  -- only MAC protection is allowed for this message.\nsenderKID            referenceNum\nbody                 pkiconf\nprotection           present\n  -- bits calculated using MSG_MAC_ALG",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "C.5. Certificate Request",
      "section_title": true,
      "ja": "C.5. 証明書リクエスト"
    },
    {
      "indent": 3,
      "text": "An (initialized) end entity requests a certificate from a CA (for any reason). When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA replies with a pkiconf message to close the transaction. All messages are authenticated.",
      "ja": "（初期化された）ENDエンティティは、CAから証明書を要求します（何らかの理由で）。CAが証明書を含むメッセージで応答すると、End Entityは証明書の確認で応答します。CAは、トランザクションを閉じるためにPKICONFメッセージで応答します。すべてのメッセージは認証されています。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix C.4, with the following exceptions:",
      "ja": "この交換のプロファイルは、付録C.4に記載されているプロファイルと同じです。以下の例外を除きます。"
    },
    {
      "indent": 6,
      "text": "* sender name SHOULD be present;",
      "ja": "* 送信者名が存在する必要があります。"
    },
    {
      "indent": 6,
      "text": "* protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY also be supported) in request, response, certConf, and pkiconf messages;",
      "ja": "* Request、Response、certConf、およびPKICONFメッセージで、MSG_SIG_ALGのPrittionalGをサポートする必要があります（MSG_MAC_ALGもサポートされる場合があります）。"
    },
    {
      "indent": 6,
      "text": "* senderKID and recipKID are only present if required for message verification;",
      "ja": "* SenderKidとRecipkidは、メッセージの確認に必要な場合にのみ存在します。"
    },
    {
      "indent": 6,
      "text": "* body is cr or cp;",
      "ja": "* ボディはCRまたはCPです。"
    },
    {
      "indent": 6,
      "text": "* body may contain one or two CertReqMsg structures, but either CertReqMsg may be used to request certification of a locally generated public key or a centrally generated public key (i.e., the position-dependence requirement of Appendix C.4 is removed); and",
      "ja": "* ボディには1つまたは2つのcertreqmsg構造が含まれる場合がありますが、CertreqMSGを使用して、ローカルに生成された公開キーまたは中央生成された公開キーの認証を要求する場合があります（つまり、付録C.4の位置依存要件が削除されます）。そして"
    },
    {
      "indent": 6,
      "text": "* protection bits are calculated according to the protectionAlg field.",
      "ja": "* 保護ビットは、保護分野に従って計算されます。"
    },
    {
      "indent": 0,
      "text": "C.6. Key Update Request",
      "section_title": true,
      "ja": "C.6. キーアップデートリクエスト"
    },
    {
      "indent": 3,
      "text": "An (initialized) end entity requests a certificate from a CA (to update the key pair and/or corresponding certificate that it already possesses). When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA replies with a PKIConfirm to close the transaction. All messages are authenticated.",
      "ja": "（初期化された）ENDエンティティは、CAから証明書を要求します（すでに所有しているキーペアおよび/または対応する証明書を更新するため）。CAが証明書を含むメッセージで応答すると、End Entityは証明書の確認で応答します。CAは、トランザクションを閉じるためにpkiconfirmで応答します。すべてのメッセージは認証されています。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix C.4, with the following exceptions:",
      "ja": "この交換のプロファイルは、付録C.4に記載されているプロファイルと同じです。以下の例外を除きます。"
    },
    {
      "indent": 6,
      "text": "* sender name SHOULD be present;",
      "ja": "* 送信者名が存在する必要があります。"
    },
    {
      "indent": 6,
      "text": "* protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY also be supported) in request, response, certConfirm, and PKIConfirm messages;",
      "ja": "* Request、Response、CertConfirm、およびPKICONFIRMメッセージで、MSG_SIG_ALGのProtectionalgをサポートする必要があります（MSG_MAC_ALGもサポートされる場合があります）。"
    },
    {
      "indent": 6,
      "text": "* senderKID and recipKID are only present if required for message verification;",
      "ja": "* SenderKidとRecipkidは、メッセージの確認に必要な場合にのみ存在します。"
    },
    {
      "indent": 6,
      "text": "* body is kur or kup;",
      "ja": "* 体はkurまたはkupです。"
    },
    {
      "indent": 6,
      "text": "* body may contain one or two CertReqMsg structures, but either CertReqMsg may be used to request certification of a locally generated public key or a centrally generated public key (i.e.,the position-dependence requirement of Appendix C.4 is removed);",
      "ja": "* ボディには1つまたは2つのcertreqmsg構造が含まれる場合がありますが、CertreqMSGを使用して、ローカルに生成された公開キーまたは中央生成された公開キーの認証を要求する場合があります（つまり、付録C.4の位置依存要件が削除されます）。"
    },
    {
      "indent": 6,
      "text": "* protection bits are calculated according to the protectionAlg field; and",
      "ja": "* 保護ビットは、保護分野に従って計算されます。そして"
    },
    {
      "indent": 6,
      "text": "* regCtrl OldCertId SHOULD be used (unless it is clear to both the sender and receiver -- by means not specified in this document -- that it is not needed).",
      "ja": "* regctrl oldcertidを使用する必要があります（このドキュメントでは指定されていないことで、送信者と受信機の両方に明確でない限り、それが必要ではないことを）。"
    },
    {
      "indent": 0,
      "text": "Appendix D. PKI Management Message Profiles (OPTIONAL)",
      "section_title": true,
      "ja": "付録D. PKI管理メッセージプロファイル（オプション）"
    },
    {
      "indent": 3,
      "text": "This appendix contains detailed profiles for those PKIMessages that MAY be supported by implementations.",
      "ja": "この付録には、実装によってサポートされる可能性のあるこれらのpkimessageの詳細なプロファイルが含まれています。"
    },
    {
      "indent": 3,
      "text": "Profiles for the PKIMessages used in the following PKI management operations are provided:",
      "ja": "次のPKI管理操作で使用されるPKIMESSAGEのプロファイルが提供されます。"
    },
    {
      "indent": 6,
      "text": "* root CA key update",
      "ja": "* ルートCAキーアップデート"
    },
    {
      "indent": 6,
      "text": "* information request/response",
      "ja": "* 情報リクエスト/応答"
    },
    {
      "indent": 6,
      "text": "* cross-certification request/response (1-way)",
      "ja": "* 相互認証要求/応答（1ウェイ）"
    },
    {
      "indent": 6,
      "text": "* in-band initialization using external identity certificate",
      "ja": "* 外部ID証明書を使用したバンドの初期化"
    },
    {
      "indent": 3,
      "text": "Future versions of this document may extend the above to include profiles for the operations listed below (along with other operations, if desired).",
      "ja": "このドキュメントの将来のバージョンは、上記を拡張して、以下にリストされている操作のプロファイルを含める場合があります（必要に応じて、他の操作とともに）。"
    },
    {
      "indent": 6,
      "text": "* revocation request",
      "ja": "* 取り消しリクエスト"
    },
    {
      "indent": 6,
      "text": "* certificate publication",
      "ja": "* 証明書の出版物"
    },
    {
      "indent": 6,
      "text": "* CRL publication",
      "ja": "* CRL出版物"
    },
    {
      "indent": 0,
      "text": "D.1. General Rules for Interpretation of These Profiles",
      "section_title": true,
      "ja": "D.1. これらのプロファイルの解釈に関する一般的なルール"
    },
    {
      "indent": 3,
      "text": "Identical to Appendix C.1.",
      "ja": "付録C.1と同一。"
    },
    {
      "indent": 0,
      "text": "D.2. Algorithm Use Profile",
      "section_title": true,
      "ja": "D.2. アルゴリズムはプロファイルを使用します"
    },
    {
      "indent": 3,
      "text": "Identical to Appendix C.2.",
      "ja": "付録C.2と同一。"
    },
    {
      "indent": 0,
      "text": "D.3. Self-Signed Certificates",
      "section_title": true,
      "ja": "D.3. 自己署名証明書"
    },
    {
      "indent": 3,
      "text": "The table below is a profile of how a certificate structure may be \"self-signed\". These structures are used for distribution of new root CA public keys. This can occur in one of three ways (see Section 4.4 above for a description of the use of these structures):",
      "ja": "以下の表は、証明書構造が「自己署名」される方法のプロファイルです。これらの構造は、新しいルートCAパブリックキーの分布に使用されます。これは、3つの方法のいずれかで発生する可能性があります（これらの構造の使用の説明については、上記のセクション4.4を参照してください）："
    },
    {
      "indent": 4,
      "text": "    +============+=============================================+\n    | Type       | Function                                    |\n    +============+=============================================+\n    | newWithNew | a \"self-signed\" certificate; the contained  |\n    |            | public key MUST be usable to verify the     |\n    |            | signature (though this provides only        |\n    |            | integrity and no authentication whatsoever) |\n    +------------+---------------------------------------------+\n    | oldWithNew | previous root CA public key signed with new |\n    |            | private key                                 |\n    +------------+---------------------------------------------+\n    | newWithOld | new root CA public key signed with previous |\n    |            | private key                                 |\n    +------------+---------------------------------------------+\n\n                              Table 3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A newWithNew certificate (including relevant extensions) must contain \"sensible\" values for all fields. For example, when present, subjectAltName MUST be identical to issuerAltName, and, when present, keyIdentifiers must contain appropriate values, et cetera.",
      "ja": "NewWithNew証明書（関連する拡張機能を含む）には、すべてのフィールドに「賢明な」値を含める必要があります。たとえば、存在する場合、subjectaltnameはIssueraltnameと同一である必要があり、存在する場合、keyidentifiersには適切な値などが含まれている必要があります。"
    },
    {
      "indent": 0,
      "text": "D.4. Root CA Key Update",
      "section_title": true,
      "ja": "D.4. ルートCAキーアップデート"
    },
    {
      "indent": 3,
      "text": "A root CA updates its key pair. It then produces a CA key update announcement message that can be made available (via some transport mechanism) to the relevant entities. A confirmation message is not required from the end entities.",
      "ja": "ルートCAはキーペアを更新します。次に、関連するエンティティに（何らかの輸送メカニズムを介して）利用可能にすることができるCAキーアップデートアナウンスメッセージを作成します。最終エンティティからは確認メッセージは必要ありません。"
    },
    {
      "indent": 3,
      "text": "ckuann message:",
      "ja": "ckuannメッセージ："
    },
    {
      "indent": 0,
      "text": "+============+================================+=====================+\n| Field      | Value                          | Comment             |\n+============+================================+=====================+\n| sender     | CA name CA name                |                     |\n+------------+--------------------------------+---------------------+\n| body       | ckuann(RootCaKeyUpdateContent) |                     |\n+------------+--------------------------------+---------------------+\n| newWithNew | optionally present             | see Appendix D.3    |\n|            |                                | above               |\n+------------+--------------------------------+---------------------+\n| newWithOld | optionally present             | see Appendix D.3    |\n|            |                                | above               |\n+------------+--------------------------------+---------------------+\n| oldWithNew | optionally present             | see Appendix D.3    |\n|            |                                | above               |\n+------------+--------------------------------+---------------------+\n| extraCerts | optionally present             | can be used to      |\n|            |                                | \"publish\"           |\n|            |                                | certificates        |\n|            |                                | (e.g.,              |\n|            |                                | certificates        |\n|            |                                | signed using the    |\n|            |                                | new private key)    |\n+------------+--------------------------------+---------------------+\n\n                               Table 4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "D.5. PKI Information Request/Response",
      "section_title": true,
      "ja": "D.5. PKI情報リクエスト/応答"
    },
    {
      "indent": 3,
      "text": "The end entity sends a general message to the PKI requesting details that will be required for later PKI management operations. The RA/CA responds with a general response. If an RA generates the response, then it will simply forward the equivalent message that it previously received from the CA, with the possible addition of certificates to the extraCerts fields of the PKIMessage. A confirmation message is not required from the end entity.",
      "ja": "End Entityは、後のPKI管理操作に必要な詳細を要求するPKIに一般的なメッセージを送信します。RA/CAは、一般的な応答で応答します。RAが応答を生成する場合、PKIMESSAGEのエクストラメッツフィールドに証明書を追加する可能性がある場合、CAから以前に受け取った同等のメッセージを単純に転送します。最終エンティティからは確認メッセージは必要ありません。"
    },
    {
      "indent": 3,
      "text": "Message Flows:",
      "ja": "メッセージの流れ："
    },
    {
      "indent": 3,
      "text": "Step# End entity                        PKI\n---------------------------------------------------------------------\n  1   format genm\n  2                -->   genm   -->\n  3                                     handle genm\n  4                                     produce genp\n  5                <--   genp   <--\n  6   handle genp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "genM:",
      "ja": "Genm："
    },
    {
      "indent": 3,
      "text": "Field               Value\n\nrecipient           CA name\n  -- the name of the CA as contained in issuerAltName\n  -- extensions or issuer fields within certificates\nprotectionAlg       MSG_MAC_ALG or MSG_SIG_ALG\n  -- any authenticated protection alg.\nSenderKID           present if required\n  -- must be present if required for verification of message\n  -- protection\nfreeText            any valid value\nbody                genr (GenReqContent)\nGenMsgContent       empty SEQUENCE\n  -- all relevant information requested\nprotection          present\n  -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "genP:",
      "ja": "Genp："
    },
    {
      "indent": 3,
      "text": "Field                Value\n\nsender               CA name\n  -- name of the CA that produced the message\nprotectionAlg        MSG_MAC_ALG or MSG_SIG_ALG\n  -- any authenticated protection alg.\nsenderKID            present if required\n  -- must be present if required for verification of message\n  -- protection\nbody                 genp (GenRepContent)\nCAProtEncCert        present (object identifier one\n                     of PROT_ENC_ALG), with relevant\n                     value\n  -- to be used if end entity needs to encrypt information for\n  -- the CA (e.g., private key for recovery purposes)\n\nSignKeyPairTypes     present, with relevant value\n  -- the set of signature algorithm identifiers that this CA will\n  -- certify for subject public keys\nEncKeyPairTypes      present, with relevant value\n  -- the set of encryption / key agreement algorithm identifiers that\n  -- this CA will certify for subject public keys\nPreferredSymmAlg     present (object identifier one\n                     of PROT_SYM_ALG) , with relevant\n                     value\n  -- the symmetric algorithm that this CA expects to be used\n  -- in later PKI messages (for encryption)\nRootCaKeyUpdate      optionally present, with\n                     relevant value\n  -- Use RootCaKeyUpdate; if backward compatibility with cmp2000 is\n  -- required, use CAKeyUpdateInfo.\n  -- The CA MAY provide information about a relevant root CA\n  -- key pair using this field (note that this does not imply\n  -- that the responding CA is the root CA in question)\nCurrentCRL           optionally present, with relevant value\n  -- the CA MAY provide a copy of a complete CRL (i.e.,\n  -- fullest possible one)\nprotection           present\n  -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG\nextraCerts           optionally present\n  -- can be used to send some certificates to the end\n  -- entity. An RA MAY add its certificate here.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "D.6. Cross-Certification Request/Response (1-way)",
      "section_title": true,
      "ja": "D.6. 相互認証要求/応答（1ウェイ）"
    },
    {
      "indent": 3,
      "text": "This section describes the creation of a single cross-certificate (i.e., not two at once). The requesting CA MAY choose who is responsible for publication of the cross-certificate created by the responding CA through use of the PKIPublicationInfo control.",
      "ja": "このセクションでは、単一のクロス認証の作成について説明します（つまり、一度に2つではありません）。要求するCAは、PKIPUblicationInfoコントロールの使用を通じて、応答するCAによって作成されたクロス認証の公開に誰が責任を負うかを選択できます。"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 8,
      "text": "1. Responding CA can verify the origin of the request (possibly requiring out-of-band means) before processing the request.",
      "ja": "1. CAの応答は、リクエストを処理する前に、リクエストの原点（おそらく帯域外の手段が必要）を検証できます。"
    },
    {
      "indent": 8,
      "text": "2. Requesting CA can authenticate the authenticity of the origin of the response (possibly requiring out-of-band means) before processing the response.",
      "ja": "2. CAを要求することで、応答を処理する前に、応答の起源（おそらく帯域外の手段が必要）の信頼性を認証できます。"
    },
    {
      "indent": 3,
      "text": "The use of certificate confirmation and the corresponding server confirmation is determined by the generalInfo field in the PKIHeader (see Section 5.1.1). The following profile does not mandate support for either confirmation.",
      "ja": "証明書の確認と対応するサーバーの確認の使用は、PKIHeaderのGeneralINFOフィールドによって決定されます（セクション5.1.1を参照）。次のプロファイルは、どちらの確認もサポートを義務付けていません。"
    },
    {
      "indent": 3,
      "text": "Message Flows:",
      "ja": "メッセージの流れ："
    },
    {
      "indent": 3,
      "text": "Step# Requesting CA                       Responding CA\n---------------------------------------------------------------------\n  1   format ccr\n  2                  -->    ccr    -->\n  3                                       handle ccr\n  4                                       produce ccp\n  5                  <--    ccp    <--\n  6   handle ccp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ccr:",
      "ja": "ccr:"
    },
    {
      "indent": 3,
      "text": "Field                 Value\n\nsender                Requesting CA name\n  -- the name of the CA who produced the message\nrecipient             Responding CA name\n  -- the name of the CA who is being asked to produce a certificate\nmessageTime           time of production of message\n  -- current time at requesting CA\nprotectionAlg         MSG_SIG_ALG\n  -- only signature protection is allowed for this request\nsenderKID             present if required\n  -- must be present if required for verification of message\n  -- protection\nrecipKID             present if required\n  -- must be present if required for verification of message\n  -- protection\ntransactionID         present\n  -- implementation-specific value, meaningful to requesting CA.\n  -- [If already in use at responding CA, then a rejection message\n  -- MUST be produced by responding CA]\nsenderNonce           present\n  -- 128 (pseudo-)random bits\nfreeText              any valid value\nbody                  ccr (CertReqMessages)\n                      only one CertReqMsg\n                      allowed\n  -- if multiple cross-certificates are required, they MUST be\n  -- packaged in separate PKIMessages\ncertTemplate          present\n  -- details follow\nversion               v1 or v3\n  -- v3 STRONGLY RECOMMENDED\nsigningAlg            present\n  -- the requesting CA must know in advance with which algorithm it\n  -- wishes the certificate to be signed\n\nsubject               present\n  -- may be NULL-DN only if subjectAltNames extension value proposed\nvalidity              present\n  -- MUST be completely specified (i.e., both fields present)\nissuer                present\n  -- may be NULL-DN only if issuerAltNames extension value proposed\npublicKey             present\n  -- the key to be certified (which must be for a signing algorithm)\nextensions            optionally present\n  -- a requesting CA must propose values for all extensions\n  -- that it requires to be in the cross-certificate\nPOPOSigningKey        present\n  -- see Appendix C.3: POP Profile\nprotection            present\n  -- bits calculated using MSG_SIG_ALG\nextraCerts            optionally present\n  -- MAY contain any additional certificates that requester wishes\n  -- to include",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ccp:",
      "ja": "ccp:"
    },
    {
      "indent": 3,
      "text": "Field                 Value\n\nsender                Responding CA name\n  -- the name of the CA who produced the message\nrecipient             Requesting CA name\n  -- the name of the CA who asked for production of a certificate\nmessageTime           time of production of message\n  -- current time at responding CA\nprotectionAlg         MSG_SIG_ALG\n  -- only signature protection is allowed for this message\nsenderKID             present if required\n  -- must be present if required for verification of message\n  -- protection\nrecipKID              present if required\ntransactionID         present\n  -- value from corresponding ccr message\nsenderNonce           present\n  -- 128 (pseudo-)random bits\nrecipNonce            present\n-- senderNonce from corresponding ccr message\nfreeText              any valid value\nbody                  ccp (CertRepMessage)\n                      only one CertResponse allowed\n  -- if multiple cross-certificates are required, they MUST be\n  -- packaged in separate PKIMessages\nresponse              present\nstatus                present\n\nPKIStatusInfo.status  present\n  -- if PKIStatusInfo.status is one of:\n  --   accepted, or\n  --   grantedWithMods,\n  -- then certifiedKeyPair MUST be present and failInfo MUST\n  -- be absent\n\nfailInfo              present depending on\n                      PKIStatusInfo.status\n  -- if PKIStatusInfo.status is:\n  --   rejection,\n  -- then certifiedKeyPair MUST be absent and failInfo MUST be\n  -- present and contain appropriate bit settings\n\ncertifiedKeyPair      present depending on\n                      PKIStatusInfo.status\ncertificate           present depending on\n                      certifiedKeyPair\n  -- content of actual certificate must be examined by requesting CA\n  -- before publication\nprotection            present\n  -- bits calculated using MSG_SIG_ALG\nextraCerts            optionally present\n  -- MAY contain any additional certificates that responder wishes\n  -- to include",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "D.7. In-Band Initialization Using External Identity Certificate",
      "section_title": true,
      "ja": "D.7. 外部ID証明書を使用したバンドの初期化"
    },
    {
      "indent": 3,
      "text": "An (uninitialized) end entity wishes to initialize into the PKI with a CA, CA-1. It uses, for authentication purposes, a pre-existing identity certificate issued by another (external) CA, CA-X. A trust relationship must already have been established between CA-1 and CA-X so that CA-1 can validate the end entity identity certificate signed by CA-X. Furthermore, some mechanism must already have been established within the TEE, also known as PSE, of the end entity that would allow it to authenticate and verify PKIMessages signed by CA-1 (as one example, the TEE may contain a certificate issued for the public key of CA-1, signed by another CA that the end entity trusts on the basis of out-of-band authentication techniques).",
      "ja": "（非初期化されていない）エンティティは、CA、CA-1を使用してPKIに初期化したいと考えています。認証のために、別の（外部）CA、CA-Xによって発行された既存のID証明書を使用します。CA-1がCA-Xが署名した最終エンティティID証明書を検証できるように、CA-1とCA-Xの間に信頼関係がすでに確立されている必要があります。さらに、いくつかのメカニズムは、PSEとしても知られているティー内ですでに確立されている必要があります。これにより、CA-1が署名したpkimessageを認証および検証できるようにします（1つの例として、TEEには、帯域存在の認証技術に基づいて最終エンティティが信頼する別のCAが署名したCA-1の公開鍵について発行された証明書が含まれている場合があります）。"
    },
    {
      "indent": 3,
      "text": "The end entity sends an initialization request to start the transaction. When CA-1 responds with a message containing the new certificate, the end entity replies with a certificate confirmation. CA-1 replies with a pkiconf message to close the transaction. All messages are signed (the end entity messages are signed using the private key that corresponds to the public key in its external identity certificate; the CA-1 messages are signed using the private key that corresponds to the public key in a certificate that can be chained to a trust anchor in the end entity's TEE).",
      "ja": "End Entityは、トランザクションを開始するための初期化リクエストを送信します。CA-1が新しい証明書を含むメッセージで応答すると、End Entityは証明書確認で応答します。CA-1は、PKICONFメッセージで返信して、トランザクションを閉じます。すべてのメッセージに署名されます（End Entityメッセージは、外部ID証明書の公開キーに対応する秘密鍵を使用して署名されます。CA-1メッセージは、End EntityのTシャツの信頼アンカーにチェーンできる公開キーに対応する秘密鍵を使用して署名されます）。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix C.4, with the following exceptions:",
      "ja": "この交換のプロファイルは、付録C.4に記載されているプロファイルと同じです。以下の例外を除きます。"
    },
    {
      "indent": 6,
      "text": "* the end entity and CA-1 do not share a symmetric MACing key (i.e., there is no out-of-band shared secret information between these entities);",
      "ja": "* End EntityとCA-1は、対称的なマッキングキーを共有していません（つまり、これらのエンティティ間にバンド外の共有秘密情報はありません）。"
    },
    {
      "indent": 6,
      "text": "* sender name in ir MUST be present (and identical to the subject name present in the external identity certificate);",
      "ja": "* IRの送信者名は存在する必要があります（および外部ID証明書に存在する件名と同じ）。"
    },
    {
      "indent": 6,
      "text": "* protectionAlg of MSG_SIG_ALG MUST be used in all messages;",
      "ja": "* MSG_SIG_ALGのProtectionalgは、すべてのメッセージで使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "* external identity certificate MUST be carried in ir extraCerts field",
      "ja": "* 外部ID証明書は、IRエクストラメートフィールドに携帯する必要があります"
    },
    {
      "indent": 6,
      "text": "* senderKID and recipKID are not used;",
      "ja": "* SenderKidとRecipkidは使用されていません。"
    },
    {
      "indent": 6,
      "text": "* body is ir or ip; and",
      "ja": "* ボディはIRまたはIPです。そして"
    },
    {
      "indent": 6,
      "text": "* protection bits are calculated according to the protectionAlg field.",
      "ja": "* 保護ビットは、保護分野に従って計算されます。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Variants of Using KEM Keys for PKI Message Protection",
      "section_title": true,
      "ja": "付録E. PKIメッセージ保護にKEMキーを使用するバリエーション"
    },
    {
      "indent": 3,
      "text": "As described in Section 5.1.3.4, any party in a PKI management operation may wish to use a KEM key pair for message protection. Possible cases are described below.",
      "ja": "セクション5.1.3.4で説明されているように、PKI管理操作の当事者は、メッセージ保護のためにKEMキーペアを使用することを望む場合があります。可能なケースを以下に説明します。"
    },
    {
      "indent": 3,
      "text": "For any PKI management operation started by a PKI entity with any type of request message, the following message flows describe the use of a KEM key. There are two cases to distinguish, namely whether the PKI entity or the PKI management entity owns a KEM key pair. If both sides own KEM key pairs, the flows need to be combined such that for each direction a shared secret key is established.",
      "ja": "あらゆるタイプのリクエストメッセージを持つPKIエンティティによって開始されたPKI管理操作については、次のメッセージフローがKEMキーの使用を説明しています。区別する2つのケースがあります。つまり、PKIエンティティまたはPKI管理エンティティがKEMキーペアを所有しているかどうかです。両側がKEMキーペアを所有している場合、各方向に共有された秘密の鍵が確立されるように、フローを組み合わせる必要があります。"
    },
    {
      "indent": 3,
      "text": "In the following message flows, Alice indicates the PKI entity that uses a KEM key pair for message authentication and Bob provides the KEM ciphertext using Alice's public KEM key, as described in Section 5.1.3.4.",
      "ja": "次のメッセージフローで、アリスはメッセージ認証にKEMキーペアを使用するPKIエンティティを示し、Bobはセクション5.1.3.4で説明されているように、AliceのパブリックKEMキーを使用してKEM Ciphertextを提供します。"
    },
    {
      "indent": 3,
      "text": "Step# PKI entity                           PKI management entity\n      (Alice)                              (Bob)\n---------------------------------------------------------------------\n  1   format unprotected genm\n        of type\n        KemCiphertextInfo\n        without value, and\n        KEM certificate in\n        extraCerts\n  2                     -->   genm    -->\n  3                                        validate KEM certificate\n  4                                        perform KEM Encapsulate\n  5                                        format unprotected genp\n                                             of type\n                                             KemCiphertextInfo\n                                             providing KEM ciphertext\n  6                     <--   genp    <--\n  7   perform KEM Decapsulate\n  8   perform key derivation\n        to get ssk\n  9   format request with\n        MAC-based protection\n 10                     -->  request  -->\n 11                                        perform key derivation\n                                             to get ssk\n 12                                        verify MAC-based\n                                             protection\n\n--------  PKI entity authenticated by PKI management entity  --------\n\n 13                                        format response with\n                                             protection depending on\n                                             available key material\n 14                     <-- response  <--\n 15   verify protection\n        provided by the\n        PKI management entity\n\n 16       Further messages of this PKI management operation\n        can be exchanged with MAC-based protection by the PKI\n         entity using the established shared secret key (ssk)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 3: Message Flow When the PKI Entity Has a KEM Key Pair and Certificate",
      "ja": "図3：PKIエンティティにKEMキーペアと証明書があるときのメッセージフロー"
    },
    {
      "indent": 3,
      "text": "Step# PKI entity                           PKI management entity\n      (Bob)                                (Alice)\n---------------------------------------------------------------------\n  1   perform KEM Encapsulate\n  2   format request providing\n        KEM ciphertext in\n        generalInfo of type\n        KemCiphertextInfo,\n        and with protection\n        depending on available\n        key material\n  3                     -->  request  -->\n  4                                        perform KEM Decapsulate\n  5                                        perform key derivation\n                                             to get ssk\n  6                                        format response with\n                                             MAC-based protection\n  7                     <-- response  <--\n  8   perform key derivation\n        to get ssk\n  9   verify MAC-based\n        protection\n\n--------  PKI management entity authenticated by PKI entity  --------\n\n 10       Further messages of this PKI management operation\n          can be exchanged with MAC-based protection by the\n             PKI management entity using the established\n                        shared secret key (ssk)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 4: Message Flow When the PKI Entity Knows That the PKI Management Entity Uses a KEM Key Pair and Has the Authentic Public Key",
      "ja": "図4：メッセージフローPKIエンティティがPKI管理エンティティがKEMキーペアを使用し、本物の公開キーを持っていることを知っているとき"
    },
    {
      "indent": 3,
      "text": "Note: Figure 4 describes the situation where KEM-based message protection may not require more than one message exchange. In this case, the transactionID MUST also be used by the PKI entity (Bob) to ensure domain separation between different PKI management operations.",
      "ja": "注：図4は、KEMベースのメッセージ保護が複数のメッセージ交換を必要としない状況を説明しています。この場合、TransactionIDは、PKIエンティティ（BOB）によっても使用され、異なるPKI管理操作間のドメイン分離を確保する必要があります。"
    },
    {
      "indent": 3,
      "text": "Step# PKI entity                           PKI management entity\n      (Bob)                                (Alice)\n---------------------------------------------------------------------\n  1   format request with\n        protection depending\n        on available key\n        material\n  2                     -->  request  -->\n  3                                        format unprotected error\n                                             with status \"rejection\"\n                                             and failInfo\n                                             \"wrongIntegrity\" and KEM\n                                             certificate in\n                                             extraCerts\n  4                     <--   error   <--\n  5   validate KEM certificate\n\n  6              proceed as shown in the figure before",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 5: Message Flow When the PKI Entity Does Not Know That the PKI Management Entity Uses a KEM Key Pair",
      "ja": "図5：PKIエンティティがPKI管理エンティティがKEMキーペアを使用していることがわからない場合のメッセージフロー"
    },
    {
      "indent": 0,
      "text": "Appendix F. Compilable ASN.1 Definitions",
      "section_title": true,
      "ja": "付録F. 編集可能なasn.1定義"
    },
    {
      "indent": 3,
      "text": "This section contains the updated 2002 ASN.1 module from [RFC5912], which was updated in [RFC9480]. This module replaces the module in Section 9 of [RFC5912]. The module contains those changes to the normative ASN.1 module from Appendix F of [RFC4210] that were specified in [RFC9480], as well as changes made in this document. This module makes reference to ASN.1 structures defined in [RFC6268], as well as the UTF-8 encoding defined in [RFC3629].",
      "ja": "このセクションには、[RFC9480]で更新された[RFC5912]の更新された2002 ASN.1モジュールが含まれています。このモジュールは、[RFC5912]のセクション9のモジュールを置き換えます。このモジュールには、[RFC9480]で指定された[RFC4210]の付録Fからの規範ASN.1モジュールの変更と、このドキュメントで行われた変更が含まれています。このモジュールは、[RFC6268]で定義されているASN.1構造と、[RFC3629]で定義されているUTF-8エンコードを参照します。"
    },
    {
      "indent": 3,
      "text": "PKIXCMP-2023\n    { iso(1) identified-organization(3) dod(6) internet(1)\n    security(5) mechanisms(5) pkix(7) id-mod(0)\n    id-mod-cmp2023-02(116) }\nDEFINITIONS EXPLICIT TAGS ::=\nBEGIN\nIMPORTS\n\nAttributeSet{}, SingleAttribute{}, Extensions{}, EXTENSION, ATTRIBUTE\nFROM PKIX-CommonTypes-2009\n    {iso(1) identified-organization(3) dod(6) internet(1) security(5)\n    mechanisms(5) pkix(7) id-mod(0) id-mod-pkixCommon-02(57)}\n\nAlgorithmIdentifier{}, SIGNATURE-ALGORITHM, ALGORITHM,\n    DIGEST-ALGORITHM, MAC-ALGORITHM, KEY-DERIVATION\nFROM AlgorithmInformation-2009\n    {iso(1) identified-organization(3) dod(6) internet(1) security(5)\n    mechanisms(5) pkix(7) id-mod(0)\n    id-mod-algorithmInformation-02(58)}\n\nCertificate, CertificateList, Time, id-kp\nFROM PKIX1Explicit-2009\n    {iso(1) identified-organization(3) dod(6) internet(1) security(5)\n    mechanisms(5) pkix(7) id-mod(0) id-mod-pkix1-explicit-02(51)}\n\nDistributionPointName, GeneralNames, GeneralName, KeyIdentifier\nFROM PKIX1Implicit-2009\n    {iso(1) identified-organization(3) dod(6) internet(1) security(5)\n    mechanisms(5) pkix(7) id-mod(0) id-mod-pkix1-implicit-02(59)}\n\nCertTemplate, PKIPublicationInfo, EncryptedKey, CertId,\n    CertReqMessages, Controls, RegControlSet, id-regCtrl\nFROM PKIXCRMF-2009\n    { iso(1) identified-organization(3) dod(6) internet(1)\n    security(5) mechanisms(5) pkix(7) id-mod(0)\n    id-mod-crmf2005-02(55) }\n    -- The import of EncryptedKey is added due to the updates made\n    -- in [RFC9480]. EncryptedValue does not need to be imported\n    -- anymore and is therefore removed here.\n\nCertificationRequest\nFROM PKCS-10\n    {iso(1) identified-organization(3) dod(6) internet(1) security(5)\n    mechanisms(5) pkix(7) id-mod(0) id-mod-pkcs10-2009(69)}\n-- (specified in [RFC2986] with 1993 ASN.1 syntax and IMPLICIT\n-- tags).  Alternatively, implementers may directly include\n-- the syntax of [RFC2986] in this module.\n\nlocalKeyId\nFROM PKCS-9\n    {iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)\n    modules(0) pkcs-9(1)}\n    -- The import of localKeyId is added due to the updates made in\n    -- [RFC9480]\n\nEnvelopedData, SignedData\nFROM CryptographicMessageSyntax-2010\n    {iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)\n    smime(16) modules(0) id-mod-cms-2009(58)}\n    -- The import of EnvelopedData and SignedData from [RFC6268] is\n    -- added due to the updates made in CMP Updates [RFC9480]\n\nKEM-ALGORITHM\nFROM KEMAlgorithmInformation-2023  -- [RFC9629]\n    { iso(1) identified-organization(3) dod(6) internet(1)\n    security(5) mechanisms(5) pkix(7) id-mod(0)\n    id-mod-kemAlgorithmInformation-2023(109) }\n    -- The import of KEM-ALGORITHM was added due to the updates made\n    -- in [RFC9810]\n;\n\n-- History of the PKIXCMP ASN.1 modules\n-- [RFC2510]\n--    1988 Syntax, PKIXCMP, 1.3.6.1.5.5.7.0.9 (id-mod-cmp)\n--    Obsoleted by RFC 4210 PKIXCMP, 1.3.6.1.5.5.7.0.16\n--                                   (id-mod-cmp2000)\n-- [RFC4210]\n--    1988 Syntax, PKIXCMP, 1.3.6.1.5.5.7.0.16 (id-mod-cmp2000)\n--    Replaced by RFC 9480 PKIXCMP, 1.3.6.1.5.5.7.0.99\n--                                  (id-mod-cmp2021-88)\n-- [RFC5912]\n--    2002 Syntax, PKIXCMP-2009, 1.3.6.1.5.5.7.0.50\n--                               (id-mod-cmp2000-02)\n--    Replaced by RFC 9480 PKIXCMP-2021, 1.3.6.1.5.5.7.0.100\n--                                       (id-mod-cmp2021-02)\n-- [RFC9480]\n--    1988 Syntax, PKIXCMP, 1.3.6.1.5.5.7.0.99 (id-mod-cmp2021-88)\n--    2002 Syntax, PKIXCMP-2021, 1.3.6.1.5.5.7.0.100\n--                               (id-mod-cmp2021-02)\n--    Obsoleted by [RFC9810] PKIXCMP-2023, 1.3.6.1.5.5.7.0.116\n--                                         (id-mod-cmp2023-02)\n-- [RFC9810]\n--    2002 Syntax, PKIXCMP-2023, 1.3.6.1.5.5.7.0.116\n--                               (id-mod-cmp2023-02)\n\n\n-- The rest of the module contains locally defined OIDs and\n-- constructs:\n\nCMPCertificate ::= CHOICE { x509v3PKCert Certificate, ... }\n-- This syntax, while bits-on-the-wire compatible with the\n-- standard X.509 definition of \"Certificate\", allows the\n-- possibility of future certificate types (such as X.509\n-- attribute certificates, card-verifiable certificates, or other\n-- kinds of certificates) within this Certificate Management\n-- Protocol, should a need ever arise to support such generality.\n-- Those implementations that do not foresee a need to ever support\n-- other certificate types MAY, if they wish, comment out the\n-- above structure and \"uncomment\" the following one prior to\n-- compiling this ASN.1 module.  (Note that interoperability\n-- with implementations that don't do this will be unaffected by\n-- this change.)\n\n-- CMPCertificate ::= Certificate\n\nPKIMessage ::= SEQUENCE {\n    header           PKIHeader,\n    body             PKIBody,\n    protection   [0] PKIProtection OPTIONAL,\n    extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                  OPTIONAL }\n\nPKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage\n\nPKIHeader ::= SEQUENCE {\n    pvno                INTEGER     { cmp1999(1), cmp2000(2),\n                                      cmp2021(3) },\n    sender              GeneralName,\n    -- identifies the sender\n    recipient           GeneralName,\n    -- identifies the intended recipient\n    messageTime     [0] GeneralizedTime         OPTIONAL,\n    -- time of production of this message (used when sender\n    -- believes that the transport will be \"suitable\", i.e.,\n    -- that the time will still be meaningful upon receipt)\n    protectionAlg   [1] AlgorithmIdentifier{ALGORITHM, {...}}\n                            OPTIONAL,\n    -- algorithm used for calculation of protection bits\n    senderKID       [2] KeyIdentifier           OPTIONAL,\n    recipKID        [3] KeyIdentifier           OPTIONAL,\n    -- to identify specific keys used for protection\n    transactionID   [4] OCTET STRING            OPTIONAL,\n    -- identifies the transaction, i.e., this will be the same in\n    -- corresponding request, response, certConf, and pkiconf\n    -- messages\n    senderNonce     [5] OCTET STRING            OPTIONAL,\n    recipNonce      [6] OCTET STRING            OPTIONAL,\n    -- nonces used to provide replay protection, senderNonce\n    -- is inserted by the creator of this message; recipNonce\n    -- is a nonce previously inserted in a related message by\n    -- the intended recipient of this message.\n    freeText        [7] PKIFreeText             OPTIONAL,\n    -- this may be used to indicate context-specific instructions\n    -- (this field is intended for human consumption)\n    generalInfo     [8] SEQUENCE SIZE (1..MAX) OF\n                        InfoTypeAndValue     OPTIONAL\n    -- this may be used to convey context-specific information\n    -- (this field is not primarily intended for human consumption)\n}\n\nPKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String\n    -- text encoded as UTF-8 string [RFC3629]\n\nPKIBody ::= CHOICE {       -- message-specific body elements\n    ir       [0]  CertReqMessages,        --Initialization Request\n    ip       [1]  CertRepMessage,         --Initialization Response\n    cr       [2]  CertReqMessages,        --Certification Request\n    cp       [3]  CertRepMessage,         --Certification Response\n    p10cr    [4]  CertificationRequest,   --imported from [RFC2986]\n    popdecc  [5]  POPODecKeyChallContent, --pop Challenge\n    popdecr  [6]  POPODecKeyRespContent,  --pop Response\n    kur      [7]  CertReqMessages,        --Key Update Request\n    kup      [8]  CertRepMessage,         --Key Update Response\n    krr      [9]  CertReqMessages,        --Key Recovery Request\n    krp      [10] KeyRecRepContent,       --Key Recovery Response\n    rr       [11] RevReqContent,          --Revocation Request\n    rp       [12] RevRepContent,          --Revocation Response\n    ccr      [13] CertReqMessages,        --Cross-Cert. Request\n    ccp      [14] CertRepMessage,         --Cross-Cert. Response\n    ckuann   [15] CAKeyUpdContent,        --CA Key Update Ann.\n    cann     [16] CertAnnContent,         --Certificate Ann.\n    rann     [17] RevAnnContent,          --Revocation Ann.\n    crlann   [18] CRLAnnContent,          --CRL Announcement\n    pkiconf  [19] PKIConfirmContent,      --Confirmation\n    nested   [20] NestedMessageContent,   --Nested Message\n    genm     [21] GenMsgContent,          --General Message\n    genp     [22] GenRepContent,          --General Response\n    error    [23] ErrorMsgContent,        --Error Message\n    certConf [24] CertConfirmContent,     --Certificate Confirm\n    pollReq  [25] PollReqContent,         --Polling Request\n    pollRep  [26] PollRepContent          --Polling Response\n}\n\nPKIProtection ::= BIT STRING\n\nProtectedPart ::= SEQUENCE {\n    header    PKIHeader,\n    body      PKIBody }\n\nid-PasswordBasedMac OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    usa(840) nt(113533) nsn(7) algorithms(66) 13 }\nPBMParameter ::= SEQUENCE {\n    salt                OCTET STRING,\n    -- Note:  Implementations MAY wish to limit acceptable sizes\n    -- of this string to values appropriate for their environment\n    -- in order to reduce the risk of denial-of-service attacks.\n    owf                 AlgorithmIdentifier{DIGEST-ALGORITHM, {...}},\n    -- AlgId for the OWF\n    iterationCount      INTEGER,\n    -- number of times the OWF is applied\n    -- Note:  Implementations MAY wish to limit acceptable sizes\n    -- of this integer to values appropriate for their environment\n    -- in order to reduce the risk of denial-of-service attacks.\n    mac                 AlgorithmIdentifier{MAC-ALGORITHM, {...}}\n    -- AlgId of the MAC algorithm\n}\n\nid-DHBasedMac OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    usa(840) nt(113533) nsn(7) algorithms(66) 30 }\nDHBMParameter ::= SEQUENCE {\n    owf                 AlgorithmIdentifier{DIGEST-ALGORITHM, {...}},\n    -- AlgId for an OWF\n    mac                 AlgorithmIdentifier{MAC-ALGORITHM, {...}}\n    -- AlgId of the MAC algorithm\n}\n\n-- id-KemBasedMac and KemBMParameter were added in [RFC9810]\n\nid-KemBasedMac OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    usa(840) nt(113533) nsn(7) algorithms(66) 16 }\nKemBMParameter ::= SEQUENCE {\n    kdf              AlgorithmIdentifier{KEY-DERIVATION, {...}},\n    -- AlgId of the Key Derivation Function algorithm\n    kemContext   [0] OCTET STRING OPTIONAL,\n    -- MAY contain additional algorithm-specific context information\n    len              INTEGER (1..MAX),\n    -- Defines the length of the keying material output of the KDF\n    -- SHOULD be the maximum key length of the MAC function\n    mac              AlgorithmIdentifier{MAC-ALGORITHM, {...}}\n    -- AlgId of the MAC algorithm\n}\n\nPKIStatus ::= INTEGER {\n    accepted               (0),\n    -- you got exactly what you asked for\n    grantedWithMods        (1),\n    -- you got something like what you asked for; the\n    -- requester is responsible for ascertaining the differences\n    rejection              (2),\n    -- you don't get it, more information elsewhere in the message\n    waiting                (3),\n    -- the request body part has not yet been processed; expect to\n    -- hear more later (note: proper handling of this status\n    -- response MAY use the polling req/rep PKIMessages specified\n    -- in Section 5.3.22; alternatively, polling in the underlying\n    -- transport layer MAY have some utility in this regard)\n    revocationWarning      (4),\n    -- this message contains a warning that a revocation is\n    -- imminent\n    revocationNotification (5),\n    -- notification that a revocation has occurred\n    keyUpdateWarning       (6)\n    -- update already done for the oldCertId specified in\n    -- CertReqMsg\n}\n\nPKIFailureInfo ::= BIT STRING {\n-- since we can fail in more than one way!\n-- More codes may be added in the future if/when required.\n    badAlg              (0),\n    -- unrecognized or unsupported algorithm identifier\n    badMessageCheck     (1),\n    -- integrity check failed (e.g., signature did not verify)\n    badRequest          (2),\n    -- transaction not permitted or supported\n    badTime             (3),\n    -- messageTime was not sufficiently close to the system time,\n    -- as defined by local policy\n    badCertId           (4),\n    -- no certificate could be found matching the provided criteria\n    badDataFormat       (5),\n    -- the data submitted has the wrong format\n    wrongAuthority      (6),\n    -- the authority indicated in the request is different from the\n    -- one creating the response token\n    incorrectData       (7),\n    -- the requester's data is incorrect (for notary services)\n    missingTimeStamp    (8),\n    -- when the timestamp is missing but should be there\n    -- (by policy)\n    badPOP              (9),\n    -- the POP failed\n    certRevoked         (10),\n    -- the certificate has already been revoked\n    certConfirmed       (11),\n    -- the certificate has already been confirmed\n    wrongIntegrity      (12),\n    -- KEM ciphertext missing for MAC-based protection of response,\n    -- or not valid integrity of message received (password based\n    -- instead of signature or vice versa)\n    badRecipientNonce   (13),\n    -- not valid recipient nonce, either missing or wrong value\n    timeNotAvailable    (14),\n    -- the TSA's time source is not available\n    unacceptedPolicy    (15),\n    -- the requested TSA policy is not supported by the TSA\n    unacceptedExtension (16),\n    -- the requested extension is not supported by the TSA\n    addInfoNotAvailable (17),\n    -- the additional information requested could not be\n    -- understood or is not available\n    badSenderNonce      (18),\n    -- not valid sender nonce, either missing or wrong size\n    badCertTemplate     (19),\n    -- not valid cert. template or missing mandatory information\n    signerNotTrusted    (20),\n    -- signer of the message unknown or not trusted\n    transactionIdInUse  (21),\n    -- the transaction identifier is already in use\n    unsupportedVersion  (22),\n    -- the version of the message is not supported\n    notAuthorized       (23),\n    -- the sender was not authorized to make the preceding\n    -- request or perform the preceding action\n    systemUnavail       (24),\n    -- the request cannot be handled due to system unavailability\n    systemFailure       (25),\n    -- the request cannot be handled due to system failure\n    duplicateCertReq    (26)\n    -- certificate cannot be issued because a duplicate\n    -- certificate already exists\n}\n\nPKIStatusInfo ::= SEQUENCE {\n    status        PKIStatus,\n    statusString  PKIFreeText     OPTIONAL,\n    failInfo      PKIFailureInfo  OPTIONAL }\n\nOOBCert ::= CMPCertificate\n\nOOBCertHash ::= SEQUENCE {\n    hashAlg     [0] AlgorithmIdentifier{DIGEST-ALGORITHM, {...}}\n                        OPTIONAL,\n    certId      [1] CertId                  OPTIONAL,\n    hashVal         BIT STRING\n    -- hashVal is calculated over the DER encoding of the\n    -- self-signed certificate with the identifier certID.\n}\n\nPOPODecKeyChallContent ::= SEQUENCE OF Challenge\n-- One Challenge per encryption or key agreement key certification\n-- request (in the same order as these requests appear in\n-- CertReqMessages).\n\n-- encryptedRand was added in [RFC9810]\n\nChallenge ::= SEQUENCE {\n   owf                 AlgorithmIdentifier{DIGEST-ALGORITHM, {...}}\n                            OPTIONAL,\n   -- MUST be present in the first Challenge; MAY be omitted in\n   -- any subsequent Challenge in POPODecKeyChallContent (if\n   -- omitted, then the owf used in the immediately preceding\n   -- Challenge is to be used).\n   witness             OCTET STRING,\n   -- the result of applying the OWF to a\n   -- randomly generated INTEGER, A. (Note that a different\n   -- INTEGER MUST be used for each Challenge.)\n   challenge           OCTET STRING,\n   -- MUST be used for cmp2000(2) popdecc messages and MUST be\n   -- the encryption of Rand (using a mechanism depending on the\n   -- private key type).\n   -- MUST be an empty OCTET STRING for cmp2021(3) popdecc messages.\n   -- Note: Using challenge omitting the optional encryptedRand is\n   -- bit-compatible to the syntax without adding this optional\n   -- field.\n   encryptedRand   [0] EnvelopedData OPTIONAL\n   -- MUST be omitted for cmp2000(2) popdecc messages.\n   -- MUST be used for cmp2021(3) popdecc messages and MUST contain\n   -- the encrypted value of Rand using CMS EnvelopedData using the\n   -- key management technique depending on the private key type as\n   -- defined in Section 5.2.2.\n}\n\n-- Rand was added in [RFC9480]\n\nRand ::= SEQUENCE {\n-- Rand is encrypted involving the public key to form the content of\n-- challenge or encryptedRand in POPODecKeyChallContent\n   int                  INTEGER,\n   -- the randomly generated INTEGER A (above)\n   sender               GeneralName\n   -- the sender's name (as included in PKIHeader)\n}\n\nPOPODecKeyRespContent ::= SEQUENCE OF INTEGER\n-- One INTEGER per encryption or key agreement key certification\n-- request (in the same order as these requests appear in\n-- CertReqMessages). The retrieved INTEGER A (above) is returned to\n-- the sender of the corresponding Challenge.\n\nCertRepMessage ::= SEQUENCE {\n    caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                  OPTIONAL,\n    response         SEQUENCE OF CertResponse }\n\nCertResponse ::= SEQUENCE {\n    certReqId           INTEGER,\n    -- to match this response with the corresponding request (a value\n    -- of -1 is to be used if certReqId is not specified in the\n    -- corresponding request, which can only be a p10cr)\n    status              PKIStatusInfo,\n    certifiedKeyPair    CertifiedKeyPair    OPTIONAL,\n    rspInfo             OCTET STRING        OPTIONAL\n    -- analogous to the id-regInfo-utf8Pairs string defined\n    -- for regInfo in CertReqMsg [RFC4211]\n}\n\nCertifiedKeyPair ::= SEQUENCE {\n    certOrEncCert       CertOrEncCert,\n    privateKey      [0] EncryptedKey      OPTIONAL,\n    -- See [RFC4211] for comments on encoding.\n    -- Changed from EncryptedValue to EncryptedKey as a CHOICE of\n    -- EncryptedValue and EnvelopedData due to the changes made in\n    -- [RFC9480].\n    -- Using the choice EncryptedValue is bit-compatible to the\n    -- syntax without this change.\n    publicationInfo [1] PKIPublicationInfo  OPTIONAL }\n\nCertOrEncCert ::= CHOICE {\n    certificate     [0] CMPCertificate,\n    encryptedCert   [1] EncryptedKey\n    -- Changed from Encrypted Value to EncryptedKey as a CHOICE of\n    -- EncryptedValue and EnvelopedData due to the changes made in\n    -- [RFC9480].\n    -- Using the choice EncryptedValue is bit-compatible to the\n    -- syntax without this change.\n}\n\nKeyRecRepContent ::= SEQUENCE {\n    status                  PKIStatusInfo,\n    newSigCert          [0] CMPCertificate OPTIONAL,\n    caCerts             [1] SEQUENCE SIZE (1..MAX) OF\n                                     CMPCertificate OPTIONAL,\n    keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF\n                                     CertifiedKeyPair OPTIONAL }\n\nRevReqContent ::= SEQUENCE OF RevDetails\n\nRevDetails ::= SEQUENCE {\n    certDetails         CertTemplate,\n    -- allows requester to specify as much as they can about\n    -- the cert. for which revocation is requested\n    -- (e.g., for cases in which serialNumber is not available)\n    crlEntryDetails     Extensions{{...}}    OPTIONAL\n    -- requested crlEntryExtensions\n}\n\nRevRepContent ::= SEQUENCE {\n    status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,\n    -- in same order as was sent in RevReqContent\n    revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,\n    -- IDs for which revocation was requested\n    -- (same order as status)\n    crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList OPTIONAL\n    -- the resulting CRLs (there may be more than one)\n}\n\nCAKeyUpdAnnContent ::= SEQUENCE {\n    oldWithNew   CMPCertificate, -- old pub signed with new priv\n    newWithOld   CMPCertificate, -- new pub signed with old priv\n    newWithNew   CMPCertificate  -- new pub signed with new priv\n}\n\n-- CAKeyUpdContent was added in [RFC9810]\nCAKeyUpdContent ::= CHOICE {\n    cAKeyUpdAnnV2      CAKeyUpdAnnContent, -- deprecated\n    cAKeyUpdAnnV3  [0] RootCaKeyUpdateContent\n}\n-- With cmp2021, the use of CAKeyUpdAnnContent is deprecated, use\n-- RootCaKeyUpdateContent instead.\n\nCertAnnContent ::= CMPCertificate\n\nRevAnnContent ::= SEQUENCE {\n    status              PKIStatus,\n    certId              CertId,\n    willBeRevokedAt     GeneralizedTime,\n    badSinceDate        GeneralizedTime,\n    crlDetails          Extensions{{...}}  OPTIONAL\n    -- extra CRL details (e.g., crl number, reason, location, etc.)\n}\n\nCRLAnnContent ::= SEQUENCE OF CertificateList\n\nPKIConfirmContent ::= NULL\n\nNestedMessageContent ::= PKIMessages\n\n-- CertReqTemplateContent, AttributeTypeAndValue,\n-- ExpandedRegControlSet, id-regCtrl-altCertTemplate,\n-- AltCertTemplate, regCtrl-algId, id-regCtrl-algId, AlgIdCtrl,\n-- regCtrl-rsaKeyLen, id-regCtrl-rsaKeyLen, and RsaKeyLenCtrl\n-- were added in [RFC9480]\n\nCertReqTemplateContent ::= SEQUENCE {\n   certTemplate           CertTemplate,\n   -- prefilled certTemplate structure elements\n   -- The SubjectPublicKeyInfo field in the certTemplate MUST NOT\n   -- be used.\n   keySpec                Controls OPTIONAL\n   -- MAY be used to specify supported algorithms\n   -- Controls  ::= SEQUENCE SIZE (1..MAX) OF AttributeTypeAndValue\n   -- as specified in CRMF [RFC4211]\n   }\n\nAttributeTypeAndValue ::= SingleAttribute{{ ... }}\n\nExpandedRegControlSet ATTRIBUTE ::= { RegControlSet |\n   regCtrl-altCertTemplate | regCtrl-algId | regCtrl-rsaKeyLen, ... }\n\nregCtrl-altCertTemplate ATTRIBUTE ::=\n   { TYPE AltCertTemplate IDENTIFIED BY id-regCtrl-altCertTemplate }\n\nid-regCtrl-altCertTemplate OBJECT IDENTIFIER ::= { id-regCtrl 7 }\n\nAltCertTemplate ::= AttributeTypeAndValue\n   -- specifies a template for a certificate other than an X.509v3\n   -- public key certificate\n\nregCtrl-algId ATTRIBUTE ::=\n   { TYPE AlgIdCtrl IDENTIFIED BY id-regCtrl-algId }\n\nid-regCtrl-algId OBJECT IDENTIFIER ::= { id-regCtrl 11 }\n\nAlgIdCtrl ::= AlgorithmIdentifier{ALGORITHM, {...}}\n   -- SHALL be used to specify supported algorithms other than RSA\n\nregCtrl-rsaKeyLen ATTRIBUTE ::=\n   { TYPE RsaKeyLenCtrl IDENTIFIED BY id-regCtrl-rsaKeyLen }\n\nid-regCtrl-rsaKeyLen OBJECT IDENTIFIER ::= { id-regCtrl 12 }\n\nRsaKeyLenCtrl ::= INTEGER (1..MAX)\n   -- SHALL be used to specify supported RSA key lengths\n\n-- RootCaKeyUpdateContent, CRLSource, and CRLStatus were added in\n-- [RFC9480]\n\nRootCaKeyUpdateContent ::= SEQUENCE {\n   newWithNew       CMPCertificate,\n   -- new root CA certificate\n   newWithOld   [0] CMPCertificate OPTIONAL,\n   -- X.509 certificate containing the new public root CA key\n   -- signed with the old private root CA key\n   oldWithNew   [1] CMPCertificate OPTIONAL\n   -- X.509 certificate containing the old public root CA key\n   -- signed with the new private root CA key\n   }\n\nCRLSource ::= CHOICE {\n   dpn          [0] DistributionPointName,\n   issuer       [1] GeneralNames }\n\nCRLStatus ::= SEQUENCE {\n   source       CRLSource,\n   thisUpdate   Time OPTIONAL }\n\n-- KemCiphertextInfo and KemOtherInfo were added in [RFC9810]\n\nKemCiphertextInfo ::= SEQUENCE {\n   kem              AlgorithmIdentifier{KEM-ALGORITHM, {...}},\n   -- AlgId of the KEM algorithm\n   ct               OCTET STRING\n   -- Ciphertext output from the Encapsulate function\n   }\n\nKemOtherInfo ::= SEQUENCE {\n   staticString     PKIFreeText,\n   -- MUST be \"CMP-KEM\"\n   transactionID    OCTET STRING,\n   -- MUST contain the values from the message previously received\n   -- containing the ciphertext (ct) in KemCiphertextInfo\n   kemContext   [0] OCTET STRING OPTIONAL\n   -- MAY contain additional algorithm-specific context information\n  }\n\nINFO-TYPE-AND-VALUE ::= TYPE-IDENTIFIER\n\nInfoTypeAndValue ::= SEQUENCE {\n    infoType    INFO-TYPE-AND-VALUE.\n                    &id({SupportedInfoSet}),\n    infoValue   INFO-TYPE-AND-VALUE.\n                    &Type({SupportedInfoSet}{@infoType}) }\n\nSupportedInfoSet INFO-TYPE-AND-VALUE ::= { ... }\n\n-- Example InfoTypeAndValue contents include, but are not limited\n-- to, the following (uncomment in this ASN.1 module and use as\n-- appropriate for a given environment):\n--\n--   id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}\n--      CAProtEncCertValue      ::= CMPCertificate\n--   id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}\n--      SignKeyPairTypesValue   ::= SEQUENCE SIZE (1..MAX) OF\n--                                      AlgorithmIdentifier{{...}}\n--   id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}\n--      EncKeyPairTypesValue    ::= SEQUENCE SIZE (1..MAX) OF\n--                                      AlgorithmIdentifier{{...}}\n--   id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}\n--      PreferredSymmAlgValue   ::= AlgorithmIdentifier{{...}}\n--   id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}\n--      CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent\n--      - id-it-caKeyUpdateInfo was deprecated with cmp2021\n--   id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}\n--      CurrentCRLValue         ::= CertificateList\n--   id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}\n--      UnsupportedOIDsValue    ::= SEQUENCE SIZE (1..MAX) OF\n--                                          OBJECT IDENTIFIER\n--   id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}\n--      KeyPairParamReqValue    ::= OBJECT IDENTIFIER\n--   id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}\n--      KeyPairParamRepValue    ::= AlgorithmIdentifier{{...}}\n--   id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}\n--      RevPassphraseValue      ::= EncryptedKey\n--      - Changed from Encrypted Value to EncryptedKey as a CHOICE\n--      - of EncryptedValue and EnvelopedData due to the changes\n--      - made in [RFC9480]\n--      - Using the choice EncryptedValue is bit-compatible to\n--      - the syntax without this change\n--   id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}\n--      ImplicitConfirmValue    ::= NULL\n--   id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}\n--      ConfirmWaitTimeValue    ::= GeneralizedTime\n--   id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}\n--      OrigPKIMessageValue     ::= PKIMessages\n--   id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}\n--      SuppLangTagsValue       ::= SEQUENCE OF UTF8String\n--   id-it-caCerts          OBJECT IDENTIFIER ::= {id-it 17}\n--      CaCertsValue            ::= SEQUENCE SIZE (1..MAX) OF\n--                                             CMPCertificate\n--      - id-it-caCerts added in [RFC9480]\n--   id-it-rootCaKeyUpdate  OBJECT IDENTIFIER ::= {id-it 18}\n--      RootCaKeyUpdateValue    ::= RootCaKeyUpdateContent\n--      - id-it-rootCaKeyUpdate added in [RFC9480]\n--   id-it-certReqTemplate  OBJECT IDENTIFIER ::= {id-it 19}\n--      CertReqTemplateValue    ::= CertReqTemplateContent\n--      - id-it-certReqTemplate added in [RFC9480]\n--   id-it-rootCaCert       OBJECT IDENTIFIER ::= {id-it 20}\n--      RootCaCertValue         ::= CMPCertificate\n--      - id-it-rootCaCert added in [RFC9480]\n--   id-it-certProfile      OBJECT IDENTIFIER ::= {id-it 21}\n--      CertProfileValue        ::= SEQUENCE SIZE (1..MAX) OF\n--                                                 UTF8String\n--      - id-it-certProfile added in [RFC9480]\n--   id-it-crlStatusList    OBJECT IDENTIFIER ::= {id-it 22}\n--      CRLStatusListValue      ::= SEQUENCE SIZE (1..MAX) OF\n--                                                  CRLStatus\n--      - id-it-crlStatusList added in [RFC9480]\n--   id-it-crls             OBJECT IDENTIFIER ::= {id-it 23}\n--      CRLsValue               ::= SEQUENCE SIZE (1..MAX) OF\n--                                            CertificateList\n--      - id-it-crls added in [RFC9480]\n--   id-it-KemCiphertextInfo    OBJECT IDENTIFIER ::= {id-it 24}\n--      KemCiphertextInfoValue  ::= KemCiphertextInfo\n--      - id-it-KemCiphertextInfo was added in [RFC9810]\n--\n-- where\n--\n--   id-pkix OBJECT IDENTIFIER ::= {\n--      iso(1) identified-organization(3)\n--      dod(6) internet(1) security(5) mechanisms(5) pkix(7)}\n-- and\n--   id-it   OBJECT IDENTIFIER ::= {id-pkix 4}\n--\n--\n-- This construct MAY also be used to define new PKIX Certificate\n-- Management Protocol request and response messages or\n-- general-purpose (e.g., announcement) messages for future needs\n-- or for specific environments.\n\nGenMsgContent ::= SEQUENCE OF InfoTypeAndValue\n\n-- May be sent by end entity, RA, or CA (depending on message\n-- content).  The OPTIONAL infoValue parameter of InfoTypeAndValue\n-- will typically be omitted for some of the examples given above.\n-- The receiver is free to ignore any contained OIDs that it\n-- does not recognize.  If sent from end entity to CA, the empty set\n-- indicates that the CA may send\n-- any/all information that it wishes.\n\nGenRepContent ::= SEQUENCE OF InfoTypeAndValue\n-- The receiver MAY ignore any contained OIDs that it does not\n-- recognize.\n\nErrorMsgContent ::= SEQUENCE {\n    pKIStatusInfo          PKIStatusInfo,\n    errorCode              INTEGER           OPTIONAL,\n    -- implementation-specific error codes\n    errorDetails           PKIFreeText       OPTIONAL\n    -- implementation-specific error details\n}\n\nCertConfirmContent ::= SEQUENCE OF CertStatus\n\nCertStatus ::= SEQUENCE {\n    certHash    OCTET STRING,\n    -- the hash of the certificate, using the same hash algorithm\n    -- as is used to create and verify the certificate signature\n    certReqId   INTEGER,\n    -- to match this confirmation with the corresponding req/rep\n    statusInfo  PKIStatusInfo OPTIONAL,\n    hashAlg [0] AlgorithmIdentifier{DIGEST-ALGORITHM, {...}} OPTIONAL\n    -- the hash algorithm to use for calculating certHash\n    -- SHOULD NOT be used in all cases where the AlgorithmIdentifier\n    -- of the certificate signature specifies a hash algorithm\n   }\n\nPollReqContent ::= SEQUENCE OF SEQUENCE {\n    certReqId              INTEGER }\n\nPollRepContent ::= SEQUENCE OF SEQUENCE {\n    certReqId              INTEGER,\n    checkAfter             INTEGER,  -- time in seconds\n    reason                 PKIFreeText OPTIONAL }\n\n--\n-- EKU extension for PKI entities used in CMP\n-- operations, added due to the changes made in [RFC9480]\n-- The EKUs for the CA and RA are reused from CMC, as defined in\n-- [RFC6402]\n--\n\n-- id-kp-cmcCA OBJECT IDENTIFIER ::= { id-kp 27 }\n-- id-kp-cmcRA OBJECT IDENTIFIER ::= { id-kp 28 }\nid-kp-cmKGA OBJECT IDENTIFIER ::= { id-kp 32 }\n\nEND",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "section_title": true,
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors of this document wish to thank Carlisle Adams, Stephen Farrell, Tomi Kause, and Tero Mononen, the original authors of [RFC4210], for their work.",
      "ja": "この文書の著者は、[RFC4210]の元の著者であるCarlisle Adams、Stephen Farrell、Tomi Kause、およびTero Mononenに感謝したいと考えています。"
    },
    {
      "indent": 3,
      "text": "We also thank all reviewers of this document for their valuable feedback.",
      "ja": "また、この文書のすべてのレビュアーが貴重なフィードバックをしてくれたことにも感謝します。"
    },
    {
      "indent": 3,
      "text": "Adding KEM support to this document was partly funded by the German Federal Ministry of Education and Research in the project Quoryptan through grant number 16KIS2033.",
      "ja": "この文書へのKEMサポートの追加は、助成金番号16KIS2033を通じて、プロジェクトQuoryptanのドイツ連邦教育省によって部分的に資金提供されていました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "section_title": true,
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Hendrik Brockhaus\nSiemens\nWerner-von-Siemens-Strasse 1\n80333 Munich\nGermany\nEmail: hendrik.brockhaus@siemens.com\nURI:   https://www.siemens.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David von Oheimb\nSiemens\nWerner-von-Siemens-Strasse 1\n80333 Munich\nGermany\nEmail: david.von.oheimb@siemens.com\nURI:   https://www.siemens.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mike Ounsworth\nEntrust\n1187 Park Place\nMinneapolis, MN 55379\nUnited States of America\nEmail: mike.ounsworth@entrust.com\nURI:   https://www.entrust.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "John Gray\nEntrust\n1187 Park Place\nMinneapolis, MN 55379\nUnited States of America\nEmail: john.gray@entrust.com\nURI:   https://www.entrust.com",
      "raw": true,
      "ja": ""
    }
  ]
}