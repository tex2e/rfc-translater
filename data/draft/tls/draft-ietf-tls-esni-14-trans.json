{
  "title": {
    "text": "RFC draft-ietf-tls-esni-14 - TLS Encrypted Client Hello",
    "ja": "RFC draft-ietf-tls-esni-14 - TLSの暗号化されたClient Hello"
  },
  "number": "draft-ietf-tls-esni-14",
  "created_at": "2022-08-12 17:57:17.004651+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "tls                                                          E. Rescorla\nInternet-Draft                                                RTFM, Inc.\nIntended status: Standards Track                                  K. Oku\nExpires: 17 August 2022                                           Fastly\n                                                             N. Sullivan\n                                                               C.A. Wood\n                                                              Cloudflare\n                                                        13 February 2022",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "TLS Encrypted Client Hello draft-ietf-tls-esni-14",
      "ja": "TLS暗号化されたクライアントHello Draft-ITETF-TLS-ESNI-14"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a mechanism in Transport Layer Security (TLS) for encrypting a ClientHello message under a server public key.",
      "ja": "このドキュメントでは、サーバーの公開キーの下でクライアントヘロメッセージを暗号化するための輸送層セキュリティ（TLS）のメカニズムについて説明します。"
    },
    {
      "indent": 0,
      "text": "Discussion Venues",
      "ja": "ディスカッション会場"
    },
    {
      "indent": 3,
      "text": "This note is to be removed before publishing as an RFC.",
      "ja": "このメモは、RFCとして公開する前に削除されます。"
    },
    {
      "indent": 3,
      "text": "Source for this draft and an issue tracker can be found at https://github.com/tlswg/draft-ietf-tls-esni (https://github.com/tlswg/draft-ietf-tls-esni).",
      "ja": "このドラフトと問題トラッカーのソースは、https：//github.com/tlswg/draft-ietf-tls-esni（https://github.com/tlswg/draft-ietf-tls-esni）にあります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.",
      "ja": "このインターネットドラフトは、BCP 78およびBCP 79の規定に完全に適合して提出されています。"
    },
    {
      "indent": 3,
      "text": "Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.",
      "ja": "インターネットドラフトは、インターネットエンジニアリングタスクフォース（IETF）の作業文書です。他のグループは、作業文書をインターネットドラフトとして配布する場合もあることに注意してください。現在のインターネットドラフトのリストは、https：//datatracker.ietf.org/drafts/current/にあります。"
    },
    {
      "indent": 3,
      "text": "Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress.\"",
      "ja": "インターネットドラフトは、最大6か月間有効なドラフトドキュメントであり、いつでも他のドキュメントで更新、交換、または廃止される場合があります。インターネットドラフトを参照資料として使用したり、「進行中の作業」以外に引用することは不適切です。"
    },
    {
      "indent": 3,
      "text": "This Internet-Draft will expire on 17 August 2022.",
      "ja": "このインターネットドラフトは、2022年8月17日に期限切れになります。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/ license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/ license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Conventions and Definitions . . . . . . . . . . . . . . . . .   4\n3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   4\n  3.1.  Topologies  . . . . . . . . . . . . . . . . . . . . . . .   4\n  3.2.  Encrypted ClientHello (ECH) . . . . . . . . . . . . . . .   6\n4.  Encrypted ClientHello Configuration . . . . . . . . . . . . .   6\n  4.1.  Configuration Identifiers . . . . . . . . . . . . . . . .   9\n  4.2.  Configuration Extensions  . . . . . . . . . . . . . . . .   9\n5.  The \"encrypted_client_hello\" Extension  . . . . . . . . . . .  10\n  5.1.  Encoding the ClientHelloInner . . . . . . . . . . . . . .  11\n  5.2.  Authenticating the ClientHelloOuter . . . . . . . . . . .  13\n6.  Client Behavior . . . . . . . . . . . . . . . . . . . . . . .  14\n  6.1.  Offering ECH  . . . . . . . . . . . . . . . . . . . . . .  14\n    6.1.1.  Encrypting the ClientHello  . . . . . . . . . . . . .  16\n    6.1.2.  GREASE PSK  . . . . . . . . . . . . . . . . . . . . .  17\n    6.1.3.  Recommended Padding Scheme  . . . . . . . . . . . . .  17\n    6.1.4.  Determining ECH Acceptance  . . . . . . . . . . . . .  18\n    6.1.5.  Handshaking with ClientHelloInner . . . . . . . . . .  19\n    6.1.6.  Handshaking with ClientHelloOuter . . . . . . . . . .  20\n    6.1.7.  Authenticating for the Public Name  . . . . . . . . .  21\n  6.2.  GREASE ECH  . . . . . . . . . . . . . . . . . . . . . . .  22\n7.  Server Behavior . . . . . . . . . . . . . . . . . . . . . . .  23\n  7.1.  Client-Facing Server  . . . . . . . . . . . . . . . . . .  23\n    7.1.1.  Sending HelloRetryRequest . . . . . . . . . . . . . .  25\n  7.2.  Backend Server  . . . . . . . . . . . . . . . . . . . . .  26\n    7.2.1.  Sending HelloRetryRequest . . . . . . . . . . . . . .  27\n8.  Compatibility Issues  . . . . . . . . . . . . . . . . . . . .  27\n  8.1.  Misconfiguration and Deployment Concerns  . . . . . . . .  28\n  8.2.  Middleboxes . . . . . . . . . . . . . . . . . . . . . . .  28\n9.  Compliance Requirements . . . . . . . . . . . . . . . . . . .  28\n10. Security Considerations . . . . . . . . . . . . . . . . . . .  29\n  10.1.  Security and Privacy Goals . . . . . . . . . . . . . . .  29\n  10.2.  Unauthenticated and Plaintext DNS  . . . . . . . . . . .  30\n  10.3.  Client Tracking  . . . . . . . . . . . . . . . . . . . .  30\n  10.4.  Ignored Configuration Identifiers and Trial\n          Decryption  . . . . . . . . . . . . . . . . . . . . . .  31\n  10.5.  Outer ClientHello  . . . . . . . . . . . . . . . . . . .  31",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  10.6.  Related Privacy Leaks  . . . . . . . . . . . . . . . . .  32\n  10.7.  Cookies  . . . . . . . . . . . . . . . . . . . . . . . .  32\n  10.8.  Attacks Exploiting Acceptance Confirmation . . . . . . .  33\n  10.9.  Comparison Against Criteria  . . . . . . . . . . . . . .  33\n    10.9.1.  Mitigate Cut-and-Paste Attacks . . . . . . . . . . .  34\n    10.9.2.  Avoid Widely Shared Secrets  . . . . . . . . . . . .  34\n    10.9.3.  Prevent SNI-Based Denial-of-Service Attacks  . . . .  34\n    10.9.4.  Do Not Stick Out . . . . . . . . . . . . . . . . . .  34\n    10.9.5.  Maintain Forward Secrecy . . . . . . . . . . . . . .  35\n    10.9.6.  Enable Multi-party Security Contexts . . . . . . . .  36\n    10.9.7.  Support Multiple Protocols . . . . . . . . . . . . .  36\n  10.10. Padding Policy . . . . . . . . . . . . . . . . . . . . .  36\n  10.11. Active Attack Mitigations  . . . . . . . . . . . . . . .  36\n    10.11.1.  Client Reaction Attack Mitigation . . . . . . . . .  37\n    10.11.2.  HelloRetryRequest Hijack Mitigation . . . . . . . .  38\n    10.11.3.  ClientHello Malleability Mitigation . . . . . . . .  39\n    10.11.4.  ClientHelloInner Packet Amplification Mitigation  .  40\n11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  41\n  11.1.  Update of the TLS ExtensionType Registry . . . . . . . .  41\n  11.2.  Update of the TLS Alert Registry . . . . . . . . . . . .  41\n12. ECHConfig Extension Guidance  . . . . . . . . . . . . . . . .  41\n13. References  . . . . . . . . . . . . . . . . . . . . . . . . .  42\n  13.1.  Normative References . . . . . . . . . . . . . . . . . .  42\n  13.2.  Informative References . . . . . . . . . . . . . . . . .  43\nAppendix A.  Alternative SNI Protection Designs . . . . . . . . .  44\n  A.1.  TLS-layer . . . . . . . . . . . . . . . . . . . . . . . .  44\n    A.1.1.  TLS in Early Data . . . . . . . . . . . . . . . . . .  44\n    A.1.2.  Combined Tickets  . . . . . . . . . . . . . . . . . .  44\n  A.2.  Application-layer . . . . . . . . . . . . . . . . . . . .  45\n    A.2.1.  HTTP/2 CERTIFICATE Frames . . . . . . . . . . . . . .  45\nAppendix B.  Linear-time Outer Extension Processing . . . . . . .  45\nAppendix C.  Acknowledgements . . . . . . . . . . . . . . . . . .  46\nAppendix D.  Change Log . . . . . . . . . . . . . . . . . . . . .  46\n  D.1.  Since draft-ietf-tls-esni-12  . . . . . . . . . . . . . .  46\n  D.2.  Since draft-ietf-tls-esni-11  . . . . . . . . . . . . . .  46\n  D.3.  Since draft-ietf-tls-esni-10  . . . . . . . . . . . . . .  46\n  D.4.  Since draft-ietf-tls-esni-09  . . . . . . . . . . . . . .  47\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  47",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "DISCLAIMER: This draft is work-in-progress and has not yet seen significant (or really any) security analysis. It should not be used as a basis for building production systems. This published version of the draft has been designated an \"implementation draft\" for testing and interop purposes.",
      "ja": "免責事項：このドラフトは進行中であり、まだ重要な（または実際にはすべての）セキュリティ分析を見ていません。生産システムを構築するための基礎として使用しないでください。このドラフトの公開されたバージョンは、テストと相互作用の目的のための「実装ドラフト」に指定されています。"
    },
    {
      "indent": 3,
      "text": "Although TLS 1.3 [RFC8446] encrypts most of the handshake, including the server certificate, there are several ways in which an on-path attacker can learn private information about the connection. The plaintext Server Name Indication (SNI) extension in ClientHello messages, which leaks the target domain for a given connection, is perhaps the most sensitive, unencrypted information in TLS 1.3.",
      "ja": "TLS 1.3 [RFC8446]は、サーバー証明書を含むほとんどの握手を暗号化しますが、オンパス攻撃者が接続に関する個人情報を学ぶことができるいくつかの方法があります。特定の接続のターゲットドメインを漏らすClientHelloメッセージのPlantext Server名表示（SNI）拡張機能は、おそらくTLS 1.3で最も敏感で暗号化されていない情報です。"
    },
    {
      "indent": 3,
      "text": "The target domain may also be visible through other channels, such as plaintext client DNS queries or visible server IP addresses. However, DoH [RFC8484] and DPRIVE [RFC7858] [RFC8094] provide mechanisms for clients to conceal DNS lookups from network inspection, and many TLS servers host multiple domains on the same IP address. Private origins may also be deployed behind a common provider, such as a reverse proxy. In such environments, the SNI remains the primary explicit signal used to determine the server's identity.",
      "ja": "ターゲットドメインは、プレーンテキストクライアントDNSクエリや表示可能なサーバーIPアドレスなど、他のチャネルを介して表示される場合があります。ただし、DOH [RFC8484]およびDPRIVE [RFC7858] [RFC8094]は、クライアントがネットワーク検査からDNSルックアップを隠すメカニズムを提供し、多くのTLSサーバーが同じIPアドレスで複数のドメインをホストします。プライベートオリジンは、逆プロキシなどの共通プロバイダーの背後に展開される場合があります。このような環境では、SNIはサーバーのIDを決定するために使用される主要な明示的信号のままです。"
    },
    {
      "indent": 3,
      "text": "This document specifies a new TLS extension, called Encrypted Client Hello (ECH), that allows clients to encrypt their ClientHello to such a deployment. This protects the SNI and other potentially sensitive fields, such as the ALPN list [RFC7301]. Co-located servers with consistent externally visible TLS configurations, including supported versions and cipher suites, form an anonymity set. Usage of this mechanism reveals that a client is connecting to a particular service provider, but does not reveal which server from the anonymity set terminates the connection.",
      "ja": "このドキュメントは、暗号化されたクライアントHello（ECH）と呼ばれる新しいTLS拡張機能を指定します。これにより、クライアントはクライアントHelloをそのような展開に暗号化できます。これにより、ALPNリスト[RFC7301]など、SNIおよびその他の潜在的に敏感なフィールドが保護されます。サポートされているバージョンや暗号スイートを含む一貫した外部で可視されるTLS構成を備えた共同配置サーバーが匿名セットを形成します。このメカニズムを使用すると、クライアントが特定のサービスプロバイダーに接続していることが明らかになりましたが、匿名セットからどのサーバーが接続を終了するかは明らかにしていません。"
    },
    {
      "indent": 3,
      "text": "ECH is only supported with (D)TLS 1.3 [RFC8446] and newer versions of the protocol.",
      "ja": "ECHは、（d）TLS 1.3 [RFC8446]およびプロトコルの新しいバージョンでのみサポートされています。"
    },
    {
      "indent": 0,
      "text": "2. Conventions and Definitions",
      "section_title": true,
      "ja": "2. 慣習と定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here. All TLS notation comes from [RFC8446], Section 3.",
      "ja": "キーワードは「必須」、「必要」、「必須」、「shall」、「shall \"、\" bood \"、\" low \"of\" bould \"、\" becommended \"、\" bodement \"、\" may \"、\" optional「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。すべてのTLS表記は、[RFC8446]、セクション3からのものです。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3. 概要"
    },
    {
      "indent": 3,
      "text": "This protocol is designed to operate in one of two topologies illustrated below, which we call \"Shared Mode\" and \"Split Mode\".",
      "ja": "このプロトコルは、以下に示す2つのトポロジのいずれかで動作するように設計されており、「共有モード」と「スプリットモード」と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "3.1. Topologies",
      "section_title": true,
      "ja": "3.1. トポロジ"
    },
    {
      "indent": 3,
      "text": "                +---------------------+\n                |                     |\n                |   2001:DB8::1111    |\n                |                     |\nClient <----->  | private.example.org |\n                |                     |\n                | public.example.com  |\n                |                     |\n                +---------------------+\n                        Server\n          (Client-Facing and Backend Combined)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 1: Shared Mode Topology",
      "ja": "図1：共有モードトポロジ"
    },
    {
      "indent": 3,
      "text": "In Shared Mode, the provider is the origin server for all the domains whose DNS records point to it. In this mode, the TLS connection is terminated by the provider.",
      "ja": "共有モードでは、プロバイダーは、DNSレコードがそれを指しているすべてのドメインのOrigin Serverです。このモードでは、TLS接続はプロバイダーによって終了します。"
    },
    {
      "indent": 3,
      "text": "           +--------------------+     +---------------------+\n           |                    |     |                     |\n           |   2001:DB8::1111   |     |   2001:DB8::EEEE    |\nClient <----------------------------->|                     |\n           | public.example.com |     | private.example.com |\n           |                    |     |                     |\n           +--------------------+     +---------------------+\n            Client-Facing Server            Backend Server",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Figure 2: Split Mode Topology",
      "ja": "図2：分割モードトポロジ"
    },
    {
      "indent": 3,
      "text": "In Split Mode, the provider is not the origin server for private domains. Rather, the DNS records for private domains point to the provider, and the provider's server relays the connection back to the origin server, who terminates the TLS connection with the client. Importantly, the service provider does not have access to the plaintext of the connection beyond the unencrypted portions of the handshake.",
      "ja": "スプリットモードでは、プロバイダーはプライベートドメインのOrigin Serverではありません。むしろ、プライベートドメインのDNSレコードはプロバイダーを指しており、プロバイダーのサーバーは接続をリレーして、クライアントとのTLS接続を終了するOrigin Serverに戻ります。重要なことに、サービスプロバイダーは、握手の暗号化されていない部分を超えて、接続の平文にアクセスできないことです。"
    },
    {
      "indent": 3,
      "text": "In the remainder of this document, we will refer to the ECH-service provider as the \"client-facing server\" and to the TLS terminator as the \"backend server\". These are the same entity in Shared Mode, but in Split Mode, the client-facing and backend servers are physically separated.",
      "ja": "このドキュメントの残りの部分では、ECH-Serviceプロバイダーを「クライアント向けサーバー」と呼び、TLSターミネーターを「バックエンドサーバー」と呼びます。これらは共有モードで同じエンティティですが、スプリットモードでは、クライアントの向きサーバーとバックエンドサーバーが物理的に分離されています。"
    },
    {
      "indent": 0,
      "text": "3.2. Encrypted ClientHello (ECH)",
      "section_title": true,
      "ja": "3.2. 暗号化されたClientHello（ECH）"
    },
    {
      "indent": 3,
      "text": "A client-facing server enables ECH by publishing an ECH configuration, which is an encryption public key and associated metadata. The server must publish this for all the domains it serves via Shared or Split Mode. This document defines the ECH configuration's format, but delegates DNS publication details to [HTTPS-RR]. Other delivery mechanisms are also possible. For example, the client may have the ECH configuration preconfigured.",
      "ja": "クライアント向けサーバーは、暗号化の公開キーと関連するメタデータであるECH構成を公開することにより、ECHを有効にします。サーバーは、共有モードまたはスプリットモードを介して提供するすべてのドメインに対してこれを公開する必要があります。このドキュメントでは、ECH構成の形式を定義しますが、DNS出版物の詳細を[HTTPS-RR]に委任します。他の送達メカニズムも可能です。たとえば、クライアントはECH構成を事前に設定している場合があります。"
    },
    {
      "indent": 3,
      "text": "When a client wants to establish a TLS session with some backend server, it constructs a private ClientHello, referred to as the ClientHelloInner. The client then constructs a public ClientHello, referred to as the ClientHelloOuter. The ClientHelloOuter contains innocuous values for sensitive extensions and an \"encrypted_client_hello\" extension (Section 5), which carries the encrypted ClientHelloInner. Finally, the client sends ClientHelloOuter to the server.",
      "ja": "クライアントがバックエンドサーバーでTLSセッションを確立したい場合、ClientHelloinnerと呼ばれるプライベートクライアントヘロを構築します。クライアントは、ClientHelloouterと呼ばれるPublic ClientHelloを構築します。ClientHelloouterには、機密拡張機能の無害な値と、暗号化されたClientHelloinnerを搭載した「encrypted_client_hello」拡張機能（セクション5）が含まれています。最後に、クライアントはclienthelloouterをサーバーに送信します。"
    },
    {
      "indent": 3,
      "text": "The server takes one of the following actions:",
      "ja": "サーバーは、次のアクションのいずれかを取得します。"
    },
    {
      "indent": 3,
      "text": "1. If it does not support ECH or cannot decrypt the extension, it completes the handshake with ClientHelloOuter. This is referred to as rejecting ECH.",
      "ja": "1. ECHをサポートしていない場合、または拡張機能を復号化できない場合、ClientHelloouterで握手が完了します。これは拒否ECHと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "2. If it successfully decrypts the extension, it forwards the ClientHelloInner to the backend server, which completes the handshake. This is referred to as accepting ECH.",
      "ja": "2. 拡張機能が正常に復号化された場合、ClientHelloinnerをバックエンドサーバーに転送し、握手が完了します。これは、ECHの受け入れと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving the server's response, the client determines whether or not ECH was accepted (Section 6.1.4) and proceeds with the handshake accordingly. When ECH is rejected, the resulting connection is not usable by the client for application data. Instead, ECH rejection allows the client to retry with up-to-date configuration (Section 6.1.6).",
      "ja": "サーバーの応答を受信すると、クライアントはECHが受け入れられたかどうか（セクション6.1.4）かどうかを判断し、それに応じて握手を進めます。ECHが拒否された場合、結果の接続は、アプリケーションデータについてクライアントが使用できません。代わりに、ECH拒絶により、クライアントは最新の構成で再試行できます（セクション6.1.6）。"
    },
    {
      "indent": 3,
      "text": "The primary goal of ECH is to ensure that connections to servers in the same anonymity set are indistinguishable from one another. Moreover, it should achieve this goal without affecting any existing security properties of TLS 1.3. See Section 10.1 for more details about the ECH security and privacy goals.",
      "ja": "ECHの主な目標は、同じ匿名セットのサーバーへの接続が互いに区別できないことを確認することです。さらに、TLS 1.3の既存のセキュリティプロパティに影響を与えることなく、この目標を達成する必要があります。ECHセキュリティとプライバシーの目標の詳細については、セクション10.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. Encrypted ClientHello Configuration",
      "section_title": true,
      "ja": "4. 暗号化されたClientHello構成"
    },
    {
      "indent": 3,
      "text": "ECH uses HPKE for public key encryption [I-D.irtf-cfrg-hpke]. The ECH configuration is defined by the following ECHConfig structure.",
      "ja": "ECHは、公開キーの暗号化[i-d.irtf-cfrg-hpke]にHPKEを使用します。ECH構成は、次のECHCONFIG構造によって定義されます。"
    },
    {
      "indent": 7,
      "text": "opaque HpkePublicKey<1..2^16-1>;\nuint16 HpkeKemId;  // Defined in I-D.irtf-cfrg-hpke\nuint16 HpkeKdfId;  // Defined in I-D.irtf-cfrg-hpke\nuint16 HpkeAeadId; // Defined in I-D.irtf-cfrg-hpke",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n    HpkeKdfId kdf_id;\n    HpkeAeadId aead_id;\n} HpkeSymmetricCipherSuite;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n    uint8 config_id;\n    HpkeKemId kem_id;\n    HpkePublicKey public_key;\n    HpkeSymmetricCipherSuite cipher_suites<4..2^16-4>;\n} HpkeKeyConfig;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n    HpkeKeyConfig key_config;\n    uint8 maximum_name_length;\n    opaque public_name<1..255>;\n    Extension extensions<0..2^16-1>;\n} ECHConfigContents;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n    uint16 version;\n    uint16 length;\n    select (ECHConfig.version) {\n      case 0xfe0d: ECHConfigContents contents;\n    }\n} ECHConfig;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The structure contains the following fields:",
      "ja": "構造には次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "version The version of ECH for which this configuration is used. Beginning with draft-08, the version is the same as the code point for the \"encrypted_client_hello\" extension. Clients MUST ignore any ECHConfig structure with a version they do not support.",
      "ja": "バージョンこの構成が使用されるECHのバージョン。ドラフト-08から始まるバージョンは、「encrypted_client_hello」拡張子のコードポイントと同じです。クライアントは、サポートしていないバージョンを使用して、eChConfig構造を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "length The length, in bytes, of the next field. This length field allows implementations to skip over the elements in such a list where they cannot parse the specific version of ECHConfig.",
      "ja": "次のフィールドの長さ、バイト単位の長さ。この長さのフィールドにより、実装は、eChConfigの特定のバージョンを解析できないこのようなリストの要素をスキップできます。"
    },
    {
      "indent": 3,
      "text": "contents An opaque byte string whose contents depend on the version. For this specification, the contents are an ECHConfigContents structure.",
      "ja": "内容内容がバージョンに依存する不透明なバイト文字列。この仕様では、内容はeChConfigContents構造です。"
    },
    {
      "indent": 3,
      "text": "The ECHConfigContents structure contains the following fields:",
      "ja": "eChConfigContents構造には、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "key_config A HpkeKeyConfig structure carrying the configuration information associated with the HPKE public key. Note that this structure contains the config_id field, which applies to the entire ECHConfigContents.",
      "ja": "key_config hpkeの公開キーに関連付けられた構成情報を運ぶhpkekeyconfig構造。この構造には、eChConfigContents全体に適用されるconfig_idフィールドが含まれていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "maximum_name_length The longest name of a backend server, if known. If not known, this value can be set to zero. It is used to compute padding (Section 6.1.3) and does not constrain server name lengths. Names may exceed this length if, e.g., the server uses wildcard names or added new names to the anonymity set.",
      "ja": "Maximum_name_length既知の場合、バックエンドサーバーの最長名。不明な場合、この値はゼロに設定できます。パディングの計算に使用され（セクション6.1.3）、サーバー名の長さを制約しません。たとえば、サーバーがワイルドカード名を使用するか、匿名セットに新しい名前を追加した場合、名前はこの長さを超える場合があります。"
    },
    {
      "indent": 3,
      "text": "public_name The DNS name of the client-facing server, i.e., the entity trusted to update the ECH configuration. This is used to correct misconfigured clients, as described in Section 6.1.6.",
      "ja": "public_nameクライアント向けサーバーのDNS名、つまりECH構成を更新すると信頼されているエンティティ。これは、セクション6.1.6で説明されているように、誤解されたクライアントを修正するために使用されます。"
    },
    {
      "indent": 6,
      "text": "Clients MUST ignore any ECHConfig structure whose public_name is not parsable as a dot-separated sequence of LDH labels, as defined in [RFC5890], Section 2.3.1 or which begins or end with an ASCII dot.",
      "ja": "クライアントは、[RFC5890]、セクション2.3.1で定義されている、またはASCII DOTで始まるまたは終了するように、public_nameがLDHラベルのドット分離されたシーケンスとして解析できないeChConfig構造を無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "Clients SHOULD ignore the ECHConfig if it contains an encoded IPv4 address. To determine if a public_name value is an IPv4 address, clients can invoke the IPv4 parser algorithm in [WHATWG-IPV4]. It returns a value when the input is an IPv4 address.",
      "ja": "エンコードされたIPv4アドレスが含まれている場合、クライアントはECHCONFIGを無視する必要があります。public_name値がIPv4アドレスであるかどうかを判断するには、クライアントは[whatwg-ipv4]でIPv4パーサーアルゴリズムを呼び出すことができます。入力がIPv4アドレスである場合、値を返します。"
    },
    {
      "indent": 6,
      "text": "See Section 6.1.7 for how the client interprets and validates the public_name.",
      "ja": "クライアントがpublic_nameを解釈および検証する方法については、セクション6.1.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "extensions A list of extensions that the client must take into consideration when generating a ClientHello message. These are described below (Section 4.2).",
      "ja": "拡張クライアントHelloメッセージを生成するときにクライアントが考慮しなければならない拡張機能のリスト。これらについては、以下に説明します（セクション4.2）。"
    },
    {
      "indent": 3,
      "text": "[[OPEN ISSUE: determine if clients should enforce a 63-octet label limit for public_name]] [[OPEN ISSUE: fix reference to WHATWG-IPV4]]",
      "ja": "[[Open Issue：クライアントがpublic_nameの63-OCTETラベルの制限を実施する必要があるかどうかを判断]]"
    },
    {
      "indent": 3,
      "text": "The HpkeKeyConfig structure contains the following fields:",
      "ja": "hpkekeyconfig構造には、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "config_id A one-byte identifier for the given HPKE key configuration. This is used by clients to indicate the key used for ClientHello encryption. Section 4.1 describes how client-facing servers allocate this value.",
      "ja": "config_id指定されたHPKEキー構成の1バイト識別子。これは、クライアントヘロ暗号化に使用されるキーを示すためにクライアントが使用します。セクション4.1では、クライアント向けサーバーがこの値を割り当てる方法について説明します。"
    },
    {
      "indent": 3,
      "text": "kem_id The HPKE KEM identifier corresponding to public_key. Clients MUST ignore any ECHConfig structure with a key using a KEM they do not support.",
      "ja": "kem_id public_keyに対応するhpke kem識別子。クライアントは、サポートしていないKEMを使用してキーを使用して、eChConfig構造を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "public_key The HPKE public key used by the client to encrypt ClientHelloInner.",
      "ja": "public_key clienthelloinnerを暗号化するためにクライアントが使用するHPKE公開キー。"
    },
    {
      "indent": 3,
      "text": "cipher_suites The list of HPKE KDF and AEAD identifier pairs clients can use for encrypting ClientHelloInner. See Section 6.1 for how clients choose from this list.",
      "ja": "cipher_suites hpke kdfおよびaead識別子ペアクライアントのリストは、clienthelloinnerを暗号化するために使用できます。クライアントがこのリストからどのように選択するかについては、セクション6.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The client-facing server advertises a sequence of ECH configurations to clients, serialized as follows.",
      "ja": "クライアント向けサーバーは、次のようにシリアル化されたクライアントに一連のECH構成を宣伝します。"
    },
    {
      "indent": 7,
      "text": "ECHConfig ECHConfigList<1..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ECHConfigList structure contains one or more ECHConfig structures in decreasing order of preference. This allows a server to support multiple versions of ECH and multiple sets of ECH parameters.",
      "ja": "eChConfiglist構造には、好みの順序を減らす際に1つ以上のeChConfig構造が含まれています。これにより、サーバーはECHの複数のバージョンと複数のECHパラメーターセットをサポートできます。"
    },
    {
      "indent": 0,
      "text": "4.1. Configuration Identifiers",
      "section_title": true,
      "ja": "4.1. 構成識別子"
    },
    {
      "indent": 3,
      "text": "A client-facing server has a set of known ECHConfig values, with corresponding private keys. This set SHOULD contain the currently published values, as well as previous values that may still be in use, since clients may cache DNS records up to a TTL or longer.",
      "ja": "クライアント向けサーバーには、対応するプライベートキーを持つ既知のeChConfig値のセットがあります。このセットには、現在公開されている値と、まだ使用されている以前の値が含まれている必要があります。これは、クライアントがDNSレコードをTTL以上にキャッシュすることができるためです。"
    },
    {
      "indent": 3,
      "text": "Section 7.1 describes a trial decryption process for decrypting the ClientHello. This can impact performance when the client-facing server maintains many known ECHConfig values. To avoid this, the client-facing server SHOULD allocate distinct config_id values for each ECHConfig in its known set. The RECOMMENDED strategy is via rejection sampling, i.e., to randomly select config_id repeatedly until it does not match any known ECHConfig.",
      "ja": "セクション7.1では、clienthelloを復号化するための試行復号化プロセスについて説明します。これは、クライアント向けサーバーが多くの既知のECHCONFIG値を維持すると、パフォーマンスに影響を与える可能性があります。これを回避するために、クライアント向けサーバーは、既知のセットの各eChConfigの個別のconfig_id値を割り当てる必要があります。推奨される戦略は、拒否サンプリング、つまり、既知のeChConfigと一致しないまでconfig_idを繰り返し選択することです。"
    },
    {
      "indent": 3,
      "text": "It is not necessary for config_id values across different client-facing servers to be distinct. A backend server may be hosted behind two different client-facing servers with colliding config_id values without any performance impact. Values may also be reused if the previous ECHConfig is no longer in the known set.",
      "ja": "異なるクライアント向けサーバーのconfig_id値が明確になる必要はありません。バックエンドサーバーは、パフォーマンスに影響を与えずにconfig_id値を備えた2つの異なるクライアント向けサーバーの背後にホストされる場合があります。以前のeChConfigが既知のセットにない場合、値は再利用される場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Configuration Extensions",
      "section_title": true,
      "ja": "4.2. 構成拡張機能"
    },
    {
      "indent": 3,
      "text": "ECH configuration extensions are used to provide room for additional functionality as needed. See Section 12 for guidance on which types of extensions are appropriate for this structure.",
      "ja": "ECH構成拡張機能は、必要に応じて追加の機能の余地を提供するために使用されます。この構造に適切な拡張機能のガイダンスについては、セクション12を参照してください。"
    },
    {
      "indent": 3,
      "text": "The format is as defined in [RFC8446], Section 4.2. The same interpretation rules apply: extensions MAY appear in any order, but there MUST NOT be more than one extension of the same type in the extensions block. An extension can be tagged as mandatory by using an extension type codepoint with the high order bit set to 1.",
      "ja": "この形式は、[RFC8446]、セクション4.2で定義されています。同じ解釈ルールが適用されます：拡張機能は任意の順序で表示される場合がありますが、拡張ブロックに同じタイプの拡張機能が1つ以上ない必要があります。拡張機能は、高次ビットを1に設定した拡張型CodePointを使用することにより、必須としてタグ付けできます。"
    },
    {
      "indent": 3,
      "text": "Clients MUST parse the extension list and check for unsupported mandatory extensions. If an unsupported mandatory extension is present, clients MUST ignore the ECHConfig.",
      "ja": "クライアントは、拡張リストを解析し、サポートされていない必須拡張機能を確認する必要があります。サポートされていない必須拡張機能が存在する場合、クライアントはeChConfigを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5. The \"encrypted_client_hello\" Extension",
      "section_title": true,
      "ja": "5. 「encrypted_client_hello」拡張機能"
    },
    {
      "indent": 3,
      "text": "To offer ECH, the client sends an \"encrypted_client_hello\" extension in the ClientHelloOuter. When it does, it MUST also send the extension in ClientHelloInner.",
      "ja": "ECHを提供するために、クライアントはclienthelloouterで「encrypted_client_hello」拡張子を送信します。それが行われた場合、それはまた、clienthelloinnerで拡張機能を送信する必要があります。"
    },
    {
      "indent": 7,
      "text": "enum {\n   encrypted_client_hello(0xfe0d), (65535)\n} ExtensionType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The payload of the extension has the following structure:",
      "ja": "拡張機能のペイロードには、次の構造があります。"
    },
    {
      "indent": 7,
      "text": "enum { outer(0), inner(1) } ECHClientHelloType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n   ECHClientHelloType type;\n   select (ECHClientHello.type) {\n       case outer:\n           HpkeSymmetricCipherSuite cipher_suite;\n           uint8 config_id;\n           opaque enc<0..2^16-1>;\n           opaque payload<1..2^16-1>;\n       case inner:\n           Empty;\n   };\n} ECHClientHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The outer extension uses the outer variant and the inner extension uses the inner variant. The inner extension has an empty payload. The outer extension has the following fields:",
      "ja": "外側の拡張は外側のバリアントを使用し、内側の拡張は内側のバリアントを使用します。内部拡張機能には空のペイロードがあります。外側の拡張機能には次のフィールドがあります。"
    },
    {
      "indent": 3,
      "text": "config_id The ECHConfigContents.key_config.config_id for the chosen ECHConfig.",
      "ja": "config_id選択したechconfigのechconfigcontents.key_config.config_id。"
    },
    {
      "indent": 3,
      "text": "cipher_suite The cipher suite used to encrypt ClientHelloInner. This MUST match a value provided in the corresponding ECHConfigContents.cipher_suites list.",
      "ja": "cipher_suite cipherスイートは、clienthelloinnerを暗号化するために使用されていました。これは、対応するeChConfigContents.cipher_suitesリストで提供される値と一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "enc The HPKE encapsulated key, used by servers to decrypt the corresponding payload field. This field is empty in a ClientHelloOuter sent in response to HelloRetryRequest.",
      "ja": "対応するペイロードフィールドを復号化するためにサーバーが使用するHPKEカプセル化キーをencします。このフィールドは、HelloretryRequestに応じて送信されたclienthelloouterで空です。"
    },
    {
      "indent": 3,
      "text": "payload The serialized and encrypted ClientHelloInner structure, encrypted using HPKE as described in Section 6.1.",
      "ja": "セクション6.1で説明されているように、HPKEを使用して暗号化されたシリアル化および暗号化されたClientHelloinner構造をペイロードします。"
    },
    {
      "indent": 3,
      "text": "When a client offers the outer version of an \"encrypted_client_hello\" extension, the server MAY include an \"encrypted_client_hello\" extension in its EncryptedExtensions message, as described in Section 7.1, with the following payload:",
      "ja": "クライアントが「encrypted_client_hello」拡張機能の外側バージョンを提供する場合、サーバーには、セクション7.1で説明されているように、次のペイロードを含む、暗号化されたedextensionsメッセージに「necrypted_client_hello」拡張機能を含めることができます。"
    },
    {
      "indent": 7,
      "text": "struct {\n   ECHConfigList retry_configs;\n} ECHEncryptedExtensions;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The response is valid only when the server used the ClientHelloOuter. If the server sent this extension in response to the inner variant, then the client MUST abort with an \"unsupported_extension\" alert.",
      "ja": "応答は、サーバーがclienthelloouterを使用した場合にのみ有効です。サーバーが内側のバリアントに応じてこの拡張機能を送信した場合、クライアントは「unsupported_extension」アラートで中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "retry_configs An ECHConfigList structure containing one or more ECHConfig structures, in decreasing order of preference, to be used by the client as described in Section 6.1.6. These are known as the server's \"retry configurations\".",
      "ja": "retry_configは、セクション6.1.6で説明されているように、クライアントが使用するように、1つ以上のeChConfig構造を含むeChconfiglist構造を、優先順位を減らします。これらは、サーバーの「再試行構成」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Finally, when the client offers the \"encrypted_client_hello\", if the payload is the inner variant and the server responds with HelloRetryRequest, it MUST include an \"encrypted_client_hello\" extension with the following payload:",
      "ja": "最後に、クライアントが「encrypted_client_hello」を提供する場合、ペイロードが内側のバリアントであり、サーバーがhelloretryrequestで応答する場合、次のペイロードを含む「encrypted_client_hello」拡張子を含める必要があります。"
    },
    {
      "indent": 7,
      "text": "struct {\n   opaque confirmation[8];\n} ECHHelloRetryRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value of ECHHelloRetryRequest.confirmation is set to hrr_accept_confirmation as described in Section 7.2.1.",
      "ja": "echhelloretretyRequest.confirmationの値は、セクション7.2.1で説明されているように、HRR_ACCEPT_CONFIRMATIONに設定されています。"
    },
    {
      "indent": 3,
      "text": "This document also defines the \"ech_required\" alert, which the client MUST send when it offered an \"encrypted_client_hello\" extension that was not accepted by the server. (See Section 11.2.)",
      "ja": "このドキュメントでは、「ECH_Required」アラートも定義します。これは、サーバーが受け入れなかった「encrypted_client_hello」拡張機能を提供したときにクライアントが送信する必要があります。（セクション11.2を参照してください。）"
    },
    {
      "indent": 0,
      "text": "5.1. Encoding the ClientHelloInner",
      "section_title": true,
      "ja": "5.1. clienthelloinnerのエンコード"
    },
    {
      "indent": 3,
      "text": "Before encrypting, the client pads and optionally compresses ClientHelloInner into a EncodedClientHelloInner structure, defined below:",
      "ja": "暗号化する前に、クライアントはclienthelloinnerをパッドにパッドし、以下に定義するEncodedClientHelloinner構造に圧縮します。"
    },
    {
      "indent": 7,
      "text": "struct {\n    ClientHello client_hello;\n    uint8 zeros[length_of_padding];\n} EncodedClientHelloInner;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client_hello field is computed by first making a copy of ClientHelloInner and setting the legacy_session_id field to the empty string. Note this field uses the ClientHello structure, defined in Section 4.1.2 of [RFC8446] which does not include the Handshake structure's four byte header. The zeros field MUST be all zeroes.",
      "ja": "Client_Helloフィールドは、最初にClientHelloInnerのコピーを作成し、regacy_session_idフィールドを空の文字列に設定することによって計算されます。注このフィールドは、握手構造の4バイトヘッダーを含まない[RFC8446]のセクション4.1.2で定義されているClientHello構造を使用します。Zerosフィールドはすべてゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Repeating large extensions, such as \"key_share\" with post-quantum algorithms, between ClientHelloInner and ClientHelloOuter can lead to excessive size. To reduce the size impact, the client MAY substitute extensions which it knows will be duplicated in ClientHelloOuter. It does so by removing and replacing extensions from EncodedClientHelloInner with a single \"ech_outer_extensions\" extension, defined as follows:",
      "ja": "QuirnHelloinnerとclienthelloouterの間で、Quantum後のアルゴリズムを使用して「key_share」などの大規模な拡張機能を繰り返すと、サイズが過剰になります。サイズの影響を減らすために、クライアントはClientHelloouterで複製されることがわかっている拡張機能を置き換えることができます。EncodedClientHelloInnerから拡張機能を削除および交換することにより、次のように定義された単一の「ECH_OUTER_EXTENSIONS」拡張機能を使用します。"
    },
    {
      "indent": 7,
      "text": "enum {\n   ech_outer_extensions(0xfd00), (65535)\n} ExtensionType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ExtensionType OuterExtensions<2..254>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OuterExtensions contains the removed ExtensionType values. Each value references the matching extension in ClientHelloOuter. The values MUST be ordered contiguously in ClientHelloInner, and the \"ech_outer_extensions\" extension MUST be inserted in the corresponding position in EncodedClientHelloInner. Additionally, the extensions MUST appear in ClientHelloOuter in the same relative order. However, there is no requirement that they be contiguous. For example, OuterExtensions may contain extensions A, B, C, while ClientHelloOuter contains extensions A, D, B, C, E, F.",
      "ja": "outourextensionsには、削除されたextensionType値が含まれています。各値は、clienthelloouterの一致する拡張機能を参照しています。値はclienthelloinnerで連続的に順序付けられる必要があり、「ech_outer_extensions」拡張子は、encodedclienthelloinnerの対応する位置に挿入する必要があります。さらに、拡張機能は同じ相対順序でclienthelloouterに表示する必要があります。ただし、それらが隣接するという要件はありません。たとえば、outerextensionsには拡張機能a、b、cが含まれている場合があり、clienthelloouterには拡張機能a、d、b、c、e、fが含まれます。"
    },
    {
      "indent": 3,
      "text": "The \"ech_outer_extensions\" extension can only be included in EncodedClientHelloInner, and MUST NOT appear in either ClientHelloOuter or ClientHelloInner.",
      "ja": "「ech_outer_extensions」拡張機能は、ecodedclienthelloinnerにのみ含めることができ、clienthelloouterまたはclienthelloinnerに表示されないでください。"
    },
    {
      "indent": 3,
      "text": "Finally, the client pads the message by setting the zeros field to a byte string whose contents are all zeros and whose length is the amount of padding to add. Section 6.1.3 describes a recommended padding scheme.",
      "ja": "最後に、クライアントは、内容物がすべてゼロであり、その長さが追加するパディングの量であるバイト文字列にゼロフィールドを設定することにより、メッセージをパッドします。セクション6.1.3では、推奨されるパディングスキームについて説明します。"
    },
    {
      "indent": 3,
      "text": "The client-facing server computes ClientHelloInner by reversing this process. First it parses EncodedClientHelloInner, interpreting all bytes after client_hello as padding. If any padding byte is non-zero, the server MUST abort the connection with an \"illegal_parameter\" alert.",
      "ja": "クライアント向けサーバーは、このプロセスを逆転させることにより、clienthelloinnerを計算します。最初に、client_helloの後にすべてのバイトをパディングとして解釈し、ecdedclienthelloinnerを解析します。パディングバイトがゼロでない場合、サーバーは「Illegal_Parameter」アラートとの接続を中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "Next it makes a copy of the client_hello field and copies the legacy_session_id field from ClientHelloOuter. It then looks for an \"ech_outer_extensions\" extension. If found, it replaces the",
      "ja": "次に、client_helloフィールドのコピーを作成し、clienthelloouterからregacy_session_idフィールドをコピーします。次に、「ech_outer_extensions」拡張子を探します。見つかった場合、それは置き換えます"
    },
    {
      "indent": 3,
      "text": "extension with the corresponding sequence of extensions in the ClientHelloOuter. The server MUST abort the connection with an \"illegal_parameter\" alert if any of the following are true:",
      "ja": "ClientHelloouterの対応する拡張シーケンスを使用した拡張。サーバーは、以下のいずれかが当てはまる場合、「Illegal_Parameter」アラートで接続を中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Any referenced extension is missing in ClientHelloOuter.",
      "ja": "* 参照されている拡張機能は、clienthelloouterに欠落しています。"
    },
    {
      "indent": 3,
      "text": "* Any extension is referenced in OuterExtensions more than once.",
      "ja": "* 任意の拡張機能は、outourextensionsで複数回参照されます。"
    },
    {
      "indent": 3,
      "text": "* \"encrypted_client_hello\" is referenced in OuterExtensions.",
      "ja": "* 「encrypted_client_hello」は、outourextensionsで参照されます。"
    },
    {
      "indent": 3,
      "text": "* The extensions in ClientHelloOuter corresponding to those in OuterExtensions do not occur in the same order.",
      "ja": "* Auterextensionsの拡張機能に対応するクライアントヘロウターの拡張機能は、同じ順序で発生しません。"
    },
    {
      "indent": 3,
      "text": "These requirements prevent an attacker from performing a packet amplification attack, by crafting a ClientHelloOuter which decompresses to a much larger ClientHelloInner. This is discussed further in Section 10.11.4.",
      "ja": "これらの要件により、攻撃者は、はるかに大きなClientHelloinnerに減圧するクライアントヘロウターを作成することにより、パケット増幅攻撃を実行することができません。これについては、セクション10.11.4でさらに説明します。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD bound the time to compute a ClientHelloInner proportionally to the ClientHelloOuter size. If the cost is disproportionately large, a malicious client could exploit this in a denial of service attack. Appendix B describes a linear-time procedure that may be used for this purpose.",
      "ja": "実装は、ClientHelloouterサイズに比例してClientHelloInnerを計算する時間を削減する必要があります。コストが不釣り合いに大きい場合、悪意のあるクライアントはサービス拒否攻撃でこれを悪用する可能性があります。付録Bでは、この目的に使用できる線形時間手順について説明しています。"
    },
    {
      "indent": 0,
      "text": "5.2. Authenticating the ClientHelloOuter",
      "section_title": true,
      "ja": "5.2. clienthelloouterの認証"
    },
    {
      "indent": 3,
      "text": "To prevent a network attacker from modifying the reconstructed ClientHelloInner (see Section 10.11.3), ECH authenticates ClientHelloOuter by passing ClientHelloOuterAAD as the associated data for HPKE sealing and opening operations. The ClientHelloOuterAAD is a serialized ClientHello structure, defined in Section 4.1.2 of [RFC8446], which matches the ClientHelloOuter except the payload field of the \"encrypted_client_hello\" is replaced with a byte string of the same length but whose contents are zeros. This value does not include the four-byte header from the Handshake structure.",
      "ja": "ネットワーク攻撃者が再構築されたClientHelloinnerを変更するのを防ぐため（セクション10.11.3を参照）、ECHはHPKEシーリングおよびオープニング操作の関連データとしてClientHelloouteraadを渡すことにより、ClientHelloouterを認証します。clienthelloouteraadは、[RFC8446]のセクション4.1.2で定義されているシリアル化されたクライアントヘロ構造です。これは、「encrypted_client_hello」のペイロードフィールドを除き、クライアントヘロウターと一致します。この値には、ハンドシェイク構造からの4バイトヘッダーは含まれません。"
    },
    {
      "indent": 3,
      "text": "The client follows the procedure in Section 6.1.1 to first construct ClientHelloOuterAAD with a placeholder payload field, then replace the field with the encrypted value to compute ClientHelloOuter.",
      "ja": "クライアントは、セクション6.1.1の手順に従って、最初にプレースホルダーペイロードフィールドを使用してclienthelloouteraadを構築し、次にフィールドを暗号化された値に置き換えて、clienthelloouterを計算します。"
    },
    {
      "indent": 3,
      "text": "The server then receives ClientHelloOuter and computes ClientHelloOuterAAD by making a copy and replacing the portion corresponding to the payload field with zeros.",
      "ja": "次に、サーバーはClientHellOouterを受信し、ColienthelloouteraadをCopientherosに作成し、ペイロードフィールドに対応する部分をZerosに置き換えることで計算します。"
    },
    {
      "indent": 3,
      "text": "The payload and the placeholder strings have the same length, so it is not necessary for either side to recompute length prefixes when applying the above transformations.",
      "ja": "ペイロードとプレースホルダーの文字列は同じ長さであるため、上記の変換を適用するときにどちらの側も長さのプレフィックスを再計算する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The decompression process in Section 5.1 forbids \"encrypted_client_hello\" in OuterExtensions. This ensures the unauthenticated portion of ClientHelloOuter is not incorporated into ClientHelloInner.",
      "ja": "セクション5.1の減圧プロセスは、outourextensionsの「encrypted_client_hello」を禁止します。これにより、clienthelloouterの認定されていない部分がClientHelloinnerに組み込まれていないことが保証されます。"
    },
    {
      "indent": 0,
      "text": "6. Client Behavior",
      "section_title": true,
      "ja": "6. クライアントの動作"
    },
    {
      "indent": 3,
      "text": "Clients that implement the ECH extension behave in one of two ways: either they offer a real ECH extension, as described in Section 6.1; or they send a GREASE ECH extension, as described in Section 6.2. Clients of the latter type do not negotiate ECH. Instead, they generate a dummy ECH extension that is ignored by the server. (See Section 10.9.4 for an explanation.) The client offers ECH if it is in possession of a compatible ECH configuration and sends GREASE ECH otherwise.",
      "ja": "ECH拡張機能を実装するクライアントは、2つの方法のいずれかで動作します。セクション6.1で説明されているように、実際のECH拡張機能を提供します。または、セクション6.2で説明されているように、グリースエック拡張機能を送信します。後者のタイプのクライアントは、ECHを交渉しません。代わりに、サーバーによって無視されるダミーECH拡張機能を生成します。（説明については、セクション10.9.4を参照してください。）互換性のあるECH構成を所有している場合、クライアントはECHを提供し、それ以外の場合はグリースECHを送信します。"
    },
    {
      "indent": 0,
      "text": "6.1. Offering ECH",
      "section_title": true,
      "ja": "6.1. ECHを提供します"
    },
    {
      "indent": 3,
      "text": "To offer ECH, the client first chooses a suitable ECHConfig from the server's ECHConfigList. To determine if a given ECHConfig is suitable, it checks that it supports the KEM algorithm identified by ECHConfig.contents.kem_id, at least one KDF/AEAD algorithm identified by ECHConfig.contents.cipher_suites, and the version of ECH indicated by ECHConfig.contents.version. Once a suitable configuration is found, the client selects the cipher suite it will use for encryption. It MUST NOT choose a cipher suite or version not advertised by the configuration. If no compatible configuration is found, then the client SHOULD proceed as described in Section 6.2.",
      "ja": "ECHを提供するために、クライアントは最初にサーバーのeChConfiglistから適切なECHCONFIGを選択します。特定のeChconfigが適切かどうかを判断するために、echconfig.contents.kem_id、echconfig.config.contents.ciphe_suitesによって識別された少なくとも1つのkdf/aeadアルゴリズムによって識別されたKEMアルゴリズムをサポートすることをチェックします。。バージョン。適切な構成が見つかると、クライアントは暗号化に使用する暗号スイートを選択します。構成によって宣伝されていない暗号スイートまたはバージョンを選択してはなりません。互換性のある構成が見つからない場合、セクション6.2で説明されているように、クライアントは続行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Next, the client constructs the ClientHelloInner message just as it does a standard ClientHello, with the exception of the following rules:",
      "ja": "次に、クライアントは、次のルールを除き、標準のclienthelloを実行するのと同じように、clienthelloinnerメッセージを構築します。"
    },
    {
      "indent": 3,
      "text": "1. It MUST NOT offer to negotiate TLS 1.2 or below. This is necessary to ensure the backend server does not negotiate a TLS version that is incompatible with ECH.",
      "ja": "1. TLS 1.2以下を交渉することを申し出てはなりません。これは、バックエンドサーバーがECHと互換性のないTLSバージョンをネゴシエートしないようにするために必要です。"
    },
    {
      "indent": 3,
      "text": "2. It MUST NOT offer to resume any session for TLS 1.2 and below.",
      "ja": "2. TLS 1.2以下のセッションを再開することを申し出てはなりません。"
    },
    {
      "indent": 3,
      "text": "3. If it intends to compress any extensions (see Section 5.1), it MUST order those extensions consecutively.",
      "ja": "3. 拡張機能を圧縮するつもりの場合（セクション5.1を参照）、それらの拡張機能を連続して注文する必要があります。"
    },
    {
      "indent": 3,
      "text": "4. It MUST include the \"encrypted_client_hello\" extension of type inner as described in Section 5. (This requirement is not applicable when the \"encrypted_client_hello\" extension is generated as described in Section 6.2.)",
      "ja": "4. セクション5で説明されているように、「encrypted_client_hello」内側の「encrypted_client_hello」の拡張を含める必要があります（この要件は、セクション6.2で説明されているように「necrypted_client_hello」拡張機能を生成する場合に適用されません。）"
    },
    {
      "indent": 3,
      "text": "The client then constructs EncodedClientHelloInner as described in Section 5.1. It also computes an HPKE encryption context and enc value as:",
      "ja": "次に、セクション5.1で説明されているように、クライアントはエンコードClientHelloinnerを構築します。また、HPKE暗号化のコンテキストを計算し、次のようにenc値を計算します。"
    },
    {
      "indent": 7,
      "text": "pkR = DeserializePublicKey(ECHConfig.contents.public_key) enc, context = SetupBaseS(pkR, \"tls ech\" || 0x00 || ECHConfig)",
      "ja": "pkr = deserializepublickey（echconfig.contents.public_key）enc、context = setupbases（pkr、 \"tls ech\" || 0x00 || echconfig）"
    },
    {
      "indent": 3,
      "text": "Next, it constructs a partial ClientHelloOuterAAD as it does a standard ClientHello, with the exception of the following rules:",
      "ja": "次に、次のルールを除き、標準のクライアントヘロを実行するように、部分的なclienthelloouteraadを構築します。"
    },
    {
      "indent": 3,
      "text": "1. It MUST offer to negotiate TLS 1.3 or above.",
      "ja": "1. TLS 1.3以上を交渉する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. If it compressed any extensions in EncodedClientHelloInner, it MUST copy the corresponding extensions from ClientHelloInner. The copied extensions additionally MUST be in the same relative order as in ClientHelloInner.",
      "ja": "2. EncodedClientHelloinnerの拡張機能を圧縮した場合、ClientHelloinnerから対応する拡張機能をコピーする必要があります。さらに、コピーされた拡張機能は、clienthelloinnerと同じ相対順序である必要があります。"
    },
    {
      "indent": 3,
      "text": "3. It MUST copy the legacy_session_id field from ClientHelloInner. This allows the server to echo the correct session ID for TLS 1.3's compatibility mode (see Appendix D.4 of [RFC8446]) when ECH is negotiated.",
      "ja": "3. clienthelloinnerからLegacy_session_idフィールドをコピーする必要があります。これにより、ECHが交渉されたときに、TLS 1.3の互換性モード（[RFC8446]の付録D.4を参照）の正しいセッションIDをエコーできます。"
    },
    {
      "indent": 3,
      "text": "4. It MAY copy any other field from the ClientHelloInner except ClientHelloInner.random. Instead, It MUST generate a fresh ClientHelloOuter.random using a secure random number generator. (See Section 10.11.1.)",
      "ja": "4. clienthelloinner.randomを除いて、clienthelloinnerから他のフィールドをコピーする場合があります。代わりに、安全な乱数ジェネレーターを使用して、新鮮なclienthelloouter.randomを生成する必要があります。（セクション10.11.1を参照してください。）"
    },
    {
      "indent": 3,
      "text": "5. The value of ECHConfig.contents.public_name MUST be placed in the \"server_name\" extension.",
      "ja": "5. echconfig.contents.public_nameの値は、「server_name」拡張子に配置する必要があります。"
    },
    {
      "indent": 3,
      "text": "6. When the client offers the \"pre_shared_key\" extension in ClientHelloInner, it SHOULD also include a GREASE \"pre_shared_key\" extension in ClientHelloOuter, generated in the manner described in Section 6.1.2. The client MUST NOT use this extension to advertise a PSK to the client-facing server. (See Section 10.11.3.) When the client includes a GREASE \"pre_shared_key\" extension, it MUST also copy the \"psk_key_exchange_modes\" from the ClientHelloInner into the ClientHelloOuter.",
      "ja": "6. クライアントがClientHelloinnerで「pre_shared_key」拡張機能を提供する場合、セクション6.1.2で説明されている方法で生成されたクライアントHelloouterのグリース「pre_shared_key」拡張機能も含める必要があります。クライアントは、この拡張機能を使用してPSKをクライアントに向けたサーバーに宣伝してはなりません。（セクション10.11.3を参照してください。）クライアントがグリース「pre_shared_key」拡張機能を含める場合、clienthelloinnerからclienthelloouterに「psk_key_exchange_modes」をコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "7. When the client offers the \"early_data\" extension in ClientHelloInner, it MUST also include the \"early_data\" extension in ClientHelloOuter. This allows servers that reject ECH and use ClientHelloOuter to safely ignore any early data sent by the client per [RFC8446], Section 4.2.10.",
      "ja": "7. クライアントがClientHelloinnerで「初期_DATA」拡張機能を提供する場合、ClientHelloouterに「Early_Data」拡張機能も含める必要があります。これにより、ECHを拒否し、ClientHelloouterを使用して、[RFC8446]、セクション4.2.10ごとにクライアントが送信した初期データを安全に無視するサーバーが可能になります。"
    },
    {
      "indent": 3,
      "text": "Note that these rules may change in the presence of an application profile specifying otherwise.",
      "ja": "これらのルールは、別の方法で指定するアプリケーションプロファイルの存在下で変更される可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The client might duplicate non-sensitive extensions in both messages. However, implementations need to take care to ensure that sensitive extensions are not offered in the ClientHelloOuter. See Section 10.5 for additional guidance.",
      "ja": "クライアントは、両方のメッセージで非感受性拡張機能を複製する場合があります。ただし、実装は、clienthelloouterで機密性の高い拡張機能が提供されないように注意する必要があります。追加のガイダンスについては、セクション10.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "Finally, the client encrypts the EncodedClientHelloInner with the above values, as described in Section 6.1.1, to construct a ClientHelloOuter. It sends this to the server, and processes the response as described in Section 6.1.4.",
      "ja": "最後に、クライアントは、セクション6.1.1で説明されているように、上記の値でエンコードされたClientHelloinnerを暗号化して、クライアントヘロウターを構築します。これをサーバーに送信し、セクション6.1.4で説明したように応答を処理します。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Encrypting the ClientHello",
      "section_title": true,
      "ja": "6.1.1. clienthelloの暗号化"
    },
    {
      "indent": 3,
      "text": "Given an EncodedClientHelloInner, an HPKE encryption context and enc value, and a partial ClientHelloOuterAAD, the client constructs a ClientHelloOuter as follows.",
      "ja": "EncodedClientHelloinner、HPKE暗号化コンテキストとEnc値、および部分的なClientHelloouteraadを考えると、クライアントは次のようにクライアントヘロウターを構築します。"
    },
    {
      "indent": 3,
      "text": "First, the client determines the length L of encrypting EncodedClientHelloInner with the selected HPKE AEAD. This is typically the sum of the plaintext length and the AEAD tag length. The client then completes the ClientHelloOuterAAD with an \"encrypted_client_hello\" extension. This extension value contains the outer variant of ECHClientHello with the following fields:",
      "ja": "最初に、クライアントは、選択されたHPKE AEADを使用してエンコードされたClientHelloinnerを暗号化する長さlを決定します。これは通常、プレーンテキストの長さとAEADタグの長さの合計です。クライアントは、「encrypted_client_hello」拡張子でclienthelloouteraadを完了します。この拡張値には、次のフィールドがあるEchclienthelloの外側のバリアントが含まれています。"
    },
    {
      "indent": 3,
      "text": "* config_id, the identifier corresponding to the chosen ECHConfig structure;",
      "ja": "* Config_ID、選択したeChConfig構造に対応する識別子。"
    },
    {
      "indent": 3,
      "text": "* cipher_suite, the client's chosen cipher suite;",
      "ja": "* Cipher_suite、クライアントが選んだ暗号スイート。"
    },
    {
      "indent": 3,
      "text": "* enc, as given above; and",
      "ja": "* 上記のように、enc。と"
    },
    {
      "indent": 3,
      "text": "* payload, a placeholder byte string containing L zeros.",
      "ja": "* ペイロード、L Zerosを含むプレースホルダーバイト文字列。"
    },
    {
      "indent": 3,
      "text": "If configuration identifiers (see Section 10.4) are to be ignored, config_id SHOULD be set to a randomly generated byte in the first ClientHelloOuter and, in the event of HRR, MUST be left unchanged for the second ClientHelloOuter.",
      "ja": "構成識別子（セクション10.4を参照）を無視する場合、config_idは最初のclienthelloouterでランダムに生成されたバイトに設定する必要があり、HRRの場合は、2番目のclienthelloouterで変更されておく必要があります。"
    },
    {
      "indent": 3,
      "text": "The client serializes this structure to construct the ClientHelloOuterAAD. It then computes the final payload as:",
      "ja": "クライアントは、この構造をシリアル化して、clienthelloouteraadを構築します。次に、次のように最終的なペイロードを計算します。"
    },
    {
      "indent": 7,
      "text": "final_payload = context.Seal(ClientHelloOuterAAD, EncodedClientHelloInner)",
      "ja": "final_payload = context.seal（clienthelloouteraad、encodedclienthelloinner）"
    },
    {
      "indent": 3,
      "text": "Finally, the client replaces payload with final_payload to obtain ClientHelloOuter. The two values have the same length, so it is not necessary to recompute length prefixes in the serialized structure.",
      "ja": "最後に、クライアントはペイロードをfinal_payloadに置き換えて、clienthelloouterを取得します。2つの値は同じ長さであるため、シリアル化された構造で長さのプレフィックスを再計算する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Note this construction requires the \"encrypted_client_hello\" be computed after all other extensions. This is possible because the ClientHelloOuter's \"pre_shared_key\" extension is either omitted, or uses a random binder (Section 6.1.2).",
      "ja": "注この構造には、他のすべての拡張機能の後に「encrypted_client_hello」を計算する必要があります。これは、clienthelloouterの「pre_shared_key」拡張機能が省略されるか、ランダムバインダーを使用しているために可能です（セクション6.1.2）。"
    },
    {
      "indent": 0,
      "text": "6.1.2. GREASE PSK",
      "section_title": true,
      "ja": "6.1.2. グリースPSK"
    },
    {
      "indent": 3,
      "text": "When offering ECH, the client is not permitted to advertise PSK identities in the ClientHelloOuter. However, the client can send a \"pre_shared_key\" extension in the ClientHelloInner. In this case, when resuming a session with the client, the backend server sends a \"pre_shared_key\" extension in its ServerHello. This would appear to a network observer as if the the server were sending this extension without solicitation, which would violate the extension rules described in [RFC8446]. Sending a GREASE \"pre_shared_key\" extension in the ClientHelloOuter makes it appear to the network as if the extension were negotiated properly.",
      "ja": "ECHを提供する場合、クライアントはClientHelloouterでPSK IDを宣伝することは許可されていません。ただし、クライアントはclienthelloinnerで「pre_shared_key」拡張機能を送信できます。この場合、クライアントとのセッションを再開すると、バックエンドサーバーはserverhelloで「pre_shared_key」拡張子を送信します。これは、ネットワークオブザーバーには、サーバーが勧誘なしにこの拡張機能を送信しているかのように見えます。これは、[RFC8446]で説明されている拡張ルールに違反します。clienthelloouterでグリース「pre_shared_key」拡張機能を送信すると、拡張機能が適切に交渉されたかのようにネットワークに表示されます。"
    },
    {
      "indent": 3,
      "text": "The client generates the extension payload by constructing an OfferedPsks structure (see [RFC8446], Section 4.2.11) as follows. For each PSK identity advertised in the ClientHelloInner, the client generates a random PSK identity with the same length. It also generates a random, 32-bit, unsigned integer to use as the obfuscated_ticket_age. Likewise, for each inner PSK binder, the client generates a random string of the same length.",
      "ja": "クライアントは、次のように、提供されたPSKS構造（[RFC8446]、セクション4.2.11を参照）を構築することにより、拡張ペイロードを生成します。clienthelloinnerで宣伝されている各PSKアイデンティティについて、クライアントは同じ長さのランダムなPSKアイデンティティを生成します。また、obfuscated_ticket_ageとして使用するために、ランダムな32ビットの符号なし整数も生成します。同様に、各内側のPSKバインダーごとに、クライアントは同じ長さのランダムな文字列を生成します。"
    },
    {
      "indent": 3,
      "text": "Per the rules of Section 6.1, the server is not permitted to resume a connection in the outer handshake. If ECH is rejected and the client-facing server replies with a \"pre_shared_key\" extension in its ServerHello, then the client MUST abort the handshake with an \"illegal_parameter\" alert.",
      "ja": "セクション6.1の規則に従って、サーバーは外側の握手の接続を再開することは許可されていません。ECHが拒否され、クライアントに向いたサーバーがServerHelloの「pre_shared_key」拡張機能で返信する場合、クライアントは「Illegal_parameter」アラートで握手を中止する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Recommended Padding Scheme",
      "section_title": true,
      "ja": "6.1.3. 推奨されるパディングスキーム"
    },
    {
      "indent": 3,
      "text": "This section describes a deterministic padding mechanism based on the following observation: individual extensions can reveal sensitive information through their length. Thus, each extension in the inner ClientHello may require different amounts of padding. This padding may be fully determined by the client's configuration or may require server input.",
      "ja": "このセクションでは、次の観察に基づいた決定論的なパディングメカニズムについて説明します。個々の拡張は、その長さを通じて機密情報を明らかにすることができます。したがって、内側のクライアントヘロの各拡張機能は、異なる量のパディングが必要になる場合があります。このパディングは、クライアントの構成によって完全に決定される場合がある場合や、サーバー入力が必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "By way of example, clients typically support a small number of application profiles. For instance, a browser might support HTTP with ALPN values [\"http/1.1\", \"h2\"] and WebRTC media with ALPNs",
      "ja": "例として、クライアントは通常、少数のアプリケーションプロファイルをサポートします。たとえば、ブラウザはALPN値のあるHTTP [\"HTTP/1.1\"、 \"H2\"]およびALPNSを使用してWebrTCメディアをサポートする場合があります"
    },
    {
      "indent": 3,
      "text": "[\"webrtc\", \"c-webrtc\"]. Clients SHOULD pad this extension by rounding up to the total size of the longest ALPN extension across all application profiles. The target padding length of most ClientHello extensions can be computed in this way.",
      "ja": "[\"webrtc\"、 \"c-webrtc\"]。クライアントは、すべてのアプリケーションプロファイルで最も長いALPN拡張機能の合計サイズにまとめて、この拡張機能をパッドアップする必要があります。ほとんどのClientHello拡張機能のターゲットパディングの長さは、この方法で計算できます。"
    },
    {
      "indent": 3,
      "text": "In contrast, clients do not know the longest SNI value in the client-facing server's anonymity set without server input. Clients SHOULD use the ECHConfig's maximum_name_length field as follows, where L is the maximum_name_length value.",
      "ja": "対照的に、クライアントは、サーバー入力なしでクライアント向けサーバーの匿名セットで最も長いSNI値を知らない。クライアントは、次のようにECHCONFIGのMaximum_Name_Lengthフィールドを使用する必要があります。ここで、LはMaximing_Name_Length値です。"
    },
    {
      "indent": 3,
      "text": "1. If the ClientHelloInner contained a \"server_name\" extension with a name of length D, add max(0, L - D) bytes of padding.",
      "ja": "1. clienthelloinnerに長さdという名前の「server_name」拡張子が含まれていた場合、パディングの最大値（0、l -d）バイトを追加します。"
    },
    {
      "indent": 3,
      "text": "2. If the ClientHelloInner did not contain a \"server_name\" extension (e.g., if the client is connecting to an IP address), add L + 9 bytes of padding. This is the length of a \"server_name\" extension with an L-byte name.",
      "ja": "2. clienthelloinnerに「server_name」拡張子（たとえば、クライアントがIPアドレスに接続している場合）が含まれていなかった場合、パディングのL 9バイトを追加します。これは、Lバイト名を持つ「server_name」拡張子の長さです。"
    },
    {
      "indent": 3,
      "text": "Finally, the client SHOULD pad the entire message as follows:",
      "ja": "最後に、クライアントは次のようにメッセージ全体をパッドする必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Let L be the length of the EncodedClientHelloInner with all the padding computed so far.",
      "ja": "1. Lを、これまでに計算されたすべてのパディングを使用して、エンコードされたClientHelloinnerの長さとします。"
    },
    {
      "indent": 3,
      "text": "2. Let N = 31 - ((L - 1) % 32) and add N bytes of padding.",
      "ja": "2. n = 31-（（l -1）％32）とし、パディングのnバイトを追加します。"
    },
    {
      "indent": 3,
      "text": "This rounds the length of EncodedClientHelloInner up to a multiple of 32 bytes, reducing the set of possible lengths across all clients.",
      "ja": "これにより、EncodedClientHelloinnerの長さが32バイトの倍数まで丸められ、すべてのクライアントで可能な長さのセットが削減されます。"
    },
    {
      "indent": 3,
      "text": "In addition to padding ClientHelloInner, clients and servers will also need to pad all other handshake messages that have sensitive-length fields. For example, if a client proposes ALPN values in ClientHelloInner, the server-selected value will be returned in an EncryptedExtension, so that handshake message also needs to be padded using TLS record layer padding.",
      "ja": "ClientHelloinnerをパディングすることに加えて、クライアントとサーバーは、敏感な長さのフィールドを持つ他のすべてのハンドシェイクメッセージをパッドする必要があります。たとえば、クライアントがClientHelloinnerでALPN値を提案する場合、サーバー選択の値は暗号化された延長で返されるため、TLSレコードレイヤーパディングを使用してハンドシェイクメッセージをパッドでパッドする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.4. Determining ECH Acceptance",
      "section_title": true,
      "ja": "6.1.4. ECHの受け入れの決定"
    },
    {
      "indent": 3,
      "text": "As described in Section 7, the server may either accept ECH and use ClientHelloInner or reject it and use ClientHelloOuter. This is determined by the server's initial message.",
      "ja": "セクション7で説明されているように、サーバーはECHを受け入れ、ClientHelloinnerを使用するか、それを拒否してClientHelloouterを使用できます。これは、サーバーの最初のメッセージによって決定されます。"
    },
    {
      "indent": 3,
      "text": "If the message does not negotiate TLS 1.3 or higher, the server has rejected ECH. Otherwise, it is either a ServerHello or HelloRetryRequest.",
      "ja": "メッセージがTLS 1.3以上を交渉しない場合、サーバーはECHを拒否しました。それ以外の場合、それはserverhelloまたはhelloretryrequestのいずれかです。"
    },
    {
      "indent": 3,
      "text": "If the message is a ServerHello, the client computes accept_confirmation as described in Section 7.2. If this value matches the last 8 bytes of ServerHello.random, the server has accepted ECH. Otherwise, it has rejected ECH.",
      "ja": "メッセージがServerHelloの場合、クライアントはセクション7.2で説明されているようにAccept_Confirmationを計算します。この値がserverhello.randomの最後の8バイトと一致する場合、サーバーはECHを受け入れました。そうでなければ、eChを拒否しました。"
    },
    {
      "indent": 3,
      "text": "If the message is a HelloRetryRequest, the client checks for the \"encrypted_client_hello\" extension. If none is found, the server has rejected ECH. Otherwise, if it has a length other than 8, the client aborts the handshake with a \"decode_error\" alert. Otherwise, the client computes hrr_accept_confirmation as described in Section 7.2.1. If this value matches the extension payload, the server has accepted ECH. Otherwise, it has rejected ECH.",
      "ja": "メッセージがhelloretryRequestの場合、クライアントは「encrypted_client_hello」拡張子をチェックします。何も見つからない場合、サーバーはECHを拒否しました。それ以外の場合、8以外の長さがある場合、クライアントは「decode_error」アラートで握手を中止します。それ以外の場合、クライアントはセクション7.2.1で説明されているようにHRR_ACCEPT_CONFIRMATIONを計算します。この値が拡張ペイロードと一致する場合、サーバーはECHを受け入れました。そうでなければ、eChを拒否しました。"
    },
    {
      "indent": 3,
      "text": "[[OPEN ISSUE: Depending on what we do for issue#450, it may be appropriate to change the client behavior if the HRR extension is present but with the wrong value.]]",
      "ja": "[[Open Issue：問題＃450に対して私たちが何をしているかによって、HRR拡張が存在するが間違った値がある場合はクライアントの動作を変更することが適切かもしれません。]]]"
    },
    {
      "indent": 3,
      "text": "If the server accepts ECH, the client handshakes with ClientHelloInner as described in Section 6.1.5. Otherwise, the client handshakes with ClientHelloOuter as described in Section 6.1.6.",
      "ja": "サーバーがECHを受け入れると、セクション6.1.5で説明されているように、クライアントHelloinnerとの握手がクライアントを握ります。それ以外の場合は、セクション6.1.6で説明されているように、クライアントヘロウターでクライアントのハンドシェイク。"
    },
    {
      "indent": 0,
      "text": "6.1.5. Handshaking with ClientHelloInner",
      "section_title": true,
      "ja": "6.1.5. clienthelloinnerとのハンドシェイク"
    },
    {
      "indent": 3,
      "text": "If the server accepts ECH, the client proceeds with the connection as in [RFC8446], with the following modifications:",
      "ja": "サーバーがECHを受け入れると、クライアントは[RFC8446]のように接続を進めます。"
    },
    {
      "indent": 3,
      "text": "The client behaves as if it had sent ClientHelloInner as the ClientHello. That is, it evaluates the handshake using the ClientHelloInner's preferences, and, when computing the transcript hash (Section 4.4.1 of [RFC8446]), it uses ClientHelloInner as the first ClientHello.",
      "ja": "クライアントは、clienthelloinnerをclienthelloとして送信したかのように動作します。つまり、ClientHelloinnerの好みを使用して握手を評価し、転写産物ハッシュ（[RFC8446]のセクション4.4.1）を計算すると、ClientHelloinnerを最初のClientHelloとして使用します。"
    },
    {
      "indent": 3,
      "text": "If the server responds with a HelloRetryRequest, the client computes the updated ClientHello message as follows:",
      "ja": "サーバーがHelloretryRequestで応答した場合、クライアントは次のように更新されたClientHelloメッセージを計算します。"
    },
    {
      "indent": 3,
      "text": "1. It computes a second ClientHelloInner based on the first ClientHelloInner, as in Section 4.1.4 of [RFC8446]. The ClientHelloInner's \"encrypted_client_hello\" extension is left unmodified.",
      "ja": "1. [RFC8446]のセクション4.1.4のように、最初のClientHelloinnerに基づいて2番目のClientHelloinnerを計算します。clienthelloinnerの「necrypted_client_hello」拡張機能は修正されていません。"
    },
    {
      "indent": 3,
      "text": "2. It constructs EncodedClientHelloInner as described in Section 5.1.",
      "ja": "2. セクション5.1で説明されているように、EncodedClientHelloinnerを構築します。"
    },
    {
      "indent": 3,
      "text": "3. It constructs a second partial ClientHelloOuterAAD message. This message MUST be syntactically valid. The extensions MAY be copied from the original ClientHelloOuter unmodified, or omitted. If not sensitive, the client MAY copy updated extensions from the second ClientHelloInner for compression.",
      "ja": "3. 2番目の部分的なclienthelloouteraadメッセージを構築します。このメッセージは構文的に有効でなければなりません。拡張機能は、元のclienthelloouterからコピーされるか、省略されている場合があります。敏感でない場合、クライアントは、圧縮のために2番目のClientHelloinnerから更新された拡張機能をコピーできます。"
    },
    {
      "indent": 3,
      "text": "4. It encrypts EncodedClientHelloInner as described in Section 6.1.1, using the second partial ClientHelloOuterAAD, to obtain a second ClientHelloOuter. It reuses the original HPKE encryption context computed in Section 6.1 and uses the empty string for enc.",
      "ja": "4. セクション6.1.1で説明されているようにエンコードされたClientHelloInnerを暗号化し、2番目のPartial ClientHelloouteraadを使用して、2番目のClientHelloouterを取得します。セクション6.1で計算された元のHPKE暗号化コンテキストを再利用し、空の文字列をENCに使用します。"
    },
    {
      "indent": 7,
      "text": "The HPKE context maintains a sequence number, so this operation internally uses a fresh nonce for each AEAD operation. Reusing the HPKE context avoids an attack described in Section 10.11.2.",
      "ja": "HPKEコンテキストはシーケンス番号を維持するため、この操作はAEAD操作ごとに新たなNonCEを内部的に使用します。HPKEコンテキストを再利用すると、セクション10.11.2で説明されている攻撃が回避されます。"
    },
    {
      "indent": 3,
      "text": "The client then sends the second ClientHelloOuter to the server. However, as above, it uses the second ClientHelloInner for preferences, and both the ClientHelloInner messages for the transcript hash. Additionally, it checks the resulting ServerHello for ECH acceptance as in Section 6.1.4. If the ServerHello does not also indicate ECH acceptance, the client MUST terminate the connection with an \"illegal_parameter\" alert.",
      "ja": "次に、クライアントは2番目のclienthelloouterをサーバーに送信します。ただし、上記のように、2番目のClientHelloinnerを設定に使用し、トランスクリプトハッシュのClientHelloinnerメッセージの両方を使用します。さらに、セクション6.1.4のように、結果のServerHelloがECHの受け入れをチェックします。ServerHelloがECHの受け入れも示していない場合、クライアントは「Illegal_Parameter」アラートとの接続を終了する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.6. Handshaking with ClientHelloOuter",
      "section_title": true,
      "ja": "6.1.6. clienthelloouterでのハンドシェイク"
    },
    {
      "indent": 3,
      "text": "If the server rejects ECH, the client proceeds with the handshake, authenticating for ECHConfig.contents.public_name as described in Section 6.1.7. If authentication or the handshake fails, the client MUST return a failure to the calling application. It MUST NOT use the retry configurations. It MUST NOT treat this as a secure signal to disable ECH.",
      "ja": "サーバーがECHを拒否した場合、クライアントは握手を続け、セクション6.1.7で説明されているように、echconfig.contents.public_nameを認証します。認証または握手が失敗した場合、クライアントは呼び出しアプリケーションに失敗を返す必要があります。再試行構成を使用しないでください。これをECHを無効にする安全な信号として扱ってはなりません。"
    },
    {
      "indent": 3,
      "text": "If the server supplied an \"encrypted_client_hello\" extension in its EncryptedExtensions message, the client MUST check that it is syntactically valid and the client MUST abort the connection with a \"decode_error\" alert otherwise. If an earlier TLS version was negotiated, the client MUST NOT enable the False Start optimization [RFC7918] for this handshake. If both authentication and the handshake complete successfully, the client MUST perform the processing described below then abort the connection with an \"ech_required\" alert before sending any application data to the server.",
      "ja": "サーバーが暗号化されたExtensionメッセージに「andrypted_client_hello」拡張子を提供した場合、クライアントは構文的に有効であることを確認する必要があり、クライアントは「decode_error」アラートに接続を中止する必要があります。以前のTLSバージョンがネゴシエートされた場合、クライアントはこの握手のために誤った開始最適化[RFC7918]を有効にしてはなりません。認証とハンドシェイクの両方が正常に完了した場合、クライアントは以下に説明する処理を実行する必要があります。次に、アプリケーションデータをサーバーに送信する前に、「ECH_REQUIRED」アラートで接続を中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server provided \"retry_configs\" and if at least one of the values contains a version supported by the client, the client can regard the ECH keys as securely replaced by the server. It SHOULD retry the handshake with a new transport connection, using the retry",
      "ja": "サーバーが「retry_configs」を提供し、少なくとも1つの値にクライアントがサポートするバージョンが含まれている場合、クライアントはECHキーをサーバーにしっかりと置き換えたものと見なすことができます。再試行を使用して、新しい輸送接続で握手を再試行する必要があります"
    },
    {
      "indent": 3,
      "text": "configurations supplied by the server. The retry configurations may only be applied to the retry connection. The client MUST NOT use retry configurations for connections beyond the retry. This avoids introducing pinning concerns or a tracking vector, should a malicious server present client-specific retry configurations in order to identify the client in a subsequent ECH handshake.",
      "ja": "サーバーが提供する構成。再試行構成は、再試行接続にのみ適用できます。クライアントは、再試行を超えて接続に再試行構成を使用してはなりません。これにより、悪意のあるサーバーがクライアント固有の再試行構成を提示して、その後のECHハンドシェイクでクライアントを識別する場合に、ピン留めの懸念や追跡ベクターの導入を避けます。"
    },
    {
      "indent": 3,
      "text": "If none of the values provided in \"retry_configs\" contains a supported version, or an earlier TLS version was negotiated, the client can regard ECH as securely disabled by the server, and it SHOULD retry the handshake with a new transport connection and ECH disabled.",
      "ja": "「retry_configs」で提供されている値にサポートされているバージョンが含まれていない場合、または以前のTLSバージョンがネゴシエートされていない場合、クライアントはサーバーによって安全に無効になっていると見なすことができ、新しいトランスポート接続とECHが無効になって握手を再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD implement a limit on retries caused by receipt of \"retry_configs\" or servers which do not acknowledge the \"encrypted_client_hello\" extension. If the client does not retry in either scenario, it MUST report an error to the calling application.",
      "ja": "クライアントは、「retry_configs」または「necrypted_client_hello」拡張機能を認めないサーバーの受領によって引き起こされるレトリの制限を実装する必要があります。クライアントがどちらのシナリオでも再試行しない場合、呼び出しアプリケーションにエラーを報告する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.7. Authenticating for the Public Name",
      "section_title": true,
      "ja": "6.1.7. 公開名の認証"
    },
    {
      "indent": 3,
      "text": "When the server rejects ECH, it continues with the handshake using the plaintext \"server_name\" extension instead (see Section 7). Clients that offer ECH then authenticate the connection with the public name, as follows:",
      "ja": "サーバーがeCHを拒否すると、代わりにプレーンテキスト「server_name」拡張機能を使用して握手を続けます（セクション7を参照）。ECHを提供するクライアントは、次のように公開名との接続を認証します。"
    },
    {
      "indent": 3,
      "text": "* The client MUST verify that the certificate is valid for ECHConfig.contents.public_name. If invalid, it MUST abort the connection with the appropriate alert.",
      "ja": "* クライアントは、証明書がechconfig.contents.public_nameに対して有効であることを確認する必要があります。無効な場合は、適切なアラートとの接続を中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the server requests a client certificate, the client MUST respond with an empty Certificate message, denoting no client certificate.",
      "ja": "* サーバーがクライアント証明書を要求する場合、クライアントはクライアント証明書を示す空の証明書メッセージで応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "In verifying the client-facing server certificate, the client MUST interpret the public name as a DNS-based reference identity. Clients that incorporate DNS names and IP addresses into the same syntax (e.g. [RFC3986], Section 7.4 and [WHATWG-IPV4]) MUST reject names that would be interpreted as IPv4 addresses. Clients that enforce this by checking and rejecting encoded IPv4 addresses in ECHConfig.contents.public_name do not need to repeat the check at this layer.",
      "ja": "クライアント向けサーバー証明書を確認する際、クライアントは公開名をDNSベースの参照IDとして解釈する必要があります。DNS名とIPアドレスを同じ構文に組み込むクライアント（例：[RFC3986]、セクション7.4、[WhatWG-IPV4]）は、IPv4アドレスとして解釈される名前を拒否する必要があります。ECHCONFIG.CONTENTS.PUBLIC_NAMEでエンコードされたIPv4アドレスをチェックおよび拒否してこれを実施するクライアントは、このレイヤーでチェックを繰り返す必要はありません。"
    },
    {
      "indent": 3,
      "text": "Note that authenticating a connection for the public name does not authenticate it for the origin. The TLS implementation MUST NOT report such connections as successful to the application. It additionally MUST ignore all session tickets and session IDs presented by the server. These connections are only used to trigger retries, as described in Section 6.1.6. This may be implemented, for instance, by reporting a failed connection with a dedicated error code.",
      "ja": "公開名の接続を認証しても、原点に対して認証されないことに注意してください。TLSの実装は、アプリケーションに成功したような接続を報告してはなりません。さらに、サーバーが提示するすべてのセッションチケットとセッションIDを無視する必要があります。これらの接続は、セクション6.1.6で説明されているように、再試行をトリガーするためにのみ使用されます。これは、たとえば、専用のエラーコードとの接続の失敗を報告することにより、実装できます。"
    },
    {
      "indent": 0,
      "text": "6.2. GREASE ECH",
      "section_title": true,
      "ja": "6.2. グリースエック"
    },
    {
      "indent": 3,
      "text": "If the client attempts to connect to a server and does not have an ECHConfig structure available for the server, it SHOULD send a GREASE [RFC8701] \"encrypted_client_hello\" extension in the first ClientHello as follows:",
      "ja": "クライアントがサーバーに接続しようとし、サーバーで使用可能なeChConfig構造がない場合、次のように最初のClientHelloでグリース[RFC8701]「cnecrypted_client_hello」拡張機能を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Set the config_id field to a random byte.",
      "ja": "* config_idフィールドをランダムバイトに設定します。"
    },
    {
      "indent": 3,
      "text": "* Set the cipher_suite field to a supported HpkeSymmetricCipherSuite. The selection SHOULD vary to exercise all supported configurations, but MAY be held constant for successive connections to the same server in the same session.",
      "ja": "* cipher_suiteフィールドをサポートされているhpkesymmetricciphersuiteに設定します。選択は、すべてのサポートされている構成を行使するために異なる必要がありますが、同じセッションで同じサーバーへの連続した接続のために一定に保持される場合があります。"
    },
    {
      "indent": 3,
      "text": "* Set the enc field to a randomly-generated valid encapsulated public key output by the HPKE KEM.",
      "ja": "* ENCフィールドを、HPKE KEMによってランダムに生成された有効な有効なカプセル化された公開キー出力に設定します。"
    },
    {
      "indent": 3,
      "text": "* Set the payload field to a randomly-generated string of L+C bytes, where C is the ciphertext expansion of the selected AEAD scheme and L is the size of the EncodedClientHelloInner the client would compute when offering ECH, padded according to Section 6.1.3.",
      "ja": "* ペイロードフィールドをランダムに生成されたL Cバイトの文字列に設定します。Cは、選択されたAEADスキームの暗号文の拡張であり、Lはセクション6.1.3に従ってパディングされたECHを提供するときにクライアントが計算するエンコードされたClientHelloinnerのサイズです。"
    },
    {
      "indent": 3,
      "text": "If sending a second ClientHello in response to a HelloRetryRequest, the client copies the entire \"encrypted_client_hello\" extension from the first ClientHello. The identical value will reveal to an observer that the value of \"encrypted_client_hello\" was fake, but this only occurs if there is a HelloRetryRequest.",
      "ja": "HelloretryRequestに応じて2番目のClientHelloを送信する場合、クライアントは最初のClientHelloから「necrypted_client_hello」拡張機能全体をコピーします。同一の値は、「encrypted_client_hello」の値が偽物であることをオブザーバーに明らかにしますが、これはhelloretryrequestがある場合にのみ発生します。"
    },
    {
      "indent": 3,
      "text": "If the server sends an \"encrypted_client_hello\" extension in either HelloRetryRequest or EncryptedExtensions, the client MUST check the extension syntactically and abort the connection with a \"decode_error\" alert if it is invalid. It otherwise ignores the extension. It MUST NOT save the \"retry_config\" value in EncryptedExtensions.",
      "ja": "サーバーがhelloretryRequestまたは暗号化されたテクステンションのいずれかで「encrypted_client_hello」拡張子を送信する場合、クライアントは拡張機能を構文的にチェックし、無効な場合は「decode_error」アラートに接続を中止する必要があります。それ以外の場合は、拡張機能を無視します。暗号化されたEndextensionsで「Retry_Config」値を保存してはなりません。"
    },
    {
      "indent": 3,
      "text": "Offering a GREASE extension is not considered offering an encrypted ClientHello for purposes of requirements in Section 6.1. In particular, the client MAY offer to resume sessions established without ECH.",
      "ja": "グリース拡張を提供することは、セクション6.1の要件の目的で暗号化されたClienthelloを提供することは見なされません。特に、クライアントは、ECHなしで確立されたセッションを再開することを申し出ることができます。"
    },
    {
      "indent": 0,
      "text": "7. Server Behavior",
      "section_title": true,
      "ja": "7. サーバーの動作"
    },
    {
      "indent": 3,
      "text": "Servers that support ECH play one of two roles, depending on the payload of the \"encrypted_client_hello\" extension in the initial ClientHello:",
      "ja": "ECHをサポートするサーバーは、最初のclienthelloの「encrypted_client_hello」拡張機能のペイロードに応じて、2つの役割のいずれかを再生します。"
    },
    {
      "indent": 3,
      "text": "* If ECHClientHello.type is outer, then the server acts as a client-facing server and proceeds as described in Section 7.1 to extract a ClientHelloInner, if available.",
      "ja": "* echclienthello.typeが外側の場合、サーバーはクライアント向けサーバーとして機能し、セクション7.1で説明されているように進行して、利用可能な場合はclienthelloinnerを抽出します。"
    },
    {
      "indent": 3,
      "text": "* If ECHClientHello.type is inner, then the server acts as a backend server and proceeds as described in Section 7.2.",
      "ja": "* echclienthello.typeが内側の場合、サーバーはバックエンドサーバーとして機能し、セクション7.2で説明されているように進行します。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, if ECHClientHello.type is not a valid ECHClientHelloType, then the server MUST abort with an \"illegal_parameter\" alert.",
      "ja": "* それ以外の場合、echclienthello.typeが有効なechclienthellotypeではない場合、サーバーは「Illegal_parameter」アラートで中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the \"encrypted_client_hello\" is not present, then the server completes the handshake normally, as described in [RFC8446].",
      "ja": "[rfc8446]に記載されているように、「cnecrypted_client_hello」が存在しない場合、サーバーは正常に握手を完了します。"
    },
    {
      "indent": 0,
      "text": "7.1. Client-Facing Server",
      "section_title": true,
      "ja": "7.1. クライアント向けサーバー"
    },
    {
      "indent": 3,
      "text": "Upon receiving an \"encrypted_client_hello\" extension in an initial ClientHello, the client-facing server determines if it will accept ECH, prior to negotiating any other TLS parameters. Note that successfully decrypting the extension will result in a new ClientHello to process, so even the client's TLS version preferences may have changed.",
      "ja": "最初のClientHelloで「necrypted_client_hello」拡張機能を受信すると、クライアント向けサーバーは、他のTLSパラメーターを交渉する前に、ECHを受け入れるかどうかを決定します。拡張機能を正常に復号化すると、新しいClientHelloが処理されるため、クライアントのTLSバージョンの設定も変更された可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "First, the server collects a set of candidate ECHConfig values. This list is determined by one of the two following methods:",
      "ja": "まず、サーバーは候補のeChConfig値のセットを収集します。このリストは、次の2つの方法のいずれかによって決定されます。"
    },
    {
      "indent": 3,
      "text": "1. Compare ECHClientHello.config_id against identifiers of each known ECHConfig and select the ones that match, if any, as candidates.",
      "ja": "1. echclienthello.config_idを既知の各echconfigの識別子と比較し、候補として一致するものを選択します。"
    },
    {
      "indent": 3,
      "text": "2. Collect all known ECHConfig values as candidates, with trial decryption below determining the final selection.",
      "ja": "2. すべての既知のeChConfig値を候補として収集し、最終選択を決定する以下の試行復号化を行います。"
    },
    {
      "indent": 3,
      "text": "Some uses of ECH, such as local discovery mode, may randomize the ECHClientHello.config_id since it can be used as a tracking vector. In such cases, the second method should be used for matching the ECHClientHello to a known ECHConfig. See Section 10.4. Unless specified by the application profile or otherwise externally configured, implementations MUST use the first method.",
      "ja": "ローカルディスカバリーモードなどのECHの使用は、追跡ベクターとして使用できるため、eChclienthello.config_idをランダム化する場合があります。そのような場合、2番目の方法は、eChclienthelloを既知のeChConfigと一致させるために使用する必要があります。セクション10.4を参照してください。アプリケーションプロファイルによって指定されていない場合、またはその他の外部で構成されている場合を除き、実装は最初の方法を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server then iterates over the candidate ECHConfig values, attempting to decrypt the \"encrypted_client_hello\" extension:",
      "ja": "その後、サーバーは候補のeChConfig値を反復し、「encrypted_client_hello」拡張機能を復号化しようとします。"
    },
    {
      "indent": 3,
      "text": "The server verifies that the ECHConfig supports the cipher suite indicated by the ECHClientHello.cipher_suite and that the version of ECH indicated by the client matches the ECHConfig.version. If not, the server continues to the next candidate ECHConfig.",
      "ja": "サーバーは、eChClienthello.cipher_suiteで示された暗号スイートをサポートしていること、およびクライアントによって示されるeCHのバージョンがeChconfig.versionと一致することを確認します。そうでない場合、サーバーは次の候補Echconfigに続きます。"
    },
    {
      "indent": 3,
      "text": "Next, the server decrypts ECHClientHello.payload, using the private key skR corresponding to ECHConfig, as follows:",
      "ja": "次に、サーバーはECHCLIENTHELLO.PAYLOADを復号化し、次のようにECHCONFIGに対応する秘密のキーSKRを使用します。"
    },
    {
      "indent": 7,
      "text": "context = SetupBaseR(ECHClientHello.enc, skR, \"tls ech\" || 0x00 || ECHConfig) EncodedClientHelloInner = context.Open(ClientHelloOuterAAD, ECHClientHello.payload)",
      "ja": "Context = setupbaser（echclienthello.enc、skr、 \"tls ech\" || 0x00 || echconfig）encodedclienthelloinner = context.open（clienthelloouteraad、echclienthello.payload）"
    },
    {
      "indent": 3,
      "text": "ClientHelloOuterAAD is computed from ClientHelloOuter as described in Section 5.2. The info parameter to SetupBaseR is the concatenation \"tls ech\", a zero byte, and the serialized ECHConfig. If decryption fails, the server continues to the next candidate ECHConfig. Otherwise, the server reconstructs ClientHelloInner from EncodedClientHelloInner, as described in Section 5.1. It then stops iterating over the candidate ECHConfig values.",
      "ja": "clienthelloouteraadは、セクション5.2で説明されているように、clienthelloouterから計算されます。SetupBaserへの情報パラメーターは、「TLS ECH」、ゼロバイト、およびシリアル化されたECHCONFIGです。復号化が失敗した場合、サーバーは次の候補Echconfigに続きます。それ以外の場合、セクション5.1で説明されているように、サーバーはecodedClientHelloinnerからClientHelloinnerを再構築します。その後、候補のeChConfig値を繰り返し停止します。"
    },
    {
      "indent": 3,
      "text": "Upon determining the ClientHelloInner, the client-facing server checks that the message includes a well-formed \"encrypted_client_hello\" extension of type inner and that it does not offer TLS 1.2 or below. If either of these checks fails, the client-facing server MUST abort with an \"illegal_parameter\" alert.",
      "ja": "ClientHelloinnerを決定すると、クライアント向けサーバーは、メッセージに型の「encrypted_client_hello」型インナーの拡張が含まれていること、およびTLS 1.2以下のTLSを提供しないことを確認します。これらのチェックのいずれかが失敗した場合、クライアント向けサーバーは「Illegal_Parameter」アラートで中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "If these checks succeed, the client-facing server then forwards the ClientHelloInner to the appropriate backend server, which proceeds as in Section 7.2. If the backend server responds with a HelloRetryRequest, the client-facing server forwards it, decrypts the client's second ClientHelloOuter using the procedure in Section 7.1.1, and forwards the resulting second ClientHelloInner. The client-facing server forwards all other TLS messages between the client and backend server unmodified.",
      "ja": "これらのチェックが成功した場合、クライアント向けサーバーは、クライアントヘロインナーを適切なバックエンドサーバーに転送します。これはセクション7.2のように進行します。バックエンドサーバーがHelloretryRequestで応答した場合、クライアント向けサーバーはそれを転送し、セクション7.1.1の手順を使用してクライアントの2番目のClientHelloouterを復号化し、結果の2番目のClientHelloinnerを転送します。クライアント向けサーバーは、クライアントとバックエンドサーバーの間で他のすべてのTLSメッセージを変更していないことを転送します。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if all candidate ECHConfig values fail to decrypt the extension, the client-facing server MUST ignore the extension and proceed with the connection using ClientHelloOuter, with the following modifications:",
      "ja": "それ以外の場合、すべての候補EechConfig値が拡張機能を復号化できない場合、クライアント向けサーバーは拡張機能を無視し、次の変更を使用してClientHelloouterを使用して接続を続行する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If sending a HelloRetryRequest, the server MAY include an \"encrypted_client_hello\" extension with a payload of 8 random bytes; see Section 10.9.4 for details.",
      "ja": "* HelloretryRequestを送信する場合、サーバーには、8つのランダムバイトのペイロードを備えた「encrypted_client_hello」拡張子を含めることができます。詳細については、セクション10.9.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "* If the server is configured with any ECHConfigs, it MUST include the \"encrypted_client_hello\" extension in its EncryptedExtensions with the \"retry_configs\" field set to one or more ECHConfig",
      "ja": "* サーバーがECHCONFIGSで構成されている場合、「retry_configs」フィールドを1つ以上のeChConfigに設定して、暗号化されたテレンスに「encrypted_client_hello」拡張機能を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "structures with up-to-date keys. Servers MAY supply multiple ECHConfig values of different versions. This allows a server to support multiple versions at once.",
      "ja": "最新のキーを持つ構造。サーバーは、異なるバージョンの複数のeChConfig値を提供する場合があります。これにより、サーバーは一度に複数のバージョンをサポートできます。"
    },
    {
      "indent": 3,
      "text": "Note that decryption failure could indicate a GREASE ECH extension (see Section 6.2), so it is necessary for servers to proceed with the connection and rely on the client to abort if ECH was required. In particular, the unrecognized value alone does not indicate a misconfigured ECH advertisement (Section 8.1). Instead, servers can measure occurrences of the \"ech_required\" alert to detect this case.",
      "ja": "復号化の障害はグリースECH拡張を示す可能性があることに注意してください（セクション6.2を参照）。したがって、サーバーは接続を進め、ECHが必要な場合にクライアントに依存して中止する必要があります。特に、認識されていない価値だけでは、誤解されたECH広告を示すものではありません（セクション8.1）。代わりに、サーバーは「ECH_Required」アラートの発生を測定して、このケースを検出できます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Sending HelloRetryRequest",
      "section_title": true,
      "ja": "7.1.1. HelloretryRequestの送信"
    },
    {
      "indent": 3,
      "text": "After sending or forwarding a HelloRetryRequest, the client-facing server does not repeat the steps in Section 7.1 with the second ClientHelloOuter. Instead, it continues with the ECHConfig selection from the first ClientHelloOuter as follows:",
      "ja": "HelloretryRequestを送信または転送した後、クライアント向けサーバーは、2番目のClientHelloouterでセクション7.1の手順を繰り返しません。代わりに、次のように、最初のclienthelloouterからのechconfigの選択を続行します。"
    },
    {
      "indent": 3,
      "text": "If the client-facing server accepted ECH, it checks the second ClientHelloOuter also contains the \"encrypted_client_hello\" extension. If not, it MUST abort the handshake with a \"missing_extension\" alert. Otherwise, it checks that ECHClientHello.cipher_suite and ECHClientHello.config_id are unchanged, and that ECHClientHello.enc is empty. If not, it MUST abort the handshake with an \"illegal_parameter\" alert.",
      "ja": "クライアント向けサーバーがECHを受け入れた場合、2番目のClientHellOouterには「encrypted_client_hello」拡張機能も含まれています。そうでない場合は、「Missing_Extension」アラートで握手を中止する必要があります。それ以外の場合、echclienthello.ciphel_suiteとechclienthello.config_idが変更されておらず、echclienthello.encが空であることをチェックします。そうでない場合は、「Illegal_Parameter」アラートで握手を中止する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, it decrypts the new ECHClientHello.payload as a second message with the previous HPKE context:",
      "ja": "最後に、以前のHPKEコンテキストで2番目のメッセージとして、新しいechclienthello.payloadを復号化します。"
    },
    {
      "indent": 7,
      "text": "EncodedClientHelloInner = context.Open(ClientHelloOuterAAD, ECHClientHello.payload)",
      "ja": "EncodedClientHelloinner = context.open（clienthelloouteraad、echclienthello.payload）"
    },
    {
      "indent": 3,
      "text": "ClientHelloOuterAAD is computed as described in Section 5.2, but using the second ClientHelloOuter. If decryption fails, the client-facing server MUST abort the handshake with a \"decrypt_error\" alert. Otherwise, it reconstructs the second ClientHelloInner from the new EncodedClientHelloInner as described in Section 5.1, using the second ClientHelloOuter for any referenced extensions.",
      "ja": "clienthelloouteraadは、セクション5.2で説明されているように計算されますが、2番目のclienthelloouterを使用します。復号化が失敗した場合、クライアント向けサーバーは、「decrypt_error」アラートで握手を中止する必要があります。それ以外の場合は、参照された拡張機能に2番目のClientHelloouterを使用して、セクション5.1で説明されているように、新しいEncodedClientHelloinnerから2番目のClientHelloinnerを再構築します。"
    },
    {
      "indent": 3,
      "text": "The client-facing server then forwards the resulting ClientHelloInner to the backend server. It forwards all subsequent TLS messages between the client and backend server unmodified.",
      "ja": "クライアント向けサーバーは、結果のClientHelloinnerをバックエンドサーバーに転送します。クライアントサーバーとバックエンドサーバーの間で、後続のすべてのTLSメッセージを変更しません。"
    },
    {
      "indent": 3,
      "text": "If the client-facing server rejected ECH, or if the first ClientHello did not include an \"encrypted_client_hello\" extension, the client-facing server proceeds with the connection as usual. The server does not decrypt the second ClientHello's ECHClientHello.payload value, if there is one. Moreover, if the server is configured with any",
      "ja": "クライアント向けサーバーがECHを拒否した場合、または最初のClientHelloに「necrypted_client_hello」拡張機能を含めなかった場合、クライアント向けサーバーは通常どおり接続を進みます。サーバーは、2番目のclienthelloのechclienthello.payload値を復号化しません。さらに、サーバーがいずれかで構成されている場合"
    },
    {
      "indent": 3,
      "text": "ECHConfigs, it MUST include the \"encrypted_client_hello\" extension in its EncryptedExtensions with the \"retry_configs\" field set to one or more ECHConfig structures with up-to-date keys, as described in Section 7.1.",
      "ja": "ECHCONFIGS、セクション7.1で説明されているように、最新のキーを持つ1つ以上のECHCONFIG構造に設定された「RETRY_CONFIGS」フィールドを使用して、暗号化されたテクステンズに「encrypted_client_hello」拡張機能を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that a client-facing server that forwards the first ClientHello cannot include its own \"cookie\" extension if the backend server sends a HelloRetryRequest. This means that the client-facing server either needs to maintain state for such a connection or it needs to coordinate with the backend server to include any information it requires to process the second ClientHello.",
      "ja": "最初のClientHelloを転送するクライアント向けサーバーは、バックエンドサーバーがHelloretryRequestを送信した場合、独自の「Cookie」拡張機能を含めることができないことに注意してください。これは、クライアント向けサーバーがそのような接続のために状態を維持する必要があるか、2番目のClientHelloを処理するために必要な情報を含めるためにバックエンドサーバーと調整する必要があることを意味します。"
    },
    {
      "indent": 0,
      "text": "7.2. Backend Server",
      "section_title": true,
      "ja": "7.2. バックエンドサーバー"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an \"encrypted_client_hello\" extension of type inner in a ClientHello, if the backend server negotiates TLS 1.3 or higher, then it MUST confirm ECH acceptance to the client by computing its ServerHello as described here.",
      "ja": "ClientHelloで「necrypted_client_hello」インナーの拡張を受信すると、バックエンドサーバーがTLS 1.3以上を交渉する場合、ここで説明するようにサーバーヘロを計算してクライアントへのECHの受け入れを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "The backend server embeds in ServerHello.random a string derived from the inner handshake. It begins by computing its ServerHello as usual, except the last 8 bytes of ServerHello.random are set to zero. It then computes the transcript hash for ClientHelloInner up to and including the modified ServerHello, as described in [RFC8446], Section 4.4.1. Let transcript_ech_conf denote the output. Finally, the backend server overwrites the last 8 bytes of the ServerHello.random with the following string:",
      "ja": "バックエンドサーバーは、serverhello.randomに内側の握手から派生した文字列を埋め込みます。ServerHello.randomの最後の8バイトがゼロに設定されていることを除いて、通常どおりServerHelloを計算することから始めます。次に、[RFC8446]、セクション4.4.1に記載されているように、ClientHelloinnerのトランスクリプトハッシュを変更し、修正されたServerHelloまで計算します。transcript_ech_confが出力を示します。最後に、バックエンドサーバーは、次の文字列でserverhello.randomの最後の8バイトを上書きします。"
    },
    {
      "indent": 6,
      "text": "accept_confirmation = HKDF-Expand-Label( HKDF-Extract(0, ClientHelloInner.random), \"ech accept confirmation\", transcript_ech_conf, 8)",
      "ja": "Accept_Confirmation = HKDF-Expand-Label（HKDF-Extract（0、clienthelloinner.random）、 \"ECH Accept Confismation\"、transcript_ech_conf、8）"
    },
    {
      "indent": 3,
      "text": "where HKDF-Expand-Label is defined in [RFC8446], Section 7.1, \"0\" indicates a string of Hash.length bytes set to zero, and Hash is the hash function used to compute the transcript hash.",
      "ja": "HKDF-EXPAND-LABELが[RFC8446]で定義されている場合、セクション7.1、「0」はゼロに設定されたハッシュ長バイトの文字列を示し、ハッシュはトランスクリプトハッシュを計算するために使用されるハッシュ関数です。"
    },
    {
      "indent": 3,
      "text": "The backend server MUST NOT perform this operation if it negotiated TLS 1.2 or below. Note that doing so would overwrite the downgrade signal for TLS 1.3 (see [RFC8446], Section 4.1.3).",
      "ja": "バックエンドサーバーは、TLS 1.2以下を交渉した場合、この操作を実行してはなりません。そうすることで、TLS 1.3のダウングレード信号が上書きされることに注意してください（[RFC8446]、セクション4.1.3を参照）。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Sending HelloRetryRequest",
      "section_title": true,
      "ja": "7.2.1. HelloretryRequestの送信"
    },
    {
      "indent": 3,
      "text": "When the backend server sends HelloRetryRequest in response to the ClientHello, it similarly confirms ECH acceptance by adding a confirmation signal to its HelloRetryRequest. But instead of embedding the signal in the HelloRetryRequest.random (the value of which is specified by [RFC8446]), it sends the signal in an extension.",
      "ja": "BackEndサーバーがClientHelloに応じてHelloretryRequestを送信すると、同様に、HelloretryRequestに確認信号を追加することにより、ECHの受け入れを確認します。しかし、HelloretryRequest.random（その値は[RFC8446]によって指定されている）に信号を埋め込む代わりに、拡張に信号を送信します。"
    },
    {
      "indent": 3,
      "text": "The backend server begins by computing HelloRetryRequest as usual, except that it also contains an \"encrypted_client_hello\" extension with a payload of 8 zero bytes. It then computes the transcript hash for the first ClientHelloInner, denoted ClientHelloInner1, up to and including the modified HelloRetryRequest. Let transcript_hrr_ech_conf denote the output. Finally, the backend server overwrites the payload of the \"encrypted_client_hello\" extension with the following string:",
      "ja": "バックエンドサーバーは、通常どおりHelloretryRequestを計算することから始まりますが、8ゼロのバイトのペイロードを備えた「necrypted_client_hello」拡張機能も含まれています。次に、修正されたHelloretryRequestまでのClientHelloInner1を示し、最初のclientHelloinnerの転写ハッシュを計算します。transcript_hrr_ech_confが出力を示します。最後に、バックエンドサーバーは、次の文字列を使用して「encrypted_client_hello」拡張子のペイロードを上書きします。"
    },
    {
      "indent": 6,
      "text": "hrr_accept_confirmation = HKDF-Expand-Label( HKDF-Extract(0, ClientHelloInner1.random), \"hrr ech accept confirmation\", transcript_hrr_ech_conf, 8)",
      "ja": "HRR_ACCEPT_CONFIRMATION = HKDF-EXPAND-LABEL（HKDF-Extract（0、ClientHelloInner1.Random）、「HRR ECH Accept Accept Accement」、Transcript_Hrr_ech_conf、8）"
    },
    {
      "indent": 3,
      "text": "In the subsequent ServerHello message, the backend server sends the accept_confirmation value as described in Section 7.2.",
      "ja": "後続のServerHelloメッセージでは、BackEndサーバーはセクション7.2で説明されているようにAccect_Confirmation値を送信します。"
    },
    {
      "indent": 0,
      "text": "8. Compatibility Issues",
      "section_title": true,
      "ja": "8. 互換性の問題"
    },
    {
      "indent": 3,
      "text": "Unlike most TLS extensions, placing the SNI value in an ECH extension is not interoperable with existing servers, which expect the value in the existing plaintext extension. Thus server operators SHOULD ensure servers understand a given set of ECH keys before advertising them. Additionally, servers SHOULD retain support for any previously-advertised keys for the duration of their validity.",
      "ja": "ほとんどのTLS拡張機能とは異なり、ECH拡張機能にSNI値を配置することは、既存のサーバーと相互運用できません。これは、既存のプレーンテキスト拡張機能の値を期待しています。したがって、サーバーオペレーターは、広告する前に、サーバーが特定のECHキーのセットを理解できるようにする必要があります。さらに、サーバーは、有効性の期間中、以前に広告されたキーのサポートを保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "However, in more complex deployment scenarios, this may be difficult to fully guarantee. Thus this protocol was designed to be robust in case of inconsistencies between systems that advertise ECH keys and servers, at the cost of extra round-trips due to a retry. Two specific scenarios are detailed below.",
      "ja": "ただし、より複雑な展開シナリオでは、これを完全に保証するのは難しい場合があります。したがって、このプロトコルは、再試行のために余分な往復を犠牲にして、ECHキーとサーバーを宣伝するシステム間で矛盾した場合に堅牢になるように設計されました。2つの特定のシナリオを以下に詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "8.1. Misconfiguration and Deployment Concerns",
      "section_title": true,
      "ja": "8.1. 誤解と展開の懸念"
    },
    {
      "indent": 3,
      "text": "It is possible for ECH advertisements and servers to become inconsistent. This may occur, for instance, from DNS misconfiguration, caching issues, or an incomplete rollout in a multi-server deployment. This may also occur if a server loses its ECH keys, or if a deployment of ECH must be rolled back on the server.",
      "ja": "ECH広告とサーバーが矛盾する可能性があります。これは、たとえば、DNSの誤解、キャッシングの問題、またはマルチサーバーの展開での不完全なロールアウトから発生する可能性があります。これは、サーバーがECHキーを失った場合、またはECHの展開をサーバー上にロールバックする必要がある場合にも発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The retry mechanism repairs inconsistencies, provided the server is authoritative for the public name. If server and advertised keys mismatch, the server will reject ECH and respond with \"retry_configs\". If the server does not understand the \"encrypted_client_hello\" extension at all, it will ignore it as required by Section 4.1.2 of [RFC8446]. Provided the server can present a certificate valid for the public name, the client can safely retry with updated settings, as described in Section 6.1.6.",
      "ja": "サーバーが公開名の権威ある場合、再試行メカニズムは矛盾を修理します。サーバーと宣伝されたキーの不一致の場合、サーバーはECHを拒否し、「RETRY_CONFIGS」で応答します。サーバーが「encrypted_client_hello」拡張機能をまったく理解していない場合、[RFC8446]のセクション4.1.2で要求されているように無視します。サーバーが公開名に有効な証明書を提示できる場合、セクション6.1.6で説明されているように、クライアントは更新された設定で安全に再試行できます。"
    },
    {
      "indent": 3,
      "text": "Unless ECH is disabled as a result of successfully establishing a connection to the public name, the client MUST NOT fall back to using unencrypted ClientHellos, as this allows a network attacker to disclose the contents of this ClientHello, including the SNI. It MAY attempt to use another server from the DNS results, if one is provided.",
      "ja": "公開名への接続を正常に確立した結果としてECHが無効になっていない限り、クライアントは、ネットワーク攻撃者がSNIを含むこのクライアントヘロの内容を開示できるため、暗号化されていないClienthellosの使用に戻ってはいけません。DNSの結果から別のサーバーを使用しようとする場合があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Middleboxes",
      "section_title": true,
      "ja": "8.2. ミドルボックス"
    },
    {
      "indent": 3,
      "text": "When connecting through a TLS-terminating proxy that does not support this extension, [RFC8446], Section 9.3 requires the proxy still act as a conforming TLS client and server. The proxy must ignore unknown parameters, and generate its own ClientHello containing only parameters it understands. Thus, when presenting a certificate to the client or sending a ClientHello to the server, the proxy will act as if connecting to the public name, without echoing the \"encrypted_client_hello\" extension.",
      "ja": "この拡張機能[RFC8446]をサポートしていないTLS終了プロキシを介して接続する場合、セクション9.3では、プロキシが適合するTLSクライアントとサーバーとして機能する必要があります。プロキシは、不明なパラメーターを無視し、理解しているパラメーターのみを含む独自のClientHelloを生成する必要があります。したがって、クライアントに証明書を提示する場合、またはクライアントヘロをサーバーに送信する場合、プロキシは「necrypted_client_hello」拡張子をエコーせずに、公開名に接続するかのように動作します。"
    },
    {
      "indent": 3,
      "text": "Depending on whether the client is configured to accept the proxy's certificate as authoritative for the public name, this may trigger the retry logic described in Section 6.1.6 or result in a connection failure. A proxy which is not authoritative for the public name cannot forge a signal to disable ECH.",
      "ja": "クライアントが公開名の権威としてプロキシの証明書を受け入れるように構成されているかどうかに応じて、これにより、セクション6.1.6で説明されている再試行ロジックがトリガーされるか、接続障害になります。公開名に対して権威がないプロキシは、ECHを無効にする信号を偽造できません。"
    },
    {
      "indent": 0,
      "text": "9. Compliance Requirements",
      "section_title": true,
      "ja": "9. コンプライアンス要件"
    },
    {
      "indent": 3,
      "text": "In the absence of an application profile standard specifying otherwise, a compliant ECH application MUST implement the following HPKE cipher suite:",
      "ja": "それ以外の場合は、アプリケーションプロファイル標準がない場合、準拠したECHアプリケーションは、次のHPKE暗号スイートを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "* KEM: DHKEM(X25519, HKDF-SHA256) (see [I-D.irtf-cfrg-hpke], Section 7.1)",
      "ja": "* KEM：DHKEM（X25519、HKDF-SHA256）（[i-d.irtf-cfrg-hpke]、セクション7.1を参照）"
    },
    {
      "indent": 3,
      "text": "* KDF: HKDF-SHA256 (see [I-D.irtf-cfrg-hpke], Section 7.2)",
      "ja": "* KDF：HKDF-SHA256（[i-d.irtf-cfrg-hpke]、セクション7.2を参照）"
    },
    {
      "indent": 3,
      "text": "* AEAD: AES-128-GCM (see [I-D.irtf-cfrg-hpke], Section 7.3)",
      "ja": "* AEAD：AES-128-GCM（[i-d.irtf-cfrg-hpke]、セクション7.3を参照）"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "10.1. Security and Privacy Goals",
      "section_title": true,
      "ja": "10.1. セキュリティとプライバシーの目標"
    },
    {
      "indent": 3,
      "text": "ECH considers two types of attackers: passive and active. Passive attackers can read packets from the network, but they cannot perform any sort of active behavior such as probing servers or querying DNS. A middlebox that filters based on plaintext packet contents is one example of a passive attacker. In contrast, active attackers can also write packets into the network for malicious purposes, such as interfering with existing connections, probing servers, and querying DNS. In short, an active attacker corresponds to the conventional threat model for TLS 1.3 [RFC8446].",
      "ja": "ECHは、受動的でアクティブな2種類の攻撃者を考慮します。パッシブ攻撃者はネットワークからパケットを読み取ることができますが、サーバーの調査やDNSのクエリなど、いかなる種類のアクティブな動作を実行することはできません。Plantextパケットのコンテンツに基づいてフィルターを使用するミドルボックスは、受動的な攻撃者の一例です。対照的に、アクティブな攻撃者は、既存の接続、調査サーバーの調査、DNSのクエリなど、悪意のある目的のためにネットワークにパケットを書き込むこともできます。要するに、アクティブな攻撃者は、TLS 1.3 [RFC8446]の従来の脅威モデルに対応します。"
    },
    {
      "indent": 3,
      "text": "Given these types of attackers, the primary goals of ECH are as follows.",
      "ja": "これらのタイプの攻撃者を考えると、ECHの主な目標は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Use of ECH does not weaken the security properties of TLS without ECH.",
      "ja": "1. ECHの使用は、ECHなしでTLSのセキュリティプロパティを弱めません。"
    },
    {
      "indent": 3,
      "text": "2. TLS connection establishment to a host with a specific ECHConfig and TLS configuration is indistinguishable from a connection to any other host with the same ECHConfig and TLS configuration. (The set of hosts which share the same ECHConfig and TLS configuration is referred to as the anonymity set.)",
      "ja": "2. 特定のECHCONFIGおよびTLS構成を備えたホストへのTLS接続確立は、同じECHCONFIGおよびTLS構成を持つ他のホストへの接続と区別できません。（同じECHCONFIGとTLS構成を共有するホストのセットは、匿名セットと呼ばれます。）"
    },
    {
      "indent": 3,
      "text": "Client-facing server configuration determines the size of the anonymity set. For example, if a client-facing server uses distinct ECHConfig values for each host, then each anonymity set has size k = 1. Client-facing servers SHOULD deploy ECH in such a way so as to maximize the size of the anonymity set where possible. This means client-facing servers should use the same ECHConfig for as many hosts as possible. An attacker can distinguish two hosts that have different ECHConfig values based on the ECHClientHello.config_id value. This also means public information in a TLS handshake should be consistent across hosts. For example, if a client-facing server services many backend origin hosts, only one of which supports some cipher suite, it may be possible to identify that host based on the contents of unencrypted handshake messages.",
      "ja": "クライアント向けサーバー構成により、匿名セットのサイズが決まります。たとえば、クライアント向けサーバーが各ホストの個別のeChConfig値を使用する場合、各匿名セットにはサイズk = 1の場合は、クライアント向けサーバーが匿名セットのサイズを最大化するためにECHを展開する必要があります。。これは、クライアント向けサーバーができるだけ多くのホストに同じeChConfigを使用する必要があることを意味します。攻撃者は、echclienthello.config_id値に基づいて異なるeChConfig値を持つ2つのホストを区別できます。これはまた、TLSの握手における公開情報がホスト間で一貫している必要があることを意味します。たとえば、クライアント向けサーバーが多くのバックエンドオリジンホストにサービスを提供している場合、そのうちの1つだけが暗号スイートをサポートしている場合、暗号化されていないハンドシェイクメッセージの内容に基づいてそのホストを識別することができる場合があります。"
    },
    {
      "indent": 3,
      "text": "Beyond these primary security and privacy goals, ECH also aims to hide, to some extent, the fact that it is being used at all. Specifically, the GREASE ECH extension described in Section 6.2 does not change the security properties of the TLS handshake at all. Its goal is to provide \"cover\" for the real ECH protocol (Section 6.1), as a means of addressing the \"do not stick out\" requirements of [RFC8744]. See Section 10.9.4 for details.",
      "ja": "これらの主要なセキュリティとプライバシーの目標を超えて、ECHは、ある程度、それがまったく使用されているという事実を隠すことも目指しています。具体的には、セクション6.2で説明されているグリースエック拡張機能は、TLSハンドシェイクのセキュリティプロパティをまったく変更しません。その目標は、[RFC8744]の「揺れ動かない」要件に対処する手段として、実際のECHプロトコル（セクション6.1）に「カバー」を提供することです。詳細については、セクション10.9.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.2. Unauthenticated and Plaintext DNS",
      "section_title": true,
      "ja": "10.2. 認識されていないDNSとプレーンテキスト"
    },
    {
      "indent": 3,
      "text": "In comparison to [I-D.kazuho-protected-sni], wherein DNS Resource Records are signed via a server private key, ECH records have no authenticity or provenance information. This means that any attacker which can inject DNS responses or poison DNS caches, which is a common scenario in client access networks, can supply clients with fake ECH records (so that the client encrypts data to them) or strip the ECH record from the response. However, in the face of an attacker that controls DNS, no encryption scheme can work because the attacker can replace the IP address, thus blocking client connections, or substitute a unique IP address which is 1:1 with the DNS name that was looked up (modulo DNS wildcards). Thus, allowing the ECH records in the clear does not make the situation significantly worse.",
      "ja": "DNSリソースレコードがサーバーの秘密キーを介して署名されている[i-d.kazuho保護-Sni]と比較して、ECHレコードには信頼性や出所情報がありません。これは、クライアントアクセスネットワークの一般的なシナリオであるDNS応答またはポイズンDNSキャッシュを注入できる攻撃者は、クライアントに偽のECHレコード（クライアントがデータを暗号化するように）を提供したり、応答からECHレコードを削除したりできることを意味します。。ただし、DNSを制御する攻撃者に直面しても、攻撃者がIPアドレスを交換してクライアント接続をブロックできるため、暗号化スキームは機能しません。（Modulo DNSワイルドカード）。したがって、ClearのECHレコードを許可しても、状況が大幅に悪化することはありません。"
    },
    {
      "indent": 3,
      "text": "Clearly, DNSSEC (if the client validates and hard fails) is a defense against this form of attack, but DoH/DPRIVE are also defenses against DNS attacks by attackers on the local network, which is a common case where ClientHello and SNI encryption are desired. Moreover, as noted in the introduction, SNI encryption is less useful without encryption of DNS queries in transit via DoH or DPRIVE mechanisms.",
      "ja": "明らかに、DNSSEC（クライアントが検証し、ハード失敗の場合）はこの形式の攻撃に対する防御ですが、DOH/DPRIVEは、クライアントヘロとSNI暗号化が必要な一般的なケースであるローカルネットワークでの攻撃者によるDNS攻撃に対する防御でもあります。。さらに、導入部で述べたように、SNI暗号化は、DOHまたはDPRIVEメカニズムを介した輸送中のDNSクエリの暗号化なしではあまり有用ではありません。"
    },
    {
      "indent": 0,
      "text": "10.3. Client Tracking",
      "section_title": true,
      "ja": "10.3. クライアント追跡"
    },
    {
      "indent": 3,
      "text": "A malicious client-facing server could distribute unique, per-client ECHConfig structures as a way of tracking clients across subsequent connections. On-path adversaries which know about these unique keys could also track clients in this way by observing TLS connection attempts.",
      "ja": "悪意のあるクライアント向けサーバーは、その後の接続全体でクライアントを追跡する方法として、ユニークでクライアントのECHCONFIG構造を配布できます。これらのユニークなキーについて知っているパス上の敵は、TLS接続の試みを観察することにより、この方法でクライアントを追跡することもできます。"
    },
    {
      "indent": 3,
      "text": "The cost of this type of attack scales linearly with the desired number of target clients. Moreover, DNS caching behavior makes targeting individual users for extended periods of time, e.g., using per-client ECHConfig structures delivered via HTTPS RRs with high TTLs, challenging. Clients can help mitigate this problem by flushing any DNS or ECHConfig state upon changing networks.",
      "ja": "このタイプの攻撃のコストは、目的の数のターゲットクライアントと直線的にスケーリングします。さらに、DNSキャッシュ動作により、個々のユーザーを長時間ターゲットにします。たとえば、高TTLを持つHTTPS RRSを介して配信されるクライアントごとのeChConfig構造を使用して、挑戦的です。クライアントは、ネットワークを変更すると、DNSまたはECHCONFIG状態をフラッシュすることにより、この問題を軽減するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "10.4. Ignored Configuration Identifiers and Trial Decryption",
      "section_title": true,
      "ja": "10.4. 無視された構成識別子と試行復号化"
    },
    {
      "indent": 3,
      "text": "Ignoring configuration identifiers may be useful in scenarios where clients and client-facing servers do not want to reveal information about the client-facing server in the \"encrypted_client_hello\" extension. In such settings, clients send a randomly generated config_id in the ECHClientHello. Servers in these settings must perform trial decryption since they cannot identify the client's chosen ECH key using the config_id value. As a result, ignoring configuration identifiers may exacerbate DoS attacks. Specifically, an adversary may send malicious ClientHello messages, i.e., those which will not decrypt with any known ECH key, in order to force wasteful decryption. Servers that support this feature should, for example, implement some form of rate limiting mechanism to limit the potential damage caused by such attacks.",
      "ja": "構成識別子を無視することは、クライアントとクライアント向けのサーバーが「encrypted_client_hello」拡張子のクライアント向けサーバーに関する情報を表示したくないシナリオで役立つ場合があります。このような設定では、クライアントはechclienthelloでランダムに生成されたconfig_idを送信します。これらの設定のサーバーは、config_id値を使用してクライアントが選択したECHキーを識別できないため、試用復帰を実行する必要があります。その結果、構成識別子を無視すると、DOS攻撃が悪化する可能性があります。具体的には、敵は悪意のあるClientHelloメッセージ、つまり、無駄な復号化を強制するために、既知のECHキーで復号化されないものを送信する場合があります。この機能をサポートするサーバーは、たとえば、そのような攻撃によって引き起こされる潜在的な損傷を制限するために、何らかの形のレート制限メカニズムを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Unless specified by the application using (D)TLS or externally configured, implementations MUST NOT use this mode.",
      "ja": "（d）TLSまたは外部構成を使用してアプリケーションで指定されていない限り、実装はこのモードを使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "10.5. Outer ClientHello",
      "section_title": true,
      "ja": "10.5. outer clienthello"
    },
    {
      "indent": 3,
      "text": "Any information that the client includes in the ClientHelloOuter is visible to passive observers. The client SHOULD NOT send values in the ClientHelloOuter which would reveal a sensitive ClientHelloInner property, such as the true server name. It MAY send values associated with the public name in the ClientHelloOuter.",
      "ja": "クライアントがClientHelloouterに含める情報は、パッシブオブザーバーに表示されます。クライアントは、True Server名などの機密性の高いClientHelloInnerプロパティを明らかにするクライアントヘロウターに値を送信してはなりません。clienthelloouterの公開名に関連付けられた値を送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "In particular, some extensions require the client send a server-name-specific value in the ClientHello. These values may reveal information about the true server name. For example, the \"cached_info\" ClientHello extension [RFC7924] can contain the hash of a previously observed server certificate. The client SHOULD NOT send values associated with the true server name in the ClientHelloOuter. It MAY send such values in the ClientHelloInner.",
      "ja": "特に、一部の拡張機能では、クライアントがclienthelloでサーバー名固有の値を送信する必要があります。これらの値は、真のサーバー名に関する情報を明らかにする場合があります。たとえば、「cached_info」clienthello拡張子[RFC7924]には、以前に観察されたサーバー証明書のハッシュを含めることができます。クライアントは、clienthelloouterの真のサーバー名に関連付けられた値を送信しないでください。ClientHelloinnerでそのような値を送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "A client may also use different preferences in different contexts. For example, it may send a different ALPN lists to different servers or in different application contexts. A client that treats this context as sensitive SHOULD NOT send context-specific values in ClientHelloOuter.",
      "ja": "クライアントは、さまざまなコンテキストで異なる設定を使用する場合もあります。たとえば、異なるサーバーまたは異なるアプリケーションコンテキストで異なるALPNリストを送信する場合があります。このコンテキストを敏感であると扱うクライアントは、ClientHelloouterでコンテキスト固有の値を送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "Values which are independent of the true server name, or other information the client wishes to protect, MAY be included in ClientHelloOuter. If they match the corresponding ClientHelloInner, they MAY be compressed as described in Section 5.1. However, note the payload length reveals information about which extensions are compressed, so inner extensions which only sometimes match the corresponding outer extension SHOULD NOT be compressed.",
      "ja": "真のサーバー名、またはクライアントが保護したい他の情報に依存しない値は、clienthelloouterに含まれる場合があります。対応するClientHelloinnerと一致する場合、セクション5.1で説明されているように圧縮される可能性があります。ただし、ペイロードの長さは、どの拡張機能が圧縮されているかについての情報を明らかにしているため、対応する外側拡張機能と一致することがある内部拡張機能を圧縮してはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Clients MAY include additional extensions in ClientHelloOuter to avoid signaling unusual behavior to passive observers, provided the choice of value and value itself are not sensitive. See Section 10.9.4.",
      "ja": "クライアントは、価値と価値の選択自体が敏感ではない場合、パッシブオブザーバーに異常な動作を信号することを避けるために、ClientHellOouterの追加の拡張機能を含めることができます。セクション10.9.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.6. Related Privacy Leaks",
      "section_title": true,
      "ja": "10.6. 関連するプライバシーリーク"
    },
    {
      "indent": 3,
      "text": "ECH requires encrypted DNS to be an effective privacy protection mechanism. However, verifying the server's identity from the Certificate message, particularly when using the X509 CertificateType, may result in additional network traffic that may reveal the server identity. Examples of this traffic may include requests for revocation information, such as OCSP or CRL traffic, or requests for repository information, such as authorityInformationAccess. It may also include implementation-specific traffic for additional information sources as part of verification.",
      "ja": "ECHでは、暗号化されたDNSが効果的なプライバシー保護メカニズムになる必要があります。ただし、特にX509証明書を使用する場合、証明書メッセージからサーバーのIDを確認すると、サーバーのIDが表示される可能性のある追加のネットワークトラフィックが発生する可能性があります。このトラフィックの例には、OCSPやCRLトラフィックなどの取り消し情報のリクエスト、またはAuthorityInformationAccessなどのリポジトリ情報のリクエストが含まれます。また、検証の一環として、追加情報源の実装固有のトラフィックを含めることもできます。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD avoid leaking information that may identify the server. Even when sent over an encrypted transport, such requests may result in indirect exposure of the server's identity, such as indicating a specific CA or service being used. To mitigate this risk, servers SHOULD deliver such information in-band when possible, such as through the use of OCSP stapling, and clients SHOULD take steps to minimize or protect such requests during certificate validation.",
      "ja": "実装は、サーバーを識別する可能性のある情報の漏れを避ける必要があります。暗号化されたトランスポートに送信された場合でも、そのような要求は、特定のCAまたは使用が使用されていることを示すなど、サーバーのIDの間接的な露出につながる可能性があります。このリスクを緩和するために、サーバーはOCSPステープルの使用など、可能な場合はバンド内のそのような情報を提供する必要があり、クライアントは証明書の検証中にそのような要求を最小限に抑えるか保護するための措置を講じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Attacks that rely on non-ECH traffic to infer server identity in an ECH connection are out of scope for this document. For example, a client that connects to a particular host prior to ECH deployment may later resume a connection to that same host after ECH deployment. An adversary that observes this can deduce that the ECH-enabled connection was made to a host that the client previously connected to and which is within the same anonymity set.",
      "ja": "ECH接続でサーバーのIDを推測するために非ECHトラフィックに依存している攻撃は、このドキュメントの範囲外です。たとえば、ECH展開の前に特定のホストに接続するクライアントは、ECH展開後に同じホストへの接続を再開する場合があります。これを観察する敵は、クライアントが以前に接続し、同じ匿名セット内にあるホストにECH対応の接続が行われたと推測できます。"
    },
    {
      "indent": 0,
      "text": "10.7. Cookies",
      "section_title": true,
      "ja": "10.7. クッキー"
    },
    {
      "indent": 3,
      "text": "Section 4.2.2 of [RFC8446] defines a cookie value that servers may send in HelloRetryRequest for clients to echo in the second ClientHello. While ECH encrypts the cookie in the second ClientHelloInner, the backend server's HelloRetryRequest is unencrypted.This means differences in cookies between backend servers, such as lengths or cleartext components, may leak information about the server identity.",
      "ja": "[RFC8446]のセクション4.2.2では、2番目のClientHelloでエコーをエコーするために、サーバーがHelloretryRequestで送信する可能性のあるCookie値を定義しています。ECHは2番目のClientHelloinnerでCookieを暗号化しますが、バックエンドサーバーのHelloretryRequestは暗号化されていません。これは、長さやクリアテキストコンポーネントなどのバックエンドサーバー間のCookieの違いを意味しますが、サーバーのアイデンティティに関する情報が漏れます。"
    },
    {
      "indent": 3,
      "text": "Backend servers in an anonymity set SHOULD NOT reveal information in the cookie which identifies the server. This may be done by handling HelloRetryRequest statefully, thus not sending cookies, or by using the same cookie construction for all backend servers.",
      "ja": "匿名セットのバックエンドサーバーは、サーバーを識別するCookie内の情報を表示しないでください。これは、HelloretryRequestを状態で処理し、Cookieを送信することはなく、すべてのバックエンドサーバーに同じCookie構造を使用することで行うことができます。"
    },
    {
      "indent": 3,
      "text": "Note that, if the cookie includes a key name, analogous to Section 4 of [RFC5077], this may leak information if different backend servers issue cookies with different key names at the time of the connection. In particular, if the deployment operates in Split Mode, the backend servers may not share cookie encryption keys. Backend servers may mitigate this by either handling key rotation with trial decryption, or coordinating to match key names.",
      "ja": "[RFC5077]のセクション4に類似したCookieにキー名が含まれている場合、異なるバックエンドサーバーが接続時に異なるキー名でCookieを発行する場合、これは情報をリークする可能性があることに注意してください。特に、展開がスプリットモードで動作する場合、バックエンドサーバーはCookie暗号化キーを共有できない場合があります。バックエンドサーバーは、トライアルの復号化でキーローテーションを処理するか、キー名と一致するように調整することにより、これを軽減できます。"
    },
    {
      "indent": 0,
      "text": "10.8. Attacks Exploiting Acceptance Confirmation",
      "section_title": true,
      "ja": "10.8. 受け入れ確認を悪用する攻撃"
    },
    {
      "indent": 3,
      "text": "To signal acceptance, the backend server overwrites 8 bytes of its ServerHello.random with a value derived from the ClientHelloInner.random. (See Section 7.2 for details.) This behavior increases the likelihood of the ServerHello.random colliding with the ServerHello.random of a previous session, potentially reducing the overall security of the protocol. However, the remaining 24 bytes provide enough entropy to ensure this is not a practical avenue of attack.",
      "ja": "受け入れを信号するために、バックエンドサーバーは、clienthelloinner.randomから派生した値でserverhello.randomの8バイトを上書きします。（詳細については、セクション7.2を参照してください。）この動作により、ServerHello.Randomが以前のセッションのServerHello.Randomと衝突する可能性が高まり、プロトコルの全体的なセキュリティが潜在的に減少する可能性があります。ただし、残りの24バイトは、これが実用的な攻撃道ではないことを保証するのに十分なエントロピーを提供します。"
    },
    {
      "indent": 3,
      "text": "On the other hand, the probability that two 8-byte strings are the same is non-negligible. This poses a modest operational risk. Suppose the client-facing server terminates the connection (i.e., ECH is rejected or bypassed): if the last 8 bytes of its ServerHello.random coincide with the confirmation signal, then the client will incorrectly presume acceptance and proceed as if the backend server terminated the connection. However, the probability of a false positive occurring for a given connection is only 1 in 2^64. This value is smaller than the probability of network connection failures in practice.",
      "ja": "一方、2つの8バイトの文字列が同じであるという確率は、交渉できません。これは、ささやかな運用リスクをもたらします。クライアント向けサーバーが接続を終了するとします（つまり、ECHが拒否またはバイパスされます）：ServerHello.Randomの最後の8バイトが確認信号と一致する場合、クライアントは誤って受け入れを想定し、バックエンドサーバーが終了したかのように進行します接続。ただし、特定の接続で誤検出が発生する確率は、2^64に1つしかありません。この値は、実際のネットワーク接続障害の確率よりも小さくなっています。"
    },
    {
      "indent": 3,
      "text": "Note that the same bytes of the ServerHello.random are used to implement downgrade protection for TLS 1.3 (see [RFC8446], Section 4.1.3). These mechanisms do not interfere because the backend server only signals ECH acceptance in TLS 1.3 or higher.",
      "ja": "ServerHello.Randomの同じバイトがTLS 1.3のダウングレード保護を実装するために使用されることに注意してください（[RFC8446]、セクション4.1.3を参照）。これらのメカニズムは、バックエンドサーバーのみがTLS 1.3以降でechの受け入れを指示するため、干渉しません。"
    },
    {
      "indent": 0,
      "text": "10.9. Comparison Against Criteria",
      "section_title": true,
      "ja": "10.9. 基準に対する比較"
    },
    {
      "indent": 3,
      "text": "[RFC8744] lists several requirements for SNI encryption. In this section, we re-iterate these requirements and assess the ECH design against them.",
      "ja": "[RFC8744]は、SNI暗号化のいくつかの要件をリストしています。このセクションでは、これらの要件を繰り返し、それらに対するECH設計を評価します。"
    },
    {
      "indent": 0,
      "text": "10.9.1. Mitigate Cut-and-Paste Attacks",
      "section_title": true,
      "ja": "10.9.1. カットアンドペースト攻撃を緩和します"
    },
    {
      "indent": 3,
      "text": "Since servers process either ClientHelloInner or ClientHelloOuter, and because ClientHelloInner.random is encrypted, it is not possible for an attacker to \"cut and paste\" the ECH value in a different Client Hello and learn information from ClientHelloInner.",
      "ja": "サーバーはClientHelloinnerまたはclienthelloouterを処理し、ClientHelloinner.randomが暗号化されているため、攻撃者が別のクライアントのhelloのech値を「カットして貼り付ける」ことはできません。"
    },
    {
      "indent": 0,
      "text": "10.9.2. Avoid Widely Shared Secrets",
      "section_title": true,
      "ja": "10.9.2. 広く共有された秘密を避けてください"
    },
    {
      "indent": 3,
      "text": "This design depends upon DNS as a vehicle for semi-static public key distribution. Server operators may partition their private keys however they see fit provided each server behind an IP address has the corresponding private key to decrypt a key. Thus, when one ECH key is provided, sharing is optimally bound by the number of hosts that share an IP address. Server operators may further limit sharing by publishing different DNS records containing ECHConfig values with different keys using a short TTL.",
      "ja": "この設計は、半静的な公開鍵分布の手段としてのDNSに依存しています。サーバーオペレーターは、IPアドレスの背後にある各サーバーがキーを復号化するための対応するプライベートキーを備えている場合、自分のプライベートキーをパーティション化する場合があります。したがって、1つのECHキーが提供されると、共有はIPアドレスを共有するホストの数に最適に結合されます。サーバーオペレーターは、短いTTLを使用して異なるキーを持つECHCONFIG値を含むさまざまなDNSレコードを公開することにより、さらに共有を制限する場合があります。"
    },
    {
      "indent": 0,
      "text": "10.9.3. Prevent SNI-Based Denial-of-Service Attacks",
      "section_title": true,
      "ja": "10.9.3. SNIベースのサービス拒否攻撃を防ぎます"
    },
    {
      "indent": 3,
      "text": "This design requires servers to decrypt ClientHello messages with ECHClientHello extensions carrying valid digests. Thus, it is possible for an attacker to force decryption operations on the server. This attack is bound by the number of valid TCP connections an attacker can open.",
      "ja": "この設計では、有効なダイジェストを運ぶeChclientHello拡張機能を使用して、サーバーをclienthelloメッセージを復号化する必要があります。したがって、攻撃者がサーバー上の復号化操作を強制することができます。この攻撃は、攻撃者が開くことができる有効なTCP接続の数に拘束されます。"
    },
    {
      "indent": 0,
      "text": "10.9.4. Do Not Stick Out",
      "section_title": true,
      "ja": "10.9.4. 突き出さないでください"
    },
    {
      "indent": 3,
      "text": "As a means of reducing the impact of network ossification, [RFC8744] recommends SNI-protection mechanisms be designed in such a way that network operators do not differentiate connections using the mechanism from connections not using the mechanism. To that end, ECH is designed to resemble a standard TLS handshake as much as possible. The most obvious difference is the extension itself: as long as middleboxes ignore it, as required by [RFC8446], the rest of the handshake is designed to look very much as usual.",
      "ja": "ネットワークの骨化の影響を減らす手段として、[RFC8744]は、ネットワークオペレーターがメカニズムを使用しない接続とメカニズムを使用して接続を区別しないように設計されることを推奨しています。そのために、ECHは標準のTLSハンドシェイクに可能な限り似ているように設計されています。最も明らかな違いは拡張自体です。[RFC8446]で要求されるように、ミドルボックスがそれを無視する限り、残りの握手は通常どおりに見えるように設計されています。"
    },
    {
      "indent": 3,
      "text": "The GREASE ECH protocol described in Section 6.2 provides a low-risk way to evaluate the deployability of ECH. It is designed to mimic the real ECH protocol (Section 6.1) without changing the security properties of the handshake. The underlying theory is that if GREASE ECH is deployable without triggering middlebox misbehavior, and real ECH looks enough like GREASE ECH, then ECH should be deployable as well. Thus, our strategy for mitigating network ossification is to deploy GREASE ECH widely enough to disincentivize differential treatment of the real ECH protocol by the network.",
      "ja": "セクション6.2で説明したグリースECHプロトコルは、ECHの展開性を評価するための低リスクの方法を提供します。ハンドシェイクのセキュリティプロパティを変更せずに、実際のECHプロトコル（セクション6.1）を模倣するように設計されています。根本的な理論は、グリースエックがミドルボックスの不正行為をトリガーせずに展開できる場合、実際のeCHがグリースECHのように十分に見える場合、ECHも展開できる必要があるということです。したがって、ネットワークの骨化を緩和するための戦略は、ネットワークによる実際のECHプロトコルの微分処理を除去するのに十分なほどグリースECHを展開することです。"
    },
    {
      "indent": 3,
      "text": "Ensuring that networks do not differentiate between real ECH and GREASE ECH may not be feasible for all implementations. While most middleboxes will not treat them differently, some operators may wish to block real ECH usage but allow GREASE ECH. This specification aims to provide a baseline security level that most deployments can achieve easily, while providing implementations enough flexibility to achieve stronger security where possible. Minimally, real ECH is designed to be indifferentiable from GREASE ECH for passive adversaries with following capabilities:",
      "ja": "ネットワークが実際のECHとグリースECHを区別しないようにすることは、すべての実装では実行不可能な場合があります。ほとんどのミドルボックスはそれらを異なって扱いませんが、一部のオペレーターは実際のECH使用量をブロックしたいが、グリースエックを許可する場合があります。この仕様の目的は、ほとんどの展開が簡単に達成できるベースラインセキュリティレベルを提供することを目的としていますが、可能な限りより強力なセキュリティを実現するのに十分な柔軟性を実装することを目的としています。最終的には、実際のECHは、次の能力を持つ受動的な敵のグリースECHから無関心になるように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The attacker does not know the ECHConfigList used by the server.",
      "ja": "1. 攻撃者は、サーバーで使用されているeChConfiglistを知りません。"
    },
    {
      "indent": 3,
      "text": "2. The attacker keeps per-connection state only. In particular, it does not track endpoints across connections.",
      "ja": "2. 攻撃者は、接続ごとの状態のみを保持します。特に、接続全体でエンドポイントを追跡しません。"
    },
    {
      "indent": 3,
      "text": "3. ECH and GREASE ECH are designed so that the following features do not vary: the code points of extensions negotiated in the clear; the length of messages; and the values of plaintext alert messages.",
      "ja": "3. ECHとグリースECHは、次の機能が変化しないように設計されています。メッセージの長さ;プレーンテキストアラートメッセージの値。"
    },
    {
      "indent": 3,
      "text": "This leaves a variety of practical differentiators out-of-scope. including, though not limited to, the following:",
      "ja": "これにより、さまざまな実用的な差別化要因がスコープ外になります。以下に限定されませんが、以下を含めます。"
    },
    {
      "indent": 3,
      "text": "1. the value of the configuration identifier;",
      "ja": "1. 構成識別子の値。"
    },
    {
      "indent": 3,
      "text": "2. the value of the outer SNI;",
      "ja": "2. 外側のSNIの値。"
    },
    {
      "indent": 3,
      "text": "3. the TLS version negotiated, which may depend on ECH acceptance;",
      "ja": "3. TLSバージョンは交渉されましたが、これはECHの受け入れに依存する可能性があります。"
    },
    {
      "indent": 3,
      "text": "4. client authentication, which may depend on ECH acceptance; and",
      "ja": "4. クライアント認証。これは、ECHの受け入れに依存する可能性があります。と"
    },
    {
      "indent": 3,
      "text": "5. HRR issuance, which may depend on ECH acceptance.",
      "ja": "5. HRR発行。これは、ECHの受け入れに依存する可能性があります。"
    },
    {
      "indent": 3,
      "text": "These can be addressed with more sophisticated implementations, but some mitigations require coordination between the client and server. These mitigations are out-of-scope for this specification.",
      "ja": "これらは、より洗練された実装で対処できますが、一部の緩和はクライアントとサーバー間の調整が必要です。これらの緩和は、この仕様のスコープ外です。"
    },
    {
      "indent": 0,
      "text": "10.9.5. Maintain Forward Secrecy",
      "section_title": true,
      "ja": "10.9.5. 秘密を維持します"
    },
    {
      "indent": 3,
      "text": "This design is not forward secret because the server's ECH key is static. However, the window of exposure is bound by the key lifetime. It is RECOMMENDED that servers rotate keys frequently.",
      "ja": "サーバーのECHキーは静的であるため、この設計は前向きな秘密ではありません。ただし、露出の窓は重要な寿命に縛られています。サーバーは頻繁にキーを回転させることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "10.9.6. Enable Multi-party Security Contexts",
      "section_title": true,
      "ja": "10.9.6. マルチパーティセキュリティコンテキストを有効にします"
    },
    {
      "indent": 3,
      "text": "This design permits servers operating in Split Mode to forward connections directly to backend origin servers. The client authenticates the identity of the backend origin server, thereby avoiding unnecessary MiTM attacks.",
      "ja": "この設計では、スプリットモードで動作するサーバーを使用して、接続を直接バックエンドオリジンサーバーに転送できます。クライアントは、バックエンドOrigin ServerのIDを認証するため、不要なMITM攻撃を回避します。"
    },
    {
      "indent": 3,
      "text": "Conversely, assuming ECH records retrieved from DNS are authenticated, e.g., via DNSSEC or fetched from a trusted Recursive Resolver, spoofing a client-facing server operating in Split Mode is not possible. See Section 10.2 for more details regarding plaintext DNS.",
      "ja": "逆に、DNSから取得されたECHレコードが認証されていると仮定します。たとえば、DNSSECを介して、または信頼できる再帰リゾルバーから取得され、スプリットモードで動作するクライアント向けサーバーをスプーフィングすることは不可能です。プレーンテキストDNSに関する詳細については、セクション10.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Authenticating the ECHConfig structure naturally authenticates the included public name. This also authenticates any retry signals from the client-facing server because the client validates the server certificate against the public name before retrying.",
      "ja": "eChconfig構造を認証することは、含まれている公開名を自然に認証します。また、クライアントが再試行する前にパブリック名に対してサーバー証明書を検証するため、クライアント向けサーバーからの再試行信号も認証されます。"
    },
    {
      "indent": 0,
      "text": "10.9.7. Support Multiple Protocols",
      "section_title": true,
      "ja": "10.9.7. 複数のプロトコルをサポートします"
    },
    {
      "indent": 3,
      "text": "This design has no impact on application layer protocol negotiation. It may affect connection routing, server certificate selection, and client certificate verification. Thus, it is compatible with multiple application and transport protocols. By encrypting the entire ClientHello, this design additionally supports encrypting the ALPN extension.",
      "ja": "この設計は、アプリケーション層プロトコルの交渉に影響を与えません。接続ルーティング、サーバー証明書の選択、およびクライアント証明書の確認に影響を与える可能性があります。したがって、複数のアプリケーションおよび輸送プロトコルと互換性があります。ClientHello全体を暗号化することにより、このデザインはALPN拡張機能の暗号化をさらにサポートします。"
    },
    {
      "indent": 0,
      "text": "10.10. Padding Policy",
      "section_title": true,
      "ja": "10.10. パディングポリシー"
    },
    {
      "indent": 3,
      "text": "Variations in the length of the ClientHelloInner ciphertext could leak information about the corresponding plaintext. Section 6.1.3 describes a RECOMMENDED padding mechanism for clients aimed at reducing potential information leakage.",
      "ja": "clienthelloinner暗号の長さのバリエーションは、対応するプレーンテキストに関する情報を漏らす可能性があります。セクション6.1.3では、潜在的な情報漏れを減らすことを目的としたクライアントに推奨されるパディングメカニズムについて説明します。"
    },
    {
      "indent": 0,
      "text": "10.11. Active Attack Mitigations",
      "section_title": true,
      "ja": "10.11. アクティブな攻撃緩和"
    },
    {
      "indent": 3,
      "text": "This section describes the rationale for ECH properties and mechanics as defenses against active attacks. In all the attacks below, the attacker is on-path between the target client and server. The goal of the attacker is to learn private information about the inner ClientHello, such as the true SNI value.",
      "ja": "このセクションでは、積極的な攻撃に対する防御としてのECHプロパティとメカニズムの理論的根拠について説明します。以下のすべての攻撃で、攻撃者はターゲットクライアントとサーバーの間のパス上にあります。攻撃者の目標は、真のSNI値など、内側のクライアントヘロに関する個人情報を学ぶことです。"
    },
    {
      "indent": 0,
      "text": "10.11.1. Client Reaction Attack Mitigation",
      "section_title": true,
      "ja": "10.11.1. クライアント反応攻撃緩和"
    },
    {
      "indent": 3,
      "text": "This attack uses the client's reaction to an incorrect certificate as an oracle. The attacker intercepts a legitimate ClientHello and replies with a ServerHello, Certificate, CertificateVerify, and Finished messages, wherein the Certificate message contains a \"test\" certificate for the domain name it wishes to query. If the client decrypted the Certificate and failed verification (or leaked information about its verification process by a timing side channel), the attacker learns that its test certificate name was incorrect. As an example, suppose the client's SNI value in its inner ClientHello is \"example.com,\" and the attacker replied with a Certificate for \"test.com\". If the client produces a verification failure alert because of the mismatch faster than it would due to the Certificate signature validation, information about the name leaks. Note that the attacker can also withhold the CertificateVerify message. In that scenario, a client which first verifies the Certificate would then respond similarly and leak the same information.",
      "ja": "この攻撃は、クライアントの反応を使用して、誤った証明書をOracleとして使用します。攻撃者は正当なClientHelloを傍受し、ServerHello、証明書、CertificateVerify、および完成したメッセージで返信します。これには、証明書メッセージには、クエリを希望するドメイン名の「テスト」証明書が含まれています。クライアントが証明書を復号化し、検証に失敗した場合（またはタイミングサイドチャネルによる検証プロセスに関する情報が漏れた）、攻撃者はそのテスト証明書名が正しくないことを知ります。例として、クライアントの内側のclienthelloのクライアントのSNI値が「Example.com」であると仮定し、攻撃者は「test.com」の証明書で返信しました。クライアントが、証明書の署名検証のために不一致が速くなるため、不一致のために検証障害アラートを生成した場合、名前の漏れに関する情報。攻撃者は、cimporationverifyメッセージを差し控えることもできることに注意してください。そのシナリオでは、最初に証明書を検証するクライアントが同様に応答し、同じ情報をリークします。"
    },
    {
      "indent": 4,
      "text": "Client                         Attacker               Server\n  ClientHello\n  + key_share\n  + ech         ------>      (intercept)     -----> X (drop)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "                          ServerHello\n                          + key_share\n                {EncryptedExtensions}\n                {CertificateRequest*}\n                       {Certificate*}\n                 {CertificateVerify*}\n              <------\nAlert\n              ------>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 3: Client reaction attack",
      "ja": "図3：クライアント反応攻撃"
    },
    {
      "indent": 3,
      "text": "ClientHelloInner.random prevents this attack. In particular, since the attacker does not have access to this value, it cannot produce the right transcript and handshake keys needed for encrypting the Certificate message. Thus, the client will fail to decrypt the Certificate and abort the connection.",
      "ja": "clienthelloinner.randomはこの攻撃を防ぎます。特に、攻撃者はこの値にアクセスできないため、証明書メッセージの暗号化に必要な適切なトランスクリプトと握手キーを作成することはできません。したがって、クライアントは証明書を復号化して接続を中止しません。"
    },
    {
      "indent": 0,
      "text": "10.11.2. HelloRetryRequest Hijack Mitigation",
      "section_title": true,
      "ja": "10.11.2. HelloretryRequestハイジャック緩和"
    },
    {
      "indent": 3,
      "text": "This attack aims to exploit server HRR state management to recover information about a legitimate ClientHello using its own attacker-controlled ClientHello. To begin, the attacker intercepts and forwards a legitimate ClientHello with an \"encrypted_client_hello\" (ech) extension to the server, which triggers a legitimate HelloRetryRequest in return. Rather than forward the retry to the client, the attacker attempts to generate its own ClientHello in response based on the contents of the first ClientHello and HelloRetryRequest exchange with the result that the server encrypts the Certificate to the attacker. If the server used the SNI from the first ClientHello and the key share from the second (attacker-controlled) ClientHello, the Certificate produced would leak the client's chosen SNI to the attacker.",
      "ja": "この攻撃の目的は、サーバーHRR状態管理を活用して、独自の攻撃者制御されたClientHelloを使用して正当なClientHelloに関する情報を回復することを目的としています。まず、攻撃者は正当なclienthelloを傍受して転送し、サーバーへの「encrypted_client_hello」（ECH）拡張機能を備えており、見返りに正当なHelloretryRequestをトリガーします。攻撃者は、クライアントに再試行を転送するのではなく、最初のClientHelloとHelloretryRequest Exchangeの内容に応じて独自のClientHelloを生成しようとします。サーバーが最初のClientHelloからSNIを使用し、2番目の（攻撃者制御）clienthelloのキー共有を使用した場合、作成された証明書はクライアントの選択したSNIを攻撃者に漏らします。"
    },
    {
      "indent": 4,
      "text": "Client                         Attacker                   Server\n  ClientHello\n  + key_share\n  + ech         ------>       (forward)        ------->\n                                             HelloRetryRequest\n                                                   + key_share\n                             (intercept)       <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "     ClientHello\n     + key_share'\n     + ech'           ------->\n                           ServerHello\n                           + key_share\n                 {EncryptedExtensions}\n                 {CertificateRequest*}\n                        {Certificate*}\n                  {CertificateVerify*}\n                            {Finished}\n                       <-------\n(process server flight)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 4: HelloRetryRequest hijack attack",
      "ja": "図4：HelloretryRequestハイジャック攻撃"
    },
    {
      "indent": 3,
      "text": "This attack is mitigated by using the same HPKE context for both ClientHello messages. The attacker does not possess the context's keys, so it cannot generate a valid encryption of the second inner ClientHello.",
      "ja": "この攻撃は、両方のClientHelloメッセージに対して同じHPKEコンテキストを使用することにより緩和されます。攻撃者はコンテキストのキーを所有していないため、2番目の内側クライアントヘロの有効な暗号化を生成することはできません。"
    },
    {
      "indent": 3,
      "text": "If the attacker could manipulate the second ClientHello, it might be possible for the server to act as an oracle if it required parameters from the first ClientHello to match that of the second ClientHello. For example, imagine the client's original SNI value in the inner",
      "ja": "攻撃者が2番目のClientHelloを操作できる場合、最初のClientHelloのパラメーターが2番目のClientHelloのパラメーターを必要とする場合、サーバーがOracleとして機能する可能性があります。たとえば、内側のクライアントの元のSNI値を想像してください"
    },
    {
      "indent": 3,
      "text": "ClientHello is \"example.com\", and the attacker's hijacked SNI value in its inner ClientHello is \"test.com\". A server which checks these for equality and changes behavior based on the result can be used as an oracle to learn the client's SNI.",
      "ja": "clienthelloは「Example.com」であり、攻撃者の内側のclienthelloのハイジャックされたSNI値は「test.com」です。これらを等間性をチェックし、結果に基づいて動作を変更するサーバーは、クライアントのSNIを学習するためにOracleとして使用できます。"
    },
    {
      "indent": 0,
      "text": "10.11.3. ClientHello Malleability Mitigation",
      "section_title": true,
      "ja": "10.11.3. ClientHello Malleability Mitigation"
    },
    {
      "indent": 3,
      "text": "This attack aims to leak information about secret parts of the encrypted ClientHello by adding attacker-controlled parameters and observing the server's response. In particular, the compression mechanism described in Section 5.1 references parts of a potentially attacker-controlled ClientHelloOuter to construct ClientHelloInner, or a buggy server may incorrectly apply parameters from ClientHelloOuter to the handshake.",
      "ja": "この攻撃の目的は、攻撃者が制御するパラメーターを追加し、サーバーの応答を観察することにより、暗号化されたClienthelloの秘密部分に関する情報をリークすることです。特に、セクション5.1で説明されている圧縮メカニズムは、攻撃者が制御する可能性のあるクライアントヘロウターの一部を参照して、クライアントヘロインナーを構築するか、バギーサーバーがクライアントヘロウターからハンドシェイクにパラメーターを誤って適用する場合があります。"
    },
    {
      "indent": 3,
      "text": "To begin, the attacker first interacts with a server to obtain a resumption ticket for a given test domain, such as \"example.com\". Later, upon receipt of a ClientHelloOuter, it modifies it such that the server will process the resumption ticket with ClientHelloInner. If the server only accepts resumption PSKs that match the server name, it will fail the PSK binder check with an alert when ClientHelloInner is for \"example.com\" but silently ignore the PSK and continue when ClientHelloInner is for any other name. This introduces an oracle for testing encrypted SNI values.",
      "ja": "まず、攻撃者は最初にサーバーと対話して、「Example.com」などの特定のテストドメインの再開チケットを取得します。その後、ClientHelloouterを受信すると、サーバーがClientHelloinnerで再開チケットを処理できるように変更されます。サーバーがサーバー名に一致する再開PSKのみを受け入れる場合、clienthelloinnerが「example.com」の場合、PSKバインダーチェックがアラートで失敗しますが、PSKを静かに無視し、ClientHelloinnerが他の名前を使用している場合は続行します。これにより、暗号化されたSNI値をテストするためのOracleが導入されます。"
    },
    {
      "indent": 9,
      "text": "Client Attacker Server",
      "ja": "クライアント攻撃者サーバー"
    },
    {
      "indent": 39,
      "text": "handshake and ticket\n   for \"example.com\"\n   <-------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "ClientHello\n+ key_share\n+ ech\n+ ech_outer_extensions(pre_shared_key)\n+ pre_shared_key\n            -------->\n                  (intercept)\n                  ClientHello\n                  + key_share\n                  + ech\n                     + ech_outer_extensions(pre_shared_key)\n                  + pre_shared_key'\n                                    -------->\n                                                   Alert\n                                                   -or-\n                                             ServerHello\n                                                      ...\n                                                Finished\n                                    <--------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Figure 5: Message flow for malleable ClientHello",
      "ja": "図5：順応性のあるClientHelloのメッセージフロー"
    },
    {
      "indent": 3,
      "text": "This attack may be generalized to any parameter which the server varies by server name, such as ALPN preferences.",
      "ja": "この攻撃は、ALPN設定など、サーバー名によって変化する任意のパラメーターに一般化される場合があります。"
    },
    {
      "indent": 3,
      "text": "ECH mitigates this attack by only negotiating TLS parameters from ClientHelloInner and authenticating all inputs to the ClientHelloInner (EncodedClientHelloInner and ClientHelloOuter) with the HPKE AEAD. See Section 5.2. An earlier iteration of this specification only encrypted and authenticated the \"server_name\" extension, which left the overall ClientHello vulnerable to an analogue of this attack.",
      "ja": "ECHは、ClientHelloinnerからTLSパラメーターを交渉し、すべての入力をClientHelloinner（EncodedClientHelloinnerおよびClientHelloouter）にHPKE AEADと認証することにより、この攻撃を軽減します。セクション5.2を参照してください。この仕様の以前の反復は、「server_name」拡張機能を暗号化および認証しただけで、全体的なclienthelloをこの攻撃のアナログに対して脆弱にしました。"
    },
    {
      "indent": 0,
      "text": "10.11.4. ClientHelloInner Packet Amplification Mitigation",
      "section_title": true,
      "ja": "10.11.4. clienthelloinnerパケット増幅軽減"
    },
    {
      "indent": 3,
      "text": "Client-facing servers must decompress EncodedClientHelloInners. A malicious attacker may craft a packet which takes excessive resources to decompress or may be much larger than the incoming packet:",
      "ja": "クライアント向けサーバーは、EncodedClientHelloInnersを減圧する必要があります。悪意のある攻撃者は、過度のリソースを削除するために過度のリソースを必要とするパケットを作成したり、着信パケットよりもはるかに大きい場合があります。"
    },
    {
      "indent": 3,
      "text": "* If looking up a ClientHelloOuter extension takes time linear in the number of extensions, the overall decoding process would take O(M*N) time, where M is the number of extensions in ClientHelloOuter and N is the size of OuterExtensions.",
      "ja": "* clienthelloouterの拡張機能を検索すると、拡張機能の数が時間がかかる場合、全体的なデコードプロセスにはO（m*n）時間がかかります。ここで、mはクライアントヘロウターの拡張数、nはoutourestensionsのサイズです。"
    },
    {
      "indent": 3,
      "text": "* If the same ClientHelloOuter extension can be copied multiple times, an attacker could cause the client-facing server to construct a large ClientHelloInner by including a large extension in ClientHelloOuter, of length L, and an OuterExtensions list referencing N copies of that extension. The client-facing server would then use O(N*L) memory in response to O(N+L) bandwidth from the client. In split-mode, an O(N*L) sized packet would then be transmitted to the backend server.",
      "ja": "* 同じClientHelloouter拡張機能を複数回コピーできる場合、攻撃者は、クライアントハロウター、Length Lの大規模な拡張機能、およびその拡張機能のNコピーを参照するOuterExtensionsリストを含めることにより、クライアント向けサーバーに大きなクライアントヘロインナーを構築する可能性があります。クライアント向けサーバーは、クライアントからのO（n L）帯域幅に応じてO（n*l）メモリを使用します。スプリットモードでは、O（n*l）サイズのパケットがバックエンドサーバーに送信されます。"
    },
    {
      "indent": 3,
      "text": "ECH mitigates this attack by requiring that OuterExtensions be referenced in order, that duplicate references be rejected, and by recommending that client-facing servers use a linear scan to perform decompression. These requirements are detailed in Section 5.1.",
      "ja": "ECHは、この攻撃を、OuterExtensionを順番に参照すること、重複する参照を拒否し、クライアント向けサーバーが線形スキャンを使用して減圧を実行することを推奨することを要求することにより、この攻撃を軽減します。これらの要件については、セクション5.1で詳しく説明しています。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "11.1. Update of the TLS ExtensionType Registry",
      "section_title": true,
      "ja": "11.1. TLS ExtensionTypeレジストリの更新"
    },
    {
      "indent": 3,
      "text": "IANA is requested to create the following entries in the existing registry for ExtensionType (defined in [RFC8446]):",
      "ja": "IANAは、extensionTypeの既存のレジストリ（[RFC8446]で定義）に次のエントリを作成するように要求されています。"
    },
    {
      "indent": 3,
      "text": "1. encrypted_client_hello(0xfe0d), with \"TLS 1.3\" column values set to \"CH, HRR, EE\", and \"Recommended\" column set to \"Yes\".",
      "ja": "1. 「TLS 1.3」の列値が「CH、HRR、EE」に設定され、「はい」に設定された「推奨」列を備えた、ecrypted_Client_Hello（0xfe0d）。"
    },
    {
      "indent": 3,
      "text": "2. ech_outer_extensions(0xfd00), with the \"TLS 1.3\" column values set to \"\", and \"Recommended\" column set to \"Yes\".",
      "ja": "2. ech_outer_extensions（0xfd00）、「tls 1.3」列値が「 \"に設定され、「はい」に設定された「推奨」列が設定されています。"
    },
    {
      "indent": 0,
      "text": "11.2. Update of the TLS Alert Registry",
      "section_title": true,
      "ja": "11.2. TLSアラートレジストリの更新"
    },
    {
      "indent": 3,
      "text": "IANA is requested to create an entry, ech_required(121) in the existing registry for Alerts (defined in [RFC8446]), with the \"DTLS-OK\" column set to \"Y\".",
      "ja": "IANAは、「dtls-ok」列が「y」に設定された「dtls-ok」列を使用して、アラートの既存のレジストリ（[rfc8446]で定義）の既存のレジストリにech_required（121）を作成するように要求されます。"
    },
    {
      "indent": 0,
      "text": "12. ECHConfig Extension Guidance",
      "section_title": true,
      "ja": "12. Echconfig拡張ガイダンス"
    },
    {
      "indent": 3,
      "text": "Any future information or hints that influence ClientHelloOuter SHOULD be specified as ECHConfig extensions. This is primarily because the outer ClientHello exists only in support of ECH. Namely, it is both an envelope for the encrypted inner ClientHello and enabler for authenticated key mismatch signals (see Section 7). In contrast, the inner ClientHello is the true ClientHello used upon ECH negotiation.",
      "ja": "clienthelloouterに影響を与える将来の情報またはヒントは、eChconfig拡張機能として指定する必要があります。これは主に、外側のクライアントヘロがECHをサポートするためにのみ存在するためです。つまり、それは暗号化された内側のクライアントヘロの封筒と、認証されたキーミスマッチ信号のイネーブラーの両方です（セクション7を参照）。対照的に、内側のClientHelloは、ECH交渉時に使用される真のClientHelloです。"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13. 参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[HTTPS-RR] Schwartz, B., Bishop, M., and E. Nygren, \"Service binding and parameter specification via the DNS (DNS SVCB and HTTPS RRs)\", Work in Progress, Internet-Draft, draft-ietf-dnsop-svcb-https-08, 12 October 2021, <https://www.ietf.org/archive/id/draft-ietf-dnsop-svcb-https-08.txt>.",
      "ja": "[HTTPS-RR] Schwartz、B.、Bishop、M。、およびE. Nygren、「DNS（DNS SVCBおよびHTTPS RRS）を介したサービス拘束力とパラメーター仕様」、作業中の作業、インターネットドラフト、ドラフト-ITF-dnsop-svcb-https-08、2021年10月12日、<https://www.ietf.org/archive/id/draft-ietf-dnsop-svcb-https-08.txt>。"
    },
    {
      "indent": 3,
      "text": "[I-D.ietf-tls-exported-authenticator] Sullivan, N., \"Exported Authenticators in TLS\", Work in Progress, Internet-Draft, draft-ietf-tls-exported-authenticator-14, 25 January 2021, <https://www.ietf.org/archive/id/draft-ietf-tls-exported-authenticator-14.txt>.",
      "ja": "[i-d.ietf-tls-exported-authenticator] Sullivan、N。、「TLSでのエクスポートされた認証者」、進行中の作業、インターネットドラフト、ドラフト-ITF-TLS-exported-authenticator-14、25年1月25日、<https：//www.ietf.org/ archive/id/draft-ietf-tls-exported-authenticator-14.txt>。"
    },
    {
      "indent": 3,
      "text": "[I-D.irtf-cfrg-hpke] Barnes, R. L., Bhargavan, K., Lipp, B., and C. A. Wood, \"Hybrid Public Key Encryption\", Work in Progress, Internet-Draft, draft-irtf-cfrg-hpke-12, 2 September 2021, <https://www.ietf.org/archive/id/draft-irtf-cfrg-hpke-12.txt>.",
      "ja": "[i-d.irtf-cfrg-hpke] Barnes、R。L.、Bhargavan、K.、Lipp、B。、およびC. A. Wood、「ハイブリッド公開キー暗号化」、進行中の作業、インターネットドラフト、Draft-ARTF-CFRG-HPKE-12、2021年9月2日、<https://www.ietf.org/ archive/id/draft-irtf-cfrg-hpke-12.txt>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5890] Klensin, J., \"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework\", RFC 5890, DOI 10.17487/RFC5890, August 2010, <https://www.rfc-editor.org/info/rfc5890>.",
      "ja": "[RFC5890] Klensin、J。、「アプリケーションの国際化ドメイン名（IDNA）：定義とドキュメントフレームワーク」、RFC 5890、DOI 10.17487/RFC5890、2010年8月、<https://www.rfc-editor.org/info/RFC5890>。"
    },
    {
      "indent": 3,
      "text": "[RFC7918] Langley, A., Modadugu, N., and B. Moeller, \"Transport Layer Security (TLS) False Start\", RFC 7918, DOI 10.17487/RFC7918, August 2016, <https://www.rfc-editor.org/info/rfc7918>.",
      "ja": "[RFC7918] Langley、A.、Modadugu、N.、およびB. Moeller、「Transport Layer Security（TLS）False Start」、RFC 7918、DOI 10.17487/RFC7918、2016年8月、<https：//www.rfc-editor.org/info/rfc7918>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc846>"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[I-D.kazuho-protected-sni] Oku, K., \"TLS Extensions for Protecting SNI\", Work in Progress, Internet-Draft, draft-kazuho-protected-sni-00, 18 July 2017, <https://www.ietf.org/archive/id/draft-kazuho-protected-sni-00.txt>.",
      "ja": "[i-d.kazuho保護-Sni] oku、K。、「SNIを保護するためのTLS拡張機能」、進行中の作業、インターネットドラフト、ドラフトカズホ保護-SNI-00、2017年7月18日、<https：// wwww.ietf.org/archive/id/draft-kazuho-protected-sni-00.txt>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、Std 66、RFC 3986、DOI 10.17487/RFC3986、2005年1月、<https：//www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC5077] Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, \"Transport Layer Security (TLS) Session Resumption without Server-Side State\", RFC 5077, DOI 10.17487/RFC5077, January 2008, <https://www.rfc-editor.org/info/rfc5077>.",
      "ja": "[RFC5077] Salowey、J.、Zhou、H.、Eronen、P。、およびH. Tschofenig、「サーバー側の状態なしの輸送層セキュリティ（TLS）セッション再開」、RFC 5077、DOI 10.17487/RFC5077、2008年1月<https://www.rfc-editor.org/info/rfc5077>。"
    },
    {
      "indent": 3,
      "text": "[RFC7301] Friedl, S., Popov, A., Langley, A., and E. Stephan, \"Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension\", RFC 7301, DOI 10.17487/RFC7301, July 2014, <https://www.rfc-editor.org/info/rfc7301>.",
      "ja": "[RFC7301] Friedl、S.、Popov、A.、Langley、A。、およびE. Stephan、「輸送層セキュリティ（TLS）アプリケーション層プロトコル交渉拡張」、RFC 7301、DOI 10.17487/RFC7301、2014年7月、<https://www.rfc-editor.org/info/rfc7301>。"
    },
    {
      "indent": 3,
      "text": "[RFC7858] Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D., and P. Hoffman, \"Specification for DNS over Transport Layer Security (TLS)\", RFC 7858, DOI 10.17487/RFC7858, May 2016, <https://www.rfc-editor.org/info/rfc7858>.",
      "ja": "[RFC7858] Hu、Z.、Zhu、L.、Heidemann、J.、Mankin、A.、Wessels、D。、およびP. Hoffman、「輸送層のセキュリティ上のDNSの仕様」、RFC 7858、doi10.17487/rfc7858、2016年5月、<https://www.rfc-editor.org/info/rfc7858>。"
    },
    {
      "indent": 3,
      "text": "[RFC7924] Santesson, S. and H. Tschofenig, \"Transport Layer Security (TLS) Cached Information Extension\", RFC 7924, DOI 10.17487/RFC7924, July 2016, <https://www.rfc-editor.org/info/rfc7924>.",
      "ja": "[RFC7924] Santesson、S。およびH. Tschofenig、「輸送層のセキュリティ（TLS）キャッシュ情報拡張」、RFC 7924、DOI 10.17487/RFC7924、2016年7月、<https：//www.rfc-editor.org/info/RFC7924>。"
    },
    {
      "indent": 3,
      "text": "[RFC8094] Reddy, T., Wing, D., and P. Patil, \"DNS over Datagram Transport Layer Security (DTLS)\", RFC 8094, DOI 10.17487/RFC8094, February 2017, <https://www.rfc-editor.org/info/rfc8094>.",
      "ja": "[RFC8094] Reddy、T.、Wing、D。、およびP. Patil、「DNS over Datagram Transport Layer Security（DTLS）」、RFC 8094、DOI 10.17487/RFC8094、2017年2月、<https：//www.rfc-editor.org/info/rfc8094>。"
    },
    {
      "indent": 3,
      "text": "[RFC8484] Hoffman, P. and P. McManus, \"DNS Queries over HTTPS (DoH)\", RFC 8484, DOI 10.17487/RFC8484, October 2018, <https://www.rfc-editor.org/info/rfc8484>.",
      "ja": "[RFC8484] Hoffman、P。and P. McManus、「dns queries over https（doh）（doh）（doh）」、RFC 8484、doi 10.17487/rfc8484、2018年10月、<https://www.rfc-editor.org/info/rfc8484>。"
    },
    {
      "indent": 3,
      "text": "[RFC8701] Benjamin, D., \"Applying Generate Random Extensions And Sustain Extensibility (GREASE) to TLS Extensibility\", RFC 8701, DOI 10.17487/RFC8701, January 2020, <https://www.rfc-editor.org/info/rfc8701>.",
      "ja": "[RFC8701]ベンジャミン、D。、「ランダム拡張を生成し、TLS拡張性（グリース）をTLS拡張性に維持する」、RFC 8701、DOI 10.17487/RFC8701、2020年1月、<https：//www.rfc-editor.org/info//RFC8701>。"
    },
    {
      "indent": 3,
      "text": "[RFC8744] Huitema, C., \"Issues and Requirements for Server Name Identification (SNI) Encryption in TLS\", RFC 8744, DOI 10.17487/RFC8744, July 2020, <https://www.rfc-editor.org/info/rfc8744>.",
      "ja": "[RFC8744] Huitema、C。、「TLSのサーバー名識別（SNI）暗号化の問題と要件」、RFC 8744、DOI 10.17487/RFC8744、2020年7月、<https://www.rfc-editor.org/info/RFC8744>。"
    },
    {
      "indent": 3,
      "text": "[WHATWG-IPV4] \"URL Living Standard - IPv4 Parser\", May 2021, <https://url.spec.whatwg.org/#concept-ipv4-parser>.",
      "ja": "[whatwg-ipv4] \"url living Standard-ipv4 parser\"、2021年5月、<https://url.spec.whatwg.org/#concept-ipv4-parser>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Alternative SNI Protection Designs",
      "section_title": true,
      "ja": "付録A.代替SNI保護設計"
    },
    {
      "indent": 3,
      "text": "Alternative approaches to encrypted SNI may be implemented at the TLS or application layer. In this section we describe several alternatives and discuss drawbacks in comparison to the design in this document.",
      "ja": "暗号化されたSNIへの代替アプローチは、TLSまたはアプリケーションレイヤーで実装できます。このセクションでは、いくつかの代替案について説明し、このドキュメントの設計と比較して欠点について説明します。"
    },
    {
      "indent": 0,
      "text": "A.1. TLS-layer",
      "section_title": true,
      "ja": "A.1. TLSレイヤー"
    },
    {
      "indent": 0,
      "text": "A.1.1. TLS in Early Data",
      "section_title": true,
      "ja": "A.1.1. 初期データのTLS"
    },
    {
      "indent": 3,
      "text": "In this variant, TLS Client Hellos are tunneled within early data\npayloads belonging to outer TLS connections established with the\nclient-facing server.  This requires clients to have established a\nprevious session --- and obtained PSKs --- with the server.  The\nclient-facing server decrypts early data payloads to uncover Client\nHellos destined for the backend server, and forwards them onwards as\nnecessary.  Afterwards, all records to and from backend servers are\nforwarded by the client-facing server -- unmodified.  This avoids\ndouble encryption of TLS records.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Problems with this approach are: (1) servers may not always be able to distinguish inner Client Hellos from legitimate application data, (2) nested 0-RTT data may not function correctly, (3) 0-RTT data may not be supported -- especially under DoS -- leading to availability concerns, and (4) clients must bootstrap tunnels (sessions), costing an additional round trip and potentially revealing the SNI during the initial connection. In contrast, encrypted SNI protects the SNI in a distinct Client Hello extension and neither abuses early data nor requires a bootstrapping connection.",
      "ja": "このアプローチの問題は次のとおりです。（1）サーバーは、内部クライアントのHellosを正当なアプリケーションデータと常に区別できるとは限らない場合があります。（2）ネストされた0-RTTデータは正しく機能しない場合があります。 - 特にDOSの下で - 利用可能性の懸念につながり、（4）クライアントはトンネル（セッション）をブートストラップする必要があり、追加の往復のコストがかかり、最初の接続中にSNIを潜在的に明らかにする必要があります。対照的に、暗号化されたSNIは、明確なクライアントのHello ExtensionでSNIを保護し、早期データを乱用したり、ブートストラップ接続を必要としません。"
    },
    {
      "indent": 0,
      "text": "A.1.2. Combined Tickets",
      "section_title": true,
      "ja": "A.1.2. 合計チケット"
    },
    {
      "indent": 3,
      "text": "In this variant, client-facing and backend servers coordinate to produce \"combined tickets\" that are consumable by both. Clients offer combined tickets to client-facing servers. The latter parse them to determine the correct backend server to which the Client Hello should be forwarded. This approach is problematic due to non-trivial coordination between client-facing and backend servers for",
      "ja": "このバリアントでは、クライアント向けサーバーとバックエンドサーバーが調整され、両方が消費できる「結合チケット」を生成します。クライアントは、クライアント向けサーバーに合わせたチケットを提供します。後者はそれらを解析して、クライアントのhelloを転送する必要がある正しいバックエンドサーバーを決定します。このアプローチは、クライアントの向きサーバーとバックエンドサーバーの間の重要な調整のために問題があります"
    },
    {
      "indent": 3,
      "text": "ticket construction and consumption. Moreover, it requires a bootstrapping step similar to that of the previous variant. In contrast, encrypted SNI requires no such coordination.",
      "ja": "チケットの建設と消費。さらに、以前のバリアントと同様のブートストラップステップが必要です。対照的に、暗号化されたSNIはそのような調整を必要としません。"
    },
    {
      "indent": 0,
      "text": "A.2. Application-layer",
      "section_title": true,
      "ja": "A.2. アプリケーション層"
    },
    {
      "indent": 0,
      "text": "A.2.1. HTTP/2 CERTIFICATE Frames",
      "section_title": true,
      "ja": "A.2.1. HTTP/2証明書フレーム"
    },
    {
      "indent": 3,
      "text": "In this variant, clients request secondary certificates with CERTIFICATE_REQUEST HTTP/2 frames after TLS connection completion. In response, servers supply certificates via TLS exported authenticators [I-D.ietf-tls-exported-authenticator] in CERTIFICATE frames. Clients use a generic SNI for the underlying client-facing server TLS connection. Problems with this approach include: (1) one additional round trip before peer authentication, (2) non-trivial application-layer dependencies and interaction, and (3) obtaining the generic SNI to bootstrap the connection. In contrast, encrypted SNI induces no additional round trip and operates below the application layer.",
      "ja": "このバリアントでは、TLS接続の完了後にCertificate_Request HTTP/2フレームを使用して、クライアントがセカンダリ証明書を要求します。これに応じて、サーバーはTLSエクスポートされた認証機[i-d.ietf-tls-exported-authenticator]を介して証明書を介して証明書を供給します。クライアントは、基礎となるクライアント向けサーバーTLS接続に一般的なSNIを使用します。このアプローチの問題には、（1）ピア認証の前の追加の往復、（2）非自明のアプリケーション層依存関係と相互作用、（3）汎用SNIを取得して接続をブートストラップする。対照的に、暗号化されたSNIは追加の往復を誘導せず、アプリケーション層の下に動作します。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Linear-time Outer Extension Processing",
      "section_title": true,
      "ja": "付録B.線形時間外側延長処理"
    },
    {
      "indent": 3,
      "text": "The following procedure processes the \"ech_outer_extensions\" extension (see Section 5.1) in linear time, ensuring that each referenced extension in the ClientHelloOuter is included at most once:",
      "ja": "次の手順では、線形時間に「ech_outer_extensions」拡張（セクション5.1を参照）を処理し、クライアントヘロウターの各参照拡張機能がせいぜい1回含まれるようにします。"
    },
    {
      "indent": 3,
      "text": "1. Let I be zero and N be the number of extensions in ClientHelloOuter.",
      "ja": "1. 私をゼロにし、nをclienthelloouterの拡張機能の数とします。"
    },
    {
      "indent": 3,
      "text": "2. For each extension type, E, in OuterExtensions:",
      "ja": "2. 各拡張タイプ、e、outourextensions："
    },
    {
      "indent": 7,
      "text": "* If E is \"encrypted_client_hello\", abort the connection with an \"illegal_parameter\" alert and terminate this procedure.",
      "ja": "* eが「cnecrypted_client_hello」の場合、「Illegal_parameter」アラートとの接続を中止し、この手順を終了します。"
    },
    {
      "indent": 7,
      "text": "* While I is less than N and the I-th extension of ClientHelloOuter does not have type E, increment I.",
      "ja": "* 私はn未満であり、clienthelloouterのi番目の拡張にはタイプE、インクリメントIがありません。"
    },
    {
      "indent": 7,
      "text": "* If I is equal to N, abort the connection with an \"illegal_parameter\" alert and terminate this procedure.",
      "ja": "* 私がnに等しい場合、「違法_parameter」アラートとの接続を中止し、この手順を終了します。"
    },
    {
      "indent": 7,
      "text": "* Otherwise, the I-th extension of ClientHelloOuter has type E. Copy it to the EncodedClientHelloInner and increment I.",
      "ja": "* それ以外の場合、clienthelloouterのi番目の拡張機能にはタイプEがあります。それをEncodedClientHelloinnerとIncrement Iにコピーします。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Acknowledgements",
      "section_title": true,
      "ja": "付録C.謝辞"
    },
    {
      "indent": 3,
      "text": "This document draws extensively from ideas in [I-D.kazuho-protected-sni], but is a much more limited mechanism because it depends on the DNS for the protection of the ECH key. Richard Barnes, Christian Huitema, Patrick McManus, Matthew Prince, Nick Sullivan, Martin Thomson, and David Benjamin also provided important ideas and contributions.",
      "ja": "このドキュメントは、[i-d.kazuho保護-Sni]のアイデアから広範囲に描かれていますが、ECHキーを保護するためのDNSに依存するため、はるかに限られたメカニズムです。リチャード・バーンズ、クリスチャン・フイテマ、パトリック・マクマナス、マシュー・プリンス、ニック・サリバン、マーティン・トムソン、デビッド・ベンジャミンも重要なアイデアと貢献を提供しました。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Change Log",
      "section_title": true,
      "ja": "付録D.ログを変更します"
    },
    {
      "indent": 6,
      "text": "*RFC Editor's Note:* Please remove this section prior to publication of a final version of this document.",
      "ja": "* RFCエディターのメモ：*このドキュメントの最終バージョンを公開する前に、このセクションを削除してください。"
    },
    {
      "indent": 3,
      "text": "Issue and pull request numbers are listed with a leading octothorp.",
      "ja": "問題とプル要求番号は、主要なOctothorpにリストされています。"
    },
    {
      "indent": 0,
      "text": "D.1. Since draft-ietf-tls-esni-12",
      "section_title": true,
      "ja": "D.1. ドラフト-iTf-tls-esni-12以来"
    },
    {
      "indent": 3,
      "text": "* Abort on duplicate OuterExtensions (#514)",
      "ja": "* 重複するoutourestensions（＃514）を中止する"
    },
    {
      "indent": 3,
      "text": "* Improve EncodedClientHelloInner definition (#503)",
      "ja": "* EncodedClientHelloinnerの定義を改善する（＃503）"
    },
    {
      "indent": 3,
      "text": "* Clarify retry configuration usage (#498)",
      "ja": "* 再生構成の使用法を明確にする（＃498）"
    },
    {
      "indent": 3,
      "text": "* Expand on config_id generation implications (#491)",
      "ja": "* config_id生成の影響を展開する（＃491）"
    },
    {
      "indent": 3,
      "text": "* Server-side acceptance signal extension GREASE (#481)",
      "ja": "* サーバー側の受け入れ信号拡張グリース（＃481）"
    },
    {
      "indent": 3,
      "text": "* Refactor overview, client implementation, and middlebox sections (#480, #478, #475, #508)",
      "ja": "* リファクタリングの概要、クライアントの実装、およびミドルボックスセクション（＃480、＃478、＃475、＃508）"
    },
    {
      "indent": 3,
      "text": "* Editorial iprovements (#485, #488, #490, #495, #496, #499, #500, #501, #504, #505, #507, #510, #511)",
      "ja": "* 編集iProvements（＃485、＃488、＃490、＃495、＃496、＃499、＃500、＃501、＃504、＃505、＃507、＃510、＃511）"
    },
    {
      "indent": 0,
      "text": "D.2. Since draft-ietf-tls-esni-11",
      "section_title": true,
      "ja": "D.2. ドラフト-iTf-tls-esni-11以来"
    },
    {
      "indent": 3,
      "text": "* Move ClientHello padding to the encoding (#443)",
      "ja": "* clienthelloのパディングをエンコードに移動する（＃443）"
    },
    {
      "indent": 3,
      "text": "* Align codepoints (#464)",
      "ja": "* CodePointsを調整する（＃464）"
    },
    {
      "indent": 3,
      "text": "* Relax OuterExtensions checks for alignment with RFC8446 (#467)",
      "ja": "* rfc8446（＃467）とのアラインメントをチェックするoutourextensionsのリラックスチェック"
    },
    {
      "indent": 3,
      "text": "* Clarify HRR acceptance and rejection logic (#470)",
      "ja": "* HRRの受け入れと拒否の論理を明確にする（＃470）"
    },
    {
      "indent": 3,
      "text": "* Editorial improvements (#468, #465, #462, #461)",
      "ja": "* 編集の改善（＃468、＃465、＃462、＃461）"
    },
    {
      "indent": 0,
      "text": "D.3. Since draft-ietf-tls-esni-10",
      "section_title": true,
      "ja": "D.3. ドラフト-iTf-tls-esni-10以来"
    },
    {
      "indent": 3,
      "text": "* Make HRR confirmation and ECH acceptance explicit (#422, #423)",
      "ja": "* HRRの確認とECHの受け入れを明示する（＃422、＃423）"
    },
    {
      "indent": 3,
      "text": "* Relax computation of the acceptance signal (#420, #449)",
      "ja": "* 受け入れ信号のリラックス計算（＃420、＃449）"
    },
    {
      "indent": 3,
      "text": "* Simplify ClientHelloOuterAAD generation (#438, #442)",
      "ja": "* clienthelloouteraad生成を簡素化する（＃438、＃442）"
    },
    {
      "indent": 3,
      "text": "* Allow empty enc in ECHClientHello (#444)",
      "ja": "* echclienthello（＃444）で空のcを許可する"
    },
    {
      "indent": 3,
      "text": "* Authenticate ECHClientHello extensions position in ClientHelloOuterAAD (#410)",
      "ja": "* clienthelloouteraad（＃410）のechclienthello拡張機能を認証する"
    },
    {
      "indent": 3,
      "text": "* Allow clients to send a dummy PSK and early_data in ClientHelloOuter when applicable (#414, #415)",
      "ja": "* クライアントが該当する場合はクライアントヘロウターでダミーPSKとearly_Dataを送信できるようにします（＃414、＃415）"
    },
    {
      "indent": 3,
      "text": "* Compress ECHConfigContents (#409)",
      "ja": "* ECHCONFIGCONTENTSを圧縮する（＃409）"
    },
    {
      "indent": 3,
      "text": "* Validate ECHConfig.contents.public_name (#413, #456)",
      "ja": "* echconfig.contents.public_name（＃413、＃456）を検証する"
    },
    {
      "indent": 3,
      "text": "* Validate ClientHelloInner contents (#411)",
      "ja": "* clienthelloinnerコンテンツを検証する（＃411）"
    },
    {
      "indent": 3,
      "text": "* Note split-mode challenges for HRR (#418)",
      "ja": "* HRRのスプリットモードの課題に注意してください（＃418）"
    },
    {
      "indent": 3,
      "text": "* Editorial improvements (#428, #432, #439, #445, #458, #455)",
      "ja": "* 編集改善（＃428、＃432、＃439、＃445、＃458、＃455）"
    },
    {
      "indent": 0,
      "text": "D.4. Since draft-ietf-tls-esni-09",
      "section_title": true,
      "ja": "D.4. ドラフト-iTF-TLS-ESNI-09以来"
    },
    {
      "indent": 3,
      "text": "* Finalize HPKE dependency (#390)",
      "ja": "* HPKE依存関係を完成させる（＃390）"
    },
    {
      "indent": 3,
      "text": "* Move from client-computed to server-chosen, one-byte config identifier (#376, #381)",
      "ja": "* クライアントコンピューターからサーバーの選択、1バイト構成識別子（＃376、＃381）に移動する"
    },
    {
      "indent": 3,
      "text": "* Rename ECHConfigs to ECHConfigList (#391)",
      "ja": "* eChConfigsをechconfiglistに変更する（＃391）"
    },
    {
      "indent": 3,
      "text": "* Clarify some security and privacy properties (#385, #383)",
      "ja": "* いくつかのセキュリティとプライバシーのプロパティを明確にする（＃385、＃383）"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc.",
      "ja": "Eric Rescorla RTFM、Inc。"
    },
    {
      "indent": 3,
      "text": "Email: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kazuho Oku Fastly",
      "ja": "カズホ・オクーはすばやく"
    },
    {
      "indent": 3,
      "text": "Email: kazuhooku@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Nick Sullivan Cloudflare",
      "ja": "ニック・サリバン・クラウドフレア"
    },
    {
      "indent": 3,
      "text": "Email: nick@cloudflare.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood Cloudflare",
      "ja": "クリストファーA.ウッドクラウドフラア"
    },
    {
      "indent": 3,
      "text": "Email: caw@heapingbits.net",
      "raw": true,
      "ja": ""
    }
  ],
  "is_draft": true
}