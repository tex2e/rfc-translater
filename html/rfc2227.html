<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 2227 - Simple Hit-Metering and Usage-Limiting for HTTP 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2227</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc2227">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <!-- <div class="row"> -->
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2227 - Simple Hit-Metering and Usage-Limiting for HTTP 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc2227">
              https://datatracker.ietf.org/doc/html/rfc2227
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 2227 - HTTPの単純なヒットメータリングと使用制限</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    <!-- </div> -->
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                           J. Mogul
Request for Comments: 2227                                        DECWRL
Category: Standards Track                                       P. Leach
                                                               Microsoft
                                                            October 1997
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Simple Hit-Metering and Usage-Limiting for HTTP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
HTTPの単純なヒットメータリングと使用制限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1997). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（1997）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ABSTRACT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document proposes a simple extension to HTTP, using a new &#34;Meter&#34; header, which permits a limited form of demographic information (colloquially called &#34;hit-counts&#34;) to be reported by caches to origin servers, in a more efficient manner than the &#34;cache-busting&#34; techniques currently used. It also permits an origin server to control the number of times a cache uses a cached response, and outlines a technique that origin servers can use to capture referral information without &#34;cache-busting.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、新しい「メーター」ヘッダーを使用して、HTTPの単純な拡張を提案します。これにより、限られた形式の人口統計情報（通称「ヒットカウント」）がキャッシュからオリジンサーバーに、より効率的な方法で報告されます。現在使用されている「キャッシュ無効化」手法。また、オリジンサーバーがキャッシュがキャッシュされた応答を使用する回数を制御できるようにし、オリジンサーバーが「キャッシュバスティング」なしで参照情報をキャプチャするために使用できる手法の概要を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
TABLE OF CONTENTS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1 Introduction 2 1.1 Goals, non-goals, and limitations 3 1.2 Brief summary of the design 4 1.3 Terminology 5 2 Overview 5 2.1 Discussion 7 3 Design concepts 8 3.1 Implementation of the &#34;metering subtree&#34; 8 3.2 Format of the Meter header 10 3.3 Negotiation of hit-metering and usage-limiting 10 3.4 Transmission of usage reports 14 3.5 When to send usage reports 15 3.6 Subdivision of usage-limits 16
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1はじめに2 1.1目標、非目標、および制限3 1.2設計の概要4 1.3用語5 2概要5 2.1考察7 3設計の概念8 3.1「メータリングサブツリー」の実装8 3.2メータヘッダーのフォーマット10 3.3ヒットメータリングと使用制限の交渉10 3.4使用レポートの送信14 3.5使用レポートを送信するタイミング15 3.6使用制限の細分化16
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4 Analysis 17 4.1 Approximation accuracy for counting users 18 4.2 What about &#34;Network Computers&#34;? 19 4.3 Critical-path delay analysis 19 5 Specification 20 5.1 Specification of Meter header and directives 20 5.2 Abbreviations for Meter directives 23 5.3 Counting rules 24 5.3.1 Counting rules for hit-metering 24 5.3.2 Counting rules for usage-limiting 25 5.3.3 Equivalent algorithms are allowed 26 5.4 Counting rules: interaction with Range requests 27 5.5 Implementation by non-caching proxies 27 5.6 Implementation by cooperating caches 28 6 Examples 28 6.1 Example of a complete set of exchanges 28 6.2 Protecting against HTTP/1.0 proxies 30 6.3 More elaborate examples 30 7 Interactions with content negotiation 31 7.1 Treatment of responses carrying a Vary header 31 7.2 Interaction with Transparent Content Negotiation 32 8 A Note on Capturing Referrals 32 9 Alternative proposals 33 10 Security Considerations 34 11 Acknowledgments 35 12 References 35 13 Authors&#39; Addresses 36 14 Full Copyright Statement 37
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4分析17 4.1ユーザーをカウントするための近似精度18 4.2「ネットワークコンピュータ」はどうですか？ 19 4.3クリティカルパス遅延の分析19 5仕様20 5.1メーターヘッダーとディレクティブの仕様20 5.2メーターディレクティブの略語23 5.3カウントルール24 5.3.1ヒットメーターのカウントルール24 5.3.2使用制限のカウントルール25 5.3 .3同等のアルゴリズムが許可されます26 5.4カウントルール：範囲要求との相互作用27 5.5非キャッシュプロキシによる実装27 5.6キャッシュの連携による実装28 6例28 6.1完全な交換の例28 6.2 HTTP / 1.0プロキシからの保護30 6.3より複雑な例30 7コンテンツネゴシエーションとの相互作用31 7.1 Varyヘッダーを含む応答の処理31 7.2透過的コンテンツネゴシエーションとの相互作用32 8リフェラルのキャプチャに関する注意32 9代替提案33 10セキュリティに関する考慮事項34 11謝辞35 12参考文献35 13著者&#39;アドレス36 14完全な著作権表示37
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
1 Introduction
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
1はじめに
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a variety of reasons, content providers want to be able to collect information on the frequency with which their content is accessed. This desire leads to some of the &#34;cache-busting&#34; done by existing servers. (&#34;Cache-busting&#34; is the use by servers of techniques intended to prevent caching of responses; it is unknown exactly how common this is.) This kind of cache-busting is done not for the purpose of maintaining transparency or security properties, but simply to collect demographic information. Some cache-busting is also done to provide different advertising images to appear on the same page (i.e., each retrieval of the page sees a different ad).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さまざまな理由から、コンテンツプロバイダーは、コンテンツへのアクセス頻度に関する情報を収集できることを望んでいます。この欲求は、既存のサーバーによって行われる「キャッシュ無効化」のいくつかにつながります。 （「キャッシュ無効化」は、応答のキャッシュを防止することを目的とした技術のサーバーによる使用です。これがどれほど一般的であるかは正確には不明です。）この種のキャッシュ無効化は、透明性やセキュリティプロパティを維持する目的ではなく、単に人口統計情報を収集します。同じページに表示されるさまざまな広告画像を提供するために、いくつかのキャッシュ無効化も行われます（つまり、ページを取得するたびに異なる広告が表示されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 This proposal supports a model similar to that of publishers of hard-copy publications: such publishers (try to) report to their advertisers how many people read an issue of a publication at least once; they don&#39;t (try to) report how many times a reader re-reads an issue. They do this by counting copies published, and then try to estimate, for their publication, on average how many people read a single copy at least once. The key point is that the results aren&#39;t exact, but are still useful. Another model is that of coding inquiries in such a way that the advertiser can tell which publication produced the inquiry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
この提案は、ハードコピーの出版社のモデルと同様のモデルをサポートします。そのような出版社は、少なくとも1度は出版物の問題を読んだ人の数を広告主に報告（試行）します。読者が問題を何度も読み直すかは報告しません（試みます）。彼らは、出版されたコピーを数えることによってこれを行い、彼らの出版物に対して、平均して何人が少なくとも1回は1つのコピーを読んだかを推定しようとします。重要な点は、結果は正確ではないが、それでも有用であるということです。別のモデルは、広告主がどのパブリケーションが問い合わせを生成したかを判別できるような方法で問い合わせをコーディングするモデルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1 Goals, non-goals, and limitations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1 目標、非目標、および制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 already allows origin servers to prevent caching of responses, and evidence exists [9] that at least some of the time, this is being done for the sole purpose of collecting counts of the number of accesses of specific pages. Some of this evidence is inferred from the study of proxy traces; some is based on explicit statements of the intention of the operators of Web servers. Information collected this way might or might not be of actual use to the people who collect it; the fact is that they want to collect it, or already do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 1.1はすでにオリジンサーバーが応答のキャッシュを防止することを許可しており、特定のページへのアクセス数のカウントを収集することのみを目的として少なくとも一部の場合に行われている証拠が存在します[9]。この証拠の一部は、プロキシトレースの調査から推測されます。一部は、Webサーバーのオペレーターの意図の明示的なステートメントに基づいています。この方法で収集された情報は、収集した人々にとって実際に役立つ場合とそうでない場合があります。実際、彼らはそれを収集したい、またはすでに収集しているのです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal of this proposal is to provide an optional performance optimization for this use of HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この提案の目的は、HTTP / 1.1のこの使用に対してオプションのパフォーマンス最適化を提供することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Optional: no server or proxy is required to implement it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- オプション：サーバーやプロキシーを実装する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Proxy-centered: there is no involvement on the part of end-client implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- プロキシ中心：エンドクライアントの実装には関与しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Solely a performance optimization: it provides no information or functionality that is not already available in HTTP/1.1. The intent is to improve performance overall, and reduce latency for almost all interactions; latency might be increased for a small fraction of HTTP interactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 単にパフォーマンスの最適化：HTTP / 1.1ではまだ利用できない情報や機能は提供されません。その目的は、全体的なパフォーマンスを改善し、ほとんどすべての対話の待ち時間を減らすことです。 HTTPインタラクションのごく一部でレイテンシが増加する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Best-efforts: it does not guarantee the accuracy of the reported information, although it does provide accurate results in the absence of persistent network failures or host crashes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- ベストエフォート：永続的なネットワーク障害やホストクラッシュがない場合でも正確な結果を提供しますが、報告される情報の正確性を保証するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Neutral with respect to privacy: it reveals to servers no information about clients that is not already available through the existing features of HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- プライバシーに関して中立：HTTP / 1.1の既存の機能ではまだ利用できないクライアントに関する情報をサーバーに公開しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goals of this specification do not include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様の目標には、以下は含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Solving the entire problem of efficiently obtaining extensive information about requests made via proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- プロキシ経由で行われたリクエストに関する広範な情報を効率的に取得するという問題全体を解決します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Improving the protection of user privacy (although our proposal may reduce the transfer of user-specific information to servers, it does not prevent it).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- ユーザーのプライバシー保護の改善（私たちの提案はユーザー固有の情報のサーバーへの転送を減らす可能性がありますが、それを妨げるものではありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Preventing or encouraging the use of log-exchange mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- ログ交換メカニズムの使用の防止または奨励。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Avoiding all forms of &#34;cache-busting&#34;, or even all cache-busting done for gathering counts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 「キャッシュ無効化」のすべての形式、またはカウントを収集するために行われるすべてのキャッシュ無効化を回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This design has certain potential limitations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この設計には、特定の潜在的な制限があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- If it is not deployed widely in both proxies and servers, it will provide little benefit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- プロキシとサーバーの両方に広く展開されていないと、ほとんどメリットがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- It may, by partially solving the hit-counting problem, reduce the pressure to adopt more complete solutions, if any become available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- ヒットカウントの問題を部分的に解決することにより、利用可能な場合、より完全なソリューションを採用するというプレッシャーを軽減できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Even if widely deployed, it might not be widely used, and so might not significantly improve performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 広く展開されていても、広く使用されていない可能性があるため、パフォーマンスが大幅に向上しない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These potential limitations might not be problems in actual practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの潜在的な制限は、実際には問題にならない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2 Brief summary of the design
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2 設計の簡単な要約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is included for people not wishing to read the entire document; it is not a specification for the proposed design, and over-simplifies many aspects of the design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは、ドキュメント全体を読みたくない人のために含まれています。これは提案された設計の仕様ではなく、設計の多くの側面を単純化しすぎています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal of this design is to eliminate the need for origin servers to use &#34;cache-busting&#34; techniques, when this is done just for the purpose of counting the number of users of a resource. (Cache-busting includes techniques such as setting immediate Expiration dates, or sending &#34;Cache-control: private&#34; in each response.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この設計の目標は、リソースのユーザー数をカウントする目的でのみ、オリジンサーバーが「キャッシュ無効化」手法を使用する必要をなくすことです。 （キャッシュ無効化には、即時の有効期限の設定、各応答での「キャッシュ制御：プライベート」の送信などの手法が含まれます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The design adds a new &#34;Meter&#34; header to HTTP; the header is always protected by the &#34;Connection&#34; header, and so is always hop-by-hop. This mechanism allows the construction of a &#34;metering subtree&#34;, which is a connected subtree of proxies, rooted at an origin server. Only those proxies that explicitly volunteer to join in the metering subtree for a resource participate in hit-metering, but those proxies that do volunteer are required to make their best effort to provide accurate counts. When a hit-metered response is forwarded outside of the metering subtree, the forwarding proxy adds &#34;Cache-control: s-maxage=0&#34;, so that other proxies (outside the metering subtree) are forced to forward all requests to a server in the metering subtree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この設計により、新しい「メーター」ヘッダーがHTTPに追加されます。ヘッダーは常に「接続」ヘッダーによって保護されるため、常にホップバイホップです。このメカニズムにより、起点サーバーをルートとする接続されたプロキシのサブツリーである「メータリングサブツリー」を構築できます。リソースのメータリングサブツリーに明示的に参加するように自発的に参加するプロキシのみがヒットメータリングに参加しますが、自発的に実行するプロキシは正確なカウントを提供するために最善を尽くす必要があります。ヒットメータリングされた応答がメータリングサブツリーの外に転送されると、転送プロキシは「Cache-control：s-maxage = 0」を追加します。これにより、他のプロキシ（メータリングサブツリーの外）はすべての要求を強制的にサーバーに転送します。計測サブツリー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NOTE: the HTTP/1.1 specification does not currently define a &#34;s-maxage&#34; Cache-control directive. The HTTP working group has decided to add such a directive to the next revision of the HTTP/1.1 specification [7].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：HTTP / 1.1仕様は現在、「s-maxage」キャッシュ制御ディレクティブを定義していません。 HTTPワーキンググループは、このようなディレクティブをHTTP / 1.1仕様の次のリビジョンに追加することを決定しました[7]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Meter header carries zero or more directives, similar to the way that the Cache-control header carries directives. Proxies may use certain Meter directives to volunteer to do hit-metering for a resource. If a proxy does volunteer, the server may use certain directives to require that a response be hit-metered. Finally, proxies use a &#34;count&#34; Meter directive to report the accumulated hit counts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterヘッダーは、キャッシュ制御ヘッダーがディレクティブを運ぶのと同様に、0個以上のディレクティブを運びます。プロキシは、特定のMeterディレクティブを使用して、リソースのヒットメータリングを自発的に行うことができます。プロキシがボランティアである場合、サーバーは特定のディレクティブを使用して、応答のヒットメータリングを要求する場合があります。最後に、プロキシは「カウント」メーターディレクティブを使用して、累積ヒットカウントを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Meter mechanism can also be used by a server to limit the number of uses that a cache may make of a cached response, before revalidating it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがMeterメカニズムを使用して、キャッシュを再検証する前に、キャッシュがキャッシュされた応答を使用する回数を制限することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full specification includes complete rules for counting &#34;uses&#34; of a response (e.g., non-conditional GETs) and &#34;reuses&#34; (conditional GETs). These rules ensure that the results are entirely consistent in all cases, except when systems or networks fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全な仕様には、応答の「使用」（たとえば、非条件付きGET）および「再利用」（条件付きGET）をカウントするための完全なルールが含まれています。これらのルールは、システムまたはネットワークに障害が発生した場合を除いて、すべてのケースで結果が完全に一貫していることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3 Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses terms defined and explained in the HTTP/1.1 specification [4], including &#34;origin server,&#34; &#34;resource,&#34; &#34;hop-by-hop,&#34; &#34;unconditional GET,&#34; and &#34;conditional GET.&#34; The reader is expected to be familiar with the HTTP/1.1 specification and its terminology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、HTTP / 1.1仕様[4]で定義および説明されている用語を使用します。これには、「元のサーバー」、「リソース」、「ホップバイホップ」、「無条件GET」、「条件付きGET」が含まれます。読者は、HTTP / 1.1仕様とその用語に精通している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHOULD&#34;, SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHOULD」、SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、RFC 2119 [1 ]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2 Overview
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The design described in this document introduces several new features to HTTP:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで説明する設計では、HTTPにいくつかの新機能が導入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Hit-metering: allows an origin server to obtain reasonably accurate counts of the number of clients using a resource instance via a proxy cache, or a hierarchy of proxy caches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- ヒットメータリング：オリジンサーバーが、プロキシキャッシュまたはプロキシキャッシュの階層を介して、リソースインスタンスを使用しているクライアント数のかなり正確な数を取得できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Usage-limiting: allows an origin server to control the number of times a cached response may be used by a proxy cache, or a hierarchy of proxy caches, before revalidation with the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 使用制限：オリジンサーバーで再検証する前に、キャッシュされた応答がプロキシキャッシュまたはプロキシキャッシュの階層によって使用される回数をオリジンサーバーが制御できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These new non-mandatory features require minimal new protocol support, no change in protocol version, relatively little overhead in message headers. The design adds no additional network round-trips in any critical path that directly affects user-perceived latency (see section 4.3 for an analysis).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの新しい必須でない機能は、最小限の新しいプロトコルサポート、プロトコルバージョンの変更なし、メッセージヘッダーのオーバーヘッドの比較的少ない必要があります。この設計では、ユーザーが認識する遅延に直接影響するクリティカルパスにネットワークラウンドトリップが追加されることはありません（分析についてはセクション4.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary goal of hit-metering and usage-limiting is to obviate the need for an origin server to send &#34;Cache-control: s-maxage=0&#34; with responses for resources whose value is not likely to change immediately. In other words, in cases where the only reason for contacting the origin server on every request that might otherwise be satisfied by a proxy cache entry is to allow the server to collect demographic information or to control the number of times a cache entry is used, the extension proposed here will avoid a significant amount of unnecessary network traffic and latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヒットメータリングと使用制限の主な目的は、オリジンサーバーが「Cache-control：s-maxage = 0」を送信して、値がすぐに変化する可能性が低いリソースに対する応答を送信する必要をなくすことです。つまり、プロキシキャッシュエントリによって満たされる可能性があるすべてのリクエストでオリジンサーバーに接続する唯一の理由が、サーバーが人口統計情報を収集できるようにするか、キャッシュエントリが使用される回数を制御できるようにする場合です。ここで提案する拡張機能により、不必要なネットワークトラフィックと待ち時間が大幅に削減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This design introduces one new &#34;Meter&#34; header, which is used both in HTTP request messages and HTTP response messages. The Meter header is used to transmit a number of directives and reports. In particular, all negotiation of the use of hit-metering and usage limits is done using this header. No other changes to the existing HTTP/1.1 specification [4] are proposed in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この設計では、HTTP要求メッセージとHTTP応答メッセージの両方で使用される1つの新しい「メーター」ヘッダーが導入されています。 Meterヘッダーは、いくつかのディレクティブとレポートを送信するために使用されます。特に、ヒットメータリングと使用制限の使用に関するすべてのネゴシエーションは、このヘッダーを使用して行われます。このドキュメントでは、既存のHTTP / 1.1仕様[4]に対するその他の変更は提案されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This design also introduces several new concepts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この設計では、いくつかの新しい概念も導入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. The concepts of a &#34;use&#34; of a cache entry, which is when a proxy returns its entity-body in response to a conditional or non-conditional request, and the &#34;reuse&#34; of a cache entry, which is when a proxy returns a 304 (Not Modified) response to a conditional request which is satisfied by that cache entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. プロキシが条件付きまたは非条件付きリクエストに応じてエンティティ本体を返すときのキャッシュエントリの「使用」と、プロキシがプロキシを返すときのキャッシュエントリの「再利用」の概念条件付き要求に対する304（変更なし）応答。このキャッシュエントリによって満たされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. The concept of a hit-metered resource, for which proxy caches make a best-effort attempt to report accurate counts of uses and/or reuses to the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. ヒットメータリングリソースの概念。プロキシキャッシュは、使用および再利用の正確な数を元のサーバーに報告するために最善の努力を払います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. The concept of a usage-limited resource, for which the origin server expects proxy caches to limit the number of uses and/or reuses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. オリジンサーバーがプロキシキャッシュを使用および/または再利用の数を制限することを期待する使用制限付きリソースの概念。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new Meter directives and reports interact to allow proxy caches and servers to cooperate in the collection of demographic data. The goal is a best-efforts approximation of the true number of uses and/or reuses, not a guaranteed exact count.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいMeterディレクティブとレポートは相互に作用し、人口統計データの収集においてプロキシキャッシュとサーバーが連携できるようにします。目標は、保証された正確な数ではなく、実際の使用および/または再利用の数のベストエフォートの概算です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new Meter directives also allow a server to bound the inaccuracy of a particular hit-count, by bounding the number of uses between reports. It can also, for example, bound the number of times the same ad is shown because of caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいMeterディレクティブを使用すると、サーバーは、レポート間の使用回数を制限することにより、特定のヒットカウントの不正確さを制限できます。たとえば、キャッシュのために同じ広告が表示される回数を制限することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 7.1 describes a way to use server-driven content negotiation (the Vary header) that allows an HTTP origin server to flexibly separate requests into categories and count requests by category. Implementation of such a categorized hit counting is likely to be a very small modification to most implementations of Vary; some implementations may not require any modification at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1では、HTTP起点サーバーが要求をカテゴリーに柔軟に分離し、カテゴリーごとに要求をカウントできるようにするサーバー駆動のコンテンツネゴシエーション（Varyヘッダー）を使用する方法について説明します。このような分類されたヒットカウントの実装は、ほとんどのVaryの実装に対して非常に小さな変更になる可能性があります。一部の実装では、まったく変更を必要としない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1 Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1 討論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mapping this onto the publishing model, a proxy cache would increment the use-count for a cache entry once for each unconditional GET done for the entry, and once for each conditional GET that results in sending a copy of the entry to update a client&#39;s invalid cached copy. Conditional GETs that result in 304 (Not Modified) are not included in the use-count, because they do not result in a new user seeing the page, but instead signify a repeat view by a user that had seen it before. However, 304 responses are counted in the reuse-count. HEADs are not counted at all, because their responses do not contain an entity-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを公開モデルにマッピングすると、プロキシキャッシュは、キャッシュエントリの使用カウントを、エントリに対する無条件GETごとに1回、条件付きGETごとに1回インクリメントして、エントリのコピーを送信してクライアントの無効を更新します。キャッシュされたコピー。 304（Not Modified）となる条件付きGETは、新しいユーザーがページを表示するのではなく、以前にそれを表示したことのあるユーザーによるリピートビューを意味するため、use-countには含まれません。ただし、304の応答が再利用カウントにカウントされます。 HEADはカウントされません。応答にはエンティティ本体が含まれないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Meter directives apply only to shared proxy caches, not to end-client (or other single-user) caches. Single user caches should not use Meter, because their hits will be automatically counted as a result of the unconditional GET with which they first fetch the page, from either the origin-server or from a proxy cache. Their subsequent conditional GETs do not result in a new user seeing the page.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterディレクティブは共有プロキシキャッシュにのみ適用され、エンドクライアント（または他のシングルユーザー）キャッシュには適用されません。シングルユーザーキャッシュはMeterを使用しないでください。ヒットは、オリジンサーバーまたはプロキシキャッシュから最初にページを取得する無条件GETの結果として自動的にカウントされるためです。その後の条件付きGETでは、新しいユーザーにページが表示されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanism specified here counts GETs; other methods either do not result in a page for the user to read, aren&#39;t cached, or are &#34;written-through&#34; and so can be directly counted by the origin server. (If, in the future, a &#34;cachable POST&#34; came into existence, whereby the entity-body in the POST request was used to select a cached response, then such POSTs would have to be treated just like GETs.) The applicability of hit-metering to any new HTTP methods that might be defined in the future is currently unspecifiable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで指定するメカニズムはGETをカウントします。他の方法では、ユーザーがページを読み取れないか、キャッシュされないか、「ライトスルー」されるため、配信元サーバーで直接カウントできます。 （将来、「キャッシュ可能なPOST」が発生し、POSTリクエストのエンティティ本体がキャッシュされた応答を選択するために使用された場合、そのようなPOSTはGETと同じように扱われる必要があります。）将来的に定義される可能性のある新しいHTTPメソッドへのメータリングは、現時点では指定できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of multiple caches along a path, a proxy cache does the obvious summation when it receives a use-count or reuse-count in a request from another cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パスに沿って複数のキャッシュがある場合、プロキシキャッシュは、別のキャッシュからのリクエストで使用数または再利用数を受け取ると、明らかな合計を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3 Design concepts
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3設計コンセプト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to allow the introduction of hit-metering and usage-limiting without requiring a protocol revision, and to ensure a reasonably close approximation of accurate counts, the negotiation of metering and usage-limiting is done hop-by-hop, not end-to-end. If one considers the &#34;tree&#34; of proxies that receive, store, and forward a specific response, the intent of this design is that within some (possibly null) &#34;metering subtree&#34;, rooted at the origin server, all proxies are using the hit-metering and/or usage-limiting requested by the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルリビジョンを必要とせずにヒットメータリングと使用制限の導入を可能にし、正確なカウントのかなり近い概算を保証するために、メータリングと使用制限のネゴシエーションはエンドバイホップではなくホップバイホップで行われます最後まで。特定の応答を受信、保存、転送するプロキシの「ツリー」を考えると、この設計の目的は、オリジンサーバーをルートとする一部の（おそらくnull）「メータリングサブツリー」内で、すべてのプロキシがヒットを使用していることです。オリジンサーバーから要求されたメータリングや使用制限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Proxies at the leaves of this subtree will insert a &#34;Cache-control: s-maxage=0&#34; directive, which forces all other proxies (below this subtree) to check with a leaf of the metering subtree on every request. However, it does not prevent them from storing and using the response, if the revalidation succeeds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このサブツリーのリーフにあるプロキシは、「Cache-control：s-maxage = 0」ディレクティブを挿入します。これにより、他のすべてのプロキシ（このサブツリーの下にある）は、すべてのリクエストでメータリングサブツリーのリーフをチェックします。ただし、再検証が成功した場合でも、応答を保存して使用することはできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No proxy is required to implement hit-metering or usage-limiting. However, any proxy that transmits the Meter header in a request MUST implement every unconditional requirement of this specification, without exception or amendment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヒットメータリングまたは使用制限を実装するためにプロキシは必要ありません。ただし、リクエストでMeterヘッダーを送信するプロキシは、例外や修正なしに、この仕様のすべての無条件要件を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a conservative design, which may sometimes fail to take advantage of hit-metering support in proxies outside the metering subtree. However, it is likely that without the reliability offered by a conservative design, managers of origin servers with requirements for accurate approximations will not take advantage of any hit-metering proposal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは保守的な設計であり、メータリングサブツリー外のプロキシでヒットメータリングサポートを利用できない場合があります。ただし、保守的な設計によって提供される信頼性がなければ、正確な概算の要件を持つオリジンサーバーのマネージャーは、ヒットメータリングの提案を活用できない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hit-metering/usage-limiting mechanism is designed to avoid any extra network round-trips in the critical path of any client request, and (as much as possible) to avoid excessively lengthening HTTP messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヒットメータリング/使用制限メカニズムは、クライアント要求のクリティカルパスでの余分なネットワークラウンドトリップを回避し、（可能な限り）HTTPメッセージが過度に長くなるのを回避するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Meter header is used to transmit both negotiation information and numeric information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterヘッダーは、交渉情報と数値情報の両方を送信するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A formal specification for the Meter header appears in section 5; the following discussion uses an informal approach to improve clarity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterヘッダーの正式な仕様はセクション5にあります。次の説明では、わかりやすくするために非公式なアプローチを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Implementation of the &#34;metering subtree&#34;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 「メータリングサブツリー」の実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;metering subtree&#34; approach is implemented in a simple, straightforward way by defining the new &#34;Meter&#34; header as one that MUST always be protected by a Connection header in every request or response. I.e., if the Meter header is present in an HTTP message, that message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;メータリングサブツリー&#34;アプローチは、新しい &#34;メーター&#34;ヘッダーをすべての要求または応答で常に接続ヘッダーによって保護する必要があるヘッダーとして定義することにより、シンプルで簡単な方法で実装されます。つまり、MeterヘッダーがHTTPメッセージに存在する場合、そのメッセージは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. MUST contain &#34;Connection: meter&#34;, and MUST be handled according to the HTTP/1.1 specification of the Connection header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. 「接続：メーター」を含む必要があり、接続ヘッダーのHTTP / 1.1仕様に従って処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. MUST NOT be sent in response to a request from a client whose version number is less than HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. バージョン番号がHTTP / 1.1未満のクライアントからの要求に応答して送信してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. MUST NOT be accepted from a client whose version number is less than HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. バージョン番号がHTTP / 1.1未満のクライアントからは受け入れられません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reason for the latter two restrictions is to protect against proxies that might not properly implement the Connection header. Otherwise, a subtree that includes an HTTP/1.0 proxy might erroneously appear to be a metering subtree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後者の2つの制限の理由は、Connectionヘッダーを適切に実装しない可能性があるプロキシから保護するためです。そうしないと、HTTP / 1.0プロキシを含むサブツリーが、メータリングサブツリーとして誤って表示される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: It appears that for the Connection header mechanism to function correctly, a system receiving an HTTP/1.0 (or lower-version) message that includes a Connection header must act as if this header, and all of the headers it protects, ought to have been removed from the message by an intermediate proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：Connectionヘッダーメカニズムが正しく機能するためには、Connectionヘッダーを含むHTTP / 1.0（またはそれより下位のバージョン）メッセージを受信するシステムは、このヘッダーとそれが保護するすべてのヘッダーのように動作する必要があります。中間プロキシによってメッセージから削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Although RFC2068 does not specifically require this behavior, it appears to be implied. Otherwise, one could not depend on the stated property (section 14.10) that the protected options &#34;MUST NOT be communicated by proxies over further connections.&#34; This should probably be clarified in a subsequent draft of the HTTP/1.1 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RFC2068はこの動作を特に必要としませんが、暗黙のようです。さもなければ、保護されたオプションが「さらなる接続を介してプロキシによって伝達されてはならない」という規定のプロパティ（セクション14.10）に依存することはできません。これはおそらく、HTTP / 1.1仕様の今後のドラフトで明らかにされるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This specification does not, in any way, propose a modification of the specification of the Connection header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この仕様は、いかなる方法でも、Connectionヘッダーの仕様の変更を提案するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the point of view of an origin server, the proxies in a metering subtree work together to obey usage limits and to maintain accurate usage counts. When an origin server specifies a usage limit, a proxy in the metering subtree may subdivide this limit among its children in the subtree as it sees fit. Similarly, when a proxy in the subtree receives a usage report, it ensures that the hits represented by this report are summed properly and reported to the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オリジンサーバーの観点から見ると、メータリングサブツリーのプロキシは連携して、使用制限に従い、正確な使用カウントを維持します。オリジンサーバーが使用制限を指定すると、メータリングサブツリーのプロキシは、サブツリーの子にこの制限を適切に分割します。同様に、サブツリーのプロキシが使用状況レポートを受信すると、このレポートによって表されるヒットが適切に合計され、配信元サーバーに報告されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a proxy forwards a hit-metered or usage-limited response to a client (proxy or end-client) not in the metering subtree, it MUST omit the Meter header, and it MUST add &#34;Cache-control: s-maxage=0&#34; to the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシがヒットメータリングされた応答または使用制限された応答をメータリングサブツリーにないクライアント（プロキシまたはエンドクライアント）に転送する場合、メータヘッダーを省略し、「Cache-control：s-maxage = 0 &#34;応答へ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Format of the Meter header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Meterヘッダーのフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Meter header is used to carry zero or more directives. Multiple Meter headers may occur in an HTTP message, but according to the rules in section 4.2 of the HTTP/1.1 specification [4], they may be combined into a single header (and should be so combined, to reduce overhead).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterヘッダーは、0個以上のディレクティブを運ぶために使用されます。 HTTPメッセージでは複数のMeterヘッダーが発生する可能性がありますが、HTTP / 1.1仕様[4]のセクション4.2のルールに従って、それらは単一のヘッダーに結合される場合があります（オーバーヘッドを減らすために結合する必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the following sequence of Meter headers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、次のMeterヘッダーのシーケンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Meter: max-uses=3
       Meter: max-reuses=10
       Meter: do-report
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
may be expressed as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように表すことができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Meter: max-uses=3, max-reuses=10, do-report
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Negotiation of hit-metering and usage-limiting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 ヒットメータリングと使用制限の交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An origin server that wants to collect hit counts for a resource, by simply forcing all requests to bypass any proxy caches, would respond to requests on the resource with &#34;Cache-control: s-maxage=0&#34;. (An origin server wishing to prevent HTTP/1.0 proxies from improperly caching the response could also send both &#34;Expires: &lt;now&gt;&#34;, to prevent such caching, and &#34;Cache-control: max-age=NNNN&#34;, to allow newer proxies to cache the response).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのリクエストにプロキシキャッシュをバイパスさせるだけで、リソースのヒットカウントを収集するオリジンサーバーは、「Cache-control：s-maxage = 0」でリソースのリクエストに応答します。 （HTTP / 1.0プロキシが応答を不適切にキャッシュしないようにするオリジンサーバーは、「Expires：&lt;now&gt;」を送信してこのようなキャッシュを防止し、「Cache-control：max-age = NNNN」を送信して新しいプロキシを許可することもできます。応答をキャッシュします）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the Meter header is to obviate the need for &#34;Cache-control: s-maxage=0&#34; within a metering subtree. Thus, any proxy may negotiate the use of hit-metering and/or usage-limiting with the next-hop server. If this server is the origin server, or is already part of a metering subtree (rooted at the origin server), then it may complete the negotiation, thereby extending the metering subtree to include the new proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterヘッダーの目的は、メータリングサブツリー内で「Cache-control：s-maxage = 0」が不要になるようにすることです。したがって、どのプロキシも、ヒットメータリングの使用やネクストホップサーバーとの使用制限のネゴシエーションを行う場合があります。このサーバーがオリジンサーバーである場合、または（オリジンサーバーをルートとする）メータリングサブツリーの一部である場合、ネゴシエーションを完了し、メータリングサブツリーを拡張して新しいプロキシを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To start the negotiation, a proxy sends its request with one of the following Meter directives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネゴシエーションを開始するには、プロキシは次のいずれかのMeterディレクティブを使用してリクエストを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
will-report-and-limit indicates that the proxy is willing and able to return usage reports and will obey any usage-limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
will-report-and-limitは、プロキシが使用状況レポートを返す意志があり、それを返すことができることを示し、すべての使用制限に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-report indicates that the proxy will obey usage-limits but will not send usage reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-reportは、プロキシが使用制限に従いますが、使用レポートを送信しないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-limit indicates that the proxy will not obey usage-limits but will send usage reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-limitは、プロキシが使用制限に従わないが、使用状況レポートを送信することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy willing to neither obey usage-limits nor send usage reports MUST NOT transmit a Meter header in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用制限に従うことも使用レポートを送信することもしないプロキシは、リクエストでMeterヘッダーを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By definition, an empty Meter header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義により、空のMeterヘッダー：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Meter:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
メーター：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is equivalent to &#34;Meter: will-report-and-limit&#34;, and so, by the definition of the Connection header (see section 14.10 of the HTTP/1.1 specification [4]), a request that contains
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「Meter：will-report-and-limit」と同等です。したがって、Connectionヘッダーの定義（HTTP / 1.1仕様[4]のセクション14.10を参照）により、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Connection: Meter
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
接続：メーター
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and no explicit Meter header is equivalent to a request that contains
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明示的なMeterヘッダーは、以下を含むリクエストに相当しません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Connection: Meter Meter: will-report-and-limit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
接続：メーターメーター：will-report-and-limit
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This makes the default case more efficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、デフォルトのケースがより効率的になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An origin server that is not interested in metering or usage-limiting the requested resource simply ignores the Meter header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求されたリソースの測定または使用制限に関心のないオリジンサーバーは、Meterヘッダーを単に無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server wants the proxy to do hit-metering and/or usage-limiting, its response should include one or more of the following Meter directives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがプロキシにヒットメータリングや使用制限を実行させたい場合は、その応答に次のMeterディレクティブを1つ以上含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For hit-metering:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヒットメータリングの場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
do-report specifies that the proxy MUST send usage reports to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
do-reportは、プロキシが使用状況レポートをサーバーに送信する必要があることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dont-report specifies that the proxy SHOULD NOT send usage reports to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dont-reportは、プロキシが使用状況レポートをサーバーに送信してはならない（SHOULD NOT）ことを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeout=NNN sets a metering timeout of NNN minutes, from the time that this response was originated, for the reporting of a hit-count. If the proxy has a non-zero hit count for this response when the timeout expires, it MUST send a report to the server at or before that time. Implies &#34;do-report&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeout = NNNは、ヒット数の報告のために、この応答が発信されたときからNNN分の計測タイムアウトを設定します。タイムアウトの期限が切れたときに、プロキシがこの応答のゼロ以外のヒットカウントを持っている場合、プロキシはその時刻以前にサーバーにレポートを送信する必要があります。 「do-report」を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By definition, an empty Meter header in a response, or any Meter header that does not contain &#34;dont-report&#34;, means &#34;Meter: do-report&#34;; this makes a common case more efficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義により、応答内の空のMeterヘッダー、または「dont-report」を含まないMeterヘッダーは、「Meter：do-report」を意味します。これにより、一般的なケースがより効率的になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: an origin server using the metering timeout mechanism to bound the collection period over which hit-counts are obtained should adjust the timeout values in the responses it sends so that all responses generated within that period reach their metering timeouts at or before the end of that period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：メータリングタイムアウトメカニズムを使用してヒットカウントを取得する収集期間を制限するオリジンサーバーは、送信するレスポンスのタイムアウト値を調整して、その期間内に生成されたすべてのレスポンスが、終了時または終了前にメータリングタイムアウトに達するようにする必要があります。その期間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the origin server simply sends a constant metering timeout T with each response for a resource, the reports that it receives will reflect activity over a period whose duration is between T and N*T (in the worst case), where N is the maximum depth of the metering subtree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
オリジンサーバーがリソースに対する各応答で一定の計測タイムアウトTを送信するだけの場合、受信するレポートは、期間がTからN * T（最悪の場合）までの期間のアクティビティを反映します（Nは最大値）。計測サブツリーの深さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For usage-limiting
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用制限のため
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-uses=NNN sets an upper limit of NNN &#34;uses&#34; of the response, not counting its immediate forwarding to the requesting end-client, for all proxies in the following subtree taken together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-uses = NNNは、次のサブツリー内のすべてのプロキシをまとめて、要求のエンドクライアントへの即時転送をカウントせずに、応答のNNN「使用」の上限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-reuses=NNN sets an upper limit of NNN &#34;reuses&#34; of the response for all proxies in the following subtree taken together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-reuses = NNNは、次のサブツリーのすべてのプロキシをまとめて、応答のNNN &#34;再利用&#34;の上限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a proxy has exhausted its allocation of &#34;uses&#34; or &#34;reuses&#34; for a cache entry, it MUST revalidate the cache entry (using a conditional request) before returning it in a response. (The proxy SHOULD use this revalidation message to send a usage report, if one was requested and it is time to send it. See sections 3.4 and 3.5.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシがキャッシュエントリの「使用」または「再利用」の割り当てを使い果たした場合、応答で返す前に、キャッシュエントリを（条件付き要求を使用して）再検証する必要があります。 （プロキシは、要求があり、それを送信する時がきた場合、この再検証メッセージを使用して使用状況レポートを送信する必要があります。セクション3.4および3.5を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These Meter response-directives apply only to the specific response that they are attached to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのMeter応答ディレクティブは、それらが関連付けられている特定の応答にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that the limit on &#34;uses&#34; set by the max-uses directive does not include the use of the response to satisfy the end-client request that caused the proxy&#39;s request to the server. This counting rule supports the notion of a cache-initiated prefetch: a cache may issue a prefetch request, receive a max-uses=0 response, store that response, and then return that response (without revalidation) when a client makes an actual request for the resource. However, each such response may be used at most once in this way, so the origin server maintains precise control over the number of actual uses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
max-usesディレクティブによって設定された「使用」の制限には、サーバーへのプロキシの要求の原因となったエンドクライアント要求を満たすための応答の使用は含まれないことに注意してください。このカウントルールは、キャッシュによって開始されるプリフェッチの概念をサポートします。キャッシュは、プリフェッチ要求を発行し、max-uses = 0応答を受信し、その応答を格納し、クライアントが実際の要求を行ったときにその応答を（再検証なしで）返します。リソース用。ただし、そのような各応答はこの方法で最大1回使用される可能性があるため、元のサーバーは実際の使用回数を正確に制御します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST NOT send a Meter header that would require a proxy to do something that it has not yet offered to do. A proxy receiving a Meter response-directive asking the proxy to do something it did not volunteer to do SHOULD ignore that directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、まだ提供していないことをプロキシに要求するMeterヘッダーを送信してはならない（MUST NOT）。 Meter応答ディレクティブを受け取ったプロキシは、プロキシに対して、ボランティアではないことを行うように要求し、そのディレクティブを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy receiving a Meter header in a response MUST either obey it, or it MUST revalidate the corresponding cache entry on every access. (I.e., if it chooses not to obey the Meter header in a response, it MUST act as if the response included &#34;Cache-control: s-maxage=0&#34;.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答でMeterヘッダーを受信するプロキシは、それに従うか、すべてのアクセスで対応するキャッシュエントリを再検証する必要があります。 （つまり、応答でMeterヘッダーに従わないことを選択した場合、応答に「Cache-control：s-maxage = 0」が含まれているかのように動作する必要があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: a proxy that has not sent the Meter header in a request for the given resource, and which has therefore not volunteered to honor Meter directives in a response, is not required to honor them. If, in this situation, the server does send a Meter header in a response, this is a protocol error. However, based on the robustness principle, the proxy may choose to interpret the Meter header as an implicit request to include &#34;Cache-control: s-maxage=0&#34; when it forwards the response, since this preserves the apparent intention of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：指定されたリソースのリクエストでMeterヘッダーを送信していないため、レスポンスでMeterディレクティブを受け入れるように申し出ていないプロキシは、それらを受け入れる必要はありません。この状況で、サーバーがMeterヘッダーを応答で送信する場合、これはプロトコルエラーです。ただし、堅牢性の原則に基づいて、プロキシはMeterヘッダーを暗黙的なリクエストとして解釈して、「Cache-control：s-maxage = 0」を含めることを選択できます。これにより、サーバーの見かけ上の意図が保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy that receives the Meter header in a request may ignore it only to the extent that this is consistent with its own duty to the next-hop server. If the received Meter request header is inconsistent with that duty, or if no Meter request header is received and the response from the next-hop server requests any form of metering or limiting, then the proxy MUST add &#34;Cache-control: s-maxage=0&#34; to any response it forwards for that request. (A proxy SHOULD NOT add or change the Expires header or max-age Cache-control directive.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストでMeterヘッダーを受信するプロキシは、これがネクストホップサーバーに対する自身の義務と一致する範囲でのみ、ヘッダーを無視できます。受信したMeterリクエストヘッダーがその義務と一致しない場合、またはMeterリクエストヘッダーが受信されず、ネクストホップサーバーからの応答が何らかの形式のメータリングまたは制限を要求する場合、プロキシは「Cache-control：s-maxageその要求に対して転送するすべての応答に対して= 0。 （プロキシは、Expiresヘッダーまたはmax-ageキャッシュ制御ディレクティブを追加または変更しないでください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For example, if proxy A receives a GET request from proxy B for URL X with &#34;Connection: Meter&#34;, but proxy A&#39;s cached response for URL does not include any Meter directives, then proxy A may ignore the metering offer from proxy B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
たとえば、プロキシAが「接続：メーター」を含むURL XのプロキシBからGETリクエストを受信したが、URLに対するプロキシAのキャッシュされた応答にメーターディレクティブが含まれていない場合、プロキシAはプロキシBからのメータリングオファーを無視することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
However, if proxy A has previously told the origin server &#34;Meter: wont-limit&#34; (implying will-report), and the cached response contains &#34;Meter: do-report&#34;, and proxy B&#39;s request includes &#34;Meter: wont-report&#34;, then proxy B&#39;s offer is inconsistent with proxy A&#39;s duty to the origin server. Therefore, in this case proxy A must add &#34;Cache-control: s-maxage=0&#34; when it returns the cached response to proxy B, and must not include a Meter header in this response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ただし、プロキシAが以前にオリジンサーバーに「Meter：wont-limit」（will-reportを暗示する）を通知し、キャッシュされた応答に「Meter：do-report」が含まれ、プロキシBのリクエストに「Meter：wont-report」が含まれている場合、その後、プロキシBのオファーは、オリジンサーバーに対するプロキシAの義務と一致しません。したがって、この場合、プロキシAは、キャッシュされた応答をプロキシBに返すときに「Cache-control：s-maxage = 0」を追加する必要があり、この応答にMeterヘッダーを含めてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server does not want to use the Meter mechanism, and will not want to use it any time soon, it may send this directive:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがMeterメカニズムを使用したくなく、すぐに使用したくない場合は、次のディレクティブを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-ask recommends that the proxy SHOULD NOT send any Meter directives to this server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-askは、プロキシーがこのサーバーにMeterディレクティブを送信してはならないことを推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The proxy SHOULD remember this fact for up to 24 hours. This avoids virtually all unnecessary overheads for servers that do not wish to use or support the Meter header. (This directive also implies &#34;dont-report&#34;.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシはこの事実を最大24時間記憶する必要があります（SHOULD）。これにより、Meterヘッダーの使用やサポートを望まないサーバーにとって、実質的にすべての不要なオーバーヘッドが回避されます。 （このディレクティブは、「dont-report」も意味します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 Transmission of usage reports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 使用レポートの送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To transmit a usage report, a proxy sends the following Meter header in a request on the appropriate resource:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用状況レポートを送信するために、プロキシは適切なリソースのリクエストで次のMeterヘッダーを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Meter: count=NNN/MMM
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first integer indicates the count of uses of the cache entry since the last report; the second integer indicates the count of reuses of the entry (see section 5.3 for rules on counting uses and reuses). The transmission of a &#34;count&#34; directive in a request with no other Meter directive is also defined as an implicit transmission of a &#34;will-report-and-limit&#34; directive, to optimize the common case. (A proxy not willing to honor usage-limits would send &#34;Meter: count=NNN/MMM, wont-limit&#34; for its reports.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の整数は、最後のレポート以降のキャッシュエントリの使用回数を示します。 2番目の整数は、エントリの再利用回数を示します（使用回数と再利用回数のカウントに関するルールについては、セクション5.3を参照してください）。他のMeterディレクティブのないリクエストでの「count」ディレクティブの送信は、一般的なケースを最適化するために、「will-report-and-limit」ディレクティブの暗黙的な送信としても定義されます。 （使用制限を守ろうとしないプロキシは、そのレポートに対して「Meter：count = NNN / MMM、wont-limit」を送信します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when a proxy forwards a client&#39;s request and receives a response, the response that the proxy sends immediately to the requesting client is not counted as a &#34;use&#34;. I.e., the reported count is the number of times the cache entry was used, and not the number of times that the response was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシがクライアントの要求を転送して応答を受信した場合、プロキシが要求元のクライアントにすぐに送信する応答は「使用」としてカウントされないことに注意してください。つまり、報告されるカウントは、キャッシュエントリが使用された回数であり、応答が使用された回数ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy SHOULD NOT transmit &#34;Meter: count=0/0&#34;, since this conveys no useful information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは有用な情報を伝えないため、プロキシは「メーター：count = 0/0」を送信しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usage reports MUST always be transmitted as part of a conditional request (such as a GET or HEAD), since the information in the conditional header (e.g., If-Modified-Since or If-None-Match) is required for the origin server to know which instance of a resource is being counted. Proxys forwarding usage reports up the metering subtree MUST NOT change the contents of the conditional header, since otherwise this would result in incorrect counting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
条件付きヘッダー（例：If-Modified-SinceまたはIf-None-Match）の情報はオリジンサーバーが要求するため、使用状況レポートは常に条件付きリクエスト（GETやHEADなど）の一部として送信する必要があります。カウントされているリソースのインスタンスを確認します。使用状況レポートをメータリングサブツリーに転送するプロキシは、条件付きヘッダーの内容を変更してはなりません。変更しないと、正しくカウントされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A usage report MUST NOT be transmitted as part of a forwarded request that includes multiple entity tags in an If-None-Match or If-Match header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用状況レポートは、If-None-MatchまたはIf-Matchヘッダーに複数のエンティティタグを含む転送要求の一部として送信してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: a proxy that offers its willingness to do hit-metering (report usage) must count both uses and reuses. It is not possible to negotiate the reporting of one but not the other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：ヒットメータリング（レポートの使用）を実行する意欲を提供するプロキシは、使用と再利用の両方をカウントする必要があります。一方の報告について交渉することはできませんが、もう一方については交渉できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5 When to send usage reports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5 使用状況レポートを送信するタイミング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy that has offered to send usage reports to its parent in the metering subtree MUST send a usage report in each of these situations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用状況レポートをメータリングサブツリーの親に送信することを提案したプロキシは、次の各状況で使用状況レポートを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. When it forwards a conditional GET on the resource instance on behalf of one of its clients (if the GET is conditional on at most one entity-tag).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. クライアントの1つに代わってリソースインスタンスで条件付きGETを転送するとき（GETが最大で1つのエンティティタグで条件付きの場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. When it forwards a conditional HEAD on the resource instance on behalf of one of its clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. クライアントの1つに代わってリソースインスタンスで条件付きHEADを転送するとき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. When it must generate a conditional GET to satisfy a client request because the max-uses limit has been exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. max-uses制限を超えたため、クライアント要求を満たすために条件付きGETを生成する必要がある場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. Upon expiration of a metering timeout associated with a cache entry that has a non-zero hit-count.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. ゼロ以外のヒットカウントを持つキャッシュエントリに関連付けられたメータリングタイムアウトの満了時。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5. When it removes the corresponding non-zero hit-count entry from its storage for any reason including:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5. 次のような理由で、対応するゼロ以外のヒットカウントエントリをストレージから削除する場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
- the proxy needs the storage space for another hit-count entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
- プロキシには、別のヒットカウントエントリ用のストレージスペースが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
- the proxy is not able to store more than one response per resource, and a request forwarded on behalf of a client has resulted in the receipt of a new response (one with a different entity-tag or last-modified time).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
- プロキシはリソースごとに複数の応答を保存することができず、クライアントに代わって転送された要求が新しい応答（異なるエンティティタグまたは最終変更時刻を持つ応答）の受信をもたらしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Note that a cache might continue to store hit-count information even after having deleted the body of the response, so it is not necessary to report the hit-count when deleting the body; it is only necessary to report it if the proxy is about to &#34;forget&#34; a non-zero value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
キャッシュは、応答の本文を削除した後もヒットカウント情報を保存し続ける場合があるため、本文を削除するときにヒットカウントを報告する必要はありません。プロキシがゼロ以外の値を「忘れる」場合にのみ報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Section 5.3 explains how hit-counts become zero or non-zero.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（セクション5.3では、ヒットカウントがゼロまたは非ゼロになる方法を説明しています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the usage report is being sent because the proxy is about to remove the hit-count entry from its storage, or because of an expired metering timeout:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシがヒットカウントエントリをストレージから削除しようとしているため、またはメータリングタイムアウトの期限が切れているために使用状況レポートが送信されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The proxy MUST send the report as part of a conditional HEAD request on the resource instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- プロキシは、リソースインスタンスの条件付きHEADリクエストの一部としてレポートを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The proxy is not required to retry the HEAD request if it fails (this is a best-efforts design). To improve accuracy, however, the proxy SHOULD retry failed HEAD requests, subject to resource constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- プロキシは、HEADリクエストが失敗した場合に再試行する必要はありません（これはベストエフォート型の設計です）。ただし、精度を向上させるために、リソースの制約に従い、プロキシは失敗したHEADリクエストを再試行する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The proxy is not required to serialize any other operation on the completion of this request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- プロキシは、この要求の完了時に他の操作をシリアル化する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: proxy implementors are strongly encouraged to batch several HEAD-based reports to the same server, when possible, over a single persistent connection, to reduce network overhead as much as possible. This may involve a non-naive algorithm for scheduling the deletion of hit-count entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：プロキシの実装者は、可能な場合は単一の永続的な接続を介して同じサーバーにいくつかのHEADベースのレポートをバッチ処理して、ネットワークのオーバーヘッドをできるだけ減らすことを強くお勧めします。これには、ヒットカウントエントリの削除をスケジュールするための単純でないアルゴリズムが含まれる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the usage count is sent because of an arriving request that also carries a &#34;count&#34; directive, the proxy MUST combine its own (possibly zero) use and reuse counts with the arriving counts, and then attempt to forward the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「count」ディレクティブも運ぶ到着リクエストが原因で使用カウントが送信された場合、プロキシは自身の（場合によってはゼロ）使用カウントと再利用カウントを到着カウントと組み合わせてから、リクエストの転送を試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the proxy is not required to forward an arriving request with a &#34;count&#34; directive, provided that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、次の条件が満たされていれば、プロキシは「count」ディレクティブで到着リクエストを転送する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- it can reply to the request using a cached response, in compliance with other requirements of the HTTP specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- HTTP仕様の他の要件に準拠して、キャッシュされた応答を使用して要求に応答できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- such a response does not exceed a max-uses limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- このような応答は、最大使用数の制限を超えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- it is not required to forward the request because of an expired metering timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 計測タイムアウトの期限が切れているため、要求を転送する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an arriving request carries a &#34;count&#34; directive, and the proxy no longer has a cache entry for the resource, the proxy MUST forward the &#34;count&#34; directive. (This is, in any case, what a proxy without a suitable cache entry would normally do for any valid request it receives.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
到着するリクエストが「count」ディレクティブを運び、プロキシがリソースのキャッシュエントリをもう持たない場合、プロキシは「count」ディレクティブを転送する必要があります。 （これは、いずれにしても、適切なキャッシュエントリのないプロキシが受信する有効なリクエストに対して通常行うことです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6 Subdivision of usage-limits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6 使用制限の細分化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an origin server specifies a usage limit, a proxy in the metering subtree may subdivide this limit among its children in the subtree as it sees fit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オリジンサーバーが使用制限を指定すると、メータリングサブツリーのプロキシは、サブツリーの子にこの制限を適切に分割します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider the situation with two proxies P1 and P2, each of which uses proxy P3 as a way to reach origin server S. Imagine that S sends P3 a response with
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、2つのプロキシP1とP2があり、それぞれがオリジンサーバーSに到達する方法としてプロキシP3を使用している状況を考えてみます。SがP3に次の応答を送信するとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Meter: max-uses=10
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
メーター：max-uses = 10
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The proxies use that response to satisfy the current requesting end-client. The max-uses directive in this example allows the combination of P1, P2, and P3 together to satisfy 10 additional end-client uses (unconditional GETs) for the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシはその応答を使用して、現在要求しているエンドクライアントを満たします。この例のmax-usesディレクティブを使用すると、P1、P2、およびP3を組み合わせて、リソースの10の追加のエンドクライアント使用（無条件GET）を満たすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification does not constrain how P3 divides up that allocation among itself and the other proxies. For example, P3 could retain all of max-use allocation for itself. In that case, it would forward the response to P1 and/or P2 with
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、P3が自身と他のプロキシの間でその割り当てを分割する方法を制限しません。たとえば、P3はそれ自体のすべてのmax-use割り当てを保持できます。その場合、応答をP1またはP2、あるいはその両方に転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Meter: max-uses=0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
メーター：max-uses = 0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P3 might also divide the allocation equally among P1 and P2, retaining none for itself (which may be the right choice if P3 has few or no other clients). In this case, it could send
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P3は、割り当てをP1とP2の間で均等に分割し、それ自体は何も保持しない場合があります（P3に他のクライアントがほとんどまたはまったくない場合、これは正しい選択です）。この場合、それは送ることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Meter: max-uses=5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
メーター：max-uses = 5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
to the proxy (P1 or P2) that made the initial request, and then record in some internal data structure that it &#34;owes&#34; the other proxy the rest of the allocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のリクエストを行ったプロキシ（P1またはP2）に送信し、他のプロキシに残りの割り当てを「負っている」ことを内部データ構造に記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this freedom to choose the max-uses value applies to the origin server, as well. There is no requirement that an origin server send the same max-uses value to all caches. For example, it might make sense to send &#34;max-uses=2&#34; the first time one hears from a cache, and then double the value (up to some maximum limit) each time one gets a &#34;use-count&#34; from that cache. The idea is that the faster a cache is using up its max-use quota, the more likely it will be to report a use-count value before removing the cache entry. Also, high and frequent use-counts imply a corresponding high efficiency benefit from allowing caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-uses値を選択するこの自由度は、配信元サーバーにも適用されることに注意してください。オリジンサーバーがすべてのキャッシュに同じmax-uses値を送信する必要はありません。たとえば、最初にキャッシュから聞いたときに「max-uses = 2」を送信し、次にそのキャッシュから「use-count」を取得するたびに値を2倍にする（最大制限まで） 。キャッシュがmax-use割り当てを使い切る速度が速いほど、キャッシュエントリを削除する前に使用カウント値を報告する可能性が高くなるという考えです。また、使用回数が多く頻繁であることは、キャッシングを許可することによる、対応する高効率の利点を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Again, the details of such heuristics would be outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合も、このようなヒューリスティックの詳細は、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4 Analysis
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section includes informal analyses of several aspects of hit-metering:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、ヒットメータリングのいくつかの側面の非公式分析が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. the accuracy of results when applied to counting users (section 4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. ユーザーのカウントに適用した場合の結果の精度（セクション4.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. the problem of counting users whose browsers do not include caches, such as Network Computers (section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. ネットワークコンピュータなどのブラウザにキャッシュが含まれていないユーザーをカウントする問題（セクション4.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. delays imposed on &#34;critical paths&#34; for HTTP operations (section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. HTTP操作の「クリティカルパス」に課される遅延（セクション4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 Approximation accuracy for counting users
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 ユーザーをカウントするための近似精度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For many (but not all) service operators, the single most important aspect of the request stream is the number of distinct users who have retrieved a particular entity within a given period (e.g., during a given day). The hit-metering mechanism is designed to provide an origin server with an approximation of the number of users that reference a given resource. The intent of the design is that the precision of this approximation is consistent with the goals of simplicity and optional implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの（すべてではない）サービスオペレーターにとって、リクエストストリームの最も重要な側面は、特定のエンティティを特定の期間（たとえば、特定の日）に取得した個別のユーザーの数です。ヒットメータリングメカニズムは、特定のリソースを参照するユーザーの概数をオリジンサーバーに提供するように設計されています。設計の目的は、この近似の精度が単純さとオプションの実装の目標と一致していることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Almost all Web users use client software that maintains local caches, and the state of the art of local-caching technology is quite effective. (Section 4.2 discusses the case where end-client caches are small or non-existent.) Therefore, assuming an effective and persistent end-client cache, each individual user who retrieves an entity does exactly one GET request that results in a 200 or 203 response, or a 206 response that includes the first byte of the entity. If a proxy cache maintains and reports an accurate use-count of such retrievals, then its reported use-count will closely approximate the number of distinct users who have retrieved the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどすべてのWebユーザーがローカルキャッシュを維持するクライアントソフトウェアを使用しており、最新のローカルキャッシュテクノロジは非常に効果的です。 （セクション4.2では、エンドクライアントキャッシュが小さいか存在しない場合について説明します。）したがって、効果的で永続的なエンドクライアントキャッシュを想定して、エンティティを取得する個々のユーザーは、1つずつGETリクエストを実行し、結果として200または203になります。応答、またはエンティティの最初のバイトを含む206応答。プロキシキャッシュがそのような取得の正確な使用数を維持および報告する場合、報告された使用数は、エンティティを取得した個別のユーザーの数とほぼ同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are some circumstances under which this approximation can break down. For example, if an entity stays in a proxy cache for much longer than it persists in the typical client cache, and users often re-reference the entity, then this scheme will tend to over-count the number of users. Or, if the cache-management policy implemented in typical client caches is biased against retaining certain kinds of frequently re-referenced entities (such as very large images), the use-counts reported will tend to overestimate the user-counts for such entities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この近似が失敗する状況がいくつかあります。たとえば、エンティティが通常のクライアントキャッシュに保持されるよりもはるかに長い間プロキシキャッシュにとどまり、ユーザーがエンティティを再参照することが多い場合、このスキームはユーザー数を過大にカウントする傾向があります。または、一般的なクライアントキャッシュに実装されたキャッシュ管理ポリシーが、頻繁に再参照される特定の種類のエンティティ（非常に大きな画像など）を保持しないように偏っている場合、報告される使用数は、そのようなエンティティのユーザー数を過大評価する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Browser log analysis has shown that when a user revisits a resource, this is almost always done very soon after the previous visit, almost always with fewer than eight intervening references [11]. Although this result might not apply universally, it implies that almost all reuses will hit in the end-client cache, and will not be seen as unconditional GETs by a proxy cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブラウザのログ分析では、ユーザーがリソースに再度アクセスすると、ほとんどの場合、前回のアクセスの直後に行われ、ほとんどの場合、中間参照が8つ未満であることが示されています[11]。この結果は普遍的には適用されない可能性がありますが、ほとんどすべての再利用がエンドクライアントキャッシュでヒットし、プロキシキャッシュによる無条件GETと見なされないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The existing (HTTP/1.0) &#34;cache-busting&#34; mechanisms for counting distinct users will certainly overestimate the number of users behind a proxy, since it provides no reliable way to distinguish between a user&#39;s initial request and subsequent repeat requests that might have been conditional GETs, had not cache-busting been employed. The
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個別のユーザーをカウントするための既存の（HTTP / 1.0）「キャッシュ無効化」メカニズムは、プロキシの背後にあるユーザー数を確実に過大評価します。これは、ユーザーの最初のリクエストと条件付きである可能性のある後続の繰り返しリクエストを区別する信頼できる方法がないためです。 GETは、キャッシュ無効化が採用されていませんでした。の
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Cache-control: s-maxage=0&#34; feature of HTTP/1.1 does allow the separation of use-counts and reuse-counts, provided that no HTTP/1.0 proxy caches intervene.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 1.1の「キャッシュ制御：s-maxage = 0」機能では、HTTP / 1.0プロキシキャッシュが介入しない限り、使用回数と再利用回数を分離できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if there is doubt about the validity of the results of hit-metering a given set of resources, the server can employ cache-busting techniques for short periods, to establish a baseline for validating the hit-metering results. Various approaches to this problem are discussed in a paper by James Pitkow [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のリソースセットのヒットメータリングの結果の妥当性に疑問がある場合、サーバーはキャッシュバースト手法を短期間使用して、ヒットメータリングの結果を検証するためのベースラインを確立できます。この問題に対するさまざまなアプローチは、James Pitkowによる論文[9]で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 What about &#34;Network Computers&#34;?
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 「ネットワークコンピュータ」はどうですか？
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The analysis in section 4.1 assumed that &#34;almost all Web users&#34; have client caches. If the Network Computers (NC) model becomes popular, however, then this assumption may be faulty: most proposed NCs have no disk storage, and relatively little RAM. Many Personal Digital Assistants (PDAs), which sometimes have network access, have similar constraints. Such client systems may do little or no caching of HTTP responses. This means that a single user might well generate many unconditional GETs that yield the same response from a proxy cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.1の分析では、「ほぼすべてのWebユーザー」がクライアントキャッシュを持っていると想定しています。ただし、ネットワークコンピューター（NC）モデルが一般的になると、この仮定は誤りになる可能性があります。ほとんどの提案されたNCにはディスクストレージがなく、RAMが比較的少ないです。多くの携帯情報端末（PDA）は、ネットワークにアクセスできる場合があり、同様の制約があります。このようなクライアントシステムは、HTTP応答のキャッシングをほとんどまたはまったく行わない場合があります。つまり、1人のユーザーが、プロキシキャッシュから同じ応答を返す無条件GETを多数生成する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First note that the hit-metering design in this document, even with such clients, provides an approximation no worse than available with unmodified HTTP/1.1: the counts that a proxy would return to an origin server would represent exactly the number of requests that the proxy would forward to the server, if the server simply specifies &#34;Cache-control: s-maxage=0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのヒットメータリングの設計は、そのようなクライアントであっても、変更されていないHTTP / 1.1で利用可能なものより劣らない概算を提供することに注意してください。プロキシがオリジンサーバーに返すカウントは、リクエストの数を正確に表します。サーバーが単に「Cache-control：s-maxage = 0」と指定した場合、プロキシはサーバーに転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, it may be possible to improve the accuracy of these hit-counts by use of some heuristics at the proxy. For example, the proxy might note the IP address of the client, and count only one GET per client address per response. This is not perfect: for example, it fails to distinguish between NCs and certain other kinds of hosts. The proxy might also use the heuristic that only those clients that never send a conditional GET should be treated this way, although we are not at all certain that NCs will never send conditional GETs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、プロキシでいくつかのヒューリスティックを使用することにより、これらのヒットカウントの精度を向上させることができる場合があります。たとえば、プロキシはクライアントのIPアドレスを記録し、応答ごとにクライアントアドレスごとに1つのGETのみをカウントする場合があります。これは完璧ではありません。たとえば、NCと他の特定の種類のホストを区別できません。プロキシはまた、条件付きGETを送信しないクライアントのみがこのように扱われるべきであるというヒューリスティックを使用する場合がありますが、NCが条件付きGETを送信しないことはまったく確実ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the solution to this problem appears to require heuristics based on the actual behavior of NCs (or perhaps a new HTTP protocol feature that allows unambiguous detection of cacheless clients), it appears to be premature to specify a solution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題の解決策は、NCの実際の動作に基づくヒューリスティック（またはおそらくキャッシュレスクライアントの明確な検出を可能にする新しいHTTPプロトコル機能）を必要とするため、解決策を指定するのは時期尚早のようです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 Critical-path delay analysis
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 クリティカルパス遅延分析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In systems (such as the Web) where latency is at issue, there is usually a tree of steps which depend on one another, in such a way that the final result cannot be accomplished until all of its predecessors have been. Since the tree structure admits some parallelism, it is not necessary to add up the timings for each step to discover the latency for the entire process. But any single path through this dependency tree cannot be parallelized, and the longest such path is the one whose length (in units of seconds) determines the overall latency. This is the &#34;critical path&#34;, because no matter how much shorter one makes any other path, that cannot change the overall latency for the final result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
レイテンシが問題となっているシステム（Webなど）では、通常、相互に依存するステップのツリーが存在し、すべての先行バージョンが完了するまで最終結果を達成することができません。ツリー構造は並列処理を許可しているため、プロセス全体のレイテンシを検出するために各ステップのタイミングを合計する必要はありません。ただし、この依存関係ツリーを経由する単一のパスは並列化できません。そのようなパスの中で最長のパスが、全体の長さ（秒単位）によって待ち時間を決定します。これは「クリティカルパス」です。他のパスをどれだけ短くしても、最終結果の全体的なレイテンシを変更することはできないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If one views the final result, for a Web request, as rendering a page at a browser, or otherwise acting on the result of a request, clearly some network round trips (e.g., exchanging TCP SYN packets if the connection doesn&#39;t already exist) are on the critical path. This hit-metering design does add some round-trips for reporting non-zero counts when a cache entry is removed, but, by design, these are off any critical path: they may be done in parallel with any other operation, and require only &#34;best efforts&#34;, so a proxy does not have to serialize other operations with their success or failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Webリクエストの最終結果をブラウザでページをレンダリングするか、またはリクエストの結果に基づいて処理する場合、明らかに一部のネットワークラウンドトリップ（たとえば、接続がまだ存在しない場合はTCP SYNパケットの交換） ）はクリティカルパス上にあります。このヒットメータリング設計では、キャッシュエントリが削除されたときにゼロ以外のカウントを報告するための往復が追加されますが、設計上、これらはクリティカルパスから外れています。これらは他の操作と並行して実行され、必要なのは「ベストエフォート」。プロキシは、成功または失敗した他の操作をシリアル化する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clearly, anything that changes network utilization (either increasing or decreasing it) can indirectly affect user-perceived latency. Our expectation is that hit-metering, on average, will reduce loading and so even its indirect effects should not add network round-trips in any critical path. But there might be a few specific instances where the added non-critical-path operations (specifically, usage reports upon cache-entry removal) delay an operation on a critical path. This is an unavoidable problem in datagram networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明らかに、ネットワーク使用率を変更する（ネットワークの増加または減少のいずれか）ことは、ユーザーが感じる遅延に間接的に影響を与える可能性があります。私たちの期待は、平均してヒットメータリングによって負荷が軽減されるため、その間接的な影響でさえ、クリティカルパスにネットワークラウンドトリップが追加されるべきではないということです。ただし、追加の非クリティカルパス操作（具体的には、キャッシュエントリの削除時の使用状況レポート）がクリティカルパスでの操作を遅らせる特定のインスタンスがいくつかある場合があります。これは、データグラムネットワークでは避けられない問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
5 Specification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
5仕様
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 Specification of Meter header and directives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 Meterヘッダーとディレクティブの仕様
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Meter general-header field is used to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meter一般ヘッダーフィールドは、次の目的で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Negotiate the use of hit-metering and usage-limiting among origin servers and proxy caches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- オリジンサーバーとプロキシキャッシュ間でのヒットメータリングと使用制限の使用について交渉します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Report use counts and reuse counts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- レポートの使用数と再利用数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation of the Meter header is optional for both proxies and origin servers. However, any proxy that transmits the Meter header in a request MUST implement every requirement of this specification, without exception or amendment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterヘッダーの実装は、プロキシとオリジンサーバーの両方でオプションです。ただし、リクエストでMeterヘッダーを送信するプロキシは、例外や修正なしに、この仕様のすべての要件を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The Meter header MUST always be protected by a Connection header. A proxy that does not implement the Meter header MUST NOT pass it through to another system (see section 5.5 for how a non-caching proxy may comply with this specification). If a Meter header is received in a message whose version is less than HTTP/1.1, it MUST be ignored (because it has clearly flowed through a proxy that does not implement Meter).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Meterヘッダーは常にConnectionヘッダーで保護する必要があります。 Meterヘッダーを実装しないプロキシは、それを別のシステムにパススルーしてはなりません（非キャッシュプロキシがこの仕様に準拠する方法については、セクション5.5を参照してください）。 HTTP / 1.1より前のバージョンのメッセージでMeterヘッダーが受信された場合は、それを無視する必要があります（Meterを実装していないプロキシを介して明確にフローされているため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy that has received a response with a version less than HTTP/1.1, and therefore from a server (or another proxy) that does not implement the Meter header, SHOULD NOT send Meter request directives to that server, because these would simply waste bandwidth. This recommendation does not apply if the proxy is currently hit-metering or usage-limiting any responses from that server. If the proxy receives a HTTP/1.1 or higher response from such a server, it should cease its suppression of the Meter directives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 1.1より前のバージョンの応答を受け取ったため、Meterヘッダーを実装していないサーバー（または別のプロキシ）からのプロキシは、帯域幅を浪費するだけなので、Meter要求ディレクティブをそのサーバーに送信しないでください。 。この推奨事項は、プロキシが現在サーバーからの応答をヒットメータリングまたは使用制限している場合には適用されません。プロキシがこのようなサーバーからHTTP / 1.1以上の応答を受信した場合、メーターディレクティブの抑制を停止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All proxies sending the Meter header MUST adhere to the &#34;metering subtree&#34; design described in section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterヘッダーを送信するすべてのプロキシは、セクション3で説明されている「メータリングサブツリー」の設計に準拠する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Meter = &#34;Meter&#34; &#34;:&#34; 0#meter-directive
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
meter-directive = meter-request-directive | meter-response-directive | meter-report-directive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
meter-directive = meter-request-directive | meter-response-directive | meter-report-directive
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
meter-request-directive = &#34;will-report-and-limit&#34; | &#34;wont-report&#34; | &#34;wont-limit&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
meter-request-directive = &#34;will-report-and-limit&#34; | 「不報告」| 「制限なし」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       meter-report-directive =
                       | &#34;count&#34; &#34;=&#34; 1*DIGIT &#34;/&#34; 1*DIGIT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       meter-response-directive =
                         &#34;max-uses&#34; &#34;=&#34; 1*DIGIT
                       | &#34;max-reuses&#34; &#34;=&#34; 1*DIGIT
                       | &#34;do-report&#34;
                       | &#34;dont-report&#34;
                       | &#34;timeout&#34; &#34;=&#34; 1*DIGIT
                       | &#34;wont-ask&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A meter-request-directive or meter-report-directive may only appear in an HTTP request message. A meter-response-directive may only appear in an HTTP response directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
meter-request-directiveまたはmeter-report-directiveは、HTTPリクエストメッセージにのみ表示されます。 meter-response-directiveは、HTTP応答ディレクティブでのみ使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An empty Meter header in a request means &#34;Meter: will-report-and-limit&#34;. An empty Meter header in a response, or any other response including one or more Meter headers without the &#34;dont-report&#34; or &#34;wont-ask&#34; directive, implies &#34;Meter: do-report&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストの空のMeterヘッダーは、「Meter：will-report-and-limit」を意味します。応答の空のMeterヘッダー、または「dont-report」または「wont-ask」ディレクティブのない1つ以上のMeterヘッダーを含むその他の応答は、「Meter：do-report」を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of the meter-request-directives are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
meter-request-directivesの意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
will-report-and-limit indicates that the proxy is willing and able to return usage reports and will obey any usage-limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
will-report-and-limitは、プロキシが使用状況レポートを返す意志があり、それを返すことができることを示し、すべての使用制限に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-report indicates that the proxy will obey usage-limits but will not send usage reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-reportは、プロキシが使用制限に従いますが、使用レポートを送信しないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-limit indicates that the proxy will not obey usage-limits but will send usage reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-limitは、プロキシが使用制限に従わないが、使用状況レポートを送信することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy willing neither to obey usage-limits nor to send usage reports MUST NOT transmit a Meter header in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用制限に従うことも使用レポートを送信することもしないプロキシは、リクエストでMeterヘッダーを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of the meter-report-directives are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
meter-report-directivesの意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
count &#34;=&#34; 1*DIGIT &#34;/&#34; 1*DIGIT Both digit strings encode decimal integers. The first integer indicates the count of uses of the cache entry since the last report; the second integer indicates the count of reuses of the entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
count &#34;=&#34; 1 * DIGIT &#34;/&#34; 1 * DIGIT両方の数字列が10進整数をエンコードします。最初の整数は、最後のレポート以降のキャッシュエントリの使用回数を示します。 2番目の整数は、エントリの再利用回数を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 5.3 specifies the counting rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.3では、カウントルールを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of the meter-response-directives are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
meter-response-directivesの意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-uses &#34;=&#34; 1*DIGIT sets an upper limit on the number of &#34;uses&#34; of the response, not counting its immediate forwarding to the requesting end-client, for all proxies in the following subtree taken together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-uses &#34;=&#34; 1 * DIGITは、次のサブツリー内のすべてのプロキシをまとめて、応答の &#34;uses&#34;の数に上限を設定し、要求側のエンドクライアントへの即時転送をカウントしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-reuses &#34;=&#34; 1*DIGIT sets an upper limit on the number of &#34;reuses&#34; of the response for all proxies in the following subtree taken together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-reuses &#34;=&#34; 1 * DIGITは、次のサブツリー内のすべてのプロキシをまとめて、応答の「再利用」の数に上限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
do-report specifies that the proxy MUST send usage reports to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
do-reportは、プロキシが使用状況レポートをサーバーに送信する必要があることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dont-report specifies that the proxy SHOULD NOT send usage reports to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dont-reportは、プロキシが使用状況レポートをサーバーに送信してはならない（SHOULD NOT）ことを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 timeout &#34;=&#34; 1*DIGIT sets a metering timeout of the specified number of minutes (not seconds) after the origination of this response (as indicated by its &#34;Date&#34; header). If the proxy has a non-zero hit count for this response when the timeout expires, it MUST send a report to the server at or before that time. Timeouts should be implemented with an accuracy of plus or minus one minute. Implies &#34;do-report&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
timeout &#34;=&#34; 1 * DIGITは、（ &#34;Date&#34;ヘッダーで示されるように）この応答の発生後、指定された分数（秒ではなく）の計測タイムアウトを設定します。タイムアウトの期限が切れたときに、プロキシがこの応答のゼロ以外のヒットカウントを持っている場合、プロキシはその時刻以前にサーバーにレポートを送信する必要があります。タイムアウトは、プラスまたはマイナス1分の精度で実装する必要があります。 「do-report」を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-ask specifies that the proxy SHOULD NOT send any Meter headers to the server. The proxy should forget this advice after a period of no more than 24 hours.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wont-askは、プロキシーがサーバーにMeterヘッダーを送信してはならないことを指定します。プロキシは、24時間以内にこのアドバイスを忘れるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 5.3 specifies the counting rules, and in particular specifies a somewhat non-obvious interpretation of the max-uses value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.3は、カウントルールを指定し、特にmax-uses値の多少明白でない解釈を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Abbreviations for Meter directives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Meterディレクティブの略語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To allow for the most efficient possible encoding of Meter headers, we define abbreviated forms of all Meter directives. These are exactly semantically equivalent to their non-abbreviated counterparts. All systems implementing the Meter header MUST implement both the abbreviated and non-abbreviated forms. Implementations SHOULD use the abbreviated forms in normal use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterヘッダーの可能な限り最も効率的なエンコーディングを可能にするために、すべてのMeterディレクティブの省略形を定義します。これらは、意味的には省略されていないものとまったく同じです。 Meterヘッダーを実装するすべてのシステムは、省略形と非省略形の両方を実装する必要があります。実装では、通常の使用では省略形を使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The abbreviated forms of Meter directive are shown below, with the corresponding non-abbreviated literals in the comments:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterディレクティブの省略形を以下に示します。対応する非省略リテラルがコメントにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Abb-Meter = &#34;Meter&#34; &#34;:&#34; 0#abb-meter-directive
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
abb-meter-directive = abb-meter-request-directive | abb-meter-response-directive | abb-meter-report-directive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
abb-meter-directive = abb-meter-request-directive | abb-meter-response-directive | abb-meter-report-directive
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
abb-meter-request-directive = &#34;w&#34; ; &#34;will-report-and-limit&#34; | &#34;x&#34; ; &#34;wont-report&#34; | &#34;y&#34; ; &#34;wont-limit&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
abb-meter-request-directive = &#34;w&#34;; 「意志報告と制限」| &#34;バツ&#34; ; 「不報告」| &#34;y&#34;; 「制限なし」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       abb-meter-report-directive =
                       | &#34;c&#34; &#34;=&#34; 1*DIGIT &#34;/&#34; 1*DIGIT   ; &#34;count&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       abb-meter-response-directive =
                         &#34;u&#34; &#34;=&#34; 1*DIGIT       ; &#34;max-uses&#34;
                       | &#34;r&#34; &#34;=&#34; 1*DIGIT       ; &#34;max-reuses&#34;
                       | &#34;d&#34;                   ; &#34;do-report&#34;
                       | &#34;e&#34;                   ; &#34;dont-report&#34;
                       | &#34;t&#34; &#34;=&#34; 1*DIGIT       ; &#34;timeout&#34;
                       | &#34;n&#34;                   ; &#34;wont-ask&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: although the Abb-Meter BNF rule is defined separately from the Meter rule, one may freely mix abbreviated and non-abbreviated Meter directives in the same header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：Abb-Meter BNFルールはMeterルールとは別に定義されていますが、同じヘッダー内で省略形と省略形以外のMeterディレクティブを自由に混在させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 Counting rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 カウント規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: please remember that hit-counts and usage-counts are associated with individual responses, not with resources. A cache entry that, over its lifetime, holds more than one response is also not a &#34;response&#34;, in this particular sense.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：ヒット数と使用数は、リソースではなく個々の応答に関連付けられていることに注意してください。この意味で、存続期間中に複数の応答を保持するキャッシュエントリも、「応答」ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let R be a cached response, and V be the value of the Request-URI and selecting request-headers (if any, see section 14.43 of the HTTP/1.1 specification [4]) that would select R if contained in a request. We define a &#34;use&#34; of R as occurring when the proxy returns its stored copy of R in a response with any of the following status codes: a 200 (OK) status; a 203 (Non-Authoritative Information) status; or a 206 (Partial Content) status when the response contains byte #0 of the entity (see section 5.4 for a discussion of Range requests).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rをキャッシュされた応答とし、VをRequest-URIの値とし、要求に含まれている場合にRを選択する要求ヘッダー（存在する場合は、HTTP / 1.1仕様[4]のセクション14.43を参照）を選択します。 Rの「使用」は、プロキシが格納されたRのコピーを、次のいずれかのステータスコードを含む応答で返すときに発生すると定義します。200（OK）ステータス。 203（非権威情報）ステータス。または、応答にエンティティのバイト＃0が含まれている場合は206（部分コンテンツ）ステータス（範囲要求の説明については、セクション5.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: when a proxy forwards a client&#39;s request and receives a response, the response that the proxy sends immediately to the requesting client is not counted as a &#34;use&#34;. I.e., the reported count is the number of times the cache entry was used, and not the number of times that the response was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：プロキシーがクライアントの要求を転送して応答を受信した場合、プロキシーが要求側クライアントに即時に送信する応答は、「使用」としてカウントされません。つまり、報告されるカウントは、キャッシュエントリが使用された回数であり、応答が使用された回数ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We define a &#34;reuse&#34; of R as as occurring when the proxy responds to a request selecting R with a 304 (Not Modified) status, unless that request is a Range request that does not specify byte #0 of the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストがエンティティのバイト＃0を指定しない範囲リクエストでない限り、Rの「再利用」は、プロキシが304（Not Modified）ステータスでRを選択するリクエストに応答するときに発生すると定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1 Counting rules for hit-metering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1 ヒットメータリングのカウントルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy participating in hit-metering for a cache response R maintains two counters, CU and CR, associated with R. When a proxy first stores R in its cache, it sets both CU and CR to 0 (zero). When a subsequent client request results in a &#34;use&#34; of R, the proxy increments CU. When a subsequent client request results in a &#34;reuse&#34; of R, the proxy increments CR. When a subsequent client request selecting R (i.e., including V) includes a &#34;count&#34; Meter directive, the proxy increments CU and CR using the corresponding values in the directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュレスポンスRのヒットメータリングに参加しているプロキシは、Rに関連付けられたCUとCRの2つのカウンターを維持します。プロキシが最初にRをキャッシュに保存すると、CUとCRの両方が0（ゼロ）に設定されます。後続のクライアント要求の結果、Rが「使用」されると、プロキシはCUをインクリメントします。後続のクライアント要求の結果、Rが「再利用」されると、プロキシはCRを増分します。 Rを選択する後続のクライアント要求（Vを含む）に「カウント」メーターディレクティブが含まれている場合、プロキシはディレクティブの対応する値を使用してCUおよびCRをインクリメントします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the proxy sends a request selecting R (i.e., including V) to the inbound server, it includes a &#34;count&#34; Meter directive with the current CU and CR as the parameter values. If this request was caused by the proxy&#39;s receipt of a request from a client, upon receipt of the server&#39;s response, the proxy sets CU and CR to the number of uses and reuses, respectively, that may have occurred while the request was in progress. (These numbers are likely, but not certain, to be zero.) If the proxy&#39;s request was a final HEAD-based report, it need no longer maintain the CU and CR values, but it may also set them to the number of intervening uses and reuses and retain them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
プロキシがR（Vを含む）を選択するリクエストをインバウンドサーバーに送信すると、現在のCUおよびCRをパラメーター値として持つ「カウント」メーターディレクティブが含まれます。この要求がクライアントからのプロキシの要求の受信によって引き起こされた場合、サーバーの応答を受信すると、プロキシはCUとCRをそれぞれ、要求の進行中に発生した使用と再利用の数に設定します。 （これらの数値はゼロになる可能性がありますが、確実ではありません。）プロキシーの要求が最終的なHEADベースのレポートである場合、CUおよびCRの値を維持する必要はありませんが、介在する使用の数に設定することもできます。そしてそれらを再利用して保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2 Counting rules for usage-limiting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2 使用制限のカウント規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy participating in usage-limiting for a response R maintains either or both of two counters TU and TR, as appropriate, for that resource. TU and TR are incremented in just the same way as CU and CR, respectively. However, TU is zeroed only upon receipt of a &#34;max-uses&#34; Meter directive for that response (including the initial receipt). Similarly, TR is zeroed only upon receipt of a &#34;max-reuses&#34; Meter directive for that response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答Rの使用制限に参加しているプロキシは、必要に応じて、そのリソースの2つのカウンターTUおよびTRのいずれかまたは両方を維持します。 TUとTRは、それぞれCUとCRと同じ方法で増分されます。ただし、TUがゼロになるのは、その応答の「max-uses」メーターディレクティブを受信したときのみです（最初の受信を含む）。同様に、TRは、その応答に対する &#34;max-reuses&#34; Meterディレクティブを受信したときにのみゼロになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy participating in usage-limiting for a response R also stores values MU and/or MR associated with R. When it receives a response including only a max-uses value, it sets MU to that value and MR to infinity. When it receives a response including only a max-reuses value, it sets MR to that value and MU to infinity. When it receives a response including both max-reuses and max-reuses values, it sets MU and MR to those values, respectively. When it receives a subsequent response including neither max-reuses nor max-reuses values, it sets both MU and MR to infinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答Rの使用制限に参加しているプロキシは、Rに関連付けられた値MUおよび/またはMRも格納します。最大使用値のみを含む応答を受信すると、MUをその値に設定し、MRを無限大に設定します。 max-reuses値のみを含む応答を受信すると、MRをその値に、MUを無限大に設定します。 max-reusesとmax-reusesの両方の値を含む応答を受信すると、MUとMRをそれぞれこれらの値に設定します。 max-reuses値もmax-reuses値も含まない後続の応答を受信すると、MUとMRの両方が無限大に設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a proxy participating in usage-limiting for a response R receives a request that would cause a &#34;use&#34; of R, and TU &gt;= MU, it MUST forward the request to the server. If it receives a request that would cause a &#34;reuse&#34; of R, and TR &gt;= MR, it MUST forward the request to the server. If (in either case) the proxy has already forwarded a previous request to the server and is waiting for the response, it should delay further handling of the new request until the response arrives (or times out); it SHOULD NOT have two revalidation requests pending at once that select the same response, unless these are Range requests selecting different subranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答Rの使用制限に参加しているプロキシが、Rの「使用」を引き起こす要求、およびTU&gt; = MUを受信した場合、要求をサーバーに転送する必要があります。 Rの「再利用」の原因となる要求を受信し、TR&gt; = MRである場合、要求をサーバーに転送する必要があります。 （どちらの場合でも）プロキシが前の要求をサーバーにすでに転送し、応答を待っている場合、応答が到着する（またはタイムアウトする）まで、新しい要求の処理を遅らせる必要があります。異なるサブレンジを選択するRangeリクエストでない限り、同じレスポンスを選択する2つの保留中の再検証リクエストを同時に保留しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a special case of this rule for the &#34;max-uses&#34; directive: if the proxy receives a response with &#34;max-uses=0&#34; and does not forward it to a requesting client, the proxy should set a flag PF associated with R. If R is true, then when a request arrives while if TU &gt;= MU, if the PF flag is set, then the request need not be forwarded to the server (provided that this is not required by other caching rules). However, the PF flag MUST be cleared on any use of the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「max-uses」ディレクティブには、このルールの特殊なケースがあります。プロキシが「max-uses = 0」で応答を受信し、それを要求元のクライアントに転送しない場合、プロキシは、関連するフラグPFを設定する必要があります。 R. Rがtrueの場合、要求が到着したときにTU&gt; = MUの場合、PFフラグが設定されていれば、要求をサーバーに転送する必要はありません（これが他のキャッシングルールで要求されていない場合）。ただし、PFフラグは、応答の使用時にクリアする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: the &#34;PF&#34; flag is so named because this feature is useful only for caches that could issue a &#34;prefetch&#34; request before an actual client request for the response. A proxy not implementing prefetching need not implement the PF flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：この機能は、実際のクライアントが応答を要求する前に「プリフェッチ」要求を発行できるキャッシュに対してのみ役立つため、「PF」フラグはそう呼ばれています。プリフェッチを実装しないプロキシは、PFフラグを実装する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.3 Equivalent algorithms are allowed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.3 同等のアルゴリズムが許可されています
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any other algorithm that exhibits the same external behavior (i.e., generates exactly the same requests from the proxy to the server) as the one in this section is explicitly allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションのアルゴリズムと同じ外部動作を示す（つまり、プロキシからサーバーへのまったく同じ要求を生成する）他のアルゴリズムは、明示的に許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: in most cases, TU will be equal to CU, and TR will be equal to CR. The only two cases where they could differ are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：ほとんどの場合、TUはCUと等しく、TRはCRと等しくなります。異なる可能性があるのは、次の2つの場合のみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
1. The proxy issues a non-conditional request for the resource using V, while TU and/or TR are non-zero, and the server&#39;s response includes a new &#34;max-uses&#34; and/or &#34;max-reuses&#34; directive (thus zeroing TU and/or TR, but not CU and CR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
1. プロキシはVを使用してリソースに対して無条件のリクエストを発行しますが、TUやTRはゼロ以外であり、サーバーの応答には新しい「max-uses」や「max-reuses」ディレクティブが含まれます（したがって、TUをゼロにします）および/またはTR、ただしCUおよびCRは除く）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
2. The proxy issues a conditional request reporting the hit-counts (and thus zeroing CU and CR, but not TU or TR), but the server&#39;s response does not include a new &#34;max-uses&#34; and/or &#34;max-reuses&#34; directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
2. プロキシはヒットカウントを報告する条件付きリクエストを発行します（したがって、CUとCRをゼロにしますが、TUまたはTRはゼロにしません）が、サーバーの応答に新しい「max-uses」または「max-reuses」ディレクティブが含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
To solve the first case, the proxy has several implementation options
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
最初のケースを解決するために、プロキシにはいくつかの実装オプションがあります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
- Always store TU and TR separately from CU and CR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
- TUおよびTRは常にCUおよびCRとは別に保管してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
- Create &#34;shadow&#34; copies of TU and TR when this situation arises (analogous to &#34;copy on write&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
- この状況が発生したときに、TUとTRの「シャドウ」コピーを作成します（「書き込み時にコピー」に類似）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
- Generate a HEAD-based usage report when the non-conditional request is sent (or when the &#34;max-uses=0&#34; is received), causing CU and CR to be zeroed (analogous in some ways to a &#34;memory barrier&#34; instruction).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
- 非条件付きリクエストが送信されたとき（または「max-uses = 0」が受信されたとき）にHEADベースの使用状況レポートを生成し、CUおよびCRをゼロにします（「メモリバリア」命令といくつかの点で類似しています）。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the second case, the server implicitly has removed the usage-limit(s) on the response (by setting MU and/or MR to infinity), and so the fact that, say, TU is different from CU is not significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2番目のケースでは、サーバーは暗黙的に（MUやMRを無限大に設定することにより）応答の使用制限を削除しているため、TUがCUと異なるという事実は重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: It may also be possible to eliminate the PF flag by sending extra HEAD-based usage-report requests, but we recommend against this; it is better to allocate an extra bit per entry than to transmit extra requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：追加のHEADベースの使用状況レポートリクエストを送信してPFフラグを削除することも可能ですが、これはお勧めしません。追加のリクエストを送信するよりも、エントリごとに追加のビットを割り当てる方が適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 Counting rules: interaction with Range requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 カウント規則：Rangeリクエストとの相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.1 allows a client to request sub-ranges of a resource. A client might end up issuing several requests with the net effect of receiving one copy of the resource. For uniformity of the results seen by origin servers, proxies need to observe a rule for counting these references, although it is not clear that one rule generates accurate results in every case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 1.1では、クライアントがリソースのサブ範囲をリクエストできます。クライアントは、リソースの1つのコピーを受信するという最終的な効果を伴って、いくつかの要求を発行することになります。起点サーバーから見た結果の均一性のために、プロキシはこれらの参照をカウントするためのルールを監視する必要がありますが、1つのルールがすべてのケースで正確な結果を生成することは明らかではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rule established in this specification is that proxies count as a &#34;use&#34; or &#34;reuse&#34; only those Range requests that result in the return of byte #0 of the resource. The rationale for this rule is that in almost every case, an end-client will retrieve the beginning of any resource that it references at all, and that it will seldom retrieve any portion more than once. Therefore, this rule appears to meet the goal of a &#34;best-efforts&#34; approximation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様で確立されたルールは、プロキシが「使用」または「再利用」としてカウントするのは、リソースのバイト＃0が返されることになるRangeリクエストのみであるということです。このルールの理論的根拠は、ほとんどすべてのケースで、エンドクライアントはそれが参照するすべてのリソースの先頭を取得し、ほとんどの場合、一度に複数の部分を取得することはありません。したがって、このルールは「ベストエフォート」近似の目標を満たしているように見えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5 Implementation by non-caching proxies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5 非キャッシングプロキシによる実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A non-caching proxy may participate in the metering subtree; this is strongly recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非キャッシングプロキシは、メータリングサブツリーに参加できます。これを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A non-caching proxy (HTTP/1.1 or higher) that participates in the metering subtree SHOULD forward Meter headers on both requests and responses, with the appropriate Connection headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メータリングサブツリーに参加する非キャッシュプロキシ（HTTP / 1.1以降）は、適切な接続ヘッダーを使用して、要求と応答の両方でメーターヘッダーを転送する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a non-caching proxy forwards Meter headers, it MUST comply with these restrictions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非キャッシングプロキシがMeterヘッダーを転送する場合は、次の制限に準拠する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. If the proxy forwards Meter headers in responses, such a response MUST NOT be returned to any request except the one that elicited it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. プロキシが応答でMeterヘッダーを転送する場合、そのような応答は、それを引き出したものを除いて、いかなる要求にも返されてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Once a non-caching proxy starts forwarding Meter headers, it should not arbitrarily stop forwarding them (or else reports may be lost).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. 非キャッシュプロキシがMeterヘッダーの転送を開始すると、それらの転送を勝手に停止してはなりません（そうしないと、レポートが失われる可能性があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy that caches some responses and not others, for whatever reason, may choose to implement the Meter header as a caching proxy for the responses that it caches, and as a non-caching proxy for the responses that it does not cache, as long as its external behavior with respect to any particularly response is fully consistent with this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何らかの理由で一部の応答のみをキャッシュし、他の応答をキャッシュしないプロキシは、キャッシュする応答のキャッシュプロキシとして、およびキャッシュしない応答の非キャッシュプロキシとして、Meterヘッダーを実装することを選択できます。特定の応答に関する外部の動作は、この仕様と完全に一致しているためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6 Implementation by cooperating caches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6 連携するキャッシュによる実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several HTTP cache implementations, most notably the Harvest/Squid cache [2], create cooperative arrangements between several caches. If such caches use a protocol other than HTTP to communicate between themselves, such as the Internet Cache Protocol (ICP) [12], and if they implement the Meter header, then they MUST act to ensure that their cooperation does not violate the intention of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのHTTPキャッシュ実装、特にHarvest / Squidキャッシュ[2]は、いくつかのキャッシュ間の協調配置を作成します。そのようなキャッシュが、インターネットキャッシュプロトコル（ICP）[12]など、HTTP以外のプロトコルを使用して相互に通信する場合、およびそれらがMeterヘッダーを実装する場合、それらのキャッシュの協力が意図に反しないように行動しなければなりません（MUST）。この仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, if one member of a group of cooperating caches agrees with a server to hit-meter a particular response, and then passes this response via a non-HTTP protocol to a second cache in the group, the caches MUST ensure that the server which requested the metering receives reports that appropriately account for any uses or resues made by the second cache. Similarly, if the first cache agreed to usage-limit the response, the total number of uses by the group of caches MUST be limited to the agreed-upon number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、協調するキャッシュのグループの1つのメンバーがサーバーと合意して特定の応答を測定し、その応答を非HTTPプロトコル経由でグループ内の2番目のキャッシュに渡す場合、キャッシュはサーバーがメータリングを要求したレポートは、2次キャッシュによって行われた使用または結果を適切に説明するレポートを受け取ります。同様に、最初のキャッシュが応答の使用制限に合意した場合、キャッシュのグループによる使用の総数は、合意された数に制限される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
6 Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
6例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 Example of a complete set of exchanges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 完全な交換の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This example shows how the protocol is intended to be used most of the time: for hit-metering without usage-limiting. Entity bodies are omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例は、ほとんどの場合にプロトコルがどのように使用されることが意図されているかを示しています：使用制限のないヒットメータリング用。エンティティボディは省略されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client sends request to a proxy:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがプロキシにリクエストを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET http://foo.com/bar.html HTTP/1.1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The proxy forwards request to the origin server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシは、要求をオリジンサーバーに転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
GET /bar.html HTTP/1.1 Host: foo.com Connection: Meter
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
GET /bar.html HTTP / 1.1ホスト：foo.com接続：メーター
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
thus offering (implicitly) &#34;will-report-and-limit&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、（暗黙的に）「will-report-and-limit」を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server responds to the proxy:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはプロキシに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Date: Fri, 06 Dec 1996 18:44:29 GMT
       Cache-control: max-age=3600
       Connection: meter
       Etag: &#34;abcde&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
thus (implicitly) requiring &#34;do-report&#34; (but not requiring usage-limiting).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、（暗黙的に）「do-report」が必要です（ただし、使用制限は必要ありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The proxy responds to the client:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシはクライアントに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Date: Fri, 06 Dec 1996 18:44:29 GMT
       Etag: &#34;abcde&#34;
       Cache-control: max-age=3600, proxy-mustcheck
       Age: 1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the proxy does not know if its client is an end-system, or a proxy that doesn&#39;t do metering, it adds the &#34;proxy-mustcheck&#34; directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシは、クライアントがエンドシステムであるか、メータリングを行わないプロキシであるかを認識していないため、「proxy-mustcheck」ディレクティブを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another client soon asks for the resource:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のクライアントがすぐにリソースを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET http://foo.com/bar.html HTTP/1.1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the proxy sends the same response as it sent to the other client, except (perhaps) for the Age value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして、プロキシは、（おそらく）Age値を除いて、他のクライアントに送信したのと同じ応答を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After an hour has passed, a third client asks for the response:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1時間経過すると、3番目のクライアントが応答を要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET http://foo.com/bar.html HTTP/1.1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But now the response&#39;s max-age has been exceeded, so the proxy revalidates the response with the origin server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、今や応答のmax-ageを超えているため、プロキシは元のサーバーで応答を再検証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET /bar.html HTTP/1.1
       If-None-Match: &#34;abcde&#34;
       Host: foo.com
       Connection: Meter
       Meter: count=1/0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
thus simultaneously fulfilling its duties to validate the response and to report the one &#34;use&#34; that wasn&#39;t forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、応答を検証し、転送されなかった1つの「使用」を報告するという義務を同時に果たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The origin server responds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オリジンサーバーは応答します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 304 Not Modified
       Date: Fri, 06 Dec 1996 19:44:29 GMT
       Cache-control: max-age=3600
       Etag: &#34;abcde&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
so the proxy can use the original response to reply to the new client; the proxy also zeros the use-count it associates with that response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、プロキシは元の応答を使用して新しいクライアントに応答できます。プロキシは、その応答に関連付けられている使用回数もゼロにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another client soon asks for the resource:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のクライアントがすぐにリソースを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET http://foo.com/bar.html HTTP/1.1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the proxy sends the appropriate response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシは適切な応答を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After another few hours, the proxy decides to remove the cache entry. When it does so, it sends to the origin server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに数時間後、プロキシはキャッシュエントリを削除することを決定します。その場合、オリジンサーバーに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HEAD /bar.html HTTP/1.1
       If-None-Match: &#34;abcde&#34;
       Host: foo.com
       Connection: Meter
       Meter: count=1/0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
reporting that one more use of the response was satisfied from the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュからの応答のもう1つの使用が満たされたことを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 Protecting against HTTP/1.0 proxies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 HTTP / 1.0プロキシからの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An origin server that does not want HTTP/1.0 caches to store the response at all, and is willing to have HTTP/1.0 end-system clients generate excess GETs (which will be forwarded by HTTP/1.0 proxies) could send this for its reply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 1.0キャッシュに応答をまったく保存させたくないオリジンサーバーで、HTTP / 1.0エンドシステムクライアントが過剰なGETを生成することを望んでいる場合（HTTP / 1.0プロキシによって転送されます）、これを応答に送信できます。 ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Cache-control: max-age=3600
       Connection: meter
       Etag: &#34;abcde&#34;
       Expires: Sun, 06 Nov 1994 08:49:37 GMT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.0 caches will see the ancient Expires header, but HTTP/1.1 caches will see the max-age directive and will ignore Expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 1.0キャッシュは古いExpiresヘッダーを参照しますが、HTTP / 1.1キャッシュはmax-ageディレクティブを参照し、Expiresを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: although most major HTTP/1.0 proxy implementations observe the Expires header, it is possible that some are in use that do not. Use of the Expires header to prevent caching by HTTP/1.0 proxies might not be entirely reliable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：ほとんどの主要なHTTP / 1.0プロキシ実装はExpiresヘッダーを監視しますが、一部は使用していない可能性があります。 Expiresヘッダーを使用してHTTP / 1.0プロキシによるキャッシュを防止することは、完全に信頼できるとは限りません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 More elaborate examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 より複雑な例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is a request from a proxy that is willing to hit-meter but is not willing to usage-limit:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、ヒットメーターを受け入れても、使用制限を受け入れないプロキシからのリクエストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
GET /bar.html HTTP/1.1 Host: foo.com Connection: Meter Meter: wont-limit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
GET /bar.html HTTP / 1.1 Host：foo.com Connection：Meter Meter：wont-limit
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is a response from an origin server that does not want hit counting, but does want &#34;uses&#34; limited to 3, and &#34;reuses&#34; limited to 6:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、ヒットカウントを必要としないが、「使用」を3に制限し、「再使用」を6に制限したいオリジンサーバーからの応答です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Cache-control: max-age=3600
       Connection: meter
       Etag: &#34;abcde&#34;
       Expires: Sun, 06 Nov 1994 08:49:37 GMT
       Meter: max-uses=3, max-reuses=6, dont-report
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is the same example with abbreviated Meter directive names:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meterディレクティブ名を省略した同じ例を次に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Cache-control: max-age=3600
       Connection: meter
       Etag: &#34;abcde&#34;
       Expires: Sun, 06 Nov 1994 08:49:37 GMT
       Meter:u=3,r=6,e
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
7 Interactions with content negotiation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
7コンテンツネゴシエーションとの相互作用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes two aspects of the interaction between hit-metering and &#34;content-negotiated&#34; resources:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ヒットメータリングと「コンテンツネゴシエートされた」リソース間の相互作用の2つの側面について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. treatment of responses carrying a Vary header (section 7.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Varyヘッダーを含む応答の処理（セクション7.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. treatment of responses that use the proposed Transparent Content Negotiation mechanism (section 7.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. 提案された透過的コンテンツネゴシエーションメカニズムを使用する応答の処理（セクション7.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 Treatment of responses carrying a Vary header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 Varyヘッダーを含む応答の処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Separate counts should be kept for each combination of the headers named in the Vary header for the Request-URI (what [4] calls &#34;the selecting request-headers&#34;), even if they map to the same entity-tag. This rule has the effect of counting hits on each variant, if there are multiple variants of a page available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じエンティティタグにマッピングされている場合でも、Request-URIのVaryヘッダーで名前が付けられたヘッダー（[4]が「selecting request-headers」と呼ぶもの）の組み合わせごとに個別のカウントを保持する必要があります。このルールは、ページのバリアントが複数ある場合、各バリアントのヒットをカウントする効果があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: This interaction between Vary and the hit-counting directives allows the origin server a lot of flexibility in specifying how hits should be counted. In essence, the origin server uses the Vary mechanism to divide the requests for a resource into arbitrary categories, based on the request- headers. (We will call these categories &#34;request-patterns&#34;.) Since a proxy keeps its hit-counts for each request-pattern, rather than for each resource, the origin server can obtain separate statistics for many aspects of an HTTP request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：Varyとヒットカウントディレクティブ間のこの相互作用により、オリジンサーバーは、ヒットのカウント方法を指定する際に多くの柔軟性を得ることができます。本質的に、オリジンサーバーはVaryメカニズムを使用して、要求ヘッダーに基づいて、リソースへの要求を任意のカテゴリに分割します。 （これらのカテゴリーを「要求パターン」と呼びます。）プロキシは、各リソースではなく、各要求パターンのヒット数を保持するため、オリジンサーバーはHTTP要求の多くの側面について個別の統計を取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if a page varied based on the value of the User-Agent header in the requests, then hit counts would be kept for each different flavor of browser. But it is in fact more general than that; because multiple header combinations can map to the same variant, it also enables the origin server to count the number of times (e.g.) the Swahili version of a page was requested, even though it is only available in English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、リクエストのUser-Agentヘッダーの値に基づいてページが変化した場合、ヒットカウントはブラウザーの異なるフレーバーごとに保持されます。しかし、実際にはそれよりも一般的です。複数のヘッダーの組み合わせが同じバリアントにマッピングできるため、オリジンサーバーは英語でのみ利用可能であっても、ページのスワヒリ語バージョンがリクエストされた回数（たとえば）をカウントすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a proxy does not support the Vary mechanism, then [4] says that it MUST NOT cache any response that carries a Vary header, and hence need not implement any aspect of this hit-counting or usage-limiting design for varying resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシがVaryメカニズムをサポートしていない場合、[4]は、Varyヘッダーを含む応答をキャッシュしてはならないため、さまざまなリソースに対してこのヒットカウントまたは使用制限設計のいかなる側面も実装する必要がないと述べています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note: this also implies that if a proxy supports the Vary mechanism but is not willing to maintain independent hit-counts for each variant response in its cache, then it must follow at least one of these rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
注：これは、プロキシがVaryメカニズムをサポートしているが、キャッシュ内の各バリアントレスポンスの独立したヒットカウントを維持したくない場合は、次のルールの少なくとも1つに従う必要があることも意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
1. It must not use the Meter header in a request to offer to hit-meter or usage-limit responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
1. ヒットメーターまたは使用制限のレスポンスを提供するために、リクエストでMeterヘッダーを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
2. If it does offer to hit-meter or usage-limit responses, and then receives a response that includes both a Vary header and a Meter header with a directive that it cannot satisfy, then the proxy must not cache the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
2. ヒットメーターまたは使用制限の応答を提供し、VaryヘッダーとMeterヘッダーの両方を含み、満たすことができないディレクティブを含む応答を受信する場合、プロキシは応答をキャッシュしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In other words, a proxy is allowed to partially implement the Vary mechanism with respect to hit-metering, as long as this has no externally visible effect on its ability to comply with the Meter specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
言い換えると、プロキシーは、メーターの仕様に準拠する能力に外部から見える影響がない限り、ヒットメーターに関してVaryメカニズムを部分的に実装することが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This approach works for counting almost any aspect of the request stream, without embedding any specific list of countable aspects in the specification or proxy implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプローチは、要求ストリームのほとんどすべての側面をカウントするために機能します。仕様またはプロキシ実装に、カウント可能な側面の特定のリストを埋め込むことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 Interaction with Transparent Content Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 透過的コンテンツネゴシエーションとの相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[A description of the interaction between this design and the proposed Transparent Content Negotiation (TCN) design [6] will be made available in a later document.]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[この設計と提案された透過的コンテンツネゴシエーション（TCN）設計[6]の間の相互作用の説明は、後のドキュメントで利用可能になります。]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8 A Note on Capturing Referrals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8紹介のキャプチャに関する注意
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is alleged that some advertisers want to pay content providers, not by the &#34;hit&#34;, but by the &#34;nibble&#34; -- the number of people who actually click on the ad to get more information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の広告主は、「ヒット」ではなく「ニブル」（詳細情報を得るために実際に広告をクリックした人の数）によってコンテンツプロバイダーに支払いたいと主張しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, HTTP already has a mechanism for doing this: the &#34;Referer&#34; header. However, perhaps it ought to be disabled for privacy reasons -- according the HTTP/1.1 spec:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、HTTPにはこれを行うためのメカニズム、「Referer」ヘッダーがすでにあります。ただし、おそらくプライバシー上の理由から無効にする必要があります-HTTP / 1.1仕様によると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
&#34;Because the source of the link may be private information or may reveal an otherwise private information source, it is strongly recommended that the user be able to select whether or not the Referer field is sent.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
「リンクのソースが個人情報であるか、または他の方法で個人情報ソースを明らかにする可能性があるため、Refererフィールドを送信するかどうかをユーザーが選択できるようにすることを強くお勧めします。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, in the case of ads, the source of the link actually wants to let the referred-to page know where the reference came from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、広告の場合、リンクのソースは実際には、参照先のページに参​​照元がどこかを知らせたいと考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This does not require the addition of any extra mechanism, but rather can use schemes that embed the referrer in the URI in a manner similar to this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これには、追加のメカニズムを追加する必要はありませんが、次のような方法でURIにリファラーを埋め込むスキームを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          http://www.blah.com/ad-reference?from=site1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such a URI should point to a resource (perhaps a CGI script) which returns a 302 redirect to the real page
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなURIは、実際のページへの302リダイレクトを返すリソース（おそらくCGIスクリプト）を指す必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          http://www.blah.com/ad-reference.html
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Proxies which do not cache 302s will cause one hit on the redirection page per use, but the real page will get cached. Proxies which do cache 302s and report hits on the cached 302s will behave optimally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
302をキャッシュしないプロキシは、使用ごとにリダイレクトページに1回ヒットしますが、実際のページはキャッシュされます。 302をキャッシュし、キャッシュされた302でヒットを報告するプロキシは、最適に動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This approach has the advantage that it works whether or not the end-client has disabled the use of Referer. Combined with the rest of the hit-metering proposal in this design, this approach allows, for example, an advertiser to know how often a reference to an advertisement was made from a particular page.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプローチには、エンドクライアントがリファラーの使用を無効にしたかどうかに関係なく機能するという利点があります。この設計のその他のヒットメータリングの提案と組み合わせると、このアプローチにより、たとえば、広告主は特定のページから広告への参照が行われた頻度を知ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
9 Alternative proposals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
9代替案
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There might be a number of other ways of gathering demographic and usage information; other mechanisms might respond to a different set of needs than this proposal does. This proposal certainly does not preclude the proposal or deployment of other such mechanisms, and many of them may be complementary to and compatible with the mechanism proposed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
人口統計および使用状況の情報を収集する方法は他にもいくつかあるかもしれません。他のメカニズムは、この提案とは異なる一連のニーズに対応する場合があります。この提案は確かに他のそのようなメカニズムの提案または展開を排除するものではなく、それらの多くはここで提案されたメカニズムを補完し、互換性があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 There has been some speculation that statistical sampling methods might be used to gather reasonably accurate data. One such proposal is to manipulate cache expiration times so that selected resources are uncachable for carefully chosen periods, allowing servers to accurately count accesses during those periods. The hit-metering mechanism proposed here is entirely complementary to that approach, since it could be used to reduce the cost of gathering those counts. James Pitkow has written a paper comparing an earlier draft of this hit-metering proposal with sampling approaches [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
統計的サンプリング手法を使用して、適度に正確なデータを収集する可能性があるという推測がいくつかあります。そのような提案の1つは、キャッシュの有効期限を操作して、選択されたリソースが慎重に選択された期間にわたって到達不能になるようにし、サーバーがそれらの期間中のアクセスを正確にカウントできるようにすることです。ここで提案されているヒットメータリングメカニズムは、それらのカウントを収集するコストを削減するために使用できるため、そのアプローチを完全に補完します。 James Pitkowは、このヒットメータリングの提案の初期のドラフトをサンプリングアプローチと比較する論文を書きました[9]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phillip Hallam-Baker has proposed using a log-exchange protocol [5], by which a server could request a proxy&#39;s logs by making an HTTP request to the proxy. This proposal asserts that it is &#34;believed to operate correctly in configurations involving multiple proxies&#34;, but it is not clear that this is true if an outer proxy is used as a (one-way) firewall. The proposal also leaves a number of open issues, such as how an origin server can be sure that all of the proxies in the request subtree actually support log-exchange. It is also not clear how this proposal couples a proxy&#39;s support of log-exchange to a server&#39;s permission to cache a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phillip Hallam-Bakerは、ログ交換プロトコル[5]を使用することを提案しました。これにより、サーバーはプロキシにHTTPリクエストを送信することにより、プロキシのログをリクエストできます。この提案は、「複数のプロキシを含む構成で正しく動作すると考えられている」と主張していますが、外部プロキシが（一方向の）ファイアウォールとして使用されている場合、これが真実であることは明らかではありません。また、この提案では、要求サブツリー内のすべてのプロキシが実際にログ交換をサポートしていることをオリジンサーバーがどのように確認できるかなど、多くの未解決の問題が残されています。また、この提案が、プロキシによるログ交換のサポートと、サーバーの応答をキャッシュする許可とをどのように組み合わせているかも明確ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For general background on the topic of Web measurement standards, see the discussion by Thomas P. Novak and Donna L. Hoffman [8]. Also see the &#34;Privacy and Demographics Overview&#34; page maintained by by the World Wide Web Consortium [10], which includes a pointer to some tentative proposals for gathering consumer demographics (not just counting references) [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Web測定標準のトピックに関する一般的な背景については、Thomas P. NovakおよびDonna L. Hoffmanによる議論を参照してください[8]。また、World Wide Web Consortiumによって管理されている「プライバシーと人口統計の概要」ページ[10]も参照してください。このページには、消費者の人口統計を収集するためのいくつかの暫定的な提案へのポインタが含まれています（参照だけではありません）[3]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
10 Security Considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
10セキュリティに関する考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Which outbound clients should a server (proxy or origin) trust to report hit counts? A malicious proxy could easily report a large number of hits on some page, and thus perhaps cause a large payment to a content provider from an advertiser. To help avoid this possibility, a proxy may choose to only relay usage counts received from its outbound proxies to its inbound servers when the proxies have authenticated themselves using Proxy-Authorization and/or they are on a list of approved proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー（プロキシまたはオリジン）がヒット数を報告するために信頼する発信クライアントはどれですか。悪意のあるプロキシは、一部のページで多数のヒットを簡単に報告し、おそらく広告主からコンテンツプロバイダーに多額の支払いを引き起こす可能性があります。この可能性を回避するために、プロキシは、プロキシがProxy-Authorizationを使用して自身を認証したとき、および/または承認済みプロキシのリストにある場合に、アウトバウンドプロキシから受信した使用カウントのみをインバウンドサーバーにリレーすることを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not possible to enforce usage limits if a proxy is willing to cheat (i.e., it offers to limit usage but then ignores a server&#39;s Meter directive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロキシがチートをする意思がある場合、使用制限を強制することはできません（つまり、使用を制限することはできますが、サーバーのMeterディレクティブを無視します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regarding privacy: it appears that the design in this document does not reveal any more information about individual users than would already be revealed by implementation of the existing HTTP/1.1 support for &#34;Cache-control: max-age=0, proxy-revalidate&#34; or &#34;Cache-control: s-maxage=0&#34;. It may, in fact, help to conceal certain aspects of the organizational structure on the outbound side of a proxy. In any case, the conflict between user requirements for anonymity and origin server requirements for demographic information cannot be resolved by purely technical means.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プライバシーについて：このドキュメントの設計では、「Cache-control：max-age = 0、proxy-revalidate」に対する既存のHTTP / 1.1サポートの実装によってすでに明らかにされているよりも、個々のユーザーに関する情報は明らかにならないようです。または「Cache-control：s-maxage = 0」。実際には、プロキシの送信側の組織構造の特定の側面を隠すのに役立つ場合があります。いずれにせよ、匿名性に関するユーザー要件と人口統計情報に関するオリジンサーバー要件の間の矛盾は、純粋に技術的な手段では解決できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
11 Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
11謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We gratefully acknowledge the constructive comments received from Anselm Baird-Smith, Ted Hardie, Koen Holtman (who suggested the technique described in section 8), Dave Kristol, Ari Luotonen, Patrick R. McManus, Ingrid Melve, and James Pitkow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anselm Baird-Smith、Ted Hardie、Koen Holtman（セクション8で説明されている手法を提案）、Dave Kristol、Ari Luotonen、Patrick R. McManus、Ingrid Melve、James Pitkowから受け取った建設的なコメントに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12 References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12参照
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Bradner、S。、「RFCで使用して要件レベルを示すためのキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Anwat Chankhunthod, Peter B. Danzig, Chuck Neerdaels, Michael F. Schwartz, and Kurt J. Worrell. A Hierarchical Internet Object Cache. Proc. 1996 USENIX Technical Conf., San Diego, January, 1996, pp. 153-163.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Anwat Chankhunthod、Peter B. Danzig、Chuck Neerdaels、Michael F. Schwartz、Kurt J. Worrell。階層型インターネットオブジェクトキャッシュ。手続き1996 USENIX Technical Conf。、サンディエゴ、1996年1月、pp。153-163。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Daniel W. Connolly. Proposals for Gathering Consumer Demographics. http://www.w3.org/pub/WWW/Demographics/Proposals.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ダニエルW.コノリー。消費者の人口統計を収集するための提案。 http://www.w3.org/pub/WWW/Demographics/Proposals.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Fielding, R., Gettys, J., Mogul, J., Nielsen, H. and T. Berners-Lee, &#34;Hypertext Transfer Protocol -- HTTP/1.1,&#34; RFC 2068, January, 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Fielding、R.、Gettys、J.、Mogul、J.、Nielsen、H。、およびT. Berners-Lee、「Hypertext Transfer Protocol-HTTP / 1.1」、RFC 2068、1997年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Phillip M. Hallam-Baker. Notification for Proxy Caches. W3C Working Draft WD-proxy-960221, World Wide Web Consortium, February, 1996. http://www.w3.org/pub/WWW/TR/WD-proxy.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. フィリップM.ハラム-ベイカー。プロキシキャッシュの通知。 W3CワーキングドラフトWD-proxy-960221、World Wide Web Consortium、1996年2月。http：//www.w3.org/pub/WWW/TR/WD-proxy.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Holtman, K., and A. Mutz, &#34;Transparent Content Negotiation in HTTP&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Holtman、K。、およびA. Mutz、「HTTPでの透過的なコンテンツネゴシエーション」、Work in Progress。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Mogul, J., &#34;Forcing HTTP/1.1 proxies to revalidate responses&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Mogul、J。、「HTTP / 1.1プロキシに応答の再検証を強制する」、Work in Progress。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Thomas P. Novak and Donna L. Hoffman. New Metrics for New Media: Toward the Development of Web Measurement Standards. This is a draft paper, currently available at http:// www2000.ogsm.vanderbilt.edu/novak/web.standards/webstand.html. Cited by permission of the author; do not quote or cite without permission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. トーマスP.ノバックとドナL.ホフマン。新しいメディアの新しい測定基準：Web測定標準の開発に向けて。これはドラフトペーパーであり、現在http：// www2000.ogsm.vanderbilt.edu/novak/web.standards/webstand.htmlで入手できます。著者の許可を得て引用;許可なく引用したり引用したりしないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. James Pitkow. In search of reliable usage data on the WWW. Proc. Sixth International World Wide Web Conference, Santa Clara, CA, April, 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. ジェームス・ピットコウ。 WWWで信頼できる使用状況データを検索します。手続き第6回国際ワールドワイドウェブ会議、カリフォルニア州サンタクララ、1997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Joseph Reagle, Rohit Khare, Dan Connolly, and Tim Berners-Lee. Privacy and Demographics Overview. http://www.w3.org/pub/WWW/Demographics/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Joseph Reagle、Rohit Khare、Dan Connolly、Tim Berners-Lee。プライバシーと人口統計の概要。 http://www.w3.org/pub/WWW/Demographics/。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. Linda Tauscher and Saul Greenberg. Revisitation Patterns in World Wide Web Navigation. Research Report 96/587/07, Department of Computer Science, University of Calgary, March, 1996. http://www.cpsc.ucalgary.ca/projects/grouplab/ papers/96WebReuse/TechReport96.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. リンダ・トーシャーとソール・グリーンバーグ。 World Wide Web Navigationの再訪パターン。リサーチレポート96/587/07、カルガリー大学コンピュータサイエンス学部、1996年3月。http：//www.cpsc.ucalgary.ca/projects/grouplab/papers/96WebReuse/TechReport96.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. Wessels, D., and K. Claffy &#34;Internet Cache Protocol (ICP), version 2&#34;, RFC 2186, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. Wessels、D。、およびK. Claffy「インターネットキャッシュプロトコル（ICP）、バージョン2」、RFC 2186、1997年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
13 Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
13著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jeffrey C. Mogul Western Research Laboratory Digital Equipment Corporation 250 University Avenue Palo Alto, California, 94305, U.S.A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジェフリーC.モーグルウエスタンリサーチラボラトリーデジタル機器コーポレーション250ユニバーシティアベニューパロアルト、カリフォルニア、94305、アメリカ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: mogul@wrl.dec.com
   Phone: 1 415 617 3304 (email preferred)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul J. Leach Microsoft 1 Microsoft Way Redmond, Washington, 98052, U.S.A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポールJ.リーチマイクロソフト1マイクロソフトウェイレドモンド、ワシントン、98052、アメリカ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: paulle@microsoft.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
14 Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
14完全な著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1997). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（1997）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implmentation may be prepared, copied, published andand distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとその翻訳はコピーして他のユーザーに提供することができ、コメントまたはその他の方法で説明したり、その実装を支援する二次的著作物を作成したり、コピーしたり、公開したり、配布したりすることができます。ただし、上記の著作権表示とこの段落は、そのようなすべてのコピーと派生物に含まれています。ただし、このドキュメント自体は、著作権に関する通知を削除したり、インターネットソサエティや他のインターネット組織への参照を削除したりするなど、いかなる方法でも変更できません。ただし、インターネット標準を開発する目的で必要な場合は除きます。インターネット標準のプロセスに従うか、または必要に応じて、それを英語以外の言語に翻訳する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに記載されている情報の使用が保証するものに限定されない一切の保証を含みません。商品性または特定の目的への適合性に関する権利または黙示の保証を侵害すること。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
