<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 2246 - The TLS Protocol Version 1.0 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2246</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc2246">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2246 - The TLS Protocol Version 1.0 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc2246">
              https://datatracker.ietf.org/doc/html/rfc2246
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 2246 - TLSプロトコルバージョン1.0</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         T. Dierks
Request for Comments: 2246                                     Certicom
Category: Standards Track                                      C. Allen
                                                               Certicom
                                                           January 1999
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
The TLS Protocol Version 1.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
TLSプロトコルバージョン1.0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（1999）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies Version 1.0 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications privacy over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、Transport Layer Security（TLS）プロトコルのバージョン1.0を規定しています。 TLSプロトコルは、インターネット上の通信プライバシーを提供します。このプロトコルにより、クライアント/サーバーアプリケーションは、盗聴、改ざん、またはメッセージの偽造を防ぐように設計された方法で通信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 1. Introduction 3 2. Goals 4 3. Goals of this document 5 4. Presentation language 5 4.1. Basic block size 6 4.2. Miscellaneous 6 4.3. Vectors 6 4.4. Numbers 7 4.5. Enumerateds 7 4.6. Constructed types 8 4.6.1. Variants 9 4.7. Cryptographic attributes 10 4.8. Constants 11 5. HMAC and the pseudorandom function 11 6. The TLS Record Protocol 13 6.1. Connection states 14 6.2. Record layer 16 6.2.1. Fragmentation 16 6.2.2. Record compression and decompression 17 6.2.3. Record payload protection 18 6.2.3.1. Null or standard stream cipher 19 6.2.3.2. CBC block cipher 19 6.3. Key calculation 21 6.3.1. Export key generation example 22 7. The TLS Handshake Protocol 23 7.1. Change cipher spec protocol 24 7.2. Alert protocol 24 7.2.1. Closure alerts 25 7.2.2. Error alerts 26 7.3. Handshake Protocol overview 29 7.4. Handshake protocol 32 7.4.1. Hello messages 33 7.4.1.1. Hello request 33 7.4.1.2. Client hello 34 7.4.1.3. Server hello 36 7.4.2. Server certificate 37 7.4.3. Server key exchange message 39 7.4.4. Certificate request 41 7.4.5. Server hello done 42 7.4.6. Client certificate 43 7.4.7. Client key exchange message 43 7.4.7.1. RSA encrypted premaster secret message 44 7.4.7.2. Client Diffie-Hellman public value 45 7.4.8. Certificate verify 45 7.4.9. Finished 46 8. Cryptographic computations 47 8.1. Computing the master secret 47 8.1.1. RSA 48 8.1.2. Diffie-Hellman 48 9. Mandatory Cipher Suites 48 10. Application data protocol 48 A. Protocol constant values 49 A.1. Record layer 49 A.2. Change cipher specs message 50 A.3. Alert messages 50 A.4. Handshake protocol 51 A.4.1. Hello messages 51 A.4.2. Server authentication and key exchange messages 52 A.4.3. Client authentication and key exchange messages 53 A.4.4. Handshake finalization message 54 A.5. The CipherSuite 54 A.6. The Security Parameters 56 B. Glossary 57 C. CipherSuite definitions 61 D. Implementation Notes 64 D.1. Temporary RSA keys 64 D.2. Random Number Generation and Seeding 64 D.3. Certificates and authentication 65 D.4. CipherSuites 65 E. Backward Compatibility With SSL 66 E.1. Version 2 client hello 67 E.2. Avoiding man-in-the-middle version rollback 68 F. Security analysis 69 F.1. Handshake protocol 69 F.1.1. Authentication and key exchange 69 F.1.1.1. Anonymous key exchange 69 F.1.1.2. RSA key exchange and authentication 70 F.1.1.3. Diffie-Hellman key exchange with authentication 71 F.1.2. Version rollback attacks 71 F.1.3. Detecting attacks against the handshake protocol 72 F.1.4. Resuming sessions 72 F.1.5. MD5 and SHA 72 F.2. Protecting application data 72 F.3. Final notes 73 G. Patent Statement 74 Security Considerations 75 References 75 Credits 77 Comments 78 Full Copyright Statement 80
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
1.はじめに3 2.目標4 3.この文書の目標5 4.プレゼンテーション言語5 4.1。基本ブロックサイズ6 4.2。その他6 4.3。ベクトル6 4.4。数字7 4.5。列挙型7 4.6。構築型8 4.6.1。バリアント9 4.7。暗号属性10 4.8。定数11 5. HMACと疑似ランダム関数11 6. TLSレコードプロトコル13 6.1。接続状態14 6.2。記録層16 6.2.1。フラグメンテーション16 6.2.2。レコードの圧縮と解凍17 6.2.3。ペイロード保護の記録18 6.2.3.1。ヌルまたは標準のストリーム暗号19 6.2.3.2。 CBCブロック暗号19 6.3。キー計算21 6.3.1。エクスポートキー生成の例22 7. TLSハンドシェイクプロトコル23 7.1。暗号仕様プロトコルの変更24 7.2。警告プロトコル24 7.2.1。閉鎖アラート25 7.2.2。エラーアラート26 7.3。ハンドシェイクプロトコルの概要29 7.4。ハンドシェイクプロトコル32 7.4.1。 Helloメッセージ33 7.4.1.1。 Helloリクエスト33 7.4.1.2。クライアントHello 34 7.4.1.3。サーバーハロー36 7.4.2。サーバー証明書37 7.4.3。サーバーキー交換メッセージ39 7.4.4。証明書リクエスト41 7.4.5。サーバーのハロー完了42 7.4.6。クライアント証明書43 7.4.7。クライアント鍵交換メッセージ43 7.4.7.1。 RSA暗号化されたプリマスターシークレットメッセージ44 7.4.7.2。クライアントDiffie-Hellmanパブリックバリュー45 7.4.8。証明書検証45 7.4.9。完了46 8.暗号計算47 8.1。マスターシークレットの計算47 8.1.1。 RSA 48 8.1.2。 Diffie-Hellman 48 9.必須の暗号スイート48 10.アプリケーションデータプロトコル48 A.プロトコル定数値49 A.1。記録層49 A.2。暗号仕様変更メッセージ50 A.3。警告メッセージ50 A.4。ハンドシェイクプロトコル51 A.4.1。 Helloメッセージ51 A.4.2。サーバー認証と鍵交換メッセージ52 A.4.3。クライアント認証と鍵交換メッセージ53 A.4.4。ハンドシェイク終了メッセージ54 A.5。サイファースイート54 A.6。セキュリティパラメータ56 B.用語集57 C. CipherSuite定義61 D.実装上の注意64 D.1。一時的なRSAキー64 D.2。乱数の生成とシード64 D.3。証明書と認証65 D.4。 CipherSuites 65 E. SSLとの下位互換性66 E.1。バージョン2クライアントhello 67 E.2。中間者バージョンのロールバックを回避する68 F.セキュリティ分析69 F.1。ハンドシェイクプロトコル69 F.1.1。認証と鍵交換69 F.1.1.1。匿名の鍵交換69 F.1.1.2。 RSA鍵の交換と認証70 F.1.1.3。認証付きのDiffie-Hellman鍵交換71 F.1.2。バージョンロールバック攻撃71 F.1.3。ハンドシェイクプロトコルに対する攻撃の検出72 F.1.4。セッションの再開72 F.1.5。 MD5およびSHA 72 F.2。アプリケーションデータの保護72 F.3。最終メモ73 G.特許ステートメント74セキュリティに関する考慮事項75参照75クレジット77コメント78完全な著作権ステートメント80
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary goal of the TLS Protocol is to provide privacy and data integrity between two communicating applications. The protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP[TCP]), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSプロトコルの主な目的は、2つの通信アプリケーション間でプライバシーとデータの整合性を提供することです。このプロトコルは、TLSレコードプロトコルとTLSハンドシェイクプロトコルの2つの層で構成されています。 TLS Record Protocolは、最も信頼できるトランスポートプロトコル（TCP [TCP]など）の上に階層化された最下位レベルです。 TLSレコードプロトコルは、2つの基本的なプロパティを持つ接続セキュリティを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The connection is private. Symmetric cryptography is used for data encryption (e.g., DES [DES], RC4 [RC4], etc.) The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another protocol (such as the TLS Handshake Protocol). The Record Protocol can also be used without encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 接続はプライベートです。対称暗号化は、データ暗号化に使用されます（たとえば、DES [DES]、RC4 [RC4]など）。この対称暗号化のキーは、接続ごとに一意に生成され、別のプロトコル（TLSなど）によってネゴシエートされた秘密に基づいていますハンドシェイクプロトコル）。レコードプロトコルは暗号化せずに使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 - The connection is reliable. Message transport includes a message integrity check using a keyed MAC. Secure hash functions (e.g., SHA, MD5, etc.) are used for MAC computations. The Record Protocol can operate without a MAC, but is generally only used in this mode while another protocol is using the Record Protocol as a transport for negotiating security parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
-接続は信頼できます。メッセージ転送には、キー付きMACを使用したメッセージ整合性チェックが含まれます。安全なハッシュ関数（SHA、MD5など）がMAC計算に使用されます。レコードプロトコルはMACがなくても動作しますが、通常はこのモードでのみ使用されますが、別のプロトコルがセキュリティパラメータをネゴシエートするためのトランスポートとしてレコードプロトコルを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Record Protocol is used for encapsulation of various higher level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS Record Protocolは、さまざまな上位レベルのプロトコルのカプセル化に使用されます。このようなカプセル化されたプロトコルの1つであるTLSハンドシェイクプロトコルを使用すると、サーバーとクライアントは相互に認証し、アプリケーションプロトコルがデータの最初のバイトを送信または受信する前に暗号化アルゴリズムと暗号化キーをネゴシエートできます。 TLSハンドシェイクプロトコルは、3つの基本的なプロパティを持つ接続セキュリティを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The peer&#39;s identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA [RSA], DSS [DSS], etc.). This authentication can be made optional, but is generally required for at least one of the peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- ピアのIDは、非対称または公開鍵暗号化（RSA [RSA]、DSS [DSS]など）を使用して認証できます。この認証はオプションにすることができますが、通常、少なくとも1つのピアに必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 共有シークレットのネゴシエーションは安全です。ネゴシエートされたシークレットは盗聴者が利用できません。認証された接続では、接続の真ん中に攻撃者が侵入しても、シークレットは取得できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- ネゴシエーションは信頼できます。通信の当事者によって検出されることなく、攻撃者がネゴシエーション通信を変更することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One advantage of TLS is that it is application protocol independent. Higher level protocols can layer on top of the TLS Protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left up to the judgment of the designers and implementors of protocols which run on top of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSの1つの利点は、TLSがアプリケーションプロトコルに依存しないことです。より高いレベルのプロトコルは、TLSプロトコルの上に透過的に階層化できます。ただし、TLS標準では、プロトコルがTLSでセキュリティを追加する方法は指定されていません。 TLSハンドシェイクを開始する方法と交換される認証証明書を解釈する方法に関する決定は、TLSの上で実行されるプロトコルの設計者と実装者の判断に委ねられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. ゴール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goals of TLS Protocol, in order of their priority, are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSプロトコルの目標は、優先度の順に、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. Cryptographic security: TLS should be used to establish a secure connection between two parties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. 暗号化セキュリティ：TLSを使用して、2者間の安全な接続を確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. Interoperability: Independent programmers should be able to develop applications utilizing TLS that will then be able to successfully exchange cryptographic parameters without knowledge of one another&#39;s code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. 相互運用性：独立したプログラマーは、TLSを利用するアプリケーションを開発できるはずです。TLSを使用すると、お互いのコードを知らなくても、暗号パラメーターを正常に交換できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 3. Extensibility: TLS seeks to provide a framework into which new public key and bulk encryption methods can be incorporated as necessary. This will also accomplish two sub-goals: to prevent the need to create a new protocol (and risking the introduction of possible new weaknesses) and to avoid the need to implement an entire new security library.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.拡張性：TLSは、必要に応じて新しい公開鍵とバルク暗号化方式を組み込むことができるフレームワークを提供しようとしています。これはまた、2つのサブ目標を達成します。新しいプロトコルを作成する必要をなくし（そして考えられる新しい弱点の導入を危険にさらすこと）、新しいセキュリティライブラリ全体を実装する必要を回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. 相対的な効率：暗号化操作は、CPUを集中的に使用する傾向があり、特に公開鍵の操作です。このため、TLSプロトコルにはオプションのセッションキャッシングスキームが組み込まれており、最初から確立する必要のある接続の数を減らすことができます。さらに、ネットワークアクティビティを減らすように注意が払われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Goals of this document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. このドキュメントの目的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the TLS protocol itself are based on the SSL 3.0 Protocol Specification as published by Netscape. The differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that TLS 1.0 and SSL 3.0 do not interoperate (although TLS 1.0 does incorporate a mechanism by which a TLS implementation can back down to SSL 3.0). This document is intended primarily for readers who will be implementing the protocol and those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとTLSプロトコル自体は、Netscapeによって発行されたSSL 3.0プロトコル仕様に基づいています。このプロトコルとSSL 3.0の違いは劇的ではありませんが、TLS 1.0とSSL 3.0が相互運用しないほど重要です（ただし、TLS 1.0には、TLS実装がSSL 3.0に戻ることができるメカニズムが組み込まれています）。このドキュメントは、主にプロトコルを実装する読者と、そのプロトコルの暗号分析を行う読者を対象としています。仕様はこれを念頭に置いて作成されており、2つのグループのニーズを反映することを目的としています。そのため、アルゴリズムに依存するデータ構造とルールの多くが（付録ではなく）テキストの本文に含まれ、それらに簡単にアクセスできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not intended to supply any details of service definition nor interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、サービス定義やインターフェイス定義の詳細を提供するものではありませんが、堅固なセキュリティを維持するために必要なポリシーの特定の領域をカバーしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Presentation language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. プレゼンテーション言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document deals with the formatting of data in an external representation. The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language &#34;C&#34; in its syntax and XDR [XDR] in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only, not to have general application beyond that particular goal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、外部表現でのデータのフォーマットを扱います。次の非常に基本的で、ややカジュアルに定義されたプレゼンテーション構文が使用されます。構文は、その構造のいくつかのソースから引き出されます。構文はプログラミング言語「C」に似ており、構文も意図もXDR [XDR]に似ていますが、あまりにも多くの類似点を描くのは危険です。このプレゼンテーション言語の目的は、TLSのみを文書化することであり、その特定の目標を超えた一般的なアプリケーションを持つことではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Basic block size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 基本ブロックサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The representation of all data items is explicitly specified. The basic data block size is one byte (i.e. 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the bytestream a multi-byte item (a numeric in the example) is formed (using C notation) by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのデータ項目の表現は明示的に指定されています。基本的なデータブロックサイズは1バイト（つまり、8ビット）です。複数バイトのデータ項目は、左から右、上から下へのバイトの連結です。バイトストリームからマルチバイトアイテム（この例では数値）は（C表記を使用して）次のように形成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
               ... | byte[n-1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This byte ordering for multi-byte values is the commonplace network byte order or big endian format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このマルチバイト値のバイト順序は、一般的なネットワークバイト順序またはビッグエンディアン形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Miscellaneous
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 雑多
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comments begin with &#34;/*&#34; and end with &#34;*/&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コメントは「/ *」で始まり、「* /」で終わります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optional components are denoted by enclosing them in &#34;[[ ]]&#34; double brackets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのコンポーネントは、 &#34;[[]]&#34;の二重括弧で囲んで示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Single byte entities containing uninterpreted data are of type opaque.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未解釈のデータを含む1バイトのエンティティは、不透明なタイプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. ベクタ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A vector (single dimensioned array) is a stream of homogeneous data elements. The size of the vector may be specified at documentation time or left unspecified until runtime. In either case the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type T&#39; that is a fixed length vector of type T is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベクトル（1次元配列）は、同種のデータ要素のストリームです。ベクトルのサイズは、ドキュメント化時に指定するか、実行時まで指定しないでおくことができます。どちらの場合も、長さはベクトルの要素数ではなくバイト数を宣言します。タイプTの固定長ベクトルである新しいタイプT &#39;を指定する構文は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
T T&#39;[n];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
T T &#39;[n];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here T&#39; occupies n bytes in the data stream, where n is a multiple of the size of T. The length of the vector is not included in the encoded stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、T &#39;はデータストリームのnバイトを占有します。nはTのサイズの倍数です。ベクトルの長さは、エンコードされたストリームには含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では、Datumはプロトコルが解釈しない3つの連続したバイトとして定義されていますが、Dataは3つの連続したDatumであり、合計で9バイトを消費します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       opaque Datum[3];      /* three uninterpreted bytes */
       Datum Data[9];        /* 3 consecutive 3 byte vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variable length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation &lt;floor..ceiling&gt;. When encoded, the actual length precedes the vector&#39;s contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector&#39;s specified maximum (ceiling) length. A variable length vector with an actual length field of zero is referred to as an empty vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可変長ベクトルは、表記&lt;floor..ceiling&gt;を使用して、有効な長さの部分範囲を包括的に指定することによって定義されます。エンコードされると、実際の長さは、バイトストリーム内のベクトルの内容に先行します。長さは、ベクターの指定された最大（天井）長さを保持するために必要なバイト数を消費する数の形式になります。ゼロの実際の長さフィールドを持つ可変長ベクトルは、空のベクトルと呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       T T&#39;&lt;floor..ceiling&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, sufficient to represent the value 400 (see Section 4.4). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17 byte vector of uint16 would be illegal).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では、必須は、不透明なタイプの300〜400バイトを含む必要があるベクトルです。空にすることはできません。実際の長さフィールドは、値400を表すのに十分な2バイト、uint16を消費します（セクション4.4を参照）。一方、longerは最大800バイトのデータ、または400 uint16要素を表すことができ、空の場合があります。そのエンコードには、ベクターの前に付加される2バイトの実際の長さフィールドが含まれます。エンコードされたベクトルの長さは、単一の要素の長さの偶数倍でなければなりません（たとえば、uint16の17バイトのベクトルは不正です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       opaque mandatory&lt;300..400&gt;;
             /* length field is 2 bytes, cannot be empty */
       uint16 longer&lt;0..800&gt;;
             /* zero to 400 16-bit unsigned integers */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 数字
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed length series of bytes concatenated as described in Section 4.1 and are also unsigned. The following numeric types are predefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的な数値データ型は、符号なしバイト（uint8）です。より大きな数値データ型はすべて、セクション4.1で説明されているように連結された固定長の一連のバイトから形成され、これも符号なしです。次の数値タイプが事前定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       uint8 uint16[2];
       uint8 uint24[3];
       uint8 uint32[4];
       uint8 uint64[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All values, here and elsewhere in the specification, are stored in &#34;network&#34; or &#34;big-endian&#34; order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様のここや他の場所にあるすべての値は、「ネットワーク」または「ビッグエンディアン」の順序で格納されます。 16進バイト01 02 03 04で表されるuint32は、10進値16909060と同等です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Enumerateds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. 列挙型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared. Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enumと呼ばれる追加のスパースデータタイプを使用できます。 enum型のフィールドは、定義で宣言された値のみを想定できます。各定義は異なるタイプです。同じタイプの列挙型のみを割り当てたり、比較したりできます。次の例に示すように、列挙型のすべての要素に値を割り当てる必要があります。列挙型の要素は順序付けされていないため、一意の値を任意の順序で割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Enumerateds occupy as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙型は、バイトストリーム内で定義された最大の序数値と同じだけのスペースを占有します。次の定義では、1バイトを使用してColorタイプのフィールドを伝送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { red(3), blue(5), white(7) } Color;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element. In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2 or 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションで、関連するタグなしで値を指定して、余分な要素を定義せずに幅の定義を強制できます。次の例では、Tasteはデータストリームで2バイトを消費しますが、想定できる値は1、2、または4のみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The names of the elements of an enumeration are scoped within the defined type. In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙型の要素の名前は、定義された型内でスコープされます。最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueになります。割り当てのターゲットが明確に指定されている場合、そのような資格は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Color color = Color.blue;     /* overspecified, legal */
       Color color = blue;           /* correct, type implicit */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For enumerateds that are never converted to external representation, the numerical information may be omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
外部表現に変換されない列挙型の場合、数値情報は省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { low, medium, high } Amount;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Constructed types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 構築型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造型は、便宜上、プリミティブ型から構築できます。各仕様は、新しい一意の型を宣言します。定義の構文はCの構文によく似ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
         T1 f1;
         T2 f2;
         ...
         Tn fn;
       } [[T]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fields within a structure may be qualified using the type&#39;s name using a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体内のフィールドは、列挙型で使用できるものとよく似た構文を使用して、型の名前を使用して修飾できます。たとえば、T.f2は前の宣言の2番目のフィールドを参照します。構造定義を埋め込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. バリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義された構造には、環境内で利用可能ないくつかの知識に基づいたバリアントがある場合があります。セレクターは、構造が定義する可能なバリアントを定義する列挙型である必要があります。 selectで宣言された列挙のすべての要素にケースアームが必要です。バリアント構造の本体には、参照用のラベルを付けることができます。実行時にバリアントが選択されるメカニズムは、プレゼンテーション言語では規定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           T1 f1;
           T2 f2;
           ....
           Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               ....
               case en: Ten;
           } [[fv]];
       } [[Tv]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { apple, orange } VariantTag;
       struct {
           uint16 number;
           opaque string&lt;0..10&gt;; /* variable length */
       } V1;
       struct {
           uint32 number;
           opaque string[10];    /* fixed length */
       } V2;
       struct {
           select (VariantTag) { /* value of selector is implicit */
               case apple: V1;   /* VariantBody, tag = apple */
               case orange: V2;  /* VariantBody, tag = orange */
           } variant_body;       /* optional label on variant */
       } VariantRecord;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variant structures may be qualified (narrowed) by specifying a value for the selector prior to the type. For example, a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアント構造は、型の前にセレクターの値を指定することで修飾（狭め）できます。たとえば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
orange VariantRecord
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
オレンジVariantRecord
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is a narrowed type of a VariantRecord containing a variant_body of type V2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
V2型のvariant_bodyを含むVariantRecordのナロー型です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. Cryptographic attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 暗号属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The four cryptographic operations digital signing, stream cipher encryption, block cipher encryption, and public key encryption are designated digitally-signed, stream-ciphered, block-ciphered, and public-key-encrypted, respectively. A field&#39;s cryptographic processing is specified by prepending an appropriate key word designation before the field&#39;s type specification. Cryptographic keys are implied by the current session state (see Section 6.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デジタル署名、ストリーム暗号化、ブロック暗号化、および公開鍵暗号化の4つの暗号化操作は、それぞれデジタル署名、ストリーム暗号化、ブロック暗号化、および公開鍵暗号化に指定されます。フィールドの暗号処理は、フィールドのタイプ指定の前に適切なキーワード指定を付加することによって指定されます。暗号化キーは、現在のセッション状態によって暗示されます（セクション6.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In digital signing, one-way hash functions are used as input for a signing algorithm. A digitally-signed element is encoded as an opaque vector &lt;0..2^16-1&gt;, where the length is specified by the signing algorithm and key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デジタル署名では、一方向ハッシュ関数が署名アルゴリズムの入力として使用されます。デジタル署名された要素は、不透明なベクトル&lt;0..2 ^ 16-1&gt;としてエンコードされます。ここで、長さは署名アルゴリズムとキーによって指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In RSA signing, a 36-byte structure of two hashes (one SHA and one MD5) is signed (encrypted with the private key). It is encoded with PKCS #1 block type 0 or type 1 as described in [PKCS1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA署名では、2つのハッシュ（1つのSHAと1つのMD5）の36バイト構造が署名されます（秘密鍵で暗号化されます）。 [PKCS1]で説明されているように、PKCS＃1ブロックタイプ0またはタイプ1でエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In DSS, the 20 bytes of the SHA hash are run directly through the Digital Signing Algorithm with no additional hashing. This produces two values, r and s. The DSS signature is an opaque vector, as above, the contents of which are the DER encoding of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DSSでは、SHAハッシュの20バイトは、追加のハッシュなしでデジタル署名アルゴリズムを介して直接実行されます。これにより、rとsの2つの値が生成されます。上記のように、DSS署名は不透明なベクトルであり、その内容は次のDERエンコードです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Dss-Sig-Value  ::=  SEQUENCE  {
            r       INTEGER,
            s       INTEGER
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically-secure keyed pseudorandom number generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム暗号の暗号化では、平文は、暗号で保護されたキー付き擬似乱数ジェネレータから生成された同じ量の出力と排他的論理和がとられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In block cipher encryption, every block of plaintext encrypts to a block of ciphertext. All block cipher encryption is done in CBC (Cipher Block Chaining) mode, and all items which are block-ciphered will be an exact multiple of the cipher block length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック暗号化暗号化では、平文のすべてのブロックが暗号文のブロックに暗号化されます。すべてのブロック暗号化暗号化はCBC（Cipher Block Chaining）モードで行われ、ブロック暗号化されるすべてのアイテムは暗号化ブロック長の正確な倍数になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In public key encryption, a public key algorithm is used to encrypt data in such a way that it can be decrypted only with the matching private key. A public-key-encrypted element is encoded as an opaque vector &lt;0..2^16-1&gt;, where the length is specified by the signing algorithm and key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開鍵暗号化では、公開鍵アルゴリズムを使用して、一致する秘密鍵でのみ復号化できるようにデータを暗号化します。公開鍵で暗号化された要素は、不透明なベクトル&lt;0..2 ^ 16-1&gt;としてエンコードされ、長さは署名アルゴリズムと鍵によって指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RSA encrypted value is encoded with PKCS #1 block type 2 as described in [PKCS1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS1]で説明されているように、RSA暗号化値はPKCS＃1ブロックタイプ2でエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       stream-ciphered struct {
           uint8 field1;
           uint8 field2;
           digitally-signed opaque hash[20];
       } UserType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of hash are used as input for the signing algorithm, then the entire structure is encrypted with a stream cipher. The length of this structure, in bytes would be equal to 2 bytes for field1 and field2, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. This is known due to the fact that the algorithm and key used for the signing are known prior to encoding or decoding this structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュの内容は署名アルゴリズムの入力として使用され、構造全体がストリーム暗号で暗号化されます。この構造体の長さ（バイト単位）は、field1とfield2の2バイト、署名の長さの2バイト、および署名アルゴリズムの出力の長さになります。これは、署名に使用されるアルゴリズムとキーが、この構造をエンコードまたはデコードする前にわかっているためにわかっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. 定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it. Under-specified types (opaque, variable length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
型付き定数は、目的の型のシンボルを宣言してそれに値を割り当てることにより、仕様の目的で定義できます。指定不足の型（不透明、可変長ベクトル、不透明を含む構造体）には値を割り当てることができません。複数要素の構造体またはベクトルのフィールドは省略できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           uint8 f1;
           uint8 f2;
       } Example1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HMAC and the pseudorandom function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HMACと疑似ランダム関数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of operations in the TLS record and handshake layer required a keyed MAC; this is a secure digest of some data protected by a secret. Forging the MAC is infeasible without knowledge of the MAC secret. The construction we use for this operation is known as HMAC, described in [HMAC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSレコードとハンドシェイク層での多くの操作には、キー付きMACが必要でした。これは、シークレットで保護された一部のデータの安全なダイジェストです。 MACシークレットを知らなければ、MACの偽造は不可能です。この操作に使用する構造は、[HMAC]で説明されているHMACとして知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 HMAC can be used with a variety of different hash algorithms. TLS uses it in the handshake with two different algorithms: MD5 and SHA-1, denoting these as HMAC_MD5(secret, data) and HMAC_SHA(secret, data). Additional hash algorithms can be defined by cipher suites and used to protect record data, but MD5 and SHA-1 are hard coded into the description of the handshaking for this version of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
HMACは、さまざまな異なるハッシュアルゴリズムで使用できます。 TLSは、MD5とSHA-1の2つの異なるアルゴリズムを使用してハンドシェイクでそれを使用します。これらはHMAC_MD5（secret、data）およびHMAC_SHA（secret、data）として示されます。追加のハッシュアルゴリズムを暗号スイートで定義し、レコードデータを保護するために使用できますが、MD5とSHA-1は、このバージョンのプロトコルのハンドシェイクの説明にハードコーディングされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, a construction is required to do expansion of secrets into blocks of data for the purposes of key generation or validation. This pseudo-random function (PRF) takes as input a secret, a seed, and an identifying label and produces an output of arbitrary length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、キーの生成または検証のために、シークレットをデータのブロックに拡張するための構造が必要です。この疑似ランダム関数（PRF）は、シークレット、シード、および識別ラベルを入力として受け取り、任意の長さの出力を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to make the PRF as secure as possible, it uses two hash algorithms in a way which should guarantee its security if either algorithm remains secure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRFを可能な限り安全にするために、2つのハッシュアルゴリズムを使用して、いずれかのアルゴリズムが安全なままである場合にそのセキュリティを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, we define a data expansion function, P_hash(secret, data) which uses a single hash function to expand a secret and seed into an arbitrary quantity of output:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初に、単一のハッシュ関数を使用してシークレットを拡張し、任意の数の出力にシードするデータ拡張関数P_hash（secret、data）を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + HMAC_hash(secret, A(2) + seed) + HMAC_hash(secret, A(3) + seed) + ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
P_hash（secret、seed）= HMAC_hash（secret、A（1）+ seed）+ HMAC_hash（secret、A（2）+ seed）+ HMAC_hash（secret、A（3）+ seed）+ ...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where + indicates concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
+は連結を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   A() is defined as:
       A(0) = seed
       A(i) = HMAC_hash(secret, A(i-1))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P_hash can be iterated as many times as is necessary to produce the required quantity of data. For example, if P_SHA-1 was being used to create 64 bytes of data, it would have to be iterated 4 times (through A(4)), creating 80 bytes of output data; the last 16 bytes of the final iteration would then be discarded, leaving 64 bytes of output data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P_hashは、必要な量のデータを生成するために必要な回数だけ繰り返すことができます。たとえば、64バイトのデータを作成するためにP_SHA-1が使用されていた場合、（A（4）を介して）4回繰り返す必要があり、80バイトの出力データが作成されます。最後の反復の最後の16バイトは破棄され、64バイトの出力データが残ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS&#39;s PRF is created by splitting the secret into two halves and using one half to generate data with P_MD5 and the other half to generate data with P_SHA-1, then exclusive-or&#39;ing the outputs of these two expansion functions together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSのPRFは、シークレットを2つに分割し、半分を使用してP_MD5でデータを生成し、残りの半分をP_SHA-1でデータを生成してから、これら2つの拡張関数の出力を排他的論理和します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S1 and S2 are the two halves of the secret and each is the same length. S1 is taken from the first half of the secret, S2 from the second half. Their length is created by rounding up the length of the overall secret divided by two; thus, if the original secret is an odd number of bytes long, the last byte of S1 will be the same as the first byte of S2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S1とS2はシークレットの2つの半分であり、それぞれ同じ長さです。 S1は秘密の前半から、S2は後半から取得されます。それらの長さは、秘密全体の長さを2で割った値を切り上げて作成されます。したがって、元のシークレットが奇数バイト長である場合、S1の最後のバイトはS2の最初のバイトと同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       L_S = length in bytes of secret;
       L_S1 = L_S2 = ceil(L_S / 2);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secret is partitioned into two halves (with the possibility of one shared byte) as described above, S1 taking the first L_S1 bytes and S2 the last L_S2 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シークレットは、上記のように2つの半分に分割され（1つの共有バイトの可能性があります）、S1は最初のL_S1バイトを取り、S2は最後のL_S2バイトを取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PRF is then defined as the result of mixing the two pseudorandom streams by exclusive-or&#39;ing them together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRFは、2つの疑似ランダムストリームを排他的論理和することによって混合した結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
                                  P_SHA-1(S2, label + seed);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The label is an ASCII string. It should be included in the exact form it is given without a length byte or trailing null character. For example, the label &#34;slithy toves&#34; would be processed by hashing the following bytes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベルはASCII文字列です。これは、長さバイトまたは末尾のヌル文字なしで指定された正確な形式で含める必要があります。たとえば、「slithy toves」というラベルは、次のバイトをハッシュすることによって処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
73 6C 69 74 68 79 20 74 6F 76 65 73
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
73 Taq Taq 74 Taq Haq 20 74 Taq Taq 73
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that because MD5 produces 16 byte outputs and SHA-1 produces 20 byte outputs, the boundaries of their internal iterations will not be aligned; to generate a 80 byte output will involve P_MD5 being iterated through A(5), while P_SHA-1 will only iterate through A(4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5は16バイトの出力を生成し、SHA-1は20バイトの出力を生成するため、それらの内部反復の境界は整列されません。 80バイトの出力を生成するには、P_MD5がA（5）で反復されるのに対し、P_SHA-1はA（4）でのみ反復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. The TLS Record Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. TLSレコードプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. Received data is decrypted, verified, decompressed, and reassembled, then delivered to higher level clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS Record Protocolは階層型プロトコルです。各層で、メッセージには長さ、説明、および内容のフィールドが含まれる場合があります。 Record Protocolは、送信されるメッセージを受け取り、データを管理可能なブロックに断片化し、オプションでデータを圧縮し、MACを適用し、暗号化して、結果を送信します。受信したデータは、復号化、検証、解凍、再構成されてから、上位レベルのクライアントに配信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Four record protocol clients are described in this document: the handshake protocol, the alert protocol, the change cipher spec protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record types can be supported by the record protocol. Any new record types should allocate type values immediately beyond the ContentType values for the four record types described here (see Appendix A.2). If a TLS implementation receives a record type it does not understand, it should just ignore it. Any protocol designed for use over TLS must be carefully designed to deal with all possible attacks against it. Note that because the type and length of a record are not protected by encryption, care should be take to minimize the value of traffic analysis of these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ハンドシェイクプロトコル、アラートプロトコル、暗号仕様変更プロトコル、アプリケーションデータプロトコルの4つのレコードプロトコルクライアントについて説明します。 TLSプロトコルの拡張を可能にするために、追加のレコードタイプをレコードプロトコルでサポートできます。新しいレコードタイプでは、ここで説明する4つのレコードタイプのContentType値のすぐ上にタイプ値を割り当てる必要があります（付録A.2を参照）。 TLS実装が理解できないレコードタイプを受け取った場合、それを無視するだけです。 TLSを介して使用するために設計されたプロトコルは、それに対する可能なすべての攻撃に対処するように注意深く設計する必要があります。レコードのタイプと長さは暗号化によって保護されていないため、これらの値のトラフィック分析の値を最小限に抑えるように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Connection states
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 接続状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TLS connection state is the operating environment of the TLS Record Protocol. It specifies a compression algorithm, encryption algorithm, and MAC algorithm. In addition, the parameters for these algorithms are known: the MAC secret and the bulk encryption keys and IVs for the connection in both the read and the write directions. Logically, there are always four connection states outstanding: the current read and write states, and the pending read and write states. All records are processed under the current read and write states. The security parameters for the pending states can be set by the TLS Handshake Protocol, and the Handshake Protocol can selectively make either of the pending states current, in which case the appropriate current state is disposed of and replaced with the pending state; the pending state is then reinitialized to an empty state. It is illegal to make a state which has not been initialized with security parameters a current state. The initial current state always specifies that no encryption, compression, or MAC will be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS接続状態は、TLSレコードプロトコルの動作環境です。圧縮アルゴリズム、暗号化アルゴリズム、およびMACアルゴリズムを指定します。さらに、これらのアルゴリズムのパラメーターは既知です。読み取りと書き込みの両方向の接続のMACシークレットとバルク暗号化キーおよびIVです。論理的には、未処理の接続状態が常に4つあります。現在の読み取り状態と書き込み状態、および保留中の読み取り状態と書き込み状態です。すべてのレコードは、現在の読み取り状態と書き込み状態で処理されます。保留状態のセキュリティパラメータはTLSハンドシェイクプロトコルによって設定でき、ハンドシェイクプロトコルは保留状態のいずれかを選択的に最新にすることができます。この場合、適切な現在の状態が破棄され、保留状態に置き換えられます。次に、保留状態が空の状態に再初期化されます。セキュリティパラメータで初期化されていない状態を現在の状態にすることは違法です。初期の現在の状態では、暗号化、圧縮、またはMACが使用されないことが常に指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security parameters for a TLS Connection read and write state are set by providing the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS接続の読み取りおよび書き込み状態のセキュリティパラメータは、次の値を指定することによって設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
connection end Whether this entity is considered the &#34;client&#34; or the &#34;server&#34; in this connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンティティがこの接続で「クライアント」または「サーバー」と見なされるかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bulk encryption algorithm An algorithm to be used for bulk encryption. This specification includes the key size of this algorithm, how much of that key is secret, whether it is a block or stream cipher, the block size of the cipher (if appropriate), and whether it is considered an &#34;export&#34; cipher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バルク暗号化アルゴリズムバルク暗号化に使用されるアルゴリズム。この仕様には、このアルゴリズムのキーサイズ、秘密キーの量、ブロック暗号かストリーム暗号か、暗号のブロックサイズ（該当する場合）、および「エクスポート」暗号と見なされるかどうかが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC algorithm An algorithm to be used for message authentication. This specification includes the size of the hash which is returned by the MAC algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACアルゴリズムメッセージ認証に使用されるアルゴリズム。この仕様には、MACアルゴリズムによって返されるハッシュのサイズが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression algorithm An algorithm to be used for data compression. This specification must include all information the algorithm requires to do compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮アルゴリズムデータ圧縮に使用されるアルゴリズム。この仕様には、アルゴリズムが圧縮を行うために必要なすべての情報を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret A 48 byte secret shared between the two peers in the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスターシークレット接続の2つのピア間で共有される48バイトのシークレット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client random A 32 byte value provided by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントランダムクライアントが提供する32バイトの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server random A 32 byte value provided by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーランダムサーバーが提供する32バイトの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These parameters are defined in the presentation language as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのパラメータは、プレゼンテーション言語で次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { server, client } ConnectionEnd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null, rc4, rc2, des, 3des, des40 } BulkCipherAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { stream, block } CipherType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { true, false } IsExportable;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null, md5, sha } MACAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* The algorithms specified in CompressionMethod,
          BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ConnectionEnd          entity;
           BulkCipherAlgorithm    bulk_cipher_algorithm;
           CipherType             cipher_type;
           uint8                  key_size;
           uint8                  key_material_length;
           IsExportable           is_exportable;
           MACAlgorithm           mac_algorithm;
           uint8                  hash_size;
           CompressionMethod      compression_algorithm;
           opaque                 master_secret[48];
           opaque                 client_random[32];
           opaque                 server_random[32];
       } SecurityParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The record layer will use the security parameters to generate the following six items:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコードレイヤーは、セキュリティパラメーターを使用して、次の6つのアイテムを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
client write MAC secret server write MAC secret client write key server write key client write IV (for block ciphers only) server write IV (for block ciphers only)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
クライアント書き込みMACシークレットサーバー書き込みMACシークレットクライアント書き込みキーサーバー書き込みキークライアント書き込みIV（ブロック暗号のみ）サーバー書き込みIV（ブロック暗号のみ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client write parameters are used by the server when receiving and processing records and vice-versa. The algorithm used for generating these items from the security parameters is described in section 6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの書き込みパラメータは、レコードを受信して​​処理するときにサーバーによって使用され、その逆も同様です。セキュリティパラメータからこれらのアイテムを生成するために使用されるアルゴリズムは、セクション6.3で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states. These current states must be updated for each record processed. Each connection state includes the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティパラメータを設定してキーを生成したら、現在の状態にすることで接続状態をインスタンス化できます。これらの現在の状態は、処理されるレコードごとに更新する必要があります。各接続状態には、次の要素が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression state The current state of the compression algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮状態圧縮アルゴリズムの現在の状態。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher state The current state of the encryption algorithm. This will consist of the scheduled key for that connection. In addition, for block ciphers running in CBC mode (the only mode specified for TLS), this will initially contain the IV for that connection state and be updated to contain the ciphertext of the last block encrypted or decrypted as records are processed. For stream ciphers, this will contain whatever the necessary state information is to allow the stream to continue to encrypt or decrypt data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化状態暗号化アルゴリズムの現在の状態。これは、その接続用にスケジュールされたキーで構成されます。さらに、CBCモード（TLSに指定された唯一のモード）で実行されているブロック暗号の場合、これはその接続状態のIVを最初に含み、レコードが処理されるときに暗号化または復号化された最後のブロックの暗号文を含むように更新されます。ストリーム暗号の場合、ストリームにデータの暗号化または復号化を継続させるために必要な状態情報が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC secret The MAC secret for this connection as generated above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACシークレット上記で生成された、この接続のMACシークレット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence number Each connection state contains a sequence number, which is maintained separately for read and write states. The sequence number must be set to zero whenever a connection state is made the active state. Sequence numbers are of type uint64 and may not exceed 2^64-1. A sequence number is incremented after each record: specifically, the first record which is transmitted under a particular connection state should use sequence number 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号各接続状態にはシーケンス番号が含まれており、読み取り状態と書き込み状態で別々に保持されます。接続状態がアクティブ状態になるときは常に、シーケンス番号をゼロに設定する必要があります。シーケンス番号のタイプはuint64で、2 ^ 64-1を超えることはできません。シーケンス番号は、各レコードの後に​​増分されます。具体的には、特定の接続状態で送信される最初のレコードは、シーケンス番号0を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Record layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 記録層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Record Layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS Record Layerは、任意のサイズの空でないブロックで上位の層から未解釈のデータを受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. 断片化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Client message boundaries are not preserved in the record layer (i.e., multiple client messages of the same ContentType may be coalesced into a single TLSPlaintext record, or a single message may be fragmented across several records).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコード層は、情報ブロックを2 ^ 14バイト以下のチャンクでデータを運ぶTLSPlaintextレコードにフラグメント化します。クライアントメッセージの境界はレコードレイヤーに保持されません（つまり、同じContentTypeの複数のクライアントメッセージが単一のTLSPlaintextレコードに結合されるか、単一のメッセージが複数のレコードにフラグメント化される可能性があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           uint8 major, minor;
       } ProtocolVersion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum {
           change_cipher_spec(20), alert(21), handshake(22),
           application_data(23), (255)
       } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           opaque fragment[TLSPlaintext.length];
       } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The higher level protocol used to process the enclosed fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type囲まれたフラグメントの処理に使用される上位レベルのプロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The version of the protocol being employed. This document describes TLS Version 1.0, which uses the version { 3, 1 }. The version value 3.1 is historical: TLS version 1.0 is a minor modification to the SSL 3.0 protocol, which bears the version value 3.0. (See Appendix A.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version使用されているプロトコルのバージョン。このドキュメントでは、バージョン{3、1}を使用するTLSバージョン1.0について説明します。バージョン値3.1は歴史的なものです。TLSバージョン1.0は、SSL 3.0プロトコルのマイナーな変更であり、バージョン値3.0を備えています。 （付録A.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSPlaintext.fragment. The length should not exceed 2^14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length次のTLSPlaintext.fragmentの長さ（バイト単位）。長さは2 ^ 14を超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The application data. This data is transparent and treated as an independent block to be dealt with by the higher level protocol specified by the type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントアプリケーションデータ。このデータは透過的で、typeフィールドで指定された上位レベルのプロトコルで処理される独立したブロックとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Data of different TLS Record layer content types may be interleaved. Application data is generally of lower precedence for transmission than other content types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：TLSレコードレイヤーのコンテンツタイプが異なるデータはインターリーブされる場合があります。アプリケーションデータは一般に、他のコンテンツタイプよりも送信の優先順位が低くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. Record compression and decompression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. レコードの圧縮と解凍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All records are compressed using the compression algorithm defined in the current session state. There is always an active compression algorithm; however, initially it is defined as CompressionMethod.null. The compression algorithm translates a TLSPlaintext structure into a TLSCompressed structure. Compression functions are initialized with default state information whenever a connection state is made active.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのレコードは、現在のセッション状態で定義された圧縮アルゴリズムを使用して圧縮されます。常にアクティブな圧縮アルゴリズムがあります。ただし、最初はCompressionMethod.nullとして定義されています。圧縮アルゴリズムは、TLSPlaintext構造をTLSCompressed構造に変換します。接続状態がアクティブになると、圧縮関数はデフォルトの状態情報で初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compression must be lossless and may not increase the content length by more than 1024 bytes. If the decompression function encounters a TLSCompressed.fragment that would decompress to a length in excess of 2^14 bytes, it should report a fatal decompression failure error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮はロスレスでなければならず、コンテンツの長さが1024バイトを超えないようにする必要があります。解凍関数が2 ^ 14バイトを超える長さに解凍するTLSCompressed.fragmentを検出した場合、致命的な解凍エラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ContentType type;       /* same as TLSPlaintext.type */
           ProtocolVersion version;/* same as TLSPlaintext.version */
           uint16 length;
           opaque fragment[TLSCompressed.length];
       } TLSCompressed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSCompressed.fragment. The length should not exceed 2^14 + 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length次のTLSCompressed.fragmentの長さ（バイト単位）。長さは2 ^ 14 + 1024を超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The compressed form of TLSPlaintext.fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment TLSPlaintext.fragmentの圧縮形式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: A CompressionMethod.null operation is an identity operation; no fields are altered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：CompressionMethod.null操作はID操作です。フィールドは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note: Decompression functions are responsible for ensuring that messages cannot cause internal buffer overflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：解凍関数は、メッセージが内部バッファオーバーフローを引き起こさないようにする責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. Record payload protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. ペイロード保護の記録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encryption and MAC functions translate a TLSCompressed structure into a TLSCiphertext. The decryption functions reverse the process. The MAC of the record also includes a sequence number so that missing, extra or repeated messages are detectable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化およびMAC関数は、TLSCompressed構造をTLSCiphertextに変換します。復号化関数はプロセスを逆にします。レコードのMACにはシーケンス番号も含まれているため、欠落、余分、または繰り返しのメッセージを検出できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           select (CipherSpec.cipher_type) {
               case stream: GenericStreamCipher;
               case block: GenericBlockCipher;
           } fragment;
       } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type field is identical to TLSCompressed.type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type typeフィールドはTLSCompressed.typeと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The version field is identical to TLSCompressed.version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version versionフィールドはTLSCompressed.versionと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSCiphertext.fragment. The length may not exceed 2^14 + 2048.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length次のTLSCiphertext.fragmentの長さ（バイト単位）。長さは2 ^ 14 + 2048を超えることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The encrypted form of TLSCompressed.fragment, with the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment暗号化された形式のTLSCompressed.fragmentとMAC。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.1. Null or standard stream cipher
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.1. ヌルまたは標準のストリーム暗号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stream ciphers (including BulkCipherAlgorithm.null - see Appendix A.6) convert TLSCompressed.fragment structures to and from stream TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム暗号（BulkCipherAlgorithm.nullを含む-付録A.6を参照）は、TLSCompressed.fragment構造をストリームTLSCiphertext.fragment構造との間で変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       stream-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
       } GenericStreamCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MAC is generated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACは次のように生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +
                     TLSCompressed.version + TLSCompressed.length +
                     TLSCompressed.fragment));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where &#34;+&#34; denotes concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「+」は連結を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seq_num The sequence number for this record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seq_numこのレコードのシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash The hashing algorithm specified by SecurityParameters.mac_algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash SecurityParameters.mac_algorithmで指定されたハッシュアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the MAC is computed before encryption. The stream cipher encrypts the entire block, including the MAC. For stream ciphers that do not use a synchronization vector (such as RC4), the stream cipher state from the end of one record is simply used on the subsequent packet. If the CipherSuite is TLS_NULL_WITH_NULL_NULL, encryption consists of the identity operation (i.e., the data is not encrypted and the MAC size is zero implying that no MAC is used). TLSCiphertext.length is TLSCompressed.length plus CipherSpec.hash_size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACは暗号化の前に計算されることに注意してください。ストリーム暗号は、MACを含むブロック全体を暗号化します。同期ベクトルを使用しないストリーム暗号（RC4など）の場合、1つのレコードの末尾からのストリーム暗号状態は、後続のパケットで単に使用されます。 CipherSuiteがTLS_NULL_WITH_NULL_NULLの場合、暗号化はID操作で構成されます（つまり、データは暗号化されず、MACサイズはゼロであり、MACが使用されないことを意味します）。 TLSCiphertext.lengthは、TLSCompressed.lengthにCipherSpec.hash_sizeを加えたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.2. CBC block cipher
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.2. CBCブロック暗号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For block ciphers (such as RC2 or DES), the encryption and MAC functions convert TLSCompressed.fragment structures to and from block TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック暗号（RC2やDESなど）の場合、暗号化およびMAC関数は、TLSCompressed.fragment構造とブロックTLSCiphertext.fragment構造との間の変換を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       } GenericBlockCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MAC is generated as described in Section 6.2.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACはセクション6.2.3.1で説明されているように生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding Padding that is added to force the length of the plaintext to be an integral multiple of the block cipher&#39;s block length. The padding may be any length up to 255 bytes long, as long as it results in the TLSCiphertext.length being an integral multiple of the block length. Lengths longer than necessary might be desirable to frustrate attacks on a protocol based on analysis of the lengths of exchanged messages. Each uint8 in the padding data vector must be filled with the padding length value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
平文の長さをブロック暗号のブロック長の整数倍にするために追加されるパディング。埋め込みは、TLSCiphertext.lengthがブロック長の整数倍になる限り、255バイトまでの長さの任意の長さでかまいません。交換されたメッセージの長さの分析に基づいてプロトコルへの攻撃を妨げるには、必要以上に長い長さが望ましい場合があります。パディングデータベクトルの各uint8には、パディング長の値を入力する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding_length The padding length should be such that the total size of the GenericBlockCipher structure is a multiple of the cipher&#39;s block length. Legal values range from zero to 255, inclusive. This length specifies the length of the padding field exclusive of the padding_length field itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding_lengthパディングの長さは、GenericBlockCipher構造の合計サイズが暗号のブロック長の倍数になるようにする必要があります。有効な値の範囲は0〜255です。この長さは、padding_lengthフィールド自体を除いたpaddingフィールドの長さを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encrypted data length (TLSCiphertext.length) is one more than the sum of TLSCompressed.length, CipherSpec.hash_size, and padding_length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化されたデータの長さ（TLSCiphertext.length）は、TLSCompressed.length、CipherSpec.hash_size、およびpadding_lengthの合計よりも1つ長くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Example: If the block length is 8 bytes, the content length (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, the length before padding is 82 bytes. Thus, the padding length modulo 8 must be equal to 6 in order to make the total length an even multiple of 8 bytes (the block length). The padding length can be 6, 14, 22, and so on, through 254. If the padding length were the minimum necessary, 6, the padding would be 6 bytes, each containing the value 6. Thus, the last 8 octets of the GenericBlockCipher before block encryption would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
例：ブロック長が8バイト、コンテンツ長（TLSCompressed.length）が61バイト、MAC長が20バイトの場合、パディング前の長さは82バイトです。したがって、合計長を8バイト（ブロック長）の偶数倍にするためには、8を法とするパディング長は6に等しくなければなりません。パディングの長さは、6、14、22などで、254まで可能です。パディングの長さが最低限必要な6である場合、パディングは6バイトであり、それぞれに値6が含まれます。したがって、最後の8オクテットブロック暗号化前のGenericBlockCipherはxx 06 06 06 06 06 06 06となります。ここで、xxはMACの最後のオクテットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: With block ciphers in CBC mode (Cipher Block Chaining) the initialization vector (IV) for the first record is generated with the other keys and secrets when the security parameters are set. The IV for subsequent records is the last ciphertext block from the previous record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：CBCモード（暗号ブロックチェーン）のブロック暗号では、最初のレコードの初期化ベクトル（IV）は、セキュリティパラメーターが設定されているときに他のキーとシークレットを使用して生成されます。後続のレコードのIVは、前のレコードの最後の暗号文ブロックです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Key calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. キー計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Record Protocol requires an algorithm to generate keys, IVs, and MAC secrets from the security parameters provided by the handshake protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコードプロトコルには、ハンドシェイクプロトコルによって提供されるセキュリティパラメータからキー、IV、およびMACシークレットを生成するアルゴリズムが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master secret is hashed into a sequence of secure bytes, which are assigned to the MAC secrets, keys, and non-export IVs required by the current connection state (see Appendix A.6). CipherSpecs require a client write MAC secret, a server write MAC secret, a client write key, a server write key, a client write IV, and a server write IV, which are generated from the master secret in that order. Unused values are empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスターシークレットは、セキュアバイトのシーケンスにハッシュされ、MACシークレット、キー、および現在の接続状態で必要な非エクスポートIVに割り当てられます（付録A.6を参照）。 CipherSpecには、クライアントシークレットMACシークレット、サーバー書き込みMACシークレット、クライアント書き込みキー、サーバー書き込みキー、クライアント書き込みIV、およびサーバー書き込みIVが必要です。これらは、マスターシークレットからこの順序で生成されます。未使用の値は空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When generating keys and MAC secrets, the master secret is used as an entropy source, and the random values provide unencrypted salt material and IVs for exportable ciphers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵とMACシークレットを生成するとき、マスターシークレットはエントロピーソースとして使用され、ランダムな値は暗号化されていないソルトマテリアルとエクスポート可能な暗号のIVを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To generate the key material, compute
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーマテリアルを生成するには、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
key_block = PRF(SecurityParameters.master_secret, &#34;key expansion&#34;, SecurityParameters.server_random + SecurityParameters.client_random);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
key_block = PRF（SecurityParameters.master_secret、 &#34;key Expansion&#34;、SecurityParameters.server_random + SecurityParameters.client_random）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
until enough output has been generated. Then the key_block is partitioned as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
十分な出力が生成されるまで。次に、key_blockは次のようにパーティション化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       client_write_MAC_secret[SecurityParameters.hash_size]
       server_write_MAC_secret[SecurityParameters.hash_size]
       client_write_key[SecurityParameters.key_material_length]
       server_write_key[SecurityParameters.key_material_length]
       client_write_IV[SecurityParameters.IV_size]
       server_write_IV[SecurityParameters.IV_size]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client_write_IV and server_write_IV are only generated for non-export block ciphers. For exportable block ciphers, the initialization vectors are generated later, as described below. Any extra key_block material is discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client_write_IVおよびserver_write_IVは、非エクスポートブロック暗号に対してのみ生成されます。エクスポート可能なブロック暗号の場合、以下で説明するように、初期化ベクトルは後で生成されます。余分なkey_blockマテリアルは破棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note: The cipher spec which is defined in this document which requires the most material is 3DES_EDE_CBC_SHA: it requires 2 x 24 byte keys, 2 x 20 byte MAC secrets, and 2 x 8 byte IVs, for a total of 104 bytes of key material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装に関するメモ：このドキュメントで定義されている、最も多くの資料を必要とする暗号仕様は、3DES_EDE_CBC_SHAです：24バイトの鍵2つ、20バイトのMACシークレット2つ、8バイトのIV 2つが必要で、合計104バイトの鍵が必要です。素材。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Exportable encryption algorithms (for which CipherSpec.is_exportable is true) require additional processing as follows to derive their final write keys:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エクスポート可能な暗号化アルゴリズム（CipherSpec.is_exportableがtrueの場合）では、最終的な書き込みキーを取得するために、次の追加処理が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       final_client_write_key =
       PRF(SecurityParameters.client_write_key,
                                  &#34;client write key&#34;,
                                  SecurityParameters.client_random +
                                  SecurityParameters.server_random);
       final_server_write_key =
       PRF(SecurityParameters.server_write_key,
                                  &#34;server write key&#34;,
                                  SecurityParameters.client_random +
                                  SecurityParameters.server_random);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Exportable encryption algorithms derive their IVs solely from the random values from the hello messages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エクスポート可能な暗号化アルゴリズムは、helloメッセージのランダムな値からのみIVを導出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iv_block = PRF(&#34;&#34;, &#34;IV block&#34;, SecurityParameters.client_random +
                      SecurityParameters.server_random);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The iv_block is partitioned into two initialization vectors as the key_block was above:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iv_blockは、key_blockが上記のように2つの初期化ベクトルに分割されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
client_write_IV[SecurityParameters.IV_size] server_write_IV[SecurityParameters.IV_size]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
client_write_IV [SecurityParameters.IV_size] server_write_IV [SecurityParameters.IV_size]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the PRF is used without a secret in this case: this just means that the secret has a length of zero bytes and contributes nothing to the hashing in the PRF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、PRFはシークレットなしで使用されることに注意してください。これは、シークレットの長さが0バイトであり、PRFのハッシュに何も寄与しないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Export key generation example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. 鍵生成の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 requires five random bytes for each of the two encryption keys and 16 bytes for each of the MAC keys, for a total of 42 bytes of key material. The PRF output is stored in the key_block. The key_block is partitioned, and the write keys are salted because this is an exportable encryption algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5では、2つの暗号化キーそれぞれに5バイトのランダムなバイトと、各MACキーに16バイトが必要で、合計で42バイトのキーマテリアルが必要です。 PRF出力はkey_blockに格納されます。 key_blockはパーティション化されており、これはエクスポート可能な暗号化アルゴリズムであるため、書き込みキーはソルト処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       key_block               = PRF(master_secret,
                                     &#34;key expansion&#34;,
                                     server_random +
                                     client_random)[0..41]
       client_write_MAC_secret = key_block[0..15]
       server_write_MAC_secret = key_block[16..31]
       client_write_key        = key_block[32..36]
       server_write_key        = key_block[37..41]
final_client_write_key  = PRF(client_write_key,
                                     &#34;client write key&#34;,
                                     client_random +
                                     server_random)[0..15]
       final_server_write_key  = PRF(server_write_key,
                                     &#34;server write key&#34;,
                                     client_random +
                                     server_random)[0..15]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iv_block                = PRF(&#34;&#34;, &#34;IV block&#34;, client_random +
                                     server_random)[0..15]
       client_write_IV = iv_block[0..7]
       server_write_IV = iv_block[8..15]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. The TLS Handshake Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. TLSハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Handshake Protocol consists of a suite of three sub-protocols which are used to allow peers to agree upon security parameters for the record layer, authenticate themselves, instantiate negotiated security parameters, and report error conditions to each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクプロトコルは、ピアがレコードレイヤーのセキュリティパラメーターについて合意し、自身を認証し、ネゴシエートされたセキュリティパラメーターをインスタンス化し、エラー状態を互いに報告するために使用される3つのサブプロトコルのスイートで構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Handshake Protocol is responsible for negotiating a session, which consists of the following items:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクプロトコルは、次の項目で構成されるセッションのネゴシエーションを担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session identifier An arbitrary byte sequence chosen by the server to identify an active or resumable session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション識別子アクティブまたは再開可能なセッション状態を識別するためにサーバーによって選択された任意のバイトシーケンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
peer certificate X509v3 [X509] certificate of the peer. This element of the state may be null.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア証明書X509v3 [X509]ピアの証明書。状態のこの要素はnullである可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression method The algorithm used to compress data prior to encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮方式暗号化の前にデータを圧縮するために使用されるアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher spec Specifies the bulk data encryption algorithm (such as null, DES, etc.) and a MAC algorithm (such as MD5 or SHA). It also defines cryptographic attributes such as the hash_size. (See Appendix A.6 for formal definition)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号仕様バルクデータ暗号化アルゴリズム（null、DESなど）とMACアルゴリズム（MD5またはSHAなど）を指定します。また、hash_sizeなどの暗号化属性も定義します。 （正式な定義については、付録A.6を参照してください）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret 48-byte secret shared between the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスターシークレットクライアントとサーバー間で共有される48バイトのシークレット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is resumable A flag indicating whether the session can be used to initiate new connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is resumableセッションを使用して新しい接続を開始できるかどうかを示すフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These items are then used to create security parameters for use by the Record Layer when protecting application data. Many connections can be instantiated using the same session through the resumption feature of the TLS Handshake Protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、これらのアイテムを使用して、アプリケーションデータを保護するときにレコードレイヤーで使用するセキュリティパラメーターを作成します。 TLSハンドシェイクプロトコルの再開機能により、同じセッションを使用して多くの接続をインスタンス化できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Change cipher spec protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 暗号仕様プロトコルを変更する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change cipher spec protocol exists to signal transitions in ciphering strategies. The protocol consists of a single message, which is encrypted and compressed under the current (not the pending) connection state. The message consists of a single byte of value 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号仕様の変更プロトコルは、暗号化戦略の移行を知らせるために存在します。プロトコルは単一のメッセージで構成され、現在の（保留中ではない）接続状態で暗号化および圧縮されます。メッセージは、値1の1バイトで構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           enum { change_cipher_spec(1), (255) } type;
       } ChangeCipherSpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change cipher spec message is sent by both the client and server to notify the receiving party that subsequent records will be protected under the newly negotiated CipherSpec and keys. Reception of this message causes the receiver to instruct the Record Layer to immediately copy the read pending state into the read current state. Immediately after sending this message, the sender should instruct the record layer to make the write pending state the write active state. (See section 6.1.) The change cipher spec message is sent during the handshake after the security parameters have been agreed upon, but before the verifying finished message is sent (see section 7.4.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号仕様変更メッセージは、クライアントとサーバーの両方から送信され、新しくネゴシエートされたCipherSpecとキーの下で後続のレコードが保護されることを受信側に通知します。このメッセージを受信すると、受信側はレコードレイヤーに読み取り保留状態を読み取り現在状態にすぐにコピーするように指示します。このメッセージを送信した直後に、送信者はレコードレイヤーに書き込み保留状態を書き込みアクティブ状態にするように指示する必要があります。 （セクション6.1を参照してください。）暗号仕様変更メッセージは、セキュリティパラメータが合意された後、ハンドシェイク中に送信されますが、検証完了メッセージが送信されます（セクション7.4.9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Alert protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. アラートプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the content types supported by the TLS Record layer is the alert type. Alert messages convey the severity of the message and a description of the alert. Alert messages with a level of fatal result in the immediate termination of the connection. In this case, other connections corresponding to the session may continue, but the session identifier must be invalidated, preventing the failed session from being used to establish new connections. Like other messages, alert messages are encrypted and compressed, as specified by the current connection state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSレコードレイヤーでサポートされているコンテンツタイプの1つはアラートタイプです。アラートメッセージは、メッセージの重大度とアラートの説明を伝えます。致命的なレベルのアラートメッセージは、接続を即座に終了させます。この場合、セッションに対応する他の接続は続行できますが、セッション識別子を無効にして、失敗したセッションが新しい接続の確立に使用されないようにする必要があります。他のメッセージと同様に、現在の接続状態で指定されているように、アラートメッセージは暗号化および圧縮されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum {
           close_notify(0),
           unexpected_message(10),
           bad_record_mac(20),
           decryption_failed(21),
           record_overflow(22),
           decompression_failure(30),
           handshake_failure(40),
           bad_certificate(42),
           unsupported_certificate(43),
           certificate_revoked(44),
           certificate_expired(45),
           certificate_unknown(46),
           illegal_parameter(47),
           unknown_ca(48),
           access_denied(49),
           decode_error(50),
           decrypt_error(51),
           export_restriction(60),
           protocol_version(70),
           insufficient_security(71),
           internal_error(80),
           user_canceled(90),
           no_renegotiation(100),
           (255)
       } AlertDescription;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           AlertLevel level;
           AlertDescription description;
       } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. Closure alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. 閉鎖アラート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Either party may initiate the exchange of closing messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーは、切り捨て攻撃を回避するために、接続が終了しているという知識を共有する必要があります。どちらの当事者も終了メッセージの交換を開始できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
close_notify This message notifies the recipient that the sender will not send any more messages on this connection. The session becomes unresumable if any connection is terminated without proper close_notify messages with level equal to warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
close_notifyこのメッセージは、送信者がこの接続でこれ以上メッセージを送信しないことを受信者に通知します。警告に等しいレベルの適切なclose_notifyメッセージなしで接続が終了すると、セッションは再開できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Either party may initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらのパーティも、close_notifyアラートを送信してクローズを開始できます。閉鎖アラートの後に受信したデータは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each party is required to send a close_notify alert before closing the write side of the connection. It is required that the other party respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes. It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各パーティは、接続の書き込み側を閉じる前にclose_notifyアラートを送信する必要があります。相手は自分のclose_notifyアラートで応答し、接続をすぐに閉じて、保留中の書き込みを破棄する必要があります。クローズのイニシエーターが、接続の読み取り側を閉じる前に、応答するclose_notifyアラートを待つ必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding close_notify alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation may choose to close the transport without waiting for the responding close_notify. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSを使用するアプリケーションプロトコルが、TLS接続が閉じられた後、基になるトランスポートを介してデータが伝送される可能性がある場合、TLS実装は、TLS接続が終了したことをアプリケーション層に示す前に、応答するclose_notifyアラートを受信する必要があります。アプリケーションプロトコルが追加のデータを転送せず、基礎となるトランスポート接続のみを閉じる場合、実装は、応答するclose_notifyを待たずにトランスポートを閉じることを選択できます。この標準のどの部分も、接続のオープンまたはクローズ時を含め、TLSの使用プロファイルがデータ転送を管理する方法を決定するために取られるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NB: It is assumed that closing a connection reliably delivers pending data before destroying the transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：接続を閉じると、トランスポートを破棄する前に、保留中のデータが確実に配信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. Error alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. エラーアラート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error handling in the TLS Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Upon transmission or receipt of an fatal alert message, both parties immediately close the connection. Servers and clients are required to forget any session-identifiers, keys, and secrets associated with a failed connection. The following error alerts are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクプロトコルでのエラー処理は非常に簡単です。エラーが検出されると、検出側は相手にメッセージを送信します。致命的な警告メッセージを送信または受信すると、両方の当事者はすぐに接続を閉じます。サーバーとクライアントは、失敗した接続に関連付けられたセッション識別子、キー、およびシークレットを忘れる必要があります。次のエラーアラートが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unexpected_message An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予期しないメッセージを受信しました。このアラートは常に致命的であり、適切な実装間の通信で監視されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_record_mac This alert is returned if a record is received with an incorrect MAC. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_record_macこのアラートは、不正なMACでレコードを受信した場合に返されます。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decryption_failed A TLSCiphertext decrypted in an invalid way: either it wasn`t an even multiple of the block length or its padding values, when checked, weren`t correct. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decryption_failed TLSCiphertextが無効な方法で復号化されました。ブロック長の偶数倍でなかったか、チェックされたときのパディング値が正しくありませんでした。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
record_overflow A TLSCiphertext record was received which had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
record_overflow 2 ^ 14 + 2048バイトを超える長さのTLSCiphertextレコード、または2 ^ 14 + 1024バイトを超えるTLSCompressedレコードに復号化されたレコードを受信しました。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decompression_failure The decompression function received improper input (e.g. data that would expand to excessive length). This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decompression_failure解凍関数が不適切な入力（たとえば、過度に長くなるデータ）を受け取りました。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
handshake_failure Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
handshake_failure handshake_failureアラートメッセージの受信は、使用可能なオプションが指定されている場合、送信者が許容可能なセキュリティパラメータのセットをネゴシエートできなかったことを示します。これは致命的なエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_certificate A certificate was corrupt, contained signatures that did not verify correctly, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_certificate証明書が破損しているか、正しく検証されない署名が含まれているなど。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsupported_certificate A certificate was of an unsupported type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsupported_certificate証明書のタイプはサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_revoked A certificate was revoked by its signer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_revoked証明書が署名者によって取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_expired A certificate has expired or is not currently valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_expired証明書の有効期限が切れているか、現在有効ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_unknown Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_unknown証明書の処理中に他の（指定されていない）問題が発生し、受け入れられなくなりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
illegal_parameter A field in the handshake was out of range or inconsistent with other fields. This is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
illegal_parameterハンドシェイクのフィールドが範囲外であるか、他のフィールドと矛盾しています。これは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unknown_ca A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn`t be matched with a known, trusted CA. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unknown_ca有効な証明書チェーンまたは部分チェーンを受け取りましたが、CA証明書が見つからなかったか、既知の信頼できるCAと一致しなかったため、証明書は受け入れられませんでした。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
access_denied A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
access_denied有効な証明書が受信されましたが、アクセス制御が適用されたときに、送信者はネゴシエーションを続行しないことを決定しました。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decode_error A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decode_error一部のフィールドが指定された範囲外だったか、メッセージの長さが正しくなかったため、メッセージをデコードできませんでした。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decrypt_error A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decrypt_errorハンドシェイク暗号化操作が失敗しました。これには、署名の正しい検証、鍵交換の復号化、完成したメッセージの検証などが含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
export_restriction A negotiation not in compliance with export restrictions was detected; for example, attempting to transfer a 1024 bit ephemeral RSA key for the RSA_EXPORT handshake method. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
export_restriction輸出規制に準拠していない交渉が検出されました。たとえば、RSA_EXPORTハンドシェイクメソッドの1024ビットの一時的なRSAキーを転送しようとしています。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
protocol_version The protocol version the client has attempted to negotiate is recognized, but not supported. (For example, old protocol versions might be avoided for security reasons). This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
protocol_versionクライアントがネゴシエートしようとしたプロトコルバージョンは認識されますが、サポートされていません。 （たとえば、古いプロトコルバージョンは、セキュリティ上の理由から回避される場合があります）。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
insufficient_security Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントでサポートされているものよりも安全な暗号を必要とするため、ネゴシエーションが失敗したときにhandshake_failureの代わりに不十分なセキュリティが返されます。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
internal_error An internal error unrelated to the peer or the correctness of the protocol makes it impossible to continue (such as a memory allocation failure). This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
internal_errorピアに関係のない内部エラーまたはプロトコルの正確さにより、続行が不可能になります（メモリ割り当ての失敗など）。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
user_canceled This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
user_canceledこのハンドシェイクは、プロトコル障害とは無関係の何らかの理由でキャンセルされています。ハンドシェイクの完了後にユーザーが操作をキャンセルした場合は、close_notifyを送信して接続を閉じるだけの方が適切です。このアラートの後には、close_notifyが続く必要があります。このメッセージは通常警告です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_renegotiation Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert; at that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate would be where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_renegotiation最初のハンドシェイク後に、hello要求に応答してクライアントから送信されるか、クライアントhelloに応答してサーバーから送信されます。これらのいずれかは通常、再交渉につながります。それが適切でない場合、受信者はこのアラートで応答する必要があります。その時点で、元のリクエスターは接続を続行するかどうかを決定できます。これが適切なケースの1つは、サーバーが要求を満たすためにプロセスを生成した場合です。プロセスは、起動時にセキュリティパラメータ（キーの長さ、認証など）を受け取り、その後のこれらのパラメータの変更を伝達することが困難になる場合があります。このメッセージは常に警告です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For all errors where an alert level is not explicitly specified, the sending party may determine at its discretion whether this is a fatal error or not; if an alert with a level of warning is received, the receiving party may decide at its discretion whether to treat this as a fatal error or not. However, all messages which are transmitted with a level of fatal must be treated as fatal messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
アラートレベルが明示的に指定されていないすべてのエラーについて、送信側は、その裁量でこれが致命的なエラーであるかどうかを判断できます。警告レベルのアラートが受信された場合、受信側は独自の裁量でこれを致命的なエラーとして扱うかどうかを決定できます。ただし、致命的なレベルで送信されるすべてのメッセージは、致命的なメッセージとして処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Handshake Protocol overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. ハンドシェイクプロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS Record Layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and use public-key encryption techniques to generate shared secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション状態の暗号パラメーターは、TLSレコードレイヤー上で動作するTLSハンドシェイクプロトコルによって生成されます。 TLSクライアントとサーバーが最初に通信を開始すると、プロトコルバージョンに同意し、暗号化アルゴリズムを選択し、必要に応じて相互に認証し、公開鍵暗号化技術を使用して共有秘密を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Handshake Protocol involves the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクプロトコルには、次の手順が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Exchange hello messages to agree on algorithms, exchange random values, and check for session resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- helloメッセージを交換してアルゴリズムについて合意し、ランダムな値を交換し、セッションの再開を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Exchange the necessary cryptographic parameters to allow the client and server to agree on a premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 必要な暗号化パラメーターを交換して、クライアントとサーバーがプリマスターシークレットについて合意できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Exchange certificates and cryptographic information to allow the client and server to authenticate themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 証明書と暗号化情報を交換して、クライアントとサーバーが自分自身を認証できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Generate a master secret from the premaster secret and exchanged random values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- プリマスターシークレットからマスターシークレットを生成し、ランダムな値を交換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Provide security parameters to the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- レコードパラメータにセキュリティパラメータを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Allow the client and server to verify that their peer has calculated the same security parameters and that the handshake occurred without tampering by an attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- クライアントとサーバーが、ピアが同じセキュリティパラメータを計算したことと、攻撃者が改ざんせずにハンドシェイクが行われたことを確認できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that higher layers should not be overly reliant on TLS always negotiating the strongest possible connection between two peers: there are a number of ways a man in the middle attacker can attempt to make two entities drop down to the least secure method they support. The protocol has been designed to minimize this risk, but there are still attacks available: for example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure, in that any cipher suite offers its promised level of security: if you negotiate 3DES with a 1024 bit RSA key exchange with a host whose certificate you have verified, you can expect to be that secure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上位層は常に2つのピア間の最強の接続をネゴシエートするTLSに過度に依存してはならないことに注意してください。中間の攻撃者が2つのエンティティを、サポートする最も安全性の低い方法にドロップダウンさせる方法はいくつかあります。プロトコルはこのリスクを最小限に抑えるように設計されていますが、利用可能な攻撃はまだあります。たとえば、攻撃者は安全なサービスが実行されているポートへのアクセスをブロックしたり、ピアに認証されていない接続をネゴシエートさせたりする可能性があります。基本的なルールは、より高いレベルはセキュリティ要件が何であるかを認識している必要があり、必要以上に安全性の低いチャネルを介して情報を送信してはならないということです。 TLSプロトコルは安全であり、どの暗号スイートも約束されたレベルのセキュリティを提供します。1024ビットのRSA鍵交換で3DESを、証明書を検証したホストとネゴシエートすると、その安全性が期待できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, you should never send data over a link encrypted with 40 bit security unless you feel that data is worth no more than the effort required to break that encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、暗号化を解除するために必要な労力以上の価値がないと感じる場合を除き、40ビットのセキュリティで暗号化されたリンクを介してデータを送信しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These goals are achieved by the handshake protocol, which can be summarized as follows: The client sends a client hello message to which the server must respond with a server hello message, or else a fatal error will occur and the connection will fail. The client hello and server hello are used to establish security enhancement capabilities between client and server. The client hello and server hello establish the following attributes: Protocol Version, Session ID, Cipher Suite, and Compression Method. Additionally, two random values are generated and exchanged: ClientHello.random and ServerHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの目標は、次のように要約できるハンドシェイクプロトコルによって達成されます。クライアントは、サーバーがサーバーのhelloメッセージで応答する必要があるクライアントのhelloメッセージを送信します。そうしないと、致命的なエラーが発生して接続が失敗します。 client helloとserver helloは、クライアントとサーバー間のセキュリティ強化機能を確立するために使用されます。 client helloとserver helloは、プロトコルバージョン、セッションID、暗号スイート、および圧縮方法の属性を確立します。さらに、2つのランダムな値が生成および交換されます：ClientHello.randomとServerHello.random。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The actual key exchange uses up to four messages: the server certificate, the server key exchange, the client certificate, and the client key exchange. New key exchange methods can be created by specifying a format for these messages and defining the use of the messages to allow the client and server to agree upon a shared secret. This secret should be quite long; currently defined key exchange methods exchange secrets which range from 48 to 128 bytes in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際の鍵交換は最大4つのメッセージを使用します。サーバー証明書、サーバー鍵交換、クライアント証明書、およびクライアント鍵交換です。これらのメッセージのフォーマットを指定し、メッセージの使用を定義してクライアントとサーバーが共有シークレットに同意できるようにすることで、新しい鍵交換方法を作成できます。この秘密はかなり長いはずです。現在定義されている鍵交換方法は、長さが48〜128バイトの秘密を交換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following the hello messages, the server will send its certificate, if it is to be authenticated. Additionally, a server key exchange message may be sent, if it is required (e.g. if their server has no certificate, or if its certificate is for signing only). If the server is authenticated, it may request a certificate from the client, if that is appropriate to the cipher suite selected. Now the server will send the server hello done message, indicating that the hello-message phase of the handshake is complete. The server will then wait for a client response. If the server has sent a certificate request message, the client must send the certificate message. The client key exchange message is now sent, and the content of that message will depend on the public key algorithm selected between the client hello and the server hello. If the client has sent a certificate with signing ability, a digitally-signed certificate verify message is sent to explicitly verify the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
helloメッセージに続いて、サーバーは、認証される場合に証明書を送信します。さらに、必要な場合（たとえば、サーバーに証明書がない場合、またはサーバーの証明書が署名専用の場合）、サーバーキー交換メッセージが送信される場合があります。サーバーが認証されると、選択された暗号スイートに適切である場合、サーバーはクライアントに証明書を要求します。これで、サーバーはサーバーのhello doneメッセージを送信し、ハンドシェイクのhello-messageフェーズが完了したことを示します。その後、サーバーはクライアントの応答を待ちます。サーバーが証明書要求メッセージを送信した場合、クライアントは証明書メッセージを送信する必要があります。これでクライアントキー交換メッセージが送信され、そのメッセージの内容は、クライアントハローとサーバーハローの間で選択された公開キーアルゴリズムに依存します。クライアントが署名機能付きの証明書を送信した場合、デジタル署名された証明書検証メッセージが送信され、証明書を明示的に検証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 At this point, a change cipher spec message is sent by the client, and the client copies the pending Cipher Spec into the current Cipher Spec. The client then immediately sends the finished message under the new algorithms, keys, and secrets. In response, the server will send its own change cipher spec message, transfer the pending to the current Cipher Spec, and send its finished message under the new Cipher Spec. At this point, the handshake is complete and the client and server may begin to exchange application layer data. (See flow chart below.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
この時点で、クライアントは暗号仕様変更メッセージを送信し、クライアントは保留中の暗号仕様を現在の暗号仕様にコピーします。次に、クライアントは、新しいアルゴリズム、キー、およびシークレットで完成したメッセージをすぐに送信します。それに応じて、サーバーは独自の暗号仕様変更メッセージを送信し、保留を現在の暗号仕様に転送し、新しい暗号仕様で完成したメッセージを送信します。この時点で、ハンドシェイクが完了し、クライアントとサーバーがアプリケーション層データの交換を開始します。 （以下のフローチャートを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ClientHello                  --------&gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      Application Data             &lt;-------&gt;     Application Data
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Fig. 1 - Message flow for a full handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図1-フルハンドシェイクのメッセージフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Indicates optional or situation-dependent messages that are not always sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 常に送信されるわけではないオプションのメッセージまたは状況依存のメッセージを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS Protocol content type, and is not actually a TLS handshake message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
注：パイプラインのストールを回避するために、ChangeCipherSpecは独立したTLSプロトコルコンテンツタイプであり、実際にはTLSハンドシェイクメッセージではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client and server decide to resume a previous session or duplicate an existing session (instead of negotiating new security parameters) the message flow is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーが（新しいセキュリティパラメータをネゴシエートする代わりに）以前のセッションを再開するか、既存のセッションを複製することを決定した場合、メッセージフローは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match. If a match is found, and the server is willing to re-establish the connection under the specified session state, it will send a ServerHello with the same Session ID value. At this point, both client and server must send change cipher spec messages and proceed directly to finished messages. Once the re-establishment is complete, the client and server may begin to exchange application layer data. (See flow chart below.) If a Session ID match is not found, the server generates a new session ID and the TLS client and server perform a full handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、再開するセッションのセッションIDを使用してClientHelloを送信します。次に、サーバーはセッションキャッシュをチェックして一致するかどうかを確認します。一致が見つかり、サーバーが指定されたセッション状態で接続を再確立する用意がある場合、同じセッションID値でServerHelloを送信します。この時点で、クライアントとサーバーの両方が暗号仕様変更メッセージを送信し、完了したメッセージに直接進む必要があります。再確立が完了すると、クライアントとサーバーはアプリケーション層データの交換を開始します。 （以下のフローチャートを参照してください。）セッションIDの一致が見つからない場合、サーバーは新しいセッションIDを生成し、TLSクライアントとサーバーは完全なハンドシェイクを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ClientHello                   --------&gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&gt;
      Application Data              &lt;-------&gt;     Application Data
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Fig. 2 - Message flow for an abbreviated handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
図2-省略されたハンドシェイクのメッセージフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents and significance of each message will be presented in detail in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各メッセージの内容と重要性については、次のセクションで詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Handshake protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. ハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Handshake Protocol is one of the defined higher level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS Record Layer, where they are encapsulated within one or more TLSPlaintext structures, which are processed and transmitted as specified by the current active session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクプロトコルは、TLSレコードプロトコルの定義済みの高レベルクライアントの1つです。このプロトコルは、セッションの安全な属性をネゴシエートするために使用されます。ハンドシェイクメッセージはTLSレコードレイヤーに提供され、1つ以上のTLSPlaintext構造内にカプセル化されます。これらの構造は、現在アクティブなセッション状態で指定されたとおりに処理および送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum {
           hello_request(0), client_hello(1), server_hello(2),
           certificate(11), server_key_exchange (12),
           certificate_request(13), server_hello_done(14),
           certificate_verify(15), client_key_exchange(16),
           finished(20), (255)
       } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           HandshakeType msg_type;    /* handshake type */
           uint24 length;             /* bytes in message */
           select (HandshakeType) {
               case hello_request:       HelloRequest;
               case client_hello:        ClientHello;
               case server_hello:        ServerHello;
               case certificate:         Certificate;
               case server_key_exchange: ServerKeyExchange;
               case certificate_request: CertificateRequest;
               case server_hello_done:   ServerHelloDone;
               case certificate_verify:  CertificateVerify;
               case client_key_exchange: ClientKeyExchange;
               case finished:            Finished;
           } body;
       } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake protocol messages are presented below in the order they must be sent; sending handshake messages in an unexpected order results in a fatal error. Unneeded handshake messages can be omitted, however. Note one exception to the ordering: the Certificate message is used twice in the handshake (from server to client, then from client to server), but described only in its first position. The one message which is not bound by these ordering rules in the Hello Request message, which can be sent at any time, but which should be ignored by the client if it arrives in the middle of a handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に、ハンドシェイクプロトコルメッセージを送信する必要がある順序で示します。予期しない順序でハンドシェイクメッセージを送信すると、致命的なエラーが発生します。ただし、不要なハンドシェイクメッセージは省略できます。順序付けの1つの例外に注意してください。証明書メッセージはハンドシェイクで2回（サーバーからクライアントへ、次にクライアントからサーバーへ）使用されますが、最初の位置でのみ説明されています。 Hello Requestメッセージのこれらの順序ルールに拘束されない1つのメッセージ。いつでも送信できますが、ハンドシェイクの途中で到着した場合、クライアントは無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. Hello messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. こんにちはメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hello phase messages are used to exchange security enhancement capabilities between the client and server. When a new session begins, the Record Layer&#39;s connection state encryption, hash, and compression algorithms are initialized to null. The current connection state is used for renegotiation messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
helloフェーズメッセージは、クライアントとサーバー間でセキュリティ強化機能を交換するために使用されます。新しいセッションが始まると、レコードレイヤーの接続状態の暗号化、ハッシュ、および圧縮アルゴリズムはnullに初期化されます。現在の接続状態は、再ネゴシエーションメッセージに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. Hello request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. こんにちはリクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: The hello request message may be sent by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：helloリクエストメッセージは、サーバーからいつでも送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: Hello request is a simple notification that the client should begin the negotiation process anew by sending a client hello message when convenient. This message will be ignored by the client if the client is currently negotiating a session. This message may be ignored by the client if it does not wish to renegotiate a session, or the client may, if it wishes, respond with a no_renegotiation alert. Since handshake messages are intended to have transmission precedence over application data, it is expected that the negotiation will begin before no more than a few records are received from the client. If the server sends a hello request but does not receive a client hello in response, it may close the connection with a fatal alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：Helloリクエストは、クライアントが都合の良いときにクライアントのHelloメッセージを送信することによって、ネゴシエーションプロセスを新たに開始する必要があるという単純な通知です。クライアントが現在セッションをネゴシエートしている場合、このメッセージはクライアントによって無視されます。このメッセージは、セッションの再ネゴシエーションを望まない場合はクライアントによって無視されるか、必要に応じてno_renegotiationアラートで応答する場合があります。ハンドシェイクメッセージはアプリケーションデータよりも送信の優先度を高くすることを目的としているため、クライアントから受信するレコードが数個以下になる前にネゴシエーションが開始されることが予想されます。サーバーがhelloリクエストを送信しても、応答としてclient helloを受信しない場合は、致命的なアラートで接続を閉じることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending a hello request, servers should not repeat the request until the subsequent handshake negotiation is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
helloリクエストを送信した後、サーバーは後続のハンドシェイクネゴシエーションが完了するまでリクエストを繰り返さないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       struct { } HelloRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: This message should never be included in the message hashes which are maintained throughout the handshake and used in the finished messages and the certificate verify message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：このメッセージは、ハンドシェイク全体で維持され、完成したメッセージと証明書検証メッセージで使用されるメッセージハッシュに含めないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. Client hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. クライアントこんにちは
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: When a client first connects to a server it is required to send the client hello as its first message. The client can also send a client hello in response to a hello request or on its own initiative in order to renegotiate the security parameters in an existing connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：クライアントが最初にサーバーに接続するときに、最初のメッセージとしてクライアントのHelloを送信する必要があります。クライアントは、既存の接続でセキュリティパラメータを再ネゴシエートするために、helloリクエストへの応答として、または独自のイニシアチブでクライアントhelloを送信することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Structure of this message: The client hello message includes a random structure, which is used later in the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
このメッセージの構造：クライアントのhelloメッセージには、後でプロトコルで使用されるランダムな構造が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           struct {
              uint32 gmt_unix_time;
              opaque random_bytes[28];
           } Random;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
gmt_unix_time The current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, GMT) according to the sender&#39;s internal clock. Clocks are not required to be set correctly by the basic TLS Protocol; higher level or application protocols may define additional requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
gmt_unix_time送信者の内部クロックによる、標準のUNIX 32ビット形式（1970年1月1日から始まる午前0時からの秒数）での現在の日時。基本的なTLSプロトコルでクロックを正しく設定する必要はありません。より高いレベルまたはアプリケーションプロトコルは、追加の要件を定義する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random_bytes 28 bytes generated by a secure random number generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random_bytes安全な乱数ジェネレータによって生成された28バイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client hello message includes a variable length session identifier. If not empty, the value identifies a session between the same client and server whose security parameters the client wishes to reuse. The session identifier may be from an earlier connection, this connection, or another currently active connection. The second option is useful if the client only wishes to update the random structures and derived values of a connection, while the third option makes it possible to establish several independent secure connections without repeating the full handshake protocol. These independent connections may occur sequentially or simultaneously; a SessionID becomes valid when the handshake negotiating it completes with the exchange of Finished messages and persists until removed due to aging or because a fatal error was encountered on a connection associated with the session. The actual contents of the SessionID are defined by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのhelloメッセージには、可変長のセッション識別子が含まれます。空でない場合、値は、同じクライアントと、クライアントが再利用したいセキュリティパラメータを持つサーバー間のセッションを識別します。セッション識別子は、以前の接続、この接続、または現在アクティブな別の接続からのものである可能性があります。 2番目のオプションは、クライアントが接続のランダム構造と派生値のみを更新したい場合に役立ちます。3番目のオプションでは、完全なハンドシェイクプロトコルを繰り返さなくても、複数の独立した安全な接続を確立できます。これらの独立した接続は、順次または同時に発生します。セッションIDは、ネゴシエートするハンドシェイクが完了メッセージの交換で完了したときに有効になり、エージングまたはセッションに関連付けられた接続で致命的なエラーが発生したために削除されるまで持続します。 SessionIDの実際の内容はサーバーによって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       opaque SessionID&lt;0..32&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Warning: Because the SessionID is transmitted without encryption or immediate MAC protection, servers must not place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
警告：SessionIDは暗号化または即時MAC保護なしで送信されるため、サーバーはセッション識別子に機密情報を配置したり、偽のセッション識別子の内容がセキュリティ違反を引き起こしたりしてはなりません。 （SessionIDを含む、全体としてのハンドシェイクのコンテンツは、ハンドシェイクの最後に交換されるFinishedメッセージによって保護されることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CipherSuite list, passed from the client to the server in the client hello message, contains the combinations of cryptographic algorithms supported by the client in order of the client&#39;s preference (favorite choice first). Each CipherSuite defines a key exchange algorithm, a bulk encryption algorithm (including secret key length) and a MAC algorithm. The server will select a cipher suite or, if no acceptable choices are presented, return a handshake failure alert and close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのhelloメッセージでクライアントからサーバーに渡されるCipherSuiteリストには、クライアントがサポートする暗号化アルゴリズムの組み合わせが、クライアントの優先順（優先順が最初）に含まれています。各CipherSuiteは、鍵交換アルゴリズム、バルク暗号化アルゴリズム（秘密鍵の長さを含む）、およびMACアルゴリズムを定義します。サーバーは暗号スイートを選択するか、受け入れ可能な選択肢が提示されない場合は、ハンドシェイク失敗のアラートを返し、接続を閉じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       uint8 CipherSuite[2];    /* Cryptographic suite selector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client hello includes a list of compression algorithms supported by the client, ordered according to the client&#39;s preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのhelloには、クライアントがサポートする圧縮アルゴリズムのリストが含まれており、クライアントの設定に従って並べられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ProtocolVersion client_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suites&lt;2..2^16-1&gt;;
           CompressionMethod compression_methods&lt;1..2^8-1&gt;;
       } ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client_version The version of the TLS protocol by which the client wishes to communicate during this session. This should be the latest (highest valued) version supported by the client. For this version of the specification, the version will be 3.1 (See Appendix E for details about backward compatibility).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client_versionクライアントがこのセッション中に通信したいTLSプロトコルのバージョン。これは、クライアントがサポートする最新の（最も価値の高い）バージョンである必要があります。このバージョンの仕様では、バージョンは3.1になります（下位互換性の詳細については、付録Eを参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random A client-generated random structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
randomクライアントが生成したランダムな構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id The ID of a session the client wishes to use for this connection. This field should be empty if no session_id is available or the client wishes to generate new security parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_idクライアントがこの接続に使用するセッションのID。 session_idが利用できない場合、またはクライアントが新しいセキュリティパラメータを生成する場合は、このフィールドを空にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suites This is a list of the cryptographic options supported by the client, with the client&#39;s first preference first. If the session_id field is not empty (implying a session resumption request) this vector must include at least the cipher_suite from that session. Values are defined in Appendix A.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suitesこれは、クライアントがサポートする暗号化オプションのリストで、クライアントの最初の設定が最初です。 session_idフィールドが空でない場合（セッション再開要求を意味します）、このベクターには少なくともそのセッションからのcipher_suiteを含める必要があります。値は付録A.5で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression_methods This is a list of the compression methods supported by the client, sorted by client preference. If the session_id field is not empty (implying a session resumption request) it must include the compression_method from that session. This vector must contain, and all implementations must support, CompressionMethod.null. Thus, a client and server will always be able to agree on a compression method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression_methodsこれは、クライアント設定でソートされた、クライアントでサポートされている圧縮方式のリストです。 session_idフィールドが空でない場合（セッション再開要求を意味します）、そのセッションからのcompression_methodを含める必要があります。このベクターはCompressionMethod.nullを含み、すべての実装がCompressionMethod.nullをサポートする必要があります。したがって、クライアントとサーバーは常に圧縮方法について合意することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending the client hello message, the client waits for a server hello message. Any other handshake message returned by the server except for a hello request is treated as a fatal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのhelloメッセージを送信した後、クライアントはサーバーのhelloメッセージを待ちます。 helloリクエストを除く、サーバーから返されるその他のハンドシェイクメッセージは、致命的なエラーとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forward compatibility note: In the interests of forward compatibility, it is permitted for a client hello message to include extra data after the compression methods. This data must be included in the handshake hashes, but must otherwise be ignored. This is the only handshake message for which this is legal; for all other messages, the amount of data in the message must match the description of the message precisely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前方互換性に関する注意：前方互換性のために、クライアントのHelloメッセージに圧縮方法の後に追加のデータを含めることが許可されています。このデータはハンドシェイクハッシュに含める必要がありますが、それ以外の場合は無視する必要があります。これが合法な唯一のハンドシェイクメッセージです。他のすべてのメッセージの場合、メッセージ内のデータ量はメッセージの説明と正確に一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. Server hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. サーバーこんにちは
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: The server will send this message in response to a client hello message when it was able to find an acceptable set of algorithms. If it cannot find such a match, it will respond with a handshake failure alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：サーバーは、許容可能なアルゴリズムのセットを見つけることができたときに、クライアントのhelloメッセージへの応答としてこのメ​​ッセージを送信します。そのような一致が見つからない場合は、ハンドシェイク失敗アラートで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
           ProtocolVersion server_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suite;
           CompressionMethod compression_method;
       } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server_version This field will contain the lower of that suggested by the client in the client hello and the highest supported by the server. For this version of the specification, the version is 3.1 (See Appendix E for details about backward compatibility).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server_versionこのフィールドには、クライアントがクライアントhelloで提案した値の低い方と、サーバーがサポートする最も高い方が含まれます。このバージョンの仕様のバージョンは3.1です（下位互換性の詳細については、付録Eを参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random This structure is generated by the server and must be different from (and independent of) ClientHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
randomこの構造はサーバーによって生成され、ClientHello.randomとは異なる（そして独立している）必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id This is the identity of the session corresponding to this connection. If the ClientHello.session_id was non-empty, the server will look in its session cache for a match. If a match is found and the server is willing to establish the new connection using the specified session state, the server will respond with the same value as was supplied by the client. This indicates a resumed session and dictates that the parties must proceed directly to the finished messages. Otherwise this field will contain a different value identifying the new session. The server may return an empty session_id to indicate that the session will not be cached and therefore cannot be resumed. If a session is resumed, it must be resumed using the same cipher suite it was originally negotiated with.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_idこれは、この接続に対応するセッションのIDです。 ClientHello.session_idが空でない場合、サーバーは一致するかどうかセッションキャッシュを調べます。一致が見つかり、サーバーが指定されたセッション状態を使用して新しい接続を確立する用意がある場合、サーバーはクライアントから提供されたものと同じ値で応答します。これは、再開されたセッションを示し、当事者が完了したメッセージに直接進む必要があることを示します。それ以外の場合、このフィールドには、新しいセッションを識別する別の値が含まれます。サーバーは空のsession_idを返し、セッションがキャッシュされないため再開できないことを示します。セッションを再開する場合は、最初にネゴシエートしたときと同じ暗号スイートを使用して再開する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suite The single cipher suite selected by the server from the list in ClientHello.cipher_suites. For resumed sessions this field is the value from the state of the session being resumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suiteサーバーがClientHello.cipher_suitesのリストから選択した単一の暗号スイート。再開されたセッションの場合、このフィールドは再開されているセッションの状態からの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression_method The single compression algorithm selected by the server from the list in ClientHello.compression_methods. For resumed sessions this field is the value from the resumed session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression_method ClientHello.compression_methodsのリストからサーバーが選択した単一の圧縮アルゴリズム。再開されたセッションの場合、このフィールドは再開されたセッション状態からの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. Server certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. サーバー証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: The server must send a certificate whenever the agreed-upon key exchange method is not an anonymous one. This message will always immediately follow the server hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：サーバーは、合意された鍵交換方式が匿名でない場合は常に証明書を送信する必要があります。このメッセージは、常にサーバーのHelloメッセージの直後に続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Meaning of this message: The certificate type must be appropriate for the selected cipher suite&#39;s key exchange algorithm, and is generally an X.509v3 certificate. It must contain a key which matches the key exchange method, as follows. Unless otherwise specified, the signing algorithm for the certificate must be the same as the algorithm for the certificate key. Unless otherwise specified, the public key may be of any length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメッセージの意味：証明書タイプは、選択した暗号スイートの鍵交換アルゴリズムに適している必要があり、通常はX.509v3証明書です。次のように、鍵交換方法と一致する鍵が含まれている必要があります。特に指定がない限り、証明書の署名アルゴリズムは、証明書キーのアルゴリズムと同じでなければなりません。特に明記しない限り、公開鍵の長さは任意です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Key Exchange Algorithm Certificate Key Type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
鍵交換アルゴリズム証明書の鍵タイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RSA RSA public key; the certificate must allow the key to be used for encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RSA RSA公開鍵。証明書では、キーを暗号化に使用できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RSA_EXPORT RSA public key of length greater than 512 bits which can be used for signing, or a key of 512 bits or shorter which can be used for either encryption or signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RSA_EXPORT署名に使用できる512ビットを超える長さのRSA公開鍵、または暗号化または署名に使用できる512ビット以下の鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_DSS DSS public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_DSS DSS公開鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_DSS_EXPORT DSS public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_DSS_EXPORT DSS公開鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_RSA RSA public key which can be used for signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_RSA署名に使用できるRSA公開鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_RSA_EXPORT RSA public key which can be used for signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_RSA_EXPORT署名に使用できるRSA公開鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DH_DSS Diffie-Hellman key. The algorithm used to sign the certificate should be DSS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DH_DSS Diffie-Hellmanキー。証明書の署名に使用されるアルゴリズムはDSSである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DH_RSA Diffie-Hellman key. The algorithm used to sign the certificate should be RSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DH_RSA Diffie-Hellmanキー。証明書の署名に使用されるアルゴリズムはRSAである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All certificate profiles, key and cryptographic formats are defined by the IETF PKIX working group [PKIX]. When a key usage extension is present, the digitalSignature bit must be set for the key to be eligible for signing, as described above, and the keyEncipherment bit must be present to allow encryption, as described above. The keyAgreement bit must be set on Diffie-Hellman certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての証明書プロファイル、キー、および暗号化形式は、IETF PKIXワーキンググループ[PKIX]によって定義されています。鍵用途拡張が存在する場合、前述のように、署名に適格な鍵のdigitalSignatureビットを設定する必要があり、暗号化を許可するには、前述のようにkeyEnciphermentビットが存在する必要があります。 Diffie-Hellman証明書では、keyAgreementビットを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As CipherSuites which specify new key exchange methods are specified for the TLS Protocol, they will imply certificate format and the required encoded keying information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい鍵交換方式を指定するCipherSuiteはTLSプロトコル用に指定されているため、証明書の形式と必要なエンコードされた鍵情報が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       opaque ASN.1Cert&lt;1..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
       } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_list This is a sequence (chain) of X.509v3 certificates. The sender&#39;s certificate must come first in the list. Each following certificate must directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate which specifies the root certificate authority may optionally be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_listこれは、X.509v3証明書のシーケンス（チェーン）です。送信者の証明書がリストの最初に来る必要があります。次の各証明書は、その前の証明書を直接証明する必要があります。証明書の検証ではルートキーを個別に配布する必要があるため、ルート認証局を指定する自己署名証明書は、リモートエンドがそれを検証するためにすでに所有している必要があるという前提の下で、オプションでチェーンから省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same message type and structure will be used for the client&#39;s response to a certificate request message. Note that a client may send no certificates if it does not have an appropriate certificate to send in response to the server&#39;s authentication request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書要求メッセージに対するクライアントの応答には、同じメッセージタイプと構造が使用されます。サーバーの認証要求に応答して送信する適切な証明書がない場合、クライアントは証明書を送信しない場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: PKCS #7 [PKCS7] is not used as the format for the certificate vector because PKCS #6 [PKCS6] extended certificates are not used. Also PKCS #7 defines a SET rather than a SEQUENCE, making the task of parsing the list more difficult.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：PKCS＃6 [PKCS6]拡張証明書は使用されないため、PKCS＃7 [PKCS7]は証明書ベクトルの形式として使用されません。また、PKCS＃7はSEQUENCEではなくSETを定義しているため、リストを解析するタスクがより困難になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. Server key exchange message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. サーバー鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: This message will be sent immediately after the server certificate message (or the server hello message, if this is an anonymous negotiation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：このメッセージは、サーバー証明書メッセージ（または匿名のネゴシエーションの場合はサーバーのhelloメッセージ）の直後に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The server key exchange message is sent by the server only when the server certificate message (if sent) does not contain enough data to allow the client to exchange a premaster secret. This is true for the following key exchange methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーキー交換メッセージは、サーバー証明書メッセージ（送信された場合）に、クライアントがプリマスターシークレットを交換するのに十分なデータが含まれていない場合にのみサーバーから送信されます。これは、次の鍵交換方法に当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
RSA_EXPORT (if the public key in the server certificate is longer than 512 bits) DHE_DSS DHE_DSS_EXPORT DHE_RSA DHE_RSA_EXPORT DH_anon
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
RSA_EXPORT（サーバー証明書の公開鍵が512ビットより長い場合）DHE_DSS DHE_DSS_EXPORT DHE_RSA DHE_RSA_EXPORT DH_anon
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
It is not legal to send the server key exchange message for the following key exchange methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のキー交換方法でサーバーキー交換メッセージを送信することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
RSA RSA_EXPORT (when the public key in the server certificate is less than or equal to 512 bits in length) DH_DSS DH_RSA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
RSA RSA_EXPORT（サーバー証明書の公開鍵の長さが512ビット以下の場合）DH_DSS DH_RSA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: This message conveys cryptographic information to allow the client to communicate the premaster secret: either an RSA public key to encrypt the premaster secret with, or a Diffie-Hellman public key with which the client can complete a key exchange (with the result being the premaster secret.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：このメッセージは、クライアントがプリマスターシークレット（プリマスターシークレットを暗号化するためのRSA公開鍵）またはクライアントが鍵交換を完了することができるDiffie-Hellman公開鍵（結果はプリマスターシークレットになります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As additional CipherSuites are defined for TLS which include new key exchange algorithms, the server key exchange message will be sent if and only if the certificate type associated with the key exchange algorithm does not provide enough information for the client to exchange a premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい鍵交換アルゴリズムを含む追加のCipherSuiteがTLSに対して定義されているため、サーバー交換鍵メッセージは、鍵交換アルゴリズムに関連付けられた証明書タイプがクライアントがプリマスターシークレットを交換するのに十分な情報を提供しない場合にのみ送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: According to current US export law, RSA moduli larger than 512 bits may not be used for key exchange in software exported from the US. With this message, the larger RSA keys encoded in certificates may be used to sign temporary shorter RSA keys for the RSA_EXPORT key exchange method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：現在の米国の輸出法によれば、512ビットを超えるRSA係数は、米国から輸出されるソフトウェアの鍵交換に使用できない場合があります。このメッセージでは、証明書にエンコードされたより大きなRSA鍵を使用して、RSA_EXPORT鍵交換方式の一時的に短いRSA鍵に署名できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       enum { rsa, diffie_hellman } KeyExchangeAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           opaque rsa_modulus&lt;1..2^16-1&gt;;
           opaque rsa_exponent&lt;1..2^16-1&gt;;
       } ServerRSAParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
rsa_modulus The modulus of the server&#39;s temporary RSA key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
rsa_modulusサーバーの一時RSAキーの係数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
rsa_exponent The public exponent of the server&#39;s temporary RSA key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
rsa_exponentサーバーの一時的なRSAキーの公開指数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           opaque dh_p&lt;1..2^16-1&gt;;
           opaque dh_g&lt;1..2^16-1&gt;;
           opaque dh_Ys&lt;1..2^16-1&gt;;
       } ServerDHParams;     /* Ephemeral DH parameters */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_p The prime modulus used for the Diffie-Hellman operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_p Diffie-Hellman演算に使用される素数係数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_g The generator used for the Diffie-Hellman operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_g Diffie-Hellman操作に使用されるジェネレータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_Ys The server&#39;s Diffie-Hellman public value (g^X mod p).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_YsサーバーのDiffie-Hellmanパブリック値（g ^ X mod p）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           select (KeyExchangeAlgorithm) {
               case diffie_hellman:
                   ServerDHParams params;
                   Signature signed_params;
               case rsa:
                   ServerRSAParams params;
                   Signature signed_params;
           };
       } ServerKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
params The server&#39;s key exchange parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
paramsサーバーの鍵交換パラメーター。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
signed_params For non-anonymous key exchanges, a hash of the corresponding params value, with the signature appropriate to that hash applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
signed_pa​​rams非匿名の鍵交換の場合、対応するparams値のハッシュと、そのハッシュに適した署名が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       md5_hash
           MD5(ClientHello.random + ServerHello.random + ServerParams);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       sha_hash
           SHA(ClientHello.random + ServerHello.random + ServerParams);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { anonymous, rsa, dsa } SignatureAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       select (SignatureAlgorithm)
       {   case anonymous: struct { };
           case rsa:
               digitally-signed struct {
                   opaque md5_hash[16];
                   opaque sha_hash[20];
               };
           case dsa:
               digitally-signed struct {
                   opaque sha_hash[20];
               };
       } Signature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. Certificate request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. 証明書の要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: A non-anonymous server can optionally request a certificate from the client, if appropriate for the selected cipher suite. This message, if sent, will immediately follow the Server Key Exchange message (if it is sent; otherwise, the Server Certificate message).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：選択した暗号スイートに適切な場合、非匿名サーバーはオプションでクライアントに証明書を要求できます。このメッセージが送信された場合、サーバーキー交換メッセージの直後に送信されます（送信された場合、送信されない場合はサーバー証明書メッセージ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       enum {
           rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
           (255)
       } ClientCertificateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       opaque DistinguishedName&lt;1..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
           DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
       } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
certificate_types This field is a list of the types of certificates requested, sorted in order of the server&#39;s preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
certificate_typesこのフィールドは、要求された証明書のタイプのリストであり、サーバーの設定順にソートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
certificate_authorities A list of the distinguished names of acceptable certificate authorities. These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used both to describe known roots and a desired authorization space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
certificate_authorities受け入れ可能な認証局の識別名のリスト。これらの識別名は、ルートCAまたは下位CAに必要な識別名を指定できます。したがって、このメッセージは、既知のルートと目的の承認スペースの両方を説明するために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: DistinguishedName is derived from [X509].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：DistinguishedNameは[X509]から派生しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: It is a fatal handshake_failure alert for an anonymous server to request client identification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：匿名サーバーがクライアントの識別を要求することは、致命的なhandshake_failureアラートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. Server hello done
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. サーバーこんにちは完了
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: The server hello done message is sent by the server to indicate the end of the server hello and associated messages. After sending this message the server will wait for a client response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：サーバーhello doneメッセージは、サーバーhelloの終了と関連メッセージを示すためにサーバーによって送信されます。このメッセージを送信した後、サーバーはクライアントの応答を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: This message means that the server is done sending messages to support the key exchange, and the client can proceed with its phase of the key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：このメッセージは、サーバーが鍵交換をサポートするメッセージの送信を完了し、クライアントが鍵交換のフェーズに進むことができることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Upon receipt of the server hello done message the client should verify that the server provided a valid certificate if required and check that the server hello parameters are acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーのハロー完了メッセージを受信すると、クライアントは、サーバーが必要に応じて有効な証明書を提供したことを確認し、サーバーのハローパラメータが受け入れ可能であることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       struct { } ServerHelloDone;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.6. Client certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.6. クライアント証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: This is the first message the client can send after receiving a server hello done message. This message is only sent if the server requests a certificate. If no suitable certificate is available, the client should send a certificate message containing no certificates. If client authentication is required by the server for the handshake to continue, it may respond with a fatal handshake failure alert. Client certificates are sent using the Certificate structure defined in Section 7.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：これは、サーバーのhello doneメッセージを受信した後にクライアントが送信できる最初のメッセージです。このメッセージは、サーバーが証明書を要求した場合にのみ送信されます。適切な証明書がない場合、クライアントは証明書を含まない証明書メッセージを送信する必要があります。サーバーがハンドシェイクを続行するためにクライアント認証が必要な場合、サーバーは致命的なハンドシェイク失敗アラートで応答することがあります。クライアント証明書は、セクション7.4.2で定義された証明書構造を使用して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: When using a static Diffie-Hellman based key exchange method (DH_DSS or DH_RSA), if client authentication is requested, the Diffie-Hellman group and generator encoded in the client&#39;s certificate must match the server specified Diffie-Hellman parameters if the client&#39;s parameters are to be used for the key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：静的なDiffie-Hellmanベースの鍵交換方式（DH_DSSまたはDH_RSA）を使用する場合、クライアント認証が要求された場合、クライアントのパラメーターでクライアントのパラメーターが指定されている場合、クライアントの証明書にエンコードされたDiffie-Hellmanグループとジェネレーターがサーバー指定のDiffie-Hellmanパラメーターと一致する必要があります。鍵交換に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7. Client key exchange message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7. クライアント鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: This message is always sent by the client. It will immediately follow the client certificate message, if it is sent. Otherwise it will be the first message sent by the client after it receives the server hello done message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：このメッセージは常にクライアントによって送信されます。送信された場合、クライアント証明書メッセージの直後に続きます。それ以外の場合は、サーバーのhello doneメッセージを受信した後、クライアントによって送信される最初のメッセージになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: With this message, the premaster secret is set, either though direct transmission of the RSA-encrypted secret, or by the transmission of Diffie-Hellman parameters which will allow each side to agree upon the same premaster secret. When the key exchange method is DH_RSA or DH_DSS, client certification has been requested, and the client was able to respond with a certificate which contained a Diffie-Hellman public key whose parameters (group and generator) matched those specified by the server in its certificate, this message will not contain any data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：このメッセージでは、RSAで暗号化されたシークレットを直接送信するか、各サイドが同じプリマスターシークレットに同意できるDiffie-Hellmanパラメータを送信することによって、プリマスターシークレットが設定されます。鍵交換方式がDH_RSAまたはDH_DSSの場合、クライアント証明書が要求され、クライアントは、証明書でサーバーによって指定されたパラメーターと一致するパラメーター（グループおよびジェネレーター）を持つDiffie-Hellman公開鍵を含む証明書で応答できました、このメッセージにはデータが含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message: The choice of messages depends on which key exchange method has been selected. See Section 7.4.3 for the KeyExchangeAlgorithm definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：メッセージの選択は、選択された鍵交換方式によって異なります。 KeyExchangeAlgorithmの定義については、7.4.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           select (KeyExchangeAlgorithm) {
               case rsa: EncryptedPreMasterSecret;
               case diffie_hellman: ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           } exchange_keys;
       } ClientKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.1. RSA encrypted premaster secret message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.1. RSA暗号化プリマスターシークレットメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: If RSA is being used for key agreement and authentication, the client generates a 48-byte premaster secret, encrypts it using the public key from the server&#39;s certificate or the temporary RSA key provided in a server key exchange message, and sends the result in an encrypted premaster secret message. This structure is a variant of the client key exchange message, not a message in itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：RSAが鍵の合意と認証に使用されている場合、クライアントは48バイトのプリマスターシークレットを生成し、サーバーの証明書の公開鍵またはサーバーの鍵交換メッセージで提供される一時的なRSA鍵を使用して暗号化します。暗号化されたプリマスターシークレットメッセージで結果を送信します。この構造はクライアント鍵交換メッセージの変形であり、それ自体がメッセージではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
           ProtocolVersion client_version;
           opaque random[46];
       } PreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
client_version The latest (newest) version supported by the client. This is used to detect version roll-back attacks. Upon receiving the premaster secret, the server should check that this value matches the value transmitted by the client in the client hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
client_versionクライアントがサポートする最新（最新）バージョン。これは、バージョンロールバック攻撃を検出するために使用されます。サーバーは、プリマスターシークレットを受信すると、この値がクライアントのhelloメッセージでクライアントから送信された値と一致することを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
random 46 securely-generated random bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
random 46の安全に生成されたランダムバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           public-key-encrypted PreMasterSecret pre_master_secret;
       } EncryptedPreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: An attack discovered by Daniel Bleichenbacher [BLEI] can be used to attack a TLS server which is using PKCS#1 encoded RSA. The attack takes advantage of the fact that by failing in different ways, a TLS server can be coerced into revealing whether a particular message, when decrypted, is properly PKCS#1 formatted or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：Daniel Bleichenbacher [BLEI]によって発見された攻撃は、PKCS＃1エンコードされたRSAを使用しているTLSサーバーを攻撃するために使用できます。この攻撃は、さまざまな方法で失敗することにより、TLSサーバーが強制的に復号化されたときに特定のメッセージが適切にPKCS＃1形式であるかどうかを明らかにできるという事実を利用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The best way to avoid vulnerability to this attack is to treat incorrectly formatted messages in a manner indistinguishable from correctly formatted RSA blocks. Thus, when it receives an incorrectly formatted RSA block, a server should generate a random 48-byte value and proceed using it as the premaster secret. Thus, the server will act identically whether the received RSA block is correctly encoded or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この攻撃に対する脆弱性を回避する最良の方法は、正しくフォーマットされたRSAブロックと区別できない方法で、誤ってフォーマットされたメッセージを処理することです。したがって、正しくフォーマットされていないRSAブロックを受信した場合、サーバーはランダムな48バイトの値を生成し、それをプリマスターシークレットとして使用する必要があります。したがって、サーバーは、受信したRSAブロックが正しくエンコードされているかどうかにかかわらず、同じように動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
pre_master_secret This random value is generated by the client and is used to generate the master secret, as specified in Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
pre_master_secretこのランダムな値はクライアントによって生成され、セクション8.1で指定されているように、マスターシークレットを生成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.2. Client Diffie-Hellman public value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.2. クライアントDiffie-Hellmanの公開値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: This structure conveys the client&#39;s Diffie-Hellman public value (Yc) if it was not already included in the client&#39;s certificate. The encoding used for Yc is determined by the enumerated PublicValueEncoding. This structure is a variant of the client key exchange message, not a message in itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：この構造は、クライアントの証明書にまだ含まれていない場合、クライアントのDiffie-Hellmanパブリック値（Yc）を伝えます。 Ycに使用されるエンコーディングは、列挙されたPublicValueEncodingによって決定されます。この構造はクライアント鍵交換メッセージの変形であり、それ自体がメッセージではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
implicit If the client certificate already contains a suitable Diffie-Hellman key, then Yc is implicit and does not need to be sent again. In this case, the Client Key Exchange message will be sent, but will be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
暗黙的クライアント証明書に適切なDiffie-Hellman鍵がすでに含まれている場合、Ycは暗黙的であり、再度送信する必要はありません。この場合、クライアントキー交換メッセージは送信されますが、空になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
explicit Yc needs to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
明示的なYcを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           select (PublicValueEncoding) {
               case implicit: struct { };
               case explicit: opaque dh_Yc&lt;1..2^16-1&gt;;
           } dh_public;
       } ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_Yc The client&#39;s Diffie-Hellman public value (Yc).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_YcクライアントのDiffie-Hellmanパブリック値（Yc）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.8. Certificate verify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.8. 証明書の確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: This message is used to provide explicit verification of a client certificate. This message is only sent following a client certificate that has signing capability (i.e. all certificates except those containing fixed Diffie-Hellman parameters). When sent, it will immediately follow the client key exchange message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：このメッセージは、クライアント証明書の明示的な検証を提供するために使用されます。このメッセージは、署名機能を持つクライアント証明書（つまり、固定Diffie-Hellmanパラメータを含むものを除くすべての証明書）に続いてのみ送信されます。送信されると、クライアント鍵交換メッセージの直後に続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
            Signature signature;
       } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The Signature type is defined in 7.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
署名タイプは、7.4.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CertificateVerify.signature.md5_hash MD5(handshake_messages);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CertificateVerify.signature.md5_hash MD5（handshake_messages）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Certificate.signature.sha_hash SHA(handshake_messages);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Certificate.signature.sha_hash SHA（handshake_messages）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here handshake_messages refers to all handshake messages sent or received starting at client hello up to but not including this message, including the type and length fields of the handshake messages. This is the concatenation of all the Handshake structures as defined in 7.4 exchanged thus far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、handshake_messagesは、クライアントhelloからこのメッセージまで（ただし、ハンドシェイクメッセージのタイプフィールドと長さフィールドを含む）までに送受信されるすべてのハンドシェイクメッセージを指します。これは、これまでに交換された7.4で定義されているすべてのハンドシェイク構造の連結です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.9. Finished
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.9. 完成した
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: A finished message is always sent immediately after a change cipher spec message to verify that the key exchange and authentication processes were successful. It is essential that a change cipher spec message be received between the other handshake messages and the Finished message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるタイミング：暗号仕様変更メッセージの直後に終了メッセージが送信され、鍵交換と認証プロセスが成功したことを確認します。他のハンドシェイクメッセージと完了メッセージの間に、暗号仕様変更メッセージを受信することが不可欠です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: The finished message is the first protected with the just-negotiated algorithms, keys, and secrets. Recipients of finished messages must verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：完成したメッセージは、最初にネゴシエートされたアルゴリズム、キー、およびシークレットで保護された最初のメッセージです。完成したメッセージの受信者は、内容が正しいことを確認する必要があります。サイドが完了メッセージを送信し、ピアから完了メッセージを受信して​​検証すると、接続を介してアプリケーションデータの送受信を開始できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           opaque verify_data[12];
       } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       verify_data
           PRF(master_secret, finished_label, MD5(handshake_messages) +
           SHA-1(handshake_messages)) [0..11];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
finished_label For Finished messages sent by the client, the string &#34;client finished&#34;. For Finished messages sent by the server, the string &#34;server finished&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
finished_labelクライアントによって送信された終了メッセージの場合、ストリング「client finished」。サーバーによって送信された終了メッセージの場合、文字列「サーバー終了」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
handshake_messages All of the data from all handshake messages up to but not including this message. This is only data visible at the handshake layer and does not include record layer headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
handshake_messagesこのメッセージを除く、このメッセージを除くすべてのハンドシェイクメッセージのすべてのデータ。これは、ハンドシェイクレイヤーでのみ表示されるデータであり、レコードレイヤーヘッダーは含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
This is the concatenation of all the Handshake structures as defined in 7.4 exchanged thus far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
これは、これまでに交換された7.4で定義されているすべてのハンドシェイク構造の連結です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is a fatal error if a finished message is not preceded by a change cipher spec message at the appropriate point in the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクの適切な時点で、完了したメッセージの前に暗号仕様変更メッセージが付いていない場合は、致命的なエラーになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hash contained in finished messages sent by the server incorporate Sender.server; those sent by the client incorporate Sender.client. The value handshake_messages includes all handshake messages starting at client hello up to, but not including, this finished message. This may be different from handshake_messages in Section 7.4.8 because it would include the certificate verify message (if sent). Also, the handshake_messages for the finished message sent by the client will be different from that for the finished message sent by the server, because the one which is sent second will include the prior one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって送信された完成したメッセージに含まれるハッシュには、Sender.serverが組み込まれています。クライアントが送信したものには、Sender.clientが組み込まれています。値handshake_messagesには、クライアントhelloからこの終了メッセージまでのすべてのハンドシェイクメッセージが含まれますが、このメッセージは含まれません。証明書検証メッセージ（送信された場合）が含まれるため、これはセクション7.4.8のhandshake_messagesとは異なる場合があります。また、クライアントが送信する終了メッセージのhandshake_messagesは、サーバーが送信する終了メッセージのhandshake_messagesとは異なります。これは、2番目に送信されるメッセージには前のメッセージが含まれるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Change cipher spec messages, alerts and any other record types are not handshake messages and are not included in the hash computations. Also, Hello Request messages are omitted from handshake hashes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：暗号仕様変更メッセージ、アラート、およびその他のレコードタイプは、ハンドシェイクメッセージではなく、ハッシュ計算には含まれません。また、Hello Requestメッセージはハンドシェイクハッシュから省略されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Cryptographic computations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 暗号計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, encryption, and MAC algorithms are determined by the cipher_suite selected by the server and revealed in the server hello message. The compression algorithm is negotiated in the hello messages, and the random values are exchanged in the hello messages. All that remains is to calculate the master secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続保護を開始するために、TLSレコードプロトコルでは、一連のアルゴリズム、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります。認証、暗号化、およびMACアルゴリズムは、サーバーによって選択され、サーバーのHelloメッセージで明らかにされたcipher_suiteによって決定されます。圧縮アルゴリズムはhelloメッセージでネゴシエートされ、ランダムな値はhelloメッセージで交換されます。あとは、マスターシークレットを計算するだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Computing the master secret
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. マスターシークレットの計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all key exchange methods, the same algorithm is used to convert the pre_master_secret into the master_secret. The pre_master_secret should be deleted from memory once the master_secret has been computed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての鍵交換方法で、同じアルゴリズムを使用してpre_master_secretをmaster_secretに変換します。 master_secretが計算されたら、pre_master_secretをメモリから削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
master_secret = PRF(pre_master_secret, &#34;master secret&#34;, ClientHello.random + ServerHello.random) [0..47];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
master_secret = PRF（pre_master_secret、 &#34;master secret&#34;、ClientHello.random + ServerHello.random）[0..47];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master secret is always exactly 48 bytes in length. The length of the premaster secret will vary depending on key exchange method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスターシークレットの長さは常に正確に48バイトです。プリマスターシークレットの長さは、鍵の交換方法によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. RSA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. RSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RSA is used for server authentication and key exchange, a 48- byte pre_master_secret is generated by the client, encrypted under the server&#39;s public key, and sent to the server. The server uses its private key to decrypt the pre_master_secret. Both parties then convert the pre_master_secret into the master_secret, as specified above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAがサーバー認証と鍵交換に使用される場合、48バイトのpre_master_secretがクライアントによって生成され、サーバーの公開鍵で暗号化されてサーバーに送信されます。サーバーは、その秘密鍵を使用してpre_master_secretを復号化します。次に、両方の当事者が、上記のようにpre_master_secretをmaster_secretに変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA digital signatures are performed using PKCS #1 [PKCS1] block type 1. RSA public key encryption is performed using PKCS #1 block type 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAデジタル署名は、PKCS＃1 [PKCS1]ブロックタイプ1を使用して実行されます。RSA公開鍵暗号化は、PKCS＃1ブロックタイプ2を使用して実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. Diffie-Hellman
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. ディフィーヘルマン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is used as the pre_master_secret, and is converted into the master_secret, as specified above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従来のDiffie-Hellman計算が実行されます。ネゴシエートされたキー（Z）はpre_master_secretとして使用され、上記のようにmaster_secretに変換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Diffie-Hellman parameters are specified by the server, and may be either ephemeral or contained within the server&#39;s certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：Diffie-Hellmanパラメーターはサーバーによって指定され、一時的なものか、サーバーの証明書に含まれているもののいずれかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Mandatory Cipher Suites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 必須の暗号スイート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of an application profile standard specifying otherwise, a TLS compliant application MUST implement the cipher suite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に指定しないアプリケーションプロファイル標準がない場合、TLS準拠のアプリケーションは、暗号スイートTLS_DHE_DSS_WITH_3DES_EDE_CBC_SHAを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Application data protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. アプリケーションデータプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application data messages are carried by the Record Layer and are fragmented, compressed and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションデータメッセージはレコードレイヤーによって運ばれ、現在の接続状態に基づいて断片化、圧縮、暗号化されます。メッセージは、レコードレイヤーに対して透過的なデータとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A. Protocol constant values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.プロトコル定数値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes protocol types and constants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、プロトコルのタイプと定数について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. Record layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 記録層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        uint8 major, minor;
    } ProtocolVersion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ProtocolVersion version = { 3, 1 };     /* TLS v1.0 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum {
        change_cipher_spec(20), alert(21), handshake(22),
        application_data(23), (255)
    } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        opaque fragment[TLSPlaintext.length];
    } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        opaque fragment[TLSCompressed.length];
    } TLSCompressed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        select (CipherSpec.cipher_type) {
            case stream: GenericStreamCipher;
            case block:  GenericBlockCipher;
        } fragment;
    } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    stream-ciphered struct {
        opaque content[TLSCompressed.length];
        opaque MAC[CipherSpec.hash_size];
    } GenericStreamCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    block-ciphered struct {
        opaque content[TLSCompressed.length];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        opaque MAC[CipherSpec.hash_size];
        uint8 padding[GenericBlockCipher.padding_length];
        uint8 padding_length;
    } GenericBlockCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. Change cipher specs message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. 暗号仕様メッセージを変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        enum { change_cipher_spec(1), (255) } type;
    } ChangeCipherSpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. Alert messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. 警告メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum {
            close_notify(0),
            unexpected_message(10),
            bad_record_mac(20),
            decryption_failed(21),
            record_overflow(22),
            decompression_failure(30),
            handshake_failure(40),
            bad_certificate(42),
            unsupported_certificate(43),
            certificate_revoked(44),
            certificate_expired(45),
            certificate_unknown(46),
            illegal_parameter(47),
            unknown_ca(48),
            access_denied(49),
            decode_error(50),
            decrypt_error(51),
            export_restriction(60),
            protocol_version(70),
            insufficient_security(71),
            internal_error(80),
            user_canceled(90),
            no_renegotiation(100),
            (255)
        } AlertDescription;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        AlertLevel level;
        AlertDescription description;
    } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. Handshake protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. ハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum {
        hello_request(0), client_hello(1), server_hello(2),
        certificate(11), server_key_exchange (12),
        certificate_request(13), server_hello_done(14),
        certificate_verify(15), client_key_exchange(16),
        finished(20), (255)
    } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        HandshakeType msg_type;
        uint24 length;
        select (HandshakeType) {
            case hello_request:       HelloRequest;
            case client_hello:        ClientHello;
            case server_hello:        ServerHello;
            case certificate:         Certificate;
            case server_key_exchange: ServerKeyExchange;
            case certificate_request: CertificateRequest;
            case server_hello_done:   ServerHelloDone;
            case certificate_verify:  CertificateVerify;
            case client_key_exchange: ClientKeyExchange;
            case finished:            Finished;
        } body;
    } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.1. Hello messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.1. こんにちはメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct { } HelloRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        uint32 gmt_unix_time;
        opaque random_bytes[28];
    } Random;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    opaque SessionID&lt;0..32&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
uint8 CipherSuite[2];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
uint8 CipherSuite [2];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion client_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suites&lt;2..2^16-1&gt;;
        CompressionMethod compression_methods&lt;1..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
} ClientHello;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
} ClientHello;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion server_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suite;
        CompressionMethod compression_method;
    } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.2. Server authentication and key exchange messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.2. サーバー認証と鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    opaque ASN.1Cert&lt;2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ASN.1Cert certificate_list&lt;1..2^24-1&gt;;
    } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum { rsa, diffie_hellman } KeyExchangeAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        opaque RSA_modulus&lt;1..2^16-1&gt;;
        opaque RSA_exponent&lt;1..2^16-1&gt;;
    } ServerRSAParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        opaque DH_p&lt;1..2^16-1&gt;;
        opaque DH_g&lt;1..2^16-1&gt;;
        opaque DH_Ys&lt;1..2^16-1&gt;;
    } ServerDHParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        select (KeyExchangeAlgorithm) {
            case diffie_hellman:
                ServerDHParams params;
                Signature signed_params;
            case rsa:
                ServerRSAParams params;
                Signature signed_params;
        };
    } ServerKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum { anonymous, rsa, dsa } SignatureAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    select (SignatureAlgorithm)
    {   case anonymous: struct { };
        case rsa:
            digitally-signed struct {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                opaque md5_hash[16];
                opaque sha_hash[20];
            };
        case dsa:
            digitally-signed struct {
                opaque sha_hash[20];
            };
    } Signature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum {
        rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
        (255)
    } ClientCertificateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    opaque DistinguishedName&lt;1..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
        DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
    } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct { } ServerHelloDone;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.3. Client authentication and key exchange messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.3. クライアント認証と鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        select (KeyExchangeAlgorithm) {
            case rsa: EncryptedPreMasterSecret;
            case diffie_hellman: DiffieHellmanClientPublicValue;
        } exchange_keys;
    } ClientKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion client_version;
        opaque random[46];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
} PreMasterSecret;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
} PreMasterSecret;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        public-key-encrypted PreMasterSecret pre_master_secret;
    } EncryptedPreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        select (PublicValueEncoding) {
            case implicit: struct {};
            case explicit: opaque DH_Yc&lt;1..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        } dh_public;
    } ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        Signature signature;
    } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.4. Handshake finalization message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.4. ハンドシェイク終了メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        opaque verify_data[12];
    } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. The CipherSuite
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. 暗号スイート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following values define the CipherSuite codes used in the client hello and server hello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の値は、クライアントのhelloメッセージとサーバーのhelloメッセージで使用されるCipherSuiteコードを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CipherSuite defines a cipher specification supported in TLS Version 1.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CipherSuiteは、TLSバージョン1.0でサポートされる暗号仕様を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a TLS connection during the first handshake on that channel, but must not be negotiated, as it provides no more protection than an unsecured connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_NULL_WITH_NULL_NULLが指定されており、そのチャネルでの最初のハンドシェイク中のTLS接続の初期状態ですが、セキュリティで保護されていない接続以上の保護は提供されないため、ネゴシエーションしてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite TLS_NULL_WITH_NULL_NULL                = { 0x00,0x00 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following CipherSuite definitions require that the server provide an RSA certificate that can be used for key exchange. The server may request either an RSA or a DSS signature-capable certificate in the certificate request message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のCipherSuite定義では、サーバーが鍵交換に使用できるRSA証明書を提供する必要があります。サーバーは、証明書要求メッセージでRSAまたはDSS署名対応の証明書を要求できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
    CipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
    CipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
    CipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
    CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
    CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
    CipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
    CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The following CipherSuite definitions are used for server-authenticated (and optionally client-authenticated) Diffie-Hellman. DH denotes cipher suites in which the server&#39;s certificate contains the Diffie-Hellman parameters signed by the certificate authority (CA). DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a DSS or RSA certificate, which has been signed by the CA. The signing algorithm used is specified after the DH or DHE parameter. The server can request an RSA or DSS signature-capable certificate from the client for client authentication or it may request a Diffie-Hellman certificate. Any Diffie-Hellman certificate provided by the client must use the parameters (group and generator) described by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
次のCipherSuite定義は、サーバー認証（およびオプションでクライアント認証）Diffie-Hellmanに使用されます。 DHは、サーバーの証明書に認証局（CA）によって署名されたDiffie-Hellmanパラメーターが含まれている暗号スイートを示します。 DHEは、一時的なDiffie-Hellmanを示します。Diffie-Hellmanパラメータは、CAによって署名されたDSSまたはRSA証明書によって署名されます。使用される署名アルゴリズムは、DHまたはDHEパラメーターの後に指定されます。サーバーは、クライアント認証のためにクライアントにRSAまたはDSS署名対応証明書を要求できます。または、Diffie-Hellman証明書を要求することもできます。クライアントによって提供されるすべてのDiffie-Hellman証明書は、サーバーによって記述されたパラメーター（グループおよびジェネレーター）を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
    CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
    CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
    CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
    CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
    CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
    CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
    CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
    CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
    CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
    CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
    CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following cipher suites are used for completely anonymous Diffie-Hellman communications in which neither party is authenticated. Note that this mode is vulnerable to man-in-the-middle attacks and is therefore deprecated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の暗号スイートは、どちらの当事者も認証されない完全に匿名のDiffie-Hellman通信に使用されます。このモードはman-in-the-middle攻撃に対して脆弱であるため、非推奨であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
    CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
    CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
    CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
    CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: All cipher suites whose first byte is 0xFF are considered private and can be used for defining local/experimental algorithms. Interoperability of such types is a local matter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：最初のバイトが0xFFであるすべての暗号スイートはプライベートと見なされ、ローカル/実験的アルゴリズムの定義に使用できます。このようなタイプの相互運用性はローカルな問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Additional cipher suites can be registered by publishing an RFC which specifies the cipher suites, including the necessary TLS protocol information, including message encoding, premaster secret derivation, symmetric encryption and MAC calculation and appropriate reference information for the algorithms involved. The RFC editor&#39;s office may, at its discretion, choose to publish specifications for cipher suites which are not completely described (e.g., for classified algorithms) if it finds the specification to be of technical interest and completely specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：メッセージのエンコード、プリマスターシークレットの導出、対称暗号化、MAC計算などの必要なTLSプロトコル情報や、関連するアルゴリズムの適切な参照情報など、暗号スイートを指定するRFCを公開することで、追加の暗号スイートを登録できます。 RFCエディターのオフィスは、その裁量で、仕様が技術的に重要であり、完全に指定されているとわかった場合、完全に記述されていない暗号スイート（たとえば、分類されたアルゴリズム）の仕様を公開することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid collision with Fortezza-based cipher suites in SSL 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：暗号スイートの値{0x00、0x1C}および{0x00、0x1D}は、SSL 3のFortezzaベースの暗号スイートとの衝突を避けるために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.6. The Security Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.6. セキュリティパラメータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These security parameters are determined by the TLS Handshake Protocol and provided as parameters to the TLS Record Layer in order to initialize a connection state. SecurityParameters includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのセキュリティパラメータは、TLSハンドシェイクプロトコルによって決定され、接続状態を初期化するためのパラメータとしてTLSレコードレイヤに提供されます。 SecurityParametersには以下が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { server, client } ConnectionEnd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null, rc4, rc2, des, 3des, des40, idea }
       BulkCipherAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { stream, block } CipherType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { true, false } IsExportable;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null, md5, sha } MACAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* The algorithms specified in CompressionMethod,
   BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ConnectionEnd entity;
           BulkCipherAlgorithm bulk_cipher_algorithm;
           CipherType cipher_type;
           uint8 key_size;
           uint8 key_material_length;
           IsExportable is_exportable;
           MACAlgorithm mac_algorithm;
           uint8 hash_size;
           CompressionMethod compression_algorithm;
           opaque master_secret[48];
           opaque client_random[32];
           opaque server_random[32];
       } SecurityParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B. Glossary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.用語集
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
application protocol An application protocol is a protocol that normally layers directly on top of the transport layer (e.g., TCP/IP). Examples include HTTP, TELNET, FTP, and SMTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションプロトコルアプリケーションプロトコルは、通常、トランスポート層（TCP / IPなど）の上に直接階層化されるプロトコルです。例としては、HTTP、TELNET、FTP、SMTPなどがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
asymmetric cipher See public key cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非対称暗号公開鍵暗号を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
authentication Authentication is the ability of one entity to determine the identity of another entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証認証とは、あるエンティティが別のエンティティのIDを決定する機能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
block cipher A block cipher is an algorithm that operates on plaintext in groups of bits, called blocks. 64 bits is a common block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック暗号ブロック暗号は、ブロックと呼ばれるビットのグループでプレーンテキストを操作するアルゴリズムです。 64ビットは一般的なブロックサイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bulk cipher A symmetric encryption algorithm used to encrypt large quantities of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バルク暗号大量のデータを暗号化するために使用される対称暗号化アルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher block chaining (CBC) CBC is a mode in which every plaintext block encrypted with a block cipher is first exclusive-ORed with the previous ciphertext block (or, in the case of the first block, with the initialization vector). For decryption, every block is first decrypted, then exclusive-ORed with the previous ciphertext block (or IV).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号ブロック連鎖（CBC）CBCは、ブロック暗号で暗号化されたすべての平文ブロックが、前の暗号テキストブロック（または、最初のブロックの場合は、初期化ベクトル）と最初に排他的ORされるモードです。復号化では、すべてのブロックが最初に復号化され、次に前の暗号文ブロック（またはIV）と排他的論理和がとられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate As part of the X.509 protocol (a.k.a. ISO Authentication framework), certificates are assigned by a trusted Certificate Authority and provide a strong binding between a party&#39;s identity or some other attributes and its public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書X.509プロトコル（別名ISO認証フレームワーク）の一部として、証明書は信頼できる認証局によって割り当てられ、パーティのIDまたはその他の属性とその公開鍵との間の強力なバインディングを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client The application entity that initiates a TLS connection to a server. This may or may not imply that the client initiated the underlying transport connection. The primary operational difference between the server and client is that the server is generally authenticated, while the client is only optionally authenticated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントサーバーへのTLS接続を開始するアプリケーションエンティティ。これは、クライアントが基になるトランスポート接続を開始したことを意味する場合とそうでない場合があります。サーバーとクライアントの主な運用上の違いは、サーバーは通常認証されるのに対し、クライアントはオプションでのみ認証されることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client write key The key used to encrypt data written by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント書き込みキークライアントによって書き込まれたデータを暗号化するために使用されるキー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client write MAC secret The secret data used to authenticate data written by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント書き込みMACシークレットクライアントによって書き込まれたデータを認証するために使用されるシークレットデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
connection A connection is a transport (in the OSI layering model definition) that provides a suitable type of service. For TLS, such connections are peer to peer relationships. The connections are transient. Every connection is associated with one session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続接続は、適切なタイプのサービスを提供するトランスポート（OSIレイヤーモデル定義内）です。 TLSの場合、このような接続はピアツーピア関係です。接続は一時的です。すべての接続は1つのセッションに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Encryption Standard DES is a very widely used symmetric encryption algorithm. DES is a block cipher with a 56 bit key and an 8 byte block size. Note that in TLS, for key generation purposes, DES is treated as having an 8 byte key length (64 bits), but it still only provides 56 bits of protection. (The low bit of each key byte is presumed to be set to produce odd parity in that key byte.) DES can also be operated in a mode where three independent keys and three encryptions are used for each block of data; this uses 168 bits of key (24 bytes in the TLS key generation method) and provides the equivalent of 112 bits of security. [DES], [3DES]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ暗号化標準DESは、非常に広く使用されている対称暗号化アルゴリズムです。 DESは、56ビットの鍵と8バイトのブロックサイズを持つブロック暗号です。 TLSでは、鍵生成の目的で、DESは8バイトの鍵長（64ビット）を持つものとして扱われますが、それでも56ビットの保護しか提供しません。 （各キーバイトの下位ビットは、そのキーバイトで奇数パリティを生成するように設定されていると想定されています。）DESは、データの各ブロックに対して3つの独立したキーと3つの暗号化が使用されるモードでも動作できます。これは、168ビットの鍵（TLS鍵生成方式では24バイト）を使用し、112ビットのセキュリティと同等のものを提供します。 [DES]、[3DES]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Digital Signature Standard (DSS) A standard for digital signing, including the Digital Signing Algorithm, approved by the National Institute of Standards and Technology, defined in NIST FIPS PUB 186, &#34;Digital Signature Standard,&#34; published May, 1994 by the U.S. Dept. of Commerce. [DSS]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デジタル署名標準（DSS）NIST FIPS PUB 186「デジタル署名標準」で定義された、国立標準技術研究所によって承認されたデジタル署名アルゴリズムを含むデジタル署名の標準。商取引の。 [DSS]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
digital signatures Digital signatures utilize public key cryptography and one-way hash functions to produce a signature of the data that can be authenticated, and is difficult to forge or repudiate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デジタル署名デジタル署名は、公開鍵暗号と一方向ハッシュ関数を利用して、認証可能なデータの署名を生成します。この署名は、偽造または否認が困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
handshake An initial negotiation between client and server that establishes the parameters of their transactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクトランザクションのパラメータを確立するクライアントとサーバー間の初期のネゴシエーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialization Vector (IV) When a block cipher is used in CBC mode, the initialization vector is exclusive-ORed with the first plaintext block prior to encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期化ベクトル（IV）CBCモードでブロック暗号が使用される場合、初期化ベクトルは暗号化の前に最初の平文ブロックと排他的論理和がとられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IDEA A 64-bit block cipher designed by Xuejia Lai and James Massey. [IDEA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IDEA Xuejia LaiとJames Masseyによって設計された64ビットブロック暗号。 [考え]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message Authentication Code (MAC) A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ認証コード（MAC）メッセージ認証コードは、メッセージといくつかの秘密データから計算された一方向のハッシュです。秘密のデータを知らずに偽造することは困難です。その目的は、メッセージが変更されたかどうかを検出することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret Secure secret data used for generating encryption keys, MAC secrets, and IVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスターシークレット暗号化キー、MACシークレット、およびIVの生成に使用される安全なシークレットデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5 MD5 is a secure hashing function that converts an arbitrarily long data stream into a digest of fixed size (16 bytes). [MD5]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5 MD5は、任意の長いデータストリームを固定サイズ（16バイト）のダイジェストに変換する安全なハッシュ関数です。 [MD5]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
public key cryptography A class of cryptographic techniques employing two-key ciphers. Messages encrypted with the public key can only be decrypted with the associated private key. Conversely, messages signed with the private key can be verified with the public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開鍵暗号2鍵暗号を使用する暗号技術のクラス。公開鍵で暗号化されたメッセージは、関連付けられた秘密鍵でのみ復号化できます。逆に、秘密鍵で署名されたメッセージは、公開鍵で検証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
one-way hash function A one-way transformation that converts an arbitrary amount of data into a fixed-length hash. It is computationally hard to reverse the transformation or to find collisions. MD5 and SHA are examples of one-way hash functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方向ハッシュ関数任意量のデータを固定長ハッシュに変換する一方向変換。変換を元に戻したり、衝突を見つけることは、計算上困難です。 MD5とSHAは一方向ハッシュ関数の例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC2 A block cipher developed by Ron Rivest at RSA Data Security, Inc. [RSADSI] described in [RC2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC2 [RC2]で説明されている、RSA Data Security、Inc. [RSADSI]のRon Rivestによって開発されたブロック暗号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC4 A stream cipher licensed by RSA Data Security [RSADSI]. A compatible cipher is described in [RC4].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC4 RSA Data Security [RSADSI]によってライセンスされたストリーム暗号。互換性のある暗号については、[RC4]で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA A very widely used public-key algorithm that can be used for either encryption or digital signing. [RSA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA暗号化またはデジタル署名のいずれかに使用できる、非常に広く使用されている公開鍵アルゴリズム。 [RSA]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
salt Non-secret random data used to make export encryption keys resist precomputation attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
saltエクスポート暗号鍵を事前計算攻撃に対抗させるために使用される非秘密のランダムデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server The server is the application entity that responds to requests for connections from clients. See also under client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーサーバーは、クライアントからの接続要求に応答するアプリケーションエンティティです。クライアントの下も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session A TLS session is an association between a client and a server. Sessions are created by the handshake protocol. Sessions define a set of cryptographic security parameters, which can be shared among multiple connections. Sessions are used to avoid the expensive negotiation of new security parameters for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションTLSセッションは、クライアントとサーバー間の関連付けです。セッションは、ハンドシェイクプロトコルによって作成されます。セッションは、複数の接続間で共有できる一連の暗号化セキュリティパラメータを定義します。セッションは、各接続の新しいセキュリティパラメータの高価なネゴシエーションを回避するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session identifier A session identifier is a value generated by a server that identifies a particular session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション識別子セッション識別子は、特定のセッションを識別するサーバーによって生成される値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server write key The key used to encrypt data written by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー書き込みキーサーバーによって書き込まれたデータを暗号化するために使用されるキー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server write MAC secret The secret data used to authenticate data written by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー書き込みMACシークレットサーバーによって書き込まれたデータを認証するために使用されるシークレットデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA The Secure Hash Algorithm is defined in FIPS PUB 180-1. It produces a 20-byte output. Note that all references to SHA actually use the modified SHA-1 algorithm. [SHA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHAセキュアハッシュアルゴリズムはFIPS PUB 180-1で定義されています。 20バイトの出力を生成します。 SHAへのすべての参照は、実際には変更されたSHA-1アルゴリズムを使用することに注意してください。 [SHA]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSL Netscape&#39;s Secure Socket Layer protocol [SSL3]. TLS is based on SSL Version 3.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSL NetscapeのSecure Socket Layerプロトコル[SSL3]。 TLSはSSLバージョン3.0に基づいています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stream cipher An encryption algorithm that converts a key into a cryptographically-strong keystream, which is then exclusive-ORed with the plaintext.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム暗号鍵を暗号的に強力な鍵ストリームに変換する暗号化アルゴリズム。次に、平文と排他的論理和がとられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
symmetric cipher See bulk cipher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称暗号バルク暗号を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport Layer Security (TLS) This protocol; also, the Transport Layer Security working group of the Internet Engineering Task Force (IETF). See &#34;Comments&#34; at the end of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート層セキュリティ（TLS）このプロトコル。また、Internet Engineering Task Force（IETF）のTransport Layer Securityワーキンググループ。このドキュメントの最後にある「コメント」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
C. CipherSuite definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
C. CipherSuiteの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
CipherSuite Is Key Cipher Hash Exportable Exchange
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
CipherSuiteは主要な暗号ハッシュエクスポート可能な交換です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
TLS_NULL_WITH_NULL_NULL * NULL NULL NULL TLS_RSA_WITH_NULL_MD5 * RSA NULL MD5 TLS_RSA_WITH_NULL_SHA * RSA NULL SHA TLS_RSA_EXPORT_WITH_RC4_40_MD5 * RSA_EXPORT RC4_40 MD5 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 * RSA_EXPORT RC2_CBC_40 MD5 TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC SHA TLS_RSA_EXPORT_WITH_DES40_CBC_SHA * RSA_EXPORT DES40_CBC SHA TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA * DH_DSS_EXPORT DES40_CBC SHA TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC SHA TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA * DH_RSA_EXPORT DES40_CBC SHA TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC SHA TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSS DES_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC SHA TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 * DH_anon_EXPORT RC4_40 MD5 TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA DH_anon DES40_CBC SHA TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC SHA TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
TLS_NULL_WITH_NULL_NULL * NULL NULL NULL TLS_RSA_WITH_NULL_MD5 * RSA NULL MD5 TLS_RSA_WITH_NULL_SHA * RSA NULL SHA TLS_RSA_EXPORT_WITH_RC4_40_MD5 * RSA_EXPORT RC4_40 MD5 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 * RSA_EXPORT RC2_CBC_40 MD5 TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC SHA TLS_RSA_EXPORT_WITH_DES40_CBC_SHA * RSA_EXPORT DES40_CBC SHA TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA * DH_DSS_EXPORT DES40_CBC SHA TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC SHA TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA * DH_RSA_EXPORT DES40_CBC SHA TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC SHA TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSS DES_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC _SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC SHA TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 * DH_anon_EXPORT RC4_40 MD5 TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA DH_anon DES40_CBC SHA TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC SHA TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Indicates IsExportable is True
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* IsExportableがTrueであることを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Key Exchange Algorithm Description Key size limit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
鍵交換アルゴリズム説明鍵サイズの制限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 DHE_DSS Ephemeral DH with DSS signatures None DHE_DSS_EXPORT Ephemeral DH with DSS signatures DH = 512 bits DHE_RSA Ephemeral DH with RSA signatures None DHE_RSA_EXPORT Ephemeral DH with RSA signatures DH = 512 bits, RSA = none DH_anon Anonymous DH, no signatures None DH_anon_EXPORT Anonymous DH, no signatures DH = 512 bits DH_DSS DH with DSS-based certificates None DH_DSS_EXPORT DH with DSS-based certificates DH = 512 bits DH_RSA DH with RSA-based certificates None DH_RSA_EXPORT DH with RSA-based certificates DH = 512 bits, RSA = none NULL No key exchange N/A RSA RSA key exchange None RSA_EXPORT RSA key exchange RSA = 512 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
DHE_DSSエフェメラルDH DSS署名ありなしDHE_DSS_EXPORTエフェメラルDH DSS署名ありDH = 512ビットDHE_RSAエフェメラルDH RSA署名ありなしDHE_RSA_EXPORTエフェメラルDH RSA署名ありDH = 512ビット、RSA =なしDH_anon匿名DH、匿名DHなし、匿名DH、匿名DH、匿名DH署名DH = 512ビットDH_DSS DH DSSベースの証明書ありDH_DSS_EXPORT DH DSSベースの証明書ありDH = 512ビットDH_RSA DH RSAベースの証明書ありDH_RSA_EXPORT DH RSAベースの証明書ありDH = 512ビット、RSA =なしNULLキーなし交換N / A RSA RSAキー交換なしRSA_EXPORT RSAキー交換RSA = 512ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key size limit The key size limit gives the size of the largest public key that can be legally used for encryption in cipher suites that are exportable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵サイズ制限鍵サイズ制限は、エクスポート可能な暗号スイートでの暗号化に合法的に使用できる最大の公開鍵のサイズを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 Key Expanded Effective IV Block Cipher Type Material Key Material Key Bits Size Size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
主要な拡張された有効なIVブロック暗号のタイプマテリアル主要なマテリアルキービットサイズサイズ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
NULL * Stream 0 0 0 0 N/A IDEA_CBC Block 16 16 128 8 8 RC2_CBC_40 * Block 5 16 40 8 8 RC4_40 * Stream 5 16 40 0 N/A RC4_128 Stream 16 16 128 0 N/A DES40_CBC * Block 5 8 40 8 8 DES_CBC Block 8 8 56 8 8 3DES_EDE_CBC Block 24 24 168 8 8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
NULL *ストリーム0 0 0 0 N / A IDEA_CBCブロック16 16128 8 8 RC2_CBC_40 *ブロック5 16 40 8 8 RC4_40 *ストリーム5 16 40 0 N / A RC4_128ストリーム16 16 128 0 N / A DES40_CBC *ブロック5 8 40 8 8 DES_CBCブロック8 8 56 8 8 3DES_EDE_CBCブロック24 24168 8 8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Indicates IsExportable is true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* IsExportableがtrueであることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Indicates whether this is a stream cipher or a block cipher running in CBC mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプこれがストリーム暗号であるか、CBCモードで実行されているブロック暗号であるかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key Material The number of bytes from the key_block that are used for generating the write keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key Material書き込みキーの生成に使用されるkey_blockからのバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Expanded Key Material The number of bytes actually fed into the encryption algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Expanded Key Material The number of bytes actually fed into the encryption algorithm
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Effective Key Bits How much entropy material is in the key material being fed into the encryption routines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Effective Key Bits How much entropy material is in the key material being fed into the encryption routines.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV Size How much data needs to be generated for the initialization vector. Zero for stream ciphers; equal to the block size for block ciphers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV Size How much data needs to be generated for the initialization vector. Zero for stream ciphers; equal to the block size for block ciphers.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Block Size The amount of data a block cipher enciphers in one chunk; a block cipher running in CBC mode can only encrypt an even multiple of its block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックサイズブロ​​ック暗号が1つのチャンクで暗号化するデータの量。 CBCモードで実行されているブロック暗号は、そのブロックサイズの偶数倍しか暗号化できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 Hash Hash Padding function Size Size NULL 0 0 MD5 16 48 SHA 20 40
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ハッシュハッシュパディング機能サイズサイズNULL 0 0 MD5 16 48 SHA 20 40
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D. Implementation Notes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D. Implementation Notes
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSプロトコルは、多くの一般的なセキュリティミスを防ぐことはできません。このセクションでは、実装者を支援するためのいくつかの推奨事項を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.1. Temporary RSA keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.1. 一時的なRSAキー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
US Export restrictions limit RSA keys used for encryption to 512 bits, but do not place any limit on lengths of RSA keys used for signing operations. Certificates often need to be larger than 512 bits, since 512-bit RSA keys are not secure enough for high-value transactions or for applications requiring long-term security. Some certificates are also designated signing-only, in which case they cannot be used for key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
米国の輸出規制では、暗号化に使用されるRSAキーが512ビットに制限されていますが、署名操作に使用されるRSAキーの長さに制限はありません。 512ビットのRSAキーは、高価値のトランザクションや長期的なセキュリティを必要とするアプリケーションには十分に安全ではないため、証明書はしばしば512ビットよりも大きくする必要があります。一部の証明書は署名専用に指定されている場合もあり、その場合は鍵交換に使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the public key in the certificate cannot be used for encryption, the server signs a temporary RSA key, which is then exchanged. In exportable applications, the temporary RSA key should be the maximum allowable length (i.e., 512 bits). Because 512-bit RSA keys are relatively insecure, they should be changed often. For typical electronic commerce applications, it is suggested that keys be changed daily or every 500 transactions, and more often if possible. Note that while it is acceptable to use the same temporary key for multiple transactions, it must be signed each time it is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書の公開鍵を暗号化に使用できない場合、サーバーは一時的なRSA鍵に署名し、それを交換します。エクスポート可能なアプリケーションでは、一時的なRSAキーは最大許容長（512ビット）にする必要があります。 512ビットのRSAキーは比較的安全ではないため、頻繁に変更する必要があります。一般的な電子商取引アプリケーションでは、キーを毎日または500トランザクションごとに、可能であればさらに頻繁に変更することをお勧めします。複数のトランザクションに同じ一時キーを使用することは許容されますが、使用するたびに署名する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA key generation is a time-consuming process. In many cases, a low-priority process can be assigned the task of key generation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA鍵の生成は時間のかかるプロセスです。多くの場合、優先度の低いプロセスに鍵生成のタスクを割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a new key is completed, the existing temporary key can be replaced with the new one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいキーが完成するたびに、既存の一時キーを新しいキーに置き換えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.2. Random Number Generation and Seeding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.2. 乱数の生成とシード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS requires a cryptographically-secure pseudorandom number generator (PRNG). Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably MD5 and/or SHA, are acceptable, but cannot provide more security than the size of the random number generator state. (For example, MD5-based PRNGs usually provide 128 bits of state.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSには、暗号で保護された疑似乱数ジェネレータ（PRNG）が必要です。 PRNGの設計とシードには注意が必要です。安全なハッシュ演算、特にMD5やSHAに基づくPRNGは許容されますが、乱数ジェネレーターの状態のサイズよりも高いセキュリティを提供することはできません。 （たとえば、MD5ベースのPRNGは通常、128ビットの状態を提供します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible&#39;s 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more. To seed a 128-bit PRNG, one would thus require approximately 100 such timer values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成されるシードマテリアルの量を見積もるには、各シードバイトに予測できない情報のビット数を追加します。たとえば、PC互換の18.2 Hzタイマーから取得したキーストロークタイミング値は、カウンター値の合計サイズが16ビット以上であっても、それぞれ1ビットまたは2ビットのセキュアビットを提供します。したがって、128ビットのPRNGをシードするには、約100のそのようなタイマー値が必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Warning: The seeding functions in RSAREF and versions of BSAFE prior to 3.0 are order-independent. For example, if 1000 seed bits are supplied, one at a time, in 1000 separate calls to the seed function, the PRNG will end up in a state which depends only on the number of 0 or 1 seed bits in the seed data (i.e., there are 1001 possible final states). Applications using BSAFE or RSAREF must take extra care to ensure proper seeding. This may be accomplished by accumulating seed bits into a buffer and processing them all at once or by processing an incrementing counter with every seed bit; either method will reintroduce order dependence into the seeding process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
警告：RSAREFおよび3.0より前のバージョンのBSAFEのシード関数は、順序に依存しません。たとえば、シード関数への1000回の個別の呼び出しで1000のシードビットが一度に1つずつ提供される場合、PRNGはシードデータの0または1のシードビットの数のみに依存する状態になります（つまり、 、1001の可能な最終状態があります）。 BSAFEまたはRSAREFを使用するアプリケーションでは、適切なシードが行われるように特に注意する必要があります。これは、シードビットをバッファに蓄積して一度に処理するか、すべてのシードビットでインクリメントカウンタを処理することによって実現できます。どちらの方法でも、順序依存をシードプロセスに再導入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.3. Certificates and authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.3. 証明書と認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully. Users should be able to view information about the certificate and root CA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully. Users should be able to view information about the certificate and root CA.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.4. CipherSuites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.4. CipherSuites
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS supports a range of key sizes and security levels, including some which provide no or minimal security. A proper implementation will probably not support many cipher suites. For example, 40-bit encryption is easily broken, so implementations requiring strong security should not allow 40-bit keys. Similarly, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man-in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512-bit RSA keys or signatures are not appropriate for high-security applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS supports a range of key sizes and security levels, including some which provide no or minimal security. A proper implementation will probably not support many cipher suites. For example, 40-bit encryption is easily broken, so implementations requiring strong security should not allow 40-bit keys. Similarly, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man-in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512-bit RSA keys or signatures are not appropriate for high-security applications.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E. Backward Compatibility With SSL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E. SSLとの下位互換性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For historical reasons and in order to avoid a profligate consumption of reserved port numbers, application protocols which are secured by TLS 1.0, SSL 3.0, and SSL 2.0 all frequently share the same connection port: for example, the https protocol (HTTP secured by SSL or TLS) uses port 443 regardless of which security protocol it is using. Thus, some mechanism must be determined to distinguish and negotiate among the various protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的な理由により、予約されたポート番号の浪費を避けるために、TLS 1.0、SSL 3.0、およびSSL 2.0によって保護されているアプリケーションプロトコルはすべて同じ接続ポートを頻繁に共有します。たとえば、httpsプロトコル（SSLによって保護されたHTTP）またはTLS）は、使用しているセキュリティプロトコルに関係なく、ポート443を使用します。したがって、さまざまなプロトコルを区別してネゴシエートするには、いくつかのメカニズムを決定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS version 1.0 and SSL 3.0 are very similar; thus, supporting both is easy. TLS clients who wish to negotiate with SSL 3.0 servers should send client hello messages using the SSL 3.0 record format and client hello structure, sending {3, 1} for the version field to note that they support TLS 1.0. If the server supports only SSL 3.0, it will respond with an SSL 3.0 server hello; if it supports TLS, with a TLS server hello. The negotiation then proceeds as appropriate for the negotiated protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS version 1.0 and SSL 3.0 are very similar; thus, supporting both is easy. TLS clients who wish to negotiate with SSL 3.0 servers should send client hello messages using the SSL 3.0 record format and client hello structure, sending {3, 1} for the version field to note that they support TLS 1.0. If the server supports only SSL 3.0, it will respond with an SSL 3.0 server hello; if it supports TLS, with a TLS server hello. The negotiation then proceeds as appropriate for the negotiated protocol.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, a TLS server which wishes to interoperate with SSL 3.0 clients should accept SSL 3.0 client hello messages and respond with an SSL 3.0 server hello if an SSL 3.0 client hello is received which has a version field of {3, 0}, denoting that this client does not support TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、SSL 3.0クライアントと相互運用したいTLSサーバーは、バージョンフィールドが{3、0}であるSSL 3.0クライアントhelloを受信した場合、SSL 3.0クライアントhelloメッセージを受け入れ、SSL 3.0サーバーhelloで応答する必要があります。このクライアントはTLSをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a client already knows the highest protocol known to a server (for example, when resuming a session), it should initiate the connection in that native protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバーに認識されている最高のプロトコルをすでに知っているときはいつでも（たとえば、セッションを再開するとき）、そのネイティブプロトコルで接続を開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.0 clients that support SSL Version 2.0 servers must send SSL Version 2.0 client hello messages [SSL2]. TLS servers should accept either client hello format if they wish to support SSL 2.0 clients on the same connection port. The only deviations from the Version 2.0 specification are the ability to specify a version with a value of three and the support for more ciphering types in the CipherSpec.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSLバージョン2.0サーバーをサポートするTLS 1.0クライアントは、SSLバージョン2.0クライアントのHelloメッセージ[SSL2]を送信する必要があります。 TLSサーバーは、同じ接続ポートでSSL 2.0クライアントをサポートする場合、いずれかのクライアントのHello形式を受け入れる必要があります。バージョン2.0仕様からの唯一の違いは、3の値でバージョンを指定できることと、CipherSpecでより多くの暗号化タイプをサポートすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Warning: The ability to send Version 2.0 client hello messages will be phased out with all due haste. Implementors should make every effort to move forward as quickly as possible. Version 3.0 provides better mechanisms for moving to newer versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
警告：バージョン2.0クライアントのhelloメッセージを送信する機能は、すべての急いで廃止されます。実装者は、できるだけ早く前進するためにあらゆる努力をする必要があります。バージョン3.0は、新しいバージョンに移行するための優れたメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following cipher specifications are carryovers from SSL Version 2.0. These are assumed to use RSA for key exchange and authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の暗号仕様は、SSLバージョン2.0からのキャリーオーバーです。これらは、鍵交換と認証にRSAを使用すると想定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
       V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
       V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                                  = { 0x04,0x00,0x80 };
       V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
       V2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
       V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cipher specifications native to TLS can be included in Version 2.0 client hello messages using the syntax below. Any V2CipherSpec element with its first byte equal to zero will be ignored by Version 2.0 servers. Clients sending any of the above V2CipherSpecs should also include the TLS equivalent (see Appendix A.5):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSネイティブの暗号仕様は、以下の構文を使用してバージョン2.0クライアントのhelloメッセージに含めることができます。最初のバイトがゼロに等しいV2CipherSpecエレメントは、バージョン2.0サーバーによって無視されます。上記のV2CipherSpecのいずれかを送信するクライアントには、同等のTLSも含める必要があります（付録A.5を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       V2CipherSpec (see TLS name) = { 0x00, CipherSuite };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.1. Version 2 client hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.1. Version 2 client hello
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Version 2.0 client hello message is presented below using this document&#39;s presentation model. The true definition is still assumed to be the SSL Version 2.0 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Version 2.0 client hello message is presented below using this document&#39;s presentation model. The true definition is still assumed to be the SSL Version 2.0 specification.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
uint8 V2CipherSpec[3];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
uint8 V2CipherSpec [3];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           uint8 msg_type;
           Version version;
           uint16 cipher_spec_length;
           uint16 session_id_length;
           uint16 challenge_length;
           V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
           opaque session_id[V2ClientHello.session_id_length];
           Random challenge;
       } V2ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
msg_type This field, in conjunction with the version field, identifies a version 2 client hello message. The value should be one (1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
msg_type This field, in conjunction with the version field, identifies a version 2 client hello message. The value should be one (1).
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The highest version of the protocol supported by the client (equals ProtocolVersion.version, see Appendix A.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The highest version of the protocol supported by the client (equals ProtocolVersion.version, see Appendix A.1).
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_spec_length This field is the total length of the field cipher_specs. It cannot be zero and must be a multiple of the V2CipherSpec length (3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_spec_lengthこのフィールドは、フィールドcipher_specsの全長です。ゼロにすることはできず、V2CipherSpecの長さ（3）の倍数でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id_length This field must have a value of either zero or 16. If zero, the client is creating a new session. If 16, the session_id field will contain the 16 bytes of session identification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id_lengthこのフィールドには、ゼロまたは16の値が必要です。ゼロの場合、クライアントは新しいセッションを作成しています。 16の場合、session_idフィールドには16バイトのセッションIDが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge_length The length in bytes of the client&#39;s challenge to the server to authenticate itself. This value must be 32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge_length自身を認証するためのサーバーへのクライアントのチャレンジの長さ（バイト単位）。この値は32でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_specs This is a list of all CipherSpecs the client is willing and able to use. There must be at least one CipherSpec acceptable to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_specsこれは、クライアントが喜んで使用できるすべてのCipherSpecのリストです。サーバーで受け入れ可能なCipherSpecが少なくとも1つ必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id If this field&#39;s length is not zero, it will contain the identification for a session that the client wishes to resume.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id If this field&#39;s length is not zero, it will contain the identification for a session that the client wishes to resume.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge The client challenge to the server for the server to identify itself is a (nearly) arbitrary length random. The TLS server will right justify the challenge data to become the ClientHello.random data (padded with leading zeroes, if necessary), as specified in this protocol specification. If the length of the challenge is greater than 32 bytes, only the last 32 bytes are used. It is legitimate (but not necessary) for a V3 server to reject a V2 ClientHello that has fewer than 16 bytes of challenge data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge The client challenge to the server for the server to identify itself is a (nearly) arbitrary length random. The TLS server will right justify the challenge data to become the ClientHello.random data (padded with leading zeroes, if necessary), as specified in this protocol specification. If the length of the challenge is greater than 32 bytes, only the last 32 bytes are used. It is legitimate (but not necessary) for a V3 server to reject a V2 ClientHello that has fewer than 16 bytes of challenge data.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Requests to resume a TLS session should use a TLS client hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：TLSセッションを再開する要求は、TLSクライアントのHelloを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.2. Avoiding man-in-the-middle version rollback
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.2. 中間者バージョンのロールバックを回避する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When TLS clients fall back to Version 2.0 compatibility mode, they should use special PKCS #1 block formatting. This is done so that TLS servers will reject Version 2.0 sessions with TLS-capable clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSクライアントがバージョン2.0互換モードにフォールバックする場合、クライアントは特別なPKCS＃1ブロックフォーマットを使用する必要があります。これは、TLSサーバーがTLS対応クライアントとのバージョン2.0セッションを拒否するように行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When TLS clients are in Version 2.0 compatibility mode, they set the right-hand (least-significant) 8 random bytes of the PKCS padding (not including the terminal null of the padding) for the RSA encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY to 0x03 (the other padding bytes are random). After decrypting the ENCRYPTED-KEY-DATA field, servers that support TLS should issue an error if these eight padding bytes are 0x03. Version 2.0 servers receiving blocks padded in this manner will proceed normally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSクライアントがバージョン2.0互換モードの場合、ENCRYPTED-KEY-DATAフィールドのRSA暗号化のために、PKCSパディングの右側（最下位）のランダムな8バイト（パディングの端末ヌルを含まない）を設定します。 CLIENT-MASTER-KEYを0x03に変更します（他のパディングバイトはランダムです）。 ENCRYPTED-KEY-DATAフィールドを復号化した後、これらの8つのパディングバイトが0x03の場合、TLSをサポートするサーバーはエラーを発行する必要があります。この方法でパディングされたブロックを受信するバージョン2.0サーバーは、正常に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F. Security analysis
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.セキュリティ分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSプロトコルは、安全でないチャネルを介して通信するクライアントとサーバー間の安全な接続を確立するように設計されています。このドキュメントは、攻撃者がかなりの計算リソースを持ち、プロトコルの外部のソースから秘密情報を取得できないことを含め、いくつかの従来の仮定を行います。攻撃者は、通信チャネルを介して送信されたメッセージをキャプチャ、変更、削除、再生、その他改ざんする機能を持っていると想定されています。この付録では、さまざまな攻撃に対抗するためにTLSがどのように設計されているかについて概説します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1. Handshake protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1. ハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake protocol is responsible for selecting a CipherSpec and generating a Master Secret, which together comprise the primary cryptographic parameters associated with a secure session. The handshake protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクプロトコルは、CipherSpecの選択とマスターシークレットの生成を担当します。マスターシークレットは、安全なセッションに関連付けられた主要な暗号化パラメーターを一緒に構成します。ハンドシェイクプロトコルは、信頼できる認証局によって署名された証明書を持つ当事者をオプションで認証することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1. Authentication and key exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1. 認証と鍵交換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other&#39;s certificate is valid and has not expired or been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは3つの認証モードをサポートします。両方の認証、非認証クライアントによるサーバー認証、完全な匿名性です。サーバーが認証されるたびに、チャネルは中間者攻撃に対して安全ですが、完全に匿名のセッションは本質的にそのような攻撃に対して脆弱です。匿名サーバーはクライアントを認証できません。サーバーが認証される場合、その証明書メッセージは、受け入れ可能な認証局につながる有効な証明書チェーンを提供する必要があります。同様に、認証されたクライアントは、受け入れ可能な証明書をサーバーに提供する必要があります。各当事者は、相手の証明書が有効であり、有効期限が切れていない、または取り消されていないことを確認する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general goal of the key exchange process is to create a pre_master_secret known to the communicating parties and not to attackers. The pre_master_secret will be used to generate the master_secret (see Section 8.1). The master_secret is required to generate the certificate verify and finished messages, encryption keys, and MAC secrets (see Sections 7.4.8, 7.4.9 and 6.3). By sending a correct finished message, parties thus prove that they know the correct pre_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵交換プロセスの一般的な目標は、攻撃者ではなく通信相手に知られるpre_master_secretを作成することです。 pre_master_secretは、master_secretを生成するために使用されます（セクション8.1を参照）。 master_secretは、証明書の検証と終了メッセージ、暗号化キー、およびMACシークレットを生成するために必要です（セクション7.4.8、7.4.9、および6.3を参照）。パーティは、正しい完成したメッセージを送信することにより、正しいpre_master_secretを知っていることを証明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.1. Anonymous key exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.1. Anonymous key exchange
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Completely anonymous sessions can be established using RSA or Diffie-Hellman for key exchange. With anonymous RSA, the client encrypts a pre_master_secret with the server&#39;s uncertified public key extracted from the server key exchange message. The result is sent in a client key exchange message. Since eavesdroppers do not know the server&#39;s private key, it will be infeasible for them to decode the pre_master_secret. (Note that no anonymous RSA Cipher Suites are defined in this document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
鍵の交換にRSAまたはDiffie-Hellmanを使用して、完全に匿名のセッションを確立できます。匿名RSAを使用すると、クライアントは、サーバーの鍵交換メッセージから抽出されたサーバーの認証されていない公開鍵を使用してpre_master_secretを暗号化します。結果はクライアントの鍵交換メッセージで送信されます。盗聴者はサーバーの秘密鍵を知らないため、pre_master_secretを解読することは不可能です。 （このドキュメントでは、匿名のRSA暗号スイートは定義されていないことに注意してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With Diffie-Hellman, the server&#39;s public parameters are contained in the server key exchange message and the client&#39;s are sent in the client key exchange message. Eavesdroppers who do not know the private values should not be able to find the Diffie-Hellman result (i.e. the pre_master_secret).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellmanを使用すると、サーバーの公開パラメーターはサーバーの鍵交換メッセージに含まれ、クライアントのパラメーターはクライアントの鍵交換メッセージで送信されます。プライベートな値を知らない盗聴者は、Diffie-Hellmanの結果（つまり、pre_master_secret）を見つけることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Warning: Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
警告：完全に匿名の接続は、受動的な盗聴に対する保護のみを提供します。独立した改ざん防止チャネルを使用して、完成したメッセージが攻撃者に置き換えられなかったことを確認しない限り、アクティブな中間者攻撃が懸念される環境ではサーバー認証が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.2. RSA key exchange and authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.2. RSA鍵の交換と認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With RSA, key exchange and server authentication are combined. The public key may be either contained in the server&#39;s certificate or may be a temporary RSA key sent in a server key exchange message. When temporary RSA keys are used, they are signed by the server&#39;s RSA or DSS certificate. The signature includes the current ClientHello.random, so old signatures and temporary keys cannot be replayed. Servers may use a single temporary RSA key for multiple negotiation sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAでは、鍵交換とサーバー認証が組み合わされています。公開キーは、サーバーの証明書に含まれている場合と、サーバーキー交換メッセージで送信される一時的なRSAキーの場合があります。一時的なRSAキーが使用される場合、それらはサーバーのRSAまたはDSS証明書によって署名されます。署名には現在のClientHello.randomが含まれているため、古い署名と一時キーは再生できません。サーバーは、複数のネゴシエーションセッションに単一の一時RSAキーを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: The temporary RSA key option is useful if servers need large certificates but must comply with government-imposed size limits on keys used for key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：一時的なRSAキーオプションは、サーバーが大きな証明書を必要とするが、キー交換に使用されるキーに政府が課すサイズ制限に準拠する必要がある場合に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After verifying the server&#39;s certificate, the client encrypts a pre_master_secret with the server&#39;s public key. By successfully decoding the pre_master_secret and producing a correct finished message, the server demonstrates that it knows the private key corresponding to the server certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの証明書を確認した後、クライアントはサーバーの公開鍵を使用してpre_master_secretを暗号化します。 pre_master_secretを正常にデコードして正しい終了メッセージを生成することにより、サーバーは、サーバー証明書に対応する秘密鍵を知っていることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RSA is used for key exchange, clients are authenticated using the certificate verify message (see Section 7.4.8). The client signs a value derived from the master_secret and all preceding handshake messages. These handshake messages include the server certificate, which binds the signature to the server, and ServerHello.random, which binds the signature to the current handshake process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAをキー交換に使用する場合、クライアントは証明書検証メッセージを使用して認証されます（セクション7.4.8を参照）。クライアントは、master_secretおよび先行するすべてのハンドシェイクメッセージから派生した値に署名します。これらのハンドシェイクメッセージには、署名をサーバーにバインドするサーバー証明書と、署名を現在のハンドシェイクプロセスにバインドするServerHello.randomが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.3. Diffie-Hellman key exchange with authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.3. 認証付きのDiffie-Hellman鍵交換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When Diffie-Hellman key exchange is used, the server can either supply a certificate containing fixed Diffie-Hellman parameters or can use the server key exchange message to send a set of temporary Diffie-Hellman parameters signed with a DSS or RSA certificate. Temporary parameters are hashed with the hello.random values before signing to ensure that attackers do not replay old parameters. In either case, the client can verify the certificate or signature to ensure that the parameters belong to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellman鍵交換が使用される場合、サーバーは、固定Diffie-Hellmanパラメーターを含む証明書を提供するか、サーバー鍵交換メッセージを使用して、DSSまたはRSA証明書で署名された一時的なDiffie-Hellmanパラメーターのセットを送信できます。一時的なパラメーターは、署名前にhello.random値でハッシュされ、攻撃者が古いパラメーターを再生しないようにします。どちらの場合でも、クライアントは証明書または署名を検証して、パラメーターがサーバーに属していることを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has a certificate containing fixed Diffie-Hellman parameters, its certificate contains the information required to complete the key exchange. Note that in this case the client and server will generate the same Diffie-Hellman result (i.e., pre_master_secret) every time they communicate. To prevent the pre_master_secret from staying in memory any longer than necessary, it should be converted into the master_secret as soon as possible. Client Diffie-Hellman parameters must be compatible with those supplied by the server for the key exchange to work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに固定Diffie-Hellmanパラメーターを含む証明書がある場合、その証明書には、鍵交換を完了するために必要な情報が含まれています。この場合、クライアントとサーバーは、通信するたびに同じDiffie-Hellman結果（つまり、pre_master_secret）を生成することに注意してください。 pre_master_secretが必要以上に長くメモリに留まるのを防ぐには、できるだけ早くmaster_secretに変換する必要があります。クライアントのDiffie-Hellmanパラメータは、鍵交換が機能するために、サーバーによって提供されるものと互換性がある必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has a standard DSS or RSA certificate or is unauthenticated, it sends a set of temporary parameters to the server in the client key exchange message, then optionally uses a certificate verify message to authenticate itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが標準のDSSまたはRSA証明書を持っているか、認証されていない場合、クライアントはクライアントの鍵交換メッセージで一時パラメーターのセットをサーバーに送信し、オプションで証明書検証メッセージを使用して自身を認証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.2. Version rollback attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.2. バージョンロールバック攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS-capable parties use an SSL 2.0 handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSにはSSLバージョン2.0に対する大幅な改善が含まれているため、攻撃者はTLS対応のクライアントとサーバーをバージョン2.0にフォールバックしようとする可能性があります。この攻撃は、2つのTLS対応パーティがSSL 2.0ハンドシェイクを使用している場合にのみ発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application specified wait threshold has expired. Parties concerned about attacks of this scale should not be using 40-bit encryption keys anyway. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非ランダムPKCS＃1ブロックタイプ2メッセージパディングを使用するソリューションは洗練されていませんが、バージョン3.0サーバーが攻撃を検出するためのかなり安全な方法を提供します。このソリューションは、攻撃者がキーをブルートフォースし、同じキーを含む新しいENCRYPTED-KEY-DATAメッセージを（ただし、通常のパディングを使用して）代用して、アプリケーションで指定された待機しきい値が満了する前に安全ではありません。この規模の攻撃を懸念する当事者は、いずれにせよ40ビットの暗号化キーを使用すべきではありません。 PKCSパディングの最下位8バイトのパディングを変更しても、プロトコルで使用される署名付きハッシュのサイズとRSAキー長のセキュリティには影響しません。これは、入力ブロックサイズを8バイト増やすことと本質的に同じであるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.3. Detecting attacks against the handshake protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.3. ハンドシェイクプロトコルに対する攻撃の検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally choose. Because many implementations will support 40-bit exportable encryption and some may even support null encryption or MAC algorithms, this attack is of particular concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、ハンドシェイク交換に影響を与え、当事者が通常選択するのとは異なる暗号化アルゴリズムを選択させる可能性があります。多くの実装は40ビットのエクスポート可能な暗号化をサポートし、一部はnull暗号化またはMACアルゴリズムをサポートすることさえあるため、この攻撃は特に懸念されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others&#39; finished messages. Without the master_secret, the attacker cannot repair the finished messages, so the attack will be discovered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この攻撃では、攻撃者は1つ以上のハンドシェイクメッセージを積極的に変更する必要があります。これが発生した場合、クライアントとサーバーは、ハンドシェイクメッセージハッシュの異なる値を計算します。その結果、当事者はお互いの完成したメッセージを受け入れません。 master_secretがないと、攻撃者は完了したメッセージを修復できないため、攻撃が発見されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.4. Resuming sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.4. セッションの再開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a connection is established by resuming a session, new ClientHello.random and ServerHello.random values are hashed with the session&#39;s master_secret. Provided that the master_secret has not been compromised and that the secure hash operations used to produce the encryption keys and MAC secrets are secure, the connection should be secure and effectively independent from previous connections. Attackers cannot use known encryption keys or MAC secrets to compromise the master_secret without breaking the secure hash operations (which use both SHA and MD5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションを再開して接続が確立されると、新しいClientHello.randomとServerHello.randomの値がセッションのmaster_secretでハッシュされます。 master_secretが危険にさらされておらず、暗号化キーとMACシークレットを生成するために使用される安全なハッシュ操作が安全であれば、接続は安全で、以前の接続から事実上独立している必要があります。攻撃者は、既知の暗号化キーまたはMACシークレットを使用して、安全なハッシュ操作（SHAとMD5の両方を使用）を壊さずにmaster_secretを危険にさらすことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sessions cannot be resumed unless both the client and server agree. If either party suspects that the session may have been compromised, or that certificates may have expired or been revoked, it should force a full handshake. An upper limit of 24 hours is suggested for session ID lifetimes, since an attacker who obtains a master_secret may be able to impersonate the compromised party until the corresponding session ID is retired. Applications that may be run in relatively insecure environments should not write session IDs to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーの両方が同意しない限り、セッションを再開することはできません。どちらかの当事者が、セッションが危険にさらされている可能性がある、または証明書が期限切れになっている、または取り消されている可能性があると疑う場合は、完全なハンドシェイクを強制する必要があります。 master_secretを取得した攻撃者は、対応するセッションIDが廃止されるまで、侵害されたパーティを偽装できる可能性があるため、セッションIDのライフタイムには24時間の上限をお勧めします。比較的安全でない環境で実行される可能性のあるアプリケーションは、セッションIDを安定したストレージに書き込むべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.5. MD5 and SHA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.5. MD5およびSHA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS uses hash functions very conservatively. Where possible, both MD5 and SHA are used in tandem to ensure that non-catastrophic flaws in one algorithm will not break the overall protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSはハッシュ関数を非常に保守的に使用します。可能であれば、MD5とSHAの両方を組み合わせて使用​​し、1つのアルゴリズムの致命的でない欠陥がプロトコル全体を壊さないようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.2. Protecting application data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.2. アプリケーションデータの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master_secret is hashed with the ClientHello.random and ServerHello.random to produce unique data encryption keys and MAC secrets for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master_secretはClientHello.randomおよびServerHello.randomでハッシュされ、接続ごとに一意のデータ暗号化キーとMACシークレットが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outgoing data is protected with a MAC before transmission. To prevent message replay or modification attacks, the MAC is computed from the MAC secret, the sequence number, the message length, the message contents, and two fixed character strings. The message type field is necessary to ensure that messages intended for one TLS Record Layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64-bits long, they should never overflow. Messages from one party cannot be inserted into the other&#39;s output, since they use independent MAC secrets. Similarly, the server-write and client-write keys are independent so stream cipher keys are used only once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信データは、送信前にMACで保護されます。メッセージの再生または変更攻撃を防ぐために、MACシークレット、シーケンス番号、メッセージの長さ、メッセージの内容、および2つの固定文字列からMACが計算されます。メッセージタイプフィールドは、1つのTLSレコードレイヤクライアント宛のメッセージが別のクライアントにリダイレクトされないようにするために必要です。シーケンス番号により、メッセージの削除または並べ替えの試行が確実に検出されます。シーケンス番号は64ビット長であるため、オーバーフローすることはありません。あるパーティからのメッセージは、独立したMACシークレットを使用するため、他のパーティの出力には挿入できません。同様に、サーバー書き込みキーとクライアント書き込みキーは独立しているため、ストリーム暗号キーは1回だけ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an attacker does break an encryption key, all messages encrypted with it can be read. Similarly, compromise of a MAC key can make message modification attacks possible. Because MACs are also encrypted, message-alteration attacks generally require breaking the encryption algorithm as well as the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者が暗号化キーを破った場合、それを使用して暗号化されたすべてのメッセージを読み取ることができます。同様に、MACキーが侵害されると、メッセージ変更攻撃が可能になります。 MACも暗号化されているため、メッセージ変更攻撃では通常、MACだけでなく暗号化アルゴリズムを破る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: MAC secrets may be larger than encryption keys, so messages can remain tamper resistant even if encryption keys are broken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：MACシークレットは暗号化キーよりも大きい場合があるため、暗号化キーが壊れていてもメッセージは改ざんされないままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.3. Final notes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.3. 最終メモ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSが安全な接続を提供できるようにするには、クライアントとサーバーの両方のシステム、キー、およびアプリケーションが安全である必要があります。さらに、実装にはセキュリティエラーがないことが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys, 40-bit bulk encryption keys, and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
システムは、サポートされている最も弱い鍵交換および認証アルゴリズムと同じくらい強力であり、信頼できる暗号化機能のみを使用する必要があります。短い公開鍵、40ビットのバルク暗号化鍵、および匿名サーバーの使用には十分な注意が必要です。実装とユーザーは、どの証明書と認証局が許容できるかを決定するときに注意する必要があります。不正な認証局は多大な損害を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
G. Patent Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
G.特許ステートメント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the cryptographic algorithms proposed for use in this protocol have patent claims on them. In addition Netscape Communications Corporation has a patent claim on the Secure Sockets Layer (SSL) work that this standard is based on. The Internet Standards Process as defined in RFC 2026 requests that a statement be obtained from a Patent holder indicating that a license will be made available to applicants under reasonable terms and conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルでの使用が提案されている暗号化アルゴリズムのいくつかは、それらに関する特許請求があります。さらに、Netscape Communications Corporationは、この標準のベースとなっているSecure Sockets Layer（SSL）に関する特許請求を行っています。 RFC 2026で定義されているインターネット標準プロセスは、ライセンスが妥当な条件の下で申請者に提供されることを示す声明を特許権者から取得することを要求しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Massachusetts Institute of Technology has granted RSA Data Security, Inc., exclusive sub-licensing rights to the following patent issued in the United States:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マサチューセッツ工科大学はRSA Data Security、Inc.に、米国で発行された次の特許の独占的サブライセンス権を付与しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Cryptographic Communications System and Method (&#34;RSA&#34;), No. 4,405,829
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
暗号通信システムおよび方法（「RSA」）、No。4,405,829
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscape Communications Corporation has been issued the following patent in the United States:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscape Communications Corporationは米国で次の特許を取得しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Secure Socket Layer Application Program Apparatus And Method (&#34;SSL&#34;), No. 5,657,390
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Secure Socket Layer Application Program Apparatus And Method（ &#34;SSL&#34;）、No. 5,657,390
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscape Communications has issued the following statement:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscape Communicationsは、次の声明を発表しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Intellectual Property Rights
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
知的財産権
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Secure Sockets Layer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
セキュア・ソケット・レイヤー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The United States Patent and Trademark Office (&#34;the PTO&#34;) recently issued U.S. Patent No. 5,657,390 (&#34;the SSL Patent&#34;) to Netscape for inventions described as Secure Sockets Layers (&#34;SSL&#34;). The IETF is currently considering adopting SSL as a transport protocol with security features. Netscape encourages the royalty-free adoption and use of the SSL protocol upon the following terms and conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
米国特許商標庁（「PTO」）は、セキュアソケットレイヤー（「SSL」）として説明されている発明について、米国特許第5,657,390号（「SSL特許」）をNetscapeに最近発行しました。 IETFは現在、セキュリティ機能を備えたトランスポートプロトコルとしてSSLを採用することを検討しています。 Netscapeは、以下の契約条件に基づいて、SSLプロトコルの使用料無料の採用と使用を奨励しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* If you already have a valid SSL Ref license today which includes source code from Netscape, an additional patent license under the SSL patent is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* Netscapeのソースコードを含む有効なSSL Refライセンスがすでにある場合は、SSL特許に基づく追加の特許ライセンスは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* If you don&#39;t have an SSL Ref license, you may have a royalty free license to build implementations covered by the SSL Patent Claims or the IETF TLS specification provided that you do not to assert any patent rights against Netscape or other companies for the implementation of SSL or the IETF TLS recommendation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* SSL Refライセンスをお持ちでない場合は、SSLscapeクレームまたはIETF TLS仕様の対象となる実装を構築するためのロイヤリティフリーライセンスをお持ちである可能性があります。ただし、Netscapeまたは他の企業に対して実装に関する特許権を主張しない場合に限ります。 SSLまたはIETF TLSの推奨事項。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
What are &#34;Patent Claims&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
「特許請求」とは：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Patent claims are claims in an issued foreign or domestic patent that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
特許クレームとは、発行された外国または国内の特許におけるクレームで、次のようなものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1) must be infringed in order to implement methods or build products according to the IETF TLS specification; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1）IETF TLS仕様に従ってメソッドを実装したり製品をビルドしたりするには、侵害されている必要があります。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2) patent claims which require the elements of the SSL patent claims and/or their equivalents to be infringed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2）SSL特許クレームの要素および/またはその同等物が侵害されることを要求する特許クレーム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Internet Society, Internet Architecture Board, Internet Engineering Steering Group and the Corporation for National Research Initiatives take no position on the validity or scope of the patents and patent applications, nor on the appropriateness of the terms of the assurance. The Internet Society and other groups mentioned above have not made any determination as to any other intellectual property rights which may apply to the practice of this standard. Any further consideration of these matters is the user&#39;s own responsibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet Society、Internet Architecture Board、Internet Engineering Steering Group、およびCorporation for National Research Initiativesは、特許および特許申請の有効性や範囲について、また保証の条件の妥当性について、いかなる立場も持ちません。上記のインターネットソサエティおよびその他のグループは、この標準の実施に適用される可能性のあるその他の知的財産権については何も決定していません。これらの事項についてさらに検討することは、ユーザー自身の責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Security Considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
セキュリティに関する考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security issues are discussed throughout this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティの問題は、このメモ全体で議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3DES] W. Tuchman, &#34;Hellman Presents No Shortcut Solutions To DES,&#34; IEEE Spectrum, v. 16, n. 7, July 1979, pp40-41.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3DES] W.タチマン、「ヘルマンはDESにショートカットソリューションを提供しない」、IEEE Spectrum、v。16、n。 1979年7月7日、40-41ページ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BLEI] Bleichenbacher D., &#34;Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1&#34; in Advances in Cryptology -- CRYPTO&#39;98, LNCS vol. 1462, pages: 1--12, 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BLEI] Bleichenbacher D。、「Advance in Cryptology-CRYPTO&#39;98、LNCS vol。のRSA暗号化標準PKCS＃1に基づくプロトコルに対する選択された暗号文攻撃」 1462、ページ：1-12、1998年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DES] ANSI X3.106, &#34;American National Standard for Information Systems-Data Link Encryption,&#34; American National Standards Institute, 1983.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DES] ANSI X3.106、「American National Standard for Information Systems-Data Link Encryption」、American National Standards Institute、1983年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DH1] W. Diffie and M. E. Hellman, &#34;New Directions in Cryptography,&#34; IEEE Transactions on Information Theory, V. IT-22, n. 6, Jun 1977, pp. 74-84.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DH1] W. DiffieおよびM. E. Hellman、「新しい方向性の暗号化」、IEEE Transactions on Information Theory、V。IT-22、n。 6、1977年6月、pp。74-84。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS] NIST FIPS PUB 186, &#34;Digital Signature Standard,&#34; National Institute of Standards and Technology, U.S. Department of Commerce, May 18, 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS] NIST FIPS PUB 186、「Digital Signature Standard」、米国連邦情報・技術局、米国商務省、1994年5月18日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FTP] Postel J., and J. Reynolds, &#34;File Transfer Protocol&#34;, STD 9, RFC 959, October 1985.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FTP] Postel J.およびJ. Reynolds、「File Transfer Protocol」、STD 9、RFC 959、1985年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP] Berners-Lee, T., Fielding, R., and H. Frystyk, &#34;Hypertext Transfer Protocol -- HTTP/1.0&#34;, RFC 1945, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP] Berners-Lee、T.、Fielding、R。、およびH. Frystyk、「Hypertext Transfer Protocol-HTTP / 1.0」、RFC 1945、May 1996。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication,&#34; RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HMAC] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDEA] X. Lai, &#34;On the Design and Security of Block Ciphers,&#34; ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[アイデア] X. Lai、「ブロック暗号の設計とセキュリティについて」、情報処理のETHシリーズ、v。1、コンスタンツ：Hartung-Gorre Verlag、1992年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD2] Kaliski, B., &#34;The MD2 Message Digest Algorithm&#34;, RFC 1319, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD2] Kaliski、B。、「The MD2 Message Digest Algorithm」、RFC 1319、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest, R., &#34;The MD5 Message Digest Algorithm&#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest、R。、「The MD5 Message Digest Algorithm」、RFC 1321、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS1] RSA Laboratories, &#34;PKCS #1: RSA Encryption Standard,&#34; version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS1] RSA Laboratories、「PKCS＃1：RSA Encryption Standard」、バージョン1.5、1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS6] RSA Laboratories, &#34;PKCS #6: RSA Extended Certificate Syntax Standard,&#34; version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS6] RSA Laboratories、「PKCS＃6：RSA Extended Certificate Syntax Standard」、バージョン1.5、1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS7] RSA Laboratories, &#34;PKCS #7: RSA Cryptographic Message Syntax Standard,&#34; version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS7] RSA Laboratories、「PKCS＃7：RSA Cryptographic Message Syntax Standard」、バージョン1.5、1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKIX] Housley, R., Ford, W., Polk, W. and D. Solo, &#34;Internet Public Key Infrastructure: Part I: X.509 Certificate and CRL Profile&#34;, RFC 2459, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKIX] Housley、R.、Ford、W.、Polk、W。およびD. Solo、「インターネット公開鍵インフラストラクチャ：パートI：X.509証明書およびCRLプロファイル」、RFC 2459、1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RC2] Rivest, R., &#34;A Description of the RC2(r) Encryption Algorithm&#34;, RFC 2268, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RC2] Rivest、R。、「A Description of the RC2（r）Encryption Algorithm」、RFC 2268、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RC4] Thayer, R. and K. Kaukonen, A Stream Cipher Encryption Algorithm, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RC4] Thayer、R。お​​よびK. Kaukonen、ストリーム暗号化暗号化アルゴリズム、作業中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSA] R. Rivest, A. Shamir, and L. M. Adleman, &#34;A Method for Obtaining Digital Signatures and Public-Key Cryptosystems,&#34; Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120- 126.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSA] R.リヴェスト、A。シャミール、およびL. M.アドルマン、「デジタル署名および公開鍵暗号システムを取得する方法」、ACMの通信、v。21、n。 1978年2月2日、120-126ページ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSADSI] Contact RSA Data Security, Inc., Tel: 415-595-8782
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSADSI]連絡先RSA Data Security、Inc.、電話：415-595-8782
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCH] B. Schneier. Applied Cryptography: Protocols, Algorithms, and Source Code in C, Published by John Wiley &amp; Sons, Inc. 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCH] B.シュナイアー。 Applied Cryptography：Protocols、Algorithms、and Source Code in C、Published by John Wiley＆Sons、Inc. 1994。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHA] NIST FIPS PUB 180-1, &#34;Secure Hash Standard,&#34; National Institute of Standards and Technology, U.S. Department of Commerce, Work in Progress, May 31, 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHA] NIST FIPS PUB 180-1、「Secure Hash Standard」、National Institute of Standards and Technology、米国商務省、Work in Progress、1994年5月31日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL2] Hickman, Kipp, &#34;The SSL Protocol&#34;, Netscape Communications Corp., Feb 9, 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL2] Hickman、Kipp、「The SSL Protocol」、Netscape Communications Corp.、1995年2月9日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL3] A. Frier, P. Karlton, and P. Kocher, &#34;The SSL 3.0 Protocol&#34;, Netscape Communications Corp., Nov 18, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL3] A. Frier、P。Karlton、およびP. Kocher、「The SSL 3.0 Protocol」、Netscape Communications Corp.、1996年11月18日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP] Postel, J., &#34;Transmission Control Protocol,&#34; STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP] Postel、J。、「Transmission Control Protocol」、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TEL] Postel J., and J. Reynolds, &#34;Telnet Protocol Specifications&#34;, STD 8, RFC 854, May 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TEL] Postel J.、およびJ. Reynolds、「Telnet Protocol Specifications」、STD 8、RFC 854、1993年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TEL] Postel J., and J. Reynolds, &#34;Telnet Option Specifications&#34;, STD 8, RFC 855, May 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TEL] Postel J.、およびJ. Reynolds、「Telnet Option Specifications」、STD 8、RFC 855、1993年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X509] CCITT. Recommendation X.509: &#34;The Directory - Authentication Framework&#34;. 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X509] CCITT。推奨事項X.509：「ディレクトリ-認証フレームワーク」。 1988。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XDR] R. Srinivansan, Sun Microsystems, RFC-1832: XDR: External Data Representation Standard, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XDR] R. Srinivansan、Sun Microsystems、RFC-1832：XDR：外部データ表現標準、1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Credits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クレジット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Win Treese Open Market
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
勝つTreeseオープンマーケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: treese@openmarket.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Editors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
編集者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christopher Allen Tim Dierks Certicom Certicom
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クリストファー・アレンティム・ディアクスサーティコムサーティコム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: callen@certicom.com         EMail: tdierks@certicom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tim Dierks Philip L. Karlton Certicom Netscape Communications
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ティムディアクスフィリップL.カールトンサーティコムネットスケープコミュニケーションズ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 EMail: tdierks@certicom.com Alan O. Freier Paul C. Kocher Netscape Communications Independent Consultant
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
メール：tdierks@certicom.com Alan O. Freier Paul C. Kocher Netscape Communications Independent Consultant
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: freier@netscape.com         EMail: pck@netcom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その他の貢献者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Abadi Robert Relyea Digital Equipment Corporation Netscape Communications
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Abadi Robert Relyea Digital Equipment Corporation Netscape Communications
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: ma@pa.dec.com               EMail: relyea@netscape.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ran Canetti Jim Roskind IBM Watson Research Center Netscape Communications
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ran Canetti Jim Roskind IBM Watson Research Center Netscape Communications
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: canetti@watson.ibm.com      EMail: jar@netscape.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taher Elgamal Micheal J. Sabin, Ph. D. Securify Consulting Engineer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taher Elgamal Micheal J. Sabin、Ph。D. Securifyコンサルティングエンジニア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: elgamal@securify.com        EMail: msabin@netcom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anil R. Gangolli Dan Simon Structured Arts Computing Corp. Microsoft
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アニルr。 Gangolli Dan Simon Stretched Arts Computing Corp.マイクロソフト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: gangolli@structuredarts.com EMail:  dansimon@microsoft.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kipp E.B. Hickman Tom Weinstein Netscape Communications Netscape Communications
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キップE.B. Hickman Tom Weinstein Netscape Communications Netscape Communications
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: kipp@netscape.com           EMail: tomw@netscape.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hugo Krawczyk IBM Watson Research Center
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hugo Krawczyk IBM Watson Research Center
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: hugo@watson.ibm.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Comments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
コメント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The discussion list for the IETF TLS working group is located at the e-mail address &lt;ietf-tls@lists.consensus.com&gt;. Information on the group and information on how to subscribe to the list is at &lt;http://lists.consensus.com/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF TLSワーキンググループのディスカッションリストは、電子メールアドレス&lt;ietf-tls@lists.consensus.com&gt;にあります。グループに関する情報とリストの購読方法に関する情報は、&lt;http://lists.consensus.com/&gt;にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Archives of the list can be found at:
       &lt;http://www.imc.org/ietf-tls/mail-archive/&gt;
Full Copyright Statement
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（1999）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとその翻訳はコピーして他のユーザーに提供することができ、コメントまたはその他の方法で説明したり、その実装を支援する二次的著作物は、いかなる種類の制限なしに、全体または一部を準備、コピー、公開、および配布することができます。ただし、上記の著作権表示とこの段落は、そのようなすべてのコピーと派生物に含まれています。ただし、この文書自体は、著作権に関する通知を削除したり、インターネットソサエティや他のインターネット組織への参照を削除したりするなど、いかなる方法でも変更できません。ただし、インターネット標準を開発する目的で必要な場合は除きます。インターネット標準のプロセスに従うか、または必要に応じて、それを英語以外の言語に翻訳する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに記載されている情報の使用が保証するものに限定されない一切の保証を含みません。商品性または特定の目的への適合性に関する権利または黙示の保証を侵害すること。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
