<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 2435 - RTP Payload Format for JPEG-compressed Video 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2435</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc2435">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 2435 - RTP Payload Format for JPEG-compressed Video 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc2435">
            https://datatracker.ietf.org/doc/html/rfc2435
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 2435 - JPEG圧縮ビデオのRTPペイロード形式</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                            L. Berc
Request for Comments: 2435                 Digital Equipment Corporation
Obsoletes: 2035                                                W. Fenner
Category: Standards Track                                     Xerox PARC
                                                            R. Frederick
                                                              Xerox PARC
                                                              S. McCanne
                                            Lawrence Berkeley Laboratory
                                                              P. Stewart
                                                              Xerox PARC
                                                            October 1998
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
RTP Payload Format for JPEG-compressed Video
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
JPEG圧縮ビデオのRTPペイロード形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（1998）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes the RTP payload format for JPEG video streams. The packet format is optimized for real-time video streams where codec parameters change rarely from frame to frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、JPEGビデオストリームのRTPペイロード形式について説明しています。パケット形式は、コーデックパラメータがフレーム間でめったに変化しないリアルタイムビデオストリーム用に最適化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Audio-Video Transport working group within the Internet Engineering Task Force. Comments are solicited and should be addressed to the working group&#39;s mailing list at rem-conf@es.net and/or the author(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、Internet Engineering Task Force内のAudio-Video Transportワーキンググループの製品です。コメントは要請されており、作業グループのrem-conf@es.netまたは著者、あるいはその両方のメーリングリストに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Changes from RFC 2035
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
RFC 2035からの変更点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of this memo is identical to RFC 2035. The changes made to the protocol are summarized in Appendix D.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモのほとんどはRFC 2035と同じです。プロトコルに加えられた変更は、付録Dに要約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Key Words
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
キーワード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [9]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Joint Photographic Experts Group (JPEG) standard [1,2,3] defines a family of compression algorithms for continuous-tone, still images. This still image compression standard can be applied to video by compressing each frame of video as an independent still image and transmitting them in series. Video coded in this fashion is often called Motion-JPEG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joint Photographic Experts Group（JPEG）標準[1,2,3]は、連続階調の静止画像用の圧縮アルゴリズムのファミリーを定義しています。この静止画像圧縮規格は、ビデオの各フレームを独立した静止画像として圧縮し、それらを直列に送信することにより、ビデオに適用できます。この方法でコーディングされたビデオは、多くの場合Motion-JPEGと呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We first give an overview of JPEG and then describe the specific subset of JPEG that is supported in RTP and the mechanism by which JPEG frames are carried as RTP payloads.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初にJPEGの概要を示し、次にRTPでサポートされているJPEGの特定のサブセットと、JPEGフレームがRTPペイロードとして伝送されるメカニズムについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The JPEG standard defines four modes of operation: the sequential DCT mode, the progressive DCT mode, the lossless mode, and the hierarchical mode. Depending on the mode, the image is represented in one or more passes. Each pass (called a frame in the JPEG standard) is further broken down into one or more scans. Within each scan, there are one to four components, which represent the three components of a color signal (e.g., &#34;red, green, and blue&#34;, or a luminance signal and two chrominance signals). These components can be encoded as separate scans or interleaved into a single scan.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEG規格は、順次DCTモード、プログレッシブDCTモード、ロスレスモード、および階層モードの4つの動作モードを定義しています。モードに応じて、画像は1つ以上のパスで表されます。各パス（JPEG規格ではフレームと呼ばれます）は、さらに1つ以上のスキャンに分割されます。各スキャン内には、1〜4つのコンポーネントがあり、カラー信号の3つのコンポーネント（「赤、緑、青」、または輝度信号と2つのクロミナンス信号など）を表します。これらのコンポーネントは、個別のスキャンとしてエンコードすることも、1つのスキャンにインターリーブすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each frame and scan is preceded with a header containing optional definitions for compression parameters like quantization tables and Huffman coding tables. The headers and optional parameters are identified with &#34;markers&#34; and comprise a marker segment; each scan appears as an entropy-coded bit stream within two marker segments. Markers are aligned to byte boundaries and (in general) cannot appear in the entropy-coded segment, allowing scan boundaries to be determined without parsing the bit stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フレームとスキャンの前には、量子化テーブルやハフマンコーディングテーブルなどの圧縮パラメーターのオプションの定義を含むヘッダーが付いています。ヘッダーとオプションのパラメーターは「マーカー」で識別され、マーカーセグメントを構成します。各スキャンは、2つのマーカーセグメント内のエントロピーコーディングされたビットストリームとして表示されます。マーカーはバイト境界に揃えられており、（一般的に）エントロピーコーディングされたセグメントに出現できないため、ビットストリームを解析せずにスキャン境界を決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compressed data is represented in one of three formats: the interchange format, the abbreviated format, or the table-specification format. The interchange format contains definitions for all the tables used by the entropy-coded segments, while the abbreviated format might omit some assuming they were defined out-of-band or by a &#34;previous&#34; image.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮データは、交換形式、省略形式、またはテーブル仕様形式の3つの形式のいずれかで表されます。交換フォーマットには、エントロピーコーディングされたセグメントで使用されるすべてのテーブルの定義が含まれていますが、省略フォーマットでは、それらが帯域外または「以前の」イメージによって定義されたと想定して一部省略されている場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The JPEG standard does not define the meaning or format of the components that comprise the image. Attributes like the color space and pixel aspect ratio must be specified out-of-band with respect to the JPEG bit stream. The JPEG File Interchange Format (JFIF) [4] is a de-facto standard that provides this extra information using an application marker segment (APP0). Note that a JFIF file is simply a JPEG interchange format image along with the APP0 segment. In the case of video, additional parameters must be defined out-of-band (e.g., frame rate, interlaced vs. non-interlaced, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
JPEG規格は、イメージを構成するコンポーネントの意味や形式を定義していません。色空間やピクセル縦横比などの属性は、JPEGビットストリームに対して帯域外で指定する必要があります。 JPEGファイル交換フォーマット（JFIF）[4]は、アプリケーションマーカーセグメント（APP0）を使用してこの追加情報を提供する事実上の標準です。 JFIFファイルは、APP0セグメントとともに単純にJPEG交換フォーマットのイメージであることに注意してください。ビデオの場合、追加のパラメーターを帯域外で定義する必要があります（フレームレート、インターレース対非インターレースなど）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the JPEG standard provides a rich set of algorithms for flexible compression, cost-effective hardware implementations of the full standard have not appeared. Instead, most hardware JPEG video codecs implement only a subset of the sequential DCT mode of operation. Typically, marker segments are interpreted in software (which &#34;re-programs&#34; the hardware) and the hardware is presented with a single, interleaved entropy-coded scan represented in the YUV color space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEG規格は柔軟な圧縮のための豊富なアルゴリズムのセットを提供しますが、完全な規格の費用効果の高いハードウェア実装は登場していません。代わりに、ほとんどのハードウェアJPEGビデオコーデックは、シーケンシャルDCTモードの動作のサブセットのみを実装しています。通常、マーカーセグメントはソフトウェアで解釈され（ハードウェアを「再プログラム」）、ハードウェアには、YUV色空間で表される1つのインターリーブエントロピー符号化スキャンが提示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scan contains an ordered sequence of Minimum Coded Units, or MCUs, which are the smallest group of image data coded in a JPEG bit stream. Each MCU defines the image data for a small rectangular block of the output image.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スキャンには、JPEGビットストリームでコード化された画像データの最小グループである、最小コード化ユニット（MCU）の順序付けされたシーケンスが含まれています。各MCUは、出力画像の小さな長方形ブロックの画像データを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restart markers in the JPEG data denote a point where the decoder should reset its state. As defined by JPEG, restart markers are the only type of marker that may appear embedded in the entropy-coded segment, and they may only appear on an MCU boundary. A &#34;restart interval&#34; is defined to be a block of data containing a restart marker followed by some fixed number of MCUs. An exception is made for the first restart interval in each frame, which omits the initial restart marker and just begins with the MCU data. When these markers are used, each frame is composed of some fixed number of back-to-back restart intervals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEGデータのリスタートマーカーは、デコーダーがその状態をリセットする必要があるポイントを示します。 JPEGで定義されているように、リスタートマーカーは、エントロピーコード化セグメントに埋め込まれて表示される唯一のマーカータイプであり、MCU境界にのみ表示される場合があります。 「再起動間隔」は、再起動マーカーとそれに続くいくつかの固定数のMCUを含むデータのブロックとして定義されます。各フレームの最初の再起動間隔には例外があり、初期の再起動マーカーが省略され、MCUデータで開始されます。これらのマーカーが使用される場合、各フレームは、一定数の連続した再起動間隔で構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. JPEG Over RTP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. RTP上のJPEG
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To maximize interoperability among hardware-based codecs, we assume the sequential DCT operating mode [1,Annex F] and restrict the set of predefined RTP/JPEG &#34;type codes&#34; (defined below) to single-scan, interleaved images. While this is more restrictive than even baseline JPEG, many hardware implementation fall short of the baseline specification (e.g., most hardware cannot decode non-interleaved scans).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハードウェアベースのコーデック間の相互運用性を最大化するために、シーケンシャルDCT動作モード[1、Annex F]を想定し、事前定義されたRTP / JPEG「タイプコード」（以下で定義）のセットをシングルスキャンのインターリーブ画像に制限します。これはベースラインJPEGよりも制限的ですが、多くのハードウェア実装はベースライン仕様に達していません（たとえば、ほとんどのハードウェアは非インターリーブスキャンをデコードできません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In practice, most of the table-specification data rarely changes from frame to frame within a single video stream. Therefore RTP/JPEG data is represented in abbreviated format, with all of the tables omitted from the bit stream where possible. Each frame begins immediately with the (single) entropy-coded scan. The information that would otherwise be in both the frame and scan headers is represented entirely within the RTP/JPEG header (defined below) that lies between the RTP header and the JPEG payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
実際には、ほとんどのテーブル仕様データは、単一のビデオストリーム内でフレームごとに変更されることはほとんどありません。したがって、RTP / JPEGデータは省略された形式で表され、可能な場合はすべてのテーブルがビットストリームから省略されます。各フレームは、（単一の）エントロピー符号化スキャンですぐに始まります。それ以外の場合はフレームヘッダーとスキャンヘッダーの両方に含まれる情報は、RTPヘッダーとJPEGペイロードの間にあるRTP / JPEGヘッダー（以下で定義）内に完全に表現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While parameters like Huffman tables and color space are likely to remain fixed for the lifetime of the video stream, other parameters should be allowed to vary, notably the quantization tables and image size (e.g., to implement rate-adaptive transmission or allow a user to adjust the &#34;quality level&#34; or resolution manually). Thus explicit fields in the RTP/JPEG header are allocated to represent this information. Since only a small set of quantization tables are typically used, we encode the entire set of quantization tables in a small integer field. Customized quantization tables are accommodated by using a special range of values in this field, and then placing the table before the beginning of the JPEG payload. The image width and height are encoded explicitly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハフマンテーブルや色空間などのパラメータは、ビデオストリームの存続期間中は固定されたままになる可能性が高いですが、他のパラメータ、特に量子化テーブルや画像サイズを変更できるようにする必要があります（たとえば、レート適応送信を実装したり、ユーザーが「品質レベル」または解像度を手動で調整します）。したがって、RTP / JPEGヘッダーの明示的なフィールドは、この情報を表すために割り当てられます。量子化テーブルの小さなセットのみが通常使用されるため、量子化テーブルのセット全体を小さな整数フィールドにエンコードします。カスタマイズされた量子化テーブルは、このフィールドで特別な範囲の値を使用し、JPEGペイロードの先頭の前にテーブルを配置することで対応できます。画像の幅と高さは明示的にエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because JPEG frames are typically larger than the underlying network&#39;s maximum packet size, frames must often be fragmented into several packets. One approach is to allow the network layer below RTP (e.g., IP) to perform the fragmentation. However, this precludes rate-controlling the resulting packet stream or partial delivery in the presence of loss, and frames may be larger than the maximum network layer reassembly length (see [10] for more information). To avoid these limitations, RTP/JPEG defines a simple fragmentation and reassembly scheme at the RTP level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEGフレームは通常、基盤となるネットワークの最大パケットサイズよりも大きいため、フレームは多くの場合、いくつかのパケットにフラグメント化する必要があります。 1つのアプローチは、RTP（IPなど）の下のネットワーク層が断片化を実行できるようにすることです。ただし、これにより、損失が発生した場合に結果として生じるパケットストリームまたは部分配信をレート制御することができなくなり、フレームはネットワーク層の最大再構成長よりも長くなる場合があります（詳細は[10]を参照）。これらの制限を回避するために、RTP / JPEGは、RTPレベルで単純なフラグメンテーションおよび再構成スキームを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RTP/JPEG Packet Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RTP / JPEGパケット形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP timestamp is in units of 90000Hz. The same timestamp MUST appear in each fragment of a given frame. The RTP marker bit MUST be set in the last packet of a frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPタイムスタンプは90000Hzの単位です。同じタイムスタンプは、特定のフレームの各フラグメントに出現する必要があります。 RTPマーカービットは、フレームの最後のパケットで設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. JPEG header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. JPEGヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each packet contains a special JPEG header which immediately follows the RTP header. The first 8 bytes of this header, called the &#34;main JPEG header&#34;, are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各パケットには、RTPヘッダーの直後に続く特別なJPEGヘッダーが含まれています。 「メインJPEGヘッダー」と呼ばれるこのヘッダーの最初の8バイトは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Type-specific |              Fragment Offset                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Type     |       Q       |     Width     |     Height    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   All fields in this header except for the Fragment Offset field MUST
   remain the same in all packets that correspond to the same JPEG
   frame.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Restart Marker header and/or Quantization Table header may follow this header, depending on the values of the Type and Q fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TypeおよびQフィールドの値に応じて、Restart Markerヘッダーまたは量子化テーブルヘッダー、あるいはその両方がこのヘッダーの後に続く場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Type-specific: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. タイプ固有：8ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interpretation depends on the value of the type field. If no interpretation is specified, this field MUST be zeroed on transmission and ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解釈は、typeフィールドの値によって異なります。解釈が指定されていない場合、このフィールドは送信時にゼロにし、受信時に無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. Fragment Offset: 24 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. フラグメントオフセット：24ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Fragment Offset is the offset in bytes of the current packet in the JPEG frame data. This value is encoded in network byte order (most significant byte first). The Fragment Offset plus the length of the payload data in the packet MUST NOT exceed 2^24 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントオフセットは、JPEGフレームデータ内の現在のパケットのバイト単位のオフセットです。この値は、ネットワークバイトオーダーでエンコードされます（最上位バイトが最初）。フラグメントオフセットとパケット内のペイロードデータの長さの合計が2 ^ 24バイトを超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. Type: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. タイプ：8ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type field specifies the information that would otherwise be present in a JPEG abbreviated table-specification as well as the additional JFIF-style parameters not defined by JPEG. Types 0-63 are reserved as fixed, well-known mappings to be defined by this document and future revisions of this document. Types 64-127 are the same as types 0-63, except that restart markers are present in the JPEG data and a Restart Marker header appears immediately following the main JPEG header. Types 128-255 are free to be dynamically defined by a session setup protocol (which is beyond the scope of this document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typeフィールドは、JPEGの省略形のテーブル仕様に存在する情報と、JPEGで定義されていない追加のJFIFスタイルのパラメーターを指定します。タイプ0〜63は、このドキュメントおよびこのドキュメントの将来の改訂で定義される既知の固定マッピングとして予約されています。タイプ64〜127は、タイプ0〜63と同じですが、リスタートマーカーがJPEGデータに存在し、リスタートマーカーヘッダーがメインJPEGヘッダーの直後に表示される点が異なります。タイプ128〜255は、セッションセットアッププロトコルによって動的に定義できます（これは、このドキュメントの範囲外です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.4. Q: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.4. Q：8ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Q field defines the quantization tables for this frame. Q values 0-127 indicate the quantization tables are computed using an algorithm determined by the Type field (see below). Q values 128-255 indicate that a Quantization Table header appears after the main JPEG header (and the Restart Marker header, if present) in the first packet of the frame (fragment offset 0). This header can be used to explicitly specify the quantization tables in-band.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Qフィールドは、このフレームの量子化テーブルを定義します。 Q値0〜127は、量子化テーブルがTypeフィールドによって決定されるアルゴリズムを使用して計算されることを示します（以下を参照）。 Q値128〜255は、フレームの最初のパケット（フラグメントオフセット0）のメインJPEGヘッダー（および存在する場合はリスタートマーカーヘッダー）の後に量子化テーブルヘッダーが表示されることを示します。このヘッダーを使用して、帯域内の量子化テーブルを明示的に指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.5. Width: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.5. 幅：8ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This field encodes the width of the image in 8-pixel multiples (e.g., a width of 40 denotes an image 320 pixels wide). The maximum width is 2040 pixels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このフィールドは、画像の幅を8ピクセルの倍数でエンコードします（たとえば、40の幅は320ピクセル幅の画像を示します）。最大幅は2040ピクセルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.6. Height: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.6. 高さ：8ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This field encodes the height of the image in 8-pixel multiples (e.g., a height of 30 denotes an image 240 pixels tall). When encoding interlaced video, this is the height of a video field, since fields are individually JPEG encoded. The maximum height is 2040 pixels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このフィールドは、画像の高さを8ピクセルの倍数でエンコードします（たとえば、高さ30は画像の高さが240ピクセルであることを示します）。インターレースビデオをエンコードする場合、フィールドは個別にJPEGエンコードされるため、これはビデオフィールドの高さです。最大の高さは2040ピクセルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.7. Restart Marker header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.7. マーカーヘッダーを再起動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header MUST be present immediately after the main JPEG header when using types 64-127. It provides the additional information required to properly decode a data stream containing restart markers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ64〜127を使用する場合、このヘッダーはメインJPEGヘッダーの直後に存在する必要があります。リスタートマーカーを含むデータストリームを正しくデコードするために必要な追加情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Restart Interval        |F|L|       Restart Count       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Restart Interval field specifies the number of MCUs that appear between restart markers. It is identical to the 16 bit value that would appear in the DRI marker segment of a JFIF header. This value MUST NOT be zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Restart Interval]フィールドは、再起動マーカーの間に表示されるMCUの数を指定します。これは、JFIFヘッダーのDRIマーカーセグメントに表示される16ビット値と同じです。この値はゼロであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the restart intervals in a frame are not guaranteed to be aligned with packet boundaries, the F (first) and L (last) bits MUST be set to 1 and the Restart Count MUST be set to 0x3FFF. This indicates that a receiver MUST reassemble the entire frame before decoding it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーム内の再起動間隔がパケット境界に揃えられることが保証されていない場合、F（最初）およびL（最後）ビットを1に設定し、再起動カウントを0x3FFFに設定する必要があります。これは、受信側がフレーム全体を再構成してからデコードする必要があることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support partial frame decoding, the frame is broken into &#34;chunks&#34; each containing an integral number of restart intervals. The Restart Count field contains the position of the first restart interval in the current &#34;chunk&#34; so that receivers know which part of the frame this data corresponds to. A Restart Interval value SHOULD be chosen to allow a &#34;chunk&#34; to completely fit within a single packet. In this case, both the F and L bits of the packet are set to 1. However, if a chunk needs to be spread across multiple packets, the F bit will be set to 1 in the first packet of the chunk (and only that one) and the L bit will be set to 1 in the last packet of the chunk (and only that one).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部分的なフレームのデコードをサポートするために、フレームは「チャンク」に分割され、それぞれに整数の再起動間隔が含まれています。 [Restart Count]フィールドには、現在の「チャンク」内の最初の再起動間隔の位置が含まれているため、受信者は、このデータがフレームのどの部分に対応するかを認識できます。 「チャンク」が1つのパケット内に完全に収まるように、再起動間隔の値を選択する必要があります（SHOULD）。この場合、パケットのFビットとLビットの両方が1に設定されます。ただし、チャンクを複数のパケットに分散させる必要がある場合、チャンクの最初のパケットでFビットが1に設定されます（そして1）そして、チャンクの最後のパケットでLビットが1に設定されます（その1つだけ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.8. Quantization Table header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.8. 量子化テーブルのヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header MUST be present after the main JPEG header (and after the Restart Marker header, if present) when using Q values 128-255. It provides a way to specify the quantization tables associated with this Q value in-band.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダーは、Q値128〜255を使用する場合、メインのJPEGヘッダーの後に（存在する場合は、リスタートマーカーヘッダーの後に）存在する必要があります。このQ値に関連する量子化テーブルを帯域内で指定する方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      MBZ      |   Precision   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Quantization Table Data                    |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length field is set to the length in bytes of the quantization table data to follow. The Length field MAY be set to zero to indicate that no quantization table data is included in this frame. See section 4.2 for more information. If the Length field in a received packet is larger than the remaining number of bytes, the packet MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さフィールドは、後に続く量子化テーブルデータの長さ（バイト単位）に設定されます。長さフィールドは、このフレームに量子化テーブルデータが含まれていないことを示すためにゼロに設定される場合があります。詳細については、セクション4.2を参照してください。受信したパケットの長さフィールドが残りのバイト数より大きい場合、パケットは破棄されなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When table data is included, the number of tables present depends on the JPEG type field. For example, type 0 uses two tables (one for the luminance component and one shared by the chrominance components). Each table is an array of 64 values given in zig-zag order, identical to the format used in a JFIF DQT marker segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テーブルデータが含まれている場合、存在するテーブルの数はJPEGタイプフィールドによって異なります。たとえば、タイプ0は2つのテーブルを使用します（1つは輝度コンポーネント用、もう1つはクロミナンスコンポーネント用）。各テーブルは、ジグザグの順序で指定された64個の値の配列であり、JFIF DQTマーカーセグメントで使用される形式と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each quantization table present, a bit in the Precision field specifies the size of the coefficients in that table. If the bit is zero, the coefficients are 8 bits yielding a table length of 64 bytes. If the bit is one, the coefficients are 16 bits for a table length of 128 bytes. For 16 bit tables, the coefficients are presented in network byte order. The rightmost bit in the Precision field (bit 15 in the diagram above) corresponds to the first table and each additional table uses the next bit to the left. Bits beyond those corresponding to the tables needed by the type in use MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在する量子化テーブルごとに、Precisionフィールドのビットは、そのテーブルの係数のサイズを指定します。ビットがゼロの場合、係数は8ビットであり、64バイトのテーブル長になります。ビットが1の場合、128バイトのテーブル長の係数は16ビットです。 16ビットテーブルの場合、係数はネットワークバイトオーダーで表示されます。精度フィールドの右端のビット（上の図のビット15）は最初のテーブルに対応し、追加の各テーブルは左側の次のビットを使用します。使用中の型が必要とするテーブルに対応するビットを超えるビットは、無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Q values from 128 to 254, the Q value to quantization table data mapping MUST be static, i.e., the receivers are guaranteed that they only need to read the table data once in order to correctly decode frames sent with that Q value. A Q value of 255 denotes that the quantization table mapping is dynamic and can change on every frame. Decoders MUST NOT depend on any previous version of the tables, and need to reload these tables on every frame. Packets MUST NOT contain Q = 255 and Length = 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
128から254までのQ値の場合、Q値から量子化テーブルデータへのマッピングは静的である必要があります。つまり、受信者は、そのQ値で送信されたフレームを正しくデコードするために、テーブルデータを一度だけ読み取る必要があることが保証されます。 255のQ値は、量子化テーブルのマッピングが動的であり、フレームごとに変更できることを示します。デコーダーは以前のバージョンのテーブルに依存してはならず（MUST）、すべてのフレームでこれらのテーブルをリロードする必要があります。パケットには、Q = 255および長さ= 0を含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.9. JPEG Payload
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.9. JPEGペイロード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The data following the RTP/JPEG headers is an entropy-coded segment consisting of a single scan. The scan header is not present and is inferred from the RTP/JPEG header. The scan is terminated either implicitly (i.e., the point at which the image is fully parsed), or explicitly with an EOI marker. The scan may be padded to arbitrary length with undefined bytes. (Some existing hardware codecs generate extra lines at the bottom of a video frame and removal of these lines would require a Huffman-decoding pass over the data.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
RTP / JPEGヘッダーに続くデータは、1回のスキャンで構成されるエントロピーコーディングされたセグメントです。スキャンヘッダーは存在せず、RTP / JPEGヘッダーから推測されます。スキャンは、暗黙的に（つまり、画像が完全に解析されるポイントで）、またはEOIマーカーで明示的に終了されます。スキャンは、未定義のバイトで任意の長さに埋め込まれることがあります。 （一部の既存のハードウェアコーデックは、ビデオフレームの下部に余分なラインを生成し、これらのラインを削除するには、データのハフマンデコードパスが必要になります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type code determines whether restart markers are present. If a type supports restart markers, the packet MUST contain a non-zero Restart Interval value in a Restart Marker Header and restart markers MUST appear on byte aligned boundaries beginning with an 0xFF between MCUs at that interval. Additional 0xFF bytes MAY appear between restart intervals. This can be used in the packetization process to align data to something like a word boundary for more efficient copying. Restart markers MUST NOT appear anywhere else in the JPEG payload. Types which do not support restart makers MUST NOT contain restart markers anywhere in the JPEG payload. All packets MUST contain a &#34;stuffed&#34; 0x00 byte following any true 0xFF byte generated by the entropy coder [1, Sec. B.1.1.5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプコードは、リスタートマーカーが存在するかどうかを決定します。タイプがリスタートマーカーをサポートしている場合、パケットはリスタートマーカーヘッダーにゼロ以外のリスタートインターバル値を含まなければならず（MUST）、リスタートマーカーはそのインターバルのMCU間の0xFFで始まるバイトアライン境界に表示される必要があります。追加の0xFFバイトが再起動間隔の間に表示される場合があります。これをパケット化プロセスで使用して、データをワード境界のようなものに整列させ、より効率的にコピーできます。リスタートマーカーは、JPEGペイロードの他の場所に表示してはなりません。リスタートメーカーをサポートしないタイプは、JPEGペイロードのどこにもリスタートマーカーを含んではいけません。すべてのパケットには、エントロピーコーダーによって生成された真の0xFFバイトに続く「詰められた」0x00バイトが含まれている必要があります[1、Sec。 B.1.1.5]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 討論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. The Type Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. タイプフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type field defines the abbreviated table-specification and additional JFIF-style parameters not defined by JPEG, since they are not present in the body of the transmitted JPEG data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typeフィールドは、送信されたJPEGデータの本文に存在しないため、省略されたテーブル仕様と、JPEGで定義されていない追加のJFIFスタイルパラメータを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three ranges of the type field are currently defined. Types 0-63 are reserved as fixed, well-known mappings to be defined by this document and future revisions of this document. Types 64-127 are the same as types 0-63, except that restart markers are present in the JPEG data and a Restart Marker header appears immediately following the main JPEG header. Types 128-255 are free to be dynamically defined by a session setup protocol (which is beyond the scope of this document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプフィールドの3つの範囲が現在定義されています。タイプ0〜63は、このドキュメントおよびこのドキュメントの将来の改訂で定義される既知の固定マッピングとして予約されています。タイプ64〜127は、タイプ0〜63と同じですが、リスタートマーカーがJPEGデータに存在し、リスタートマーカーヘッダーがメインJPEGヘッダーの直後に表示される点が異なります。タイプ128〜255は、セッションセットアッププロトコルによって動的に定義できます（これは、このドキュメントの範囲外です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of the first group of fixed mappings, types 0 and 1 are currently defined, along with the corresponding types 64 and 65 that indicate the presence of restart markers. They correspond to an abbreviated table-specification indicating the &#34;Baseline DCT sequential&#34; mode, 8-bit samples, square pixels, three components in the YUV color space, standard Huffman tables as defined in [1, Annex K.3], and a single interleaved scan with a scan component selector indicating components 1, 2, and 3 in that order. The Y, U, and V color planes correspond to component numbers 1, 2, and 3, respectively. Component 1 (i.e., the luminance plane) uses Huffman table number 0 and quantization table number 0 (defined below) and components 2 and 3 (i.e., the chrominance planes) use Huffman table number 1 and quantization table number 1 (defined below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
固定マッピングの最初のグループのうち、タイプ0と1が現在定義されており、対応するタイプ64と65は、リスタートマーカーの存在を示しています。これらは、「ベースラインDCTシーケンシャル」モード、8ビットサンプル、正方形ピクセル、YUV色空間の3つのコンポーネント、[1、Annex K.3]で定義されている標準ハフマンテーブル、およびaコンポーネント1、2、3をこの順序で示すスキャンコンポーネントセレクターを備えた単一のインターリーブスキャン。 Y、U、およびVカラープレーンは、それぞれコンポーネント番号1、2、および3に対応します。コンポーネント1（つまり、輝度プレーン）はハフマンテーブル番号0と量子化テーブル番号0（下で定義）を使用し、コンポーネント2と3（つまり、クロミナンスプレーン）はハフマンテーブル番号1と量子化テーブル番号1（下で定義）を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type numbers 2-5 are reserved and SHOULD NOT be used. Applications based on previous versions of this document (RFC 2035) should be updated to indicate the presence of restart markers with type 64 or 65 and the Restart Marker header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ番号2〜5は予約されており、使用しないでください。このドキュメントの以前のバージョン（RFC 2035）に基づくアプリケーションは、タイプ64または65のリスタートマーカーとリスタートマーカーヘッダーの存在を示すように更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two RTP/JPEG types currently defined are described below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在定義されている2つのRTP / JPEGタイプについて以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            horizontal   vertical   Quantization
           types  component samp. fact. samp. fact. table number
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |       |  1 (Y)  |     2     |     1     |     0     |
         | 0, 64 |  2 (U)  |     1     |     1     |     1     |
         |       |  3 (V)  |     1     |     1     |     1     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |       |  1 (Y)  |     2     |     2     |     0     |
         | 1, 65 |  2 (U)  |     1     |     1     |     1     |
         |       |  3 (V)  |     1     |     1     |     1     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These sampling factors indicate that the chrominance components of type 0 video is downsampled horizontally by 2 (often called 4:2:2) while the chrominance components of type 1 video are downsampled both horizontally and vertically by 2 (often called 4:2:0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのサンプリングファクターは、タイプ0のビデオのクロミナンスコンポーネントが水平方向に2でダウンサンプリングされる（多くの場合4：2：2）、タイプ1のビデオのクロミナンスコンポーネントが水平方向と垂直方向の両方でダウンサンプリングされる（多くの場合4：2：0） ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Types 0 and 1 can be used to carry both progressively scanned and interlaced image data. This is encoded using the Type-specific field in the main JPEG header. The following values are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ0と1は、プログレッシブスキャンとインターレースの両方の画像データを運ぶために使用できます。これは、メインJPEGヘッダーのタイプ固有のフィールドを使用してエンコードされます。以下の値が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0 : Image is progressively scanned. On a computer monitor, it can be displayed as-is at the specified width and height.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0：画像は順次スキャンされます。コンピュータのモニターでは、指定された幅と高さでそのまま表示できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1 : Image is an odd field of an interlaced video signal. The height specified in the main JPEG header is half of the height of the entire displayed image. This field should be de-interlaced with the even field following it such that lines from each of the images alternate. Corresponding lines from the even field should appear just above those same lines from the odd field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1：画像は、インターレースビデオ信号の奇数フィールドです。メインJPEGヘッダーで指定された高さは、表示された画像全体の高さの半分です。このフィールドは、各画像からのラインが交互になるように、それに続く偶数フィールドとインターレース解除する必要があります。偶数フィールドの対応するラインは、奇数フィールドの同じラインのすぐ上に表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2 : Image is an even field of an interlaced video signal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2：画像は、インターレースビデオ信号の偶数フィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3 : Image is a single field from an interlaced video signal, but it should be displayed full frame as if it were received as both the odd &amp; even fields of the frame. On a computer monitor, each line in the image should be displayed twice, doubling the height of the image.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3：画像はインターレースビデオ信号の単一フィールドですが、フレームの奇数フィールドと偶数フィールドの両方として受信されたかのように、フレーム全体を表示する必要があります。コンピューターのモニターでは、画像の各線が2回表示され、画像の高さが2倍になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix B contains C source code for transforming the RTP/JPEG header parameters into the JPEG frame and scan headers that are absent from the data payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Bには、RTP / JPEGヘッダーパラメータをJPEGフレームに変換するためのCソースコードと、データペイロードに存在しないスキャンヘッダーが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. The Q Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Qフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For JPEG types 0 and 1 (and their corresponding types 64 and 65), Q values between 1 and 99 inclusive are defined as follows. Other values less than 128 are reserved. Additional types are encouraged to use this definition if applicable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEGタイプ0および1（および対応するタイプ64および65）の場合、1から99までのQ値は次のように定義されます。 128未満の他の値は予約されています。該当する場合は、追加のタイプでこの定義を使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both type 0 and type 1 JPEG require two quantization tables. These tables are calculated as follows. For 1 &lt;= Q &lt;= 99, the Independent JPEG Group&#39;s formula [5] is used to produce a scale factor S as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ0とタイプ1の両方のJPEGには、2つの量子化テーブルが必要です。これらのテーブルは次のように計算されます。 1 &lt;= Q &lt;= 99の場合、独立JPEGグループの公式[5]を使用して、スケール係数Sを次のように生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           S = 5000 / Q          for  1 &lt;= Q &lt;= 50
             = 200 - 2 * Q       for 51 &lt;= Q &lt;= 99
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This value is then used to scale Tables K.1 and K.2 from [1] (saturating each value to 8 bits) to give quantization table numbers 0 and 1, respectively. C source code is provided in Appendix A to compute these tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この値を使用して、テーブルK.1およびK.2を[1]からスケーリングし（各値を8ビットに飽和）、量子化テーブル番号をそれぞれ0および1にします。付録Aには、これらのテーブルを計算するためのCソースコードが用意されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Q values 128-255, dynamically defined quantization tables are used. These tables may be specified either in-band or out of band by something like a session setup protocol, but the Quantization Table header MUST be present in the first packet of every frame. When the tables are specified out of band, they may be omitted from the packet by setting the Length field in this header to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Q値が128〜255の場合、動的に定義された量子化テーブルが使用されます。これらのテーブルは、セッションセットアッププロトコルなどによって帯域内または帯域外で指定できますが、量子化テーブルヘッダーは、すべてのフレームの最初のパケットに存在する必要があります。テーブルが帯域外で指定されている場合、このヘッダーのLengthフィールドを0に設定することにより、パケットから除外することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the quantization tables are sent in-band, they need not be sent with every frame. Like the out of band case, frames which do not contain tables will have a Quantization Table header with a Length field of 0. While this does decrease the overhead of including the tables, new receivers will be unable to properly decode frames from the time they start up until they receive the tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
量子化テーブルがインバンドで送信される場合、すべてのフレームで送信される必要はありません。帯域外の場合と同様に、テーブルを含まないフレームには、長さフィールドが0の量子化テーブルヘッダーがあります。これにより、テーブルを含めるオーバーヘッドが減少しますが、新しいレシーバーは、フレームを適切にデコードできなくなります。テーブルを受け取るまで起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Fragmentation and Reassembly
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 断片化と再構成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since JPEG frames can be large, they must often be fragmented. Frames SHOULD be fragmented into packets in a manner avoiding fragmentation at a lower level. If support for partial frame decoding is desired, frames SHOULD be fragmented such that each packet contains an integral number of restart intervals (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEGフレームは大きくなる可能性があるため、しばしばフラグメント化する必要があります。フレームは、下位レベルでの断片化を回避する方法でパケットに断片化する必要があります（SHOULD）。部分的なフレームデコードのサポートが必要な場合は、各パケットに再起動間隔の整数が含まれるようにフレームをフラグメント化する必要があります（以下を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Each packet that makes up a single frame MUST have the same timestamp, and the RTP marker bit MUST be set on the last packet in a frame. The fragment offset field of each packet is set to the byte offset of its payload data within the original frame. Packets making up a frame SHOULD be sent sequentially and the fragments they contain MUST NOT overlap one another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
1つのフレームを構成する各パケットには同じタイムスタンプが必要であり、RTPマーカービットはフレームの最後のパケットに設定する必要があります。各パケットのフラグメントオフセットフィールドは、元のフレーム内のペイロードデータのバイトオフセットに設定されます。フレームを構成するパケットは順次送信されるべきであり、それらに含まれるフラグメントは互いに重複してはいけません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An entire frame can be identified as a sequence of packets beginning with a packet having a zero fragment offset and ending with a packet having the RTP marker bit set. Missing packets can be detected either with RTP sequence numbers or with the fragment offset and lengths of each packet. Reassembly could be carried out without the offset field (i.e., using only the RTP marker bit and sequence numbers), but an efficient single-copy implementation would not otherwise be possible in the presence of misordered packets. Moreover, if the last packet of the previous frame (containing the marker bit) were dropped, then a receiver could not always detect that the current frame is entirely intact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーム全体は、フラグメントオフセットがゼロのパケットから始まり、RTPマーカービットが設定されたパケットで終わる一連のパケットとして識別できます。欠落したパケットは、RTPシーケンス番号、または各パケットのフラグメントオフセットと長さのいずれかで検出できます。オフセットフィールドなしで（つまり、RTPマーカービットとシーケンス番号のみを使用して）再構成を実行できますが、順序が正しくないパケットが存在する場合、効率的なシングルコピーの実装はできません。さらに、前のフレーム（マーカービットを含む）の最後のパケットがドロップされた場合、レシーバーは、現在のフレームが完全に無傷であることを常に検出できませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Restart Markers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. マーカーを再起動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restart markers indicate a point in the JPEG stream at which the Huffman decoder and DC predictors are reset, allowing partial decoding starting at that point. To fully take advantage of this, however, a decoder must know which MCUs of a frame a particular restart interval encodes. While the original JPEG specification does provide a small sequence number field in the restart markers for this purpose, it is not large enough to properly cope with the loss of an entire packet&#39;s worth of data at a typical network MTU size. The RTP/JPEG Restart Marker header contains the additional information needed to accomplish this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リスタートマーカーは、ハフマンデコーダーとDC予測子がリセットされるJPEGストリーム内のポイントを示し、そのポイントから部分的なデコードを開始できるようにします。ただし、これを十分に活用するには、デコーダーが特定の再起動間隔でエンコードするフレームのMCUを認識している必要があります。元のJPEG仕様では、この目的のために再起動マーカーに小さなシーケンス番号フィールドが提供されていますが、通常のネットワークMTUサイズでパケット全体のデータの損失に適切に対処するには十分な大きさではありません。 RTP / JPEGリスタートマーカーヘッダーには、これを実行するために必要な追加情報が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of restart intervals SHOULD be chosen to always allow an integral number of restart intervals to fit within a single packet. This will guarantee that packets can be decoded independently from one another. If a restart interval ends up being larger than a packet, the F and L bits in the Restart Marker header can be used to fragment it, but the resulting set of packets must all be received by a decoder for that restart interval to be decoded properly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再起動間隔のサイズは、常に整数の再起動間隔が1つのパケットに収まるように選択する必要があります（SHOULD）。これにより、パケットを互いに独立してデコードできることが保証されます。再起動間隔が最終的にパケットよりも大きくなる場合、再起動マーカーヘッダーのFビットとLビットを使用してパケットをフラグメント化できますが、その再起動間隔を正しくデコードするには、結果のパケットのセットをすべてデコーダーで受信する必要があります。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a decoder has received either a single packet with both the F and L bits set on or a contiguous sequence of packets (based on the RTP sequence number) which begin with an F bit and end with an L bit, it can begin decoding. The position of the MCU at the beginning of the data can be determined by multiplying the Restart Count value by the Restart Interval value. A packet (or group of packets as identified by the F and L bits) may contain any number of consecutive restart intervals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダは、FビットとLビットの両方がオンに設定された単一のパケット、またはFビットで始まりLビットで終わる一連のパケット（RTPシーケンス番号に基づく）を受信すると、デコードを開始できます。データの最初のMCUの位置は、Restart Count値にRestart Interval値を掛けることで決定できます。パケット（またはFおよびLビットで識別されるパケットのグループ）には、任意の数の連続した再起動間隔を含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To accommodate encoders which generate frames with restart markers in them but cannot fragment the data in this manner, the Restart Count field may be set to 0x3FFF with the F and L bits both set to 1. This indicates to decoders that the entire frame must be reassembled before decoding it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
フレーム内にリスタートマーカーが含まれているフレームを生成するが、この方法でデータをフラグメント化できないエンコーダーに対応するには、Restart Countフィールドを0x3FFFに設定し、FビットとLビットを1に設定します。これにより、フレーム全体がデコードする前に再構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP packets using the payload format defined in this specification are subject to the security considerations discussed in the RTP specification [6], and any appropriate RTP profile (for example [7]). This implies that confidentiality of the media streams is achieved by encryption. Because the data compression used with this payload format is applied end-to-end, encryption may be performed after compression so there is no conflict between the two operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様で定義されているペイロード形式を使用するRTPパケットは、RTP仕様[6]および適切なRTPプロファイル（[7]など）で説明されているセキュリティ上の考慮事項に従います。これは、メディアストリームの機密性が暗号化によって達成されることを意味します。このペイロード形式で使用されるデータ圧縮はエンドツーエンドで適用されるため、圧縮後に暗号化を実行して、2つの操作が競合しないようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A potential denial-of-service threat exists for data encodings using compression techniques that have non-uniform receiver-end computational load. The attacker can inject pathological datagrams into the stream which are complex to decode and cause the receiver to be overloaded. However, this encoding does not exhibit any significant non-uniformity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信側の計算負荷が均一でない圧縮技術を使用したデータエンコーディングには、潜在的なサービス拒否の脅威が存在します。攻撃者は、デコードが複雑な病理学的データグラムをストリームに挿入し、レシーバーに過負荷をかける可能性があります。ただし、このエンコーディングでは、大きな不均一性は発生しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another potential denial-of-service threat exists around the fragmentation mechanism presented here. Receivers should be prepared to limit the total amount of data associated with assembling received frames so as to avoid resource exhaustion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここに示されている断片化メカニズムの周りには、別の潜在的なサービス拒否の脅威が存在します。受信側は、リソースの枯渇を回避するために、受信したフレームの組み立てに関連するデータの総量を制限できるように準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with any IP-based protocol, in some circumstances a receiver may be overloaded simply by the receipt of too many packets, either desired or undesired. Network-layer authentication may be used to discard packets from undesired sources, but the processing cost of the authentication itself may be too high. In a multicast environment, pruning of specific sources will be implemented in a future version of IGMP [8] and in multicast routing protocols to allow a receiver to select which sources are allowed to reach it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のIPベースのプロトコルと同様に、状況によっては、受信側は、必要以上に多くのパケットを受信しただけで過負荷になる場合があります。ネットワーク層認証は、望ましくないソースからのパケットを破棄するために使用できますが、認証自体の処理コストが高すぎる可能性があります。マルチキャスト環境では、特定のソースのプルーニングがIGMP [8]の将来のバージョンで実装され、マルチキャストルーティングプロトコルでは、受信者がそれに到達できるソースを選択できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A security review of this payload format found no additional considerations beyond those in the RTP specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このペイロード形式のセキュリティレビューでは、RTP仕様以外の考慮事項は見つかりませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 著者のアドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lance M. Berc Systems Research Center Digital Equipment Corporation 130 Lytton Ave Palo Alto CA 94301
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lance M. Berc Systems Research Center Digital Equipment Corporation 130 Lytton Ave Palo Alto CA 94301
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 650 853 2100
   EMail: berc@pa.dec.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
William C. Fenner Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウィリアムC.フェナーゼロックスPARC 3333コヨーテヒルロードパロアルト、カリフォルニア94304
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 650 812 4816
   EMail: fenner@parc.xerox.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ron Frederick Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ron Frederick Xerox PARC 3333 Coyote Hill Road Palo Alto、CA 94304
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 650 812 4459
   EMail: frederick@parc.xerox.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Steven McCanne University of California at Berkeley Electrical Engineering and Computer Science 633 Soda Hall Berkeley, CA 94720
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Steven McCanneカリフォルニア大学バークレー校電気工学およびコンピュータサイエンス633 Soda Hallバークレー、カリフォルニア94720
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 510 642 0865
   EMail: mccanne@cs.berkeley.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Stewart Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Stewart Xerox PARC 3333 Coyote Hill Road Palo Alto、CA 94304
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 650 812 4821
   EMail: stewart@parc.xerox.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] ISO DIS 10918-1. Digital Compression and Coding of Continuous-tone Still Images (JPEG), CCITT Recommendation T.81.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] ISO DIS 10918-1。連続階調静止画像（JPEG）のデジタル圧縮とコーディング、CCITT勧告T.81。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] William B. Pennebaker, Joan L. Mitchell, JPEG: Still Image Data Compression Standard, Van Nostrand Reinhold, 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] ウィリアムB.ペネベーカー、ジョアンL.ミッチェル、JPEG：静止画像データ圧縮標準、ヴァンノストランドラインホールド、1993年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Gregory K. Wallace, The JPEG Sill Picture Compression Standard, Communications of the ACM, April 1991, Vol 34, No. 1, pp. 31-44.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Gregory K. Wallace、The JPEG Sill Picture Compression Standard、Communications of the ACM、1991年4月、Vol 34、No。1、31〜44ページ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] The JPEG File Interchange Format. Maintained by C-Cube Microsystems, Inc., and available in ftp://ftp.uu.net/graphics/jpeg/jfif.ps.gz.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] JPEGファイル交換形式。 C-Cube Microsystems、Inc.によって保守され、ftp：//ftp.uu.net/graphics/jpeg/jfif.ps.gzで入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Tom Lane et. al., The Independent JPEG Group software JPEG codec. Source code available in ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6a.tar.gz.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] トムレーン他その他、The Independent JPEG Group software JPEG codec。 ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6a.tar.gzにあるソースコード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, RFC 1889, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Schulzrinne、H.、Casner、S.、Frederick、R。およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、RFC 1889、1996年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Schulzrinne, H., &#34;RTP Profile for Audio and Video Conferences with Minimal Control&#34;, RFC 1890, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Schulzrinne、H。、「Minimal Controlを使用したオーディオおよびビデオ会議のRTPプロファイル」、RFC 1890、1996年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Fenner, W., &#34;Internet Group Management Protocol Version 2&#34;, RFC 2236, November 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Fenner、W。、「インターネットグループ管理プロトコルバージョン2」、RFC 2236、1997年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Bradner、S。、「RFCで使用して要件レベルを示すためのキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Kent C., and J. Mogul, &#34;Fragmentation Considered Harmful&#34;, Proceedings of the ACM SIGCOMM &#39;87 Workshop on Frontiers in Computer Communications Technology, August 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] ケントC.およびJ.モーグル、「フラグメンテーションは有害と見なされる」、ACM SIGCOMM &#39;87 Workshop of Frontiers in Computer Communications Technology、1987年8月の議事録。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following code can be used to create a quantization table from a Q factor:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のコードを使用して、Qファクターから量子化テーブルを作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Table K.1 from JPEG spec.
 */
static const int jpeg_luma_quantizer[64] = {
        16, 11, 10, 16, 24, 40, 51, 61,
        12, 12, 14, 19, 26, 58, 60, 55,
        14, 13, 16, 24, 40, 57, 69, 56,
        14, 17, 22, 29, 51, 87, 80, 62,
        18, 22, 37, 56, 68, 109, 103, 77,
        24, 35, 55, 64, 81, 104, 113, 92,
        49, 64, 78, 87, 103, 121, 120, 101,
        72, 92, 95, 98, 112, 100, 103, 99
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Table K.2 from JPEG spec.
 */
static const int jpeg_chroma_quantizer[64] = {
        17, 18, 24, 47, 99, 99, 99, 99,
        18, 21, 26, 66, 99, 99, 99, 99,
        24, 26, 56, 99, 99, 99, 99, 99,
        47, 66, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Call MakeTables with the Q factor and two u_char[64] return arrays
 */
void
MakeTables(int q, u_char *lqt, u_char *cqt)
{
  int i;
  int factor = q;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (q &lt; 1) factor = 1;
  if (q &gt; 99) factor = 99;
  if (q &lt; 50)
    q = 5000 / factor;
  else
    q = 200 - factor*2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (i=0; i &lt; 64; i++) {
    int lq = (jpeg_luma_quantizer[i] * q + 50) / 100;
    int cq = (jpeg_chroma_quantizer[i] * q + 50) / 100;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Limit the quantizers to 1 &lt;= q &lt;= 255 */
    if (lq &lt; 1) lq = 1;
    else if (lq &gt; 255) lq = 255;
    lqt[i] = lq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (cq &lt; 1) cq = 1;
    else if (cq &gt; 255) cq = 255;
    cqt[i] = cq;
  }
}
Appendix B
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following routines can be used to create the JPEG marker segments corresponding to the table-specification data that is absent from the RTP/JPEG body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のルーチンを使用して、RTP / JPEGボディにないテーブル仕様データに対応するJPEGマーカーセグメントを作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char lum_dc_codelens[] = {
        0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char lum_dc_symbols[] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char lum_ac_codelens[] = {
        0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char lum_ac_symbols[] = {
        0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
        0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
        0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
        0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
        0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
        0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
        0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
        0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
        0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
        0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
        0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
        0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
        0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
        0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
        0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
        0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
        0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
        0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
        0xf9, 0xfa,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char chm_dc_codelens[] = {
        0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char chm_dc_symbols[] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char chm_ac_codelens[] = {
        0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char chm_ac_symbols[] = {
        0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
        0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
        0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
        0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
        0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
        0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
        0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
        0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
        0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
        0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
        0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
        0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
        0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
        0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
        0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
        0xf9, 0xfa,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char *
MakeQuantHeader(u_char *p, u_char *qt, int tableNo)
{
        *p++ = 0xff;
        *p++ = 0xdb;            /* DQT */
        *p++ = 0;               /* length msb */
        *p++ = 67;              /* length lsb */
        *p++ = tableNo;
        memcpy(p, qt, 64);
        return (p + 64);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char *
MakeHuffmanHeader(u_char *p, u_char *codelens, int ncodes,
                  u_char *symbols, int nsymbols, int tableNo,
                  int tableClass)
{
        *p++ = 0xff;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        *p++ = 0xc4;            /* DHT */
        *p++ = 0;               /* length msb */
        *p++ = 3 + ncodes + nsymbols; /* length lsb */
        *p++ = (tableClass &lt;&lt; 4) | tableNo;
        memcpy(p, codelens, ncodes);
        p += ncodes;
        memcpy(p, symbols, nsymbols);
        p += nsymbols;
        return (p);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_char *
MakeDRIHeader(u_char *p, u_short dri) {
        *p++ = 0xff;
        *p++ = 0xdd;            /* DRI */
        *p++ = 0x0;             /* length msb */
        *p++ = 4;               /* length lsb */
        *p++ = dri &gt;&gt; 8;        /* dri msb */
        *p++ = dri &amp; 0xff;      /* dri lsb */
        return (p);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Arguments:
 *    type, width, height: as supplied in RTP/JPEG header
 *    lqt, cqt: quantization tables as either derived from
 *         the Q field using MakeTables() or as specified
 *         in section 4.2.
 *    dri: restart interval in MCUs, or 0 if no restarts.
 *
 *    p: pointer to return area
 *
 *  Return value:
 *    The length of the generated headers.
 *
 *    Generate a frame and scan headers that can be prepended to the
 *    RTP/JPEG data payload to produce a JPEG compressed image in
 *    interchange format (except for possible trailing garbage and
 *    absence of an EOI marker to terminate the scan).
 */
int MakeHeaders(u_char *p, int type, int w, int h, u_char *lqt,
                u_char *cqt, u_short dri)
{
        u_char *start = p;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /* convert from blocks to pixels */
        w &lt;&lt;= 3;
        h &lt;&lt;= 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xd8;            /* SOI */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        p = MakeQuantHeader(p, lqt, 0);
        p = MakeQuantHeader(p, cqt, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        if (dri != 0)
                p = MakeDRIHeader(p, dri);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xc0;            /* SOF */
        *p++ = 0;               /* length msb */
        *p++ = 17;              /* length lsb */
        *p++ = 8;               /* 8-bit precision */
        *p++ = h &gt;&gt; 8;          /* height msb */
        *p++ = h;               /* height lsb */
        *p++ = w &gt;&gt; 8;          /* width msb */
        *p++ = w;               /* wudth lsb */
        *p++ = 3;               /* number of components */
        *p++ = 0;               /* comp 0 */
        if (type == 0)
                *p++ = 0x21;    /* hsamp = 2, vsamp = 1 */
        else
                *p++ = 0x22;    /* hsamp = 2, vsamp = 2 */
        *p++ = 0;               /* quant table 0 */
        *p++ = 1;               /* comp 1 */
        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */
        *p++ = 1;               /* quant table 1 */
        *p++ = 2;               /* comp 2 */
        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */
        *p++ = 1;               /* quant table 1 */
        p = MakeHuffmanHeader(p, lum_dc_codelens,
                              sizeof(lum_dc_codelens),
                              lum_dc_symbols,
                              sizeof(lum_dc_symbols), 0, 0);
        p = MakeHuffmanHeader(p, lum_ac_codelens,
                              sizeof(lum_ac_codelens),
                              lum_ac_symbols,
                              sizeof(lum_ac_symbols), 0, 1);
        p = MakeHuffmanHeader(p, chm_dc_codelens,
                              sizeof(chm_dc_codelens),
                              chm_dc_symbols,
                              sizeof(chm_dc_symbols), 1, 0);
        p = MakeHuffmanHeader(p, chm_ac_codelens,
                              sizeof(chm_ac_codelens),
                              chm_ac_symbols,
                              sizeof(chm_ac_symbols), 1, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xda;            /* SOS */
        *p++ = 0;               /* length msb */
        *p++ = 12;              /* length lsb */
        *p++ = 3;               /* 3 components */
        *p++ = 0;               /* comp 0 */
        *p++ = 0;               /* huffman table 0 */
        *p++ = 1;               /* comp 1 */
        *p++ = 0x11;            /* huffman table 1 */
        *p++ = 2;               /* comp 2 */
        *p++ = 0x11;            /* huffman table 1 */
        *p++ = 0;               /* first DCT coeff */
        *p++ = 63;              /* last DCT coeff */
        *p++ = 0;               /* sucessive approx. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        return (p - start);
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix C
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録C
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following routine is used to illustrate the RTP/JPEG packet fragmentation and header creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のルーチンを使用して、RTP / JPEGパケットの断片化とヘッダーの作成を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For clarity and brevity, the structure definitions are only valid for 32-bit big-endian (most significant octet first) architectures. Bit fields are assumed to be packed tightly in big-endian bit order, with no additional padding. Modifications would be required to construct a portable implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明確かつ簡潔にするために、構造体の定義は32ビットのビッグエンディアン（最上位オクテットが最初）のアーキテクチャでのみ有効です。ビットフィールドは、ビッグエンディアンのビット順で密にパックされ、追加のパディングはないものと見なされます。移植可能な実装を構築するには、変更が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * RTP data header from RFC1889
 */
typedef struct {
        unsigned int version:2;   /* protocol version */
        unsigned int p:1;         /* padding flag */
        unsigned int x:1;         /* header extension flag */
        unsigned int cc:4;        /* CSRC count */
        unsigned int m:1;         /* marker bit */
        unsigned int pt:7;        /* payload type */
        u_int16 seq;              /* sequence number */
        u_int32 ts;               /* timestamp */
        u_int32 ssrc;             /* synchronization source */
        u_int32 csrc[1];          /* optional CSRC list */
} rtp_hdr_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define RTP_HDR_SZ 12
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define RTP_HDR_SZ 12
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* The following definition is from RFC1890 */
#define RTP_PT_JPEG             26
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
struct jpeghdr {
        unsigned int tspec:8;   /* type-specific field */
        unsigned int off:24;    /* fragment byte offset */
        u_int8 type;            /* id of jpeg decoder params */
        u_int8 q;               /* quantization factor (or table id) */
        u_int8 width;           /* frame width in 8 pixel blocks */
        u_int8 height;          /* frame height in 8 pixel blocks */
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
struct jpeghdr_rst {
        u_int16 dri;
        unsigned int f:1;
        unsigned int l:1;
        unsigned int count:14;
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
struct jpeghdr_qtable {
        u_int8  mbz;
        u_int8  precision;
        u_int16 length;
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define RTP_JPEG_RESTART 0x40
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define RTP_JPEG_RESTART 0x40
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Procedure SendFrame:
 *
 *  Arguments:
 *    start_seq: The sequence number for the first packet of the current
 *               frame.
 *    ts: RTP timestamp for the current frame
 *    ssrc: RTP SSRC value
 *    jpeg_data: Huffman encoded JPEG scan data
 *    len: Length of the JPEG scan data
 *    type: The value the RTP/JPEG type field should be set to
 *    typespec: The value the RTP/JPEG type-specific field should be set
 *              to
 *    width: The width in pixels of the JPEG image
 *    height: The height in pixels of the JPEG image
 *    dri: The number of MCUs between restart markers (or 0 if there
 *         are no restart markers in the data
 *    q: The Q factor of the data, to be specified using the Independent
 *       JPEG group&#39;s algorithm if 1 &lt;= q &lt;= 99, specified explicitly
 *       with lqt and cqt if q &gt;= 128, or undefined otherwise.
 *    lqt: The quantization table for the luminance channel if q &gt;= 128
 *    cqt: The quantization table for the chrominance channels if
 *         q &gt;= 128
 *
 *  Return value:
 *    the sequence number to be sent for the first packet of the next
 *    frame.
 *
 * The following are assumed to be defined:
 *
 * PACKET_SIZE                         - The size of the outgoing packet
 * send_packet(u_int8 *data, int len)  - Sends the packet to the network
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
u_int16 SendFrame(u_int16 start_seq, u_int32 ts, u_int32 ssrc,
                   u_int8 *jpeg_data, int len, u_int8 type,
                   u_int8 typespec, int width, int height, int dri,
                   u_int8 q, u_int8 *lqt, u_int8 *cqt) {
        rtp_hdr_t rtphdr;
        struct jpeghdr jpghdr;
        struct jpeghdr_rst rsthdr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct jpeghdr_qtable qtblhdr;
        u_int8 packet_buf[PACKET_SIZE];
        u_int8 *ptr;
        int bytes_left = len;
        int seq = start_seq;
        int pkt_len, data_len;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /* Initialize RTP header
         */
        rtphdr.version = 2;
        rtphdr.p = 0;
        rtphdr.x = 0;
        rtphdr.cc = 0;
        rtphdr.m = 0;
        rtphdr.pt = RTP_PT_JPEG;
        rtphdr.seq = start_seq;
        rtphdr.ts = ts;
        rtphdr.ssrc = ssrc;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /* Initialize JPEG header
         */
        jpghdr.tspec = typespec;
        jpghdr.off = 0;
        jpghdr.type = type | ((dri != 0) ? RTP_JPEG_RESTART : 0);
        jpghdr.q = q;
        jpghdr.width = width / 8;
        jpghdr.height = height / 8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /* Initialize DRI header
         */
        if (dri != 0) {
                rsthdr.dri = dri;
                rsthdr.f = 1;        /* This code does not align RIs */
                rsthdr.l = 1;
                rsthdr.count = 0x3fff;
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /* Initialize quantization table header
         */
        if (q &gt;= 128) {
                qtblhdr.mbz = 0;
                qtblhdr.precision = 0; /* This code uses 8 bit tables only */
                qtblhdr.length = 128;  /* 2 64-byte tables */
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        while (bytes_left &gt; 0) {
                ptr = packet_buf + RTP_HDR_SZ;
                memcpy(ptr, &amp;jpghdr, sizeof(jpghdr));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                ptr += sizeof(jpghdr);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                if (dri != 0) {
                        memcpy(ptr, &amp;rsthdr, sizeof(rsthdr));
                        ptr += sizeof(rsthdr);
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                if (q &gt;= 128 &amp;&amp; jpghdr.off == 0) {
                        memcpy(ptr, &amp;qtblhdr, sizeof(qtblhdr));
                        ptr += sizeof(qtblhdr);
                        memcpy(ptr, lqt, 64);
                        ptr += 64;
                        memcpy(ptr, cqt, 64);
                        ptr += 64;
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                data_len = PACKET_SIZE - (ptr - packet_buf);
                if (data_len &gt;= bytes_left) {
                        data_len = bytes_left;
                        rtphdr.m = 1;
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                memcpy(packet_buf, &amp;rtphdr, RTP_HDR_SZ);
                memcpy(ptr, jpeg_data + jpghdr.off, data_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                send_packet(packet_buf, (ptr - packet_buf) + data_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                jpghdr.off += data_len;
                bytes_left -= data_len;
                rtphdr.seq++;
        }
        return rtphdr.seq;
}
Appendix D
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section outlines the changes between this document and its precdecessor, RFC 2035. The changes to the protocol were made with an eye towards causing as few interoperability problems between implementations based on the older text and newer implementations, and indeed, many of the obsolete conventions can still be unambiguously decoded by a newer implementation. However, use of the older conventions in newer implementations is strongly discouraged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、このドキュメントとその前身であるRFC 2035の間の変更の概要を説明します。プロトコルへの変更は、古いテキストと新しい実装に基づく実装間での相互運用性の問題を最小限に抑えることを目的として行われました。新しい実装では、まだ明確にデコードできます。ただし、新しい実装で古い規則を使用することは強くお勧めしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o Types 0 and 1 have been augmented to allow for the encoding of interlaced video images, using 2 bits of the type-specific field. See section 4.1 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o タイプ0および1は、タイプ固有のフィールドの2ビットを使用して、インターレースされたビデオ画像をエンコードできるように拡張されています。詳細については、セクション4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o There has been discussion in the working group arguing for more flexibility in specifying the JPEG quantization tables. This memo allows table coefficients to be specified explicitly through the use of an optional Quantization Table header, discussed in sections 3.1.8 and 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o JPEG量子化テーブルを指定する際の柔軟性の向上について議論するワーキンググループでの議論がありました。このメモでは、セクション3.1.8および4.2で説明するオプションの量子化テーブルヘッダーを使用して、テーブル係数を明示的に指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o In RFC 2035, the encoding of restart marker information in the Type field made it difficult to add new types. Additionally, the type- specific field was used for the restart count, making it unavailable for other type-specific purposes. This memo moves the restart marker indication to a particular bit in the Type field, and adds an optional header to hold the additional information required, leaving the type-specific field free for its intended purpose. The handling of partial frame decoding was also made more robust against packet loss. See sections 3.1.7 and 4.4 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o RFC 2035では、タイプフィールドのリスタートマーカー情報のエンコーディングにより、新しいタイプを追加することが困難でした。さらに、タイプ固有のフィールドが再起動カウントに使用され、他のタイプ固有の目的には使用できなくなりました。このメモは、リスタートマーカーの表示をTypeフィールドの特定のビットに移動し、オプションのヘッダーを追加して必要な追加情報を保持し、タイプ固有のフィールドを目的に応じて空けておきます。部分的なフレームデコードの処理も、パケット損失に対してより堅牢になりました。詳細については、セクション3.1.7および4.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）The Internet Society（1998）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとその翻訳はコピーして他のユーザーに提供することができ、コメントまたはその他の方法で説明したり、その実装を支援する二次的著作物は、いかなる種類の制限なしに、全体または一部を準備、コピー、公開、および配布することができますただし、上記の著作権表示とこの段落は、そのようなすべてのコピーと派生物に含まれています。ただし、このドキュメント自体は、著作権に関する通知を削除したり、インターネットソサエティや他のインターネット組織への参照を削除したりするなど、いかなる方法でも変更できません。ただし、インターネット標準を開発する目的で必要な場合は除きます。インターネット標準のプロセスに従うか、または必要に応じて、それを英語以外の言語に翻訳する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに記載されている情報の使用が保証するものに限定されないいかなる保証も含め、一切の保証を否認します。商品性または特定の目的への適合性に関する権利または黙示の保証を侵害すること。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
