<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 3492 - Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3492</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3492">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 3492 - Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc3492">
            https://datatracker.ietf.org/doc/html/rfc3492
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 3492 - Punycode：アプリケーションでの国際化ドメイン名のUnicodeのブートストリングエンコーディング（IDNA）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                        A. Costello
Request for Comments: 3492                 Univ. of California, Berkeley
Category: Standards Track                                     March 2003
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Punycode：アプリケーションでの国際化ドメイン名のUnicodeのブートストリングエンコーディング（IDNA）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode is a simple and efficient transfer encoding syntax designed for use with Internationalized Domain Names in Applications (IDNA). It uniquely and reversibly transforms a Unicode string into an ASCII string. ASCII characters in the Unicode string are represented literally, and non-ASCII characters are represented by ASCII characters that are allowed in host name labels (letters, digits, and hyphens). This document defines a general algorithm called Bootstring that allows a string of basic code points to uniquely represent any string of code points drawn from a larger set. Punycode is an instance of Bootstring that uses particular parameter values specified by this document, appropriate for IDNA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycodeは、アプリケーション（IDNA）で国際化されたドメイン名で使用するために設計されたシンプルで効率的な転送エンコード構文です。ユニークでユニコード文字列をASCII文字列に変換します。Unicode文字列のASCII文字は文字通り表され、非ASCII文字はホスト名ラベル（文字、数字、ハイフン）で許可されるASCII文字で表されます。このドキュメントでは、Bootstringと呼ばれる一般的なアルゴリズムを定義します。これにより、一連の基本コードポイントが、より大きなセットから描かれた一連のコードポイントを一意に表すことができます。Punycodeは、IDNAに適したこのドキュメントで指定された特定のパラメーター値を使用するブートストリングのインスタンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction...............................................2
       1.1 Features..............................................2
       1.2 Interaction of protocol parts.........................3
   2. Terminology................................................3
   3. Bootstring description.....................................4
       3.1 Basic code point segregation..........................4
       3.2 Insertion unsort coding...............................4
       3.3 Generalized variable-length integers..................5
       3.4 Bias adaptation.......................................7
   4. Bootstring parameters......................................8
   5. Parameter values for Punycode..............................8
   6. Bootstring algorithms......................................9
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
       6.1 Bias adaptation function.............................10
       6.2 Decoding procedure...................................11
       6.3 Encoding procedure...................................12
       6.4 Overflow handling....................................13
   7. Punycode examples.........................................14
       7.1 Sample strings.......................................14
       7.2 Decoding traces......................................17
       7.3 Encoding traces......................................19
   8. Security Considerations...................................20
   9. References................................................21
       9.1 Normative References.................................21
       9.2 Informative References...............................21
   A. Mixed-case annotation.....................................22
   B. Disclaimer and license....................................22
   C. Punycode sample implementation............................23
   Author&#39;s Address.............................................34
   Full Copyright Statement.....................................35
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDNA] describes an architecture for supporting internationalized domain names. Labels containing non-ASCII characters can be represented by ACE labels, which begin with a special ACE prefix and contain only ASCII characters. The remainder of the label after the prefix is a Punycode encoding of a Unicode string satisfying certain constraints. For the details of the prefix and constraints, see [IDNA] and [NAMEPREP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDNA]は、国際化されたドメイン名をサポートするためのアーキテクチャについて説明しています。非ASCII文字を含むラベルは、特別なACEプレフィックスで始まり、ASCII文字のみを含むACEラベルで表現できます。プレフィックスの後のラベルの残りの部分は、特定の制約を満たすユニコード文字列のパニコードエンコードです。接頭辞と制約の詳細については、[IDNA]と[NamePrep]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode is an instance of a more general algorithm called Bootstring, which allows strings composed from a small set of &#34;basic&#34; code points to uniquely represent any string of code points drawn from a larger set. Punycode is Bootstring with particular parameter values appropriate for IDNA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycodeは、Bootstringと呼ばれるより一般的なアルゴリズムのインスタンスであり、「基本的な」コードポイントの小さなセットから構成される文字列が、より大きなセットから描かれた一連のコードポイントを一意に表すことができます。Punycodeは、IDNAに適した特定のパラメーター値を持つブートストリングです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1 特徴
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstring has been designed to have the following features:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstringは、次の機能を持つように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Completeness: Every extended string (sequence of arbitrary code points) can be represented by a basic string (sequence of basic code points). Restrictions on what strings are allowed, and on length, can be imposed by higher layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 完全性：すべての拡張文字列（任意のコードポイントのシーケンス）は、基本文字列（基本コードポイントのシーケンス）で表すことができます。許可されている文字列の制限、および長さの制限は、より高い層によって課すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Uniqueness: There is at most one basic string that represents a given extended string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 一意性：与えられた拡張文字列を表す基本的な文字列は最大1つあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Reversibility: Any extended string mapped to a basic string can be recovered from that basic string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 可逆性：基本的な文字列にマッピングされた拡張された文字列は、その基本文字列から回復できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Efficient encoding: The ratio of basic string length to extended string length is small. This is important in the context of domain names because RFC 1034 [RFC1034] restricts the length of a domain label to 63 characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 効率的なエンコーディング：基本文字列の長さと延長された文字列の長さの比は小さいです。これは、RFC 1034 [RFC1034]がドメインラベルの長さを63文字に制限するため、ドメイン名のコンテキストで重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Simplicity: The encoding and decoding algorithms are reasonably simple to implement. The goals of efficiency and simplicity are at odds; Bootstring aims at a good balance between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* シンプルさ：エンコーディングおよびデコードアルゴリズムの実装はかなり簡単です。効率とシンプルさの目標は対立しています。ブートストリングは、それらの間のバランスをとることを目指しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Readability: Basic code points appearing in the extended string are represented as themselves in the basic string (although the main purpose is to improve efficiency, not readability).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 読みやすさ：拡張文字列に表示される基本コードポイントは、基本的な文字列でそれ自体として表されます（ただし、主な目的は、読みやすさではなく効率を改善することです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode can also support an additional feature that is not used by the ToASCII and ToUnicode operations of [IDNA]. When extended strings are case-folded prior to encoding, the basic string can use mixed case to tell how to convert the folded string into a mixed-case string. See appendix A &#34;Mixed-case annotation&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycodeは、[IDNA]のToasciiおよびTounicode操作では使用されていない追加の機能もサポートできます。エンコードの前に拡張された文字列がケース折りたたまれると、基本的な文字列は混合ケースを使用して、折り畳まれた文字列を混合ケースの文字列に変換する方法を伝えることができます。付録A「混合ケースアノテーション」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2 Interaction of protocol parts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2 プロトコル部分の相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode is used by the IDNA protocol [IDNA] for converting domain labels into ASCII; it is not designed for any other purpose. It is explicitly not designed for processing arbitrary free text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycodeは、ドメインラベルをASCIIに変換するためにIDNAプロトコル[IDNA]によって使用されます。他の目的のために設計されていません。任意の無料テキストを処理するために明示的に設計されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14, RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「必須」、「そうしない」、「必須」、「必要」、「しない」、「そうしない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、BCP 14、RFC 2119 [RFC2119]に記載されているように解釈される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A code point is an integral value associated with a character in a coded character set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードポイントは、コード化された文字セットの文字に関連付けられた不可欠な値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As in the Unicode Standard [UNICODE], Unicode code points are denoted by &#34;U+&#34; followed by four to six hexadecimal digits, while a range of code points is denoted by two hexadecimal numbers separated by &#34;..&#34;, with no prefixes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unicode標準[Unicode]と同様に、Unicodeコードポイントは「U」に続く4〜6匹の16進数で示されますが、コードポイントの範囲は、「..」で区切られた2つの16進数で示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operators div and mod perform integer division; (x div y) is the quotient of x divided by y, discarding the remainder, and (x mod y) is the remainder, so (x div y) * y + (x mod y) == x. Bootstring uses these operators only with nonnegative operands, so the quotient and remainder are always nonnegative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペレーターDivおよびMODは、整数部門を実行します。（x div y）はxの商をyで割って残りを破棄し、（x mod y）が残りを廃棄するので、（x div y） * y（x mod y）== x。Bootstringはこれらのオペレーターを非陰性オペランドでのみ使用するため、商と残りは常に非陰性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The break statement jumps out of the innermost loop (as in C).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブレークステートメントは、最も内側のループから飛び出します（cのように）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An overflow is an attempt to compute a value that exceeds the maximum value of an integer variable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーフローとは、整数変数の最大値を超える値を計算する試みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Bootstring description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. ブートストリングの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstring represents an arbitrary sequence of code points (the &#34;extended string&#34;) as a sequence of basic code points (the &#34;basic string&#34;). This section describes the representation. Section 6 &#34;Bootstring algorithms&#34; presents the algorithms as pseudocode. Sections 7.1 &#34;Decoding traces&#34; and 7.2 &#34;Encoding traces&#34; trace the algorithms for sample inputs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブートストリングは、基本コードポイント（「基本文字列」）のシーケンスとしてのコードポイント（「拡張文字列」）の任意のシーケンスを表します。このセクションでは、表現について説明します。セクション6「ブートストリングアルゴリズム」は、アルゴリズムを擬似コードとして示します。セクション7.1「デコードトレース」と7.2「エンコードトレース」は、サンプル入力のアルゴリズムをトレースします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe the four techniques used in Bootstring. &#34;Basic code point segregation&#34; is a very simple and efficient encoding for basic code points occurring in the extended string: they are simply copied all at once. &#34;Insertion unsort coding&#34; encodes the non-basic code points as deltas, and processes the code points in numerical order rather than in order of appearance, which typically results in smaller deltas. The deltas are represented as &#34;generalized variable-length integers&#34;, which use basic code points to represent nonnegative integers. The parameters of this integer representation are dynamically adjusted using &#34;bias adaptation&#34;, to improve efficiency when consecutive deltas have similar magnitudes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、ブートストリングで使用される4つの手法について説明します。「Basic Code Point Segregation」は、拡張文字列で発生する基本コードポイントの非常にシンプルで効率的なエンコードです。それらは一度にすべてコピーされます。「Insertion unsort Coding」は、非基準コードポイントをデルタとしてエンコードし、外観の順にコードポイントを数値で処理します。これにより、通常は小さくなります。デルタは「一般化された可変長さの整数」として表され、基本的なコードポイントを使用して非陰性整数を表します。この整数表現のパラメーターは、「バイアス適応」を使用して動的に調整され、連続したデルタが同様の大きさを持っている場合に効率を向上させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Basic code point segregation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 基本的なコードポイント分離
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All basic code points appearing in the extended string are represented literally at the beginning of the basic string, in their original order, followed by a delimiter if (and only if) the number of basic code points is nonzero. The delimiter is a particular basic code point, which never appears in the remainder of the basic string. The decoder can therefore find the end of the literal portion (if there is one) by scanning for the last delimiter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張文字列に表示されるすべての基本コードポイントは、基本的な文字列の先頭に文字通り元の順序で表され、その後に基本コードポイントの数がゼロである場合（および場合にのみ）区切り文字が続きます。区切り文字は特定の基本コードポイントであり、基本文字列の残りの部分には決して表示されません。したがって、デコーダーは、最後の区切り文字をスキャンすることにより、リテラル部分の終わり（ある場合）を見つけることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Insertion unsort coding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 挿入アンソートコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remainder of the basic string (after the last delimiter if there is one) represents a sequence of nonnegative integral deltas as generalized variable-length integers, described in section 3.3. The meaning of the deltas is best understood in terms of the decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本文字列の残りの部分（最後の区切り文字がある場合は、最後の区切り文字がある場合）は、セクション3.3で説明されている一般化された可変長整数としての非陰性積分デルタのシーケンスを表します。デルタの意味は、デコーダーの観点から最もよく理解されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder builds the extended string incrementally. Initially, the extended string is a copy of the literal portion of the basic string (excluding the last delimiter). The decoder inserts non-basic code points, one for each delta, into the extended string, ultimately arriving at the final decoded string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダーは、拡張文字列を段階的に構築します。最初に、拡張文字列は、基本文字列のリテラル部分のコピーです（最後の区切り文字を除く）。デコーダーは、各デルタ用に1つの非基準コードポイントを拡張文字列に挿入し、最終的に最終的なデコードされた文字列に到着します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the heart of this process is a state machine with two state variables: an index i and a counter n. The index i refers to a position in the extended string; it ranges from 0 (the first position) to the current length of the extended string (which refers to a potential position beyond the current end). If the current state is &lt;n,i&gt;, the next state is &lt;n,i+1&gt; if i is less than the length of the extended string, or &lt;n+1,0&gt; if i equals the length of the extended string. In other words, each state change causes i to increment, wrapping around to zero if necessary, and n counts the number of wrap-arounds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロセスの中心には、インデックスIとカウンターnの2つの状態変数を備えた状態マシンがあります。インデックスIは、拡張文字列の位置を指します。0（最初の位置）から拡張文字列の現在の長さ（現在の端を超えた潜在的な位置を指します）の範囲です。現在の状態が&lt;n、i&gt;の場合、次の状態は&lt;n、i 1&gt;拡張文字列の長さよりも小さい場合、または拡張文字列の長さに等しい場合は&lt;n 1,0&gt;です。言い換えれば、各状態の変化により、Iが増加し、必要に応じてゼロに包み込み、nはラップアラウンドの数を数えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notice that the state always advances monotonically (there is no way for the decoder to return to an earlier state). At each state, an insertion is either performed or not performed. At most one insertion is performed in a given state. An insertion inserts the value of n at position i in the extended string. The deltas are a run-length encoding of this sequence of events: they are the lengths of the runs of non-insertion states preceeding the insertion states. Hence, for each delta, the decoder performs delta state changes, then an insertion, and then one more state change. (An implementation need not perform each state change individually, but can instead use division and remainder calculations to compute the next insertion state directly.) It is an error if the inserted code point is a basic code point (because basic code points were supposed to be segregated as described in section 3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態は常に単調に進歩していることに注意してください（デコーダーが以前の状態に戻る方法はありません）。各状態で、挿入が実行されるか、実行されません。最大で1つの挿入が特定の状態で実行されます。挿入により、拡張文字列の位置Iにnの値が挿入されます。デルタは、この一連のイベントの走行距離エンコードです。これらは、挿入状態を前処理する非挿入状態の実行の長さです。したがって、各デルタについて、デコーダーはデルタ状態の変更を実行し、次に挿入し、さらに1つの状態の変更を実行します。（実装は各状態の変更を個別に実行する必要はありませんが、代わりに分割と残りの計算を使用して次の挿入状態を直接計算できます。）挿入されたコードポイントが基本コードポイントである場合（基本コードポイントが想定されていたため、エラーです。セクション3.1で説明されているように分離されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encoder&#39;s main task is to derive the sequence of deltas that will cause the decoder to construct the desired string. It can do this by repeatedly scanning the extended string for the next code point that the decoder would need to insert, and counting the number of state changes the decoder would need to perform, mindful of the fact that the decoder&#39;s extended string will include only those code points that have already been inserted. Section 6.3 &#34;Encoding procedure&#34; gives a precise algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーダーの主なタスクは、デコーダーが目的の文字列を構築する原因となるデルタのシーケンスを導出することです。これは、デコーダーが挿入する必要がある次のコードポイントの拡張文字列を繰り返しスキャンし、デコーダーが実行する必要がある状態の変更の数をカウントすることでこれを行うことができます。すでに挿入されているコードポイント。セクション6.3「エンコード手順」は、正確なアルゴリズムを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Generalized variable-length integers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 一般化された可変長整数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a conventional integer representation the base is the number of distinct symbols for digits, whose values are 0 through base-1. Let digit_0 denote the least significant digit, digit_1 the next least significant, and so on. The value represented is the sum over j of digit_j * w(j), where w(j) = base^j is the weight (scale factor) for position j. For example, in the base 8 integer 437, the digits are 7, 3, and 4, and the weights are 1, 8, and 64, so the value is 7 + 3*8 + 4*64 = 287. This representation has two disadvantages: First, there are multiple encodings of each value (because there can be extra zeros in the most significant positions), which is inconvenient
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従来の整数表現では、ベースは数字の明確なシンボルの数であり、その値は0からbase-1です。DIGIT_0は、最も有意な数字、DIGIT_1が次に最も重要でないことなどを示します。表される値は、digit_j * w（j）のjの合計です。ここで、w（j）= base^jは位置jの重み（スケール係数）です。たとえば、ベース8整数437では、数字は7、3、および4、重みは1、8、および64であるため、値は7 3*8 4*64 = 287です。この表現には2つの欠点があります。：最初に、各値には複数のエンコーディングがあります（最も重要な位置に余分なゼロがある可能性があるため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
when unique encodings are needed. Second, the integer is not self-delimiting, so if multiple integers are concatenated the boundaries between them are lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一意のエンコーディングが必要な場合。第二に、整数は自己決定ではないため、複数の整数が連結されている場合、それらの間の境界が失われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The generalized variable-length representation solves these two problems. The digit values are still 0 through base-1, but now the integer is self-delimiting by means of thresholds t(j), each of which is in the range 0 through base-1. Exactly one digit, the most significant, satisfies digit_j &lt; t(j). Therefore, if several integers are concatenated, it is easy to separate them, starting with the first if they are little-endian (least significant digit first), or starting with the last if they are big-endian (most significant digit first). As before, the value is the sum over j of digit_j * w(j), but the weights are different:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般化された可変長い表現は、これら2つの問題を解決します。数字の値はまだ0からbase-1ですが、現在、整数はしきい値t（j）によって自己削除されており、それぞれが範囲0からbase-1にあります。最も重要な1桁の正確な1桁は、digit_j &lt;t（j）を満たしています。したがって、いくつかの整数が連結されている場合、それらを分離するのは簡単です。最初の整数は、小さなエンディアンの場合（最初は最も有意な数字ではない）、またはビッグエンディアンの場合は最後から始まります（最初は最も有意な数字）。前と同様に、値はdigit_j * w（j）のjの合計ですが、重みは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      w(0) = 1
      w(j) = w(j-1) * (base - t(j-1)) for j &gt; 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider the little-endian sequence of base 8 digits 734251... Suppose the thresholds are 2, 3, 5, 5, 5, 5... This implies that the weights are 1, 1*(8-2) = 6, 6*(8-3) = 30, 30*(8-5) = 90, 90*(8-5) = 270, and so on. 7 is not less than 2, and 3 is not less than 3, but 4 is less than 5, so 4 is the last digit. The value of 734 is 7*1 + 3*6 + 4*30 = 145. The next integer is 251, with value 2*1 + 5*6 + 1*30 = 62. Decoding this representation is very similar to decoding a conventional integer: Start with a current value of N = 0 and a weight w = 1. Fetch the next digit d and increase N by d * w. If d is less than the current threshold (t) then stop, otherwise increase w by a factor of (base - t), update t for the next position, and repeat.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、ベース8桁の小さなエンディアンシーケンス734251を考えてみましょう...しきい値が2、3、5、5、5、5であると仮定します...これは、重みが1、1*（8-2）であることを意味します= 6、6*（8-3）= 30、30*（8-5）= 90、90*（8-5）= 270など。7は2歳以上で、3は3歳以上ですが、4は5未満であるため、4は最後の数字です。734の値は7*1 3*6 4*30 = 145です。次の整数は251で、値2*1 5*6 1*30 = 62です。この表現のデコードは、従来の整数のデコードに非常に似ています。n = 0とa重量w = 1の電流値があります。次の桁dを取得し、d * wでnを増やします。Dが現在のしきい値（t）よりも少ない場合、停止し、それ以外の場合はwを（base -t）係数で増やし、次の位置にtを更新し、繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding this representation is similar to encoding a conventional integer: If N &lt; t then output one digit for N and stop, otherwise output the digit for t + ((N - t) mod (base - t)), then replace N with (N - t) div (base - t), update t for the next position, and repeat.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この表現をエンコードすることは、従来の整数のエンコードに似ています。n&lt;tの場合、nに1桁を出力して停止し、それ以外の場合はt（（n -t）mod（base -t））の数字を出力し、nを（nを置き換えます。-t）div（base -t）、次の位置にtを更新し、繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any particular set of values of t(j), there is exactly one generalized variable-length representation of each nonnegative integral value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t（j）の特定の値のセットについて、各非陰性積分値の一般化された変数長い表現が正確に1つあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstring uses little-endian ordering so that the deltas can be separated starting with the first. The t(j) values are defined in terms of the constants base, tmin, and tmax, and a state variable called bias:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstringは小さなエンディアン注文を使用して、Deltasを最初から分離できるようにします。T（j）値は、定数ベース、TMIN、およびTMAX、およびバイアスと呼ばれる状態変数に関して定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      t(j) = base * (j + 1) - bias,
      clamped to the range tmin through tmax
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The clamping means that if the formula yields a value less than tmin or greater than tmax, then t(j) = tmin or tmax, respectively. (In the pseudocode in section 6 &#34;Bootstring algorithms&#34;, the expression base * (j + 1) is denoted by k for performance reasons.) These t(j) values cause the representation to favor integers within a particular range determined by the bias.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クランプは、式がTMINよりも少ない値またはTMAXより大きい値を生成する場合、それぞれt（j）= TMINまたはTMAXを生成することを意味します。（セクション6「ブートストリングアルゴリズム」の擬似コードでは、式ベース *（j 1）はパフォーマンス上の理由でKで示されます。）これらのt（j）値により、表現はバイアスによって決定される特定の範囲内の整数を支持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 Bias adaptation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 バイアス適応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After each delta is encoded or decoded, bias is set for the next delta as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各デルタがエンコードまたはデコードされた後、次のように次のデルタにバイアスが設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Delta is scaled in order to avoid overflow in the next step:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. デルタは、次のステップでオーバーフローを避けるために拡大されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
let delta = delta div 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Delta = Delta Div 2とします
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
But when this is the very first delta, the divisor is not 2, but instead a constant called damp. This compensates for the fact that the second delta is usually much smaller than the first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
しかし、これが最初のデルタである場合、除数は2ではなく、湿気と呼ばれる定数です。これは、通常、2番目のデルタが最初のデルタよりもはるかに小さいという事実を補います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Delta is increased to compensate for the fact that the next delta will be inserting into a longer string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. デルタは、次のデルタがより長い文字列に挿入するという事実を補うために増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
let delta = delta + (delta div numpoints)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
let delta = delta（delta div numpoints）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
numpoints is the total number of code points encoded/decoded so far (including the one corresponding to this delta itself, and including the basic code points).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Numpointsは、これまでにエンコード/デコードされたコードポイントの総数（このデルタ自体に対応するものを含む、および基本的なコードポイントを含む）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Delta is repeatedly divided until it falls within a threshold, to predict the minimum number of digits needed to represent the next delta:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. デルタは、次のデルタを表すために必要な最小数字の数を予測するために、しきい値に該当するまで繰り返し分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         while delta &gt; ((base - tmin) * tmax) div 2
         do let delta = delta div (base - tmin)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The bias is set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. バイアスが設定されています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         let bias =
           (base * the number of divisions performed in step 3) +
           (((base - tmin + 1) * delta) div (delta + skew))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The motivation for this procedure is that the current delta provides a hint about the likely size of the next delta, and so t(j) is set to tmax for the more significant digits starting with the one expected to be last, tmin for the less significant digits up through the one expected to be third-last, and somewhere between tmin and tmax for the digit expected to be second-last
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この手順の動機は、現在のデルタが次のデルタの可能性のあるサイズに関するヒントを提供することです。したがって、t（j）は、最後になると予想されるものから始まるより重要な数字でtmaxに設定されます。3番目の最後になると予想されるものを介して大幅に数字を上げ、TMINとTMAXの間のどこかで2番目に続くと予想される桁
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(balancing the hope of the expected-last digit being unnecessary against the danger of it being insufficient).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（予想される最後の数字が不十分であるという危険に対して不要であるという希望のバランスをとる）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Bootstring parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. ブートストリングパラメーター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given a set of basic code points, one needs to be designated as the delimiter. The base cannot be greater than the number of distinguishable basic code points remaining. The digit-values in the range 0 through base-1 need to be associated with distinct non-delimiter basic code points. In some cases multiple code points need to have the same digit-value; for example, uppercase and lowercase versions of the same letter need to be equivalent if basic strings are case-insensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一連の基本的なコードポイントを考えると、デリミッターとして指定する必要があります。ベースは、残っている識別可能な基本コードポイントの数より大きくすることはできません。範囲0からbase-1の数字値は、異なる非削除型基本コードポイントに関連付ける必要があります。場合によっては、複数のコードポイントが同じ数字値を持つ必要があります。たとえば、基本文字列がケースに依存しない場合、同じ文字の大文字と小文字のバージョンが同等である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial value of n cannot be greater than the minimum non-basic code point that could appear in extended strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nの初期値は、拡張文字列に表示される可能性のある最小の非基準コードポイントよりも大きくすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining five parameters (tmin, tmax, skew, damp, and the initial value of bias) need to satisfy the following constraints:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りの5つのパラメーター（TMIN、TMAX、スキュー、湿気、およびバイアスの初期値）は、次の制約を満たす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0 &lt;= tmin &lt;= tmax &lt;= base-1
      skew &gt;= 1
      damp &gt;= 2
      initial_bias mod base &lt;= base - tmin
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Provided the constraints are satisfied, these five parameters affect efficiency but not correctness. They are best chosen empirically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約が満たされている場合、これらの5つのパラメーターは効率に影響しますが、正しさには影響しません。それらは経験的に最もよく選ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If support for mixed-case annotation is desired (see appendix A), make sure that the code points corresponding to 0 through tmax-1 all have both uppercase and lowercase forms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
混合ケースの注釈のサポートが必要な場合（付録Aを参照）、0からTMAX-1に対応するコードポイントにすべて大文字と小文字の両方のフォームがあることを確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Parameter values for Punycode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Punycodeのパラメーター値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode uses the following Bootstring parameter values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycodeは、次のブートストリングパラメーター値を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
base = 36 tmin = 1 tmax = 26 skew = 38 damp = 700 initial_bias = 72 initial_n = 128 = 0x80
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
base = 36 tmin = 1 tmax = 26 skew = 38 damp = 700 initial_bias = 72 initial_n = 128 = 0x80
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the only restriction Punycode imposes on the input integers is that they be nonnegative, these parameters are especially designed to work well with Unicode [UNICODE] code points, which are integers in the range 0..10FFFF (but not D800..DFFF, which are reserved for
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力整数に唯一の制限が課すのは、それらが非陰性であることですが、これらのパラメーターは特に、0..10FFFの範囲の整数であるUnicode [Unicode]コードポイントでうまく機能するように設計されています（ただし、D800..DFFFではありません、予約されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
use by the UTF-16 encoding of Unicode). The basic code points are the ASCII [ASCII] code points (0..7F), of which U+002D (-) is the delimiter, and some of the others have digit-values as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UnicodeのUTF-16エンコーディングによる使用）。基本的なコードポイントは、ASCII [ASCII]コードポイント（0..7F）です。u 002d（ - ）は区切り文字であり、他の一部には次のように数字の値があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      code points    digit-values
      ------------   ----------------------
      41..5A (A-Z) =  0 to 25, respectively
      61..7A (a-z) =  0 to 25, respectively
      30..39 (0-9) = 26 to 35, respectively
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using hyphen-minus as the delimiter implies that the encoded string can end with a hyphen-minus only if the Unicode string consists entirely of basic code points, but IDNA forbids such strings from being encoded. The encoded string can begin with a hyphen-minus, but IDNA prepends a prefix. Therefore IDNA using Punycode conforms to the RFC 952 rule that host name labels neither begin nor end with a hyphen-minus [RFC952].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハイフン - マイナスを区切り文字として使用すると、ユニコード文字列が完全に基本的なコードポイントで構成されている場合にのみ、エンコードされた文字列がハイフン - マイナスで終わることを意味しますが、IDNAはそのような文字列がエンコードされるのを禁止します。エンコードされた文字列はハイフン - マイナスで始まることができますが、IDNAはプレフィックスを準備します。したがって、Punycodeを使用したIDNAは、ホスト名がハイフン - マイナスで始まることも終了しないRFC 952ルールに準拠しています[RFC952]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A decoder MUST recognize the letters in both uppercase and lowercase forms (including mixtures of both forms). An encoder SHOULD output only uppercase forms or only lowercase forms, unless it uses mixed-case annotation (see appendix A).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダーは、大文字と小文字の両方の文字（両方のフォームの混合物を含む）の文字を認識する必要があります。エンコーダーは、混合ケースの注釈を使用しない限り、大文字または小文字のみのみを出力する必要があります（付録Aを参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Presumably most users will not manually write or type encoded strings (as opposed to cutting and pasting them), but those who do will need to be alert to the potential visual ambiguity between the following sets of characters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
おそらく、ほとんどのユーザーは、エンコードされた文字列を手動で書き込み、タイプしません（それらを切断して貼り付けるのではなく）が、次の文字のセット間の潜在的な視覚的曖昧さに注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
G 6 I l 1 O 0 S 5 U V Z 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
G 6 I L 1 O 0 S 5 U V Z 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such ambiguities are usually resolved by context, but in a Punycode encoded string there is no context apparent to humans.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなあいまいさは通常、コンテキストによって解決されますが、プニュコードエンコードされた文字列には、人間に明らかなコンテキストはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Bootstring algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. ブートストリングアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some parts of the pseudocode can be omitted if the parameters satisfy certain conditions (for which Punycode qualifies). These parts are enclosed in {braces}, and notes immediately following the pseudocode explain the conditions under which they can be omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメーターが特定の条件を満たしている場合（Punycodeの資格がある）、Pseudocodeの一部を省略できます。これらの部分は{ブレース}に囲まれており、擬似コードの直後のメモは、それらが省略できる条件を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Formally, code points are integers, and hence the pseudocode assumes that arithmetic operations can be performed directly on code points. In some programming languages, explicit conversion between code points and integers might be necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正式には、コードポイントは整数であるため、擬似コードは算術操作をコードポイントで直接実行できると想定しています。一部のプログラミング言語では、コードポイントと整数間の明示的な変換が必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 Bias adaptation function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 バイアス適応関数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   function adapt(delta,numpoints,firsttime):
     if firsttime then let delta = delta div damp
     else let delta = delta div 2
     let delta = delta + (delta div numpoints)
     let k = 0
     while delta &gt; ((base - tmin) * tmax) div 2 do begin
       let delta = delta div (base - tmin)
       let k = k + base
     end
     return k + (((base - tmin + 1) * delta) div (delta + skew))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It does not matter whether the modifications to delta and k inside adapt() affect variables of the same name inside the encoding/decoding procedures, because after calling adapt() the caller does not read those variables before overwriting them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adapt（）内部のDeltaとKの変更がエンコード/デコード手順内の同じ名前の変数に影響するかどうかは関係ありません。Adapt（）を呼び出した後、発信者はそれらを上書きする前にそれらの変数を読み取らないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 Decoding procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 デコード手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   let n = initial_n
   let i = 0
   let bias = initial_bias
   let output = an empty string indexed from 0
   consume all code points before the last delimiter (if there is one)
     and copy them to output, fail on any non-basic code point
   if more than zero code points were consumed then consume one more
     (which will be the last delimiter)
   while the input is not exhausted do begin
     let oldi = i
     let w = 1
     for k = base to infinity in steps of base do begin
       consume a code point, or fail if there was none to consume
       let digit = the code point&#39;s digit-value, fail if it has none
       let i = i + digit * w, fail on overflow
       let t = tmin if k &lt;= bias {+ tmin}, or
               tmax if k &gt;= bias + tmax, or k - bias otherwise
       if digit &lt; t then break
       let w = w * (base - t), fail on overflow
     end
     let bias = adapt(i - oldi, length(output) + 1, test oldi is 0?)
     let n = n + i div (length(output) + 1), fail on overflow
     let i = i mod (length(output) + 1)
     {if n is a basic code point then fail}
     insert n into output at position i
     increment i
   end
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full statement enclosed in braces (checking whether n is a basic code point) can be omitted if initial_n exceeds all basic code points (which is true for Punycode), because n is never less than initial_n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nがinitial_n以下ではないため、initial_nがすべての基本コードポイント（これはpunycodeに当てはまる）を超える場合、ブレースに囲まれた完全なステートメント（nが基本コードポイントであるかどうかを確認）は省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the assignment of t, where t is clamped to the range tmin through tmax, &#34;+ tmin&#34; can always be omitted. This makes the clamping calculation incorrect when bias &lt; k &lt; bias + tmin, but that cannot happen because of the way bias is computed and because of the constraints on the parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tの割り当てでは、tがtmaxを介して範囲tminにクランプされ、「tmin」はいつでも省略できます。これにより、バイアス&lt;k &lt;バイアスTMINの場合、クランプ計算が正しくなりますが、バイアスの計算方法とパラメーターの制約のために発生することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the decoder state can only advance monotonically, and there is only one representation of any delta, there is therefore only one encoded string that can represent a given sequence of integers. The only error conditions are invalid code points, unexpected end-of-input, overflow, and basic code points encoded using deltas instead of appearing literally. If the decoder fails on these errors as shown above, then it cannot produce the same output for two distinct inputs. Without this property it would have been necessary to re-
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダー状態は単調にしか前進しないため、デルタの表現は1つしかないため、整数の特定のシーケンスを表すことができるエンコードされた文字列は1つだけです。唯一のエラー条件は、無効なコードポイント、予期しない入力終了、オーバーフロー、および文字通りに表示される代わりにDeltasを使用してエンコードされた基本的なコードポイントです。上記のようにこれらのエラーでデコーダーが故障した場合、2つの異なる入力に対して同じ出力を生成することはできません。このプロパティがなければ、それは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
encode the output and verify that it matches the input in order to guarantee the uniqueness of the encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力をエンコードし、エンコードの一意性を保証するために入力と一致することを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 Encoding procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 エンコード手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   let n = initial_n
   let delta = 0
   let bias = initial_bias
   let h = b = the number of basic code points in the input
   copy them to the output in order, followed by a delimiter if b &gt; 0
   {if the input contains a non-basic code point &lt; n then fail}
   while h &lt; length(input) do begin
     let m = the minimum {non-basic} code point &gt;= n in the input
     let delta = delta + (m - n) * (h + 1), fail on overflow
     let n = m
     for each code point c in the input (in order) do begin
       if c &lt; n {or c is basic} then increment delta, fail on overflow
       if c == n then begin
         let q = delta
         for k = base to infinity in steps of base do begin
           let t = tmin if k &lt;= bias {+ tmin}, or
                   tmax if k &gt;= bias + tmax, or k - bias otherwise
           if q &lt; t then break
           output the code point for digit t + ((q - t) mod (base - t))
           let q = (q - t) div (base - t)
         end
         output the code point for digit q
         let bias = adapt(delta, h + 1, test h equals b?)
         let delta = 0
         increment h
       end
     end
     increment delta and n
   end
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full statement enclosed in braces (checking whether the input contains a non-basic code point less than n) can be omitted if all code points less than initial_n are basic code points (which is true for Punycode if code points are unsigned).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブレースに囲まれた完全なステートメント（入力にn未満の基本コードポイントが含まれているかどうかを確認する）は、すべてのコードポイントがinitial_nより少ない場合、基本コードポイント（コードポイントが符号なしである場合はプニコードに当てはまる）である場合は省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The brace-enclosed conditions &#34;non-basic&#34; and &#34;or c is basic&#34; can be omitted if initial_n exceeds all basic code points (which is true for Punycode), because the code point being tested is never less than initial_n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テストされているコードポイントがInitial_nを超えることはないため、initial_nがすべての基本コードポイント（Punycodeに当てはまる）を超える場合、「非基準」および「またはcは基本」を省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the assignment of t, where t is clamped to the range tmin through tmax, &#34;+ tmin&#34; can always be omitted. This makes the clamping calculation incorrect when bias &lt; k &lt; bias + tmin, but that cannot
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tの割り当てでは、tがtmaxを介して範囲tminにクランプされ、「tmin」はいつでも省略できます。これにより、バイアス&lt;k &lt;バイアスtminの場合、クランプ計算が正しくなりますが、それはできません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
happen because of the way bias is computed and because of the constraints on the parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイアスの計算方法とパラメーターの制約のために発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The checks for overflow are necessary to avoid producing invalid output when the input contains very large values or is very long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーフローのチェックは、入力に非常に大きな値が含まれているか、非常に長い場合に無効な出力の生成を避けるために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The increment of delta at the bottom of the outer loop cannot overflow because delta &lt; length(input) before the increment, and length(input) is already assumed to be representable. The increment of n could overflow, but only if h == length(input), in which case the procedure is finished anyway.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
外側ループの下部にあるデルタの増分は、増分前のデルタ&lt;長さ（入力）、および長さ（入力）がすでに表現可能であると想定されているため、オーバーフローできません。nの増分はオーバーフローする可能性がありますが、h ==長さ（入力）の場合にのみ、その場合は手順が完了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 Overflow handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 オーバーフロー処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For IDNA, 26-bit unsigned integers are sufficient to handle all valid IDNA labels without overflow, because any string that needed a 27-bit delta would have to exceed either the code point limit (0..10FFFF) or the label length limit (63 characters). However, overflow handling is necessary because the inputs are not necessarily valid IDNA labels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IDNAの場合、26ビットのデルタを必要とする文字列がコードポイント制限（0..10ffff）またはラベルの長さの制限（ラベル長）を超える必要があるため、26ビットの符号なしの整数はオーバーフローなしですべての有効なIDNAラベルを処理するのに十分です。63文字）。ただし、入力は必ずしも有効なIDNAラベルではないため、オーバーフロー処理が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the programming language does not provide overflow detection, the following technique can be used. Suppose A, B, and C are representable nonnegative integers and C is nonzero. Then A + B overflows if and only if B &gt; maxint - A, and A + (B * C) overflows if and only if B &gt; (maxint - A) div C, where maxint is the greatest integer for which maxint + 1 cannot be represented. Refer to appendix C &#34;Punycode sample implementation&#34; for demonstrations of this technique in the C language.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プログラミング言語がオーバーフロー検出を提供しない場合、次の手法を使用できます。A、B、およびCが表現可能な非陰性整数であり、Cが非ゼロであると仮定します。b&gt; maxint -a、およびa（b * c）がb&gt;（maxint -a）div cの場合にのみ、b&gt; maxint -aとa（b * c）がオーバーフローする場合にのみ、bオーバーフローします。C言語でのこの手法のデモンストレーションについては、付録C「Punycodeサンプルの実装」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoding and encoding algorithms shown in sections 6.2 and 6.3 handle overflow by detecting it whenever it happens. Another approach is to enforce limits on the inputs that prevent overflow from happening. For example, if the encoder were to verify that no input code points exceed M and that the input length does not exceed L, then no delta could ever exceed (M - initial_n) * (L + 1), and hence no overflow could occur if integer variables were capable of representing values that large. This prevention approach would impose more restrictions on the input than the detection approach does, but might be considered simpler in some programming languages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション6.2および6.3に示されているデコードおよびエンコードアルゴリズムは、発生するたびに検出してオーバーフローを処理します。別のアプローチは、オーバーフローが発生しないようにする入力の制限を強制することです。たとえば、エンコーダが入力コードポイントがmを超えていないこと、入力長がLを超えないことを確認した場合、デルタは（m -initial_n） *（l 1）を超えることができないため、オーバーフローが発生しない場合、整数変数は、その大きな値を表すことができました。この予防アプローチは、検出アプローチよりも入力により多くの制限を課しますが、一部のプログラミング言語ではより単純であると見なされる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In theory, the decoder could use an analogous approach, limiting the number of digits in a variable-length integer (that is, limiting the number of iterations in the innermost loop). However, the number of digits that suffice to represent a given delta can sometimes represent much larger deltas (because of the adaptation), and hence this approach would probably need integers wider than 32 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理論的には、デコーダーは類似のアプローチを使用して、可変長整数の数字数を制限できます（つまり、最も内側のループの反復回数を制限します）。ただし、特定のデルタを表すのに十分な数字の数は、（適応のため）はるかに大きなデルタを表すことがあります。したがって、このアプローチはおそらく32ビットよりも広い整数が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yet another approach for the decoder is to allow overflow to occur, but to check the final output string by re-encoding it and comparing to the decoder input. If and only if they do not match (using a case-insensitive ASCII comparison) overflow has occurred. This delayed-detection approach would not impose any more restrictions on the input than the immediate-detection approach does, and might be considered simpler in some programming languages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダーのもう1つのアプローチは、オーバーフローが発生することを許可することですが、最終出力文字列を再エンコードしてデコーダー入力と比較することにより、最終出力文字列を確認することです。それらが一致しない場合にのみ（ケース非感受性ASCII比較を使用して）オーバーフローが発生しました。この遅延検出アプローチは、即時の検出アプローチよりも入力に多くの制限を課すことはなく、一部のプログラミング言語ではより単純であると見なされる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In fact, if the decoder is used only inside the IDNA ToUnicode operation [IDNA], then it need not check for overflow at all, because ToUnicode performs a higher level re-encoding and comparison, and a mismatch has the same consequence as if the Punycode decoder had failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際、デコーダーがiDNA tounicode操作[idna]内でのみ使用されている場合、tounicodeはより高いレベルの再エンコードと比較を実行し、不一致が同じ結果をもたらすため、オーバーフローをまったくチェックする必要はありません。Punycode Decoderが失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Punycode examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. パニコードの例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 Sample strings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 サンプル文字列
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the Punycode encodings below, the ACE prefix is not shown. Backslashes show where line breaks have been inserted in strings too long for one line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のプニュコードエンコーディングでは、ACEプレフィックスは表示されません。バックスラッシュは、1つのラインに対して長い文字列にラインブレークが挿入された場所を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first several examples are all translations of the sentence &#34;Why can&#39;t they just speak in &lt;language&gt;?&#34; (courtesy of Michael Kaplan&#39;s &#34;provincial&#34; page [PROVINCIAL]). Word breaks and punctuation have been removed, as is often done in domain names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のいくつかの例は、すべて「なぜ彼らは&lt;言語&gt;で話すことができないのか」という文の翻訳です。（Michael Kaplanの「Provincial」ページ[Provincial]の厚意により）。ドメイン名でしばしば行われるように、単語の破損と句読点が削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (A) Arabic (Egyptian):
       u+0644 u+064A u+0647 u+0645 u+0627 u+0628 u+062A u+0643 u+0644
       u+0645 u+0648 u+0634 u+0639 u+0631 u+0628 u+064A u+061F
       Punycode: egbpdaj6bu4bxfgehfvwxn
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (B) Chinese (simplified):
       u+4ED6 u+4EEC u+4E3A u+4EC0 u+4E48 u+4E0D u+8BF4 u+4E2D u+6587
       Punycode: ihqwcrb4cv8a8dqg056pqjye
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (C) Chinese (traditional):
       u+4ED6 u+5011 u+7232 u+4EC0 u+9EBD u+4E0D u+8AAA u+4E2D u+6587
       Punycode: ihqwctvzc91f659drss3x8bo0yb
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (D) Czech: Pro&lt;ccaron&gt;prost&lt;ecaron&gt;nemluv&lt;iacute&gt;&lt;ccaron&gt;esky
       U+0050 u+0072 u+006F u+010D u+0070 u+0072 u+006F u+0073 u+0074
       u+011B u+006E u+0065 u+006D u+006C u+0075 u+0076 u+00ED u+010D
       u+0065 u+0073 u+006B u+0079
       Punycode: Proprostnemluvesky-uyb24dma41a
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (E) Hebrew:
       u+05DC u+05DE u+05D4 u+05D4 u+05DD u+05E4 u+05E9 u+05D5 u+05D8
       u+05DC u+05D0 u+05DE u+05D3 u+05D1 u+05E8 u+05D9 u+05DD u+05E2
       u+05D1 u+05E8 u+05D9 u+05EA
       Punycode: 4dbcagdahymbxekheh6e0a7fei0b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (F) Hindi (Devanagari):
       u+092F u+0939 u+0932 u+094B u+0917 u+0939 u+093F u+0928 u+094D
       u+0926 u+0940 u+0915 u+094D u+092F u+094B u+0902 u+0928 u+0939
       u+0940 u+0902 u+092C u+094B u+0932 u+0938 u+0915 u+0924 u+0947
       u+0939 u+0948 u+0902
       Punycode: i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (G) Japanese (kanji and hiragana):
       u+306A u+305C u+307F u+3093 u+306A u+65E5 u+672C u+8A9E u+3092
       u+8A71 u+3057 u+3066 u+304F u+308C u+306A u+3044 u+306E u+304B
       Punycode: n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (H) Korean (Hangul syllables):
       u+C138 u+ACC4 u+C758 u+BAA8 u+B4E0 u+C0AC u+B78C u+B4E4 u+C774
       u+D55C u+AD6D u+C5B4 u+B97C u+C774 u+D574 u+D55C u+B2E4 u+BA74
       u+C5BC u+B9C8 u+B098 u+C88B u+C744 u+AE4C
       Punycode: 989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j\
                 psd879ccm6fea98c
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (I) Russian (Cyrillic):
       U+043F u+043E u+0447 u+0435 u+043C u+0443 u+0436 u+0435 u+043E
       u+043D u+0438 u+043D u+0435 u+0433 u+043E u+0432 u+043E u+0440
       u+044F u+0442 u+043F u+043E u+0440 u+0443 u+0441 u+0441 u+043A
       u+0438
       Punycode: b1abfaaepdrnnbgefbaDotcwatmq2g4l
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (J) Spanish: Porqu&lt;eacute&gt;nopuedensimplementehablarenEspa&lt;ntilde&gt;ol
       U+0050 u+006F u+0072 u+0071 u+0075 u+00E9 u+006E u+006F u+0070
       u+0075 u+0065 u+0064 u+0065 u+006E u+0073 u+0069 u+006D u+0070
       u+006C u+0065 u+006D u+0065 u+006E u+0074 u+0065 u+0068 u+0061
       u+0062 u+006C u+0061 u+0072 u+0065 u+006E U+0045 u+0073 u+0070
       u+0061 u+00F1 u+006F u+006C
       Punycode: PorqunopuedensimplementehablarenEspaol-fmd56a
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (K) Vietnamese:
       T&lt;adotbelow&gt;isaoh&lt;odotbelow&gt;kh&lt;ocirc&gt;ngth&lt;ecirchookabove&gt;ch\
       &lt;ihookabove&gt;n&lt;oacute&gt;iti&lt;ecircacute&gt;ngVi&lt;ecircdotbelow&gt;t
       U+0054 u+1EA1 u+0069 u+0073 u+0061 u+006F u+0068 u+1ECD u+006B
       u+0068 u+00F4 u+006E u+0067 u+0074 u+0068 u+1EC3 u+0063 u+0068
       u+1EC9 u+006E u+00F3 u+0069 u+0074 u+0069 u+1EBF u+006E u+0067
       U+0056 u+0069 u+1EC7 u+0074
       Punycode: TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next several examples are all names of Japanese music artists, song titles, and TV programs, just because the author happens to have them handy (but Japanese is useful for providing examples of single-row text, two-row text, ideographic text, and various mixtures thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のいくつかの例はすべて、著者がそれらを便利にしているからといって、日本の音楽アーティスト、歌のタイトル、テレビ番組のすべての名前です（ただし、日本語は単一列テキスト、2列テキスト、表意文字テキスト、およびそのさまざまな混合物）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (L) 3&lt;nen&gt;B&lt;gumi&gt;&lt;kinpachi&gt;&lt;sensei&gt;
       u+0033 u+5E74 U+0042 u+7D44 u+91D1 u+516B u+5148 u+751F
       Punycode: 3B-ww4c5e180e575a65lsy2b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (M) &lt;amuro&gt;&lt;namie&gt;-with-SUPER-MONKEYS
       u+5B89 u+5BA4 u+5948 u+7F8E u+6075 u+002D u+0077 u+0069 u+0074
       u+0068 u+002D U+0053 U+0055 U+0050 U+0045 U+0052 u+002D U+004D
       U+004F U+004E U+004B U+0045 U+0059 U+0053
       Punycode: -with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (N) Hello-Another-Way-&lt;sorezore&gt;&lt;no&gt;&lt;basho&gt;
       U+0048 u+0065 u+006C u+006C u+006F u+002D U+0041 u+006E u+006F
       u+0074 u+0068 u+0065 u+0072 u+002D U+0057 u+0061 u+0079 u+002D
       u+305D u+308C u+305E u+308C u+306E u+5834 u+6240
       Punycode: Hello-Another-Way--fc4qua05auwb3674vfr0b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (O) &lt;hitotsu&gt;&lt;yane&gt;&lt;no&gt;&lt;shita&gt;2
       u+3072 u+3068 u+3064 u+5C4B u+6839 u+306E u+4E0B u+0032
       Punycode: 2-u9tlzr9756bt3uc0v
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (P) Maji&lt;de&gt;Koi&lt;suru&gt;5&lt;byou&gt;&lt;mae&gt;
       U+004D u+0061 u+006A u+0069 u+3067 U+004B u+006F u+0069 u+3059
       u+308B u+0035 u+79D2 u+524D
       Punycode: MajiKoi5-783gue6qz075azm5e
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (Q) &lt;pafii&gt;de&lt;runba&gt;
       u+30D1 u+30D5 u+30A3 u+30FC u+0064 u+0065 u+30EB u+30F3 u+30D0
       Punycode: de-jg4avhby1noc0d
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (R) &lt;sono&gt;&lt;supiido&gt;&lt;de&gt;
       u+305D u+306E u+30B9 u+30D4 u+30FC u+30C9 u+3067
       Punycode: d9juau41awczczp
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last example is an ASCII string that breaks the existing rules for host name labels. (It is not a realistic example for IDNA, because IDNA never encodes pure ASCII labels.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の例は、ホスト名ラベルの既存のルールを破るASCII文字列です。（IDNAは純粋なASCIIラベルをエンコードしないため、IDNAの現実的な例ではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (S) -&gt; $1.00 &lt;-
       u+002D u+003E u+0020 u+0024 u+0031 u+002E u+0030 u+0030 u+0020
       u+003C u+002D
       Punycode: -&gt; $1.00 &lt;--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 Decoding traces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 デコードトレース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following traces, the evolving state of the decoder is shown as a sequence of hexadecimal values, representing the code points in the extended string. An asterisk appears just after the most recently inserted code point, indicating both n (the value preceeding the asterisk) and i (the position of the value just after the asterisk). Other numerical values are decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のトレースでは、デコーダーの進化する状態は、拡張された文字列のコードポイントを表す16進数のシーケンスとして表示されます。アスタリスクは、ごく最近挿入されたコードポイントの直後に表示され、N（アスタリスクの前処理値）とI（アスタリスクの直後の値の位置）の両方を示します。他の数値値は小数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding trace of example B from section 7.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1からの例Bのトレースの解読：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   n is 128, i is 0, bias is 72
   input is &#34;ihqwcrb4cv8a8dqg056pqjye&#34;
   there is no delimiter, so extended string starts empty
   delta &#34;ihq&#34; decodes to 19853
   bias becomes 21
   4E0D *
   delta &#34;wc&#34; decodes to 64
   bias becomes 20
   4E0D 4E2D *
   delta &#34;rb&#34; decodes to 37
   bias becomes 13
   4E3A * 4E0D 4E2D
   delta &#34;4c&#34; decodes to 56
   bias becomes 17
   4E3A 4E48 * 4E0D 4E2D
   delta &#34;v8a&#34; decodes to 599
   bias becomes 32
   4E3A 4EC0 * 4E48 4E0D 4E2D
   delta &#34;8d&#34; decodes to 130
   bias becomes 23
   4ED6 * 4E3A 4EC0 4E48 4E0D 4E2D
   delta &#34;qg&#34; decodes to 154
   bias becomes 25
   4ED6 4EEC * 4E3A 4EC0 4E48 4E0D 4E2D
   delta &#34;056p&#34; decodes to 46301
   bias becomes 84
   4ED6 4EEC 4E3A 4EC0 4E48 4E0D 4E2D 6587 *
   delta &#34;qjye&#34; decodes to 88531
   bias becomes 90
   4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 * 4E2D 6587
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding trace of example L from section 7.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1からの例Lのトレースの解読：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n is 128, i is 0, bias is 72 input is &#34;3B-ww4c5e180e575a65lsy2b&#34; literal portion is &#34;3B-&#34;, so extended string starts as: 0033 0042 delta &#34;ww4c&#34; decodes to 62042 bias becomes 27 0033 0042 5148 * delta &#34;5e&#34; decodes to 139 bias becomes 24 0033 0042 516B * 5148 delta &#34;180e&#34; decodes to 16683 bias becomes 67 0033 5E74 * 0042 516B 5148 delta &#34;575a&#34; decodes to 34821 bias becomes 82 0033 5E74 0042 516B 5148 751F * delta &#34;65l&#34; decodes to 14592 bias becomes 67 0033 5E74 0042 7D44 * 516B 5148 751F delta &#34;sy2b&#34; decodes to 42088 bias becomes 84 0033 5E74 0042 7D44 91D1 * 516B 5148 751F
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nは128、iは0、バイアスは72入力です。入力は「3B-WW4C5E180E575A65LSY2B &#34;リテラル部分は「3B」です。したがって、拡張文字列は次のように開始されます。5e &#34;139のバイアスへのデコードは24 0033 0042 516B * 5148 DELTA&#34; 180E &#34;DECODE TO 16683になります67 0033 5E74 * 0042 516B 5148 DELTA&#34; 575A &#34;TO 34821 BIASになります。14592までのデコードバイアスは67 0033 5E74 0042 7D44 * 516B 5148 751F DELTA &#34;SY2B&#34; 42088へのデコードは84 0033 5E74 0042 7D44 91D1 * 516B 5148 751FF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3 Encoding traces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3 トレースのエンコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following traces, code point values are hexadecimal, while other numerical values are decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のトレースでは、コードポイント値は16進数であり、他の数値値は10進数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding trace of example B from section 7.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1からの例Bのトレースのエンコード：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bias is 72 input is: 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 4E2D 6587 there are no basic code points, so no literal portion next code point to insert is 4E0D needed delta is 19853, encodes as &#34;ihq&#34; bias becomes 21 next code point to insert is 4E2D needed delta is 64, encodes as &#34;wc&#34; bias becomes 20 next code point to insert is 4E3A needed delta is 37, encodes as &#34;rb&#34; bias becomes 13 next code point to insert is 4E48 needed delta is 56, encodes as &#34;4c&#34; bias becomes 17 next code point to insert is 4EC0 needed delta is 599, encodes as &#34;v8a&#34; bias becomes 32 next code point to insert is 4ED6 needed delta is 130, encodes as &#34;8d&#34; bias becomes 23 next code point to insert is 4EEC needed delta is 154, encodes as &#34;qg&#34; bias becomes 25 next code point to insert is 6587 needed delta is 46301, encodes as &#34;056p&#34; bias becomes 84 next code point to insert is 8BF4 needed delta is 88531, encodes as &#34;qjye&#34; bias becomes 90 output is &#34;ihqwcrb4cv8a8dqg056pqjye&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイアスは72入力です。4ED64EEC4EEC 4EEC 4EC0 4E48 4E0D 8BF4 4E2D 6587基本的なコードポイントはありません。INSERT IS 4E2D必要なデルタは64、「WC」バイアスが20になるとエンコードは20次のコードポイントが挿入されます4E3A必要なデルタは37、「RB」バイアスが13になるとエンコードは13次のコードポイントを挿入する必要があります4E48必要なデルタは56、エンコードとしてエンコード「4c」バイアスは17になります挿入するコードポイントは4ec0必要なコードポイントが599である必要があり、「V8a」バイアスが挿入される32次のコードポイントは4ed6必要なデルタです。IS IS 4EECが必要なデルタは154で、「QG」バイアスが25になるようにエンコードは25次のコードポイントを挿入します6587必要なデルタは46301、「056p」バイアスが84次のコードポイントになるため、挿入される必要があります。「Qjye」バイアスは90出力になります「ihqwcrb4cv8a8dqg056pqjye」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding trace of example L from section 7.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1からの例Lのトレースをエンコードする：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bias is 72 input is: 0033 5E74 0042 7D44 91D1 516B 5148 751F basic code points (0033, 0042) are copied to literal portion: &#34;3B-&#34; next code point to insert is 5148 needed delta is 62042, encodes as &#34;ww4c&#34; bias becomes 27 next code point to insert is 516B needed delta is 139, encodes as &#34;5e&#34; bias becomes 24 next code point to insert is 5E74 needed delta is 16683, encodes as &#34;180e&#34; bias becomes 67 next code point to insert is 751F needed delta is 34821, encodes as &#34;575a&#34; bias becomes 82 next code point to insert is 7D44 needed delta is 14592, encodes as &#34;65l&#34; bias becomes 67 next code point to insert is 91D1 needed delta is 42088, encodes as &#34;sy2b&#34; bias becomes 84 output is &#34;3B-ww4c5e180e575a65lsy2b&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイアスは72入力です：0033 5E74 0042 7D44 91D1 516B 5148 751F基本コードポイント（0033、0042）はリテラル部分にコピーされます： &#34;3b-&#34;次のコードポイントは5148必要なデルタです。挿入する27次のコードポイントは516B必要なデルタは139、「5E」バイアスが24になるアックアセンズ24次のコードポイントIS 5E74必要なデルタは16683、エンコード「180E」バイアスは67次のコードポイントが挿入デルタは34821で、「575a」バイアスが82になるとエンコードは82次のコードポイントを挿入します7d44必要なデルタは14592、「65L」バイアスは67次のコードポイントが挿入されます91d1必要なデルタは42088、「sy2b」バイアスとしてエンコードする必要があります84出力になります「3B-WW4C5E180E575A65LSY2B」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Users expect each domain name in DNS to be controlled by a single authority. If a Unicode string intended for use as a domain label could map to multiple ACE labels, then an internationalized domain name could map to multiple ASCII domain names, each controlled by a different authority, some of which could be spoofs that hijack service requests intended for another. Therefore Punycode is designed so that each Unicode string has a unique encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーは、DNSの各ドメイン名が単一の当局によって制御されることを期待しています。ドメインラベルとして使用することを目的としたユニコード文字列が複数のACEラベルにマッピングできる場合、国際化されたドメイン名が複数のASCIIドメイン名にマッピングできます。それぞれが異なる権限によって制御されます。別。したがって、Punycodeは、各Unicode文字列に一意のエンコードがあるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, there can still be multiple Unicode representations of the &#34;same&#34; text, for various definitions of &#34;same&#34;. This problem is addressed to some extent by the Unicode standard under the topic of canonicalization, and this work is leveraged for domain names by Nameprep [NAMEPREP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、「同じ」のさまざまな定義に対して、「同じ」テキストの複数のユニコード表現がまだある場合があります。この問題は、標準化のトピックに基づくユニコード標準によってある程度対処されており、この作業はNamePrep [NamePrep]によってドメイン名に活用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1 Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2 Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC952] Harrenstien, K., Stahl, M. and E. Feinler, &#34;DOD Internet Host Table Specification&#34;, RFC 952, October 1985.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC952] Harrenstien、K.、Stahl、M。、およびE. Feinler、「Dod Internet Host Table Specification」、RFC 952、1985年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris, P., &#34;Domain Names - Concepts and Facilities&#34;, STD 13, RFC 1034, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris、P。、「ドメイン名 - 概念と施設」、STD 13、RFC 1034、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDNA] Faltstrom, P., Hoffman, P. and A. Costello, &#34;Internationalizing Domain Names in Applications (IDNA)&#34;, RFC 3490, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDNA] Faltstrom、P.、Hoffman、P。and A. Costello、「アプリケーションの国際化ドメイン名（IDNA）」、RFC 3490、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NAMEPREP] Hoffman, P. and M. Blanchet, &#34;Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)&#34;, RFC 3491, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Nameprep] Hoffman、P。and M. Blanchet、「NamePrep：国際化ドメイン名のStringPrepプロファイル（IDN）」、RFC 3491、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASCII] Cerf, V., &#34;ASCII format for Network Interchange&#34;, RFC 20, October 1969.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASCII] Cerf、V。、「ネットワークインターチェンジ用ASCII形式」、RFC 20、1969年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PROVINCIAL] Kaplan, M., &#34;The &#39;anyone can be provincial!&#39; page&#34;, http://www.trigeminal.com/samples/provincial.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[州]カプラン、M。、「「誰でも地方！」Page &#34;、http://www.trigeminal.com/samples/provincial.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] The Unicode Consortium, &#34;The Unicode Standard&#34;, http://www.unicode.org/unicode/standard/standard.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode] Unicode Consortium、「Unicode Standard」、http://www.unicode.org/unicode/standard/standard.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A. Mixed-case annotation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.混合ケースアノテーション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to use Punycode to represent case-insensitive strings, higher layers need to case-fold the strings prior to Punycode encoding. The encoded string can use mixed case as an annotation telling how to convert the folded string into a mixed-case string for display purposes. Note, however, that mixed-case annotation is not used by the ToASCII and ToUnicode operations specified in [IDNA], and therefore implementors of IDNA can disregard this appendix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パニコードを使用して症例感受性の文字列を表すためには、高層がパニコードエンコードの前に文字列をケース折る必要があります。エンコードされた文字列は、折り畳まれた文字列をディスプレイの目的で混合ケースの文字列に変換する方法を示す注釈として混合ケースを使用できます。ただし、[IDNA]で指定されたToasciiおよびTounicode操作では混合ケースの注釈が使用されていないため、IDNAの実装者はこの付録を無視できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Basic code points can use mixed case directly, because the decoder copies them verbatim, leaving lowercase code points lowercase, and leaving uppercase code points uppercase. Each non-basic code point is represented by a delta, which is represented by a sequence of basic code points, the last of which provides the annotation. If it is uppercase, it is a suggestion to map the non-basic code point to uppercase (if possible); if it is lowercase, it is a suggestion to map the non-basic code point to lowercase (if possible).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダーが逐語的にコピーし、小文字コードポイント小文字を残し、大文字のコードポイント大文字を残すため、基本的なコードポイントは混合ケースを直接使用できます。各非基準コードポイントは、基本コードポイントのシーケンスで表されるデルタで表されます。最後のコードポイントは注釈を提供します。大文字の場合、非基本コードポイントを大文字にマッピングすることは提案です（可能であれば）。小文字の場合、非基本コードポイントを小文字にマッピングすることは提案です（可能であれば）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These annotations do not alter the code points returned by decoders; the annotations are returned separately, for the caller to use or ignore. Encoders can accept annotations in addition to code points, but the annotations do not alter the output, except to influence the uppercase/lowercase form of ASCII letters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの注釈は、デコーダによって返されるコードポイントを変更しません。発信者が使用または無視するように、注釈は個別に返されます。エンコーダーはコードポイントに加えて注釈を受け入れることができますが、注釈はASCII文字の大文字/小文字の形式に影響を与えることを除いて出力を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode encoders and decoders need not support these annotations, and higher layers need not use them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycodeエンコーダーとデコーダーはこれらの注釈をサポートする必要はなく、高層はそれらを使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B. Disclaimer and license
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.免責事項とライセンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regarding this entire document or any portion of it (including the pseudocode and C code), the author makes no guarantees and is not responsible for any damage resulting from its use. The author grants irrevocable permission to anyone to use, modify, and distribute it in any way that does not diminish the rights of anyone else to use, modify, and distribute it, provided that redistributed derivative works do not contain misleading author or version information. Derivative works need not be licensed under similar terms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメント全体またはその一部（PseudocodeおよびC Codeを含む）に関して、著者は保証せず、その使用に起因する損害について責任を負いません。著者は、再配分されたデリバティブ作業に誤解を招く著者またはバージョン情報が含まれていない限り、他の人がそれを使用、変更、および配布する権利を減少させない方法で、使用、変更、および配布する人に取消不能の許可を与えます。デリバティブ作業は、同様の条件でライセンスされる必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
C. Punycode sample implementation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
C.パニコードサンプルの実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
punycode.c from RFC 3492
http://www.nicemice.net/idn/
Adam M. Costello
http://www.nicemice.net/amc/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
This is ANSI C code (C89) implementing Punycode (RFC 3492).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これは、Punycode（RFC 3492）を実装するANSI Cコード（C89）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
*/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
*/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/************************************************************/
/* Public interface (would normally go in its own .h file): */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#include &lt;limits.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
enum punycode_status {
  punycode_success,
  punycode_bad_input,   /* Input is invalid.                       */
  punycode_big_output,  /* Output would exceed the space provided. */
  punycode_overflow     /* Input needs wider integers to process.  */
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#if UINT_MAX &gt;= (1 &lt;&lt; 26) - 1
typedef unsigned int punycode_uint;
#else
typedef unsigned long punycode_uint;
#endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_encode( punycode_uint input_length, const punycode_uint input[], const unsigned char case_flags[], punycode_uint *output_length, char output[] );
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_encode（punycode_uint input_length、const punycode_uint input []、const unsigned char case_flags []、punycode_uint *output_length、char output []）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* punycode_encode() converts Unicode to Punycode.  The input     */
    /* is represented as an array of Unicode code points (not code    */
    /* units; surrogate pairs are not allowed), and the output        */
    /* will be represented as an array of ASCII code points.  The     */
    /* output string is *not* null-terminated; it will contain        */
    /* zeros if and only if the input contains zeros.  (Of course     */
    /* the caller can leave room for a terminator and add one if      */
    /* needed.)  The input_length is the number of code points in     */
    /* the input.  The output_length is an in/out argument: the       */
    /* caller passes in the maximum number of code points that it     */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* can receive, and on successful return it will contain the      */
    /* number of code points actually output.  The case_flags array   */
    /* holds input_length boolean values, where nonzero suggests that */
    /* the corresponding Unicode character be forced to uppercase     */
    /* after being decoded (if possible), and zero suggests that      */
    /* it be forced to lowercase (if possible).  ASCII code points    */
    /* are encoded literally, except that ASCII letters are forced    */
    /* to uppercase or lowercase according to the corresponding       */
    /* uppercase flags.  If case_flags is a null pointer then ASCII   */
    /* letters are left as they are, and other code points are        */
    /* treated as if their uppercase flags were zero.  The return     */
    /* value can be any of the punycode_status values defined above   */
    /* except punycode_bad_input; if not punycode_success, then       */
    /* output_size and output might contain garbage.                  */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_decode( punycode_uint input_length, const char input[], punycode_uint *output_length, punycode_uint output[], unsigned char case_flags[] );
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_decode（punycode_uint input_length、const char input []、punycode_uint *output_length、punycode_uint output []、unsigned char case_flags []）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* punycode_decode() converts Punycode to Unicode.  The input is  */
    /* represented as an array of ASCII code points, and the output   */
    /* will be represented as an array of Unicode code points.  The   */
    /* input_length is the number of code points in the input.  The   */
    /* output_length is an in/out argument: the caller passes in      */
    /* the maximum number of code points that it can receive, and     */
    /* on successful return it will contain the actual number of      */
    /* code points output.  The case_flags array needs room for at    */
    /* least output_length values, or it can be a null pointer if the */
    /* case information is not needed.  A nonzero flag suggests that  */
    /* the corresponding Unicode character be forced to uppercase     */
    /* by the caller (if possible), while zero suggests that it be    */
    /* forced to lowercase (if possible).  ASCII code points are      */
    /* output already in the proper case, but their flags will be set */
    /* appropriately so that applying the flags would be harmless.    */
    /* The return value can be any of the punycode_status values      */
    /* defined above; if not punycode_success, then output_length,    */
    /* output, and case_flags might contain garbage.  On success, the */
    /* decoder will never need to write an output_length greater than */
    /* input_length, because of how the encoding is defined.          */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**********************************************************/
/* Implementation (would normally go in its own .c file): */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Bootstring parameters for Punycode ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
enum { base = 36, tmin = 1, tmax = 26, skew = 38, damp = 700,
       initial_bias = 72, initial_n = 0x80, delimiter = 0x2D };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* basic(cp) tests whether cp is a basic code point: */
#define basic(cp) ((punycode_uint)(cp) &lt; 0x80)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* delim(cp) tests whether cp is a delimiter: */
#define delim(cp) ((cp) == delimiter)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* decode_digit(cp) returns the numeric value of a basic code */
/* point (for use in representing integers) in the range 0 to */
/* base-1, or base if cp is does not represent a value.       */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static punycode_uint decode_digit(punycode_uint cp)
{
  return  cp - 48 &lt; 10 ? cp - 22 :  cp - 65 &lt; 26 ? cp - 65 :
          cp - 97 &lt; 26 ? cp - 97 :  base;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* encode_digit(d,flag) returns the basic code point whose value      */
/* (when used for representing integers) is d, which needs to be in   */
/* the range 0 to base-1.  The lowercase form is used unless flag is  */
/* nonzero, in which case the uppercase form is used.  The behavior   */
/* is undefined if flag is nonzero and digit d has no uppercase form. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static char encode_digit(punycode_uint d, int flag)
{
  return d + 22 + 75 * (d &lt; 26) - ((flag != 0) &lt;&lt; 5);
  /*  0..25 map to ASCII a..z or A..Z */
  /* 26..35 map to ASCII 0..9         */
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* flagged(bcp) tests whether a basic code point is flagged */
/* (uppercase).  The behavior is undefined if bcp is not a  */
/* basic code point.                                        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define flagged(bcp) ((punycode_uint)(bcp) - 65 &lt; 26)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* encode_basic(bcp,flag) forces a basic code point to lowercase */
/* if flag is zero, uppercase if flag is nonzero, and returns    */
/* the resulting code point.  The code point is unchanged if it  */
/* is caseless.  The behavior is undefined if bcp is not a basic */
/* code point.                                                   */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static char encode_basic(punycode_uint bcp, int flag) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static char ecode_basic（punycode_uint bcp、int flag）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  bcp -= (bcp - 97 &lt; 26) &lt;&lt; 5;
  return bcp + ((!flag &amp;&amp; (bcp - 65 &lt; 26)) &lt;&lt; 5);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Platform-specific constants ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* maxint is the maximum value of a punycode_uint variable: */
static const punycode_uint maxint = -1;
/* Because maxint is unsigned, -1 becomes the maximum value. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Bias adaptation function ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static punycode_uint adapt( punycode_uint delta, punycode_uint numpoints, int firsttime ) { punycode_uint k;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static punycode_uint adapt（punycode_uint delta、punycode_uint numpoints、int firsttime）{punycode_uint k;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  delta = firsttime ? delta / damp : delta &gt;&gt; 1;
  /* delta &gt;&gt; 1 is a faster way of doing delta / 2 */
  delta += delta / numpoints;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (k = 0;  delta &gt; ((base - tmin) * tmax) / 2;  k += base) {
    delta /= base - tmin;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  return k + (base - tmin + 1) * delta / (delta + skew);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Main encode function ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_encode( punycode_uint input_length, const punycode_uint input[], const unsigned char case_flags[], punycode_uint *output_length, char output[] ) { punycode_uint n, delta, h, b, out, max_out, bias, j, m, q, k, t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_encode（punycode_uint input_length、const punycode_uint input []、const unsigned char case_flags []、punycode_uint *output_length、char output []）{punycode_uint n、delta、h、out out、max_out、j、m、m、q、m、m、m、Q、K、T;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Initialize the state: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  n = initial_n;
  delta = out = 0;
  max_out = *output_length;
  bias = initial_bias;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Handle the basic code points: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (j = 0;  j &lt; input_length;  ++j) {
    if (basic(input[j])) {
      if (max_out - out &lt; 2) return punycode_big_output;
      output[out++] =
        case_flags ?  encode_basic(input[j], case_flags[j]) : input[j];
    }
    /* else if (input[j] &lt; n) return punycode_bad_input; */
    /* (not needed for Punycode with unsigned code points) */
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  h = b = out;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* h is the number of code points that have been handled, b is the  */
  /* number of basic code points, and out is the number of characters */
  /* that have been output.                                           */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (b &gt; 0) output[out++] = delimiter;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Main encoding loop: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  while (h &lt; input_length) {
    /* All non-basic code points &lt; n have been     */
    /* handled already.  Find the next larger one: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (m = maxint, j = 0;  j &lt; input_length;  ++j) {
      /* if (basic(input[j])) continue; */
      /* (not needed for Punycode) */
      if (input[j] &gt;= n &amp;&amp; input[j] &lt; m) m = input[j];
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Increase delta enough to advance the decoder&#39;s    */
    /* &lt;n,i&gt; state to &lt;m,0&gt;, but guard against overflow: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (m - n &gt; (maxint - delta) / (h + 1)) return punycode_overflow;
    delta += (m - n) * (h + 1);
    n = m;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (j = 0;  j &lt; input_length;  ++j) {
      /* Punycode does not need to check whether input[j] is basic: */
      if (input[j] &lt; n /* || basic(input[j]) */ ) {
        if (++delta == 0) return punycode_overflow;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (input[j] == n) {
        /* Represent delta as a generalized variable-length integer: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        for (q = delta, k = base;  ;  k += base) {
          if (out &gt;= max_out) return punycode_big_output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          t = k &lt;= bias /* + tmin */ ? tmin :     /* +tmin not needed */
              k &gt;= bias + tmax ? tmax : k - bias;
          if (q &lt; t) break;
          output[out++] = encode_digit(t + (q - t) % (base - t), 0);
          q = (q - t) / (base - t);
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        output[out++] = encode_digit(q, case_flags &amp;&amp; case_flags[j]);
        bias = adapt(delta, h + 1, h == b);
        delta = 0;
        ++h;
      }
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ++delta, ++n;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  *output_length = out;
  return punycode_success;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Main decode function ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_decode( punycode_uint input_length, const char input[], punycode_uint *output_length, punycode_uint output[], unsigned char case_flags[] ) { punycode_uint n, out, i, max_out, bias, b, j, in, oldi, w, k, digit, t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_decode（punycode_uint input_length、const char input []、punycode_uint *output_length、punycode_uint output []、unsigned char case_flags []）{punycode_uint n、out、i、max_out、bias、b、j、oldi、K、桁、T;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Initialize the state: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  n = initial_n;
  out = i = 0;
  max_out = *output_length;
  bias = initial_bias;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Handle the basic code points:  Let b be the number of input code */
  /* points before the last delimiter, or 0 if there is none, then    */
  /* copy the first b code points to the output.                      */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (b = j = 0;  j &lt; input_length;  ++j) if (delim(input[j])) b = j;
  if (b &gt; max_out) return punycode_big_output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (j = 0;  j &lt; b;  ++j) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (case_flags) case_flags[out] = flagged(input[j]);
    if (!basic(input[j])) return punycode_bad_input;
    output[out++] = input[j];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Main decoding loop:  Start just after the last delimiter if any  */
  /* basic code points were copied; start at the beginning otherwise. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (in = b &gt; 0 ? b + 1 : 0;  in &lt; input_length;  ++out) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* in is the index of the next character to be consumed, and */
    /* out is the number of code points in the output array.     */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Decode a generalized variable-length integer into delta,  */
    /* which gets added to i.  The overflow checking is easier   */
    /* if we increase i as we go, then subtract off its starting */
    /* value at the end to obtain delta.                         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (oldi = i, w = 1, k = base;  ;  k += base) {
      if (in &gt;= input_length) return punycode_bad_input;
      digit = decode_digit(input[in++]);
      if (digit &gt;= base) return punycode_bad_input;
      if (digit &gt; (maxint - i) / w) return punycode_overflow;
      i += digit * w;
      t = k &lt;= bias /* + tmin */ ? tmin :     /* +tmin not needed */
          k &gt;= bias + tmax ? tmax : k - bias;
      if (digit &lt; t) break;
      if (w &gt; maxint / (base - t)) return punycode_overflow;
      w *= (base - t);
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    bias = adapt(i - oldi, out + 1, oldi == 0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* i was supposed to wrap around from out+1 to 0,   */
    /* incrementing n each time, so we&#39;ll fix that now: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (i / (out + 1) &gt; maxint - n) return punycode_overflow;
    n += i / (out + 1);
    i %= (out + 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Insert n at position i of the output: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* not needed for Punycode: */
    /* if (decode_digit(n) &lt;= base) return punycode_invalid_input; */
    if (out &gt;= max_out) return punycode_big_output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (case_flags) {
      memmove(case_flags + i + 1, case_flags + i, out - i);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Case of last character determines uppercase flag: */
      case_flags[i] = flagged(input[in - 1]);
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    memmove(output + i + 1, output + i, (out - i) * sizeof *output);
    output[i++] = n;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  *output_length = out;
  return punycode_success;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/******************************************************************/
/* Wrapper for testing (would normally go in a separate .c file): */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* For testing, we&#39;ll just set some compile-time limits rather than */
/* use malloc(), and set a compile-time option rather than using a  */
/* command-line option.                                             */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
enum {
  unicode_max_length = 256,
  ace_max_length = 256
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static void usage(char **argv)
{
  fprintf(stderr,
    &#34;\n&#34;
    &#34;%s -e reads code points and writes a Punycode string.\n&#34;
    &#34;%s -d reads a Punycode string and writes code points.\n&#34;
    &#34;\n&#34;
    &#34;Input and output are plain text in the native character set.\n&#34;
    &#34;Code points are in the form u+hex separated by whitespace.\n&#34;
    &#34;Although the specification allows Punycode strings to contain\n&#34;
    &#34;any characters from the ASCII repertoire, this test code\n&#34;
    &#34;supports only the printable characters, and needs the Punycode\n&#34;
    &#34;string to be followed by a newline.\n&#34;
    &#34;The case of the u in u+hex is the force-to-uppercase flag.\n&#34;
    , argv[0], argv[0]);
  exit(EXIT_FAILURE);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static void fail(const char *msg)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
静的ボイド障害（const char *msg）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
{
  fputs(msg,stderr);
  exit(EXIT_FAILURE);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static const char too_big[] =
  &#34;input or output is too large, recompile with larger limits\n&#34;;
static const char invalid_input[] = &#34;invalid input\n&#34;;
static const char overflow[] = &#34;arithmetic overflow\n&#34;;
static const char io_error[] = &#34;I/O error\n&#34;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* The following string is used to convert printable */
/* characters between ASCII and the native charset:  */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static const char print_ascii[] =
  &#34;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#34;
  &#34;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#34;
  &#34; !\&#34;#$%&amp;&#39;()*+,-./&#34;
  &#34;0123456789:;&lt;=&gt;?&#34;
  &#34;@ABCDEFGHIJKLMNO&#34;
  &#34;PQRSTUVWXYZ[\\]^_&#34;
  &#34;`abcdefghijklmno&#34;
  &#34;pqrstuvwxyz{|}~\n&#34;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
int main(int argc, char **argv)
{
  enum punycode_status status;
  int r;
  unsigned int input_length, output_length, j;
  unsigned char case_flags[unicode_max_length];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (argc != 2) usage(argv);
  if (argv[1][0] != &#39;-&#39;) usage(argv);
  if (argv[1][2] != 0) usage(argv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (argv[1][1] == &#39;e&#39;) {
    punycode_uint input[unicode_max_length];
    unsigned long codept;
    char output[ace_max_length+1], uplus[3];
    int c;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Read the input code points: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
input_length = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
input_length = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (;;) {
      r = scanf(&#34;%2s%lx&#34;, uplus, &amp;codept);
      if (ferror(stdin)) fail(io_error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (r == EOF || r == 0) break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (r != 2 || uplus[1] != &#39;+&#39; || codept &gt; (punycode_uint)-1) {
        fail(invalid_input);
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (input_length == unicode_max_length) fail(too_big);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (uplus[0] == &#39;u&#39;) case_flags[input_length] = 0;
      else if (uplus[0] == &#39;U&#39;) case_flags[input_length] = 1;
      else fail(invalid_input);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      input[input_length++] = codept;
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Encode: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    output_length = ace_max_length;
    status = punycode_encode(input_length, input, case_flags,
                             &amp;output_length, output);
    if (status == punycode_bad_input) fail(invalid_input);
    if (status == punycode_big_output) fail(too_big);
    if (status == punycode_overflow) fail(overflow);
    assert(status == punycode_success);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Convert to native charset and output: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (j = 0;  j &lt; output_length;  ++j) {
      c = output[j];
      assert(c &gt;= 0 &amp;&amp; c &lt;= 127);
      if (print_ascii[c] == 0) fail(invalid_input);
      output[j] = print_ascii[c];
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    output[j] = 0;
    r = puts(output);
    if (r == EOF) fail(io_error);
    return EXIT_SUCCESS;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (argv[1][1] == &#39;d&#39;) {
    char input[ace_max_length+2], *p, *pp;
    punycode_uint output[unicode_max_length];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Read the Punycode input string and convert to ASCII: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    fgets(input, ace_max_length+2, stdin);
    if (ferror(stdin)) fail(io_error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (feof(stdin)) fail(invalid_input);
    input_length = strlen(input) - 1;
    if (input[input_length] != &#39;\n&#39;) fail(too_big);
    input[input_length] = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (p = input;  *p != 0;  ++p) {
      pp = strchr(print_ascii, *p);
      if (pp == 0) fail(invalid_input);
      *p = pp - print_ascii;
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Decode: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    output_length = unicode_max_length;
    status = punycode_decode(input_length, input, &amp;output_length,
                             output, case_flags);
    if (status == punycode_bad_input) fail(invalid_input);
    if (status == punycode_big_output) fail(too_big);
    if (status == punycode_overflow) fail(overflow);
    assert(status == punycode_success);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Output the result: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (j = 0;  j &lt; output_length;  ++j) {
      r = printf(&#34;%s+%04lX\n&#34;,
                 case_flags[j] ? &#34;U&#34; : &#34;u&#34;,
                 (unsigned long) output[j] );
      if (r &lt; 0) fail(io_error);
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
 return EXIT_SUCCESS; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
exit_successを返します。}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  usage(argv);
  return EXIT_SUCCESS;  /* not reached, but quiets compiler warning */
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者の連絡先
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Adam M. Costello
   University of California, Berkeley
   http://www.nicemice.net/amc/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントと翻訳は他の人にコピーされて提供される場合があり、それについてコメントまたは説明するか、その実装を支援する派生作品は、いかなる種類の制限なしに、準備、コピー、公開、配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準のプロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は現在、インターネット協会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
