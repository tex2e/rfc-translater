<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 4418 - UMAC: Message Authentication Code using Universal Hashing 日本語訳</title>
  <meta name="description" content="RFC 4418は、UMAC（Universal Hashingを使用したメッセージ認証コード）に関する規格です。UMACは、効率的でセキュアなメッセージ認証を提供するために設計されています。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4418</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc4418">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 4418 - UMAC: Message Authentication Code using Universal Hashing 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc4418">
            https://datatracker.ietf.org/doc/html/rfc4418
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 4418 - UMAC：ユニバーサルハッシュを使用したメッセージ認証コード</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成＆有志による翻訳・編集</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 4418は、UMAC（Universal Hashingを使用したメッセージ認証コード）に関する規格です。UMACは、効率的でセキュアなメッセージ認証を提供するために設計されています。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                    T. Krovetz, Ed.
Request for Comments: 4418                                CSU Sacramento
Category: Informational                                       March 2006
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
UMAC: Message Authentication Code using Universal Hashing
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
UMAC：ユニバーサルハッシュを使用したメッセージ認証コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2006）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification describes how to generate an authentication tag using the UMAC message authentication algorithm. UMAC is designed to be very fast to compute in software on contemporary uniprocessors. Measured speeds are as low as one cycle per byte. UMAC relies on addition of 32-bit and 64-bit numbers and multiplication of 32-bit numbers, operations well-supported by contemporary machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、UMACメッセージ認証アルゴリズムを用いて認証タグを生成する方法を規定しています。UMACは、現代のユニプロセッサ上でソフトウェアによる計算が非常に高速になるように設計されています。測定された速度は1バイトあたり1サイクルと非常に低速です。UMACは、32ビットおよび64ビットの数値の加算、および32ビットの数値の乗算に依存しており、これらの演算は現代のマシンで十分にサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To generate the authentication tag on a given message, a &#34;universal&#34; hash function is applied to the message and key to produce a short, fixed-length hash value, and this hash value is then xor&#39;ed with a key-derived pseudorandom pad. UMAC enjoys a rigorous security analysis, and its only internal &#34;cryptographic&#34; component is a block cipher used to generate the pseudorandom pads and internal key material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のメッセージの認証タグを生成するには、メッセージと鍵に「ユニバーサル」ハッシュ関数を適用して短い固定長のハッシュ値を生成します。このハッシュ値は、鍵から導出された疑似ランダムパッドと排他的論理和（XOR）演算されます。UMACは厳格なセキュリティ分析を備えており、内部の「暗号化」コンポーネントは、疑似ランダムパッドと内部鍵マテリアルを生成するために使用されるブロック暗号のみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................3
   2. Notation and Basic Operations ...................................4
      2.1. Operations on strings ......................................4
      2.2. Operations on Integers .....................................5
      2.3. String-Integer Conversion Operations .......................6
      2.4. Mathematical Operations on Strings .........................6
      2.5. ENDIAN-SWAP: Adjusting Endian Orientation ..................6
           2.5.1. ENDIAN-SWAP Algorithm ...............................6
   3. Key- and Pad-Derivation Functions ...............................7
      3.1. Block Cipher Choice ........................................7
      3.2. KDF: Key-Derivation Function ...............................8
           3.2.1. KDF Algorithm .......................................8
      3.3. PDF: Pad-Derivation Function ...............................8
           3.3.1. PDF Algorithm .......................................9
   4. UMAC Tag Generation ............................................10
      4.1. UMAC Algorithm ............................................10
      4.2. UMAC-32, UMAC-64, UMAC-96, and UMAC-128 ...................10
   5. UHASH: Universal Hash Function .................................10
      5.1. UHASH Algorithm ...........................................11
      5.2. L1-HASH: First-Layer Hash .................................12
           5.2.1. L1-HASH Algorithm ..................................12
           5.2.2. NH Algorithm .......................................13
      5.3. L2-HASH: Second-Layer Hash ................................14
           5.3.1. L2-HASH Algorithm ..................................14
           5.3.2. POLY Algorithm .....................................15
      5.4. L3-HASH: Third-Layer Hash .................................16
           5.4.1. L3-HASH Algorithm ..................................16
   6. Security Considerations ........................................17
      6.1. Resistance to Cryptanalysis ...............................17
      6.2. Tag Lengths and Forging Probability .......................17
      6.3. Nonce Considerations ......................................19
      6.4. Replay Attacks ............................................20
      6.5. Tag-Prefix Verification ...................................21
      6.6. Side-Channel Attacks ......................................21
   7. Acknowledgements ...............................................21
   Appendix. Test Vectors ............................................22
   References ........................................................24
      Normative References ...........................................24
      Informative References .........................................24
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMAC is a message authentication code (MAC) algorithm designed for high performance. It is backed by a rigorous formal analysis, and there are no intellectual property claims made by any of the authors to any ideas used in its design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACは、高性能のために設計されたメッセージ認証コード（MAC）アルゴリズムです。これは、厳格な正式な分析に裏付けられており、そのデザインで使用されているアイデアに対して著者のいずれも行われた知的財産の主張はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMAC is a MAC in the style of Wegman and Carter [4, 7]. A fast &#34;universal&#34; hash function is used to hash an input message M into a short string. This short string is then masked by xor&#39;ing with a pseudorandom pad, resulting in the UMAC tag. Security depends on the sender and receiver sharing a randomly-chosen secret hash function and pseudorandom pad. This is achieved by using keyed hash function H and pseudorandom function F. A tag is generated by performing the computation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACは、WegmanとCarterのスタイルのMacです[4、7]。高速な「ユニバーサル」ハッシュ関数を使用して、入力メッセージmを短い文字列にハッシュします。この短い文字列は、擬似ランダムパッドでXorをマスクし、UMACタグになります。セキュリティは、ランダムに選択された秘密のハッシュ関数と擬似ランダムパッドを共有する送信者と受信機に依存します。これは、キー付きハッシュ関数Hと擬似ランダム関数Fを使用することで実現されます。タグは、計算を実行することで生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Tag = H_K1(M) xor F_K2(Nonce)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where K1 and K2 are secret random keys shared by sender and receiver, and Nonce is a value that changes with each generated tag. The receiver needs to know which nonce was used by the sender, so some method of synchronizing nonces needs to be used. This can be done by explicitly sending the nonce along with the message and tag, or agreeing upon the use of some other non-repeating value such as a sequence number. The nonce need not be kept secret, but care needs to be taken to ensure that, over the lifetime of a UMAC key, a different nonce is used with each message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、K1とK2は送信者と受信機が共有する秘密のランダムキーであり、NonCEは各生成されたタグで変化する値です。受信者は、送信者がどの非CEを使用しているかを知る必要があるため、Nonceを同期する方法を使用する必要があります。これは、メッセージとタグとともにNonceを明示的に送信すること、またはシーケンス番号などの他の非反復値の使用に同意することで実行できます。ノンスは秘密にする必要はありませんが、UMACキーの生涯にわたって、各メッセージで異なるノンスが使用されることを保証するために注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMAC uses a keyed function, called UHASH (also specified in this document), as the keyed hash function H and uses a pseudorandom function F whose default implementation uses the Advanced Encryption Standard (AES) algorithm. UMAC is designed to produce 32-, 64-, 96-, or 128-bit tags, depending on the desired security level. The theory of Wegman-Carter MACs and the analysis of UMAC show that if one &#34;instantiates&#34; UMAC with truly random keys and pads then the probability that an attacker (even a computationally unbounded one) produces a correct tag for any message of its choosing is no more than 1/2^30, 1/2^60, 1/2^90, or 1/2^120 if the tags output by UMAC are of length 32, 64, 96, or 128 bits, respectively (here the symbol ^ represents exponentiation). When an attacker makes N forgery attempts, the probability of getting one or more tags right increases linearly to at most N/2^30, N/2^60, N/2^90, or N/2^120. In a real implementation of UMAC, using AES to produce keys and pads, the forgery probabilities listed above increase by a small amount related to the security of AES. As long as AES is secure, this small additive term is insignificant for any practical attack. See Section 6.2 for more details. Analysis relevant to UMAC security is in [3, 6].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACは、UHASH（このドキュメントでも指定されている）と呼ばれるキー付き関数を使用して、キー付きハッシュ関数Hとして使用し、デフォルトの実装が高度な暗号化標準（AES）アルゴリズムを使用する擬似ランダム関数Fを使用します。UMACは、目的のセキュリティレベルに応じて、32、64-、96-、または128ビットタグを生成するように設計されています。Wegman-Carter Macの理論とUMACの分析は、真にランダムなキーとパッドを使用してUMACを「インスタンス化」すると、攻撃者（計算上未結合のものでも）が選択のメッセージの正しいタグを生成する確率があることを示しています。UMACによるタグ出力がそれぞれ長さ32、64、96、または128ビットの場合、1/2^30、1/2^60、1/2^90、または1/2^120以下（ここでシンボル ^は指数を表します）。攻撃者がN Forgeryの試みを行うと、1つ以上のタグを正しく取得する確率は、最大のn/2^30、n/2^60、n/2^90、またはn/2^120で直線的に増加します。UMACの実際の実装では、AESを使用してキーとパッドを生成すると、上記の偽造確率はAESのセキュリティに関連する少量だけ増加します。AESが安全である限り、この小さな追加項は、実際の攻撃に対しては重要ではありません。詳細については、セクション6.2を参照してください。UMACセキュリティに関連する分析は[3、6]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMAC performs best in environments where 32-bit quantities are efficiently multiplied into 64-bit results. In producing 64-bit tags on an Intel Pentium 4 using SSE2 instructions, which do two of these multiplications in parallel, UMAC processes messages at a peak rate of about one CPU cycle per byte, with the peak being achieved on messages of around four kilobytes and longer. On the Pentium III, without the use of SSE parallelism, UMAC achieves a peak of two cycles per byte. On shorter messages, UMAC still performs well: around four cycles per byte on 256-byte messages and under two cycles per byte on 1500-byte messages. The time to produce a 32-bit tag is a little more than half that needed to produce a 64-bit tag, while 96- and 128-bit tags take one-and-a-half and twice as long, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACは、32ビットの量が効率的に64ビットの結果に増加している環境で最高のパフォーマンスを発揮します。SSE2命令を使用してIntel Pentium 4で64ビットタグを生成する際に、これらの乗算のうち2つを並行してUMACを処理すると、BYTEあたり約1 CPUサイクルのピークレートでメッセージを処理します。そして長い。Pentium IIIでは、SSE並列性を使用せずに、UMACはバイトあたり2サイクルのピークを達成します。短いメッセージでは、UMACは引き続きうまく機能します。256バイトのメッセージでバイトあたり約4サイクル、1500バイトメッセージでバイトごとに2サイクル以下です。32ビットタグを作成する時間は、64ビットタグを作成するために必要な半分を少し超えていますが、96ビットと128ビットのタグはそれぞれ1.5倍、2倍の長さです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optimized source code, performance data, errata, and papers concerning UMAC can be found at http://www.cs.ucdavis.edu/~rogaway/umac/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACに関する最適化されたソースコード、パフォーマンスデータ、ERRATA、および論文は、http://www.cs.ucdavis.edu/~rogaway/umac/にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Notation-and-Basic-Operations">
2. Notation and Basic Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 表記および基本操作
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specification of UMAC involves the manipulation of both strings and numbers. String variables are denoted with an initial uppercase letter, whereas numeric variables are denoted in all lowercase. The algorithms of UMAC are denoted in all uppercase letters. Simple functions, like those for string-length and string-xor, are written in all lowercase.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACの仕様には、文字列と数字の両方の操作が含まれます。文字列変数は初期大文字で示されますが、数値変数はすべての小文字で示されます。UMACのアルゴリズムは、すべての大文字で示されています。string-lengthやstring-xorのような単純な関数は、すべての小文字で書かれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a variable is followed by an underscore (&#34;_&#34;), the underscore is intended to denote a subscript, with the subscripted expression evaluated to resolve the meaning of the variable. For example, if i=2, then M_{2 * i} refers to the variable M_4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変数の後にアンダースコア（&#34;_&#34;）が続く場合、アンダースコアは添字を表すことを意図しており、添字付きの式が評価されて変数の意味が解釈されます。例えば、i=2の場合、M_{2 * i}は変数M_4を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Operations-on-strings">
2.1. Operations on strings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 文字列の操作
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Messages to be hashed are viewed as strings of bits that get zero-padded to an appropriate byte length. Once the message is padded, all strings are viewed as strings of bytes. A &#34;byte&#34; is an 8-bit string. The following notation is used to manipulate these strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュ化されるメッセージは、適切なバイト長になるようにゼロパディングされたビット列として扱われます。メッセージがパディングされると、すべての文字列はバイト列として扱われます。「バイト」は8ビットの文字列です。これらの文字列を操作するには、以下の表記法を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
bytelength(S): The length of string S in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
bytelength(S): 文字列Sのバイト単位の長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
bitlength(S): The length of string S in bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
bitlength(S): 文字列Sのビット単位の長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
zeroes(n): The string made of n zero-bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
zeroes(n): n 個のゼロバイトで構成される文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S xor T: The string that is the bitwise exclusive-or of S and T. Strings S and T always have the same length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S xor T：S と T のビット単位の排他的論理和である文字列。文字列 S と T は常に同じ長さになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S and T: The string that is the bitwise conjunction of S and T. Strings S and T always have the same length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S and T: S と T のビット単位の結合である文字列。文字列 S と T は常に同じ長さになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S[i]: The i-th byte of the string S (indices begin at 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S[i]: 文字列Sのi番目のバイト（インデックスは1から始まります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S[i...j]: The substring of S consisting of bytes i through j.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S[i...j]: iからjまでのバイトで構成されるSの部分文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S || T: The string S concatenated with string T.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
S || T: 文字列 S と文字列 T を連結したもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
zeropad(S,n): The string S, padded with zero-bits to the nearest positive multiple of n bytes. Formally, zeropad(S,n) = S || T, where T is the shortest string of zero-bits (possibly empty) so that S || T is non-empty and 8n divides bitlength(S || T).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
zeropad(S,n): 文字列Sに、nバイトの正の倍数に最も近いゼロビットをパディングしたもの。正式には、zeropad(S,n) = S || T であり、Tはゼロビットの最短文字列（空文字列も含む）であり、S || Tは空文字列ではなく、8nでbitlength(S || T)を割り切れる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Operations-on-Integers">
2.2. Operations on Integers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 整数の操作
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standard notation is used for most mathematical operations, such as &#34;*&#34; for multiplication, &#34;+&#34; for addition and &#34;mod&#34; for modular reduction. Some less standard notations are defined here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準表記は、「乗算のための*」、追加のための「*」、モジュラー削減のための「MOD」など、ほとんどの数学操作に使用されます。ここでは、いくつかの標準表記が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a^i: The integer a raised to the i-th power.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a^i: 整数 a の i 乗。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ceil(x): The smallest integer greater than or equal to x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ceil(x): x以上の最小の整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
prime(n): The largest prime number less than 2^n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
prime(n): 2^n未満の最大の素数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prime numbers used in UMAC are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACで使用される主要な数字は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    +-----+--------------------+---------------------------------------+
    |  n  | prime(n) [Decimal] | prime(n) [Hexadecimal]                |
    +-----+--------------------+---------------------------------------+
    | 36  | 2^36  - 5          | 0x0000000F FFFFFFFB                   |
    | 64  | 2^64  - 59         | 0xFFFFFFFF FFFFFFC5                   |
    | 128 | 2^128 - 159        | 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFF61 |
    +-----+--------------------+---------------------------------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--String-Integer-Conversion-Operations">
2.3. String-Integer Conversion Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. String-Integer変換操作
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversion between strings and integers is done using the following functions. Each function treats initial bits as more significant than later ones.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文字列と整数の間の変換は、次の関数を使用して行われます。各関数は、初期ビットを後のビットよりも重要なものとして扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
bit(S,n): Returns the integer 1 if the n-th bit of the string S is 1, otherwise returns the integer 0 (indices begin at 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
bit(S,n): 文字列 S の n 番目のビットが 1 の場合、整数 1 を返します。それ以外の場合は整数 0 を返します (インデックスは 1 から始まります)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
str2uint(S): The non-negative integer whose binary representation is the string S. More formally, if S is t bits long then str2uint(S) = 2^{t-1} * bit(S,1) + 2^{t-2} * bit(S,2) + ... + 2^{1} * bit(S,t-1) + bit(S,t).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
str2uint(S): バイナリ表現が文字列 S である非負の整数。より正式には、S が t ビット長の場合、str2uint(S) = 2^{t-1} * bit(S,1) + 2^{t-2} * bit(S,2) + ... + 2^{1} * bit(S,t-1) + bit(S,t) となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
uint2str(n,i): The i-byte string S such that str2uint(S) = n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
uint2str(n,i): str2uint(S) = nとなるiバイトの文字列S。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4--Mathematical-Operations-on-Strings">
2.4. Mathematical Operations on Strings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. 文字列の数学操作
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the primary operations in UMAC is repeated application of addition and multiplication on strings. The operations &#34;+_32&#34;, &#34;+_64&#34;, and &#34;*_64&#34; are defined
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACにおける主要な演算の一つは、文字列に対する加算と乗算の繰り返しです。演算「+_32」、「+_64」、「*_64」は次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &#34;S +_32 T&#34; as uint2str(str2uint(S) + str2uint(T) mod 2^32, 4),
     &#34;S +_64 T&#34; as uint2str(str2uint(S) + str2uint(T) mod 2^64, 8), and
     &#34;S *_64 T&#34; as uint2str(str2uint(S) * str2uint(T) mod 2^64, 8).
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These operations correspond well with the addition and multiplication operations that are performed efficiently by modern computers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの演算は、現代のコンピュータによって効率的に実行される加算および乗算演算とよく一致しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-5--ENDIAN-SWAP-Adjusting-Endian-Orientation">
2.5. ENDIAN-SWAP: Adjusting Endian Orientation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. ENDIAN-SWAP：エンディアン方向の調整
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message data is read little-endian to speed tag generation on little-endian computers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージデータは、リトルエンディアンコンピューターのタグ生成をスピードアップするために、リトルエンディアンを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-5-1--ENDIAN-SWAP-Algorithm">
2.5.1. ENDIAN-SWAP Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5.1. Endian-Swapアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     S, string with length divisible by 4 bytes.
   Output:
     T, string S with each 4-byte word endian-reversed.

   Compute T using the following algorithm.

     //
     // Break S into 4-byte chunks
     //
     n = bytelength(S) / 4
     Let S_1, S_2, ..., S_n be strings of length 4 bytes
        so that S_1 || S_2 || ... || S_n = S.

     //
     // Byte-reverse each chunk, and build-up T
     //
     T = &lt;empty string&gt;
     for i = 1 to n do
       Let W_1, W_2, W_3, W_4  be bytes
          so that W_1 || W_2 || W_3 || W_4 = S_i
       SReversed_i = W_4 || W_3 || W_2 || W_1
       T = T || SReversed_i
     end for

     Return T
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Key--and-Pad-Derivation-Functions">
3. Key- and Pad-Derivation Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. キーとパッドの導出関数
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pseudorandom bits are needed internally by UHASH and at the time of tag generation. The functions listed in this section use a block cipher to generate these bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
擬似ランダムビットは、Uhashによって内部的にタグ生成時に必要です。このセクションにリストされている関数は、ブロック暗号を使用してこれらのビットを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Block-Cipher-Choice">
3.1. Block Cipher Choice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. ブロック暗号の選択
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMAC uses the services of a block cipher. The selection of a block cipher defines the following constants and functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACはブロック暗号のサービスを使用します。ブロック暗号の選択によって、以下の定数と関数が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
BLOCKLEN : The length, in bytes, of the plaintext block on which the block cipher operates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
BLOCKLEN: ブロック暗号が動作するプレーンテキスト ブロックの長さ (バイト単位)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
KEYLEN : The block cipher&#39;s key length, in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
KEYLEN: ブロック暗号のキーの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ENCIPHER(K,P) : The application of the block cipher on P (a string of BLOCKLEN bytes) using key K (a string of KEYLEN bytes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ENCIPHER(K,P) : キー K (KEYLEN バイトの文字列) を使用して、P (BLOCKLEN バイトの文字列) にブロック暗号を適用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, if AES is used with 16-byte keys, then BLOCKLEN would equal 16 (because AES employs 16-byte blocks), KEYLEN would equal 16, and ENCIPHER would refer to the AES function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、AES が 16 バイトのキーで使用される場合、BLOCKLEN は 16 になり (AES は 16 バイトのブロックを使用するため)、KEYLEN は 16 になり、ENCIPHER は AES 関数を参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless specified otherwise, AES with 128-bit keys shall be assumed to be the chosen block cipher for UMAC. Only if explicitly specified otherwise, and agreed to by communicating parties, shall some other block cipher be used. In any case, BLOCKLEN must be at least 16 and a power of two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別途指定がない限り、UMACでは128ビット鍵のAESがブロック暗号として選択されるものとします。明示的に別途指定され、通信当事者間で合意された場合にのみ、他のブロック暗号が使用されます。いずれの場合も、BLOCKLENは16以上かつ2のべき乗でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AES is defined in another document [1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AESは別のドキュメント[1]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--KDF-Key-Derivation-Function">
3.2. KDF: Key-Derivation Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. KDF：キー導出関数
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key-derivation function generates pseudorandom bits used to key the hash functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キー導出関数は、ハッシュ関数の鍵に使用される擬似ランダムビットを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--KDF-Algorithm">
3.2.1. KDF Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. KDFアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     K, string of length KEYLEN bytes.
     index, a non-negative integer less than 2^64.
     numbytes, a non-negative integer less than 2^64.
   Output:
     Y, string of length numbytes bytes.

   Compute Y using the following algorithm.

     //
     // Calculate number of block cipher iterations
     //
     n = ceil(numbytes / BLOCKLEN)
     Y = &lt;empty string&gt;

     //
     // Build Y using block cipher in a counter mode
     //
     for i = 1 to n do
       T = uint2str(index, BLOCKLEN-8) || uint2str(i, 8)
       T = ENCIPHER(K, T)
       Y = Y || T
     end for

     Y = Y[1...numbytes]

     Return Y
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--PDF-Pad-Derivation-Function">
3.3. PDF: Pad-Derivation Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. PDF：パッド導出関数
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function takes a key and a nonce and returns a pseudorandom pad for use in tag generation. A pad of length 4, 8, 12, or 16 bytes can be generated. Notice that pads generated using nonces that differ only in their last bit (when generating 8-byte pads) or last two bits (when generating 4-byte pads) are derived from the same block cipher encryption. This allows caching and sharing a single block cipher invocation for sequential nonces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数はキーとノンスを取り、タグ生成で使用するために擬似ランダムパッドを返します。長さ4、8、12、または16バイトのパッドを生成できます。最後のビット（8バイトパッドを生成するとき）または最後の2ビット（4バイトパッドを生成するとき）でのみ異なる非セースを使用して生成されたパッドは、同じブロック暗号化から派生していることに注意してください。これにより、シーケンシャルノンスのための単一のブロック暗号の呼び出しをキャッシュして共有できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-1--PDF-Algorithm">
3.3.1. PDF Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. PDFアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     K, string of length KEYLEN bytes.
     Nonce, string of length 1 to BLOCKLEN bytes.
     taglen, the integer 4, 8, 12 or 16.
   Output:
     Y, string of length taglen bytes.

   Compute Y using the following algorithm.

      //
      // Extract and zero low bit(s) of Nonce if needed
      //
      if (taglen = 4 or taglen = 8)
        index = str2uint(Nonce) mod (BLOCKLEN/taglen)
        Nonce = Nonce xor uint2str(index, bytelength(Nonce))
      end if

      //
      // Make Nonce BLOCKLEN bytes by appending zeroes if needed
      //
      Nonce = Nonce || zeroes(BLOCKLEN - bytelength(Nonce))

      //
      // Generate subkey, encipher and extract indexed substring
      //
      K&#39; = KDF(K, 0, KEYLEN)
      T = ENCIPHER(K&#39;, Nonce)
      if (taglen = 4 or taglen = 8)
        Y = T[1 + (index*taglen) ... taglen + (index*taglen)]
      else
        Y = T[1...taglen]
      end if

      Return Y
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--UMAC-Tag-Generation">
4. UMAC Tag Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. UMACタグ生成
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tag generation for UMAC proceeds by using UHASH (defined in the next section) to hash the message, applying the PDF to the nonce, and computing the xor of the resulting strings. The length of the pad and hash can be either 4, 8, 12, or 16 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACのタグ生成は、UHASH（次のセクションで定義されている）を使用してメッセージをハッシュし、PDFを非CEに適用し、結果の文字列のXORを計算します。パッドとハッシュの長さは、4、8、12、または16バイトのいずれかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--UMAC-Algorithm">
4.1. UMAC Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. UMACアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     K, string of length KEYLEN bytes.
     M, string of length less than 2^67 bits.
     Nonce, string of length 1 to BLOCKLEN bytes.
     taglen, the integer 4, 8, 12 or 16.
   Output:
     Tag, string of length taglen bytes.

   Compute Tag using the following algorithm.

     HashedMessage = UHASH(K, M, taglen)
     Pad           = PDF(K, Nonce, taglen)
     Tag           = Pad xor HashedMessage

     Return Tag
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--UMAC-32-UMAC-64-UMAC-96-and-UMAC-128">
4.2. UMAC-32, UMAC-64, UMAC-96, and UMAC-128
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. UMAC-32、UMAC-64、UMAC-96、およびUMAC-128
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The preceding UMAC definition has a parameter &#34;taglen&#34;, which specifies the length of tag generated by the algorithm. The following aliases define names that make tag length explicit in the name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のUMAC定義には、アルゴリズムによって生成されるタグの長さを指定するパラメータ「taglen」があります。以下のエイリアスは、タグの長さを名前に明示的に示す名前を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     UMAC-32(K, M, Nonce) = UMAC(K, M, Nonce, 4)
     UMAC-64(K, M, Nonce) = UMAC(K, M, Nonce, 8)
     UMAC-96(K, M, Nonce) = UMAC(K, M, Nonce, 12)
     UMAC-128(K, M, Nonce) = UMAC(K, M, Nonce, 16)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--UHASH-Universal-Hash-Function">
5. UHASH: Universal Hash Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. UHASH：ユニバーサルハッシュ関数
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UHASH is a keyed hash function, which takes as input a string of arbitrary length, and produces a 4-, 8-, 12-, or 16-byte output. UHASH does its work in three stages, or layers. A message is first hashed by L1-HASH, its output is then hashed by L2-HASH, whose output is then hashed by L3-HASH. If the message being hashed is no longer than 1024 bytes, then L2-HASH is skipped as an optimization. Because L3-HASH outputs a string whose length is only four bytes long, multiple iterations of this three-layer hash are used if a total hash-output longer than four bytes is requested. To reduce memory use, L1-HASH reuses most of its key material between iterations. A significant amount of internal key is required for UHASH, but it remains constant so long as UMAC&#39;s key is unchanged. It is the implementer&#39;s choice whether to generate the internal keys each time a message is hashed, or to cache them between messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UHASH はキー付きハッシュ関数で、任意の長さの文字列を入力として受け取り、4、8、12、または 16 バイトの出力を生成します。UHASH は 3 つのステージ、つまりレイヤーで動作します。メッセージは最初に L1-HASH でハッシュされ、その出力は次に L2-HASH でハッシュされ、その出力は L3-HASH でハッシュされます。ハッシュされるメッセージが 1024 バイト以下の場合、最適化のため L2-HASH はスキップされます。L3-HASH は 4 バイトの長さの文字列を出力するため、合計 4 バイトを超えるハッシュ出力が要求された場合、この 3 レイヤー ハッシュを複数回繰り返して使用します。メモリ使用量を削減するため、L1-HASH は繰り返しの間でキー マテリアルのほとんどを再利用します。UHASH には大量の内部キーが必要ですが、UMAC のキーが変更されない限り、その量は一定のままです。メッセージがハッシュされるたびに内部キーを生成するか、メッセージ間で内部キーをキャッシュするかは実装者が選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Please note that UHASH has certain combinatoric properties making it suitable for Wegman-Carter message authentication. UHASH is not a cryptographic hash function and is not a suitable general replacement for functions like SHA-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UHASHは、Wegman-Carterメッセージ認証に適した特定の組み合わせ特性を備えていることにご注意ください。UHASHは暗号ハッシュ関数ではなく、SHA-1などの関数の一般的な代替として適していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UHASH is presented here in a top-down manner. First, UHASH is described, then each of its component hashes is presented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここではUHASHをトップダウン方式で説明します。まずUHASHについて説明し、次にUHASHを構成するハッシュをそれぞれ紹介します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--UHASH-Algorithm">
5.1. UHASH Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. UHASHアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     K, string of length KEYLEN bytes.
     M, string of length less than 2^67 bits.
     taglen, the integer 4, 8, 12 or 16.
   Output:
     Y, string of length taglen bytes.

   Compute Y using the following algorithm.

     //
     // One internal iteration per 4 bytes of output
     //
     iters = taglen / 4

     //
     // Define total key needed for all iterations using KDF.
     // L1Key reuses most key material between iterations.
     //
     L1Key  = KDF(K, 1, 1024 + (iters - 1) * 16)
     L2Key  = KDF(K, 2, iters * 24)
     L3Key1 = KDF(K, 3, iters * 64)
     L3Key2 = KDF(K, 4, iters * 4)

     //
     // For each iteration, extract key and do three-layer hash.
     // If bytelength(M) &lt;= 1024, then skip L2-HASH.
     //
     Y = &lt;empty string&gt;
     for i = 1 to iters do
       L1Key_i  = L1Key [(i-1) * 16 + 1 ... (i-1) * 16 + 1024]
       L2Key_i  = L2Key [(i-1) * 24 + 1 ... i * 24]
       L3Key1_i = L3Key1[(i-1) * 64 + 1 ... i * 64]
       L3Key2_i = L3Key2[(i-1) * 4  + 1 ... i * 4]

       A = L1-HASH(L1Key_i, M)
       if (bitlength(M) &lt;= bitlength(L1Key_i)) then
         B = zeroes(8) || A
       else
         B = L2-HASH(L2Key_i, A)
       end if
       C = L3-HASH(L3Key1_i, L3Key2_i, B)
       Y = Y || C
     end for

     Return Y
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--L1-HASH-First-Layer-Hash">
5.2. L1-HASH: First-Layer Hash
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. L1-HASH：ファーストレイヤーハッシュ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first-layer hash breaks the message into 1024-byte chunks and hashes each with a function called NH. Concatenating the results forms a string, which is up to 128 times shorter than the original.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファーストレイヤーのハッシュは、メッセージを1024バイトのチャンクに分割し、それぞれがNHと呼ばれる関数でハッシュします。結果を連結すると、文字列が形成されますが、これは元の文字列よりも最大128倍短くなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-1--L1-HASH-Algorithm">
5.2.1. L1-HASH Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1. L1-HASHアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     K, string of length 1024 bytes.
     M, string of length less than 2^67 bits.
   Output:
     Y, string of length (8 * ceil(bitlength(M)/8192)) bytes.

   Compute Y using the following algorithm.

     //
     // Break M into 1024 byte chunks (final chunk may be shorter)
     //
     t = max(ceil(bitlength(M)/8192), 1)
     Let M_1, M_2, ..., M_t be strings so that M = M_1 || M_2 || ... ||
        M_t, and bytelength(M_i) = 1024 for all 0 &lt; i &lt; t.

     //
     // For each chunk, except the last: endian-adjust, NH hash
     // and add bit-length.  Use results to build Y.
     //
     Len = uint2str(1024 * 8, 8)
     Y = &lt;empty string&gt;
     for i = 1 to t-1 do
       ENDIAN-SWAP(M_i)
       Y = Y || (NH(K, M_i) +_64 Len)
     end for

     //
     // For the last chunk: pad to 32-byte boundary, endian-adjust,
     // NH hash and add bit-length.  Concatenate the result to Y.
     //
     Len = uint2str(bitlength(M_t), 8)
     M_t = zeropad(M_t, 32)
     ENDIAN-SWAP(M_t)
     Y = Y || (NH(K, M_t) +_64 Len)

     return Y
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-2--NH-Algorithm">
5.2.2. NH Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2. NHアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because this routine is applied directly to every bit of input data, optimized implementation of it yields great benefit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このルーチンは入力データのすべてのビットに直接適用されるため、最適化された実装によって大きなメリットが得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     K, string of length 1024 bytes.
     M, string with length divisible by 32 bytes.
   Output:
     Y, string of length 8 bytes.

   Compute Y using the following algorithm.

     //
     // Break M and K into 4-byte chunks
     //
     t = bytelength(M) / 4
     Let M_1, M_2, ..., M_t be 4-byte strings
       so that M = M_1 || M_2 || ... || M_t.
     Let K_1, K_2, ..., K_t be 4-byte strings
       so that K_1 || K_2 || ... || K_t  is a prefix of K.

     //
     // Perform NH hash on the chunks, pairing words for multiplication
     // which are 4 apart to accommodate vector-parallelism.
     //
     Y = zeroes(8)
     i = 1
     while (i &lt; t) do
       Y = Y +_64 ((M_{i+0} +_32 K_{i+0}) *_64 (M_{i+4} +_32 K_{i+4}))
       Y = Y +_64 ((M_{i+1} +_32 K_{i+1}) *_64 (M_{i+5} +_32 K_{i+5}))
       Y = Y +_64 ((M_{i+2} +_32 K_{i+2}) *_64 (M_{i+6} +_32 K_{i+6}))
       Y = Y +_64 ((M_{i+3} +_32 K_{i+3}) *_64 (M_{i+7} +_32 K_{i+7}))
       i = i + 8
     end while

     Return Y
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--L2-HASH-Second-Layer-Hash">
5.3. L2-HASH: Second-Layer Hash
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. L2-HASH：セカンドレイヤーハッシュ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second-layer rehashes the L1-HASH output using a polynomial hash called POLY. If the L1-HASH output is long, then POLY is called once on a prefix of the L1-HASH output and called using different settings on the remainder. (This two-step hashing of the L1-HASH output is needed only if the message length is greater than 16 megabytes.) Careful implementation of POLY is necessary to avoid a possible timing attack (see Section 6.6 for more information).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第2層は、L1-HASH出力をPOLYと呼ばれる多項式ハッシュを用いて再ハッシュします。L1-HASH出力が長い場合、L1-HASH出力のプレフィックスに対してPOLYを1回呼び出し、残りの部分に対しては異なる設定を用いてPOLYを呼び出します。（このL1-HASH出力の2段階ハッシュは、メッセージ長が16MBを超える場合にのみ必要です。）タイミング攻撃の可能性を回避するために、POLYの実装には注意が必要です（詳細はセクション6.6を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3-1--L2-HASH-Algorithm">
5.3.1. L2-HASH Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1. L2-HASHアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     K, string of length 24 bytes.
     M, string of length less than 2^64 bytes.
   Output:
     Y, string of length 16 bytes.

   Compute y using the following algorithm.

     //
     //  Extract keys and restrict to special key-sets
     //
     Mask64  = uint2str(0x01ffffff01ffffff, 8)
     Mask128 = uint2str(0x01ffffff01ffffff01ffffff01ffffff, 16)
     k64    = str2uint(K[1...8]  and Mask64)
     k128   = str2uint(K[9...24] and Mask128)

     //
     // If M is no more than 2^17 bytes, hash under 64-bit prime,
     // otherwise, hash first 2^17 bytes under 64-bit prime and
     // remainder under 128-bit prime.
     //
     if (bytelength(M) &lt;= 2^17) then             // 2^14 64-bit words

        //
        // View M as an array of 64-bit words, and use POLY modulo
        // prime(64) (and with bound 2^64 - 2^32) to hash it.
        //
        y = POLY(64, 2^64 - 2^32,  k64, M)
     else
        M_1 = M[1...2^17]
        M_2 = M[2^17 + 1 ... bytelength(M)]
        M_2 = zeropad(M_2 || uint2str(0x80,1), 16)
        y = POLY(64, 2^64 - 2^32, k64, M_1)
        y = POLY(128, 2^128 - 2^96, k128, uint2str(y, 16) || M_2)
      end if

     Y = uint2str(y, 16)

     Return Y
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3-2--POLY-Algorithm">
5.3.2. POLY Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2. POLYアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     wordbits, the integer 64 or 128.
     maxwordrange, positive integer less than 2^wordbits.
     k, integer in the range 0 ... prime(wordbits) - 1.
     M, string with length divisible by (wordbits / 8) bytes.
   Output:
     y, integer in the range 0 ... prime(wordbits) - 1.

   Compute y using the following algorithm.

     //
     // Define constants used for fixing out-of-range words
     //
     wordbytes = wordbits / 8
     p = prime(wordbits)
     offset = 2^wordbits - p
     marker = p - 1

     //
     // Break M into chunks of length wordbytes bytes
     //
     n = bytelength(M) / wordbytes
     Let M_1, M_2, ..., M_n be strings of length wordbytes bytes
       so that M = M_1 || M_2 || ... || M_n

     //
     // Each input word m is compared with maxwordrange.  If not smaller
     // then &#39;marker&#39; and (m - offset), both in range, are hashed.
     //
     y = 1
     for i = 1 to n do
       m = str2uint(M_i)
       if (m &gt;= maxwordrange) then
         y = (k * y + marker) mod p
         y = (k * y + (m - offset)) mod p
       else
         y = (k * y + m) mod p
       end if
     end for

     Return y
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--L3-HASH-Third-Layer-Hash">
5.4. L3-HASH: Third-Layer Hash
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. L3-HASH：サードレイヤーハッシュ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The output from L2-HASH is 16 bytes long. This final hash function hashes the 16-byte string to a fixed length of 4 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
L2-Hashからの出力の長さは16バイトです。この最後のハッシュ関数は、16バイトの文字列を固定長の4バイトにハッシュします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-1--L3-HASH-Algorithm">
5.4.1. L3-HASH Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.1. L3-HASHアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Input:
     K1, string of length 64 bytes.
     K2, string of length 4 bytes.
     M, string of length 16 bytes.
   Output:
     Y, string of length 4 bytes.

   Compute Y using the following algorithm.

     y = 0

     //
     // Break M and K1 into 8 chunks and convert to integers
     //
     for i = 1 to 8 do
       M_i = M [(i - 1) * 2 + 1 ... i * 2]
       K_i = K1[(i - 1) * 8 + 1 ... i * 8]
       m_i = str2uint(M_i)
       k_i = str2uint(K_i) mod prime(36)
     end for

     //
     // Inner-product hash, extract last 32 bits and affine-translate
     //
     y = (m_1 * k_1 + ... + m_8 * k_8) mod prime(36)
     y = y mod 2^32
     Y = uint2str(y, 4)
     Y = Y xor K2

     Return Y

        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Security-Considerations">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a message authentication code specification, this entire document is about security. Here we describe some security considerations important for the proper understanding and use of UMAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ認証コードの仕様として、このドキュメント全体はセキュリティに関するものです。ここでは、UMACの適切な理解と使用に重要なセキュリティ上の考慮事項について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Resistance-to-Cryptanalysis">
6.1. Resistance to Cryptanalysis
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 暗号化に対する耐性
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The strength of UMAC depends on the strength of its underlying cryptographic functions: the key-derivation function (KDF) and the pad-derivation function (PDF). In this specification, both operations are implemented using a block cipher, by default the Advanced Encryption Standard (AES). However, the design of UMAC allows for the replacement of these components. Indeed, it is possible to use other block ciphers or other cryptographic objects, such as (properly keyed) SHA-1 or HMAC for the realization of the KDF or PDF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACの強度は、基礎となる暗号化関数の強度、つまりキーダリベーション関数（KDF）とパッド剥離関数（PDF）に依存します。この仕様では、両方の操作がブロック暗号を使用して実装されています。デフォルトでは、Advanced暗号化標準（AES）です。ただし、UMACの設計により、これらのコンポーネントを交換できます。実際、KDFまたはPDFの実現には、（適切にキー付き）SHA-1やHMACなどの他のブロック暗号または他の暗号化オブジェクトを使用することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The core of the UMAC design, the UHASH function, does not depend on cryptographic assumptions: its strength is specified by a purely mathematical property stated in terms of collision probability, and this property is proven unconditionally [3, 6]. This means the strength of UHASH is guaranteed regardless of advances in cryptanalysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACデザインの中核であるUhash関数は、暗号化の仮定に依存しません。その強度は、衝突確率の観点から述べられている純粋に数学的なプロパティによって指定され、この特性は無条件に証明されています[3、6]。これは、暗号化の進歩に関係なく、Uhashの強度が保証されることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The analysis of UMAC [3, 6] shows this scheme to have provable security, in the sense of modern cryptography, by way of tight reductions. What this means is that an adversarial attack on UMAC that forges with probability that significantly exceeds the established collision probability of UHASH will give rise to an attack of comparable complexity. This attack will break the block cipher, in the sense of distinguishing the block cipher from a family of random permutations. This design approach essentially obviates the need for cryptanalysis on UMAC: cryptanalytic efforts might as well focus on the block cipher, the results imply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMAC [3、6]の分析は、このスキームが、緊密な削減によって、現代の暗号化の意味で、証明可能なセキュリティを持つことを示しています。これが意味することは、UHASHの確立された衝突確率を大幅に超える確率で鍛えられるUMACに対する敵対的な攻撃が、同等の複雑さの攻撃を引き起こすということです。この攻撃は、ブロック暗号をランダムな順列のファミリーと区別するという意味で、ブロック暗号を破壊します。この設計アプローチは、本質的にUMACでの暗号化の必要性を回避します。暗号化の取り組みは、ブロック暗号に焦点を合わせている可能性があり、結果は暗示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--Tag-Lengths-and-Forging-Probability">
6.2. Tag Lengths and Forging Probability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. タグの長さと偽造確率
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A MAC algorithm is used to authenticate messages between two parties that share a secret MAC key K. An authentication tag is computed for a message using K and, in some MAC algorithms such as UMAC, a nonce. Messages transmitted between parties are accompanied by their tag and, possibly, nonce. Breaking the MAC means that the attacker is able to generate, on its own, with no knowledge of the key K, a new message M (i.e., one not previously transmitted between the legitimate parties) and to compute on M a correct authentication tag under the key K. This is called a forgery. Note that if the authentication tag is specified to be of length t, then the attacker can trivially break the MAC with probability 1/2^t. For this, the attacker can just generate any message of its choice and try a random tag; obviously, the tag is correct with probability 1/2^t. By repeated guesses, the attacker can increase linearly its probability of success.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACアルゴリズムは、秘密MAC鍵Kを共有する2者間のメッセージを認証するために使用されます。メッセージの認証タグは、Kと、UMACなどの一部のMACアルゴリズムではノンスを用いて計算されます。当事者間で送信されるメッセージには、タグと、場合によってはノンスが付随します。MACを破るということは、攻撃者が鍵Kを知らずに、新しいメッセージM（つまり、正当な当事者間で以前に送信されたことのないメッセージ）を独自に生成し、鍵Kを用いてM上で正しい認証タグを計算できることを意味します。これは偽造と呼ばれます。認証タグの長さがtに指定されている場合、攻撃者は確率1/2^tでMACを簡単に破ることができることに注意してください。これを行うには、攻撃者は任意のメッセージを生成し、ランダムなタグを試すだけで済みます。明らかに、そのタグは確率1/2^tで正しいものです。攻撃者は推測を繰り返すことで、成功確率を線形的に高めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of UMAC-64, for example, the above guessing-attack strategy is close to optimal. An adversary can correctly guess an 8-byte UMAC tag with probability 1/2^64 by simply guessing a random value. The results of [3, 6] show that no attack strategy can produce a correct tag with probability better than 1/2^60 if UMAC were to use a random function in its work rather than AES. Another result [2], when combined with [3, 6], shows that so long as AES is secure as a pseudorandom permutation, it can be used instead of a random function without significantly increasing the 1/2^60 forging probability, assuming that no more than 2^64 messages are authenticated. Likewise, 32-, 96-, and 128-bit tags cannot be forged with more than 1/2^30, 1/2^90, and 1/2^120 probability plus the probability of a successful attack against AES as a pseudorandom permutation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えばUMAC-64の場合、上記の推測攻撃戦略はほぼ最適である。攻撃者はランダムな値を推測するだけで、8バイトのUMACタグを1/2^64の確率で正しく推測できる。[3, 6]の結果は、UMACがAESではなくランダム関数を使用する場合、1/2^60より高い確率で正しいタグを生成する攻撃戦略は存在しないことを示している。[2]の別の結果と[3, 6]を組み合わせると、AESが疑似ランダム順列として安全である限り、認証されるメッセージが2^64以下であれば、1/2^60の偽造確率を大幅に増加させることなく、ランダム関数の代わりにAESを使用できることがわかる。同様に、32 ビット、96 ビット、および 128 ビットのタグは、1/2^30、1/2^90、および 1/2^120 の確率と、疑似ランダム順列としての AES に対する攻撃が成功する確率以上では偽造できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AES has undergone extensive study and is assumed to be very secure as a pseudorandom permutation. If we assume that no attacker with feasible computational power can distinguish randomly-keyed AES from a randomly-chosen permutation with probability delta (more precisely, delta is a function of the computational resources of the attacker and of its ability to sample the function), then we obtain that no such attacker can forge UMAC with probability greater than 1/2^30, 1/^60, 1/2^90, or 1/2^120, plus 3*delta. Over N forgery attempts, forgery occurs with probability no more than N/2^30, N/^60, N/2^90, or N/2^120, plus 3*delta. The value delta may exceed 1/2^30, 1/2^60, 1/2^90, or 1/2^120, in which case the probability of UMAC forging is dominated by a term representing the security of AES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AESは広範囲に研究され、疑似ランダム順列として非常に安全であると想定されています。実現可能な計算能力を持つ攻撃者が、ランダム鍵AESとランダムに選択された順列を確率デルタ（より正確には、デルタは攻撃者の計算リソースと関数をサンプリングする能力の関数）で区別できないと仮定すると、そのような攻撃者は1/2^30、1/^60、1/2^90、または1/2^120に3*デルタを加えた値を超える確率でUMACを偽造できないことがわかります。N回の偽造試行において、偽造が発生する確率はN/2^30、N/^60、N/2^90、またはN/2^120に3*デルタを加えた値以下です。値のデルタは 1/2^30、1/2^60、1/2^90、または 1/2^120 を超える場合があり、その場合、UMAC 偽造の確率は AES のセキュリティを表す項によって左右されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With UMAC, off-line computation aimed at exceeding the forging probability is hopeless as long as the underlying cipher is not broken. An attacker attempting to forge UMAC tags will need to interact with the entity that verifies message tags and try a large number of forgeries before one is likely to succeed. The system architecture will determine the extent to which this is possible. In a well-architected system, there should not be any high-bandwidth capability for presenting forged MACs and determining if they are valid. In particular, the number of authentication failures at the verifying party should be limited. If a large number of such attempts are detected, the session key in use should be dropped and the event be recorded in an audit log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACでは、基盤となる暗号が破られない限り、偽造確率を超えることを目的としたオフライン計算は不可能です。UMACタグの偽造を試みる攻撃者は、メッセージタグを検証するエンティティとやり取りし、成功確率が上がるまでに多数の偽造を試行する必要があります。これがどの程度可能であるかは、システムアーキテクチャによって決まります。適切に設計されたシステムでは、偽造されたMACを提示し、その有効性を判断するために高帯域幅の能力を必要としません。特に、検証側での認証失敗回数を制限する必要があります。このような試行が多数検出された場合、使用中のセッションキーを削除し、そのイベントを監査ログに記録する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let us reemphasize: a forging probability of 1/2^60 does not mean that there is an attack that runs in 2^60 time; to the contrary, as long as the block cipher in use is not broken there is no such attack for UMAC. Instead, a 1/2^60 forging probability means that if an attacker could have N forgery attempts, then the attacker would have no more than N/2^60 probability of getting one or more of them right.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
改めて強調しておきますが、偽造確率が1/2^60であるということは、2^60の時間で実行される攻撃が存在するという意味ではありません。むしろ、使用されているブロック暗号が破られない限り、UMACに対してそのような攻撃は存在しません。偽造確率が1/2^60であるということは、攻撃者がN回の偽造試行を行った場合、そのうち1回以上正解する確率はN/2^60以下であることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be pointed out that once an attempted forgery is successful, it is possible, in principle, that subsequent messages under this key may be easily forged. This is important to understand in gauging the severity of a successful forgery, even though no such attack on UMAC is known to date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一度偽造の試みが成功すると、原理的には、この鍵を使用した後続のメッセージも容易に偽造される可能性があることを指摘しておく必要があります。UMACに対するそのような攻撃は今のところ知られていませんが、偽造の成功の重大性を判断する上で、この点を理解することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In conclusion, 64-bit tags seem appropriate for many security architectures and commercial applications. If one wants a more conservative option, at a cost of about 50% or 100% more computation, UMAC can produce 96- or 128-bit tags that have basic collision probabilities of at most 1/2^90 and 1/2^120. If one needs less security, with the benefit of about 50% less computation, UMAC can produce 32-bit tags. In this case, under the same assumptions as before, one cannot forge a message with probability better than 1/2^30. Special care must be taken when using 32-bit tags because 1/2^30 forgery probability is considered fairly high. Still, high-speed low-security authentication can be applied usefully on low-value data or rapidly-changing key environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結論として、64 ビット タグは多くのセキュリティ アーキテクチャと商用アプリケーションに適していると思われます。より保守的なオプションが必要な場合は、約 50% または 100% 多くの計算コストがかかりますが、UMAC は、最大で 1/2^90 と 1/2^120 の基本衝突確率を持つ 96 ビットまたは 128 ビットのタグを生成できます。それほどセキュリティを必要としない場合は、計算が約 50% 少なくなるという利点で、UMAC は 32 ビットのタグを生成できます。この場合、前と同じ仮定の下では、1/2^30 よりも高い確率でメッセージを偽造することはできません。1/2^30 の偽造確率はかなり高いと考えられるため、32 ビット タグを使用する場合は特別な注意が必要です。それでも、高速でセキュリティの低い認証は、価値の低いデータや急速に変化するキー環境に適用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--Nonce-Considerations">
6.3. Nonce Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. ノンスの考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMAC requires a nonce with length in the range 1 to BLOCKLEN bytes. All nonces in an authentication session must be equal in length. For secure operation, no nonce value should be repeated within the life of a single UMAC session key. There is no guarantee of message authenticity when a nonce is repeated, and so messages accompanied by a repeated nonce should be considered inauthentic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACは、1バイトからBLOCKLENバイトまでの長さのノンスを必要とします。認証セッション内のすべてのノンスの長さは同じでなければなりません。安全な運用のために、単一のUMACセッション鍵の有効期間中は、ノンス値が重複してはなりません。ノンスが重複した場合、メッセージの真正性は保証されません。したがって、ノンスが重複しているメッセージは真正ではないとみなされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To authenticate messages over a duplex channel (where two parties send messages to each other), a different key could be used for each direction. If the same key is used in both directions, then it is crucial that all nonces be distinct. For example, one party can use even nonces while the other party uses odd ones. The receiving party must verify that the sender is using a nonce of the correct form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双方向チャネル（2者が互いにメッセージを送信するチャネル）でメッセージを認証するには、方向ごとに異なる鍵を使用できます。双方向で同じ鍵を使用する場合は、すべてのナンスが異なっていることが重要です。例えば、一方の当事者が偶数のナンスを使用し、もう一方の当事者が奇数のナンスを使用するといったことが可能です。受信側は、送信者が正しい形式のナンスを使用していることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification does not indicate how nonce values are created, updated, or communicated between the entity producing a tag and the entity verifying a tag. The following are possibilities:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、タグを生成するエンティティとタグを検証するエンティティの間で、ノンス値がどのように作成、更新、または通信されるかについては規定していません。以下の可能性が考えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The nonce is an 8-byte unsigned number, Counter, which is initialized to zero, which is incremented by one following the generation of each authentication tag, and which is always communicated along with the message and the authentication tag. An error occurs at the sender if there is an attempt to authenticate more than 2^64 messages within a session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ノンスは8バイトの符号なし数値（Counter）であり、0に初期化され、認証タグが生成されるたびに1ずつ増加し、常にメッセージと認証タグと共に通信されます。1つのセッション内で2^64を超えるメッセージの認証を試行すると、送信側でエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The nonce is a BLOCKLEN-byte unsigned number, Counter, which is initialized to zero and which is incremented by one following the generation of each authentication tag. The Counter is not explicitly communicated between the sender and receiver. Instead, the two are assumed to communicate over a reliable transport, and each maintains its own counter so as to keep track of what the current nonce value is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. nonceはBLOCKLENバイトの符号なし数値Counterで、0に初期化され、認証タグが生成されるたびに1ずつ増加します。Counterは送信者と受信者の間で明示的に伝達されることはありません。送信者と受信者は信頼性の高いトランスポートを介して通信することが前提とされており、それぞれが現在のnonce値を追跡するために独自のCounterを保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The nonce is a BLOCKLEN-byte random value. (Because repetitions in a random n-bit value are expected at around 2^(n/2) trials, the number of messages to be communicated in a session using n-bit nonces should not be allowed to approach 2^(n/2).)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. NonCeはブロックバイバイトのランダム値です。（ランダムなn-bit値の繰り返しは約2^（n/2）試行で予想されるため、n-bit noncesを使用したセッションで伝達されるメッセージの数は2^（n/2に近づくことを許可されないでください）。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We emphasize that the value of the nonce need not be kept secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nonce の値を秘密にする必要がないことを強調します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When UMAC is used within a higher-level protocol, there may already be a field, such as a sequence number, which can be co-opted so as to specify the nonce needed by UMAC [5]. The application will then specify how to construct the nonce from this already-existing field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACが高レベルのプロトコル内で使用される場合、Sequence番号などのフィールドが既にある可能性があります。これは、UMACが必要とする非CEを指定するために採用できます[5]。その後、アプリケーションは、この既存のフィールドからノンスを構築する方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--Replay-Attacks">
6.4. Replay Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. リプレイ攻撃
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A replay attack entails the attacker repeating a message, nonce, and authentication tag. In many applications, replay attacks may be quite damaging and must be prevented. In UMAC, this would normally be done at the receiver by having the receiver check that no nonce value is used twice. On a reliable connection, when the nonce is a counter, this is trivial. On an unreliable connection, when the nonce is a counter, one would normally cache some window of recent nonces. Out-of-order message delivery in excess of what the window allows will result in rejecting otherwise valid authentication tags. We emphasize that it is up to the receiver when a given (message, nonce, tag) triple will be deemed authentic. Certainly, the tag should be valid for the message and nonce, as determined by UMAC, but the message may still be deemed inauthentic because the nonce is detected to be a replay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リプレイ攻撃には、攻撃者がメッセージ、NonCE、および認証タグを繰り返していることを伴います。多くのアプリケーションでは、リプレイ攻撃は非常に損害を与える可能性があり、防止する必要があります。UMACでは、これは通常、受信機に2回使用されていないことを受信機にチェックさせることにより、受信機で行われます。信頼できる接続では、ノンスがカウンターである場合、これは些細なことです。信頼できない接続では、ノンスがカウンターである場合、通常、最近のノンスのウィンドウをキャッシュします。ウィンドウが許可するものを超えるオーダーアウトメッセージ配信により、他の方法では有効な認証タグが拒否されます。特定の（メッセージ、ノンス、タグ）トリプルが本物と見なされる場合、レシーバー次第であることを強調します。確かに、UMACによって決定されるように、タグはメッセージとNonCEに対して有効である必要がありますが、ノンスがリプレイであると検出されるため、メッセージは依然として不正であるとみなされる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5--Tag-Prefix-Verification">
6.5. Tag-Prefix Verification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. Tag-Prefix検証
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMAC&#39;s definition makes it possible to implement tag-prefix verification; for example, a receiver might verify only the 32-bit prefix of a 64-bit tag if its computational load is high. Or a receiver might reject out-of-hand a 64-bit tag whose 32-bit prefix is incorrect. Such practices are potentially dangerous and can lead to attacks that reduce the security of the session to the length of the verified prefix. A UMAC key (or session) must have an associated and immutable tag length and the implementation should not leak information that would reveal if a given proper prefix of a tag is valid or invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UMACの定義により、Tag-Prefix検証を実装できます。たとえば、レシーバーは、計算負荷が高い場合、64ビットタグの32ビットプレフィックスのみを確認できます。または、レシーバーは、32ビットのプレフィックスが正しくない64ビットタグを手で拒否する場合があります。このようなプラクティスは潜在的に危険であり、セッションのセキュリティを検証済みのプレフィックスの長さまで減らす攻撃につながる可能性があります。UMACキー（またはセッション）には、関連付けられた不変のタグの長さが必要であり、実装は、タグの特定の適切なプレフィックスが有効または無効である場合に明らかにする情報を漏らしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-6--Side-Channel-Attacks">
6.6. Side-Channel Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. サイドチャネル攻撃
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Side-channel attacks have the goal of subverting the security of a cryptographic system by exploiting its implementation characteristics. One common side-channel attack is to measure system response time and derive information regarding conditions met by the data being processed. Such attacks are known as &#34;timing attacks&#34;. Discussion of timing and other side-channel attacks is outside of this document&#39;s scope. However, we warn that there are places in the UMAC algorithm where timing information could be unintentionally leaked. In particular, the POLY algorithm (Section 5.3.2) tests whether a value m is out of a particular range, and the behavior of the algorithm differs depending on the result. If timing attacks are to be avoided, care should be taken to equalize the computation time in both cases. Timing attacks can also occur for more subtle reasons, including caching effects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サイドチャネル攻撃には、実装特性を活用することにより、暗号化システムのセキュリティを破壊するという目標があります。一般的なサイドチャネル攻撃の1つは、システムの応答時間を測定し、処理されるデータによって満たされた条件に関する情報を導き出すことです。このような攻撃は「タイミング攻撃」として知られています。タイミングおよびその他のサイドチャネル攻撃の議論は、このドキュメントの範囲外です。ただし、タイミング情報が意図せずにリークされる可能性があるUMACアルゴリズムには場所があることを警告します。特に、ポリアルゴリズム（セクション5.3.2）は、値mが特定の範囲から外れているかどうかをテストし、アルゴリズムの動作は結果によって異なります。タイミング攻撃を回避する場合、どちらの場合も計算時間を均等にするように注意する必要があります。また、キャッシュ効果など、より微妙な理由でタイミング攻撃が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Acknowledgements">
7. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David McGrew and Scott Fluhrer, of Cisco Systems, played a significant role in improving UMAC by encouraging us to pay more attention to the performance of short messages. Thanks go to Jim Schaad and to those who made helpful suggestions to the CFRG mailing list for improving this document during RFC consideration. Black, Krovetz, and Rogaway have received support for this work under NSF awards 0208842, 0240000, and 9624560, and a gift from Cisco Systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cisco SystemsのDavid McGrewとScott Fluhrerは、短いメッセージのパフォーマンスにもっと注意を払うことを奨励することで、UMACを改善する上で重要な役割を果たしました。Jim Schaadと、RFCの検討中にこのドキュメントを改善してくれたCFRGメーリングリストに有益な提案をした人に感謝します。Black、Krovetz、およびRogawayは、NSF Awards 0208842、0240000、および9624560の下でこの作業を支持しており、Cisco Systemsからの贈り物を受けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix--Test-Vectors">
Appendix. Test Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix. テストベクトル
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following are some sample UMAC outputs over a collection of input values, using AES with 16-byte keys. Let
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、16バイトの鍵を持つAESを使用して、入力値の集合に対するUMAC出力のサンプルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     K  = &#34;abcdefghijklmnop&#34;                  // A 16-byte UMAC key
     N  = &#34;bcdefghi&#34;                          // An 8-byte nonce
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The tags generated by UMAC using key K and nonce N are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーKとノンスnを使用してUMACによって生成されたタグは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Message      32-bit Tag    64-bit Tag            96-bit Tag
     -------      ----------    ----------            ----------
     &lt;empty&gt;       113145FB  6E155FAD26900BE1  32FEDB100C79AD58F07FF764
     &#39;a&#39; * 3       3B91D102  44B5CB542F220104  185E4FE905CBA7BD85E4C2DC
     &#39;a&#39; * 2^10    599B350B  26BF2F5D60118BD9  7A54ABE04AF82D60FB298C3C
     &#39;a&#39; * 2^15    58DCF532  27F8EF643B0D118D  7B136BD911E4B734286EF2BE
     &#39;a&#39; * 2^20    DB6364D1  A4477E87E9F55853  F8ACFA3AC31CFEEA047F7B11
     &#39;a&#39; * 2^25    5109A660  2E2DBC36860A0A5F  72C6388BACE3ACE6FBF062D9
     &#39;abc&#39; * 1     ABF3A3A0  D4D7B9F6BD4FBFCF  883C3D4B97A61976FFCF2323
     &#39;abc&#39; * 500   ABEB3C8B  D4CF26DDEFD5C01A  8824A260C53C66A36C9260A6
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first column lists a small sample of messages that are strings of repeated ASCII &#39;a&#39; bytes or &#39;abc&#39; strings. The remaining columns give in hexadecimal the tags generated when UMAC is called with the corresponding message, nonce N and key K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の列には、ASCII 文字の「a」バイトまたは「abc」文字列が繰り返されるメッセージの小さなサンプルがリストされています。残りの列には、対応するメッセージ、ノンス N、キー K を指定して UMAC が呼び出されたときに生成されるタグが 16 進数で示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using key K and producing a 64-bit tag, the following relevant keys are generated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーKを使用して64ビットタグを作成する場合、次の関連キーが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              Iteration 1         Iteration 2
                              -----------         -----------
     NH (Section 5.2.2)

       K_1                     ACD79B4F            C6DFECA2
       K_2                     6EDA0D0E            964A710D
       K_3                     1625B603            AD7EDE4D
       K_4                     84F9FC93            A1D3935E
       K_5                     C6DFECA2            62EC8672
       ...
       K_256                   0BF0F56C            744C294F

     L2-HASH (Section 5.3.1)

       k64             0094B8DD0137BEF8    01036F4D000E7E72

     L3-HASH (Section 5.4.1)

       k_5                   056533C3A8          0504BF4D4E
       k_6                   07591E062E          0126E922FF
       k_7                   0C2D30F89D          030C0399E2
       k_8                   046786437C          04C1CB8FED
       K2                      2E79F461            A74C03AA
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note that k_1 ... k_4 are not listed in this example because they are multiplied by zero in L3-HASH.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（K_1 ... K_4は、L3-HASHでゼロを掛けているため、この例にはリストされていません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When generating a 64-bit tag on input &#34;&#39;abc&#39; * 500&#34;, the following intermediate results are produced:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力「 &#39;ABC * 500」で64ビットタグを生成する場合、次の中間結果が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   Iteration 1
                   -----------
     L1-HASH  E6096F94EDC45CAC1BEDCD0E7FDAA906
     L2-HASH  0000000000000000A6C537D7986FA4AA
     L3-HASH  05F86309
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   Iteration 2
                   -----------
     L1-HASH  2665EAD321CFAE79C82F3B90261641E5
     L2-HASH  00000000000000001D79EAF247B394BF
     L3-HASH  DF9AD858
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Concatenating the two L3-HASH results produces a final UHASH result of 05F86309DF9AD858. The pad generated for nonce N is D13745D4304F1842, which when xor&#39;ed with the L3-HASH result yields a tag of D4CF26DDEFD5C01A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのL3-HASH結果を連結すると、05F86309DF9AD858の最終的なUHASH結果が生成されます。NonCe N用に生成されたパッドはD13745D4304F1842であり、L3-HASH結果でXOR&#39;edがD4CF26DDEFD5C01Aのタグを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Normative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
引用文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] FIPS-197, &#34;Advanced Encryption Standard (AES)&#34;, National Institute of Standards and Technology, 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] FIPS-197、「Advanced Encryption Standard（AES）」、国立標準技術研究所、2001年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Informative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参考引用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] D. Bernstein, &#34;Stronger security bounds for permutations&#34;, unpublished manuscript, 2005. This work refines &#34;Stronger security bounds for Wegman-Carter-Shoup authenticators&#34;, Advances in Cryptology - EUROCRYPT 2005, LNCS vol. 3494, pp. 164-180, Springer-Verlag, 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] D.バーンスタイン、「順列のより強力なセキュリティ境界」、未発表の原稿、2005年。この作業は、「Wegman-Carter-Shoup Authenticatorsのより強いセキュリティ境界線」を洗練し、暗号化の進歩-EuroCrypt 2005、LNCS Vol。3494、pp。164-180、Springer-Verlag、2005。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] J. Black, S. Halevi, H. Krawczyk, T. Krovetz, and P. Rogaway, &#34;UMAC: Fast and provably secure message authentication&#34;, Advances in Cryptology - CRYPTO &#39;99, LNCS vol. 1666, pp. 216- 233, Springer-Verlag, 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] J. Black、S。Halevi、H。Krawczyk、T。Krovetz、およびP. Rogaway、「UMAC：高速かつ証明されたメッセージ認証」、暗号学の進歩-Crypto &#39;99、LNCS Vol。1666、pp。216-233、Springer-Verlag、1999。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] L. Carter and M. Wegman, &#34;Universal classes of hash functions&#34;, Journal of Computer and System Sciences, 18 (1979), pp. 143- 154.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] L.カーターとM.ウェグマン、「ハッシュ機能のユニバーサルクラス」、Journal of Computer and System Sciences、18（1979）、pp。143-154。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Kent, S., &#34;IP Encapsulating Security Payload (ESP)&#34;, RFC 4303, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Kent、S。、「セキュリティペイロード（ESP）のカプセル化IP」、RFC 4303、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] T. Krovetz, &#34;Software-optimized universal hashing and message authentication&#34;, UMI Dissertation Services, 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] T. Krovetz、「ソフトウェアが最適化されたユニバーサルハッシュおよびメッセージ認証」、UMI論文サービス、2000。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] M. Wegman and L. Carter, &#34;New hash functions and their use in authentication and set equality&#34;, Journal of Computer and System Sciences, 22 (1981), pp. 265-279.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] M.ウェグマンとL.カーター、「新しいハッシュ機能と認証とセットの平等におけるそれらの使用」、Journal of Computer and System Sciences、22（1981）、pp。265-279。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
John Black Department of Computer Science University of Colorado Boulder, CO 80309 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジョンブラックコンピュータサイエンス大学コロラド大学ボルダー、コロラド州80309米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: jrblack@cs.colorado.edu
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Shai Halevi IBM T.J. Watson Research Center P.O. Box 704 Yorktown Heights, NY 10598 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Shai Halevi Ibm T.J.ワトソン研究センターP.O.ボックス704ヨークタウンハイツ、ニューヨーク10598 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: shaih@alum.mit.edu
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alejandro Hevia Department of Computer Science University of Chile Santiago 837-0459 CHILE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アレハンドロヘビアコンピュータサイエンス学科チリサンティアゴ837-0459チリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: ahevia@dcc.uchile.cl
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hugo Krawczyk IBM Research 19 Skyline Dr Hawthorne, NY 10533 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hugo Krawczyk IBM Research 19 Skyline Dr Hawthorne、NY 10533 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: hugo@ee.technion.ac.il
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ted Krovetz (Editor) Department of Computer Science California State University Sacramento, CA 95819 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テッドクロベッツ（編集者）コンピュータサイエンス学科カリフォルニア州立大学サクラメント、カリフォルニア州95819米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: tdk@acm.org
      Phillip Rogaway
   Department of Computer Science
   University of California
   Davis, CA 95616
   USA
   and
   Department of Computer Science
   Faculty of Science
   Chiang Mai University
   Chiang Mai 50200
   THAILAND
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: rogaway@cs.ucdavis.edu
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2006）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要なテクノロジーをカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
