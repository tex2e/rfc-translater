<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 6386 - VP8 Data Format and Decoding Guide 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6386</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6386 - VP8 Data Format and Decoding Guide 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6386">
              https://tools.ietf.org/html/rfc6386
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6386 - VP8データフォーマットおよび復号化ガイド</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Independent Submission                                       J. Bankoski
Request for Comments: 6386                                   J. Koleszar
Category: Informational                                       L. Quillio
ISSN: 2070-1721                                               J. Salonen
                                                              P. Wilkins
                                                                   Y. Xu
                                                             Google Inc.
                                                           November 2011
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   VP8 Data Format and Decoding Guide
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the VP8 compressed video data format, together with a discussion of the decoding procedure for the format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、一緒にフォーマットするための復号化手順の議論で、VP8圧縮ビデオデータフォーマットを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6386.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6386で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
   2. Format Overview .................................................5
   3. Compressed Frame Types ..........................................7
   4. Overview of Compressed Data Format ..............................8
   5. Overview of the Decoding Process ................................9
   6. Description of Algorithms ......................................14
   7. Boolean Entropy Decoder ........................................16
      7.1. Underlying Theory of Coding ...............................17
      7.2. Practical Algorithm Description ...........................18
      7.3. Actual Implementation .....................................20
   8. Compressed Data Components .....................................25
      8.1. Tree Coding Implementation ................................27
      8.2. Tree Coding Example .......................................28
   9. Frame Header ...................................................30
      9.1. Uncompressed Data Chunk ...................................30
      9.2. Color Space and Pixel Type (Key Frames Only) ..............33
      9.3. Segment-Based Adjustments .................................34
      9.4. Loop Filter Type and Levels ...............................35
      9.5. Token Partition and Partition Data Offsets ................36
      9.6. Dequantization Indices ....................................37
      9.7. Refresh Golden Frame and Altref Frame .....................38
      9.8. Refresh Last Frame Buffer .................................39
      9.9. DCT Coefficient Probability Update ........................39
      9.10. Remaining Frame Header Data (Non-Key Frame) ..............40
      9.11. Remaining Frame Header Data (Key Frame) ..................41
   10. Segment-Based Feature Adjustments .............................41
   11. Key Frame Macroblock Prediction Records .......................42
      11.1. mb_skip_coeff ............................................42
      11.2. Luma Modes ...............................................42
      11.3. Subblock Mode Contexts ...................................45
      11.4. Chroma Modes .............................................46
      11.5. Subblock Mode Probability Table ..........................47
   12. Intraframe Prediction .........................................50
      12.1. mb_skip_coeff ............................................51
      12.2. Chroma Prediction ........................................51
      12.3. Luma Prediction ..........................................54
   13. DCT Coefficient Decoding ......................................60
      13.1. Macroblock without Non-Zero Coefficient Values ...........61
      13.2. Coding of Individual Coefficient Values ..................61
      13.3. Token Probabilities ......................................63
      13.4. Token Probability Updates ................................68
      13.5. Default Token Probability Table ..........................73
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   14. DCT and WHT Inversion and Macroblock Reconstruction ...........76
      14.1. Dequantization ...........................................76
      14.2. Inverse Transforms .......................................78
      14.3. Implementation of the WHT Inversion ......................78
      14.4. Implementation of the DCT Inversion ......................81
      14.5. Summation of Predictor and Residue .......................83
   15. Loop Filter ...................................................84
      15.1. Filter Geometry and Overall Procedure ....................85
      15.2. Simple Filter ............................................87
      15.3. Normal Filter ............................................91
      15.4. Calculation of Control Parameters ........................95
   16. Interframe Macroblock Prediction Records ......................97
      16.1. Intra-Predicted Macroblocks ..............................97
      16.2. Inter-Predicted Macroblocks ..............................98
      16.3. Mode and Motion Vector Contexts ..........................99
      16.4. Split Prediction ........................................105
   17. Motion Vector Decoding .......................................108
      17.1. Coding of Each Component ................................108
      17.2. Probability Updates .....................................110
   18. Interframe Prediction ........................................113
      18.1. Bounds on, and Adjustment of, Motion Vectors ............113
      18.2. Prediction Subblocks ....................................115
      18.3. Sub-Pixel Interpolation .................................115
      18.4. Filter Properties .......................................118
   19. Annex A: Bitstream Syntax ....................................120
      19.1. Uncompressed Data Chunk .................................121
      19.2. Frame Header ............................................122
      19.3. Macroblock Data .........................................130
   20. Attachment One: Reference Decoder Source Code ................133
      20.1. bit_ops.h ...............................................133
      20.2. bool_decoder.h ..........................................133
      20.3. dequant_data.h ..........................................137
      20.4. dixie.c .................................................138
      20.5. dixie.h .................................................151
      20.6. dixie_loopfilter.c ......................................158
      20.7. dixie_loopfilter.h ......................................170
      20.8. idct_add.c ..............................................171
      20.9. idct_add.h ..............................................174
      20.10. mem.h ..................................................175
      20.11. modemv.c ...............................................176
      20.12. modemv.h ...............................................192
      20.13. modemv_data.h ..........................................193
      20.14. predict.c ..............................................198
      20.15. predict.h ..............................................231
      20.16. tokens.c ...............................................232
      20.17. tokens.h ...............................................242
      20.18. vp8_prob_data.h ........................................243
      20.19. vpx_codec_internal.h ...................................252
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      20.20. vpx_decoder.h ..........................................263
      20.21. vpx_decoder_compat.h ...................................271
      20.22. vpx_image.c ............................................285
      20.23. vpx_image.h ............................................291
      20.24. vpx_integer.h ..........................................298
      20.25. AUTHORS File ...........................................299
      20.26. LICENSE ................................................301
      20.27. PATENTS ................................................302
   21. Security Considerations ......................................302
   22. References ...................................................303
      22.1. Normative Reference .....................................303
      22.2. Informative References ..................................303
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the VP8 compressed video data format, together with a discussion of the decoding procedure for the format. It is intended to be used in conjunction with, and as a guide to, the reference decoder source code provided in Attachment One (Section 20). If there are any conflicts between this narrative and the reference source code, the reference source code should be considered correct. The bitstream is defined by the reference source code and not this narrative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、一緒にフォーマットするための復号化手順の議論で、VP8圧縮ビデオデータフォーマットを記述する。それに関連して使用されることを意図し、そして添付の一つ（第20）に設けられた基準デコーダのソースコードへのガイドとしてれます。この物語基準ソースコードとの間の競合がある場合、参照ソースコードが正しいと見なされるべきです。ビットストリームは、参照ソースコードではなく、この物語によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like many modern video compression schemes, VP8 is based on decomposition of frames into square subblocks of pixels, prediction of such subblocks using previously constructed blocks, and adjustment of such predictions (as well as synthesis of unpredicted blocks) using a discrete cosine transform (hereafter abbreviated as DCT). In one special case, however, VP8 uses a Walsh-Hadamard transform (hereafter abbreviated as WHT) instead of a DCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの現代のビデオ圧縮方式のように、VP8は、離散コサイン変換を用いて画素の正方形のサブブロックへのフレームの分解、以前に構築されたブロックを使用してこのようなサブブロックの予測、及びそのような予測の調整（ならびに予測されないブロックの合成）に基づいている（以下、 DCTと略します）。 1特殊なケースでは、しかし、VP8（以下WHTと略す）ウォルシュ - アダマール変換の代わりにDCTを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Roughly speaking, such systems reduce datarate by exploiting the temporal and spatial coherence of most video signals. It is more efficient to specify the location of a visually similar portion of a prior frame than it is to specify pixel values. The frequency segregation provided by the DCT and WHT facilitates the exploitation of both spatial coherence in the original signal and the tolerance of the human visual system to moderate losses of fidelity in the reconstituted signal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大雑把に言えば、このようなシステムは、ほとんどのビデオ信号の時間的、空間的コヒーレンスを利用してデータレートを減らします。画素値を指定するよりも前のフレームの視覚的に類似する部分の位置を指定するために、より効率的です。 DCTとWHTによって提供される周波数分離は、空間元の信号におけるコヒーレンスと再構成された信号に忠実度の損失を緩和するために、人間の視覚系の公差の両方の利用を容易にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 augments these basic concepts with, among other things, sophisticated usage of contextual probabilities. The result is a significant reduction in datarate at a given quality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8は他のもの、コンテキスト確率の洗練された使用法の中で、これらの基本的な概念を拡張します。結果は、与えられた品質でのデータ転送速度の大幅な減少です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike some similar schemes (the older MPEG formats, for example), VP8 specifies exact values for reconstructed pixels. Specifically, the specification for the DCT and WHT portions of the reconstruction does not allow for any &#34;drift&#34; caused by truncation of fractions. Rather, the algorithm is specified using fixed-precision integer operations exclusively. This greatly facilitates the verification of the correctness of a decoder implementation and also avoids difficult-to-predict visual incongruities between such implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの同様のスキーム（例えば古いMPEGフォーマット）とは異なり、VP8は、再構成画素について正確な値を指定します。具体的には、DCT及び再構成のWHT部分の仕様は、画分の切り捨てによって引き起こされる任意の「ドリフト」を可能にしません。むしろ、アルゴリズムは、排他的に固定精度の整数演算を使用して指定されます。これは大幅デコーダの実装の正当性の検証を容易にし、また難予測そのような実装の間の視覚的不適合を回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be remarked that, in a complete video playback system, the displayed frames may or may not be identical to the reconstructed frames. Many systems apply a final level of filtering (commonly referred to as postprocessing) to the reconstructed frames prior to viewing. Such postprocessing has no effect on the decoding and reconstruction of subsequent frames (which are predicted using the completely specified reconstructed frames) and is beyond the scope of this document. In practice, the nature and extent of this sort of postprocessing is dependent on both the taste of the user and on the computational facilities of the playback environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全なビデオ再生システムでは、表示フレームは、または再構成されたフレームと同一であってもなくてもよい、ということに留意すべきです。多くのシステムは、視聴の前再構成フレームのフィルタリングの最終レベル（一般に後処理と呼ばれる）を適用します。そのような後処理は、（完全に指定された再構成されたフレームを用いて予測される）と、この文書の範囲を超えて、後続フレームの復号および再構成に影響を及ぼしません。実際には、後処理のこの種の性質と程度は、ユーザの味の両方で、再生環境の計算機能に依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Format Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.フォーマットの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 works exclusively with an 8-bit YUV 4:2:0 image format. In this format, each 8-bit pixel in the two chroma planes (U and V) corresponds positionally to a 2x2 block of 8-bit luma pixels in the Y plane; coordinates of the upper left corner of the Y block are of course exactly twice the coordinates of the corresponding chroma pixels. When we refer to pixels or pixel distances without specifying a plane, we are implicitly referring to the Y plane or to the complete image, both of which have the same (full) resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2：0映像フォーマットVP8は、8ビットYUV 4で排他的に動作します。このフォーマットでは、二つの色差平面における各8ビットピクセル（U及びV）はY平面内の8ビットの輝度画素の2×2ブロックに位置対応します。 Yブロックの左上隅の座標が正確当然の対応クロマ画素の二倍座標です。我々は平面を指定せずにピクセルまたはピクセル距離を参照するとき、我々は、暗黙的に同じ（フル）解像度を有する両方とも、Y平面に、または完全な画像を参照しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As is usually the case, the pixels are simply a large array of bytes stored in rows from top to bottom, each row being stored from left to right. This &#34;left to right&#34; then &#34;top to bottom&#34; raster-scan order is reflected in the layout of the compressed data as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常そうであるように、画素は単に上から下への行に格納されたバイトの大きいアレイであり、各列は、左から右に記憶されています。これは、「左から右」、次いで「上から下へ、」ラスタスキャン順は同様に、圧縮データのレイアウトに反映されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Provision has been made in the VP8 bitstream header for the support of a secondary YUV color format, in the form of a reserved bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
規定は、予約ビットの形で、二次YUVカラーフォーマットをサポートするためのVP8ビットストリームヘッダてなされたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Occasionally, at very low datarates, a compression system may decide to reduce the resolution of the input signal to facilitate efficient compression. The VP8 data format supports this via optional upscaling of its internal reconstruction buffer prior to output (this is completely distinct from the optional postprocessing discussed earlier, which has nothing to do with decoding per se). This upsampling restores the video frames to their original resolution. In other words, the compression/decompression system can be viewed as a &#34;black box&#34;, where the input and output are always at a given resolution. The compressor might decide to &#34;cheat&#34; and process the signal at a lower resolution. In that case, the decompressor needs the ability to restore the signal to its original resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時々、非常に低いデータレートで、圧縮システムは、効率的な圧縮を容易にするために、入力信号の解像度を低減することを決定することができます。 VP8データ形式（これは、復号自体とは何の関係もない前述任意の後処理から完全に区別される）出力前にその内部再構成バッファのオプションのアップスケーリングを介してこれを支持します。このアップサンプリングは、元の解像度にビデオフレームを復元します。換言すれば、圧縮/伸張システムは、入力と出力が所定の解像度で常に「ブラックボックス」として見ることができます。コンプレッサーは「カンニング」と低い解像度で信号を処理することを決定するかもしれません。その場合、デコンプレッサは、元の解像度の信号を復元する能力を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internally, VP8 decomposes each output frame into an array of macroblocks. A macroblock is a square array of pixels whose Y dimensions are 16x16 and whose U and V dimensions are 8x8. Macroblock-level data in a compressed frame occurs (and must be processed) in a raster order similar to that of the pixels comprising the frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
内部的には、VP8は、マクロブロックの配列に各出力フレームを分解する。マクロブロックはY寸法である16×16とUとVの大きさ8×8である画素の正方形のアレイです。圧縮フレームにおけるマクロブロックレベルのデータが発生（及び処理されなければならない）フレームを構成する画素と同様のラスタ順に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Macroblocks are further decomposed into 4x4 subblocks. Every macroblock has 16 Y subblocks, 4 U subblocks, and 4 V subblocks. Any subblock-level data (and processing of such data) again occurs in raster order, this time in raster order within the containing macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マクロブロックは、さらに4×4のサブブロックに分解されます。すべてのマクロブロックは、16個のYサブブロック、4つのUのサブブロック、および4 Vサブブロックを有します。任意のサブブロックレベルのデータ（およびそのようなデータの処理）を再度、ラスタ順に含むマクロブロック内のラスタ順に、この時間を生じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in further detail below, data can be specified at the levels of both macroblocks and their subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下でさらに詳細に議論されるように、データは、マクロブロックとそのサブブロックの両方のレベルで指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pixels are always treated, at a minimum, at the level of subblocks, which may be thought of as the &#34;atoms&#34; of the VP8 algorithm. In particular, the 2x2 chroma blocks corresponding to 4x4 Y subblocks are never treated explicitly in the data format or in the algorithm specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画素は常にVP8アルゴリズムの「原子」と考えることができるサブブロックのレベルで、最低でも、処理されます。具体的には、4×4 Yサブブロックに対応する2×2のクロマ・ブロックは、データ形式またはアルゴリズム明細書に明示的に扱われることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCT and WHT always operate at a 4x4 resolution. The DCT is used for the 16Y, 4U, and 4V subblocks. The WHT is used (with some but not all prediction modes) to encode a 4x4 array comprising the average intensities of the 16 Y subblocks of a macroblock. These average intensities are, up to a constant normalization factor, nothing more than the 0th DCT coefficients of the Y subblocks. This &#34;higher-level&#34; WHT is a substitute for the explicit specification of those coefficients, in exactly the same way as the DCT of a subblock substitutes for the specification of the pixel values comprising the subblock. We consider this 4x4 array as a second-order subblock called Y2, and think of a macroblock as containing 24 &#34;real&#34; subblocks and, sometimes, a 25th &#34;virtual&#34; subblock. This is dealt with further in Section 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCTとWHTは常に4×4の解像度で動作します。 DCTは16Y、4U、4Vおよびサブブロックのために使用されています。 WHTは、マクロブロックの16個のYのサブブロックの平均強度を含む4×4アレイを符号化するために（一部ではなく、すべての予測モードで）使用されます。これらの平均強度は、アップ一定の正規化係数に、Yのサブブロックの0番目のDCT係数に過ぎません。この「高レベル」WHTは、サブブロックを含む画素値の指定のためのサブブロック代替のDCTと全く同じようにこれらの係数を明示的に指定するための代替です。私たちは、時々、第25回「仮想」サブブロックを二次サブブロックと呼ばれるY2として、この4×4アレイを考慮し、24「本物」のサブブロックを含むものとして、マクロブロックを考えると。これは、第13節でさらに扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The frame layout used by the reference decoder may be found in the file vpx_image.h (Section 20.23).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基準デコーダによって使用されるフレームのレイアウトはファイルvpx_image.h（セクション20.23）に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Compressed Frame Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.圧縮フレームタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are only two types of frames in VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8のフレームの唯一の2つのタイプがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intraframes (also called key frames and, in MPEG terminology, I-frames) are decoded without reference to any other frame in a sequence; that is, the decompressor reconstructs such frames beginning from its &#34;default&#34; state. Key frames provide random access (or seeking) points in a video stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（また、キーフレームと、MPEG用語では、Iフレームと呼ばれる）イントラフレームは、シーケンス内の他のフレームを参照せずに復号されます。つまり、デコンプレッサは、その「デフォルト」の状態から始まるようなフレームを再構築します。キーフレームは、ビデオストリームにおけるランダムアクセス（または求めている）ポイントを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interframes (also called prediction frames and, in MPEG terminology, P-frames) are encoded with reference to prior frames, specifically all prior frames up to and including the most recent key frame. Generally speaking, the correct decoding of an interframe depends on the correct decoding of the most recent key frame and all ensuing frames. Consequently, the decoding algorithm is not tolerant of dropped frames: In an environment in which frames may be dropped or corrupted, correct decoding will not be possible until a key frame is correctly received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターフレームは、前のフレームを参照して、最も最近のキーフレームを含むアップ具体すべての前フレームを符号化される（また、MPEG用語で、Pフレームは、予測フレームと呼ばれます）。一般的に言って、インターの正しい復号化は、最新のキーフレームの正しい復号化し、すべてのその後のフレームに依存します。これにより、復号化アルゴリズムは、ドロップされたフレームの耐性はない：キーフレームが正しく受信されるまで、削除または破損している可能性がありフレームれる環境では、正しい復号化ができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In contrast to MPEG, there is no use of bidirectional prediction. No frame is predicted using frames temporally subsequent to it; there is no analog to an MPEG B-frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPEGとは対照的に、双方向予測の使用はありません。何フレームは、それに時間的に後のフレームを用いて予測されません。 MPEG Bフレームへのアナログはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secondly, VP8 augments these notions with that of alternate prediction frames, called golden frames and altref frames (alternative reference frames). Blocks in an interframe may be predicted using blocks in the immediately previous frame as well as the most recent golden frame or altref frame. Every key frame is automatically golden and altref, and any interframe may optionally replace the most recent golden or altref frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二に、VP8ゴールデンフレームとaltrefフレーム（別の参照フレーム）と呼ばれる代替的な予測フレーム、のものとこれらの概念を増強します。インター内のブロックは、直前のフレームだけでなく、最新の金色のフレームまたはaltrefフレーム内のブロックを用いて予測することができます。すべてのキーフレームが自動的に黄金とaltrefあり、そして任意のインターは、必要に応じて最新の黄金やaltrefフレームを交換することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Golden frames and altref frames may also be used to partially overcome the intolerance to dropped frames discussed above: If a compressor is configured to code golden frames only with reference to the prior golden frame (and key frame), then the &#34;substream&#34; of key and golden frames may be decoded regardless of loss of other interframes. Roughly speaking, the implementation requires (on the compressor side) that golden frames subsume and recode any context updates effected by the intervening interframes. A typical application of this approach is video conferencing, in which retransmission of a prior golden frame and/or a delay in playback until receipt of the next golden frame is preferable to a larger retransmit and/or delay until the next key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その後、圧縮機のみ前ゴールデンフレーム（およびキーフレーム）を参照して金色のフレームを符号化するように構成されている場合、キーの「サブ」：ゴールデンフレームとフレームaltref部分的に上述のフレームをドロップする不耐性を克服するためにも使用することができますそして金色のフレームにかかわらず、他のインターフレームの損失をデコードすることができます。大まかに言えば、実装ゴールデンフレームが包摂および介在インターフレームによって行わ任意のコンテキストの更新を再符号化することを（圧縮機側）を必要とします。このアプローチの典型的なアプリケーションは、従来の金色フレームおよび/または次黄金フレームを受信するまで再生の遅延の再送が次のキーフレームまで大きく再送信、および/または遅延に好適であるビデオ会議です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Overview of Compressed Data Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
圧縮データフォーマットの4概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input to a VP8 decoder is a sequence of compressed frames whose order matches their order in time. Issues such as the duration of frames, the corresponding audio, and synchronization are generally provided by the playback environment and are irrelevant to the decoding process itself; however, to aid in fast seeking, a start code is included in the header of each key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8デコーダへの入力は順序時にそれらの順序に一致する圧縮フレームのシーケンスです。そのようなフレームの持続時間は、対応するオーディオ、および同期化などの問題は、一般に、再生環境によって提供され、復号化プロセス自体とは無関係されています。しかし、高速シークを助けるために、スタートコードは、各キーフレームのヘッダに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder is simply presented with a sequence of compressed frames and produces a sequence of decompressed (reconstructed) YUV frames corresponding to the input sequence. As stated in the Introduction, the exact pixel values in the reconstructed frame are part of VP8&#39;s specification. This document specifies the layout of the compressed frames and gives unambiguous algorithms for the correct production of reconstructed frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダは、単に圧縮されたフレームのシーケンスを提示し、入力シーケンスに対応する圧縮解除（再構築）YUVフレームのシーケンスを生成します。冒頭で述べたように、再構成されたフレームの正確な画素値はVP8の仕様の一部です。この文書では、圧縮されたフレームのレイアウトを指定し、再構築されたフレームの正しい生産のための明確なアルゴリズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first frame presented to the decompressor is of course a key frame. This may be followed by any number of interframes; the correct reconstruction of each frame depends on all prior frames up to the key frame. The next key frame restarts this process: The decompressor resets to its default initial condition upon reception of a key frame, and the decoding of a key frame (and its ensuing interframes) is completely independent of any prior decoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解凍器に提示最初のフレームはもちろん、キーフレームです。これは、インターフレームの任意の数が続いてもよいです。各フレームの正確な再構成は、キーフレームまでの全ての前のフレームに依存します。次のキーフレームが再起動し、このプロセス：キーフレームを受信すると、そのデフォルトの初期状態にデコンプレッサリセット、およびキーフレームの復号（およびその後続インターフレーム）は、任意の復号化の前の完全に独立しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the highest level, every compressed frame has three or more pieces. It begins with an uncompressed data chunk comprising 10 bytes in the case of key frames and 3 bytes for interframes. This is followed by two or more blocks of compressed data (called partitions). These compressed data partitions begin and end on byte boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最高レベルでは、すべての圧縮フレームは3個以上を持っています。これは、キーフレームおよびインターフレームのための3バイトの場合には10のバイトを含む非圧縮データのチャンクから始まります。これは、圧縮されたデータ（と呼ばれるパーティション）の2つ以上のブロックが続いています。これらの圧縮されたデータパーティションが始まり、バイト境界で終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first compressed partition has two subsections:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の圧縮されたパーティションは、2つのサブセクションがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Header information that applies to the frame as a whole.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
全体としてのフレームに適用される1ヘッダー情報。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Per-macroblock information specifying how each macroblock is predicted from the already-reconstructed data that is available to the decompressor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各マクロブロックは、デコンプレッサに利用可能で既に再構成されたデータから予測される方法を指定する2単位のマクロブロック情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated above, the macroblock-level information occurs in raster-scan order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述したように、マクロブロック・レベルの情報は、ラスタスキャン順に起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of the partitions contain, for each block, the DCT/WHT coefficients (quantized and logically compressed) of the residue signal to be added to the predicted block values. It typically accounts for roughly 70% of the overall datarate. VP8 supports packing the compressed DCT/WHT coefficients&#39; data from macroblock rows into separate partitions. If there is more than one partition for these coefficients, the sizes of the partitions -- except the last partition -- in bytes are also present in the bitstream right after the above first partition. Each of the sizes is a 3-byte data item written in little endian format. These sizes provide the decoder direct access to all DCT/WHT coefficient partitions, which enables parallel processing of the coefficients in a decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パーティションの残りの部分は、各ブロックについて、予測ブロックの値に追加される残差信号のDCT / WHT係数（量子化された論理的圧縮）を含みます。それは、典型的には、全体的なデータレートの約70％を占めています。 VP8は別々のパーティションにマクロブロック行から圧縮DCT / WHT係数のデータをパックサポートしています。これらの係数のために複数のパーティションがある場合は、パーティションのサイズ - 最後のパーティションを除く - バイト単位では、右上記の最初のパーティションの後にも、ビットストリーム中に存在しています。サイズはそれぞれ、リトルエンディアン形式で記述された3バイトのデータ項目です。これらのサイズは、デコーダ内の係数の並列処理を可能にする全てのDCT / WHT係数のパーティションにデコーダの直接アクセスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The separate partitioning of the prediction data and coefficient data also allows flexibility in the implementation of a decompressor: An implementation may decode and store the prediction information for the whole frame and then decode, transform, and add the residue signal to the entire frame, or it may simultaneously decode both partitions, calculating prediction information and adding in the residue signal for each block in order. The length field in the frame tag, which allows decoding of the second partition to begin before the first partition has been completely decoded, is necessary for the second &#34;block-at-a-time&#34; decoder implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装がデコードし、フレーム全体の予測情報を格納し、復号化、変換、及びフレーム全体に残差信号を加算、またはできる：予測データと係数データの別個の分割はまた、減圧装置の実装の柔軟性を可能にしますそれは同時に予測情報を計算し、順番に各ブロックの残差信号に加算し、両方のパーティションを復号することができます。最初のパーティションが完全に復号された前に、第2パーティションの復号化を開始することを可能にするフレームタグ、長さフィールドは、第二の「ブロック・アット・タイム」デコーダの実装のために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All partitions are decoded using separate instances of the boolean entropy decoder described in Section 7. Although some of the data represented within the partitions is conceptually &#34;flat&#34; (a bit is just a bit with no probabilistic expectation one way or the other), because of the way such coders work, there is never a direct correspondence between a &#34;conceptual bit&#34; and an actual physical bit in the compressed data partitions. Only in the 3- or 10-byte uncompressed chunk described above is there such a physical correspondence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのパーティションは、（ビットがない確率的期待一方向又は相互に少しだけである）パーティション内に表されるデータの一部は、概念的に「フラット」であるが、セクション7に記載のブールエントロピー復号器の別のインスタンスを使用して復号されるためそのようなコーダは、作業方法の、「概念的なビット」と圧縮されたデータ・パーティション内の実際の物理的なビットとの間に直接的な対応が存在ことはありません。のみ上記3-または10バイトの非圧縮チャンクにそのような物理的な対応があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A related matter is that seeking within a partition is not supported. The data must be decompressed and processed (or at least stored) in the order in which it occurs in the partition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連する問題は、パーティション内で求めているがサポートされていないことです。データを解凍し、それがパーティションで発生した順序で処理された（または少なくとも記憶）されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While this document specifies the ordering of the partition data correctly, the details and semantics of this data are discussed in a more logical fashion to facilitate comprehension. For example, the frame header contains updates to many probability tables used in decoding per-macroblock data. The per-macroblock data is often described before the layouts of the probabilities and their updates, even though this is the opposite of their order in the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は正しくパーティションのデータの順序を指定しますが、このデータの詳細と意味は理解を容易にするために、より論理的な方法で説明されています。例えば、フレームヘッダごとのマクロブロックデータの復号に使用される多くの確率テーブルの更新を含んでいます。ごとのマクロブロックのデータは、多くの場合、これはビットストリーム内の順序とは逆であっても、確率とそのアップデートのレイアウトの前に記述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Overview of the Decoding Process
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
復号処理の概要5。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A VP8 decoder needs to maintain four YUV frame buffers whose resolutions are at least equal to that of the encoded image. These buffers hold the current frame being reconstructed, the immediately previous reconstructed frame, the most recent golden frame, and the most recent altref frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8デコーダは、その解像度の符号化画像と少なくとも等しい4つのYUVフレームバッファを維持する必要があります。これらのバッファは、再構成されている現在のフレーム、直前の再構成されたフレーム、最新の金色のフレーム、および最新のaltrefフレームを保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most implementations will wish to &#34;pad&#34; these buffers with &#34;invisible&#34; pixels that extend a moderate number of pixels beyond all four edges of the visible image. This simplifies interframe prediction by allowing all (or most) prediction blocks -- which are not guaranteed to lie within the visible area of a prior frame -- to address usable image data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの実装では、可視画像のすべての4つの辺を超えた画素の適度な数を拡張する「見えない」ピクセルと「パッド」、これらのバッファを希望します。使用可能な画像データに対処するために - 前のフレームの表示領域内に存在することが保証されていない - これは、すべての（又はほとんどの）予測ブロックを可能にすることによって、フレーム間予測を簡単にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the amount of padding chosen, the invisible rows above (or below) the image are filled with copies of the top (or bottom) row of the image; the invisible columns to the left (or right) of the image are filled with copies of the leftmost (or rightmost) visible row; and the four invisible corners are filled with copies of the corresponding visible corner pixels. The use of these prediction buffers (and suggested sizes for the halo) will be elaborated on in the discussion of motion vectors, interframe prediction, and sub-pixel interpolation later in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
かかわらず、選択されたパディングの量の、画像上（または下）不可視行は画像の上部（または下部）行のコピーが充填されています。画像の不可視左列（又は右）は、左端（または右端）可視行のコピーが充填されています。四本の不可視角が対応する可視コーナーピクセルのコピーが充填されています。これらの予測バッファの使用（およびハロためにサイズを示唆）がこのドキュメントの動きベクトル、フレーム間予測、およびサブピクセル補間の議論において上で詳述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As will be seen in the description of the frame header, the image dimensions are specified (and can change) with every key frame. These buffers (and any other data structures whose size depends on the size of the image) should be allocated (or re-allocated) immediately after the dimensions are decoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームヘッダの説明で分かるように、画像の寸法が指定されている（そして変更することができる）すべてのキーフレームで。これらのバッファ（およびそのサイズ画像のサイズに依存する他のデータ構造）は、寸法がデコードされた直後に割り当てられなければならない（又は再割り当て）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Leaving most of the details for later elaboration, the following is an outline of the decoding process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後で精緻化のための詳細のほとんどを残して、次のように復号処理の概要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, the frame header (the beginning of the first data partition) is decoded. Altering or augmenting the maintained state of the decoder, this provides the context in which the per-macroblock data can be interpreted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、フレームヘッダ（最初のデータ・パーティションの開始）が復号されます。デコーダの保持状態を変更または増強、このごとのマクロブロックデータを解釈することができるコンテキストを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macroblock data occurs (and must be processed) in raster-scan order. This data comes in two or more parts. The first (prediction or mode) part comes in the remainder of the first data partition. The other parts comprise the data partition(s) for the DCT/WHT coefficients of the residue signal. For each macroblock, the prediction data must be processed before the residue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マクロブロックデータは、ラスタスキャン順に発生（及び処理されなければなりません）。このデータは、2つ以上の部分で提供されます。最初の（予測又はモード）部分は、第1のデータ・パーティションの残りの部分に来ます。その他の部分は、残差信号のDCT / WHT係数のデータ・パーティション（複数可）を含みます。各マクロブロックについて、予測データは、残基の前に処理されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each macroblock is predicted using one (and only one) of four possible frames. All macroblocks in a key frame, and all intra-coded macroblocks in an interframe, are predicted using the already-decoded macroblocks in the current frame. Macroblocks in an interframe may also be predicted using the previous frame, the golden frame, or the altref frame. Such macroblocks are said to be inter-coded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各マクロブロックは、4つの可能なフレームのうちの1つ（1つのみ）を用いて予測されます。キーフレームのすべてのマクロブロック、及びフレーム間における全てのイントラ符号化マクロブロックは、現在のフレーム内の既に復号化されたマクロブロックを用いて予測されます。フレーム間におけるマクロブロックは、前のフレーム、ゴールデンフレーム、又はaltrefフレームを用いて予測することができます。そのようなマクロブロックはインター符号化であると言われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of prediction is to use already-constructed image data to approximate the portion of the original image being reconstructed. The effect of any of the prediction modes is then to write a macroblock-sized prediction buffer containing this approximation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予測の目的は、再構成されている原画像の一部分を近似するように既に構成された画像データを使用することです。予測モードのいずれかの効果は、この近似を含むマクロブロックサイズの予測バッファを記述することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the prediction method, the residue DCT signal is decoded, dequantized, reverse-transformed, and added to the prediction buffer to produce the (almost final) reconstruction value of the macroblock, which is stored in the correct position of the current frame buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
かかわらず、予測方法の、残基DCT信号は、復号化され逆量子化、逆変換、及び現在のフレームバッファの正しい位置に記憶されたマクロブロック、の（ほぼ最終的な）再構成値を生成する予測バッファに追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The residue signal consists of 24 (sixteen Y, four U, and four V) 4x4 quantized and losslessly compressed DCT transforms approximating the difference between the original macroblock in the uncompressed source and the prediction buffer. For most prediction modes, the 0th coefficients of the sixteen Y subblocks are expressed via a 25th WHT of the second-order virtual Y2 subblock discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残差信号は、24（16 Y 4 U、4 V）から成る4×4の量子化及び無損失圧縮DCTは、非圧縮のソースと予測バッファ内のオリジナルのマクロブロックとの差を近似変換します。最も予測モードのために、16 Yサブブロックの0番目の係数は、上述の二次仮想Y2サブブロックの25 WHTを介して発現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intra-prediction exploits the spatial coherence of frames. The 16x16 luma (Y) and 8x8 chroma (UV) components are predicted independently of each other using one of four simple means of pixel propagation, starting from the already-reconstructed (16-pixel-long luma, 8-pixel-long chroma) row above, and column to the left of, the current macroblock. The four methods are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イントラ予測は、フレームの空間コヒーレンスを利用します。 16×16の輝度（Y）および8×8クロマは（UV）成分は、既に再構成された（16ピクセル長輝度、8画素長クロマ）から出発して、画素伝播の4つの簡単な手段のいずれかを使用して、互いに独立して予測されます上記行、及び現在のマクロブロックの左側の列。 4つの方法があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Copying the row from above throughout the prediction buffer.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.予測バッファを通して上から行をコピーします。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Copying the column from the left throughout the prediction buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.予測バッファを通して左から列をコピーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Copying the average value of the row and column throughout the prediction buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.予測バッファ全体に行と列の平均値をコピーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Extrapolation from the row and column using the (fixed) second difference (horizontal and vertical) from the upper left corner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
左上から（水平および垂直）（固定）は、第2の差を使用して行と列から4の外挿。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, the sixteen Y subblocks may be predicted independently of each other using one of ten different modes, four of which are 4x4 analogs of those described above, augmented with six &#34;diagonal&#34; prediction methods. There are two types of predictions, one intra and one prediction (among all the modes), for which the residue signal does not use the Y2 block to encode the DC portion of the sixteen 4x4 Y subblock DCTs. This &#34;independent Y subblock&#34; mode has no effect on the 8x8 chroma prediction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、16 Yサブブロックは、6つの「対角線」予測方法で増強、上記のものの4×4類似体である4つのうち10個の異なるモード、のいずれかを使用して、互いに独立して予測することができます。残差信号は、16個の4×4 YのサブブロックのDCTのDC部分を符号化するためにY2ブロックを使用しないため、予測の2種類1つのイントラ及び（全てのモードのうちの）1つの予測があります。この「独立したYのサブブロック」モードでは、8×8クロマ予測には影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inter-prediction exploits the temporal coherence between nearby frames. Except for the choice of the prediction frame itself, there is no difference between inter-prediction based on the previous frame and that based on the golden frame or altref frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インター予測は、近くのフレーム間の時間的コヒーレンスを利用します。予測フレーム自体の選択を除いて、金色のフレームまたはaltrefフレームに基づいて、前のフレームに基づいて、インター予測とその違いはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inter-prediction is conceptually very simple. While, for reasons of efficiency, there are several methods of encoding the relationship between the current macroblock and corresponding sections of the prediction frame, ultimately each of the sixteen Y subblocks is related to a 4x4 subblock of the prediction frame, whose position in that frame differs from the current subblock position by a (usually small) displacement. These two-dimensional displacements are called motion vectors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インター予測は、概念的には非常に簡単です。 、効率の理由のために、予測フレームの現在のマクロブロックと対応するセクションとの間の関係をコードするいくつかの方法があるが、最終的に16 Yのサブブロックの各々は、予測フレームの4×4サブブロックに関連して、その位置がそのフレームに（通常は小さな）変位によって現在のサブブロックの位置は異なります。これらの二次元変位は、動きベクトルと呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The motion vectors used by VP8 have quarter-pixel precision. Prediction of a subblock using a motion vector that happens to have integer (whole number) components is very easy: The 4x4 block of pixels from the displaced block in the previous, golden, or altref frame is simply copied into the correct position of the current macroblock&#39;s prediction buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8によって使用される動きベクトルは1/4画素精度を有します。整数（整数）の成分を持つように起こる動きベクトルを用いてサブブロックの予測は非常に容易である：前、黄金、又はaltrefフレーム内の変位したブロックからのピクセルの4×4ブロックは、単に現在の正しい位置にコピーされますマクロブロックの予測バッファ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fractional displacements are conceptually and implementationally more complex. They require the inference (or synthesis) of sample values that, strictly speaking, do not exist. This is one of the most basic problems in signal processing, and readers conversant with that subject will see that the approach taken by VP8 provides a good balance of robustness, accuracy, and efficiency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラクショナル変位は概念的およびimplementationallyより複雑です。彼らは、厳密に言えば、存在しない、サンプル値の推論（または合成）が必要です。これは、信号処理における最も基本的な問題の一つであり、その対象に精通読者はVP8によって撮影されたアプローチは、堅牢性、精度、及び効率の良好なバランスを提供することがわかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Leaving the details for the implementation discussion below, the pixel interpolation is calculated by applying a kernel filter (using reasonable-precision integer math) three pixels on either side, both horizontally and vertically, of the pixel to be synthesized. The resulting 4x4 block of synthetic pixels is then copied into position exactly as in the case of integer displacements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の実施議論の詳細を残して、画素補間を合成するピクセルの、水平方向と垂直方向の両方、いずれかの側に（合理的な精度の整数演算を使用して）3つの画素をカーネルフィルタを適用することによって計算されます。合成画素の結果として得られる4×4ブロックは、その後、正確整数変位の場合と同様の位置にコピーされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the eight chroma subblocks is handled similarly. Their motion vectors are never specified explicitly; instead, the motion vector for each chroma subblock is calculated by averaging the vectors of the four Y subblocks that occupy the same area of the frame. Since chroma pixels have twice the diameter (and four times the area) of luma pixels, the calculated chroma motion vectors have 1/8-pixel resolution, but the procedure for copying or generating pixels for each subblock is essentially identical to that done in the luma plane.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8つのクロマサブブロックのそれぞれは、同様に処理されます。彼らの動きベクトルは、明示的に指定されることはありません。代わりに、各クロマ・サブブロックの動きベクトルは、フレームの同じ領域を占める4つのYサブブロックのベクトルを平均することによって計算されます。クロマ画素は輝度画素の二倍の直径（及び4倍領域）を有しているので、計算されたクロマ動きベクトルは、1/8ピクセル解像度を有するが、各サブブロックのピクセルをコピーまたは生成するための手順は、で行われたものと本質的に同一でありますルマ平面。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After all the macroblocks have been generated (predicted and corrected with the DCT/WHT residue), a filtering step (the loop filter) is applied to the entire frame. The purpose of the loop filter is to reduce blocking artifacts at the boundaries between macroblocks and between subblocks of the macroblocks. The term &#34;loop filter&#34; is used because this filter is part of the &#34;coding loop&#34;; that is, it affects the reconstructed frame buffers that are used to predict ensuing frames. This is distinguished from the postprocessing filters discussed earlier, which affect only the viewed video and do not &#34;feed into&#34; subsequent frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全てのマクロブロックを生成（予測とDCT / WHT残基で補正）された後、フィルタリングステップ（ループフィルタ）がフレーム全体に適用されます。ループフィルタの目的は、マクロブロック間及びマクロブロックのサブブロックの境界にブロッキングアーティファクトを減少させることです。このフィルタは、「符号化ループ」の一部であるため、用語「ループフィルタ」が使用されます。つまり、それはその後のフレームを予測するために使用される再構成されたフレームバッファに影響を与えます。これは、視聴映像に影響を与え、その後のフレーム「に供給」していない前述した後処理フィルタとは区別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Next, if signaled in the data, the current frame may replace the golden frame prediction buffer and/or the altref frame buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、データにシグナリング場合、現在のフレームゴールデンフレーム予測バッファ及び/又はaltrefフレームバッファを交換してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The halos of the frame buffers are next filled as specified above. Finally, at least as far as decoding is concerned, the (references to) the &#34;current&#34; and &#34;last&#34; frame buffers should be exchanged in preparation for the next frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記指定されたフレームバッファのハロー次に充填されます。最後に、少なくとも限り復号化に関しては、（参考文献の）「現在の」および「最後」のフレームバッファは、次のフレームの準備のために交換されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Various processes may be required (or desired) before viewing the generated frame. As discussed in the frame dimension information below, truncation and/or upscaling of the frame may be required. Some playback systems may require a different frame format (RGB, YUY2, etc.). Finally, as mentioned in the Introduction, further postprocessing or filtering of the image prior to viewing may be desired. Since the primary purpose of this document is a decoding specification, the postprocessing is not specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
様々なプロセスが生成されたフレームを表示する前に必要な（または所望の）ことができます。下フレーム寸法情報に論じたように、フレームの切り捨て及び/又はアップスケーリングは必要とされ得ます。一部の再生システムは、異なるフレームフォーマット（RGB、YUY2、等）を必要とするかもしれません。前視野の画像の紹介、さらに後処理またはフィルタリングで述べたように、最終的に、所望され得ます。この文書の主な目的は、復号化仕様であるため、後処理は、この文書で指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the basic ideas of prediction and correction used by VP8 are straightforward, many of the details are quite complex. The management of probabilities is particularly elaborate. Not only do the various modes of intra-prediction and motion vector specification have associated probabilities, but they, together with the coding of DCT coefficients and motion vectors, often base these probabilities on a variety of contextual information (calculated from what has been decoded so far), as well as on explicit modification via the frame header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8が使用する予測と補正の基本的な考え方は単純ですが、詳細の多くは非常に複雑です。確率の管理は特に精巧です。イントラ予測との動きベクトル仕様の様々なモードは確率が関連付けられているが、彼らは、一緒にDCT係数と動きベクトルのコーディングと、多くの場合、コンテキスト情報のさまざまなこれらの確率をベースにしないだけで（そのデコードされたものから計算遠）、ならびにフレームヘッダを介して明示的に変更に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;top-level&#34; of decoding and frame reconstruction is implemented in the reference decoder file dixie.c (Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
復号および再構成フレームの「トップレベル」は、参照デコーダファイルdixie.c（セクション20.4）に実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This concludes our summary of decoding and reconstruction; we continue by discussing the individual aspects in more depth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、デコードと復興の私達の要約を終えます。我々はより多くの深さで個々の側面を議論することにより、継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reasonable &#34;divide and conquer&#34; approach to implementation of a decoder is to begin by decoding streams composed exclusively of key frames. After that works reliably, interframe handling can be added more easily than if complete functionality were attempted immediately. In accordance with this, we first discuss components needed to decode key frames (most of which are also used in the decoding of interframes) and conclude with topics exclusive to interframes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「分割統治」合理デコーダの実装へのアプローチは、排他的にキーフレームからなるストリームをデコードすることにより開始します。それが確実に動作した後、フレーム間の取り扱いをより簡単に、完全な機能はすぐにしようとした場合よりも追加することができます。これに応じて、我々は最初のキーフレームをデコードするために必要なコンポーネントを（そのほとんどはまた、インターフレームのデコードに使用されている）について議論し、インターフレームへの排他的な話題と結論付けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Description of Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
アルゴリズムの6.説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the intent of this document, together with the reference decoder source code, is to specify a platform-independent procedure for the decoding and reconstruction of a VP8 video stream, many (small) algorithms must be described exactly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の目的として、共に参照デコーダのソースコードと、VP8ビデオストリームの復号および再構成のために、プラットフォームに依存しない手順を指定することで、多くの（小さな）アルゴリズムが正確に記載されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to its near-universality, terseness, ability to easily describe calculation at specific precisions, and the fact that On2&#39;s reference VP8 decoder is written in C, these algorithm fragments are written using the C programming language, augmented with a few simple definitions below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、その近普遍、簡潔、容易に特定の精度で計算を説明するための能力、及びはOn2の基準VP8デコーダはCで書かれているという事実のために、これらのアルゴリズムの断片は、以下のいくつかの簡単な定義を拡張Cプログラミング言語を用いて書かれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The standard (and best) reference for C is [Kernighan].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cのための標準的な（そして最高の）参照が[カーニハン]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many code fragments will be presented in this document. Some will be nearly identical to corresponding sections of the reference decoder; others will differ. Roughly speaking, there are three reasons for such differences:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのコードの断片は、この文書で提示されます。いくつかの基準デコーダのセクションに対応するとほぼ同じであろう。他の人が異なります。大雑把に言えば、このような差異のための3つの理由があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. For reasons of efficiency, the reference decoder version may be less obvious.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.効率の理由から、基準デコーダのバージョンはそれほど明白であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The reference decoder often uses large data structures to maintain context that need not be described or used here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2リファレンスデコーダは、多くの場合、ここに記載又は使用する必要がないコンテキストを維持するために、大規模なデータ構造を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The authors of this document felt that a different expression of the same algorithm might facilitate exposition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.本書の著者は、同じアルゴリズムの異なる発現は、博覧会を促進するかもしれないと感じました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the chosen presentation, the calculation effected by any of the algorithms described here is identical to that effected by the corresponding portion of the reference decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
かかわらず、選択されたプレゼンテーションの、ここで説明したアルゴリズムのいずれかによって影響を受けた計算は、基準デコーダの対応する部分の影響を受けたものと同一です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All VP8 decoding algorithms use integer math. To facilitate specification of arithmetic precision, we define the following types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのVP8デコードアルゴリズムは、整数演算を使用します。演算精度の仕様を容易にするために、我々は、以下のタイプを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef   signed char  int8; /* signed int exactly 8 bits wide */
   typedef unsigned char uint8; /* unsigned &#34;&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef short int16;         /* signed int exactly 16 bits wide */
   typedef unsigned int16 uint16; /* unsigned &#34;&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* int32 is a signed integer type at least 32 bits wide */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef long int32; /* guaranteed to work on all systems */
   typedef int  int32; /* will be more efficient on some systems */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef unsigned int32 uint32;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
符号なしのInt32 UINT32のtypedef。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* unsigned integer type, at least 16 bits wide, whose exact size
      is most convenient to whatever processor we are using */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef unsigned int uint;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsigned int型UINTのtypedef。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* While pixels themselves are 8-bit unsigned integers,
      pixel arithmetic often occurs at 16- or 32-bit precision and
      the results need to be &#34;saturated&#34; or clamped to an 8-bit
      range. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint8 Pixel;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UINT8ピクセルのtypedef。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pixel clamp255(int32 v) { return v &lt; 0? 0 : (v &lt; 255? v : 255);}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画素klamp255（INT32で）{&lt;0でリサイクル比？ 0（&lt;255：255）;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*  As is elaborated in the discussion of the bool_decoder below,
       VP8 represents probabilities as unsigned 8-bit numbers. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint8 Prob;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UINT8度Probのtypedef。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We occasionally need to discuss mathematical functions involving honest-to-goodness &#34;infinite precision&#34; real numbers. The DCT is first described via the cosine function cos; the ratio of the lengths of the circumference and diameter of a circle is denoted pi; at one point, we take a (base 1/2) logarithm, denoted log; and pow(x, y) denotes x raised to the power y. If x = 2 and y is a small non-negative integer, pow(2, y) may be expressed in C as 1 &lt;&lt; y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、時折、正直ツー良さ「無限の精度」実数を含む数学関数を議論する必要があります。 DCTは、第コサイン関数COSを介して説明されています。円の円周と直径の長さの比は、PI示されています。ある時点で、我々は、（ベース1/2）対数、示さログを取ります。そしてPOW（x、y）はy乗Xを表します。 x = 2およびyは小さな非負整数である場合、POW（2、y）は1つの&lt;&lt; yとCで表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, we sometimes need to divide signed integers by powers of two; that is, we occasionally right-shift signed numbers. The behavior of such shifts (i.e., the propagation of the sign bit) is, perhaps surprisingly, not defined by the C language itself and is left up to individual compilers. Because of the utility of this frequently needed operation, it is at least arguable that it should be defined by the language (to naturally propagate the sign bit) and, at a minimum, should be correctly implemented by any reasonable compiler. In the interest of strict portability, we attempt to call attention to these shifts when they arise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、私たちは時々、2の累乗による符号付き整数を分割する必要があります。つまり、我々は時折右シフトは、数字に署名しました。このようなシフトの挙動（すなわち、符号ビットの伝播）は、おそらく驚くべきことに、C言語そのものによって定義されておらず、個々のコンパイラに任されます。このため、頻繁に必要な操作の有用性、それは言語によって定義されるべきである（当然符号ビットを伝播する）と、最低でも、正確に任意の合理的なコンパイラによって実装されるべきであること、少なくとも議論の余地があります。厳格な可搬性の関心では、我々は、彼らが発生した場合、これらの変化に注意を喚起しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Boolean Entropy Decoder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.ブールエントロピーデコーダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in the overview above, essentially the entire VP8 data stream is encoded using a boolean entropy coder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の概要で述べたように、本質的に全体VP8データストリームはブールエントロピー符号化器を使用して符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An understanding of the bool_decoder is critical to the implementation of a VP8 decompressor, so we discuss the bool_decoder in detail. It is easier to comprehend the bool_decoder in conjunction with the bool_encoder used by the compressor to write the compressed data partitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bool_decoderの理解はVP8の伸長器の実装に不可欠であるので、我々は詳細にbool_decoderを議論します。圧縮されたデータパーティションを書くためにコンプレッサーで使用bool_encoderと一緒にbool_decoderを理解する方が簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bool_encoder encodes (and the bool_decoder decodes) one bool (zero-or-one boolean value) at a time. Its purpose is to losslessly compress a sequence of bools for which the probability of their being zero or one can be well-estimated (via constant or previously coded information) at the time they are written, using identical corresponding probabilities at the time they are read.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時bool_encoderは、コード（及びbool_decoderはデコード）を一度BOOL（ゼロまたはワンブール値）。その目的は、無損失それらは0または1である確率は、それらが読み取られる時に同一の対応する確率を使用して、それらが書かれている時（一定または以前に符号化された情報を介して）十分に推定できるためboolsのシーケンスを圧縮することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the reader is probably aware, if a bool is much more likely to be zero than one (for instance), it can, on average, be faithfully encoded using much less than one bit per value. The bool_encoder exploits this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BOOLがはるかにゼロである可能性が高い（例えば）、それは、平均して、忠実値毎に1ビットよりもはるかに少ないを使用して符号化することができるものよりもあればリーダーとして、おそらく認識しています。 bool_encoderはこれを利用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the 1940s, [Shannon] proved that there is a lower bound for the average datarate of a faithful encoding of a sequence of bools (whose probability distributions are known and are independent of each other) and also that there are encoding algorithms that approximate this lower bound as closely as one wishes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1940年代に、[シャノンは（確率分布知られており、互いに独立している）boolsの配列の忠実な符号化の平均データレートのために結合し、これを近似もコードが存在することをアルゴリズム低いがあることを証明しました下1人の希望として密接に結合しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If we encode a sequence of bools whose probability of being zero is p (and whose probability of being 1 is 1-p), the lowest possible datarate per value is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、確率がゼロであることのP（確率1であることの1-P）であるboolsの配列をコードした場合、値ごとに可能な限り低いデータレートであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
plog(p) + (1-p)log(1-p);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PLOG（P）+（1-P）ログ（1-P）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
taking the logarithms to the base 1/2 expresses the datarate in bits/ value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベース1/2対数を取ると、ビット/値のデータレートを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We give two simple examples. At one extreme, if p = 1/2, then log(p) = log(1-p) = 1, and the lowest possible datarate per bool is 1/2 + 1/2 = 1; that is, we cannot do any better than simply literally writing out bits. At another extreme, if p is very small, say p = 1/1024, then log(p)=10, log(1-p) is roughly .0014, and the lowest possible datarate is approximately 10/1024 + .0014, roughly 1/100 of a bit per bool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は2つの簡単な例を与えます。極端な、もしP = 1/2で、ログ（P）=ログ（1-P）= 1、およびBOOLあたり最低の可能なデータレートは1/2 + 1/2 = 1です。それは、我々は単に文字通りビットを書き出すよりも良く行うことができないです。 pが非常に小さい場合、他の極端で、P = 1/1024は、ログ（P）= 10、ログ（1-p）が略0.0014であると言う、そして可能な限り低いデータレートが約1024分の10 + 0.0014であり、略1/100 BOOLあたりビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because most of the bools in the VP8 datastream have zero-probabilities nowhere near 1/2, the compression provided by the bool_encoder is critical to the performance of VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8のデータストリームにおけるboolsのほとんどはどこにも1/2に近いゼロ確率を持っているので、bool_encoderが提供する圧縮は、VP8の性能にとって重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The boolean coder used by VP8 is a variant of an arithmetic coder. An excellent discussion of arithmetic coding (and other lossless compression techniques) can be found in [Bell].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8で使用されるブールコーダは算術符号化の変形です。算術符号化（および他の可逆圧縮技術）の優れた議論は[ベル]に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Underlying Theory of Coding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。コーディングの基礎となる理論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic idea used by the boolean coder is to consider the entire data stream (either of the partitions in our case) as the binary expansion of a single number x with 0 &lt;= x &lt; 1. The bits (or bytes) in x are of course written from high to low order, and if b[j] (B[j]) is the j^(th) bit (byte) in the partition, the value x is simply the sum (starting with j = 1) of pow(2, -j) * b[j] or pow(256, -j) * B[j].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブールコーダによって使用される基本的な考え方は、0 &lt;= X &lt;1、Xのビット（又はバイト）であると単一数xのバイナリ拡張として全体のデータストリーム（我々の場合におけるパーティションのいずれか）を考慮することです（j = 1から始まる）のコースが低い順に高いから書き込まれ、およびb [J]（B [j]は）パーティション内J ^（TH）ビット（バイト）である場合、値xは、単純合計でありますPOWの（2、-j）* B [J]またはPOW（256、-j）* B [J]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before the first bool is coded, all values of x are possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のブールが符号化される前に、Xの全ての値が可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding of each bool restricts the possible values of x in proportion to the probability of what is coded. If p1 is the probability of the first bool being zero and a zero is coded, the range of possible values of x is restricted to 0 &lt;= x &lt; p1. If a one is coded, the range becomes p1 &lt;= x &lt; 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ブール値の符号化は、符号化されているものの確率に比例して、xの可能な値を制限します。 P1がゼロである第1 BOOLの確率であり、ゼロが符号化される場合、Xの取り得る値の範囲は0 &lt;= xの&lt;P1に制限されています。一方が符号化される場合、範囲は、P1 &lt;= X &lt;1となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding continues by repeating the same idea. At every stage, there is an interval a &lt;= x &lt; b of possible values of x. If p is the probability of a zero being coded at this stage and a zero is coded, the interval becomes a &lt;= x &lt; a + (p(b-a)). If a one is coded, the possible values of x are restricted to a + (p(b-a)) &lt;= x &lt; b.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コーディングは、同じ考えを繰り返すことにより継続します。各段階で、xの可能な値の間隔b &lt;= xは&lt;あります。 pがある場合は、この段階で符号化されたゼロの確率ゼロを符号化され、間隔が&lt;= xで&lt;+（P（B-A））となります。一方が符号化される場合、Xの可能な値は+（P（B-A））&lt;= xと&lt;Bに制限されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming that only finitely many values are to be coded, after the encoder has received the last bool, it can write as its output any value x that lies in the final interval. VP8 simply writes the left endpoint of the final interval. Consequently, the output it would make if encoding were to stop at any time either increases or stays the same as each bool is encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーダは、最後のブール値を受信した後にのみ、有限個の値は、符号化されると仮定すると、それはその出力として最終区間内にある任意の値xを書き込むことができます。 VP8は、単に最終区間の左端点を書き込みます。符号化はいつでも増加または各ブール値が符号化されるように同じままのいずれかを停止した場合、結果として、出力は、それがするであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding parallels encoding. The decoder is presented with the number x, which has only the initial restriction 0 &lt;= x &lt; 1. To decode the first bool, the decoder is given the first probability p1. If x &lt; p1, a zero is decoded; if x &gt;= p1, a one is decoded. In either case, the new restriction on x -- that is, the interval of possible values of x -- is remembered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
復号化は、エンコーディングに匹敵します。デコーダは最初のブール値を復号する&lt;1のみ初期制限0 &lt;= xを持つ数x、が提示されると、デコーダは、第1の確率P1に与えられます。 X &lt;P1の場合は、ゼロが復号されます。 X&gt; = p1の場合、一方が復号されます。いずれの場合においても、Xに新しい制限 -  xの可能な値のものであり、間隔が - 覚えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding continues in exactly the same way: If a &lt;= x &lt; b is the current interval and we are to decode a bool with zero-probability p, we return a zero if a &lt;= x &lt; a + (p(b-a)) and a one if a + (p(b-a)) &lt;= x &lt; b. In either case, the new restriction is remembered in preparation for decoding the next bool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
復号化は、まったく同じ方法で継続する。&lt;= xが&lt;Bは現在の間隔であり、我々はゼロ確率pでBOOLを復号するためには、我々が戻った場合はゼロ&lt;= xであれば&lt;+（P（BA））そして1つが+（P（BA））&lt;= xと&lt;B。いずれの場合においても、新たな制限は、次のブール値を復号化する準備のために記憶されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The process outlined above uses real numbers of infinite precision to express the probabilities and ranges. It is true that, if one could actualize this process and coded a large number of bools whose supplied probabilities matched their value distributions, the datarate achieved would approach the theoretical minimum as the number of bools encoded increased.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で概説したプロセスは、確率および範囲を表現するために無限の精度の実数を使用します。それが真である、1つは、このプロセスを実現し、供給された確率価値分布を一致bools多数のboolsの数が増加コードされる理論的な最小値に近づくであろう実現データレートを符号化することができれば。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unfortunately, computers operate at finite precision, and an approximation to the theoretically perfect process described above is necessary. Such approximation increases the datarate but, at quite moderate precision and for a wide variety of data sets, this increase is negligible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残念ながら、コンピュータは、有限の精度で動作し、上記の理論的に完全なプロセスへの近似が必要です。そのような近似は、データレートを増加するが、非常に適度な精度で、データセットの様々なため、この増加は無視できる程度です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The only conceptual limitations are, first, that coder probabilities must be expressed at finite precision and, second, that the decoder be able to detect each individual modification to the value interval via examination of a fixed amount of input. As a practical matter, many of the implementation details stem from the fact that the coder can function using only a small &#34;window&#34; to incrementally read or write the arbitrarily precise number x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単に概念的な制限は、符号化確率は、デコーダは入力の一定量の検査を介し値間隔に各個々の変形を検出することができること、第二、有限の精度で発現されなければならないこと、最初あります。実際問題として、実装の詳細の多くは、コーダがインクリメンタルに任意の正確な数xを読み書きするだけの小さな「窓」を使用して機能することができるという事実から生じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Practical Algorithm Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。実用的なアルゴリズムの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8&#39;s boolean coder works with 8-bit probabilities p. The range of such p is 0 &lt;= p &lt;= 255; the actual probability represented by p is p/256. Also, the coder is designed so that decoding of a bool requires no more than an 8-bit comparison, and so that the state of both the encoder and decoder can be easily represented using a small number of unsigned 16-bit integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8のブールコーダは、8ビットの確率pで動作します。このようなPの範囲は0 &lt;= p &lt;= 255です。 pで表され、実際の確率は、p / 256です。ブール値のデコーディングは、8ビットの比較よりも多くを必要としないように、また、符号器が設計され、エンコーダとデコーダの両方の状態を容易に符号なし16ビット整数の小さな数を使用して表すことができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details are most easily understood if we first describe the algorithm using bit-at-a-time input and output. Aside from the ability to maintain a position in this bitstream and write/read bits, the encoder also needs the ability to add 1 to the bits already output; after writing n bits, adding 1 to the existing output is the same thing as adding pow(2, -n) to x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は最初のビット・アット・タイム入力および出力を使用してアルゴリズムを記述する場合の詳細は、最も容易に理解されます。脇ビットを読み出す/このビットストリーム内の位置を維持し、書き込みする能力から、エンコーダは既に出力ビットに1を追加する機能が必要。既存の出力に1を加算し、nビットを書き込んだ後、XにPOW（2、-n）を添加することと同じことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Together with the bit position, the encoder must maintain two unsigned 8-bit numbers, which we call &#34;bottom&#34; and &#34;range&#34;. Writing w for the n bits already written and S = pow(2, - n - 8) for the scale of the current bit position one byte out, we have the following constraint on all future values v of w (including the final value v = x):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一緒にビット位置と、エンコーダは、我々が「下」と「範囲」と呼ぶ2の符号なし8ビット数を、維持しなければなりません。 （ -  N  -  2、8）nビット既に書き込まれ、S =捕虜のためのwは書き込み電流のビット位置1バイトのうち規模のため、我々はWのすべての将来の値vに制約下記た（最終値Vを含みます= X）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
w + ( S * bottom ) &lt;= v &lt; w + ( S * ( bottom + range ) )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W +（S *の下）&lt;= V &lt;W +（S *（ボトム+レンジ））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, appending bottom to the already-written bits w gives the left endpoint of the interval of possible values, appending bottom + range gives the right endpoint, and range itself (scaled to the current output position) is the length of the interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、既に書き込まれたビットに底を付加することは、可能な値の間隔の左端点を与える底を追加+範囲は、間隔の長さを右エンドポイントを与え、それ自身の範囲（現在の出力位置にスケーリング）がwです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So that our probabilistic encodings are reasonably accurate, we do not let range vary by more than a factor of two: It stays within the bounds 128 &lt;= range &lt;= 255.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私達の確率論エンコーディングが合理的に正確であるように、我々は範囲を聞かせていない2倍以上に異なります。これは、128 &lt;=範囲&lt;= 255境界内にとどまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The process for encoding a boolean value val whose probability of being zero is prob / 256 -- and whose probability of being one is ( 256 - prob ) / 256 -- with 1 &lt;= prob &lt;= 255 is as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確率一つであるのである（256  -   -  PROB）/ 256  - その確率がゼロであるのPROB / 256であるブール値val符号化するためのプロセスは以下のように1 &lt;= PROB &lt;= 255です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using an unsigned 16-bit multiply followed by an unsigned right shift, we calculate an unsigned 8-bit split value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
乗算の符号なし右シフトが続く符号なし16ビットを使用して、我々は、符号なし8ビットの分割値を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
split = 1 + (((range - 1) * probability)]] &gt;&gt; 8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スプリット= 1 +（（（範囲 -  1）*確率）]] &gt;&gt; 8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
split is approximately ( prob / 256 ) * range and lies within the bounds 1 &lt;= split &lt;= range - 1. These bounds ensure the correctness of the decoding procedure described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スプリットは、約（PROB / 256）*範囲であり、範囲内にある1 &lt;=スプリット&lt;=範囲 -  1.これらの限界は、後述する復号手順の正確さを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the incoming boolean val to be encoded is false, we leave the left interval endpoint bottom alone and reduce range, replacing it by split. If the incoming val is true, we move up the left endpoint to bottom + split, propagating any carry to the already-written value w (this is where we need the ability to add 1 to w), and reduce range to range - split.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコードされるべき入ってくるブールvalがfalseの場合、我々はそのままに間隔エンドポイント下を離れ、分割によってそれを置き換える、範囲を縮小します。入ってくるvalが真であるならば、我々はワット既に書き込まれた値へのキャリーを（我々はワットに1を追加する機能を必要とするところ、これがある）伝播し、下の+スプリットに左のエンドポイントを上に移動し、範囲に範囲を減らす - スプリット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the value encoded, range has been reduced and now has the bounds 1 &lt;= range &lt;= 254. If range &lt; 128, the encoder doubles it and shifts the high-order bit out of bottom to the output as it also doubles bottom, repeating this process one bit at a time until 128 &lt;= range &lt;= 255. Once this is completed, the encoder is ready to accept another bool, maintaining the constraints described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲&lt;128は、エンコーダがそれを倍増し、出力するように底部のうち上位ビットをシフトした場合に関係なく符号化された値の範囲は低減されており、現在の境界を有し、1 &lt;=範囲&lt;= 254は、また、底を倍増としてこれが完了すると128 &lt;=範囲&lt;= 255、エンコーダは、上述した制約を維持し、別のブールを受け入れる準備ができるまで、一度にこのプロセスを1つのビットを繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After encoding the last bool, the partition may be completed by appending bottom to the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後BOOLを符号化した後、パーティションは、ビットストリームに底部を追加することによって完了することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder mimics the state of the encoder. It maintains, together with an input bit position, two unsigned 8-bit numbers, a range identical to that maintained by the encoder and a value. Decoding one bool at a time, the decoder (in effect) tracks the same left interval endpoint as does the encoder and subtracts it from the remaining input. Appending the unread portion of the bitstream to the 8-bit value gives the difference between the actual value encoded and the known left endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダは、エンコーダの状態を模倣します。それは、一緒になって、入力ビット位置、2の符号なし8ビット数、符号器及び値によって維持されるものと同一の範囲で、維持します。一度に一つのブール値を復号する、（効果）デコーダは、エンコーダが行うのと同じ左間隔のエンドポイントを追跡し、残りの入力からそれを減算します。 8ビットの値にビットストリームの未読部分を付加する符号化された実際の値と既知の左エンドポイントとの間の差を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder is initialized by setting range = 255 and reading the first 16 input bits into value. The decoder maintains range and calculates split in exactly the same way as does the encoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダは、範囲= 255を設定した値に最初の16個の入力ビットを読み取ることによって初期化されます。デコーダは、範囲を維持し、エンコーダと同様にまったく同じ方法でスプリットを算出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To decode a bool, it compares value to split; if value &lt; split, the bool is zero, and range is replaced with split. If value &gt;= split, the bool is one, range is replaced with range - split, and value is replaced with value - split.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブール値をデコードするには、それは分割する値とを比較し、値&lt;分割する場合、ブール値はゼロであり、その範囲は、分割で置換されています。値&gt; =スプリット場合、BOOLが1で、範囲を範囲と置き換えられる - スプリット、及び値が値に置き換えられる - スプリット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Again, range is doubled one bit at a time until it is at least 128. The value is doubled in parallel, shifting a new input bit into the bottom each time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは値が底に毎回新しい入力ビットをシフトし、並列に倍、少なくとも128になるまで再び、範囲は、一度に1ビットを倍になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Writing Value for value together with the unread input bits and Range for range extended indefinitely on the right by zeros, the condition Value &lt; Range is maintained at all times by the decoder. In particular, the bits shifted out of value as it is doubled are always zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゼロが右側に無限に拡張された範囲のための未読入力ビットと範囲と一緒値の値を書き込み、条件値&lt;範囲は、デコーダによって常に維持されています。それが2倍になるように、特に、ビットは常にゼロである値のシフトアウト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Actual Implementation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。実際の実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The C code below gives complete implementations of the encoder and decoder described above. While they are logically identical to the &#34;bit-at-a-time&#34; versions, they internally buffer a couple of extra bytes of the bitstream. This allows I/O to be done (more practically) a byte at a time and drastically reduces the number of carries the encoder has to propagate into the already-written data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のCコードは、上述したエンコーダ及びデコーダの完全な実装を与えます。彼らは、「ビット・アット・タイム」のバージョンと論理的に同じですが、それらは内部的にビットストリームの余分なバイトのカップルをバッファリングします。これは、I / Oが同時に（より実際的）バイトを行い、大幅エンコーダが既に書き込まれているデータに伝播しなければならない運ぶの数を減らすことを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another (logically equivalent) implementation may be found in the reference decoder file bool_decoder.h (Section 20.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の（論理的に等価）の実装は、基準デコーダファイルbool_decoder.h（セクション20.2）に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Encoder first */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef struct {
     uint8 *output;  /* ptr to next byte to be written */
     uint32 range;   /* 128 &lt;= range &lt;= 255 */
     uint32 bottom;  /* minimum value of remaining output */
     int bit_count;  /* # of shifts before an output byte
                        is available */
   } bool_encoder;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Must set initial state of encoder before writing any bools. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void init_bool_encoder(bool_encoder *e, uint8 *start_partition)
   {
     e-&gt;output = start_partition;
     e-&gt;range = 255;
     e-&gt;bottom = 0;
     e-&gt;bit_count = 24;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Encoding very rarely produces a carry that must be propagated
      to the already-written output.  The arithmetic guarantees that
      the propagation will never go beyond the beginning of the
      output.  Put another way, the encoded value x is always less
      than one. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void add_one_to_output(uint8 *q)
   {
     while (*--q == 255)
       *q = 0;
     ++*q;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Main function writes a bool_value whose probability of being
      zero is (expected to be) prob/256. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void write_bool(bool_encoder *e, Prob prob, int bool_value)
   {
     /* split is approximately (range * prob) / 256 and,
        crucially, is strictly bigger than zero and strictly
        smaller than range */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
uint32 split = 1 + (((e-&gt;range - 1) * prob) &gt;&gt; 8);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
UINT32スプリット= 1 +（（（E-&gt;レンジ -  1）* PROB）&gt;&gt; 8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if (bool_value) {
       e-&gt;bottom += split; /* move up bottom of interval */
       e-&gt;range -= split;  /* with corresponding decrease in range */
     } else
       e-&gt;range = split;   /* decrease range, leaving bottom alone */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
while (e-&gt;range &lt; 128) { e-&gt;range &lt;&lt;= 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
一方、（E-&gt;範囲&lt;128）{E-&gt;範囲&lt;&lt; = 1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (e-&gt;bottom &amp; (1 &lt;&lt; 31))  /* detect carry */
         add_one_to_output(e-&gt;output);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       e-&gt;bottom &lt;&lt;= 1;        /* before shifting bottom */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (!--e-&gt;bit_count) {  /* write out high byte of bottom ... */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
*e-&gt;output++ = (uint8) (e-&gt;bottom &gt;&gt; 24);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* E-&gt;出力++ =（UINT8）（E-&gt;ボトム&gt;&gt; 24）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         e-&gt;bottom &amp;= (1 &lt;&lt; 24) - 1;  /* ... keeping low 3 bytes */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         e-&gt;bit_count = 8;            /* 8 shifts until next output */
       }
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Call this function (exactly once) after encoding the last
      bool value for the partition being written */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void flush_bool_encoder(bool_encoder *e)
   {
     int c = e-&gt;bit_count;
     uint32 v = e-&gt;bottom;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if (v &amp; (1 &lt;&lt; (32 - c)))   /* propagate (unlikely) carry */
       add_one_to_output(e-&gt;output);
     v &lt;&lt;= c &amp; 7;               /* before shifting remaining output */
     c &gt;&gt;= 3;                   /* to top of internal buffer */
     while (--c &gt;= 0)
       v &lt;&lt;= 8;
     c = 4;
     while (--c &gt;= 0) {    /* write remaining data, possibly padded */
       *e-&gt;output++ = (uint8) (v &gt;&gt; 24);
       v &lt;&lt;= 8;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Decoder state exactly parallels that of the encoder.
      &#34;value&#34;, together with the remaining input, equals the
      complete encoded number x less the left endpoint of the
      current coding interval. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef struct {
     uint8   *input;     /* pointer to next compressed data byte */
     uint32  range;      /* always identical to encoder&#39;s range */
     uint32  value;      /* contains at least 8 significant bits */
     int     bit_count;  /* # of bits shifted out of
                            value, at most 7 */
   } bool_decoder;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Call this function before reading any bools from the
      partition. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void init_bool_decoder(bool_decoder *d, uint8 *start_partition)
   {
     {
       int i = 0;
       d-&gt;value = 0;           /* value = first 2 input bytes */
       while (++i &lt;= 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
 d-&gt;value = (d-&gt;value &lt;&lt; 8) | *start_partition++; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
D-&gt;値=（D-&gt;値&lt;&lt; 8）| * start_partition ++; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     d-&gt;input = start_partition;  /* ptr to next byte to be read */
     d-&gt;range = 255;           /* initial range is full */
     d-&gt;bit_count = 0;         /* have not yet shifted out any bits */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Main function reads a bool encoded at probability prob/256,
      which of course must agree with the probability used when the
      bool was written. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int read_bool(bool_decoder *d, Prob prob)
   {
     /* range and split are identical to the corresponding values
        used by the encoder when this bool was written */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     uint32  split = 1 + (((d-&gt;range - 1) * prob) &gt;&gt; 8);
     uint32  SPLIT = split &lt;&lt; 8;
     int     retval;           /* will be 0 or 1 */ if (d-&gt;value &gt;= SPLIT) {  /* encoded a one */
       retval = 1;
       d-&gt;range -= split;  /* reduce range */
       d-&gt;value -= SPLIT;  /* subtract off left endpoint of interval */
     } else {              /* encoded a zero */
       retval = 0;
       d-&gt;range = split;  /* reduce range, no change in left endpoint */
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     while (d-&gt;range &lt; 128) {  /* shift out irrelevant value bits */
       d-&gt;value &lt;&lt;= 1;
       d-&gt;range &lt;&lt;= 1;
       if (++d-&gt;bit_count == 8) {  /* shift in new bits 8 at a time */
         d-&gt;bit_count = 0;
         d-&gt;value |= *d-&gt;input++;
       }
     }
     return retval;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Convenience function reads a &#34;literal&#34;, that is, a &#34;num_bits&#34;-
      wide unsigned value whose bits come high- to low-order, with
      each bit encoded at probability 128 (i.e., 1/2). */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32 read_literal(bool_decoder *d, int num_bits) { uint32 v = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UINT32 read_literal（bool_decoderの* dを、num_bitsをINT）{UINT32のV = 0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     while (num_bits--)
       v = (v &lt;&lt; 1) + read_bool(d, 128);
     return v;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Variant reads a signed number */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int32 read_signed_literal(bool_decoder *d, int num_bits)
   {
     int32 v = 0;
     if (!num_bits)
       return 0;
     if (read_bool(d, 128))
       v = -1;
     while (--num_bits)
       v = (v &lt;&lt; 1) + read_bool(d, 128);
     return v;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Compressed Data Components
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.圧縮データコンポーネント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the lowest level, VP8&#39;s compressed data is simply a sequence of probabilistically encoded bools. Most of this data is composed of (slightly) larger semantic units fashioned from bools, which we describe here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最下位レベルでは、VP8の圧縮データは、単に、確率的符号化さboolsの配列です。このデータのほとんどは、我々がここで説明するbools、から作ら（わずかに）大きな意味単位で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We sometimes use these descriptions in C expressions within data format specifications. In this context, they refer to the return value of a call to an appropriate bool_decoder d, reading (as always) from its current reference point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは時々、データフォーマット仕様の範囲内でCの式でこれらの記述を使用しています。この文脈において、彼らはその現在の基準点から（いつものように）読み取り、適切なbool_decoder dにコールの戻り値を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------------+-------+--------------------------------------------+
   | Call         | Alt.  | Return                                     |
   +--------------+-------+--------------------------------------------+
   | Bool(p)      | B(p)  | Bool with probability p/256 of being 0.    |
   |              |       | Return value of read_bool(d, p).           |
   |              |       |                                            |
   | Flag         | F     | A one-bit flag (same thing as a B(128) or  |
   |              |       | an L(1)).  Abbreviated F.  Return value of |
   |              |       | read_bool(d, 128).                         |
   |              |       |                                            |
   | Lit(n)       | L(n)  | Unsigned n-bit number encoded as n flags   |
   |              |       | (a &#34;literal&#34;).  Abbreviated L(n).  The     |
   |              |       | bits are read from high to low order.      |
   |              |       | Return value of read_literal(d, n).        |
   |              |       |                                            |
   | SignedLit(n) |       | Signed n-bit number encoded similarly to   |
   |              |       | an L(n).  Return value of                  |
   |              |       | read_signed_literal(d, n).  These are      |
   |              |       | rare.                                      |
   |              |       |                                            |
   | P(8)         |       | An 8-bit probability.  No different from   |
   |              |       | an L(8), but we sometimes use this         |
   |              |       | notation to emphasize that a probability   |
   |              |       | is being coded.                            |
   |              |       |                                            |
   | P(7)         |       | A 7-bit specification of an 8-bit          |
   |              |       | probability.  Coded as an L(7) number x;   |
   |              |       | the resulting 8-bit probability is x ? x   |
   |              |       | &lt;&lt; 1 : 1.                                  |
   |              |       |                                            |
   | F?  X        |       | A flag that, if true, is followed by a     |
   |              |       | piece of data X.                           |
   |              |       |                                            |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | F?  X:Y      |       | A flag that, if true, is followed by X     |
   |              |       | and, if false, is followed by Y.  Also     |
   |              |       | used to express a value where Y is an      |
   |              |       | implicit default (not encoded in the data  |
   |              |       | stream), as in F?  P(8):255, which         |
   |              |       | expresses an optional probability: If the  |
   |              |       | flag is true, the probability is specified |
   |              |       | as an 8-bit literal, while if the flag is  |
   |              |       | false, the probability defaults to 255.    |
   |              |       |                                            |
   | B(p)?  X     | B(p)? | Variants of the above using a boolean      |
   |              | X:Y   | indicator whose probability is not         |
   |              |       | necessarily 128.                           |
   |              |       |                                            |
   | T            |       | Tree-encoded value from small alphabet.    |
   +--------------+-------+--------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last type requires elaboration. We often wish to encode something whose value is restricted to a small number of possibilities (the alphabet).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後のタイプは、精緻化が必要です。私たちはしばしば、その値の可能性の数が少ない（アルファベット）に制限されている何かをエンコードしたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is done by representing the alphabet as the leaves of a small binary tree. The (non-leaf) nodes of the tree have associated probabilities p and correspond to calls to read_bool(d, p). We think of a zero as choosing the left branch below the node and a one as choosing the right branch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、小さなバイナリツリーの葉のようにアルファベットを表現することによって行われます。ツリーの（非リーフ）ノードは、確率pを関連付けてread_boolする呼び出し（D、P）に対応しています。私たちは、ノードの下の左の枝と右の枝を選択するような一つを選ぶようにゼロと考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, every value (leaf) whose tree depth is x is decoded after exactly x calls to read_bool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、その木の深さであるX Xコールを正確にした後に復号されたすべての値（葉）read_boolします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A tree representing an encoding of an alphabet of n possible values always contains n-1 non-leaf nodes, regardless of its shape (this is easily seen by induction on n).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n個の可能な値のアルファベットのエンコーディングを表すツリーは関係なく、常にその形状のN-1の非リーフノードを、（これは容易Nに誘導することによって見られる）を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are many ways that a given alphabet can be so represented. The choice of tree has little impact on datarate but does affect decoder performance. The trees used by VP8 are chosen to (on average) minimize the number of calls to read_bool. This amounts to shaping the tree so that values that are more probable have smaller tree depth than do values that are less probable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与えられたアルファベットがそう表現することができる多くの方法があります。木の選択は、データレートにほとんど影響を持っていますが、復号器の性能に影響を与えません。 VP8で使用されるツリーはread_boolするコールの数を最小限に（平均で）ように選択されます。これは、より可能性のある値は劣勢である値を行うよりも小さなツリーの深さを持つように木を形作るになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Readers familiar with Huffman coding will notice that, given an alphabet together with probabilities for each value, the associated Huffman tree minimizes the expected number of calls to read_bool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハフマン符号化に精通している読者は、各値の確率と一緒にアルファベットを付し、ことに気づくであろう、関連するハフマンツリーはread_boolするコール数の期待値を最小化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such readers will also realize that the coding method described here never results in higher datarates than does the Huffman method and, indeed, often results in much lower datarates. Huffman coding is, in fact, nothing more than a special case of this method in which each node probability is fixed at 128 (i.e., 1/2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような読者にも、多くの場合、はるかに低いデータレートになり、実際に、ハフマン法を行い、よりここで説明した符号化方法は、より高いデータレートにつながることはないことを理解するであろう。ハフマン符号化は、実際には、各ノードの確率が128（即ち、1/2）に固定されているこの方法の特別な場合に過ぎません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Tree Coding Implementation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。ツリーコーディング実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We give a suggested implementation of a tree data structure followed by a couple of actual examples of its usage by VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、VP8によるその使用方法の実際の例をいくつに続いて、ツリーデータ構造の提案実装を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is most convenient to represent the values using small positive integers, typically an enum counting up from zero. The largest alphabet (used to code DCT coefficients, described in Section 13) that is tree-coded by VP8 has only 12 values. The tree for this alphabet adds 11 interior nodes and so has a total of 23 positions. Thus, an 8-bit number easily accommodates both a tree position and a return value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
小さな正の整数、ゼロからカウントアップ一般的に列挙型を使用して値を表現するために最も便利です。 VP8によってツリー符号化されている（第13章に記載されたDCT係数を符号化するために使用される）最大アルファベットのみ12値を有しています。このアルファベットのツリーが11個の内部ノードを追加し、そう23点の位置の合計を有します。したがって、8ビットの数を容易ツリー位置と戻り値の両方を収容します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A tree may then be compactly represented as an array of (pairs of) 8-bit integers. Each (even) array index corresponds to an interior node of the tree; the 0th index of course corresponds to the root of the tree. The array entries come in pairs corresponding to the left (0) and right (1) branches of the subtree below the interior node. We use the convention that a positive (even) branch entry is the index of a deeper interior node, while a nonpositive entry v corresponds to a leaf whose value is -v.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ツリーは、次に、コンパクト8ビット整数（対）の配列として表すことができます。各（偶数）配列インデックスは、ツリーの内部ノードに対応します。当然の0番目のインデックスは、ツリーのルートに対応しています。アレイエントリは、左（0）と内部ノードの下のサブツリーの右（1）枝に対応するペアで来ます。正でないエントリーvはその値-vで、葉に対応している私たちは、正（さえ）枝エントリはより深い内部ノードのインデックスである規則を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The node probabilities associated to a tree-coded value are stored in an array whose indices are half the indices of the corresponding tree positions. The length of the probability array is one less than the size of the alphabet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ツリー符号化された値に関連付けられたノードの確率は、そのインデックス対応するツリーの位置の半分の指標である配列に格納されています。確率配列の長さは、アルファベットのサイズよりも小さいものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is C code implementing the foregoing. The advantages of our data structure should be noted. Aside from the smallness of the structure itself, the tree-directed reading algorithm is essentially a single line of code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、上記を実現Cコードです。我々のデータ構造の利点が注目されるべきです。脇構造自体の小ささから、ツリー指向読み取りアルゴリズムは、本質的に単一のコード行です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* A tree specification is simply an array of 8-bit integers. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef int8 tree_index;
   typedef const tree_index Tree[];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Read and return a tree-coded value at the current decoder
      position. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int treed_read(
     bool_decoder * const d, /* bool_decoder always returns a 0 or 1 */
     Tree t,                 /* tree specification */
     const Prob p[]     /* corresponding interior node probabilities */
   ) {
     register tree_index i = 0;   /* begin at root */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* Descend tree until leaf is reached */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
while ((i = t[ i + read_bool(d, p[i&gt;&gt;1])]) &gt; 0) {}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ながら、{}（（I =さt）&gt; 0 [iが[I &gt;&gt; 1]）read_bool（D、Pを+]）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     return -i;     /* return value is negation of nonpositive index */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tree-based decoding is implemented in the reference decoder file bool_decoder.h (Section 20.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ツリーベースの復号化は、基準デコーダファイルbool_decoder.h（セクション20.2）に実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Tree Coding Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。ツリーのコーディング例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a multi-part example, without getting too far into the semantics of macroblock decoding (which is of course taken up below), we look at the &#34;mode&#34; coding for intra-predicted macroblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチパートの例として、（以下取り上げもちろんである）マクロブロック復号の意味論にすぎ得ることなく、我々は、イントラ予測マクロブロックをコードする「モード」を見てください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It so happens that, because of a difference in statistics, the Y (or luma) mode encoding uses two different trees: one for key frames and another for interframes. This is the only instance in VP8 of the same dataset being coded by different trees under different circumstances. The UV (or chroma) modes are a proper subset of the Y modes and, as such, have their own decoding tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーフレーム用とインターフレームのための別の：とてもため、統計の違いにより、Y（または輝度）モード符号化は、2つの異なるツリーを使用することが起こります。これは、異なる状況下で異なる木によって符号化された同じデータセットのVP8における唯一のインスタンスです。 UV（またはクロマ）モードのような、独自の復号ツリーを有する、Yモードの適切なサブセットであり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef enum
   {
       DC_PRED, /* predict DC using row above and column to the left */
       V_PRED,  /* predict rows using row above */
       H_PRED,  /* predict columns using column to the left */
       TM_PRED, /* propagate second differences a la &#34;True Motion&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       B_PRED,  /* each Y subblock is independently predicted */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       num_uv_modes = B_PRED,  /* first four modes apply to chroma */
       num_ymodes   /* all modes apply to luma */
   }
   intra_mbmode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* The aforementioned trees together with the implied codings as
      comments.
      Actual (i.e., positive) indices are always even.
      Value (i.e., nonpositive) indices are arbitrary. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index ymode_tree [2 * (num_ymodes - 1)] =
   {
    -DC_PRED, 2,        /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,              /* &#34;1&#34; subtree has 2 descendant subtrees */
      -V_PRED, -H_PRED, /* &#34;10&#34; subtree: V_PRED = &#34;100&#34;,
                           H_PRED = &#34;101&#34; */
      -TM_PRED, -B_PRED /* &#34;11&#34; subtree: TM_PRED = &#34;110&#34;,
                           B_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index kf_ymode_tree [2 * (num_ymodes - 1)] =
   {
    -B_PRED, 2,            /* root: B_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -DC_PRED, -V_PRED,   /* &#34;10&#34; subtree: DC_PRED = &#34;100&#34;,
                              V_PRED = &#34;101&#34; */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index uv_mode_tree [2 * (num_uv_modes - 1)] =
   {
    -DC_PRED, 2,          /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     -V_PRED, 4,          /* &#34;1&#34; subtree:  V_PRED = &#34;10&#34;,
                             &#34;11&#34; subtree */
      -H_PRED, -TM_PRED   /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                             TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Given a bool_decoder d, a Y mode might be decoded as follows. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob pretend_its_huffman [num_ymodes - 1] = { 128, 128, 128, 128};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST度Probのpretend_its_huffman [num_ymodes  -  1] = {128、128、128、128}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ymode = (intra_mbmode) treed_read(d, ymode_tree, pretend_its_huffman);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ymode =（intra_mbmode）treed_read（D、ymode_tree、pretend_its_huffman）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since it greatly facilitates re-use of reference code, and since there is no real reason to do otherwise, it is strongly suggested that any decoder implementation use exactly the same enumeration values and probability table layouts as those described in this document (and in the reference code) for all tree-coded data in VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは非常に基準コードの再利用を容易にし、そうでなければ行うには本当の理由が存在しないので、それが強く示唆されているので、その任意のデコーダの実装使用まさにこの文書に記載されているもの（とで同じ列挙値及び確率テーブルレイアウトVP8内のすべてのツリー符号化されたデータのための参照コード）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Frame Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.フレームヘッダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The uncompressed data chunk at the start of each frame and at the first part of the first data partition contains information pertaining to the frame as a whole. We list the fields in the order of occurrence. Most of the header decoding occurs in the reference decoder file dixie.c (Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フレームの開始時に第1のデータ・パーティションの最初の部分で非圧縮データチャンクは、全体としてフレームに関する情報を含んでいます。私たちは、発生順のフィールドをリストします。ヘッダ復号化のほとんどは、参照デコーダファイルdixie.c（セクション20.4）で発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Uncompressed Data Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。非圧縮データチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The uncompressed data chunk comprises a common (for key frames and interframes) 3-byte frame tag that contains four fields, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように非圧縮データチャンクは、4つのフィールドが含まれている（キーフレームおよびインターフレームのための）共通の3バイトのフレームのタグを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. A 1-bit frame type (0 for key frames, 1 for interframes).
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. A 1ビットのフレームタイプ（キーフレーム0、インターフレームのための1）。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A 3-bit version number (0 - 3 are defined as four different profiles with different decoding complexity; other values may be defined for future variants of the VP8 data format).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A 3ビットのバージョン番号（0から3は、異なる復号複雑さを持つ4つの異なるプロファイルとして定義され、他の値がVP8データフォーマットの将来の変異体のために定義されてもよいです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. A 1-bit show_frame flag (0 when current frame is not for display, 1 when current frame is for display).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. A 1ビットshow_frameフラグ（0現在のフレームが表示するためのものである場合、現在のフレームは、ディスプレイ、1のためではありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. A 19-bit field containing the size of the first data partition in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト単位の最初のデータ・パーティションのサイズを含む。4. 19ビットのフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The version number setting enables or disables certain features in the bitstream, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにバージョン番号の設定は、ビットストリーム中の特定の機能を有効または無効にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            +---------+-------------------------+-------------+
            | Version | Reconstruction Filter   | Loop Filter |
            +---------+-------------------------+-------------+
            | 0       | Bicubic                 | Normal      |
            |         |                         |             |
            | 1       | Bilinear                | Simple      |
            |         |                         |             |
            | 2       | Bilinear                | None        |
            |         |                         |             |
            | 3       | None                    | None        |
            |         |                         |             |
            | Other   | Reserved for future use |             |
            +---------+-------------------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference software also adjusts the loop filter based on version number, as per the table above. Version number 1 implies a &#34;simple&#34; loop filter, and version numbers 2 and 3 imply no loop filter. However, the &#34;simple&#34; filter setting in this context has no effect whatsoever on the decoding process, and the &#34;no loop filter&#34; setting only forces the reference encoder to set filter level equal to 0. Neither affect the decoding process. In decoding, the only loop filter settings that matter are those in the frame header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照ソフトウェアは、上記の表のとおり、バージョン番号に基づいて、ループフィルタを調整します。バージョン番号1は、「単純な」ループフィルタを意味し、バージョン番号2及び3には、ループフィルタを意味しません。しかしながら、この文脈での「単純な」フィルタ設定は、復号化処理に何ら影響を与えない、と設定のみ「は、ループフィルタ」は0に等しいフィルタレベルを設定しないどちらも復号処理に影響を与えるために、基準エンコーダを強制しません。復号化において、重要でのみループフィルタの設定は、フレームヘッダ内のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For key frames, the frame tag is followed by a further 7 bytes of uncompressed data, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにキーフレームに対して、フレームタグは、非圧縮データのさらに7つのバイトが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Start code byte 0 0x9d Start code byte 1 0x01 Start code byte 2 0x2a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードバイト0は、コードバイト1 0x01をスタートコードバイト2 0x2aを開始0x9d開始します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16 bits : (2 bits Horizontal Scale &lt;&lt; 14) | Width (14 bits) 16 bits : (2 bits Vertical Scale &lt;&lt; 14) | Height (14 bits)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16ビット（2ビット水平スケール&lt;&lt; 14）|幅（14ビット）の16ビット（2ビット垂直スケール&lt;&lt; 14）|高さ（14ビット）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following source code segment illustrates validation of the start code and reading the width, height, and scale factors for a key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のソースコード・セグメントは、スタートコードの検証およびキーフレームのための幅、高さ、およびスケールファクタを読み取るを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsigned char *c = pbi-&gt;source+3;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsigned char型* C = pbi-&gt;ソース+ 3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
// vet via sync code if (c[0]!=0x9d||c[1]!=0x01||c[2]!=0x2a) return -1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期コードを介し//獣医なら（C [0] = 0x9d || C [1] = 0x01の|| C [2] = 0x2a！！）リターン-1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where pbi-&gt;source points to the beginning of the frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこpbi-&gt;ソースポイントフレームの先頭に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following code reads the image dimension from the bitstream:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のコードは、ビットストリームからの画像の寸法を読み出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   pc-&gt;Width      = swap2(*(unsigned short*)(c+3))&amp;0x3fff;
   pc-&gt;horiz_scale = swap2(*(unsigned short*)(c+3))&gt;&gt;14;
   pc-&gt;Height     = swap2(*(unsigned short*)(c+5))&amp;0x3fff;
   pc-&gt;vert_scale  = swap2(*(unsigned short*)(c+5))&gt;&gt;14;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the swap2 macro takes care of the endian on a different platform:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこswap2マクロは、異なるプラットフォーム上でエンディアンの世話をします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#if defined(__ppc__) || defined(__ppc64__) # define swap2(d) \ ((d&amp;0x000000ff)&lt;&lt;8) | \ ((d&amp;0x0000ff00)&gt;&gt;8) #else # define swap2(d) d #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義された（__ ppc__）の#if ||定義された（__ ppc64__）＃swap2（D）\（（D＆0x000000ff）&lt;&lt; 8）を定義| \（（D＆0x0000ff00）&gt;&gt; 8）＃swap2（d）のD #endifの定義の#else
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While each frame is encoded as a raster scan of 16x16 macroblocks, the frame dimensions are not necessarily evenly divisible by 16. In this case, write ew = 16 - (width &amp; 15) and eh = 16 - (height &amp; 15) for the excess width and height, respectively. Although they are encoded, the last ew columns and eh rows are not actually part of the image and should be discarded before final output. However, these &#34;excess pixels&#34; should be maintained in the internal reconstruction buffer used to predict ensuing frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用（高さ＆15） - （幅＆15）とEH = 16  - 各フレームは、16×16マクロブロックのラスタスキャンとして符号化されている間、フレームの寸法はこの場合には、必ずしも16で割り切れない、書き込みEWは16 =それぞれ超過幅と高さ、。それらがコード化されていますが、最後のEW列とえっ行は実際に画像の一部ではなく、最終出力前に廃棄されなければなりません。しかし、これらの「過剰画素が」後続のフレームを予測するために使用される内部再構成バッファに維持されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scaling specifications for each dimension are encoded as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように各次元のスケーリング仕様はエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +-------+--------------------------------------+
             | Value | Scaling                              |
             +-------+--------------------------------------+
             | 0     | No upscaling (the most common case). |
             |       |                                      |
             | 1     | Upscale by 5/4.                      |
             |       |                                      |
             | 2     | Upscale by 5/3.                      |
             |       |                                      |
             | 3     | Upscale by 2.                        |
             +-------+--------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upscaling does not affect the reconstruction buffer, which should be maintained at the encoded resolution. Any reasonable method of upsampling (including any that may be supported by video hardware in the playback environment) may be used. Since scaling has no effect on decoding, we do not discuss it any further.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アップスケーリングは、符号化された解像度で維持されなければならない再構成緩衝液を、影響を与えません。 （任意の再生環境でビデオハードウェアによってサポートされてもよいものを含む）アップサンプリングの任意の合理的な方法を用いてもよいです。スケーリングは、デコードには影響しませんので、我々はそれ以上のことを議論していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in Section 5, allocation (or re-allocation) of data structures (such as the reconstruction buffer) whose size depends on dimension will be triggered here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5で論じたように、大きさ寸法に依存する（例えば、再構成バッファなど）のデータ構造の割当て（または再割り当て）が、ここでトリガされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Color Space and Pixel Type (Key Frames Only)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。カラースペースとピクセルタイプ（キーフレームのみ）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Field | Value                                    |
           +-------+------------------------------------------+
           | L(1)  | 1-bit color space type specification     |
           |       |                                          |
           | L(1)  | 1-bit pixel value clamping specification |
           +-------+------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The color space type bit is encoded as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように色空間タイプビットが符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 - YUV color space similar to the YCrCb color space defined in [ITU-R_BT.601]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0  -  [ITU-R_BT.601]で定義されたYCrCb色空間に類似するYUV色空間
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 - Reserved for future use
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1 O  - 今後の使用のために予約
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pixel value clamping type bit is encoded as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように画素値クランプタイプのビットが符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 - Decoders are required to clamp the reconstructed pixel values to between 0 and 255 (inclusive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0  - デコーダは0〜255（両端を含む）に再構成された画素値をクランプするために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 - Reconstructed pixel values are guaranteed to be between 0 and 255; no clamping is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1 O  - 再構成画素値は0と255の間であることが保証されます。何クランプが必要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information in this subsection does not appear in interframes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このサブセクションに記載されている情報は、インターフレームに表示されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. Segment-Based Adjustments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3。セグメントベースの調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This subsection contains probability and value information for implementing segment adaptive adjustments to default decoder behavior. The data in this subsection is used in the decoding of the ensuing per-segment information and applies to the entire frame. When segment adaptive adjustments are enabled, each macroblock will be assigned a segment ID. Macroblocks with the same segment ID belong to the same segment and have the same adaptive adjustments over default baseline values for the frame. The adjustments can be quantizer level or loop filter strength.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、デコーダの動作をデフォルトにセグメントの適応調整を実装するための確率と値の情報が含まれています。このサブセクション内のデータは、その後当たりセグメント情報の復号化に使用され、フレーム全体に適用されます。セグメント適応調整が有効な場合、各マクロブロックは、セグメントIDが割り当てられます。同じセグメントIDを持つマクロブロックが同じセグメントに属し、フレームのデフォルトのベースライン値を超える同じ適応調整を持っています。調整は、量子化レベル又はループフィルタ強度とすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The context for decoding this feature at the macroblock level is provided by a subsection in the frame header, which contains:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マクロブロック・レベルでこの機能を復号するためのコンテキストを含むフレームヘッダ内のサブセクションによって提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A segmentation_enabled flag that enables the feature for this frame if set to 1, and disables it if set to 0. The following fields occur if the feature is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Aは1に設定されている場合、このフレームの機能を有効フラグsegmentation_enabled、及び機能が有効になっている場合、次のフィールドが発生0に設定されている場合、それを無効にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. L(1) indicates if the segment map is updated for the current frame (update_mb_segmentation_map).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セグメントマップは、現在のフレーム（update_mb_segmentation_map）のために更新された場合2 L（1）を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. L(1) indicates if the segment feature data items are updated for the current frame (update_segment_feature_data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セグメントフィーチャデータ項目は、現在のフレーム（update_segment_feature_data）のために更新される場合3. L（1）を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If Item 3 above (update_segment_feature_data) is 1, the following fields occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（update_segment_feature_data）上記項目3が1の場合4、次のフィールドが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       a.  L(1), the mode of segment feature data
           (segment_feature_mode), can be absolute-value mode (0) or
           delta value mode (1).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
b. Segment feature data items are decoded segment by segment for each segment feature. For every data item, a one-bit flag indicates whether the item is 0, or a non-zero value to be decoded. If the value is non-zero, then the value is decoded as a magnitude L(n), followed by a one-bit sign (L(1) -- 0 for positive and 1 for negative). The length n can be looked up from a pre-defined length table for all feature data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
B。セグメント特徴データ項目は、各セグメントの機能のためにセグメントごとに復号されます。すべてのデータ項目に対して、1ビットのフラグは、アイテムが0であるかどうかを示す、または非ゼロ値を復号します。値がゼロでない場合、その値は1ビットの符号（ - 正の場合は0、負のための1 L（1））、続いて大きさL（N）としてデコードされます。長さnの全ての特徴データに対して予め定義された長テーブルからルックアップすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the L(1) flag as noted in Item 2 above is set to 1, the probabilities of the decoding tree for the segment map are decoded from the bitstream. Each probability is decoded with a one-bit flag indicating whether the probability is the default value of 255 (flag is set to 0), or an 8-bit value, L(8), from the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アイテム上記2で述べたようにL（1）フラグが1に設定されている場合は5は、セグメントマップの復号ツリーの確率は、ビットストリームから復号化されます。各確率は、Lは、ビットストリームから、（8）、確率が255のデフォルト値（フラグが0に設定されている）、または8ビットの値であるか否かを示す1ビットのフラグでデコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout and semantics supporting this feature at the macroblock level are described in Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マクロブロック・レベルでこの機能をサポートしているレイアウトと意味論はセクション10に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. Loop Filter Type and Levels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4。ループ・フィルタの種類とレベル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 supports two types of loop filters having different computational complexity. The following bits occur in the header to support the selection of the baseline type, strength, and sharpness behavior of the loop filter used for the current frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8は異なる計算の複雑さを持つループフィルタの2種類をサポートしています。次のビットは、現在のフレームに使用されるループフィルタのベースラインタイプ、強さ、シャープネスの挙動の選択をサポートするために、ヘッダに起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       +-------+-------------------+
                       | Index | Description       |
                       +-------+-------------------+
                       | L(1)  | filter_type       |
                       |       |                   |
                       | L(6)  | loop_filter_level |
                       |       |                   |
                       | L(3)  | sharpness_level   |
                       +-------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of these numbers will be further explained in Section 15.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの数字の意味はさらに、セクション15で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 has a feature in the bitstream that enables adjustment of the loop filter level based on a macroblock&#39;s prediction mode and reference frame. The per-macroblock adjustment is done through delta values against the default loop filter level for the current frame. This subsection contains flag and value information for implementing per-macroblock loop filter level adjustment to default decoder behavior. The data in this section is used in the decoding of the ensuing per-macroblock information and applies to the entire frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8は、マクロブロックの予測モード及び参照フレームに基づいて、ループフィルタレベルの調整を可能にするビットストリームに特徴を有しています。単位のマクロブロックの調整は、現在のフレームのデフォルトのループフィルタレベルに対するデルタ値を介して行われます。ここでは、デコーダの動作をデフォルトに当たりマクロブロックループフィルタレベル調整を実現するためのフラグ値情報を含みます。このセクション内のデータは、その後毎マクロブロック情報の復号化に使用され、フレーム全体に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
L(1) is a one-bit flag indicating if the macroblock loop filter adjustment is on for the current frame. 0 means that such a feature is not supported in the current frame, and 1 means this feature is enabled for the current frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lは、（1）マクロブロック・ループフィルタ調整は、現在のフレームのためであるかどうかを示す1ビットのフラグです。 0は、そのような機能は、現在のフレームでサポートされていないことを意味し、1は、この機能は、現在のフレームのために有効にされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether the adjustment is based on a reference frame or encoding mode, the adjustment of the loop filter level is done via a delta value against a baseline loop filter value. The delta values are updated for the current frame if an L(1) bit, mode_ref_lf_delta_update, takes the value 1. There are two groups of delta values: One group of delta values is for reference frame-based adjustments, and the other group is for mode-based adjustments. The number of delta values in the two groups is MAX_REF_LF_DELTAS and MAX_MODE_LF_DELTAS, respectively. For every value within the two groups, there is a one-bit L(1) to indicate if the particular value is updated. When one is updated (1), it is transmitted as a six-bit-magnitude L(6) followed by a one-bit sign flag (L(1) -- 0 for positive and 1 for negative).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
調整は、基準フレーム又は符号化モードに基づいているかどうか、ループフィルタレベルの調整は、基準ループフィルタ値に対してデルタ値を介して行われます。デルタ値の1つのグループは、参照フレームベースの調整のためであり、そして他の基であり：Lは、（1）ビット、mode_ref_lf_delta_updateは、デルタ値の二つのグループがあり、値1をとる場合、デルタ値は、現在のフレームのために更新されますモードベースの調整のために。両群におけるデルタ値の数は、それぞれ、MAX_REF_LF_DELTAS及びMAX_MODE_LF_DELTASあります。二つのグループ内のすべての値に対して、特定の値が更新されたかどうかを示すために1ビットL（1）があります。 （ - 陰性について陽性で0と1 L（1））一方が（1）更新された場合、それは、6ビットの大きさL（6）1ビットの符号フラグが続くように送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. Token Partition and Partition Data Offsets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5。トークンのパーティションとパーティションデータオフセット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 allows DCT coefficients to be packed into multiple partitions, besides the first partition with header and per-macroblock prediction information, so the decoder can perform parallel decoding in an efficient manner. A two-bit L(2) is used to indicate the number of coefficient data partitions within a compressed frame. The two bits are defined in the following table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8は、ヘッダとごとのマクロブロックの予測情報と最初のパーティション以外に、DCT係数が複数のパーティションに充填することが可能となるので、デコーダは、効率的な方法で並列復号を行うことができます。 2ビットのL（2）は、圧縮フレーム内の係数データパーティションの数を示すために使用されます。 2つのビットは、以下の表に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                 +-------+-------+----------------------+
                 | Bit 1 | Bit 0 | Number of Partitions |
                 +-------+-------+----------------------+
                 | 0     | 0     | 1                    |
                 |       |       |                      |
                 | 0     | 1     | 2                    |
                 |       |       |                      |
                 | 1     | 0     | 4                    |
                 |       |       |                      |
                 | 1     | 1     | 8                    |
                 +-------+-------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Offsets are embedded in the bitstream to provide the decoder direct access to token partitions. If the number of data partitions is greater than 1, the size of each partition (except the last) is written in 3 bytes (24 bits). The size of the last partition is the remainder of the data not used by any of the previous partitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセットは、パーティションをトークンにデコーダの直接アクセスを提供するために、ビットストリーム中に埋め込まれています。データ・パーティションの数が1より大きい場合、（最後を除く）各パーティションのサイズは、3バイト（24ビット）に書き込まれます。最後のパーティションのサイズは、前のパーティションのいずれかで使用されていないデータの残りの部分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The partitioned data are consecutive in the bitstream, so the size can also be used to calculate the offset of each partition. The following pseudocode illustrates how the size/offset is defined by the three bytes in the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分割されたデータは、ビットストリームにおいて連続しているので、サイズは、各パーティションのオフセットを計算するために使用することができます。次の擬似コードは、サイズ/オフセットがビットストリーム中の3つのバイトによって定義されている様子を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Offset/size = (uint32)(byte0) + ((uint32)(byte1)&lt;&lt;8) + ((uint32)(byte2)&lt;&lt;16);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセット/サイズ=（UINT32）（BYTE0）+（（UINT32）（BYTE1）&lt;&lt; 8）+（（UINT32）（バイト2）&lt;&lt; 16）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. Dequantization Indices
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6。逆量子化インデックス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All residue signals are specified via a quantized 4x4 DCT applied to the Y, U, V, or Y2 subblocks of a macroblock. As detailed in Section 14, before inverting the transform, each decoded coefficient is multiplied by one of six dequantization factors, the choice of which depends on the plane (Y, chroma = U or V, Y2) and coefficient position (DC = coefficient 0, AC = coefficients 1-15). The six values are specified using 7-bit indices into six corresponding fixed tables (the tables are given in Section 14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全ての残留信号は、DCTは、マクロブロックのY、U、V、またはY2のサブブロックに適用される量子化された4×4を介して指定されています。セクション14で詳述するように、変換反転の前に、各復号された係数は、6つの逆量子化要因の一つによって乗算され、の選択は、平面（Y、クロマ= UまたはV、Y2）と係数位置に依存（DC係数0 = 、AC =係数1-15）。 6つの値は、（テーブルは、セクション14に示されている）は、6つの対応する固定されたテーブルに7ビットインデックスを使用して指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first 7-bit index gives the dequantization table index for Y-plane AC coefficients, called yac_qi. It is always coded and acts as a baseline for the other 5 quantization indices, each of which is represented by a delta from this baseline index. Pseudocode for reading the indices follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第7ビットインデックスはY平面AC係数の逆量子化テーブルインデックスと呼ばれるyac_qiを与えます。それは常に符号化され、この基準指数からのデルタによって表されるそれぞれが他の5つの量子化インデックスのためのベースラインとして作用します。インデックスを読み取るための擬似コードは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   yac_qi     = L(7);           /* Y ac index always specified */
   ydc_delta  = F? delta(): 0;  /* Y dc delta specified if
                                   flag is true */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   y2dc_delta = F? delta(): 0;  /* Y2 dc delta specified if
                                   flag is true */
   y2ac_delta = F? delta(): 0;  /* Y2 ac delta specified if
                                   flag is true */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   uvdc_delta = F? delta(): 0;  /* chroma dc delta specified
                                   if flag is true */
   uvac_delta = F? delta(): 0;  /* chroma ac delta specified
                                   if flag is true */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where delta() is the process to read 5 bits from the bitstream to determine a signed delta value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デルタ（）は、署名されたデルタ値を決定するために、ビットストリームからの5ビットを読み取るためのプロセスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +-------+--------------------------------------------------+
       | Index | Description                                      |
       +-------+--------------------------------------------------+
       | L(4)  | Magnitude of delta                               |
       |       |                                                  |
       | L(1)  | Sign of delta, 0 for positive and 1 for negative |
       +-------+--------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. Refresh Golden Frame and Altref Frame
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7。ゴールデンフレームとAltrefフレームを更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For key frames, both the golden frame and the altref frame are refreshed/ replaced by the current reconstructed frame, by default. For non-key frames, VP8 uses two bits to indicate whether the two frame buffers are refreshed, using the reconstructed current frame:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーフレームのために、金色のフレームとaltrefフレームの両方は、デフォルトでは、現在の再構成フレームに置き換え/更新されます。非キーフレームについて、VP8は、再構成された現在のフレームを使用して、2つのフレームバッファが更新されるかどうかを示すために2ビットを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------+----------------------------------------------------------+
   | Index | Description                                              |
   +-------+----------------------------------------------------------+
   | L(1)  | Whether golden frame is refreshed (0 for no, 1 for yes). |
   |       |                                                          |
   | L(1)  | Whether altref frame is refreshed (0 for no, 1 for yes). |
   +-------+----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the flag for the golden frame is 0, VP8 uses 2 more bits in the bitstream to indicate whether the buffer (and which buffer) is copied to the golden frame, or if no buffer is copied:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
金色のフレームのフラグが0である場合、VP8は、バッファ（及びそのバッファ）が金色のフレームにコピーされているかどうかを示すために、ビットストリーム中の2つの以上のビットを使用し、あるいは全くバッファがコピーされていない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Index | Description                              |
           +-------+------------------------------------------+
           | L(2)  | Buffer copy flag for golden frame buffer |
           +-------+------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 means no buffer is copied to the golden frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 0はバッファが金色のフレームにコピーされないことを意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 means last_frame is copied to the golden frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 1はlast_frameが金色のフレームにコピーされることを意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2 means alt_ref_frame is copied to the golden frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 2はalt_ref_frameが金色のフレームにコピーされることを意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, when the flag for altref is 0, VP8 uses 2 bits in the bitstream to indicate which buffer is copied to alt_ref_frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
altrefフラグが0である場合、同様に、VP8はalt_ref_frameにコピーされたバッファを示すために、ビットストリームに2ビットを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Index | Description                              |
           +-------+------------------------------------------+
           | L(2)  | Buffer copy flag for altref frame buffer |
           +-------+------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 means no buffer is copied to the altref frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 0はバッファがaltrefフレームにコピーされないことを意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 means last_frame is copied to the altref frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 1はlast_frameがaltrefフレームにコピーされることを意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2 means golden_frame is copied to the altref frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 2はgolden_frameがaltrefフレームにコピーされることを意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two bits are transmitted for ref_frame_sign_bias for golden_frame and alt_ref_frame, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのビットは、それぞれ、golden_frameとalt_ref_frameためref_frame_sign_biasために送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                +-------+---------------------------------+
                | Index | Description                     |
                +-------+---------------------------------+
                | L(1)  | Sign bias flag for golden frame |
                |       |                                 |
                | L(1)  | Sign bias flag for altref frame |
                +-------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These values are used to control the sign of the motion vectors when a golden frame or an altref frame is used as the reference frame for a macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの値は、金色のフレームまたはaltrefフレームがマクロブロックの参照フレームとして使用される動きベクトルの符号を制御するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. Refresh Last Frame Buffer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8。最後のフレームバッファを更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 uses one bit, L(1), to indicate if the last frame reference buffer is refreshed using the constructed current frame. On a key frame, this bit is overridden, and the last frame buffer is always refreshed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8は、最後のフレーム基準バッファを構築現在のフレームを使用して更新されるかどうかを示すために、（1）L、1ビットを使用します。キーフレームでは、このビットが上書きされ、最後のフレームバッファは常に更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. DCT Coefficient Probability Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9。 DCT係数の確率を更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This field contains updates to the probability tables used to decode DCT coefficients. For each of the probabilities in the tables, there is an L(1) flag indicating if the probability is updated for the current frame, and if the L(1) flag is set to 1, there follows an additional 8-bit value representing the new probability value. These tables are maintained across interframes but are of course replaced with their defaults at the beginning of every key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このフィールドは、DCT係数を復号化するために使用される確率テーブルへの更新が含まれています。テーブル内の確率のそれぞれについて、確率は、現在のフレームのために更新された場合（1）を示すフラグLがあり、L（1）フラグが1に設定されている場合、を表す追加の8ビット値が、以下新しい確率値。これらのテーブルは、インターフレーム間で維持されているが、もちろん、すべてのキーフレームの先頭でそのデフォルトに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout and semantics of this field will be taken up in Section 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このフィールドのレイアウトと意味論はセクション13に取り込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10. Remaining Frame Header Data (Non-Key Frame)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10。残りのフレームヘッダデータ（非キーフレーム）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------+-----------------------------------------------------------+
   | Index | Description                                               |
   +-------+-----------------------------------------------------------+
   | L(1)  | mb_no_skip_coeff.  This flag indicates at the frame level |
   |       | if skipping of macroblocks with no non-zero coefficients  |
   |       | is enabled.  If it is set to 0, then prob_skip_false is   |
   |       | not read and mb_skip_coeff is forced to 0 for all         |
   |       | macroblocks (see Sections 11.1 and 12.1).                 |
   |       |                                                           |
   | L(8)  | prob_skip_false = probability used for decoding a         |
   |       | macroblock-level flag, which indicates if a macroblock    |
   |       | has any non-zero coefficients.  Only read if              |
   |       | mb_no_skip_coeff is 1.                                    |
   |       |                                                           |
   | L(8)  | prob_intra = probability that a macroblock is &#34;intra&#34;     |
   |       | predicted (that is, predicted from the already-encoded    |
   |       | portions of the current frame), as opposed to &#34;inter&#34;     |
   |       | predicted (that is, predicted from the contents of a      |
   |       | prior frame).                                             |
   |       |                                                           |
   | L(8)  | prob_last = probability that an inter-predicted           |
   |       | macroblock is predicted from the immediately previous     |
   |       | frame, as opposed to the most recent golden frame or      |
   |       | altref frame.                                             |
   |       |                                                           |
   | L(8)  | prob_gf = probability that an inter-predicted macroblock  |
   |       | is predicted from the most recent golden frame, as        |
   |       | opposed to the altref frame.                              |
   |       |                                                           |
   | F     | If true, followed by four L(8)s updating the              |
   |       | probabilities for the different types of intra-prediction |
   |       | for the Y plane.  These probabilities correspond to the   |
   |       | four interior nodes of the decoding tree for intra-Y      |
   |       | modes in an interframe, that is, the even positions in    |
   |       | the ymode_tree array given above.                         |
   |       |                                                           |
   | F     | If true, followed by three L(8)s updating the             |
   |       | probabilities for the different types of intra-prediction |
   |       | for the chroma planes.  These probabilities correspond to |
   |       | the even positions in the uv_mode_tree array given above. |
   |       |                                                           |
   | X     | Motion vector probability update.  Details are given in   |
   |       | Section 17.2, &#34;Probability Updates&#34;.                      |
   +-------+-----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding of this portion of the frame header is handled in the reference decoder file dixie.c (Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームヘッダのこの部分の復号は、参照デコーダファイルdixie.c（セクション20.4）で処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11. Remaining Frame Header Data (Key Frame)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11。残りのフレームヘッダデータ（キーフレーム）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------+-----------------------------------------------------------+
   | Index | Description                                               |
   +-------+-----------------------------------------------------------+
   | L(1)  | mb_no_skip_coeff.  This flag indicates at the frame level |
   |       | if skipping of macroblocks with no non-zero coefficients  |
   |       | is enabled.  If it is set to 0, then prob_skip_false is   |
   |       | not read and mb_skip_coeff is forced to 0 for all         |
   |       | macroblocks (see Sections 11.1 and 12.1).                 |
   |       |                                                           |
   | L(8)  | prob_skip_false = Probability used for decoding a         |
   |       | macroblock-level flag, which indicates if a macroblock    |
   |       | has any non-zero coefficients.  Only read if              |
   |       | mb_no_skip_coeff is 1.                                    |
   +-------+-----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding of this portion of the frame header is handled in the reference decoder file modemv.c (Section 20.11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームヘッダのこの部分の復号は、参照デコーダファイルmodemv.c（セクション20.11）で処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This completes the layout of the frame header. The remainder of the first data partition consists of macroblock-level prediction data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、フレームヘッダのレイアウトを完了する。最初のデータ・パーティションの残りの部分は、マクロブロック・レベルの予測データから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the frame header is processed, all probabilities needed to decode the prediction and residue data are known and will not change until the next frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームヘッダが処理された後、予測及び残留データを復号するために必要な全ての確率が知られており、次のフレームまで変化しないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Segment-Based Feature Adjustments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.セグメントベースの機能の調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every macroblock may optionally override some of the default behaviors of the decoder. Specifically, VP8 uses segment-based adjustments to support changing quantizer level and loop filter level for a macroblock. When the segment-based adjustment feature is enabled for a frame, each macroblock within the frame is coded with a segment_id. This effectively segments all the macroblocks in the current frame into a number of different segments. Macroblocks within the same segment behave exactly the same for quantizer and loop filter level adjustments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのマクロブロックは、必要に応じてデコーダのデフォルト動作の一部を無効にすることができます。具体的には、VP8は、マクロブロックの量子化レベルとループフィルタレベルの変更をサポートするために、セグメント・ベースの調整を使用します。セグメントベースの調整機能がフレームのために有効にされたときに、フレーム内の各マクロブロックは、segment_idにして符号化されます。この効果セグメントの異なるセグメントの数に現在のフレーム内の全てのマクロブロック。同一セグメント内のマクロブロックは、量子化器とループフィルタレベル調整のためのまったく同じように動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If both the segmentation_enabled and update_mb_segmentation_map flags in subsection B of the frame header take a value of 1, the prediction data for each (intra- or inter-coded) macroblock begins with a specification of segment_id for the current macroblock. It is decoded using this simple tree ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームヘッダのサブセクションBの両方のsegmentation_enabledとupdate_mb_segmentation_mapフラグが1の値をとる場合は、各（イントラまたはインター符号化された）マクロブロックの予測データは、現在のマクロブロックのための仕様segment_idに始まります。それは、この単純な木を使用してデコードされ...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index mb_segment_tree [2 * (4-1)] =
     {
       2,  4,     /* root: &#34;0&#34;, &#34;1&#34; subtrees */
       -0, -1,    /* &#34;00&#34; = 0th value, &#34;01&#34; = 1st value */
        -2, -3    /* &#34;10&#34; = 2nd value, &#34;11&#34; = 3rd value */
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
... combined with a 3-entry probability table, mb_segment_tree_probs[3]. The macroblock&#39;s segment_id is used later in the decoding process to look into the segment_feature_data table and determine how the quantizer and loop filter levels are adjusted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
... 3エントリ確率テーブルと組み合わせて、mb_segment_tree_probs [3]。マクロブロックのsegment_idにはsegment_feature_data表に見て、量子化器ループフィルタレベルが調整される方法を決定するために復号プロセスで後に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoding of segment_id, together with the parsing of intra-prediction modes (which is taken up next), is implemented in the reference decoder file modemv.c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
segment_idにの復号化は、一緒に（次巻き取られる）イントラ予測モードの解析と、参照デコーダファイルmodemv.cに実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Key Frame Macroblock Prediction Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.キーフレームのマクロブロック予測レコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After specifying the features described above, the macroblock prediction record next specifies the prediction mode used for the macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の特徴を指定した後、マクロブロック予測レコードは、次のマクロブロックのために使用される予測モードを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. mb_skip_coeff
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1。 mb_skip_coeff
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The single bool flag is decoded using prob_skip_false if and only if mb_no_skip_coeff is set to 1 (see Sections 9.10 and 9.11). If mb_no_skip_coeff is set to 0, then this value defaults to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一ブールフラグとmb_no_skip_coeffが1に設定されている場合にのみ（セクション9.10および9.11を参照）場合prob_skip_falseを用いて復号化されます。 0にmb_no_skip_coeffが0に設定されている場合は、この値がデフォルトになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Luma Modes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2。ルマモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First comes the luma specification of type intra_mbmode, coded using the kf_ymode_tree, as described in Section 8 and repeated here for convenience:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の便宜のために、セクション8に記載されており、ここでは繰り返さとして、kf_ymode_treeを使用してコード化された型intra_mbmodeの輝度仕様は、付属しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef enum
   {
       DC_PRED, /* predict DC using row above and column to the left */
       V_PRED,  /* predict rows using row above */
       H_PRED,  /* predict columns using column to the left */
       TM_PRED, /* propagate second differences a la &#34;True Motion&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       B_PRED,  /* each Y subblock is independently predicted */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       num_uv_modes = B_PRED,  /* first four modes apply to chroma */
       num_ymodes   /* all modes apply to luma */
   }
   intra_mbmode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index kf_ymode_tree [2 * (num_ymodes - 1)] =
   {
    -B_PRED, 2,            /* root: B_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -DC_PRED, -V_PRED,   /* &#34;10&#34; subtree: DC_PRED = &#34;100&#34;,
                              V_PRED = &#34;101&#34; */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For key frames, the Y mode is decoded using a fixed probability array as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーフレームのために、Yモードは次のように固定された確率アレイを用いて復号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const Prob kf_ymode_prob [num_ymodes - 1] = { 145, 156, 163, 128};
   Ymode = (intra_mbmode) treed_read(d, kf_ymode_tree, kf_ymode_prob);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d is of course the bool_decoder being used to read the first data partition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dはもちろん、最初のデータ・パーティションを読み取るために使用されてbool_decoderです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Ymode is B_PRED, it is followed by a (tree-coded) mode for each of the 16 Y subblocks. The 10 subblock modes and their coding tree are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
YmodeがB_PREDである場合、それは、16個のYのサブブロックの各々について（木符号化）モードが続きます。次のように10のサブブロックモードとそのコーディングツリーは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef enum
   {
       B_DC_PRED,  /* predict DC using row above and column
                      to the left */
       B_TM_PRED,  /* propagate second differences a la
                      &#34;True Motion&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       B_VE_PRED,  /* predict rows using row above */
       B_HE_PRED,  /* predict columns using column to the left */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       B_LD_PRED,  /* southwest (left and down) 45 degree diagonal
                      prediction */
       B_RD_PRED,  /* southeast (right and down) &#34;&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       B_VR_PRED,  /* SSE (vertical right) diagonal prediction */
       B_VL_PRED,  /* SSW (vertical left) &#34;&#34; */
       B_HD_PRED,  /* ESE (horizontal down) &#34;&#34; */
       B_HU_PRED,  /* ENE (horizontal up) &#34;&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 num_intra_bmodes } intra_bmode;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
num_intra_bmodes} intra_bmode。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Coding tree for the above, with implied codings as comments */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index bmode_tree [2 * (num_intra_bmodes - 1)] =
   {
    -B_DC_PRED, 2,                   /* B_DC_PRED = &#34;0&#34; */
     -B_TM_PRED, 4,                  /* B_TM_PRED = &#34;10&#34; */
      -B_VE_PRED, 6,                 /* B_VE_PRED = &#34;110&#34; */
       8, 12,
        -B_HE_PRED, 10,              /* B_HE_PRED = &#34;11100&#34; */
         -B_RD_PRED, -B_VR_PRED,     /* B_RD_PRED = &#34;111010&#34;,
                                        B_VR_PRED = &#34;111011&#34; */
        -B_LD_PRED, 14,              /* B_LD_PRED = &#34;111110&#34; */
          -B_VL_PRED, 16,            /* B_VL_PRED = &#34;1111110&#34; */
            -B_HD_PRED, -B_HU_PRED   /* HD = &#34;11111110&#34;,
                                        HU = &#34;11111111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first four modes are smaller versions of the similarly named 16x16 modes above, albeit with slightly different numbering. The last six &#34;diagonal&#34; modes are unique to luma subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の4つのモードは、わずかに異なる番号を持つにもかかわらず、上記同様の名前の16×16モードのより小さなバージョンです。最後の6つの「対角」モードは、輝度サブブロックに固有のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Subblock Mode Contexts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3。サブブロックモードのコンテキスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding of subblock modes in key frames uses the modes already coded for the subblocks to the left of and above the subblock to select a probability array for decoding the current subblock mode. This is our first instance of contextual prediction, and there are several caveats associated with it:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーフレームにおけるサブブロックモードの符号化は、現在のサブブロックモードを復号化するための確率アレイを選択するために、すでにのサブブロックと上記左サブブロックのための符号化モードを使用します。これは文脈予測の私たちの最初のインスタンスであり、それに関連したいくつかの注意点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The adjacency relationships between subblocks are based on the normal default raster placement of the subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.サブブロック間の隣接関係は、サブブロックの通常のデフォルトのラスタ配置に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The adjacent subblocks need not lie in the current macroblock. The subblocks to the left of the left-edge subblocks 0, 4, 8, and 12 are the right-edge subblocks 3, 7, 11, and 15, respectively, of the (already coded) macroblock immediately to the left. Similarly, the subblocks above the top-edge subblocks 0, 1, 2, and 3 are the bottom-edge subblocks 12, 13, 14, and 15 of the already-coded macroblock immediately above us.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.隣接するサブブロックは、現在のマクロブロック内に存在する必要はありません。左エッジサブブロック0、4、8、及び12の左側にサブブロックは、すぐ左に（既に符号化された）マクロブロックのそれぞれのサブブロック3、7、11、15、右エッジです。同様に、トップエッジサブブロック0、1、2、及び3以上のサブブロックは、ボトムエッジサブブロック12、13、14、直ちに米国上記既に符号化されたマクロブロックの15。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. For macroblocks on the top row or left edge of the image, some of the predictors will be non-existent. Such predictors are taken to have had the value B_DC_PRED, which, perhaps conveniently, takes the value 0 in the enumeration above. A simple management scheme for these contexts might maintain a row of above predictors and four left predictors. Before decoding the frame, the entire row is initialized to B_DC_PRED; before decoding each row of macroblocks, the four left predictors are also set to B_DC_PRED. After decoding a macroblock, the bottom four subblock modes are copied into the row predictor (at the current position, which then advances to be above the next macroblock), and the right four subblock modes are copied into the left predictor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.上部行のマクロブロック又は画像の左端のために、予測因子のいくつかは、存在しないであろう。このような予測因子は、おそらく便利、上記の列挙に値0をとり、値B_DC_PREDを、持っていたために取られています。これらの状況のた​​めの単純な管理方式は、上記の予測因子四の左予測子の行を保持するかもしれません。フレームを復号する前に、行全体がB_DC_PREDに初期化されます。マクロブロックの各行を復号する前には、4つの左側予測子もB_DC_PREDに設定されています。マクロブロックを復号化した後、底部4つのサブブロックモードが（その後、次のマクロブロックの上になるように進み、現在の位置で）行予測にコピーされ、そして右の4つのサブブロックモードは左予測にコピーされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Many macroblocks will of course be coded using a 16x16 luma prediction mode. For the purpose of predicting ensuing subblock modes (only), such macroblocks derive a subblock mode, constant throughout the macroblock, from the 16x16 luma mode as follows: DC_PRED uses B_DC_PRED, V_PRED uses B_VE_PRED, H_PRED uses B_HE_PRED, and TM_PRED uses B_TM_PRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.多くのマクロブロックはもちろん、16×16の輝度予測モードを使用して符号化されます。次のようにサブブロックモード（のみ）に続く予測の目的のために、そのようなマクロブロックは16×16輝度モードから、マクロブロック全体にわたって一定のサブブロックモードを導き出す：DC_PREDはB_DC_PREDを使用して、V_PREDはB_VE_PREDを使用して、H_PREDはB_HE_PREDを使用し、そしてTM_PREDはB_TM_PREDを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Although we discuss interframe modes in Section 16, we remark here that, while interframes do use all the intra-coding modes described here and below, the subblock modes in an interframe are coded using a single constant probability array that does not depend on any context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5.私たちは、セクション16でインターモードを議論するが、我々は、インターフレームは、ここで、下記の全てのイントラ符号化モードを使用して行いながら、インターにおけるサブブロックモードがオンに依存しない、単一の一定の確率アレイを使用してコード化されている、ことをここで発言任意のコンテキスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dependence of subblock mode probability on the nearby subblock mode context is most easily handled using a three-dimensional constant array:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
近くの日焼け止めモードコンテキスト上の日焼け止めモード確率の依存性は、最も容易に三次元の定数配列を使用して処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes] [num_intra_bmodes-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コスト問題kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes] [num_intra_bmodes-1]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The outer two dimensions of this array are indexed by the already-coded subblock modes above and to the left of the current block, respectively. The inner dimension is a typical tree probability list whose indices correspond to the even indices of the bmode_tree above. The mode for the j^(th) luma subblock is then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアレイの外側の2つの寸法は、それぞれ、現在のブロックの左側上記とに既に符号化されたサブブロックモードによってインデックス付けされます。内側寸法は、そのインデックス上記bmode_treeの偶数インデックスに対応する典型的なツリー確率リストです。 J ^（番目）ルマサブブロックのためのモードが続いています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bmode = (intra_bmode) treed_read(d, bmode_tree, kf_bmode_prob [A] [L]);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BMODE =（intra_bmode）treed_read（D、bmode_tree、kf_bmode_prob [A] [L]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the 4x4 Y subblock index j varies from 0 to 15 in raster order, and A and L are the modes used above and to the left of the j^(th) subblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4×4 Yサブブロックインデックスjは、ラスタ順に0から15まで変化し、A及びLは、上記とj ^（番目）のサブブロックの左側に使用されるモードである場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the kf_bmode_prob array are given at the end of this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kf_bmode_prob配列の内容は、このセクションの終わりに与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. Chroma Modes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4。クロマモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the Y mode (and optional subblock mode) specification comes the chroma mode. The chroma modes are a subset of the Y modes and are coded using the uv_mode_tree, as described in Section 8 and repeated here for convenience:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yモード（およびオプションのサブブロックモード）後の仕様は、クロマモードを付属しています。セクション8に記載され、便宜のためここでは繰り返さとしてクロマモードは、Yモードのサブセットであるとuv_mode_treeを用いて符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index uv_mode_tree [2 * (num_uv_modes - 1)] =
   {
    -DC_PRED, 2,           /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     -V_PRED, 4,           /* &#34;1&#34; subtree:  V_PRED = &#34;10&#34;,
                              &#34;11&#34; subtree */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As for the Y modes (in a key frame), the chroma modes are coded using a fixed, contextless probability table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（キーフレームで）Yモード用として、クロマモードが固定され、コンテキストレス確率テーブルを用いて符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const Prob kf_uv_mode_prob [num_uv_modes - 1] = { 142, 114, 183};
   uv_mode = (intra_mbmode) treed_read(d, uv_mode_tree,
     kf_uv_mode_prob);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This completes the description of macroblock prediction coding for key frames. As will be discussed in Section 16, the coding of intra modes within interframes is similar, but not identical, to that described here (and in the reference code) for prediction modes and, indeed, for all tree-coded data in VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、キーフレームのマクロブロック予測符号化の説明を終えます。セクション16に説明するように、インターフレーム内のイントラ・モードの符号化は、VP8内のすべてのツリー符号化されたデータのために、実際に、予測モードのためにここで（及び参照コードで）説明したものと、同様の、しかし同一ではないと。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5. Subblock Mode Probability Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5。サブブロックモード確率テーブル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, here is the fixed probability table used to decode subblock modes in key frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、ここでキーフレームにおけるサブブロックのモードを復号化するために使用される固定された確率テーブルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes] [num_intra_bmodes-1] = { { { 231, 120, 48, 89, 115, 113, 120, 152, 112}, { 152, 179, 64, 126, 170, 118, 46, 70, 95}, { 175, 69, 143, 80, 85, 82, 72, 155, 103}, { 56, 58, 10, 171, 218, 189, 17, 13, 152}, { 144, 71, 10, 38, 171, 213, 144, 34, 26}, { 114, 26, 17, 163, 44, 195, 21, 10, 173}, { 121, 24, 80, 195, 26, 62, 44, 64, 85}, { 170, 46, 55, 19, 136, 160, 33, 206, 71}, { 63, 20, 8, 114, 114, 208, 12, 9, 226}, { 81, 40, 11, 96, 182, 84, 29, 16, 36} },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コスト問題kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes] [num_intra_bmodes-1] = {{{231、120、48、89、115、113、120、152、112}、{152、179、64、126、170、118、 46、70、95}、{175、69、143、80、85、82、72、155、103}、{56、58、10、171、218、189、17、13、152}、{144。 71、10、38、171、213、144、34、26}、{114、26、17、163、44、195、21、10、173}、{121、24、80、195、26、62、 44、64、85}、{170、46、55、19、136、160、33、206、71}、{63、20、8、114、114、208、12、9、226}、{81、 40、11、96、182、84、29、16、36}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
{ { 134, 183, 89, 137, 98, 101, 106, 165, 148}, { 72, 187, 100, 130, 157, 111, 32, 75, 80}, { 66, 102, 167, 99, 74, 62, 40, 234, 128}, { 41, 53, 9, 178, 241, 141, 26, 8, 107}, { 104, 79, 12, 27, 217, 255, 87, 17, 7}, { 74, 43, 26, 146, 73, 166, 49, 23, 157}, { 65, 38, 105, 160, 51, 52, 31, 115, 128}, { 87, 68, 71, 44, 114, 51, 15, 186, 23}, { 47, 41, 14, 110, 182, 183, 21, 17, 194}, { 66, 45, 25, 102, 197, 189, 23, 18, 22} }, { { 88, 88, 147, 150, 42, 46, 45, 196, 205}, { 43, 97, 183, 117, 85, 38, 35, 179, 61}, { 39, 53, 200, 87, 26, 21, 43, 232, 171}, { 56, 34, 51, 104, 114, 102, 29, 93, 77}, { 107, 54, 32, 26, 51, 1, 81, 43, 31}, { 39, 28, 85, 171, 58, 165, 90, 98, 64}, { 34, 22, 116, 206, 23, 34, 43, 166, 73}, { 68, 25, 106, 22, 64, 171, 36, 225, 114}, { 34, 19, 21, 102, 132, 188, 16, 76, 124}, { 62, 18, 78, 95, 85, 57, 50, 48, 51} }, { { 193, 101, 35, 159, 215, 111, 89, 46, 111}, { 60, 148, 31, 172, 219, 228, 21, 18, 111}, { 112, 113, 77, 85, 179, 255, 38, 120, 114}, { 40, 42, 1, 196, 245, 209, 10, 25, 109}, { 100, 80, 8, 43, 154, 1, 51, 26, 71}, { 88, 43, 29, 140, 166, 213, 37, 43, 154}, { 61, 63, 30, 155, 67, 45, 68, 1, 209}, { 142, 78, 78, 16, 255, 128, 34, 197, 171}, { 41, 40, 5, 102, 211, 183, 4, 1, 221}, { 51, 50, 17, 168, 209, 192, 23, 25, 82} }, { { 125, 98, 42, 88, 104, 85, 117, 175, 82}, { 95, 84, 53, 89, 128, 100, 113, 101, 45}, { 75, 79, 123, 47, 51, 128, 81, 171, 1}, { 57, 17, 5, 71, 102, 57, 53, 41, 49}, { 115, 21, 2, 10, 102, 255, 166, 23, 6}, { 38, 33, 13, 121, 57, 73, 26, 1, 85}, { 41, 10, 67, 138, 77, 110, 90, 47, 114}, { 101, 29, 16, 10, 85, 128, 101, 196, 26}, { 57, 18, 10, 102, 102, 213, 34, 20, 43}, { 117, 20, 15, 36, 163, 128, 68, 1, 26} },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
{ { 134, 183, 89, 137, 98, 101, 106, 165, 148}, { 72, 187, 100, 130, 157, 111, 32, 75, 80}, { 66, 102, 167, 99, 74, 62, 40, 234, 128}, { 41, 53, 9, 178, 241, 141, 26, 8, 107}, { 104, 79, 12, 27, 217, 255, 87, 17, 7}, { 74, 43, 26, 146, 73, 166, 49, 23, 157}, { 65, 38, 105, 160, 51, 52, 31, 115, 128}, { 87, 68, 71, 44, 114, 51, 15, 186, 23}, { 47, 41, 14, 110, 182, 183, 21, 17, 194}, { 66, 45, 25, 102, 197, 189, 23, 18, 22} }, { { 88, 88, 147, 150, 42, 46, 45, 196, 205}, { 43, 97, 183, 117, 85, 38, 35, 179, 61}, { 39, 53, 200, 87, 26, 21, 43, 232, 171}, { 56, 34, 51, 104, 114, 102, 29, 93, 77}, { 107, 54, 32, 26, 51, 1, 81, 43, 31}, { 39, 28, 85, 171, 58, 165, 90, 98, 64}, { 34, 22, 116, 206, 23, 34, 43, 166, 73}, { 68, 25, 106, 22, 64, 171, 36, 225, 114}, { 34, 19, 21, 102, 132, 188, 16, 76, 124}, { 62, 18, 78, 95, 85, 57, 50, 48, 51} }, { { 193, 101, 35, 159, 215, 111, 89, 46, 111}, { 60, 148, 31, 172, 219, 228, 21, 18, 111}, { 112, 113, 77, 85, 179, 255, 38, 120, 114}, { 40, 42, 1, 196, 245, 209, 10, 25, 109}, { 100, 80, 8, 43, 154, 1, 51, 26, 71}, { 88, 43, 29, 140, 166, 213, 37, 43, 154}, { 61, 63, 30, 155, 67, 45, 68, 1, 209}, { 142, 78, 78, 16, 255, 128, 34, 197, 171}, { 41, 40, 5, 102, 211, 183, 4, 1, 221}, { 51, 50, 17, 168, 209, 192, 23, 25, 82} }, { { 125, 98, 42, 88, 104, 85, 117, 175, 82}, { 95, 84, 53, 89, 128, 100, 113, 101, 45}, { 75, 79, 123, 47, 51, 128, 81, 171, 1}, { 57, 17, 5, 71, 102, 57, 53, 41, 49}, { 115, 21, 2, 10, 102, 255, 166, 23, 6}, { 38, 33, 13, 121, 57, 73, 26, 1, 85}, { 41, 10, 67, 138, 77, 110, 90, 47, 114}, { 101, 29, 16, 10, 85, 128, 101, 196, 26}, { 57, 18, 10, 102, 102, 213, 34, 20, 43}, { 117, 20, 15, 36, 163, 128, 68, 1, 26} },
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
{ { 138, 31, 36, 171, 27, 166, 38, 44, 229}, { 67, 87, 58, 169, 82, 115, 26, 59, 179}, { 63, 59, 90, 180, 59, 166, 93, 73, 154}, { 40, 40, 21, 116, 143, 209, 34, 39, 175}, { 57, 46, 22, 24, 128, 1, 54, 17, 37}, { 47, 15, 16, 183, 34, 223, 49, 45, 183}, { 46, 17, 33, 183, 6, 98, 15, 32, 183}, { 65, 32, 73, 115, 28, 128, 23, 128, 205}, { 40, 3, 9, 115, 51, 192, 18, 6, 223}, { 87, 37, 9, 115, 59, 77, 64, 21, 47} }, { { 104, 55, 44, 218, 9, 54, 53, 130, 226}, { 64, 90, 70, 205, 40, 41, 23, 26, 57}, { 54, 57, 112, 184, 5, 41, 38, 166, 213}, { 30, 34, 26, 133, 152, 116, 10, 32, 134}, { 75, 32, 12, 51, 192, 255, 160, 43, 51}, { 39, 19, 53, 221, 26, 114, 32, 73, 255}, { 31, 9, 65, 234, 2, 15, 1, 118, 73}, { 88, 31, 35, 67, 102, 85, 55, 186, 85}, { 56, 21, 23, 111, 59, 205, 45, 37, 192}, { 55, 38, 70, 124, 73, 102, 1, 34, 98} }, { { 102, 61, 71, 37, 34, 53, 31, 243, 192}, { 69, 60, 71, 38, 73, 119, 28, 222, 37}, { 68, 45, 128, 34, 1, 47, 11, 245, 171}, { 62, 17, 19, 70, 146, 85, 55, 62, 70}, { 75, 15, 9, 9, 64, 255, 184, 119, 16}, { 37, 43, 37, 154, 100, 163, 85, 160, 1}, { 63, 9, 92, 136, 28, 64, 32, 201, 85}, { 86, 6, 28, 5, 64, 255, 25, 248, 1}, { 56, 8, 17, 132, 137, 255, 55, 116, 128}, { 58, 15, 20, 82, 135, 57, 26, 121, 40} }, { { 164, 50, 31, 137, 154, 133, 25, 35, 218}, { 51, 103, 44, 131, 131, 123, 31, 6, 158}, { 86, 40, 64, 135, 148, 224, 45, 183, 128}, { 22, 26, 17, 131, 240, 154, 14, 1, 209}, { 83, 12, 13, 54, 192, 255, 68, 47, 28}, { 45, 16, 21, 91, 64, 222, 7, 1, 197}, { 56, 21, 39, 155, 60, 138, 23, 102, 213}, { 85, 26, 85, 85, 128, 128, 32, 146, 171}, { 18, 11, 7, 63, 144, 171, 4, 4, 246}, { 35, 27, 10, 146, 174, 171, 12, 26, 128} },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
{ { 138, 31, 36, 171, 27, 166, 38, 44, 229}, { 67, 87, 58, 169, 82, 115, 26, 59, 179}, { 63, 59, 90, 180, 59, 166, 93, 73, 154}, { 40, 40, 21, 116, 143, 209, 34, 39, 175}, { 57, 46, 22, 24, 128, 1, 54, 17, 37}, { 47, 15, 16, 183, 34, 223, 49, 45, 183}, { 46, 17, 33, 183, 6, 98, 15, 32, 183}, { 65, 32, 73, 115, 28, 128, 23, 128, 205}, { 40, 3, 9, 115, 51, 192, 18, 6, 223}, { 87, 37, 9, 115, 59, 77, 64, 21, 47} }, { { 104, 55, 44, 218, 9, 54, 53, 130, 226}, { 64, 90, 70, 205, 40, 41, 23, 26, 57}, { 54, 57, 112, 184, 5, 41, 38, 166, 213}, { 30, 34, 26, 133, 152, 116, 10, 32, 134}, { 75, 32, 12, 51, 192, 255, 160, 43, 51}, { 39, 19, 53, 221, 26, 114, 32, 73, 255}, { 31, 9, 65, 234, 2, 15, 1, 118, 73}, { 88, 31, 35, 67, 102, 85, 55, 186, 85}, { 56, 21, 23, 111, 59, 205, 45, 37, 192}, { 55, 38, 70, 124, 73, 102, 1, 34, 98} }, { { 102, 61, 71, 37, 34, 53, 31, 243, 192}, { 69, 60, 71, 38, 73, 119, 28, 222, 37}, { 68, 45, 128, 34, 1, 47, 11, 245, 171}, { 62, 17, 19, 70, 146, 85, 55, 62, 70}, { 75, 15, 9, 9, 64, 255, 184, 119, 16}, { 37, 43, 37, 154, 100, 163, 85, 160, 1}, { 63, 9, 92, 136, 28, 64, 32, 201, 85}, { 86, 6, 28, 5, 64, 255, 25, 248, 1}, { 56, 8, 17, 132, 137, 255, 55, 116, 128}, { 58, 15, 20, 82, 135, 57, 26, 121, 40} }, { { 164, 50, 31, 137, 154, 133, 25, 35, 218}, { 51, 103, 44, 131, 131, 123, 31, 6, 158}, { 86, 40, 64, 135, 148, 224, 45, 183, 128}, { 22, 26, 17, 131, 240, 154, 14, 1, 209}, { 83, 12, 13, 54, 192, 255, 68, 47, 28}, { 45, 16, 21, 91, 64, 222, 7, 1, 197}, { 56, 21, 39, 155, 60, 138, 23, 102, 213}, { 85, 26, 85, 85, 128, 128, 32, 146, 171}, { 18, 11, 7, 63, 144, 171, 4, 4, 246}, { 35, 27, 10, 146, 174, 171, 12, 26, 128} },
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 { { 190, 80, 35, 99, 180, 80, 126, 54, 45}, { 85, 126, 47, 87, 176, 51, 41, 20, 32}, { 101, 75, 128, 139, 118, 146, 116, 128, 85}, { 56, 41, 15, 176, 236, 85, 37, 9, 62}, { 146, 36, 19, 30, 171, 255, 97, 27, 20}, { 71, 30, 17, 119, 118, 255, 17, 18, 138}, { 101, 38, 60, 138, 55, 70, 43, 26, 142}, { 138, 45, 61, 62, 219, 1, 81, 188, 64}, { 32, 41, 20, 117, 151, 142, 20, 21, 163}, { 112, 19, 12, 61, 195, 128, 48, 4, 24} } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ { 190, 80, 35, 99, 180, 80, 126, 54, 45}, { 85, 126, 47, 87, 176, 51, 41, 20, 32}, { 101, 75, 128, 139, 118, 146, 116, 128, 85}, { 56, 41, 15, 176, 236, 85, 37, 9, 62}, { 146, 36, 19, 30, 171, 255, 97, 27, 20}, { 71, 30, 17, 119, 118, 255, 17, 18, 138}, { 101, 38, 60, 138, 55, 70, 43, 26, 142}, { 138, 45, 61, 62, 219, 1, 81, 188, 64}, { 32, 41, 20, 117, 151, 142, 20, 21, 163}, { 112, 19, 12, 61, 195, 128, 48, 4, 24} } };
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Intraframe Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.フレーム内予測
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intraframe prediction uses already-coded macroblocks within the current frame to approximate the contents of the current macroblock. It applies to intra-coded macroblocks in an interframe and to all macroblocks in a key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イントラ予測は、現在のマクロブロックの内容を近似するために、現在のフレーム内の既に符号化マクロブロックを使用します。これは、インターで、キーフレーム内のすべてのマクロブロックに対してイントラ符号化されたマクロブロックに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Relative to the current macroblock &#34;M&#34;, the already-coded macroblocks include all macroblocks above M together with the macroblocks on the same row as, and to the left of, M, though at most four of these macroblocks are actually used: the block &#34;A&#34; directly above M, the blocks immediately to the left and right of A, and the block immediately to the left of M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのマクロブロックの最大で4つの実際に使用しているが、現在のマクロブロック「M」に対して、既に符号化されたマクロブロックは、一緒に、及びMの左側に同じ行のマクロブロックとM上の全てのマクロブロックを含む：ブロック「」直上M、左およびAの右、及びMのすぐ左にブロックに直ちにブロック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the prediction modes (i.e., means of extrapolation from already-calculated values) uses fairly simple arithmetic on pixel values whose positions, relative to the current position, are defined by the mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予測モード（すなわち、既に計算された値から外挿手段）の各々は、位置、現在の位置に対して、モードによって定義される画素値にかなり単純な算術を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chroma (U and V) and luma (Y) predictions are independent of each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クロマ（U及びV）及び輝度（Y）の予測は、互いに独立しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The relative addressing of pixels applied to macroblocks on the upper row or left column of the frame will sometimes cause pixels outside the visible frame to be referenced. Usually such out-of-bounds pixels have an assumed value of 129 for pixels to the left of the leftmost column of the visible frame and 127 for pixels above the top row of the visible frame (including the special case of the pixel above and to the left of the top-left pixel in the visible frame). Exceptions to this (associated to certain modes) will be noted below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上段またはフレームの左欄にマクロブロックに適用される画素の相対アドレッシングを時々参照される可視フレームの外側のピクセルを引き起こすであろう。通常、そのような範囲外の画素は、可視フレームの左端の列の左側の画素について129（上記とに画素の特別な場合を含む、可視フレームの一番上の行上の画素のための127の想定値を有します可視フレームにおける左上画素の左）。 （特定のモードに関連する）、これに例外は、以下に記載されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The already-coded macroblocks referenced by intra-prediction have been &#34;reconstructed&#34;, that is, have been predicted and residue-adjusted (as described in Section 14), but have not been loop-filtered. While it does process the edges between individual macroblocks and individual subblocks, loop filtering (described in Section 15) is applied to the frame as a whole, after all of the macroblocks have been reconstructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イントラ予測で参照される既に符号化マクロブロックは、「再構築」されている、すなわち、予測された、残渣調整（項14に記載のように）が、ループフィルタリングされていません。それは、個々のマクロブロックおよび個々のサブブロック、ループフィルタ（セクション15を参照）との間のエッジを処理しながら、マクロブロックの全てが再構築された後に、全体としてのフレームに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. mb_skip_coeff
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1。 mb_skip_coeff
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The single bool flag is decoded using prob_skip_false if and only if mb_no_skip_coeff is set to 1 (see Sections 9.10 and 9.11). If mb_no_skip_coeff is set to 0, then this value defaults to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一ブールフラグとmb_no_skip_coeffが1に設定されている場合にのみ（セクション9.10および9.11を参照）場合prob_skip_falseを用いて復号化されます。 0にmb_no_skip_coeffが0に設定されている場合は、この値がデフォルトになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. Chroma Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2。クロマ予測
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chroma prediction is a little simpler than the luma prediction, so we treat it first. Each of the chroma modes treats U and V identically; that is, the U and V prediction values are calculated in parallel, using the same relative addressing and arithmetic in each of the two planes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クロマ予測は、輝度予測よりも少し簡単ですので、我々は最初にそれを扱います。クロマモードのそれぞれは、同一U及びVを扱います。つまり、UとVの予測値は、二つの平面のそれぞれにおいて同一の相対アドレッシング及び演算を使用して、並行して計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The modes extrapolate prediction values using the 8-pixel row &#34;A&#34; lying immediately above the block (that is, the bottom chroma row of the macroblock immediately above the current macroblock) and the 8-pixel column &#34;L&#34; immediately to the left of the block (that is, the rightmost chroma column of the macroblock immediately to the left of the current macroblock).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードは、すぐ左に8画素行「」ブロックの直上に位置する（すなわち、直ちに現在のマクロブロックの上のマクロブロックの底彩度行）で、8画素列「L」を使用して予測値を外挿するブロック（すなわち、現在のマクロブロックのすぐ左のマクロブロックの右端の彩度列です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vertical prediction (chroma mode V_PRED) simply fills each 8-pixel row of the 8x8 chroma block with a copy of the &#34;above&#34; row (A). If the current macroblock lies on the top row of the frame, all 8 of the pixel values in A are assigned the value 127.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
垂直予測（クロマモードV_PRED）は単に「上」の行（A）のコピーで8×8クロマ・ブロックの各8画素行を埋めます。現在のマクロブロックがフレームの一番上の行にある場合は、Aの画素値の全8は、値127を割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, horizontal prediction (H_PRED) fills each 8-pixel column of the 8x8 chroma block with a copy of the &#34;left&#34; column (L). If the current macroblock is in the left column of the frame, all 8 pixel values in L are assigned the value 129.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、水平予測（H_PRED）が「左」の列（L）のコピーを有する8×8クロマ・ブロックの各8画素列を埋めます。現在のマクロブロックがフレームの左側の列にある場合、L内の全ての8つのピクセル値は値129が割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DC prediction (DC_PRED) fills the 8x8 chroma block with a single value. In the generic case of a macroblock lying below the top row and right of the leftmost column of the frame, this value is the average of the 16 (genuinely visible) pixels in the (union of the) above row A and left column L.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DC予測（DC_PRED）は、単一の値を持つ8×8クロマ・ブロックを埋めます。フレームの左端の列の一番上の行と右下にあるマクロブロックの一般的な場合には、この値は、行Aと左側の列L.上記（の連合）16（純粋に見える）画素の平均であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, if the current macroblock lies on the top row of the frame, the average of the 8 pixels in L is used; if it lies in the left column of the frame, the average of the 8 pixels in A is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のマクロブロックがフレームの一番上の行にある場合はそれ以外の場合、L 8つの画素の平均値が使用されます。それはフレームの左側の列にある場合は、Aに8つの画素の平均値が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the averages used in these exceptional cases are not the same as those that would be arrived at by using the out-of-bounds A and L values defined for V_PRED and H_PRED. In the case of the leftmost macroblock on the top row of the frame, the 8x8 block is simply filled with the constant value 128.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの例外的な場合に使用される平均がV_PREDとH_PREDに対して定義された範囲外A及びLの値を使用して到着したであろうものと同じではないことに留意されたいです。フレームの一番上の行の左端のマクロブロックの場合には、8×8ブロックは、単に定数値128で満たされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For DC_PRED, apart from the exceptional case of the top-left macroblock, we are averaging either 16 or 8 pixel values to get a single prediction value that fills the 8x8 block. The rounding is done as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DC_PREDため、離れた左上のマクロブロックの例外的なケースから、我々は、8×8ブロックを満たす単一の予測値を取得するために、16のまたは8の画素値を平均化しています。次のように丸めが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int sum;  /* sum of 8 or 16 pixels at (at least) 16-bit precision */
   int shf;  /* base 2 logarithm of the number of pixels (3 or 4) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pixel DCvalue = (sum + (1 &lt;&lt; (shf-1))) &gt;&gt; shf;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピクセルDCvalue =（和+（1 &lt;&lt;（SHF-1）））&gt;&gt; SHF。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the summands are all valid pixels, no &#34;clamp&#34; is necessary in the calculation of DCvalue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加数は、全ての有効画素なので、ノー「クランプ」はDCvalueの計算に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining &#34;True Motion&#34; (TM_PRED) chroma mode gets its name from an older technique of video compression used by On2 Technologies, to which it bears some relation. In addition to the row &#34;A&#34; and column &#34;L&#34;, TM_PRED uses the pixel &#34;P&#34; above and to the left of the chroma block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りの「真の動き」（TM_PRED）クロマモードでは、いくつかの関係を負担先のはOn2 Technologies社によって使用されるビデオ圧縮の古い技術からその名前を取得します。行「A」および列「L」に加えて、TM_PREDは、上記およびクロマブロックの左にある画素「P」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following figure gives an example of how TM_PRED works:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の図は、TM_PREDがどのように機能するかの例を示します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | P   | A0  | A1  | A2  | A3  | A4  | A5  | A6  | A7  |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L0  | X00 | X01 | X02 | X03 | X04 | X05 | X06 | X07 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L1  | X10 | X11 | X12 | X13 | X14 | X15 | X16 | X17 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L2  | X20 | X21 | X22 | X23 | X24 | X25 | X26 | X27 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L3  | X30 | X31 | X32 | X33 | X34 | X35 | X36 | X37 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L4  | X40 | X41 | X42 | X43 | X44 | X45 | X46 | X47 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L5  | X50 | X51 | X52 | X53 | X54 | X55 | X56 | X57 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L6  | X60 | X61 | X62 | X63 | X64 | X65 | X66 | X67 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L7  | X70 | X71 | X72 | X73 | X74 | X75 | X76 | X77 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where P, As, and Ls represent reconstructed pixel values from previously coded blocks, and X00 through X77 represent predicted values for the current block. TM_PRED uses the following equation to calculate X_ij:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、P、Lsは以前に符号化されたブロックから再構成画素値を表し、X77を介しX00は、現在ブロックの予測値を表す。そして、としてTM_PREDはX_ijを計算するためには、次の式を使用しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X_ij = L_i + A_j - P (i, j=0, 1, 2, 3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X_ij = L_iを+ A_j  -  P（I、J = 0、1、2、3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact algorithm is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように正確なアルゴリズムは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void TMpred(
       Pixel b[8][8],      /* chroma (U or V) prediction block */
       const Pixel A[8],   /* row of already-constructed pixels
                              above block */
       const Pixel L[8],   /* column of &#34;&#34; just to the left of
                              block */
       const Pixel P       /* pixel just to the left of A and
                              above L*/
   ) {
       int r = 0;          /* row */
       do {
           int c = 0;      /* column */
           do {
               b[r][c] = clamp255(L[r]+ A[c] - P);
           } while (++c &lt; 8);
       } while (++r &lt; 8);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the process could equivalently be described as propagating the vertical differences between pixels in L (starting from P), using the pixels from A to start each column.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロセスは、等価的に各列を開始するためにAからの画素を用いて、（Pから始まる）Lにおける画素間の垂直方向の差を伝播するように記述することができることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation of chroma intra-prediction may be found in the reference decoder file predict.c (Section 20.14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クロマイントラ予測の実装は、基準デコーダファイルpredict.c（セクション20.14）に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike DC_PRED, for macroblocks on the top row or left edge, TM_PRED does use the out-of-bounds values of 127 and 129 (respectively) defined for V_PRED and H_PRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DC_PRED異なり、一番上の行または左端にマクロブロックについて、TM_PREDはV_PREDとH_PREDに対して定義された（それぞれ）127と129の範囲外の値を使用しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. Luma Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3。ルマ予測
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prediction processes for the first four 16x16 luma modes (DC_PRED, V_PRED, H_PRED, and TM_PRED) are essentially identical to the corresponding chroma prediction processes described above, the only difference being that we are predicting a single 16x16 luma block instead of two 8x8 chroma blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の4つの16×16輝度モード（DC_PRED、V_PRED、H_PRED、及びTM_PRED）のためのプロセスは、上述の対応するクロマ予測プロセスと本質的に同一である予測、唯一の違いは、我々は、単一の16×16輝度ブロックの代わりに、2つの8×8彩度を予測していることですブロック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the row &#34;A&#34; and column &#34;L&#34; here contain 16 pixels, the DC prediction is calculated using 16 or 32 pixels (and shf is 4 or 5), and we of course fill the entire prediction buffer, that is, 16 rows (or columns) containing 16 pixels each. The reference implementation of 16x16 luma prediction is also in predict.c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、行「A」および列「L」はここで16個の画素を含む、DC予測は、16個の又は32の画素を用いて算出される（及びSHFは4又は5）、我々はもちろん全体予測バッファを満たす、すなわち、16であります16個の画素それぞれを含む行（または列）。 16×16の輝度予測のリファレンス実装はpredict.cでもあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the remaining luma mode (B_PRED), each 4x4 Y subblock is independently predicted using one of ten modes (listed, along with their encodings, in Section 11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残り輝度モード（B_PRED）においては、各4×4 Yサブブロックは、独立して（セクション11で、それらの符号化と共に、列挙された）1〜10個のモードを用いて予測されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, unlike the full-macroblock modes already described, some of the subblock modes use prediction pixels above and to the right of the current subblock. In detail, each 4x4 subblock &#34;B&#34; is predicted using (at most) the 4-pixel column &#34;L&#34; immediately to the left of B and the 8-pixel row &#34;A&#34; immediately above B, consisting of the 4 pixels above B followed by the 4 adjacent pixels above and to the right of B, together with the single pixel &#34;P&#34; immediately to the left of A (and immediately above L).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、既に説明したフルマクロブロックモードとは異なり、サブブロックモードの一部は、現在のサブブロックの右上方とに予測画素を用います。詳細には、各4×4サブブロック「B」はBの左側および「the」は、直ちにB上に、B上記4つの画素からなる8画素行に直ちに4画素列「L」（最大で）を用いて予測されます一緒に（そして直ちにL上）のすぐ左側に単一ピクセル「P」で、上記とBの右に隣接する画素4が続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purpose of subblock intra-prediction, the pixels immediately to the left and right of a pixel in a subblock are the same as the pixels immediately to the left and right of the corresponding pixel in the frame buffer &#34;F&#34;. Vertical offsets behave similarly: The above row A lies immediately above B in F, and the adjacent pixels in the left column L are separated by a single row in F.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブブロックのイントラ予測の目的のために、直ちにサブブロック内の画素の左右の画素が直ちにフレームバッファ「F」に対応する画素の左右の画素と同一です。垂直オフセットは、同様に動作：上記の行Aは、Fに直ちにBの上方に位置し、左列Lに隣接する画素は、Fに単一の行によって分離されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because entire macroblocks (as opposed to their constituent subblocks) are reconstructed in raster-scan order, for subblocks lying along the right edge (and not along the top row) of the current macroblock, the four &#34;extra&#34; prediction pixels in A above and to the right of B have not yet actually been constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
なぜなら、現在のマクロブロックの全体のマクロブロック（その構成サブブロックとは対照的に）サブブロックが（としない一番上の行に沿って）右端に沿って存在するため、ラスタスキャン順に再構築される、上記の4つの「余分な」予測画素とBの右側に、まだ実際に構築されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subblocks 7, 11, and 15 are affected. All three of these subblocks use the same extra pixels as does subblock 3 (at the upper right corner of the macroblock), namely the 4 pixels immediately above and to the right of subblock 3. Writing (R,C) for a frame buffer position offset from the upper left corner of the current macroblock by R rows and C columns, the extra pixels for all the right-edge subblocks (3, 7, 11, and 15) are at positions (-1,16), (-1,17), (-1,18), and (-1,19). For the rightmost macroblock in each macroblock row except the top row, the extra pixels shall use the same value as the pixel at position (-1,15), which is the rightmost visible pixel on the line immediately above the macroblock row. For the top macroblock row, all the extra pixels assume a value of 127.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブブロック7、11、及び15が影響を受けます。 （マクロブロックの右上隅に）サブブロック3と同様に、これらのサブブロックの3つ全てが直上及び書き込み（R、C）フレームバッファ位置のサブブロック3の右側に、すなわち4つの画素を同一の余分なピクセルを使用しますR行とC列によって現在のマクロブロックの左上隅からのオフセット、すべての右エッジサブブロック（3、7、11、および15）のための余分なピクセルが（位置（-1,16）である-1 、17）、（-1,18）、及び（-1,19）。一番上の行を除いて、各マクロブロック行の右端のマクロブロックのために、余分なピクセルが直ちにマクロブロック行の上の行の右端の可視画素位置の画素（-1,15）、同じ値を使用しなければなりません。上部マクロブロック行のため、すべての余分なピクセルが127の値を取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details of the prediction modes are most easily described in code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予測モードの詳細については、最も簡単にコードに記述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Result pixels are often averages of two or three predictor
      pixels.  The following subroutines are used to calculate
      these averages.  Because the arguments are valid pixels, no
      clamping is necessary.  An actual implementation would
      probably use inline functions or macros. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Compute weighted average centered at y w/adjacent x, z */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pixel avg3(Pixel x, Pixel y, Pixel z) { return (x + y + y + z + 2) &gt;&gt; 2;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画素avg3（画素x、画素y、画素Z）{リターン（X + Y + Y + Z + 2）&gt;&gt; 2;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Weighted average of 3 adjacent pixels centered at p */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pixel avg3p(const Pixel *p) { return avg3(p[-1], p[0], p[1]);}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画素avg3p（CONST画素* P）{戻りavg3た（p [-1]、P [0]、P [1]）;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Simple average of x and y */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pixel avg2(Pixel x, Pixel y) { return (x + y + 1) &gt;&gt; 1;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画素AVG2（画素x、画素y）{リターン（X + Y + 1）&gt;&gt; 1;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Average of p[0] and p[1] may be considered to be a synthetic
      pixel lying between the two, that is, one half-step past p. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pixel avg2p(const Pixel *p) { return avg2(p[0], p[1]);}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画素avg2p（CONST画素* P）{戻りAVG2（P [0]、P [1]）;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void subblock_intra_predict(
       Pixel B[4][4],     /* Y subblock prediction buffer */
       const Pixel *A,    /* A[0]...A[7] = above row, A[-1] = P */
       const Pixel *L,    /* L[0]...L[3] = left column, L[-1] = P */
       intra_bmode mode   /* enum is in Section 11.2 */
   ) {
       Pixel E[9];        /* 9 already-constructed edge pixels */
       E[0] = L[3];  E[1] = L[2];  E[2] = L[1];  E[3] = L[0];
       E[4] = A[-1];      /* == L[-1] == P */
       E[5] = A[0];  E[6] = A[1];  E[7] = A[2];  E[8] = A[3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     switch(mode) {
       /* First four modes are similar to corresponding
          full-block modes. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_DC_PRED:
       {
           int v = 4;      /* DC sum/avg, 4 is rounding adjustment */
           int i = 0;  do { v += A[i] + L[i];}  while (++i &lt; 4);
           v &gt;&gt;= 3;        /* averaging 8 pixels */
           i = 0;  do {    /* fill prediction buffer with constant DC
                              value */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               int j = 0;  do { B[i][j] = v;}  while (++j &lt; 4);
           } while (++i &lt; 4);
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_TM_PRED: /* just like 16x16 TM_PRED */
       {
           int r = 0;  do {
               int c = 0;  do {
                   B[r][c] = clamp255(L[r] + A[c] - A[-1]);
               } while (++c &lt; 4);
           } while (++r &lt; 4);
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_VE_PRED: /* like 16x16 V_PRED except using averages */
       {
           int c = 0;  do { /* all 4 rows = smoothed top row */
               B[0][c] = B[1][c] = B[2][c] = B[3][c] = avg3p(A + c);
           } while (++c &lt; 4);
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_HE_PRED: /* like 16x16 H_PRED except using averages */
       {
           /* Bottom row is exceptional because L[4] does not exist */
           int v = avg3(L[2], L[3], L[3]);
           int r = 3;  while (1) {  /* all 4 columns = smoothed left
                                       column */
               B[r][0] = B[r][1] = B[r][2] = B[r][3] = v;
               if (--r &lt; 0)
                   break;
               v = avg3p(L + r);  /* upper 3 rows use average of
                                      3 pixels */
           }
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* The remaining six &#34;diagonal&#34; modes subdivide the
          prediction buffer into diagonal lines.  All the pixels
          on each line are assigned the same value; this value is
          (a smoothed or synthetic version of) an
          already-constructed predictor value lying on the same
          line.  For clarity, in the comments, we express the
          positions of these predictor pixels relative to the
          upper left corner of the destination array B.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
These modes are unique to subblock prediction and have no full-block analogs. The first two use lines at +|- 45 degrees from horizontal (or, equivalently, vertical), that is, lines whose slopes are +|- 1. */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
これらのモードは、予測をサブブロックに固有であり、何のフルブロックアナログを持っていません。最初の2つの使用株+ |  - 水平（または、等価的に、垂直）から45°、すなわち、傾斜しているライン+ |  -  1 * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_LD_PRED:    /* southwest (left and down) step =
                             (-1, 1) or (1,-1) */
           /* avg3p(A + j) is the &#34;smoothed&#34; pixel at (-1,j) */
           B[0][0] = avg3p(A + 1);
           B[0][1] = B[1][0] = avg3p(A + 2);
           B[0][2] = B[1][1] = B[2][0] = avg3p(A + 3);
           B[0][3] = B[1][2] = B[2][1] = B[3][0] = avg3p(A + 4);
           B[1][3] = B[2][2] = B[3][1] = avg3p(A + 5);
           B[2][3] = B[3][2] = avg3p(A + 6);
           B[3][3] = avg3(A[6], A[7], A[7]); /* A[8] does not exist */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_RD_PRED: /* southeast (right and down) step =
                          (1,1) or (-1,-1) */
           B[3][0] = avg3p(E + 1);  /* predictor is from (2, -1) */
           B[3][1] = B[2][0] = avg3p(E + 2);  /* (1, -1) */
           B[3][2] = B[2][1] = B[1][0] = avg3p(E + 3);  /* (0, -1) */
           B[3][3] = B[2][2] = B[1][1] = B[0][0] =
             avg3p(E + 4);  /* (-1, -1) */
           B[2][3] = B[1][2] = B[0][1] = avg3p(E + 5);  /* (-1, 0) */
           B[1][3] = B[0][2] = avg3p(E + 6);  /* (-1, 1) */
           B[0][3] = avg3p(E + 7);  /* (-1, 2) */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* The remaining 4 diagonal modes use lines whose slopes are
          +|- 2 and +|- 1/2.  The angles of these lines are roughly
          +|- 27 degrees from horizontal or vertical.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Unlike the 45 degree diagonals, here we often need to &#34;synthesize&#34; predictor pixels midway between two actual predictors using avg2p(p), which we think of as returning the pixel &#34;at&#34; p[1/2]. */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
45度の対角線とは異なり、ここで私たちはしばしば、我々はP 1/2「に」画素を返すように考えるavg2p（P）を使用して2つの実際の予測子、の間の予測画素途中で「合成」する必要があります。 * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_VR_PRED:    /* SSE (vertical right) step =
                             (2,1) or (-2,-1) */
           B[3][0] = avg3p(E + 2);  /* predictor is from (1, -1) */
           B[2][0] = avg3p(E + 3);  /* (0, -1) */
           B[3][1] = B[1][0] = avg3p(E + 4);  /* (-1,   -1) */
           B[2][1] = B[0][0] = avg2p(E + 4);  /* (-1, -1/2) */
           B[3][2] = B[1][1] = avg3p(E + 5);  /* (-1,    0) */
           B[2][2] = B[0][1] = avg2p(E + 5);  /* (-1,  1/2) */
           B[3][3] = B[1][2] = avg3p(E + 6);  /* (-1,    1) */
           B[2][3] = B[0][2] = avg2p(E + 6);  /* (-1,  3/2) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           B[1][3] = avg3p(E + 7);  /* (-1, 2) */
           B[0][3] = avg2p(E + 7);  /* (-1, 5/2) */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_VL_PRED:    /* SSW (vertical left) step =
                             (2,-1) or (-2,1) */
           B[0][0] = avg2p(A);  /* predictor is from (-1, 1/2) */
           B[1][0] = avg3p(A + 1);  /* (-1, 1) */
           B[2][0] = B[0][1] = avg2p(A + 1);  /* (-1, 3/2) */
           B[1][1] = B[3][0] = avg3p(A + 2);  /* (-1,   2) */
           B[2][1] = B[0][2] = avg2p(A + 2);  /* (-1, 5/2) */
           B[3][1] = B[1][2] = avg3p(A + 3);  /* (-1,   3) */
           B[2][2] = B[0][3] = avg2p(A + 3);  /* (-1, 7/2) */
           B[3][2] = B[1][3] = avg3p(A + 4);  /* (-1,   4) */
           /* Last two values do not strictly follow the pattern. */
           B[2][3] = avg3p(A + 5);  /* (-1, 5) [avg2p(A + 4) =
                                        (-1,9/2)] */
           B[3][3] = avg3p(A + 6);  /* (-1, 6) [avg3p(A + 5) =
                                        (-1,5)] */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_HD_PRED:    /* ESE (horizontal down) step =
                             (1,2) or (-1,-2) */
           B[3][0] = avg2p(E);  /* predictor is from (5/2, -1) */
           B[3][1] = avg3p(E + 1);  /* (2, -1) */
           B[2][0] = B[3][2] = svg2p(E + 1);  /* ( 3/2, -1) */
           B[2][1] = B[3][3] = avg3p(E + 2);  /* (   1, -1) */
           B[2][2] = B[1][0] = avg2p(E + 2);  /* ( 1/2, -1) */
           B[2][3] = B[1][1] = avg3p(E + 3);  /* (   0, -1) */
           B[1][2] = B[0][0] = avg2p(E + 3);  /* (-1/2, -1) */
           B[1][3] = B[0][1] = avg3p(E + 4);  /* (  -1, -1) */
           B[0][2] = avg3p(E + 5);  /* (-1, 0) */
           B[0][3] = avg3p(E + 6);  /* (-1, 1) */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case B_HU_PRED:    /* ENE (horizontal up) step = (1,-2)
                             or (-1,2) */
           B[0][0] = avg2p(L);  /* predictor is from (1/2, -1) */
           B[0][1] = avg3p(L + 1);  /* (1, -1) */
           B[0][2] = B[1][0] = avg2p(L + 1);  /* (3/2, -1) */
           B[0][3] = B[1][1] = avg3p(L + 2);  /* (  2, -1) */
           B[1][2] = B[2][0] = avg2p(L + 2);  /* (5/2, -1) */
           B[1][3] = B[2][1] = avg3(L[2], L[3], L[3]);  /* (3, -1) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Not possible to follow pattern for much of the bottom
              row because no (nearby) already-constructed pixels lie
              on the diagonals in question. */
           B[2][2] = B[2][3] = B[3][0] = B[3][1] = B[3][2] = B[3][3]
             = L[3];
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference decoder implementation of subblock intra-prediction may be found in predict.c (Section 20.14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブブロックのイントラ予測の基準デコーダ実装はpredict.c（セクション20.14）に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. DCT Coefficient Decoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. DCT係数のデコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second data partition consists of an encoding of the quantized DCT (and WHT) coefficients of the residue signal. As discussed in the format overview (Section 2), for each macroblock, the residue is added to the (intra- or inter-generated) prediction buffer to produce the final (except for loop filtering) reconstructed macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二のデータ・パーティションは、残差信号の量子化DCT（及びWHT）係数の符号化から成ります。フォーマットの概要（セクション2）で説明したように、マクロブロック毎に、残渣は、マクロブロックを再構成（ループ・フィルタリングを除く）の最終を生成する（イントラまたはインター生成された）予測バッファに追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 works exclusively with 4x4 DCTs and WHTs, applied to the 24 (or 25 with the Y2 subblock) 4x4 subblocks of a macroblock. The ordering of macroblocks within any of the &#34;residue&#34; partitions in general follows the same raster scan as used in the first &#34;prediction&#34; partition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8は、（Y2サブブロックまたは25）24に印加される4×4のDCTとWHTs、マクロブロックの4×4サブブロックと排他的に動作します。一般に、「残基」のパーティションのいずれか内のマクロブロックの順序は、最初の「予測」パーティションで使用したものと同じラスタ走査に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all intra- and inter-prediction modes apart from B_PRED (intra: whose Y subblocks are independently predicted) and SPLITMV (inter), each macroblock&#39;s residue record begins with the Y2 component of the residue, coded using a WHT. B_PRED and SPLITMV coded macroblocks omit this WHT and specify the 0th DCT coefficient in each of the 16 Y subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（イントラ：そのYサブブロック独立に予測される）B_PREDから離れたすべてのイントラ及びインター予測モードについて、およびSPLITMV（インター）、各マクロブロックの残差レコードはWHTを用いて符号化された残基のY2成分、始まります。 B_PREDとSPLITMV符号化マクロブロックは、このWHTを省略して16個のYサブブロックのそれぞれにおける0番目のDCT係数を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the optional Y2 block, the residue record continues with 16 DCTs for the Y subblocks, followed by 4 DCTs for the U subblocks, ending with 4 DCTs for the V subblocks. The subblocks occur in the usual order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意Y2ブロック後、残渣レコードはVサブブロック4つのDCTで終わるUサブブロック4つのDCT、続いてYサブブロックのための16個のDCT、を続けます。サブブロックは、通常の順序で発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCTs and WHT are tree-coded using a 12-element alphabet whose members we call &#34;tokens&#34;. Except for the end-of-block token (which sets the remaining subblock coefficients to zero and is followed by the next block), each token (sometimes augmented with data immediately following the token) specifies the value of the single coefficient at the current (implicit) position and is followed by a token applying to the next (implicit) position.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCTとWHTは、ツリーコーディングされたメンバーたちは、「トークン」と呼ぶ12要素のアルファベットを使用しています。 （ゼロに残りのサブブロックの係数を設定し、次のブロックが続く）、エンドオブブロックトークンを除いて、（時々、データがすぐにトークンを以下で増強）各トークンは、（現在の単一の係数の値を指定します暗黙的な）位置と、次の（暗黙）の位置に適用するトークンが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all the Y and chroma subblocks, the ordering of the coefficients follows a so-called zig-zag order. DCTs begin at coefficient 1 if Y2 is present, and begin at coefficient 0 if Y2 is absent. The WHT for a Y2 subblock always begins at coefficient 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのYとクロマサブブロックについて、係数の順序は、いわゆるジグザグ順序に従います。 DCTは、Y2が存在する場合、係数1で始まり、そしてY2が不在である場合、係数0から始まります。 Y2サブブロックのためのWHTは常に係数0から始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Macroblock without Non-Zero Coefficient Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1。非ゼロ係数値なしのマクロブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the flag within macroblock (MB) MODE_INFO indicates that a macroblock does not have any non-zero coefficients, the decoding process of DCT coefficients is skipped for the macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マクロブロック（MB）MODE_INFO内のフラグはマクロブロックは、任意の非ゼロ係数を持たないことを示す場合、DCT係数の復号処理は、マクロブロックのためにスキップされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Coding of Individual Coefficient Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2。個々の係数値のコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding of coefficient tokens is the same for the DCT and WHT, and for the remainder of this section &#34;DCT&#34; should be taken to mean either DCT or WHT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
係数トークンの符号化は、DCT及びWHTについて同じであり、このセクションの残りの部分は、「DCT」とは、DCTまたはWHTのいずれかを意味すると解釈されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All tokens (except end-of-block) specify either a single unsigned value or a range of unsigned values (immediately) followed by a simple probabilistic encoding of the offset of the value from the base of that range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（エンド・オブ・ブロックを除く）すべてのトークンは、単一の符号なしの値または符号なしの値の範囲のいずれかを指定する（直ちに）その範囲のベースからのオフセット値の単純な確率的符号化が続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-zero values (of either type) are then followed by a flag indicating the sign of the coded value (negative if 1, positive if 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（いずれかのタイプの）非ゼロ値は、（、1であれば負の場合は0、正の）符号化された値の符号を示すフラグが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below are the tokens and decoding tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、トークンと、復号化ツリーがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef enum
   {
       DCT_0,      /* value 0 */
       DCT_1,      /* 1 */
       DCT_2,      /* 2 */
       DCT_3,      /* 3 */
       DCT_4,      /* 4 */
       dct_cat1,   /* range 5 - 6  (size 2) */
       dct_cat2,   /* 7 - 10   (4) */
       dct_cat3,   /* 11 - 18  (8) */
       dct_cat4,   /* 19 - 34  (16) */
       dct_cat5,   /* 35 - 66  (32) */
       dct_cat6,   /* 67 - 2048  (1982) */
       dct_eob,    /* end of block */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       num_dct_tokens   /* 12 */
   }
   dct_token;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index coeff_tree [2 * (num_dct_tokens - 1)] =
   {
    -dct_eob, 2,               /* eob = &#34;0&#34;   */
     -DCT_0, 4,                /* 0   = &#34;10&#34;  */
      -DCT_1, 6,               /* 1   = &#34;110&#34; */
       8, 12,
        -DCT_2, 10,            /* 2   = &#34;11100&#34; */
         -DCT_3, -DCT_4,       /* 3   = &#34;111010&#34;, 4 = &#34;111011&#34; */
        14, 16,
         -dct_cat1, -dct_cat2, /* cat1 =  &#34;111100&#34;,
                                  cat2 = &#34;111101&#34; */
        18, 20,
         -dct_cat3, -dct_cat4, /* cat3 = &#34;1111100&#34;,
                                  cat4 = &#34;1111101&#34; */
         -dct_cat5, -dct_cat6  /* cat4 = &#34;1111110&#34;,
                                  cat4 = &#34;1111111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, all DCT coefficients are decoded using the same tree. However, if the preceding coefficient is a DCT_0, decoding will skip the first branch, since it is not possible for dct_eob to follow a DCT_0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的に、全てのDCT係数が同じツリーを使用して復号されます。前の係数がDCT_0であれば、それはDCT_0に従うことdct_eobことは不可能であるので、デコードは、最初の分岐をスキップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The tokens dct_cat1 ... dct_cat6 specify ranges of unsigned values, the value within the range being formed by adding an unsigned offset (whose width is 1, 2, 3, 4, 5, or 11 bits, respectively) to the base of the range, using the following algorithm and fixed probability tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンはdct_cat1 ... dct_cat6のベースに符号なしの値の範囲は、（それぞれ、幅が1、2、3、4、5、又は11ビット）の符号なしオフセットを加算することにより形成される範囲内の値を指定します範囲は、以下のアルゴリズムおよび固定確率テーブルを使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   uint DCTextra(bool_decoder *d, const Prob *p)
   {
       uint v = 0;
       do { v += v + read_bool(d, *p);}  while (*++p);
       return v;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const Prob Pcat1[] = { 159, 0};
   const Prob Pcat2[] = { 165, 145, 0};
   const Prob Pcat3[] = { 173, 148, 140, 0};
   const Prob Pcat4[] = { 176, 155, 140, 135, 0};
   const Prob Pcat5[] = { 180, 157, 141, 134, 130, 0};
   const Prob Pcat6[] =
       { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If v -- the unsigned value decoded using the coefficient tree, possibly augmented by the process above -- is non-zero, its sign is set by simply reading a flag:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
V場合 - 符号なしの値はおそらく上記の方法により増大係数ツリーを用いて復号が - 非ゼロであり、その符号は、単にフラグを読み出すことによって設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
if (read_bool(d, 128)) v = -v;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IF（read_bool（D、128））V = -v。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. Token Probabilities
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3。トークンの確率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability specification for the token tree (unlike that for the &#34;extra bits&#34; described above) is rather involved. It uses three pieces of context to index a large probability table, the contents of which may be incrementally modified in the frame header. The full (non-constant) probability table is laid out as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（上述の「追加ビット」の場合とは異なり）トークンツリーの確率仕様はかなり複雑です。これは、増分フレームヘッダに修飾されてもよい内容がインデックスにコンテキスト3個大きな確率テーブルを使用します。次のように完全な（非定数）確率テーブルがレイアウトされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prob coeff_probs [4] [8] [3] [num_dct_tokens-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題のcoeff_probs [4] [8] [3] [num_dct_tokens-1]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Working from the outside in, the outermost dimension is indexed by the type of plane being decoded:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最も外側の寸法がデコードされる平面のタイプによってインデックス付けされ、外部からの作業：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 - Y beginning at coefficient 1 (i.e., Y after Y2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0  -  Yは、（Y2後即ち、Y）、係数1から始まります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 - Y2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 1  -  Y2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2 - U or V
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 2  -  UまたはV
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 3 - Y beginning at coefficient 0 (i.e., Y in the absence of Y2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3 O  -  Yは、係数0から始まる（即ち、Y Y2の非存在下で）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next dimension is selected by the position of the coefficient being decoded. That position, c, steps by ones up to 15, starting from zero for block types 1, 2, or 3 and starting from one for block type 0. The second array index is then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の寸法は、デコードされた係数の位置によって選択されます。ブロックタイプ1、2、または3のためにゼロから開始し、ブロックタイプごとに1つから出発して15までのものによってその位置、C、手順は、0二番目の配列インデックスが次にあります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
coeff_bands [c]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
coeff_bands [C]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const int coeff_bands [16] = { 0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST INT coeff_bands [16] = {0、1、2、3、6、4、5、6、6、6、6、6、6、6、6、7}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is a fixed mapping of position to &#34;band&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「バンド」に位置の固定マッピングです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third dimension is the trickiest. Roughly speaking, it measures the &#34;local complexity&#34; or extent to which nearby coefficients are non-zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
三次元はトリッキーです。大まかに言えば、それは近くの係数が非ゼロであると「ローカル複雑」または程度を測定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the first coefficient (DC, unless the block type is 0), we consider the (already encoded) blocks within the same plane (Y2, Y, U, or V) above and to the left of the current block. The context index is then the number (0, 1, or 2) of these blocks that had at least one non-zero coefficient in their residue record. Specifically for Y2, because macroblocks above and to the left may or may not have a Y2 block, the block above is determined by the most recent macroblock in the same column that has a Y2 block, and the block to the left is determined by the most recent macroblock in the same row that has a Y2 block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の係数（DC、ブロックタイプが0である場合を除く）のために、我々は現在ブロックの左側上記とに同一の平面（Y2、Y、U、又はV）内に（既に符号化された）ブロックを考えます。コンテキストインデックスは、次に、その残留物レコードに少なくとも1つの非ゼロ係数を有していたこれらのブロックの数（0、1、または2）です。具体的には上記と左マクロブロックがまたはY2ブロックを有しても有さなくてもよいので、Y2のために、ブロックは、上記Y2ブロックを有し、同一列内の最新のマクロブロックによって決定され、左側のブロックによって決定されますY2ブロックを持って、同じ行の中で最も最近のマクロブロック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Beyond the first coefficient, the context index is determined by the absolute value of the most recently decoded coefficient (necessarily within the current block) and is 0 if the last coefficient was a zero, 1 if it was plus or minus one, and 2 if its absolute value exceeded one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の係数を超え、コンテキストインデックスは（必ずしも現在のブロック内の）最も最近に復号化係数の絶対値によって決定されている0の最後の係数であった場合には、プラスまたはマイナス1であった場合、ゼロ、1、及び2ならその絶対値が1を超えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the intuitive meaning of this measure changes as coefficients are decoded. For example, prior to the first token, a zero means that the neighbors are empty, suggesting that the current block may also be empty. After the first token, because an end-of-block token must have at least one non-zero value before it, a zero means that we just decoded a zero and hence guarantees that a non-zero coefficient will appear later in this block. However, this shift in meaning is perfectly okay because the complete context depends also on the coefficient band (and since band 0 is occupied exclusively by position 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
係数がデコードされているとして、この措置の直観的な意味が変わることに注意してください。例えば、前に最初のトークンに、ゼロは、現在のブロックは、空であってもよいことを示唆し、隣人が空であることを意味します。最初のトークンの後、エンド・オブ・ブロックトークンは、それ以前に少なくとも一つの非ゼロ値を持たなければならないので、ゼロは我々がちょうどゼロを復号し、したがって、非ゼロ係数は、このブロックの後半で表示されることを保証することを意味します。完全なコンテキストが、係数のバンドにも依存する（そしてバンド0以来、位置0で独占的に占有されている）しかし、の意味で、このシフトは完全に大丈夫です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with other contexts used by VP8, the &#34;neighboring block&#34; context described here needs a special definition for subblocks lying along the top row or left edge of the frame. These &#34;non-existent&#34; predictors above and to the left of the image are simply taken to be empty -- that is, taken to contain no non-zero coefficients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8によって使用される他の状況と同様に、ここで説明した「隣接ブロック」コンテキストは、一番上の行またはフレームの左端に沿って位置するサブブロックのために特別な定義を必要とします。上記画像の左側にこれらの「非存在」予測子は単に空であると解釈される - すなわち、NO非ゼロ係数を含まないために取られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The residue decoding of each macroblock then requires, in each of two directions (above and to the left), an aggregate coefficient predictor consisting of a single Y2 predictor, two predictors for each of U and V, and four predictors for Y. In accordance with the scan-ordering of macroblocks, a decoder needs to maintain a single &#34;left&#34; aggregate predictor and a row of &#34;above&#34; aggregate predictors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各マクロブロックの残差復号は、次によると二つの方向（左上とに）、単一Y2予測器からなる集合体係数予測、U及びVのそれぞれのための2つの予測子、およびYのための4つの予測子のそれぞれに、必要マクロブロックのスキャン順序と、デコーダは、単一の「左」集計予測及び「上」集計予測子の行を維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before decoding any residue, these maintained predictors may simply be cleared, in compliance with the definition of &#34;non-existent&#34; prediction. After each block is decoded, the two predictors referenced by the block are replaced with the (empty or non-empty) state of the block, in preparation for the later decoding of the blocks below and to the right of the block just decoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意の残留物をデコードする前に、これらの維持予測因子は、単に「存在しない」予測の定義に準拠して、クリアすることができます。各ブロックがデコードされた後、ブロックによって参照される2つの予測子は以下だけ復号化されたブロックの右側にあるブロックの後の復号の準備のために、ブロックの（空または空でない）状態で置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fourth, and final, dimension of the token probability array is of course indexed by (half) the position in the token tree structure, as are all tree probability arrays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのツリー確率アレイであるとしてトークン確率アレイの第四、及び最終的な寸法は、トークンツリー構造で（半）位置によってインデックス付けは勿論です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pseudocode below illustrates the decoding process. Note that criteria, functions, etc. delimited with ** are either dependent on decoder architecture or are elaborated on elsewhere in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の擬似コードは、復号プロセスを示します。等基準、機能は、デコーダのアーキテクチャに依存するか、この文書の他の場所で詳述されているのいずれかである**で区切られていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int block[16] = { 0 }; /* current 4x4 block coeffs */
   int firstCoeff = 0;
   int plane;
   int ctx2;
   int ctx3 = 0; /* the 3rd context referred to in above description */
   Prob *probTable;
   int token;
   int sign;
   int absValue;
   int extraBits;
   bool prevCoeffWasZero = false;
   bool currentBlockHasCoeffs = false;
   /* base coeff abs values per each category, elem #0 is
      DCT_VAL_CATEGORY1, * #1 is DCT_VAL_CATEGORY2, etc. */
   int categoryBase[6] = { 5, 7, 11, 19, 35, 67 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Determine plane to use */
   if ( **current_block_is_Y2_block** )       plane = 0;
   else if ( **current_block_is_chroma** )   plane = 2;
   else if ( **current_macroblock_has_Y2** ) plane = 1;
   else                                      plane = 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* For luma blocks of a &#34;Y2 macroblock&#34; we skip coeff index #0 */
   if ( plane == 1 )
       firstCoeff++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Determine whether neighbor 4x4 blocks have coefficients.
      This is dependent on the plane we are currently decoding;
      i.e., we check only coefficients from the same plane as the
      current block. */
   if ( **left_neighbor_block_has_coefficients(plane)** )
       ctx3++;
   if ( **above_neighbor_block_has_coefficients(plane)** )
       ctx3++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   for( i = firstCoeff; i &lt; 16; ++i )
   {
       ctx2 = coeff_bands[i];
       probTable = coeff_probs[plane][ctx2][ctx3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* skip first code (dct_eob) if previous token was DCT_0 */
       if ( prevCoeffWasZero )
           token = treed_read ( d, **coeff_tree_without_eob**,
             probTable );
       else
           token = treed_read ( d, coeff_tree, probTable );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( token == dct_eob ) break;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（トークン== dct_eob）ブレークであれば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if ( token != DCT_0 )
       {
           currentBlockHasCoeffs = true;
     if ( **token_has_extra_bits(token)** )
     {
         extraBits = DCTextra( token );
         absValue =
             categoryBase[**token_to_cat_index(token)**] +
       extraBits;
     }
     else
     {
         absValue = **token_to_abs_value(token)**;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     sign = read_bool(d, 128);
           block[i] = sign ? -absValue : absValue;
       }
       else
       {
           absValue = 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Set contexts and stuff for next coeff */
       if ( absValue == 0 )         ctx3 = 0;
       else if ( absValue == 1 )   ctx3 = 1;
       else                        ctx3 = 2;
       prevCoeffWasZero = true;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Store current block status to decoder internals */
   **block_has_coefficients[currentMb][currentBlock]** =
     currentBlockHasCoeffs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While we have in fact completely described the coefficient decoding procedure, the reader will probably find it helpful to consult the reference implementation, which can be found in the file tokens.c (Section 20.16).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは実際には完全に係数復号手順を説明しているが、読者はおそらく、それが参考にファイルtokens.c（セクション20.16）で見つけることができるリファレンス実装を、相談するでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. Token Probability Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4。トークン確率アップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, the token-decoding probabilities may change from frame to frame. After detection of a key frame, they are of course set to their defaults as shown in Section 13.5; this must occur before decoding the remainder of the header, as both key frames and interframes may adjust these probabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述したように、トークン復号確率は、フレームごとに変化してもよいです。 13.5項に示すように、キーフレームを検出した後、彼らはデフォルトに設定され、もちろんです。キーフレームおよびインターフレームの両方がこれらの確率を調整することができるように、これは、ヘッダの残りを復号する前に発生しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout and semantics of the coefficient probability update record (Section I of the frame header) are straightforward. For each position in the coeff_probs array there occurs a fixed-probability bool indicating whether or not the corresponding probability should be updated. If the bool is true, there follows a P(8) replacing that probability. Note that updates are cumulative; that is, a probability updated on one frame is in effect for all ensuing frames until the next key frame, or until the probability is explicitly updated by another frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
係数の確率更新記録（フレーム・ヘッダのセクションI）のレイアウト及びセマンティクスは簡単です。 coeff_probsアレイの各位置に対する対応する確率が更新されるべきか否かを示す固定確率BOOLが生じます。ブール値がtrueの場合、その確率を交換P（8）が続きます。アップデートは累積的であることに注意してください。それは確率が明示的に別のフレームによって更新されるまでの1つのフレームに更新確率は、次のキーフレームまで、すべての後続のフレームのために有効である、または、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm to effect the foregoing is simple:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記を達成するアルゴリズムは単純です：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int i = 0; do { int j = 0; do { int k = 0; do { int t = 0; do {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int型私= 0; {int型J = 0を実行します。 {= 0整数kを行います。 {INT、T = 0を行います。行う {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (read_bool(d, coeff_update_probs [i] [j] [k] [t]))
               coeff_probs [i] [j] [k] [t] = read_literal(d, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      } while (++t &lt; num_dct_tokens - 1);
     } while (++k &lt; 3);
    } while (++j &lt; 8);
   } while (++i &lt; 4);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (constant) update probabilities are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように（一定の）更新確率は、次のとおり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob coeff_update_probs [4] [8] [3] [num_dct_tokens-1] = { { { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255}, { 249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255}, { 234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255}, { 250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} } },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST度Probのcoeff_update_probs [4] [8] [3] [num_dct_tokens-1] = {{{{255、255、255、255、255、255、255、255、255、255、255}、{255、255、 255、255、255、255、255、255、255、255、255}、{255、255、255、255、255、255、255、255、255、255、255}}、{{176、246、 255、255、255、255、255、255、255、255、255}、{223、241、252、255、255、255、255、255、255、255、255}、{249、253、253、 255、255、255、255、255、255、255、255}}、{{255、244、252、255、255、255、255、255、255、255、255}、{234、254、254、 255、255、255、255、255、255、255、255}、{253、255、255、255、255、255、255、255、255、255、255}}、{{255、246、254、 255、255、255、255、255、255、255、255}、{239、253、254、255、255、255、255、255、255、255、255}、{254、255、254、255、 255、255、255、255、255、255、255}}、{{255、248、254、255、255、255、255、255、255、255、255}、{251、255、254、255、 255、255、255、255、255、255、255}、{255、255、255、255、255、255、255、255、255、255、255}}、{{255、253、254、255、 255、255、255、255、 255、255、255}、{251、254、254、255、255、255、255、255、255、255、255}、{254、255、254、255、255、255、255、255、255、 255、255}}、{{255、254、253、255、254、255、255、255、255、255、255}、{250、255、254、255、254、255、255、255、255、 255、255}、{254、255、255、255、255、255、255、255、255、255、255}}、{{255、255、255、255、255、255、255、255、255、 255、255}、{255、255、255、255、255、255、255、255、255、255、255}、{255、255、255、255、255、255、255、255、255、255、 255}}}、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
{ { { 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255}, { 234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255} }, { { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} } }, { { { 186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255}, { 234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255}, { 251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255} },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
{ { { 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255}, { 234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255} }, { { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} } }, { { { 186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255}, { 234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255}, { 251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255} },
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 { { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} } }, { { { 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255}, { 248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255} },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
{ { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} } }, { { { 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255}, { 248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255} },
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 { { 255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255}, { 248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} } } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ { 255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255}, { 248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255}, { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} }, { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255} } } };
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5. Default Token Probability Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5。デフォルトのトークン確率テーブル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default token probabilities are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにデフォルトのトークンの確率があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob default_coeff_probs [4] [8] [3] [num_dct_tokens - 1] = { { { { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}, { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}, { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128} }, { { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128}, { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128}, { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128} }, { { 1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128}, { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128}, { 78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128} }, { { 1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128}, { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128}, { 77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128} }, { { 1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128}, { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128}, { 37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128} }, { { 1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128}, { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128}, { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128} }, { { 1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128}, { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128}, { 80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128} },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コストの問題がdefault_coeff_probs [4] [8] [3] [num_dct_tokens  -  1] = {{{{128、128、128、128、128、128、128、128、128、128、128}、{128、128、 128、128、128、128、128、128、128、128、128}、{128、128、128、128、128、128、128、128、128、128、128}}、{{253、136、 254、255、228、219、128、128、128、128、128}、{189、129、242、255、227、213、255、219、128、128、128}、{106、126、227、 252、214、209、255、255、128、128、128}}、{{1、98、248、255、236、226、255、255、128、128、128}、{181、133、238、 254、221、234、255、154、128、128、128}、{78、134、202、247、198、180、255、219、128、128、128}}、{{1、185、249、 255、243、255、128、128、128、128、128}、{184、150、247、255、236、224、128、128、128、128、128}、{77、110、216、255、 236、230、128、128、128、128、128}}、{{1、101、251、255、241、255、128、128、128、128、128}、{170、139、241、252。 236、209、255、255、128、128、128}、{37、116、196、243、228、255、255、255、128、128、128}}、{{1、204、254、255、 245、255、128、128、128、128 128}、{207、160、250、255、238、128、128、128、128、128、128}、{102、103、231、255、211、171、128、128、128、128、128 }}、{{1、152、252、255、240、255、128、128、128、128、128}、{177、135、243、255、234、225、128、128、128、128、128 }、{80、129、211、255、194、224、128、128、128、128、128}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 { { 1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128} } }, { { { 198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62}, { 131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1}, { 68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128} }, { { 1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128}, { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128}, { 81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128} }, { { 1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128}, { 99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128}, { 23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128} }, { { 1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128}, { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128}, { 44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128} }, { { 1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128}, { 94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128}, { 22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128} }, { { 1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128}, { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128}, { 35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128} }, { { 1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128}, { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128}, { 45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128} }, { { 1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128}, { 203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128}, { 137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128} } },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
{ { 1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128} } }, { { { 198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62}, { 131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1}, { 68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128} }, { { 1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128}, { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128}, { 81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128} }, { { 1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128}, { 99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128}, { 23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128} }, { { 1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128}, { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128}, { 44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128} }, { { 1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128}, { 94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128}, { 22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128} }, { { 1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128}, { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128}, { 35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128} }, { { 1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128}, { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128}, { 45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128} }, { { 1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128}, { 203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128}, { 137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128} } },
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
{ { { 253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128}, { 175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128}, { 73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128} }, { { 1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128}, { 239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128}, { 155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128} }, { { 1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128}, { 201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128}, { 69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128} }, { { 1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128}, { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128}, { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128} }, { { 1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128}, { 190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128}, { 149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128} }, { { 1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128} }, { { 1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128}, { 213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128}, { 55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128} }, { { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}, { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}, { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128} } }, { { { 202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255}, { 126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128}, { 61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128} },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
{ { { 253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128}, { 175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128}, { 73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128} }, { { 1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128}, { 239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128}, { 155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128} }, { { 1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128}, { 201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128}, { 69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128} }, { { 1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128}, { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128}, { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128} }, { { 1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128}, { 190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128}, { 149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128} }, { { 1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128} }, { { 1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128}, { 213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128}, { 55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128} }, { { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}, { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}, { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128} } }, { { { 202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255}, { 126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128}, { 61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128} },
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 { { 1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128}, { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128}, { 39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128} }, { { 1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128}, { 124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128}, { 24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128} }, { { 1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128}, { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128}, { 28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128} }, { { 1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128}, { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128}, { 20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128} }, { { 1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128}, { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128}, { 47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128} }, { { 1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128}, { 141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128}, { 42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128} }, { { 1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128} } } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ { 1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128}, { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128}, { 39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128} }, { { 1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128}, { 124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128}, { 24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128} }, { { 1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128}, { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128}, { 28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128} }, { { 1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128}, { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128}, { 20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128} }, { { 1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128}, { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128}, { 47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128} }, { { 1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128}, { 141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128}, { 42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128} }, { { 1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128}, { 238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128} } } };
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. DCT and WHT Inversion and Macroblock Reconstruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. DCT及びWHT反転、マクロブロックの再構成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. Dequantization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1。逆量子化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After decoding the DCTs/WHTs as described above, each (quantized) coefficient in each subblock is multiplied by one of six dequantization factors, the choice of factor depending on the plane (Y2, Y, or chroma) and position (DC = coefficient zero, AC = any other coefficient). If the current macroblock has overridden the quantizer level (as described in Section 10), then the six factors are looked up from two dequantization tables with appropriate scaling and clamping using the single index supplied by the override. Otherwise, the frame-level dequantization factors (as described in Section 9.6) are used. In either case, the multiplies are computed and stored using 16-bit signed integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のようにのDCT / WHTsを復号した後、各サブブロック内の各（量子化）係数は、6つの逆量子化係数、平面（Y2、Y、またはクロマ）と位置に応じて係数の選択（DC =係数ゼロのいずれかによって乗算され、AC）は、任意の他の係数=。 （項10に記載のように）現在のマクロブロックが量子化レベルをオーバーライドしている場合、6つの要因は、オーバーライドにより供給される単一のインデックスを使用して、適切なスケーリング及びクランプを持つ2つの逆量子化テーブルからルックアップされます。そうでなければ、フレームレベルの逆量子化係数（セクション9.6に記載のように）使用されています。いずれの場合においても、乗算が16ビットの符号付き整数を使用して計算されて記憶されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two dequantization tables, which may also be found in the reference decoder file dequant_data.h (Section 20.3), are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように、基準デコーダファイルdequant_data.h（セクション20.3）に見出すことができる2つの逆量子化テーブルは、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const int dc_qlookup[QINDEX_RANGE] = { 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157, };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【QINDEX_RANGE] = {4、5、6、7、8、9、10、10、11、12、13、14、15、16、17、17、18、19、20、20、21 dc_qlookup静的のconst int型、21、22、22、23、23、24、25、25、26、27、28、29、30、31、32、33、34、35、36、37、37、38、39、40、41 、42、43、44、45、46、46、47、48、49、50、51、52、53、54、55、56、57、58、59、60、61、62、63、64、65 、66、67、68、69、70、71、72、73、74、75、76、76、77、78、79、80、81、82、83、84、85、86、87、88、89 、91、93、95、96、98、100、101、102、104、106、108、110、112、114、116、118、122、124、126、128、130、132、134、136、138 、140、143、145、148、151、154、157、}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const int ac_qlookup[QINDEX_RANGE] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284, };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【QINDEX_RANGE] = {4、5、6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、21、22、23、24 ac_qlookup静的のconst int型、25、26、27、28、29、30、31、32、33、34、35、36、37、38、39、40、41、42、43、44、45、46、47、48、49 、50、51、52、53、54、55、56、57、58、60、62、64、66、68、70、72、74、76、78、80、82、84、86、88、90 、92、94、96、98、100、102、104、106、108、110、112、114、116、119、122、125、128、131、134、137、140、143、146、149、152 、155、158、161、164、167、170、173、177、181、185、189、193、197、201、205、209、213、217、221、225、229、234、239、245、249 、254、259、264、269、274、279、284、}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lookup values from the above two tables are directly used in the DC and AC coefficients in Y1, respectively. For Y2 and chroma, values from the above tables undergo either scaling or clamping before the multiplies. Details regarding these scaling and clamping processes can be found in related lookup functions in dixie.c (Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記2つのテーブルのルックアップ値はそれぞれ直接、Y1におけるDC及びAC係数に使用されています。 Y2及び彩度のために、上記の表の値は、乗算の前にスケーリングまたはクランプのいずれかを受けます。これらのスケーリングと締め付けプロセスに関する詳細はdixie.c（20.4項）に関連するルックアップ機能で見つけることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Inverse Transforms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2。逆変換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Y2 residue block exists (i.e., the macroblock luma mode is not SPLITMV or B_PRED), it is inverted first (using the inverse WHT) and the element of the result at row i, column j is used as the 0th coefficient of the Y subblock at position (i, j), that is, the Y subblock whose index is (i * 4) + j. As discussed in Section 13, if the luma mode is B_PRED or SPLITMV, the 0th Y coefficients are part of the residue signal for the subblocks themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Y2残基のブロックが存在する場合、それは、行iにおける結果の要素（逆WHT使用して）最初に反転される（すなわち、マクロブロックのルミナンスモードがSPLITMV又はB_PREDない）、列jは、0番目の係数として使用されます位置（i、j）におけるYのサブブロック、すなわち、その指標である（iは4 *）+ J Yサブブロックです。輝度モードがB_PRED又はSPLITMVされている場合、セクション13で説明したように、0番目のY係数は、サブブロック自身のための残差信号の一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In either case, the inverse transforms for the sixteen Y subblocks and eight chroma subblocks are computed next. All 24 of these inversions are independent of each other; their results may (at least conceptually) be stored in 24 separate 4x4 arrays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれの場合においても、逆は16 Yサブブロックのための変換と8つのクロマ・サブブロックは、次の計算されます。これらの反転のすべての24は、互いに独立しています。それらの結果は、（少なくとも概念的には）24個の別々の4×4アレイに格納されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As is done by the reference decoder, an implementation may wish to represent the prediction and residue buffers as macroblock-sized arrays (that is, a 16x16 Y buffer and two 8x8 chroma buffers). Regarding the inverse DCT implementation given below, this requires a simple adjustment to the address calculation for the resulting residue pixels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基準デコーダによって行われているように、実装は（すなわち、16×16 Yバッファと2つの8×8クロマ・バッファである）マクロブロックサイズのアレイとして予測し、残渣バッファを表現することを望むかもしれません。以下に示す逆DCTの実装については、これは、得られた残渣ピクセルのためのアドレス計算の簡単な調整を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. Implementation of the WHT Inversion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3。 WHT反転の実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As previously discussed (see Sections 2 and 13), for macroblocks encoded using prediction modes other than B_PRED and SPLITMV, the DC values derived from the DCT transform on the 16 Y blocks are collected to construct a 25th block of a macroblock (16 Y, 4 U, 4 V constitute the 24 blocks). This 25th block is transformed using a Walsh-Hadamard transform (WHT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述したようB_PREDとSPLITMV以外の予測モードを用いて符号化マクロブロックについて、（セクション2及び13を参照）、16個のYブロックに対してDCT変換に由来するDC値は、マクロブロックの25ブロック（16 Yを構築するために収集され、 4 U、V 4は、24個のブロックを構成します）。この第25ブロックは、変換（WHT）のウォルシュ - アダマールを使用して変換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inputs to the inverse WHT (that is, the dequantized coefficients), the intermediate &#34;horizontally detransformed&#34; signal, and the completely detransformed residue signal are all stored as arrays of 16-bit signed integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆WHTへの入力（すなわち、逆量子化係数である）、中間「水平detransformed」信号、および完全detransformed残差信号は、すべての16ビット符号付き整数のアレイとして記憶されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following the tradition of specifying bitstream format using the decoding process, we specify the inverse WHT in the decoding process using the following C-style source code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
復号化プロセスを使用してビットストリーム形式を指定するの伝統に従い、我々は以下のCスタイルのソースコードを使用して復号処理において逆WHTを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void vp8_short_inv_walsh4x4_c(short *input, short *output)
   {
     int i;
     int a1, b1, c1, d1;
     int a2, b2, c2, d2;
     short *ip = input;
     short *op = output;
     int temp1, temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0] + ip[12];
       b1 = ip[4] + ip[8];
       c1 = ip[4] - ip[8];
       d1 = ip[0] - ip[12];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       op[0] = a1 + b1;
       op[4] = c1 + d1;
       op[8] = a1 - b1;
       op[12]= d1 - c1;
       ip++;
       op++;
     }
     ip = output;
     op = output;
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0] + ip[3];
       b1 = ip[1] + ip[2];
       c1 = ip[1] - ip[2];
       d1 = ip[0] - ip[3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       a2 = a1 + b1;
       b2 = c1 + d1;
       c2 = a1 - b1;
       d2 = d1 - c1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       op[0] = (a2+3)&gt;&gt;3;
       op[1] = (b2+3)&gt;&gt;3;
       op[2] = (c2+3)&gt;&gt;3;
       op[3] = (d2+3)&gt;&gt;3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ip+=4;
       op+=4;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that there is only one non-zero DC value in input, the inverse transform can be simplified to the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力で唯一の非ゼロDC値がある場合には、逆変換は、以下のように簡略化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void vp8_short_inv_walsh4x4_1_c(short *input, short *output)
   {
     int i;
     int a1;
     short *op=output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
a1 = ((input[0] + 3)&gt;&gt;3);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A1 =（（入力[0] + 2）&gt;&gt; 3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       op[0] = a1;
       op[1] = a1;
       op[2] = a1;
       op[3] = a1;
       op+=4;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that a conforming decoder should implement the inverse transform using exactly the same rounding to achieve bit-wise matching output to the output of the process specified by the above C source code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
準拠デコーダが上記Cソースコードで指定されたプロセスの出力にビット単位マッチング出力を達成するために、正確に同じ丸めを用いて逆変換を実装する必要があることに留意すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference decoder WHT inversion may be found in the file idct_add.c (Section 20.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基準デコーダWHT反転がファイルidct_add.c（セクション20.8）に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. Implementation of the DCT Inversion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4。 DCT反転の実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the DCT inversions are computed in exactly the same way. In principle, VP8 uses a classical 2-D inverse discrete cosine transform, implemented as two passes of 1-D inverse DCT. The 1-D inverse DCT was calculated using a similar algorithm to what was described in [Loeffler]. However, the paper only provided the 8-point and 16-point version of the algorithms, which was adapted by On2 to perform the 4-point 1-D DCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCT反転のすべてがまったく同じ方法で計算されています。原理的には、VP8は、1-D逆DCTの二つのパスとして実装され、古典的な2次元逆離散コサイン変換を使用します。 1-D逆DCTは、[レフラー]で説明したものと同様のアルゴリズムを用いて計算しました。しかし、紙は、4点1-D DCTを実行するためにはOn2により適合させたアルゴリズムの8点、16点バージョンを提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Accurate calculation of 1-D DCT of the above algorithm requires infinite precision. VP8 of course can use only a finite-precision approximation. Also, the inverse DCT used by VP8 takes care of normalization of the standard unitary transform; that is, every dequantized coefficient has roughly double the size of the corresponding unitary coefficient. However, at all but the highest datarates, the discrepancy between transmitted and ideal coefficients is due almost entirely to (lossy) compression and not to errors induced by finite-precision arithmetic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のアルゴリズムの1-D DCTの正確な計算は、無限の精度を必要とします。当然のVP8は、有限精度の近似を使用することができます。また、VP8で使用される逆DCTは標準ユニタリ変換の正規化の世話をします。つまり、すべての逆量子化係数は、対応する単一の係数の約2倍のサイズを有します。しかし、全てが、最も高いデータレートで送信され、理想係数間の不一致は、有限精度算術により誘導される誤差をほぼ完全に（非可逆）圧縮としないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inputs to the inverse DCT (that is, the dequantized coefficients), the intermediate &#34;horizontally detransformed&#34; signal, and the completely detransformed residue signal are all stored as arrays of 16-bit signed integers. The details of the computation are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆DCTへの入力（すなわち、逆量子化係数である）、中間「水平detransformed」信号、および完全detransformed残差信号は、すべての16ビット符号付き整数のアレイとして記憶されます。次のように計算の詳細です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should also be noted that this implementation makes use of the 16-bit fixed-point version of two multiplication constants:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、この実装では、2つの乗算定数の16ビット固定小数点バージョンを使用することに留意すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sqrt(2) * cos (pi/8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SQRT（2）* COS（PI / 8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sqrt(2) * sin (pi/8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SQRT（2）*罪（PI / 8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the first constant is bigger than 1, to maintain the same 16-bit fixed-point precision as the second one, we make use of the fact that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の定数は1より大きいので、第二のものと同じ16ビットの固定小数点精度を維持するために、我々は、という事実を利用します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
x * a = x + x*(a-1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X * A = X + X *（a-1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
therefore
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
故に
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
x * sqrt(2) * cos (pi/8) = x + x * (sqrt(2) * cos(pi/8)-1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X * SQRT（2）* COS（PI / 8）= X + X *（SQRT（2）* COS（PI / 8）-1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* IDCT implementation */
   static const int cospi8sqrt2minus1=20091;
   static const int sinpi8sqrt2      =35468;
   void short_idct4x4llm_c(short *input, short *output, int pitch)
   {
     int i;
     int a1, b1, c1, d1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     short *ip=input;
     short *op=output;
     int temp1, temp2;
     int shortpitch = pitch&gt;&gt;1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0]+ip[8];
       b1 = ip[0]-ip[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       temp1 = (ip[4] * sinpi8sqrt2)&gt;&gt;16;
       temp2 = ip[12]+((ip[12] * cospi8sqrt2minus1)&gt;&gt;16);
       c1 = temp1 - temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       temp1 = ip[4] + ((ip[4] * cospi8sqrt2minus1)&gt;&gt;16);
       temp2 = (ip[12] * sinpi8sqrt2)&gt;&gt;16;
       d1 = temp1 + temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       op[shortpitch*0] = a1+d1;
       op[shortpitch*3] = a1-d1;
       op[shortpitch*1] = b1+c1;
       op[shortpitch*2] = b1-c1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ip++;
       op++;
     }
     ip = output;
     op = output;
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0]+ip[2];
       b1 = ip[0]-ip[2];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       temp1 = (ip[1] * sinpi8sqrt2)&gt;&gt;16;
       temp2 = ip[3]+((ip[3] * cospi8sqrt2minus1)&gt;&gt;16);
       c1 = temp1 - temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
temp1 = ip[1] + ((ip[1] * cospi8sqrt2minus1)&gt;&gt;16);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
TEMP1 = IP [1] +（（IP [1] * cospi8sqrt2minus1）&gt;&gt; 16）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       temp2 = (ip[3] * sinpi8sqrt2)&gt;&gt;16;
       d1 = temp1 + temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       op[0] = (a1+d1+4)&gt;&gt;3;
       op[3] = (a1-d1+4)&gt;&gt;3;
       op[1] = (b1+c1+4)&gt;&gt;3;
       op[2] = (b1-c1+4)&gt;&gt;3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ip+=shortpitch;
       op+=shortpitch;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference decoder DCT inversion may be found in the file idct_add.c (Section 20.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基準デコーダDCT反転はファイルidct_add.c（セクション20.8）に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5. Summation of Predictor and Residue
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5。予測と残留の総和
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the prediction and residue signals are summed to form the reconstructed macroblock, which, except for loop filtering (taken up next), completes the decoding process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、予測及び残留信号は、復号処理を終了する（次取り）ループ・フィルタリングを除いて、再構成されたマクロブロックを形成するために合計されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The summing procedure is fairly straightforward, having only a couple of details. The prediction and residue buffers are both arrays of 16-bit signed integers. Each individual (Y, U, and V pixel) result is calculated first as a 32-bit sum of the prediction and residue, and is then saturated to 8-bit unsigned range (using, say, the clamp255 function defined above) before being stored as an 8-bit unsigned pixel value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加算手続きの詳細の唯一のカップルを持つ、非常に簡単です。予測と残留緩衝液は、16ビット符号付き整数の両方の配列です。各個々の（Y、U、及びV画素）結果は、予測、残渣の32ビットの和として最初に計算され、その後される前に8ビットの符号なしの範囲（たとえば、使用して、上記で定義されclamp255関数）に飽和しています8ビットの符号なしの画素値として記憶されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 also supports a mode where the encoding of a bitstream guarantees all reconstructed pixel values between 0 and 255; compliant bitstreams of such requirements have the clamp_type bit in the frame header set to 1. In such a case, the clamp255 function is no longer required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8はまた、ビットストリームの符号化は、0と255の間のすべての再構成画素値を保証するモードをサポートします。そのような要件の準拠のビットストリームは、このような場合には1に設定されたフレームのヘッダにclamp_typeビットを有する、clamp255機能はもはや必要とされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The summation process is the same, regardless of the (intra or inter) mode of prediction in effect for the macroblock. The reference decoder implementation of reconstruction may be found in the file idct_add.c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加算プロセスに関係なく、マクロブロックのために有効な予測（イントラまたはインター）モードの、同じです。再構成の基準デコーダの実装では、ファイルidct_add.cに見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Loop Filter
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.ループ・フィルタ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Loop filtering is the last stage of frame reconstruction and the next-to-last stage of the decoding process. The loop filter is applied to the entire frame after the summation of predictor and residue signals, as described in Section 14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ループフィルタは、フレーム再構成及び復号処理の次に、最終段の最終段です。項14に記載されているように、ループフィルタは、予測及び残留信号の加算後フレーム全体に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the loop filter is to eliminate (or at least reduce) visually objectionable artifacts associated with the semi-independence of the coding of macroblocks and their constituent subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ループフィルタの目的は、マクロブロックとその構成サブブロックの符号化の半独立に関連付けられた視覚的に不快なアーチファクトを除去（または、少なくとも低減）することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As was discussed in Section 5, the loop filter is &#34;integral&#34; to decoding, in that the results of loop filtering are used in the prediction of subsequent frames. Consequently, a functional decoder implementation must perform loop filtering exactly as described here. This is distinct from any postprocessing that may be applied only to the image immediately before display; such postprocessing is entirely at the option of the implementor (and/or user) and has no effect on decoding per se.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5で説明したようにループ・フィルタリングの結果は、後続のフレームの予測に使用されるという点で、ループフィルタは、復号化に「一体」です。したがって、機能的デコーダ・インプリメンテーションは、ここで説明するとおりにループ・フィルタリングを実行しなければなりません。これはすぐに表示前の画像にのみ適用することができる任意の後処理とは区別されます。そのような後処理は、実装のオプション（および/またはユーザ）に完全であり、それ自体が復号化に影響を及ぼしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The baseline frame-level parameters controlling the loop filter are defined in the frame header (Section 9.4) along with a mechanism for adjustment based on a macroblock&#39;s prediction mode and/or reference frame. The first is a flag (filter_type) selecting the type of filter (normal or simple); the other two are numbers (loop_filter_level and sharpness_level) that adjust the strength or sensitivity of the filter. As described in Sections 9.3 and 10, loop_filter_level may also be overridden on a per-macroblock basis using segmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ループフィルタを制御する基準フレーム・レベル・パラメータは、マクロブロックの予測モードおよび/または基準フレームに基づいて調整するための機構とともにフレームヘッダ（セクション9.4）で定義されています。最初のフラグ（FILTER_TYPE）（通常または単純な）フィルタの種類を選択することです。他の2つは強度やフィルタの感度を調整する数値（loop_filter_levelとsharpness_level）です。セクション9.3および10に記載されているように、loop_filter_levelもセグメンテーションを用いて毎マクロブロックに基づいて上書きされてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Loop filtering is one of the more computationally intensive aspects of VP8 decoding. This is the reason for the existence of the optional, less-demanding simple filter type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ループフィルタは、VP8復号のより計算集約的な側面の一つです。これはオプションで、あまり要求単純なフィルタタイプの存在理由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note carefully that loop filtering must be skipped entirely if loop_filter_level at either the frame header level or macroblock override level is 0. In no case should the loop filter be run with a value of 0; it should instead be skipped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
慎重にそのループ・フィルタリングは、フレーム・ヘッダ・レベルまたはマクロブロック・オーバーライド・レベルのいずれかでloop_filter_levelループフィルタは、0の値を使用して実行されるべきでない場合には0である場合、完全にスキップする必要があります。それは代わりにスキップする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We begin by discussing the aspects of loop filtering that are independent of the controlling parameters and type of filter chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、制御パラメータと選択されたフィルタのタイプとは無関係であるループフィルタの態様を議論することから始めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. Filter Geometry and Overall Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1。フィルターの形状と全体的な手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Y, U, and V planes are processed independently and identically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Y、U、及びVプレーンは、独立して同様に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The loop filter acts on the edges between adjacent macroblocks and on the edges between adjacent subblocks of a macroblock. All such edges are horizontal or vertical. For each pixel position on an edge, a small number (two or three) of pixels adjacent to either side of the position are examined and possibly modified. The displacements of these pixels are at a right angle to the edge orientation; that is, for a horizontal edge, we treat the pixels immediately above and below the edge position, and for a vertical edge, we treat the pixels immediately to the left and right of the edge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ループフィルタは、隣接するマクロブロック間のマクロブロックの隣接サブブロック間のエッジのエッジに作用します。すべてのそのようなエッジは、水平または垂直です。エッジ上の各画素位置について、位置のいずれかの側に隣接する画素の数が少ない（二、三）を調べ、おそらく修正されます。これらのピクセルの変位は、エッジ方向に対して直角です。すなわち、水平エッジのために、我々はすぐにエッジ位置の上および下のピクセルを扱う、であり、そして垂直エッジのために、我々はすぐにエッジの左右に画素を扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We call this collection of pixels associated to an edge position a segment; the length of a segment is 2, 4, 6, or 8. Excepting that the normal filter uses slightly different algorithms for, and either filter may apply different control parameters to, the edges between macroblocks and those between subblocks, the treatment of edges is quite uniform: All segments straddling an edge are treated identically; there is no distinction between the treatment of horizontal and vertical edges, whether between macroblocks or between subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、エッジ位置セグメントに関連する画素のこのコレクションを呼び出します。セグメントの長さは、通常のフィルタは、のためにわずかに異なるアルゴリズムを使用し、それ以外は2、4、6、または8であり、フィルタのいずれかには、マクロブロックとサブブロックの間に、それらの間のエッジは、エッジの処理が異なる制御パラメータを適用することができます極めて均一：エッジをまたぐすべてのセグメントが同じように処理されます。かどうかをマクロブロック間またはサブブロック間の水平及び垂直エッジの治療の間に区別はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a consequence, adjacent subblock edges within a macroblock may be concatenated and processed in their entirety. There is a single 8-pixel-long vertical edge horizontally centered in each of the U and V blocks (the concatenation of upper and lower 4-pixel edges between chroma subblocks), and three 16-pixel-long vertical edges at horizontal positions 1/4, 1/2, and 3/4 the width of the luma macroblock, each representing the concatenation of four 4-pixel sub-edges between pairs of Y subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その結果、マクロブロック内の隣接するサブブロックエッジは、その全体が連結され、処理されてもよいです。そこ水平U及びVブロック（クロマ・サブブロックの間に上下の4画素のエッジの連結）のそれぞれの中心に単一の8画素長い垂直エッジであり、水平方向の位置1における3つの16ピクセル長の垂直エッジ/ 4、1/2、3/4輝度マクロブロックの幅、Yのサブブロックの対の間の4つの4画素サブエッジの連結を表す各。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macroblocks comprising the frame are processed in the usual raster-scan order. Each macroblock is &#34;responsible for&#34; the inter-macroblock edges immediately above and to the left of it (but not the edges below and to the right of it), as well as the edges between its subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームを構成するマクロブロックは、通常のラスタスキャン順に処理されます。各マクロブロックはすぐ左側（ただし、それの真下とにエッジ）、ならびにそのサブブロック間のエッジ上との間のマクロブロックエッジ「の責任」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each macroblock M, there are four filtering steps, which are, (almost) in order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各マクロブロックmについて、順に4つのフィルタリングステップ、（ほとんど）があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If M is not on the leftmost column of macroblocks, filter across the left (vertical) inter-macroblock edge of M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Mは、マクロブロックの一番左の列にない場合は、左の両端のフィルタM.の（垂直）インターマクロブロックエッジ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Filter across the vertical subblock edges within M.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
M.内の垂直サブブロックのエッジを横切る2フィルタ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If M is not on the topmost row of macroblocks, filter across the top (horizontal) inter-macroblock edge of M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前記Mは、マクロブロックの最上行、上部のフィルタM.の（水平）インターマクロブロックのエッジ上にない場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Filter across the horizontal subblock edges within M.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
M.内の水平サブブロックのエッジを横切る4フィルタ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We write MY, MU, and MV for the planar constituents of M, that is, the 16x16 luma block, 8x8 U block, and 8x8 V block comprising M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、MY、MU、MV及びMの平面構成のために、すなわち、16×16輝度ブロック、8×8 Uブロック、および8×8 Vブロックは、Mを含む書きます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In step 1, for each of the three blocks MY, MU, and MV, we filter each of the (16 luma or 8 chroma) segments straddling the column separating the block from the block immediately to the left of it, using the inter-macroblock filter and controls associated to the loop_filter_level and sharpness_level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステップ1において、三つのブロックMY、MU、MVとのそれぞれについて、我々は相互を用いて、すぐ左側にブロックからブロックを分離カラムにまたがる（16ルーマまたはクロマ8）各セグメントをフィルタリングloop_filter_levelとsharpness_levelに関連するマクロブロック・フィルタとを制御します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In step 4, we filter across the (three luma and one each for U and V) vertical subblock edges described above, this time using the inter-subblock filter and controls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステップ4において、我々は（3つの輝度とUとVに対して1つずつ）を横切ってフィルタ垂直サブブロックエッジがインターサブブロックフィルタとコントロールを使用して、上記今回の説明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Steps 2 and 4 are skipped for macroblocks that satisfy both of the following two conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステップ2および4は、次の2つの条件の両方を満たすマクロブロックのためにスキップされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Macroblock coding mode is neither B_PRED nor SPLITMV; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.マクロブロック符号化モードはB_PREDもSPLITMVでもありません。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. There is no DCT coefficient coded for the whole macroblock.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.全体のマクロブロックのためにコード化された何のDCT係数はありません。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For these macroblocks, loop filtering for edges between subblocks internal to a macroblock is effectively skipped. This skip strategy significantly reduces VP8 loop-filtering complexity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのマクロブロックに対して、マクロブロックの内部サブブロック間のエッジのためのループ・フィルタリングは有効にスキップされます。このスキップ戦略は大幅にVP8ループ・フィルタの複雑さを軽減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Edges between macroblocks and those between subblocks are treated with different control parameters (and, in the case of the normal filter, with different algorithms). Except for pixel addressing, there is no distinction between the treatment of vertical and horizontal edges. Luma edges are always 16 pixels long, chroma edges are always 8 pixels long, and the segments straddling an edge are treated identically; this of course facilitates vector processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マクロブロックとサブブロックの間に、それらの間にエッジが（異なるアルゴリズムを用いて、通常のフィルタの場合、と）異なる制御パラメータを用いて処理されます。アドレッシング画素を除いて、垂直及び水平エッジの治療の間に区別はありません。輝度エッジが常に16個のピクセル長さ、彩度エッジが常に8つの画素の長さで、エッジをまたぐセグメントが同じように処理されます。もちろん、これはベクトル処理を容易にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because many pixels belong to segments straddling two or more edges, and so will be filtered more than once, the order in which edges are processed given above must be respected by any implementation. Within a single edge, however, the segments straddling that edge are disjoint, and the order in which these segments are processed is immaterial.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの画素が二つ以上のエッジをまたぐセグメントに属し、したがって複数回ろ過されるので、エッジは上記の処理される順序は、任意の実装によって尊重されなければなりません。単一のエッジ内に、しかし、そのエッジにまたがるセグメントがばらばらであり、これらのセグメントが処理される順序は重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before taking up the filtering algorithms themselves, we should emphasize a point already made: Even though the pixel segments associated to a macroblock are antecedent to the macroblock (that is, lie within the macroblock or in already-constructed macroblocks), a macroblock must not be filtered immediately after its &#34;reconstruction&#34; (described in Section 14). Rather, the loop filter applies after all the macroblocks have been &#34;reconstructed&#34; (i.e., had their predictor summed with their residue); correct decoding is predicated on the fact that already-constructed portions of the current frame referenced via intra-prediction (described in Section 12) are not yet filtered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
自身をフィルタリングアルゴリズムを巻き取る前に、我々は既になさ点を強調すべきである：マクロブロックに関連するピクセルセグメント（つまり、嘘マクロブロック内の又は既に構築されたマクロブロック内の）マクロブロックに先行されても、マクロブロックはいけません（項14に記載）の「再構成」の直後に濾過されます。全てのマクロブロックが「再構築」された後ではなく、ループ・フィルタが適用される（すなわち、その予測は、それらの残基と加算していました）。正しい復号が（項12に記載の）イントラ予測を介して参照される現在のフレームの既に構築された部分がまだフィルタリングされていないという事実に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. Simple Filter
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2。単純なフィルタ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Having described the overall procedure of, and pixels affected by, the loop filter, we turn our attention to the treatment of individual segments straddling edges. We begin by describing the simple filter, which, as the reader might guess, is somewhat simpler than the normal filter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全体的な手順を説明し、ループフィルタの影響を受けるピクセルは、我々はエッジをまたぐ個々のセグメントの治療に注意を向けるました。私たちは、読者が想像として、通常のフィルタよりもやや単純である、単純なフィルタを、記述することから始めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the simple filter only applies to luma edges. Chroma edges are left unfiltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単純なフィルタは、エッジのみをルマするために適用されることに注意してください。クロマのエッジがフィルタリングされていないままにされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Roughly speaking, the idea of loop filtering is, within limits, to reduce the difference between pixels straddling an edge. Differences in excess of a threshold (associated to the loop_filter_level) are assumed to be &#34;natural&#34; and are unmodified; differences below the threshold are assumed to be artifacts of quantization and the (partially) separate coding of blocks, and are reduced via the procedures described below. While the loop_filter_level is in principle arbitrary, the levels chosen by a VP8 compressor tend to be correlated to quantizer levels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大まかに言えば、ループ・フィルタリングのアイデアは、エッジを跨ぐ画素間の差を減少させるために、限度内です。 （loop_filter_levelに関連する）しきい値を超える差が「自然」であると仮定し、非修飾されています。閾値以下の差は、量子化及びブロックの（部分的に）別々の符号化のアーチファクトであると仮定され、そして以下に記載された手順を介して低減されます。 loop_filter_levelは原則的に任意であるが、VP8圧縮機によって選択されたレベルは、量子化レベルと相関する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of the filtering arithmetic is done using 8-bit signed operands (having a range of -128 to +127, inclusive), supplemented by 16-bit temporaries holding results of multiplies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィルタリング演算の大部分は、乗算の結果を保持する16ビットの一時によって補足8ビット符号付きオペランド（-128〜+127の範囲を有する、包括的）を使用して行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sums and other temporaries need to be &#34;clamped&#34; to a valid signed 8-bit range:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
和およびその他の一時は、有効な符号付き8ビットの範囲に「クランプ」する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int8 c(int v) { return (int8) (v &lt; -128 ? -128 : (v &lt; 128 ? v : 127)); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INT8と（INT C）{リサイクル比（INT8）（IN &lt;-128 -128（&lt;128で：127））; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since pixel values themselves are unsigned 8-bit numbers, we need to convert between signed and unsigned values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画素自体が符号なし8ビット数である値ので、我々は、符号付きおよび符号なしの値との間で変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Convert pixel value (0 &lt;= v &lt;= 255) to an 8-bit signed
      number. */
   int8 u2s(Pixel v) { return (int8) (v - 128);}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Clamp, then convert signed number back to pixel value. */
   Pixel s2u(int v) { return (Pixel) (c(v) + 128);}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Filtering is often predicated on absolute-value thresholds. The following function is the equivalent of the standard library function abs, whose prototype is found in the standard header file stdlib.h. For us, the argument v is always the difference between two pixels and lies in the range -255 &lt;= v &lt;= +255.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィルタリングは、多くの場合、絶対値のしきい値に基づいています。以下の関数はプロトタイプ標準ヘッダファイルstdlib.hに見出される標準ライブラリ関数ABS、のと等価です。私たちにとって、引数vは常に2つのピクセル間の差であると範囲-255 &lt;= V &lt;= 255です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int abs(int v) { return v &lt; 0? -v : v;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;0のintのABS（INT c）は{リサイクル比？ -in：}で
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An actual implementation would of course use inline functions or macros to accomplish these trivial procedures (which are used by both the normal and simple loop filters). An optimal implementation would probably express them in machine language, perhaps using single instruction, multiple data (SIMD) vector instructions. On many SIMD processors, the saturation accomplished by the above clamping function is often folded into the arithmetic instructions themselves, obviating the explicit step taken here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際の実装はもちろん、（正常および単純なループフィルタの両方で使用されている）、これらの些細な手順を達成するために、インライン関数またはマクロを使用します。最適な実装では、おそらく、おそらく、単一命令複数データ（SIMD）ベクトル命令を使用して、機械語でそれらを表現します。多くのSIMDプロセッサでは、上記クランプ機能によって達成飽和は、多くの場合、ここに取り込ま明示的なステップをなくす、算術命令自体に折り畳まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To simplify the specification of relative pixel positions, we use the word &#34;before&#34; to mean &#34;immediately above&#34; (for a vertical segment straddling a horizontal edge) or &#34;immediately to the left of&#34; (for a horizontal segment straddling a vertical edge), and the word &#34;after&#34; to mean &#34;immediately below&#34; or &#34;immediately to the right of&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（垂直方向のエッジを跨ぐ水平セグメントについて）（水平方向のエッジを跨ぐ垂直セグメントについて）「直上」または「即時の左に」を意味する「前」の相対画素位置の指定を簡略化するために、我々は、単語を使用「直下」または「すぐの右側にある」を意味する「後」、および単語。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given an edge, a segment, and a limit value, the simple loop filter computes a value based on the four pixels that straddle the edge (two either side). If that value is below a supplied limit, then, very roughly speaking, the two pixel values are brought closer to each other, &#34;shaving off&#34; something like a quarter of the difference. The same procedure is used for all segments straddling any type of edge, regardless of the nature (inter-macroblock, inter-subblock, luma, or chroma) of the edge; only the limit value depends on the edge type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エッジセグメント、および限界値を与え、単純なループフィルタは、エッジ（二両側）を跨ぐ4つの画素に基づいて値を計算します。その値が供給される限界以下である場合、次に、非常に大まかに言えば、2つの画素値の差分の四分の一のようなものを「削り取る」、互いに近接にもたらされます。同じ手順を、自然（インターマクロブロック、インターサブブロック、輝度、彩度又は）エッジのに関わらず、エッジの任意のタイプにまたがるすべてのセグメントのために使用されます。唯一の制限値は、エッジタイプに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact procedure (for a single segment) is as follows; the subroutine common_adjust is used by both the simple filter presented here and the normal filters discussed in Section 15.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように（単一セグメントのための）正確な手順です。サブルーチンcommon_adjustは、ここで紹介する単純なフィルタおよび15.3項で述べた通常のフィルタの両方で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int8 common_adjust(
       int use_outer_taps,   /* filter is 2 or 4 taps wide */
       const Pixel *P1,    /* pixel before P0 */
       Pixel *P0,          /* pixel before edge */
       Pixel *Q0,          /* pixel after edge */
       const Pixel *Q1     /* pixel after Q0 */
   ) {
       cint8 p1 = u2s(*P1);   /* retrieve and convert all 4 pixels */
       cint8 p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0);
       cint8 q1 = u2s(*Q1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Disregarding clamping, when &#34;use_outer_taps&#34; is false,
          &#34;a&#34; is 3*(q0-p0).  Since we are about to divide &#34;a&#34; by
          8, in this case we end up multiplying the edge
          difference by 5/8.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
When &#34;use_outer_taps&#34; is true (as for the simple filter), &#34;a&#34; is p1 - 3*p0 + 3*q0 - q1, which can be thought of as a refinement of 2*(q0 - p0), and the adjustment is something like (q0 - p0)/4. */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
2 *の改良と考えることができるQ1、 -  3 * P0 + 3 * Q0  - （Q0  -  P0）、および調整 &#34;use_outer_taps&#34; は（単純なフィルタのような）が真である場合、 &#34;&#34; P1であります（ -  P0、Q0）/ 4のようなものです。 * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int8 a = c((use_outer_taps? c(p1 - q1) : 0) + 3*(q0 - p0));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
INT8 = Cの（（use_outer_taps C（P1  -  Q1）：0）+ 3 *（Q0  -  P0））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* b is used to balance the rounding of a/8 in the case where
          the &#34;fractional&#34; part &#34;f&#34; of a/8 is exactly 1/2. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
cint8 b = (c(a + 3)) &gt;&gt; 3;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
cint8 B =（C（A + 3））&gt;&gt; 3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Divide a by 8, rounding up when f &gt;= 1/2.
          Although not strictly part of the C language,
          the right shift is assumed to propagate the sign bit. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
a = c(a + 4) &gt;&gt; 3;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
= Cの（A + 4）&gt;&gt; 3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Subtract &#34;a&#34; from q0, &#34;bringing it closer&#34; to p0. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*Q0 = s2u(q0 - a);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Q0 = S2U（Q0  -  A）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Add &#34;a&#34; (with adjustment &#34;b&#34;) to p0, &#34;bringing it closer&#34;
          to q0.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The clamp of &#34;a+b&#34;, while present in the reference decoder, is superfluous; we have -16 &lt;= a &lt;= 15 at this point. */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
基準デコーダに存在する一方、「A + B」のクランプは、不必要です。我々は-16 &lt;= A &lt;= 15この時点で。 * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*P0 = s2u(p0 + b);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* P0 = S2U（P0 + 1 B）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return a; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void simple_segment(
       uint8 edge_limit,   /* do nothing if edge difference
                              exceeds limit */
       const Pixel *P1,    /* pixel before P0 */
       Pixel *P0,          /* pixel before edge */
       Pixel *Q0,          /* pixel after edge */
       const Pixel *Q1     /* pixel after Q0 */
   ) {
       if ((abs(*P0 - *Q0)*2 + abs(*P1 - *Q1)/2) &lt;= edge_limit))
           common_adjust(1, P1, P0, Q0, Q1);   /* use outer taps */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We make a couple of remarks about the rounding procedure above. When b is zero (that is, when the &#34;fractional part&#34; of a is not 1/2), we are (except for clamping) adding the same number to p0 as we are subtracting from q0. This preserves the average value of p0 and q0, but the resulting difference between p0 and q0 is always even; in particular, the smallest non-zero gradation +-1 is not possible here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、上記の丸め手順についての発言のカップルになります。 bは（の「小数部分」は1/2でない場合には、である）がゼロである場合、我々はQ0から減算されるP0に同じ番号を追加する（クランプを除く）です。これは、P0とQ0の平均値を保持するが、P0とQ0の間に生じる差は常に偶数です。具体的には、最小の非ゼログラデーション+ -1は、ここではできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When b is one, the value we add to p0 (again except for clamping) is one less than the value we are subtracting from q0. In this case, the resulting difference is always odd (and the small gradation +-1 is possible), but the average value is reduced by 1/2, yielding, for instance, a very slight darkening in the luma plane. (In the very unlikely event of appreciable darkening after a large number of interframes, a compressor would of course eventually compensate for this in the selection of predictor and/or residue.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bが1である場合、我々は（再びクランプを除く）P0に加算値は、我々がQ0から減算された値よりも小さいものです。この場合には、得られた差が（可能である-1と小さい階調+）は常に奇数であるが、平均値は1/2に低減され、例えば、輝度平面において非常にわずかな暗色化をもたらします。 （インターフレームの多数後かなり暗色の非常に低い場合には、圧縮機はもちろん、最終的に予測および/または残基の選択でこれを補うことになります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The derivation of the edge_limit value used above, which depends on the loop_filter_level and sharpness_level, as well as the type of edge being processed, will be taken up after we describe the normal loop filtering algorithm below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は以下の通常ループ・フィルタリング・アルゴリズムを記述した後loop_filter_levelとsharpness_level、並びに処理されるエッジのタイプに依存する上で使用edge_limit値の導出は、取り込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3. Normal Filter
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3。通常のフィルター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The normal loop filter is a refinement of the simple loop filter; all of the general discussion above applies here as well. In particular, the functions c, u2s, s2u, abs, and common_adjust are used by both the normal and simple filters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常のループ・フィルタは、単純なループフィルタの改良です。上記の一般的な議論のすべてがここにも適用されます。具体的には、関数C、u2s、S2U、ABS、及びcommon_adjustは、通常、シンプルなフィルタの両方で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, the normal algorithms for inter-macroblock and inter-subblock edges differ. Nonetheless, they have a great deal in common: They use similar threshold algorithms to disable the filter and to detect high internal edge variance (which influences the filtering algorithm). Both algorithms also use, at least conditionally, the simple filter adjustment procedure described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述したように、インターマクロブロック及びインターサブブロックのエッジの通常のアルゴリズムが異なります。それにもかかわらず、それらは共通の多くを持っている：彼らは、フィルタを無効にするために、同様の閾値アルゴリズムを使用して（フィルタリングアルゴリズムに影響を与える）高い内部エッジ分散を検出します。両方のアルゴリズムはまた、少なくとも条件付きで、上述した単純なフィルタ調整手順を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The common thresholding algorithms are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように一般的なしきい値のアルゴリズムがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* All functions take (among other things) a segment (of length
      at most 4 + 4 = 8) symmetrically straddling an edge.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The pixel values (or pointers) are always given in order, from the &#34;beforemost&#34; to the &#34;aftermost&#34;. So, for a horizontal edge (written &#34;|&#34;), an 8-pixel segment would be ordered p3 p2 p1 p0 | q0 q1 q2 q3. */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
画素値（又はポインタ）は常に「aftermost」から「beforemost」から順に与えられます。したがって、水平方向のエッジに対して（書かれた「|」）、8画素セグメントは、P3、P2、P1、P0順序付けされることになります| Q0のQ1 Q2 Q3を。 * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Filtering is disabled if the difference between any two
      adjacent &#34;interior&#34; pixels in the 8-pixel segment exceeds
      the relevant threshold (I).  A more complex thresholding
      calculation is done for the group of four pixels that
      straddle the edge, in line with the calculation in
      simple_segment() above. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int filter_yes(
       uint8 I,        /* limit on interior differences */
       uint8 E,        /* limit at the edge */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       cint8 p3, cint8 p2, cint8 p1, cint8 p0, /* pixels before
                                                  edge */
       cint8 q0, cint8 q1, cint8 q2, cint8 q3  /* pixels after
                                                  edge */
   ) {
       return  (abs(p0 - q0)*2 + abs(p1 - q1)/2) &lt;= E
           &amp;&amp;  abs(p3 - p2) &lt;= I  &amp;&amp;  abs(p2 - p1) &lt;= I  &amp;&amp;
             abs(p1 - p0) &lt;= I
           &amp;&amp;  abs(q3 - q2) &lt;= I  &amp;&amp;  abs(q2 - q1) &lt;= I  &amp;&amp;
             abs(q1 - q0) &lt;= I;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Filtering is altered if (at least) one of the differences
      on either side of the edge exceeds a threshold (we have
      &#34;high edge variance&#34;). */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int hev(
       uint8 threshold,
       cint8 p1, cint8 p0, /* pixels before edge */
       cint8 q0, cint8 q1  /* pixels after edge */
   ) {
       return abs(p1 - p0) &gt; threshold  ||  abs(q1 - q0) &gt; threshold;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The subblock filter is a variant of the simple filter. In fact, if we have high edge variance, the adjustment is exactly as for the simple filter. Otherwise, the simple adjustment (without outer taps) is applied, and the two pixels one step in from the edge pixels are adjusted by roughly half the amount by which the two edge pixels are adjusted; since the edge adjustment here is essentially 3/8 the edge difference, the inner adjustment is approximately 3/16 the edge difference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブブロックフィルターは、単純なフィルタの変形です。私たちは、高いエッジ分散を持っている場合、実際には、調整が正確に、単純なフィルタのようです。そうでない場合、（外タップなし）簡単な調整が適用され、エッジ画素から1つのステップで二つの画素は、二つのエッジ画素が調整される約半分の量だけ調整されます。ここでエッジ調整は、本質的に3/8エッジの差であるので、内部調整が約3/16エッジ差です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void subblock_filter(
       uint8 hev_threshold,     /* detect high edge variance */
       uint8 interior_limit,    /* possibly disable filter */
       uint8 edge_limit,
       cint8 *P3, cint8 *P2, int8 *P1, int8 *P0,   /* pixels before
                                                      edge */
       int8 *Q0, int8 *Q1, cint8 *Q2, cint8 *Q3    /* pixels after
                                                      edge */
   ) {
       cint8 p3 = u2s(*P3), p2 = u2s(*P2), p1 = u2s(*P1),
         p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0), q1 = u2s(*Q1), q2 = u2s(*Q2),
         q3 = u2s(*Q3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (filter_yes(interior_limit, edge_limit, q3, q2, q1, q0,
         p0, p1, p2, p3))
       {
           const int hv = hev(hev_threshold, p1, p0, q0, q1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
cint8 a = (common_adjust(hv, P1, P0, Q0, Q1) + 1) &gt;&gt; 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
cint8 =（common_adjust（HV、P1、P0、Q0、Q1）+ 1）&gt;&gt; 1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (!hv) {
               *Q1 = s2u(q1 - a);
               *P1 = s2u(p1 + a);
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inter-macroblock filter has potentially wider scope. If the edge variance is high, it performs the simple adjustment (using the outer taps, just like the simple filter and the corresponding case of the normal subblock filter). If the edge variance is low, we begin with the same basic filter calculation and apply multiples of it to pixel pairs symmetric about the edge; the magnitude of adjustment decays as we move away from the edge and six of the pixels in the segment are affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターマクロブロックフィルタは、潜在的に、より広い範囲を有します。エッジ分散が高い場合、それは、（単純なフィルタと通常のサブブロックフィルタの対応する場合と同様に、外側のタップを使用して）簡単な調整を行います。エッジ分散が低い場合、我々は、同じ基本フィルタ演算で始まり、エッジ約画素対対称にそれの倍数を適用します。我々は、エッジから離れると、セグメントにおける画素の6が影響を受けるように調整の大きさが減衰します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void MBfilter(
       uint8 hev_threshold,     /* detect high edge variance */
       uint8 interior_limit,    /* possibly disable filter */
       uint8 edge_limit,
       cint8 *P3, int8 *P2, int8 *P1, int8 *P0,  /* pixels before
                                                    edge */
       int8 *Q0, int8 *Q1, int8 *Q2, cint8 *Q3   /* pixels after
                                                    edge */
   ) {
       cint8 p3 = u2s(*P3), p2 = u2s(*P2), p1 = u2s(*P1),
         p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0), q1 = u2s(*Q1), q2 = u2s(*Q2),
         q3 = u2s(*Q3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (filter_yes(interior_limit, edge_limit, q3, q2, q1, q0,
         p0, p1, p2, p3))
       {
           if (!hev(hev_threshold, p1, p0, q0, q1))
           {
               /* Same as the initial calculation in &#34;common_adjust&#34;,
                  w is something like twice the edge difference */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
const int8 w = c(c(p1 - q1) + 3*(q0 - p0));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
W = Cの（ -  Q1）+ 3 *（Q0  -  C（P1、P0））INT8 CONST。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* 9/64 is approximately 9/63 = 1/7, and 1&lt;&lt;7 = 128 =
                  2*64.  So this a, used to adjust the pixels adjacent
                  to the edge, is something like 3/7 the edge
                  difference. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
int8 a = c((27*w + 63) &gt;&gt; 7);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
INT8 = Cの（（27 * W + 63）&gt;&gt; 7）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
*Q0 = s2u(q0 - a); *P0 = s2u(p0 + a);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
* Q0 = S2U（Q0  -  A）。 * P0 = S2U（P0 + A）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* Next two are adjusted by 2/7 the edge difference */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
a = c((18*w + 63) &gt;&gt; 7);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
A = Cの（（18 * W + 63）&gt;&gt; 7）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
*Q1 = s2u(q1 - a); *P1 = s2u(p1 + a);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
* Q1 = S2U（Q1  -  A）。 * P1 = S2U（P1 + A）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* Last two are adjusted by 1/7 the edge difference */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
a = c((9*w + 63) &gt;&gt; 7);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
A = Cの（（9×W + 63）&gt;&gt; 7）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
*Q2 = s2u(q2 - a); *P2 = s2u(p2 + a);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
* Q2 = S2U（Q2  -  A）。 * P2 = S2U（P2 + A）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           } else                      /* if hev, do simple filter */
               common_adjust(1, P1, P0, Q0, Q1);   /* using outer
                                                       taps */
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4. Calculation of Control Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4。制御パラメータの計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We conclude the discussion of loop filtering by showing how the thresholds supplied to the procedures above are derived from the two control parameters sharpness_level (an unsigned 3-bit number having maximum value 7) and loop_filter_level (an unsigned 6-bit number having maximum value 63).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、しきい値は、上記二つの制御パラメータsharpness_levelとloop_filter_level（符号なしの3ビットの数が最大値7を有する）から誘導される手順に供給する方法を示すことによって、ループフィルタの説明を結論（符号なし6ビットの数が最大値63を有します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the sharpness_level is constant over the frame, individual macroblocks may override the loop_filter_level with one of four possibilities supplied in the frame header (as described in Section 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sharpness_levelフレームにわたって一定であるが、個々のマクロブロック（セクション10で説明したように）フレームヘッダ内に供給される4つの可能性をloop_filter_levelをオーバーライドすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the simple and normal filters disable filtering if a value derived from the four pixels that straddle the edge (2 either side) exceeds a threshold / limit value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エッジ（2両側）を跨ぐ4つの画素から得られた値が閾値/限界値を超えた場合、両方のシンプルかつ正常なフィルタは、フィルタ無効。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Luma and Chroma use the same inter-macroblock edge limit */
   uint8 mbedge_limit = ((loop_filter_level + 2) * 2) +
     interior_limit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Luma and Chroma use the same inter-subblock edge limit */
   uint8 sub_bedge_limit = (loop_filter_level * 2) + interior_limit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining thresholds are used only by the normal filters. The filter-disabling interior difference limit is the same for all edges (luma, chroma, inter-subblock, inter-macroblock) and is given by the following.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りのしきい値は唯一の通常のフィルタで使用されています。フィルタ無効内部差の上限は、すべてのエッジ（輝度、彩度、インターサブブロック、インターマクロブロック）についても同様であり、以下によって与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8 interior_limit = loop_filter_level;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UINT8 interior_limit = loop_filter_level。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   if (sharpness_level)
   {
       interior_limit  &gt;&gt;=  sharpness_level &gt; 4 ?  2 : 1;
       if (interior_limit &gt; 9 - sharpness_level)
           interior_limit = 9 - sharpness_level;
   }
   if (!interior_limit)
       interior_limit = 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, we give the derivation of the high edge-variance threshold, which is also the same for all edge types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、我々はまた、すべてのエッジタイプの同じ高エッジ分散閾値の導出を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8 hev_threshold = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UINT8 hev_threshold = 0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   if (we_are_decoding_akey_frame)   /* current frame is a key frame */
   {
       if (loop_filter_level &gt;= 40)
           hev_threshold = 2;
       else if (loop_filter_level &gt;= 15)
           hev_threshold = 1;
   }
   else                            /* current frame is an interframe */
   {
       if (loop_filter_level &gt;= 40)
           hev_threshold = 3;
       else if (loop_filter_level &gt;= 20)
           hev_threshold = 2;
       else if (loop_filter_level &gt;= 15)
           hev_threshold = 1;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Interframe Macroblock Prediction Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.インターマクロブロック予測レコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We describe the layout and semantics of the prediction records for macroblocks in an interframe.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、インターのマクロブロックの予測レコードのレイアウトと意味を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the feature specification (which is described in Section 10 and is identical for intraframes and interframes), there comes a Bool(prob_intra), which indicates inter-prediction (i.e., prediction from prior frames) when true and intra-prediction (i.e., prediction from already-coded portions of the current frame) when false. The zero-probability prob_intra is set by field J of the frame header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（項10に記載のイントラフレームおよびインターフレームについて同一である）機能指定した後、インター予測を示すブール（prob_intra）を、そこに来る（すなわち、前のフレームからの予測）、即ち真とイントラ予測（、場合、現在のフレームの既に符号化された部分）から予測偽。ゼロ確率prob_intraは、フレームヘッダのフィールドJによって設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. Intra-Predicted Macroblocks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1。イントラ予測マクロブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For intra-prediction, the layout of the prediction data is essentially the same as the layout for key frames, although the contexts used by the decoding process are slightly different.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
復号化プロセスで使用されるコンテキストがわずかに異なるが、イントラ予測のために、予測データのレイアウトは、本質的にキーフレームのレイアウトと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in Section 8, the &#34;outer&#34; Y mode here uses a different tree from that used in key frames, repeated here for convenience.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション8で説明したように、ここで「外側」Yモードは、便宜上、ここでは繰り返さキーフレームに使用されるものとは異なるツリーを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index ymode_tree [2 * (num_ymodes - 1)] =
   {
    -DC_PRED, 2,           /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -V_PRED, -H_PRED,    /* &#34;10&#34; subtree:  V_PRED = &#34;100&#34;,
                              H_PRED = &#34;101&#34; */
      -TM_PRED, -B_PRED    /* &#34;11&#34; subtree:  TM_PRED = &#34;110&#34;,
                              B_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability table used to decode this tree is variable. As described in Section 11, it (along with the similarly treated UV table) can be updated by field J of the frame header. Similar to the coefficient-decoding probabilities, such updates are cumulative and affect all ensuing frames until the next key frame or explicit update. The default probabilities for the Y and UV tables are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このツリーを復号化するために使用される確率テーブルは変数です。セクション11で説明したように、（同様に処理UVテーブルとともに）、それは、フレームヘッダのフィールドJによって更新することができます。係数復号確率と同様に、そのような更新は累積的であり、次のキーフレームまたは明示的な更新まで、すべての後続のフレームに影響を与えます。 YおよびUV表のデフォルトの確率は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Prob ymode_prob [num_ymodes - 1] = { 112, 86, 140, 37};
   Prob uv_mode_prob [num_uv_modes - 1] = { 162, 101, 204};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These defaults must be restored after detection of a key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのデフォルトは、キーフレームの検出後に復元する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Just as for key frames, if the Y mode is B_PRED, there next comes an encoding of the intra_bpred mode used by each of the sixteen Y subblocks. These encodings use the same tree as does that for key frames but, in place of the contexts used in key frames, these encodings use the single fixed probability table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
YモードがB_PREDされている場合だけ、キーフレームのように、次の16 Yのサブブロックのそれぞれが使用するintra_bpredモードのエンコーディングが付属しています。 、キーフレームのためではなく、キーフレームで使用されるコンテキストの代わりに、これらのエンコーディングは、単一の固定確率テーブルを使用することを同じようにこれらのエンコーディングは同じ木を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob bmode_prob [num_intra_bmodes - 1] = { 120, 90, 79, 133, 87, 85, 80, 111, 151 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コスト問題bmode_prob [num_intra_bmodes  -  1] = {120、90、79、133、87、85、80、111、151}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Last comes the chroma mode, again coded using the same tree as that used for key frames, this time using the dynamic uv_mode_prob table described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に再度上記動的uv_mode_probテーブルを使用して、キーフレームに使用されるものとして、この時間は同じ木を用いて符号化されたクロマモードは、来ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The calculation of the intra-prediction buffer is identical to that described for key frames in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イントラ予測バッファの演算部12でのキーフレームのために記載したものと同一です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. Inter-Predicted Macroblocks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2。インター予測マクロブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise (when the above bool is true), we are using inter-prediction (which of course only happens for interframes), to which we now restrict our attention.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（上記のブール値がtrueの場合）そうでなければ、我々は今、我々の注意を制限している、（もちろん唯一のインターフレームのために起こる）インター予測を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next datum is then another bool, B(prob_last), selecting the reference frame. If 0, the reference frame is the previous frame (the last frame); if 1, another bool (prob_gf) selects the reference frame between the golden frame (0) and the altref frame (1). The probabilities prob_last and prob_gf are set in field J of the frame header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のデータは、基準フレームを選択する別のBOOL、B（prob_last）、です。 0の場合、基準フレームは、前のフレーム（最終フレーム）です。 1ならば、別のBOOL（prob_gf）が金色のフレーム（0）とaltrefフレーム（1）との間の参照フレームを選択します。確率prob_lastとprob_gfは、フレームヘッダのフィールドJに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Together with setting the reference frame, the purpose of inter-mode decoding is to set a motion vector for each of the sixteen Y subblocks of the current macroblock. These settings then define the calculation of the inter-prediction buffer (detailed in Section 18). While the net effect of inter-mode decoding is straightforward, the implementation is somewhat complex; the (lossless) compression achieved by this method justifies the complexity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
併せて参照フレームを設定して、インターモード復号の目的は、現在のマクロブロックの16 Yのサブブロックのそれぞれに対する動きベクトルを設定することです。これらの設定は、次に、（セクション18で詳述）インター予測バッファの計算を定義します。インターモード復号の正味の効果は簡単であるが、実装はやや複雑です。この方法によって達成さ（ロスレス）圧縮は、複雑さを正当化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the reference frame selector comes the mode (or motion vector reference) applied to the macroblock as a whole, coded using the following enumeration and tree. Setting mv_nearest = num_ymodes is a convenience that allows a single variable to unambiguously hold an inter- or intra-prediction mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照フレーム選択後のモード（又は動きベクトル参照）は、以下の列挙木を用いて符号化され、全体としてマクロブロックに適用されています。 mv_nearest =のnum_ymodesを設定すると、単一の変数が明確インター又はイントラ予測モードを保持することができ便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef enum
   {
       mv_nearest = num_ymodes, /* use &#34;nearest&#34; motion vector
                                   for entire MB */
       mv_near,                 /* use &#34;next nearest&#34; &#34;&#34; */
       mv_zero,                 /* use zero &#34;&#34; */
       mv_new,                  /* use explicit offset from
                                   implicit &#34;&#34; */
       mv_split,                /* use multiple motion vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 num_mv_refs = mv_split + 1 - mv_nearest } mv_ref;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
num_mv_refs = mv_split + 1  -  mv_nearest} MV_REF。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index mv_ref_tree [2 * (num_mv_refs - 1)] =
   {
    -mv_zero, 2,                /* zero = &#34;0&#34; */
     -mv_nearest, 4,            /* nearest = &#34;10&#34; */
      -mv_near, 6,              /* near = &#34;110&#34; */
        -mv_new, -mv_split      /* new = &#34;1110&#34;, split = &#34;1111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3. Mode and Motion Vector Contexts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3。モードと動きベクトルコンテキスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability table used to decode the mv_ref, along with three reference motion vectors used by the selected mode, is calculated via a survey of the already-decoded motion vectors in (up to) 3 nearby macroblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MV_REFを復号するために用いられる確率テーブルは、選択されたモードで使用される3つの基準動きベクトルと一緒に、3個の近くのマクロブロック（最大）で既に復号された動きベクトルの調査を介して計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm generates a sorted list of distinct motion vectors adjacent to the search site. The best_mv is the vector with the highest score. The mv_nearest is the non-zero vector with the highest score. The mv_near is the non-zero vector with the next highest score. The number of motion vectors coded using the SPLITMV mode is scored using the same weighting and is returned with the scores of the best, nearest, and near vectors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、検索サイトに隣接した個別の動きベクトルのソートされたリストを生成します。 best_mvは、最高得点を持つベクトルです。 mv_nearestはスコアが最も高い非ゼロベクトルです。 mv_nearは、次のスコアが最も高い非ゼロベクトルです。 SPLITMVモードを使用して符号化された動きベクトルの数が同じ重み付けを用いて獲得され、最高のスコアを、最も近い、近ベクターで返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The three adjacent macroblocks above, left, and above-left are considered in order. If the macroblock is intra-coded, no action is taken. Otherwise, the motion vector is compared to other previously found motion vectors to determine if it has been seen before, and if so contributes its weight to that vector; otherwise, it enters a new vector in the list. The above and left vectors have twice the weight of the above-left vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3個の隣接するマクロブロックが上、左、上、左ために考慮されます。マクロブロックがイントラ符号化されている場合は、何も起こりません。そうでない場合、動きベクトルは、前に見られているかどうかを決定するために、他の以前に見出された動きベクトルと比較され、その結果、ベクターへのその重量に寄与する場合、それ以外の場合は、リストに新しいベクトルを入力します。上記と左ベクトルは、上記左のベクトルの倍の重さを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As is the case with many contexts used by VP8, it is possible for macroblocks near the top or left edges of the image to reference blocks that are outside the visible image. VP8 provides a border of 1 macroblock filled with 0x0 motion vectors left of the left edge, and a border filled with 0,0 motion vectors of 1 macroblocks above the top edge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8で使用される多くの状況と同様に、画像の上または左のエッジの近くのマクロブロックが可視画像の外側にあるブロックを参照することが可能です。 VP8は、左端の左0x0の動きベクトルを充填した1個のマクロブロックの境界を提供し、境界は上端上記1個のマクロブロックの0,0動きベクトルを充填しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Much of the process is more easily described in C than in English. The reference code for this can be found in modemv.c (Section 20.11). The calculation of reference vectors, probability table, and, finally, the inter-prediction mode itself is implemented as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロセスの多くは、より簡単に英語に比べてCで記述されています。このための参照コードはmodemv.c（セクション20.11）に見出すことができます。参照ベクトル、確率テーブル、および、次のように最後に、インター予測モード自体が実装されているの計算。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef union
   {
       unsigned int as_int;
       MV           as_mv;
   } int_mv;        /* facilitates rapid equality tests */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void mv_bias(MODE_INFO *x,int refframe, int_mv *mvp,
     int * ref_frame_sign_bias)
   {
       MV xmv;
       xmv = x-&gt;mbmi.mv.as_mv;
       if ( ref_frame_sign_bias[x-&gt;mbmi.ref_frame] !=
         ref_frame_sign_bias[refframe] )
       {
           xmv.row*=-1;
           xmv.col*=-1;
       }
       mvp-&gt;as_mv = xmv;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void vp8_clamp_mv(MV *mv, const MACROBLOCKD *xd)
   {
       if ( mv-&gt;col &lt; (xd-&gt;mb_to_left_edge - LEFT_TOP_MARGIN) )
           mv-&gt;col = xd-&gt;mb_to_left_edge - LEFT_TOP_MARGIN;
       else if ( mv-&gt;col &gt; xd-&gt;mb_to_right_edge + RIGHT_BOTTOM_MARGIN )
           mv-&gt;col = xd-&gt;mb_to_right_edge + RIGHT_BOTTOM_MARGIN;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if ( mv-&gt;row &lt; (xd-&gt;mb_to_top_edge - LEFT_TOP_MARGIN) )
           mv-&gt;row = xd-&gt;mb_to_top_edge - LEFT_TOP_MARGIN;
       else if ( mv-&gt;row &gt; xd-&gt;mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN )
           mv-&gt;row = xd-&gt;mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the function vp8_find_near_mvs(), the vectors &#34;nearest&#34; and &#34;near&#34; are used by the corresponding modes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数vp8_find_near_mvs（）において、ベクターは、「最も近い」と「周辺」は、対応するモードで使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The vector best_mv is used as a base for explicitly coded motion vectors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベクターbest_mvは、明示的コード化された動きベクトルのためのベースとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first three entries in the return value cnt are (in order) weighted census values for &#34;zero&#34;, &#34;nearest&#34;, and &#34;near&#34; vectors. The final value indicates the extent to which SPLITMV was used by the neighboring macroblocks. The largest possible &#34;weight&#34; value in each case is 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
戻り値CNTの最初の3つのエントリは、（順番に）重み付けされたセンサス「ゼロ」の値、「最も近い」、および「近い」ベクトルです。最終的な値はSPLITMVは、隣接するマクロブロックによって使用された程度を示しています。各場合において可能な最大の「重み」値は5です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_find_near_mvs ( MACROBLOCKD *xd, const MODE_INFO *here, MV *nearest, MV *near, MV *best_mv, int cnt[4], int refframe, int * ref_frame_sign_bias )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_find_near_mvs（MACROBLOCKD *のXD、CONST MODE_INFO *ここでは、MV *最寄りの、MV *近く、MV * best_mv、int型CNT [4]、int型のrefframe、INT * ref_frame_sign_bias）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   {
       const MODE_INFO *above = here - xd-&gt;mode_info_stride;
       const MODE_INFO *left = here - 1;
       const MODE_INFO *aboveleft = above - 1;
       int_mv            near_mvs[4];
       int_mv           *mv = near_mvs;
       int             *cntx = cnt;
       enum {CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Zero accumulators */
       mv[0].as_int = mv[1].as_int = mv[2].as_int = 0;
       cnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Process above */
       if (above-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (above-&gt;mbmi.mv.as_int) {
               (++mv)-&gt;as_int = above-&gt;mbmi.mv.as_int;
               mv_bias(above, refframe, mv, ref_frame_sign_bias);
               ++cntx;
           }
           *cntx += 2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Process left */
       if (left-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (left-&gt;mbmi.mv.as_int) {
               int_mv this_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               this_mv.as_int = left-&gt;mbmi.mv.as_int;
               mv_bias(left, refframe, &amp;this_mv, ref_frame_sign_bias);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (this_mv.as_int != mv-&gt;as_int) {
                   (++mv)-&gt;as_int = this_mv.as_int;
                   ++cntx;
               }
               *cntx += 2;
           } else
               cnt[CNT_ZERO] += 2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Process above left */
       if (aboveleft-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (aboveleft-&gt;mbmi.mv.as_int) {
               int_mv this_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               this_mv.as_int = aboveleft-&gt;mbmi.mv.as_int;
               mv_bias(aboveleft, refframe, &amp;this_mv,
                 ref_frame_sign_bias);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (this_mv.as_int != mv-&gt;as_int) {
                   (++mv)-&gt;as_int = this_mv.as_int;
                   ++cntx;
               }
               *cntx += 1;
           } else
               cnt[CNT_ZERO] += 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* If we have three distinct MVs ... */
       if (cnt[CNT_SPLITMV]) {
           /* See if above-left MV can be merged with NEAREST */
           if (mv-&gt;as_int == near_mvs[CNT_NEAREST].as_int)
               cnt[CNT_NEAREST] += 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
cnt[CNT_SPLITMV] = ((above-&gt;mbmi.mode == SPLITMV) + (left-&gt;mbmi.mode == SPLITMV)) * 2 + (aboveleft-&gt;mbmi.mode == SPLITMV);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CNT [CNT_SPLITMV] =（（上述&gt; mbmi.mode == SPLITMV）+（左&gt; mbmi.mode == SPLITMV））* 2 +（aboveleft-&gt; mbmi.mode == SPLITMV）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Swap near and nearest if necessary */
       if (cnt[CNT_NEAR] &gt; cnt[CNT_NEAREST]) {
           int tmp;
           tmp = cnt[CNT_NEAREST];
           cnt[CNT_NEAREST] = cnt[CNT_NEAR];
           cnt[CNT_NEAR] = tmp;
           tmp = near_mvs[CNT_NEAREST].as_int;
           near_mvs[CNT_NEAREST].as_int = near_mvs[CNT_NEAR].as_int;
           near_mvs[CNT_NEAR].as_int = tmp;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Use near_mvs[0] to store the &#34;best&#34; MV */
       if (cnt[CNT_NEAREST] &gt;= cnt[CNT_ZERO])
           near_mvs[CNT_ZERO] = near_mvs[CNT_NEAREST];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Set up return values */
       *best_mv = near_mvs[0].as_mv;
       *nearest = near_mvs[CNT_NEAREST].as_mv;
       *near = near_mvs[CNT_NEAR].as_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       vp8_clamp_mv(nearest, xd);
       vp8_clamp_mv(near, xd);
       vp8_clamp_mv(best_mv, xd); //TODO: Move this up before
                                    the copy
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mv_ref probability table (mv_ref_p) is then derived from the census as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにMV_REF確率テーブル（mv_ref_p）を、国勢調査から誘導されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const int vp8_mode_contexts[6][4] = { { 7, 1, 1, 143, }, { 14, 18, 14, 107, }, { 135, 64, 57, 68, }, { 60, 56, 128, 65, }, { 159, 134, 128, 34, }, { 234, 188, 128, 28, }, }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST INT vp8_mode_contexts [6] [4] = {{7、1、1、143}、{14、18、14、107}、{135、64、57、68}、{60、56、128 、65}、{159、134、128、34、}、{234、188、128、28、}、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   vp8_prob *vp8_mv_ref_probs(vp8_prob mv_ref_p[VP8_MVREFS-1],
     int cnt[4])
   {
       mv_ref_p[0] = vp8_mode_contexts [cnt[0]] [0];
       mv_ref_p[1] = vp8_mode_contexts [cnt[1]] [1];
       mv_ref_p[2] = vp8_mode_contexts [cnt[2]] [2];
       mv_ref_p[3] = vp8_mode_contexts [cnt[3]] [3];
       return p;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once mv_ref_p is established, the mv_ref is decoded as usual.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mv_ref_pが確立されると、MV_REFはいつものようにデコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
mvr = (mv_ref) treed_read(d, mv_ref_tree, mv_ref_p);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
MVR =（MV_REF）treed_read（D、mv_ref_tree、mv_ref_p）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the first four inter-coding modes, the same motion vector is used for all the Y subblocks. The first three modes use an implicit motion vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の4つのインター符号化モードのために、同一の動きベクトルは、すべてのYのサブブロックのために使用されます。最初の3つのモードが暗黙の動きベクトルを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------+------------------------------------------------------+
   | Mode       | Instruction                                          |
   +------------+------------------------------------------------------+
   | mv_nearest | Use the nearest vector returned by                   |
   |            | vp8_find_near_mvs.                                   |
   |            |                                                      |
   | mv_near    | Use the near vector returned by vp8_find_near_mvs.   |
   |            |                                                      |
   | mv_zero    | Use a zero vector; that is, predict the current      |
   |            | macroblock from the corresponding macroblock in the  |
   |            | prediction frame.                                    |
   |            |                                                      |
   | NEWMV      | This mode is followed by an explicitly coded motion  |
   |            | vector (the format of which is described in the next |
   |            | section) that is added (component-wise) to the       |
   |            | best_mv reference vector returned by find_near_mvs   |
   |            | and applied to all 16 subblocks.                     |
   +------------+------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4. Split Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4。スプリット予測
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining mode (SPLITMV) causes multiple vectors to be applied to the Y subblocks. It is immediately followed by a partition specification that determines how many vectors will be specified and how they will be assigned to the subblocks. The possible partitions, with indicated subdivisions and coding tree, are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りのモード（SPLITMV）は、複数のベクトルがYのサブブロックに適用させます。それはすぐに指定され、それらがどのようにサブブロックに割り当てられますどのように多くのベクトルを決定するパーティションの指定が続いています。次のように示されている細分化し、コーディングツリーで可能なパーティションは、あります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef enum
   {
       mv_top_bottom,   /* two pieces {0...7} and {8...15} */
       mv_left_right,   /* {0,1,4,5,8,9,12,13} and
                           {2,3,6,7,10,11,14,15} */
       mv_quarters,    /* {0,1,4,5}, {2,3,6,7}, {8,9,12,13},
                          {10,11,14,15} */
       MV_16,          /* every subblock gets its own vector
                          {0} ... {15} */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 mv_num_partitions } MVpartition;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mv_num_partitions} MVpartition。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index mvpartition_tree [2 * (mvnum_partition - 1)] =
   {
    -MV_16, 2,                         /* MV_16 = &#34;0&#34; */
     -mv_quarters, 4,                  /* mv_quarters = &#34;10&#34; */
      -mv_top_bottom, -mv_left_right   /* top_bottom = &#34;110&#34;,
                                          left_right = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The partition is decoded using a fixed, constant probability table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パーティションは、固定、一定の確率テーブルを用いて復号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const Prob mvpartition_probs [mvnum_partition - 1] =
     { 110, 111, 150};
   part = (MVpartition) treed_read(d, mvpartition_tree,
     mvpartition_probs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the partition come two (for mv_top_bottom or mv_left_right), four (for mv_quarters), or sixteen (for MV_16) subblock inter-prediction modes. These modes occur in the order indicated by the partition layouts (given as comments to the MVpartition enum) and are coded as follows. (As was done for the macroblock-level modes, we offset the mode enumeration so that a single variable may unambiguously hold either an intra- or inter-subblock mode.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パーティションの後のサブブロックインター予測モード（MV_16用）（mv_quarters用）（mv_top_bottomまたはmv_left_right用）2つ、4つ、または16を来ります。これらのモードは（MVpartition列挙にコメントとして与えられた）パーティションレイアウトによって示される順序で発生し、次のように符号化されます。 （マクロブロックレベルモードに対して行ったように単一の変数が明確にイントラまたはインターサブブロックモードのいずれかを保持することができるように、我々は、モード列挙を相殺しました。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prior to decoding each subblock, a decoding tree context is chosen as illustrated in the code snippet below. The context is based on the immediate left and above subblock neighbors, and whether they are equal, are zero, or a combination of those.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のコードスニペットに示すように、各サブブロックを復号化する前に、復号化ツリーのコンテキストが選択されます。コンテキストは、すぐ左に及びサブブロック近隣の上方基づき、それらは、同じであるゼロ、またはそれらの組み合わせであるかどうかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef enum
   {
       LEFT4x4 = num_intra_bmodes,   /* use already-coded MV to
                                        my left */
       ABOVE4x4,             /* use already-coded MV above me */
       ZERO4x4,              /* use zero MV */
       NEW4x4,               /* explicit offset from &#34;best&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       num_sub_mv_ref
   };
   sub_mv_ref;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index sub_mv_ref_tree [2 * (num_sub_mv_ref - 1)] =
   {
    -LEFT4X4, 2,           /* LEFT = &#34;0&#34; */
     -ABOVE4X4, 4,         /* ABOVE = &#34;10&#34; */
      -ZERO4X4, -NEW4X4    /* ZERO = &#34;110&#34;, NEW = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Choose correct decoding tree context
    * Function parameters are left subblock neighbor MV and above
    * subblock neighbor MV */
   int vp8_mvCont(MV *l, MV*a)
   {
       int lez = (l-&gt;row == 0 &amp;&amp; l-&gt;col == 0);   /* left neighbor
                                                    is zero */
       int aez = (a-&gt;row == 0 &amp;&amp; a-&gt;col == 0);   /* above neighbor
                                                    is zero */
       int lea = (l-&gt;row == a-&gt;row &amp;&amp; l-&gt;col == a-&gt;col);  /* left
                                neighbor equals above neighbor */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (lea &amp;&amp; lez)
           return SUBMVREF_LEFT_ABOVE_ZED; /* =4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (lea)
           return SUBMVREF_LEFT_ABOVE_SAME; /* =3 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (aez)
           return SUBMVREF_ABOVE_ZED; /* =2 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (lez)
           return SUBMVREF_LEFT_ZED; /* =1*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return SUBMVREF_NORMAL; /* =0 */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Constant probabilities and decoding procedure. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob sub_mv_ref_prob [5][num_sub_mv_ref - 1] = { { 147,136,18 }, { 106,145,1 }, { 179,121,1 }, { 223,1 ,34 }, { 208,1 ,1 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST度Probのsub_mv_ref_prob [5] [num_sub_mv_ref  -  1] = {{147,136,18}、{106,145,1}、{179,121,1}、{223,1、34}、{208,1、1}}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       sub_ref = (sub_mv_ref) treed_read(d, sub_mv_ref_tree,
         sub_mv_ref_prob[context]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two sub-prediction modes simply copy the already-coded motion vectors used by the blocks above and to the left of the subblock at the upper left corner of the current subset (i.e., collection of subblocks being predicted). These prediction blocks need not lie in the current macroblock and, if the current subset lies at the top or left edges of the frame, need not lie in the frame. In this latter case, their motion vectors are taken to be zero, as are subblock motion vectors within an intra-predicted macroblock. Also, to ensure the correctness of prediction within this macroblock, all subblocks lying in an already-decoded subset of the current macroblock must have their motion vectors set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の二つのサブ予測モードは、単に現在のサブセットの左上隅の上およびサブブロックの左ブロックによって使用される既に符号化された動きベクトルをコピーする（すなわち、サブブロックの集合は、予測されます）。これらの予測ブロックがフレームにある必要はなく、現在のサブセットは、フレームの上部または左端に位置している場合、現在のマクロブロックにあるとする必要はありません。イントラ予測されたマクロブロック内のサブブロックの動きベクトルであり、この後者の場合には、それらの動きベクトルは、ゼロであるとみなされます。また、このマクロブロック内の予測の正確さを保証するために、現在のマクロブロックの復号済みのサブセットに横たわっているすべてのサブブロックは、彼らの動きベクトルが設定されている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ZERO4x4 uses a zero motion vector and predicts the current subset using the corresponding subset from the prediction frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ZERO4x4はゼロ動きベクトルを使用して予測フレームからの対応するサブセットを使用して、現在のサブセットを予測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NEW4x4 is exactly like NEWMV except that NEW4x4 is applied only to the current subset. It is followed by a two-dimensional motion vector offset (described in the next section) that is added to the best vector returned by the earlier call to find_near_mvs to form the motion vector in effect for the subset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのNEW4x4が唯一の現在のサブセットに適用される以外NEW4x4はまさにNEWMVのようなものです。これは、サブセットに有効な動きベクトルを形成するfind_near_mvsの以前の呼び出しによって返される最良のベクトルに加算される（次のセクションで説明）オフセットの二次元動きベクトルが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parsing of both inter-prediction modes and motion vectors (described next) can be found in the reference decoder file modemv.c (Section 20.11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（次に説明する）インター予測モードと動きベクトルの両方の解析は、基準デコーダファイルmodemv.c（セクション20.11）に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Motion Vector Decoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.動きベクトルデコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed above, motion vectors appear in two places in the VP8 datastream: applied to whole macroblocks in NEWMV mode and applied to subsets of macroblocks in NEW4x4 mode. The format of the vectors is identical in both cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述したように、動きベクトルは、VP8のデータストリーム内の2つの場所に表示される：NEWMVモードにおける全マクロブロックに適用されるとNEW4x4モードにおけるマクロブロックのサブセットに適用されます。ベクトルの形式は、両方の場合で同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each vector has two pieces: a vertical component (row) followed by a horizontal component (column). The row and column use separate coding probabilities but are otherwise represented identically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
垂直成分（行）の水平成分（カラム）が続く。各ベクトルは、二つの部分を有しています。行と列は別個の符号化確率を使用するが、それ以外は同一に表されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. Coding of Each Component
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1。各コンポーネントのコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each component is a signed integer V representing a vertical or horizontal luma displacement of V quarter-pixels (and a chroma displacement of V eighth-pixels). The absolute value of V, if non-zero, is followed by a boolean sign. V may take any value between -1023 and +1023, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各成分は、Vクォーターピクセルの垂直または水平ルマ変位（及びV 1/8画素のクロマ変位）を表す符号付き整数Vです。 Vの絶対値は、非ゼロの場合は、ブール値の符号が続きます。 Vは、包括的、-1023と+1023の間の任意の値をとることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The absolute value A is coded in one of two different ways according to its size. For 0 &lt;= A &lt;= 7, A is tree-coded, and for 8 &lt;= A &lt;= 1023, the bits in the binary expansion of A are coded using independent boolean probabilities. The coding of A begins with a bool specifying which range is in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
絶対値Aは、その大きさに応じて二つの異なる方法のいずれかで符号化されます。 0 &lt;= A &lt;= 7の場合、Aは、ツリー符号化され、そして8は&lt;= A &lt;= 1023 Aのバイナリ膨張のビットは、独立ブール確率を用いて符号化されます。 Aの符号化が有効である範囲ブール指定で始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding a motion vector component then requires a 19-position probability table, whose offsets, along with the procedure used to decode components, are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動きベクトル成分を復号化することは、次に、そのオフセット成分を復号化するために使用される手順に沿って、以下の通りである、19位の確率テーブルを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef enum
   {
       mvpis_short,         /* short (&lt;= 7) vs long (&gt;= 8) */
       MVPsign,             /* sign for non-zero */
       MVPshort,            /* 8 short values = 7-position tree */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       MVPbits = MVPshort + 7,      /* 8 long value bits
                                       w/independent probs */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       MVPcount = MVPbits + 10      /* 19 probabilities in total */
   }
   MVPindices;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef Prob MV_CONTEXT [MVPcount];    /* Decoding spec for
                                             a single component */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Tree used for small absolute values (has expected
      correspondence). */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const tree_index small_mvtree [2 * (8 - 1)] =
   {
    2, 8,          /* &#34;0&#34; subtree, &#34;1&#34; subtree */
     4, 6,         /* &#34;00&#34; subtree, &#34;01&#34; subtree */
      -0, -1,      /* 0 = &#34;000&#34;, 1 = &#34;001&#34; */
      -2, -3,      /* 2 = &#34;010&#34;, 3 = &#34;011&#34; */
     10, 12,       /* &#34;10&#34; subtree, &#34;11&#34; subtree */
      -4, -5,      /* 4 = &#34;100&#34;, 5 = &#34;101&#34; */
      -6, -7       /* 6 = &#34;110&#34;, 7 = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Read MV component at current decoder position, using
      supplied probs. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int read_mvcomponent(bool_decoder *d, const MV_CONTEXT *mvc) { const Prob * const p = (const Prob *) mvc;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INT read_mvcomponent（bool_decoderの* dを、CONST MV_CONTEXT * MVC）{CONST度Prob * CONSTのP =（CONST度Prob *）MVC。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int A = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int型のA = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (read_bool(d, p [mvpis_short]))    /* 8 &lt;= A &lt;= 1023 */
       {
           /* Read bits 0, 1, 2 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           int i = 0;
           do { A += read_bool(d, p [MVPbits + i]) &lt;&lt; i;}
             while (++i &lt; 3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Read bits 9, 8, 7, 6, 5, 4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           i = 9;
           do { A += read_bool(d, p [MVPbits + i]) &lt;&lt; i;}
             while (--i &gt; 3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* We know that A &gt;= 8 because it is coded long,
              so if A &lt;= 15, bit 3 is one and is not
              explicitly coded. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (!(A &amp; 0xfff0)  ||  read_bool(d, p [MVPbits + 3]))
               A += 8;
       }
       else    /* 0 &lt;= A &lt;= 7 */
           A = treed_read(d, small_mvtree, p + MVPshort);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return A &amp;&amp; read_bool(r, p [MVPsign]) ? -A : A; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&amp;&amp; read_bool（R、P [MVPsign]）を返しますか？ -A：A; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. Probability Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2。確率アップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder should maintain an array of two MV_CONTEXTs for decoding row and column components, respectively. These MV_CONTEXTs should be set to their defaults every key frame. Each individual probability may be updated every interframe (by field J of the frame header) using a constant table of update probabilities. Each optional update is of the form B? P(7), that is, a bool followed by a 7-bit probability specification if true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダは、それぞれ、行と列のコンポーネントをデコードするための2つのMV_CONTEXTsの配列を維持しなければなりません。これらのMV_CONTEXTsは、すべてのキーフレームをデフォルトに設定する必要があります。各個々の確率は、更新確率の定数テーブルを用いて、（フレーム・ヘッダのフィールドJによって）毎にインターを更新することができます。各オプションの更新は、フォームBのでしょうか？ P（7）、それは、真の場合は7ビットの確率仕様続いブール値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with other dynamic probabilities used by VP8, the updates remain in effect until the next key frame or until replaced via another update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8によって使用される他の動的確率と同様に、更新は、次のキーフレームまで、または別の更新を介して置換されるまで有効のまま。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In detail, the probabilities should then be managed as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように具体的には、確率は、管理されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Never-changing table of update probabilities for each
      individual probability used in decoding motion vectors. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const MV_CONTEXT vp8_mv_update_probs[2] = { { 237, 246, 253, 253, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 250, 250, 252, 254, 254 }, { 231, 243, 245, 253, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 251, 251, 254, 254, 254 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST MV_CONTEXT [2] = {{237、246、253、253、254、254、254、254、254、254、254、254、254、254、250、250、252、254、254}、{231 vp8_mv_update_probs 、243、245、253、254、254、254、254、254、254、254、254、254、254、251、251、254、254、254}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Default MV decoding probabilities. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const MV_CONTEXT default_mv_context[2] = { { // row 162, // is short 128, // sign 225, 146, 172, 147, 214, 39, 156, // short tree 128, 129, 132, 75, 145, 178, 206, 239, 254, 254 // long bits },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST MV_CONTEXTはdefault_mv_context [2] = {{//行162、// 128短く、145、225、146、172、147、214、39、156、//短いツリー128、129、132、75署名// 、178、206、239、254、254 //長いビット}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
{ // same for column 164, // is short 128, 204, 170, 119, 235, 140, 230, 228, 128, 130, 130, 74, 148, 180, 203, 236, 254, 254 // long bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
{//列164に対して同じ、// 128、204、170、119、235、140、230、228、128、130、130、74、148、180、203、236、254、254 //長い短いですビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝ ｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Current MV decoding probabilities, set to above defaults
      every key frame. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   MV_CONTEXT mvc [2];     /* always row, then column */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Procedure for decoding a complete motion vector. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef struct { int16 row, col;}  MV;  /* as in previous section */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   MV read_mv(bool_decoder *d)
   {
       MV v;
       v.row = (int16) read_mvcomponent(d, mvc);
       v.col = (int16) read_mvcomponent(d, mvc + 1);
       return v;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Procedure for updating MV decoding probabilities, called
      every interframe with &#34;d&#34; at the appropriate position in
      the frame header. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void update_mvcontexts(bool_decoder *d)
   {
       int i = 0;
       do {                      /* component = row, then column */
           const Prob *up = mv_update_probs[i];    /* update probs
                                                      for component */
           Prob *p = mvc[i];                  /* start decode tbl &#34;&#34; */
           Prob * const pstop = p + MVPcount; /* end decode tbl &#34;&#34; */
           do {
               if (read_bool(d, *up++))     /* update this position */
               {
                   const Prob x = read_literal(d, 7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   *p = x? x&lt;&lt;1 : 1;
               }
           } while (++p &lt; pstop);              /* next position */
       } while (++i &lt; 2);                      /* next component */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This completes the description of the motion-vector decoding procedure and, with it, the procedure for decoding interframe macroblock prediction records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、動きベクトル復号化処理の説明を終了し、それとともに、インターマクロブロック予測レコードを復号化するための手順。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. Interframe Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.フレーム間予測
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given an inter-prediction specification for the current macroblock, that is, a reference frame together with a motion vector for each of the sixteen Y subblocks, we describe the calculation of the prediction buffer for the macroblock. Frame reconstruction is then completed via the previously described processes of residue summation (Section 14) and loop filtering (Section 15).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16 Yのサブブロックのそれぞれの動きベクトルと共に、参照フレームで現在のマクロブロックに対するインター予測仕様が与えられると、我々は、マクロブロックに対する予測バッファの計算を記述する。フレーム再構成は、次に残渣総和（セクション14）と、ループフィルタ（セクション15）の前述の工程を経て完成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The management of inter-predicted subblocks and sub-pixel interpolation may be found in the reference decoder file predict.c (Section 20.14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インター予測サブブロックおよびサブピクセル補間の管理は、参照デコーダファイルpredict.c（セクション20.14）に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. Bounds on, and Adjustment of, Motion Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1。上の境界、及び、動きベクトルの調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since each motion vector is differentially encoded from a neighboring block or macroblock and the only clamp is to ensure that the referenced motion vector represents a valid location inside a reference frame buffer, it is technically possible within the VP8 format for a block or macroblock to have arbitrarily large motion vectors, up to the size of the input image plus the extended border areas. For practical reasons, VP8 imposes a motion vector size range limit of -4096 to 4095 full pixels, regardless of image size (VP8 defines 14 raw bits for width and height; 16383x16383 is the maximum possible image size). Bitstream-compliant encoders and decoders shall enforce this limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各動きベクトルは、示差隣接するブロックまたはマクロブロックから符号化のみクランプは、参照動きベクトルは、参照フレームバッファ内の有効な位置を表し、それが持っているVP8ブロックのフォーマットまたはマクロブロック内の技術的に可能であることを保証することであるので任意の大きな動きベクトル、入力画像のサイズと拡張境界領域まで。実用的な理由から、VP8にかかわらず、画像サイズの（VP8は、幅と高さの14個の生のビットを定義し; 16383x16383が可能な最大画像サイズである）、-4096〜4095のフルピクセルの動きベクトル大きさの範囲の制限を課します。ビットストリーム対応のエンコーダとデコーダは、この制限を実施しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the motion vectors applied to the chroma subblocks have 1/8-pixel resolution, the synthetic pixel calculation, outlined in Section 5 and detailed below, uses this resolution for the luma subblocks as well. In accordance, the stored luma motion vectors are all doubled, each component of each luma vector becoming an even integer in the range -2046 to +2046, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クロマ・サブブロックに適用される動きベクトル1/8ピクセル解像度を有するので、第5章に概説し、以下に詳述する合成画素演算は、同様に輝度サブブロックのために、この解像度を使用します。応じて、格納されたルミナンス動きベクトルは全て、包括2046の範囲-2046、偶数整数になって、各輝度ベクトルの各成分を二倍にしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The vector applied to each chroma subblock is calculated by averaging the vectors for the 4 luma subblocks occupying the same visible area as the chroma subblock in the usual correspondence; that is, the vector for U and V block 0 is the average of the vectors for the Y subblocks { 0, 1, 4, 5}, chroma block 1 corresponds to Y blocks { 2, 3, 6, 7}, chroma block 2 to Y blocks { 8, 9, 12, 13}, and chroma block 3 to Y blocks { 10, 11, 14, 15}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各クロマ・サブブロックに適用されるベクトルは、通常対応するクロマサブブロックと同一の表示領域を占有4つのルマサブブロックのためのベクトルを平均することによって計算されます。それはUとVブロック0のためのベクターは、Yサブブロックのためのベクトルの平均であり、{0、1、4、5}、クロマ・ブロック1は、Yブロック{2、3、6、7}、クロマ・ブロックに対応しますYブロックのYブロック{8、9、12、13}、及びクロマブロック2~3 {10、11、14、15}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In detail, each of the two components of the vectors for each of the chroma subblocks is calculated from the corresponding luma vector components as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように詳細には、クロマサブブロックの各々のためのベクターの二つの成分の各々は、対応する輝度ベクトル成分から計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int avg(int c1, int c2, int c3, int c4) { int s = c1 + c2 + c3 + c4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INT平均（INT C1、C2 INT、INT C3、C4 INT）{int型、S = C1 + C2 + C3 + C4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* The shift divides by 8 (not 4) because chroma pixels
          have twice the diameter of luma pixels.  The handling
          of negative motion vector components is slightly
          cumbersome because, strictly speaking, right shifts
          of negative numbers are not well-defined in C. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return s &gt;= 0 ? (s + 4) &gt;&gt; 3 : -((-s + 4) &gt;&gt; 3); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リターンS&gt; = 0？ （S + 4）&gt;&gt; 3  - （（ -  S + 4）&gt;&gt; 3）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, if the version number in the frame tag specifies only full-pel chroma motion vectors, then the fractional parts of both components of the vector are truncated to zero, as illustrated in the following pseudocode (assuming 3 bits of fraction for both luma and chroma vectors):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームのタグ内のバージョン番号が次の擬似コードに示すように、次にベクトルの両方の成分の小数部分がゼロに切り捨てられのみフルペルクロマ動きベクトルを、指定した場合、さらに、（両方の輝度のための画分の3ビットを仮定し、クロマベクトル）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       x = x &amp; (~7);
       y = y &amp; (~7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Earlier in this document we described the vp8_clamp_mv() function to limit &#34;nearest&#34; and &#34;near&#34; motion vector predictors inside specified margins within the frame boundaries. Additional clamping is performed for NEWMV macroblocks, for which the final motion vector is clamped again after combining the &#34;best&#34; predictor and the differential vector decoded from the stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前この文書に記載されている私たちは、フレーム境界内の指定されたマージン内の「最も近い」と「近い」動きベクトル予測因子を制限するvp8_clamp_mv（）関数を記述しました。追加のクランプは、最終的な動きベクトルは「最良の」予測とストリームから復号差分ベクトルを合成した後に再びクランプされたNEWMVマクロブロックのために実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the secondary clamping is not performed for SPLITMV macroblocks, meaning that any subblock&#39;s motion vector within the SPLITMV macroblock may point outside the clamping zone. These non-clamped vectors are also used when determining the decoding tree context for subsequent subblocks&#39; modes in the vp8_mvCont() function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、二次クランプSPLITMVマクロブロック内の任意のサブブロックの動きベクトルは、クランピングゾーンの外側に指してもよいことを意味し、SPLITMVマクロブロックのために実行されません。これらの非クランプベクターvp8_mvCont（）関数の後続のサブブロックモードの復号ツリーのコンテキストを決定する際にも使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. Prediction Subblocks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2。予測サブブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prediction calculation for each subblock is then as follows. Temporarily disregarding the fractional part of the motion vector (that is, rounding &#34;up&#34; or &#34;left&#34; by right-shifting each component 3 bits with sign propagation) and adding the origin (upper left position) of the (16x16 luma or 8x8 chroma) current macroblock gives us an origin in the Y, U, or V plane of the predictor frame (either the golden frame or previous frame).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように各サブブロックの予測計算は、次にです。一時的に動きベクトルの端数部分を無視する（すなわち「アップ」丸め、であるか、または右シフト符号伝播各成分3ビットで「左」）と（16×16輝度又は8×8クロマの原点（左上）を添加）現在のマクロブロックは、予測フレーム（金色のフレームまたは前のフレームのいずれか）のY、U、又はV面に私たちの起源を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering that origin to be the upper left corner of a (luma or chroma) macroblock, we need to specify the relative positions of the pixels associated to that subblock, that is, any pixels that might be involved in the sub-pixel interpolation processes for the subblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その起源を考慮すると（輝度や彩度）マクロブロックの左上隅になるように、我々は、そのサブブロックに関連する画素の相対的な位置を指定する必要があり、つまり、ためのサブピクセル補間プロセスに関与する可能性のあるピクセルサブブロック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3. Sub-Pixel Interpolation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3。サブピクセル補間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sub-pixel interpolation is effected via two one-dimensional convolutions. These convolutions may be thought of as operating on a two-dimensional array of pixels whose origin is the subblock origin, that is the origin of the prediction macroblock described above plus the offset to the subblock. Because motion vectors are arbitrary, so are these &#34;prediction subblock origins&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブピクセル補間は、2つの1次元畳み込みを介して行われます。これらの畳み込みは、それが上述の予測マクロブロックの原点プラスサブブロックへのオフセット、原点サブブロック起源である画素の二次元アレイ上で動作すると考えることができます。動きベクトルは任意であるので、これらの「予測サブブロックの起源」であるため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The integer part of the motion vector is subsumed in the origin of the prediction subblock; the 16 (synthetic) pixels we need to construct are given by 16 offsets from the origin. The integer part of each of these offsets is the offset of the corresponding pixel from the subblock origin (using the vertical stride). To these integer parts is added a constant fractional part, which is simply the difference between the actual motion vector and its integer truncation used to calculate the origins of the prediction macroblock and subblock. Each component of this fractional part is an integer between 0 and 7, representing a forward displacement in eighths of a pixel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動きベクトルの整数部分は、予測サブブロックの原点に包含されます。私たちが構築する必要がある16（合成）の画素は、原点からの16件のオフセットによって与えられます。これらのオフセットのそれぞれの整数部は、（垂直ストライドを使用して）サブブロック原点から対応する画素のオフセットです。これらの整数部分に単に予測マクロブロック及びサブブロックの起源を計算するために使用される実際の動きベクトルとその整数切り捨てとの差である一定の小数部を添加します。この小数部の各構成要素は、ピクセルの3/8に前方変位を表し、0と7の間の整​​数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is these fractional displacements that determine the filtering process. If they both happen to be zero (that is, we had a &#34;whole pixel&#34; motion vector), the prediction subblock is simply copied into the corresponding piece of the current macroblock&#39;s prediction buffer. As discussed in Section 14, the layout of the macroblock&#39;s prediction buffer can depend on the specifics of the reconstruction implementation chosen. Of course, the vertical displacement between lines of the prediction subblock is given by the stride, as are all vertical displacements used here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、フィルタリング処理を決定し、これらの小数の変位です。どちらも（つまり、私たちは「全画素」動きベクトルを有していた）がゼロであることが起こる場合、予測サブブロックは、単に現在のマクロブロックの予測バッファの対応する部分にコピーされます。セクション14で説明したように、マクロブロックの予測バッファのレイアウトは、選択された再構成の実装の詳細に依存することができます。ここで使用される全ての垂直変位であるように、もちろん、予測サブブロックのライン間の垂直変位は、ストライドによって与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, at least one of the fractional displacements is non-zero. We then synthesize the missing pixels via a horizontal, followed by a vertical, one-dimensional interpolation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合は、小数変位の少なくとも一方が非ゼロです。我々は、次に、垂直、一次元補間続く水平介して欠落画素を合成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two interpolations are essentially identical. Each uses a (at most) six-tap filter (the choice of which of course depends on the one-dimensional offset). Thus, every calculated pixel references at most three pixels before (above or to the left of) it and at most three pixels after (below or to the right of) it. The horizontal interpolation must calculate two extra rows above and three extra rows below the 4x4 block, to provide enough samples for the vertical interpolation to proceed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの補間が本質的に同一です。それぞれ、（最大で）6タップフィルタ（もちろんオフセット一次元に依存するの選択肢）を使用しています。したがって、すべての前（上または左に）最も3つの画素で算出された画素の参照その最も3つの画素で（の右下またはまで）後。水平補間は、垂直補間が進行するために十分なサンプルを提供するために、上記2つの追加の行と4×4ブロックの次の3つの余分な行を計算しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the reconstruction filter type given in the version number field in the frame tag, either a bicubic or a bilinear tap set is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双三次または双線形タップセットのいずれかが使用され、フレームタグにバージョン番号フィールドに指定された再構成フィルタの種類に応じ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact implementation of subsampling is as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにサブサンプリングの正確な実装です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Filter taps taken to 7-bit precision.
      Because DC is always passed, taps always sum to 128. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const int BilinearFilters[8][6] = { { 0, 0, 128, 0, 0, 0 }, { 0, 0, 112, 16, 0, 0 }, { 0, 0, 96, 32, 0, 0 }, { 0, 0, 80, 48, 0, 0 }, { 0, 0, 64, 64, 0, 0 }, { 0, 0, 48, 80, 0, 0 }, { 0, 0, 32, 96, 0, 0 }, { 0, 0, 16, 112, 0, 0 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST INT BilinearFilters [8] [6] = {{0、0、128、0、0、0}、{0、0、112、16、0、0}、{0、0、96、32、0、 0}、{0、0、80、48、0、0}、{0、0、64、64、0、0}、{0、0、48、80、0、0}、{0、0、 32、96、0、0}、{0、0、16、112、0、0}}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const int filters [8] [6] = {        /* indexed by displacement */
       { 0,  0,  128,    0,   0,  0 },  /* degenerate whole-pixel */
       { 0, -6,  123,   12,  -1,  0 },  /* 1/8 */
       { 2, -11, 108,   36,  -8,  1 },  /* 1/4 */
       { 0, -9,   93,   50,  -6,  0 },  /* 3/8 */
       { 3, -16,  77,   77, -16,  3 },  /* 1/2 is symmetric */
       { 0, -6,   50,   93,  -9,  0 },  /* 5/8 = reverse of 3/8 */
       { 1, -8,   36,  108, -11,  2 },  /* 3/4 = reverse of 1/4 */
       { 0, -1,   12,  123,  -6,  0 }   /* 7/8 = reverse of 1/8 */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* One-dimensional synthesis of a single sample.
      Filter is determined by fractional displacement */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Pixel interp(
       const int fil[6],   /* filter to apply */
       const Pixel *p,     /* origin (rounded &#34;before&#34;) in
                              prediction area */
       const int s         /* size of one forward step &#34;&#34; */
   ) {
       int32 a = 0;
       int i = 0;
       p -= s + s;         /* move back two positions */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       do {
           a += *p * fil[i];
           p += s;
       }  while (++i &lt; 6);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return clamp255((a + 64) &gt;&gt; 7);    /* round to nearest
                                              8-bit value */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* First do horizontal interpolation, producing intermediate
      buffer. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void Hinterp(
       Pixel temp[9][4],   /* 9 rows of 4 (intermediate)
                              destination values */
       const Pixel *p,     /* subblock origin in prediction
                              frame */
       int s,              /* vertical stride to be used in
                              prediction frame */
       uint hfrac,         /* 0 &lt;= horizontal displacement &lt;= 7 */
       uint bicubic        /* 1=bicubic filter, 0=bilinear */
   ) {
       const int * const fil = bicubic ? filters [hfrac] :
         BilinearFilters[hfrac];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int r = 0;  do              /* for each row */
       {
           int c = 0;  do          /* for each destination sample */
           {
               /* Pixel separation = one horizontal step = 1 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               temp[r][c] = interp(fil, p + c, 1);
           } while (++c &lt; 4);
       }
       while (p += s, ++r &lt; 9);    /* advance p to next row */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Finish with vertical interpolation, producing final results.
      Input array &#34;temp&#34; is of course that computed above. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void Vinterp(
       Pixel final[4][4],  /* 4 rows of 4 (final) destination values */
       const Pixel temp[9][4],
       uint vfrac,         /* 0 &lt;= vertical displacement &lt;= 7 */
       uint bicubic        /* 1=bicubic filter, 0=bilinear */
   ) {
       const int * const fil = bicubic ? filters [vfrac] :
         BilinearFilters[vfrac];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int r = 0;  do              /* for each row */
       {
           int c = 0;  do          /* for each destination sample */
           {
               /* Pixel separation = one vertical step = width
                  of array = 4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               final[r][c] = interp(fil, temp[r] + c, 4);
           }
           while (++c &lt; 4);
       }
       while (++r &lt; 4);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4. Filter Properties
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4。フィルタのプロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We discuss briefly the rationale behind the choice of filters. Our approach is necessarily cursory; a genuinely accurate discussion would require a couple of books. Readers unfamiliar with signal processing may or may not wish to skip this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、簡単にフィルタの選択の背後にある理論的根拠を議論します。我々のアプローチは必ずしも一遍です。本当に正確な議論は、書籍のカップルを必要とします。信号処理に不慣れな読者はあるいはこれをスキップしたくない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All digital signals are of course sampled in some fashion. The case where the inter-sample spacing (say in time for audio samples, or space for pixels) is uniform, that is, the same at all positions, is particularly common and amenable to analysis. Many aspects of the treatment of such signals are best-understood in the frequency domain via Fourier Analysis, particularly those aspects of the signal that are not changed by shifts in position, especially when those positional shifts are not given by a whole number of samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのデジタル信号はもちろん、いくつかの方法でサンプリングされています。サンプル間の間隔は、（オーディオサンプル、またはピクセルのための空間時間で言う）均一である場合、すなわち、全ての位置で同じであるが、特に一般的であり、分析に適しています。このような信号の処理の多くの態様は、これらの位置ずれがサンプルの全体数によって与えられない場合は特に、位置にシフトすることによって変更されない信号の特に側面、フーリエ解析によって周波数ドメインで最もよく理解されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-integral translates of a sampled signal are a textbook example of the foregoing. In our case of non-integral motion vectors, we wish to say what the underlying image &#34;really is&#34; at these pixels; although we don&#39;t have values for them, we feel that it makes sense to talk about them. The correctness of this feeling is predicated on the underlying signal being band-limited, that is, not containing any energy in spatial frequencies that cannot be faithfully rendered at the pixel resolution at our disposal. In one dimension, this range of &#34;OK&#34; frequencies is called the Nyquist band; in our two-dimensional case of integer-grid samples, this range might be termed a Nyquist rectangle. The finer the grid, the more we know about the image, and the wider the Nyquist rectangle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サンプリングされた信号の非整数並進は、上記の教科書の例です。非整数の動きベクトルの私たちのケースでは、下にある画像は、これらのピクセルに「本当に」何を言うことを望みます。私たちはそれらの値を持っていませんが、我々はそれが彼らの話をすることは理にかなっていると感じています。この感覚の正しさはない忠実に私達の処分でピクセルの解像度でレンダリングすることができない空間周波数における任意のエネルギーを含む、つまり、帯域制限されている基本的な信号に基づいています。一次元では、「OK」この周波数範囲は、ナイキスト帯域と呼ばれています。整数グリッドのサンプルの私達の2次元の場合には、この範囲は、ナイキスト長方形と呼ぶことがあります。細かいグリッドは、より多くの我々は画像、及びより広いナイキスト矩形について知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It turns out that, for such band-limited signals, there is indeed an exact mathematical formula to produce the correct sample value at an arbitrary point. Unfortunately, this calculation requires the consideration of every single sample in the image, as well as needing to operate at infinite precision. Also, strictly speaking, all band-limited signals have infinite spatial (or temporal) extent, so everything we are discussing is really some sort of approximation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような帯域制限信号に対して、任意の時点で正確なサンプル値を生成するために、正確な数学的な式が実際に存在することが判明しました。残念なことに、この計算は、画像内のすべての単一のサンプルの考慮を必要とするだけでなく、無限の精度で動作する必要が。また、厳密に言えば、すべての帯域制限された信号は、無限の空間（または一時的な）範囲を持っているので、我々が議論しているすべてのものは実際に近似のいくつかの並べ替えです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is true that the theoretically correct subsampling procedure, as well as any approximation thereof, is always given by a translation-invariant weighted sum (or filter) similar to that used by VP8. It is also true that the reconstruction error made by such a filter can be simply represented as a multiplier in the frequency domain; that is, such filters simply multiply the Fourier transform of any signal to which they are applied by a fixed function associated to the filter. This fixed function is usually called the frequency response (or transfer function); the ideal subsampling filter has a frequency response equal to one in the Nyquist rectangle and zero everywhere else.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理論的に正しいサブサンプリング手順、ならびにそれらの任意の近似は、常にVP8によって使用されるものと同様の並進不変加重和（またはフィルタ）で与えられることは事実です。そのようなフィルタによって作られた再構成エラーは、単に、周波数領域における乗算として表すことができることも事実です。つまり、そのようなフィルタは、単にフーリエ変換は、それらがフィルタに関連する固定機能によって適用された任意の信号の変換掛けます。この固定機能は、通常、周波数応答（または伝達関数）と呼ばれます。理想的なサブサンプリングフィルタは、ナイキスト矩形内の1つ及び他の場所にゼロに等しい周波数応答を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another basic fact about approximations to &#34;truly correct&#34; subsampling is that the wider the subrectangle (within the Nyquist rectangle) of spatial frequencies one wishes to &#34;pass&#34; (that is, correctly render) or, put more accurately, the closer one wishes to approximate the ideal transfer function, the more samples of the original signal must be considered by the subsampling, and the wider the calculation precision necessitated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「本当に正しい」サブサンプリングの近似についてのもう一つの基本的な事実は、1つの「パス」（つまり、正しくレンダリング）、または、より正確に置くことを希望する空間周波数の（ナイキスト矩形内）subrectangle広いが、近い1がしたいということです理想的な伝達関数を近似し、元の信号の複数のサンプルをサブサンプリングすることによって考慮されなければならない、より広い計算精度が必要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filters chosen by VP8 were chosen, within the constraints of 4 or 6 taps and 7-bit precision, to do the best possible job of handling the low spatial frequencies near the 0th DC frequency along with introducing no resonances (places where the absolute value of the frequency response exceeds one).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8によって選択されたフィルタは、絶対値がない共鳴（場所を導入しないとともに、第0 DC周波数付近の低い空間周波数を処理可能な限り最高の仕事をするために、4つのまたは6タップと7ビットの精度の制約内で、選択されました周波数応答の）いずれかを超えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The justification for the foregoing has two parts. First, resonances can produce extremely objectionable visible artifacts when, as often happens in actual compressed video streams, filters are applied repeatedly. Second, the vast majority of energy in real-world images lies near DC and not at the high end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の正当化は二つの部分を有しています。多くの場合、実際の圧縮されたビデオストリームに起こるように、フィルタが繰り返し適用された場合、まず、共振は非常に不快な目に見える成果物を生成することができます。第二に、実世界の画像のエネルギーの大半は、DC近くのないハイエンドに位置しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To get slightly more specific, the filters chosen by VP8 are the best resonance-free 4- or 6-tap filters possible, where &#34;best&#34; describes the frequency response near the origin: The response at 0 is required to be 1, and the graph of the response at 0 is as flat as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう少し具体的な取得するには、VP8が選択したフィルタは、可能な限り最高の共鳴フリー4または6タップフィルタである、「最高の」原点付近の周波数応答を記述する場所：0での応答は1であることが要求され、そして0での応答のグラフは、できるだけ平坦です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide an intuitively more obvious point of reference, the &#34;best&#34; 2-tap filter is given by simple linear interpolation between the surrounding actual pixels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照の直感的により明白ポイントを提供するために、「最良の」2タップ・フィルタは、周囲の実画素との間の単純な線形補間によって与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, it should be noted that, because of the way motion vectors are calculated, the (shorter) 4-tap filters (used for odd fractional displacements) are applied in the chroma plane only. Human color perception is notoriously poor, especially where higher spatial frequencies are involved. The shorter filters are easier to understand mathematically, and the difference between them and a theoretically slightly better 6-tap filter is negligible where chroma is concerned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、ため、動きベクトルを算出する方法で、（奇数分数変位のために使用）（短）4タップフィルタのみ彩度平面で適用されることに留意すべきです。人間の色知覚は、より高い空間周波数が関与している、特に場合は、非常に遅いです。短いフィルタは数学的に理解しやすく、彩度が懸念しているところ、彼らと理論的にはわずかに良い6タップフィルタの違いはごくわずかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. Annex A: Bitstream Syntax
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19附属書A：ビットストリーム構文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This annex presents the bitstream syntax in a tabular form. All the information elements have been introduced and explained in the previous sections but are collected here for a quick reference. Each syntax element is briefly described after the tabular representation along with a reference to the corresponding paragraph in the main document. The meaning of each syntax element value is not repeated here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この附属書は、表形式でビットストリーム構文を示します。すべての情報要素が導入され、前のセクションで説明したが、すぐに参照のために、ここで収集されてきました。各シンタックス要素は、簡単にメインドキュメント内の対応する段落を参照すると共に、平板表現の後に記載されています。各シンタックス要素の値の意味はここでは繰り返しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The top-level hierarchy of the bitstream is introduced in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットストリームの最上位階層はセクション4に導入されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition of syntax element coding types can be found in Section 8. The types used in the representation in this annex are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
符号化タイプの構文要素の定義は、セクション8に記載されています。この附属書での表現に使用されるタイプは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o f(n), n-bit value from stream (n successive bits, not boolean encoded)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームからO F（n）は、nビット値（N個の連続ビットではなく、ブールコードされます）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o L(n), n-bit number encoded as n booleans (with equal probability of being 0 or 1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n個のブール値としてエンコードO L（n）は、nビット番号（0又は1であることの等しい確率で）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o B(p), bool with probability p of being 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0である確率PとO B（P）、BOOL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o T, tree-encoded value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O T、ツリー符号化された値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1. Uncompressed Data Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1。非圧縮データチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | Frame Tag                                         | Type  |
   | ------------------------------------------------- | ----- |
   | frame_tag                                         | f(24) |
   | if (key_frame) {                                  |       |
   |     start_code                                    | f(24) |
   |     horizontal_size_code                          | f(16) |
   |     vertical_size_code                            | f(16) |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 3-byte frame tag can be parsed as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように3バイトのフレームのタグを解析することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   unsigned char *c = pbi-&gt;source;
   unsigned int tmp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tmp = (c[2] &lt;&lt; 16) | (c[1] &lt;&lt; 8) | c[0];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TMP =（C [2] &lt;&lt; 16）| （C [1] &lt;&lt; 8）| C [0]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   key_frame = tmp &amp; 0x1;
   version = (tmp &gt;&gt; 1) &amp; 0x7;
   show_frame = (tmp &gt;&gt; 4) &amp; 0x1;
   first_part_size = (tmp &gt;&gt; 5) &amp; 0x7FFFF;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o key_frame indicates whether the current frame is a key frame or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O key_frameは、現在のフレームがキーフレームであるか否かを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o version determines the bitstream version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oバージョンは、ビットストリームのバージョンを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o show_frame indicates whether the current frame is meant to be displayed or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O show_frameは、現在のフレームが表示されたりしないことを意味するかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o first_part_size determines the size of the first partition (control partition), excluding the uncompressed data chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O first_part_sizeは、非圧縮データのチャンクを除いて、最初のパーティション（制御パーティション）のサイズを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The start_code is a constant 3-byte pattern having value 0x9d012a. The latter part of the uncompressed chunk (after the start_code) can be parsed as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
START_CODEは、値0x9d012aを有する定3バイトのパターンです。次のように（START_CODE後）の非圧縮チャンクの後の部分を解析することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   unsigned char *c = pbi-&gt;source + 6;
   unsigned int tmp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tmp = (c[1] &lt;&lt; 8) | c[0];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TMP =（C [1] &lt;&lt; 8）| C [0]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   width = tmp &amp; 0x3FFF;
   horizontal_scale = tmp &gt;&gt; 14;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tmp = (c[3] &lt;&lt; 8) | c[2];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TMP =（C [3] &lt;&lt; 8）| C [2]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   height = tmp &amp; 0x3FFF;
   vertical_scale = tmp &gt;&gt; 14;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2. Frame Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2。フレームヘッダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | Frame Header                                      | Type  |
   | ------------------------------------------------- | ----- |
   | if (key_frame) {                                  |       |
   |   color_space                                     | L(1)  |
   |   clamping_type                                   | L(1)  |
   | }                                                 |       |
   | segmentation_enabled                              | L(1)  |
   | if (segmentation_enabled)                         |       |
   |   update_segmentation()                           |       |
   | filter_type                                       | L(1)  |
   | loop_filter_level                                 | L(6)  |
   | sharpness_level                                   | L(3)  |
   | mb_lf_adjustments()                               |       |
   | log2_nbr_of_dct_partitions                        | L(2)  |
   | quant_indices()                                   |       |
   | if (key_frame)                                    |       |
   |   refresh_entropy_probs                           | L(1)  |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| else { | | | refresh_golden_frame | L(1) | | refresh_alternate_frame | L(1) | | if (!refresh_golden_frame) | | | copy_buffer_to_golden | L(2) | | if (!refresh_alternate_frame) | | | copy_buffer_to_alternate | L(2) | | sign_bias_golden | L(1) | | sign_bias_alternate | L(1) | | refresh_entropy_probs | L(1) | | refresh_last | L(1) | | } | | | token_prob_update() | | | mb_no_skip_coeff | L(1) | | if (mb_no_skip_coeff) | | | prob_skip_false | L(8) | | if (!key_frame) { | | | prob_intra | L(8) | | prob_last | L(8) | | prob_gf | L(8) | | intra_16x16_prob_update_flag | L(1) | | if (intra_16x16_prob_update_flag) { | | | for (i = 0; i &lt; 4; i++) | | | intra_16x16_prob | L(8) | | } | | | intra_chroma prob_update_flag | L(1) | | if (intra_chroma_prob_update_flag) { | | | for (i = 0; i &lt; 3; i++) | | | intra_chroma_prob | L(8) | | } | | | mv_prob_update() | | | } | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
|他に{| | | refresh_golden_frame | L（1）| | refresh_alternate_frame | L（1）| | （もし！refresh_golden_frame）| | | copy_buffer_to_golden | L（2）| | （もし！refresh_alternate_frame）| | | copy_buffer_to_alternate | L（2）| | sign_bias_golden | L（1）| | sign_bias_alternate | L（1）| | refresh_entropy_probs | L（1）| | refresh_last | L（1）| | } | | | token_prob_update（）| | | mb_no_skip_coeff | L（1）| | （mb_no_skip_coeff）の場合| | | prob_skip_false | L（8）| |もし（！のkey_frame）{| | | prob_intra | L（8）| | prob_last | L（8）| | prob_gf | L（8）| | intra_16x16_prob_update_flag | L（1）| | （intra_16x16_prob_update_flag）の場合{| | | |（私は++;;私は4 &lt;I = 0）について| | intra_16x16_prob | L（8）| | } | | | intra_chromaのprob_update_flag | L（1）| | （intra_chroma_prob_update_flag）の場合{| | | |（私は++;;私は3を&lt;I = 0）について| | intra_chroma_prob | L（8）| | } | | | mv_prob_update（）| | | } | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o color_space defines the YUV color space of the sequence (Section 9.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O color_spaceシーケンスのYUV色空間を定義する（9.2節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o clamping_type specifies if the decoder is required to clamp the reconstructed pixel values (Section 9.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダは、再構成画素値をクランプする必要がある場合、Oのclamping_typeが指定（9.2節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segmentation_enabled enables the segmentation feature for the current frame (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O segmentation_enabled現在のフレームのセグメンテーション機能を有効（9.3節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o filter_type determines whether the normal or the simple loop filter is used (Sections 9.4, 15)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O FILTER_TYPEは正常又は単純なループフィルタは（セクション9.4、15）が使用されたか否かを判定する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loop_filter_level controls the deblocking filter (Sections 9.4, 15)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O loop_filter_levelは、デブロッキングフィルタ（セクション9.4、15）を制御します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sharpness_level controls the deblocking filter (Sections 9.4, 15)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O sharpness_levelは、デブロッキングフィルタ（セクション9.4、15）を制御します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o log2_nbr_of_dct_partitions determines the number of separate partitions containing the DCT coefficients of the macroblocks (Section 9.5)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入出力log2_nbr_of_dct_partitionsは、マクロブロックのDCT係数を含む別々のパーティションの数を決定する（第9.5節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_entropy_probs determines whether updated token probabilities are used only for this frame or until further update
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O refresh_entropy_probs更新トークン確率のみがこのフレームのまたはさらなる更新まで使用されているか否かを判断します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_golden_frame determines if the current decoded frame refreshes the golden frame (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の復号フレームゴールデンフレームをリフレッシュする場合入出力refresh_golden_frameを判断する（第9.7節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_alternate_frame determines if the current decoded frame refreshes the alternate reference frame (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のデコードされたフレームは、代替基準フレームを更新した場合入出力refresh_alternate_frameを判断する（第9.7節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o copy_buffer_to_golden determines if the golden reference is replaced by another reference (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
黄金基準が別の基準（第9.7節）によって置換されている場合、O copy_buffer_to_goldenを判定する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o copy_buffer_to_alternate determines if the alternate reference is replaced by another reference (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代替的な参照は、別の参照によって置き換えられている場合に入出力copy_buffer_to_alternateを判断する（第9.7節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sign_bias_golden controls the sign of motion vectors when the golden frame is referenced (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
金色のフレームが参照されるとき、動きベクトルの符号を制御sign_bias_golden O（9.7節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sign_bias_alternate controls the sign of motion vectors when the alternate frame is referenced (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O sign_bias_alternate代替フレームを参照する動きベクトルの符号（第9.7節）を制御します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_last determines if the current decoded frame refreshes the last frame reference buffer (Section 9.8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のデコードされたフレームが最後のフレーム基準バッファー（9.8節）を更新した場合、O refresh_lastを判定する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_no_skip_coeff enables or disables the skipping of macroblocks containing no non-zero coefficients (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O mb_no_skip_coeffには非ゼロ係数（セクション9.10）を含まないマクロブロックのスキップを有効または無効
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_skip_false indicates the probability that the macroblock is not skipped (flag indicating skipped macroblock is false) (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O prob_skip_falseは、マクロブロックがスキップされない確率（スキップマクロブロックを示すフラグが偽である）（セクション9.10）を示し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_intra indicates the probability of an intra macroblock (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O prob_intraは、イントラマクロブロック（セクション9.10）の確率を示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_last indicates the probability that the last reference frame is used for inter-prediction (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O prob_lastは、最後の参照フレームは、インター予測のために使用される確率を示している（セクション9.10）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_gf indicates the probability that the golden reference frame is used for inter-prediction (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O prob_gfゴールデン参照フレームがインター予測のために使用される確率を示す（セクション9.10）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_16x16_prob_update_flag indicates if the branch probabilities used in the decoding of the luma intra-prediction mode are updated (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輝度イントラ予測モードの復号に使用される分岐確率が更新される場合、O intra_16x16_prob_update_flag（セクション9.10）を示し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_16x16_prob indicates the branch probabilities of the luma intra-prediction mode decoding tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O intra_16x16_probは、輝度イントラ予測モード復号ツリーの分岐確率を表します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_chroma_prob_update_flag indicates if the branch probabilities used in the decoding of the chroma intra-prediction mode are updated (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クロマイントラ予測モードの復号に使用される分岐確率が更新される場合、O intra_chroma_prob_update_flag（セクション9.10）を示し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_chroma_prob indicates the branch probabilities of the chroma intra-prediction mode decoding tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O intra_chroma_probは、クロマイントラ予測モード復号ツリーの分岐確率を表します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | update_segmentation()                             | Type  |
   | ------------------------------------------------- | ----- |
   | update_mb_segmentation_map                        | L(1)  |
   | update_segment_feature_data                       | L(1)  |
   | if (update_segment_feature_data) {                |       |
   |   segment_feature_mode                            | L(1)  |
   |   for (i = 0; i &lt; 4; i++) {                       |       |
   |     quantizer_update                              | L(1)  |
   |     if (quantizer_update) {                       |       |
   |       quantizer_update_value                      | L(7)  |
   |       quantizer_update_sign                       | L(1)  |
   |     }                                             |       |
   |   }                                               |       |
   |   for (i = 0; i &lt; 4; i++) {                       |       |
   |     loop_filter_update                            | L(1)  |
   |     if (loop_filter_update) {                     |       |
   |       lf_update_value                             | L(6)  |
   |       lf_update_sign                              | L(1)  |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
   | if (update_mb_segmentation_map) {                 |       |
   |   for (i = 0; i &lt; 3; i++) {                       |       |
   |     segment_prob_update                           | L(1)  |
   |     if (segment_prob_update)                      |       |
   |       segment_prob                                | L(8)  |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o update_mb_segmentation_map determines if the MB segmentation map is updated in the current frame (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MBセグメンテーションマップは、現在のフレーム（セクション9.3）に更新される場合、O update_mb_segmentation_mapを判定する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o update_segment_feature_data indicates if the segment feature data is updated in the current frame (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セグメントフィーチャデータが現在のフレームで更新された場合にO update_segment_feature_dataを示し（9.3節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_feature_mode indicates the feature data update mode, 0 for delta and 1 for the absolute value (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O segment_feature_mode絶対値についての特徴データ更新デルタためのモード、0と1を表す（9.3節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o quantizer_update indicates if the quantizer value is updated for the i^(th) segment (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
量子化値は、I ^（TH）セグメント（セクション9.3）のために更新された場合O quantizer_updateを示し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o quantizer_update_value indicates the update value for the segment quantizer (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O quantizer_update_valueは、セグメント量子化器（セクション9.3）の更新値を示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o quantizer_update_sign indicates the update sign for the segment quantizer (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O quantizer_update_signセグメント量子化器の更新記号を示す（9.3節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loop_filter_update indicates if the loop filter level value is updated for the i^(th) segment (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ループフィルタレベル値I ^（TH）セグメントのために更新された場合に入出力loop_filter_updateが示す（9.3節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o lf_update_value indicates the update value for the loop filter level (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O lf_update_valueループフィルタレベルの更新値を示している（第9.3節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o lf_update_sign indicates the update sign for the loop filter level (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O lf_update_signループフィルタレベルの更新記号を示す（9.3節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_prob_update indicates whether the branch probabilities used to decode the segment_id in the MB header are decoded from the stream or use the default value of 255 (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O segment_prob_updateは、MBヘッダにsegment_idにを復号するために使用される分岐確率は、ストリームから復号されるかどうかを示す又は255（セクション9.3）のデフォルト値を使用します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_prob indicates the branch probabilities of the segment_id decoding tree (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oのsegment_probは、segment_idにデコードツリーの分岐確率を表す（9.3節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | mb_lf_adjustments()                               | Type  |
   | ------------------------------------------------- | ----- |
   | loop_filter_adj_enable                            | L(1)  |
   | if (loop_filter_adj_enable) {                     |       |
   |   mode_ref_lf_delta_update                        | L(1)  |
   |   if (mode_ref_lf_delta_update) {                 |       |
   |     for (i = 0; i &lt; 4; i++) {                     |       |
   |       ref_frame_delta_update_flag                 | L(1)  |
   |       if (ref_frame_delta_update_flag) {          |       |
   |         delta_magnitude                           | L(6)  |
   |         delta_sign                                | L(1)  |
   |       }                                           |       |
   |     }                                             |       |
   |     for (i = 0; i &lt; 4; i++) {                     |       |
   |       mb_mode_delta_update_flag                   | L(1)  |
   |       if (mb_mode_delta_update_flag) {            |       |
   |         delta_magnitude                           | L(6)  |
   |         delta_sign                                | L(1)  |
   |       }                                           |       |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loop_filter_adj_enable indicates if the MB-level loop filter adjustment (based on the used reference frame and coding mode) is on for the current frame (Section 9.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O loop_filter_adj_enable（使用される参照フレームと符号化モードに基づいて）MB-レベルループフィルタ調整は、現在のフレーム（セクション9.4）のためであるかどうかを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mode_ref_lf_delta_update indicates if the delta values used in an adjustment are updated in the current frame (Section 9.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
調整に使用されるデルタ値は、現在のフレームで更新された場合にO mode_ref_lf_delta_updateを示し（9.4節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ref_frame_delta_update_flag indicates if the adjustment delta value corresponding to a certain used reference frame is updated (Section 9.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の使用される基準フレームに対応する補正デルタ値が更新される場合、O ref_frame_delta_update_flagを示し（9.4節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o delta_magnitude is the absolute value of the delta value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O delta_magnitudeは、デルタ値の絶対値であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o delta_sign is the sign of the delta value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O delta_signは、デルタ値の符号であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_mode_delta_update_flag indicates if the adjustment delta value corresponding to a certain MB prediction mode is updated (Section 9.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のMBの予測モードに対応する調整デルタ値が更新された場合、O mb_mode_delta_update_flag（セクション9.4）を示し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | quant_indices()                                   | Type  |
   | ------------------------------------------------- | ----- |
   | y_ac_qi                                           | L(7)  |
   | y_dc_delta_present                                | L(1)  |
   | if (y_dc_delta_present) {                         |       |
   |   y_dc_delta_magnitude                            | L(4)  |
   |   y_dc_delta_sign                                 | L(1)  |
   | }                                                 |       |
   | y2_dc_delta_present                               | L(1)  |
   | if (y2_dc_delta_present) {                        |       |
   |   y2_dc_delta_magnitude                           | L(4)  |
   |   y2_dc_delta_sign                                | L(1)  |
   | }                                                 |       |
   | y2_ac_delta_present                               | L(1)  |
   | if (y2_ac_delta_present) {                        |       |
   |   y2_ac_delta_magnitude                           | L(4)  |
   |   y2_ac_delta_sign                                | L(1)  |
   | }                                                 |       |
   | uv_dc_delta_present                               | L(1)  |
   | if (uv_dc_delta_present) {                        |       |
   |   uv_dc_delta_magnitude                           | L(4)  |
   |   uv_dc_delta_sign                                | L(1)  |
   | }                                                 |       |
   | uv_ac_delta_present                               | L(1)  |
   | if (uv_ac_delta_present) {                        |       |
   |   uv_ac_delta_magnitude                           | L(4)  |
   |   uv_ac_delta_sign                                | L(1)  |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_ac_qi is the dequantization table index used for the luma AC coefficients (and other coefficient groups if no delta value is present) (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（無デルタ値が存在しない場合には他の係数群）O y_ac_qi（セクション9.6）ルマAC係数のために使用される逆量子化テーブルのインデックスであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the luma DC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームは、輝度DC係数逆量子化インデックスを取得するために、ベースラインインデックスに追加されたデルタ値が含まれている場合、入出力y_dc_delta_presentが示す（セクション9.6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_magnitude is the magnitude of the delta value (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O y_dc_delta_magnitudeは、デルタ値（セクション9.6）の大きさであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_sign is the sign of the delta value (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O y_dc_delta_signは、デルタ値（セクション9.6）の符号であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y2_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the Y2 block DC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームは、Y2ブロックのDC係数逆量子化インデックスを取得するために、ベースラインインデックスに追加されたデルタ値が含まれている場合、入出力y2_dc_delta_presentが示す（セクション9.6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y2_ac_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the Y2 block AC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームは、Y2ブロックのAC係数逆量子化インデックスを取得するために、ベースラインインデックスに追加されたデルタ値が含まれている場合、入出力y2_ac_delta_presentが示す（セクション9.6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o uv_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the chroma DC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームは、クロマDC係数逆量子化インデックスを取得するために、ベースラインインデックスに追加されたデルタ値が含まれている場合、入出力uv_dc_delta_presentが示す（セクション9.6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o uv_ac_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the chroma AC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームは、クロマAC係数逆量子化インデックスを取得するために、ベースラインインデックスに追加されたデルタ値が含まれている場合、入出力uv_ac_delta_presentが示す（セクション9.6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | token_prob_update()                               | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = 0; i &lt; 4; i++) {                         |       |
   |   for (j = 0; j &lt; 8; j++) {                       |       |
   |     for (k = 0; k &lt; 3; k++) {                     |       |
   |       for (l = 0; l &lt; 11; l++) {                  |       |
   |         coeff_prob_update_flag                    | L(1)  |
   |         if (coeff_prob_update_flag)               |       |
   |           coeff_prob                              | L(8)  |
   |       }                                           |       |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o coeff_prob_update_flag indicates if the corresponding branch probability is updated in the current frame (Section 13.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対応する分岐確率は、現在のフレームで更新された場合に入出力coeff_prob_update_flagを示す（セクション13.4）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o coeff_prob is the new branch probability (Section 13.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O coeff_probは、新たな分岐確率（13.4）であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | mv_prob_update()                                  | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = 0; i &lt; 2; i++) {                         |       |
   |   for (j = 0; j &lt; 19; j++) {                      |       |
   |     mv_prob_update_flag                           | L(1)  |
   |     if (mv_prob_update_flag)                      |       |
   |       prob                                        | L(7)  |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_prob_update_flag indicates if the corresponding MV decoding probability is updated in the current frame (Section 17.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対応MV復号確率は、現在のフレーム（セクション17.2）で更新された場合にO mv_prob_update_flagを示し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob is the updated probability (Section 17.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PROBは、更新確率である（17.2節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.3. Macroblock Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.3。マクロデータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | Macroblock Data                                   | Type  |
   | ------------------------------------------------- | ----- |
   | macroblock_header()                               |       |
   | residual_data()                                   |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | macroblock_header()                               | Type  |
   | ------------------------------------------------- | ----- |
   | if (update_mb_segmentation_map)                   |       |
   |   segment_id                                      | T     |
   | if (mb_no_skip_coeff)                             |       |
   |   mb_skip_coeff                                   | B(p)  |
   | if (!key_frame)                                   |       |
   |   is_inter_mb                                     | B(p)  |
   | if (is_inter_mb) {                                |       |
   |   mb_ref_frame_sel1                               | B(p)  |
   |   if (mb_ref_frame_sel1)                          |       |
   |     mb_ref_frame_sel2                             | B(p)  |
   |   mv_mode                                         | T     |
   |   if (mv_mode == SPLITMV) {                       |       |
   |     mv_split_mode                                 | T     |
   |     for (i = 0; i &lt; numMvs; i++) {                |       |
   |       sub_mv_mode                                 | T     |
   |       if (sub_mv_mode == NEWMV4x4) {              |       |
   |         read_mvcomponent()                        |       |
   |         read_mvcomponent()                        |       |
   |       }                                           |       |
   |     }                                             |       |
   |   } else if (mv_mode == NEWMV) {                  |       |
   |     read_mvcomponent()                            |       |
   |     read_mvcomponent()                            |       |
   |   }                                               |       |
   | } else { /* intra mb */                           |       |
   |   intra_y_mode                                    | T     |
   |   if (intra_y_mode == B_PRED) {                   |       |
   |     for (i = 0; i &lt; 16; i++)                      |       |
   |       intra_b_mode                                | T     |
   |   }                                               |       |
   |   intra_uv_mode                                   | T     |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_id indicates to which segment the macroblock belongs (Section 10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O segment_idには、マクロブロックが属するセグメントに（セクション10）を示しています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_skip_coeff indicates whether the macroblock contains any coded coefficients or not (Section 11.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O mb_skip_coeffマクロブロックは、任意の符号化係数を含むか否かを示す（セクション11.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o is_inter_mb indicates whether the macroblock is intra- or inter-coded (Section 16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入出力is_inter_mbは、マクロブロックがイントラまたはインター符号化（セクション16）であるかどうかを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_ref_frame_sel1 selects the reference frame to be used; last frame (0), golden/alternate (1) (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O mb_ref_frame_sel1は、使用する参照フレームを選択します。最後のフレーム（0）、ゴールデン/代替（1）（セクション16.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_ref_frame_sel2 selects whether the golden (0) or alternate reference frame (1) is used (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O mb_ref_frame_sel2ゴールデン（0）又は代替の基準フレーム（1）が使用されているか否かを選択する（セクション16.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_mode determines the macroblock motion vector mode (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O mv_modeは、マクロブロックの動きベクトルモードを決定する（セクション16.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_split_mode gives the macroblock partitioning specification and determines the number of motion vectors used (numMvs) (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O mv_split_modeは、マクロブロック分割仕様を与え、（numMvs）使用される動きベクトルの数を決定する（セクション16.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sub_mv_mode determines the sub-macroblock motion vector mode for macroblocks coded using the SPLITMV motion vector mode (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O sub_mv_modeはSPLITMV動きベクトルモード（セクション16.2）を使用して符号化されたマクロブロックのサブマクロブロックの動きベクトルモードを決定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_y_mode selects the luminance intra-prediction mode (Section 16.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入出力intra_y_mode輝度イントラ予測モードを選択する（セクション16.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_b_mode selects the sub-macroblock luminance prediction mode for macroblocks coded using B_PRED mode (Section 16.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O intra_b_modeはB_PREDモード（セクション16.1）を使用して符号化されたマクロブロックのサブマクロブロック輝度予測モードを選択します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_uv_mode selects the chrominance intra-prediction mode (Section 16.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O intra_uv_modeは、色差イントラ予測モードを選択する（セクション16.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | residual_data()                                   | Type  |
   | ------------------------------------------------- | ----- |
   | if (!mb_skip_coeff) {                             |       |
   |   if ( (is_inter_mb &amp;&amp; mv_mode != SPLITMV) ||     |       |
   |        (!is_inter_mb &amp;&amp; intra_y_mode != B_PRED) ) |       |
   |     residual_block() /* Y2 */                     |       |
   |   for (i = 0; i &lt; 24; i++)                        |       |
   |     residual_block() /* 16 Y, 4 U, 4 V */         |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | residual_block()                                  | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = firstCoeff; i &lt; 16; i++) {               |       |
   |   token                                           | T     |
   |   if (token == EOB) break;                        |       |
   |   if (token_has_extra_bits)                       |       |
   |     extra_bits                                    | L(n)  |
   |   if (coefficient != 0)                           |       |
   |     sign                                          | L(1)  |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o firstCoeff is 1 for luma blocks of macroblocks containing Y2 subblock; otherwise 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O firstCoeffはY2サブブロックを含むマクロブロックの輝度ブロックに対して1です。それ以外の場合は0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o token defines the value of the coefficient, the value range of the coefficient, or the end of block (Section 13.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oトークンは、係数の値、係数の値の範囲、またはブロックの終わりを定義する（セクション13.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o extra_bits determines the value of the coefficient within the value range defined by the token (Section 13.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入出力extra_bitsトークン（セクション13.2）で定義される値の範囲内で係数の値を決定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sign indicates the sign of the coefficient (Section 13.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O記号は係数の符号を示している（セクション13.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. Attachment One: Reference Decoder Source Code
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.添付ワン：リファレンスデコーダソースコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1. bit_ops.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1。 bit_ops.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef BIT_OPS_H
   #define BIT_OPS_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Evaluates to a mask with n bits set */
   #define BITS_MASK(n) ((1&lt;&lt;(n))-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Returns len bits, with the LSB at position bit */
   #define BITS_GET(val, bit, len) (((val)&gt;&gt;(bit))&amp;BITS_MASK(len))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2. bool_decoder.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2。 bool_decoder.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef BOOL_DECODER_H
   #define BOOL_DECODER_H
   #include &lt;stddef.h&gt; struct bool_decoder
   {
       const unsigned char *input;      /* next compressed data byte */
       size_t               input_len;  /* length of the input buffer */
       unsigned int         range;      /* identical to encoder&#39;s
                                         * range */
       unsigned int         value;      /* contains at least 8
                                         * significant bits */
       int                  bit_count;  /* # of bits shifted out of
                                         * value, max 7 */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   init_bool_decoder(struct bool_decoder *d,
                     const unsigned char *start_partition,
                     size_t               sz)
   {
       if (sz &gt;= 2)
       {
           d-&gt;value = (start_partition[0] &lt;&lt; 8) /* first 2 input
                                                 * bytes */
                      | start_partition[1];
           d-&gt;input = start_partition + 2;      /* ptr to next byte */
           d-&gt;input_len = sz - 2;
       }
       else
       {
           d-&gt;value = 0;
           d-&gt;input = NULL;
           d-&gt;input_len = 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       d-&gt;range = 255;    /* initial range is full */
       d-&gt;bit_count = 0;  /* have not yet shifted out any bits */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static int bool_get(struct bool_decoder *d, int probability)
   {
       /* range and split are identical to the corresponding values
          used by the encoder when this bool was written */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       unsigned int  split = 1 + (((d-&gt;range - 1) * probability) &gt;&gt; 8);
       unsigned int  SPLIT = split &lt;&lt; 8;
       int           retval;           /* will be 0 or 1 */ if (d-&gt;value &gt;= SPLIT)    /* encoded a one */
       {
           retval = 1;
           d-&gt;range -= split;  /* reduce range */
           d-&gt;value -= SPLIT;  /* subtract off left endpoint of
                                * interval */
       }
       else                  /* encoded a zero */
       {
           retval = 0;
           d-&gt;range = split; /* reduce range, no change in left
                              * endpoint */
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       while (d-&gt;range &lt; 128)    /* shift out irrelevant value bits */
       {
           d-&gt;value &lt;&lt;= 1;
           d-&gt;range &lt;&lt;= 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (++d-&gt;bit_count == 8)  /* shift in new bits 8 at a time */
           {
               d-&gt;bit_count = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (d-&gt;input_len)
               {
                   d-&gt;value |= *d-&gt;input++;
                   d-&gt;input_len--;
               }
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return retval; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
retvalを返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static int bool_get_bit(struct bool_decoder *br)
   {
       return bool_get(br, 128);
   } static int bool_get_uint(struct bool_decoder *br, int bits)
   {
       int z = 0;
       int bit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (bit = bits - 1; bit &gt;= 0; bit--)
       {
           z |= (bool_get_bit(br) &lt;&lt; bit);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return z; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Zを返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static int bool_get_int(struct bool_decoder *br, int bits)
   {
       int z = 0;
       int bit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (bit = bits - 1; bit &gt;= 0; bit--)
       {
           z |= (bool_get_bit(br) &lt;&lt; bit);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return bool_get_bit(br) ? -z : z; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リターンbool_get_bit（BR）？ -グーグー; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static int bool_maybe_get_int(struct bool_decoder *br, int bits) { return bool_get_bit(br) ? bool_get_int(br, bits) : 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的INT bool_maybe_get_int（構造体bool_decoderの*のBR、ビットINT）{戻りbool_get_bit（BR）？ bool_get_int（BR、ビット）：0。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static int bool_read_tree(struct bool_decoder *bool, const int *t, const unsigned char *p) { int i = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的INT bool_read_tree（構造体bool_decoderの*ブール値、のconst int型* tの、CONST unsigned char型の*はP）{I 0 = int型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
while ((i = t[ i + bool_get(bool, p[i&gt;&gt;1])]) &gt; 0);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
一方、（（I =さt [iがbool_getを+（BOOL、P [I &gt;&gt; 1]）]）&gt; 0）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return -i; } #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
-i返します。 } #endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3. dequant_data.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3。 dequant_data.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const int dc_q_lookup[128] = { 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的のconst int型dc_q_lookup [128] = {4、5、6、7、8、9、10、10、11、12、13、14、15、16、17、17、18、19、20、20、21 、21、22、22、23、23、24、25、25、26、27、28、29、30、31、32、33、34、35、36、37、37、38、39、40、41 、42、43、44、45、46、46、47、48、49、50、51、52、53、54、55、56、57、58、59、60、61、62、63、64、65 、66、67、68、69、70、71、72、73、74、75、76、76、77、78、79、80、81、82、83、84、85、86、87、88、89 、91、93、95、96、98、100、101、102、104、106、108、110、112、114、116、118、122、124、126、128、130、132、134、136、138 、140、143、145、148、151、154、157}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const int ac_q_lookup[128] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[128] = {4、5、6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、21、22、23、24 ac_q_lookup静的のconst int型、25、26、27、28、29、30、31、32、33、34、35、36、37、38、39、40、41、42、43、44、45、46、47、48、49 、50、51、52、53、54、55、56、57、58、60、62、64、66、68、70、72、74、76、78、80、82、84、86、88、90 、92、94、96、98、100、102、104、106、108、110、112、114、116、119、122、125、128、131、134、137、140、143、146、149、152 、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284 };
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.4. dixie.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.4。 dixie.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;bit_ops.h&#34;
   #include &#34;dixie.h&#34;
   #include &#34;vp8_prob_data.h&#34;
   #include &#34;dequant_data.h&#34;
   #include &#34;modemv.h&#34;
   #include &#34;tokens.h&#34;
   #include &#34;predict.h&#34;
   #include &#34;dixie_loopfilter.h&#34;
   #include &lt;string.h&gt;
   #include &lt;assert.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum { FRAME_HEADER_SZ = 3, KEYFRAME_HEADER_SZ = 7 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙{FRAME_HEADER_SZ = 3、KEYFRAME_HEADER_SZ = 7}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ARRAY_COPY(a,b) {\ assert(sizeof(a)==sizeof(b));memcpy(a,b,sizeof(a));} static void decode_entropy_header(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, struct vp8_entropy_hdr *hdr)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ARRAY_COPY（B）{\アサート（のsizeof（A）==のsizeof（b）参照）;のmemcpy（A、B、はsizeof（A））;}静的ボイドdecode_entropy_header（構造体vp8_decoder_ctx * CTX、構造体bool_decoder * BOOL 、構造体vp8_entropy_hdrの*のHDR）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ int i, j, k, l;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{I、J、K、L int型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Read coefficient probability updates */
       for (i = 0; i &lt; BLOCK_TYPES; i++)
           for (j = 0; j &lt; COEFF_BANDS; j++)
               for (k = 0; k &lt; PREV_COEFF_CONTEXTS; k++)
                   for (l = 0; l &lt; ENTROPY_NODES; l++)
                       if (bool_get(bool,
                                    k_coeff_entropy_update_probs
                                        [i][j][k][l]))
                           hdr-&gt;coeff_probs[i][j][k][l] =
                               bool_get_uint(bool, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Read coefficient skip mode probability */
       hdr-&gt;coeff_skip_enabled = bool_get_bit(bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (hdr-&gt;coeff_skip_enabled) hdr-&gt;coeff_skip_prob = bool_get_uint(bool, 8);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（hdr-&gt; coeff_skip_enabled）hdr-&gt; coeff_skip_prob = bool_get_uint（BOOL、8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Parse interframe probability updates */
       if (!ctx-&gt;frame_hdr.is_keyframe)
       {
           hdr-&gt;prob_inter = bool_get_uint(bool, 8);
           hdr-&gt;prob_last  = bool_get_uint(bool, 8);
           hdr-&gt;prob_gf    = bool_get_uint(bool, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (bool_get_bit(bool))
               for (i = 0; i &lt; 4; i++)
                   hdr-&gt;y_mode_probs[i] = bool_get_uint(bool, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (bool_get_bit(bool)) for (i = 0; i &lt; 3; i++) hdr-&gt;uv_mode_probs[i] = bool_get_uint(bool, 8);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
IF（i = 0;私は（bool_get_bit（BOOL））&lt;3; iは++）hdr-&gt; uv_mode_probs [I] = bool_get_uint（BOOL、8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 2; i++)
               for (j = 0; j &lt; MV_PROB_CNT; j++)
                   if (bool_get(bool, k_mv_entropy_update_probs[i][j]))
                   {
                       int x = bool_get_uint(bool, 7);
                       hdr-&gt;mv_probs[i][j] = x ? x &lt;&lt; 1 : 1;
                   }
       }
   } static void
   decode_reference_header(struct vp8_decoder_ctx    *ctx,
                           struct bool_decoder       *bool,
                           struct vp8_reference_hdr  *hdr)
   {
       unsigned int key = ctx-&gt;frame_hdr.is_keyframe;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       hdr-&gt;refresh_gf    = key ? 1 : bool_get_bit(bool);
       hdr-&gt;refresh_arf   = key ? 1 : bool_get_bit(bool);
       hdr-&gt;copy_gf       = key ? 0 : !hdr-&gt;refresh_gf
                            ? bool_get_uint(bool, 2) : 0;
       hdr-&gt;copy_arf      = key ? 0 : !hdr-&gt;refresh_arf
                            ? bool_get_uint(bool, 2) : 0;
       hdr-&gt;sign_bias[GOLDEN_FRAME] = key ? 0 : bool_get_bit(bool);
       hdr-&gt;sign_bias[ALTREF_FRAME] = key ? 0 : bool_get_bit(bool);
       hdr-&gt;refresh_entropy = bool_get_bit(bool);
       hdr-&gt;refresh_last  = key ? 1 : bool_get_bit(bool);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   decode_quantizer_header(struct vp8_decoder_ctx    *ctx,
                           struct bool_decoder       *bool,
                           struct vp8_quant_hdr      *hdr)
   {
       int update;
       int last_q = hdr-&gt;q_index;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       hdr-&gt;q_index = bool_get_uint(bool, 7);
       update = last_q != hdr-&gt;q_index;
       update |= (hdr-&gt;y1_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;y2_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;y2_ac_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;uv_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;uv_ac_delta_q = bool_maybe_get_int(bool, 4));
       hdr-&gt;delta_update = update;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void decode_and_init_token_partitions(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, const unsigned char *data, unsigned int sz, struct vp8_token_hdr *hdr)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的な無効decode_and_init_token_partitions（構造体vp8_decoder_ctx * CTX、構造体bool_decoderの*ブール値、CONSTはunsigned char *データ、unsigned int型SZ、構造体vp8_token_hdr * HDR）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{iがint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hdr-&gt;partitions = 1 &lt;&lt; bool_get_uint(bool, 2);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hdr-&gt;パーティション= 1 &lt;&lt; bool_get_uint（BOOL、2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (sz &lt; 3 *(hdr-&gt;partitions - 1)) vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_CORRUPT_FRAME, &#34;Truncated packet found parsing partition&#34; &#34; lengths.&#34;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（SZ &lt;3 *（hdr-&gt;パーティション -  1））vpx_internal_error（＆ctx-&gt;誤差、VPX_CODEC_CORRUPT_FRAME、 &#34;長さ &#34;切り捨てパケットパーティションを解析見出さ&#34;&#34;。）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
sz -= 3 * (hdr-&gt;partitions - 1);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
SZ  -  = 3 *（hdr-&gt;パーティション -  1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; hdr-&gt;partitions; i++)
       {
           if (i &lt; hdr-&gt;partitions - 1)
           {
               hdr-&gt;partition_sz[i] = (data[2] &lt;&lt; 16)
                                      | (data[1] &lt;&lt; 8) | data[0];
               data += 3;
           }
           else
               hdr-&gt;partition_sz[i] = sz;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (sz &lt; hdr-&gt;partition_sz[i])
               vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_CORRUPT_FRAME,
                                  &#34;Truncated partition %d&#34;, i);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 sz -= hdr-&gt;partition_sz[i]; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
SZ  -  = hdr-&gt; partition_sz [I]。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; ctx-&gt;token_hdr.partitions; i++)
       {
           init_bool_decoder(&amp;ctx-&gt;tokens[i].bool, data,
                             ctx-&gt;token_hdr.partition_sz[i]);
           data += ctx-&gt;token_hdr.partition_sz[i];
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void decode_loopfilter_header(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, struct vp8_loopfilter_hdr *hdr)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的な無効decode_loopfilter_header（構造体vp8_decoder_ctx * CTX、構造体bool_decoderの*ブール値、構造体vp8_loopfilter_hdr * HDR）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ if (ctx-&gt;frame_hdr.is_keyframe) memset(hdr, 0, sizeof(*hdr));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{IF（ctx-&gt; frame_hdr.is_keyframe）のmemset（HDR、0、はsizeof（* HDR））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       hdr-&gt;use_simple    = bool_get_bit(bool);
       hdr-&gt;level         = bool_get_uint(bool, 6);
       hdr-&gt;sharpness     = bool_get_uint(bool, 3);
       hdr-&gt;delta_enabled = bool_get_bit(bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (hdr-&gt;delta_enabled &amp;&amp; bool_get_bit(bool)) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（hdr-&gt; delta_enabled &amp;&amp; bool_get_bit（BOOL））{I int型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; BLOCK_CONTEXTS; i++)
               hdr-&gt;ref_delta[i] = bool_maybe_get_int(bool, 6);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 for (i = 0; i &lt; BLOCK_CONTEXTS; i++) hdr-&gt;mode_delta[i] = bool_maybe_get_int(bool, 6); } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用（i = 0; iは&lt;BLOCK_CONTEXTSと、iは++）hdr-&gt; mode_delta [I] = bool_maybe_get_int（BOOL、6）。 }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void decode_segmentation_header(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, struct vp8_segment_hdr *hdr) { if (ctx-&gt;frame_hdr.is_keyframe) memset(hdr, 0, sizeof(*hdr));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドdecode_segmentation_header（構造体vp8_decoder_ctx * CTX、構造体bool_decoderの*ブール値、構造体vp8_segment_hdr * HDR）{IF（ctx-&gt; frame_hdr.is_keyframe）のmemset（HDR、0、はsizeof（* HDR））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hdr-&gt;enabled = bool_get_bit(bool);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hdr-&gt;有効= bool_get_bit（BOOL）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (hdr-&gt;enabled) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（hdr-&gt;有効）{iがint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           hdr-&gt;update_map = bool_get_bit(bool);
           hdr-&gt;update_data = bool_get_bit(bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (hdr-&gt;update_data) { hdr-&gt;abs = bool_get_bit(bool);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
IF（hdr-&gt; update_data）{hdr-&gt; ABS = bool_get_bit（BOOL）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (i = 0; i &lt; MAX_MB_SEGMENTS; i++)
                   hdr-&gt;quant_idx[i] = bool_maybe_get_int(bool, 7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
 for (i = 0; i &lt; MAX_MB_SEGMENTS; i++) hdr-&gt;lf_level[i] = bool_maybe_get_int(bool, 6); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
用（i = 0; iは&lt;MAX_MB_SEGMENTSと、iは++）hdr-&gt; lf_level [I] = bool_maybe_get_int（BOOL、6）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (hdr-&gt;update_map)
           {
               for (i = 0; i &lt; MB_FEATURE_TREE_PROBS; i++)
                   hdr-&gt;tree_probs[i] = bool_get_bit(bool)
                                        ? bool_get_uint(bool, 8)
                                        : 255;
           }
       }
       else
       {
           hdr-&gt;update_map = 0;
           hdr-&gt;update_data = 0;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void dequant_global_init(struct dequant_factors dqf[MAX_MB_SEGMENTS]) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドdequant_global_init（構造体dequant_factors [MAX_MB_SEGMENTS] DQF）{iはint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 for (i = 0; i &lt; MAX_MB_SEGMENTS; i++) dqf[i].quant_idx = -1; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[I] .quant_idx = -1 DQF（iは++; iはMAX_MB_SEGMENTSを&lt;I = 0）ため、 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static int
   clamp_q(int q)
   {
       if (q &lt; 0) return 0;
       else if (q &gt; 127) return 127;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return q;
   } static int
   dc_q(int q)
   {
       return dc_q_lookup[clamp_q(q)];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static int ac_q(int q) { return ac_q_lookup[clamp_q(q)]; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的INT ac_q（INT Q）{ac_q_lookup戻り[clamp_q（Q）]。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   dequant_init(struct dequant_factors        factors[MAX_MB_SEGMENTS],
                const struct vp8_segment_hdr *seg,
                const struct vp8_quant_hdr   *quant_hdr)
   {
       int i, q;
       struct dequant_factors *dqf = factors;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; (seg-&gt;enabled ? MAX_MB_SEGMENTS : 1); i++)
       {
           q = quant_hdr-&gt;q_index;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (seg-&gt;enabled)
               q = (!seg-&gt;abs) ? q + seg-&gt;quant_idx[i]
                               : seg-&gt;quant_idx[i];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (dqf-&gt;quant_idx != q || quant_hdr-&gt;delta_update)
           {
               dqf-&gt;factor[TOKEN_BLOCK_Y1][0] =
                   dc_q(q + quant_hdr-&gt;y1_dc_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_Y1][1] =
                   ac_q(q);
               dqf-&gt;factor[TOKEN_BLOCK_UV][0] =
                   dc_q(q + quant_hdr-&gt;uv_dc_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_UV][1] =
                   ac_q(q + quant_hdr-&gt;uv_ac_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_Y2][0] =
                   dc_q(q + quant_hdr-&gt;y2_dc_delta_q) * 2;
               dqf-&gt;factor[TOKEN_BLOCK_Y2][1] =
                   ac_q(q + quant_hdr-&gt;y2_ac_delta_q) * 155 / 100;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (dqf-&gt;factor[TOKEN_BLOCK_Y2][1] &lt; 8)
                   dqf-&gt;factor[TOKEN_BLOCK_Y2][1] = 8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if (dqf-&gt;factor[TOKEN_BLOCK_UV][0] &gt; 132) dqf-&gt;factor[TOKEN_BLOCK_UV][0] = 132;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
IF（dqf-&gt;因子[TOKEN_BLOCK_UV] [0]&gt; 132）dqf-&gt;因子[TOKEN_BLOCK_UV] [0] = 132。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
 dqf-&gt;quant_idx = q; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
dqf-&gt; quant_idx = Q。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 dqf++; } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DQF ++; }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   decode_frame(struct vp8_decoder_ctx *ctx,
                const unsigned char    *data,
                unsigned int            sz)
   {
       vpx_codec_err_t  res;
       struct bool_decoder  bool;
       int                  i, row, partition;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ctx-&gt;saved_entropy_valid = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ctx-&gt; saved_entropy_valid = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ((res = vp8_parse_frame_header(data, sz, &amp;ctx-&gt;frame_hdr))) vpx_internal_error(&amp;ctx-&gt;error, res, &#34;Failed to parse frame header&#34;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（（RES = vp8_parse_frame_header（データ、SZ、＆ctx-&gt; frame_hdr）））vpx_internal_error（＆ctx-&gt;誤差、RESは、 &#34;フレームヘッダの解析に失敗しました&#34;）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (ctx-&gt;frame_hdr.is_experimental) vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_UNSUP_BITSTREAM, &#34;Experimental bitstreams not supported.&#34;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
もし（ctx-&gt; frame_hdr.is_experimental）vpx_internal_error（＆ctx-&gt;エラー、VPX_CODEC_UNSUP_BITSTREAMは、 &#34;実験ビットストリームがサポートされていません。&#34;）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       data += FRAME_HEADER_SZ;
       sz -= FRAME_HEADER_SZ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.is_keyframe)
       {
           data += KEYFRAME_HEADER_SZ;
           sz -= KEYFRAME_HEADER_SZ;
           ctx-&gt;mb_cols = (ctx-&gt;frame_hdr.kf.w + 15) / 16;
           ctx-&gt;mb_rows = (ctx-&gt;frame_hdr.kf.h + 15) / 16;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Start the bitreader for the header/entropy partition */
       init_bool_decoder(&amp;bool, data, ctx-&gt;frame_hdr.part0_sz);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Skip the colorspace and clamping bits */
       if (ctx-&gt;frame_hdr.is_keyframe)
           if (bool_get_uint(&amp;bool, 2))
               vpx_internal_error(
                   &amp;ctx-&gt;error, VPX_CODEC_UNSUP_BITSTREAM,
                   &#34;Reserved bits not supported.&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       decode_segmentation_header(ctx, &amp;bool, &amp;ctx-&gt;segment_hdr);
       decode_loopfilter_header(ctx, &amp;bool, &amp;ctx-&gt;loopfilter_hdr);
       decode_and_init_token_partitions(ctx,
                                        &amp;bool,
                                        data + ctx-&gt;frame_hdr.part0_sz,
                                        sz - ctx-&gt;frame_hdr.part0_sz,
                                        &amp;ctx-&gt;token_hdr);
       decode_quantizer_header(ctx, &amp;bool, &amp;ctx-&gt;quant_hdr);
       decode_reference_header(ctx, &amp;bool, &amp;ctx-&gt;reference_hdr);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Set keyframe entropy defaults.  These get updated on keyframes
        * regardless of the refresh_entropy setting.
        */
       if (ctx-&gt;frame_hdr.is_keyframe)
       {
           ARRAY_COPY(ctx-&gt;entropy_hdr.coeff_probs,
                      k_default_coeff_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.mv_probs,
                      k_default_mv_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.y_mode_probs,
                      k_default_y_mode_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.uv_mode_probs,
                      k_default_uv_mode_probs);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (!ctx-&gt;reference_hdr.refresh_entropy)
       {
           ctx-&gt;saved_entropy = ctx-&gt;entropy_hdr;
           ctx-&gt;saved_entropy_valid = 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
decode_entropy_header(ctx, &amp;bool, &amp;ctx-&gt;entropy_hdr);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
decode_entropy_header（CTX、＆ブール、＆ctx-&gt; entropy_hdr）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       vp8_dixie_modemv_init(ctx);
       vp8_dixie_tokens_init(ctx);
       vp8_dixie_predict_init(ctx);
       dequant_init(ctx-&gt;dequant_factors, &amp;ctx-&gt;segment_hdr,
                    &amp;ctx-&gt;quant_hdr);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (row = 0, partition = 0; row &lt; ctx-&gt;mb_rows; row++)
       {
           vp8_dixie_modemv_process_row(
               ctx, &amp;bool, row, 0, ctx-&gt;mb_cols);
           vp8_dixie_tokens_process_row(ctx, partition, row, 0,
                                        ctx-&gt;mb_cols);
           vp8_dixie_predict_process_row(ctx, row, 0, ctx-&gt;mb_cols);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (ctx-&gt;loopfilter_hdr.level &amp;&amp; row)
               vp8_dixie_loopfilter_process_row(ctx, row - 1, 0,
                                                ctx-&gt;mb_cols);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 if (++partition == ctx-&gt;token_hdr.partitions) partition = 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（++パーティション== ctx-&gt; token_hdr.partitions）パーティション= 0。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (ctx-&gt;loopfilter_hdr.level) vp8_dixie_loopfilter_process_row( ctx, row - 1, 0, ctx-&gt;mb_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（ctx-&gt; loopfilter_hdr.level）vp8_dixie_loopfilter_process_row（CTX、行 -  1、0、ctx-&gt; mb_cols）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ctx-&gt;frame_cnt++;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ctx-&gt; frame_cnt ++;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (!ctx-&gt;reference_hdr.refresh_entropy)
       {
           ctx-&gt;entropy_hdr = ctx-&gt;saved_entropy;
           ctx-&gt;saved_entropy_valid = 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Handle reference frame updates */
       if (ctx-&gt;reference_hdr.copy_arf == 1)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
       }
       else if (ctx-&gt;reference_hdr.copy_arf == 2)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.copy_gf == 1)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
       } else if (ctx-&gt;reference_hdr.copy_gf == 2)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_gf)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_arf)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_last)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
           ctx-&gt;ref_frames[LAST_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_decode_init(struct vp8_decoder_ctx *ctx) { dequant_global_init(ctx-&gt;dequant_factors); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボイドvp8_dixie_decode_init（構造体vp8_decoder_ctx * CTX）{dequant_global_init（ctx-&gt; dequant_factors）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define CHECK_FOR_UPDATE(lval,rval,update_flag) do {\ unsigned int old = lval; \ update_flag |= (old != (lval = rval)); \ } while (0)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define CHECK_FOR_UPDATE（LVAL、rvalに、update_flagは）LVAL = unsigned int型の古い\ {行います。 \ update_flag | =（古い=（LVAL = rvalに）！）。 \}（0）、一方
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_parse_frame_header(const unsigned char *data, unsigned int sz, struct vp8_frame_hdr *hdr) { unsigned long raw;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_parse_frame_header（CONSTはunsigned char *データ、unsigned int型SZ、構造体vp8_frame_hdr * HDR）{unsigned long型生。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (sz &lt; 10)
           return VPX_CODEC_CORRUPT_FRAME;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* The frame header is defined as a three-byte little endian
        * value
        */
       raw = data[0] | (data[1] &lt;&lt; 8) | (data[2] &lt;&lt; 16);
       hdr-&gt;is_keyframe     = !BITS_GET(raw, 0, 1);
       hdr-&gt;version         = BITS_GET(raw, 1, 2);
       hdr-&gt;is_experimental = BITS_GET(raw, 3, 1);
       hdr-&gt;is_shown        = BITS_GET(raw, 4, 1);
       hdr-&gt;part0_sz        = BITS_GET(raw, 5, 19);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (sz &lt;= hdr-&gt;part0_sz + (hdr-&gt;is_keyframe ? 10 : 3)) return VPX_CODEC_CORRUPT_FRAME;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（SZ &lt;= hdr-&gt; part0_sz +（hdr-&gt; is_keyframe 10：3））戻りVPX_CODEC_CORRUPT_FRAME。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hdr-&gt;frame_size_updated = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hdr-&gt; frame_size_updated = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (hdr-&gt;is_keyframe) { unsigned int update = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（hdr-&gt; is_keyframe）{unsigned int型アップデート= 0の場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Keyframe header consists of a three-byte sync code
            * followed by the width and height and associated scaling
            * factors.
            */
           if (data[3] != 0x9d || data[4] != 0x01 || data[5] != 0x2a)
               return VPX_CODEC_UNSUP_BITSTREAM;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           raw = data[6] | (data[7] &lt;&lt; 8)
                 | (data[8] &lt;&lt; 16) | (data[9] &lt;&lt; 24);
           CHECK_FOR_UPDATE(hdr-&gt;kf.w,       BITS_GET(raw,  0, 14),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.scale_w, BITS_GET(raw, 14,  2),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.h,       BITS_GET(raw, 16, 14),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.scale_h, BITS_GET(raw, 30,  2),
                            update);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
hdr-&gt;frame_size_updated = update;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
hdr-&gt; frame_size_updated =更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 if (!hdr-&gt;kf.w || !hdr-&gt;kf.h) return VPX_CODEC_UNSUP_BITSTREAM; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（！hdr-&gt; kf.w || hdr-&gt; kf.h）であれば、戻りVPX_CODEC_UNSUP_BITSTREAM。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return VPX_CODEC_OK; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VPX_CODEC_OKを返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_dixie_decode_frame(struct vp8_decoder_ctx *ctx, const unsigned char *data, unsigned int sz) { volatile struct vp8_decoder_ctx *ctx_ = ctx;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_dixie_decode_frame（構造体vp8_decoder_ctx * CTX、CONSTはunsigned char *データ、unsigned int型SZ）{揮発性構造体vp8_decoder_ctx * CTX_ = CTX。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ctx-&gt;error.error_code = VPX_CODEC_OK;
       ctx-&gt;error.has_detail = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (!setjmp(ctx-&gt;error.jmp)) decode_frame(ctx, data, sz);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
もし（！のsetjmp（ctx-&gt; error.jmp））decode_frame（CTX、データ、SZ）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return ctx_-&gt;error.error_code; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CTX _-&gt; error.error_code返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void
   vp8_dixie_decode_destroy(struct vp8_decoder_ctx *ctx)
   {
       vp8_dixie_predict_destroy(ctx);
       vp8_dixie_tokens_destroy(ctx);
       vp8_dixie_modemv_destroy(ctx);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.5. dixie.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.5。低い。また、
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef DIXIE_H
   #define DIXIE_H
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;bool_decoder.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vp8_frame_hdr
   {
       unsigned int is_keyframe;      /* Frame is a keyframe */
       unsigned int is_experimental;  /* Frame is a keyframe */
       unsigned int version;          /* Bitstream version */
       unsigned int is_shown;         /* Frame is to be displayed. */
       unsigned int part0_sz;         /* Partition 0 length, in bytes */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct vp8_kf_hdr
       {
           unsigned int w;        /* Width */
           unsigned int h;        /* Height */
           unsigned int scale_w;  /* Scaling factor, Width */
           unsigned int scale_h;  /* Scaling factor, Height */
       } kf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       unsigned int frame_size_updated; /* Flag to indicate a resolution
                                         * update.
                                         */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum { MB_FEATURE_TREE_PROBS = 3, MAX_MB_SEGMENTS = 4 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙{MB_FEATURE_TREE_PROBS = 3、MAX_MB_SEGMENTS = 4}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vp8_segment_hdr
   {
       unsigned int         enabled;
       unsigned int         update_data;
       unsigned int         update_map;
       unsigned int         abs;    /* 0=deltas, 1=absolute values */
       unsigned int         tree_probs[MB_FEATURE_TREE_PROBS];
       int                  lf_level[MAX_MB_SEGMENTS];
       int                  quant_idx[MAX_MB_SEGMENTS];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum { BLOCK_CONTEXTS = 4 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙{BLOCK_CONTEXTS = 4}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vp8_loopfilter_hdr
   {
       unsigned int         use_simple;
       unsigned int         level;
       unsigned int         sharpness;
       unsigned int         delta_enabled;
       int                  ref_delta[BLOCK_CONTEXTS];
       int                  mode_delta[BLOCK_CONTEXTS];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum { MAX_PARTITIONS = 8 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙{MAX_PARTITIONS = 8}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vp8_token_hdr
   {
       unsigned int        partitions;
       unsigned int        partition_sz[MAX_PARTITIONS];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vp8_quant_hdr
   {
       unsigned int       q_index;
       int                delta_update;
       int                y1_dc_delta_q;
       int                y2_dc_delta_q;
       int                y2_ac_delta_q;
       int                uv_dc_delta_q;
       int                uv_ac_delta_q;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vp8_reference_hdr
   {
       unsigned int refresh_last;
       unsigned int refresh_gf;
       unsigned int refresh_arf;
       unsigned int copy_gf;
       unsigned int copy_arf;
       unsigned int sign_bias[4];
       unsigned int refresh_entropy;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum
   {
       BLOCK_TYPES        = 4,
       PREV_COEFF_CONTEXTS = 3,
       COEFF_BANDS         = 8,
       ENTROPY_NODES      = 11,
   };
   typedef unsigned char coeff_probs_table_t[BLOCK_TYPES][COEFF_BANDS]
   [PREV_COEFF_CONTEXTS]
   [ENTROPY_NODES];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum
   {
       MV_PROB_CNT = 2 + 8 - 1 + 10 /* from entropymv.h */
   };
   typedef unsigned char mv_component_probs_t[MV_PROB_CNT];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vp8_entropy_hdr
   {
       coeff_probs_table_t   coeff_probs;
       mv_component_probs_t  mv_probs[2];
       unsigned int          coeff_skip_enabled;
       unsigned char         coeff_skip_prob;
       unsigned char         y_mode_probs[4];
       unsigned char         uv_mode_probs[3];
       unsigned char         prob_inter;
       unsigned char         prob_last;
       unsigned char         prob_gf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum reference_frame { CURRENT_FRAME, LAST_FRAME, GOLDEN_FRAME, ALTREF_FRAME, NUM_REF_FRAMES };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙reference_frame {CURRENT_FRAME、LAST_FRAME、GOLDEN_FRAME、ALTREF_FRAME、NUM_REF_FRAMES}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum prediction_mode
   {
       /* 16x16 intra modes */
       DC_PRED, V_PRED, H_PRED, TM_PRED, B_PRED,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* 16x16 inter modes */
       NEARESTMV, NEARMV, ZEROMV, NEWMV, SPLITMV,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
MB_MODE_COUNT,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
MB_MODE_COUNT、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* 4x4 intra modes */
       B_DC_PRED = 0, B_TM_PRED, B_VE_PRED, B_HE_PRED, B_LD_PRED,
       B_RD_PRED, B_VR_PRED, B_VL_PRED, B_HD_PRED, B_HU_PRED,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* 4x4 inter modes */
       LEFT4X4, ABOVE4X4, ZERO4X4, NEW4X4,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 B_MODE_COUNT };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B_MODE_COUNT}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum splitmv_partitioning { SPLITMV_16X8, SPLITMV_8X16, SPLITMV_8X8, SPLITMV_4X4 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙splitmv_partitioning {SPLITMV_16X8、SPLITMV_8X16、SPLITMV_8X8、SPLITMV_4X4}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef short filter_t[6];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefの短いfilter_t [6]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef union mv
   {
       struct
       {
           int16_t x, y;
       }  d;
       uint32_t               raw;
   } mv_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct mb_base_info
   {
       unsigned char y_mode     : 4;
       unsigned char uv_mode    : 4;
       unsigned char segment_id : 2;
       unsigned char ref_frame  : 2;
       unsigned char skip_coeff : 1;
       unsigned char need_mc_border : 1;
       enum splitmv_partitioning  partitioning : 2;
       union mv      mv;
       unsigned int  eob_mask;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct mb_info
   {
       struct mb_base_info base;
       union
       {
           union mv              mvs[16];
           enum prediction_mode  modes[16];
       } split;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* A &#34;token entropy context&#34; has 4 Y values, 2 U, 2 V, and 1 Y2 */
   typedef int token_entropy_ctx_t[4 + 2 + 2 + 1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct token_decoder
   {
       struct bool_decoder  bool;
       token_entropy_ctx_t  left_token_entropy_ctx;
       short               *coeffs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum token_block_type { TOKEN_BLOCK_Y1, TOKEN_BLOCK_UV, TOKEN_BLOCK_Y2, TOKEN_BLOCK_TYPES, };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙token_block_type {TOKEN_BLOCK_Y1、TOKEN_BLOCK_UV、TOKEN_BLOCK_Y2、TOKEN_BLOCK_TYPES、}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dequant_factors
   {
       int   quant_idx;
       short factor[TOKEN_BLOCK_TYPES][2]; /* [ Y1, UV, Y2 ]
                                            * [ DC, AC ] */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ref_cnt_img
   {
       vpx_image_t  img;
       unsigned int ref_cnt;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vp8_decoder_ctx
   {
       struct vpx_internal_error_info  error;
       unsigned int                    frame_cnt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct vp8_frame_hdr            frame_hdr;
       struct vp8_segment_hdr          segment_hdr;
       struct vp8_loopfilter_hdr       loopfilter_hdr;
       struct vp8_token_hdr            token_hdr;
       struct vp8_quant_hdr            quant_hdr;
       struct vp8_reference_hdr        reference_hdr;
       struct vp8_entropy_hdr          entropy_hdr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct vp8_entropy_hdr          saved_entropy;
       unsigned int                    saved_entropy_valid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       unsigned int                    mb_rows;
       unsigned int                    mb_cols;
       struct mb_info                 *mb_info_storage;
       struct mb_info                **mb_info_rows_storage;
       struct mb_info                **mb_info_rows;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       token_entropy_ctx_t            *above_token_entropy_ctx;
       struct token_decoder            tokens[MAX_PARTITIONS];
       struct dequant_factors          dequant_factors[MAX_MB_SEGMENTS];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct ref_cnt_img              frame_strg[NUM_REF_FRAMES];
       struct ref_cnt_img             *ref_frames[NUM_REF_FRAMES];
       ptrdiff_t                       ref_frame_offsets[4];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       const filter_t                 *subpixel_filters;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_decode_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_decode_init（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_decode_destroy(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_decode_destroy（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_parse_frame_header(const unsigned char *data, unsigned int sz, struct vp8_frame_hdr *hdr);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_parse_frame_header（CONSTはunsigned char *データ、unsigned int型SZ、構造体vp8_frame_hdr * HDR）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_dixie_decode_frame(struct vp8_decoder_ctx *ctx, const unsigned char *data, unsigned int sz);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_dixie_decode_frame（構造体vp8_decoder_ctx * CTX、CONSTはunsigned char *データ、unsigned int型SZ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define CLAMP_255(x) ((x)&lt;0?0:((x)&gt;255?255:(x)))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define CLAMP_255（x）は（（X）&lt;0：？（（X）&gt; 255 255：？（X）））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6. dixie_loopfilter.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6。 dixie_loopfilter.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;dixie_loopfilter.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ABS(x) ((x) &gt;= 0 ? (x) : -(x))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ABS（X）（（X）&gt; = 0（X）： - （X））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define p3 pixels[-4*stride] #define p2 pixels[-3*stride] #define p1 pixels[-2*stride] #define p0 pixels[-1*stride] #define q0 pixels[ 0*stride] #define q1 pixels[ 1*stride] #define q2 pixels[ 2*stride] #define q3 pixels[ 3*stride]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define P3画素[-4 *ストライド]の#define P2画素[-3 *ストライド]の#define P1画素[-2 *ストライド]の#define P0画素[-1 *ストライド]の#define Q0画素[0 *ストライド]＃ Q1の画素を定義する[1 *ストライド]の#define Q2画素[2 *ストライド]の#define Q3画素[3 *ストライド]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define static static int
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define静的な静的int型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
saturate_int8(int x) { if (x &lt; -128) return -128;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
saturate_int8（INT X）{IF（X &lt;-128）-128を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (x &gt; 127)
           return 127;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return x;
   } static int
   saturate_uint8(int x)
   {
       if (x &lt; 0)
           return 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (x &gt; 255)
           return 255;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return x; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Xを返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static int high_edge_variance(unsigned char *pixels, int stride, int hev_threshold) { return ABS(p1 - p0) &gt; hev_threshold || ABS(q1 - q0) &gt; hev_threshold; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的INT high_edge_variance（unsigned char型*画素、INTストライド、int型hev_threshold）{戻りABS（P1  -  P0）&gt; hev_threshold || ABS（Q1  -  Q0）&gt; hev_threshold。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static int simple_threshold(unsigned char *pixels, int stride, int filter_limit) { return (ABS(p0 - q0) * 2 + (ABS(p1 - q1) &gt;&gt; 1)) &lt;= filter_limit; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的INT simple_threshold（unsigned char型*画素、INTストライド、int型filter_limit）{リターン（ABS（P0  -  Q0）* 2 +（ABS（P1  -  Q1）&gt;&gt; 1））&lt;= filter_limit。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static int
   normal_threshold(unsigned char *pixels,
                    int            stride,
                    int            edge_limit,
                    int            interior_limit)
   {
       int E = edge_limit;
       int I = interior_limit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return simple_threshold(pixels, stride, 2 * E + I)
              &amp;&amp; ABS(p3 - p2) &lt;= I &amp;&amp; ABS(p2 - p1) &lt;= I
              &amp;&amp; ABS(p1 - p0) &lt;= I &amp;&amp; ABS(q3 - q2) &lt;= I
              &amp;&amp; ABS(q2 - q1) &lt;= I &amp;&amp; ABS(q1 - q0) &lt;= I;
   } static void
   filter_common(unsigned char *pixels,
                 int            stride,
                 int            use_outer_taps)
   {
       int a, f1, f2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
a = 3 * (q0 - p0);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
= 3 *（Q0  -  P0）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (use_outer_taps) a += saturate_int8(p1 - q1);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（use_outer_taps）、A + = saturate_int8（P1  -  Q1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
a = saturate_int8(a);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
A = saturate_int8（A）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       f1 = ((a + 4 &gt; 127) ? 127 : a + 4) &gt;&gt; 3;
       f2 = ((a + 3 &gt; 127) ? 127 : a + 3) &gt;&gt; 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       p0 = saturate_uint8(p0 + f2);
       q0 = saturate_uint8(q0 - f1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (!use_outer_taps)
       {
           /* This handles the case of subblock_filter()
            * (from the bitstream guide.
            */
           a = (f1 + 1) &gt;&gt; 1;
           p1 = saturate_uint8(p1 + a);
           q1 = saturate_uint8(q1 - a);
       }
   } static void
   filter_mb_edge(unsigned char *pixels,
                  int            stride)
   {
       int w, a;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
w = saturate_int8(saturate_int8(p1 - q1) + 3 * (q0 - p0));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
W = saturate_int8（saturate_int8（P1  -  Q1）+ 3 *（Q0  -  P0））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       a = (27 * w + 63) &gt;&gt; 7;
       p0 = saturate_uint8(p0 + a);
       q0 = saturate_uint8(q0 - a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       a = (18 * w + 63) &gt;&gt; 7;
       p1 = saturate_uint8(p1 + a);
       q1 = saturate_uint8(q1 - a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       a = (9 * w + 63) &gt;&gt; 7;
       p2 = saturate_uint8(p2 + a);
       q2 = saturate_uint8(q2 - a);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void filter_mb_v_edge(unsigned char *src, int stride, int edge_limit, int interior_limit, int hev_threshold, int size) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドfilter_mb_v_edge（unsigned char型の*のSRC、int型のストライド、int型edge_limit、int型interior_limit、int型hev_threshold、int型のサイズ）{私はint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, 1, edge_limit, interior_limit))
           {
               if (high_edge_variance(src, 1, hev_threshold))
                   filter_common(src, 1, 1);
               else
                   filter_mb_edge(src, 1);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           src += stride;
       }
   } static void
   filter_subblock_v_edge(unsigned char *src,
                          int            stride,
                          int            edge_limit,
                          int            interior_limit,
                          int            hev_threshold,
                          int            size)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, 1, edge_limit, interior_limit))
               filter_common(src, 1,
                             high_edge_variance(src, 1, hev_threshold));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 src += stride; } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRC + =ストライド。 }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void filter_mb_h_edge(unsigned char *src, int stride, int edge_limit, int interior_limit, int hev_threshold, int size) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドfilter_mb_h_edge（unsigned char型の*のSRC、int型のストライド、int型edge_limit、int型interior_limit、int型hev_threshold、int型のサイズ）{私はint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, stride, edge_limit,
                                interior_limit))
           {
               if (high_edge_variance(src, stride, hev_threshold))
                   filter_common(src, stride, 1);
               else
                   filter_mb_edge(src, stride);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           src += 1;
       }
   } static void
   filter_subblock_h_edge(unsigned char *src,
                          int            stride,
                          int            edge_limit,
                          int            interior_limit,
                          int            hev_threshold,
                          int            size)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, stride, edge_limit,
                                interior_limit))
               filter_common(src, stride,
                             high_edge_variance(src, stride,
                                                hev_threshold));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 src += 1; } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRC + = 1; }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void filter_v_edge_simple(unsigned char *src, int stride, int filter_limit) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的な無効filter_v_edge_simple（unsigned char型の*のSRC、int型のストライド、int型のfilter_limit）{int型I;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
       {
           if (simple_threshold(src, 1, filter_limit))
               filter_common(src, 1, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           src += stride;
       }
   } static void
   filter_h_edge_simple(unsigned char *src,
                        int            stride,
                        int            filter_limit)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
       {
           if (simple_threshold(src, stride, filter_limit))
               filter_common(src, stride, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 src += 1; } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRC + = 1; }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void calculate_filter_parameters(struct vp8_decoder_ctx *ctx, struct mb_info *mbi, int *edge_limit_, int *interior_limit_, int *hev_threshold_) { int filter_level, interior_limit, hev_threshold;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドcalculate_filter_parameters（構造体vp8_decoder_ctx * CTX、構造体mb_info * MBI、INT * edge_limit_、INT * interior_limit_、INT * hev_threshold_）{int型filter_level、interior_limit、hev_threshold。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Reference code/spec seems to conflate filter_level and
        * edge_limit
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
filter_level = ctx-&gt;loopfilter_hdr.level;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
filter_level CTX- =&gt; loopfilter_hdr.level。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;segment_hdr.enabled)
       {
           if (!ctx-&gt;segment_hdr.abs)
               filter_level +=
                   ctx-&gt;segment_hdr.lf_level[mbi-&gt;base.segment_id];
           else
               filter_level =
                   ctx-&gt;segment_hdr.lf_level[mbi-&gt;base.segment_id];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (filter_level &gt; 63)
           filter_level = 63;
       else if (filter_level &lt; 0)
           filter_level = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (ctx-&gt;loopfilter_hdr.delta_enabled) { filter_level += ctx-&gt;loopfilter_hdr.ref_delta[mbi-&gt;base.ref_frame];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（ctx-&gt; loopfilter_hdr.delta_enabled）{filter_level + = ctx-&gt; loopfilter_hdr.ref_delta [mbi-&gt; base.ref_frame]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (mbi-&gt;base.ref_frame == CURRENT_FRAME)
           {
               if (mbi-&gt;base.y_mode == B_PRED)
                   filter_level += ctx-&gt;loopfilter_hdr.mode_delta[0];
           }
           else if (mbi-&gt;base.y_mode == ZEROMV)
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[1];
           else if (mbi-&gt;base.y_mode == SPLITMV)
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[3];
           else
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[2];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (filter_level &gt; 63)
           filter_level = 63;
       else if (filter_level &lt; 0)
           filter_level = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
interior_limit = filter_level;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
interior_limit = filter_level。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (ctx-&gt;loopfilter_hdr.sharpness) { interior_limit &gt;&gt;= ctx-&gt;loopfilter_hdr.sharpness &gt; 4 ? 2 : 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（ctx-&gt; loopfilter_hdr.sharpness）{interior_limit &gt;&gt; = ctx-&gt; loopfilter_hdr.sharpness&gt; 4であれば？ 2：1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 if (interior_limit &gt; 9 - ctx-&gt;loopfilter_hdr.sharpness) interior_limit = 9 - ctx-&gt;loopfilter_hdr.sharpness; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（interior_limit&gt; 9  -  ctx-&gt; loopfilter_hdr.sharpness）interior_limit = 9  -  ctx-&gt; loopfilter_hdr.sharpness。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (interior_limit &lt; 1) interior_limit = 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（interior_limit &lt;1）interior_limit = 1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hev_threshold = (filter_level &gt;= 15);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hev_threshold =（filter_level&gt; = 15）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (filter_level &gt;= 40) hev_threshold++;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hev_threshold ++ IF（&gt; = 40 filter_level）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (filter_level &gt;= 20 &amp;&amp; !ctx-&gt;frame_hdr.is_keyframe) hev_threshold++;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（もし！filter_level&gt; = 20 &amp;&amp; ctx-&gt; frame_hdr.is_keyframe）hev_threshold ++;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       *edge_limit_ = filter_level;
       *interior_limit_ = interior_limit;
       *hev_threshold_ = hev_threshold;
   } static void
   filter_row_normal(struct vp8_decoder_ctx *ctx,
                     unsigned int            row,
                     unsigned int            start_col,
                     unsigned int            num_cols)
   {
       unsigned char  *y, *u, *v;
       int             stride, uv_stride;
       struct mb_info *mbi;
       unsigned int    col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       stride    = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       uv_stride = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_U];
       y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       u = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_U];
       v = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_V];
       y += (stride * row + start_col) * 16;
       u += (uv_stride * row + start_col) * 8;
       v += (uv_stride * row + start_col) * 8;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
for (col = start_col; col &lt; start_col + num_cols; col++) { int edge_limit, interior_limit, hev_threshold;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
用（COL = start_col; COL &lt;start_col + NUM_COLS; COL ++）{int型edge_limit、interior_limit、hev_threshold。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* TODO: Only need to recalculate every MB if segmentation is
            * enabled.
            */
           calculate_filter_parameters(ctx, mbi, &amp;edge_limit,
                                       &amp;interior_limit, &amp;hev_threshold);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (edge_limit)
           {
               if (col)
               {
                   filter_mb_v_edge(y, stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 2);
                   filter_mb_v_edge(u, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
                   filter_mb_v_edge(v, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* NOTE: This conditional is actually dependent on the
                * number of coefficients decoded, not the skip flag as
                * coded in the bitstream.  The tokens task is expected
                * to set 31 if there is *any* non-zero data.
                */
               if (mbi-&gt;base.eob_mask
                   || mbi-&gt;base.y_mode == SPLITMV
                   || mbi-&gt;base.y_mode == B_PRED)
               {
                   filter_subblock_v_edge(y + 4, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(y + 8, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(y + 12, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(u + 4, uv_stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          1);
                   filter_subblock_v_edge(v + 4, uv_stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          1);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (row)
               {
                   filter_mb_h_edge(y, stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 2);
                   filter_mb_h_edge(u, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
                   filter_mb_h_edge(v, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
               } if (mbi-&gt;base.eob_mask
                   || mbi-&gt;base.y_mode == SPLITMV
                   || mbi-&gt;base.y_mode == B_PRED)
               {
                   filter_subblock_h_edge(y + 4 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(y + 8 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(y + 12 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(u + 4 * uv_stride, uv_stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 1);
                   filter_subblock_h_edge(v + 4 * uv_stride, uv_stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 1);
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           y += 16;
           u += 8;
           v += 8;
           mbi++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   filter_row_simple(struct vp8_decoder_ctx *ctx,
                     unsigned int            row,
                     unsigned int            start_col,
                     unsigned int            num_cols)
   {
       unsigned char  *y;
       int             stride;
       struct mb_info *mbi;
       unsigned int    col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
       stride    = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       y += (stride * row + start_col) * 16;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
for (col = start_col; col &lt; start_col + num_cols; col++) { int edge_limit, interior_limit, hev_threshold;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
用（COL = start_col; COL &lt;start_col + NUM_COLS; COL ++）{int型edge_limit、interior_limit、hev_threshold。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* TODO: Only need to recalculate every MB if segmentation is
            * enabled.
            */
           calculate_filter_parameters(ctx, mbi, &amp;edge_limit,
                                       &amp;interior_limit, &amp;hev_threshold);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (edge_limit) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
IF（edge_limit）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* NOTE: This conditional is actually dependent on the
                * number of coefficients decoded, not the skip flag as
                * coded in the bitstream.  The tokens task is expected
                * to set 31 if there is *any* non-zero data.
                */
               int filter_subblocks = (mbi-&gt;base.eob_mask
                                       || mbi-&gt;base.y_mode == SPLITMV
                                       || mbi-&gt;base.y_mode == B_PRED);
               int mb_limit = (edge_limit + 2) * 2 + interior_limit;
               int b_limit = edge_limit * 2 + interior_limit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if (col) filter_v_edge_simple(y, stride, mb_limit);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
（COL）filter_v_edge_simple（Y、ストライド、mb_limit）であれば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (filter_subblocks)
               {
                   filter_v_edge_simple(y + 4, stride, b_limit);
                   filter_v_edge_simple(y + 8, stride, b_limit);
                   filter_v_edge_simple(y + 12, stride, b_limit);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if (row) filter_h_edge_simple(y, stride, mb_limit);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
（行）filter_h_edge_simple（Y、ストライド、mb_limit）であれば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (filter_subblocks)
               {
                   filter_h_edge_simple(y + 4 * stride, stride,
                                        b_limit);
                   filter_h_edge_simple(y + 8 * stride, stride,
                                        b_limit);
                   filter_h_edge_simple(y + 12 * stride, stride,
                                        b_limit);
               }
           } y += 16;
           mbi++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void
   vp8_dixie_loopfilter_process_row(struct vp8_decoder_ctx *ctx,
                                    unsigned int            row,
                                    unsigned int            start_col,
                                    unsigned int            num_cols)
   {
       if (ctx-&gt;loopfilter_hdr.use_simple)
           filter_row_simple(ctx, row, start_col, num_cols);
       else
           filter_row_normal(ctx, row, start_col, num_cols);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.7. dixie_loopfilter.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.7。 dixie_loopfilter.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef DIXIE_LOOPFILTER_H
   #define DIXIE_LOOPFILTER_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_loopfilter_process_row(struct vp8_decoder_ctx *ctx, unsigned int row, unsigned int start_col, unsigned int num_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボイドvp8_dixie_loopfilter_process_row（構造体vp8_decoder_ctx * CTX、unsigned int型の行、unsigned int型start_col、unsigned int型NUM_COLS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8. idct_add.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8。 idct_add.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;idct_add.h&#34;
   #include &lt;assert.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void
   vp8_dixie_walsh(const short *input, short *output)
   {
       int i;
       int a1, b1, c1, d1;
       int a2, b2, c2, d2;
       const short *ip = input;
       short *op = output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[12];
           b1 = ip[4] + ip[8];
           c1 = ip[4] - ip[8];
           d1 = ip[0] - ip[12];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           op[0] = a1 + b1;
           op[4] = c1 + d1;
           op[8] = a1 - b1;
           op[12] = d1 - c1;
           ip++;
           op++;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ip = output;
       op = output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[3];
           b1 = ip[1] + ip[2];
           c1 = ip[1] - ip[2];
           d1 = ip[0] - ip[3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           a2 = a1 + b1;
           b2 = c1 + d1;
           c2 = a1 - b1;
           d2 = d1 - c1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           op[0] = (a2 + 3) &gt;&gt; 3;
           op[1] = (b2 + 3) &gt;&gt; 3;
           op[2] = (c2 + 3) &gt;&gt; 3;
           op[3] = (d2 + 3) &gt;&gt; 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           ip += 4;
           op += 4;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define cospi8sqrt2minus1 20091
   #define sinpi8sqrt2       35468
   #define rounding          0
   static void
   idct_columns(const short *input, short *output)
   {
       int i;
       int a1, b1, c1, d1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       const short *ip = input;
       short *op = output;
       int temp1, temp2;
       int shortpitch = 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[8];
           b1 = ip[0] - ip[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           temp1 = (ip[4] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           temp2 = ip[12] +
               ((ip[12] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           c1 = temp1 - temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           temp1 = ip[4] +
               ((ip[4] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           temp2 = (ip[12] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           d1 = temp1 + temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           op[shortpitch*0] = a1 + d1;
           op[shortpitch*3] = a1 - d1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           op[shortpitch*1] = b1 + c1;
           op[shortpitch*2] = b1 - c1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           ip++;
           op++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void
   vp8_dixie_idct_add(unsigned char        *recon,
                      const unsigned char  *predict,
                      int                   stride,
                      const short          *coeffs)
   {
       int i;
       int a1, b1, c1, d1, temp1, temp2;
       short tmp[16];
       idct_columns(coeffs, tmp);
       coeffs = tmp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = coeffs[0] + coeffs[2];
           b1 = coeffs[0] - coeffs[2];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           temp1 = (coeffs[1] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           temp2 = coeffs[3] +
               ((coeffs[3] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           c1 = temp1 - temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           temp1 = coeffs[1] +
               ((coeffs[1] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           temp2 = (coeffs[3] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           d1 = temp1 + temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           recon[0] = CLAMP_255(predict[0] + ((a1 + d1 + 4) &gt;&gt; 3));
           recon[3] = CLAMP_255(predict[3] + ((a1 - d1 + 4) &gt;&gt; 3));
           recon[1] = CLAMP_255(predict[1] + ((b1 + c1 + 4) &gt;&gt; 3));
           recon[2] = CLAMP_255(predict[2] + ((b1 - c1 + 4) &gt;&gt; 3));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           coeffs += 4;
           recon += stride;
           predict += stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.9. idct_add.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.9。 idct_add.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef IDCT_ADD_H
   #define IDCT_ADD_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_idct_add_init（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add(unsigned char *recon, const unsigned char *predict, int stride, const short *coeffs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_idct_add（unsigned char型*偵察、constのはunsigned char *、int型のストライド、constの短い* coeffsを予測します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_walsh(const short *in, short *out);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_walsh（定数短い*で、短い*アウト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add_process_row(struct vp8_decoder_ctx *ctx, short *coeffs, unsigned int row, unsigned int start_col, unsigned int num_cols); #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボイドvp8_dixie_idct_add_process_row（構造体vp8_decoder_ctx * CTX、短い* coeffs、unsigned int型の行、unsigned int型start_col、unsigned int型NUM_COLS）。 #endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.10. mem.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.10。 Memkh
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef VPX_PORTS_MEM_H
   #define VPX_PORTS_MEM_H
   #include &#34;vpx_config.h&#34;
   #include &#34;vpx_integer.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#if defined(__GNUC__) &amp;&amp; __GNUC__ #define DECLARE_ALIGNED(n,typ,val) typ val __attribute__ \ ((aligned (n))) #elif defined(_MSC_VER) #define DECLARE_ALIGNED(n,typ,val) __declspec(align(n)) typ val #else #warning No alignment directives known for this compiler. #define DECLARE_ALIGNED(n,typ,val) typ val #endif #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義（__ GNUC__）&amp;&amp; __GNUC__の#define DECLARE_ALIGNED（N、TYP、ヴァル）TYPヴァル__attribute__ \（（整列（N）））#elifの定義（_MSC_VER）の#define DECLARE_ALIGNED（N、TYP、ヴァル）__declspec（整列（の#ifこのコンパイラで知らn））を標準ヴァルの#else #warning無配向ディレクティブありません。 #define DECLARE_ALIGNED（N、TYP、ヴァル）TYPヴァル#endifの#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Declare an aligned array on the stack, for situations where the
    * stack pointer may not have the alignment we expect.  Creates an
    * array with a modified name, then defines val to be a pointer, and
    * aligns that pointer within the array.
    */
   #define DECLARE_ALIGNED_ARRAY(a,typ,val,n)\
   typ val##_[(n)+(a)/sizeof(typ)+1];\
   typ *val = (typ*)((((intptr_t)val##_)+(a)-1)&amp;((intptr_t)-(a)))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Indicates that the usage of the specified variable has been
    * audited to assure that it&#39;s safe to use uninitialized.  Silences
    * &#39;may be used uninitialized&#39; warnings on gcc.
    */
   #if defined(__GNUC__) &amp;&amp; __GNUC__
   #define UNINITIALIZED_IS_SAFE(x) x=x
   #else
   #define UNINITIALIZED_IS_SAFE(x) x
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.11. modemv.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.11。 modemv.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;modemv_data.h&#34;
   #include &lt;stdlib.h&gt;
   #include &lt;assert.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct mv_clamp_rect
   {
       int to_left, to_right, to_top, to_bottom;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static union mv clamp_mv(union mv raw, const struct mv_clamp_rect *bounds) { union mv newmv;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的組合MV clamp_mv（ユニオンMV生、CONST構造体のmv_clamp_rect *境界）{ユニオンのMV newmv。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       newmv.d.x = (raw.d.x &lt; bounds-&gt;to_left)
                   ? bounds-&gt;to_left : raw.d.x;
       newmv.d.x = (raw.d.x &gt; bounds-&gt;to_right)
                   ? bounds-&gt;to_right : newmv.d.x;
       newmv.d.y = (raw.d.y &lt; bounds-&gt;to_top)
                   ? bounds-&gt;to_top : raw.d.y;
       newmv.d.y = (raw.d.y &gt; bounds-&gt;to_bottom)
                   ? bounds-&gt;to_bottom : newmv.d.y;
       return newmv;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static int read_segment_id(struct bool_decoder *bool, struct vp8_segment_hdr *seg) { return bool_get(bool, seg-&gt;tree_probs[0]) ? 2 + bool_get(bool, seg-&gt;tree_probs[2]) : bool_get(bool, seg-&gt;tree_probs[1]); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的INT read_segment_id（構造体bool_decoder * BOOL、構造体vp8_segment_hdr * SEG）{戻りbool_get（BOOL、seg-&gt; tree_probs [0]）？ 2 + bool_get（BOOL、seg-&gt; tree_probs [2]）：bool_get（BOOL、seg-&gt; tree_probs [1]）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static enum prediction_mode
   above_block_mode(const struct mb_info *this,
                    const struct mb_info *above,
                    unsigned int b)
   {
       if (b &lt; 4)
       {
           switch (above-&gt;base.y_mode)
           {
           case DC_PRED:
               return B_DC_PRED;
           case V_PRED:
               return B_VE_PRED;
           case H_PRED:
               return B_HE_PRED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           case TM_PRED:
               return B_TM_PRED;
           case B_PRED:
               return above-&gt;split.modes[b+12];
           default:
               assert(0);
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return this-&gt;split.modes[b-4]; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
this-&gt; split.modes [B-4]を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static enum prediction_mode
   left_block_mode(const struct mb_info *this,
                   const struct mb_info *left,
                   unsigned int b)
   {
       if (!(b &amp; 3))
       {
           switch (left-&gt;base.y_mode)
           {
           case DC_PRED:
               return B_DC_PRED;
           case V_PRED:
               return B_VE_PRED;
           case H_PRED:
               return B_HE_PRED;
           case TM_PRED:
               return B_TM_PRED;
           case B_PRED:
               return left-&gt;split.modes[b+3];
           default:
               assert(0);
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return this-&gt;split.modes[b-1];
   } static void
   decode_kf_mb_mode(struct mb_info      *this,
                     struct mb_info      *left,
                     struct mb_info      *above,
                     struct bool_decoder *bool)
   {
       int y_mode, uv_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
y_mode = bool_read_tree(bool, kf_y_mode_tree, kf_y_mode_probs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
y_mode = bool_read_tree（BOOL、kf_y_mode_tree、kf_y_mode_probs）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (y_mode == B_PRED) { unsigned int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（y_mode == B_PRED）{unsigned int型I。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               enum prediction_mode a = above_block_mode(this, above,
                                                         i);
               enum prediction_mode l = left_block_mode(this, left, i);
               enum prediction_mode b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               b = bool_read_tree(bool, b_mode_tree,
                                  kf_b_mode_probs[a][l]);
               this-&gt;split.modes[i] = b;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
uv_mode = bool_read_tree(bool, uv_mode_tree, kf_uv_mode_probs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
uv_mode = bool_read_tree（BOOL、uv_mode_tree、kf_uv_mode_probs）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = y_mode;
       this-&gt;base.uv_mode = uv_mode;
       this-&gt;base.mv.raw = 0;
       this-&gt;base.ref_frame = 0;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   decode_intra_mb_mode(struct mb_info         *this,
                        struct vp8_entropy_hdr *hdr,
                        struct bool_decoder    *bool)
   {
       /* Like decode_kf_mb_mode, but with probabilities transmitted in
        * the bitstream and no context on the above/left block mode.
        */
       int y_mode, uv_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
y_mode = bool_read_tree(bool, y_mode_tree, hdr-&gt;y_mode_probs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
y_mode = bool_read_tree（BOOL、y_mode_tree、hdr-&gt; y_mode_probs）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (y_mode == B_PRED) { unsigned int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（y_mode == B_PRED）{unsigned int型I。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               enum prediction_mode b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               b = bool_read_tree(bool, b_mode_tree,
                                  default_b_mode_probs);
               this-&gt;split.modes[i] = b;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
uv_mode = bool_read_tree(bool, uv_mode_tree, hdr-&gt;uv_mode_probs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
uv_mode = bool_read_tree（BOOL、uv_mode_tree、hdr-&gt; uv_mode_probs）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = y_mode;
       this-&gt;base.uv_mode = uv_mode;
       this-&gt;base.mv.raw = 0;
       this-&gt;base.ref_frame = CURRENT_FRAME;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static int
   read_mv_component(struct bool_decoder *bool,
                     const unsigned char  mvc[MV_PROB_CNT])
   {
       enum {IS_SHORT, SIGN, SHORT, BITS = SHORT + 8 - 1,
             LONG_WIDTH = 10};
       int x = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (bool_get(bool, mvc[IS_SHORT])) /* Large */
       {
           int i = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 3; i++)
               x += bool_get(bool, mvc[BITS + i]) &lt;&lt; i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Skip bit 3, which is sometimes implicit */
           for (i = LONG_WIDTH - 1; i &gt; 3; i--)
               x += bool_get(bool, mvc[BITS + i]) &lt;&lt; i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (!(x &amp; 0xFFF0)  ||  bool_get(bool, mvc[BITS + 3]))
               x += 8;
       }
       else   /* small */
           x = bool_read_tree(bool, small_mv_tree, mvc + SHORT);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (x &amp;&amp; bool_get(bool, mvc[SIGN])) x = -x;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（X &amp;&amp; bool_get（BOOL、MVC [SIGN]））x = -x。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return x &lt;&lt; 1; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X &lt;&lt; 1を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static mv_t above_block_mv(const struct mb_info *this, const struct mb_info *above, unsigned int b) { if (b &lt; 4) { if (above-&gt;base.y_mode == SPLITMV) return above-&gt;split.mvs[b+12];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的mv_tのabove_block_mv（CONST構造体mb_info *この、CONST構造体mb_info *上記、unsigned int型のB）{IF（B &lt;4）{IF（上述&gt; base.y_mode == SPLITMV）戻り上述&gt; split.mvs [B + 12]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           return above-&gt;base.mv;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return this-&gt;split.mvs[b-4]; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
this-&gt; split.mvs [B-4]を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static mv_t left_block_mv(const struct mb_info *this, const struct mb_info *left, unsigned int b) { if (!(b &amp; 3)) { if (left-&gt;base.y_mode == SPLITMV) return left-&gt;split.mvs[b+3];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的mv_tのleft_block_mv（constの構造体mb_info *この、constの構造体mb_info *左、unsigned int型のB）{場合（！（B＆3））{場合（左&gt; base.y_mode == SPLITMV）リターン左&gt; split.mvs [B + 3]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           return left-&gt;base.mv;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return this-&gt;split.mvs[b-1];
   } static enum prediction_mode
   submv_ref(struct bool_decoder *bool, union mv l, union mv a)
   {
       enum subblock_mv_ref
       {
           SUBMVREF_NORMAL,
           SUBMVREF_LEFT_ZED,
           SUBMVREF_ABOVE_ZED,
           SUBMVREF_LEFT_ABOVE_SAME,
           SUBMVREF_LEFT_ABOVE_ZED
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int lez = !(l.raw);
       int aez = !(a.raw);
       int lea = l.raw == a.raw;
       enum subblock_mv_ref ctx = SUBMVREF_NORMAL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (lea &amp;&amp; lez)
           ctx = SUBMVREF_LEFT_ABOVE_ZED;
       else if (lea)
           ctx = SUBMVREF_LEFT_ABOVE_SAME;
       else if (aez)
           ctx = SUBMVREF_ABOVE_ZED;
       else if (lez)
           ctx = SUBMVREF_LEFT_ZED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return bool_read_tree(bool, submv_ref_tree, submv_ref_probs2[ctx]); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
戻りbool_read_tree（BOOL、submv_ref_tree、submv_ref_probs2 [CTX]）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   read_mv(struct bool_decoder  *bool,
           union mv             *mv,
           mv_component_probs_t  mvc[2])
   {
       mv-&gt;d.y = read_mv_component(bool, mvc[0]);
       mv-&gt;d.x = read_mv_component(bool, mvc[1]);
   } static void
   mv_bias(const struct mb_info *mb,
           const unsigned int   sign_bias[3],
           enum reference_frame ref_frame,
           union mv             *mv)
   {
       if (sign_bias[mb-&gt;base.ref_frame] ^ sign_bias[ref_frame])
       {
           mv-&gt;d.x *= -1;
           mv-&gt;d.y *= -1;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum near_mv_v { CNT_BEST = 0, CNT_ZEROZERO = 0, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙near_mv_v {CNT_BEST = 0、CNT_ZEROZERO = 0、CNT_NEAREST、CNT_NEAR、CNT_SPLITMV}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   find_near_mvs(const struct mb_info   *this,
                 const struct mb_info   *left,
                 const struct mb_info   *above,
                 const unsigned int      sign_bias[3],
                 union  mv               near_mvs[4],
                 int                     cnt[4])
   {
       const struct mb_info *aboveleft = above - 1;
       union  mv             *mv = near_mvs;
       int                   *cntx = cnt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Zero accumulators */
       mv[0].raw = mv[1].raw = mv[2].raw = 0;
       cnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Process above */
       if (above-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (above-&gt;base.mv.raw)
           {
               (++mv)-&gt;raw = above-&gt;base.mv.raw;
               mv_bias(above, sign_bias, this-&gt;base.ref_frame, mv);
               ++cntx;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 *cntx += 2; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Cntx + = 2; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Process left */
       if (left-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (left-&gt;base.mv.raw)
           {
               union mv this_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               this_mv.raw = left-&gt;base.mv.raw;
               mv_bias(left, sign_bias, this-&gt;base.ref_frame, &amp;this_mv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (this_mv.raw != mv-&gt;raw)
               {
                   (++mv)-&gt;raw = this_mv.raw;
                   ++cntx;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               *cntx += 2;
           }
           else
               cnt[CNT_ZEROZERO] += 2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Process above left */
       if (aboveleft-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (aboveleft-&gt;base.mv.raw)
           {
               union mv this_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               this_mv.raw = aboveleft-&gt;base.mv.raw;
               mv_bias(aboveleft, sign_bias, this-&gt;base.ref_frame,
                       &amp;this_mv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (this_mv.raw != mv-&gt;raw)
               {
                   (++mv)-&gt;raw = this_mv.raw;
                   ++cntx;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               *cntx += 1;
           }
           else
               cnt[CNT_ZEROZERO] += 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* If we have three distinct MVs ... */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (cnt[CNT_SPLITMV])
       {
           /* See if above-left MV can be merged with NEAREST */
           if (mv-&gt;raw == near_mvs[CNT_NEAREST].raw)
               cnt[CNT_NEAREST] += 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
cnt[CNT_SPLITMV] = ((above-&gt;base.y_mode == SPLITMV) + (left-&gt;base.y_mode == SPLITMV)) * 2 + (aboveleft-&gt;base.y_mode == SPLITMV);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CNT [CNT_SPLITMV] =（（上述&gt; base.y_mode == SPLITMV）+（左&gt; base.y_mode == SPLITMV））* 2 +（aboveleft-&gt; base.y_mode == SPLITMV）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Swap near and nearest if necessary */
       if (cnt[CNT_NEAR] &gt; cnt[CNT_NEAREST])
       {
           int tmp;
           tmp = cnt[CNT_NEAREST];
           cnt[CNT_NEAREST] = cnt[CNT_NEAR];
           cnt[CNT_NEAR] = tmp;
           tmp = near_mvs[CNT_NEAREST].raw;
           near_mvs[CNT_NEAREST].raw = near_mvs[CNT_NEAR].raw;
           near_mvs[CNT_NEAR].raw = tmp;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Use near_mvs[CNT_BEST] to store the &#34;best&#34; MV.  Note that this
        * storage shares the same address as near_mvs[CNT_ZEROZERO].
        */
       if (cnt[CNT_NEAREST] &gt;= cnt[CNT_BEST])
           near_mvs[CNT_BEST] = near_mvs[CNT_NEAREST];
   } static void
   decode_split_mv(struct mb_info         *this,
                   const struct mb_info   *left,
                   const struct mb_info   *above,
                   struct vp8_entropy_hdr *hdr,
                   union  mv              *best_mv,
                   struct bool_decoder    *bool)
   {
       const int *partition;
       int        j, k, mask, partition_id;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       partition_id = bool_read_tree(bool, split_mv_tree,
                                     split_mv_probs);
       partition = mv_partitions[partition_id];
       this-&gt;base.partitioning = partition_id;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (j = 0, mask = 0; mask &lt; 65535; j++)
       {
           union mv mv, left_mv, above_mv;
           enum prediction_mode subblock_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Find the first subblock in this partition. */
           for (k = 0; j != partition[k]; k++);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Decode the next MV */
           left_mv = left_block_mv(this, left, k);
           above_mv = above_block_mv(this, above, k);
           subblock_mode = submv_ref(bool, left_mv,  above_mv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           switch (subblock_mode)
           {
           case LEFT4X4:
               mv = left_mv;
               break;
           case ABOVE4X4:
               mv = above_mv;
               break;
           case ZERO4X4:
               mv.raw = 0;
               break;
           case NEW4X4:
               read_mv(bool, &amp;mv, hdr-&gt;mv_probs);
               mv.d.x += best_mv-&gt;d.x;
               mv.d.y += best_mv-&gt;d.y;
               break;
           default:
               assert(0);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Fill the MVs for this partition */
           for (; k &lt; 16; k++)
               if (j == partition[k])
               {
                   this-&gt;split.mvs[k] = mv;
                   mask |= 1 &lt;&lt; k;
               }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static int need_mc_border(union mv mv, int l, int t, int b_w, int w, int h) { int b, r;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的INT need_mc_border（ユニオンのMV MV、int型、L、T INT、INT B_W、INT W、INT H）{int型B、R。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Get distance to edge for top-left pixel */
       l += (mv.d.x &gt;&gt; 3);
       t += (mv.d.y &gt;&gt; 3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Get distance to edge for bottom-right pixel */
       r = w - (l + b_w);
       b = h - (t + b_w);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return (l &gt;&gt; 1 &lt; 2 || r &gt;&gt; 1 &lt; 3 || t &gt;&gt; 1 &lt; 2 || b &gt;&gt; 1 &lt; 3); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リターン（L &gt;&gt; 1 &lt;2 || R &gt;&gt; 1 &lt;3 || T &gt;&gt; 1 &lt;2 || B &gt;&gt; 1 &lt;3）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   decode_mvs(struct vp8_decoder_ctx       *ctx,
              struct mb_info               *this,
              const struct mb_info         *left,
              const struct mb_info         *above,
              const struct mv_clamp_rect   *bounds,
              struct bool_decoder          *bool)
   {
       struct vp8_entropy_hdr *hdr = &amp;ctx-&gt;entropy_hdr;
       union mv          near_mvs[4];
       union mv          clamped_best_mv;
       int               mv_cnts[4];
       unsigned char     probs[4];
       enum {BEST, NEAREST, NEAR};
       int x, y, w, h, b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       this-&gt;base.ref_frame = bool_get(bool, hdr-&gt;prob_last)
                              ? 2 + bool_get(bool, hdr-&gt;prob_gf)
                              : 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       find_near_mvs(this, this - 1, above,
                     ctx-&gt;reference_hdr.sign_bias, near_mvs, mv_cnts);
       probs[0] = mv_counts_to_probs[mv_cnts[0]][0];
       probs[1] = mv_counts_to_probs[mv_cnts[1]][1];
       probs[2] = mv_counts_to_probs[mv_cnts[2]][2];
       probs[3] = mv_counts_to_probs[mv_cnts[3]][3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = bool_read_tree(bool, mv_ref_tree, probs);
       this-&gt;base.uv_mode = this-&gt;base.y_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       this-&gt;base.need_mc_border = 0;
       x = (-bounds-&gt;to_left - 128) &gt;&gt; 3;
       y = (-bounds-&gt;to_top - 128) &gt;&gt; 3;
       w = ctx-&gt;mb_cols * 16;
       h = ctx-&gt;mb_rows * 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       switch (this-&gt;base.y_mode)
       {
       case NEARESTMV:
           this-&gt;base.mv = clamp_mv(near_mvs[NEAREST], bounds);
           break;
       case NEARMV:
           this-&gt;base.mv = clamp_mv(near_mvs[NEAR], bounds);
           break;
       case ZEROMV:
           this-&gt;base.mv.raw = 0;
           return; //skip need_mc_border check
       case NEWMV:
           clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);
           read_mv(bool, &amp;this-&gt;base.mv, hdr-&gt;mv_probs);
           this-&gt;base.mv.d.x += clamped_best_mv.d.x;
           this-&gt;base.mv.d.y += clamped_best_mv.d.y;
           break;
       case SPLITMV:
       {
           union mv          chroma_mv[4] = {{{0}}};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);
           decode_split_mv(this, left, above, hdr, &amp;clamped_best_mv,
                           bool);
           this-&gt;base.mv = this-&gt;split.mvs[15];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (b = 0; b &lt; 16; b++)
           {
               chroma_mv[(b&gt;&gt;1&amp;1) + (b&gt;&gt;2&amp;2)].d.x +=
                   this-&gt;split.mvs[b].d.x;
               chroma_mv[(b&gt;&gt;1&amp;1) + (b&gt;&gt;2&amp;2)].d.y +=
                   this-&gt;split.mvs[b].d.y;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (need_mc_border(this-&gt;split.mvs[b],
               x + (b &amp; 3) * 4, y + (b &amp; ~3), 4, w, h))
               {
                   this-&gt;base.need_mc_border = 1;
                   break;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (b = 0; b &lt; 4; b++)
           {
               chroma_mv[b].d.x += 4 + 8 * (chroma_mv[b].d.x &gt;&gt; 31);
               chroma_mv[b].d.y += 4 + 8 * (chroma_mv[b].d.y &gt;&gt; 31);
               chroma_mv[b].d.x /= 4;
               chroma_mv[b].d.y /= 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
//note we&#39;re passing in non-subsampled coordinates
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
//私たちは非サブサンプリングされた座標を渡している注意してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (need_mc_border(chroma_mv[b],
               x + (b &amp; 1) * 8, y + (b &gt;&gt; 1) * 8, 16, w, h))
               {
                   this-&gt;base.need_mc_border = 1;
                   break;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 return; //skip need_mc_border check } default: assert(0); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
返します。アサート（0）; //}チェックneed_mc_borderデフォルトをスキップ}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (need_mc_border(this-&gt;base.mv, x, y, 16, w, h))
           this-&gt;base.need_mc_border = 1;
   } void
   vp8_dixie_modemv_process_row(struct vp8_decoder_ctx *ctx,
   struct bool_decoder    *bool,
   int                     row,
   int                     start_col,
   int                     num_cols)
   {
       struct mb_info       *above, *this;
       unsigned int          col;
       struct mv_clamp_rect  bounds;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       this = ctx-&gt;mb_info_rows[row] + start_col;
       above = ctx-&gt;mb_info_rows[row - 1] + start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Calculate the eighth-pel MV bounds using a 1 MB border. */
       bounds.to_left   = -((start_col + 1) &lt;&lt; 7);
       bounds.to_right  = (ctx-&gt;mb_cols - start_col) &lt;&lt; 7;
       bounds.to_top    = -((row + 1) &lt;&lt; 7);
       bounds.to_bottom = (ctx-&gt;mb_rows - row) &lt;&lt; 7;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
for (col = start_col; col &lt; start_col + num_cols; col++) { if (ctx-&gt;segment_hdr.update_map) this-&gt;base.segment_id = read_segment_id(bool, &amp;ctx-&gt;segment_hdr);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
用（COL = start_col; COL &lt;start_col + NUM_COLS; COL ++）{IF（ctx-&gt; segment_hdr.update_map）this-&gt; base.segment_id = read_segment_id（BOOL、＆ctx-&gt; segment_hdr）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (ctx-&gt;entropy_hdr.coeff_skip_enabled)
               this-&gt;base.skip_coeff = bool_get(bool,
               ctx-&gt;entropy_hdr.coeff_skip_prob);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (ctx-&gt;frame_hdr.is_keyframe) { if (!ctx-&gt;segment_hdr.update_map) this-&gt;base.segment_id = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
（ctx-&gt; frame_hdr.is_keyframe）なら、{もし（ctx-&gt; segment_hdr.update_map！）this-&gt; base.segment_id = 0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               decode_kf_mb_mode(this, this - 1, above, bool);
           }
           else
           {
               if (bool_get(bool, ctx-&gt;entropy_hdr.prob_inter))
                   decode_mvs(ctx, this, this - 1, above, &amp;bounds,
                              bool);
               else
                   decode_intra_mb_mode(this, &amp;ctx-&gt;entropy_hdr, bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               bounds.to_left -= 16 &lt;&lt; 3;
               bounds.to_right -= 16 &lt;&lt; 3;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Advance to next mb */
           this++;
           above++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void
   vp8_dixie_modemv_init(struct vp8_decoder_ctx *ctx)
   {
       unsigned int    mbi_w, mbi_h, i;
       struct mb_info *mbi;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       mbi_w = ctx-&gt;mb_cols + 1; /* For left border col */
       mbi_h = ctx-&gt;mb_rows + 1; /* For above border row */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           free(ctx-&gt;mb_info_storage);
           ctx-&gt;mb_info_storage = NULL;
           free(ctx-&gt;mb_info_rows_storage);
           ctx-&gt;mb_info_rows_storage = NULL;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (!ctx-&gt;mb_info_storage) ctx-&gt;mb_info_storage = calloc(mbi_w * mbi_h, sizeof(*ctx-&gt;mb_info_storage));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
もし（ctx-&gt; mb_info_storage！）ctx-&gt; mb_info_storage =はcalloc（mbi_w * mbi_h、はsizeof（* ctx-&gt; mb_info_storage））;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (!ctx-&gt;mb_info_rows_storage)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（もし！ctx-&gt; mb_info_rows_storage）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           ctx-&gt;mb_info_rows_storage = calloc(mbi_h,
           sizeof(*ctx-&gt;mb_info_rows_storage));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Set up row pointers */
       mbi = ctx-&gt;mb_info_storage + 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; mbi_h; i++)
       {
           ctx-&gt;mb_info_rows_storage[i] = mbi;
           mbi += mbi_w;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ctx-&gt;mb_info_rows = ctx-&gt;mb_info_rows_storage + 1;
   } void
   vp8_dixie_modemv_destroy(struct vp8_decoder_ctx *ctx)
   {
       free(ctx-&gt;mb_info_storage);
       ctx-&gt;mb_info_storage = NULL;
       free(ctx-&gt;mb_info_rows_storage);
       ctx-&gt;mb_info_rows_storage = NULL;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.12. modemv.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.12。 modemv.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef MODEMV_H
   #define MODEMV_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_modemv_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_modemv_init（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_modemv_destroy(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_modemv_destroy（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_modemv_process_row(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, int row, int start_col, int num_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボイドvp8_dixie_modemv_process_row（構造体vp8_decoder_ctx * CTX、構造体bool_decoderの*ブール値、INT行、INT start_col、INT NUM_COLS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.13. modemv_data.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20：13。 modemv_data.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static const unsigned char kf_y_mode_probs[] = { 145, 156, 163, 128};
   static const unsigned char kf_uv_mode_probs[] = { 142, 114, 183};
   static const unsigned char kf_b_mode_probs[10][10][9] =
   {
     { /* above mode 0 */
       { /* left mode 0 */ 231, 120,  48,  89, 115, 113, 120, 152, 112},
       { /* left mode 1 */ 152, 179,  64, 126, 170, 118,  46,  70,  95},
       { /* left mode 2 */ 175,  69, 143,  80,  85,  82,  72, 155, 103},
       { /* left mode 3 */  56,  58,  10, 171, 218, 189,  17,  13, 152},
       { /* left mode 4 */ 144,  71,  10,  38, 171, 213, 144,  34,  26},
       { /* left mode 5 */ 114,  26,  17, 163,  44, 195,  21,  10, 173},
       { /* left mode 6 */ 121,  24,  80, 195,  26,  62,  44,  64,  85},
       { /* left mode 7 */ 170,  46,  55,  19, 136, 160,  33, 206,  71},
       { /* left mode 8 */  63,  20,   8, 114, 114, 208,  12,   9, 226},
       { /* left mode 9 */  81,  40,  11,  96, 182,  84,  29,  16,  36}
     },
     { /* above mode 1 */
       { /* left mode 0 */ 134, 183,  89, 137,  98, 101, 106, 165, 148},
       { /* left mode 1 */  72, 187, 100, 130, 157, 111,  32,  75,  80},
       { /* left mode 2 */  66, 102, 167,  99,  74,  62,  40, 234, 128},
       { /* left mode 3 */  41,  53,   9, 178, 241, 141,  26,   8, 107},
       { /* left mode 4 */ 104,  79,  12,  27, 217, 255,  87,  17,   7},
       { /* left mode 5 */  74,  43,  26, 146,  73, 166,  49,  23, 157},
       { /* left mode 6 */  65,  38, 105, 160,  51,  52,  31, 115, 128},
       { /* left mode 7 */  87,  68,  71,  44, 114,  51,  15, 186,  23},
       { /* left mode 8 */  47,  41,  14, 110, 182, 183,  21,  17, 194},
       { /* left mode 9 */  66,  45,  25, 102, 197, 189,  23,  18,  22}
     },
     { /* above mode 2 */
       { /* left mode 0 */  88,  88, 147, 150,  42,  46,  45, 196, 205},
       { /* left mode 1 */  43,  97, 183, 117,  85,  38,  35, 179,  61},
       { /* left mode 2 */  39,  53, 200,  87,  26,  21,  43, 232, 171},
       { /* left mode 3 */  56,  34,  51, 104, 114, 102,  29,  93,  77},
       { /* left mode 4 */ 107,  54,  32,  26,  51,   1,  81,  43,  31},
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       { /* left mode 5 */  39,  28,  85, 171,  58, 165,  90,  98,  64},
       { /* left mode 6 */  34,  22, 116, 206,  23,  34,  43, 166,  73},
       { /* left mode 7 */  68,  25, 106,  22,  64, 171,  36, 225, 114},
       { /* left mode 8 */  34,  19,  21, 102, 132, 188,  16,  76, 124},
       { /* left mode 9 */  62,  18,  78,  95,  85,  57,  50,  48,  51}
     },
     { /* above mode 3 */
       { /* left mode 0 */ 193, 101,  35, 159, 215, 111,  89,  46, 111},
       { /* left mode 1 */  60, 148,  31, 172, 219, 228,  21,  18, 111},
       { /* left mode 2 */ 112, 113,  77,  85, 179, 255,  38, 120, 114},
       { /* left mode 3 */  40,  42,   1, 196, 245, 209,  10,  25, 109},
       { /* left mode 4 */ 100,  80,   8,  43, 154,   1,  51,  26,  71},
       { /* left mode 5 */  88,  43,  29, 140, 166, 213,  37,  43, 154},
       { /* left mode 6 */  61,  63,  30, 155,  67,  45,  68,   1, 209},
       { /* left mode 7 */ 142,  78,  78,  16, 255, 128,  34, 197, 171},
       { /* left mode 8 */  41,  40,   5, 102, 211, 183,   4,   1, 221},
       { /* left mode 9 */  51,  50,  17, 168, 209, 192,  23,  25,  82}
     },
     { /* above mode 4 */
       { /* left mode 0 */ 125,  98,  42,  88, 104,  85, 117, 175,  82},
       { /* left mode 1 */  95,  84,  53,  89, 128, 100, 113, 101,  45},
       { /* left mode 2 */  75,  79, 123,  47,  51, 128,  81, 171,   1},
       { /* left mode 3 */  57,  17,   5,  71, 102,  57,  53,  41,  49},
       { /* left mode 4 */ 115,  21,   2,  10, 102, 255, 166,  23,   6},
       { /* left mode 5 */  38,  33,  13, 121,  57,  73,  26,   1,  85},
       { /* left mode 6 */  41,  10,  67, 138,  77, 110,  90,  47, 114},
       { /* left mode 7 */ 101,  29,  16,  10,  85, 128, 101, 196,  26},
       { /* left mode 8 */  57,  18,  10, 102, 102, 213,  34,  20,  43},
       { /* left mode 9 */ 117,  20,  15,  36, 163, 128,  68,   1,  26}
     },
     { /* above mode 5 */
       { /* left mode 0 */ 138,  31,  36, 171,  27, 166,  38,  44, 229},
       { /* left mode 1 */  67,  87,  58, 169,  82, 115,  26,  59, 179},
       { /* left mode 2 */  63,  59,  90, 180,  59, 166,  93,  73, 154},
       { /* left mode 3 */  40,  40,  21, 116, 143, 209,  34,  39, 175},
       { /* left mode 4 */  57,  46,  22,  24, 128,   1,  54,  17,  37},
       { /* left mode 5 */  47,  15,  16, 183,  34, 223,  49,  45, 183},
       { /* left mode 6 */  46,  17,  33, 183,   6,  98,  15,  32, 183},
       { /* left mode 7 */  65,  32,  73, 115,  28, 128,  23, 128, 205},
       { /* left mode 8 */  40,   3,   9, 115,  51, 192,  18,   6, 223},
       { /* left mode 9 */  87,  37,   9, 115,  59,  77,  64,  21,  47}
     },
     { /* above mode 6 */
       { /* left mode 0 */ 104,  55,  44, 218,   9,  54,  53, 130, 226},
       { /* left mode 1 */  64,  90,  70, 205,  40,  41,  23,  26,  57},
       { /* left mode 2 */  54,  57, 112, 184,   5,  41,  38, 166, 213},
       { /* left mode 3 */  30,  34,  26, 133, 152, 116,  10,  32, 134},
       { /* left mode 4 */  75,  32,  12,  51, 192, 255, 160,  43,  51},
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       { /* left mode 5 */  39,  19,  53, 221,  26, 114,  32,  73, 255},
       { /* left mode 6 */  31,   9,  65, 234,   2,  15,   1, 118,  73},
       { /* left mode 7 */  88,  31,  35,  67, 102,  85,  55, 186,  85},
       { /* left mode 8 */  56,  21,  23, 111,  59, 205,  45,  37, 192},
       { /* left mode 9 */  55,  38,  70, 124,  73, 102,   1,  34,  98}
     },
     { /* above mode 7 */
       { /* left mode 0 */ 102,  61,  71,  37,  34,  53,  31, 243, 192},
       { /* left mode 1 */  69,  60,  71,  38,  73, 119,  28, 222,  37},
       { /* left mode 2 */  68,  45, 128,  34,   1,  47,  11, 245, 171},
       { /* left mode 3 */  62,  17,  19,  70, 146,  85,  55,  62,  70},
       { /* left mode 4 */  75,  15,   9,   9,  64, 255, 184, 119,  16},
       { /* left mode 5 */  37,  43,  37, 154, 100, 163,  85, 160,   1},
       { /* left mode 6 */  63,   9,  92, 136,  28,  64,  32, 201,  85},
       { /* left mode 7 */  86,   6,  28,   5,  64, 255,  25, 248,   1},
       { /* left mode 8 */  56,   8,  17, 132, 137, 255,  55, 116, 128},
       { /* left mode 9 */  58,  15,  20,  82, 135,  57,  26, 121,  40}
     },
     { /* above mode 8 */
       { /* left mode 0 */ 164,  50,  31, 137, 154, 133,  25,  35, 218},
       { /* left mode 1 */  51, 103,  44, 131, 131, 123,  31,   6, 158},
       { /* left mode 2 */  86,  40,  64, 135, 148, 224,  45, 183, 128},
       { /* left mode 3 */  22,  26,  17, 131, 240, 154,  14,   1, 209},
       { /* left mode 4 */  83,  12,  13,  54, 192, 255,  68,  47,  28},
       { /* left mode 5 */  45,  16,  21,  91,  64, 222,   7,   1, 197},
       { /* left mode 6 */  56,  21,  39, 155,  60, 138,  23, 102, 213},
       { /* left mode 7 */  85,  26,  85,  85, 128, 128,  32, 146, 171},
       { /* left mode 8 */  18,  11,   7,  63, 144, 171,   4,   4, 246},
       { /* left mode 9 */  35,  27,  10, 146, 174, 171,  12,  26, 128}
     },
     { /* above mode 9 */
       { /* left mode 0 */ 190,  80,  35,  99, 180,  80, 126,  54,  45},
       { /* left mode 1 */  85, 126,  47,  87, 176,  51,  41,  20,  32},
       { /* left mode 2 */ 101,  75, 128, 139, 118, 146, 116, 128,  85},
       { /* left mode 3 */  56,  41,  15, 176, 236,  85,  37,   9,  62},
       { /* left mode 4 */ 146,  36,  19,  30, 171, 255,  97,  27,  20},
       { /* left mode 5 */  71,  30,  17, 119, 118, 255,  17,  18, 138},
       { /* left mode 6 */ 101,  38,  60, 138,  55,  70,  43,  26, 142},
       { /* left mode 7 */ 138,  45,  61,  62, 219,   1,  81, 188,  64},
       { /* left mode 8 */  32,  41,  20, 117, 151, 142,  20,  21, 163},
       { /* left mode 9 */ 112,  19,  12,  61, 195, 128,  48,   4,  24}
     }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static const int kf_y_mode_tree[] =
   {
     -B_PRED, 2,
     4, 6,
     -DC_PRED, -V_PRED,
     -H_PRED, -TM_PRED
   };
   static const int y_mode_tree[] =
   {
     -DC_PRED, 2,
     4, 6,
     -V_PRED, -H_PRED,
     -TM_PRED, -B_PRED
   };
   static const int uv_mode_tree[6] =
   {
     -DC_PRED, 2,
     -V_PRED, 4,
     -H_PRED, -TM_PRED
   };
   static const int b_mode_tree[18] =
   {
     -B_DC_PRED, 2,               /* 0 = DC_NODE */
     -B_TM_PRED, 4,               /* 1 = TM_NODE */
     -B_VE_PRED, 6,               /* 2 = VE_NODE */
     8, 12,                       /* 3 = COM_NODE */
     -B_HE_PRED, 10,              /* 4 = HE_NODE */
     -B_RD_PRED, -B_VR_PRED,      /* 5 = RD_NODE */
     -B_LD_PRED, 14,              /* 6 = LD_NODE */
     -B_VL_PRED, 16,              /* 7 = VL_NODE */
     -B_HD_PRED, -B_HU_PRED       /* 8 = HD_NODE */
   };
   static const int small_mv_tree[14] =
   {
     2, 8,
     4, 6,
     -0, -1,
     -2, -3,
     10, 12,
     -4, -5,
     -6, -7
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static const int mv_ref_tree[8] =
   {
     -ZEROMV, 2,
     -NEARESTMV, 4,
     -NEARMV, 6,
     -NEWMV, -SPLITMV
   };
   static const int submv_ref_tree[6] =
   {
     -LEFT4X4, 2,
     -ABOVE4X4, 4,
     -ZERO4X4, -NEW4X4
   };
   static const int split_mv_tree[6] =
   {
     -3, 2,
     -2, 4,
     -0, -1
   };
   static const unsigned char default_b_mode_probs[] =
   { 120,  90,  79, 133,  87,  85,  80, 111, 151};
   static const unsigned char mv_counts_to_probs[6][4] =
   {
     {   7,   1,   1, 143 },
     {  14,  18,  14, 107 },
     { 135,  64,  57,  68 },
     {  60,  56, 128,  65 },
     { 159, 134, 128,  34 },
     { 234, 188, 128,  28 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   };
   static const unsigned char split_mv_probs[3] =
   { 110, 111, 150};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char submv_ref_probs2[5][3] = { { 147, 136, 18 }, { 106, 145, 1 }, { 179, 121, 1 }, { 223, 1, 34 }, { 208, 1, 1 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数はunsigned charのsubmv_ref_probs2 [5] [3] = {{147、136、18}、{106、145、1}、{179、121、1}、{223、1、34}、{208、1、 1}}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const static int mv_partitions[4][16] = { {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1 }, {0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1 }, {0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3 }, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST静的INT mv_partitions [4] [16] = {{0、0、0、0、0、0、0、0、1、1、1、1、1、1、1、1}、{0,0 、1、1、0、0、1、1、0、0、1、1、0、0、1、1}、{0、0、1、1、0、0、1、1、2、2 、3、3、2、2、3、3}、{0、1、2、3、4、5、6、7、8、9、10、11、12、13、14、15}}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.14. predict.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.14。 predict.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;predict.h&#34;
   #include &#34;idct_add.h&#34;
   #include &#34;mem.h&#34;
   #include &lt;assert.h&gt;
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum { BORDER_PIXELS = 16, };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙{BORDER_PIXELS = 16、}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const filter_t sixtap_filters[8] = { { 0, 0, 128, 0, 0, 0 }, { 0, -6, 123, 12, -1, 0 }, { 2, -11, 108, 36, -8, 1 }, { 0, -9, 93, 50, -6, 0 }, { 3, -16, 77, 77, -16, 3 }, { 0, -6, 50, 93, -9, 0 }, { 1, -8, 36, 108, -11, 2 }, { 0, -1, 12, 123, -6, 0 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 静的定数[8] = {{0、0、128、0、0、0}、{0、-6、123、12、-1、0}、{2、-11、108、36、sixtap_filtersをfilter_t 8,1}、{0、-9、93、50、-6、0}、{3、-16、77、77、-16、3}、{0、-6、50、93、-9、 0}、{1、-8、36、108、-11、2}、{0、-1、12、123、-6、0}}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const filter_t bilinear_filters[8] = { { 0, 0, 128, 0, 0, 0 }, { 0, 0, 112, 16, 0, 0 }, { 0, 0, 96, 32, 0, 0 }, { 0, 0, 80, 48, 0, 0 }, { 0, 0, 64, 64, 0, 0 }, { 0, 0, 48, 80, 0, 0 }, { 0, 0, 32, 96, 0, 0 }, { 0, 0, 16, 112, 0, 0 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数はfilter_t bilinear_filters [8] = {{0、0、128、0、0、0}、{0、0、112、16、0、0}、{0、0、96、32、0、0} 、{0、0、80、48、0、0}、{0、0、64、64、0、0}、{0、0、48、80、0、0}、{0、0、32、 96、0、0}、{0、0、16、112、0、0}}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   predict_h_nxn(unsigned char *predict,
                 int            stride,
                 int            n)
   {
       unsigned char *left = predict - 1;
       int            i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) predict[i *stride + j] = left[i * stride]; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用（i = 0; iがn &lt;; iは++）のために（J = 0; nはJ &lt;; J ++）=左の[i *がストライド] [iがストライド+ jは*]予測します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   predict_v_nxn(unsigned char *predict,
                 int            stride,
                 int            n)
   {
       unsigned char *above = predict - stride;
       int            i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
           for (j = 0; j &lt; n; j++)
               predict[i *stride + j] = above[j];
   } static void
   predict_tm_nxn(unsigned char *predict,
                  int            stride,
                  int            n)
   {
       /* Transposes the left column to the top row for later
        * consumption by the idct/recon stage
        */
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       unsigned char  p = above[-1];
       int            i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (j = 0; j &lt; n; j++)
       {
           for (i = 0; i &lt; n; i++)
               predict[i] = CLAMP_255(*left + above[i] - p);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           predict += stride;
           left += stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   predict_dc_nxn(unsigned char *predict,
                  int            stride,
                  int            n)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            i, j, dc = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
       {
           dc += *left + above[i];
           left += stride;
       } switch (n)
       {
       case 16:
           dc = (dc + 16) &gt;&gt; 5;
           break;
       case  8:
           dc = (dc + 8) &gt;&gt; 4;
           break;
       case  4:
           dc = (dc + 4) &gt;&gt; 3;
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) predict[i *stride + j] = dc; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用（i = 0; iがn &lt;; iは++）のために（J = 0; nはJ &lt;; J ++）= DC [iがストライド+ jは*]予測します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   predict_ve_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = (above[-1] + 2 * above[0] + above[1] + 2) &gt;&gt; 2;
       predict[1] = (above[ 0] + 2 * above[1] + above[2] + 2) &gt;&gt; 2;
       predict[2] = (above[ 1] + 2 * above[2] + above[3] + 2) &gt;&gt; 2;
       predict[3] = (above[ 2] + 2 * above[3] + above[4] + 2) &gt;&gt; 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 1; i &lt; 4; i++)
           for (j = 0; j &lt; 4; j++)
               predict[i *stride + j] = predict[j];
   } static void
   predict_he_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] + left[0] + 2) &gt;&gt; 2;
   } static void
   predict_ld_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[0] + 2 * above[1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[1] = pred1 = (above[1] + 2 * above[2] +
                             above[3] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (above[2] + 2 * above[3] +
                             above[4] + 2) &gt;&gt; 2;
       predict[3] = pred3 = (above[3] + 2 * above[4] +
                             above[5] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred1;
       predict[1] = pred2;
       predict[2] = pred3;
       predict[3] = pred4 = (above[4] + 2 * above[5] +
                             above[6] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred2;
       predict[1] = pred3;
       predict[2] = pred4;
       predict[3] = pred5 = (above[5] + 2 * above[6] +
                             above[7] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred3;
       predict[1] = pred4;
       predict[2] = pred5;
       predict[3] = pred6 = (above[6] + 2 * above[7] +
                             above[7] + 2) &gt;&gt; 2;
   } static void
   predict_rd_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred0 =
           (left[ 0] + 2 * above[-1] + above[0] + 2) &gt;&gt; 2;
       predict[1] = pred1 =
           (above[-1] + 2 * above[ 0] + above[1] + 2) &gt;&gt; 2;
       predict[2] = pred2 =
           (above[ 0] + 2 * above[ 1] + above[2] + 2) &gt;&gt; 2;
       predict[3] = pred3 =
           (above[ 1] + 2 * above[ 2] + above[3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred4 =
           (left[stride] + 2 * left[0] + above[-1] + 2) &gt;&gt; 2;
       predict[1] = pred0;
       predict[2] = pred1;
       predict[3] = pred2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred5 =
           (left[stride*2] + 2 * left[stride] + left[0] + 2) &gt;&gt; 2;
       predict[1] = pred4;
       predict[2] = pred0;
       predict[3] = pred1;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred6 = (left[stride*3] + 2 * left[stride*2] +
                             left[stride] + 2) &gt;&gt; 2;
       predict[1] = pred5;
       predict[2] = pred4;
       predict[3] = pred0;
   } static void
   predict_vr_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[-1] + above[0] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (above[ 0] + above[1] + 1) &gt;&gt; 1;
       predict[2] = pred2 = (above[ 1] + above[2] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (above[ 2] + above[3] + 1) &gt;&gt; 1;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred4 = (left[ 0] + 2 * above[-1] +
                             above[0] + 2) &gt;&gt; 2;
       predict[1] = pred5 = (above[-1] + 2 * above[ 0] +
                             above[1] + 2) &gt;&gt; 2;
       predict[2] = pred6 = (above[ 0] + 2 * above[ 1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[3] = pred7 = (above[ 1] + 2 * above[ 2] +
                             above[3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred8 =
           (left[stride] + 2 * left[0] + above[-1] + 2) &gt;&gt; 2;
       predict[1] = pred0;
       predict[2] = pred1;
       predict[3] = pred2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred9 =
           (left[stride*2] + 2 * left[stride] + left[0] + 2) &gt;&gt; 2;
       predict[1] = pred4;
       predict[2] = pred5;
       predict[3] = pred6;
   } static void
   predict_vl_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[0] + above[1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (above[1] + above[2] + 1) &gt;&gt; 1;
       predict[2] = pred2 = (above[2] + above[3] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (above[3] + above[4] + 1) &gt;&gt; 1;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred4 = (above[0] + 2 * above[1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[1] = pred5 = (above[1] + 2 * above[2] +
                             above[3] + 2) &gt;&gt; 2;
       predict[2] = pred6 = (above[2] + 2 * above[3] +
                             above[4] + 2) &gt;&gt; 2;
       predict[3] = pred7 = (above[3] + 2 * above[4] +
                             above[5] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred1;
       predict[1] = pred2;
       predict[2] = pred3;
       predict[3] = pred8 = (above[4] + 2 * above[5] +
                             above[6] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred5;
       predict[1] = pred6;
       predict[2] = pred7;
       predict[3] = pred9 = (above[5] + 2 * above[6] +
                             above[7] + 2) &gt;&gt; 2;
   } static void
   predict_hd_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred0 = (left[ 0] + above[-1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (left[ 0] + 2 * above[-1] +
                             above[0] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (above[-1] + 2 * above[ 0] +
                             above[1] + 2) &gt;&gt; 2;
       predict[3] = pred3 = (above[ 0] + 2 * above[ 1] +
                             above[2] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred4 = (left[stride] + left[0] + 1) &gt;&gt; 1;
       predict[1] = pred5 = (left[stride] + 2 * left[0] +
                             above[-1] + 2) &gt;&gt; 2;
       predict[2] = pred0;
       predict[3] = pred1;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred6 = (left[stride*2] + left[stride] + 1) &gt;&gt; 1;
       predict[1] = pred7 = (left[stride*2] + 2 * left[stride] +
                             left[0] + 2) &gt;&gt; 2;
       predict[2] = pred4;
       predict[3] = pred5;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred8 = (left[stride*3] + left[stride*2] + 1) &gt;&gt; 1;
       predict[1] = pred9 = (left[stride*3] + 2 * left[stride*2] +
                             left[stride] + 2) &gt;&gt; 2;
       predict[2] = pred6;
       predict[3] = pred7;
   } static void
   predict_hu_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred0 = (left[stride*0] +
                             left[stride*1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (left[stride*0] + 2 * left[stride*1] +
                             left[stride*2] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (left[stride*1] + left[stride*2] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (left[stride*1] + 2 * left[stride*2] +
                             left[stride*3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred2;
       predict[1] = pred3;
       predict[2] = pred4 = (left[stride*2] + left[stride*3] + 1) &gt;&gt; 1;
       predict[3] = pred5 = (left[stride*2] + 2 * left[stride*3] +
                             left[stride*3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred4;
       predict[1] = pred5;
       predict[2] = pred6 = left[stride*3];
       predict[3] = pred6;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict[0] = pred6;
       predict[1] = pred6;
       predict[2] = pred6;
       predict[3] = pred6;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_h_16x16(unsigned char *predict, int stride) { predict_h_nxn(predict, stride, 16); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドpredict_h_16x16（unsigned char型*予測、INTストライド）{predict_h_nxnは（予測、ストライド、16）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   predict_v_16x16(unsigned char *predict, int stride)
   {
       predict_v_nxn(predict, stride, 16);
   } static void
   predict_tm_16x16(unsigned char *predict, int stride)
   {
       predict_tm_nxn(predict, stride, 16);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_h_8x8(unsigned char *predict, int stride) { predict_h_nxn(predict, stride, 8); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドpredict_h_8x8（unsigned char型*は、int型のストライドを予測）{predict_h_nxn（予測、ストライド、8）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_v_8x8(unsigned char *predict, int stride) { predict_v_nxn(predict, stride, 8); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドpredict_v_8x8（unsigned char型*は、int型のストライドを予測）{predict_v_nxn（予測、ストライド、8）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_tm_8x8(unsigned char *predict, int stride) { predict_tm_nxn(predict, stride, 8); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドpredict_tm_8x8（unsigned char型*は、int型のストライドを予測）{predict_tm_nxn（予測、ストライド、8）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_tm_4x4(unsigned char *predict, int stride) { predict_tm_nxn(predict, stride, 4); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドpredict_tm_4x4（unsigned char型*は、int型のストライドを予測）{predict_tm_nxn（予測、ストライド、4）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   copy_down(unsigned char           *recon,
             int                      stride)
   {
       /* Copy the four pixels above-right of subblock 3 to
        * above-right of subblocks 7, 11, and 15
        */
       uint32_t tmp, *copy = (void *)(recon + 16 - stride);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       stride = stride / sizeof(unsigned int);
       tmp = *copy;
       copy += stride * 4;
       *copy = tmp;
       copy += stride * 4;
       *copy = tmp;
       copy += stride * 4;
       *copy = tmp;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void b_pred(unsigned char *predict, int stride, struct mb_info *mbi, short *coeffs) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドb_pred（unsigned char型*、int型のストライドを予測構造体mb_info * MBI、短い* coeffs）{iはint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
copy_down(predict, stride);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
copy_down（予測、ストライド）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
for (i = 0; i &lt; 16; i++) { unsigned char *b_predict = predict + (i &amp; 3) * 4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
用（i = 0; iは16 &lt;; iは++）{unsigned char型* b_predict = +（I＆3）* 4を予測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           switch (mbi-&gt;split.modes[i])
           {
           case B_DC_PRED:
               predict_dc_nxn(b_predict, stride, 4);
               break;
           case B_TM_PRED:
               predict_tm_4x4(b_predict, stride);
               break;
           case B_VE_PRED:
               predict_ve_4x4(b_predict, stride);
               break;
           case B_HE_PRED:
               predict_he_4x4(b_predict, stride);
               break;
           case B_LD_PRED:
               predict_ld_4x4(b_predict, stride);
               break;
           case B_RD_PRED:
               predict_rd_4x4(b_predict, stride);
               break;
           case B_VR_PRED:
               predict_vr_4x4(b_predict, stride);
               break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           case B_VL_PRED:
               predict_vl_4x4(b_predict, stride);
               break;
           case B_HD_PRED:
               predict_hd_4x4(b_predict, stride);
               break;
           case B_HU_PRED:
               predict_hu_4x4(b_predict, stride);
               break;
           default:
               assert(0);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           vp8_dixie_idct_add(b_predict, b_predict, stride, coeffs);
           coeffs += 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 if ((i &amp; 3) == 3) { predict += stride * 4; } } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IF（（I＆3）== 3）{* 4 + =ストライドを予測します。 }}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的な無効
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   fixup_dc_coeffs(struct mb_info *mbi,
                   short          *coeffs)
   {
       short y2[16];
       int   i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vp8_dixie_walsh(coeffs + 24 * 16, y2);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vp8_dixie_walsh（coeffs + 24 * 16、Y2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 for (i = 0; i &lt; 16; i++) coeffs[i*16] = y2[i]; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用（i = 0; iは16 &lt;; iは++）coeffs [i *が16] = Y2 [I]。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_intra_luma(unsigned char *predict, int stride, struct mb_info *mbi, short *coeffs) { if (mbi-&gt;base.y_mode == B_PRED) b_pred(predict, stride, mbi, coeffs); else
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドpredict_intra_luma（unsigned char型は*、int型のストライドを予測する、構造体mb_info * MBI、短い* coeffs）{IF（mbi-&gt; base.y_mode == B_PRED）（、ストライド、MBI、coeffsを予測する）b_pred。他
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       {
           int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           switch (mbi-&gt;base.y_mode)
           {
           case DC_PRED:
               predict_dc_nxn(predict, stride, 16);
               break;
           case V_PRED:
               predict_v_16x16(predict, stride);
               break;
           case H_PRED:
               predict_h_16x16(predict, stride);
               break;
           case TM_PRED:
               predict_tm_16x16(predict, stride);
               break;
           default:
               assert(0);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
fixup_dc_coeffs(mbi, coeffs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
fixup_dc_coeffs（上、coeffs）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               vp8_dixie_idct_add(predict, predict, stride, coeffs);
               coeffs += 16;
               predict += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 if ((i &amp; 3) == 3) predict += stride * 4 - 16; } } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IF（（I＆3）== 3）+ =歩幅×4予測 -  16。 }}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_intra_chroma(unsigned char *predict_u, unsigned char *predict_v, int stride, struct mb_info *mbi, short *coeffs) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドpredict_intra_chroma（unsigned char型* predict_u、unsigned char型の*のpredict_v、INTストライド、構造体mb_info * MBI、短い* coeffs）{int型I。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       switch (mbi-&gt;base.uv_mode)
       {
       case DC_PRED:
           predict_dc_nxn(predict_u, stride, 8);
           predict_dc_nxn(predict_v, stride, 8);
           break;
       case V_PRED:
           predict_v_8x8(predict_u, stride);
           predict_v_8x8(predict_v, stride);
           break;
       case H_PRED:
           predict_h_8x8(predict_u, stride);
           predict_h_8x8(predict_v, stride);
           break;
       case TM_PRED:
           predict_tm_8x8(predict_u, stride);
           predict_tm_8x8(predict_v, stride);
           break;
       default:
           assert(0);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
coeffs += 16 * 16;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
coeffs * 16 + = 16;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 16; i &lt; 20; i++)
       {
           vp8_dixie_idct_add(predict_u, predict_u, stride, coeffs);
           coeffs += 16;
           predict_u += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 if (i &amp; 1) predict_u += stride * 4 - 8; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（I＆1）predict_u + =ストライド* 4から8。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 20; i &lt; 24; i++)
       {
           vp8_dixie_idct_add(predict_v, predict_v, stride, coeffs);
           coeffs += 16;
           predict_v += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (i &amp; 1)
               predict_v += stride * 4 - 8;
       }
   } static void
   sixtap_horiz(unsigned char       *output,
                int                  output_stride,
                const unsigned char *reference,
                int                  reference_stride,
                int                  cols,
                int                  rows,
                const filter_t       filter
               )
   {
       int r, c, temp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (r = 0; r &lt; rows; r++)
       {
           for (c = 0; c &lt; cols; c++)
           {
               temp = (reference[-2] * filter[0]) +
                      (reference[-1] * filter[1]) +
                      (reference[ 0] * filter[2]) +
                      (reference[ 1] * filter[3]) +
                      (reference[ 2] * filter[4]) +
                      (reference[ 3] * filter[5]) +
                      64;
               temp &gt;&gt;= 7;
               output[c] = CLAMP_255(temp);
               reference++;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           reference += reference_stride - cols;
           output += output_stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void sixtap_vert(unsigned char *output, int output_stride, const unsigned char *reference, int reference_stride, int cols, int rows, const filter_t filter ) { int r, c, temp;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドsixtap_vert（unsigned char型の*の出力、int型output_stride、CONSTはunsigned char *参照、INT reference_stride、INT colsの、INT行、CONST filter_tフィルタ）{int型のR、C、TEMP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (r = 0; r &lt; rows; r++)
       {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (c = 0; c &lt; cols; c++)
           {
               temp = (reference[-2*reference_stride] * filter[0]) +
                      (reference[-1*reference_stride] * filter[1]) +
                      (reference[ 0*reference_stride] * filter[2]) +
                      (reference[ 1*reference_stride] * filter[3]) +
                      (reference[ 2*reference_stride] * filter[4]) +
                      (reference[ 3*reference_stride] * filter[5]) +
                      64;
               temp &gt;&gt;= 7;
               output[c] = CLAMP_255(temp);
               reference++;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           reference += reference_stride - cols;
           output += output_stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void sixtap_2d(unsigned char *output, int output_stride, const unsigned char *reference, int reference_stride, int cols, int rows, int mx, int my, const filter_t filters[8] ) { DECLARE_ALIGNED(16, unsigned char, temp[16*(16+5)]);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドsixtap_2d（unsigned char型の*の出力、int型output_stride、CONSTはunsigned char *参照、INT reference_stride、INT colsの、INT行、INT MX、INT私、CONST filter_tフィルタ[8]）{DECLARE_ALIGNED（16、unsigned char型、TEMP [ 16 *（16 + 5）]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       sixtap_horiz(temp, 16,
                    reference - 2 * reference_stride, reference_stride,
                    cols, rows + 5, filters[mx]);
       sixtap_vert(output, output_stride,
                   temp + 2 * 16, 16,
                   cols, rows, filters[my]);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct img_index
   {
       unsigned char *y, *u, *v;
       int            stride, uv_stride;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char * filter_block(unsigned char *output, const unsigned char *reference, int stride, const union mv *mv, const filter_t filters[8]) { int mx, my;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数unsigned char型の*のfilter_block（unsigned char型の*の出力、CONSTはunsigned char *参照、INTストライド、CONST組合MV * MV、CONST filter_tフィルタ[8]）{int型のMX、私。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Handle 0,0 as a special case.  TODO: Does this make it any
        * faster?
        */
       if (!mv-&gt;raw)
           return reference;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       mx = mv-&gt;d.x &amp; 7;
       my = mv-&gt;d.y &amp; 7;
       reference += ((mv-&gt;d.y &gt;&gt; 3) * stride) + (mv-&gt;d.x &gt;&gt; 3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mx | my)
       {
           sixtap_2d(output, stride, reference, stride, 4, 4, mx, my,
                     filters);
           reference = output;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return reference; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void recon_1_block(unsigned char *output, const unsigned char *reference, int stride, const union mv *mv, const filter_t filters[8], short *coeffs, struct mb_info *mbi, int b ) { const unsigned char *predict;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドrecon_1_block（unsigned char型の*の出力、CONSTはunsigned char *参照、INTストライド、CONST組合MV * MV、CONST filter_tフィルタ[8]、短い* coeffs、構造体mb_info * MBI、int型B）{CONSTはunsigned char *予測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict = filter_block(output, reference, stride, mv, filters);
       vp8_dixie_idct_add(output, predict, stride, coeffs + 16 * b);
   } static mv_t
   calculate_chroma_splitmv(struct mb_info *mbi,
                            int             b,
                            int             full_pixel)
   {
       int temp;
       union mv mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       temp = mbi-&gt;split.mvs[b].d.x +
              mbi-&gt;split.mvs[b+1].d.x +
              mbi-&gt;split.mvs[b+4].d.x +
              mbi-&gt;split.mvs[b+5].d.x;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (temp &lt; 0)
           temp -= 4;
       else
           temp += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
mv.d.x = temp / 8;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
mv.d.x = TEMP / 8。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
temp = mbi-&gt;split.mvs[b].d.y + mbi-&gt;split.mvs[b+1].d.y + mbi-&gt;split.mvs[b+4].d.y + mbi-&gt;split.mvs[b+5].d.y;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
TEMP =オーバー&gt; split.mvs [B] .dyオーバー+&gt; split.mvs [B + 1] + .dyオーバー&gt; split.mvs [B + 4] + .dyオーバー&gt; split.mvs [B +5] .dy。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (temp &lt; 0)
           temp -= 4;
       else
           temp += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
mv.d.y = temp / 8;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
mv.d.y = TEMP / 8。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (full_pixel)
       {
           mv.d.x &amp;= ~7;
           mv.d.y &amp;= ~7;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return mv; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MVを返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Note: We rely on the reconstructed border having the same stride
    * as the reference buffer because the filter_block can&#39;t adjust the
    * stride with its return value, only the reference pointer.
    */
   static void
   build_mc_border(unsigned char       *dst,
                   const unsigned char *src,
                   int                  stride,
                   int                  x,
                   int                  y,
                   int                  b_w,
                   int                  b_h,
                   int                  w,
                   int                  h
                  )
   {
       const unsigned char *ref_row;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Get a pointer to the start of the real data for this row */
       ref_row = src - x - y * stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (y &gt;= h)
           ref_row += (h - 1) * stride;
       else if (y &gt; 0)
           ref_row += y * stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
do { int left, right = 0, copy;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
やる{左、右= 0、コピーをint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
left = x &lt; 0 ? -x : 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
左=のx &lt;0の？ -x：0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (left &gt; b_w) left = b_w;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
IF（左&gt; B_W）左= B_W。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (x + b_w &gt; w) right = x + b_w - w;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
IF（X + B_W&gt; W）右= X + B_W  -  W。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (right &gt; b_w) right = b_w;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
IF（右&gt; B_W）右= B_W。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
copy = b_w - left - right;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
コピー= B_Wは - 左 - 右。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (left) memset(dst, ref_row[0], left);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
memset（DST、ref_row [0]、左）（左）であれば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (copy) memcpy(dst + left, ref_row + x + left, copy);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
（コピー）のmemcpy（DST +左、ref_row + X +左、コピー）する場合、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (right) memset(dst + left + copy, ref_row[w-1], right);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
（右）のmemset場合（DST +左+コピー、ref_row [W-1]、右）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           dst += stride;
           y++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (y &lt; h &amp;&amp; y &gt; 0)
               ref_row += stride;
       }
       while (--b_h);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   recon_1_edge_block(unsigned char        *output,
                      unsigned char        *emul_block,
                      const unsigned char  *reference,
                      int                   stride,
                      const union mv       *mv,
                      const filter_t        filters[8],
                      short                *coeffs,
                      struct mb_info       *mbi,
                      int                   x,
                      int                   y,
                      int                   w,
                      int                   h,
                      int                   start_b
                     )
   {
       const unsigned char *predict;
       int                  b = start_b;
       const int            b_w = 4;
       const int            b_h = 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       x += mv-&gt;d.x &gt;&gt; 3;
       y += mv-&gt;d.y &gt;&gt; 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Need two pixels left/above, 3 right/below for 6-tap */
       if (x &lt; 2 || x + b_w - 1 + 3 &gt;= w || y &lt; 2 ||
           y + b_h - 1 + 3 &gt;= h)
       {
           reference += (mv-&gt;d.x &gt;&gt; 3) + (mv-&gt;d.y &gt;&gt; 3) * stride;
           build_mc_border(emul_block,
                           reference - 2 - 2 * stride, stride,
                           x - 2, y - 2, b_w + 5, b_h + 5, w, h);
           reference = emul_block + 2 * stride + 2;
           reference -= (mv-&gt;d.x &gt;&gt; 3) + (mv-&gt;d.y &gt;&gt; 3) * stride;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       predict = filter_block(output, reference, stride, mv, filters);
       vp8_dixie_idct_add(output, predict, stride, coeffs + 16 * b);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   predict_inter_emulated_edge(struct vp8_decoder_ctx  *ctx,
                               struct img_index        *img,
                               short                   *coeffs,
                               struct mb_info          *mbi,
                               int                      mb_col,
                               int                      mb_row)
   {
       /* TODO: Move this into its own buffer.  This only works because
        * we still have a border allocated.
        */
       unsigned char *emul_block = ctx-&gt;frame_strg[0].img.img_data;
       unsigned char *reference;
       unsigned char *output;
       ptrdiff_t      reference_offset;
       int            w, h, x, y, b;
       union mv       chroma_mv[4];
       unsigned char *u = img-&gt;u, *v = img-&gt;v;
       int            full_pixel = ctx-&gt;frame_hdr.version == 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       x = mb_col * 16;
       y = mb_row * 16;
       w = ctx-&gt;mb_cols * 16;
       h = ctx-&gt;mb_rows * 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       output = img-&gt;y;
       reference_offset = ctx-&gt;ref_frame_offsets[mbi-&gt;base.ref_frame];
       reference = output + reference_offset;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (mbi-&gt;base.y_mode != SPLITMV) { union mv uvmv;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（もし！mbi-&gt; base.y_mode = SPLITMV）{組合のMV uvmv。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           uvmv = mbi-&gt;base.mv;
           uvmv.d.x = (uvmv.d.x + 1 + (uvmv.d.x &gt;&gt; 31) * 2) / 2;
           uvmv.d.y = (uvmv.d.y + 1 + (uvmv.d.y &gt;&gt; 31) * 2) / 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (full_pixel)
           {
               uvmv.d.x &amp;= ~7;
               uvmv.d.y &amp;= ~7;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           chroma_mv[0] = uvmv;
           chroma_mv[1] = uvmv;
           chroma_mv[2] = uvmv;
           chroma_mv[3] = uvmv;
       }
       else
       {
           chroma_mv[0] = calculate_chroma_splitmv(mbi,  0, full_pixel);
           chroma_mv[1] = calculate_chroma_splitmv(mbi,  2, full_pixel);
           chroma_mv[2] = calculate_chroma_splitmv(mbi,  8, full_pixel);
           chroma_mv[3] = calculate_chroma_splitmv(mbi, 10, full_pixel);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Luma */
       for (b = 0; b &lt; 16; b++)
       {
           union mv *ymv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode != SPLITMV)
               ymv = &amp;mbi-&gt;base.mv;
           else
               ymv = mbi-&gt;split.mvs + b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
recon_1_edge_block(output, emul_block, reference, img-&gt;stride, ymv, ctx-&gt;subpixel_filters, coeffs, mbi, x, y, w, h, b);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
recon_1_edge_block（出力、emul_block、参照、IMG-&gt;ストライド、YMV、ctx-&gt; subpixel_filters、coeffs、MBI、X、Y、W、H、B）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           x += 4;
           output += 4;
           reference += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((b &amp; 3) == 3)
           {
               x -= 16;
               y += 4;
               output += 4 * img-&gt;stride - 16;
               reference += 4 * img-&gt;stride - 16;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       x = mb_col * 16;
       y = mb_row * 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Chroma */
       x &gt;&gt;= 1;
       y &gt;&gt;= 1;
       w &gt;&gt;= 1;
       h &gt;&gt;= 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (b = 0; b &lt; 4; b++)
       {
           recon_1_edge_block(u, emul_block, u + reference_offset,
                              img-&gt;uv_stride,
                              &amp;chroma_mv[b], ctx-&gt;subpixel_filters,
                              coeffs, mbi, x, y, w, h, b + 16);
           recon_1_edge_block(v, emul_block, v + reference_offset,
                              img-&gt;uv_stride,
                              &amp;chroma_mv[b], ctx-&gt;subpixel_filters,
                              coeffs, mbi, x, y, w, h, b + 20);
           u += 4;
           v += 4;
           x += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (b &amp; 1)
           {
               x -= 8;
               y += 4;
               u += 4 * img-&gt;uv_stride - 8;
               v += 4 * img-&gt;uv_stride - 8;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_inter(struct vp8_decoder_ctx *ctx, struct img_index *img, short *coeffs, struct mb_info *mbi)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的な無効predict_inter（構造体vp8_decoder_ctx * CTX、構造体img_index * IMG、短い* coeffs、構造体mb_info * MBI）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   {
       unsigned char *y = img-&gt;y;
       unsigned char *u = img-&gt;u;
       unsigned char *v = img-&gt;v;
       ptrdiff_t      reference_offset;
       union mv       chroma_mv[4];
       int            full_pixel = ctx-&gt;frame_hdr.version == 3;
       int b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mbi-&gt;base.y_mode != SPLITMV)
       {
           union mv             uvmv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           uvmv = mbi-&gt;base.mv;
           uvmv.d.x = (uvmv.d.x + 1 + (uvmv.d.x &gt;&gt; 31) * 2) / 2;
           uvmv.d.y = (uvmv.d.y + 1 + (uvmv.d.y &gt;&gt; 31) * 2) / 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (full_pixel)
           {
               uvmv.d.x &amp;= ~7;
               uvmv.d.y &amp;= ~7;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           chroma_mv[0] =
               chroma_mv[1] =
                   chroma_mv[2] =
                       chroma_mv[3] = uvmv;
       }
       else
       {
           chroma_mv[0] = calculate_chroma_splitmv(mbi,  0, full_pixel);
           chroma_mv[1] = calculate_chroma_splitmv(mbi,  2, full_pixel);
           chroma_mv[2] = calculate_chroma_splitmv(mbi,  8, full_pixel);
           chroma_mv[3] = calculate_chroma_splitmv(mbi, 10, full_pixel);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
reference_offset = ctx-&gt;ref_frame_offsets[mbi-&gt;base.ref_frame];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
reference_offset = ctx-&gt; ref_frame_offsets [mbi-&gt; base.ref_frame]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
for (b = 0; b &lt; 16; b++) { union mv *ymv;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（; B &lt;16; B = 0、B ++）用{組合MV * YMV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode != SPLITMV)
               ymv = &amp;mbi-&gt;base.mv;
           else
               ymv = mbi-&gt;split.mvs + b;
           recon_1_block(y, y + reference_offset, img-&gt;stride,
                         ymv, ctx-&gt;subpixel_filters, coeffs, mbi, b);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
y += 4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
そして+ = 4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 if ((b &amp; 3) == 3) y += 4 * img-&gt;stride - 16; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（（B＆3）== 3）Y + = 4 * IMG-&gt;ストライド -  16。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (b = 0; b &lt; 4; b++)
       {
           recon_1_block(u, u + reference_offset,
                         img-&gt;uv_stride, &amp;chroma_mv[b],
                         ctx-&gt;subpixel_filters, coeffs, mbi, b + 16);
           recon_1_block(v, v + reference_offset,
                         img-&gt;uv_stride, &amp;chroma_mv[b],
                         ctx-&gt;subpixel_filters, coeffs, mbi, b + 20);
           u += 4;
           v += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (b &amp; 1)
           {
               u += 4 * img-&gt;uv_stride - 8;
               v += 4 * img-&gt;uv_stride - 8;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void
   vp8_dixie_release_ref_frame(struct ref_cnt_img *rcimg)
   {
       if (rcimg)
       {
           assert(rcimg-&gt;ref_cnt);
           rcimg-&gt;ref_cnt--;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_ref_frame(struct ref_cnt_img *rcimg)
   {
       rcimg-&gt;ref_cnt++;
       return rcimg;
   } struct ref_cnt_img *
   vp8_dixie_find_free_ref_frame(struct ref_cnt_img *frames)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
           if (frames[i].ref_cnt == 0)
           {
               frames[i].ref_cnt = 1;
               return &amp;frames[i];
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       assert(0);
       return NULL;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   fixup_left(unsigned char        *predict,
              int                   width,
              int                   stride,
              unsigned int          row,
              enum prediction_mode  mode)
   {
       /* The left column of out-of-frame pixels is taken to be 129,
        * unless we&#39;re doing DC_PRED, in which case we duplicate the
        * above row, unless this is also row 0, in which case we use
        * 129.
        */
       unsigned char *left = predict - 1;
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode == DC_PRED &amp;&amp; row)
       {
           unsigned char *above = predict - stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; width; i++)
           {
               *left = above[i];
               left += stride;
           }
       }
       else
       {
           /* Need to re-set the above row, in case the above MB was
            * DC_PRED.
            */
           left -= stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = -1; i &lt; width; i++)
           {
               *left = 129;
               left += stride;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   fixup_above(unsigned char        *predict,
               int                   width,
               int                   stride,
               unsigned int          col,
               enum prediction_mode  mode)
   {
       /* The above row of out-of-frame pixels is taken to be 127,
        * unless we&#39;re doing DC_PRED, in which case we duplicate the
        * left col, unless this is also col 0, in which case we use
        * 127.
        */
       unsigned char *above = predict - stride;
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode == DC_PRED &amp;&amp; col)
       {
           unsigned char *left = predict - 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; width; i++)
           {
               above[i] = *left;
               left += stride;
           }
       }
       else
           /* Need to re-set the left col, in case the last MB was
            * DC_PRED.
            */
           memset(above - 1, 127, width + 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 memset(above + width, 127, 4); // for above-right subblock modes } void vp8_dixie_predict_init(struct vp8_decoder_ctx *ctx) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
memsetの（+幅、127以上の、4）。 //上記右サブブロックモードに対する}ボイドvp8_dixie_predict_init（構造体vp8_decoder_ctx * CTX）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int i;
       unsigned char *this_frame_base;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           for (i = 0; i &lt; NUM_REF_FRAMES; i++)
           {
               unsigned int w = ctx-&gt;mb_cols * 16 + BORDER_PIXELS * 2;
               unsigned int h = ctx-&gt;mb_rows * 16 + BORDER_PIXELS * 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               vpx_img_free(&amp;ctx-&gt;frame_strg[i].img);
               ctx-&gt;frame_strg[i].ref_cnt = 0;
               ctx-&gt;ref_frames[i] = NULL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if (!vpx_img_alloc(&amp;ctx-&gt;frame_strg[i].img, IMG_FMT_I420, w, h, 16)) vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_MEM_ERROR, &#34;Failed to allocate %dx%d&#34; &#34; framebuffer&#34;, w, h);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
IF（！vpx_img_alloc（＆ctx-&gt; frame_strg [I] .IMG、IMG_FMT_I420、W、H、16））vpx_internal_error（＆ctx-&gt;エラー、VPX_CODEC_MEM_ERRORは、 &#34;％DX％D割当てに失敗しました&#34;、 &#34;フレームバッファ&#34;、H、W） ;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
vpx_img_set_rect(&amp;ctx-&gt;frame_strg[i].img, BORDER_PIXELS, BORDER_PIXELS, ctx-&gt;frame_hdr.kf.w, ctx-&gt;frame_hdr.kf.h);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
vpx_img_set_rect（＆ctx-&gt; frame_strg [I] .IMG、BORDER_PIXELS、BORDER_PIXELS、ctx-&gt; frame_hdr.kf.w、ctx-&gt; frame_hdr.kf.h）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (ctx-&gt;frame_hdr.version)
               ctx-&gt;subpixel_filters = bilinear_filters;
           else
               ctx-&gt;subpixel_filters = sixtap_filters;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Find a free framebuffer to predict into */
       if (ctx-&gt;ref_frames[CURRENT_FRAME])
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ctx-&gt;ref_frames[CURRENT_FRAME] =
           vp8_dixie_find_free_ref_frame(ctx-&gt;frame_strg);
       this_frame_base = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.img_data;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Calculate offsets to the other reference frames */
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
       {
           struct ref_cnt_img  *ref = ctx-&gt;ref_frames[i];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 ctx-&gt;ref_frame_offsets[i] = ref ? ref-&gt;img.img_data - this_frame_base : 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ctx-&gt; ref_frame_offsets [I] = REF？ REF-&gt; img.img_data  -  this_frame_base：0; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* TODO: No need to do this on every frame... */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_destroy(struct vp8_decoder_ctx *ctx) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_predict_destroy（構造体vp8_decoder_ctxの*のCTX）{私はint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
       {
           vpx_img_free(&amp;ctx-&gt;frame_strg[i].img);
           ctx-&gt;frame_strg[i].ref_cnt = 0;
           ctx-&gt;ref_frames[i] = NULL;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void
   vp8_dixie_predict_process_row(struct vp8_decoder_ctx *ctx,
                                 unsigned int            row,
                                 unsigned int            start_col,
                                 unsigned int            num_cols)
   {
       struct img_index img;
       struct mb_info *mbi;
       unsigned int    col;
       short          *coeffs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
       img.stride =
           ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       img.uv_stride =
           ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_U];
       img.y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       img.u = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_U];
       img.v = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_V];
       img.y += (img.stride * row + start_col) * 16;
       img.u += (img.uv_stride * row + start_col) * 8;
       img.v += (img.uv_stride * row + start_col) * 8;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
       coeffs = ctx-&gt;tokens[row &amp;
           (ctx-&gt;token_hdr.partitions - 1)].coeffs +
           25 * 16 * start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Fix up the out-of-frame pixels */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (start_col == 0)
       {
           fixup_left(img.y, 16, img.stride, row, mbi-&gt;base.y_mode);
           fixup_left(img.u, 8, img.uv_stride, row, mbi-&gt;base.uv_mode);
           fixup_left(img.v, 8, img.uv_stride, row, mbi-&gt;base.uv_mode);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 if (row == 0) *(img.y - img.stride - 1) = 127; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（行== 0）*（img.y  -  img.stride  -  1）= 127。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           if (row == 0)
           {
               fixup_above(img.y, 16, img.stride, col,
                           mbi-&gt;base.y_mode);
               fixup_above(img.u, 8, img.uv_stride, col,
                           mbi-&gt;base.uv_mode);
               fixup_above(img.v, 8, img.uv_stride, col,
                           mbi-&gt;base.uv_mode);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode &lt;= B_PRED)
           {
               predict_intra_luma(img.y, img.stride, mbi, coeffs);
               predict_intra_chroma(img.u, img.v, img.uv_stride, mbi,
                                    coeffs);
           } else
           {
               if (mbi-&gt;base.y_mode != SPLITMV) // &amp;&amp; != BPRED
                   fixup_dc_coeffs(mbi, coeffs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (mbi-&gt;base.need_mc_border)
                   predict_inter_emulated_edge(ctx, &amp;img, coeffs, mbi,
                                               col, row);
               else
                   predict_inter(ctx, &amp;img, coeffs, mbi);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Advance to the next macroblock */
           mbi++;
           img.y += 16;
           img.u += 8;
           img.v += 8;
           coeffs += 25 * 16;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (col == ctx-&gt;mb_cols)
       {
           /* Extend the last row by four pixels for intra-prediction.
            * This will be propagated later by copy_down.
            */
           uint32_t *extend = (uint32_t *)(img.y + 15 * img.stride);
           uint32_t  val = 0x01010101 * img.y[-1 + 15 * img.stride];
           *extend = val;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.15. predict.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.15。 predict.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef PREDICT_H
   #define PREDICT_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_predict_init（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_destroy(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_predict_destroy（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_process_row(struct vp8_decoder_ctx *ctx, unsigned int row, unsigned int start_col, unsigned int num_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボイドvp8_dixie_predict_process_row（構造体vp8_decoder_ctx * CTX、unsigned int型の行、unsigned int型start_col、unsigned int型NUM_COLS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_release_ref_frame(struct ref_cnt_img *rcimg);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_release_ref_frame（構造体ref_cnt_imgの*のrcimg）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
struct ref_cnt_img * vp8_dixie_ref_frame(struct ref_cnt_img *rcimg);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体ref_cnt_img * vp8_dixie_ref_frame（構造体ref_cnt_img * rcimg）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
struct ref_cnt_img * vp8_dixie_find_free_ref_frame(struct ref_cnt_img *frames);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体ref_cnt_img * vp8_dixie_find_free_ref_frame（構造体ref_cnt_img *フレーム）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.16. tokens.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.16。 tokens.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;dixie.h&#34;
   #include &#34;tokens.h&#34;
   #include &lt;stdlib.h&gt;
   #include &lt;string.h&gt;
   #include &lt;malloc.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum { EOB_CONTEXT_NODE, ZERO_CONTEXT_NODE, ONE_CONTEXT_NODE, LOW_VAL_CONTEXT_NODE, TWO_CONTEXT_NODE, THREE_CONTEXT_NODE, HIGH_LOW_CONTEXT_NODE, CAT_ONE_CONTEXT_NODE, CAT_THREEFOUR_CONTEXT_NODE, CAT_THREE_CONTEXT_NODE, CAT_FIVE_CONTEXT_NODE }; enum { ZERO_TOKEN, ONE_TOKEN, TWO_TOKEN, THREE_TOKEN, FOUR_TOKEN, DCT_VAL_CATEGORY1, DCT_VAL_CATEGORY2, DCT_VAL_CATEGORY3,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙{EOB_CONTEXT_NODE、ZERO_CONTEXT_NODE、ONE_CONTEXT_NODE、LOW_VAL_CONTEXT_NODE、TWO_CONTEXT_NODE、THREE_CONTEXT_NODE、HIGH_LOW_CONTEXT_NODE、CAT_ONE_CONTEXT_NODE、CAT_THREEFOUR_CONTEXT_NODE、CAT_THREE_CONTEXT_NODE、CAT_FIVE_CONTEXT_NODE}。列挙{ZERO_TOKEN、ONE_TOKEN、TWO_TOKEN、THREE_TOKEN、FOUR_TOKEN、DCT_VAL_CATEGORY1、DCT_VAL_CATEGORY2、DCT_VAL_CATEGORY3、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       DCT_VAL_CATEGORY4,
       DCT_VAL_CATEGORY5,
       DCT_VAL_CATEGORY6,
       DCT_EOB_TOKEN,
       MAX_ENTROPY_TOKENS
   };
   struct extrabits
   {
       short         min_val;
       short         length;
       unsigned char probs[12];
   };
   static const unsigned int left_context_index[25] =
   {
       0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
       4, 4, 5, 5, 6, 6, 7, 7, 8
   };
   static const unsigned int above_context_index[25] =
   {
       0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,
       4, 5, 4, 5, 6, 7, 6, 7, 8
   };
   #define X(n) ((n) * PREV_COEFF_CONTEXTS * ENTROPY_NODES)
   static const unsigned int bands_x[16] =
   {
       X(0), X(1), X(2), X(3), X(6), X(4), X(5), X(6),
       X(6), X(6), X(6), X(6), X(6), X(6), X(6), X(7)
   };
   #undef X
   static const struct extrabits extrabits[MAX_ENTROPY_TOKENS] =
   {
       { 0, -1, {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //ZERO_TOKEN
       { 1, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //ONE_TOKEN
       { 2, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //TWO_TOKEN
       { 3, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //THREE_TOKEN
       { 4, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //FOUR_TOKEN
       { 5, 0,  {159,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY1
       { 7, 1,  {145, 165,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY2
       {11, 2,  {140, 148, 173,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 {19, 3, {135, 140, 155, 176, 0, 0, 0, 0, 0, 0, 0, 0 } }, //DCT_VAL_CATEGORY4 {35, 4, {130, 134, 141, 157, 180, 0, 0, 0, 0, 0, 0, 0 } }, //DCT_VAL_CATEGORY5 {67, 10, {129, 130, 133, 140, 153, 177, 196, 230, 243, 254, 254, 0 } }, //DCT_VAL_CATEGORY6 { 0, -1, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, // EOB TOKEN };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{19、3、{135、140、155、176、0、0、0、0、0、0、0、0}} // DCT_VAL_CATEGORY4 {35、4、{130、134、141、157、180 、0、0、0、0、0、0、0}} // DCT_VAL_CATEGORY5 {67、10、{129、130、133、140、153、177、196、230、243、254、254、0} } // DCT_VAL_CATEGORY6 {0、-1、{0、0、0、0、0、0、0、0、0、0、0、0}} // EOB TOKEN}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned int zigzag[16] = { 0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数unsigned int型ジグザグ[16] = {0、1、4、8、5、2、3、6、9、12、13、10、7、11、14、15}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define DECODE_AND_APPLYSIGN(value_to_sign) \ v = (bool_get_bit(bool) ? -value_to_sign \ : value_to_sign) * dqf[!!c];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define DECODE_AND_APPLYSIGN（value_to_sign）\ V =（bool_get_bit（BOOL）-value_to_sign \：value_to_sign）* DQF [!! C]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define DECODE_AND_BRANCH_IF_ZERO(probability,branch) \ if (!bool_get(bool, probability)) goto branch;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define DECODE_AND_BRANCH_IF_ZERO（確率、ブランチ）\もし後藤ブランチ（bool_get（ブール値、確率）！）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define DECODE_AND_LOOP_IF_ZERO(probability,branch) \
       if (!bool_get(bool, probability)) \
       { \
           prob = type_probs; \
           if (c&lt;15) {\
               ++c; \
               prob += bands_x[c]; \
               goto branch; \
           }\
           else \
               goto BLOCK_FINISHED; /* for malformed input */\
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val) \ DECODE_AND_APPLYSIGN(val) \ prob = type_probs + (ENTROPY_NODES*2); \ if (c &lt; 15){\ b_tokens[zigzag[c]] = v; \ ++c; \ goto DO_WHILE; }\ b_tokens[zigzag[15]] = v; \ goto BLOCK_FINISHED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（ヴァル）\ DECODE_AND_APPLYSIGN（ヴァル）\ PROB = type_probs +（ENTROPY_NODES * 2）。 \（C &lt;15）{\ b_tokens [ジグザグ[C] = Vであれば、 \ C ++; \後藤DO_WHILE。 } \ b_tokens [ジグザグ[15] = V。 \後藤BLOCK_FINISHED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define DECODE_EXTRABIT_AND_ADJUST_VAL(t,bits_count)\ val += bool_get(bool, extrabits[t].probs[bits_count]) &lt;&lt; \ bits_count;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define DECODE_EXTRABIT_AND_ADJUST_VAL（T、bits_count）\ヴァル+ = bool_get &lt;&lt; \ bits_count（BOOL、extrabits [t]は[bits_count]を.probs）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static int
   decode_mb_tokens(struct bool_decoder  *bool,
                    token_entropy_ctx_t   left,
                    token_entropy_ctx_t   above,
                    short                *tokens,
                    enum prediction_mode  mode,
                    coeff_probs_table_t   probs,
                    short                 factor[TOKEN_BLOCK_TYPES][2])
   {
       int            i, stop, type;
       int            c, t, v;
       int            val, bits_count;
       int            eob_mask;
       short         *b_tokens;   // tokens for this block
       unsigned char *type_probs; // probabilities for this block type
       unsigned char *prob;
       short         *dqf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
eob_mask = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
eob_mask = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode != B_PRED &amp;&amp; mode != SPLITMV)
       {
           i = 24;
           stop = 24;
           type = 1;
           b_tokens = tokens + 24 * 16;
           dqf = factor[TOKEN_BLOCK_Y2];
       }
       else
       {
           i = 0;
           stop = 16;
           type = 3;
           b_tokens = tokens;
           dqf = factor[TOKEN_BLOCK_Y1];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Save a pointer to the coefficient probs for the current type.
        * Need to repeat this whenever type changes.
        */
       type_probs = probs[type][0][0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   BLOCK_LOOP:
       t = left[left_context_index[i]] + above[above_context_index[i]];
       c = !type; /* all blocks start at 0 except type 0, which starts
                   * at 1. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       prob = type_probs;
       prob += t * ENTROPY_NODES;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   DO_WHILE:
       prob += bands_x[c];
       DECODE_AND_BRANCH_IF_ZERO(prob[EOB_CONTEXT_NODE],
         BLOCK_FINISHED);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CHECK_0_:
       DECODE_AND_LOOP_IF_ZERO(prob[ZERO_CONTEXT_NODE], CHECK_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[ONE_CONTEXT_NODE],
                                 ONE_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[LOW_VAL_CONTEXT_NODE],
                                 LOW_VAL_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[HIGH_LOW_CONTEXT_NODE],
                                 HIGH_LOW_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_THREEFOUR_CONTEXT_NODE],
                                 CAT_THREEFOUR_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_FIVE_CONTEXT_NODE],
                                 CAT_FIVE_CONTEXT_NODE_0_);
       val = extrabits[DCT_VAL_CATEGORY6].min_val;
       bits_count = extrabits[DCT_VAL_CATEGORY6].length;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       do
       {
           DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY6,
             bits_count);
           bits_count --;
       }
       while (bits_count &gt;= 0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（ヴァル）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CAT_FIVE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY5].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 4);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 3);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CAT_THREEFOUR_CONTEXT_NODE_0_:
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_THREE_CONTEXT_NODE],
                                 CAT_THREE_CONTEXT_NODE_0_);
       val = extrabits[DCT_VAL_CATEGORY4].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 3);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CAT_THREE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY3].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HIGH_LOW_CONTEXT_NODE_0_: DECODE_AND_BRANCH_IF_ZERO(prob[CAT_ONE_CONTEXT_NODE], CAT_ONE_CONTEXT_NODE_0_);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HIGH_LOW_CONTEXT_NODE_0_：DECODE_AND_BRANCH_IF_ZERO（PROB [CAT_ONE_CONTEXT_NODE]、CAT_ONE_CONTEXT_NODE_0_）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       val = extrabits[DCT_VAL_CATEGORY2].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY2, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY2, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CAT_ONE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY1].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY1, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   LOW_VAL_CONTEXT_NODE_0_:
       DECODE_AND_BRANCH_IF_ZERO(prob[TWO_CONTEXT_NODE],
                                 TWO_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[THREE_CONTEXT_NODE],
                                 THREE_CONTEXT_NODE_0_);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(4);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
THREE_CONTEXT_NODE_0_: DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(3);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
THREE_CONTEXT_NODE_0_：DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TWO_CONTEXT_NODE_0_: DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(2);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TWO_CONTEXT_NODE_0_：DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ONE_CONTEXT_NODE_0_:
       DECODE_AND_APPLYSIGN(1);
       prob = type_probs + ENTROPY_NODES;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (c &lt; 15)
       {
           b_tokens[zigzag[c]] = v;
           ++c;
           goto DO_WHILE;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       b_tokens[zigzag[15]] = v;
   BLOCK_FINISHED:
       eob_mask |= (c &gt; 1) &lt;&lt; i;
       t = (c != !type);   // any non-zero data?
       eob_mask |= t &lt;&lt; 31;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       left[left_context_index[i]] = above[above_context_index[i]] = t;
       b_tokens += 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
i++;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
I ++;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (i &lt; stop) goto BLOCK_LOOP;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
もし（私はストップを&lt;）後藤BLOCK_LOOP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (i == 25)
       {
           type = 0;
           i = 0;
           stop = 16;
           type_probs = probs[type][0][0];
           b_tokens = tokens;
           dqf = factor[TOKEN_BLOCK_Y1];
           goto BLOCK_LOOP;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (i == 16)
       {
           type = 2;
           type_probs = probs[type][0][0];
           stop = 24;
           dqf = factor[TOKEN_BLOCK_UV];
           goto BLOCK_LOOP;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return eob_mask;
   } static void
   reset_row_context(token_entropy_ctx_t *left)
   {
       memset(left, 0, sizeof(*left));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void reset_above_context(token_entropy_ctx_t *above, unsigned int cols) { memset(above, 0, cols * sizeof(*above)); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的ボイドreset_above_context（token_entropy_ctx_t *上記、unsigned int型COLS）{memsetの（上記、0、COLS *はsizeof（*上記））。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static void
   reset_mb_context(token_entropy_ctx_t  *left,
                    token_entropy_ctx_t  *above,
                    enum prediction_mode  mode)
   {
       /* Reset the macroblock context on the left and right.  We have
        * to preserve the context of the second order block if this mode
        * would not have updated it.
        */
       memset(left, 0, sizeof((*left)[0]) * 8);
       memset(above, 0, sizeof((*above)[0]) * 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode != B_PRED &amp;&amp; mode != SPLITMV)
       {
           (*left)[8] = 0;
           (*above)[8] = 0;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void
   vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,
                                unsigned int            partition,
                                unsigned int            row,
                                unsigned int            start_col,
                                unsigned int            num_cols)
   {
       struct token_decoder *tokens = &amp;ctx-&gt;tokens[partition];
       short              coeffs = tokens-&gt;coeffs + 25 * 16 * start_col;
       unsigned int       col;
       token_entropy_ctx_t  *above = ctx-&gt;above_token_entropy_ctx
                                     + start_col;
       token_entropy_ctx_t  *left = &amp;tokens-&gt;left_token_entropy_ctx;
       struct mb_info       *mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (row == 0)
           reset_above_context(above, num_cols);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (start_col == 0) reset_row_context(left);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（start_col == 0）reset_row_context（左）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
for (col = start_col; col &lt; start_col + num_cols; col++) { memset(coeffs, 0, 25 * 16 * sizeof(short));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
用（COL = start_col; COL &lt;start_col + NUM_COLS; COL ++）{memsetの（coeffs、0、25 * 16 *はsizeof（ショート））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (mbi-&gt;base.skip_coeff)
           {
               reset_mb_context(left, above, mbi-&gt;base.y_mode);
               mbi-&gt;base.eob_mask = 0;
           }
           else
           {
               struct dequant_factors *dqf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               dqf = ctx-&gt;dequant_factors  + mbi-&gt;base.segment_id;
               mbi-&gt;base.eob_mask =
                   decode_mb_tokens(&amp;tokens-&gt;bool,
                                    *left, *above,
                                    coeffs,
                                    mbi-&gt;base.y_mode,
                                    ctx-&gt;entropy_hdr.coeff_probs,
                                    dqf-&gt;factor);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           above++;
           mbi++;
           coeffs += 25 * 16;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_init(struct vp8_decoder_ctx *ctx) { unsigned int partitions = ctx-&gt;token_hdr.partitions;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボイドvp8_dixie_tokens_init（構造体vp8_decoder_ctx * CTX）{unsigned int型のパーティション= ctx-&gt; token_hdr.partitions。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           unsigned int i;
           unsigned int coeff_row_sz =
               ctx-&gt;mb_cols * 25 * 16 * sizeof(short);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i = 0; i &lt; partitions; i++)
           {
               free(ctx-&gt;tokens[i].coeffs);
               ctx-&gt;tokens[i].coeffs = memalign(16, coeff_row_sz);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
 if (!ctx-&gt;tokens[i].coeffs) vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_MEM_ERROR, NULL); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
（もし！ctx-&gt;トークン[i]の.coeffs）vpx_internal_error（＆ctx-&gt;エラー、VPX_CODEC_MEM_ERROR、NULL）; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           free(ctx-&gt;above_token_entropy_ctx);
           ctx-&gt;above_token_entropy_ctx =
               calloc(ctx-&gt;mb_cols,
               sizeof(*ctx-&gt;above_token_entropy_ctx));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 if (!ctx-&gt;above_token_entropy_ctx) vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_MEM_ERROR, NULL); } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もしvpx_internal_error（＆ctx-&gt;エラー、VPX_CODEC_MEM_ERROR、NULL）（ctx-&gt; above_token_entropy_ctx！）。 }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_destroy(struct vp8_decoder_ctx *ctx) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_tokens_destroy（構造体vp8_decoder_ctxの*のCTX）{私はint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; MAX_PARTITIONS; i++)
           free(ctx-&gt;tokens[i].coeffs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 free(ctx-&gt;above_token_entropy_ctx); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無料（ctx-&gt; above_token_entropy_ctx）; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.17. tokens.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.17。 tokens.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef TOKENS_H
   #define TOKENS_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_tokens_init（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_destroy(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vp8_dixie_tokens_destroy（構造体vp8_decoder_ctxの*のCTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx, unsigned int partition, unsigned int row, unsigned int start_col, unsigned int num_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボイドvp8_dixie_tokens_process_row（構造体vp8_decoder_ctx * CTX、unsigned int型のパーティション、unsigned int型の行、unsigned int型start_col、unsigned int型NUM_COLS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.18. vp8_prob_data.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.18。 vp8_prob_data.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char k_coeff_entropy_update_probs[BLOCK_TYPES][COEFF_BANDS] [PREV_COEFF_CONTEXTS] [ENTROPY_NODES] = { { { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255}, {249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255}, {234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数はunsigned charのk_coeff_entropy_update_probs [BLOCK_TYPES] [COEFF_BANDS] [PREV_COEFF_CONTEXTS] [ENTROPY_NODES] = {{{{255、255、255、255、255、255、255、255、255、255、255}、{255、255、 255、255、255、255、255、255、255、255、255}、{255、255、255、255、255、255、255、255、255、255、255}、}、{{176、246 、255、255、255、255、255、255、255、255、255}、{223、241、252、255、255、255、255、255、255、255、255}、{249、253、253 、255、255、255、255、255、255、255、255}、}、{{255、244、252、255、255、255、255、255、255、255、255}、{234、254、 254、255、255、255、255、255、255、255、255}、{253、255、255、255、255、255、255、255、255、255、255}、}、{{255、246 、254、255、255、255、255、255、255、255、255}、{239、253、254、255、255、255、255、255、255、255、255}、{254、255、254 、255、255、255、255、255、255、255、255}、}、{{255、248、254、255、255、255、255、255、255、255、255}、{251、255、 254、255、255、255、255、255、255、255、255}、{255、255、255、255、255、255、255、255、255、255、255 }、}、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           {
               {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},
               {250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
       {
           {
               {217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},
               {234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255},
           },
           {
               {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 { {255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, }, { { {186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255}, {234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255}, {251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255}, }, { {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255}, }, { {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
{ {255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, }, { { {186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255}, {234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255}, {251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255}, }, { {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255}, }, { {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, },
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, }, { { {248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255}, {248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255}, }, { {255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255}, {248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
{ {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, }, { { {248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255}, {248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255}, }, { {255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255}, {248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}, }, { {255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255}, {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, },
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 { {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, }, };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}, }, }, };
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char k_default_y_mode_probs [] = { 112, 86, 140, 37};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数はunsigned charのk_default_y_mode_probs [] = {112、86、140、37}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char k_default_uv_mode_probs [] = { 162, 101, 204};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数はunsigned charのk_default_uv_mode_probs [] = {162、101、204}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static const
   unsigned char k_default_coeff_probs [BLOCK_TYPES][COEFF_BANDS]
   [PREV_COEFF_CONTEXTS][ENTROPY_NODES] =
   {
       { /* block type 0 */
           { /* coeff band 0 */
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 1 */
               { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},
               { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},
               { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128}
           },
           { /* coeff band 2 */
               {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},
               { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},
               {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128}
           },
           { /* coeff band 3 */
               {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},
               { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},
               {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128}
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           { /* coeff band 4 */
               {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},
               { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},
               {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},
               { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},
               { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},
               { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},
               {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128}
           },
           { /* coeff band 7 */
               {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 1 */
           { /* coeff band 0 */
               { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},
               { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},
               {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128}
           },
           { /* coeff band 1 */
               {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},
               { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},
               {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128}
           },
           { /* coeff band 2 */
               {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},
               {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},
               {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128}
           },
           { /* coeff band 3 */
               {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},
               { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},
               {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128}
           },
           { /* coeff band 4 */
               {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},
               {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},
               {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128}
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           { /* coeff band 5 */
               {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},
               { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},
               {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},
               { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},
               {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128}
           },
           { /* coeff band 7 */
               {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},
               { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},
               { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 2 */
           { /* coeff band 0 */
               { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},
               { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},
               {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128}
           },
           { /* coeff band 1 */
               {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},
               { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},
               { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128}
           },
           { /* coeff band 2 */
               {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},
               { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},
               {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128}
           },
           { /* coeff band 3 */
               {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},
               { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},
               { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 4 */
               {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},
               { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},
               { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           { /* coeff band 6 */
               {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},
               { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},
               {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 7 */
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 3 */
           { /* coeff band 0 */
               { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},
               { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},
               {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128}
           },
           { /* coeff band 1 */
               {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},
               { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},
               {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128}
           },
           { /* coeff band 2 */
               {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},
               { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},
               {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128}
           },
           { /* coeff band 3 */
               {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},
               { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},
               {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128}
           },
           { /* coeff band 4 */
               {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},
               { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},
               {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},
               { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},
               {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},
               { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},
               {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128}
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           { /* coeff band 7 */
               {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char k_mv_entropy_update_probs[2][MV_PROB_CNT] = { { 237, 246, 253, 253, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 250, 250, 252, 254, 254 }, { 231, 243, 245, 253, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 251, 251, 254, 254, 254 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数はunsigned charのk_mv_entropy_update_probs [2] [MV_PROB_CNT] = {{237、246、253、253、254、254、254、254、254、254、254、254、254、254、250、250、252、254、 254}、{231、243、245、253、254、254、254、254、254、254、254、254、254、254、251、251、254、254、254}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char k_default_mv_probs[2][MV_PROB_CNT] = { { // row 162, // is short 128, // sign 225, 146, 172, 147, 214, 39, 156, // short tree 128, 129, 132, 75, 145, 178, 206, 239, 254, 254 // long bits }, { 164, 128, 204, 170, 119, 235, 140, 230, 228, 128, 130, 130, 74, 148, 180, 203, 236, 254, 254
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的定数はunsigned charのk_default_mv_probs [2] [MV_PROB_CNT] = {{//行162、// 128短く、129、225、146、172、147、214、39、156、//短いツリー128に署名// 132、75、145、178、206、239、254、254 //長いビット}、{164、128、204、170、119、235、140、230、228、128、130、130、74、148、 180、203、236、254、254
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 } };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝ ｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.19. vpx_codec_internal.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.19。 vpx_codec_internal.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\file vpx_codec_internal.h
    * \brief Describes the decoder algorithm interface for algorithm
    *        implementations.
    *
    * This file defines the private structures and data types that are
    * only relevant to implementing an algorithm, as opposed to using
    * it.
    *
    * To create a decoder algorithm class, an interface structure is put
    * into the global namespace:
    *     &lt;pre&gt;
    *     my_codec.c:
    *       vpx_codec_iface_t my_codec = {
    *           &#34;My Codec v1.0&#34;,
    *           VPX_CODEC_ALG_ABI_VERSION,
    *           ...
    *       };
    *     &lt;/pre&gt;
    *
    * An application instantiates a specific decoder instance by using
    * vpx_codec_init() and a pointer to the algorithm&#39;s interface
    * structure:
    *     &lt;pre&gt;
    *     my_app.c:
    *       extern vpx_codec_iface_t my_codec;
    *       {
    *           vpx_codec_ctx_t algo;
    *           res = vpx_codec_init(&amp;algo, &amp;my_codec);
    *       }
    *     &lt;/pre&gt;
    *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 * Once initialized, the instance is managed using other functions * from the vpx_codec_* family. */ #ifndef VPX_CODEC_INTERNAL_H #define VPX_CODEC_INTERNAL_H #include &#34;vpx_decoder.h&#34; #include &lt;stdarg.h&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*一度インスタンスはvpx_codec_ *家族から他の機能*を使用して管理され、初期化。 * / #ifndefのVPX_CODEC_INTERNAL_Hの#define VPX_CODEC_INTERNAL_Hの#include &#34;vpx_decoder.h&#34; の#include &lt;STDARG.H&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief Current ABI version number
    *
    * \internal
    * If this file is altered in any way that changes the Application
    * Binary Interface (ABI), this value must be bumped.  Examples
    * include, but are not limited to, changing types, removing or
    * reassigning enums, adding/removing/rearranging fields to
    * structures.
    */
   #define VPX_CODEC_INTERNAL_ABI_VERSION (3)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef struct vpx_codec_alg_priv vpx_codec_alg_priv_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefは構造体vpx_codec_alg_priv vpx_codec_alg_priv_t。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief init function pointer prototype
    *
    * Performs algorithm-specific initialization of the decoder context.
    * This function is called by the generic vpx_codec_init() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx   Pointer to this instance&#39;s context
    * \retval #VPX_CODEC_OK
    *     The input stream was recognized and decoder initialized.
    * \retval #VPX_CODEC_MEM_ERROR
    *     Memory operation failed.
    */
   typedef vpx_codec_err_t (*vpx_codec_init_fn_t)(vpx_codec_ctx_t *ctx);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief destroy function pointer prototype
    *
    * Performs algorithm-specific destruction of the decoder context.
    * This function is called by the generic vpx_codec_destroy() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx   Pointer to this instance&#39;s context
    * \retval #VPX_CODEC_OK
    *     The input stream was recognized and decoder initialized.
    * \retval #VPX_CODEC_MEM_ERROR
    *     Memory operation failed.
    */
   typedef vpx_codec_err_t (*vpx_codec_destroy_fn_t)(
       vpx_codec_alg_priv_t *ctx);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief parse stream info function pointer prototype
    *
    * Performs high level parsing of the bitstream.  This function is
    * called by the generic vpx_codec_parse_stream() wrapper function,
    * so plugins implementing this interface may trust the input
    * parameters to be properly initialized.
    *
    * \param[in]      data    Pointer to a block of data to parse
    * \param[in]      data_sz Size of the data buffer
    * \param[in,out]  si      Pointer to stream info to update.  The
    *                         size member \ref MUST be properly
    *                         initialized, but \ref MAY be clobbered by
    *                         the algorithm.  This parameter \ref MAY
    *                         be NULL.
    *
    * \retval #VPX_CODEC_OK
    *     Bitstream is parsable and stream information updated
    */
   typedef vpx_codec_err_t (*vpx_codec_peek_si_fn_t)(
       const uint8_t         *data,
       unsigned int           data_sz,
       vpx_codec_stream_info_t *si);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief Return information about the current stream.
    *
    * Returns information about the stream that has been parsed during
    * decoding.
    *
    * \param[in]      ctx     Pointer to this instance&#39;s context
    * \param[in,out]  si      Pointer to stream info to update.  The
    *                         size member \ref MUST be properly
    *                         initialized, but \ref MAY be clobbered by
    *                         the algorithm.  This parameter \ref MAY
    *                         be NULL.
    *
    * \retval #VPX_CODEC_OK
    *     Bitstream is parsable and stream information updated
    */
   typedef vpx_codec_err_t (*vpx_codec_get_si_fn_t)(
       vpx_codec_alg_priv_t    *ctx,
       vpx_codec_stream_info_t *si);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief control function pointer prototype
    *
    * This function is used to exchange algorithm-specific data with the
    * decoder instance.  This can be used to implement features specific
    * to a particular algorithm.
    *
    * This function is called by the generic vpx_codec_control() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.  However, this
    * interface does not provide type safety for the exchanged data or
    * assign meanings to the control codes.  Those details should be
    * specified in the algorithm&#39;s header file.  In particular, the
    * ctrl_id parameter is guaranteed to exist in the algorithm&#39;s
    * control mapping table, and the data parameter may be NULL.
    *
    *
    * \param[in]     ctx       Pointer to this instance&#39;s context
    * \param[in]     ctrl_id   Algorithm-specific control identifier
    * \param[in,out] data      Data to exchange with algorithm instance.
    *
    * \retval #VPX_CODEC_OK
    *     The internal state data was deserialized.
    */
   typedef vpx_codec_err_t (*vpx_codec_control_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       int                   ctrl_id,
       va_list               ap);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief control function pointer mapping
    *
    * This structure stores the mapping between control identifiers and
    * implementing functions.  Each algorithm provides a list of these
    * mappings.  This list is searched by the vpx_codec_control()
    * wrapper function to determine which function to invoke.  The
    * special value {0, NULL} is used to indicate end-of-list, and must
    * be present.  The special value {0, &lt;non-null&gt;} can be used as a
    * catch-all mapping.  This implies that ctrl_id values chosen by the
    * algorithm \ref MUST be non-zero.
    */
   typedef const struct
   {
       int                    ctrl_id;
       vpx_codec_control_fn_t   fn;
   } vpx_codec_ctrl_fn_map_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief decode data function pointer prototype
    *
    * Processes a buffer of coded data.  If the processing results in a
    * new decoded frame becoming available, #VPX_CODEC_CB_PUT_SLICE and
    * #VPX_CODEC_CB_PUT_FRAME events are generated as appropriate.
    * This function is called by the generic vpx_codec_decode() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx         Pointer to this instance&#39;s context
    * \param[in] data        Pointer to this block of new coded data.
    *                        If NULL, a #VPX_CODEC_CB_PUT_FRAME event is
    *                        posted for the previously decoded frame.
    * \param[in] data_sz     Size of the coded data, in bytes.
    *
    * \return Returns #VPX_CODEC_OK if the coded data was processed
    *         completely and future pictures can be decoded without
    *         error.  Otherwise, see the descriptions of the other error
    *         codes in ::vpx_codec_err_t for recoverability
    *         capabilities.
    */
   typedef vpx_codec_err_t (*vpx_codec_decode_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       const uint8_t         *data,
       unsigned int     data_sz,
       void        *user_priv,
       long         deadline);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief Decoded frames iterator
    *
    * Iterates over a list of the frames available for display.  The
    * iterator storage should be initialized to NULL to start the
    * iteration.  Iteration is complete when this function returns NULL.
    *
    * The list of available frames becomes valid upon completion of the
    * vpx_codec_decode call, and remains valid until the next call to
    * vpx_codec_decode.
    *
    * \param[in]     ctx      Pointer to this instance&#39;s context
    * \param[in out] iter     Iterator storage, initialized to NULL
    *
    * \return Returns a pointer to an image, if one is ready for
    *         display.  Frames produced will always be in PTS
    *         (presentation time stamp) order.
    */
   typedef vpx_image_t*(*vpx_codec_get_frame_fn_t)(
       vpx_codec_alg_priv_t *ctx,
       vpx_codec_iter_t     *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*\brief External Memory Allocation memory map get iterator
    *
    * Iterates over a list of the memory maps requested by the decoder.
    * The iterator storage should be initialized to NULL to start the
    * iteration.  Iteration is complete when this function returns NULL.
    *
    * \param[in out] iter     Iterator storage, initialized to NULL
    *
    * \return Returns a pointer to a memory segment descriptor, or NULL
    *         to indicate end-of-list.
    */
   typedef vpx_codec_err_t (*vpx_codec_get_mmap_fn_t)(
       const vpx_codec_ctx_t      *ctx,
       vpx_codec_mmap_t           *mmap,
       vpx_codec_iter_t           *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*\brief External Memory Allocation memory map set iterator
    *
    * Sets a memory descriptor inside the decoder instance.
    *
    * \param[in] ctx      Pointer to this instance&#39;s context
    * \param[in] mmap     Memory map to store.
    *
    * \retval #VPX_CODEC_OK
    *     The memory map was accepted and stored.
    * \retval #VPX_CODEC_MEM_ERROR
    *     The memory map was rejected.
    */
   typedef vpx_codec_err_t (*vpx_codec_set_mmap_fn_t)(
       vpx_codec_ctx_t         *ctx,
       const vpx_codec_mmap_t  *mmap);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef vpx_codec_err_t (*vpx_codec_encode_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       const vpx_image_t     *img,
       vpx_codec_pts_t        pts,
       unsigned long          duration,
       vpx_enc_frame_flags_t  flags,
       unsigned long          deadline);
   typedef const vpx_codec_cx_pkt_t*(*vpx_codec_get_cx_data_fn_t)(
       vpx_codec_alg_priv_t *ctx,
       vpx_codec_iter_t     *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef vpx_codec_err_t
   (*vpx_codec_enc_config_set_fn_t)(
       vpx_codec_alg_priv_t       *ctx,
       const vpx_codec_enc_cfg_t  *cfg);
   typedef vpx_fixed_buf_t *
   (*vpx_codec_get_global_headers_fn_t)(vpx_codec_alg_priv_t   *ctx);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef vpx_image_t * (*vpx_codec_get_preview_frame_fn_t)(vpx_codec_alg_priv_t *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefのvpx_image_tの*（* vpx_codec_get_preview_frame_fn_t）（vpx_codec_alg_priv_t * CTX）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief usage configuration mapping
    *
    * This structure stores the mapping between usage identifiers and
    * configuration structures.  Each algorithm provides a list of these
    * mappings.  This list is searched by the
    * vpx_codec_enc_config_default() wrapper function to determine which
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    * config to return.  The special value {-1, {0}} is used to indicate
    * end-of-list, and must be present.  At least one mapping must be
    * present, in addition to the end-of-list.
    *
    */
   typedef const struct
   {
       int                 usage;
       vpx_codec_enc_cfg_t cfg;
   } vpx_codec_enc_cfg_map_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define NOT_IMPLEMENTED 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define NOT_IMPLEMENTED 0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief Decoder algorithm interface
    *
    * All decoders \ref MUST expose a variable of this type.
    */
   struct vpx_codec_iface
   {
       const char               *name;
       int                       abi_version;
       vpx_codec_caps_t          caps;
       vpx_codec_init_fn_t       init;
       vpx_codec_destroy_fn_t    destroy;
       vpx_codec_ctrl_fn_map_t  *ctrl_maps;
       vpx_codec_get_mmap_fn_t   get_mmap;
       vpx_codec_set_mmap_fn_t   set_mmap;
       struct
       {
           vpx_codec_peek_si_fn_t    peek_si;
           vpx_codec_get_si_fn_t     get_si;
           vpx_codec_decode_fn_t     decode;
           vpx_codec_get_frame_fn_t  get_frame;
       } dec;
       struct
       {
           vpx_codec_enc_cfg_map_t           *cfg_maps;
           vpx_codec_encode_fn_t              encode;
           vpx_codec_get_cx_data_fn_t         get_cx_data;
           vpx_codec_enc_config_set_fn_t      cfg_set;
           vpx_codec_get_global_headers_fn_t  get_glob_hdrs;
           vpx_codec_get_preview_frame_fn_t   get_preview;
       } enc;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief Callback function pointer / user data pair storage */
   typedef struct vpx_codec_priv_cb_pair
   {
       union
       {
           vpx_codec_put_frame_cb_fn_t    put_frame;
           vpx_codec_put_slice_cb_fn_t    put_slice;
       };
       void                            *user_priv;
   } vpx_codec_priv_cb_pair_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\brief Instance private storage
    *
    * This structure is allocated by the algorithm&#39;s init function.  It
    * can be extended in one of two ways.  First, a second, algorithm
    * specific structure can be allocated and the priv member pointed to
    * it.  Alternatively, this structure can be made the first member of
    * the algorithm-specific structure, and the pointer casted to the
    * proper type.
    */
   struct vpx_codec_priv
   {
       unsigned int                    sz;
       vpx_codec_iface_t              *iface;
       struct vpx_codec_alg_priv      *alg_priv;
       const char                     *err_detail;
       vpx_codec_flags_t               init_flags;
       struct
       {
           vpx_codec_priv_cb_pair_t    put_frame_cb;
           vpx_codec_priv_cb_pair_t    put_slice_cb;
       } dec;
       struct
       {
           struct vpx_fixed_buf        cx_data_dst_buf;
           unsigned int                cx_data_pad_before;
           unsigned int                cx_data_pad_after;
           vpx_codec_cx_pkt_t          cx_data_pkt;
       } enc;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#undef VPX_CTRL_USE_TYPE #define VPX_CTRL_USE_TYPE(id, typ) \ static typ id##__value(va_list args) \ {return va_arg(args, typ);} \ static typ id##__convert(void *x)\ {\
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#undefのVPX_CTRL_USE_TYPEの#define VPX_CTRL_USE_TYPE（ID、typ）の\静的TYP番号## __値（va_listの引数）\ {リターンのva_arg（引数、TYP）;} \静的TYP番号## __変換（ボイド* X）\ {\
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           union\
           {\
               void *x;\
               typ   d;\
           } u;\
           u.x = x;\
           return u.d;\
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#undef VPX_CTRL_USE_TYPE_DEPRECATED #define VPX_CTRL_USE_TYPE_DEPRECATED(id, typ) \ static typ id##__value(va_list args) \ {return va_arg(args, typ);} \ static typ id##__convert(void *x)\ {\ union\ {\ void *x;\ typ d;\ } u;\ u.x = x;\ return u.d;\ }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#undefのVPX_CTRL_USE_TYPE_DEPRECATEDの#define VPX_CTRL_USE_TYPE_DEPRECATED（ID、typ）の\静的TYP番号## __値（va_listの引数）\ {リターンのva_arg（引数、TYP）;} \静的TYP番号## __変換（ボイド* X）\ {\組合\ {\ボイド*のX; \標準D; \} U; \ UX = X; \戻りUD; \}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define CAST(id, arg) id##__value(arg) #define RECAST(id, x) id##__convert(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define CAST（ID、引数）ID ## __値（引数）の#defineリキャスト（ID、X）のID ## __変換（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Internal Utility Functions
    *
    * The following functions are intended to be used inside algorithms
    * as utilities for manipulating vpx_codec_* data structures.
    */
   struct vpx_codec_pkt_list
   {
       unsigned int            cnt;
       unsigned int            max;
       struct vpx_codec_cx_pkt pkts[1];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define vpx_codec_pkt_list_decl(n)\
       union {struct vpx_codec_pkt_list head;\
           struct {struct vpx_codec_pkt_list head;\
               struct vpx_codec_cx_pkt    pkts[n];} alloc;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define vpx_codec_pkt_list_init(m)\ (m)-&gt;alloc.head.cnt = 0,\ (m)-&gt;alloc.head.max = \ sizeof((m)-&gt;alloc.pkts) / sizeof((m)-&gt;alloc.pkts[0])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define vpx_codec_pkt_list_init（M）\（M） - &gt; alloc.head.cnt = 0、\（M） - &gt; alloc.head.max = \はsizeof（（M） - &gt; alloc.pkts）/はsizeof（（M） - &gt; alloc.pkts [0]）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int vpx_codec_pkt_list_add(struct vpx_codec_pkt_list *, const struct vpx_codec_cx_pkt *);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int型vpx_codec_pkt_list_add（構造体vpx_codec_pkt_listの*、constの構造体vpx_codec_cx_pkt *）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const vpx_codec_cx_pkt_t* vpx_codec_pkt_list_get(struct vpx_codec_pkt_list *list, vpx_codec_iter_t *iter);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
constのvpx_codec_cx_pkt_t * vpx_codec_pkt_list_get（構造体vpx_codec_pkt_list *リスト、vpx_codec_iter_t * ITER）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;stdio.h&gt;
   #include &lt;setjmp.h&gt;
   struct vpx_internal_error_info
   {
       vpx_codec_err_t  error_code;
       int              has_detail;
       char             detail[80];
       int              setjmp;
       jmp_buf          jmp;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void vpx_internal_error(struct vpx_internal_error_info *info, vpx_codec_err_t error, const char *fmt, ...) { va_list ap;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的な無効vpx_internal_error（構造体vpx_internal_error_info *情報、vpx_codec_err_tエラー、CONSTするchar * fmtは、...）{va_listのAPを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       info-&gt;error_code = error;
       info-&gt;has_detail = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (fmt) { size_t sz = sizeof(info-&gt;detail);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IF（FMT）{size_t型SZ =はsizeof（info-&gt;詳細）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           info-&gt;has_detail = 1;
           va_start(ap, fmt);
           vsnprintf(info-&gt;detail, sz - 1, fmt, ap);
           va_end(ap);
           info-&gt;detail[sz-1] = &#39;\0&#39;;
       } if (info-&gt;setjmp)
           longjmp(info-&gt;jmp, info-&gt;error_code);
   }
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.20. vpx_decoder.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.20。 vpx_decoder.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\defgroup decoder Decoder Algorithm Interface
    * \ingroup codec
    * This abstraction allows applications using this decoder to easily
    * support multiple video formats with minimal code duplication.
    * This section describes the interface common to all decoders.
    * @{
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\file vpx_decoder.h
    * \brief Describes the decoder algorithm interface to applications.
    *
    * This file describes the interface between an application and a
    * video decoder algorithm.
    *
    */
   #ifdef __cplusplus
   extern &#34;C&#34; {
   #endif
   #ifndef VPX_DECODER_H
   #define VPX_DECODER_H
   #include &#34;vpx_codec.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Current ABI version number
        *
        * \internal
        * If this file is altered in any way that changes the ABI, this
        * value must be bumped.  Examples include, but are not limited
        * to, changing types, removing or reassigning enums,
        * adding/removing/rearranging fields to structures
        */
   #define VPX_DECODER_ABI_VERSION (2 + VPX_CODEC_ABI_VERSION)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*! \brief Decoder capabilities bitfield
        *
        *  Each decoder advertises the capabilities it supports as part
        *  of its ::vpx_codec_iface_t interface structure.  Capabilities
        *  are extra interfaces or functionality, and are not required
        *  to be supported by a decoder.
        *
        *  The available flags are specified by VPX_CODEC_CAP_* defines.
        */
   #define VPX_CODEC_CAP_PUT_SLICE  0x10000 /**&lt; Will issue put_slice
       callbacks */
   #define VPX_CODEC_CAP_PUT_FRAME  0x20000 /**&lt; Will issue put_frame
       callbacks */
   #define VPX_CODEC_CAP_POSTPROC   0x40000 /**&lt; Can postprocess decoded
       frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*! \brief Initialization-time Feature Enabling
        *
        *  Certain codec features must be known at initialization time,
        *  to allow for proper memory allocation.
        *
        *  The available flags are specified by VPX_CODEC_USE_* defines.
        */
   #define VPX_CODEC_USE_POSTPROC   0x10000 /**&lt; Postprocess decoded
       frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Stream properties
        *
        * This structure is used to query or set properties of the
        * decoded stream.  Algorithms may extend this structure with
        * data specific to their bitstream by setting the sz member
        * appropriately.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       typedef struct vpx_codec_stream_info
       {
           unsigned int sz;    /**&lt; Size of this structure */
           unsigned int w;     /**&lt; Width (or 0 for unknown/default) */
           unsigned int h;     /**&lt; Height (or 0 for unknown/default) */
           unsigned int is_kf; /**&lt; Current frame is a keyframe */
       } vpx_codec_stream_info_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* REQUIRED FUNCTIONS
        *
        * The following functions are required to be implemented for all
        * decoders.  They represent the base case functionality expected
        * of all decoders.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Initialization Configurations
        *
        * This structure is used to pass init time configuration options
        * to the decoder.
        */
       typedef struct vpx_codec_dec_cfg
       {
           unsigned int threads; /**&lt; Maximum number of threads to use,
               default 1 */
           unsigned int w;      /**&lt; Width */
           unsigned int h;      /**&lt; Height */
       } vpx_codec_dec_cfg_t; /**&lt; alias for struct vpx_codec_dec_cfg */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_codec_dec_init convenience
        * macro instead of this function directly, to ensure that the
        * ABI version number parameter is properly initialized.
        *
        * In XMA mode (activated by setting VPX_CODEC_USE_XMA in the
        * flags parameter), the storage pointed to by the cfg parameter
        * must be kept readable and stable until all memory maps have
        * been set.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        * \param[in]    iface   Pointer to the algorithm interface to
        *                       use.
        * \param[in]    cfg     Configuration to use, if known.  May be
        *                       NULL.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 * \param[in] flags Bitfield of VPX_CODEC_USE_* flags * \param[in] ver ABI version number. Must be set to * VPX_DECODER_ABI_VERSION * \retval #VPX_CODEC_OK * The decoder algorithm initialized. * \retval #VPX_CODEC_MEM_ERROR * Memory allocation failed. */ vpx_codec_err_t vpx_codec_dec_init_ver( vpx_codec_ctx_t *ctx, vpx_codec_iface_t *iface, vpx_codec_dec_cfg_t *cfg, vpx_codec_flags_t flags, int ver);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* [中]の\ PARAM VPX_CODEC_USE_のフラグビットフィールド*フラグ* ABI版バージョン番号[中]の\ PARAM。 * VPX_DECODER_ABI_VERSIONに設定する必要があります* \ RETVAL #VPX_CODEC_OK *デコーダアルゴリズム初期化。 * \ RETVAL #VPX_CODEC_MEM_ERROR *メモリの割り当てに失敗しました。 * / vpx_codec_err_t vpx_codec_dec_init_ver（vpx_codec_ctx_t * CTX、vpx_codec_iface_t *のiface、vpx_codec_dec_cfg_t * CFG、vpx_codec_flags_tフラグ、INT版）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Convenience macro for vpx_codec_dec_init_ver()
        *
        * Ensures the ABI version parameter is properly set.
        */
   #define vpx_codec_dec_init(ctx, iface, cfg, flags) \
       vpx_codec_dec_init_ver(ctx, iface, cfg, flags, \
       VPX_DECODER_ABI_VERSION)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Parse stream info from a buffer
        *
        * Performs high level parsing of the bitstream.  Construction of
        * a decoder context is not necessary.  Can be used to determine
        * if the bitstream is of the proper format, and to extract
        * information from the stream.
        *
        * \param[in]      iface   Pointer to the algorithm interface
        * \param[in]      data    Pointer to a block of data to parse
        * \param[in]      data_sz Size of the data buffer
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member
        *                         \ref MUST be properly initialized, but
        *                         \ref MAY be clobbered by the
        *                         algorithm.  This parameter \ref MAY be
        *                         NULL.
        *
        * \retval #VPX_CODEC_OK
        *     Bitstream is parsable and stream information updated
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_codec_err_t vpx_codec_peek_stream_info( vpx_codec_iface_t *iface, const uint8_t *data, unsigned int data_sz, vpx_codec_stream_info_t *si);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_codec_err_t vpx_codec_peek_stream_info（vpx_codec_iface_t * ifaceの、constのuint8_t *データ、unsigned int型data_sz、vpx_codec_stream_info_tの*のSI）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Return information about the current stream.
        *
        * Returns information about the stream that has been parsed
        * during decoding.
        *
        * \param[in]      ctx     Pointer to this instance&#39;s context
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member \ref MUST be properly
        *                         initialized, but \ref MAY be clobbered
        *                         by the algorithm.  This parameter \ref
        *                         MAY be NULL.
        *
        * \retval #VPX_CODEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_codec_err_t vpx_codec_get_stream_info(
           vpx_codec_ctx_t         *ctx,
           vpx_codec_stream_info_t *si);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Decode data
        *
        * Processes a buffer of coded data.  If the processing results
        * in a new decoded frame becoming available, PUT_SLICE and
        * PUT_FRAME events may be generated, as appropriate.  Encoded
        * data \ref MUST be passed in DTS (decode time stamp) order.
        * Frames produced will always be in PTS (presentation time
        * stamp) order.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] data         Pointer to this block of new coded
        *                         data.  If NULL, a
        *                         VPX_CODEC_CB_PUT_FRAME event is posted
        *                         for the previously decoded frame.
        * \param[in] data_sz      Size of the coded data, in bytes.
        * \param[in] user_priv    Application-specific data to associate
        *                         with this frame.
        * \param[in] deadline     Soft deadline the decoder should
        *                         attempt to meet, in us.  Set to zero
        *                         for unlimited.
        *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 * \return Returns #VPX_CODEC_OK if the coded data was processed * completely and future pictures can be decoded without * error. Otherwise, see the descriptions of the other * error codes in ::vpx_codec_err_t for recoverability * capabilities. */ vpx_codec_err_t vpx_codec_decode(vpx_codec_ctx_t *ctx, const uint8_t *data, unsigned int data_sz, void *user_priv, long deadline);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
符号化されたデータが完全に処理されました*そして未来の絵は*誤りなく復号できる場合* \リターンは#VPX_CODEC_OKを返します。それ以外の場合は、中::リカバリ*機能のvpx_codec_err_t他*エラーコードの説明を参照してください。 * / vpx_codec_err_t vpx_codec_decode（vpx_codec_ctx_t * CTX、CONST uint8_t *データ、unsigned int型data_sz、void *型user_priv、長い締め切り）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Decoded frames iterator
        *
        * Iterates over a list of the frames available for display.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * NULL.
        *
        * The list of available frames becomes valid upon completion of
        * the vpx_codec_decode call, and remains valid until the next
        * call to vpx_codec_decode.
        *
        * \param[in]     ctx      Pointer to this instance&#39;s context
        * \param[in,out] iter     Iterator storage, initialized to NULL
        *
        * \return Returns a pointer to an image, if one is ready for
        *         display.  Frames produced will always be in PTS
        *         (presentation time stamp) order.
        */
       vpx_image_t *vpx_codec_get_frame(vpx_codec_ctx_t  *ctx,
                                        vpx_codec_iter_t *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_frame Frame-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_CODEC_CAP_PUT_FRAME
        * capability.  Calling these functions for codecs that don&#39;t
        * advertise this capability will result in an error code being
        * returned, usually VPX_CODEC_ERROR
        * @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief put frame callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of decoded image data.
        */
       typedef void (*vpx_codec_put_frame_cb_fn_t)(
           void        *user_priv,
           const vpx_image_t *img);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Register for notification of frame completion.
        *
        * Registers a given function to be called when a decoded frame
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_CODEC_OK
        *     Callback successfully registered.
        * \retval #VPX_CODEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_codec_err_t vpx_codec_register_put_frame_cb(
           vpx_codec_ctx_t             *ctx,
           vpx_codec_put_frame_cb_fn_t  cb,
           void                        *user_priv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_slice Slice-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_CODEC_CAP_PUT_SLICE
        * capability.  Calling these functions for codecs that don&#39;t
        * advertise this capability will result in an error code being
        * returned, usually VPX_CODEC_ERROR
        * @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief put slice callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of partially decoded image
        * data.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
typedef void (*vpx_codec_put_slice_cb_fn_t)( void *user_priv, const vpx_image_t *img, const vpx_image_rect_t *valid, const vpx_image_rect_t *update);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
typedefは無効（* vpx_codec_put_slice_cb_fn_t）（void *型user_priv、constのvpx_image_t * IMG、constのvpx_image_rect_t *有効な、constのvpx_image_rect_t *更新）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Register for notification of slice completion.
        *
        * Registers a given function to be called when a decoded slice
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_CODEC_OK
        *     Callback successfully registered.
        * \retval #VPX_CODEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_codec_err_t vpx_codec_register_put_slice_cb(
           vpx_codec_ctx_t             *ctx,
           vpx_codec_put_slice_cb_fn_t  cb,
           void                        *user_priv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_slice*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!@} - end defgroup decoder*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifdef __cplusplus } #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifdef __cplusplus} #endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT #include &#34;vpx_decoder_compat.h&#34; #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（VPX_CODEC_DISABLE_COMPAT）に定義の#if！|| ！VPX_CODEC_DISABLE_COMPATの#include &#34;vpx_decoder_compat.h&#34; #endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.21. vpx_decoder_compat.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.21。 vpx_decoder_compat.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\defgroup decoder Common Decoder Algorithm Interface
    * This abstraction allows applications using this decoder to easily
    * support multiple video formats with minimal code duplication.
    * This section describes the interface common to all codecs.
    * @{
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\file
    * \brief Provides a compatibility layer between version 1 and 2 of
    * this API.
    *
    * This interface has been deprecated.  Only existing code should
    * make use of this interface, and therefore, it is only thinly
    * documented.  Existing code should be ported to the vpx_codec_*
    * API.
    */
   #ifdef __cplusplus
   extern &#34;C&#34; {
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef VPX_DECODER_COMPAT_H #define VPX_DECODER_COMPAT_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndefのVPX_DECODER_COMPAT_Hの#define VPX_DECODER_COMPAT_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Decoder algorithm return codes */
       typedef enum {
           /*!\brief Operation completed without error */
           VPX_DEC_OK = VPX_CODEC_OK,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*!\brief Unspecified error */
           VPX_DEC_ERROR = VPX_CODEC_ERROR,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*!\brief Memory operation failed */
           VPX_DEC_MEM_ERROR = VPX_CODEC_MEM_ERROR,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*!\brief ABI version mismatch */
           VPX_DEC_ABI_MISMATCH = VPX_CODEC_ABI_MISMATCH,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*!\brief The given bitstream is not supported.
            *
            * The bitstream was unable to be parsed at the highest
            * level.  The decoder is unable to proceed.  This error \ref
            * SHOULD be treated as fatal to the stream.
            */
           VPX_DEC_UNSUP_BITSTREAM = VPX_CODEC_UNSUP_BITSTREAM,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*!\brief Encoded bitstream uses an unsupported feature
            *
            * The decoder does not implement a feature required by the
            * encoder.  This return code should only be used for
            * features that prevent future pictures from being properly
            * decoded.  This error \ref MAY be treated as fatal to the
            * stream or \ref MAY be treated as fatal to the current
            * Group of Pictures (GOP).
            */
           VPX_DEC_UNSUP_FEATURE = VPX_CODEC_UNSUP_FEATURE,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*!\brief The coded data for this stream is corrupt or
            * incomplete
            *
            * There was a problem decoding the current frame.  This
            * return code should only be used for failures that prevent
            * future pictures from being properly decoded.  This error
            * \ref MAY be treated as fatal to the stream or \ref MAY be
            * treated as fatal to the current GOP.  If decoding is
            * continued for the current GOP, artifacts may be present.
            */
           VPX_DEC_CORRUPT_FRAME = VPX_CODEC_CORRUPT_FRAME,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*!\brief An application-supplied parameter is not valid.
            *
            */
           VPX_DEC_INVALID_PARAM = VPX_CODEC_INVALID_PARAM,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*!\brief An iterator reached the end of list.
            *
            */
           VPX_DEC_LIST_END = VPX_CODEC_LIST_END
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
} vpx_dec_err_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
} vpx_dec_err_t。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*! \brief Decoder capabilities bitfield
        *
        *  Each decoder advertises the capabilities it supports as part
        *  of its ::vpx_dec_iface_t interface structure.  Capabilities
        *  are extra interfaces or functionality, and are not required
        *  to be supported by a decoder.
        *
        *  The available flags are specified by VPX_DEC_CAP_* defines.
        */
       typedef int vpx_dec_caps_t;
   #define VPX_DEC_CAP_PUT_SLICE  0x0001 /**&lt; Will issue put_slice
                                            callbacks */
   #define VPX_DEC_CAP_PUT_FRAME  0x0002 /**&lt; Will issue put_frame
                                            callbacks */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define VPX_DEC_CAP_XMA        0x0004 /**&lt; Supports External Memory
                                            Allocation */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Stream properties
        *
        * This structure is used to query or set properties of the
        * decoded stream.  Algorithms may extend this structure with
        * data specific to their bitstream by setting the sz member
        * appropriately.
        */
   #if 1
       typedef vpx_codec_stream_info_t vpx_dec_stream_info_t;
   #else
       typedef struct
       {
           unsigned int sz;    /**&lt; Size of this structure */
           unsigned int w;     /**&lt; Width (or 0 for unknown/default) */
           unsigned int h;     /**&lt; Height (or 0 for unknown/default) */
           unsigned int is_kf; /**&lt; Current frame is a keyframe */
       } vpx_dec_stream_info_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Decoder interface structure.
        *
        * Contains function pointers and other data private to the
        * decoder implementation.  This structure is opaque to the
        * application.
        */
       typedef const struct vpx_codec_iface vpx_dec_iface_t;
       typedef       struct vpx_codec_priv  vpx_dec_priv_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Iterator
        *
        * Opaque storage used for iterating over lists.
        */
       typedef vpx_codec_iter_t vpx_dec_iter_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Decoder context structure
        *
        * All decoders \ref MUST support this context structure fully.
        * In general, this data should be considered private to the
        * decoder algorithm, and not be manipulated or examined by the
        * calling application.  Applications may reference the &#39;name&#39;
        * member to get a printable description of the algorithm.
        */
   #if 1
       typedef vpx_codec_ctx_t vpx_dec_ctx_t;
   #else
       typedef struct
       {
           const char          *name;  /**&lt; Printable interface name */
           vpx_dec_iface_t     *iface; /**&lt; Interface pointers */
           vpx_dec_err_t        err;   /**&lt; Last returned error */
           vpx_dec_priv_t      *priv;  /**&lt; Algorithm private storage */
       } vpx_dec_ctx_t;
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Return the build configuration
        *
        * Returns a printable string containing an encoded version of
        * the build configuration.  This may be useful to vpx support.
        *
        */
       const char *vpx_dec_build_config(void) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Return the name for a given interface
        *
        * Returns a human readable string for name of the given decoder
        * interface.
        *
        * \param[in]    iface     Interface pointer
        *
        */
       const char *vpx_dec_iface_name(
           vpx_dec_iface_t *iface) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Convert error number to printable string
        *
        * Returns a human readable string for the last error returned
        * by the algorithm.  The returned error will be one line and
        * will not contain any newline characters.
        *
        *
        * \param[in]    err     Error number.
        *
        */
       const char *vpx_dec_err_to_string(vpx_dec_err_t  err) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Retrieve error synopsis for decoder context
        *
        * Returns a human readable string for the last error returned by
        * the algorithm.  The returned error will be one line and will
        * not contain any newline characters.
        *
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        *
        */
       const char *vpx_dec_error(vpx_dec_ctx_t  *ctx) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Retrieve detailed error information for decoder context
        *
        * Returns a human readable string providing detailed information
        * about the last error.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 * \retval NULL * No detailed information is available. */ const char *vpx_dec_error_detail(vpx_dec_ctx_t *ctx) DEPRECATED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* RETVAL NULL \ *詳細な情報はありません。 * / CONSTするchar * vpx_dec_error_detail（vpx_dec_ctx_t * CTX）推奨されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* REQUIRED FUNCTIONS
        *
        * The following functions are required to be implemented for all
        * decoders.  They represent the base case functionality expected
        * of all decoders.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_dec_init convenience macro
        * instead of this function directly, to ensure that the ABI
        * version number parameter is properly initialized.
        *
        * \param[in]   ctx    Pointer to this instance&#39;s context.
        * \param[in]   iface  Pointer to the algorithm interface to use.
        * \param[in]   ver    ABI version number.  Must be set to
        *                       VPX_DECODER_ABI_VERSION
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        * \retval #VPX_DEC_MEM_ERROR
        *     Memory allocation failed.
        */
       vpx_dec_err_t vpx_dec_init_ver(
           vpx_dec_ctx_t    *ctx,
           vpx_dec_iface_t  *iface,
           int               ver) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define vpx_dec_init(ctx, iface) \ vpx_dec_init_ver(ctx, iface, VPX_DECODER_ABI_VERSION)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define vpx_dec_init（CTX、のiface）\ vpx_dec_init_ver（CTX、ifaceで、VPX_DECODER_ABI_VERSION）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Destroy a decoder instance
        *
        * Destroys a decoder context, freeing any associated memory
        * buffers.
        *
        * \param[in] ctx   Pointer to this instance&#39;s context
        *
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 * \retval #VPX_DEC_MEM_ERROR * Memory allocation failed. */ vpx_dec_err_t vpx_dec_destroy(vpx_dec_ctx_t *ctx) DEPRECATED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* \ RETVAL #VPX_DEC_MEM_ERROR *メモリの割り当てに失敗しました。 * / vpx_dec_err_t vpx_dec_destroy（vpx_dec_ctx_tの*のCTX）推奨されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Get the capabilities of an algorithm.
        *
        * Retrieves the capabilities bitfield from the algorithm&#39;s
        * interface.
        *
        * \param[in] iface   Pointer to the algorithm interface
        *
        */
       vpx_dec_caps_t vpx_dec_get_caps(
           vpx_dec_iface_t *iface) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Parse stream info from a buffer
        *
        * Performs high level parsing of the bitstream.  Construction of
        * a decoder context is not necessary.  Can be used to determine
        * if the bitstream is of the proper format, and to extract
        * information from the stream.
        *
        * \param[in]      iface   Pointer to the algorithm interface
        * \param[in]      data    Pointer to a block of data to parse
        * \param[in]      data_sz Size of the data buffer
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member \ref MUST be properly
        *                         initialized, but \ref MAY be
        *                         clobbered by the algorithm.  This
        *                         parameter \ref MAY be NULL.
        *
        * \retval #VPX_DEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_dec_err_t vpx_dec_peek_stream_info(
                                vpx_dec_iface_t       *iface,
                                const uint8_t         *data,
                                unsigned int           data_sz,
                                vpx_dec_stream_info_t *si) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Return information about the current stream.
        *
        * Returns information about the stream that has been parsed
        * during decoding.
        *
        * \param[in]      ctx     Pointer to this instance&#39;s context
        * \param[in,out]  si      Pointer to stream info to update.
        *                         The size member \ref MUST be properly
        *                         initialized, but \ref MAY be clobbered
        *                         by the algorithm.  This parameter \ref
        *                         MAY be NULL.
        *
        * \retval #VPX_DEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_dec_err_t vpx_dec_get_stream_info(
           vpx_dec_ctx_t         *ctx,
           vpx_dec_stream_info_t *si) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Control algorithm
        *
        * This function is used to exchange algorithm-specific data with
        * the decoder instance.  This can be used to implement features
        * specific to a particular algorithm.
        *
        * This wrapper function dispatches the request to the helper
        * function associated with the given ctrl_id.  It tries to call
        * this function transparently, but will return #VPX_DEC_ERROR if
        * the request could not be dispatched.
        *
        * \param[in]     ctx          Pointer to this instance&#39;s context
        * \param[in]     ctrl_id      Algorithm-specific control
        *                             identifier
        * \param[in,out] data         Data to exchange with algorithm
        *                             instance.
        *
        * \retval #VPX_DEC_OK
        *     The control request was processed.
        * \retval #VPX_DEC_ERROR
        *     The control request was not processed.
        * \retval #VPX_DEC_INVALID_PARAM
        *     The data was not valid.
        */
       vpx_dec_err_t vpx_dec_control(vpx_dec_ctx_t  *ctx,
                                     int             ctrl_id,
                                     void           *data) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Decode data
        *
        * Processes a buffer of coded data.  If the processing results
        * in a new decoded frame becoming available,
        * #VPX_DEC_CB_PUT_SLICE and #VPX_DEC_CB_PUT_FRAME events may be
        * generated, as appropriate.  Encoded data \ref MUST be passed
        * in DTS (decode time stamp) order.  Frames produced will always
        * be in PTS (presentation time stamp) order.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] data         Pointer to this block of new coded
        *                         data.  If NULL, a VPX_DEC_CB_PUT_FRAME
        *                         event is posted for the previously
        *                         decoded frame.
        * \param[in] data_sz      Size of the coded data, in bytes.
        * \param[in] user_priv    Application-specific data to associate
        *                         with this frame.
        * \param[in] rel_pts      PTS relative to the previous frame, in
        *                         us.  If unknown or unavailable, set to
        *                         zero.
        *
        * \return Returns #VPX_DEC_OK if the coded data was processed
        *         completely and future pictures can be decoded without
        *         error.  Otherwise, see the descriptions of the other
        *         error codes in ::vpx_dec_err_t for recoverability
        *         capabilities.
        */
       vpx_dec_err_t vpx_dec_decode(
           vpx_dec_ctx_t  *ctx,
           uint8_t        *data,
           unsigned int    data_sz,
           void           *user_priv,
           int             rel_pts) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Decoded frames iterator
        *
        * Iterates over a list of the frames available for display.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * NULL.
        *
        * The list of available frames becomes valid upon completion of
        * the vpx_dec_decode call, and remains valid until the next call
        * to vpx_dec_decode.
        *
        * \param[in]     ctx      Pointer to this instance&#39;s context
        * \param[in out] iter     Iterator storage, initialized to NULL
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 * * \return Returns a pointer to an image, if one is ready for * display. Frames produced will always be in PTS * (presentation time stamp) order. */ vpx_image_t *vpx_dec_get_frame(vpx_dec_ctx_t *ctx, vpx_dec_iter_t *iter) DEPRECATED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1は、*表示のための準備ができている場合* * \リターンは、画像へのポインタを返します。生成フレームは常にPTS *（プレゼンテーションタイムスタンプ）順になります。 * / * vpx_image_t vpx_dec_get_frame（vpx_dec_ctx_t * CTX、vpx_dec_iter_t * ITER）推奨されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_frame Frame-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_PUT_FRAME capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief put frame callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of decoded image data.
        */
       typedef void (*vpx_dec_put_frame_cb_fn_t)(
               void          *user_priv,
               const vpx_image_t *img);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Register for notification of frame completion.
        *
        * Registers a given function to be called when a decoded frame
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_DEC_OK
        *     Callback successfully registered.
        * \retval #VPX_DEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_dec_err_t vpx_dec_register_put_frame_cb(
               vpx_dec_ctx_t             *ctx,
               vpx_dec_put_frame_cb_fn_t  cb,
               void                      *user_priv) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_slice Slice-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_PUT_SLICE capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR
        * @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief put slice callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of partially decoded image
        * data.
        */
       typedef void (*vpx_dec_put_slice_cb_fn_t)(void        *user_priv,
               const vpx_image_t      *img,
               const vpx_image_rect_t *valid,
               const vpx_image_rect_t *update);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Register for notification of slice completion.
        *
        * Registers a given function to be called when a decoded slice
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_DEC_OK
        *     Callback successfully registered.
        * \retval #VPX_DEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_dec_err_t vpx_dec_register_put_slice_cb(vpx_dec_ctx_t   *ctx,
               vpx_dec_put_slice_cb_fn_t  cb,
               void                      *user_priv) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_slice*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\defgroup cap_xma External Memory Allocation Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_XMA capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR
        * @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Memory Map Entry
        *
        * This structure is used to contain the properties of a memory
        * segment.  It is populated by the decoder in the request phase,
        * and by the calling application once the requested allocation
        * has been performed.
        */
   #if 1
   #define VPX_DEC_MEM_ZERO     0x1  /**&lt; Segment must be zeroed by
                                          allocation */
   #define VPX_DEC_MEM_WRONLY   0x2  /**&lt; Segment need not be
                                          readable */
   #define VPX_DEC_MEM_FAST     0x4  /**&lt; Place in fast memory, if
                                          available */
       typedef struct vpx_codec_mmap vpx_dec_mmap_t;
   #else
       typedef struct vpx_dec_mmap
       {
           /*
            * The following members are set by the codec when requesting
            * a segment
            */
           unsigned int   id;     /**&lt; identifier for the segment&#39;s
                                       contents */
           unsigned long  sz;     /**&lt; size of the segment, in bytes */
           unsigned int   align;  /**&lt; required alignment of the
                                       segment, in bytes */
           unsigned int   flags;  /**&lt; bitfield containing segment
                                       properties */
   #define VPX_DEC_MEM_ZERO     0x1  /**&lt; Segment must be zeroed by
                                          allocation */
   #define VPX_DEC_MEM_WRONLY   0x2  /**&lt; Segment need not be
                                          readable */
   #define VPX_DEC_MEM_FAST     0x4  /**&lt; Place in fast memory, if
                                          available */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* The following members are to be filled in by the
            * allocation function */
           void          *base;   /**&lt; pointer to the allocated
                                       segment */
           void (*dtor)(struct vpx_dec_mmap *map);  /**&lt; destructor to
                                                         call */
           void          *priv;   /**&lt; allocator private storage */
       } vpx_dec_mmap_t;
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance in external allocation
        * mode
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_dec_xma_init convenience
        * macro instead of this function directly, to ensure that the
        * ABI version number parameter is properly initialized.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        * \param[in]    iface   Pointer to the algorithm interface to
        *                       use.
        * \param[in]    ver     ABI version number.  Must be set to
        *                       VPX_DECODER_ABI_VERSION
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        * \retval #VPX_DEC_ERROR
        *     Decoder does not support XMA mode.
        */
       vpx_dec_err_t vpx_dec_xma_init_ver(vpx_dec_ctx_t    *ctx,
                                          vpx_dec_iface_t  *iface,
                                          int           ver) DEPRECATED;
   #define vpx_dec_xma_init(ctx, iface) \
       vpx_dec_xma_init_ver(ctx, iface, VPX_DECODER_ABI_VERSION)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Iterate over the list of segments to allocate.
        *
        * Iterates over a list of the segments to allocate.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * VPX_DEC_LIST_END.  The amount of memory needed to allocate is
        * dependent upon the size of the encoded stream.  This means
        * that the stream info structure must be known at allocation
        * time.  It can be populated with the vpx_dec_peek_stream_info()
        * function.  In cases where the stream to be decoded is not
        * available at allocation time, a fixed size must be requested.
        * The decoder will not be able to decode streams larger than the
        * size used at allocation time.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 * * \param[in] ctx Pointer to this instance&#39;s context. * \param[out] mmap Pointer to the memory map entry to * populate. * \param[in] si Pointer to the stream info. * \param[in out] iter Iterator storage, initialized to NULL * * \retval #VPX_DEC_OK * The memory map entry was populated. * \retval #VPX_DEC_ERROR * Decoder does not support XMA mode. * \retval #VPX_DEC_MEM_ERROR * Unable to determine segment size from stream info. */ vpx_dec_err_t vpx_dec_get_mem_map( vpx_dec_ctx_t *ctx, vpx_dec_mmap_t *mmap, const vpx_dec_stream_info_t *si, vpx_dec_iter_t *iter) DEPRECATED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
このインスタンスのコンテキストへのポインタCTX [中] * * \のPARAM。 *メモリマップエントリへのmmapのポインタ[OUT]の\ paramが*移入します。ストリーム情報にSIのポインタ[入力] * \のPARAM。 * NULLに初期化さITERイテレータストレージ[アウト] \のPARAM、* * \ RETVAL #VPX_DEC_OK *メモリマップのエントリが読み込まれました。 * RETVAL #VPX_DEC_ERROR \ *デコーダはXMAモードをサポートしていません。 * \ RETVAL #VPX_DEC_MEM_ERROR *ストリーム情報からセグメントサイズを決定することができません。 * / vpx_dec_err_t vpx_dec_get_mem_map（vpx_dec_ctx_t * CTX、vpx_dec_mmap_t * MMAP、CONST vpx_dec_stream_info_tの*のSI、vpx_dec_iter_t * ITER）推奨されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Identify allocated segments to decoder instance
        *
        * Stores a list of allocated segments in the decoder.  Segments
        * \ref MUST be passed in the order they are read from
        * vpx_dec_get_mem_map(), but may be passed in groups of any
        * size.  Segments \ref MUST be set only once.  The allocation
        * function \ref MUST ensure that the vpx_dec_mmap_t::base member
        * is non-NULL.  If the segment requires cleanup handling (e.g.,
        * calling free() or close()) then the vpx_dec_mmap_t::dtor
        * member \ref MUST be populated.
        *
        * \param[in]      ctx       Pointer to this instance&#39;s context.
        * \param[in]      mmaps     Pointer to the first memory map
        *                           entry in the list.
        * \param[in]      num_maps  Number of entries being set at this
        *                           time
        *
        * \retval #VPX_DEC_OK
        *     The segment was stored in the decoder context.
        * \retval #VPX_DEC_ERROR
        *     Decoder does not support XMA mode.
        * \retval #VPX_DEC_MEM_ERROR
        *     Segment base address was not set, or segment was already
        * stored.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
*/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
＊／
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_dec_err_t vpx_dec_set_mem_map( vpx_dec_ctx_t *ctx, vpx_dec_mmap_t *mmaps, unsigned int num_maps) DEPRECATED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_dec_err_t vpx_dec_set_mem_map（vpx_dec_ctx_t * CTX、vpx_dec_mmap_t * mmaps、unsigned int型num_maps）推奨されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_xma*/
       /*!@} - end defgroup decoder*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif #ifdef __cplusplus } #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifのの#ifdef __cplusplus} #endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.22. vpx_image.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.22。 vpx_image.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &#34;vpx/vpx_image.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書式#include &lt;stdlib.h&gt;に含ま書式#include &lt;string.hの&gt;の#include &#34;VPX / vpx_image.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static vpx_image_t *img_alloc_helper(vpx_image_t *img, vpx_img_fmt_t fmt, unsigned int d_w, unsigned int d_h, unsigned int stride_align, unsigned char *img_data) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的vpx_image_t * img_alloc_helper（vpx_image_t * IMG、vpx_img_fmt_t FMT、unsigned int型d_w、unsigned int型D_H、unsigned int型stride_align、unsigned char型* img_data）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       unsigned int  h, w, s, xcs, ycs, bps;
       int           align;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Treat align==0 like align==1 */
       if (!stride_align)
           stride_align = 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Validate alignment (must be power of 2) */
       if (stride_align &amp; (stride_align - 1))
           goto fail;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Get sample size for this format */
       switch (fmt)
       {
       case VPX_IMG_FMT_RGB32:
       case VPX_IMG_FMT_RGB32_LE:
       case VPX_IMG_FMT_ARGB:
       case VPX_IMG_FMT_ARGB_LE:
           bps = 32;
           break;
       case VPX_IMG_FMT_RGB24:
       case VPX_IMG_FMT_BGR24:
           bps = 24;
           break;
       case VPX_IMG_FMT_RGB565:
       case VPX_IMG_FMT_RGB565_LE:
       case VPX_IMG_FMT_RGB555:
       case VPX_IMG_FMT_RGB555_LE:
       case VPX_IMG_FMT_UYVY:
       case VPX_IMG_FMT_YUY2:
       case VPX_IMG_FMT_YVYU:
           bps = 16;
           break;
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           bps = 12;
           break;
       default:
           bps = 16;
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Get chroma shift values for this format */
       switch (fmt)
       {
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           xcs = 1;
           break;
       default:
           xcs = 0;
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       switch (fmt)
       {
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           ycs = 1;
           break;
       default:
           ycs = 0;
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Calculate storage sizes given the chroma subsampling */
       align = (1 &lt;&lt; xcs) - 1;
       w = (d_w + align) &amp; ~align;
       align = (1 &lt;&lt; ycs) - 1;
       h = (d_h + align) &amp; ~align;
       s = (fmt &amp; VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
       s = (s + stride_align - 1) &amp; ~(stride_align - 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Allocate the new image */
       if (!img)
       {
           img = (vpx_image_t *)calloc(1, sizeof(vpx_image_t));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (!img)
               goto fail;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           img-&gt;self_allocd = 1;
       } else
       {
           memset(img, 0, sizeof(vpx_image_t));
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
img-&gt;img_data = img_data;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IMG-&gt; img_data = img_data。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (!img_data)
       {
           img-&gt;img_data = malloc((fmt &amp; VPX_IMG_FMT_PLANAR) ?
             h * w * bps / 8 : h * s);
           img-&gt;img_data_owner = 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (!img-&gt;img_data) goto fail;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（！IMG-&gt; img_data）後藤失敗した場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       img-&gt;fmt = fmt;
       img-&gt;w = w;
       img-&gt;h = h;
       img-&gt;x_chroma_shift = xcs;
       img-&gt;y_chroma_shift = ycs;
       img-&gt;bps = bps;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Calculate strides */
       img-&gt;stride[VPX_PLANE_Y] = img-&gt;stride[VPX_PLANE_ALPHA] = s;
       img-&gt;stride[VPX_PLANE_U] = img-&gt;stride[VPX_PLANE_V] = s &gt;&gt; xcs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Default viewport to entire image */
       if (!vpx_img_set_rect(img, 0, 0, d_w, d_h))
           return img;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   fail:
       vpx_img_free(img);
       return NULL;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   vpx_image_t *vpx_img_alloc(vpx_image_t  *img,
                              vpx_img_fmt_t fmt,
                              unsigned int  d_w,
                              unsigned int  d_h,
                              unsigned int  stride_align)
   {
       return img_alloc_helper(img, fmt, d_w, d_h, stride_align, NULL);
   } vpx_image_t *vpx_img_wrap(vpx_image_t  *img,
                             vpx_img_fmt_t fmt,
                             unsigned int  d_w,
                             unsigned int  d_h,
                             unsigned int  stride_align,
                             unsigned char       *img_data)
   {
       return img_alloc_helper(img, fmt, d_w, d_h, stride_align,
         img_data);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int vpx_img_set_rect(vpx_image_t *img, unsigned int x, unsigned int y, unsigned int w, unsigned int h) { unsigned char *data;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INT vpx_img_set_rect（vpx_image_t * IMG、unsigned int型のx、unsigned int型Y、unsigned int型W、unsigned int型の時間）{unsigned char型*データ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (x + w &lt;= img-&gt;w &amp;&amp; y + h &lt;= img-&gt;h)
       {
           img-&gt;d_w = w;
           img-&gt;d_h = h;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Calculate plane pointers */
           if (!(img-&gt;fmt &amp; VPX_IMG_FMT_PLANAR))
           {
               img-&gt;planes[VPX_PLANE_PACKED] =
                   img-&gt;img_data + x * img-&gt;bps / 8 + y *
                     img-&gt;stride[VPX_PLANE_PACKED];
           }
           else
           {
               data = img-&gt;img_data;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (img-&gt;fmt &amp; VPX_IMG_FMT_HAS_ALPHA)
               {
                   img-&gt;planes[VPX_PLANE_ALPHA] =
                       data + x + y * img-&gt;stride[VPX_PLANE_ALPHA];
                   data += img-&gt;h * img-&gt;stride[VPX_PLANE_ALPHA];
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               img-&gt;planes[VPX_PLANE_Y] =
                 data + x + y * img-&gt;stride[VPX_PLANE_Y];
               data += img-&gt;h * img-&gt;stride[VPX_PLANE_Y];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (!(img-&gt;fmt &amp; VPX_IMG_FMT_UV_FLIP))
               {
                   img-&gt;planes[VPX_PLANE_U] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
                   data += (img-&gt;h &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
                   img-&gt;planes[VPX_PLANE_V] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
               }
               else
               {
                   img-&gt;planes[VPX_PLANE_V] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
                   data += (img-&gt;h &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
                   img-&gt;planes[VPX_PLANE_U] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 return 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
0を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return -1; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
-1を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void vpx_img_flip(vpx_image_t *img)
   {
       /* Note: In the calculation pointer adjustment calculation, we
        * want the rhs to be promoted to a signed type.  Section 6.3.1.8
        * of the ISO C99 standard [ISO-C99] indicates that if the
        * adjustment parameter is unsigned, the stride parameter will be
        * promoted to unsigned, causing errors when the lhs is a larger
        * type than the rhs.
        */
       img-&gt;planes[VPX_PLANE_Y] += (signed)
         (img-&gt;d_h - 1) * img-&gt;stride[VPX_PLANE_Y];
       img-&gt;stride[VPX_PLANE_Y] = -img-&gt;stride[VPX_PLANE_Y];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_U] += (signed)
         ((img-&gt;d_h &gt;&gt; img-&gt;y_chroma_shift) - 1)
                               * img-&gt;stride[VPX_PLANE_U];
       img-&gt;stride[VPX_PLANE_U] = -img-&gt;stride[VPX_PLANE_U];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_V] += (signed)
                               ((img-&gt;d_h &gt;&gt; img-&gt;y_chroma_shift) - 1) *
                               img-&gt;stride[VPX_PLANE_V];
       img-&gt;stride[VPX_PLANE_V] = -img-&gt;stride[VPX_PLANE_V];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_ALPHA] += (signed)
         (img-&gt;d_h - 1) * img-&gt;stride[VPX_PLANE_ALPHA];
       img-&gt;stride[VPX_PLANE_ALPHA] = -img-&gt;stride[VPX_PLANE_ALPHA];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vpx_img_free(vpx_image_t *img) { if (img) { if (img-&gt;img_data &amp;&amp; img-&gt;img_data_owner) free(img-&gt;img_data);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空vpx_img_free（vpx_image_t * IMG）{場合（IMG）{場合（IMG-&gt; img_data &amp;&amp; IMG-&gt; img_data_owner）無料（IMG-&gt; img_data）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 if (img-&gt;self_allocd) free(img); } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もし（IMG-&gt; self_allocd）無料（IMG）; }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.23. vpx_image.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.23。 vpx_image.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*!\file
    * \brief Describes the vpx image descriptor and associated
    * operations
    *
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifdef __cplusplus extern &#34;C&#34; { #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifdef __cplusplusはextern &#34;C&#34; {#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef VPX_IMAGE_H #define VPX_IMAGE_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndefのVPX_IMAGE_Hの#define VPX_IMAGE_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Current ABI version number
        *
        * \internal
        * If this file is altered in any way that changes the ABI, this
        * value must be bumped.  Examples include, but are not limited
        * to, changing types, removing or reassigning enums,
        * adding/removing/rearranging fields to structures
        */
   #define VPX_IMAGE_ABI_VERSION (1) /**&lt;\hideinitializer*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define VPX_IMG_FMT_PLANAR     0x100  /**&lt; Image is a planar
                                              format */
   #define VPX_IMG_FMT_UV_FLIP    0x200  /**&lt; V plane precedes U plane
                                              in memory */
   #define VPX_IMG_FMT_HAS_ALPHA  0x400  /**&lt; Image has an alpha channel
                                              component */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief List of supported image formats */
       typedef enum vpx_img_fmt {
           VPX_IMG_FMT_NONE,
           VPX_IMG_FMT_RGB24,      /**&lt; 24 bit per pixel packed RGB */
           VPX_IMG_FMT_RGB32,      /**&lt; 32 bit per pixel packed 0RGB */
           VPX_IMG_FMT_RGB565,     /**&lt; 16 bit per pixel, 565 */
           VPX_IMGFMT_RGB555,      /**&lt; 16 bit per pixel, 555 */
           VPX_IMG_FMT_UYVY,       /**&lt; UYVY packed YUV */
           VPX_IMG_FMT_YUY2,       /**&lt; YUYV packed YUV */
           VPX_IMG_FMT_YVYU,       /**&lt; YVYU packed YUV */
           VPX_IMG_FMT_BGR24,      /**&lt; 24 bit per pixel packed BGR */
           VPX_IMG_FMT_RGB32_LE,   /**&lt; 32 bit packed BGR0 */
           VPX_IMG_FMT_ARGB,       /**&lt; 32 bit packed ARGB, alpha=255 */
           VPX_IMG_FMT_ARGB_LE,    /**&lt; 32 bit packed BGRA, alpha=255 */
           VPX_IMG_FMT_RGB565_LE,  /**&lt; 16 bit per pixel,
                                        gggbbbbb rrrrrggg */
           VPX_IMG_FMT_RGB555_LE,  /**&lt; 16 bit per pixel,
                                        gggbbbbb 0rrrrrgg */
           VPX_IMG_FMT_YV12    = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 1, /**&lt; planar YVU */
           VPX_IMG_FMT_I420    = VPX_IMG_FMT_PLANAR | 2,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           VPX_IMG_FMT_VPXYV12 = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 3, /** &lt; planar 4:2:0 format with
                                            vpx color space */
           VPX_IMG_FMT_VPXI420 = VPX_IMG_FMT_PLANAR | 4   /** &lt; planar
             4:2:0 format with vpx color space */
       }
       vpx_img_fmt_t; /**&lt; alias for enum vpx_img_fmt */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT
   /** \deprecated Use #VPX_IMG_FMT_PLANAR */
   #define IMG_FMT_PLANAR         VPX_IMG_FMT_PLANAR
   /** \deprecated Use #VPX_IMG_FMT_UV_FLIP */
   #define IMG_FMT_UV_FLIP        VPX_IMG_FMT_UV_FLIP
   /** \deprecated Use #VPX_IMG_FMT_HAS_ALPHA */
   #define IMG_FMT_HAS_ALPHA      VPX_IMG_FMT_HAS_ALPHA
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Deprecated list of supported image formats
        * \deprecated New code should use #vpx_img_fmt
        */
   #define img_fmt   vpx_img_fmt
       /*!\brief alias for enum img_fmt.
        * \deprecated New code should use #vpx_img_fmt_t
        */
   #define img_fmt_t vpx_img_fmt_t
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /** \deprecated Use #VPX_IMG_FMT_NONE */
   #define IMG_FMT_NONE       VPX_IMG_FMT_NONE
   /** \deprecated Use #VPX_IMG_FMT_RGB24 */
   #define IMG_FMT_RGB24      VPX_IMG_FMT_RGB24
   /** \deprecated Use #VPX_IMG_FMT_RGB32 */
   #define IMG_FMT_RGB32      VPX_IMG_FMT_RGB32
   /** \deprecated Use #VPX_IMG_FMT_RGB565 */
   #define IMG_FMT_RGB565     VPX_IMG_FMT_RGB565
   /** \deprecated Use #VPX_IMG_FMT_RGB555 */
   #define IMG_FMT_RGB555     VPX_IMG_FMT_RGB555
   /** \deprecated Use #VPX_IMG_FMT_UYVY */
   #define IMG_FMT_UYVY       VPX_IMG_FMT_UYVY
   /** \deprecated Use #VPX_IMG_FMT_YUY2 */
   #define IMG_FMT_YUY2       VPX_IMG_FMT_YUY2
   /** \deprecated Use #VPX_IMG_FMT_YVYU */
   #define IMG_FMT_YVYU       VPX_IMG_FMT_YVYU
   /** \deprecated Use #VPX_IMG_FMT_BGR24 */
   #define IMG_FMT_BGR24      VPX_IMG_FMT_BGR24
   /**&lt; \deprecated Use #VPX_IMG_FMT_RGB32_LE */
   #define IMG_FMT_RGB32_LE   VPX_IMG_FMT_RGB32_LE
   /** \deprecated Use #VPX_IMG_FMT_ARGB */
   #define IMG_FMT_ARGB       VPX_IMG_FMT_ARGB
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /** \deprecated Use #VPX_IMG_FMT_ARGB_LE */
   #define IMG_FMT_ARGB_LE    VPX_IMG_FMT_ARGB_LE
   /** \deprecated Use #VPX_IMG_FMT_RGB565_LE */
   #define IMG_FMT_RGB565_LE  VPX_IMG_FMT_RGB565_LE
   /** \deprecated Use #VPX_IMG_FMT_RGB555_LE */
   #define IMG_FMT_RGB555_LE  VPX_IMG_FMT_RGB555_LE
   /** \deprecated Use #VPX_IMG_FMT_YV12 */
   #define IMG_FMT_YV12       VPX_IMG_FMT_YV12
   /** \deprecated Use #VPX_IMG_FMT_I420 */
   #define IMG_FMT_I420       VPX_IMG_FMT_I420
   /** \deprecated Use #VPX_IMG_FMT_VPXYV12 */
   #define IMG_FMT_VPXYV12    VPX_IMG_FMT_VPXYV12
   /** \deprecated Use #VPX_IMG_FMT_VPXI420 */
   #define IMG_FMT_VPXI420    VPX_IMG_FMT_VPXI420
   #endif /* VPX_CODEC_DISABLE_COMPAT */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /**\brief Image Descriptor */
       typedef struct vpx_image
       {
           vpx_img_fmt_t fmt; /**&lt; Image Format */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Image storage dimensions */
           unsigned int  w;   /**&lt; Stored image width */
           unsigned int  h;   /**&lt; Stored image height */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Image display dimensions */
           unsigned int  d_w;   /**&lt; Displayed image width */
           unsigned int  d_h;   /**&lt; Displayed image height */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Chroma subsampling info */
           unsigned int  x_chroma_shift;   /**&lt; subsampling order, X */
           unsigned int  y_chroma_shift;   /**&lt; subsampling order, Y */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Image data pointers. */
   #define VPX_PLANE_PACKED 0  /**&lt; To be used for all packed formats */
   #define VPX_PLANE_Y      0  /**&lt; Y (Luminance) plane */
   #define VPX_PLANE_U      1  /**&lt; U (Chroma) plane */
   #define VPX_PLANE_V      2  /**&lt; V (Chroma) plane */
   #define VPX_PLANE_ALPHA  3  /**&lt; A (Transparency) plane */
   #if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT
   #define PLANE_PACKED     VPX_PLANE_PACKED
   #define PLANE_Y          VPX_PLANE_Y
   #define PLANE_U          VPX_PLANE_U
   #define PLANE_V          VPX_PLANE_V
   #define PLANE_ALPHA      VPX_PLANE_ALPHA
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           unsigned char *planes[4];  /**&lt; pointer to the top-left pixel
           q                               for each plane */
           int    stride[4];  /**&lt; stride between rows for each plane */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           int    bps; /**&lt; bits per sample (for packed formats) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* The following member may be set by the application to
            * associate data with this image.
            */
           void   *user_priv; /**&lt; may be set by the application to
                                    associate data with this image. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* The following members should be treated as private. */
           unsigned char *img_data;       /**&lt; private */
           int      img_data_owner; /**&lt; private */
           int      self_allocd;    /**&lt; private */
       } vpx_image_t; /**&lt; alias for struct vpx_image */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /**\brief Representation of a rectangle on a surface */
       typedef struct vpx_image_rect
       {
           unsigned int x; /**&lt; leftmost column */
           unsigned int y; /**&lt; topmost row */
           unsigned int w; /**&lt; width */
           unsigned int h; /**&lt; height */
       } vpx_image_rect_t; /**&lt; alias for struct vpx_image_rect */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Open a descriptor, allocating storage for the
        * underlying image
        *
        * Returns a descriptor for storing an image of the given format.
        * The storage for the descriptor is allocated on the heap.
        *
        * \param[in]    img       Pointer to storage for descriptor.
        *                         If this parameter is NULL, the storage
        *                         for the descriptor will be allocated
        *                         on the heap.
        * \param[in]    fmt       Format for the image
        * \param[in]    d_w       Width of the image
        * \param[in]    d_h       Height of the image
        * \param[in]    align     Alignment, in bytes, of each row in
        *                         the image.
        *
        * \return Returns a pointer to the initialized image descriptor.
        *         If the img parameter is non-null, the value of the img
        *         parameter will be returned.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_image_t *vpx_img_alloc(vpx_image_t *img, vpx_img_fmt_t fmt, unsigned int d_w, unsigned int d_h, unsigned int align);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_image_t * vpx_img_alloc（vpx_image_t * IMG、vpx_img_fmt_t FMT、unsigned int型d_w、unsigned int型D_H、unsigned int型アライン）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Open a descriptor, using existing storage for the
        * underlying image
        *
        * Returns a descriptor for storing an image of the given format.
        * The storage for descriptor has been allocated elsewhere, and a
        * descriptor is desired to &#34;wrap&#34; that storage.
        *
        * \param[in]    img       Pointer to storage for descriptor.
        *                         If this parameter is NULL, the storage
        *                         for the descriptor will be
        *                         allocated on the heap.
        * \param[in]    fmt       Format for the image
        * \param[in]    d_w       Width of the image
        * \param[in]    d_h       Height of the image
        * \param[in]    align     Alignment, in bytes, of each row in
        *                         the image.
        * \param[in]    img_data  Storage to use for the image
        *
        * \return Returns a pointer to the initialized image descriptor.
        *         If the img parameter is non-null, the value of the img
        *         parameter will be returned.
        */
       vpx_image_t *vpx_img_wrap(vpx_image_t  *img,
                                 vpx_img_fmt_t fmt,
                                 unsigned int d_w,
                                 unsigned int d_h,
                                 unsigned int align,
                                 unsigned char      *img_data);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Set the rectangle identifying the displayed portion of
        * the image
        *
        * Updates the displayed rectangle (aka viewport) on the image
        * surface to match the specified coordinates and size.
        *
        * \param[in]    img       Image descriptor
        * \param[in]    x         leftmost column
        * \param[in]    y         topmost row
        * \param[in]    w         width
        * \param[in]    h         height
        *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 * \return 0 if the requested rectangle is valid, non-zero * otherwise. */ int vpx_img_set_rect(vpx_image_t *img, unsigned int x, unsigned int y, unsigned int w, unsigned int h);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
要求された矩形が非ゼロで、有効であれば* \リターン0 *そう。 * / INT vpx_img_set_rect（vpx_image_t * IMG、unsigned int型のx、unsigned int型のY、W unsigned int型、unsigned int型のH）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Flip the image vertically (top for bottom)
        *
        * Adjusts the image descriptor&#39;s pointers and strides to make
        * the image be referenced upside-down.
        *
        * \param[in]    img       Image descriptor
        */
       void vpx_img_flip(vpx_image_t *img);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*!\brief Close an image descriptor
        *
        * Frees all allocated storage associated with an image
        * descriptor.
        *
        * \param[in]    img       Image descriptor
        */
       void vpx_img_free(vpx_image_t *img);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif #ifdef __cplusplus } #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifのの#ifdef __cplusplus} #endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.24. vpx_integer.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.24。 vpx_integer.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef VPX_INTEGER_H #define VPX_INTEGER_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndefのVPX_INTEGER_Hの#define VPX_INTEGER_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* get ptrdiff_t, size_t, wchar_t, NULL */
   #include &lt;stddef.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #if defined(_MSC_VER) || defined(VPX_EMULATE_INTTYPES)
   typedef signed char  int8_t;
   typedef signed short int16_t;
   typedef signed int   int32_t;
   typedef unsigned char  uint8_t;
   typedef unsigned short uint16_t;
   typedef unsigned int   uint32_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #if defined(_MSC_VER)
   typedef signed __int64   int64_t;
   typedef unsigned __int64 uint64_t;
   #define PRId64 &#34;I64d&#34;
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #ifdef HAVE_ARMV6
   typedef unsigned int int_fast16_t;
   #else
   typedef signed short int_fast16_t;
   #endif
   typedef signed char int_fast8_t;
   typedef unsigned char uint_fast8_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef _UINTPTR_T_DEFINED typedef unsigned int uintptr_t; #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndefの_UINTPTR_T_DEFINEDのtypedef unsigned int型のuintptr_tを。 #endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#else
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#else
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Most platforms have the C99 standard integer types. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#if defined(__cplusplus) &amp;&amp; !defined(__STDC_FORMAT_MACROS) #define __STDC_FORMAT_MACROS #endif #include &lt;stdint.h&gt; #include &lt;inttypes.h&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#if（__ CPLUSPLUS）&amp;&amp;！定義された（__ STDC_FORMAT_MACROS）の#define __STDC_FORMAT_MACROS #endifの書式#include &lt;stdint.h&gt;の#include &lt;inttypes.h&gt;に定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endifの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.25. AUTHORS File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.25。作者ファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Aaron Watry &lt;awatry@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アーロンWatry &lt;awatry@gmail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adrian Grange &lt;agrange@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エイドリアン・グランジ&lt;agrange@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alex Converse &lt;alex.converse@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アレックスコンバース&lt;alex.converse@gmail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andoni Morales Alastruey &lt;ylatuya@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アンドニ・モラレスAlastruey &lt;ylatuya@gmail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andres Mejia &lt;mcitadel@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アンドレス・メヒア&lt;mcitadel@gmail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attila Nagy &lt;attilanagy@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アッティラナジ&lt;attilanagy@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fabio Pedretti &lt;fabio.ped@libero.it&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファビオ・ペドレッティ&lt;fabio.ped@libero.it&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Frank Galligan &lt;fgalligan@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フランクGalligan &lt;fgalligan@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fredrik Soederquist &lt;fs@opera.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレドリックSoederquist &lt;fs@opera.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fritz Koenig &lt;frkoenig@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フリッツ・ケーニッヒ&lt;frkoenig@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Gaute Strokkenes &lt;gaute.strokkenes@broadcom.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Gaute木製バケツ&lt;gaute.strokkenes@broadcom.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Giuseppe Scrivano &lt;gscrivano@gnu.org&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジュゼッペScrivano &lt;gscrivano@gnu.org&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Guillermo Ballester Valor &lt;gbvalor@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ギレルモBallester武勇&lt;gbvalor@gmail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Henrik Lundin &lt;hlundin@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘンリク・ランディン&lt;hlundin@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
James Berry &lt;jamesberry@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジェームズ・ベリー&lt;jamesberry@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
James Zern &lt;jzern@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジェームズZern &lt;jzern@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jan Kratochvil &lt;jan.kratochvil@redhat.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジャン・クラトックビル&lt;jan.kratochvil@redhat.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jeff Muizelaar &lt;jmuizelaar@mozilla.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジェフPOUND &lt;jmuizelaar@mozilla.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jim Bankoski &lt;jimbankoski@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジム・Bankoski &lt;jimbankoski@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Johann Koenig &lt;johannkoenig@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヨハン・ケーニッヒ&lt;johannkoenig@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
John Koleszar &lt;jkoleszar@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジョンKoleszár&lt;jkoleszar@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Justin Clift &lt;justin@salasaga.org&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジャスティン・クリフト&lt;justin@salasaga.org&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Justin Lebar &lt;justin.lebar@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジャスティン幅&lt;justin.lebar@gmail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Luca Barbato &lt;lu_zero@gentoo.org&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルカBarbato &lt;lu_zero@gentoo.org&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Makoto Kato &lt;makoto.kt@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まこと かと ＜まこと。ｋｔ＠ｇまいｌ。こｍ＞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Ettl &lt;ettl.martin78@googlemail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マーティンEttl &lt;ettl.martin78@googlemail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael Kohler &lt;michaelkohler@live.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイケル・コーラー&lt;michaelkohler@live.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mikhal Shemer &lt;mikhal@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミハル・Shemer &lt;михал@гоогле.цум&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pascal Massimino &lt;pascal.massimino@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パスカル・マッシミーノ&lt;pascal.massimino@gmail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Patrik Westin &lt;patrik.westin@gmail.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パトリックウェスティン&lt;patrik.westin@gmail.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Wilkins &lt;paulwilkins@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポール・ウィルキンス&lt;paulwilkins@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pavol Rusnak &lt;stick@gk2.sk&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パボルRusnak &lt;stick@gk2.sk&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Philip Jaegenstedt &lt;philipj@opera.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィリップJaegenstedt &lt;philipj@opera.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Scott LaVarnway &lt;slavarnway@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スコットLaVarnway &lt;slavarnway@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tero Rintaluoma &lt;teror@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TERO Rintaluoma &lt;teror@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timothy B. Terriberry &lt;tterribe@xiph.org&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ティモシー・B. Terriberry &lt;tterribe@xiph.org&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tom Finegan &lt;tomfinegan@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トムFinegan &lt;tomfinegan@google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yaowu Xu &lt;yaowu@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Y嘆きウーX U &lt;医薬Google.com @&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yunqing Wang &lt;yunqingwang@google.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Y UN清王&lt;Yunqingネットワーク@ Google.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グーグル株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Mozilla Foundation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mozilla Foundationは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Xiph.Org Foundation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Xiph.Org財団
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.26. LICENSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.26。ライセンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2010, 2011, Google Inc. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2010、2011、グーグル株式会社すべての権利を保有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再配布および、改変してまたは改変せずに、ソースおよびバイナリ形式で使用し、以下の条件が満たされていることを許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oソースコードの再配布は、上記の著作権表示、条件のリストおよび以下の免責事項を保持しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oバイナリ形式で再配布は、上記の著作権表示、条件のリストおよび文書および/または分布を備えた他の材料で次の免責事項を再現しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Neither the name of Google nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oグーグルの名前もその貢献者の名前はいずれも、特定の書面による事前の許可なしに、本ソフトウェアから派生した製品を推薦または促進するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「現状のまま」、いかなる明示または黙示の保証、含むがこれらに限定されないが、特定目的に対する適合性の黙示の保証は放棄さ本ソフトウェアは著作権所有者によって提供されます。 NO EVENT著作権者もコントリビューターを含むあらゆる直接的、間接的、偶発的、特別、懲罰的、または間接的損害（についても責任を負いあってもよいが、代替商品またはサービスの調達、これらに限定されないものとし、使用、データ、または利益の損失; OR事業の中断）原因で生じた（そのような損害の可能性について知らされていた場合でも、一切このソフトウェアの使用の損失、データの損失）過失またはその他を含む責任、それが契約、厳格な責任、不法行為のどのような理論の上で。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.27. PATENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.27。特許
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional IP Rights Grant (Patents)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加のIPの権利付与（特許）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;This implementation&#34; means the copyrightable works distributed by Google as part of the WebM Project.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「この実装は、」WebMのプロジェクトの一環としてGoogleが配布著作権保護作品を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Google hereby grants to you a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, transfer, and otherwise run, modify and propagate the contents of this implementation of VP8, where such license applies only to those patent claims, both currently owned by Google and acquired in the future, licensable by Google that are necessarily infringed by this implementation of VP8. This grant does not include claims that would be infringed only as a consequence of further modification of this implementation. If you or your agent or exclusive licensee institute or order or agree to the institution of patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that this implementation of VP8 or any code incorporated within this implementation of VP8 constitutes direct or contributory patent infringement, or inducement of patent infringement, then any patent rights granted to you under this License for this implementation of VP8 shall terminate as of the date such litigation is filed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Googleはここに、あなたに永遠の、世界的、非独占的、無償を許可しませんロイヤリティフリーの、取消不能（この項で述べたよう除いて）にする特許ライセンスを、利用してきた、販売の申し出、販売、輸入、転送、そうでなければ実行し、そのようなライセンスの両方が、現在Googleが所有しており、将来的に取得し、必ずしもVP8のこの実装によって侵害されているGoogleによるライセンス供与、のみ、特許請求の範囲に適用されるVP8、この実装の内容を変更して伝播します。この助成金は、この実装のさらなる変更の結果として侵害されるだろう主張が含まれていません。あなたやあなたのエージェントまたは専用実施権機関や注文または（訴訟におけるクロス請求または反訴を含む）任意のエンティティに対する特許訴訟の機関に同意するには、VP8のこの実装または任意のコードがVP8構成のこの実装の中に組み込まれていることを主張した場合直接または寄与特許侵害、または特許侵害の誘発は、その後、VP8のこの実装のために、このライセンスの下であなたに付与された特許権は、そのような訴訟が提起された日で終了するものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A VP8 decoder should take appropriate security considerations into account, as outlined in [RFC4732] and [RFC3552]. It is extremely important that a decoder be robust against malicious payloads. Malicious payloads must not cause the decoder to overrun its allocated memory or to consume inordinate resources. Although encoder issues are typically rarer, the same applies to an encoder. Malicious stream data must not cause the encoder to misbehave, as this might allow an attacker access to transcoding gateways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4732]及び[RFC3552]に概説されるようVP8デコーダは、アカウントに適切なセキュリティ問題を取るべきです。デコーダは、悪意のあるペイロードに対して堅牢であることが極めて重要です。悪意のあるペイロードは、デコーダがその割り当てられたメモリをオーバーランしたり、過度のリソースを消費させてはなりません。エンコーダの問題は通常、稀ではあるが、同じことがエンコーダに適用されます。これは、トランスコーディングゲートウェイへの攻撃者がアクセスを許可する可能性があるとして、悪質なストリームデータは、エンコーダが誤動作することがあってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1. Normative Reference
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bell] Bell, T., Cleary, J., and I. Witten, &#34;Text Compression&#34;, 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ベル]ベル、T.、クリアリー、J.、およびI.ウィッテン、 &#34;テキスト圧縮&#34;、1990年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISO-C99] International Organization for Standardization, &#34;Information technology -- Programming languages -- C&#34;, ISO/IEC 9899:1999, 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準化のための[ISO-C99]国際機関、 &#34;情報技術 - プログラミング言語 -  C&#34;、​​ISO / IEC 9899：1999、1999。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ITU-R_BT.601] International Telecommunication Union, &#34;ITU BT.601-7: Studio encoding parameters of digital television for standard 4:3 and wide screen 16:9 aspect ratios&#34;, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ITU-R_BT.601]国際電気通信連合、 &#34;ITU BT.601-7：3とワイドスクリーン16：：4規格のデジタルテレビのスタジオ符号化パラメータ9のアスペクト比&#34; を、2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kernighan] Kernighan, B. and D. Ritchie, &#34;The C Programming Language (2nd edition)&#34;, April 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【カーニハン]カーニハン、B.及びD.リッチー、「Cプログラミング言語（第2版）」、1988年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Loeffler] Loeffler, C., Ligtenberg , A., and G. Moschytz, &#34;Practical Fast 1-D DCT Algorithms with 11 Multiplications&#34;, May 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【レフラー]レフラー、C.、Ligtenberg、A.、およびG. Moschytz、 &#34;11回の乗算と実用的な高速1-D DCTアルゴリズム&#34;、1989年5月を。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3552] Rescorla, E. and B. Korver, &#34;Guidelines for Writing RFC Text on Security Considerations&#34;, BCP 72, RFC 3552, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3552]レスコラ、E.とB.コーバー、BCP 72、RFC 3552、2003年7月、 &#34;セキュリティ上の考慮事項の書き方RFCテキストのためのガイドライン&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4732] Handley, M., Ed., Rescorla, E., Ed., and IAB, &#34;Internet Denial-of-Service Considerations&#34;, RFC 4732, December 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4732]ハンドリー、M.、エド。、レスコラ、E.、エド。、およびIAB、 &#34;インターネットサービス拒否の注意事項&#34;、RFC 4732、2006年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shannon] Shannon, C., &#34;A Mathematical Theory of Communication&#34;, Bell System Technical Journal Vol. 27, pp. 379-423 and 623-656, July and October 1948.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[シャノン]シャノン、C.、「通信の数学的理論」、ベルシステムテクニカルジャーナルの巻。 27頁379から423と623から656、7月と1948年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
James Bankoski Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジェームズBankoskiグーグル株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: jimbankoski@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：jimbankoski@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
John Koleszar Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジョンKoleszárグーグル株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: jkoleszar@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：jkoleszar@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lou Quillio Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーQuillioグーグル株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: louquillio@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：louquillio@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Janne Salonen Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヤンネサロネングーグル株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: jsalonen@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：jsalonen@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Wilkins Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポール・ウィルキンスグーグル株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: paulwilkins@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：paulwilkins@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yaowu Xu Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウーX Uグーグル株式会社を嘆きY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: yaowu@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：yaowu@google.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
