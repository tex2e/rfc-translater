<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 6455 - The WebSocket Protocol 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6455</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://tools.ietf.org/html/rfc6455">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6455 - The WebSocket Protocol 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6455">
              https://tools.ietf.org/html/rfc6455
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6455 - WebSocketプロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                          I. Fette
Request for Comments: 6455                                  Google, Inc.
Category: Standards Track                                    A. Melnikov
ISSN: 2070-1721                                               Isode Ltd.
                                                           December 2011
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
The WebSocket Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
WebSocketプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the origin-based security model commonly used by web browsers. The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or &lt;iframe&gt;s and long polling).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketプロトコルにより、制御された環境で信頼できないコードを実行しているクライアントと、そのコードからの通信をオプトインしたリモートホストとの間の双方向通信が可能になります。これに使用されるセキュリティモデルは、Webブラウザで一般的に使用されるオリジンベースのセキュリティモデルです。このプロトコルは、TCPで階層化された開始ハンドシェイクとそれに続く基本的なメッセージフレーミングで構成されています。このテクノロジーの目的は、複数のHTTP接続のオープンに依存しないサーバーとの双方向通信を必要とするブラウザーベースのアプリケーションにメカニズムを提供することです（たとえば、XMLHttpRequestまたは&lt;iframe&gt;の使用とロングポーリング）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはInternet Standards Trackドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6455.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6455で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2011 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Background . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  Protocol Overview  . . . . . . . . . . . . . . . . . . . .  5
     1.3.  Opening Handshake  . . . . . . . . . . . . . . . . . . . .  6
     1.4.  Closing Handshake  . . . . . . . . . . . . . . . . . . . .  9
     1.5.  Design Philosophy  . . . . . . . . . . . . . . . . . . . .  9
     1.6.  Security Model . . . . . . . . . . . . . . . . . . . . . . 10
     1.7.  Relationship to TCP and HTTP . . . . . . . . . . . . . . . 11
     1.8.  Establishing a Connection  . . . . . . . . . . . . . . . . 11
     1.9.  Subprotocols Using the WebSocket Protocol  . . . . . . . . 12
   2.  Conformance Requirements . . . . . . . . . . . . . . . . . . . 12
     2.1.  Terminology and Other Conventions  . . . . . . . . . . . . 13
   3.  WebSocket URIs . . . . . . . . . . . . . . . . . . . . . . . . 14
   4.  Opening Handshake  . . . . . . . . . . . . . . . . . . . . . . 14
     4.1.  Client Requirements  . . . . . . . . . . . . . . . . . . . 14
     4.2.  Server-Side Requirements . . . . . . . . . . . . . . . . . 20
       4.2.1.  Reading the Client&#39;s Opening Handshake . . . . . . . . 21
       4.2.2.  Sending the Server&#39;s Opening Handshake . . . . . . . . 22
     4.3.  Collected ABNF for New Header Fields Used in Handshake . . 25
     4.4.  Supporting Multiple Versions of WebSocket Protocol . . . . 26
   5.  Data Framing . . . . . . . . . . . . . . . . . . . . . . . . . 27
     5.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . 27
     5.2.  Base Framing Protocol  . . . . . . . . . . . . . . . . . . 28
     5.3.  Client-to-Server Masking . . . . . . . . . . . . . . . . . 32
     5.4.  Fragmentation  . . . . . . . . . . . . . . . . . . . . . . 33
     5.5.  Control Frames . . . . . . . . . . . . . . . . . . . . . . 36
       5.5.1.  Close  . . . . . . . . . . . . . . . . . . . . . . . . 36
       5.5.2.  Ping . . . . . . . . . . . . . . . . . . . . . . . . . 37
       5.5.3.  Pong . . . . . . . . . . . . . . . . . . . . . . . . . 37
     5.6.  Data Frames  . . . . . . . . . . . . . . . . . . . . . . . 38
     5.7.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . 38
     5.8.  Extensibility  . . . . . . . . . . . . . . . . . . . . . . 39
   6.  Sending and Receiving Data . . . . . . . . . . . . . . . . . . 39
     6.1.  Sending Data . . . . . . . . . . . . . . . . . . . . . . . 39
     6.2.  Receiving Data . . . . . . . . . . . . . . . . . . . . . . 40
   7.  Closing the Connection . . . . . . . . . . . . . . . . . . . . 41
     7.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . . . 41
       7.1.1.  Close the WebSocket Connection . . . . . . . . . . . . 41
       7.1.2.  Start the WebSocket Closing Handshake  . . . . . . . . 42
       7.1.3.  The WebSocket Closing Handshake is Started . . . . . . 42
       7.1.4.  The WebSocket Connection is Closed . . . . . . . . . . 42
       7.1.5.  The WebSocket Connection Close Code  . . . . . . . . . 42
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
       7.1.6.  The WebSocket Connection Close Reason  . . . . . . . . 43
       7.1.7.  Fail the WebSocket Connection  . . . . . . . . . . . . 43
     7.2.  Abnormal Closures  . . . . . . . . . . . . . . . . . . . . 44
       7.2.1.  Client-Initiated Closure . . . . . . . . . . . . . . . 44
       7.2.2.  Server-Initiated Closure . . . . . . . . . . . . . . . 44
       7.2.3.  Recovering from Abnormal Closure . . . . . . . . . . . 44
     7.3.  Normal Closure of Connections  . . . . . . . . . . . . . . 45
     7.4.  Status Codes . . . . . . . . . . . . . . . . . . . . . . . 45
       7.4.1.  Defined Status Codes . . . . . . . . . . . . . . . . . 45
       7.4.2.  Reserved Status Code Ranges  . . . . . . . . . . . . . 47
   8.  Error Handling . . . . . . . . . . . . . . . . . . . . . . . . 48
     8.1.  Handling Errors in UTF-8-Encoded Data  . . . . . . . . . . 48
   9.  Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . 48
     9.1.  Negotiating Extensions . . . . . . . . . . . . . . . . . . 48
     9.2.  Known Extensions . . . . . . . . . . . . . . . . . . . . . 50
   10. Security Considerations  . . . . . . . . . . . . . . . . . . . 50
     10.1. Non-Browser Clients  . . . . . . . . . . . . . . . . . . . 50
     10.2. Origin Considerations  . . . . . . . . . . . . . . . . . . 50
     10.3. Attacks On Infrastructure (Masking)  . . . . . . . . . . . 51
     10.4. Implementation-Specific Limits . . . . . . . . . . . . . . 52
     10.5. WebSocket Client Authentication  . . . . . . . . . . . . . 53
     10.6. Connection Confidentiality and Integrity . . . . . . . . . 53
     10.7. Handling of Invalid Data . . . . . . . . . . . . . . . . . 53
     10.8. Use of SHA-1 by the WebSocket Handshake  . . . . . . . . . 54
   11. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 54
     11.1. Registration of New URI Schemes  . . . . . . . . . . . . . 54
       11.1.1. Registration of &#34;ws&#34; Scheme  . . . . . . . . . . . . . 54
       11.1.2. Registration of &#34;wss&#34; Scheme . . . . . . . . . . . . . 55
     11.2. Registration of the &#34;WebSocket&#34; HTTP Upgrade Keyword . . . 56
     11.3. Registration of New HTTP Header Fields . . . . . . . . . . 57
       11.3.1. Sec-WebSocket-Key  . . . . . . . . . . . . . . . . . . 57
       11.3.2. Sec-WebSocket-Extensions . . . . . . . . . . . . . . . 58
       11.3.3. Sec-WebSocket-Accept . . . . . . . . . . . . . . . . . 58
       11.3.4. Sec-WebSocket-Protocol . . . . . . . . . . . . . . . . 59
       11.3.5. Sec-WebSocket-Version  . . . . . . . . . . . . . . . . 60
     11.4. WebSocket Extension Name Registry  . . . . . . . . . . . . 61
     11.5. WebSocket Subprotocol Name Registry  . . . . . . . . . . . 61
     11.6. WebSocket Version Number Registry  . . . . . . . . . . . . 62
     11.7. WebSocket Close Code Number Registry . . . . . . . . . . . 64
     11.8. WebSocket Opcode Registry  . . . . . . . . . . . . . . . . 65
     11.9. WebSocket Framing Header Bits Registry . . . . . . . . . . 66
   12. Using the WebSocket Protocol from Other Specifications . . . . 66
   13. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 67
   14. References . . . . . . . . . . . . . . . . . . . . . . . . . . 68
     14.1. Normative References . . . . . . . . . . . . . . . . . . . 68
     14.2. Informative References . . . . . . . . . . . . . . . . . . 69
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. バックグラウンド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, creating web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls [RFC6202].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまで、クライアントとサーバー間の双方向通信を必要とするウェブアプリケーション（インスタントメッセージングやゲームアプリケーションなど）を作成するには、アップストリーム通知を別個のHTTP呼び出しとして送信しながら、サーバーの更新をポーリングするHTTPの悪用が必要でした[RFC6202]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This results in a variety of problems:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、さまざまな問題が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client and a new one for each incoming message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、クライアントごとにいくつかの異なる基本的なTCP接続を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The wire protocol has a high overhead, with each client-to-server message having an HTTP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ワイヤープロトコルはオーバーヘッドが高く、クライアントからサーバーへの各メッセージにはHTTPヘッダーがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアント側のスクリプトは、返信を追跡するために、発信接続から着信接続へのマッピングを維持することを強制されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket Protocol provides. Combined with the WebSocket API [WSAPI], it provides an alternative to HTTP polling for two-way communication from a web page to a remote server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より簡単な解決策は、双方向のトラフィックに単一のTCP接続を使用することです。これは、WebSocketプロトコルが提供するものです。 WebSocket API [WSAPI]と組み合わせることで、Webページからリモートサーバーへの双方向通信のためのHTTPポーリングの代替手段を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ手法をさまざまなWebアプリケーションに使用できます。ゲーム、株価表示、同時編集が可能なマルチユーザーアプリケーション、サーバー側のサービスをリアルタイムで公開するユーザーインターフェイスなどです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication). Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for further discussion). The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment. However, the design does not limit WebSocket to HTTP, and future implementations could use a simpler handshake over a dedicated port without reinventing the entire protocol. This last point is important because the traffic patterns of interactive messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
WebSocketプロトコルは、HTTPをトランスポート層として使用する既存の双方向通信技術に取って代わり、既存のインフラストラクチャ（プロキシ、フィルタリング、認証）を活用するように設計されています。 HTTPは当初、双方向通信に使用することを目的としていなかったため、このようなテクノロジーは効率と信頼性のトレードオフとして実装されました（詳細については[RFC6202]を参照）。 WebSocketプロトコルは、既存のHTTPインフラストラクチャのコンテキストで、既存の双方向HTTPテクノロジーの目標に対処しようとします。そのため、現在の環境に固有の複雑さを示唆している場合でも、HTTPポート80および443で動作するように設計されており、HTTPプロキシと仲介者をサポートしています。ただし、この設計はWebSocketをHTTPに限定するものではなく、将来の実装では、プロトコル全体を再発明することなく、専用ポートでより簡単なハンドシェイクを使用できるようになります。インタラクティブメッセージングのトラフィックパターンは標準のHTTPトラフィックと厳密には一致せず、一部のコンポーネントに異常な負荷を引き起こす可能性があるため、この最後のポイントは重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol has two parts: a handshake and the data transfer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルには、ハンドシェイクとデータ転送の2つの部分があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake from the client looks as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントからのハンドシェイクは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        GET /chat HTTP/1.1
        Host: server.example.com
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
        Origin: http://example.com
        Sec-WebSocket-Protocol: chat, superchat
        Sec-WebSocket-Version: 13
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake from the server looks as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーからのハンドシェイクは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        HTTP/1.1 101 Switching Protocols
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
        Sec-WebSocket-Protocol: chat
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントからのリーディングラインは、Request-Lineフォーマットに従います。サーバーからの先頭行は、ステータス行形式に従います。 Request-LineおよびStatus-Lineプロダクションは、[RFC2616]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An unordered set of header fields comes after the leading line in both cases. The meaning of these header fields is specified in Section 4 of this document. Additional header fields may also be present, such as cookies [RFC6265]. The format and parsing of headers is as defined in [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
順序付けされていないヘッダーフィールドのセットは、どちらの場合も先頭行の後にあります。これらのヘッダーフィールドの意味は、このドキュメントのセクション4で指定されています。 Cookie [RFC6265]などの追加のヘッダーフィールドが存在する場合もあります。ヘッダーのフォーマットと解析は[RFC2616]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーの両方がハンドシェイクを送信すると、ハンドシェイクが成功した場合、データ転送部分が開始されます。これは、双方向通信チャネルであり、各サイドは、互いに独立して、自由にデータを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 After a successful handshake, clients and servers transfer data back and forth in conceptual units referred to in this specification as &#34;messages&#34;. On the wire, a message is composed of one or more frames. The WebSocket message does not necessarily correspond to a particular network layer framing, as a fragmented message may be coalesced or split by an intermediary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ハンドシェイクが成功すると、クライアントとサーバーは、この仕様で「メッセージ」と呼ばれる概念的な単位でデータを送受信します。ネットワーク上では、メッセージは1つ以上のフレームで構成されます。断片化されたメッセージは仲介者によって合体または分割される可能性があるため、WebSocketメッセージは必ずしも特定のネットワーク層のフレーミングに対応しているわけではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A frame has an associated type. Each frame belonging to the same message contains the same type of data. Broadly speaking, there are types for textual data (which is interpreted as UTF-8 [RFC3629] text), binary data (whose interpretation is left up to the application), and control frames (which are not intended to carry data for the application but instead for protocol-level signaling, such as to signal that the connection should be closed). This version of the protocol defines six frame types and leaves ten reserved for future use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームにはタイプが関連付けられています。同じメッセージに属する各フレームには、同じタイプのデータが含まれています。大まかに言えば、テキストデータ（UTF-8 [RFC3629]テキストとして解釈される）、バイナリデータ（解釈はアプリケーションに任されている）、および制御フレーム（アプリケーションのデータを運ぶことを目的としていない）のタイプがあります。ただし、代わりに、接続を閉じる必要があることを通知するなど、プロトコルレベルのシグナリング用です。このバージョンのプロトコルは6つのフレームタイプを定義し、将来の使用のために10を予約しておきます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Opening Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. ハンドシェイクを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client&#39;s handshake is an HTTP Upgrade request:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープニングハンドシェイクは、HTTPベースのサーバー側のソフトウェアおよび仲介者と互換性があるように意図されているため、そのサーバーと通信するHTTPクライアントとそのサーバーと通信するWebSocketクライアントの両方で1つのポートを使用できます。このため、WebSocketクライアントのハンドシェイクはHTTPアップグレードリクエストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        GET /chat HTTP/1.1
        Host: server.example.com
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
        Origin: http://example.com
        Sec-WebSocket-Protocol: chat, superchat
        Sec-WebSocket-Version: 13
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In compliance with [RFC2616], header fields in the handshake may be sent by the client in any order, so the order in which different header fields are received is not significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2616]に準拠して、ハンドシェイクのヘッダーフィールドは任意の順序でクライアントから送信される可能性があるため、異なるヘッダーフィールドが受信される順序は重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;Request-URI&#34; of the GET method [RFC2616] is used to identify the endpoint of the WebSocket connection, both to allow multiple domains to be served from one IP address and to allow multiple WebSocket endpoints to be served by a single server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETメソッド[RFC2616]の「Request-URI」は、WebSocket接続のエンドポイントを識別するために使用されます。これにより、1つのIPアドレスから複数のドメインにサービスを提供したり、1つのサーバーで複数のWebSocketエンドポイントにサービスを提供したりできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client includes the hostname in the |Host| header field of its handshake as per [RFC2616], so that both the client and the server can verify that they agree on which host is in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのホスト名が| Host |に含まれている[RFC2616]によるハンドシェイクのヘッダーフィールド。これにより、クライアントとサーバーの両方が、どのホストが使用されているかについて合意できることを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional header fields are used to select options in the WebSocket Protocol. Typical options available in this version are the subprotocol selector (|Sec-WebSocket-Protocol|), list of extensions support by the client (|Sec-WebSocket-Extensions|), |Origin| header field, etc. The |Sec-WebSocket-Protocol| request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client. The server selects one or none of the acceptable protocols and echoes that value in its handshake to indicate that it has selected that protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加のヘッダーフィールドは、WebSocketプロトコルのオプションを選択するために使用されます。このバージョンで使用できる一般的なオプションは、サブプロトコルセレクター（| Sec-WebSocket-Protocol |）、クライアントがサポートする拡張機能のリスト（| Sec-WebSocket-Extensions |）、| Origin |です。ヘッダーフィールドなど。| Sec-WebSocket-Protocol | request-headerフィールドは、どのサブプロトコル（WebSocketプロトコルを介して階層化されたアプリケーションレベルのプロトコル）がクライアントに受け入れられるかを示すために使用できます。サーバーは、受け入れ可能なプロトコルを1つまたはまったく選択せず、その値をハンドシェイクにエコーして、そのプロトコルが選択されたことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Sec-WebSocket-Protocol: chat
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Sec-WebSocket-Protocol：チャット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Origin| header field [RFC6454] is used to protect against unauthorized cross-origin use of a WebSocket server by scripts using the WebSocket API in a web browser. The server is informed of the script origin generating the WebSocket connection request. If the server does not wish to accept connections from this origin, it can choose to reject the connection by sending an appropriate HTTP error code. This header field is sent by browser clients; for non-browser clients, this header field may be sent if it makes sense in the context of those clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
|起源|ヘッダーフィールド[RFC6454]は、WebブラウザーでWebSocket APIを使用するスクリプトによるWebSocketサーバーの不正なクロスオリジン使用から保護するために使用されます。サーバーは、WebSocket接続要求を生成するスクリプトの起点を通知されます。サーバーがこのオリジンからの接続を受け入れたくない場合は、適切なHTTPエラーコードを送信して、接続を拒否することを選択できます。このヘッダーフィールドはブラウザクライアントによって送信されます。非ブラウザークライアントの場合、これらのクライアントのコンテキストで意味がある場合、このヘッダーフィールドが送信されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the server has to prove to the client that it received the client&#39;s WebSocket handshake, so that the server doesn&#39;t accept connections that are not WebSocket connections. This prevents an attacker from tricking a WebSocket server by sending it carefully crafted packets using XMLHttpRequest [XMLHttpRequest] or a form submission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、サーバーはクライアントのWebSocketハンドシェイクを受信したことをクライアントに証明する必要があるため、サーバーはWebSocket接続ではない接続を受け入れません。これにより、攻撃者がXMLHttpRequest [XMLHttpRequest]またはフォーム送信を使用して巧妙に細工されたパケットを送信することにより、WebSocketサーバーをだますことができなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To prove that the handshake was received, the server has to take two pieces of information and combine them to form a response. The first piece of information comes from the |Sec-WebSocket-Key| header field in the client handshake:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクが受信されたことを証明するために、サーバーは2つの情報を取得し、それらを組み合わせて応答を形成する必要があります。最初の情報は、| Sec-WebSocket-Key |から取得されます。クライアントハンドシェイクのヘッダーフィールド：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this header field, the server has to take the value (as present in the header field, e.g., the base64-encoded [RFC4648] version minus any leading and trailing whitespace) and concatenate this with the Globally Unique Identifier (GUID, [RFC4122]) &#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34; in string form, which is unlikely to be used by network endpoints that do not understand the WebSocket Protocol. A SHA-1 hash (160 bits) [FIPS.180-3], base64-encoded (see Section 4 of [RFC4648]), of this concatenation is then returned in the server&#39;s handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダーフィールドの場合、サーバーは値を取得し（ヘッダーフィールドに存在するように、たとえば、base64でエンコードされた[RFC4648]バージョンから先頭と末尾の空白を差し引いたもの）、これをグローバル一意識別子（GUID、[RFC4122 ]）文字列形式の「258EAFA5-E914-47DA-95CA-C5AB0DC85B11」。これは、WebSocketプロトコルを理解しないネットワークエンドポイントでは使用されない可能性があります。この連結のSHA-1ハッシュ（160ビット）[FIPS.180-3]、base64エンコード（[RFC4648]のセクション4を参照）は、サーバーのハンドシェイクで返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Concretely, if as in the example above, the |Sec-WebSocket-Key| header field had the value &#34;dGhlIHNhbXBsZSBub25jZQ==&#34;, the server would concatenate the string &#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34; to form the string &#34;dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34;. The server would then take the SHA-1 hash of this, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded (see Section 4 of [RFC4648]), to give the value &#34;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#34;. This value would then be echoed in the |Sec-WebSocket-Accept| header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、上記の例のように、| Sec-WebSocket-Key |ヘッダーフィールドの値が &#34;dGhlIHNhbXBsZSBub25jZQ ==&#34;の場合、サーバーは文字列 &#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34;を連結して文字列 &#34;dGhlIHNhbXBsZSBub25jZQ == 258EAFA5-E914-47DA-95CA-95CA-95CA-95CA-95CA-5CAB-95CA-5CAB11C95C-ABC95C5サーバーはこのSHA-1ハッシュを取得し、値0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xeaを提供します。次に、この値はbase64でエンコードされ（[RFC4648]のセクション4を参照）、値 &#34;s3pPLMBiTxaQ9kYGzzhZRbK + xOo =&#34;が得られます。この値は、| Sec-WebSocket-Accept |にエコーされます。ヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーからのハンドシェイクは、クライアントのハンドシェイクよりもはるかに簡単です。最初の行はHTTPステータス行で、ステータスコードは101です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
HTTP/1.1 101 Switching Protocols
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
HTTP / 1.1 101スイッチングプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply. The headers follow the status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
101以外のステータスコードは、WebSocketハンドシェイクが完了しておらず、HTTPのセマンティクスが引き続き適用されることを示します。ヘッダーはステータスコードの後に​​続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Connection| and |Upgrade| header fields complete the HTTP Upgrade. The |Sec-WebSocket-Accept| header field indicates whether the server is willing to accept the connection. If present, this header field must include a hash of the client&#39;s nonce sent in |Sec-WebSocket-Key| along with a predefined GUID. Any other value must not be interpreted as an acceptance of the connection by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
|接続|と|アップグレード|ヘッダーフィールドは、HTTPアップグレードを完了します。 | Sec-WebSocket-Accept |ヘッダーフィールドは、サーバーが接続を受け入れる用意があるかどうかを示します。存在する場合、このヘッダーフィールドには、| Sec-WebSocket-Key |で送信されるクライアントのナンスのハッシュが含まれている必要があります。事前定義されたGUIDとともに。その他の値は、サーバーによる接続の受け入れとして解釈されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        HTTP/1.1 101 Switching Protocols
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These fields are checked by the WebSocket client for scripted pages. If the |Sec-WebSocket-Accept| value does not match the expected value, if the header field is missing, or if the HTTP status code is not 101, the connection will not be established, and WebSocket frames will not be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのフィールドは、スクリプト化されたページについてWebSocketクライアントによってチェックされます。 | Sec-WebSocket-Accept |値が期待値と一致しない、ヘッダーフィールドがない、またはHTTPステータスコードが101でない場合、接続は確立されず、WebSocketフレームは送信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Option fields can also be included. In this version of the protocol, the main option field is |Sec-WebSocket-Protocol|, which indicates the subprotocol that the server has selected. WebSocket clients verify that the server included one of the values that was specified in the WebSocket client&#39;s handshake. A server that speaks multiple subprotocols has to make sure it selects one based on the client&#39;s handshake and specifies it in its handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションフィールドも含めることができます。このバージョンのプロトコルでは、メインオプションフィールドは| Sec-WebSocket-Protocol |で、サーバーが選択したサブプロトコルを示します。 WebSocketクライアントは、サーバーにWebSocketクライアントのハンドシェイクで指定された値の1つが含まれていたことを確認します。複数のサブプロトコルを話すサーバーは、クライアントのハンドシェイクに基づいて1つを選択し、ハンドシェイクでそれを指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Sec-WebSocket-Protocol: chat
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Sec-WebSocket-Protocol：チャット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server can also set cookie-related option fields to _set_ cookies, as described in [RFC6265].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6265]で説明されているように、サーバーはcookie関連のオプションフィールドを_set_ cookiesに設定することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Closing Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. ハンドシェイクを閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The closing handshake is far simpler than the opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クローズハンドシェイクは、オープンハンドシェイクよりもはるかに単純です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake (detailed in Section 5.5.1). Upon receiving such a frame, the other peer sends a Close frame in response, if it hasn&#39;t already sent one. Upon receiving _that_ control frame, the first peer then closes the connection, safe in the knowledge that no further data is forthcoming.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらのピアも、指定された制御シーケンスを含むデータを含む制御フレームを送信して、クローズハンドシェイクを開始できます（詳細は5.5.1項を参照）。そのようなフレームを受信すると、もう一方のピアは、まだフレームを送信していない場合は、それに応答してCloseフレームを送信します。最初のピアは、その制御フレームを受信すると接続を閉じ、これ以上データが送信されないことを確認して安全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame indicating the connection should be closed, a peer discards any further data received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続を閉じる必要があることを示す制御フレームを送信した後、ピアはそれ以上データを送信しません。接続を閉じる必要があることを示す制御フレームを受信した後、ピアは受信したデータを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is safe for both peers to initiate this handshake simultaneously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方のピアがこのハンドシェイクを同時に開始しても安全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The closing handshake is intended to complement the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of intercepting proxies and other intermediaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クロージングハンドシェイクは、TCPクロージングハンドシェイク（FIN / ACK）を補完することを目的としています。TCPクロージングハンドシェイクは、特に傍受するプロキシやその他の仲介者が存在する場合、エンドツーエンドで常に信頼できるとは限らないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By sending a Close frame and waiting for a Close frame in response, certain cases are avoided where data may be unnecessarily lost. For instance, on some platforms, if a socket is closed with data in the receive queue, a RST packet is sent, which will then cause recv() to fail for the party that received the RST, even if there was data waiting to be read.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Closeフレームを送信し、それに応答してCloseフレームを待機することにより、データが不必要に失われる可能性がある特定のケースが回避されます。たとえば、一部のプラットフォームでは、受信キューにデータがあるソケットが閉じられると、RSTパケットが送信されます。これにより、データを待っているデータがあったとしても、RSTを受信したパーティでrecv()が失敗します。読んだ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. Design Philosophy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. デザイン哲学
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The WebSocket Protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (e.g., HTTP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
WebSocketプロトコルは、最小限のフレーミングが必要であるという原則に基づいて設計されています（存在する唯一のフレーミングは、プロトコルをストリームベースではなくフレームベースにし、Unicodeテキストとバイナリフレームの区別をサポートすることです）。メタデータがアプリケーションレイヤー（たとえば、HTTP）によってTCPの上に階層化されるのと同じ方法で、メタデータはアプリケーションレイヤーによってWebSocketの上に階層化されることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conceptually, WebSocket is really just a layer on top of TCP that does the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
概念的には、WebSocketは実際にはTCP上のレイヤーにすぎず、次のことを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o adds a web origin-based security model for browsers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ブラウザにWebオリジンベースのセキュリティモデルを追加します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1つのポートで複数のサービスと1つのIPアドレスで複数のホスト名をサポートするために、アドレッシングとプロトコルの命名メカニズムを追加します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCPの上にフレーミングメカニズムを重ねて、TCPが構築されているが長さの制限がないIPパケットメカニズムに戻る
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o includes an additional closing handshake in-band that is designed to work in the presence of proxies and other intermediaries
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロキシやその他の仲介者の存在下で機能するように設計された追加のハンドシェイクインバンドが追加で含まれています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other than that, WebSocket adds nothing. Basically it is intended to be as close to just exposing raw TCP to script as possible given the constraints of the Web. It&#39;s also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade request. One could conceptually use other protocols to establish client-server messaging, but the intent of WebSockets is to provide a relatively simple protocol that can coexist with HTTP and deployed HTTP infrastructure (such as proxies) and that is as close to TCP as is safe for use with such infrastructure given security considerations, with targeted additions to simplify usage and keep simple things simple (such as the addition of message semantics).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外は、WebSocketは何も追加しません。基本的には、Webの制約を考慮して、生のTCPをスクリプトに公開するだけに近いものにすることを目的としています。また、ハンドシェイクを有効なHTTPアップグレード要求にすることで、サーバーがHTTPサーバーとポートを共有できるように設計されています。概念的には他のプロトコルを使用してクライアント/サーバーメッセージングを確立することもできますが、WebSocketの目的は、HTTPやデプロイされたHTTPインフラストラクチャ（プロキシなど）と共存でき、安全である限りTCPに近い、比較的単純なプロトコルを提供することですセキュリティを考慮してこのようなインフラストラクチャで使用します。ターゲットを追加して使用を簡素化し、単純なものを単純に保ちます（メッセージセマンティクスの追加など）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol is intended to be extensible; future versions will likely introduce additional concepts such as multiplexing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは拡張可能であることを目的としています。将来のバージョンでは、多重化などの追加の概念が導入される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.6. Security Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.6. セキュリティモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WebSocket Protocol uses the origin model used by web browsers to restrict which web pages can contact a WebSocket server when the WebSocket Protocol is used from a web page. Naturally, when the WebSocket Protocol is used by a dedicated client directly (i.e., not from a web page through a web browser), the origin model is not useful, as the client can provide any arbitrary origin string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketプロトコルは、Webブラウザーが使用するオリジンモデルを使用して、WebSocketプロトコルがWebページから使用されるときにWebSocketサーバーに接続できるWebページを制限します。当然、WebSocketプロトコルが専用クライアントによって直接（つまり、WebブラウザからではなくWebページから）使用される場合、クライアントは任意の起点文字列を提供できるため、起点モデルは役に立ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 This protocol is intended to fail to establish a connection with servers of pre-existing protocols like SMTP [RFC5321] and HTTP, while allowing HTTP servers to opt-in to supporting this protocol if desired. This is achieved by having a strict and elaborate handshake and by limiting the data that can be inserted into the connection before the handshake is finished (thus limiting how much the server can be influenced).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このプロトコルは、SMTP [RFC5321]やHTTPなどの既存のプロトコルのサーバーとの接続を確立できず、必要に応じてHTTPサーバーがこのプロトコルのサポートをオプトインできるようにすることを目的としています。これは、厳密で手の込んだハンドシェイクを使用し、ハンドシェイクが完了する前に接続に挿入できるデータを制限することで実現されます（したがって、サーバーに影響を与えることができる量を制限します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is similarly intended to fail to establish a connection when data from other protocols, especially HTTP, is sent to a WebSocket server, for example, as might happen if an HTML &#34;form&#34; were submitted to a WebSocket server. This is primarily achieved by requiring that the server prove that it read the handshake, which it can only do if the handshake contains the appropriate parts, which can only be sent by a WebSocket client. In particular, at the time of writing of this specification, fields starting with |Sec-| cannot be set by an attacker from a web browser using only HTML and JavaScript APIs such as XMLHttpRequest [XMLHttpRequest].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、他のプロトコル、特にHTTPからのデータがWebSocketサーバーに送信されたときに、たとえばHTML &#34;フォーム&#34;がWebSocketサーバーに送信された場合に発生する可能性があるように、接続の確立に失敗することを目的としています。これは主に、サーバーがハンドシェイクを読み取ることを証明することを要求することで実現されます。これは、ハンドシェイクに適切なパーツが含まれ、WebSocketクライアントからのみ送信できる場合にのみ可能です。特に、この仕様の執筆時点では、| Sec- |で始まるフィールドXMLHttpRequest [XMLHttpRequest]などのHTMLおよびJavaScript APIのみを使用して、攻撃者がWebブラウザーから設定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7. Relationship to TCP and HTTP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7. TCPおよびHTTPとの関係
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WebSocket Protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketプロトコルは、独立したTCPベースのプロトコルです。 HTTPとの唯一の関係は、そのハンドシェイクがHTTPサーバーによってアップグレード要求として解釈されることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By default, the WebSocket Protocol uses port 80 for regular WebSocket connections and port 443 for WebSocket connections tunneled over Transport Layer Security (TLS) [RFC2818].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトでは、WebSocketプロトコルは、通常のWebSocket接続にポート80を使用し、トランスポート層セキュリティ（TLS）[RFC2818]でトンネリングされたWebSocket接続にポート443を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.8. Establishing a Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.8. 接続の確立
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a connection is to be made to a port that is shared by an HTTP server (a situation that is quite likely to occur with traffic to ports 80 and 443), the connection will appear to the HTTP server to be a regular GET request with an Upgrade offer. In relatively simple setups with just one IP address and a single server for all traffic to a single hostname, this might allow a practical way for systems based on the WebSocket Protocol to be deployed. In more elaborate setups (e.g., with load balancers and multiple servers), a dedicated set of hosts for WebSocket connections separate from the HTTP servers is probably easier to manage. At the time of writing of this specification, it should be noted that connections on ports 80 and 443 have significantly different success rates, with connections on port 443 being significantly more likely to succeed, though this may change with time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPサーバーで共有されているポートに接続する場合（ポート80と443へのトラフィックで発生する可能性が非常に高い状況）、接続はHTTPサーバーに表示され、通常のGET要求であるように見えます。アップグレードのオファー。単一のホスト名へのすべてのトラフィックに対して単一のIPアドレスと単一のサーバーを使用する比較的単純なセットアップでは、これにより、WebSocketプロトコルに基づくシステムを展開するための実用的な方法が可能になる場合があります。より複雑な設定（たとえば、ロードバランサーと複数のサーバー）では、HTTPサーバーとは別のWebSocket接続専用のホストのセットを管理する方がおそらく簡単です。この仕様の執筆時点では、ポート80と443での接続の成功率は大きく異なり、ポート443での接続は成功する可能性が大幅に高くなっていますが、これは時間とともに変化する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.9. Subprotocols Using the WebSocket Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.9. WebSocketプロトコルを使用したサブプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_This section is non-normative._
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_このセクションは非規範的です。_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can request that the server use a specific subprotocol by including the |Sec-WebSocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Protocol |を含めることにより、クライアントはサーバーが特定のサブプロトコルを使用することを要求できます。その握手でフィールド。これが指定されている場合、サーバーは、接続を確立するために、応答に同じフィールドと選択されたサブプロトコル値の1つを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These subprotocol names should be registered as per Section 11.5. To avoid potential collisions, it is recommended to use names that contain the ASCII version of the domain name of the subprotocol&#39;s originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it &#34;chat.example.com&#34;. If the Example Organization called their competing subprotocol &#34;chat.example.org&#34;, then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのサブプロトコル名は、セクション11.5に従って登録する必要があります。潜在的な衝突を回避するために、サブプロトコルの発信元のドメイン名のASCIIバージョンを含む名前を使用することをお勧めします。たとえば、Example Corporationがウェブ上の多くのサーバーによって実装されるチャットサブプロトコルを作成する場合、「chat.example.com」という名前を付けることができます。サンプル組織が競合するサブプロトコル「chat.example.org」を呼び出した場合、2つのサブプロトコルはサーバーによって同時に実装でき、サーバーはクライアントから送信された値に基づいて使用するサブプロトコルを動的に選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subprotocols can be versioned in backward-incompatible ways by changing the subprotocol name, e.g., going from &#34;bookings.example.net&#34; to &#34;v2.bookings.example.net&#34;. These subprotocols would be considered completely separate by WebSocket clients. Backward-compatible versioning can be implemented by reusing the same subprotocol string but carefully designing the actual subprotocol to support this kind of extensibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブプロトコルは、サブプロトコル名を変更することで、下位互換性のない方法でバージョン管理できます。たとえば、「bookings.example.net」から「v2.bookings.example.net」に変更できます。これらのサブプロトコルは、WebSocketクライアントによって完全に分離されていると見なされます。下位互換性のあるバージョン管理は、同じサブプロトコル文字列を再利用することで実装できますが、この種の拡張性をサポートするように実際のサブプロトコルを慎重に設計します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Conformance Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 適合要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様のすべての図、例、および注釈は非規範的であり、すべてのセクションは明示的に非規範的とマークされています。この仕様の他のすべては規範的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requirements phrased in the imperative as part of algorithms (such as &#34;strip any leading space characters&#34; or &#34;return false and abort these steps&#34;) are to be interpreted with the meaning of the key word (&#34;MUST&#34;, &#34;SHOULD&#34;, &#34;MAY&#34;, etc.) used in introducing the algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムの一部として命令で語られた要件（「先頭の空白文字を取り除く」または「falseを返してこれらの手順を中止する」など）は、キーワードの意味（「MUST」、「SHOULD」、「 MAY &#34;など）を使用してアルゴリズムを紹介します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conformance requirements phrased as algorithms or specific steps MAY be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow and not intended to be performant.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムまたは特定のステップとして表現された適合要件は、最終結果が同等である限り、任意の方法で実装できます。 （特に、この仕様で定義されているアルゴリズムは、わかりやすくするためのものであり、パフォーマンスを向上させるためのものではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Terminology and Other Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 用語とその他の規約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_ASCII_ shall mean the character-encoding scheme defined in [ANSI.X3-4.1986].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_ASCII_は、[ANSI.X3-4.1986]で定義されている文字エンコード方式を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document makes reference to UTF-8 values and uses UTF-8 notational formats as defined in STD 63 [RFC3629].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、UTF-8値を参照し、STD 63 [RFC3629]で定義されているUTF-8表記形式を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key terms such as named algorithms or definitions are indicated like _this_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付きアルゴリズムや定義などの主要な用語は、_this_のように示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names of header fields or variables are indicated like |this|.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールドまたは変数の名前は、| this |のように示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variable values are indicated like /this/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変数値は/ this /のように示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document references the procedure to _Fail the WebSocket Connection_. This procedure is defined in Section 7.1.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、_WebSocket接続に失敗する手順について説明します。この手順は、セクション7.1.7で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_Converting a string to ASCII lowercase_ means replacing all characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER Z).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_文字列をASCII小文字に変換することは、U + 0041からU + 005Aの範囲内のすべての文字（つまり、ラテン大文字Aからラテン大文字Zまで）を、U + 0061からU + 007Aの範囲内の対応する文字（つまり、ローマ字小文字Aからローマ字小文字Z）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comparing two strings in an _ASCII case-insensitive_ manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_ASCIIの大文字と小文字を区別しない方法で2つの文字列を比較することは、U + 0041からU + 005Aの範囲の文字（つまり、ラテン大文字Aからラテン大文字Z）の文字とU + 0061からU + 007Aの範囲の対応する文字（つまり、ラテン小文字Aからラテン小文字Zまで）も一致すると見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The term &#34;URI&#34; is used in this document as defined in [RFC3986].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、[RFC3986]で定義されている「URI」という用語が使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an implementation is required to _send_ data as part of the WebSocket Protocol, the implementation MAY delay the actual transmission arbitrarily, e.g., buffering data so as to send fewer IP packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketプロトコルの一部としてデータを_send_する実装が必要な場合、実装は実際の送信を任意に遅延させることができます（例：データをバッファリングして、送信するIPパケットを少なくします）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this document uses both [RFC5234] and [RFC2616] variants of ABNF in different sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、異なるセクションでABNFの[RFC5234]と[RFC2616]の両方のバリアントを使用していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. WebSocket URIs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. WebSocket URI
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines two URI schemes, using the ABNF syntax defined in RFC 5234 [RFC5234], and terminology and ABNF productions defined by the URI specification RFC 3986 [RFC3986].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、RFC 5234 [RFC5234]で定義されたABNF構文と、URI仕様RFC 3986 [RFC3986]で定義された用語とABNFプロダクションを使用して、2つのURIスキームを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          ws-URI = &#34;ws:&#34; &#34;//&#34; host [ &#34;:&#34; port ] path [ &#34;?&#34; query ]
          wss-URI = &#34;wss:&#34; &#34;//&#34; host [ &#34;:&#34; port ] path [ &#34;?&#34; query ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          host = &lt;host, defined in [RFC3986], Section 3.2.2&gt;
          port = &lt;port, defined in [RFC3986], Section 3.2.3&gt;
          path = &lt;path-abempty, defined in [RFC3986], Section 3.3&gt;
          query = &lt;query, defined in [RFC3986], Section 3.4&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The port component is OPTIONAL; the default for &#34;ws&#34; is port 80, while the default for &#34;wss&#34; is port 443.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポートコンポーネントはオプションです。 「ws」のデフォルトはポート80、「wss」のデフォルトはポート443です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The URI is called &#34;secure&#34; (and it is said that &#34;the secure flag is set&#34;) if the scheme component matches &#34;wss&#34; case-insensitively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スキーマコンポーネントが大文字と小文字を区別せずに「wss」と一致する場合、URIは「セキュア」と呼ばれます（「セキュアフラグが設定されている」と呼ばれます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;resource-name&#34; (also known as /resource name/ in Section 4.1) can be constructed by concatenating the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「リソース名」（4.1節では/ resource name /とも呼ばれます）は、以下を連結することで作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;/&#34; if the path component is empty
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「/」、パスコンポーネントが空の場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the path component
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o パスコンポーネント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;?&#34; if the query component is non-empty
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「？」クエリコンポーネントが空でない場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the query component
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クエリコンポーネント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fragment identifiers are meaningless in the context of WebSocket URIs and MUST NOT be used on these URIs. As with any URI scheme, the character &#34;#&#34;, when not indicating the start of a fragment, MUST be escaped as %23.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメント識別子はWebSocket URIのコンテキストでは無意味であり、これらのURIで使用してはなりません（MUST NOT）。他のURIスキームと同様に、文字「＃」は、フラグメントの開始を示さない場合、％23としてエスケープする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Opening Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. ハンドシェイクを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Client Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. クライアントの要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To _Establish a WebSocket Connection_, a client opens a connection and sends a handshake as defined in this section. A connection is defined to initially be in a CONNECTING state. A client will need to supply a /host/, /port/, /resource name/, and a /secure/ flag, which are the components of a WebSocket URI as discussed in Section 3, along with a list of /protocols/ and /extensions/ to be used. Additionally, if the client is a web browser, it supplies /origin/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_WebSocket接続を確立する_ために、クライアントは接続を開き、このセクションで定義されているようにハンドシェイクを送信します。接続は、最初はCONNECTING状態になるように定義されています。クライアントは、/ host /、/ port /、/ resource name /、および/ secure /フラグを提供する必要があります。これらは、セクション3で説明したWebSocket URIのコンポーネントであり、/ protocols /および/ extensions /使用されます。さらに、クライアントがWebブラウザーの場合は、/ origin /を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients running in controlled environments, e.g., browsers on mobile handsets tied to specific carriers, MAY offload the management of the connection to another agent on the network. In such a situation, the client for the purposes of this specification is considered to include both the handset software and any such agents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御された環境で実行されているクライアント（特定のキャリアに関連付けられたモバイルハンドセットのブラウザーなど）は、ネットワーク上の別のエージェントへの接続の管理をオフロードできます（MAY）。そのような状況では、この仕様の目的のクライアントは、ハンドセットソフトウェアとそのようなエージェントの両方を含むと見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client is to _Establish a WebSocket Connection_ given a set of (/host/, /port/, /resource name/, and /secure/ flag), along with a list of /protocols/ and /extensions/ to be used, and an /origin/ in the case of web browsers, it MUST open a connection, send an opening handshake, and read the server&#39;s handshake in response. The exact requirements of how the connection should be opened, what should be sent in the opening handshake, and how the server&#39;s response should be interpreted are as follows in this section. In the following text, we will use terms from Section 3, such as &#34;/host/&#34; and &#34;/secure/ flag&#34; as defined in that section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（_host /、/ port /、/ resource name /、および/ secure /フラグ）のセットと、使用する/ protocols /および/ extensions /のリストを指定して、クライアントが_WebSocket接続を確立する場合、および/ origin /（Webブラウザーの場合）は、接続を開き、開始ハンドシェイクを送信し、それに応じてサーバーのハンドシェイクを読み取る必要があります。このセクションでは、接続を開く方法、開始ハンドシェイクで何を送信するか、サーバーの応答をどのように解釈するかの正確な要件について説明します。以下のテキストでは、そのセクションで定義されている「/ host /」や「/ secure / flag」など、セクション3の用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The components of the WebSocket URI passed into this algorithm (/host/, /port/, /resource name/, and /secure/ flag) MUST be valid according to the specification of WebSocket URIs specified in Section 3. If any of the components are invalid, the client MUST _Fail the WebSocket Connection_ and abort these steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. このアルゴリズムに渡されるWebSocket URIのコンポーネント（/ host /、/ port /、/ resource name /、および/ secure /フラグ）は、セクション3で指定されたWebSocket URIの仕様に従って有効でなければなりません（MUST）。が無効な場合、クライアントは_WebSocket接続に失敗_し、これらの手順を中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the client already has a WebSocket connection to the remote host (IP address) identified by /host/ and port /port/ pair, even if the remote host is known by another name, the client MUST wait until that connection has been established or for that connection to have failed. There MUST be no more than one connection in a CONNECTING state. If multiple connections to the same IP address are attempted simultaneously, the client MUST serialize them so that there is no more than one connection at a time running through the following steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. / host /とポート/ port /のペアで識別されるリモートホスト（IPアドレス）へのWebSocket接続がクライアントにすでにある場合、リモートホストが別の名前で認識されている場合でも、クライアントはその接続が確立されるまで待機する必要があります。その接続が失敗したため。 CONNECTING状態の接続は1つだけでなければなりません。同じIPアドレスへの複数の接続が同時に試行される場合、クライアントは、一度に複数の接続が実行されないように、それらをシリアル化して、次の手順を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If the client cannot determine the IP address of the remote host (for example, because all communication is being done through a proxy server that performs DNS queries itself), then the client MUST assume for the purposes of this step that each host name refers to a distinct remote host, and instead the client SHOULD limit the total number of simultaneous pending connections to a reasonably low number (e.g., the client might allow simultaneous pending connections to a.example.com and b.example.com, but if thirty simultaneous connections to a single host are requested, that may not be allowed). For example, in a web browser context, the client needs to consider the number of tabs the user has open in setting a limit to the number of simultaneous pending connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
クライアントがリモートホストのIPアドレスを判別できない場合（たとえば、すべての通信がDNSクエリ自体を実行するプロキシサーバーを介して行われているため）、クライアントはこの手順の目的のために、各ホスト名が参照していると想定する必要があります。別個のリモートホスト、および代わりにクライアントは、同時保留接続の総数をかなり低い数に制限する必要があります（たとえば、クライアントはa.example.comとb.example.comへの同時保留接続を許可する場合がありますが、同時に30の場合単一のホストへの接続が要求されますが、許可されない場合があります）。たとえば、Webブラウザーのコンテキストでは、クライアントは、保留中の同時接続の数に制限を設定するときに、ユーザーが開いているタブの数を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
NOTE: This makes it harder for a script to perform a denial-of-service attack by just opening a large number of WebSocket connections to a remote host. A server can further reduce the load on itself when attacked by pausing before closing the connection, as that will reduce the rate at which the client reconnects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
注：これにより、リモートホストへのWebSocket接続を多数開くだけで、スクリプトがサービス拒否攻撃を実行することが困難になります。サーバーは、クライアントが再接続する速度を低下させるため、接続を閉じる前に一時停止することにより、攻撃されたときのサーバー自体の負荷をさらに軽減できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
NOTE: There is no limit to the number of established WebSocket connections a client can have with a single remote host. Servers can refuse to accept connections from hosts/IP addresses with an excessive number of existing connections or disconnect resource-hogging connections when suffering high load.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
注：クライアントが単一のリモートホストと確立できるWebSocket接続の数に制限はありません。サーバーは、過剰な数の既存の接続があるホスト/ IPアドレスからの接続の受け入れを拒否したり、高負荷の場合にリソースを消費する接続を切断したりできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. _Proxy Usage_: If the client is configured to use a proxy when using the WebSocket Protocol to connect to host /host/ and port /port/, then the client SHOULD connect to that proxy and ask it to open a TCP connection to the host given by /host/ and the port given by /port/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. _Proxy Usage_：クライアントがWebSocketプロトコルを使用してホスト/ host /およびポート/ port /に接続するときにプロキシを使用するように構成されている場合、クライアントはそのプロキシに接続して、指定されたホストへのTCP接続を開くように要求する必要があります（SHOULD） / host /および/ port /で指定されたポート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXAMPLE: For example, if the client uses an HTTP proxy for all traffic, then if it was to try to connect to port 80 on server example.com, it might send the following lines to the proxy server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
例：たとえば、クライアントがすべてのトラフィックにHTTPプロキシを使用している場合、サーバーexample.comのポート80に接続しようとすると、次の行がプロキシサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
CONNECT example.com:80 HTTP/1.1 Host: example.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
CONNECT example.com:80 HTTP / 1.1ホスト：example.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If there was a password, the connection might look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
パスワードがあった場合、接続は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              CONNECT example.com:80 HTTP/1.1
              Host: example.com
              Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If the client is not configured to use a proxy, then a direct TCP connection SHOULD be opened to the host given by /host/ and the port given by /port/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
クライアントがプロキシを使用するように構成されていない場合、/ host /で指定されたホストと/ port /で指定されたポートへの直接TCP接続を開く必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
NOTE: Implementations that do not expose explicit UI for selecting a proxy for WebSocket connections separate from other proxies are encouraged to use a SOCKS5 [RFC1928] proxy for WebSocket connections, if available, or failing that, to prefer the proxy configured for HTTPS connections over the proxy configured for HTTP connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
注：他のプロキシとは別のWebSocket接続のプロキシを選択するための明示的なUIを公開していない実装では、WebSocket接続にSOCKS5 [RFC1928]プロキシを使用することをお勧めします。 HTTP接続用に構成されたプロキシ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
For the purpose of proxy autoconfiguration scripts, the URI to pass the function MUST be constructed from /host/, /port/, /resource name/, and the /secure/ flag using the definition of a WebSocket URI as given in Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
プロキシ自動設定スクリプトの目的のために、関数を渡すためのURIは、セクション3で指定されているWebSocket URIの定義を使用して、/ host /、/ port /、/ resource name /、および/ secure /フラグから構築する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
NOTE: The WebSocket Protocol can be identified in proxy autoconfiguration scripts from the scheme (&#34;ws&#34; for unencrypted connections and &#34;wss&#34; for encrypted connections).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
注：WebSocketプロトコルは、スキームのプロキシ自動構成スクリプトで識別できます（非暗号化接続の場合は「ws」、暗号化接続の場合は「wss」）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the connection could not be opened, either because a direct connection failed or because any proxy used returned an error, then the client MUST _Fail the WebSocket Connection_ and abort the connection attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 直接接続が失敗したため、または使用されたプロキシがエラーを返したために接続を開くことができなかった場合、クライアントは_WebSocket接続に失敗_し、接続試行を中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If /secure/ is true, the client MUST perform a TLS handshake over the connection after opening the connection and before sending the handshake data [RFC2818]. If this fails (e.g., the server&#39;s certificate could not be verified), then the client MUST _Fail the WebSocket Connection_ and abort the connection. Otherwise, all further communication on this channel MUST run through the encrypted tunnel [RFC5246].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. / secure /がtrueの場合、クライアントは、接続を開いた後、ハンドシェイクデータ[RFC2818]を送信する前に、接続を介してTLSハンドシェイクを実行する必要があります。これが失敗した場合（たとえば、サーバーの証明書を検証できなかった場合）、クライアントは_WebSocket接続に失敗_し、接続を中止する必要があります。それ以外の場合、このチャネルでの以降のすべての通信は、暗号化されたトンネル[RFC5246]を介して実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Clients MUST use the Server Name Indication extension in the TLS handshake [RFC6066].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
クライアントは、TLSハンドシェイク[RFC6066]でサーバー名表示拡張機能を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a connection to the server has been established (including a connection via a proxy or over a TLS-encrypted tunnel), the client MUST send an opening handshake to the server. The handshake consists of an HTTP Upgrade request, along with a list of required and optional header fields. The requirements for this handshake are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーへの接続が確立されると（プロキシ経由またはTLS暗号化トンネル経由の接続を含む）、クライアントはサーバーにオープニングハンドシェイクを送信する必要があります。ハンドシェイクは、必須およびオプションのヘッダーフィールドのリストとともに、HTTPアップグレードリクエストで構成されます。このハンドシェイクの要件は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The handshake MUST be a valid HTTP request as specified by [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. [RFC2616]で指定されているように、ハンドシェイクは有効なHTTPリクエストである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The method of the request MUST be GET, and the HTTP version MUST be at least 1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. リクエストのメソッドはGETでなければならず、HTTPバージョンは少なくとも1.1でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
For example, if the WebSocket URI is &#34;ws://example.com/chat&#34;, the first line sent should be &#34;GET /chat HTTP/1.1&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
たとえば、WebSocket URIが「ws：//example.com/chat」の場合、送信される最初の行は「GET / chat HTTP / 1.1」である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The &#34;Request-URI&#34; part of the request MUST match the /resource name/ defined in Section 3 (a relative URI) or be an absolute http/https URI that, when parsed, has a /resource name/, /host/, and /port/ that match the corresponding ws/wss URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. リクエストの「Request-URI」部分は、セクション3で定義された/ resource name /（相対URI）と一致するか、解析時に/ resource name /、/ host /、および/ port /は、対応するws / wss URIに一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The request MUST contain a |Host| header field whose value contains /host/ plus optionally &#34;:&#34; followed by /port/ (when not using the default port).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. リクエストには| Host |を含める必要があります値が/ host /とオプションで &#34;：&#34;の後に続く/ port /を含むヘッダーフィールド（デフォルトのポートを使用しない場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The request MUST contain an |Upgrade| header field whose value MUST include the &#34;websocket&#34; keyword.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. リクエストには|アップグレード|が含まれている必要があります値が「websocket」キーワードを含まなければならないヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. The request MUST contain a |Connection| header field whose value MUST include the &#34;Upgrade&#34; token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. リクエストには|接続|が含まれている必要がありますその値が「アップグレード」トークンを含まなければならないヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The request MUST include a header field with the name |Sec-WebSocket-Key|. The value of this header field MUST be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded (see Section 4 of [RFC4648]). The nonce MUST be selected randomly for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. リクエストには、| Sec-WebSocket-Key |という名前のヘッダーフィールドを含める必要があります。このヘッダーフィールドの値は、base64でエンコードされたランダムに選択された16バイトの値で構成されるナンスでなければなりません（[RFC4648]のセクション4を参照）。 nonceは、接続ごとにランダムに選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
NOTE: As an example, if the randomly selected value was the sequence of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, the value of the header field would be &#34;AQIDBAUGBwgJCgsMDQ4PEC==&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
注：例として、ランダムに選択された値がバイトのシーケンス0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10である場合、ヘッダーフィールドの値は「AQIDBAUGBwgJCgsMDQ4PE =
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. The request MUST include a header field with the name |Origin| [RFC6454] if the request is coming from a browser client. If the connection is from a non-browser client, the request MAY include this header field if the semantics of that client match the use-case described here for browser clients. The value of this header field is the ASCII serialization of origin of the context in which the code establishing the connection is running. See [RFC6454] for the details of how this header field value is constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. リクエストには、| Origin |という名前のヘッダーフィールドを含める必要があります。 [RFC6454]リクエストがブラウザクライアントからのものである場合。接続が非ブラウザークライアントからのものである場合、そのクライアントのセマンティクスが、ここで説明するブラウザークライアントのユースケースと一致すれば、リクエストにこのヘッダーフィールドが含まれる場合があります。このヘッダーフィールドの値は、接続を確立するコードが実行されているコンテキストの起点のASCIIシリアル化です。このヘッダーフィールド値の構成方法の詳細については、[RFC6454]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
As an example, if code downloaded from www.example.com attempts to establish a connection to ww2.example.com, the value of the header field would be &#34;http://www.example.com&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
例として、www.example.comからダウンロードされたコードがww2.example.comへの接続を確立しようとした場合、ヘッダーフィールドの値は「http://www.example.com」になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. The request MUST include a header field with the name |Sec-WebSocket-Version|. The value of this header field MUST be 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. リクエストには、| Sec-WebSocket-Version |という名前のヘッダーフィールドを含める必要があります。このヘッダーフィールドの値は13でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
NOTE: Although draft versions of this document (-09, -10, -11, and -12) were posted (they were mostly comprised of editorial changes and clarifications and not changes to the wire protocol), values 9, 10, 11, and 12 were not used as valid values for Sec-WebSocket-Version. These values were reserved in the IANA registry but were not and will not be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
注：このドキュメントのドラフトバージョン（-09、-10、-11、および-12）が投稿されました（それらは主に編集上の変更と説明で構成され、ワイヤープロトコルへの変更ではありませんでした）、値9、10、11および12は、Sec-WebSocket-Versionの有効な値として使用されていません。これらの値はIANAレジストリで予約されていましたが、使用されておらず、今後も使用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. The request MAY include a header field with the name |Sec-WebSocket-Protocol|. If present, this value indicates one or more comma-separated subprotocol the client wishes to speak, ordered by preference. The elements that comprise this value MUST be non-empty strings with characters in the range U+0021 to U+007E not including separator characters as defined in [RFC2616] and MUST all be unique strings. The ABNF for the value of this header field is 1#token, where the definitions of constructs and rules are as given in [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. リクエストには、| Sec-WebSocket-Protocol |という名前のヘッダーフィールドを含めることができます。存在する場合、この値は、クライアントが発話したい1つ以上のコンマ区切りのサブプロトコルを優先順に示します。この値を構成する要素は、[RFC2616]で定義されている区切り文字を含まないU + 0021からU + 007Eの範囲の文字を含む空でない文字列である必要があり、すべて一意の文字列である必要があります。このヘッダーフィールドの値のABNFは1＃tokenです。ここで、構成とルールの定義は[RFC2616]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. The request MAY include a header field with the name |Sec-WebSocket-Extensions|. If present, this value indicates the protocol-level extension(s) the client wishes to speak. The interpretation and format of this header field is described in Section 9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. リクエストには、| Sec-WebSocket-Extensions |という名前のヘッダーフィールドを含めることができます。存在する場合、この値は、クライアントが話したいプロトコルレベルの拡張機能を示します。このヘッダーフィールドの解釈と形式については、セクション9.1で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. The request MAY include any other header fields, for example, cookies [RFC6265] and/or authentication-related header fields such as the |Authorization| header field [RFC2616], which are processed according to documents that define them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. リクエストには、Cookie [RFC6265]や| Authorization |などの認証関連ヘッダーフィールドなど、他のヘッダーフィールドを含めることができます（MAY）。ヘッダーフィールド[RFC2616]。ヘッダーフィールドを定義するドキュメントに従って処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client&#39;s opening handshake has been sent, the client MUST wait for a response from the server before sending any further data. The client MUST validate the server&#39;s response as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのオープニングハンドシェイクが送信されると、クライアントはサーバーからの応答を待ってから、データを送信する必要があります。クライアントは、次のようにサーバーの応答を検証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the status code received from the server is not 101, the client handles the response per HTTP [RFC2616] procedures. In particular, the client might perform authentication if it receives a 401 status code; the server might redirect the client using a 3xx status code (but clients are not required to follow them), etc. Otherwise, proceed as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. サーバーから受信したステータスコードが101でない場合、クライアントはHTTP [RFC2616]手順に従って応答を処理します。特に、クライアントは、401ステータスコードを受信すると認証を実行する可能性があります。サーバーは、3xxステータスコードを使用してクライアントをリダイレクトする場合があります（ただし、クライアントはそれらに従う必要はありません）。それ以外の場合は、次の手順を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the response lacks an |Upgrade| header field or the |Upgrade| header field contains a value that is not an ASCII case-insensitive match for the value &#34;websocket&#34;, the client MUST _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 応答に|アップグレード|がない場合ヘッダーフィールドまたは|アップグレード|ヘッダーフィールドに値「websocket」のASCIIの大文字と小文字を区別しない一致ではない値が含まれています。クライアントは_WebSocket接続に失敗する必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the response lacks a |Connection| header field or the |Connection| header field doesn&#39;t contain a token that is an ASCII case-insensitive match for the value &#34;Upgrade&#34;, the client MUST _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 応答に|接続|がない場合ヘッダーフィールドまたは|接続|ヘッダーフィールドには、値「Upgrade」のASCIIの大文字と小文字を区別しない一致であるトークンが含まれていません。クライアントは_WebSocket接続に失敗する必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the response lacks a |Sec-WebSocket-Accept| header field or the |Sec-WebSocket-Accept| contains a value other than the base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-Key| (as a string, not base64-decoded) with the string &#34;258EAFA5- E914-47DA-95CA-C5AB0DC85B11&#34; but ignoring any leading and trailing whitespace, the client MUST _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 応答に| Sec-WebSocket-Accept |がない場合ヘッダーフィールドまたは| Sec-WebSocket-Accept | | Sec-WebSocket-Key |の連結のbase64エンコードSHA-1以外の値が含まれています（base64デコードではなく文字列として）文字列「258EAFA5- E914-47DA-95CA-C5AB0DC85B11」を使用しますが、先頭と末尾の空白を無視して、クライアントは_WebSocket接続に失敗する必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the response includes a |Sec-WebSocket-Extensions| header field and this header field indicates the use of an extension that was not present in the client&#39;s handshake (the server has indicated an extension not requested by the client), the client MUST _Fail the WebSocket Connection_. (The parsing of this header field to determine which extensions are requested is discussed in Section 9.1.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 応答に| Sec-WebSocket-Extensions |が含まれている場合ヘッダーフィールドとこのヘッダーフィールドは、クライアントのハンドシェイクに存在しない拡張機能の使用を示します（サーバーはクライアントから要求されていない拡張機能を示しました）、クライアントは_WebSocket接続に失敗する必要があります_。 （要求された拡張を判別するためのこのヘッダーフィールドの解析については、セクション9.1で説明します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If the response includes a |Sec-WebSocket-Protocol| header field and this header field indicates the use of a subprotocol that was not present in the client&#39;s handshake (the server has indicated a subprotocol not requested by the client), the client MUST _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 応答に| Sec-WebSocket-Protocol |が含まれている場合ヘッダーフィールドとこのヘッダーフィールドは、クライアントのハンドシェイクに存在しないサブプロトコルの使用を示します（サーバーはクライアントから要求されていないサブプロトコルを示しました）、クライアントは_WebSocket接続に失敗する必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server&#39;s response does not conform to the requirements for the server&#39;s handshake as defined in this section and in Section 4.2.2, the client MUST _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの応答が、このセクションとセクション4.2.2で定義されているサーバーのハンドシェイクの要件に準拠していない場合、クライアントは_WebSocket接続に失敗する必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Please note that according to [RFC2616], all header field names in both HTTP requests and HTTP responses are case-insensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2616]によると、HTTPリクエストとHTTPレスポンスの両方のヘッダーフィールド名はすべて大文字と小文字が区別されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server&#39;s response is validated as provided for above, it is said that _The WebSocket Connection is Established_ and that the WebSocket Connection is in the OPEN state. The _Extensions In Use_ is defined to be a (possibly empty) string, the value of which is equal to the value of the |Sec-WebSocket-Extensions| header field supplied by the server&#39;s handshake or the null value if that header field was not present in the server&#39;s handshake. The _Subprotocol In Use_ is defined to be the value of the |Sec-WebSocket-Protocol| header field in the server&#39;s handshake or the null value if that header field was not present in the server&#39;s handshake. Additionally, if any header fields in the server&#39;s handshake indicate that cookies should be set (as defined by [RFC6265]), these cookies are referred to as _Cookies Set During the Server&#39;s Opening Handshake_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のようにサーバーの応答が検証されると、_WebSocket接続が確立された_、WebSocket接続がOPEN状態であると見なされます。 _Extensions In Use_は（おそらく空の）文字列として定義され、その値は| Sec-WebSocket-Extensions |の値と同じです。サーバーのハンドシェイクによって提供されるヘッダーフィールド、またはそのヘッダーフィールドがサーバーのハンドシェイクに存在しない場合はnull値。 _Subprotocol In Use_は、| Sec-WebSocket-Protocol |の値として定義されています。サーバーのハンドシェイクのヘッダーフィールド、またはそのヘッダーフィールドがサーバーのハンドシェイクに存在しない場合はnull値。さらに、サーバーのハンドシェイクのヘッダーフィールドがCookieを設定する必要があることを示している場合（[RFC6265]で定義）、これらのCookieは_Cookieがサーバーのオープニングハンドシェイク中に設定されると呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Server-Side Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. サーバー側の要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers MAY offload the management of the connection to other agents on the network, for example, load balancers and reverse proxies. In such a situation, the server for the purposes of this specification is considered to include all parts of the server-side infrastructure from the first device to terminate the TCP connection all the way to the server that processes requests and sends responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ロードバランサーやリバースプロキシなど、ネットワーク上の他のエージェントへの接続管理の負荷を軽減できます（MAY）。このような状況では、この仕様のサーバーは、最初のデバイスからサーバー側インフラストラクチャのすべての部分を含み、要求を処理して応答を送信するサーバーへのTCP接続を完全に終了すると見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXAMPLE: A data center might have a server that responds to WebSocket requests with an appropriate handshake and then passes the connection to another server to actually process the data frames. For the purposes of this specification, the &#34;server&#34; is the combination of both computers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例：データセンターには、適切なハンドシェイクでWebSocket要求に応答し、接続を別のサーバーに渡して実際にデータフレームを処理するサーバーがある場合があります。この仕様では、「サーバー」は両方のコンピューターの組み合わせです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Reading the Client&#39;s Opening Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. クライアントのオープニングハンドシェイクを読み取る
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client starts a WebSocket connection, it sends its part of the opening handshake. The server must parse at least part of this handshake in order to obtain the necessary information to generate the server part of the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがWebSocket接続を開始すると、開始ハンドシェイクの一部を送信します。サーバーは、ハンドシェイクのサーバー部分を生成するために必要な情報を取得するために、このハンドシェイクの少なくとも一部を解析する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client&#39;s opening handshake consists of the following parts. If the server, while reading the handshake, finds that the client did not send a handshake that matches the description below (note that as per [RFC2616], the order of the header fields is not important), including but not limited to any violations of the ABNF grammar specified for the components of the handshake, the server MUST stop processing the client&#39;s handshake and return an HTTP response with an appropriate error code (such as 400 Bad Request).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのオープニングハンドシェイクは、次の部分で構成されています。サーバーがハンドシェイクの読み取り中に、クライアントが以下の説明に一致するハンドシェイクを送信しなかったことが判明した場合（[RFC2616]によると、ヘッダーフィールドの順序は重要ではありません）。違反も含まれますが、これらに限定されません。ハンドシェイクのコンポーネントに指定されたABNF文法の場合、サーバーはクライアントのハンドシェイクの処理を停止し、適切なエラーコード（400 Bad Requestなど）を含むHTTP応答を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. An HTTP/1.1 or higher GET request, including a &#34;Request-URI&#34; [RFC2616] that should be interpreted as a /resource name/ defined in Section 3 (or an absolute HTTP/HTTPS URI containing the /resource name/).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. セクション3で定義された/ resource name /（または/ resource name /を含む絶対HTTP / HTTPS URI）として解釈される「Request-URI」[RFC2616]を含むHTTP / 1.1以降のGETリクエスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A |Host| header field containing the server&#39;s authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. |ホスト|サーバーの権限を含むヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. An |Upgrade| header field containing the value &#34;websocket&#34;, treated as an ASCII case-insensitive value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. |アップグレード|値「websocket」を含むヘッダーフィールド。ASCIIの大文字と小文字を区別しない値として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. A |Connection| header field that includes the token &#34;Upgrade&#34;, treated as an ASCII case-insensitive value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. A |接続|トークン「Upgrade」を含むヘッダーフィールド。ASCIIの大文字と小文字を区別しない値として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. A |Sec-WebSocket-Key| header field with a base64-encoded (see Section 4 of [RFC4648]) value that, when decoded, is 16 bytes in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. | Sec-WebSocket-Key | base64でエンコードされた（[RFC4648]のセクション4を参照）値を持つヘッダーフィールド。デコードされると、長さが16バイトになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. A |Sec-WebSocket-Version| header field, with a value of 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. | Sec-WebSocket-Version |ヘッダーフィールド、値は13。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Optionally, an |Origin| header field. This header field is sent by all browser clients. A connection attempt lacking this header field SHOULD NOT be interpreted as coming from a browser client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. オプションで、| Origin |ヘッダーフィールド。このヘッダーフィールドは、すべてのブラウザクライアントから送信されます。このヘッダーフィールドがない接続試行は、ブラウザクライアントからの接続として解釈されるべきではありません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Optionally, a |Sec-WebSocket-Protocol| header field, with a list of values indicating which protocols the client would like to speak, ordered by preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. オプションで、| Sec-WebSocket-Protocol |ヘッダーフィールド。クライアントが話したいプロトコルを示す値のリストがあり、優先順に並べられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Optionally, a |Sec-WebSocket-Extensions| header field, with a list of values indicating which extensions the client would like to speak. The interpretation of this header field is discussed in Section 9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. オプションで、| Sec-WebSocket-Extensions |ヘッダーフィールドと、クライアントが話したい拡張機能を示す値のリスト。このヘッダーフィールドの解釈については、セクション9.1で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Optionally, other header fields, such as those used to send cookies or request authentication to a server. Unknown header fields are ignored, as per [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. 必要に応じて、Cookieの送信やサーバーへの認証の要求に使用されるフィールドなど、他のヘッダーフィールド。 [RFC2616]に従い、不明なヘッダーフィールドは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Sending the Server&#39;s Opening Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. サーバーのオープニングハンドシェイクの送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client establishes a WebSocket connection to a server, the server MUST complete the following steps to accept the connection and send the server&#39;s opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバーへのWebSocket接続を確立すると、サーバーは次の手順を完了して接続を受け入れ、サーバーの開始ハンドシェイクを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the connection is happening on an HTTPS (HTTP-over-TLS) port, perform a TLS handshake over the connection. If this fails (e.g., the client indicated a host name in the extended client hello &#34;server_name&#34; extension that the server does not host), then close the connection; otherwise, all further communication for the connection (including the server&#39;s handshake) MUST run through the encrypted tunnel [RFC5246].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 接続がHTTPS（HTTP-over-TLS）ポートで行われている場合は、接続でTLSハンドシェイクを実行します。これが失敗した場合（たとえば、サーバーがホストしていない拡張クライアントhello &#34;server_name&#34;拡張でクライアントがホスト名を示した場合）、接続を閉じます。それ以外の場合、接続（サーバーのハンドシェイクを含む）のためのそれ以降のすべての通信は、暗号化されたトンネル[RFC5246]を介して実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The server can perform additional client authentication, for example, by returning a 401 status code with the corresponding |WWW-Authenticate| header field as described in [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. サーバーは、たとえば対応する| WWW-Authenticate |とともに401ステータスコードを返すことにより、追加のクライアント認証を実行できます。 [RFC2616]で説明されているヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The server MAY redirect the client using a 3xx status code [RFC2616]. Note that this step can happen together with, before, or after the optional authentication step described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. サーバーは、3xxステータスコード[RFC2616]を使用してクライアントをリダイレクトしてもよい（MAY）。このステップは、上記のオプションの認証ステップと同時、その前、または後に実行できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Establish the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 次の情報を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/origin/ The |Origin| header field in the client&#39;s handshake indicates the origin of the script establishing the connection. The origin is serialized to ASCII and converted to lowercase. The server MAY use this information as part of a determination of whether to accept the incoming connection. If the server does not validate the origin, it will accept connections from anywhere. If the server does not wish to accept this connection, it MUST return an appropriate HTTP error code (e.g., 403 Forbidden) and abort the WebSocket handshake described in this section. For more detail, refer to Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/ origin / The | Origin |クライアントのハンドシェイクのヘッダーフィールドは、接続を確立するスクリプトの発信元を示します。オリジンはASCIIにシリアル化され、小文字に変換されます。サーバーは、着信接続を受け入れるかどうかの決定の一部としてこの情報を使用する場合があります。サーバーがオリジンを検証しない場合、サーバーはどこからの接続も受け入れます。サーバーがこの接続を受け入れたくない場合は、適切なHTTPエラーコード（403 Forbiddenなど）を返し、このセクションで説明するWebSocketハンドシェイクを中止する必要があります。詳細については、セクション10を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/key/ The |Sec-WebSocket-Key| header field in the client&#39;s handshake includes a base64-encoded value that, if decoded, is 16 bytes in length. This (encoded) value is used in the creation of the server&#39;s handshake to indicate an acceptance of the connection. It is not necessary for the server to base64- decode the |Sec-WebSocket-Key| value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/ key / | Sec-WebSocket-Key |クライアントのハンドシェイクのヘッダーフィールドには、base64でエンコードされた値が含まれます。デコードされた場合、長さは16バイトです。この（エンコードされた）値は、サーバーのハンドシェイクの作成で使用され、接続の受け入れを示します。サーバーがbase64-| Sec-WebSocket-Key |をデコードする必要はありません値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/version/ The |Sec-WebSocket-Version| header field in the client&#39;s handshake includes the version of the WebSocket Protocol with which the client is attempting to communicate. If this version does not match a version understood by the server, the server MUST abort the WebSocket handshake described in this section and instead send an appropriate HTTP error code (such as 426 Upgrade Required) and a |Sec-WebSocket-Version| header field indicating the version(s) the server is capable of understanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/ version / | Sec-WebSocket-Version |クライアントのハンドシェイクのヘッダーフィールドには、クライアントが通信しようとしているWebSocketプロトコルのバージョンが含まれています。このバージョンがサーバーが理解するバージョンと一致しない場合、サーバーはこのセクションで説明するWebSocketハンドシェイクを中止し、代わりに適切なHTTPエラーコード（426アップグレードが必要など）と| Sec-WebSocket-Version |を送信する必要があります。サーバーが理解できるバージョンを示すヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/resource name/ An identifier for the service provided by the server. If the server provides multiple services, then the value should be derived from the resource name given in the client&#39;s handshake in the &#34;Request-URI&#34; [RFC2616] of the GET method. If the requested service is not available, the server MUST send an appropriate HTTP error code (such as 404 Not Found) and abort the WebSocket handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/ resource name /サーバーが提供するサービスの識別子。サーバーが複数のサービスを提供する場合、値は、GETメソッドの「Request-URI」[RFC2616]のクライアントのハンドシェイクで指定されたリソース名から派生する必要があります。要求されたサービスが利用できない場合、サーバーは適切なHTTPエラーコード（404 Not Foundなど）を送信し、WebSocketハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/subprotocol/ Either a single value representing the subprotocol the server is ready to use or null. The value chosen MUST be derived from the client&#39;s handshake, specifically by selecting one of the values from the |Sec-WebSocket-Protocol| field that the server is willing to use for this connection (if any). If the client&#39;s handshake did not contain such a header field or if the server does not agree to any of the client&#39;s requested subprotocols, the only acceptable value is null. The absence of such a field is equivalent to the null value (meaning that if the server does not wish to agree to one of the suggested subprotocols, it MUST NOT send back a |Sec-WebSocket-Protocol| header field in its response). The empty string is not the same as the null value for these purposes and is not a legal value for this field. The ABNF for the value of this header field is (token), where the definitions of constructs and rules are as given in [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
/ subprotocol /サーバーが使用できるサブプロトコルを表す単一の値、またはnullのいずれか。選択された値は、特に| Sec-WebSocket-Protocol |から値の1つを選択することにより、クライアントのハンドシェイクから派生しなければなりません（MUST）。サーバーがこの接続に使用する用意があるフィールド（存在する場合）。クライアントのハンドシェイクにそのようなヘッダーフィールドが含まれていない場合、またはサーバーがクライアントの要求されたサブプロトコルのいずれにも同意しない場合、許容される値はnullのみです。そのようなフィールドがないことはnull値に相当します（つまり、サーバーが提案されたサブプロトコルの1つに同意したくない場合は、その応答で| Sec-WebSocket-Protocol |ヘッダーフィールドを返してはなりません）。空の文字列は、これらの目的ではnull値と同じではなく、このフィールドでは有効な値ではありません。このヘッダーフィールドの値のABNFは（トークン）であり、構成とルールの定義は[RFC2616]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 /extensions/ A (possibly empty) list representing the protocol-level extensions the server is ready to use. If the server supports multiple extensions, then the value MUST be derived from the client&#39;s handshake, specifically by selecting one or more of the values from the |Sec-WebSocket-Extensions| field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes. Extensions not listed by the client MUST NOT be listed. The method by which these values should be selected and interpreted is discussed in Section 9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
/ extensions /サーバーが使用できるプロトコルレベルの拡張機能を表す（場合によっては空の）リスト。サーバーが複数の拡張機能をサポートしている場合、値はクライアントのハンドシェイクから、具体的には| Sec-WebSocket-Extensions |から1つ以上の値を選択することによって派生する必要があります。フィールド。そのようなフィールドがないことは、null値と同等です。空の文字列は、これらの目的のためのnull値と同じではありません。クライアントによってリストされていない拡張機能はリストしてはいけません。これらの値を選択して解釈する方法については、セクション9.1で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the server chooses to accept the incoming connection, it MUST reply with a valid HTTP response indicating the following.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. サーバーが着信接続を受け入れることを選択した場合は、以下を示す有効なHTTP応答で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. A Status-Line with a 101 response code as per RFC 2616 [RFC2616]. Such a response could look like &#34;HTTP/1.1 101 Switching Protocols&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. RFC 2616 [RFC2616]に基づく101応答コードを含むStatus-Line。このような応答は、「HTTP / 1.1 101スイッチングプロトコル」のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. An |Upgrade| header field with value &#34;websocket&#34; as per RFC 2616 [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. |アップグレード| RFC 2616 [RFC2616]に基づく「websocket」という値を持つヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. A |Connection| header field with value &#34;Upgrade&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. A |接続|値が「Upgrade」のヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
4. A |Sec-WebSocket-Accept| header field. The value of this header field is constructed by concatenating /key/, defined above in step 4 in Section 4.2.2, with the string &#34;258EAFA5- E914-47DA-95CA-C5AB0DC85B11&#34;, taking the SHA-1 hash of this concatenated value to obtain a 20-byte value and base64- encoding (see Section 4 of [RFC4648]) this 20-byte hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
4. A | Sec-WebSocket-Accept |ヘッダーフィールド。このヘッダーフィールドの値は、セクション4.2.2のステップ4で定義された/ key /を文字列 &#34;258EAFA5- E914-47DA-95CA-C5AB0DC85B11&#34;と連結し、この連結された値のSHA-1ハッシュをとることによって構築されます。 20バイトの値とbase64エンコーディング（[RFC4648]のセクション4を参照）を取得するには、この20バイトのハッシュを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
The ABNF [RFC2616] of this header field is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
このヘッダーフィールドのABNF [RFC2616]は、次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           Sec-WebSocket-Accept     = base64-value-non-empty
           base64-value-non-empty = (1*base64-data [ base64-padding ]) |
                                    base64-padding
           base64-data      = 4base64-character
           base64-padding   = (2base64-character &#34;==&#34;) |
                              (3base64-character &#34;=&#34;)
           base64-character = ALPHA | DIGIT | &#34;+&#34; | &#34;/&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE: As an example, if the value of the |Sec-WebSocket-Key| header field in the client&#39;s handshake were &#34;dGhlIHNhbXBsZSBub25jZQ==&#34;, the server would append the string &#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34; to form the string &#34;dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34;. The server would then take the SHA-1 hash of this string, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded, to give the value &#34;s3pPLMBiTxaQ9kYGzzhZRbK+xOo=&#34;, which would be returned in the |Sec-WebSocket-Accept| header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：例として、| Sec-WebSocket-Key |の値がクライアントのハンドシェイクのヘッダーフィールドは &#34;dGhlIHNhbXBsZSBub25jZQ ==&#34;だった場合、サーバーは文字列 &#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34;を追加して文字列 &#34;dGhlIHNhbXBsZSBub25jZQ == 258EAFA5-E914-47DA.47AB95C47A95C-47AB95C11A47-95AB11サーバーはこの文字列のSHA-1ハッシュを取得し、値0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xeaを提供します。次に、この値はbase64でエンコードされ、値 &#34;s3pPLMBiTxaQ9kYGzzhZRbK + xOo =&#34;を提供します。これは、| Sec-WebSocket-Accept |で返されます。ヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
5. Optionally, a |Sec-WebSocket-Protocol| header field, with a value /subprotocol/ as defined in step 4 in Section 4.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
5. オプションで、| Sec-WebSocket-Protocol |セクション4.2.2のステップ4で定義された値/ subprotocol /を持つヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
6. Optionally, a |Sec-WebSocket-Extensions| header field, with a value /extensions/ as defined in step 4 in Section 4.2.2. If multiple extensions are to be used, they can all be listed in a single |Sec-WebSocket-Extensions| header field or split between multiple instances of the |Sec-WebSocket-Extensions| header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
6. オプションで、| Sec-WebSocket-Extensions |セクション4.2.2のステップ4で定義された/ extensions /の値を持つヘッダーフィールド。複数の拡張機能を使用する場合、それらすべてを単一の| Sec-WebSocket-Extensions |にリストできます。ヘッダーフィールドまたは| Sec-WebSocket-Extensions |の複数のインスタンス間で分割ヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This completes the server&#39;s handshake. If the server finishes these steps without aborting the WebSocket handshake, the server considers the WebSocket connection to be established and that the WebSocket connection is in the OPEN state. At this point, the server may begin sending (and receiving) data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これでサーバーのハンドシェイクが完了しました。サーバーがWebSocketハンドシェイクを中止せずにこれらの手順を完了すると、サーバーはWebSocket接続が確立されていると見なし、WebSocket接続がOPEN状態にあると見なします。この時点で、サーバーはデータの送信（および受信）を開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Collected ABNF for New Header Fields Used in Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. ハンドシェイクで使用される新しいヘッダーフィールドのABNFを収集
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is using ABNF syntax/rules from Section 2.1 of [RFC2616], including the &#34;implied *LWS rule&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[暗黙の* LWSルール]を含め、[RFC2616]のセクション2.1のABNF構文/ルールを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the following ABNF conventions are used in this section. Some names of the rules correspond to names of the corresponding header fields. Such rules express values of the corresponding header fields, for example, the Sec-WebSocket-Key ABNF rule describes syntax of the |Sec-WebSocket-Key| header field value. ABNF rules with the &#34;-Client&#34; suffix in the name are only used in requests sent by the client to the server; ABNF rules with the &#34;-Server&#34; suffix in the name are only used in responses sent by the server to the client. For example, the ABNF rule Sec-WebSocket-Protocol-Client describes syntax of the |Sec-WebSocket-Protocol| header field value sent by the client to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、次のABNF規則が使用されていることに注意してください。ルールの一部の名前は、対応するヘッダーフィールドの名前に対応しています。このようなルールは、対応するヘッダーフィールドの値を表します。たとえば、Sec-WebSocket-Key ABNFルールは、| Sec-WebSocket-Key |の構文を記述します。ヘッダーフィールドの値。名前に「-Client」というサフィックスが付いたABNFルールは、クライアントからサーバーに送信されるリクエストでのみ使用されます。名前に「-Server」という接尾辞が付いたABNFルールは、サーバーからクライアントに送信される応答でのみ使用されます。たとえば、ABNFルールSec-WebSocket-Protocol-Clientは、| Sec-WebSocket-Protocol |の構文を記述します。クライアントからサーバーに送信されるヘッダーフィールド値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following new header fields can be sent during the handshake from the client to the server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の新しいヘッダーフィールドは、ハンドシェイク中にクライアントからサーバーに送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Sec-WebSocket-Key = base64-value-non-empty Sec-WebSocket-Extensions = extension-list Sec-WebSocket-Protocol-Client = 1#token Sec-WebSocket-Version-Client = version
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Sec-WebSocket-Key = base64-value-non-empty Sec-WebSocket-Extensions = extension-list Sec-WebSocket-Protocol-Client = 1＃token Sec-WebSocket-Version-Client = version
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      base64-value-non-empty = (1*base64-data [ base64-padding ]) |
                                base64-padding
      base64-data      = 4base64-character
      base64-padding   = (2base64-character &#34;==&#34;) |
                         (3base64-character &#34;=&#34;)
      base64-character = ALPHA | DIGIT | &#34;+&#34; | &#34;/&#34;
      extension-list = 1#extension
      extension = extension-token *( &#34;;&#34; extension-param )
      extension-token = registered-token
      registered-token = token
      extension-param = token [ &#34;=&#34; (token | quoted-string) ]
           ; When using the quoted-string syntax variant, the value
           ; after quoted-string unescaping MUST conform to the
           ; &#39;token&#39; ABNF.
      NZDIGIT       =  &#34;1&#34; | &#34;2&#34; | &#34;3&#34; | &#34;4&#34; | &#34;5&#34; | &#34;6&#34; |
                       &#34;7&#34; | &#34;8&#34; | &#34;9&#34;
      version = DIGIT | (NZDIGIT DIGIT) |
                (&#34;1&#34; DIGIT DIGIT) | (&#34;2&#34; DIGIT DIGIT)
                ; Limited to 0-255 range, with no leading zeros
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following new header fields can be sent during the handshake from the server to the client:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の新しいヘッダーフィールドは、ハンドシェイク中にサーバーからクライアントに送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Sec-WebSocket-Extensions = extension-list Sec-WebSocket-Accept = base64-value-non-empty Sec-WebSocket-Protocol-Server = token Sec-WebSocket-Version-Server = 1#version
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Sec-WebSocket-Extensions = extension-list Sec-WebSocket-Accept = base64-value-non-empty Sec-WebSocket-Protocol-Server = token Sec-WebSocket-Version-Server = 1＃version
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Supporting Multiple Versions of WebSocket Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. WebSocketプロトコルの複数のバージョンのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides some guidance on supporting multiple versions of the WebSocket Protocol in clients and servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、クライアントとサーバーでWebSocketプロトコルの複数のバージョンをサポートするためのガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Using the WebSocket version advertisement capability (the
   |Sec-WebSocket-Version| header field), a client can initially request
   the version of the WebSocket Protocol that it prefers (which doesn&#39;t
   necessarily have to be the latest supported by the client).  If the
   server supports the requested version and the handshake message is
   otherwise valid, the server will accept that version.  If the server
   doesn&#39;t support the requested version, it MUST respond with a
   |Sec-WebSocket-Version| header field (or multiple
   |Sec-WebSocket-Version| header fields) containing all versions it is
   willing to use.  At this point, if the client supports one of the
   advertised versions, it can repeat the WebSocket handshake using a
   new version value.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following example demonstrates version negotiation described above:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例は、上記のバージョンネゴシエーションを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade ... Sec-WebSocket-Version: 25
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
GET / chat HTTP / 1.1ホスト：server.example.comアップグレード：websocket接続：アップグレード... Sec-WebSocket-Version：25
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response from the server might look as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーからの応答は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HTTP/1.1 400 Bad Request ... Sec-WebSocket-Version: 13, 8, 7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HTTP / 1.1 400 Bad Request ... Sec-WebSocket-Version：13、8、7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the last response from the server might also look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーからの最後の応答も次のようになる可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HTTP/1.1 400 Bad Request ... Sec-WebSocket-Version: 13 Sec-WebSocket-Version: 8, 7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HTTP / 1.1 400 Bad Request ... Sec-WebSocket-Version：13 Sec-WebSocket-Version：8、7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client now repeats the handshake that conforms to version 13:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはバージョン13に準拠するハンドシェイクを繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade ... Sec-WebSocket-Version: 13
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
GET / chat HTTP / 1.1ホスト：server.example.comアップグレード：websocket接続：アップグレード... Sec-WebSocket-Version：13
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Data Framing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. データフレーミング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 概観
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the WebSocket Protocol, data is transmitted using a sequence of frames. To avoid confusing network intermediaries (such as intercepting proxies) and for security reasons that are further discussed in Section 10.3, a client MUST mask all frames that it sends to the server (see Section 5.3 for further details). (Note that masking is done whether or not the WebSocket Protocol is running over TLS.) The server MUST close the connection upon receiving a frame that is not masked. In this case, a server MAY send a Close frame with a status code of 1002 (protocol error) as defined in Section 7.4.1. A server MUST NOT mask any frames that it sends to the client. A client MUST close a connection if it detects a masked frame. In this case, it MAY use the status code 1002 (protocol error) as defined in Section 7.4.1. (These rules might be relaxed in a future specification.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketプロトコルでは、データは一連のフレームを使用して送信されます。ネットワークメディエーション（インターセプトプロキシなど）の混乱を避け、セクション10.3でさらに説明するセキュリティ上の理由から、クライアントはサーバーに送信するすべてのフレームをマスクする必要があります（詳細については、セクション5.3を参照）。 （WebSocketプロトコルがTLSで実行されているかどうかにかかわらず、マスキングが行われることに注意してください。）サーバーは、マスキングされていないフレームを受信すると接続を閉じる必要があります。この場合、サーバーは、セクション7.4.1で定義されているように、ステータスコード1002（プロトコルエラー）のCloseフレームを送信できます（MAY）。サーバーは、クライアントに送信するフレームをマスクしてはなりません（MUST NOT）。クライアントは、マスクされたフレームを検出した場合、接続を閉じる必要があります。この場合、セクション7.4.1で定義されているように、ステータスコード1002（プロトコルエラー）を使用できます。 （これらのルールは、将来の仕様で緩和される可能性があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base framing protocol defines a frame type with an opcode, a payload length, and designated locations for &#34;Extension data&#34; and &#34;Application data&#34;, which together define the &#34;Payload data&#34;. Certain bits and opcodes are reserved for future expansion of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本フレーミングプロトコルは、オペコード、ペイロード長、および「ペイロードデータ」を定義する「拡張データ」と「アプリケーションデータ」の指定位置でフレームタイプを定義します。特定のビットとオペコードは、プロトコルの将来の拡張のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A data frame MAY be transmitted by either the client or the server at any time after opening handshake completion and before that endpoint has sent a Close frame (Section 5.5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレームは、ハンドシェイクの開始が完了した後、エンドポイントがクローズフレームを送信する前にいつでもクライアントまたはサーバーのいずれかから送信できます（セクション5.5.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Base Framing Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 基本フレーミングプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This wire format for the data transfer part is described by the ABNF [RFC5234] given in detail in this section. (Note that, unlike in other sections of this document, the ABNF in this section is operating on groups of bits. The length of each group of bits is indicated in a comment. When encoded on the wire, the most significant bit is the leftmost in the ABNF). A high-level overview of the framing is given in the following figure. In a case of conflict between the figure below and the ABNF specified later in this section, the figure is authoritative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ転送部分のこのワイヤ形式は、このセクションで詳細に説明されているABNF [RFC5234]によって記述されています。 （このドキュメントの他のセクションとは異なり、このセクションのABNFはビットのグループで動作していることに注意してください。ビットの各グループの長さはコメントに示されています。ネットワーク上でエンコードされる場合、最上位ビットは左端です。 ABNFで）。フレーミングの概要を次の図に示します。以下の図と、このセクションで後で指定するABNFとの間に矛盾がある場合、図は信頼できるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FIN: 1 bit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FIN：1ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これがメッセージの最後のフラグメントであることを示します。最初のフラグメントは、最後のフラグメントでもかまいません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSV1, RSV2, RSV3: 1 bit each
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSV1、RSV2、RSV3：各1ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
MUST be 0 unless an extension is negotiated that defines meanings for non-zero values. If a nonzero value is received and none of the negotiated extensions defines the meaning of such a nonzero value, the receiving endpoint MUST _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0以外の値の意味を定義する拡張がネゴシエートされない限り、0でなければなりません。ゼロ以外の値が受信され、ネゴシエートされた拡張機能のいずれもそのようなゼロ以外の値の意味を定義していない場合、受信側のエンドポイントは_WebSocket接続に失敗する必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Opcode: 4 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペコード：4ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Defines the interpretation of the &#34;Payload data&#34;. If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_. The following values are defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「ペイロードデータ」の解釈を定義します。不明なオペコードを受信した場合、受信エンドポイントは_WebSocket接続に失敗する必要があります_。以下の値が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* %x0 denotes a continuation frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ％x0は継続フレームを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* %x1 denotes a text frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ％x1はテキストフレームを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* %x2 denotes a binary frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ％x2はバイナリフレームを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* %x3-7 are reserved for further non-control frames
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ％x3-7は、それ以外の非制御フレーム用に予約されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* %x8 denotes a connection close
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ％x8は接続のクローズを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* %x9 denotes a ping
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ％x9はpingを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* %xA denotes a pong
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ％xAはポンを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* %xB-F are reserved for further control frames
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ％xB-Fは、以降の制御フレーム用に予約されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mask: 1 bit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスク：1ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Defines whether the &#34;Payload data&#34; is masked. If set to 1, a masking key is present in masking-key, and this is used to unmask the &#34;Payload data&#34; as per Section 5.3. All frames sent from client to server have this bit set to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「ペイロードデータ」がマスクされるかどうかを定義します。 1に設定すると、マスキングキーがmasking-keyに存在し、これを使用して、セクション5.3の「ペイロードデータ」のマスクを解除します。クライアントからサーバーに送信されるすべてのフレームでは、このビットが1に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Payload length:  7 bits, 7+16 bits, or 7+64 bits
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The length of the &#34;Payload data&#34;, in bytes: if 0-125, that is the payload length. If 126, the following 2 bytes interpreted as a 16-bit unsigned integer are the payload length. If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the most significant bit MUST be 0) are the payload length. Multibyte length quantities are expressed in network byte order. Note that in all cases, the minimal number of bytes MUST be used to encode the length, for example, the length of a 124-byte-long string can&#39;t be encoded as the sequence 126, 0, 124. The payload length is the length of the &#34;Extension data&#34; + the length of the &#34;Application data&#34;. The length of the &#34;Extension data&#34; may be zero, in which case the payload length is the length of the &#34;Application data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「ペイロードデータ」の長さ（バイト）。0〜125の場合、ペイロードの長さです。 126の場合、16ビットの符号なし整数として解釈される次の2バイトはペイロード長です。 127の場合、64ビットの符号なし整数として解釈される次の8バイト（最上位ビットは0でなければならない）は、ペイロードの長さです。マルチバイト長の数量は、ネットワークバイトオーダーで表されます。すべての場合において、最小バイト数を使用して長さをエンコードする必要があることに注意してください。たとえば、124バイト長の文字列の長さは、シーケンス126、0、124としてエンコードできません。ペイロードの長さは「拡張データ」の長さ+「アプリケーションデータ」の長さ。 「拡張データ」の長さはゼロでもかまいません。その場合、ペイロードの長さは「アプリケーションデータ」の長さになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Masking-key: 0 or 4 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスキングキー：0または4バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
All frames sent from the client to the server are masked by a 32-bit value that is contained within the frame. This field is present if the mask bit is set to 1 and is absent if the mask bit is set to 0. See Section 5.3 for further information on client-to-server masking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントからサーバーに送信されるすべてのフレームは、フレーム内に含まれる32ビット値によってマスクされます。このフィールドは、マスクビットが1に設定されている場合に存在し、マスクビットが0に設定されている場合は存在しません。クライアントからサーバーへのマスキングの詳細については、セクション5.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Payload data: (x+y) bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ペイロードデータ：（x + y）バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The &#34;Payload data&#34; is defined as &#34;Extension data&#34; concatenated with &#34;Application data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「ペイロードデータ」は、「拡張データ」と「アプリケーションデータ」を連結したものとして定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extension data: x bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張データ：xバイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The &#34;Extension data&#34; is 0 bytes unless an extension has been negotiated. Any extension MUST specify the length of the &#34;Extension data&#34;, or how that length may be calculated, and how the extension use MUST be negotiated during the opening handshake. If present, the &#34;Extension data&#34; is included in the total payload length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「拡張データ」は、拡張がネゴシエートされていない限り、0バイトです。拡張機能は、「拡張データ」の長さ、またはその長さの計算方法、および開始ハンドシェイク中に拡張機能の使用をネゴシエートする方法を指定する必要があります。存在する場合、「拡張データ」はペイロードの全長に含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application data: y bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションデータ：yバイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Arbitrary &#34;Application data&#34;, taking up the remainder of the frame after any &#34;Extension data&#34;. The length of the &#34;Application data&#34; is equal to the payload length minus the length of the &#34;Extension data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
任意の「アプリケーションデータ」、「拡張データ」の後のフレームの残りを占める。 「アプリケーションデータ」の長さは、ペイロードの長さから「拡張データ」の長さを引いたものに等しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base framing protocol is formally defined by the following ABNF [RFC5234]. It is important to note that the representation of this data is binary, not ASCII characters. As such, a field with a length of 1 bit that takes values %x0 / %x1 is represented as a single bit whose value is 0 or 1, not a full byte (octet) that stands for the characters &#34;0&#34; or &#34;1&#34; in the ASCII encoding. A field with a length of 4 bits with values between %x0-F again is represented by 4 bits, again NOT by an ASCII character or full byte (octet) with these values. [RFC5234] does not specify a character encoding: &#34;Rules resolve into a string of terminal values, sometimes called characters. In ABNF, a character is merely a non-negative integer. In certain contexts, a specific mapping (encoding) of values into a character set (such as ASCII) will be specified.&#34; Here, the specified encoding is a binary encoding where each terminal value is encoded in the specified number of bits, which varies for each field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本フレーミングプロトコルは、次のABNF [RFC5234]によって正式に定義されています。このデータの表現はASCII文字ではなくバイナリであることに注意することが重要です。したがって、値％x0 /％x1を取る1ビットの長さのフィールドは、値が0または1の単一ビットとして表され、文字「0」または「1」を表す完全なバイト（オクテット）ではありません。 &#34;ASCIIエンコーディング。 ％x0-Fの間の値を持つ4ビットの長さのフィールドも、これらの値を持つASCII文字またはフルバイト（オクテット）ではなく、4ビットで表されます。 [RFC5234]は文字エンコードを指定していません。「ルールは、文字と呼ばれることもある最終値の文字列に解決されます。ABNFでは、文字は単なる非負の整数です。特定のコンテキストでは、値の特定のマッピング（エンコード）が文字セット（ASCIIなど）が指定されます。」ここで、指定されたエンコーディングは、各ターミナル値がフィールドごとに異なる指定されたビット数でエンコードされるバイナリエンコーディングです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ws-frame                = frame-fin           ; 1 bit in length
                              frame-rsv1          ; 1 bit in length
                              frame-rsv2          ; 1 bit in length
                              frame-rsv3          ; 1 bit in length
                              frame-opcode        ; 4 bits in length
                              frame-masked        ; 1 bit in length
                              frame-payload-length   ; either 7, 7+16,
                                                     ; or 7+64 bits in
                                                     ; length
                              [ frame-masking-key ]  ; 32 bits in length
                              frame-payload-data     ; n*8 bits in
                                                     ; length, where
                                                     ; n &gt;= 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-fin               = %x0 ; more frames of this message follow
                            / %x1 ; final frame of this message
                                  ; 1 bit in length
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-rsv1              = %x0 / %x1
                              ; 1 bit in length, MUST be 0 unless
                              ; negotiated otherwise
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-rsv2              = %x0 / %x1
                              ; 1 bit in length, MUST be 0 unless
                              ; negotiated otherwise
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-rsv3              = %x0 / %x1
                              ; 1 bit in length, MUST be 0 unless
                              ; negotiated otherwise
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
frame-opcode = frame-opcode-non-control / frame-opcode-control / frame-opcode-cont
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
frame-opcode = frame-opcode-non-control / frame-opcode-control / frame-opcode-cont
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-opcode-cont       = %x0 ; frame continuation
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-opcode-non-control= %x1 ; text frame
                            / %x2 ; binary frame
                            / %x3-7
                            ; 4 bits in length,
                            ; reserved for further non-control frames
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-opcode-control    = %x8 ; connection close
                            / %x9 ; ping
                            / %xA ; pong
                            / %xB-F ; reserved for further control
                                    ; frames
                                    ; 4 bits in length
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-masked            = %x0
                            ; frame is not masked, no frame-masking-key
                            / %x1
                            ; frame is masked, frame-masking-key present
                            ; 1 bit in length
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-payload-length    = ( %x00-7D )
                            / ( %x7E frame-payload-length-16 )
                            / ( %x7F frame-payload-length-63 )
                            ; 7, 7+16, or 7+64 bits in length,
                            ; respectively
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-payload-length-16 = %x0000-FFFF ; 16 bits in length
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF
                            ; 64 bits in length
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
frame-masking-key = 4( %x00-FF ) ; present only if frame-masked is 1 ; 32 bits in length
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
frame-masking-key = 4（％x00-FF）; frame-maskedが1の場合にのみ存在します。長さ32ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-payload-data      = (frame-masked-extension-data
                               frame-masked-application-data)
                            ; when frame-masked is 1
                              / (frame-unmasked-extension-data
                                frame-unmasked-application-data)
                            ; when frame-masked is 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-masked-extension-data     = *( %x00-FF )
                            ; reserved for future extensibility
                            ; n*8 bits in length, where n &gt;= 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-masked-application-data   = *( %x00-FF )
                            ; n*8 bits in length, where n &gt;= 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-unmasked-extension-data   = *( %x00-FF )
                            ; reserved for future extensibility
                            ; n*8 bits in length, where n &gt;= 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    frame-unmasked-application-data = *( %x00-FF )
                            ; n*8 bits in length, where n &gt;= 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Client-to-Server Masking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. クライアントからサーバーへのマスキング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A masked frame MUST have the field frame-masked set to 1, as defined in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスクされたフレームは、セクション5.2で定義されているように、frame-maskedフィールドを1に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The masking key is contained completely within the frame, as defined in Section 5.2 as frame-masking-key. It is used to mask the &#34;Payload data&#34; defined in the same section as frame-payload-data, which includes &#34;Extension data&#34; and &#34;Application data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.2でframe-masking-keyとして定義されているように、マスキングキーは完全にフレーム内に含まれています。 「拡張データ」と「アプリケーションデータ」を含むframe-payload-dataと同じセクションで定義された「ペイロードデータ」をマスクするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The masking key is a 32-bit value chosen at random by the client. When preparing a masked frame, the client MUST pick a fresh masking key from the set of allowed 32-bit values. The masking key needs to be unpredictable; thus, the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame. The unpredictability of the masking key is essential to prevent authors of malicious applications from selecting the bytes that appear on the wire. RFC 4086 [RFC4086] discusses what entails a suitable source of entropy for security-sensitive applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスキングキーは、クライアントによってランダムに選択された32ビットの値です。マスクされたフレームを準備するとき、クライアントは許可された32ビット値のセットから新しいマスキングキーを選択する必要があります。マスキングキーは予測不能である必要があります。したがって、マスキングキーはエントロピーの強力なソースから派生する必要があり、特定のフレームのマスキングキーは、サーバー/プロキシが後続のフレームのマスキングキーを予測することを単純にしてはなりません。マスキングキーの予測不能性は、悪意のあるアプリケーションの作成者が回線に表示されるバイトを選択できないようにするために不可欠です。 RFC 4086 [RFC4086]は、セキュリティの影響を受けやすいアプリケーションに適切なエントロピーのソースを必要とするものについて説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The masking does not affect the length of the &#34;Payload data&#34;. To convert masked data into unmasked data, or vice versa, the following algorithm is applied. The same algorithm applies regardless of the direction of the translation, e.g., the same steps are applied to mask the data as to unmask the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスキングは、「ペイロードデータ」の長さに影響しません。マスクされたデータをマスクされていないデータに、またはその逆に変換するには、次のアルゴリズムが適用されます。変換の方向に関係なく、同じアルゴリズムが適用されます。たとえば、データのマスクを解除する場合と同じステップを適用して、データをマスクします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Octet i of the transformed data (&#34;transformed-octet-i&#34;) is the XOR of octet i of the original data (&#34;original-octet-i&#34;) with octet at index i modulo 4 of the masking key (&#34;masking-key-octet-j&#34;):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変換されたデータのオクテットi（「transformed-octet-i」）は、元のデータ（「original-octet-i」）のオクテットiと、マスキングキー（「masking-key」の4を法とするインデックスiのオクテット）のXORです。 -octet-j &#34;）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The payload length, indicated in the framing as frame-payload-length, does NOT include the length of the masking key. It is the length of the &#34;Payload data&#34;, e.g., the number of bytes following the masking key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーミングでframe-payload-lengthとして示されているペイロード長には、マスキングキーの長さが含まれていません。これは、「ペイロードデータ」の長さです。たとえば、マスキングキーに続くバイト数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 断片化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary purpose of fragmentation is to allow sending a message that is of unknown size when the message is started without having to buffer that message. If messages couldn&#39;t be fragmented, then an endpoint would have to buffer the entire message so its length could be counted before the first byte is sent. With fragmentation, a server or intermediary may choose a reasonable size buffer and, when the buffer is full, write a fragment to the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメンテーションの主な目的は、メッセージの開始時にサイズが不明なメッセージをバッファリングせずに送信できるようにすることです。メッセージを断片化できなかった場合、エンドポイントはメッセージ全体をバッファーに入れて、最初のバイトが送信される前にその長さをカウントできるようにする必要があります。断片化により、サーバーまたは仲介者は適切なサイズのバッファーを選択し、バッファーがいっぱいになるとフラグメントをネットワークに書き込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A secondary use-case for fragmentation is for multiplexing, where it is not desirable for a large message on one logical channel to monopolize the output channel, so the multiplexing needs to be free to split the message into smaller fragments to better share the output channel. (Note that the multiplexing extension is not described in this document.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
フラグメンテーションの2番目の使用例は、多重化です。1つの論理チャネル上の大きなメッセージが出力チャネルを独占することは望ましくないため、出力チャネルをより適切に共有するには、多重化を自由にしてメッセージを小さなフラグメントに分割する必要があります。 。 （多重化拡張はこのドキュメントでは説明されていないことに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless specified otherwise by an extension, frames have no semantic meaning. An intermediary might coalesce and/or split frames, if no extensions were negotiated by the client and the server or if some extensions were negotiated, but the intermediary understood all the extensions negotiated and knows how to coalesce and/or split frames in the presence of these extensions. One implication of this is that in absence of extensions, senders and receivers must not depend on the presence of specific frame boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張機能で特に指定されていない限り、フレームには意味がありません。クライアントとサーバーによって拡張機能がネゴシエートされなかった場合、または一部の拡張機能がネゴシエートされた場合、仲介者はフレームを結合または分割する可能性がありますが、仲介者はすべての拡張機能をネゴシエートし、存在する場合にフレームを統合または分割する方法を知っています。これらの拡張機能。これが意味することの1つは、拡張機能がない場合、送信者と受信者は特定のフレーム境界の存在に依存してはならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules apply to fragmentation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメンテーションには次のルールが適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An unfragmented message consists of a single frame with the FIN bit set (Section 5.2) and an opcode other than 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フラグメント化されていないメッセージは、FINビットが設定された単一のフレーム（セクション5.2）と、0以外のオペコードで構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A fragmented message consists of a single frame with the FIN bit clear and an opcode other than 0, followed by zero or more frames with the FIN bit clear and the opcode set to 0, and terminated by a single frame with the FIN bit set and an opcode of 0. A fragmented message is conceptually equivalent to a single larger message whose payload is equal to the concatenation of the payloads of the fragments in order; however, in the presence of extensions, this may not hold true as the extension defines the interpretation of the &#34;Extension data&#34; present. For instance, &#34;Extension data&#34; may only be present at the beginning of the first fragment and apply to subsequent fragments, or there may be &#34;Extension data&#34; present in each of the fragments that applies only to that particular fragment. In the absence of &#34;Extension data&#34;, the following example demonstrates how fragmentation works.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フラグメント化されたメッセージは、FINビットがクリアされており、オペコードが0以外の単一フレームで構成され、その後にFINビットがクリアされ、オペコードが0に設定された0個以上のフレームが続き、FINビットがセットされ、オペコード0。フラグメント化されたメッセージは、概念的には、そのペイロードがフラグメントのペイロードを順番に連結したものに等しい1つの大きなメッセージと同等です。ただし、拡張が存在する場合、拡張が存在する「拡張データ」の解釈を定義するため、これは当てはまらない場合があります。たとえば、「拡張データ」は最初のフラグメントの先頭にのみ存在し、後続のフラグメントに適用される場合や、特定のフラグメントにのみ適用される「拡張データ」が各フラグメントに存在する場合があります。 「拡張データ」がない場合、次の例は断片化がどのように機能するかを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
EXAMPLE: For a text message sent as three fragments, the first fragment would have an opcode of 0x1 and a FIN bit clear, the second fragment would have an opcode of 0x0 and a FIN bit clear, and the third fragment would have an opcode of 0x0 and a FIN bit that is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
例：3つのフラグメントとして送信されるテキストメッセージの場合、最初のフラグメントのオペコードは0x1でFINビットがクリアされ、2番目のフラグメントのオペコードは0x0でFINビットがクリアされ、3番目のフラグメントのオペコードは0x0および設定されているFINビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Control frames (see Section 5.5) MAY be injected in the middle of a fragmented message. Control frames themselves MUST NOT be fragmented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 制御フレーム（セクション5.5を参照）は、断片化されたメッセージの途中に挿入される場合があります。制御フレーム自体は断片化してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Message fragments MUST be delivered to the recipient in the order sent by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メッセージフラグメントは、送信者が送信した順序で受信者に配信される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The fragments of one message MUST NOT be interleaved between the fragments of another message unless an extension has been negotiated that can interpret the interleaving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o インターリーブを解釈できる拡張機能がネゴシエートされていない限り、1つのメッセージのフラグメントを別のメッセージのフラグメント間でインターリーブしてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An endpoint MUST be capable of handling control frames in the middle of a fragmented message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エンドポイントは、断片化されたメッセージの途中で制御フレームを処理できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sender MAY create fragments of any size for non-control messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 送信者は、非制御メッセージ用に任意のサイズのフラグメントを作成できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clients and servers MUST support receiving both fragmented and unfragmented messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーは、断片化されたメッセージと断片化されていないメッセージの両方の受信をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As control frames cannot be fragmented, an intermediary MUST NOT attempt to change the fragmentation of a control frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 制御フレームはフラグメント化できないため、中間者は制御フレームのフラグメント化を変更してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An intermediary MUST NOT change the fragmentation of a message if any reserved bit values are used and the meaning of these values is not known to the intermediary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 予約ビット値が使用され、これらの値の意味が仲介者に知られていない場合、仲介者はメッセージの断片化を変更してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An intermediary MUST NOT change the fragmentation of any message in the context of a connection where extensions have been negotiated and the intermediary is not aware of the semantics of the negotiated extensions. Similarly, an intermediary that didn&#39;t see the WebSocket handshake (and wasn&#39;t notified about its content) that resulted in a WebSocket connection MUST NOT change the fragmentation of any message of such connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 仲介者は、拡張がネゴシエートされており、仲介者がネゴシエートされた拡張のセマンティクスを認識していない接続のコンテキストで、メッセージの断片化を変更してはなりません（MUST NOT）。同様に、WebSocket接続の原因となったWebSocketハンドシェイクを確認しなかった（およびその内容について通知されなかった）仲介者は、そのような接続のメッセージの断片化を変更してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As a consequence of these rules, all fragments of a message are of the same type, as set by the first fragment&#39;s opcode. Since control frames cannot be fragmented, the type for all fragments in a message MUST be either text, binary, or one of the reserved opcodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o これらのルールの結果として、メッセージのすべてのフラグメントは、最初のフラグメントのオペコードによって設定されたものと同じタイプになります。コントロールフレームはフラグメント化できないため、メッセージ内のすべてのフラグメントのタイプは、テキスト、バイナリ、または予約済みのオペコードのいずれかである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE: If control frames could not be interjected, the latency of a ping, for example, would be very long if behind a large message. Hence, the requirement of handling control frames in the middle of a fragmented message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：制御フレームを挿入できなかった場合、たとえば大きなメッセージの背後にある場合、pingの待機時間は非常に長くなります。したがって、断片化されたメッセージの途中で制御フレームを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION NOTE: In the absence of any extension, a receiver doesn&#39;t have to buffer the whole frame in order to process it. For example, if a streaming API is used, a part of a frame can be delivered to the application. However, note that this assumption might not hold true for all future WebSocket extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：拡張子がない場合、受信側はフレーム全体をバッファリングして処理する必要はありません。たとえば、ストリーミングAPIが使用されている場合、フレームの一部をアプリケーションに配信できます。ただし、この仮定は将来のすべてのWebSocket拡張機能に当てはまるとは限らないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Control Frames
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. 制御フレーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御フレームは、オペコードの最上位ビットが1であるオペコードによって識別されます。制御フレームに現在定義されているオペコードには、0x8（クローズ）、0x9（Ping）、および0xA（ポン）があります。オペコード0xB-0xFは、まだ定義されていない他の制御フレーム用に予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Control frames are used to communicate state about the WebSocket. Control frames can be interjected in the middle of a fragmented message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コントロールフレームは、WebSocketに関する状態を通信するために使用されます。制御フレームは、断片化されたメッセージの途中に挿入できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての制御フレームは、125バイト以下のペイロード長を持たなければならず（MUST）、フラグメント化してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.1. Close
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.1. 閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Close frame contains an opcode of 0x8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Closeフレームには、0x8のオペコードが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Close frame MAY contain a body (the &#34;Application data&#34; portion of the frame) that indicates a reason for closing, such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that does not conform to the format expected by the endpoint. If there is a body, the first two bytes of the body MUST be a 2-byte unsigned integer (in network byte order) representing a status code with value /code/ defined in Section 7.4. Following the 2-byte integer, the body MAY contain UTF-8-encoded data with value /reason/, the interpretation of which is not defined by this specification. This data is not necessarily human readable but may be useful for debugging or passing information relevant to the script that opened the connection. As the data is not guaranteed to be human readable, clients MUST NOT show it to end users.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Closeフレームには、終了する理由を示すボディ（フレームの「アプリケーションデータ」部分）が含まれている場合があります（シャットダウンするエンドポイント、フレームを受信しすぎたエンドポイントが大きすぎる、フレームを受信したエンドポイントなど）。エンドポイントが予期する形式に準拠していません。ボディがある場合、ボディの最初の2バイトは、セクション7.4で定義された値/ code /のステータスコードを表す2バイトの符号なし整数（ネットワークバイト順）である必要があります。 2バイト整数に続いて、本文には値が/ reason /のUTF-8でエンコードされたデータが含まれる場合があり、その解釈はこの仕様では定義されていません。このデータは必ずしも人間が読めるとは限りませんが、接続を開いたスクリプトに関連する情報をデバッグまたは渡すのに役立つ場合があります。データは人間が読めることが保証されていないため、クライアントはそれをエンドユーザーに見せてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Close frames sent from client to server must be masked as per Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントからサーバーに送信されるクローズフレームは、セクション5.3に従ってマスクする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application MUST NOT send any more data frames after sending a Close frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、Closeフレームを送信した後、これ以上データフレームを送信してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an endpoint receives a Close frame and did not previously send a Close frame, the endpoint MUST send a Close frame in response. (When sending a Close frame in response, the endpoint typically echos the status code it received.) It SHOULD do so as soon as practical. An endpoint MAY delay sending a Close frame until its current message is sent (for instance, if the majority of a fragmented message is already sent, an endpoint MAY send the remaining fragments before sending a Close frame). However, there is no guarantee that the endpoint that has already sent a Close frame will continue to process data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントがCloseフレームを受信し、以前にCloseフレームを送信していない場合、エンドポイントは応答としてCloseフレームを送信する必要があります。 （応答としてCloseフレームを送信する場合、エンドポイントは通常、受信したステータスコードをエコーし​​ます。）できるだけ早くそうする必要があります。エンドポイントは、現在のメッセージが送信されるまでCloseフレームの送信を遅らせる場合があります（たとえば、断片化されたメッセージの大部分がすでに送信されている場合、エンドポイントは、Closeフレームを送信する前に残りのフラグメントを送信する場合があります）。ただし、すでにCloseフレームを送信したエンドポイントが引き続きデータを処理するという保証はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After both sending and receiving a Close message, an endpoint considers the WebSocket connection closed and MUST close the underlying TCP connection. The server MUST close the underlying TCP connection immediately; the client SHOULD wait for the server to close the connection but MAY close the connection at any time after sending and receiving a Close message, e.g., if it has not received a TCP Close from the server in a reasonable time period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Closeメッセージの送信と受信の両方の後、エンドポイントはWebSocket接続が閉じられたと見なし、基になるTCP接続を閉じなければなりません（MUST）。サーバーは、基になるTCP接続をすぐに閉じる必要があります。クライアントは、サーバーが接続を閉じるまで待機する必要がありますが、適切な時間内にサーバーからTCP Closeを受信しなかった場合など、Closeメッセージを送受信した後はいつでも接続を閉じることができます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client and server both send a Close message at the same time, both endpoints will have sent and received a Close message and should consider the WebSocket connection closed and close the underlying TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーの両方が同時にCloseメッセージを送信する場合、両方のエンドポイントがCloseメッセージを送受信しているため、WebSocket接続が閉じていると見なして、基になるTCP接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2. Ping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2. ping
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Ping frame contains an opcode of 0x9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pingフレームには、0x9のオペコードが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Ping frame MAY include &#34;Application data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pingフレームには「アプリケーションデータ」が含まれる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in response, unless it already received a Close frame. It SHOULD respond with Pong frame as soon as is practical. Pong frames are discussed in Section 5.5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、Pingフレームを受信すると、既にCloseフレームを受信して​​いない限り、応答としてPongフレームを送信する必要があります。それは、実用的であるとすぐに、ポンフレームで応答する必要があります。ピンポンフレームについては、セクション5.5.3で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MAY send a Ping frame any time after the connection is established and before the connection is closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、接続が確立された後、接続が閉じられる前であればいつでもPingフレームを送信できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE: A Ping frame may serve either as a keepalive or as a means to verify that the remote endpoint is still responsive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：Pingフレームは、キープアライブとして、またはリモートエンドポイントがまだ応答していることを確認する手段として機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.3. Pong
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.3. ポン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Pong frame contains an opcode of 0xA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pongフレームには、0xAのオペコードが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 5.5.2 details requirements that apply to both Ping and Pong frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.5.2では、PingフレームとPongフレームの両方に適用される要件について詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Pong frame sent in response to a Ping frame must have identical &#34;Application data&#34; as found in the message body of the Ping frame being replied to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pingフレームへの応答として送信されるPongフレームは、応答されるPingフレームのメッセージ本文にあるのと同じ「アプリケーションデータ」を持っている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an endpoint receives a Ping frame and has not yet sent Pong frame(s) in response to previous Ping frame(s), the endpoint MAY elect to send a Pong frame for only the most recently processed Ping frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントがPingフレームを受信し、以前のPingフレームに応答してPongフレームをまだ送信していない場合、エンドポイントは、最後に処理されたPingフレームに対してのみPongフレームを送信することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Pong frame MAY be sent unsolicited. This serves as a unidirectional heartbeat. A response to an unsolicited Pong frame is not expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pongフレームは未承諾で送信される場合があります。これは一方向のハートビートとして機能します。未承諾のPongフレームに対する応答は想定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. Data Frames
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. データフレーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data frames (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Opcodes 0x3-0x7 are reserved for further non-control frames yet to be defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレーム（非制御フレームなど）は、オペコードの最上位ビットが0であるオペコードによって識別されます。現在定義されているデータフレームのオペコードには、0x1（テキスト）、0x2（バイナリ）があります。オペコード0x3-0x7は、まだ定義されていない他の非制御フレーム用に予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data frames carry application-layer and/or extension-layer data. The opcode determines the interpretation of the data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレームは、アプリケーション層および/または拡張層のデータを伝送します。オペコードはデータの解釈を決定します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Text
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テキスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The &#34;Payload data&#34; is text data encoded as UTF-8. Note that a particular text frame might include a partial UTF-8 sequence; however, the whole message MUST contain valid UTF-8. Invalid UTF-8 in reassembled messages is handled as described in Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「ペイロードデータ」は、UTF-8でエンコードされたテキストデータです。特定のテキストフレームに部分的なUTF-8シーケンスが含まれる場合があることに注意してください。ただし、メッセージ全体には有効なUTF-8が含まれている必要があります。再構成されたメッセージ内の無効なUTF-8は、セクション8.1で説明されているように処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Binary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイナリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The &#34;Payload data&#34; is arbitrary binary data whose interpretation is solely up to the application layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「ペイロードデータ」は、アプリケーションレイヤーにのみ解釈される任意のバイナリデータです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. 例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A single-frame unmasked text message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 単一フレームのマスクされていないテキストメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains &#34;Hello&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f（「Hello」を含む）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A single-frame masked text message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 単一フレームのマスクされたテキストメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains &#34;Hello&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58（「Hello」を含む）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A fragmented unmasked text message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 断片化されたマスクされていないテキストメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x01 0x03 0x48 0x65 0x6c (contains &#34;Hel&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x01 0x03 0x48 0x65 0x6c（「Hel」を含む）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x80 0x02 0x6c 0x6f (contains &#34;lo&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x80 0x02 0x6c 0x6f（「lo」を含む）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Unmasked Ping request and masked Ping response
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o マスクされていないPing要求とマスクされたPing応答
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of &#34;Hello&#34;, but the contents of the body are arbitrary)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f（「Hello」のボディが含まれますが、ボディのコンテンツは任意です）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains a body of &#34;Hello&#34;, matching the body of the ping)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58（pingの本体と一致する「Hello」の本体を含む）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 256 bytes binary message in a single unmasked frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 単一のマスクされていないフレーム内の256バイトのバイナリメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x82 0x7E 0x0100 [256 bytes of binary data]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x82 0x7E 0x0100 [256バイトのバイナリデータ]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 64KiB binary message in a single unmasked frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 単一のマスクされていないフレーム内の64KiBバイナリメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 0x82 0x7F 0x0000000000010000 [65536バイトのバイナリデータ]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. Extensibility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. 拡張性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol is designed to allow for extensions, which will add capabilities to the base protocol. The endpoints of a connection MUST negotiate the use of any extensions during the opening handshake. This specification provides opcodes 0x3 through 0x7 and 0xB through 0xF, the &#34;Extension data&#34; field, and the frame-rsv1, frame-rsv2, and frame-rsv3 bits of the frame header for use by extensions. The negotiation of extensions is discussed in further detail in Section 9.1. Below are some anticipated uses of extensions. This list is neither complete nor prescriptive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、基本プロトコルに機能を追加する拡張を可能にするように設計されています。接続のエンドポイントは、開始ハンドシェイク中に拡張機能の使用についてネゴシエートする必要があります。この仕様は、オペコード0x3から0x7および0xBから0xF、「拡張データ」フィールド、および拡張で使用するためのフレームヘッダーのframe-rsv1、frame-rsv2、frame-rsv3ビットを提供します。拡張の交渉については、9.1節でさらに詳しく説明します。以下は、予想される拡張機能の使用例です。このリストは完全でも規範的でもありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;Extension data&#34; may be placed in the &#34;Payload data&#34; before the &#34;Application data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「拡張データ」は、「ペイロードデータ」の「アプリケーションデータ」の前に配置できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reserved bits can be allocated for per-frame needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 予約ビットは、フレームごとのニーズに割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reserved opcode values can be defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 予約済みのオペコード値を定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reserved bits can be allocated to the opcode field if more opcode values are needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o さらに多くのオペコード値が必要な場合は、予約ビットをオペコードフィールドに割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A reserved bit or an &#34;extension&#34; opcode can be defined that allocates additional bits out of the &#34;Payload data&#34; to define larger opcodes or more per-frame bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o より大きなオペコードまたはより多くのフレームごとのビットを定義するために、「ペイロードデータ」から追加のビットを割り当てる予約ビットまたは「拡張」オペコードを定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Sending and Receiving Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. データの送受信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Sending Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. データの送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To _Send a WebSocket Message_ comprising of /data/ over a WebSocket connection, an endpoint MUST perform the following steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket接続を介して/ data /で構成される_WebSocketメッセージを送信するには、エンドポイントは次の手順を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The endpoint MUST ensure the WebSocket connection is in the OPEN state (cf. Sections 4.1 and 4.2.2.) If at any point the state of the WebSocket connection changes, the endpoint MUST abort the following steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. エンドポイントは、WebSocket接続がOPEN状態であることを確認する必要があります（セクション4.1および4.2.2を参照）。いずれかの時点でWebSocket接続の状態が変化した場合、エンドポイントは次の手順を中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. An endpoint MUST encapsulate the /data/ in a WebSocket frame as defined in Section 5.2. If the data to be sent is large or if the data is not available in its entirety at the point the endpoint wishes to begin sending the data, the endpoint MAY alternately encapsulate the data in a series of frames as defined in Section 5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. エンドポイントは、セクション5.2で定義されているように、/ data /をWebSocketフレームにカプセル化する必要があります。送信されるデータが大きい場合、またはエンドポイントがデータの送信を開始したい時点でデータが完全に利用できない場合、エンドポイントは、セクション5.4で定義されている一連のフレームにデータを交互にカプセル化できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The opcode (frame-opcode) of the first frame containing the data MUST be set to the appropriate value from Section 5.2 for data that is to be interpreted by the recipient as text or binary data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. データを含む最初のフレームのオペコード（frame-opcode）は、受信者がテキストまたはバイナリデータとして解釈するデータに対して、セクション5.2の適切な値に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The FIN bit (frame-fin) of the last frame containing the data MUST be set to 1 as defined in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. セクション5.2で定義されているように、データを含む最後のフレームのFINビット（frame-fin）を1に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the data is being sent by the client, the frame(s) MUST be masked as defined in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. データがクライアントによって送信されている場合は、セクション5.3で定義されているようにフレームをマスクする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If any extensions (Section 9) have been negotiated for the WebSocket connection, additional considerations may apply as per the definition of those extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 拡張（セクション9）がWebSocket接続についてネゴシエートされている場合、それらの拡張の定義に従って追加の考慮事項が適用される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The frame(s) that have been formed MUST be transmitted over the underlying network connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. 形成されたフレームは、基になるネットワーク接続を介して送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Receiving Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. データ受信中
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To receive WebSocket data, an endpoint listens on the underlying network connection. Incoming data MUST be parsed as WebSocket frames as defined in Section 5.2. If a control frame (Section 5.5) is received, the frame MUST be handled as defined by Section 5.5. Upon receiving a data frame (Section 5.6), the endpoint MUST note the /type/ of the data as defined by the opcode (frame-opcode) from Section 5.2. The &#34;Application data&#34; from this frame is defined as the /data/ of the message. If the frame comprises an unfragmented message (Section 5.4), it is said that _A WebSocket Message Has Been Received_ with type /type/ and data /data/. If the frame is part of a fragmented message, the &#34;Application data&#34; of the subsequent data frames is concatenated to form the /data/. When the last fragment is received as indicated by the FIN bit (frame-fin), it is said that _A WebSocket Message Has Been Received_ with data /data/ (comprised of the concatenation of the &#34;Application data&#34; of the fragments) and type /type/ (noted from the first frame of the fragmented message). Subsequent data frames MUST be interpreted as belonging to a new WebSocket message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
WebSocketデータを受信するために、エンドポイントは基盤となるネットワーク接続をリッスンします。受信データは、セクション5.2で定義されているWebSocketフレームとして解析する必要があります。制御フレーム（セクション5.5）を受信した場合、フレームはセクション5.5の定義に従って処理する必要があります。データフレーム（セクション5.6）を受信すると、エンドポイントは、セクション5.2のオペコード（frame-opcode）で定義されたデータの/ type /に注意する必要があります。このフレームの「アプリケーションデータ」は、メッセージの/ data /として定義されます。フレームが断片化されていないメッセージで構成されている場合（セクション5.4）、タイプ/ type /およびデータ/ data /の_A WebSocketメッセージが受信されました_と言われます。フレームがフラグメント化されたメッセージの一部である場合、後続のデータフレームの「アプリケーションデータ」が連結されて、/ data /が形成されます。最後のフラグメントがFINビット（frame-fin）で示されるように受信されると、_WebSocketメッセージが受信されました_データ/ data /（フラグメントの「アプリケーションデータ」の連結で構成されます）およびタイプ/ type /（断片化されたメッセージの最初のフレームから書き留められます）。後続のデータフレームは、新しいWebSocketメッセージに属するものとして解釈される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extensions (Section 9) MAY change the semantics of how data is read, specifically including what comprises a message boundary. Extensions, in addition to adding &#34;Extension data&#34; before the &#34;Application data&#34; in a payload, MAY also modify the &#34;Application data&#34; (such as by compressing it).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張（セクション9）は、特にメッセージ境界を構成するものを含め、データの読み取り方法のセマンティクスを変更する場合があります。拡張機能では、ペイロードの「アプリケーションデータ」の前に「拡張データ」を追加するだけでなく、「アプリケーションデータ」を変更することもできます（圧縮など）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST remove masking for data frames received from a client as described in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.3で説明されているように、サーバーはクライアントから受信したデータフレームのマスキングを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Closing the Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 接続を閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.1. Close the WebSocket Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.1. WebSocket接続を閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To _Close the WebSocket Connection_, an endpoint closes the underlying TCP connection. An endpoint SHOULD use a method that cleanly closes the TCP connection, as well as the TLS session, if applicable, discarding any trailing bytes that may have been received. An endpoint MAY close the connection via any means available when necessary, such as when under attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
_WebSocket接続を閉じる_ために、エンドポイントは基になるTCP接続を閉じます。エンドポイントは、TCP接続と、該当する場合はTLSセッションを完全に閉じるメソッドを使用して、受信された可能性のある後続のバイトを破棄する必要があります（SHOULD）。エンドポイントは、攻撃を受けているときなど、必要なときに利用可能な任意の手段で接続を閉じてもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The underlying TCP connection, in most normal cases, SHOULD be closed first by the server, so that it holds the TIME_WAIT state and not the client (as this would prevent it from re-opening the connection for 2 maximum segment lifetimes (2MSL), while there is no corresponding server impact as a TIME_WAIT connection is immediately reopened upon a new SYN with a higher seq number). In abnormal cases (such as not having received a TCP Close from the server after a reasonable amount of time) a client MAY initiate the TCP Close. As such, when a server is instructed to _Close the WebSocket Connection_ it SHOULD initiate a TCP Close immediately, and when a client is instructed to do the same, it SHOULD wait for a TCP Close from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基礎となるTCP接続は、ほとんどの通常の場合、最初にサーバーによって閉じられる必要があります。これにより、クライアントではなくTIME_WAIT状態が保持されます（これにより、最大2つのセグメントライフタイム（2MSL）で接続を再度開くことができなくなるため、 TIME_WAIT接続は、より高いシーケンス番号を持つ新しいSYNですぐに再開されるため、対応するサーバーへの影響はありません。異常な場合（妥当な時間の後にサーバーからTCPクローズを受信しないなど）は、クライアントがTCPクローズを開始してもよい（MAY）。そのため、サーバーが_WebSocket接続を閉じるように指示された場合、サーバーはすぐにTCPクローズを開始する必要があり（SHOULD）、クライアントが同じことを行うように指示された場合、サーバーからのTCPクローズを待つ必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example of how to obtain a clean closure in C using Berkeley sockets, one would call shutdown() with SHUT_WR on the socket, call recv() until obtaining a return value of 0 indicating that the peer has also performed an orderly shutdown, and finally call close() on the socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バークレーソケットを使用してCでクリーンなクロージャを取得する方法の例として、ソケットにSHUT_WRを指定してshutdown()を呼び出し、ピアが正常なシャットダウンを実行したことを示す0の戻り値を取得するまでrecv()を呼び出します。最後に、ソケットでclose()を呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.2. Start the WebSocket Closing Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.2. WebSocketクローズハンドシェイクを開始する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To _Start the WebSocket Closing Handshake_ with a status code (Section 7.4) /code/ and an optional close reason (Section 7.1.6) /reason/, an endpoint MUST send a Close control frame, as described in Section 5.5.1, whose status code is set to /code/ and whose close reason is set to /reason/. Once an endpoint has both sent and received a Close control frame, that endpoint SHOULD _Close the WebSocket Connection_ as defined in Section 7.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータスコード（セクション7.4）/ code /とオプションのクローズ理由（セクション7.1.6）/ reason /を使用して_WebSocketクローズハンドシェイクを開始するには、セクション5.5.1で説明されているように、エンドポイントはクローズコントロールフレームを送信する必要があります。ステータスコードは/ code /に設定され、その終了理由は/ reason /に設定されます。エンドポイントがCloseコントロールフレームを送受信した後、セクション7.1.1で定義されているように、そのエンドポイントは_WebSocket接続を閉じる必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.3. The WebSocket Closing Handshake is Started
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.3. WebSocketクローズハンドシェイクが開始されました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon either sending or receiving a Close control frame, it is said that _The WebSocket Closing Handshake is Started_ and that the WebSocket connection is in the CLOSING state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Closeコントロールフレームを送信または受信すると、_WebSocketクローズハンドシェイクが開始され、WebSocket接続がCLOSING状態であると言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.4. The WebSocket Connection is Closed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.4. WebSocket接続が閉じています
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the underlying TCP connection is closed, it is said that _The WebSocket Connection is Closed_ and that the WebSocket connection is in the CLOSED state. If the TCP connection was closed after the WebSocket closing handshake was completed, the WebSocket connection is said to have been closed _cleanly_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基になるTCP接続が閉じられると、_The WebSocket Connection is Closed_であり、WebSocket接続がCLOSED状態であると言われます。 WebSocketクローズハンドシェイクの完了後にTCP接続が閉じられた場合、WebSocket接続は_cleanly_閉じられたと言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the WebSocket connection could not be established, it is also said that _The WebSocket Connection is Closed_, but not _cleanly_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket接続を確立できなかった場合も、_The WebSocket Connection is Closed_ではあるが、_cleanly_ではない、とも言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.5. The WebSocket Connection Close Code
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.5. WebSocket接続終了コード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As defined in Sections 5.5.1 and 7.4, a Close control frame may contain a status code indicating a reason for closure. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. _The WebSocket Connection Close Code_ is defined as the status code (Section 7.4) contained in the first Close control frame received by the application implementing this protocol. If this Close control frame contains no status code, _The WebSocket Connection Close Code_ is considered to be 1005. If _The WebSocket Connection is Closed_ and no Close control frame was received by the endpoint (such as could occur if the underlying transport connection is lost), _The WebSocket Connection Close Code_ is considered to be 1006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.5.1および7.4で定義されているように、クローズコントロールフレームには、クローズの理由を示すステータスコードが含まれる場合があります。 WebSocket接続のクローズは、いずれかのエンドポイントによって、場合によっては同時に開始される可能性があります。 _WebSocket接続終了コード_は、このプロトコルを実装するアプリケーションが受信した最初のCloseコントロールフレームに含まれるステータスコード（セクション7.4）として定義されます。このCloseコントロールフレームにステータスコードが含まれていない場合、_WebSocket接続のクローズコード_は1005と見なされます。 、_WebSocket接続終了コード_は1006と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NOTE: Two endpoints may not agree on the value of _The WebSocket Connection Close Code_. As an example, if the remote endpoint sent a Close frame but the local application has not yet read the data containing the Close frame from its socket&#39;s receive buffer, and the local application independently decided to close the connection and send a Close frame, both endpoints will have sent and received a Close frame and will not send further Close frames. Each endpoint will see the status code sent by the other end as _The WebSocket Connection Close Code_. As such, it is possible that the two endpoints may not agree on the value of _The WebSocket Connection Close Code_ in the case that both endpoints _Start the WebSocket Closing Handshake_ independently and at roughly the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
注：2つのエンドポイントが_The WebSocket Connection Close Code_の値に同意しない場合があります。例として、リモートエンドポイントがCloseフレームを送信したが、ローカルアプリケーションがそのソケットの受信バッファからCloseフレームを含むデータをまだ読み取っていない場合、ローカルアプリケーションが接続を閉じてCloseフレームを送信することを独自に決定した場合、両方のエンドポイントCloseフレームを送受信し、それ以上Closeフレームを送信しません。各エンドポイントは、もう一方の端から送信されたステータスコードを_The WebSocket Connection Close Code_として認識します。そのため、両方のエンドポイントが独立して、ほぼ同時に_WebSocketクローズハンドシェイクを開始した場合、2つのエンドポイントが_The WebSocket Connection Close Code_の値に一致しない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.6. The WebSocket Connection Close Reason
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.6. WebSocket接続終了の理由
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As defined in Sections 5.5.1 and 7.4, a Close control frame may contain a status code indicating a reason for closure, followed by UTF-8-encoded data, the interpretation of said data being left to the endpoints and not defined by this protocol. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. _The WebSocket Connection Close Reason_ is defined as the UTF-8-encoded data following the status code (Section 7.4) contained in the first Close control frame received by the application implementing this protocol. If there is no such data in the Close control frame, _The WebSocket Connection Close Reason_ is the empty string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.5.1および7.4で定義されているように、Closeコントロールフレームには、閉鎖の理由を示すステータスコードと、それに続くUTF-8でエンコードされたデータが含まれている可能性があります。 。 WebSocket接続のクローズは、いずれかのエンドポイントによって、場合によっては同時に開始される可能性があります。 _WebSocket接続クローズの理由_は、このプロトコルを実装するアプリケーションが受信した最初のCloseコントロールフレームに含まれるステータスコード（セクション7.4）に続く、UTF-8でエンコードされたデータとして定義されます。 Closeコントロールフレームにそのようなデータがない場合、_The WebSocket Connection Close Reason_は空の文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE: Following the same logic as noted in Section 7.1.5, two endpoints may not agree on _The WebSocket Connection Close Reason_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：セクション7.1.5と同じロジックに従って、2つのエンドポイントが_The WebSocket Connection Close Reason_に同意しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.7. Fail the WebSocket Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.7. WebSocket接続を失敗させる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain algorithms and specifications require an endpoint to _Fail the WebSocket Connection_. To do so, the client MUST _Close the WebSocket Connection_, and MAY report the problem to the user (which would be especially useful for developers) in an appropriate manner. Similarly, to do so, the server MUST _Close the WebSocket Connection_, and SHOULD log the problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のアルゴリズムと仕様では、_WebSocket接続に失敗するためのエンドポイントが必要です。これを行うには、クライアントは_WebSocket接続を閉じる_必要があります。また、適切な方法で問題をユーザー（特に開発者に役立つ）に報告できます（MAY）。同様に、これを行うには、サーバーは_WebSocket接続を閉じる_必要があり、問題を記録する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If _The WebSocket Connection is Established_ prior to the point where the endpoint is required to _Fail the WebSocket Connection_, the endpoint SHOULD send a Close frame with an appropriate status code (Section 7.4) before proceeding to _Close the WebSocket Connection_. An endpoint MAY omit sending a Close frame if it believes the other side is unlikely to be able to receive and process the Close frame, due to the nature of the error that led the WebSocket connection to fail in the first place. An endpoint MUST NOT continue to attempt to process data (including a responding Close frame) from the remote endpoint after being instructed to _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントが_WebSocket接続に失敗する必要があるポイントの前に_The WebSocket Connection is Established_がある場合、エンドポイントは、_Close the WebSocket Connection_に進む前に、適切なステータスコード（セクション7.4）でCloseフレームを送信する必要があります。エンドポイントは、WebSocket接続が最初に失敗する原因となったエラーの性質が原因で、反対側がCloseフレームを受信して​​処理する可能性が低いと考える場合、Closeフレームの送信を省略してもよい（MAY）。エンドポイントは、_WebSocket接続に失敗するように指示された後、リモートエンドポイントからのデータ（応答するCloseフレームを含む）の処理を継続して試みてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except as indicated above or as specified by the application layer (e.g., a script using the WebSocket API), clients SHOULD NOT close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記またはアプリケーションレイヤー（WebSocket APIを使用するスクリプトなど）で指定されている場合を除き、クライアントは接続を閉じないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Abnormal Closures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 異常な閉鎖
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. Client-Initiated Closure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. クライアントが開始する閉鎖
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain algorithms, in particular during the opening handshake, require the client to _Fail the WebSocket Connection_. To do so, the client MUST _Fail the WebSocket Connection_ as defined in Section 7.1.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のアルゴリズム、特にオープンハンドシェイク中は、クライアントが_WebSocket接続に失敗する_必要があります。そのためには、クライアントはセクション7.1.7で定義されているように_WebSocket接続に失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If at any point the underlying transport layer connection is unexpectedly lost, the client MUST _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれかの時点で、基になるトランスポート層接続が予期せず失われた場合、クライアントは_WebSocket接続に失敗する必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except as indicated above or as specified by the application layer (e.g., a script using the WebSocket API), clients SHOULD NOT close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記またはアプリケーションレイヤー（WebSocket APIを使用するスクリプトなど）で指定されている場合を除き、クライアントは接続を閉じないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. Server-Initiated Closure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. サーバーが開始するクロージャー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain algorithms require or recommend that the server _Abort the WebSocket Connection_ during the opening handshake. To do so, the server MUST simply _Close the WebSocket Connection_ (Section 7.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のアルゴリズムでは、オープニングハンドシェイク中にサーバーが_WebSocket接続を中止する_ことが必要または推奨されます。そのためには、サーバーは単に_WebSocket接続を閉じる_（セクション7.1.1）必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.3. Recovering from Abnormal Closure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.3. 異常な閉鎖からの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Abnormal closures may be caused by any number of reasons. Such closures could be the result of a transient error, in which case reconnecting may lead to a good connection and a resumption of normal operations. Such closures may also be the result of a nontransient problem, in which case if each deployed client experiences an abnormal closure and immediately and persistently tries to reconnect, the server may experience what amounts to a denial-of-service attack by a large number of clients trying to reconnect. The end result of such a scenario could be that the service is unable to recover in a timely manner or recovery is made much more difficult.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異常な閉鎖は、さまざまな理由で発生する可能性があります。このようなクロージャは一時的なエラーの結果である可能性があり、その場合、再接続すると正常な接続と通常の操作の再開につながる可能性があります。このようなクロージャは、一時的でない問題の結果である可能性もあります。その場合、デプロイされた各クライアントで異常なクロージャが発生し、すぐに持続的に再接続しようとすると、サーバーで大量のサービス拒否攻撃が発生する可能性があります。再接続を試みるクライアント。そのようなシナリオの最終結果は、サービスがタイムリーに回復できないか、回復がはるかに困難になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To prevent this, clients SHOULD use some form of backoff when trying to reconnect after abnormal closures as described in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを防ぐために、クライアントは、このセクションで説明されているように、異常なクローズの後に再接続を試みるときに何らかの形式のバックオフを使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first reconnect attempt SHOULD be delayed by a random amount of time. The parameters by which this random delay is chosen are left to the client to decide; a value chosen randomly between 0 and 5 seconds is a reasonable initial delay though clients MAY choose a different interval from which to select a delay length based on implementation experience and particular application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の再接続試行は、ランダムな時間だけ遅延する必要があります。このランダムな遅延が選択されるパラメーターは、クライアントに決定を任せます。クライアントが実装経験と特定のアプリケーションに基づいて遅延の長さを選択する別の間隔を選択する場合がありますが、0〜5秒の間でランダムに選択された値は妥当な初期遅延です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Should the first reconnect attempt fail, subsequent reconnect attempts SHOULD be delayed by increasingly longer amounts of time, using a method such as truncated binary exponential backoff.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の再接続の試行が失敗した場合、後続の再接続の試行は、切り捨てられたバイナリ指数バックオフなどの方法を使用して、ますます長い時間遅延する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Normal Closure of Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 接続の通常の閉鎖
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers MAY close the WebSocket connection whenever desired. Clients SHOULD NOT close the WebSocket connection arbitrarily. In either case, an endpoint initiates a closure by following the procedures to _Start the WebSocket Closing Handshake_ (Section 7.1.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、必要に応じていつでもWebSocket接続を閉じることができます。クライアントはWebSocket接続を勝手に閉じないでください。どちらの場合でも、エンドポイントは_WebSocketクローズハンドシェイクを開始する手順（セクション7.1.2）に従って、クロージャを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Status Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. ステータスコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When closing an established connection (e.g., when sending a Close frame, after the opening handshake has completed), an endpoint MAY indicate a reason for closure. The interpretation of this reason by an endpoint, and the action an endpoint should take given this reason, are left undefined by this specification. This specification defines a set of pre-defined status codes and specifies which ranges may be used by extensions, frameworks, and end applications. The status code and any associated textual message are optional components of a Close frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確立された接続を閉じるとき（たとえば、開始ハンドシェイクが完了した後、Closeフレームを送信するとき）、エンドポイントは閉じた理由を示してもよい（MAY）。エンドポイントによるこの理由の解釈、およびこの理由でエンドポイントが実行する必要のあるアクションは、この仕様では定義されていません。この仕様は、事前定義されたステータスコードのセットを定義し、拡張機能、フレームワーク、およびエンドアプリケーションで使用できる範囲を指定します。ステータスコードと関連するテキストメッセージは、閉じるフレームのオプションコンポーネントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. Defined Status Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. 定義されたステータスコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints MAY use the following pre-defined status codes when sending a Close frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、Closeフレームを送信するときに、次の事前定義されたステータスコードを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１０００
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1000 indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1000は通常の閉鎖を示します。つまり、接続が確立された目的が達成されたことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1001
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００１
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1001 indicates that an endpoint is &#34;going away&#34;, such as a server going down or a browser having navigated away from a page.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1001は、サーバーがダウンしたり、ブラウザがページから移動したりするなど、エンドポイントが「離れる」ことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1002
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００２
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1002 indicates that an endpoint is terminating the connection due to a protocol error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1002は、プロトコルエラーが原因でエンドポイントが接続を終了していることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1003
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００３
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1003 indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1003は、エンドポイントが受け入れることができないタイプのデータを受信したために、エンドポイントが接続を終了していることを示します（たとえば、テキストデータのみを理解するエンドポイントは、バイナリメッセージを受信した場合にこれを送信できます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1004
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００４
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Reserved. The specific meaning might be defined in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
予約済み。特定の意味は将来定義されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1005
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００５
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1005 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that no status code was actually present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1005は予約済みの値であり、エンドポイントによってCloseコントロールフレームのステータスコードとして設定してはなりません（MUST NOT）。これは、ステータスコードが実際に存在しないことを示すステータスコードを必要とするアプリケーションで使用するために指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1006
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００６
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1006 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed abnormally, e.g., without sending or receiving a Close control frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1006は予約済みの値であり、エンドポイントによってCloseコントロールフレームのステータスコードとして設定してはなりません（MUST NOT）。これは、たとえば、Closeコントロールフレームを送信または受信せずに、接続が異常に閉じられたことを示すステータスコードを期待するアプリケーションで使用するために指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1007
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００７
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1007 indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1007は、メッセージのタイプと一致しないメッセージ内のデータ（テキストメッセージ内の非UTF-8 [RFC3629]データなど）を受信したため、エンドポイントが接続を終了していることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1008
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００８
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1008 indicates that an endpoint is terminating the connection because it has received a message that violates its policy. This is a generic status code that can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a need to hide specific details about the policy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1008は、ポリシーに違反するメッセージを受信したため、エンドポイントが接続を終了していることを示します。これは、他に適切なステータスコード（1003や1009など）がない場合、またはポリシーに関する特定の詳細を非表示にする必要がある場合に返される一般的なステータスコードです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1009
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１００９
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1009 indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1009は、処理するには大きすぎるメッセージを受信したため、エンドポイントが接続を終了していることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1010
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１０１０
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 1010 indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn&#39;t return them in the response message of the WebSocket handshake. The list of extensions that are needed SHOULD appear in the /reason/ part of the Close frame. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
1010は、サーバーが1つ以上の拡張をネゴシエートすることを期待していたが、サーバーがWebSocketハンドシェイクの応答メッセージでそれらを返さなかったため、エンドポイント（クライアント）が接続を終了していることを示します。必要な拡張機能のリストは、閉じるフレームの/ reason /部分に表示する必要があります（SHOULD）。このステータスコードはWebSocketハンドシェイクに失敗する可能性があるため、サーバーでは使用されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1011
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１０１１
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1011 indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1011は、予期しない状況が発生したためにサーバーが接続を終了していることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1015
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１０１５
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1015 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can&#39;t be verified).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1015は予約済みの値であり、エンドポイントによってCloseコントロールフレームのステータスコードとして設定してはなりません（MUST NOT）。これは、TLSハンドシェイクの実行に失敗したために接続が閉じられたことを示すステータスコードを必要とするアプリケーションで使用するように指定されています（たとえば、サーバー証明書を確認できません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. Reserved Status Code Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. 予約済みステータスコードの範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-999
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
０ー９９９
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Status codes in the range 0-999 are not used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0〜999の範囲のステータスコードは使用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1000-2999
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
１０００ー２９９９
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Status codes in the range 1000-2999 are reserved for definition by this protocol, its future revisions, and extensions specified in a permanent and readily available public specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1000〜2999の範囲のステータスコードは、このプロトコル、その将来のリビジョン、および永続的ですぐに利用できる公開仕様で指定されている拡張機能による定義のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3000-3999
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
３０００ー３９９９
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Status codes in the range 3000-3999 are reserved for use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3000〜3999の範囲のステータスコードは、ライブラリ、フレームワーク、およびアプリケーションで使用するために予約されています。これらのステータスコードはIANAに直接登録されます。これらのコードの解釈は、このプロトコルでは定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4000-4999
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
４０００ー４９９９
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Status codes in the range 4000-4999 are reserved for private use and thus can&#39;t be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4000〜4999の範囲のステータスコードは、個人使用のために予約されているため、登録できません。このようなコードは、WebSocketアプリケーション間の事前の合意で使用できます。これらのコードの解釈は、このプロトコルでは定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Error Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. エラー処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Handling Errors in UTF-8-Encoded Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. UTF-8でエンコードされたデータのエラーの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an endpoint is to interpret a byte stream as UTF-8 but finds that the byte stream is not, in fact, a valid UTF-8 stream, that endpoint MUST _Fail the WebSocket Connection_. This rule applies both during the opening handshake and during subsequent data exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントがバイトストリームをUTF-8として解釈する必要があるが、バイトストリームが実際には有効なUTF-8ストリームではない場合、そのエンドポイントはWebSocket接続に失敗する必要があります。このルールは、開始ハンドシェイクとその後のデータ交換の両方に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket clients MAY request extensions to this specification, and WebSocket servers MAY accept some or all extensions requested by the client. A server MUST NOT respond with any extension not requested by the client. If extension parameters are included in negotiations between the client and the server, those parameters MUST be chosen in accordance with the specification of the extension to which the parameters apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketクライアントはこの仕様の拡張を要求することができ、WebSocketサーバーはクライアントが要求する拡張の一部またはすべてを受け入れることができます（MAY）。サーバーは、クライアントから要求されていない拡張機能で応答してはなりません（MUST NOT）。拡張パラメーターがクライアントとサーバー間のネゴシエーションに含まれている場合、それらのパラメーターは、パラメーターが適用される拡張の仕様に従って選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Negotiating Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 拡張の交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client requests extensions by including a |Sec-WebSocket-Extensions| header field, which follows the normal rules for HTTP header fields (see [RFC2616], Section 4.2) and the value of the header field is defined by the following ABNF [RFC2616]. Note that this section is using ABNF syntax/rules from [RFC2616], including the &#34;implied *LWS rule&#34;. If a value is received by either the client or the server during negotiation that does not conform to the ABNF below, the recipient of such malformed data MUST immediately _Fail the WebSocket Connection_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Extensions |を含めることにより、クライアントは拡張機能をリクエストしますHTTPヘッダーフィールド（[RFC2616]、セクション4.2を参照）の通常のルールに従い、ヘッダーフィールドの値は、次のABNF [RFC2616]によって定義されます。このセクションでは、「暗黙の* LWSルール」を含む、[RFC2616]のABNF構文/ルールを使用していることに注意してください。以下のABNFに準拠していない値がネゴシエーション中にクライアントまたはサーバーによって受信された場合、そのような不正なデータの受信者は直ちに_WebSocket接続に失敗する必要があります_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Sec-WebSocket-Extensions = extension-list
         extension-list = 1#extension
         extension = extension-token *( &#34;;&#34; extension-param )
         extension-token = registered-token
         registered-token = token
         extension-param = token [ &#34;=&#34; (token | quoted-string) ]
             ;When using the quoted-string syntax variant, the value
             ;after quoted-string unescaping MUST conform to the
             ;&#39;token&#39; ABNF.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that like other HTTP header fields, this header field MAY be split or combined across multiple lines. Ergo, the following are equivalent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のHTTPヘッダーフィールドと同様に、このヘッダーフィールドは複数の行に分割または結合される場合があります。エルゴ、以下は同等です：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Sec-WebSocket-Extensions: foo
         Sec-WebSocket-Extensions: bar; baz=2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is exactly equivalent to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全に等しい
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Sec-WebSocket-Extensions: foo, bar; baz=2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any extension-token used MUST be a registered token (see Section 11.4). The parameters supplied with any given extension MUST be defined for that extension. Note that the client is only offering to use any advertised extensions and MUST NOT use them unless the server indicates that it wishes to use the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用される拡張トークンは、登録済みのトークンでなければなりません（セクション11.4を参照）。特定の拡張機能で提供されるパラメーターは、その拡張機能に対して定義する必要があります。クライアントはアドバタイズされた拡張機能の使用のみを提案しており、サーバーが拡張機能の使用を希望していることを示さない限り、それらを使用してはならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the order of extensions is significant. Any interactions between multiple extensions MAY be defined in the documents defining the extensions. In the absence of such definitions, the interpretation is that the header fields listed by the client in its request represent a preference of the header fields it wishes to use, with the first options listed being most preferable. The extensions listed by the server in response represent the extensions actually in use for the connection. Should the extensions modify the data and/or framing, the order of operations on the data should be assumed to be the same as the order in which the extensions are listed in the server&#39;s response in the opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張の順序は重要であることに注意してください。複数の拡張間の相互作用は、拡張を定義するドキュメントで定義される場合があります。そのような定義がない場合、解釈は、要求でクライアントによってリストされたヘッダーフィールドが、使用したいヘッダーフィールドの優先順位を表すとリストされた最初のオプションが最も好ましいと解釈されます。応答としてサーバーによってリストされる拡張機能は、接続に実際に使用されている拡張機能を表します。拡張機能がデータやフレーミングを変更する場合、データに対する操作の順序は、開始ハンドシェイクでのサーバーの応答に拡張機能がリストされている順序と同じであると想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if there are two extensions &#34;foo&#34; and &#34;bar&#34; and if the header field |Sec-WebSocket-Extensions| sent by the server has the value &#34;foo, bar&#34;, then operations on the data will be made as bar(foo(data)), be those changes to the data itself (such as compression) or changes to the framing that may &#34;stack&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、2つの拡張「foo」と「bar」があり、ヘッダーフィールドが| Sec-WebSocket-Extensions |である場合サーバーから送信された値が「foo、bar」の場合、データに対する操作はbar（foo（data））として行われ、データ自体への変更（圧縮など）、または「スタック&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-normative examples of acceptable extension header fields (note that long lines are folded for readability):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受け入れ可能な拡張ヘッダーフィールドの非規範的な例（読みやすいように長い行は折り返されています）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Sec-WebSocket-Extensions: deflate-stream
         Sec-WebSocket-Extensions: mux; max-channels=4; flow-control,
          deflate-stream
         Sec-WebSocket-Extensions: private-extension
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A server accepts one or more extensions by including a |Sec-WebSocket-Extensions| header field containing one or more extensions that were requested by the client. The interpretation of any extension parameters, and what constitutes a valid response by a server to a requested set of parameters by a client, will be defined by each such extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
| Sec-WebSocket-Extensions |を含めることにより、サーバーは1つ以上の拡張を受け入れます。クライアントによって要求された1つ以上の拡張を含むヘッダーフィールド。拡張パラメーターの解釈、およびクライアントが要求したパラメーターのセットに対するサーバーからの有効な応答を構成するものは、そのような各拡張によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Known Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 既知の拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extensions provide a mechanism for implementations to opt-in to additional protocol features. This document doesn&#39;t define any extension, but implementations MAY use extensions defined separately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張機能は、実装が追加のプロトコル機能をオプトインするためのメカニズムを提供します。このドキュメントでは拡張機能を定義していませんが、実装では個別に定義された拡張機能を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes some security considerations applicable to the WebSocket Protocol. Specific security considerations are described in subsections of this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、WebSocketプロトコルに適用可能なセキュリティの考慮事項について説明します。特定のセキュリティに関する考慮事項は、このセクションのサブセクションで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Non-Browser Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 非ブラウザクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WebSocket Protocol protects against malicious JavaScript running inside a trusted application such as a web browser, for example, by checking of the |Origin| header field (see below). See Section 1.6 for additional details. Such assumptions don&#39;t hold true in the case of a more-capable client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketプロトコルは、| Origin |のチェックなどにより、Webブラウザーなどの信頼できるアプリケーション内で実行される悪意のあるJavaScriptから保護します。ヘッダーフィールド（下記参照）。詳細については、セクション1.6を参照してください。このような仮定は、より能力のあるクライアントの場合には当てはまりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While this protocol is intended to be used by scripts in web pages, it can also be used directly by hosts. Such hosts are acting on their own behalf and can therefore send fake |Origin| header fields, misleading the server. Servers should therefore be careful about assuming that they are talking directly to scripts from known origins and must consider that they might be accessed in unexpected ways. In particular, a server should not trust that any input is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルはWebページのスクリプトで使用することを目的としていますが、ホストで直接使用することもできます。そのようなホストは自分自身に代わって行動しているため、偽の|送信元|を送信できます。ヘッダーフィールド、サーバーを誤解させる。したがって、サーバーは、既知のオリジンのスクリプトと直接通信していると想定する場合は注意が必要であり、予期しない方法でアクセスされる可能性があることを考慮する必要があります。特に、サーバーは入力が有効であることを信頼してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXAMPLE: If the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例：サーバーがSQLクエリの一部として入力を使用する場合、サーバーがSQLインジェクションの影響を受けないように、すべての入力テキストはSQLサーバーに渡される前にエスケープする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Origin Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 起源に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that are not intended to process input from any web page but only for certain sites SHOULD verify the |Origin| field is an origin they expect. If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Webページからの入力を処理することを目的としていないが、特定のサイトのみを対象とするサーバーは、| Origin |を検証する必要があります。フィールドは、彼らが期待する起源です。示されたオリジンがサーバーに受け入れられない場合、HTTP 403 Forbiddenステータスコードを含む応答でWebSocketハンドシェイクに応答する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The |Origin| header field protects from the attack cases when the untrusted party is typically the author of a JavaScript application that is executing in the context of the trusted client. The client itself can contact the server and, via the mechanism of the |Origin| header field, determine whether to extend those communication privileges to the JavaScript application. The intent is not to prevent non-browsers from establishing connections but rather to ensure that trusted browsers under the control of potentially malicious JavaScript cannot fake a WebSocket handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
|起源|ヘッダーフィールドは、信頼できない当事者が通常、信頼できるクライアントのコンテキストで実行されているJavaScriptアプリケーションの作成者である場合の攻撃ケースから保護します。クライアント自体はサーバーにアクセスでき、| Origin |のメカニズムを介してヘッダーフィールドで、これらの通信権限をJavaScriptアプリケーションに拡張するかどうかを決定します。その目的は、ブラウザー以外のユーザーが接続を確立できないようにすることではなく、悪意のあるJavaScriptの制御下にある信頼できるブラウザーがWebSocketハンドシェイクを偽造できないようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. Attacks On Infrastructure (Masking)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. インフラストラクチャへの攻撃（マスキング）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to endpoints being the target of attacks via WebSockets, other parts of web infrastructure, such as proxies, may be the subject of an attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントがWebSocketを介した攻撃の標的であることに加えて、プロキシなどのWebインフラストラクチャの他の部分が攻撃の対象になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As this protocol was being developed, an experiment was conducted to demonstrate a class of attacks on proxies that led to the poisoning of caching proxies deployed in the wild [TALKING]. The general form of the attack was to establish a connection to a server under the &#34;attacker&#39;s&#34; control, perform an UPGRADE on the HTTP connection similar to what the WebSocket Protocol does to establish a connection, and subsequently send data over that UPGRADEd connection that looked like a GET request for a specific known resource (which in an attack would likely be something like a widely deployed script for tracking hits or a resource on an ad-serving network). The remote server would respond with something that looked like a response to the fake GET request, and this response would be cached by a nonzero percentage of deployed intermediaries, thus poisoning the cache. The net effect of this attack would be that if a user could be convinced to visit a website the attacker controlled, the attacker could potentially poison the cache for that user and other users behind the same cache and run malicious script on other origins, compromising the web security model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルが開発されているときに、野生で展開されているキャッシングプロキシのポイズニングにつながるプロキシに対するクラスの攻撃を実証する実験が行われました[TALKING]。攻撃の一般的な形式は、「攻撃者」の制御下でサーバーへの接続を確立し、接続を確立するためにWebSocketプロトコルが行うのと同様にHTTP接続でUPGRADEを実行し、その後、そのUPGRADEされた接続を介してデータを送信しました。特定の既知のリソースに対するGETリクエストのようなものです（攻撃では、ヒットを追跡するために広く展開されているスクリプトや、広告配信ネットワーク上のリソースのようになります）。リモートサーバーは、偽のGET要求に対する応答のようなもので応答し、この応答は、配備された仲介者のゼロ以外のパーセンテージによってキャッシュされるため、キャッシュが汚染されます。この攻撃の正味の影響は、ユーザーが攻撃者が制御したWebサイトを訪問するように確信できた場合、攻撃者はそのユーザーと他のユーザーのキャッシュを同じキャッシュの背後で汚染し、他のオリジンで悪意のあるスクリプトを実行して、セキュリティを侵害する可能性があります。 Webセキュリティモデル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid such attacks on deployed intermediaries, it is not sufficient to prefix application-supplied data with framing that is not compliant with HTTP, as it is not possible to exhaustively discover and test that each nonconformant intermediary does not skip such non-HTTP framing and act incorrectly on the frame payload. Thus, the defense adopted is to mask all data from the client to the server, so that the remote script (attacker) does not have control over how the data being sent appears on the wire and thus cannot construct a message that could be misinterpreted by an intermediary as an HTTP request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
展開された仲介者へのこのような攻撃を回避するには、アプリケーションに提供されたデータにHTTPに準拠していないフレーミングをプレフィックスするだけでは不十分です。フレームペイロードに対して正しく動作しない。したがって、採用されている防御策は、クライアントからサーバーへのすべてのデータをマスクすることです。これにより、リモートスクリプト（攻撃者）は、送信されるデータがネットワーク上でどのように表示されるかを制御できず、メッセージが誤って解釈される可能性があります。 HTTPリクエストとしての仲介。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Clients MUST choose a new masking key for each frame, using an algorithm that cannot be predicted by end applications that provide data. For example, each masking could be drawn from a cryptographically strong random number generator. If the same key is used or a decipherable pattern exists for how the next key is chosen, the attacker can send a message that, when masked, could appear to be an HTTP request (by taking the message the attacker wishes to see on the wire and masking it with the next masking key to be used, the masking key will effectively unmask the data when the client applies it).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントは、データを提供するエンドアプリケーションによって予測できないアルゴリズムを使用して、各フレームの新しいマスキングキーを選択する必要があります。たとえば、各マスキングは、暗号学的に強力な乱数ジェネレータから取得できます。同じキーが使用されている場合、または次のキーの選択方法に解読可能なパターンが存在する場合、攻撃者はマスクされている場合、HTTPリクエストのように見えるメッセージを送信できます（攻撃者がネットワーク上で見たいメッセージを取得することにより）使用する次のマスキングキーでマスキングすると、マスキングキーは、クライアントがデータを適用するときにデータのマスクを実質的に解除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also necessary that once the transmission of a frame from a client has begun, the payload (application-supplied data) of that frame must not be capable of being modified by the application. Otherwise, an attacker could send a long frame where the initial data was a known value (such as all zeros), compute the masking key being used upon receipt of the first part of the data, and then modify the data that is yet to be sent in the frame to appear as an HTTP request when masked. (This is essentially the same problem described in the previous paragraph with using a known or predictable masking key.) If additional data is to be sent or data to be sent is somehow changed, that new or changed data must be sent in a new frame and thus with a new masking key. In short, once transmission of a frame begins, the contents must not be modifiable by the remote script (application).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、クライアントからのフレームの送信が開始されると、そのフレームのペイロード（アプリケーションが提供するデータ）がアプリケーションによって変更されないようにする必要があります。それ以外の場合、攻撃者は初期データが既知の値（すべてゼロなど）である長いフレームを送信し、データの最初の部分の受信時に使用されているマスキングキーを計算してから、まだ作成されていないデータを変更する可能性があります。フレームで送信され、マスクされたときにHTTPリクエストとして表示されます。 （これは基本的に、前の段落で説明した既知または予測可能なマスキングキーを使用した場合と同じ問題です。）追加のデータを送信する場合、または送信するデータを変更する場合は、新しいデータまたは変更したデータを新しいフレームで送信する必要があります。したがって、新しいマスキングキーを使用します。つまり、フレームの送信が開始されると、コンテンツはリモートスクリプト（アプリケーション）によって変更可能であってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The threat model being protected against is one in which the client sends data that appears to be an HTTP request. As such, the channel that needs to be masked is the data from the client to the server. The data from the server to the client can be made to look like a response, but to accomplish this request, the client must also be able to forge a request. As such, it was not deemed necessary to mask data in both directions (the data from the server to the client is not masked).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保護対象の脅威モデルは、クライアントがHTTPリクエストのように見えるデータを送信する脅威モデルです。そのため、マスクする必要があるチャネルは、クライアントからサーバーへのデータです。サーバーからクライアントへのデータを応答のように見せることができますが、この要求を実行するには、クライアントも要求を偽造できる必要があります。そのため、双方向でデータをマスクする必要はないと考えられました（サーバーからクライアントへのデータはマスクされません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Despite the protection provided by masking, non-compliant HTTP proxies will still be vulnerable to poisoning attacks of this type by clients and servers that do not apply masking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスキングによる保護にもかかわらず、非準拠のHTTPプロキシは、マスキングを適用しないクライアントおよびサーバーによるこのタイプのポイズニング攻撃に対して依然として脆弱です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. Implementation-Specific Limits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. 実装固有の制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations that have implementation- and/or platform-specific limitations regarding the frame size or total message size after reassembly from multiple frames MUST protect themselves against exceeding those limits. (For example, a malicious endpoint can try to exhaust its peer&#39;s memory or mount a denial-of-service attack by sending either a single big frame (e.g., of size 2**60) or by sending a long stream of small frames that are a part of a fragmented message.) Such an implementation SHOULD impose a limit on frame sizes and the total message size after reassembly from multiple frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のフレームからの再構成後のフレームサイズまたはメッセージの合計サイズに関して、実装またはプラットフォーム固有の制限がある実装は、それらの制限を超えないように保護する必要があります。 （たとえば、悪意のあるエンドポイントは、単一の大きなフレーム（たとえば、サイズ2 ** 60）を送信するか、小さなフレームの長いストリームを送信することによって、ピアのメモリを使い果たしたり、サービス拒否攻撃を仕掛けたりすることができます。は断片化されたメッセージの一部です。）このような実装では、複数のフレームから再構成した後のフレームサイズと合計メッセージサイズに制限を課す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. WebSocket Client Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. WebSocketクライアント認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protocol doesn&#39;t prescribe any particular way that servers can authenticate clients during the WebSocket handshake. The WebSocket server can use any client authentication mechanism available to a generic HTTP server, such as cookies, HTTP authentication, or TLS authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、サーバーがWebSocketハンドシェイク中にクライアントを認証できる特定の方法を規定していません。 WebSocketサーバーは、Cookie、HTTP認証、TLS認証など、一般的なHTTPサーバーが使用できる任意のクライアント認証メカニズムを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. Connection Confidentiality and Integrity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. 接続の機密性と整合性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connection confidentiality and integrity is provided by running the WebSocket Protocol over TLS (wss URIs). WebSocket implementations MUST support TLS and SHOULD employ it when communicating with their peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続の機密性と整合性は、TLS（wss URI）を介してWebSocketプロトコルを実行することによって提供されます。 WebSocket実装はTLSをサポートしなければならず（MUST）、ピアと通信するときにTLSを使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For connections using TLS, the amount of benefit provided by TLS depends greatly on the strength of the algorithms negotiated during the TLS handshake. For example, some TLS cipher mechanisms don&#39;t provide connection confidentiality. To achieve reasonable levels of protection, clients should use only Strong TLS algorithms. &#34;Web Security Context: User Interface Guidelines&#34; [W3C.REC-wsc-ui-20100812] discusses what constitutes Strong TLS algorithms. [RFC5246] provides additional guidance in Appendix A.5 and Appendix D.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSを使用する接続の場合、TLSによって提供される利点の量は、TLSハンドシェイク中にネゴシエートされるアルゴリズムの強度に大きく依存します。たとえば、一部のTLS暗号化メカニズムは接続の機密性を提供しません。妥当なレベルの保護を実現するには、クライアントは強力なTLSアルゴリズムのみを使用する必要があります。 「Webセキュリティコンテキスト：ユーザーインターフェイスガイドライン」[W3C.REC-wsc-ui-20100812]では、強力なTLSアルゴリズムの構成要素について説明しています。 [RFC5246]は、付録A.5および付録D.3に追加のガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. Handling of Invalid Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. 無効なデータの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Incoming data MUST always be validated by both clients and servers. If, at any time, an endpoint is faced with data that it does not understand or that violates some criteria by which the endpoint determines safety of input, or when the endpoint sees an opening handshake that does not correspond to the values it is expecting (e.g., incorrect path or origin in the client request), the endpoint MAY drop the TCP connection. If the invalid data was received after a successful WebSocket handshake, the endpoint SHOULD send a Close frame with an appropriate status code (Section 7.4) before proceeding to _Close the WebSocket Connection_. Use of a Close frame with an appropriate status code can help in diagnosing the problem. If the invalid data is sent during the WebSocket handshake, the server SHOULD return an appropriate HTTP [RFC2616] status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信データは常にクライアントとサーバーの両方で検証される必要があります。いつでも、エンドポイントが理解できない、またはエンドポイントが入力の安全性を決定するいくつかの基準に違反するデータに直面している場合、またはエンドポイントが予期している値に対応しない開始ハンドシェイクを見つけた場合（たとえば、クライアントリクエストのパスまたはオリジンが正しくない場合）、エンドポイントはTCP接続をドロップする場合があります。 WebSocketハンドシェイクが成功した後に無効なデータが受信された場合、エンドポイントは、_WebSocket接続を閉じる_に進む前に、適切なステータスコード（セクション7.4）を含むCloseフレームを送信する必要があります（SHOULD）。適切なステータスコードを含むCloseフレームを使用すると、問題の診断に役立ちます。 WebSocketハンドシェイク中に無効なデータが送信された場合、サーバーは適切なHTTP [RFC2616]ステータスコードを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A common class of security problems arises when sending text data using the wrong encoding. This protocol specifies that messages with a Text data type (as opposed to Binary or other types) contain UTF-8- encoded data. Although the length is still indicated and applications implementing this protocol should use the length to determine where the frame actually ends, sending data in an improper encoding may still break assumptions that applications built on top of this protocol may make, leading to anything from misinterpretation of data to loss of data or potential security bugs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
間違ったエンコーディングを使用してテキストデータを送信すると、セキュリティ問題の一般的なクラスが発生します。このプロトコルは、（バイナリまたは他のタイプではなく）テキストデータタイプのメッセージにUTF-8でエンコードされたデータが含まれることを指定します。長さは引き続き示され、このプロトコルを実装するアプリケーションは長さを使用してフレームが実際に終了する場所を決定する必要がありますが、不適切なエンコーディングでデータを送信すると、このプロトコルの上に構築されたアプリケーションが行う可能性のある仮定が依然として破られ、誤解の原因となる可能性がありますデータ損失または潜在的なセキュリティバグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. Use of SHA-1 by the WebSocket Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. WebSocketハンドシェイクによるSHA-1の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WebSocket handshake described in this document doesn&#39;t depend on any security properties of SHA-1, such as collision resistance or resistance to the second pre-image attack (as described in [RFC4270]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで説明されているWebSocketハンドシェイクは、SHA-1のセキュリティプロパティ（衝突耐性や2番目のプリイメージ攻撃への耐性など）に依存していません（[RFC4270]で説明されています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Registration of New URI Schemes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. 新しいURIスキームの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. Registration of &#34;ws&#34; Scheme
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. 「ws」スキームの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A |ws| URI identifies a WebSocket server and resource name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A | ws | URIはWebSocketサーバーとリソース名を識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI scheme name ws
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキーム名ws
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status Permanent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス永久
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI scheme syntax Using the ABNF [RFC5234] syntax and ABNF terminals from the URI specification [RFC3986]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキーム構文ABNF [RFC5234]構文とURI仕様[RFC3986]のABNF端子を使用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           &#34;ws:&#34; &#34;//&#34; authority path-abempty [ &#34;?&#34; query ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &lt;path-abempty&gt; and &lt;query&gt; [RFC3986] components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in [RFC3986].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;path-abempty&gt;および&lt;query&gt; [RFC3986]コンポーネントは、サーバーに送信されるリソース名を形成して、必要なサービスの種類を識別します。他のコンポーネントは、[RFC3986]で説明されている意味を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI scheme semantics The only operation for this scheme is to open a connection using the WebSocket Protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキームのセマンティクスこのスキームの唯一の操作は、WebSocketプロトコルを使用して接続を開くことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding considerations Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in [RFC3987] or its replacement. For the purposes of scheme-based normalization, Internationalized Domain Name (IDN) forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of [RFC3987]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコードに関する考慮事項上記で定義された構文によって除外されたホストコンポーネントの文字は、[RFC3987]またはその置換で指定されているように、UnicodeからASCIIに変換する必要があります。スキームに基づく正規化の目的で、ホストコンポーネントの国際化ドメイン名（IDN）形式とそれらのpunycodeへの変換は同等と見なされます（[RFC3987]のセクション5.3.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI [RFC3986] and Internationalized Resource Identifier (IRI) [RFC3987] specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
上記で定義された構文で除外されている他のコンポーネントの文字は、最初に文字をUTF-8としてエンコードし、次にURI [RFC3986]および国際化で定義されているパーセントエンコード形式を使用して対応するバイトを置き換えることにより、UnicodeからASCIIに変換する必要があります。リソース識別子（IRI）[RFC3987]仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications/protocols that use this URI scheme name WebSocket Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このURIスキーム名を使用するアプリケーション/プロトコルWebSocketプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interoperability considerations Use of WebSocket requires use of HTTP version 1.1 or higher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相互運用性に関する考慮事項WebSocketを使用するには、HTTPバージョン1.1以降を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security considerations See &#34;Security Considerations&#34; section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティに関する考慮事項「セキュリティに関する考慮事項」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contact HYBI WG &lt;hybi@ietf.org&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HYBI WG &lt;hybi@ietf.org&gt;に連絡する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Author/Change controller
      IETF &lt;iesg@ietf.org&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
References RFC 6455
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6455を参照
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2. Registration of &#34;wss&#34; Scheme
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2. 「wss」スキームの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A |wss| URI identifies a WebSocket server and resource name and indicates that traffic over that connection is to be protected via TLS (including standard benefits of TLS such as data confidentiality and integrity and endpoint authentication).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A | wss | URIはWebSocketサーバーとリソース名を識別し、その接続上のトラフィックがTLSを介して保護されることを示します（データの機密性と整合性、エンドポイント認証などのTLSの標準的な利点を含みます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI scheme name wss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキーム名wss
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status Permanent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス永久
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI scheme syntax Using the ABNF [RFC5234] syntax and ABNF terminals from the URI specification [RFC3986]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキーム構文ABNF [RFC5234]構文とURI仕様[RFC3986]のABNF端子を使用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           &#34;wss:&#34; &#34;//&#34; authority path-abempty [ &#34;?&#34; query ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &lt;path-abempty&gt; and &lt;query&gt; components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in [RFC3986].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;path-abempty&gt;および&lt;query&gt;コンポーネントは、目的のサービスの種類を識別するためにサーバーに送信されるリソース名を形成します。他のコンポーネントは、[RFC3986]で説明されている意味を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI scheme semantics The only operation for this scheme is to open a connection using the WebSocket Protocol, encrypted using TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキームのセマンティクスこのスキームの唯一の操作は、TLSを使用して暗号化されたWebSocketプロトコルを使用して接続を開くことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding considerations Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in [RFC3987] or its replacement. For the purposes of scheme-based normalization IDN forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of [RFC3987]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコードに関する考慮事項上記で定義された構文によって除外されたホストコンポーネントの文字は、[RFC3987]またはその置換で指定されているように、UnicodeからASCIIに変換する必要があります。ホストコンポーネントのスキームベースの正規化IDN形式とそれらのpunycodeへの変換は、同等と見なされます（[RFC3987]のセクション5.3.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI [RFC3986] and IRI [RFC3987] specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
上記で定義された構文で除外されている他のコンポーネントの文字は、最初に文字をUTF-8としてエンコードし、次にURI [RFC3986]およびIRIで定義されているパーセントエンコード形式を使用して対応するバイトを置き換えることにより、UnicodeからASCIIに変換する必要があります。 [RFC3987]仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications/protocols that use this URI scheme name WebSocket Protocol over TLS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このURIスキーム名を使用するアプリケーション/プロトコルTLS経由のWebSocketプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interoperability considerations Use of WebSocket requires use of HTTP version 1.1 or higher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相互運用性に関する考慮事項WebSocketを使用するには、HTTPバージョン1.1以降を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security considerations See &#34;Security Considerations&#34; section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティに関する考慮事項「セキュリティに関する考慮事項」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contact HYBI WG &lt;hybi@ietf.org&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HYBI WG &lt;hybi@ietf.org&gt;に連絡する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Author/Change controller
      IETF &lt;iesg@ietf.org&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
References RFC 6455
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6455を参照
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Registration of the &#34;WebSocket&#34; HTTP Upgrade Keyword
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 「WebSocket」HTTPアップグレードキーワードの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines a keyword registered in the HTTP Upgrade Tokens Registry as per RFC 2817 [RFC2817].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、RFC 2817 [RFC2817]に従って、HTTPアップグレードトークンレジストリに登録されているキーワードを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name of token WebSocket
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンWebSocketの名前
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Author/Change controller
      IETF &lt;iesg@ietf.org&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contact HYBI &lt;hybi@ietf.org&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HYBI &lt;hybi@ietf.org&gt;に連絡する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
References RFC 6455
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6455を参照
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Registration of New HTTP Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. 新しいHTTPヘッダーフィールドの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. Sec-WebSocket-Key
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. Sec-WebSocket-Key
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、Permanent Message Header Field Namesレジストリ[RFC3864]に登録されているヘッダーフィールドについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header field name Sec-WebSocket-Key
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールド名Sec-WebSocket-Key
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applicable protocol http
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
該当プロトコルhttp
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status standard
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス基準
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author/Change controller IETF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者/変更コントローラーIETF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specification document(s) RFC 6455
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様書RFC 6455
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Related information This header field is only used for WebSocket opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連情報このヘッダーフィールドは、WebSocketオープニングハンドシェイクにのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Key| header field is used in the WebSocket opening handshake. It is sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket opening handshake. This helps ensure that the server does not accept connections from non-WebSocket clients (e.g., HTTP clients) that are being abused to send data to unsuspecting WebSocket servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Key |ヘッダーフィールドは、WebSocketオープニングハンドシェイクで使用されます。クライアントからサーバーに送信され、サーバーが使用する情報の一部を提供して、有効なWebSocketオープンハンドシェイクを受信したことを証明します。これにより、不正なWebSocketサーバーにデータを送信するために悪用されている非WebSocketクライアント（HTTPクライアントなど）からの接続をサーバーが受け入れないようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Key| header field MUST NOT appear more than once in an HTTP request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Key |ヘッダーフィールドは、HTTPリクエストで複数回使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.2. Sec-WebSocket-Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.2. Sec-WebSocket-Extensions
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes a header field for registration in the Permanent Message Header Field Names registry [RFC3864].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、Permanent Message Header Field Namesレジストリ[RFC3864]に登録するためのヘッダーフィールドについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header field name Sec-WebSocket-Extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールド名Sec-WebSocket-Extensions
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applicable protocol http
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
該当プロトコルhttp
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status standard
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス基準
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author/Change controller IETF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者/変更コントローラーIETF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specification document(s) RFC 6455
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様書RFC 6455
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Related information This header field is only used for WebSocket opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連情報このヘッダーフィールドは、WebSocketオープニングハンドシェイクにのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Extensions| header field is used in the WebSocket opening handshake. It is initially sent from the client to the server, and then subsequently sent from the server to the client, to agree on a set of protocol-level extensions to use for the duration of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Extensions |ヘッダーフィールドは、WebSocketオープニングハンドシェイクで使用されます。これは、最初にクライアントからサーバーに送信され、次にサーバーからクライアントに送信されて、接続期間中に使用する一連のプロトコルレベルの拡張機能について合意します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Extensions| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Extensions| header field that contains all values. However, the |Sec-WebSocket-Extensions| header field MUST NOT appear more than once in an HTTP response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Extensions |ヘッダーフィールドは、HTTPリクエストで複数回表示される場合があります（これは、すべての値を含む単一の| Sec-WebSocket-Extensions |ヘッダーフィールドと論理的に同じです。ただし、| Sec-WebSocket-Extensions |ヘッダーフィールドは、 HTTP応答で1回。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.3. Sec-WebSocket-Accept
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.3. Sec-WebSocket-Accept
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、Permanent Message Header Field Namesレジストリ[RFC3864]に登録されているヘッダーフィールドについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header field name Sec-WebSocket-Accept
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールド名Sec-WebSocket-Accept
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applicable protocol http
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
該当プロトコルhttp
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status standard
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス基準
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author/Change controller IETF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者/変更コントローラーIETF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specification document(s) RFC 6455
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様書RFC 6455
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Related information This header field is only used for the WebSocket opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連情報このヘッダーフィールドは、WebSocketオープニングハンドシェイクにのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Accept| header field is used in the WebSocket opening handshake. It is sent from the server to the client to confirm that the server is willing to initiate the WebSocket connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Accept |ヘッダーフィールドは、WebSocketオープニングハンドシェイクで使用されます。サーバーからクライアントに送信され、サーバーがWebSocket接続を開始する意思があることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Accept| header MUST NOT appear more than once in an HTTP response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Accept |ヘッダーは、HTTP応答に複数回出現してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.4. Sec-WebSocket-Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.4. Sec-WebSocket-Protocol
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、Permanent Message Header Field Namesレジストリ[RFC3864]に登録されているヘッダーフィールドについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header field name Sec-WebSocket-Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールド名Sec-WebSocket-Protocol
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applicable protocol http
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
該当プロトコルhttp
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status standard
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス基準
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author/Change controller IETF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者/変更コントローラーIETF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specification document(s) RFC 6455
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様書RFC 6455
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Related information This header field is only used for the WebSocket opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連情報このヘッダーフィールドは、WebSocketオープニングハンドシェイクにのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Protocol| header field is used in the WebSocket opening handshake. It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection. This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Protocol |ヘッダーフィールドは、WebSocketオープニングハンドシェイクで使用されます。接続のサブプロトコルを確認するために、クライアントからサーバーに送信され、サーバーからクライアントに返されます。これにより、スクリプトはサブプロトコルを選択し、サーバーがそのサブプロトコルを提供することに同意したことを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Protocol| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Protocol| header field that contains all values). However, the |Sec-WebSocket-Protocol| header field MUST NOT appear more than once in an HTTP response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Protocol |ヘッダーフィールドは、HTTPリクエストで複数回表示される場合があります（すべての値を含む単一の| Sec-WebSocket-Protocol |ヘッダーフィールドと論理的に同じです）。ただし、| Sec-WebSocket-Protocol |ヘッダーフィールドは、HTTP応答で複数回出現してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.5. Sec-WebSocket-Version
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.5. Sec-WebSocket-Version
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、Permanent Message Header Field Namesレジストリ[RFC3864]に登録されているヘッダーフィールドについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header field name Sec-WebSocket-Version
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールド名Sec-WebSocket-Version
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applicable protocol http
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
該当プロトコルhttp
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status standard
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス基準
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author/Change controller IETF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者/変更コントローラーIETF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specification document(s) RFC 6455
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様書RFC 6455
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Related information This header field is only used for the WebSocket opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連情報このヘッダーフィールドは、WebSocketオープニングハンドシェイクにのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Version| header field is used in the WebSocket opening handshake. It is sent from the client to the server to indicate the protocol version of the connection. This enables servers to correctly interpret the opening handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner. The |Sec-WebSocket-Version| header field is also sent from the server to the client on WebSocket handshake error, when the version received from the client does not match a version understood by the server. In such a case, the header field includes the protocol version(s) supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Version |ヘッダーフィールドは、WebSocketオープニングハンドシェイクで使用されます。クライアントからサーバーに送信され、接続のプロトコルバージョンを示します。これにより、サーバーはデータから送信される開始ハンドシェイクと後続のデータを正しく解釈し、サーバーがそのデータを安全な方法で解釈できない場合は接続を閉じることができます。 | Sec-WebSocket-Version |クライアントから受信したバージョンがサーバーによって認識されるバージョンと一致しない場合、WebSocketハンドシェイクエラー時にヘッダーフィールドもサーバーからクライアントに送信されます。このような場合、ヘッダーフィールドには、サーバーでサポートされているプロトコルバージョンが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there is no expectation that higher version numbers are necessarily backward compatible with lower version numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高いバージョン番号が必ずしも低いバージョン番号と下位互換性があるとは期待されていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The |Sec-WebSocket-Version| header field MAY appear multiple times in an HTTP response (which is logically the same as a single |Sec-WebSocket-Version| header field that contains all values). However, the |Sec-WebSocket-Version| header field MUST NOT appear more than once in an HTTP request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
| Sec-WebSocket-Version |ヘッダーフィールドは、HTTP応答に複数回表示される場合があります（すべての値を含む単一の| Sec-WebSocket-Version |ヘッダーフィールドと論理的に同じです）。ただし、| Sec-WebSocket-Version |ヘッダーフィールドは、HTTPリクエストで複数回使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. WebSocket Extension Name Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. WebSocket拡張名レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification creates a new IANA registry for WebSocket Extension names to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、RFC 5226 [RFC5226]で規定されている原則に従って、WebSocketプロトコルで使用されるWebSocket拡張機能名の新しいIANAレジストリを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As part of this registry, IANA maintains the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このレジストリの一部として、IANAは次の情報を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extension Identifier The identifier of the extension, as will be used in the |Sec-WebSocket-Extensions| header field registered in Section 11.3.2 of this specification. The value must conform to the requirements for an extension-token as defined in Section 9.1 of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張識別子| Sec-WebSocket-Extensions |で使用される拡張の識別子この仕様のセクション11.3.2に登録されているヘッダーフィールド。この値は、この仕様のセクション9.1で定義されている拡張トークンの要件に準拠している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extension Common Name The name of the extension, as the extension is generally referred to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張機能の共通名拡張機能が一般的に参照されるため、拡張機能の名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extension Definition A reference to the document in which the extension being used with the WebSocket Protocol is defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張定義WebSocketプロトコルで使用されている拡張が定義されているドキュメントへの参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Known Incompatible Extensions A list of extension identifiers with which this extension is known to be incompatible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既知の互換性のない拡張機能この拡張機能に互換性がないことがわかっている拡張機能識別子のリスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket Extension names are to be subject to the &#34;First Come First Served&#34; IANA registration policy [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket拡張機能の名前は、「先着順」のIANA登録ポリシー[RFC5226]の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are no initial values in this registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このレジストリには初期値はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5. WebSocket Subprotocol Name Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5. WebSocketサブプロトコル名レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification creates a new IANA registry for WebSocket Subprotocol names to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、RFC 5226 [RFC5226]に規定されている原則に従って、WebSocketプロトコルで使用されるWebSocketサブプロトコル名の新しいIANAレジストリを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As part of this registry, IANA maintains the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このレジストリの一部として、IANAは次の情報を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subprotocol Identifier The identifier of the subprotocol, as will be used in the |Sec-WebSocket-Protocol| header field registered in Section 11.3.4 of this specification. The value must conform to the requirements given in item 10 of Section 4.1 of this specification -- namely, the value must be a token as defined by RFC 2616 [RFC2616].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
|サブプロトコルID | Sec-WebSocket-Protocol |で使用されるサブプロトコルのIDこの仕様のセクション11.3.4に登録されているヘッダーフィールド。値は、この仕様のセクション4.1の項目10で指定された要件に準拠する必要があります。つまり、値はRFC 2616 [RFC2616]で定義されているトークンでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subprotocol Common Name The name of the subprotocol, as the subprotocol is generally referred to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブプロトコルの共通名サブプロトコルは一般的に参照されるため、サブプロトコルの名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subprotocol Definition A reference to the document in which the subprotocol being used with the WebSocket Protocol is defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブプロトコル定義WebSocketプロトコルで使用されるサブプロトコルが定義されているドキュメントへの参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket Subprotocol names are to be subject to the &#34;First Come First Served&#34; IANA registration policy [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketサブプロトコル名は、「先着順」IANA登録ポリシー[RFC5226]の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.6. WebSocket Version Number Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.6. WebSocketバージョン番号レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification creates a new IANA registry for WebSocket Version Numbers to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、RFC 5226 [RFC5226]で規定されている原則に従って、WebSocketプロトコルで使用されるWebSocketバージョン番号の新しいIANAレジストリを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As part of this registry, IANA maintains the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このレジストリの一部として、IANAは次の情報を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Version Number The version number to be used in the |Sec-WebSocket-Version| is specified in Section 4.1 of this specification. The value must be a non-negative integer in the range between 0 and 255 (inclusive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン番号| Sec-WebSocket-Version |で使用されるバージョン番号この仕様のセクション4.1で指定されています。値は0〜255の範囲の負でない整数である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reference The RFC requesting a new version number or a draft name with version number (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照新しいバージョン番号またはバージョン番号付きのドラフト名を要求するRFC（以下を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status Either &#34;Interim&#34; or &#34;Standard&#34;. See below for description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス「暫定」または「標準」のいずれか。説明については、以下を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A version number is designated as either &#34;Interim&#34; or &#34;Standard&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン番号は、「暫定」または「標準」として指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A &#34;Standard&#34; version number is documented in an RFC and used to identify a major, stable version of the WebSocket protocol, such as the version defined by this RFC. &#34;Standard&#34; version numbers are subject to the &#34;IETF Review&#34; IANA registration policy [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「標準」バージョン番号はRFCに記載されており、このRFCで定義されているバージョンなど、WebSocketプロトコルのメジャーで安定したバージョンを識別するために使用されます。 「標準」バージョン番号は、「IETFレビュー」IANA登録ポリシー[RFC5226]の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An &#34;Interim&#34; version number is documented in an Internet-Draft and used to help implementors identify and interoperate with deployed versions of the WebSocket protocol, such as versions developed before the publication of this RFC. &#34;Interim&#34; version numbers are subject to the &#34;Expert Review&#34; IANA registration policy [RFC5226], with the chairs of the HYBI Working Group (or, if the working group closes, the Area Directors for the IETF Applications Area) being the initial Designated Experts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「暫定」バージョン番号はInternet-Draftに記載されており、このRFCの公開前に開発されたバージョンなど、WebSocketプロトコルのデプロイされたバージョンを実装者が識別して相互運用するのに役立ちます。 「暫定」バージョン番号は、「エキスパートレビュー」IANA登録ポリシー[RFC5226]の対象となり、HYBIワーキンググループの議長（または、ワーキンググループが閉会する場合は、IETFアプリケーションエリアのエリアディレクター）が最初に指定されます専門家。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has added initial values to the registry as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、次のようにレジストリに初期値を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+-----------------------------------------+----------+
   |Version |                Reference                |  Status  |
   | Number |                                         |          |
   +--------+-----------------------------------------+----------+
   | 0      + draft-ietf-hybi-thewebsocketprotocol-00 | Interim  |
   +--------+-----------------------------------------+----------+
   | 1      + draft-ietf-hybi-thewebsocketprotocol-01 | Interim  |
   +--------+-----------------------------------------+----------+
   | 2      + draft-ietf-hybi-thewebsocketprotocol-02 | Interim  |
   +--------+-----------------------------------------+----------+
   | 3      + draft-ietf-hybi-thewebsocketprotocol-03 | Interim  |
   +--------+-----------------------------------------+----------+
   | 4      + draft-ietf-hybi-thewebsocketprotocol-04 | Interim  |
   +--------+-----------------------------------------+----------+
   | 5      + draft-ietf-hybi-thewebsocketprotocol-05 | Interim  |
   +--------+-----------------------------------------+----------+
   | 6      + draft-ietf-hybi-thewebsocketprotocol-06 | Interim  |
   +--------+-----------------------------------------+----------+
   | 7      + draft-ietf-hybi-thewebsocketprotocol-07 | Interim  |
   +--------+-----------------------------------------+----------+
   | 8      + draft-ietf-hybi-thewebsocketprotocol-08 | Interim  |
   +--------+-----------------------------------------+----------+
   | 9      +                Reserved                 |          |
   +--------+-----------------------------------------+----------+
   | 10     +                Reserved                 |          |
   +--------+-----------------------------------------+----------+
   | 11     +                Reserved                 |          |
   +--------+-----------------------------------------+----------+
   | 12     +                Reserved                 |          |
   +--------+-----------------------------------------+----------+
   | 13     +                RFC 6455                 | Standard |
   +--------+-----------------------------------------+----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7. WebSocket Close Code Number Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7. WebSocketクローズコード番号レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification creates a new IANA registry for WebSocket Connection Close Code Numbers in accordance with the principles set out in RFC 5226 [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、RFC 5226 [RFC5226]で規定されている原則に従って、WebSocket接続クローズコード番号の新しいIANAレジストリを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As part of this registry, IANA maintains the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このレジストリの一部として、IANAは次の情報を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status Code The Status Code denotes a reason for a WebSocket connection closure as per Section 7.4 of this document. The status code is an integer number between 1000 and 4999 (inclusive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータスコードステータスコードは、このドキュメントのセクション7.4に従って、WebSocket接続が閉じられる理由を示します。ステータスコードは、1000〜4999の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning The meaning of the status code. Each status code has to have a unique meaning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意味ステータスコードの意味。各ステータスコードには固有の意味が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contact A contact for the entity reserving the status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
連絡先ステータスコードを予約するエンティティの連絡先。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reference The stable document requesting the status codes and defining their meaning. This is required for status codes in the range 1000-2999 and recommended for status codes in the range 3000-3999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照ステータスコードを要求し、その意味を定義する安定したドキュメント。これは、1000〜2999の範囲のステータスコードに必要で、3000〜3999の範囲のステータスコードに推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket Close Code Numbers are subject to different registration requirements depending on their range. Requests for status codes for use by this protocol and its subsequent versions or extensions are subject to any one of the &#34;Standards Action&#34;, &#34;Specification Required&#34; (which implies &#34;Designated Expert&#34;), or &#34;IESG Review&#34; IANA registration policies and should be granted in the range 1000-2999. Requests for status codes for use by libraries, frameworks, and applications are subject to the &#34;First Come First Served&#34; IANA registration policy and should be granted in the range 3000-3999. The range of status codes from 4000-4999 is designated for Private Use. Requests should indicate whether they are requesting status codes for use by the WebSocket Protocol (or a future version of the protocol), by extensions, or by libraries/frameworks/applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketクローズコード番号は、その範囲に応じて異なる登録要件の対象となります。このプロトコルとその後続のバージョンまたは拡張機能で使用するステータスコードの要求は、「標準アクション」、「必要な仕様」（「指定エキスパート」を意味する）、または「IESGレビュー」IANA登録ポリシーのいずれかに従い、 1000〜2999の範囲で付与されます。ライブラリ、フレームワーク、およびアプリケーションで使用するステータスコードのリクエストには、「先着順」のIANA登録ポリシーが適用され、3000〜3999の範囲で付与する必要があります。 4000〜4999のステータスコードの範囲は、私的使用に指定されています。リクエストは、WebSocketプロトコル（またはプロトコルの将来のバージョン）、拡張機能、またはライブラリー/フレームワーク/アプリケーションによって使用されるステータスコードを要求しているかどうかを示す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has added initial values to the registry as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、次のようにレジストリに初期値を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     |Status Code | Meaning         | Contact       | Reference |
    -+------------+-----------------+---------------+-----------|
     | 1000       | Normal Closure  | hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1001       | Going Away      | hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1002       | Protocol error  | hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1003       | Unsupported Data| hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1004       | ---Reserved---- | hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1005       | No Status Rcvd  | hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1006       | Abnormal Closure| hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1007       | Invalid frame   | hybi@ietf.org | RFC 6455  |
     |            | payload data    |               |           |
    -+------------+-----------------+---------------+-----------|
     | 1008       | Policy Violation| hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1009       | Message Too Big | hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1010       | Mandatory Ext.  | hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
     | 1011       | Internal Server | hybi@ietf.org | RFC 6455  |
     |            | Error           |               |           |
    -+------------+-----------------+---------------+-----------|
     | 1015       | TLS handshake   | hybi@ietf.org | RFC 6455  |
    -+------------+-----------------+---------------+-----------|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.8. WebSocket Opcode Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.8. WebSocket Opcodeレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification creates a new IANA registry for WebSocket Opcodes in accordance with the principles set out in RFC 5226 [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、RFC 5226 [RFC5226]で規定されている原則に従って、WebSocket Opcodeの新しいIANAレジストリを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As part of this registry, IANA maintains the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このレジストリの一部として、IANAは次の情報を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Opcode The opcode denotes the frame type of the WebSocket frame, as defined in Section 5.2. The opcode is an integer number between 0 and 15, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペコードオペコードは、セクション5.2で定義されているように、WebSocketフレームのフレームタイプを示します。オペコードは、0から15までの整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning The meaning of the opcode value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意味オペコード値の意味。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reference The specification requesting the opcode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照オペコードを要求する仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket Opcode numbers are subject to the &#34;Standards Action&#34; IANA registration policy [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket Opcode番号は、「標準アクション」IANA登録ポリシー[RFC5226]の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has added initial values to the registry as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、次のようにレジストリに初期値を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     |Opcode  | Meaning                             | Reference |
    -+--------+-------------------------------------+-----------|
     | 0      | Continuation Frame                  | RFC 6455  |
    -+--------+-------------------------------------+-----------|
     | 1      | Text Frame                          | RFC 6455  |
    -+--------+-------------------------------------+-----------|
     | 2      | Binary Frame                        | RFC 6455  |
    -+--------+-------------------------------------+-----------|
     | 8      | Connection Close Frame              | RFC 6455  |
    -+--------+-------------------------------------+-----------|
     | 9      | Ping Frame                          | RFC 6455  |
    -+--------+-------------------------------------+-----------|
     | 10     | Pong Frame                          | RFC 6455  |
    -+--------+-------------------------------------+-----------|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.9. WebSocket Framing Header Bits Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.9. WebSocketフレーミングヘッダービットレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification creates a new IANA registry for WebSocket Framing Header Bits in accordance with the principles set out in RFC 5226 [RFC5226]. This registry controls assignment of the bits marked RSV1, RSV2, and RSV3 in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、RFC 5226 [RFC5226]で規定されている原則に従って、WebSocketフレーミングヘッダービット用の新しいIANAレジストリを作成します。このレジストリは、セクション5.2でRSV1、RSV2、およびRSV3とマークされたビットの割り当てを制御します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These bits are reserved for future versions or extensions of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのビットは、この仕様の将来のバージョンまたは拡張のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocket Framing Header Bits assignments are subject to the &#34;Standards Action&#34; IANA registration policy [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketフレーミングヘッダービットの割り当ては、「標準アクション」IANA登録ポリシー[RFC5226]に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Using the WebSocket Protocol from Other Specifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 他の仕様のWebSocketプロトコルの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WebSocket Protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g., in a specification defining a scripted API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebSocketプロトコルは、スクリプトAPIを定義する仕様など、動的な作成者定義コンテンツの一般的なメカニズムを提供するために別の仕様で使用されることを目的としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such a specification first needs to _Establish a WebSocket Connection_, providing that algorithm with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような仕様では、最初に_WebSocket接続を確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The destination, consisting of a /host/ and a /port/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o / host /と/ port /で構成される宛先。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A /resource name/, which allows for multiple services to be identified at one host and port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o /リソース名/。これにより、1つのホストとポートで複数のサービスを識別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A /secure/ flag, which is true if the connection is to be encrypted and false otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o / secure /フラグ。接続を暗号化する場合はtrue、それ以外の場合はfalse。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An ASCII serialization of an origin [RFC6454] that is being made responsible for the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接続を担当するオリジン[RFC6454]のASCIIシリアル化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Optionally, a string identifying a protocol that is to be layered over the WebSocket connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o オプションで、WebSocket接続を介して階層化されるプロトコルを識別する文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URI using the steps to parse a WebSocket URI&#39;s components. These steps fail if the URI does not specify a WebSocket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/ host /、/ port /、/ resource name /、および/ secure /フラグは通常、WebSocket URIのコンポーネントを解析する手順を使用して、URIから取得されます。 URIがWebSocketを指定していない場合、これらの手順は失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If at any time the connection is to be closed, then the specification needs to use the _Close the WebSocket Connection_ algorithm (Section 7.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いつでも接続を閉じる場合、仕様では_Close the WebSocket Connection_アルゴリズムを使用する必要があります（セクション7.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 7.1.4 defines when _The WebSocket Connection is Closed_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1.4は、_The WebSocket Connection is Closed_を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While a connection is open, the specification will need to handle the cases when _A WebSocket Message Has Been Received_ (Section 6.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続が開いている間、仕様はWebSocketメッセージが受信された場合（セクション6.2）のケースを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To send some data /data/ to an open connection, the specification needs to _Send a WebSocket Message_ (Section 6.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開いている接続にデータ/ data /を送信するには、仕様で_WebSocketメッセージを送信する必要があります（セクション6.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special thanks are due to Ian Hickson, who was the original author and editor of this protocol. The initial design of this specification benefitted from the participation of many people in the WHATWG and WHATWG mailing list. Contributions to that specification are not tracked by section, but a list of all who contributed to that specification is given in the WHATWG HTML specification at http://whatwg.org/html5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルの最初の作成者および編集者であるIan Hicksonに特に感謝します。この仕様の最初の設計は、WHATWGおよびWHATWGメーリングリストへの多くの人々の参加から利益を得ました。その仕様への貢献はセクションごとに追跡されませんが、その仕様に貢献したすべてのリストは、http：//whatwg.org/html5のWHATWG HTML仕様に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special thanks also to John Tamplin for providing a significant amount of text for the &#34;Data Framing&#34; section of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様の「データフレーミング」セクションに大量のテキストを提供してくれたJohn Tamplinにも特に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special thanks also to Adam Barth for providing a significant amount of text and background research for the &#34;Data Masking&#34; section of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様の「データマスキング」セクションに大量のテキストと背景の研究を提供してくれたAdam Barthにも感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special thanks to Lisa Dusseault for the Apps Area review (and for helping to start this work), Richard Barnes for the Gen-Art review, and Magnus Westerlund for the Transport Area Review. Special thanks to HYBI WG past and present WG chairs who tirelessly worked behind the scene to move this work toward completion: Joe Hildebrand, Salvatore Loreto, and Gabriel Montenegro. And last but not least, special thank you to the responsible Area Director Peter Saint-Andre.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Apps Areaレビュー（およびこの作業の開始を支援してくれた）のLisa Dusseault、Gen-ArtレビューのRichard Barnes、およびTransport Area ReviewのMagnus Westerlundに特に感謝します。 HYBI WGの過去と現在のWG議長、Joe Hildebrand、Salvatore Loreto、Gabriel Montenegroがこの作業を完了に向けて尽力してくれたことに感謝します。そして最後に、責任あるエリアディレクターのピーターサンタンドレに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thank you to the following people who participated in discussions on the HYBI WG mailing list and contributed ideas and/or provided detailed reviews (the list is likely to be incomplete): Greg Wilkins, John Tamplin, Willy Tarreau, Maciej Stachowiak, Jamie Lokier, Scott Ferguson, Bjoern Hoehrmann, Julian Reschke, Dave Cridland, Andy Green, Eric Rescorla, Inaki Baz Castillo, Martin Thomson, Roberto Peon, Patrick McManus, Zhong Yu, Bruce Atherton, Takeshi Yoshino, Martin J. Duerst, James Graham, Simon Pieters, Roy T. Fielding, Mykyta Yevstifeyev, Len Holgate, Paul Colomiets, Piotr Kulaga, Brian Raymor, Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch, Stephen Farrell, Sean Turner, Pete Resnick, Peter Thorson, Joe Mason, John Fallows, and Alexander Philippou. Note that people listed above didn&#39;t necessarily endorse the end result of this work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HYBI WGメーリングリストでのディスカッションに参加し、アイデアを提供したり、詳細なレビューを提供した（リストは不完全である可能性が高い）次の人々に感謝します。GregWilkins、John Tamplin、Willy Tarreau、Maciej Stachowiak、Jamie Lokier、スコットファーガソン、Bjoern Hoehrmann、Julian Reschke、Dave Cridland、Andy Green、Eric Rescorla、Inaki Baz Castillo、Martin Thomson、Roberto Peon、Patrick McManus、Zhong Yu、Bruce Atherton、Takeshi Yoshino、Martin J. Duerst、James Graham、Simon Pieters 、Roy T. Fielding、Mykyta Yevstifeyev、Len Holgate、Paul Colomiets、Piotr Kulaga、Brian Raymor、Jan Koehler、Joonas Lehtolahti、Sylvain Hellegouarch、Stephen Farrell、Sean Turner、Pete Resnick、Peter Thorson、Joe Mason、John Fallows、Alexander Philippou。上記の人々は、この作業の最終結果を必ずしも承認したわけではないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ANSI.X3-4.1986] American National Standards Institute, &#34;Coded Character Set - 7-bit American Standard Code for Information Interchange&#34;, ANSI X3.4, 1986.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ANSI.X3-4.1986] American National Standards Institute、「Coded Character Set-7-bit American Standard Code for Information Interchange」、ANSI X3.4、1986。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS.180-3] National Institute of Standards and Technology, &#34;Secure Hash Standard&#34;, FIPS PUB 180-3, October 2008, &lt;http://csrc.nist.gov/publications/fips/fips180-3/ fips180-3_final.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS.180-3]米国国立標準技術研究所、「Secure Hash Standard」、FIPS PUB 180-3、2008年10月、&lt;http://csrc.nist.gov/publications/fips/fips180-3/ fips180- 3_final.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1928] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, &#34;SOCKS Protocol Version 5&#34;, RFC 1928, March 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1928] Leech、M.、Ganis、M.、Lee、Y.、Kuris、R.、Koblas、D。、およびL. Jones、「SO​​CKS Protocol Version 5」、RFC 1928、1996年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &#34;Hypertext Transfer Protocol -- HTTP/1.1&#34;, RFC 2616, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2616] Fielding、R.、Gettys、J.、Mogul、J.、Frystyk、H.、Masinter、L.、Leach、P。、およびT. Berners-Lee、「ハイパーテキスト転送プロトコル-HTTP / 1.1」 、RFC 2616、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2817] Khare, R. and S. Lawrence, &#34;Upgrading to TLS Within HTTP/1.1&#34;, RFC 2817, May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2817] Khare、R。およびS. Lawrence、「HTTP / 1.1内のTLSへのアップグレード」、RFC 2817、2000年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818] Rescorla, E., &#34;HTTP Over TLS&#34;, RFC 2818, May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818] Rescorla、E。、「HTTP over TLS」、RFC 2818、2000年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, STD 63, RFC 3629, November 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、2003年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3864] Klyne, G., Nottingham, M., and J. Mogul, &#34;Registration Procedures for Message Header Fields&#34;, BCP 90, RFC 3864, September 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3864]クライン、G。、ノッティンガム、M。、およびJ.モーグル、「メッセージヘッダーフィールドの登録手順」、BCP 90、RFC 3864、2004年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, January 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、2005年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3987] Duerst, M. and M. Suignard, &#34;Internationalized Resource Identifiers (IRIs)&#34;, RFC 3987, January 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3987] Duerst、M。およびM. Suignard、「Internationalized Resource Identifiers（IRIs）」、RFC 3987、2005年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake、D.、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson, S., &#34;The Base16, Base32, and Base64 Data Encodings&#34;, RFC 4648, October 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、2006年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5234] Crocker, D. and P. Overell, &#34;Augmented BNF for Syntax Specifications: ABNF&#34;, STD 68, RFC 5234, January 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5234] Crocker、D。およびP. Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、2008年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6066] Eastlake, D., &#34;Transport Layer Security (TLS) Extensions: Extension Definitions&#34;, RFC 6066, January 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6066] Eastlake、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、2011年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6454] Barth, A., &#34;The Web Origin Concept&#34;, RFC 6454, December 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6454]バース、A。、「The Web Origin Concept」、RFC 6454、2011年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4122] Leach, P., Mealling, M., and R. Salz, &#34;A Universally Unique IDentifier (UUID) URN Namespace&#34;, RFC 4122, July 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4122] Leach、P.、Mealling、M。、およびR. Salz、「Universally Unique IDentifier（UUID）URN Namespace」、RFC 4122、2005年7月
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4270] Hoffman, P. and B. Schneier, &#34;Attacks on Cryptographic Hashes in Internet Protocols&#34;, RFC 4270, November 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4270] Hoffman、P。およびB. Schneier、「インターネットプロトコルにおける暗号化ハッシュへの攻撃」、RFC 4270、2005年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5321] Klensin, J., &#34;Simple Mail Transfer Protocol&#34;, RFC 5321, October 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5321] Klensin、J。、「Simple Mail Transfer Protocol」、RFC 5321、2008年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6202] Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins, &#34;Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP&#34;, RFC 6202, April 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6202] Loreto、S.、Saint-Andre、P.、Salsano、S。、およびG. Wilkins、「双方向HTTPでのロングポーリングとストリーミングの使用に関する既知の問題とベストプラクティス」、RFC 6202、2011年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6265] Barth, A., &#34;HTTP State Management Mechanism&#34;, RFC 6265, April 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6265]バース、A。、「HTTP状態管理メカニズム」、RFC 6265、2011年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, &#34;Talking to Yourself for Fun and Profit&#34;, 2010, &lt;http://w2spconf.com/2011/papers/websocket.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TALKING] Huang、LS。、Chen、E.、Barth、A.、Rescorla、E.、and C. Jackson、 &#34;Talking Yourself to Yourself for Fun and Profit&#34;、2010、&lt;http://w2spconf.com/2011 /papers/websocket.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.REC-wsc-ui-20100812] Roessler, T. and A. Saldhana, &#34;Web Security Context: User Interface Guidelines&#34;, World Wide Web Consortium Recommendation REC-wsc-ui-20100812, August 2010, &lt;http://www.w3.org/TR/2010/REC-wsc-ui-20100812/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.REC-wsc-ui-20100812] Roessler、T。およびA. Saldhana、「Web Security Context：User Interface Guidelines」、World Wide Web Consortium Recommendation REC-wsc-ui-20100812、2010年8月、&lt;http：/ /www.w3.org/TR/2010/REC-wsc-ui-20100812/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Latest version available at &lt;http://www.w3.org/TR/wsc-ui/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
&lt;http://www.w3.org/TR/wsc-ui/&gt;で入手可能な最新バージョン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WSAPI] Hickson, I., &#34;The WebSocket API&#34;, W3C Working Draft WD-websockets-20110929, September 2011, &lt;http://www.w3.org/TR/2011/WD-websockets-20110929/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WSAPI] Hickson、I.、 &#34;The WebSocket API&#34;、W3C Working Draft WD-websockets-20110929、2011年9月、&lt;http://www.w3.org/TR/2011/WD-websockets-20110929/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Latest version available at &lt;http://www.w3.org/TR/websockets/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
&lt;http://www.w3.org/TR/websockets/&gt;で入手可能な最新バージョン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XMLHttpRequest] van Kesteren, A., Ed., &#34;XMLHttpRequest&#34;, W3C Candidate Recommendation CR-XMLHttpRequest-20100803, August 2010, &lt;http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XMLHttpRequest] van Kesteren、A.、Ed。、 &#34;XMLHttpRequest&#34;、W3C Candidate Recommendation CR-XMLHttpRequest-20100803、August 2010、&lt;http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Latest version available at &lt;http://www.w3.org/TR/XMLHttpRequest/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
&lt;http://www.w3.org/TR/XMLHttpRequest/&gt;で入手可能な最新バージョン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ian Fette Google, Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ian Fette Google、Inc.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: ifette+ietf@google.com
   URI:   http://www.ianfette.com/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alexey Melnikov Isode Ltd. 5 Castle Business Village 36 Station Road Hampton, Middlesex TW12 2BX UK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alexey Melnikov Isode Ltd. 5 Castle Business Village 36 Station Road Hampton、Middlesex TW12 2BX UK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: Alexey.Melnikov@isode.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
