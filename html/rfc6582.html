<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 6582 - The NewReno Modification to TCP&#39;s Fast Recovery Algorithm 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6582</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc6582">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6582 - The NewReno Modification to TCP's Fast Recovery Algorithm 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc6582">
              https://datatracker.ietf.org/doc/html/rfc6582
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6582 - TCPの高速リカバリアルゴリズムに対するNewRenoの変更</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                      T. Henderson
Request for Comments: 6582                                        Boeing
Obsoletes: 3782                                                 S. Floyd
Category: Standards Track                                           ICSI
ISSN: 2070-1721                                                A. Gurtov
                                                      University of Oulu
                                                              Y. Nishida
                                                            WIDE Project
                                                              April 2012
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The NewReno Modification to TCP&#39;s Fast Recovery Algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
TCPの高速リカバリアルゴリズムに対するNewRenoの変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery. RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &#34;partial acknowledgments&#34; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK. This document describes a specific algorithm for responding to partial acknowledgments, referred to as &#34;NewReno&#34;. This response to partial acknowledgments was first proposed by Janey Hoe. This document obsoletes RFC 3782.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681は、以下の4つの絡み合ったTCP輻輳制御アルゴリズムを文書化しています。スロースタート、輻輳回避、高速再送信、高速リカバリ。 RFC 5681では、これらのアルゴリズムの特定の変更を明示的に許可しています。これには、TCP選択的確認応答（SACK）オプション（RFC 2883）を使用する変更や、「部分的確認応答」に応答する変更（新しいデータをカバーするが、未処理のすべてのデータではない損失が検出された）SACKがない場合。このドキュメントでは、「NewReno」と呼ばれる、部分的な確認応答に応答するための特定のアルゴリズムについて説明します。部分的な承認に対するこの応答は、Janey Hoeによって最初に提案されました。このドキュメントはRFC 3782を廃止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはInternet Standards Trackドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6582.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6582で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2012 IETF Trustおよびドキュメントの作成者として特定された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの素材が含まれている場合があります。この素材の一部の著作権を管理する人は、IETFトラストにそのような素材の変更を許可する権利を付与していない可能性がありますIETF標準プロセス外。このような資料の著作権を管理する人から適切なライセンスを取得しない限り、このドキュメントはIETF標準プロセス外で変更できません。また、その派生物は、IETF標準プロセス外で作成できません。 RFCとして、またはそれを英語以外の言語に翻訳するための出版物。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the typical implementation of the TCP fast recovery algorithm described in [RFC5681] (first implemented in the 1990 BSD Reno release, and referred to as the &#34;Reno algorithm&#34; in [FF96]), the TCP data sender only retransmits a packet after a retransmit timeout has occurred, or after three duplicate acknowledgments have arrived triggering the fast retransmit algorithm. A single retransmit timeout might result in the retransmission of several data packets, but each invocation of the fast retransmit algorithm in RFC 5681 leads to the retransmission of only a single data packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]で説明されているTCP高速リカバリアルゴリズムの典型的な実装（1990 BSD Renoリリースで最初に実装され、[FF96]で「Renoアルゴリズム」と呼ばれる）の場合、TCPデータ送信者は、再送信タイムアウトが発生したか、3つの重複した確認応答が到着した後、高速再送信アルゴリズムがトリガーされました。単一の再送信タイムアウトにより、複数のデータパケットが再送信される可能性がありますが、RFC 5681の高速再送信アルゴリズムを呼び出すたびに、単一のデータパケットのみが再送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two problems arise with Reno TCP when multiple packet losses occur in a single window. First, Reno will often take a timeout, as has been documented in [Hoe95]. Second, even if a retransmission timeout is avoided, multiple fast retransmits and window reductions can occur, as documented in [F94]. When multiple packet losses occur, if the SACK option [RFC2883] is available, the TCP sender has the information to make intelligent decisions about which packets to retransmit and which packets not to retransmit during fast recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つのウィンドウで複数のパケット損失が発生すると、Reno TCPで2つの問題が発生します。最初に、[Hoe95]で説明されているように、Renoはしばしばタイムアウトします。第2に、再送信タイムアウトが回避された場合でも、[F94]で説明されているように、複数の高速再送信とウィンドウ縮小が発生する可能性があります。複数のパケット損失が発生した場合、SACKオプション[RFC2883]が利用可能であれば、TCP送信側は、高速リカバリ中に再送信するパケットと再送信しないパケットについてインテリジェントな決定を行うための情報を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document applies to TCP connections that are unable to use the TCP Selective Acknowledgment (SACK) option, either because the option is not locally supported or because the TCP peer did not indicate a willingness to use SACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、オプションがローカルでサポートされていないか、TCPピアがSACKを使用する意思を示さなかったため、TCP選択的確認応答（SACK）オプションを使用できないTCP接続に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of SACK, there is little information available to the TCP sender in making retransmission decisions during fast recovery. From the three duplicate acknowledgments, the sender infers a packet loss, and retransmits the indicated packet. After this, the data sender could receive additional duplicate acknowledgments, as the data receiver acknowledges additional data packets that were already in flight when the sender entered fast retransmit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SACKがない場合、TCP送信者が高速リカバリ中に再送信を決定するために利用できる情報はほとんどありません。 3つの重複する確認応答から、送信者はパケット損失を推測し、示されたパケットを再送信します。この後、送信者が高速再送信を入力したときにデータレシーバーがすでに処理中だった追加のデータパケットを確認するため、データ送信者は追加の重複確認応答を受信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of multiple packets dropped from a single window of data, the first new information available to the sender comes when the sender receives an acknowledgment for the retransmitted packet (that is, the packet retransmitted when fast retransmit was first entered). If there is a single packet drop and no reordering, then the acknowledgment for this packet will acknowledge all of the packets transmitted before fast retransmit was entered. However, if there are multiple packet drops, then the acknowledgment for the retransmitted packet will acknowledge some but not all of the packets transmitted before the fast retransmit. We call this acknowledgment a partial acknowledgment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のデータウィンドウからドロップされた複数のパケットの場合、送信者が利用できる最初の新しい情報は、送信者が再送信されたパケット（つまり、高速再送信が最初に入力されたときに再送信されたパケット）の確認応答を受信したときに得られます。単一のパケットドロップがあり、並べ替えがない場合、このパケットの確認応答は、高速再送信が開始される前に送信されたすべてのパケットを確認応答します。ただし、複数のパケットドロップがある場合、再送信されたパケットの確認応答は、高速再送信の前に送信されたすべてのパケットではなく一部のパケットを確認します。この確認を部分的な確認と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Along with several other suggestions, [Hoe95] suggested that during fast recovery the TCP data sender respond to a partial acknowledgment by inferring that the next in-sequence packet has been lost and retransmitting that packet. This document describes a modification to the fast recovery algorithm in RFC 5681 that incorporates a response to partial acknowledgments received during fast recovery. We call this modified fast recovery algorithm NewReno, because it is a slight but significant variation of the behavior that has been historically referred to as Reno. This document does not discuss the other suggestions in [Hoe95] and [Hoe96], such as a change to the ssthresh parameter during slow start, or the proposal to send a new packet for every two duplicate acknowledgments during fast recovery. The version of NewReno in this document also draws on other discussions of NewReno in the literature [LM97] [Hen98].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のいくつかの提案とともに、[Hoe95]は、高速リカバリ中に、TCPデータ送信者が次のシーケンス内のパケットが失われたと推測してそのパケットを再送信することにより、部分的な確認応答に応答することを提案しました。このドキュメントでは、高速リカバリ中に受信された部分的な確認応答への応答を組み込んだ、RFC 5681の高速リカバリアルゴリズムの変更について説明します。この修正された高速リカバリアルゴリズムをNewRenoと呼びます。これは、これまでRenoと呼ばれてきた動作のわずかではあるが重要なバリエーションであるためです。このドキュメントでは、[Hoe95]と[Hoe96]の他の提案（スロースタート時のssthreshパラメータの変更、高速リカバリ時の2つの重複する確認応答ごとに新しいパケットを送信する提案など）については説明しません。このドキュメントのNewRenoのバージョンは、文献[LM97] [Hen98]でのNewRenoに関する他の議論も利用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 We do not claim that the NewReno version of fast recovery described here is an optimal modification of fast recovery for responding to partial acknowledgments, for TCP connections that are unable to use SACK. Based on our experiences with the NewReno modification in the network simulator known as ns-2 [NS] and with numerous implementations of NewReno, we believe that this modification improves the performance of the fast retransmit and fast recovery algorithms in a wide variety of scenarios. Previous versions of this RFC [RFC2582] [RFC3782] provide simulation-based evidence of the possible performance gains.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ここで説明する高速リカバリのNewRenoバージョンは、SACKを使用できないTCP接続の部分的な確認応答に応答するための高速リカバリの最適な修正であるとは主張していません。 ns-2 [NS]と呼ばれるネットワークシミュレータでのNewRenoの変更に関する経験と、NewRenoの多数の実装に基づくと、この変更により、さまざまなシナリオでの高速再送信および高速リカバリアルゴリズムのパフォーマンスが向上すると考えられます。このRFC [RFC2582] [RFC3782]の以前のバージョンは、可能なパフォーマンス向上のシミュレーションベースの証拠を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology and Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 用語と定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document assumes that the reader is familiar with the terms SENDER MAXIMUM SEGMENT SIZE (SMSS), CONGESTION WINDOW (cwnd), and FLIGHT SIZE (FlightSize) defined in [RFC5681].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、読者が[RFC5681]で定義されているSENDER MAXIMUM SEGMENT SIZE（SMSS）、CONGESTION WINDOW（cwnd）、およびFLIGHT SIZE（FlightSize）という用語に精通していることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an additional sender-side state variable called &#34;recover&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、「recover」と呼ばれる追加の送信側の状態変数を定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
recover: When in fast recovery, this variable records the send sequence number that must be acknowledged before the fast recovery procedure is declared to be over.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
リカバリー：高速リカバリーの場合、この変数は、高速リカバリー手順が終了したと宣言される前に確認応答が必要な送信シーケンス番号を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. The Fast Retransmit and Fast Recovery Algorithms in NewReno
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. NewRenoの高速再送信および高速回復アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic idea of these extensions to the fast retransmit and fast recovery algorithms described in Section 3.2 of [RFC5681] is as follows. The TCP sender can infer, from the arrival of duplicate acknowledgments, whether multiple losses in the same window of data have most likely occurred, and avoid taking a retransmit timeout or making multiple congestion window reductions due to such an event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]のセクション3.2で説明されている高速再送信および高速リカバリアルゴリズムに対するこれらの拡張の基本的な考え方は次のとおりです。 TCP送信側は、重複する確認応答の到着から、同じデータウィンドウで複数の損失が発生した可能性が最も高いかどうかを推測し、そのようなイベントにより再送信タイムアウトが発生したり、複数の輻輳ウィンドウを削減したりすることを回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NewReno modification applies to the fast recovery procedure that begins when three duplicate ACKs are received and ends when either a retransmission timeout occurs or an ACK arrives that acknowledges all of the data up to and including the data that was outstanding when the fast recovery procedure began.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NewRenoの変更は、3つの重複するACKが受信されたときに始まり、再送信タイムアウトが発生するか、またはACKが到着して、高速復旧手順が開始されたときに未解決だったデータまでのすべてのデータを確認応答するときに完了する高速復旧手順に適用されます。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Specification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 仕様
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures specified in Section 3.2 of [RFC5681] are followed, with the modifications listed below. Note that this specification avoids the use of the key words defined in RFC 2119 [RFC2119], since it mainly provides sender-side implementation guidance for performance improvement, and does not affect interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]のセクション3.2で指定された手順に従い、以下に変更を加えます。この仕様は、主にパフォーマンス向上のための送信側の実装ガイダンスを提供し、相互運用性に影響を与えないため、RFC 2119 [RFC2119]で定義されているキーワードの使用を避けていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) Initialization of TCP protocol control block: When the TCP protocol control block is initialized, recover is set to the initial send sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1）TCPプロトコル制御ブロックの初期化：TCPプロトコル制御ブロックが初期化されると、recoverは初期送信シーケンス番号に設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) Three duplicate ACKs: When the third duplicate ACK is received, the TCP sender first checks the value of recover to see if the Cumulative Acknowledgment field covers more than recover. If so, the value of recover is incremented to the value of the highest sequence number transmitted by the TCP so far. The TCP then enters fast retransmit (step 2 of Section 3.2 of [RFC5681]). If not, the TCP does not enter fast retransmit and does not reset ssthresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2）3つの重複するACK：3番目の重複するACKが受信されると、TCP送信側は最初に、recoverの値をチェックして、累積確認フィールドが回復以上のものをカバーしているかどうかを確認します。その場合、recoverの値は、TCPによってこれまでに送信された最高のシーケンス番号の値に増分されます。その後、TCPは高速再送信に入ります（[RFC5681]のセクション3.2のステップ2）。そうでない場合、TCPは高速再送信を開始せず、ssthreshをリセットしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3) Response to newly acknowledged data: Step 6 of [RFC5681] specifies the response to the next ACK that acknowledges previously unacknowledged data. When an ACK arrives that acknowledges new data, this ACK could be the acknowledgment elicited by the initial retransmission from fast retransmit, or elicited by a later retransmission. There are two cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3）新しく確認されたデータへの応答：[RFC5681]のステップ6は、以前に確認されていないデータを確認する次のACKへの応答を指定します。新しいデータを確認するACKが到着すると、このACKは、高速再送信からの最初の再送信によって引き出された確認応答、またはその後の再送信によって引き出された確認応答である可能性があります。 2つのケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Full acknowledgments: If this ACK acknowledges all of the data up to and including recover, then the ACK acknowledges all the intermediate segments sent between the original transmission of the lost segment and the receipt of the third duplicate ACK. Set cwnd to either (1) min (ssthresh, max(FlightSize, SMSS) + SMSS) or (2) ssthresh, where ssthresh is the value set when fast retransmit was entered, and where FlightSize in (1) is the amount of data presently outstanding. This is termed &#34;deflating&#34; the window. If the second option is selected, the implementation is encouraged to take measures to avoid a possible burst of data, in case the amount of data outstanding in the network is much less than the new congestion window allows. A simple mechanism is to limit the number of data packets that can be sent in response to a single acknowledgment. Exit the fast recovery procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
完全確認応答：このACKが、回復までのすべてのデータを確認応答した場合、ACKは、失われたセグメントの元の送信と3番目の重複ACKの受信の間に送信されたすべての中間セグメントを確認応答します。 cwndを（1）min（ssthresh、max（FlightSize、SMSS）+ SMSS）または（2）ssthreshに設定します。ここで、ssthreshは高速再送信が入力されたときに設定された値であり、（1）のFlightSizeはデータ量です現在傑出した。これはウィンドウの「収縮」と呼ばれます。 2番目のオプションを選択した場合、ネットワークで未処理のデータ量が新しい輻輳ウィンドウで許容される量よりもはるかに少ない場合に備えて、データのバーストを回避するための対策を講じることをお勧めします。単純なメカニズムは、単一の確認応答に応答して送信できるデータパケットの数を制限することです。高速リカバリ手順を終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Partial acknowledgments: If this ACK does *not* acknowledge all of the data up to and including recover, then this is a partial ACK. In this case, retransmit the first unacknowledged segment. Deflate the congestion window by the amount of new data acknowledged by the Cumulative Acknowledgment field. If the partial ACK acknowledges at least one SMSS of new data, then add back SMSS bytes to the congestion window. This artificially inflates the congestion window in order to reflect the additional segment that has left the network. Send a new segment if permitted by the new value of cwnd. This &#34;partial window deflation&#34; attempts to ensure that, when fast recovery eventually ends, approximately ssthresh amount of data will be outstanding in the network. Do not exit the fast recovery procedure (i.e., if any duplicate ACKs subsequently arrive, execute step 4 of Section 3.2 of [RFC5681]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
部分的確認応答：このACKが、回復までのすべてのデータを確認しなかった場合、これは部分的確認応答です。この場合、最初の未確認セグメントを再送信します。 [累積確認応答]フィールドで確認応答された新しいデータの量で、輻輳ウィンドウを縮小します。部分的なACKが新しいデータの少なくとも1つのSMSSを確認する場合、輻輳ウィンドウにSMSSバイトを追加します。これは、ネットワークを離れた追加のセグメントを反映するために、混雑ウィンドウを人工的に膨らませます。 cwndの新しい値で許可されている場合は、新しいセグメントを送信します。この「部分的なウィンドウデフレーション」は、高速リカバリが最終的に終了したときに、ネットワーク内で約ssthresh量のデータが未処理であることを保証しようとします。高速リカバリ手順を終了しないでください（つまり、重複するACKが後で到着した場合は、[RFC5681]のセクション3.2のステップ4を実行します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
For the first partial ACK that arrives during fast recovery, also reset the retransmit timer. Timer management is discussed in more detail in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
高速リカバリ中に到着した最初の部分的ACKについては、再送信タイマーもリセットします。タイマー管理については、セクション4で詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4) Retransmit timeouts: After a retransmit timeout, record the highest sequence number transmitted in the variable recover, and exit the fast recovery procedure if applicable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4）再送信タイムアウト：再送信タイムアウトの後、送信された最大シーケンス番号を変数recoverに記録し、該当する場合は高速復旧手順を終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 2 above specifies a check that the Cumulative Acknowledgment field covers more than recover. Because the acknowledgment field contains the sequence number that the sender next expects to receive, the acknowledgment &#34;ack_number&#34; covers more than recover when
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のステップ2は、累積確認フィールドが回復以上のものをカバーするチェックを指定します。確認応答フィールドには、送信者が次に受信することを期待するシーケンス番号が含まれているため、確認応答「ack_number」は、次の場合に回復以上のものをカバーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ack_number - 1 &gt; recover;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
i.e., at least one byte more of data is acknowledged beyond the highest byte that was outstanding when fast retransmit was last entered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
つまり、高速再送信が最後に入力されたときに未処理だった最上位バイトを超えて、少なくとも1バイト以上のデータが確認されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in step 3 above, the congestion window is deflated after a partial acknowledgment is received. The congestion window was likely to have been inflated considerably when the partial acknowledgment was received. In addition, depending on the original pattern of packet losses, the partial acknowledgment might acknowledge nearly a window of data. In this case, if the congestion window was not deflated, the data sender might be able to send nearly a window of data back-to-back.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のステップ3では、部分的な確認応答が受信された後、輻輳ウィンドウが縮小されていることに注意してください。部分的な確認が受信されたとき、輻輳ウィンドウはかなり膨らんでいた可能性が高いです。さらに、パケット損失の元のパターンによっては、部分的な確認応答によってほぼウィンドウのデータが確認応答される場合があります。この場合、輻輳ウィンドウが縮小されていなければ、データ送信者はほぼウィンドウのデータを連続して送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not specify the sender&#39;s response to duplicate ACKs when the fast retransmit/fast recovery algorithm is not invoked. This is addressed in other documents, such as those describing the Limited Transmit procedure [RFC3042]. This document also does not address issues of adjusting the duplicate acknowledgment threshold, but assumes the threshold specified in the IETF standards; the current standard is [RFC5681], which specifies a threshold of three duplicate acknowledgments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、高速再送信/高速リカバリアルゴリズムが呼び出されない場合の重複ACKに対する送信者の応答を指定していません。これは、限定送信手順[RFC3042]を説明するドキュメントなど、他のドキュメントで対処されています。このドキュメントでは、重複する確認のしきい値の調整に関する問題についても触れていませんが、IETF標準で指定されているしきい値を想定しています。現在の標準は[RFC5681]で、3つの重複する確認応答のしきい値を指定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a final note, we would observe that in the absence of the SACK option, the data sender is working from limited information. When the issue of recovery from multiple dropped packets from a single window of data is of particular importance, the best alternative would be to use the SACK option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、SACKオプションがない場合、データ送信者は限られた情報で作業していることがわかります。データの単一のウィンドウからの複数のドロップされたパケットからの回復の問題が特に重要である場合、最良の代替策はSACKオプションを使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Handling Duplicate Acknowledgments after a Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. タイムアウト後の重複確認応答の処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After each retransmit timeout, the highest sequence number transmitted so far is recorded in the variable recover. If, after a retransmit timeout, the TCP data sender retransmits three consecutive packets that have already been received by the data receiver, then the TCP data sender will receive three duplicate acknowledgments that do not cover more than recover. In this case, the duplicate acknowledgments are not an indication of a new instance of congestion. They are simply an indication that the sender has unnecessarily retransmitted at least three packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各再送信タイムアウトの後、これまでに送信された最大のシーケンス番号が変数recoverに記録されます。再送信タイムアウトの後、TCPデータセンダーがデータレシーバーによってすでに受信されている3つの連続したパケットを再送信する場合、TCPデータセンダーは、回復以上のものをカバーしない3つの重複した確認応答を受信します。この場合、確認応答の重複は、輻輳の新しいインスタンスを示すものではありません。これらは単に、送信者が少なくとも3つのパケットを不必要に再送信したことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, when a retransmitted packet is itself dropped, the sender can also receive three duplicate acknowledgments that do not cover more than recover. In this case, the sender would have been better off if it had initiated fast retransmit. For a TCP sender that implements the algorithm specified in Section 3.2 of this document, the sender does not infer a packet drop from duplicate acknowledgments in this scenario. As always, the retransmit timer is the backup mechanism for inferring packet loss in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、再送信されたパケット自体がドロップされた場合、送信者は、回復以上のものをカバーしない3つの重複した確認応答も受信できます。この場合、送信者は高速再送信を開始した方がよいでしょう。このドキュメントのセクション3.2で指定されたアルゴリズムを実装するTCP送信者の場合、送信者は、このシナリオでの重複した確認応答からのパケットのドロップを推測しません。いつものように、この場合、再送信タイマーはパケット損失を推測するためのバックアップメカニズムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several heuristics, based on timestamps or on the amount of advancement of the Cumulative Acknowledgment field, that allow the sender to distinguish, in some cases, between three duplicate acknowledgments following a retransmitted packet that was dropped, and three duplicate acknowledgments from the unnecessary retransmission of three packets [Gur03] [GF04]. The TCP sender may use such a heuristic to decide to invoke a fast retransmit in some cases, even when the three duplicate acknowledgments do not cover more than recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムスタンプまたは累積確認フィールドの進行量に基づいて、いくつかのヒューリスティックがあり、送信者は、場合によっては、ドロップされた再送信パケットに続く3つの重複確認と、不要なものからの3つの重複確認を区別できます。 3つのパケットの再送信[Gur03] [GF04]。 TCP送信側は、このようなヒューリスティックを使用して、3つの重複する確認応答が回復以上のものをカバーしていない場合でも、高速再送信を呼び出すことを決定する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, when three duplicate acknowledgments are caused by the unnecessary retransmission of three packets, this is likely to be accompanied by the Cumulative Acknowledgment field advancing by at least four segments. Similarly, a heuristic based on timestamps uses the fact that when there is a hole in the sequence space, the timestamp echoed in the duplicate acknowledgment is the timestamp of the most recent data packet that advanced the Cumulative Acknowledgment field [RFC1323]. If timestamps are used, and the sender stores the timestamp of the last acknowledged segment, then the timestamp echoed by duplicate acknowledgments can be used to distinguish between a retransmitted packet that was dropped and three duplicate acknowledgments from the unnecessary retransmission of three packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、3つの重複した確認応答が3つのパケットの不必要な再送信によって引き起こされた場合、これには、少なくとも4つのセグメントだけ進んだ累積確認応答フィールドが伴う可能性があります。同様に、タイムスタンプに基づくヒューリスティックは、シーケンススペースに穴がある場合、重複する確認応答にエコーされるタイムスタンプが、累積確認フィールド[RFC1323]を進んだ最新のデータパケットのタイムスタンプであるという事実を使用します。タイムスタンプが使用され、送信者が最後に確認応答されたセグメントのタイムスタンプを保存している場合、重複した確認応答によってエコーされたタイムスタンプを使用して、ドロップされた再送信パケットと3つの重複した確認応答を、3つのパケットの不要な再送信から区別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. ACK Heuristic
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. ACKヒューリスティック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the ACK-based heuristic is used, then following the advancement of the Cumulative Acknowledgment field, the sender stores the value of the previous cumulative acknowledgment as prev_highest_ack, and stores the latest cumulative ACK as highest_ack. In addition, the following check is performed if, in step 2 of Section 3.2, the Cumulative Acknowledgment field does not cover more than recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACKベースのヒューリスティックが使用されている場合、送信者は累積確認フィールドの拡張に続いて、以前の累積確認の値をprev_highest_ackとして保存し、最新の累積ACKをhighest_ackとして保存します。さらに、セクション3.2のステップ2で、累積確認フィールドが回復以上のものをカバーしない場合、次のチェックが実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2*) If the Cumulative Acknowledgment field didn&#39;t cover more than recover, check to see if the congestion window is greater than SMSS bytes and the difference between highest_ack and prev_highest_ack is at most 4*SMSS bytes. If true, duplicate ACKs indicate a lost segment (enter fast retransmit). Otherwise, duplicate ACKs likely result from unnecessary retransmissions (do not enter fast retransmit).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2 *）[累積確認応答]フィールドが回復以上のものをカバーしていない場合は、輻輳ウィンドウがSMSSバイトより大きく、highest_ackとprev_highest_ackの差が最大で4 * SMSSバイトであるかどうかを確認します。 trueの場合、重複ACKは失われたセグメントを示します（高速再送信を入力）。そうでなければ、重複したACKは不必要な再送信から生じる可能性があります（高速再送信を入力しないでください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The congestion window check serves to protect against fast retransmit immediately after a retransmit timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳ウィンドウチェックは、再送信タイムアウトの直後の高速再送信から保護するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If several ACKs are lost, the sender can see a jump in the cumulative ACK of more than three segments, and the heuristic can fail. [RFC5681] recommends that a receiver should send duplicate ACKs for every out-of-order data packet, such as a data packet received during fast recovery. The ACK heuristic is more likely to fail if the receiver does not follow this advice, because then a smaller number of ACK losses are needed to produce a sufficient jump in the cumulative ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のACKが失われると、送信者は3つを超えるセグメントの累積ACKのジャンプを確認でき、ヒューリスティックが失敗する可能性があります。 [RFC5681]は、高速リカバリ中に受信したデータパケットなど、順序が乱れているすべてのデータパケットに対して、受信者が重複したACKを送信することを推奨しています。受信者がこのアドバイスに従わない場合、ACKヒューリスティックは失敗する可能性が高くなります。これは、累積ACKに十分なジャンプを生成するために必要なACK損失の数が少ないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Timestamp Heuristic
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. タイムスタンプヒューリスティック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this heuristic is used, the sender stores the timestamp of the last acknowledged segment. In addition, the last sentence of step 2 in Section 3.2 of this document is replaced as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヒューリスティックを使用する場合、送信者は最後に確認されたセグメントのタイムスタンプを保存します。さらに、このドキュメントのセクション3.2のステップ2の最後の文は、次のように置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2**) If the Cumulative Acknowledgment field didn&#39;t cover more than recover, check to see if the echoed timestamp in the last non-duplicate acknowledgment equals the stored timestamp. If true, duplicate ACKs indicate a lost segment (enter fast retransmit). Otherwise, duplicate ACKs likely result from unnecessary retransmissions (do not enter fast retransmit).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2 **）Cumulative Acknowledgmentフィールドが回復以上のものをカバーしなかった場合は、最後の重複していない確認のエコーされたタイムスタンプが保存されたタイムスタンプと等しいかどうかを確認してください。 trueの場合、重複ACKは失われたセグメントを示します（高速再送信を入力）。そうでなければ、重複したACKは不必要な再送信から生じる可能性があります（高速再送信を入力しないでください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The timestamp heuristic works correctly, both when the receiver echoes timestamps, as specified by [RFC1323], and by its revision attempts. However, if the receiver arbitrarily echoes timestamps, the heuristic can fail. The heuristic can also fail if a timeout was spurious and returning ACKs are not from retransmitted segments. This can be prevented by detection algorithms such as the Eifel detection algorithm [RFC3522].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムスタンプヒューリスティックは、[RFC1323]で指定されているように、受信者がタイムスタンプをエコーする場合と、その改訂試行の両方で正しく機能します。ただし、受信者が任意にタイムスタンプをエコーすると、ヒューリスティックが失敗する可能性があります。タイムアウトが偽であり、返されるACKが再送信されたセグメントからのものでない場合、ヒューリスティックは失敗する可能性もあります。これは、Eifel検出アルゴリズム[RFC3522]などの検出アルゴリズムによって防止できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Implementation Issues for the Data Receiver
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. データレシーバーの実装に関する問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] specifies that &#34;Out-of-order data segments SHOULD be acknowledged immediately, in order to accelerate loss recovery&#34;. Neal Cardwell has noted that some data receivers do not send an immediate acknowledgment when they send a partial acknowledgment, but instead wait first for their delayed acknowledgment timer to expire [C98]. As [C98] notes, this severely limits the potential benefit of NewReno by delaying the receipt of the partial acknowledgment at the data sender. Echoing [RFC5681], our recommendation is that the data receiver send an immediate acknowledgment for an out-of-order segment, even when that out-of-order segment fills a hole in the buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]は、「損失の回復を加速するために、順不同のデータセグメントをすぐに確認する必要がある」と規定しています。 Neal Cardwell氏は、一部のデータレシーバーは、部分的な確認応答を送信するときにすぐに確認応答を送信せず、遅延確認応答タイマーが期限切れになるまで最初に待機することに注意しています[C98]。 [C98]が指摘しているように、これはデータ送信側での部分的な確認応答の受信を遅らせることによってNewRenoの潜在的な利点を厳しく制限します。 [RFC5681]をエコーすると、データレシーバーは、順序の乱れたセグメントがバッファーの穴を埋めた場合でも、順序の乱れたセグメントの即時確認を送信することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Implementation Issues for the Data Sender
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. データ送信者の実装の問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In Section 3.2, step 3 above, it is noted that implementations should take measures to avoid a possible burst of data when leaving fast recovery, in case the amount of new data that the sender is eligible to send due to the new value of the congestion window is large. This can arise during NewReno when ACKs are lost or treated as pure window updates, thereby causing the sender to underestimate the number of new segments that can be sent during the recovery procedure. Specifically, bursts can occur when the FlightSize is much less than the new congestion window when exiting from fast recovery. One simple mechanism to avoid a burst of data when leaving fast recovery is to limit the number of data packets that can be sent in response to a single acknowledgment. (This is known as &#34;maxburst_&#34; in ns-2 [NS].) Other possible mechanisms for avoiding bursts include rate-based pacing, or setting the slow start threshold to the resultant congestion window and then resetting the congestion window to FlightSize. A recommendation on the general mechanism to avoid excessively bursty sending patterns is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
上記のセクション3.2、ステップ3では、輻輳の新しい値のために送信者が送信する資格がある新しいデータの量が多い場合に備えて、実装は高速復旧を離れるときにデータのバーストの可能性を回避するための対策を講じる必要があることに注意してください窓が大きい。これは、ACKが失われたり、純粋なウィンドウの更新として扱われたりするNewReno中に発生する可能性があり、それにより、送信者は、回復手順中に送信できる新しいセグメントの数を過小評価します。具体的には、FastSizeが高速リカバリから抜けるときに新しい輻輳ウィンドウよりもはるかに小さい場合、バーストが発生する可能性があります。高速リカバリを終了するときにデータのバーストを回避する簡単なメカニズムの1つは、単一の確認応答に応答して送信できるデータパケットの数を制限することです。 （これはns-2 [NS]では &#34;maxburst_&#34;として知られています。）バーストを回避するための他の可能なメカニズムには、レートベースのペーシング、またはスロースタートしきい値を結果の輻輳ウィンドウに設定して、輻輳ウィンドウをFlightSizeにリセットすることが含まれます。過度にバースト的な送信パターンを回避するための一般的なメカニズムに関する推奨事項は、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation may want to use a separate flag to record whether or not it is presently in the fast recovery procedure. The use of the value of the duplicate acknowledgment counter for this purpose is not reliable, because it can be reset upon window updates and out-of-order acknowledgments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装では、別のフラグを使用して、現在それが高速リカバリ手順にあるかどうかを記録することができます。この目的での重複確認応答カウンターの値の使用は、ウィンドウの更新や順序が正しくない確認応答時にリセットされる可能性があるため、信頼できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When updating the Cumulative Acknowledgment field outside of fast recovery, the state variable recover may also need to be updated in order to continue to permit possible entry into fast recovery (Section 3.2, step 2). This issue arises when an update of the Cumulative Acknowledgment field results in a sequence wraparound that affects the ordering between the Cumulative Acknowledgment field and the state variable recover. Entry into fast recovery is only possible when the Cumulative Acknowledgment field covers more than the state variable recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速リカバリの外部で累積確認フィールドを更新する場合、高速リカバリへの可能なエントリを許可し続けるために、状態変数recoverも更新する必要がある場合があります（セクション3.2、ステップ2）。この問題は、累積確認応答フィールドの更新の結果、累積確認応答フィールドと状態変数の回復の間の順序に影響するシーケンスラップアラウンドが発生した場合に発生します。高速リカバリーへのエントリーは、累積確認フィールドが状態変数リカバリー以上のものをカバーしている場合にのみ可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important for the sender to respond correctly to duplicate ACKs received when the sender is no longer in fast recovery (e.g., because of a retransmit timeout). The Limited Transmit procedure [RFC3042] describes possible responses to the first and second duplicate acknowledgments. When three or more duplicate acknowledgments are received, the Cumulative Acknowledgment field doesn&#39;t cover more than recover, and a new fast recovery is not invoked, the sender should follow the guidance in Section 4. Otherwise, the sender could end up in a chain of spurious timeouts. We mention this only because several NewReno implementations had this bug, including the implementation in ns-2 [NS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者が（たとえば、再送信タイムアウトのために）高速リカバリでなくなったときに受信した重複ACKに正しく送信者が応答することが重要です。限定送信手順[RFC3042]は、最初と2番目の重複する確認応答に対する可能な応答について説明しています。 3つ以上の重複する確認応答を受信した場合、累積確認応答フィールドは回復以上のものをカバーせず、新しい高速回復が呼び出されない場合、送信者はセクション4のガイダンスに従う必要があります。そうしないと、送信者がチェーンになってしまう可能性があります偽のタイムアウトの。 ns-2 [NS]での実装を含め、いくつかのNewReno実装にこのバグがあったため、これについてのみ言及します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It has been observed that some TCP implementations enter a slow start or congestion avoidance window updating algorithm immediately after the cwnd is set by the equation found in Section 3.2, step 3, even without a new external event generating the cwnd change. Note that after cwnd is set based on the procedure for exiting fast recovery (Section 3.2, step 3), cwnd should not be updated until a further event occurs (e.g., arrival of an ack, or timeout) after this adjustment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい外部イベントがcwndの変更を生成しなくても、cwndがセクション3.2、ステップ3にある式によって設定された直後に、一部のTCP実装がスロースタートまたは輻輳回避ウィンドウ更新アルゴリズムに入ることが確認されています。高速リカバリを終了する手順（セクション3.2、ステップ3）に基づいてcwndを設定した後は、この調整後にさらにイベント（ACKの到着、タイムアウトなど）が発生するまでcwndを更新しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] discusses general security considerations concerning TCP congestion control. This document describes a specific algorithm that conforms with the congestion control requirements of [RFC5681], and so those considerations apply to this algorithm, too. There are no known additional security concerns for this specific algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]は、TCP輻輳制御に関する一般的なセキュリティの考慮事項について説明します。このドキュメントでは、[RFC5681]の輻輳制御要件に準拠する特定のアルゴリズムについて説明しているため、これらの考慮事項はこのアルゴリズムにも適用されます。この特定のアルゴリズムに関する既知の追加のセキュリティ問題はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Conclusions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 結論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies the NewReno fast retransmit and fast recovery algorithms for TCP. This NewReno modification to TCP can even be important for TCP implementations that support the SACK option, because the SACK option can only be used for TCP connections when both TCP end-nodes support the SACK option. NewReno performs better than Reno in a number of scenarios discussed in previous versions of this RFC ([RFC2582] [RFC3782]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、TCPのNewReno高速再送信および高速リカバリアルゴリズムを指定します。 SACKオプションは、両方のTCPエンドノードがSACKオプションをサポートしている場合にのみTCP接続に使用できるため、TCPに対するこのNewRenoの変更は、SACKオプションをサポートするTCP実装にとっても重要になる可能性があります。 NewRenoは、このRFCの以前のバージョン（[RFC2582] [RFC3782]）で説明されているいくつかのシナリオで、Renoよりもパフォーマンスが優れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of options for the basic algorithms presented in Section 3 are also referenced in Appendix A of this document. These include the handling of the retransmission timer, the response to partial acknowledgments, and whether or not the sender must maintain a state variable called recover. Our belief is that the differences between these variants of NewReno are small compared to the differences between Reno and NewReno. That is, the important thing is to implement NewReno instead of Reno for a TCP connection without SACK; it is less important exactly which variant of NewReno is implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3で示した基本的なアルゴリズムの多くのオプションは、このドキュメントの付録Aでも参照されています。これらには、再送信タイマーの処理、部分的な確認応答への応答、および送信側が回復と呼ばれる状態変数を維持する必要があるかどうかが含まれます。私たちの信念は、NewRenoのこれらのバリアントの違いは、RenoとNewRenoの違いに比べて小さいということです。つまり、重要なことは、SACKなしのTCP接続に対してRenoではなくNewRenoを実装することです。 NewRenoのどのバリアントが実装されているかは、それほど重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many thanks to Anil Agarwal, Mark Allman, Armando Caro, Jeffrey Hsu, Vern Paxson, Kacheong Poon, Keyur Shah, and Bernie Volz for detailed feedback on the precursor RFCs 2582 and 3782. Jeffrey Hsu provided clarifications on the handling of the variable recover; these clarifications were applied to RFC 3782 via an erratum and are incorporated into the text of Section 6 of this document. Yoshifumi Nishida contributed a modification to the fast recovery algorithm to account for the case in which FlightSize is 0 when the TCP sender leaves fast recovery and the TCP receiver uses delayed acknowledgments. Alexander Zimmermann provided several suggestions to improve the clarity of the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 2582および3782の前駆体に関する詳細なフィードバックを提供してくれたAnil Agarwal、Mark Allman、Armando Caro、Jeffrey Hsu、Vern Paxson、Kacheong Poon、Keyur Shah、およびBernie Volzに感謝します。JeffreyHsuは、変数回復の処理についての説明を提供しました。これらの説明は正誤表を介してRFC 3782に適用され、このドキュメントのセクション6のテキストに組み込まれています。 TCP送信者が高速復旧を離れ、TCP受信者が遅延確認応答を使用するときにFlightSizeが0である場合を説明するために、西田喜文は高速復旧アルゴリズムに変更を加えました。 Alexander Zimmermannは、ドキュメントの明瞭さを改善するためのいくつかの提案を提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman、M.、Paxson、V。、およびE. Blanton、「TCP Congestion Control」、RFC 5681、2009年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[C98] Cardwell, N., &#34;delayed ACKs for retransmitted packets: ouch!&#34;. November 1998, Email to the tcpimpl mailing list, archived at &lt;http://groups.yahoo.com/group/tcp-impl/message/1428&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[C98] Cardwell、N。、「再送信されたパケットの遅延ACK：痛い！」。 1998年11月、&lt;http://groups.yahoo.com/group/tcp-impl/message/1428&gt;にアーカイブされたtcpimplメーリングリストへのメール。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[F94] Floyd, S., &#34;TCP and Successive Fast Retransmits&#34;, Technical report, May 1995. &lt;ftp://ftp.ee.lbl.gov/papers/fastretrans.ps&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[F94] Floyd、S。、「TCP and Successive Fast Retransmits」、テクニカルレポート、1995年5月。&lt;ftp://ftp.ee.lbl.gov/papers/fastretrans.ps&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FF96] Fall, K. and S. Floyd, &#34;Simulation-based Comparisons of Tahoe, Reno and SACK TCP&#34;, Computer Communication Review, July 1996. &lt;ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FF96]秋、K.、S。フロイド、「タホ、リノ、SACK TCPのシミュレーションベースの比較」、Computer Communication Review、1996年7月。&lt;ftp://ftp.ee.lbl.gov/papers/sacks。 ps.Z&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GF04] Gurtov, A. and S. Floyd, &#34;Resolving Acknowledgment Ambiguity in non-SACK TCP&#34;, NExt Generation Teletraffic and Wired/Wireless Advanced Networking (NEW2AN&#39;04), February 2004. &lt;http://www.cs.helsinki.fi/u/gurtov/ papers/heuristics.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GF04] Gurtov、A。およびS. Floyd、「非SACK TCPにおける確認のあいまいさの解決」、NExt Generation Teletraffic and Wired / Wireless Advanced Networking（NEW2AN&#39;04）、2004年2月。&lt;http：//www.cs。 helsinki.fi/u/gurtov/papers/heuristics.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Gur03] Gurtov, A., &#34;[Tsvwg] resolving the problem of unnecessary fast retransmits in go-back-N&#34;, email to the tsvwg mailing list, July 28, 2003. &lt;http://www.ietf.org/mail-archive/ web/tsvwg/current/msg04334.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Gur03] Gurtov、A。、「[[Tsvwg] go-back-Nでの不要な高速再送信の問題の解決」、2003年7月28日、tsvwgメーリングリストへのメール。&lt;http://www.ietf.org/ mail-archive / web / tsvwg / current / msg04334.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Hen98] Henderson, T., &#34;Re: NewReno and the 2001 Revision&#34;, September 1998. Email to the tcpimpl mailing list, archived at &lt;http://groups.yahoo.com/group/tcp-impl/message/1321&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Hen98] Henderson、T。、「Re：NewReno and 2001 Revision」、1998年9月。&lt;http://groups.yahoo.com/group/tcp-impl/message/1321にアーカイブされたtcpimplメーリングリストに電子メールで送信します。 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Hoe95] Hoe, J., &#34;Startup Dynamics of TCP&#39;s Congestion Control and Avoidance Schemes&#34;, Master&#39;s Thesis, MIT, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Hoe95] Hoe、J。、「TCPの輻輳制御および回避スキームのスタートアップダイナミクス」、修士論文、MIT、1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Hoe96] Hoe, J., &#34;Improving the Start-up Behavior of a Congestion Control Scheme for TCP&#34;, ACM SIGCOMM, August 1996. &lt;http://ccr.sigcomm.org/archive/1996/conf/hoe.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Hoe96] Hoe、J。、「TCPの輻輳制御方式の起動動作の改善」、ACM SIGCOMM、1996年8月。&lt;http://ccr.sigcomm.org/archive/1996/conf/hoe.pdf &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LM97] Lin, D. and R. Morris, &#34;Dynamics of Random Early Detection&#34;, SIGCOMM 97, October 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LM97]リン、D。、およびR.モリス、「ランダム初期検出のダイナミクス」、SIGCOMM 97、1997年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NS] &#34;The Network Simulator version 2 (ns-2)&#34;, &lt;http://www.isi.edu/nsnam/ns/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NS]「ネットワークシミュレータバージョン2（ns-2）」、&lt;http://www.isi.edu/nsnam/ns/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1323] Jacobson, V., Braden, R., and D. Borman, &#34;TCP Extensions for High Performance&#34;, RFC 1323, May 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1323] Jacobson、V.、Braden、R。、およびD. Borman、「高性能のTCP拡張機能」、RFC 1323、1992年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2582] Floyd, S. and T. Henderson, &#34;The NewReno Modification to TCP&#39;s Fast Recovery Algorithm&#34;, RFC 2582, April 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2582]フロイド、S。およびT.ヘンダーソン、「TCPの高速リカバリアルゴリズムに対するNewRenoの変更」、RFC 2582、1999年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, &#34;An Extension to the Selective Acknowledgement (SACK) Option for TCP&#34;, RFC 2883, July 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2883]フロイド、S。、マハビ、J。、マティス、M。、およびM.ポドルスキー、「TCPの選択的確認応答（SACK）オプションの拡張」、RFC 2883、2000年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3042] Allman, M., Balakrishnan, H., and S. Floyd, &#34;Enhancing TCP&#39;s Loss Recovery Using Limited Transmit&#34;, RFC 3042, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3042] Allman、M.、Balakrishnan、H。、およびS. Floyd、「Enhancing TCP&#39;s Loss Recovery Using Limited Transmit」、RFC 3042、2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3522] Ludwig, R. and M. Meyer, &#34;The Eifel Detection Algorithm for TCP&#34;, RFC 3522, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3522] Ludwig、R。およびM. Meyer、「TCPのEifel検出アルゴリズム」、RFC 3522、2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782] Floyd, S., Henderson, T., and A. Gurtov, &#34;The NewReno Modification to TCP&#39;s Fast Recovery Algorithm&#34;, RFC 3782, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]フロイド、S。、ヘンダーソン、T。、およびA.グルトフ、「TCPの高速リカバリアルゴリズムに対するNewRenoの変更」、RFC 3782、2004年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A. Additional Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A.追加情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Previous versions of this RFC ([RFC2582] [RFC3782]) contained additional informative material on the following subjects, and may be consulted by readers who may want more information about possible variants to the algorithms and who may want references to specific [NS] simulations that provide NewReno test cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このRFCの以前のバージョン（[RFC2582] [RFC3782]）には、次の主題に関する追加の情報資料が含まれており、アルゴリズムの可能なバリアントに関する詳細情報が必要な読者や、特定の[NS]シミュレーションへの参照が必要な読者が参照することがあります。 NewRenoテストケースを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 4 of [RFC3782] discusses some alternative behaviors for resetting the retransmit timer after a partial acknowledgment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]のセクション4では、部分的な確認応答後に再送信タイマーをリセットするためのいくつかの代替動作について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 5 of [RFC3782] discusses some alternative behaviors for performing retransmission after a partial acknowledgment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]のセクション5では、部分的な確認応答の後に再送信を実行するためのいくつかの代替動作について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 6 of [RFC3782] describes more information about the motivation for the sender&#39;s state variable recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]のセクション6では、送信者の状態変数が回復する動機について詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 9 of [RFC3782] introduces some NS simulation test suites for NewReno. In addition, references to simulation results can be found throughout [RFC3782].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]のセクション9では、NewRenoのNSシミュレーションテストスイートを紹介しています。さらに、シミュレーション結果への参照は[RFC3782]全体にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 10 of [RFC3782] provides a comparison of Reno and NewReno TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]のセクション10は、RenoとNewReno TCPの比較を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 11 of [RFC3782] lists changes relative to [RFC2582].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]のセクション11は、[RFC2582]に関連する変更点を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix B. Changes Relative to RFC 3782
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. RFC 3782に関連する変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In [RFC3782], the cwnd after Full ACK reception will be set to (1) min (ssthresh, FlightSize + SMSS) or (2) ssthresh. However, the first option carries a risk of performance degradation: With the first option, if FlightSize is zero, the result will be 1 SMSS. This means TCP can transmit only 1 segment at that moment, which can cause a delay in ACK transmission at the receiver due to a delayed ACK algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]では、フルACK受信後のcwndは（1）分（ssthresh、FlightSize + SMSS）または（2）ssthreshに設定されます。ただし、最初のオプションにはパフォーマンス低下のリスクがあります。最初のオプションでは、FlightSizeがゼロの場合、結果は1 SMSSになります。これは、TCPがその時点で送信できるのは1セグメントのみであることを意味します。これにより、遅延ACKアルゴリズムが原因で、受信側でのACK送信が遅延する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FlightSize on Full ACK reception can be zero in some situations. A typical example is where the sending window size during fast recovery is small. In this case, the retransmitted packet and new data packets can be transmitted within a short interval. If all these packets successfully arrive, the receiver may generate a Full ACK that acknowledges all outstanding data. Even if the window size is not small, loss of ACK packets or a receive buffer shortage during fast recovery can also increase the possibility of falling into this situation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状況によっては、フルACK受信時のFlightSizeがゼロになることがあります。典型的な例は、高速リカバリ中の送信ウィンドウサイズが小さい場合です。この場合、再送信されたパケットと新しいデータパケットを短い間隔で送信できます。これらすべてのパケットが正常に到着した場合、受信者はすべての未処理のデータを確認するフルACKを生成することがあります。ウィンドウサイズが小さくない場合でも、高速回復中にACKパケットが失われたり、受信バッファーが不足したりすると、この状況に陥る可能性が高くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The proposed fix in this document, which sets cwnd to at least 2*SMSS if the implementation uses option 1 in the Full ACK case (Section 3.2, step 3, option 1), ensures that the sender TCP transmits at least two segments on Full ACK reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで提案されている修正は、実装がフルACKケース（セクション3.2、ステップ3、オプション1）でオプション1を使用する場合にcwndを少なくとも2 * SMSSに設定し、送信側TCPがフルで少なくとも2つのセグメントを送信することを保証します。 ACK受信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, an erratum was reported for RFC 3782 (an editorial clarification to Section 8); this erratum has been addressed in Section 6 of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、RFC 3782（セクション8への編集上の明確化）のエラッタが報告されました。このエラッタは、このドキュメントのセクション6で対処されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specification text (Section 3.2 herein) was rewritten to more closely track Section 3.2 of [RFC5681].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様テキスト（ここのセクション3.2）は、[RFC5681]のセクション3.2をより厳密に追跡するように書き直されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sections 4, 5, and 9-11 of [RFC3782] were removed, and instead Appendix A of this document was added to back-reference this informative material. A few references that have no citation in the main body of the document have been removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]のセクション4、5、および9-11が削除され、代わりにこのドキュメントの付録Aが追加され、この有益な資料を後方参照しました。文書の本文で引用されていないいくつかの参照が削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tom Henderson The Boeing Company
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トムヘンダーソンザボーイングカンパニー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: thomas.r.henderson@boeing.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sally Floyd International Computer Science Institute
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サリーフロイドインターナショナルコンピュータサイエンスインスティテュート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 (510) 666-2989
   EMail: floyd@acm.org
   URL: http://www.icir.org/floyd/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andrei Gurtov University of Oulu Centre for Wireless Communications CWC P.O. Box 4500 FI-90014 University of Oulu Finland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アンドレイ・グルトフオウル大学ワイヤレス通信センターCWC P.O.ボックス4500 FI-90014フィンランドオウル大学
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: gurtov@ee.oulu.fi
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yoshifumi Nishida WIDE Project Endo 5322 Fujisawa, Kanagawa 252-8520 Japan
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
よしふみ にしだ うぃで Ｐろじぇｃｔ えんど ５３２２ ふじさわ、 かながわ ２５２ー８５２０ じゃぱん
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: nishida@wide.ad.jp
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
