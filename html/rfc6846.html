<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 6846 - RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6846</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc6846">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <!-- <div class="row"> -->
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6846 - RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc6846">
              https://datatracker.ietf.org/doc/html/rfc6846
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6846 - RObustヘッダー圧縮（ROHC）：TCP / IP（ROHC-TCP）のプロファイル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    <!-- </div> -->
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                      G. Pelletier
Request for Comments: 6846                   InterDigital Communications
Obsoletes: 4996                                              K. Sandlund
Category: Standards Track                                       Ericsson
ISSN: 2070-1721                                             L-E. Jonsson
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-54">
 M. West Siemens/Roke Manor January 2013
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-54">
Ｍ。 うぇｓｔ しえめんｓ／ろけ まのｒ じゃぬあｒｙ ２０１３
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
RObustヘッダー圧縮（ROHC）：TCP / IP（ROHC-TCP）のプロファイル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies a RObust Header Compression (ROHC) profile for compression of TCP/IP packets. The profile, called ROHC-TCP, provides efficient and robust compression of TCP headers, including frequently used TCP options such as selective acknowledgments (SACKs) and Timestamps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、TCP / IPパケットを圧縮するためのRObust Header Compression（ROHC）プロファイルを指定しています。 ROHC-TCPと呼ばれるプロファイルは、選択的確認応答（SACK）やタイムスタンプなどの頻繁に使用されるTCPオプションを含め、TCPヘッダーの効率的で堅牢な圧縮を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP works well when used over links with significant error rates and long round-trip times. For many bandwidth-limited links where header compression is essential, such characteristics are common.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPは、エラー率が高く、ラウンドトリップ時間が長いリンクで使用するとうまく機能します。ヘッダーの圧縮が不可欠である多くの帯域幅が制限されたリンクでは、このような特性が一般的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification obsoletes RFC 4996. It fixes a technical issue with the SACK compression and clarifies other compression methods used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様はRFC 4996を廃止します。SACK圧縮の技術的な問題を修正し、使用される他の圧縮方法を明確にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはInternet Standards Trackドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6846.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6846で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2013 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................5
   2. Terminology .....................................................5
   3. Background ......................................................7
      3.1. Existing TCP/IP Header Compression Schemes .................7
      3.2. Classification of TCP/IP Header Fields .....................8
   4. Overview of the TCP/IP Profile (Informative) ...................10
      4.1. General Concepts ..........................................10
      4.2. Compressor and Decompressor Interactions ..................10
           4.2.1. Compressor Operation ...............................10
           4.2.2. Decompressor Feedback ..............................11
      4.3. Packet Formats and Encoding Methods .......................11
           4.3.1. Compressing TCP Options ............................11
           4.3.2. Compressing Extension Headers ......................11
      4.4. Expected Compression Ratios with ROHC-TCP .................12
   5. Compressor and Decompressor Logic (Normative) ..................13
      5.1. Context Initialization ....................................13
      5.2. Compressor Operation ......................................13
           5.2.1. Compression Logic ..................................13
                  5.2.1.1. Optimistic Approach .......................14
                  5.2.1.2. Periodic Context Refreshes ................14
           5.2.2. Feedback Logic .....................................14
                  5.2.2.1. Optional Acknowledgments (ACKs) ...........14
                  5.2.2.2. Negative Acknowledgments (NACKs) ..........15
           5.2.3. Context Replication ................................15
      5.3. Decompressor Operation ....................................16
           5.3.1. Decompressor States and Logic ......................16
                  5.3.1.1. Reconstruction and Verification ...........16
                  5.3.1.2. Detecting Context Damage ..................17
                  5.3.1.3. No Context (NC) State .....................18
                  5.3.1.4. Static Context (SC) State .................18
                  5.3.1.5. Full Context (FC) State ...................19
           5.3.2. Feedback Logic .....................................19
           5.3.3. Context Replication ................................20
   6. Encodings in ROHC-TCP (Normative) ..............................20
      6.1. Control Fields in ROHC-TCP ................................20
           6.1.1. Master Sequence Number (MSN) .......................20
           6.1.2. IP-ID Behavior .....................................21
           6.1.3. Explicit Congestion Notification (ECN) .............22
      6.2. Compressed Header Chains ..................................22
      6.3. Compressing TCP Options with List Compression .............24
           6.3.1. List Compression ...................................25
           6.3.2. Table-Based Item Compression .......................26
           6.3.3. Encoding of Compressed Lists .......................26
           6.3.4. Item Table Mappings ................................28
           6.3.5. Compressed Lists in Dynamic Chain ..................30
           6.3.6. Irregular Chain Items for TCP Options ..............30
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
           6.3.7. Replication of TCP Options .........................30
      6.4. Profile-Specific Encoding Methods .........................31
           6.4.1. inferred_ip_v4_header_checksum .....................31
           6.4.2. inferred_mine_header_checksum ......................31
           6.4.3. inferred_ip_v4_length ..............................32
           6.4.4. inferred_ip_v6_length ..............................32
           6.4.5. inferred_offset ....................................33
           6.4.6. baseheader_extension_headers .......................33
           6.4.7. baseheader_outer_headers ...........................34
           6.4.8. Scaled Encoding of Fields ..........................34
                  6.4.8.1. Scaled TCP Sequence Number Encoding .......35
                  6.4.8.2. Scaled Acknowledgment Number Encoding .....35
      6.5. Encoding Methods with External Parameters .................36
   7. Packet Types (Normative) .......................................38
      7.1. Initialization and Refresh (IR) Packets ...................38
      7.2. Context Replication (IR-CR) Packets .......................40
      7.3. Compressed (CO) Packets ...................................42
   8. Header Formats (Normative) .....................................43
      8.1. Design Rationale for Compressed Base Headers ..............44
      8.2. Formal Definition of Header Formats .......................47
      8.3. Feedback Formats and Options ..............................88
           8.3.1. Feedback Formats ...................................88
           8.3.2. Feedback Options ...................................89
                  8.3.2.1. The REJECT Option .........................89
                  8.3.2.2. The MSN-NOT-VALID Option ..................90
                  8.3.2.3. The MSN Option ............................90
                  8.3.2.4. The CONTEXT_MEMORY Feedback Option ........91
                  8.3.2.5. Unknown Option Types ......................91
   9. Changes from RFC 4996 ..........................................91
      9.1. Functional Changes ........................................91
      9.2. Non-functional Changes ....................................92
   10. Security Considerations .......................................92
   11. IANA Considerations ...........................................93
   12. Acknowledgments ...............................................93
   13. References ....................................................93
      13.1. Normative References .....................................93
      13.2. Informative References ...................................94
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several reasons to perform header compression on low- or medium-speed links for TCP/IP traffic, and these have already been discussed in [RFC2507]. Additional considerations that make robustness an important objective for a TCP [RFC0793] compression scheme are introduced in [RFC4163]. Finally, existing TCP/IP header compression schemes ([RFC1144], [RFC2507]) are limited in their handling of the TCP options field and cannot compress the headers of handshaking packets (SYNs and FINs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP / IPトラフィックの低速または中速リンクでヘッダー圧縮を実行する理由はいくつかあり、これらはすでに[RFC2507]で説明されています。 [RFC4163]では、TCP [RFC0793]圧縮スキームの堅牢性を重要な目的とする追加の考慮事項が導入されています。最後に、既存のTCP / IPヘッダー圧縮スキーム（[RFC1144]、[RFC2507]）は、TCPオプションフィールドの処理に制限があり、ハンドシェイクパケット（SYNおよびFIN）のヘッダーを圧縮できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is thus desirable for a header compression scheme to be able to handle loss on the link between the compression and decompression points as well as loss before the compression point. The header compression scheme also needs to consider how to efficiently compress short-lived TCP transfers and TCP options, such as selective acknowledgments (SACK) ([RFC2018], [RFC2883]) and Timestamps ([RFC1323]). TCP options that may be less frequently used do not necessarily need to be compressed by the protocol, and instead can be passed transparently without reducing the overall compression efficiency of other parts of the TCP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、ヘッダ圧縮スキームが、圧縮ポイントと解凍ポイントとの間のリンクの損失、および圧縮ポイントの前の損失を処理できることが望ましい。ヘッダー圧縮スキームでは、選択的確認応答（SACK）（[RFC2018]、[RFC2883]）やタイムスタンプ（[RFC1323]）などの短期間のTCP転送とTCPオプションを効率的に圧縮する方法も考慮する必要があります。使用頻度の低いTCPオプションは必ずしもプロトコルで圧縮する必要はなく、代わりにTCPヘッダーの他の部分の全体的な圧縮効率を低下させることなく透過的に渡すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Robust Header Compression (ROHC) Working Group has developed a header compression framework on top of which various profiles can be defined for different protocol sets, or for different compression strategies. This document defines a TCP/IP compression profile for the ROHC framework [RFC5795], compliant with the requirements listed in [RFC4163].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robust Header Compression（ROHC）ワーキンググループは、ヘッダー圧縮フレームワークを開発しました。その上に、さまざまなプロトコルセットまたはさまざまな圧縮戦略のためにさまざまなプロファイルを定義できます。このドキュメントは、[RFC4163]にリストされている要件に準拠するROHCフレームワーク[RFC5795]のTCP / IP圧縮プロファイルを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, it describes a header compression scheme for TCP/IP header compression (ROHC-TCP) that is robust against packet loss and that offers enhanced capabilities, in particular for the compression of header fields including TCP options. The profile identifier for TCP/IP compression is 0x0006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、TCP / IPヘッダー圧縮（ROHC-TCP）のヘッダー圧縮スキームについて説明します。これは、パケット損失に対して堅牢であり、特にTCPオプションを含むヘッダーフィールドの圧縮に拡張機能を提供します。 TCP / IP圧縮のプロファイル識別子は0x0006です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 This document reuses some of the terminology found in [RFC5795]. In addition, this document uses or defines the following terms: Base context
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このドキュメントは、[RFC5795]にあるいくつかの用語を再利用します。さらに、このドキュメントでは次の用語を使用または定義しています。基本コンテキスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The base context is a context that has been validated by both the compressor and the decompressor. A base context can be used as the reference when building a new context using replication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
基本コンテキストは、コンプレッサーとデコンプレッサーの両方によって検証されたコンテキストです。ベースコンテキストは、レプリケーションを使用して新しいコンテキストを構築するときの参照として使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Base Context Identifier (Base CID)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベースコンテキスト識別子（ベースCID）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The Base CID is the CID that identifies the base context, from which information needed for context replication can be extracted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ベースCIDは、ベースコンテキストを識別するCIDであり、そこからコンテキストレプリケーションに必要な情報を抽出できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Base header
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベースヘッダー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The Base header is a compressed representation of the innermost IP and TCP headers of the uncompressed packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Baseヘッダーは、非圧縮パケットの最も内側のIPおよびTCPヘッダーの圧縮表現です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chaining of items
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アイテムのチェーン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A chain groups fields based on similar characteristics. ROHC-TCP defines chain items for static, dynamic, replicable, or irregular fields. Chaining is done by appending an item for each header, e.g., to the chain in their order of appearance in the uncompressed packet. Chaining is useful to construct compressed headers from an arbitrary number of any of the protocol headers for which ROHC-TCP defines a compressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
チェーンは、同様の特性に基づいてフィールドをグループ化します。 ROHC-TCPは、静的、動的、複製可能、または不規則なフィールドのチェーン項目を定義します。チェーンは、各ヘッダーの項目を、たとえば、非圧縮パケットの出現順にチェーンに追加することによって行われます。チェーンは、ROHC-TCPが圧縮形式を定義するプロトコルヘッダーの任意の数から圧縮ヘッダーを構築するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Context Replication (CR)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキスト複製（CR）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Context replication is the mechanism that establishes and initializes a new context based on another existing valid context (a base context). This mechanism is introduced to reduce the overhead of the context establishment procedure, and is especially useful for compression of multiple short-lived TCP connections that may be occurring simultaneously or near-simultaneously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
コンテキストレプリケーションは、別の既存の有効なコンテキスト（ベースコンテキスト）に基づいて新しいコンテキストを確立および初期化するメカニズムです。このメカニズムは、コンテキスト確立手順のオーバーヘッドを削減するために導入され、同時にまたはほぼ同時に発生する可能性がある複数の短期間のTCP接続の圧縮に特に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP packet types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPパケットタイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ROHC-TCP uses three different packet types: the Initialization and Refresh (IR) packet type, the Context Replication (IR-CR) packet type, and the Compressed packet (CO) type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ROHC-TCPは、3つの異なるパケットタイプを使用します。初期化およびリフレッシュ（IR）パケットタイプ、コンテキストレプリケーション（IR-CR）パケットタイプ、および圧縮パケット（CO）タイプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Short-lived TCP transfer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
短期間のTCP転送
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Short-lived TCP transfers refer to TCP connections transmitting only small amounts of packets for each single connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
短期間のTCP転送とは、単一の接続ごとに少量のパケットのみを送信するTCP接続を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. バックグラウンド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides some background information on TCP/IP header compression. The fundamentals of general header compression can be found in [RFC5795]. In the following subsections, two existing TCP/IP header compression schemes are first described along with a discussion of their limitations, followed by the classification of TCP/IP header fields. Finally, some of the characteristics of short-lived TCP transfers are summarized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、TCP / IPヘッダー圧縮に関する背景情報を提供します。一般的なヘッダー圧縮の基本は[RFC5795]にあります。次のサブセクションでは、まず2つの既存のTCP / IPヘッダー圧縮方式について説明し、それらの制限について説明した後、TCP / IPヘッダーフィールドの分類について説明します。最後に、短期間のTCP転送の特性のいくつかを要約します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A behavior analysis of TCP/IP header fields is found in [RFC4413].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP / IPヘッダーフィールドの動作分析は、[RFC4413]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Existing TCP/IP Header Compression Schemes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 既存のTCP / IPヘッダー圧縮スキーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compressed TCP (CTCP) and IP Header Compression (IPHC) are two different schemes that may be used to compress TCP/IP headers. Both schemes transmit only the differences from the previous header in order to reduce the size of the TCP/IP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮TCP（CTCP）とIPヘッダー圧縮（IPHC）は、TCP / IPヘッダーの圧縮に使用できる2つの異なる方式です。どちらの方式も、TCP / IPヘッダーのサイズを小さくするために、前のヘッダーとの違いのみを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CTCP [RFC1144] compressor detects transport-level retransmissions and sends a header that updates the context completely when they occur. While CTCP works well over reliable links, it is vulnerable when used over less reliable links as even a single packet loss results in loss of synchronization between the compressor and the decompressor. This in turn leads to the TCP receiver discarding all remaining packets in the current window because of a checksum error. This effectively prevents the TCP fast retransmit algorithm [RFC5681] from being triggered. In such a case, the compressor must wait until TCP times out and retransmits a packet to resynchronize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CTCP [RFC1144]コンプレッサーは、トランスポートレベルの再送信を検出し、それらが発生したときにコンテキストを完全に更新するヘッダーを送信します。 CTCPは信頼性の高いリンクでうまく機能しますが、単一のパケット損失でもコンプレッサーとデコンプレッサーの間の同期が失われる結果となるため、信頼性の低いリンクで使用すると脆弱になります。これにより、チェックサムエラーが原因で、TCPレシーバーが現在のウィンドウに残っているすべてのパケットを破棄することになります。これにより、TCP高速再送信アルゴリズム[RFC5681]がトリガーされるのを効果的に防ぎます。このような場合、コンプレッサーはTCPがタイムアウトし、パケットを再送信して再同期するまで待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To reduce the errors due to the inconsistent contexts between compressor and decompressor when compressing TCP, IPHC [RFC2507] improves somewhat on CTCP by augmenting the repair mechanism of CTCP with a local repair mechanism called TWICE and with a link-layer mechanism based on negative acknowledgments to request a header that updates the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPHC [RFC2507]は、TCPを圧縮するときのコンプレッサーとデコンプレッサー間の不整合なコンテキストによるエラーを減らすために、TWICEと呼ばれるローカル修復メカニズムと否定応答に基づくリンク層メカニズムでCTCPの修復メカニズムを強化することにより、CTCPをいくらか改善します。コンテキストを更新するヘッダーをリクエストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TWICE algorithm assumes that only the Sequence Number field of TCP segments is changing with the deltas between consecutive packets being constant in most cases. This assumption is, however, not always true, especially when TCP Timestamps and SACK options are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TWICEアルゴリズムは、TCPセグメントのシーケンス番号フィールドのみが変化することを前提としています。ほとんどの場合、連続するパケット間のデルタは一定です。ただし、この仮定は常に当てはまるわけではありません。特に、TCPタイムスタンプおよびSACKオプションが使用されている場合はそうです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full header request mechanism requires a feedback channel that may be unavailable in some circumstances. This channel is used to explicitly request that the next packet be sent with an uncompressed header to allow resynchronization without waiting for a TCP timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全なヘッダー要求メカニズムには、状況によっては使用できないフィードバックチャネルが必要です。このチャネルは、次のパケットが非圧縮ヘッダーで送信され、TCPタイムアウトを待たずに再同期できるように明示的に要求するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, this mechanism does not perform well on links with long round-trip times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、このメカニズムは、ラウンドトリップ時間が長いリンクではうまく機能しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both CTCP and IPHC are also limited in their handling of the TCP options field. For IPHC, any change in the options field (caused by Timestamps or SACK, for example) renders the entire field uncompressible, while for CTCP, such a change in the options field effectively disables TCP/IP header compression altogether.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CTCPとIPHCはどちらも、TCPオプションフィールドの処理に制限があります。 IPHCの場合、（TimestampsやSACKなどが原因で）オプションフィールドを変更すると、フィールド全体が圧縮できなくなりますが、CTCPの場合、オプションフィールドを変更すると、TCP / IPヘッダー圧縮が完全に無効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, existing TCP/IP compression schemes do not compress the headers of handshaking packets (SYNs and FINs). Compressing these packets may greatly improve the overall header compression ratio for the cases where many short-lived TCP connections share the same channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、既存のTCP / IP圧縮スキームは、ハンドシェイクパケット（SYNおよびFIN）のヘッダーを圧縮しません。これらのパケットを圧縮すると、多くの短期間のTCP接続が同じチャネルを共有する場合の全体的なヘッダー圧縮率が大幅に向上する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Classification of TCP/IP Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. TCP / IPヘッダーフィールドの分類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header compression is possible due to the fact that there is much redundancy between header field values within packets, especially between consecutive packets. To utilize these properties for TCP/IP header compression, it is important to understand the change patterns of the various header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダー圧縮は、パケット内のヘッダーフィールド値の間、特に連続したパケット間で多くの冗長性があるために可能です。これらのプロパティをTCP / IPヘッダー圧縮に利用するには、さまざまなヘッダーフィールドの変更パターンを理解することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All fields of the TCP/IP packet header have been classified in detail in [RFC4413]. The main conclusion is that most of the header fields can easily be compressed away since they seldom or never change. The following fields do, however, require more sophisticated mechanisms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP / IPパケットヘッダーのすべてのフィールドは、[RFC4413]で詳細に分類されています。主な結論は、ほとんどまたはまったく変更されないため、ほとんどのヘッダーフィールドは簡単に圧縮できるということです。ただし、次のフィールドには、より高度なメカニズムが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- IPv4 Identification (16 bits) - IP-ID - TCP Sequence Number (32 bits) - SN - TCP Acknowledgment Number (32 bits) - TCP Reserved ( 4 bits) - TCP ECN flags ( 2 bits) - ECN - TCP Window (16 bits) - TCP Options o Maximum Segment Size (32 bits) - MSS o Window Scale (24 bits) - WSCALE o SACK Permitted (16 bits) o TCP SACK (80, 144, 208, or 272 bits) - SACK o TCP Timestamp (80 bits) - TS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- IPv4識別（16ビット）-IP-ID-TCPシーケンス番号（32ビット）-SN-TCP確認番号（32ビット）-TCP予約済み（4ビット）-TCP ECNフラグ（2ビット）-ECN-TCPウィンドウ（16ビット）-TCPオプションo最大セグメントサイズ（32ビット）-MSS oウィンドウスケール（24ビット）-WSCALE o SACK許可（16ビット）o TCP SACK（80、144、208、または272ビット）-SACK o TCPタイムスタンプ（80ビット）-TS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The assignment of IP-ID values can be done in various ways, usually one of sequential, sequential jump, or random, as described in Section 4.1.3 of [RFC4413]. Some IPv4 stacks do use a sequential assignment when generating IP-ID values but do not transmit the contents of this field in network byte order; instead, it is sent with the two octets reversed. In this case, the compressor can compress the IP-ID field after swapping the bytes. Consequently, the decompressor also swaps the bytes of the IP-ID after decompression to regenerate the original IP-ID. With respect to TCP compression, the analysis in [RFC4413] reveals that there is no obvious candidate among the TCP fields suitable to infer the IP-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
[RFC4413]のセクション4.1.3で説明されているように、IP-ID値の割り当てはさまざまな方法で行うことができます。通常、順次、順次ジャンプ、ランダムのいずれかです。一部のIPv4スタックは、IP-ID値を生成するときに順次割り当てを使用しますが、このフィールドの内容をネットワークバイト順で送信しません。代わりに、2オクテットを逆にして送信されます。この場合、圧縮プログラムは、バイトをスワップした後でIP-IDフィールドを圧縮できます。その結果、圧縮解除プログラムは、元のIP-IDを再生成するために、圧縮解除後にIP-IDのバイトもスワップします。 TCP圧縮に関して、[RFC4413]の分析は、IP-IDを推論するのに適したTCPフィールドの中に明白な候補がないことを明らかにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change pattern of several TCP fields (Sequence Number, Acknowledgment Number, Window, etc.) is very hard to predict. Of particular importance to a TCP/IP header compression scheme is the understanding of the sequence and acknowledgment numbers [RFC4413].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのTCPフィールド（シーケンス番号、確認応答番号、ウィンドウなど）の変更パターンは、予測が非常に困難です。 TCP / IPヘッダー圧縮方式で特に重要なのは、シーケンス番号と確認応答番号の理解です[RFC4413]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, the TCP Sequence Number can be anywhere within a range defined by the TCP Window at any point on the path (i.e., wherever a compressor might be deployed). Missing packets or retransmissions can cause the TCP Sequence Number to fluctuate within the limits of this window. The TCP Window also bounds the jumps in acknowledgment number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、TCPシーケンス番号は、パス上の任意のポイント（つまり、コンプレッサーが配置される可能性がある場所）で、TCPウィンドウによって定義された範囲内の任意の場所にすることができます。パケットの欠落または再送信により、TCPシーケンス番号がこのウィンドウの制限内で変動する可能性があります。 TCPウィンドウは、確認応答番号のジャンプも制限します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another important behavior of the TCP/IP header is the dependency between the sequence number and the acknowledgment number. TCP connections can be either near-symmetrical or show a strong asymmetrical bias with respect to the data traffic. In the latter case, the TCP connections mainly have one-way traffic (Web browsing and file downloading, for example). This means that on the forward path (from server to client), only the sequence number is changing while the acknowledgment number remains constant for most packets; on the backward path (from client to server), only the acknowledgment number is changing and the sequence number remains constant for most packets. A compression scheme for TCP should thus have packet formats suitable for either cases, i.e., packet formats that can carry either only sequence number bits, only acknowledgment number bits, or both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP / IPヘッダーのもう1つの重要な動作は、シーケンス番号と確認応答番号の間の依存関係です。 TCP接続は、ほぼ対称的であるか、データトラフィックに関して強い非対称的なバイアスを示します。後者の場合、TCP接続には主に一方向のトラフィックがあります（Webの閲覧やファイルのダウンロードなど）。これは、（サーバーからクライアントへの）転送パスでは、シーケンス番号のみが変更され、承認番号はほとんどのパケットで一定のままであることを意味します。 （クライアントからサーバーへの）逆方向パスでは、確認応答番号のみが変更され、シーケンス番号はほとんどのパケットで一定のままです。したがって、TCPの圧縮方式は、どちらの場合にも適したパケット形式、つまりシーケンス番号ビットのみ、確認応答番号ビットのみ、またはその両方を運ぶことができるパケット形式を持つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, TCP flows can be short-lived transfers. Short-lived TCP transfers will degrade the performance of header compression schemes that establish a new context by initially sending full headers. Multiple simultaneous or near simultaneous TCP connections may exhibit much similarity in header field values and context values among each other, which would make it possible to reuse information between flows when initializing a new context. A mechanism to this end, context replication [RFC4164], makes the context establishment step faster and more efficient, by replicating part of an existing context to a new flow. The conclusion from [RFC4413] is that part of the IP sub-context, some TCP fields, and some context values can be replicated since they seldom change or change with only a small jump.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、TCPフローは短期間の転送になる可能性があります。存続期間の短いTCP転送は、最初に完全なヘッダーを送信することにより新しいコンテキストを確立するヘッダー圧縮スキームのパフォーマンスを低下させます。複数の同時またはほぼ同時のTCP接続は、ヘッダーフィールド値とコンテキスト値が互いに非常に類似している場合があり、新しいコンテキストを初期化するときにフロー間で情報を再利用できるようになります。このためのメカニズムであるコンテキスト複製[RFC4164]は、既存のコンテキストの一部を新しいフローに複製することにより、コンテキスト確立ステップをより速く効率的にします。 [RFC4413]からの結論は、IPサブコンテキストの一部、一部のTCPフィールド、および一部のコンテキスト値は、ほとんど変更されないか、わずかなジャンプで変更されるため、複製できるということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP also compresses the following headers: IPv6 Destination Options header [RFC2460], IPv6 Routing header [RFC2460], IPv6 Hop-by-Hop Options header [RFC2460], Authentication Header (AH) [RFC4302], Generic Routing Encapsulation (GRE) [RFC2784][RFC2890], and the Minimal Encapsulation (MINE) header [RFC2004].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPは、次のヘッダーも圧縮します。IPv6宛先オプションヘッダー[RFC2460]、IPv6ルーティングヘッダー[RFC2460]、IPv6ホップバイホップオプションヘッダー[RFC2460]、認証ヘッダー（AH）[RFC4302]、汎用ルーティングカプセル化（GRE ）[RFC2784] [RFC2890]、およびMinimal Encapsulation（MINE）ヘッダー[RFC2004]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Headers specific to Mobile IP (for IPv4 or IPv6) do not receive any special treatment in this document, for reasons similar to those described in [RFC3095].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3095]で説明されているのと同様の理由により、このドキュメントではモバイルIP（IPv4またはIPv6の場合）に固有のヘッダーは特別な扱いを受けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Overview of the TCP/IP Profile (Informative)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. TCP / IPプロファイルの概要（参考）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. General Concepts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 一般的な概念
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP uses the ROHC protocol as described in [RFC5795]. ROHC-TCP supports context replication as defined in [RFC4164]. Context replication can be particularly useful for short-lived TCP flows [RFC4413].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPは、[RFC5795]で説明されているROHCプロトコルを使用します。 ROHC-TCPは、[RFC4164]で定義されているコンテキスト複製をサポートしています。コンテキスト複製は、存続期間の短いTCPフローに特に役立ちます[RFC4413]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Compressor and Decompressor Interactions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. コンプレッサーとデコンプレッサーの相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Compressor Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. コンプレッサー操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header compression with ROHC can be conceptually characterized as the interaction of a compressor with a decompressor state machine. The compressor&#39;s task is to minimally send the information needed to successfully decompress a packet, based on a certain confidence regarding the state of the decompressor context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHCを使用したヘッダー圧縮は、概念的には、コンプレッサーとデコンプレッサーステートマシンの相互作用として特徴付けることができます。圧縮プログラムのタスクは、圧縮解除コンテキストの状態に関する一定の信頼性に基づいて、パケットを正常に解凍するために必要な情報を最小限に送信することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For ROHC-TCP compression, the compressor normally starts compression with the initial assumption that the decompressor has no useful information to process the new flow, and sends Initialization and Refresh (IR) packets. Alternatively, the compressor may also support Context Replication (CR) and use IR-CR packets [RFC4164], which attempts to reuse context information related to another flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP圧縮の場合、コンプレッサーは通常、デコンプレッサーが新しいフローを処理するための有用な情報を持たないという初期仮定で圧縮を開始し、初期化およびリフレッシュ（IR）パケットを送信します。あるいは、コンプレッサーはコンテキスト複製（CR）をサポートし、別のフローに関連するコンテキスト情報を再利用しようとするIR-CRパケット[RFC4164]を使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressor can then adjust the compression level based on its confidence that the decompressor has the necessary information to successfully process the Compressed (CO) packets that it selects. In other words, the task of the compressor is to ensure that the decompressor operates in the state that allows decompression of the most efficient CO packet(s), and to allow the decompressor to move to that state as soon as possible otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、圧縮プログラムは、圧縮解除プログラムが選択した圧縮（CO）パケットを正常に処理するために必要な情報を持っているという信頼度に基づいて、圧縮レベルを調整できます。言い換えると、コンプレッサーのタスクは、最も効率的なCOパケットの解凍を可能にする状態でデコンプレッサーが動作することを保証し、そうでない場合はできるだけ早くデコンプレッサーがその状態に移行できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Decompressor Feedback
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 減圧装置のフィードバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ROHC-TCP profile can be used in environments with or without feedback capabilities from decompressor to compressor. ROHC-TCP, however, assumes that if a ROHC feedback channel is available and if this channel is used at least once by the decompressor for a specific ROHC-TCP context, this channel will be used during the entire compression operation for that context. If the feedback channel disappears, compression should be restarted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPプロファイルは、圧縮解除プログラムから圧縮プログラムへのフィードバック機能がある環境とない環境で使用できます。ただし、ROHC-TCPは、ROHCフィードバックチャネルが使用可能で、このチャネルが特定のROHC-TCPコンテキストのデコンプレッサによって少なくとも1回使用される場合、そのチャネルの圧縮操作全体でこのチャネルが使用されることを前提としています。フィードバックチャネルが消えた場合は、圧縮を再開する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reception of either positive acknowledgments (ACKs) or negative acknowledgments (NACKs) establishes the feedback channel from the decompressor for the context for which the feedback was received. Once there is an established feedback channel for a specific context, the compressor should make use of this feedback to estimate the current state of the decompressor. This helps in increasing the compression efficiency by providing the information needed for the compressor to achieve the necessary confidence level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
肯定応答（ACK）または否定応答（NACK）のいずれかを受信すると、フィードバックが受信されたコンテキストの圧縮解除装置からのフィードバックチャネルが確立されます。特定のコンテキストに対して確立されたフィードバックチャネルがあると、コンプレッサーはこのフィードバックを利用して、デコンプレッサーの現在の状態を推定する必要があります。これは、コンプレッサーが必要な信頼レベルを達成するために必要な情報を提供することにより、圧縮効率を高めるのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ROHC-TCP feedback mechanism is limited in its applicability by the number of (least significant bit (LSB) encoded) master sequence number (MSN) (see Section 6.1.1) bits used in the FEEDBACK-2 format (see Section 8.3). It is not suitable for a decompressor to use feedback altogether where the MSN bits in the feedback could wrap around within one round-trip time. Instead, unidirectional operation -- where the compressor periodically sends larger context-updating packets -- is more appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPフィードバックメカニズムの適用範囲は、FEEDBACK-2形式（セクション8.3を参照）で使用される（最下位ビット（LSB）エンコード）マスターシーケンス番号（MSN）（セクション6.1.1を参照）ビットの数によって制限されます。 。フィードバックのMSNビットが1つのラウンドトリップ時間内にラップアラウンドする可能性がある場合、デコンプレッサがフィードバックを完全に使用することは適切ではありません。代わりに、単方向操作（コンプレッサーが定期的に大きなコンテキスト更新パケットを送信する）の方が適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Packet Formats and Encoding Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. パケット形式とエンコード方式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet formats and encoding methods used for ROHC-TCP are defined using the formal notation [RFC4997]. The formal notation is used to provide an unambiguous representation of the packet formats and a clear definition of the encoding methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPで使用されるパケット形式とエンコード方式は、正式な表記法[RFC4997]を使用して定義されています。形式表記は、パケット形式の明確な表現とエンコード方式の明確な定義を提供するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. Compressing TCP Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. TCPオプションの圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TCP options in ROHC-TCP are compressed using a list compression encoding that allows option content to be established so that TCP options can be added to the context without having to send all TCP options uncompressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPのTCPオプションは、オプションのコンテンツを確立できるリスト圧縮エンコーディングを使用して圧縮されているため、すべてのTCPオプションを圧縮せずに送信することなく、TCPオプションをコンテキストに追加できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. Compressing Extension Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. 拡張ヘッダーの圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP compresses the extension headers as listed in Section 3.2. These headers are treated exactly as other headers and thus have a static chain, a dynamic chain, an irregular chain, and a chain for context replication (Section 6.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPは、セクション3.2にリストされている拡張ヘッダーを圧縮します。これらのヘッダーは他のヘッダーとまったく同じように扱われるため、静的チェーン、動的チェーン、不規則なチェーン、およびコンテキストレプリケーション用のチェーンがあります（セクション6.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This means that headers appearing in or disappearing from the flow being compressed will lead to changes to the static chain. However, the change pattern of extension headers is not deemed to impair compression efficiency with respect to this design strategy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、圧縮されるフローにヘッダーが表示される、またはフローからヘッダーが非表示になると、静的チェーンが変更されることを意味します。ただし、拡張ヘッダーの変更パターンは、この設計戦略に関して圧縮効率を損なうとは見なされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Expected Compression Ratios with ROHC-TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. ROHC-TCPで期待される圧縮率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following table illustrates typical compression ratios that can be expected when using ROHC-TCP and IPHC [RFC2507].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の表は、ROHC-TCPおよびIPHC [RFC2507]を使用する場合に予想される一般的な圧縮率を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The figures in the table assume that the compression context has already been properly initialized. For the TS option, the Timestamp is assumed to change with small values. All TCP options include a suitable number of No Operation (NOP) options [RFC0793] for padding and/or alignment. Finally, in the examples for IPv4, a sequential IP-ID behavior is assumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表の数値は、圧縮コンテキストがすでに適切に初期化されていることを前提としています。 TSオプションの場合、タイムスタンプは小さな値で変化すると想定されています。すべてのTCPオプションには、パディングおよび/またはアラインメントのための適切な数のNo Operation（NOP）オプション[RFC0793]が含まれています。最後に、IPv4の例では、順次IP-ID動作が想定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             Total Header Size (octets)
                              ROHC-TCP          IPHC
                     Unc.   DATA    ACK      DATA    ACK
   IPv4+TCP+TS       52       8      8        18     18
   IPv4+TCP+TS       52       7      6        16     16   (1)
   IPv6+TCP+TS       72       8      7        18     18
   IPv6+TCP+no opt   60       6      5         6      6
   IPv6+TCP+SACK     80       -     15         -     80   (2)
   IPv6+TCP+SACK     80       -      9         -     26   (3)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) The payload size of the data stream is constant. (2) The SACK option appears in the header, but was not present in the previous packet. Two SACK blocks are assumed. (3) The SACK option appears in the header, and was also present in the previous packet (with different SACK blocks). Two SACK blocks are assumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（1）データストリームのペイロードサイズは一定です。 （2）SACKオプションはヘッダーに表示されますが、前のパケットには存在しませんでした。 2つのSACKブロックが想定されています。 （3）SACKオプションはヘッダーに表示され、前のパケット（異なるSACKブロックを持つ）にも存在していました。 2つのSACKブロックが想定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The table below illustrates the typical initial compression ratios for ROHC-TCP and IPHC. The data stream in the example is assumed to be IPv4+TCP, with a sequential behavior for the IP-ID. The following options are assumed present in the SYN packet: TS, MSS, and WSCALE, with an appropriate number of NOP options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の表は、ROHC-TCPおよびIPHCの一般的な初期圧縮率を示しています。この例のデータストリームはIPv4 + TCPで、IP-IDのシーケンシャルな動作を想定しています。次のオプションは、SYNパケットに存在すると想定されています：TS、MSS、およびWSCALE、および適切な数のNOPオプション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Total Header Size (octets) Unc. ROHC-TCP IPHC 1st packet (SYN) 60 49 60 2nd packet 52 12 52
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
合計ヘッダーサイズ（オクテット）Unc。 ROHC-TCP IPHC 1番目のパケット（SYN）60 49 60 2番目のパケット52 12 52
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The figures in the table assume that the compressor has received an acknowledgment from the decompressor before compressing the second packet, which can be expected when feedback is used in ROHC-TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表の数値は、コンプレッサーが2番目のパケットを圧縮する前に圧縮解除プログラムから確認応答を受信したと想定しています。これは、ROHC-TCPでフィードバックが使用されている場合に予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is because in the most common case, the TCP ACKs are expected to take the same return path, and because TCP does not send more packets until the TCP SYN packet has been acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、最も一般的なケースでは、TCP ACKは同じ戻りパスを使用することが期待されているため、TCPは、TCP SYNパケットが確認されるまで追加のパケットを送信しないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Compressor and Decompressor Logic (Normative)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. コンプレッサーとデコンプレッサーロジック（規範的）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Context Initialization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. コンテキストの初期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The static context of ROHC-TCP flows can be initialized in either of two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPフローの静的コンテキストは、次の2つの方法のいずれかで初期化できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. By using an IR packet as in Section 7.1, where the profile number is 0x06 and the static chain ends with the static part of a TCP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. セクション7.1のようにIRパケットを使用することにより、プロファイル番号は0x06であり、静的チェーンはTCPヘッダーの静的部分で終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. By replicating an existing context using the mechanism defined by [RFC4164]. This is done with the IR-CR packet defined in Section 7.2, where the profile number is 0x06.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. [RFC4164]で定義されたメカニズムを使用して既存のコンテキストを複製する。これは、セクション7.2で定義されたIR-CRパケットを使用して行われます。プロファイル番号は0x06です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Compressor Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. コンプレッサー操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1. Compression Logic
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1. 圧縮ロジック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The task of the compressor is to determine what data must be sent when compressing a TCP/IP packet, so that the decompressor can successfully reconstruct the original packet based on its current state. The selection of the type of compressed header to send thus depends on a number of factors, including:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮プログラムのタスクは、TCP / IPパケットを圧縮するときに送信する必要があるデータを決定することです。これにより、圧縮解除プログラムは、現在の状態に基づいて元のパケットを正常に再構築できます。したがって、送信する圧縮ヘッダーのタイプの選択は、次のようないくつかの要因に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The change behavior of header fields in the flow, e.g., conveying the necessary information within the restrictions of the set of available packet formats.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フロー内のヘッダーフィールドの動作の変更。たとえば、使用可能なパケット形式のセットの制限内で必要な情報を伝達します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The compressor&#39;s level of confidence regarding decompressor state, e.g., by selecting header formats updating the same type of information for a number of consecutive packets or from the reception of decompressor feedback (ACKs and/or NACKs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 圧縮解除プログラムの状態に関する圧縮プログラムの信頼レベル。たとえば、ヘッダー形式を選択して、いくつかの連続するパケットについて同じタイプの情報を更新することにより、または圧縮解除プログラムのフィードバック（ACKおよび/またはNACK）の受信から。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Additional robustness required for the flow, e.g., periodic refreshes of static and dynamic information using IR and IR-DYN packets when decompressor feedback is not expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローに必要な追加の堅牢性、たとえば、圧縮解除プログラムのフィードバックが予想されない場合のIRおよびIR-DYNパケットを使用した静的および動的情報の定期的な更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The impact of these factors on the compressor&#39;s packet type selection is described in more detail in the following subsections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの要素がコンプレッサーのパケットタイプ選択に与える影響については、次のサブセクションで詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, a &#34;higher compression state&#34; means that less data will be sent in compressed packets, i.e., smaller compressed headers are used, while a lower compression state means that a larger amount of data will be sent using larger compressed headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、「高い圧縮状態」とは、圧縮パケットで送信されるデータが少なくなることを意味します。つまり、使用される圧縮ヘッダーは小さくなります。一方、低い圧縮状態とは、大きい圧縮ヘッダーを使用して大量のデータが送信されることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1.1. Optimistic Approach
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1.1. 楽観的アプローチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The optimistic approach is the principle by which a compressor sends the same type of information for a number of packets (consecutively or not) until it is fairly confident that the decompressor has received the information. The optimistic approach is useful to ensure robustness when ROHC-TCP is used to compress packets over lossy links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
楽観的アプローチは、圧縮解除プログラムが情報を受信したことをかなり確信するまで、圧縮プログラムが多数のパケットに対して同じタイプの情報を（連続的かどうかにかかわらず）送信するという原則です。オプティミスティックアプローチは、ROHC-TCPを使用して損失の多いリンクを介してパケットを圧縮するときに、堅牢性を確保するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, if field X in the uncompressed packet changes value, the compressor MUST use a packet type that contains an encoding for field X until it has gained confidence that the decompressor has received at least one packet containing the new value for X. The compressor SHOULD choose a compressed format with the smallest header that can convey the changes needed to fulfill the optimistic approach condition used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、圧縮されていないパケットのフィールドXが値を変更する場合、圧縮プログラムは、圧縮解除プログラムがXの新しい値を含む少なくとも1つのパケットを受信したという確信が得られるまで、フィールドXのエンコードを含むパケットタイプを使用する必要があります。使用される楽観的アプローチ条件を満たすために必要な変更を伝達できる最小のヘッダーを持つ圧縮形式を選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1.2. Periodic Context Refreshes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1.2. 定期的なコンテキストの更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the optimistic approach is used, there will always be a possibility of decompression failures since the decompressor may not have received sufficient information for correct decompression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプティミスティックアプローチを使用する場合、デコンプレッサが正しい解凍のための十分な情報を受け取っていない可能性があるため、常に解凍が失敗する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, until the decompressor has established a feedback channel, the compressor SHOULD periodically move to a lower compression state and send IR and/or IR-DYN packets. These refreshes can be based on timeouts, on the number of compressed packets sent for the flow, or any other strategy specific to the implementation. Once the feedback channel is established, the decompressor MAY stop performing periodic refreshes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、圧縮解除プログラムがフィードバックチャネルを確立するまで、圧縮プログラムは定期的に低圧縮状態に移行し、IRおよび/またはIR-DYNパケットを送信する必要があります（SHOULD）。これらの更新は、タイムアウト、フローに送信された圧縮パケットの数、または実装に固有のその他の戦略に基づくことができます。フィードバックチャネルが確立されると、デコンプレッサは定期的な更新の実行を停止する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2. Feedback Logic
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2. フィードバックロジック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The semantics of feedback messages, acknowledgments (ACKs) and negative acknowledgments (NACKs or STATIC-NACKs), are defined in Section 5.2.4.1 of [RFC5795].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバックメッセージのセマンティクス、確認応答（ACK）、否定応答（NACKまたはSTATIC-NACK）は、[RFC5795]のセクション5.2.4.1で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.1. Optional Acknowledgments (ACKs)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.1. オプションの確認応答（ACK）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressor MAY use acknowledgment feedback (ACKs) to move to a higher compression state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンプレッサーは、確認フィードバック（ACK）を使用して、より高い圧縮状態に移行できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon reception of an ACK for a context-updating packet, the compressor obtains confidence that the decompressor has received the acknowledged packet and that it has observed changes in the packet flow up to the acknowledged packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキスト更新パケットのACKを受信すると、コンプレッサーは、解凍器が確認済みパケットを受信し、確認済みパケットまでのパケットフローの変化を観察したという確信を得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This functionality is optional, so a compressor MUST NOT expect to get such ACKs, even if a feedback channel is available and has been established for that flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能はオプションであるため、たとえフィードバックチャネルが利用可能で、そのフローに対して確立されている場合でも、コンプレッサーはそのようなACKを取得することを期待してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.2. Negative Acknowledgments (NACKs)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.2. 否定応答（NACK）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressor uses feedback from the decompressor to move to a lower compression state (NACKs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンプレッサーは、デコンプレッサーからのフィードバックを使用して、より低い圧縮状態（NACK）に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On reception of a NACK feedback, the compressor SHOULD:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NACKフィードバックを受信すると、コンプレッサーは次のことを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o assume that only the static part of the decompressor is valid, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 解凍器の静的な部分のみが有効であると仮定し、そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o re-send all dynamic information (via an IR or IR-DYN packet) the next time it compresses a packet for the indicated flow
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 指定されたフローのパケットを次に圧縮するときに、すべての動的情報を（IRまたはIR-DYNパケットを介して）再送信します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unless it has confidence that information sent after the packet being acknowledged already provides a suitable response to the NACK feedback. In addition, the compressor MAY use a CO packet carrying a 7-bit Cyclic Redundancy Check (CRC) if it can determine with enough confidence what information provides a suitable response to the NACK feedback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットが確認された後に送信された情報がNACKフィードバックへの適切な応答をすでに提供しているという確信がない限り。さらに、コンプレッサーは、どの情報がNACKフィードバックへの適切な応答を提供するかを十分な自信を持って判断できる場合、7ビットの巡回冗長検査（CRC）を運ぶCOパケットを使用してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On reception of a STATIC-NACK feedback, the compressor SHOULD:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STATIC-NACKフィードバックを受信すると、コンプレッサーは次のことを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o assume that the decompressor has no valid context, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o デコンプレッサに有効なコンテキストがないと仮定し、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o re-send all static and all dynamic information (via an IR packet) the next time it compresses a packet for the indicated flow
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 指定されたフローのパケットを次回圧縮するときに、（IRパケットを介して）すべての静的およびすべての動的情報を再送信します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unless it has confidence that information sent after the packet that is being acknowledged already provides a suitable response to the STATIC-NACK feedback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認されているパケットの後に送信された情報がSTATIC-NACKフィードバックへの適切な応答をすでに提供しているという確信がない限り。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.3. Context Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.3. コンテキスト複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A compressor MAY support context replication by implementing the additional compression and feedback logic defined in [RFC4164].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンプレッサーは、[RFC4164]で定義されている追加の圧縮およびフィードバックロジックを実装することにより、コンテキストレプリケーションをサポートしてもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Decompressor Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 減圧装置の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1. Decompressor States and Logic
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1. 減圧装置の状態とロジック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The three states of the decompressor are No Context (NC), Static Context (SC), and Full Context (FC). The decompressor starts in its lowest compression state, the NC state. Successful decompression will always move the decompressor to the FC state. The decompressor state machine normally never leaves the FC state once it has entered this state; only repeated decompression failures will force the decompressor to transit downwards to a lower state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコンプレッサの3つの状態は、コンテキストなし（NC）、静的コンテキスト（SC）、および完全コンテキスト（FC）です。圧縮解除プログラムは、最も低い圧縮状態であるNC状態で起動します。解凍が成功すると、解凍プログラムは常にFC状態に移行します。圧縮解除状態マシンは、いったんこの状態になると、通常はFC状態を終了しません。減圧の失敗が繰り返された場合にのみ、減圧装置は下の状態に強制的に遷移します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below is the state machine for the decompressor. Details of the transitions between states and decompression logic are given in the subsections following the figure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、圧縮解除プログラムの状態マシンです。状態と解凍ロジックの間の遷移の詳細は、図に続くサブセクションに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                 Success
                +--&gt;------&gt;------&gt;------&gt;------&gt;------&gt;--+
                |                                        |
    No Static   |            No Dynamic        Success   |    Success
     +--&gt;--+    |             +--&gt;--+      +---&gt;-----&gt;---+    +--&gt;--+
     |     |    |             |     |      |             |    |     |
     |     v    |             |     v      |             v    |     v
   +-----------------+   +---------------------+   +-------------------+
   | No Context (NC) |   | Static Context (SC) |   | Full Context (FC) |
   +-----------------+   +---------------------+   +-------------------+
      ^                         |        ^                         |
      |  Static Context         |        | Context Damage Assumed  |
      |  Damage Assumed         |        |                         |
      +-----&lt;------&lt;------&lt;-----+        +-----&lt;------&lt;------&lt;-----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.1. Reconstruction and Verification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.1. 再構築と検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When decompressing an IR or an IR-DYN packet, the decompressor MUST validate the integrity of the received header using CRC-8 validation [RFC5795]. If validation fails, the packet MUST NOT be delivered to upper layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IRまたはIR-DYNパケットを圧縮解除するとき、圧縮解除プログラムはCRC-8検証[RFC5795]を使用して受信したヘッダーの整合性を検証する必要があります。検証が失敗した場合、パケットは上位層に配信されてはならない（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving an IR-CR packet, the decompressor MUST perform the actions as specified in [RFC4164].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IR-CRパケットを受信すると、圧縮解除プログラムは、[RFC4164]で指定されているアクションを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When decompressing other packet types (e.g., CO packets), the decompressor MUST validate the outcome of the decompression attempt using CRC verification [RFC5795]. If verification fails, a decompressor implementation MAY attempt corrective or repair measures on the packet, and the result of any attempt MUST be validated using the CRC verification; otherwise, the packet MUST NOT be delivered to upper layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のパケットタイプ（COパケットなど）を解凍するとき、解凍プログラムはCRC検証[RFC5795]を使用して解凍試行の結果を検証しなければなりません（MUST）。検証が失敗した場合、デコンプレッサの実装は、パケットの修正または修復手段を試行してもよい（MAY）。試行の結果は、CRC検証を使用して検証する必要があります。それ以外の場合、パケットは上位層に配信してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the CRC-8 validation or the CRC verification of the received header is successful, the decompressor SHOULD update its context with the information received in the current header; the decompressor then passes the reconstructed packet to the system&#39;s network layer. Otherwise, the decompressor context MUST NOT be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したヘッダーのCRC-8検証またはCRC検証が成功した場合、圧縮解除プログラムは、現在のヘッダーで受信した情報でそのコンテキストを更新する必要があります（SHOULD）。次に、圧縮解除プログラムは、再構築されたパケットをシステムのネットワーク層に渡します。それ以外の場合、解凍コンテキストは更新してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the received packet is older than the current reference packet, e.g., based on the master sequence number (MSN) in the compressed packet, the decompressor MAY refrain from updating the context using the information received in the current packet, even if the correctness of its header was successfully verified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したパケットが現在の参照パケットより古い場合、たとえば、圧縮パケットのマスターシーケンス番号（MSN）に基づいている場合、圧縮解除プログラムは、現在のパケットで受信した情報を使用してコンテキストを更新しない場合があります。ヘッダーは正常に検証されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.2. Detecting Context Damage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.2. コンテキストの損傷の検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All header formats carry a CRC and are context updating. A packet for which the CRC succeeds updates the reference values of all header fields, either explicitly (from the information about a field carried within the compressed header) or implicitly (fields that are inferred from other fields).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのヘッダー形式はCRCを伝達し、コンテキストを更新します。 CRCが成功したパケットは、すべてのヘッダーフィールドの参照値を、明示的に（圧縮ヘッダー内で運ばれるフィールドに関する情報から）、または暗黙的に（他のフィールドから推測されるフィールド）更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decompressor may assume that some or the entire context is invalid, following one or more failures to validate or verify a header using the CRC. Because the decompressor cannot know the exact reason(s) for a CRC failure or what field caused it, the validity of the context hence does not refer to what exact context entry is deemed valid or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮解除プログラムは、CRCを使用してヘッダーを検証または検証する1つまたは複数の失敗に続いて、コンテキストの一部または全体が無効であると想定する場合があります。デコンプレッサは、CRC失敗の正確な理由や、それが原因となったフィールドを知ることができないため、コンテキストの有効性は、どのコンテキストエントリが有効であると見なされるかを指しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Validity of the context rather relates to the detection of a problem with the context. The decompressor first assumes that the type of information that most likely caused the failure(s) is the state that normally changes for each packet, i.e., context damage of the dynamic part of the context. Upon repeated failures and unsuccessful repairs, the decompressor then assumes that the entire context, including the static part, needs to be repaired, i.e., static context damage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキストの有効性は、コンテキストの問題の検出に関連しています。デコンプレッサは、最初に、障害を引き起こす可能性が最も高い情報のタイプが、通常はパケットごとに変化する状態、つまりコンテキストの動的な部分のコンテキストの損傷であると想定します。障害が繰り返し発生し、修復が失敗すると、デコンプレッサは、静的な部分を含むコンテキスト全体を修復する必要があると想定します。つまり、静的なコンテキストの損傷です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Context Damage Detection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキスト損傷検出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The assumption of context damage means that the decompressor will not attempt decompression of a CO header that carries a 3-bit CRC, and only attempt decompression of IR, IR-DYN, or IR-CR headers or CO headers protected by a CRC-7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
コンテキストの損傷の想定は、デコンプレッサが3ビットCRCを伝送するCOヘッダーの解凍を試みず、CR、7で保護されたIR、IR-DYN、またはIR-CRヘッダーまたはCOヘッダーのみの解凍を試みることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Static Context Damage Detection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的コンテキスト損傷検出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The assumption of static context damage means that the decompressor refrains from attempting decompression of any type of header other than the IR header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
静的なコンテキストの損傷の想定は、解凍器がIRヘッダー以外のすべてのタイプのヘッダーの解凍を試みないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
How these assumptions are made, i.e., how context damage is detected, is open to implementations. It can be based on the residual error rate, where a low error rate makes the decompressor assume damage more often than on a high-rate link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの仮定がどのように行われるか、つまり、コンテキストの損傷がどのように検出されるかは、実装に対して開かれています。それは、残留エラー率に基づくことができます。この場合、エラー率が低いと、デコンプレッサーは高速リンクよりも頻繁に損傷を想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decompressor implements these assumptions by selecting the type of compressed header for which it may attempt decompression. In other words, validity of the context refers to the ability of a decompressor to attempt or not attempt decompression of specific packet types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮解除プログラムは、圧縮解除を試行する可能性のある圧縮ヘッダーのタイプを選択することにより、これらの仮定を実装します。言い換えると、コンテキストの有効性は、特定のパケットタイプの圧縮解除を試みる、または試みない圧縮解除機能の能力を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.3. No Context (NC) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.3. コンテキストなし（NC）状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initially, while working in the No Context (NC) state, the decompressor has not yet successfully decompressed a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初は、コンテキストなし（NC）状態で作業している間、解凍プログラムはまだパケットを正常に解凍していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allowing decompression:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解凍を許可：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the NC state, only packets carrying sufficient information on the static fields (IR and IR-CR packets) can be decompressed; otherwise, the packet MUST NOT be decompressed and MUST NOT be delivered to upper layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NC状態では、静的フィールドに関する十分な情報を運ぶパケット（IRおよびIR-CRパケット）のみが圧縮解除できます。それ以外の場合、パケットを解凍してはならず、上位層に配信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Feedback logic:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバックロジック：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the NC state, the decompressor should send a STATIC-NACK if a packet of a type other than IR is received, or if decompression of an IR packet has failed, subject to the feedback rate limitation as described in Section 5.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NC状態では、IR以外のタイプのパケットを受信した場合、またはIRパケットの圧縮解除に失敗した場合、セクション5.3.2で説明されているフィードバックレート制限に従って、圧縮解除プログラムはSTATIC-NACKを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a packet has been validated and decompressed correctly, the decompressor MUST transit to the FC state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットが検証されて正しく解凍されると、解凍プログラムはFC状態に遷移する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.4. Static Context (SC) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.4. 静的コンテキスト（SC）の状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the decompressor is in the Static Context (SC) state, only the static part of the decompressor context is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコンプレッサが静的コンテキスト（SC）状態の場合、デコンプレッサコンテキストの静的な部分のみが有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the SC state, the decompressor moves back to the NC state if static context damage is detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的コンテキストの損傷が検出されると、SC状態からデコンプレッサはNC状態に戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allowing decompression:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解凍を許可：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the SC state, packets carrying sufficient information on the dynamic fields covered by an 8-bit CRC (e.g., IR and IR-DYN) or CO packets covered by a 7-bit CRC can be decompressed; otherwise, the packet MUST NOT be decompressed and MUST NOT be delivered to upper layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SC状態では、8ビットCRCでカバーされる動的フィールド（IRやIR-DYNなど）または7ビットCRCでカバーされるCOパケットに関する十分な情報を運ぶパケットを解凍できます。それ以外の場合、パケットを解凍してはならず、上位層に配信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Feedback logic:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバックロジック：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the SC state, the decompressor should send a STATIC-NACK if CRC validation of an IR/IR-DYN/IR-CR fails and static context damage is assumed. If any other packet type is received, the decompressor should send a NACK. Both of the above cases are subject to the feedback rate limitation as described in Section 5.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SC状態では、IR / IR-DYN / IR-CRのCRC検証が失敗し、静的コンテキストの損傷が想定される場合、デコンプレッサはSTATIC-NACKを送信する必要があります。他のパケットタイプが受信された場合、デコンプレッサはNACKを送信する必要があります。上記のケースは両方とも、セクション5.3.2で説明されているようにフィードバックレート制限の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a packet has been validated and decompressed correctly, the decompressor MUST transit to the FC state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットが検証されて正しく解凍されると、解凍プログラムはFC状態に遷移する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.5. Full Context (FC) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1.5. フルコンテキスト（FC）状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the Full Context (FC) state, both the static and the dynamic parts of the decompressor context are valid. From the FC state, the decompressor moves back to the SC state if context damage is detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フルコンテキスト（FC）状態では、圧縮解除コンテキストの静的部分と動的部分の両方が有効です。コンテキストの損傷が検出された場合、デコンプレッサはFC状態からSC状態に戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allowing decompression:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解凍を許可：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the FC state, decompression can be attempted regardless of the type of packet received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
FC状態では、受信したパケットのタイプに関係なく、解凍を試行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Feedback logic:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバックロジック：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the FC state, the decompressor should send a NACK if the decompression of any packet type fails and context damage is assumed, subject to the feedback rate limitation as described in Section 5.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
FC状態では、セクション5.3.2で説明されているフィードバックレート制限に従い、パケットタイプの解凍が失敗し、コンテキストの損傷が想定される場合、解凍プログラムはNACKを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2. Feedback Logic
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2. フィードバックロジック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decompressor MAY send positive feedback (ACKs) to initially establish the feedback channel for a particular flow. Either positive feedback (ACKs) or negative feedback (NACKs) establishes this channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコンプレッサは、特定のフローのフィードバックチャネルを最初に確立するために正のフィードバック（ACK）を送信する場合があります。正帰還（ACK）または負帰還（NACK）のいずれかがこのチャネルを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the feedback channel is established, the decompressor is REQUIRED to continue sending NACKs or STATIC-NACKs for as long as the context is associated with the same profile, in this case with profile 0x0006, as per the logic defined for each state in Section 5.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバックチャネルが確立されると、5.3で各状態に対して定義されたロジックに従って、コンテキストが同じプロファイル（この場合はプロファイル0x0006）に関連付けられている限り、デコンプレッサはNACKまたはSTATIC-NACKの送信を継続する必要があります。 .1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decompressor MAY send ACKs upon successful decompression of any packet type. In particular, when a packet carrying a significant context update is correctly decompressed, the decompressor MAY send an ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮解除プログラムは、任意のパケットタイプの圧縮解除が成功したときにACKを送信できます（MAY）。特に、重要なコンテキスト更新を運ぶパケットが正しく圧縮解除されるとき、圧縮解除プログラムはACKを送信してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decompressor should limit the rate at which it sends feedback, for both ACKs and STATIC-NACK/NACKs, and should avoid sending unnecessary duplicates of the same type of feedback message that may be associated to the same event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコンプレッサは、ACKとSTATIC-NACK / NACKの両方について、フィードバックを送信する速度を制限し、同じイベントに関連付けられている可能性がある同じタイプのフィードバックメッセージの不要な重複を送信しないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.3. Context Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.3. コンテキスト複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP supports context replication; therefore, the decompressor MUST implement the additional decompressor and feedback logic defined in [RFC4164].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPはコンテキスト複製をサポートしています。したがって、解凍器は、[RFC4164]で定義されている追加の解凍器とフィードバックロジックを実装しなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Encodings in ROHC-TCP (Normative)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. ROHC-TCPのエンコーディング（規定）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Control Fields in ROHC-TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. ROHC-TCPの制御フィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In ROHC-TCP, a number of control fields are used by the decompressor in its interpretation of the format of the packets received from the compressor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPでは、圧縮プログラムから受信したパケットのフォーマットを解釈する際に、圧縮解除プログラムによっていくつかの制御フィールドが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A control field is a field that is transmitted from the compressor to the decompressor, but is not part of the uncompressed header. Values for control fields can be set up in the context of both the compressor and the decompressor. Once established at the decompressor, the values of these fields should be kept until updated by another packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御フィールドは、コンプレッサーからデコンプレッサーに送信されるフィールドですが、非圧縮ヘッダーの一部ではありません。制御フィールドの値は、コンプレッサーとデコンプレッサーの両方のコンテキストで設定できます。これらのフィールドの値は、デコンプレッサで確立されると、別のパケットによって更新されるまで保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. Master Sequence Number (MSN)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. マスターシーケンス番号（MSN）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no field in the TCP header that can act as the master sequence number for TCP compression, as explained in [RFC4413], Section 5.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4413]のセクション5.6で説明されているように、TCPヘッダーには、TCP圧縮のマスターシーケンス番号として機能するフィールドはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To overcome this problem, ROHC-TCP introduces a control field called the Master Sequence Number (MSN) field. The MSN field is created at the compressor, rather than using one of the fields already present in the uncompressed header. The compressor increments the value of the MSN by one for each packet that it sends.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題を克服するために、ROHC-TCPはマスターシーケンス番号（MSN）フィールドと呼ばれる制御フィールドを導入しています。 MSNフィールドは、圧縮されていないヘッダーに既に存在するフィールドの1つを使用するのではなく、コンプレッサーで作成されます。コンプレッサーは、送信するパケットごとにMSNの値を1つずつ増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MSN field has the following two functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MSNフィールドには、次の2つの機能があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Differentiating between packets when sending feedback data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. フィードバックデータを送信する際のパケットの区別。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Inferring the value of incrementing fields such as the IP-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. IP-IDなどの増分フィールドの値を推測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MSN field is present in every packet sent by the compressor. The MSN is LSB encoded within the CO packets, and the 16-bit MSN is sent in full in IR/IR-DYN packets. The decompressor always sends the MSN as part of the feedback information. The compressor can later use the MSN to infer which packet the decompressor is acknowledging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MSNフィールドは、コンプレッサーによって送信されるすべてのパケットに存在します。 MSNはCOパケット内でLSBエンコードされ、16ビットMSNはIR / IR-DYNパケットで完全に送信されます。デコンプレッサは常にフィードバック情報の一部としてMSNを送信します。圧縮プログラムは、後でMSNを使用して、圧縮解除プログラムが確認応答しているパケットを推測できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the MSN is initialized, it SHOULD be initialized to a random value. The compressor should only initialize a new MSN for the initial IR or IR-CR packet sent for a CID that corresponds to a context that is not already associated with this profile. In other words, if the compressor reuses the same CID to compress many TCP flows one after the other, the MSN is not reinitialized but rather continues to increment monotonically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MSNが初期化されるとき、ランダムな値に初期化される必要があります（SHOULD）。コンプレッサーは、このプロファイルにまだ関連付けられていないコンテキストに対応するCIDに送信される初期IRまたはIR-CRパケットの新しいMSNのみを初期化する必要があります。つまり、コンプレッサーが同じCIDを再利用して多数のTCPフローを次々に圧縮する場合、MSNは再初期化されず、単調に増加し続けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For context replication, the compressor does not use the MSN of the base context when sending the IR-CR packet, unless the replication process overwrites the base context (i.e., Base CID == CID). Instead, the compressor uses the value of the MSN if it already exists in the ROHC-TCP context being associated with the new flow (CID); otherwise, the MSN is initialized to a new value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキストレプリケーションの場合、レプリケーションプロセスがベースコンテキストを上書きしない限り（つまり、ベースCID == CID）、コンプレッサーはIR-CRパケットを送信するときにベースコンテキストのMSNを使用しません。代わりに、新しいフロー（CID）に関連付けられているROHC-TCPコンテキストにMSNの値が既に存在する場合、コンプレッサーはMSNの値を使用します。それ以外の場合、MSNは新しい値に初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. IP-ID Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. IP-IDの動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IP-ID field of the IPv4 header can have different change patterns. Conceptually, a compressor monitors changes in the value of the IP-ID field and selects encoding methods and packet formats that are the closest match to the observed change pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4ヘッダーのIP-IDフィールドは、さまざまな変更パターンを持つことができます。概念的には、コンプレッサーはIP-IDフィールドの値の変化を監視し、観察された変化パターンに最も近いエンコード方法とパケット形式を選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP defines different types of compression techniques for the IP-ID, to provide the flexibility to compress any of the behaviors it may observe for this field: sequential in network byte order (NBO), sequential byte-swapped, random (RND), or constant to a value of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPは、IP-IDのさまざまな種類の圧縮技術を定義し、このフィールドで観察される可能性のある動作を順次圧縮する柔軟性を提供します：ネットワークバイト順（NBO）の順次、バイトスワップの順次、ランダム（RND） 、またはゼロの値への定数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressor monitors changes in the value of the IP-ID field for a number of packets, to identify which one of the above listed compression alternatives is the closest match to the observed change pattern. The compressor can then select packet formats and encoding methods based on the identified field behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンプレッサーは、いくつかのパケットのIP-IDフィールドの値の変化を監視して、上記の圧縮の選択肢のどれが、観察された変化パターンに最も近い一致であるかを識別します。次に、圧縮プログラムは、識別されたフィールドの動作に基づいて、パケット形式とエンコード方法を選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If more than one level of IP headers is present, ROHC-TCP can assign a sequential behavior (NBO or byte-swapped) only to the IP-ID of the innermost IP header. This is because only this IP-ID can possibly have a sufficiently close correlation with the MSN (see also Section 6.1.1) to compress it as a sequentially changing field. Therefore, a compressor MUST NOT assign either the sequential (NBO) or the sequential byte-swapped behavior to tunneling headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数レベルのIPヘッダーが存在する場合、ROHC-TCPは最も内側のIPヘッダーのIP-IDにのみ順次動作（NBOまたはバイトスワップ）を割り当てることができます。これは、このIP-IDだけがMSNと十分に密接な相関を持ち（セクション6.1.1も参照）、順次変化するフィールドとしてそれを圧縮できるためです。したがって、圧縮プログラムは、シーケンシャル（NBO）またはシーケンシャルバイトスワップ動作のいずれかをトンネリングヘッダーに割り当ててはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The control field for the IP-ID behavior determines which set of packet formats will be used. These control fields are also used to determine the contents of the irregular chain item (see Section 6.2) for each IP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP-ID動作の制御フィールドは、使用されるパケット形式のセットを決定します。これらの制御フィールドは、各IPヘッダーの不規則なチェーン項目（セクション6.2を参照）の内容を決定するためにも使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. Explicit Congestion Notification (ECN)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. 明示的な輻輳通知（ECN）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When ECN [RFC3168] is used once on a flow, the ECN bits could change quite often. ROHC-TCP maintains a control field in the context to indicate whether or not ECN is used. This control field is transmitted in the dynamic chain of the TCP header, and its value can be updated using specific compressed headers carrying a 7-bit CRC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECN [RFC3168]がフローで1回使用されると、ECNビットが頻繁に変更される可能性があります。 ROHC-TCPは、ECNが使用されているかどうかを示すために、コンテキストに制御フィールドを保持します。この制御フィールドは、TCPヘッダーの動的チェーンで送信され、その値は、7ビットCRCを伝送する特定の圧縮ヘッダーを使用して更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this control field indicates that ECN is being used, items of all IP and TCP headers in the irregular chain include bits used for ECN. To preserve octet-alignment, all of the TCP reserved bits are transmitted and, for outer IP headers, the entire Type of Service/ Traffic Class (TOS/TC) field is included in the irregular chain. When there is only one IP header present in the packet (i.e., no IP tunneling is used), this compression behavior allows the compressor to handle changes in the ECN bits by adding a single octet to the compressed header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この制御フィールドがECNが使用されていることを示す場合、不規則なチェーンのすべてのIPおよびTCPヘッダーの項目には、ECNに使用されるビットが含まれます。オクテットアライメントを維持するために、すべてのTCP予約ビットが送信され、外部IPヘッダーの場合、タイプオブサービス/トラフィッククラス（TOS / TC）フィールド全体が不規則なチェーンに含まれます。パケットにIPヘッダーが1つしかない場合（つまり、IPトンネリングが使用されていない場合）、この圧縮動作により、コンプレッサーは単一のオクテットを圧縮ヘッダーに追加することにより、ECNビットの変更を処理できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reason for including the ECN bits of all IP headers in the compressed packet when the control field is set is that the profile needs to efficiently compress flows containing IP tunnels using the &#34;full-functionality option&#34; of Section 9.1 of [RFC3168]. For these flows, a change in the ECN bits of an inner IP header is propagated to the outer IP headers. When the &#34;limited-functionality&#34; option is used, the compressor will therefore sometimes send one octet more than necessary per tunnel header, but this has been considered a reasonable trade-off when designing this profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御フィールドが設定されているときにすべてのIPヘッダーのECNビットを圧縮パケットに含める理由は、プロファイルが[RFC3168]のセクション9.1の「全機能オプション」を使用してIPトンネルを含むフローを効率的に圧縮する必要があるためです。これらのフローでは、内部IPヘッダーのECNビットの変更が外部IPヘッダーに伝搬されます。したがって、「機能制限」オプションを使用すると、コンプレッサーはトンネルヘッダーごとに必要以上に1オクテットを送信することがありますが、これは、このプロファイルを設計する際の妥当なトレードオフと見なされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Compressed Header Chains
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 圧縮ヘッダーチェーン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some packet types use one or more chains containing sub-header information. The function of a chain is to group fields based on similar characteristics, such as static, dynamic, or irregular fields. Chaining is done by appending an item for each header to the chain in their order of appearance in the uncompressed packet, starting from the fields in the outermost header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のパケットタイプは、サブヘッダー情報を含む1つ以上のチェーンを使用します。チェーンの機能は、静的、動的、または不規則なフィールドなどの同様の特性に基づいてフィールドをグループ化することです。チェーン化は、最も外側のヘッダーのフィールドから始めて、各ヘッダーのアイテムを非圧縮パケット内の出現順にチェーンに追加することによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chains are defined for all headers compressed by ROHC-TCP, as listed below. Also listed are the names of the encoding methods used to encode each of these protocol headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チェーンは、以下に示すように、ROHC-TCPによって圧縮されたすべてのヘッダーに対して定義されます。これらの各プロトコルヘッダーのエンコードに使用されるエンコード方法の名前もリストされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP [RFC0793], encoding method: &#34;tcp&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP [RFC0793]、エンコード方式： &#34;tcp&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv4 [RFC0791], encoding method: &#34;ipv4&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv4 [RFC0791]、エンコード方式： &#34;ipv4&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv6 [RFC2460], encoding method: &#34;ipv6&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv6 [RFC2460]、エンコード方式： &#34;ipv6&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o AH [RFC4302], encoding method: &#34;ah&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o AH [RFC4302]、エンコード方式： &#34;ah&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GRE [RFC2784][RFC2890], encoding method: &#34;gre&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GRE [RFC 2784] [RFC 2890]、エンコード方式： &#34;gre&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MINE [RFC2004], encoding method: &#34;mine&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MINE [RFC2004]、エンコード方式： &#34;mine&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv6 Destination Options header [RFC2460], encoding method: &#34;ip_dest_opt&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv6宛先オプションヘッダー[RFC2460]、エンコード方式： &#34;ip_dest_opt&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv6 Hop-by-Hop Options header [RFC2460], encoding method: &#34;ip_hop_opt&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv6ホップバイホップオプションヘッダー[RFC2460]、エンコード方式： &#34;ip_hop_opt&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv6 Routing header [RFC2460], encoding method: &#34;ip_rout_opt&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPv6ルーティングヘッダー[RFC2460]、エンコード方式： &#34;ip_rout_opt&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Static chain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的チェーン：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The static chain consists of one item for each header of the chain of protocol headers to be compressed, starting from the outermost IP header and ending with a TCP header. In the formal description of the packet formats, this static chain item for each header is a format whose name is suffixed by &#34;_static&#34;. The static chain is only used in IR packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
静的チェーンは、最も外側のIPヘッダーから始まり、TCPヘッダーで終わる、圧縮されるプロトコルヘッダーのチェーンのヘッダーごとに1つの項目で構成されます。パケット形式の正式な説明では、各ヘッダーのこの静的チェーン項目は、名前の末尾に「_static」が付いた形式です。静的チェーンはIRパケットでのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dynamic chain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動的チェーン：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The dynamic chain consists of one item for each header of the chain of protocol headers to be compressed, starting from the outermost IP header and ending with a TCP header. The dynamic chain item for the TCP header also contains a compressed list of TCP options (see Section 6.3). In the formal description of the packet formats, the dynamic chain item for each header type is a format whose name is suffixed by &#34;_dynamic&#34;. The dynamic chain is used in both IR and IR-DYN packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
動的チェーンは、圧縮されるプロトコルヘッダーのチェーンの各ヘッダーに対して1つの項目で構成され、最も外側のIPヘッダーから始まり、TCPヘッダーで終わります。 TCPヘッダーの動的チェーン項目には、TCPオプションの圧縮リストも含まれています（セクション6.3を参照）。パケット形式の正式な説明では、各ヘッダータイプの動的チェーン項目は、名前の末尾に「_dynamic」が付いた形式です。ダイナミックチェーンは、IRパケットとIR-DYNパケットの両方で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replicate chain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複製チェーン：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The replicate chain consists of one item for each header in the chain of protocol headers to be compressed, starting from the outermost IP header and ending with a TCP header. The replicate chain item for the TCP header also contains a compressed list of TCP options (see Section 6.3). In the formal description of the packet formats, the replicate chain item for each header type is a format whose name is suffixed by &#34;_replicate&#34;. Header fields that are not present in the replicate chain are replicated from the base context. The replicate chain is only used in the IR-CR packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
レプリケートチェーンは、圧縮されるプロトコルヘッダーのチェーンのヘッダーごとに1つの項目で構成され、最も外側のIPヘッダーから始まり、TCPヘッダーで終わります。 TCPヘッダーのレプリケートチェーンアイテムには、TCPオプションの圧縮リストも含まれています（セクション6.3を参照）。パケット形式の正式な説明では、各ヘッダータイプのレプリケートチェーンアイテムは、名前の末尾に「_replicate」が付いた形式です。レプリケートチェーンに存在しないヘッダーフィールドは、ベースコンテキストからレプリケートされます。複製チェーンはIR-CRパケットでのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Irregular chain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不規則なチェーン：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The structure of the irregular chain is analogous to the structure of the static chain. For each compressed packet, the irregular chain is appended at the specified location in the general format of the compressed packets as defined in Section 7.3. This chain also includes the irregular chain items for TCP options as defined in Section 6.3.6, which are placed directly after the irregular chain item of the TCP header, and in the same order as the options appear in the uncompressed packet. In the formal description of the packet formats, the irregular chain item for each header type is a format whose name is suffixed by &#34;_irregular&#34;. The irregular chain is used only in CO packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
不規則なチェーンの構造は、静的なチェーンの構造に似ています。セクション7.3で定義されているように、圧縮パケットごとに、不規則なチェーンが圧縮パケットの一般的な形式で指定された場所に追加されます。このチェーンには、セクション6.3.6で定義されているTCPオプションの不規則なチェーンアイテムも含まれます。これらは、TCPヘッダーの不規則なチェーンアイテムの直後に配置され、オプションが非圧縮パケットに現れるのと同じ順序です。パケットフォーマットの正式な説明では、各ヘッダータイプの不規則なチェーンアイテムは、名前の末尾に「_irregular」が付いたフォーマットです。不規則なチェーンは、COパケットでのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The format of the irregular chain for the innermost IP header differs from the format of outer IP headers, since this header is part of the compressed base header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
最も内側のIPヘッダーの不規則なチェーンの形式は、外側のIPヘッダーの形式とは異なります。これは、このヘッダーが圧縮された基本ヘッダーの一部であるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Compressing TCP Options with List Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. リスト圧縮によるTCPオプションの圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes in detail how list compression is applied to the TCP options. In the definition of the packet formats for ROHC-TCP, the most frequent TCP options have one encoding method each, as listed in the table below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、リスト圧縮がTCPオプションにどのように適用されるかについて詳しく説明します。 ROHC-TCPのパケット形式の定義では、以下の表に示すように、最も頻度の高いTCPオプションにはそれぞれ1つのエンコード方式があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +-----------------+------------------------+
           |   Option name   |  Encoding method name  |
           +-----------------+------------------------+
           |      NOP        | tcp_opt_nop            |
           |      EOL        | tcp_opt_eol            |
           |      MSS        | tcp_opt_mss            |
           |  WINDOW SCALE   | tcp_opt_wscale         |
           |   TIMESTAMP     | tcp_opt_ts             |
           | SACK-PERMITTED  | tcp_opt_sack_permitted |
           |      SACK       | tcp_opt_sack           |
           | Generic options | tcp_opt_generic        |
           +-----------------+------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Each of these encoding methods has an uncompressed format, a format suffixed by &#34;_list_item&#34; and a format suffixed by &#34;_irregular&#34;. In some cases, a single encoding method may have multiple &#34;_list_item&#34; or &#34;_irregular&#34; formats, in which case bindings inside these formats determine what format is used. This is further described in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これらの各エンコード方式には、圧縮されていない形式、「_ list_item」のサフィックスが付いた形式、および「_irregular」のサフィックスが付いた形式があります。場合によっては、単一のエンコード方式に複数の「_list_item」または「_irregular」形式がある場合があります。その場合、これらの形式内のバインディングによって、使用される形式が決まります。これについては、次のセクションで詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. List Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. リスト圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TCP options in the uncompressed packet can be represented as an ordered list, whose order and presence are usually constant between packets. The generic structure of such a list is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮されていないパケットのTCPオプションは、順序付けられたリストとして表すことができ、その順序と存在は通常、パケット間で一定です。このようなリストの一般的な構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            +--------+--------+--...--+--------+
      list: | item 1 | item 2 |       | item n |
            +--------+--------+--...--+--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To compress this list, ROHC-TCP uses a list compression scheme, which compresses each of these items individually and combines them into a compressed list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このリストを圧縮するために、ROHC-TCPはリスト圧縮スキームを使用します。これは、これらの各アイテムを個別に圧縮し、それらを圧縮リストに結合します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic principles of list-based compression are the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リストベースの圧縮の基本原則は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1) When a context is being initialized, a complete representation of the compressed list of options is transmitted. All options that have any content are present in the compressed list of items sent by the compressor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1）コンテキストが初期化されるとき、オプションの圧縮リストの完全な表現が送信されます。コンテンツを含むすべてのオプションは、コンプレッサーによって送信されたアイテムの圧縮リストにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Then, once the context has been initialized:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、コンテキストが初期化されると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2) When the structure AND the content of the list are unchanged, no information about the list is sent in compressed headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2）リストの構造と内容が変更されていない場合、リストに関する情報は圧縮ヘッダーで送信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3) When the structure of the list is constant, and when only the content defined within the irregular format for one or more options is changed, no information about the list needs to be sent in compressed base headers; the irregular content is sent as part of the irregular chain, as described in Section 6.3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3）リストの構造が一定で、1つ以上のオプションの不規則なフォーマット内で定義されたコンテンツのみが変更された場合、リストに関する情報を圧縮ベースヘッダーで送信する必要はありません。セクション6.3.6で説明されているように、不規則なコンテンツは不規則なチェーンの一部として送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4) When the structure of the list changes, a compressed list is sent in the compressed base header, including a representation of its structure and order. Content defined within the irregular format of an option can still be sent as part of the irregular chain (as described in Section 6.3.6), provided that the item content is not part of the compressed list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4）リストの構造が変更されると、圧縮されたリストが、その構造と順序の表現を含む、圧縮されたベースヘッダーで送信されます。オプションの不規則な形式で定義されたコンテンツは、アイテムのコンテンツが圧縮リストに含まれていない限り、不規則なチェーンの一部として送信できます（セクション6.3.6を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. Table-Based Item Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. テーブルベースのアイテム圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The table-based item compression compresses individual items sent in compressed lists. The compressor assigns a unique identifier, &#34;Index&#34;, to each item, &#34;Item&#34;, of a list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テーブルベースのアイテム圧縮は、圧縮リストで送信された個々のアイテムを圧縮します。コンプレッサーは、リストの各アイテム「アイテム」に一意の識別子「インデックス」を割り当てます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compressor Logic
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンプレッサーロジック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The compressor conceptually maintains an item table containing all items, indexed using &#34;Index&#34;. The (Index, Item) pair is sent together in compressed lists until the compressor gains enough confidence that the decompressor has observed the mapping between items and their respective index. Confidence is obtained from the reception of an acknowledgment from the decompressor, or by sending (Index, Item) pairs using the optimistic approach. Once confidence is obtained, the index alone is sent in compressed lists to indicate the presence of the item corresponding to this index.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
コンプレッサーは概念的に、「インデックス」を使用してインデックス付けされたすべてのアイテムを含むアイテムテーブルを維持します。 （インデックス、アイテム）のペア​​は、圧縮解除プログラムがアイテムとそれぞれのインデックスとの間のマッピングを観察したという十分な確信がコンプレッサーに得られるまで、圧縮リストで一緒に送信されます。信頼性は、圧縮解除プログラムからの確認の受信から、または楽観的なアプローチを使用して（インデックス、アイテム）ペアを送信することによって取得されます。信頼が得られると、インデックスのみが圧縮リストで送信され、このインデックスに対応するアイテムの存在が示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The compressor may reassign an existing index to a new item, by re-establishing the mapping using the procedure described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
コンプレッサーは、上記の手順を使用してマッピングを再確立することにより、既存のインデックスを新しいアイテムに再割り当てできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decompressor Logic
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解凍ロジック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The decompressor conceptually maintains an item table that contains all (Index, Item) pairs received. The item table is updated whenever an (Index, Item) pair is received and decompression is successfully verified using the CRC. The decompressor retrieves the item from the table whenever an index without an accompanying item is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
デコンプレッサは、概念的には、受信したすべての（インデックス、アイテム）ペアを含むアイテムテーブルを維持します。 （インデックス、アイテム）ペアが受信され、CRCを使用して解凍が正常に検証されると、アイテムテーブルが更新されます。圧縮解除プログラムは、付随するアイテムのないインデックスが受信されるたびに、テーブルからアイテムを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If an index without an accompanying item is received and the decompressor does not have any context for this index, the header MUST be discarded and a NACK SHOULD be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
付随するアイテムのないインデックスが受信され、デコンプレッサがこのインデックスのコンテキストを持たない場合、ヘッダーを破棄し、NACKを送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3. Encoding of Compressed Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3. 圧縮リストのエンコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each item present in a compressed list is represented by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮リストにある各アイテムは、次のように表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an index into the table of items
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アイテムのテーブルへのインデックス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a presence bit indicating if a compressed representation of the item is present in the list
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アイテムの圧縮表現がリストに存在するかどうかを示す存在ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an item (if the presence bit is set)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アイテム（存在ビットが設定されている場合）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decompression of an item will fail if the presence bit is not set and the decompressor has no entry in the context for that item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレゼンスビットが設定されておらず、デコンプレッサにそのアイテムのコンテキストにエントリがない場合、アイテムの解凍は失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A compressed list of TCP options uses the following encoding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPオプションの圧縮リストは、次のエンコードを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | Reserved  |PS |       m       |
      +---+---+---+---+---+---+---+---+
      |        XI_1, ..., XI_m        | m octets, or m * 4 bits
      /                --- --- --- ---/
      |               :    Padding    : if PS = 0 and m is odd
      +---+---+---+---+---+---+---+---+
      |                               |
      /      item_1, ..., item_n      / variable
      |                               |
      +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Reserved: MUST be set to zero; otherwise, the decompressor MUST discard the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
予約済み：ゼロに設定する必要があります。それ以外の場合、圧縮解除プログラムはパケットを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PS: Indicates size of XI fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PS：XIフィールドのサイズを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PS = 0 indicates 4-bit XI fields;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PS = 0は、4ビットのXIフィールドを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PS = 1 indicates 8-bit XI fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PS = 1は、8ビットXIフィールドを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
m: Number of XI item(s) in the compressed list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
m：圧縮リスト内のXIアイテムの数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
XI_1, ..., XI_m: m XI items. Each XI represents one TCP option in the uncompressed packet, in the same order as they appear in the uncompressed packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
XI_1、...、XI_m：m XIアイテム。各XIは、非圧縮パケット内の1つのTCPオプションを、非圧縮パケット内に出現するのと同じ順序で表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The format of an XI item is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
XIアイテムのフォーマットは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                 +---+---+---+---+
         PS = 0: | X |   Index   |
                 +---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   0   1   2   3   4   5   6   7
                 +---+---+---+---+---+---+---+---+
         PS = 1: | X | Reserved  |     Index     |
                 +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
X: Indicates whether the item is present in the list:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
X：アイテムがリストに存在するかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
X = 1 indicates that the item corresponding to the Index is sent in the item_1, ..., item_n list;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
X = 1は、インデックスに対応するアイテムがitem_1、...、item_nリストで送信されることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
X = 0 indicates that the item corresponding to the Index is not sent and is instead included in the irregular chain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
X = 0は、インデックスに対応するアイテムが送信されず、不規則なチェーンに含まれることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Reserved: MUST be set to zero; otherwise, the decompressor MUST discard the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
予約済み：ゼロに設定する必要があります。それ以外の場合、圧縮解除プログラムはパケットを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Index: An index into the item table. See Section 6.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
インデックス：アイテムテーブルへのインデックス。セクション6.3.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
When 4-bit XI items are used, the XI items are placed in octets in the following manner:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
4ビットXIアイテムが使用される場合、XIアイテムは次の方法でオクテットに配置されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           0   1   2   3   4   5   6   7
         +---+---+---+---+---+---+---+---+
         |     XI_k      |    XI_k + 1   |
         +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Padding: A 4-bit padding field is present when PS = 0 and the number of XIs is odd. The Padding field MUST be set to zero; otherwise, the decompressor MUST discard the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パディング：PS = 0でXIの数が奇数の場合、4ビットのパディングフィールドが存在します。 Paddingフィールドはゼロに設定する必要があります。それ以外の場合、圧縮解除プログラムはパケットを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Item 1, ..., item n: Each item corresponds to an XI with X = 1 in XI 1, ..., XI m. The format of the entries in the item list is described in the table in Section 6.3. The compressed format(s) suffixed by &#34;_list_item&#34; in the encoding methods defines the item inside the compressed item list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
アイテム1、...、アイテムn：各アイテムは、XI 1、...、XI mのX = 1のXIに対応します。アイテムリストのエントリの形式については、6.3項の表を参照してください。エンコード方式で「_list_item」の接尾辞が付いた圧縮形式は、圧縮アイテムリスト内のアイテムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. Item Table Mappings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. アイテムテーブルのマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The item table for TCP options list compression is limited to 16 different items, since it is unlikely that any packet flow will contain a larger number of unique options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPオプションリスト圧縮の項目テーブルは、パケットフローに多数の一意のオプションが含まれる可能性が低いため、16の異なる項目に制限されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mapping between the TCP option type and table indexes are listed in the table below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPオプションタイプとテーブルインデックス間のマッピングを次の表に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         +-----------------+---------------+
         |   Option name   |  Table index  |
         +-----------------+---------------+
         |      NOP        |       0       |
         |      EOL        |       1       |
         |      MSS        |       2       |
         |  WINDOW SCALE   |       3       |
         |   TIMESTAMP     |       4       |
         | SACK-PERMITTED  |       5       |
         |      SACK       |       6       |
         | Generic options |      7-15     |
         +-----------------+---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some TCP options are used more frequently than others. To simplify their compression, a part of the item table is reserved for these option types, as shown on the table above. Both the compressor and the decompressor MUST use these mappings between item and indexes to (de)compress TCP options when using list compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のTCPオプションは他よりも頻繁に使用されます。上の表に示すように、圧縮を簡単にするために、アイテムテーブルの一部がこれらのオプションタイプ用に予約されています。圧縮プログラムと圧縮解除プログラムの両方は、リスト圧縮を使用する場合、アイテムとインデックス間のこれらのマッピングを使用して、TCPオプションを圧縮（圧縮解除）する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is expected that the option types for which an index is reserved in the item table will only appear once in a list. However, if an option type is detected twice in the same options list and if both options have a different content, the compressor should compress the second occurrence of the option type by mapping it to a generic compressed option. Otherwise, if the options have the exact same content, the compressor can still use the same table index for both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アイテムテーブルでインデックスが予約されているオプションタイプは、リストに一度だけ表示されることが期待されています。ただし、オプションタイプが同じオプションリストで2回検出され、両方のオプションの内容が異なる場合、コンプレッサーは、2番目に出現するオプションタイプを汎用の圧縮オプションにマッピングして圧縮する必要があります。それ以外の場合、オプションの内容がまったく同じであれば、圧縮プログラムは引き続き両方に同じテーブルインデックスを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NOP option
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOPオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The NOP option can appear more than once in the list. However, since its value is always the same, no context information needs to be transmitted. Multiple NOP options can thus be mapped to the same index. Since the NOP option does not have any content when compressed as a &#34;_list_item&#34;, it will never be present in the item list. For consistency, the compressor should still establish an entry in the list by setting the presence bit, as done for the other type of options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NOPオプションは、リストに複数回表示できます。ただし、その値は常に同じであるため、コンテキスト情報を送信する必要はありません。したがって、複数のNOPオプションを同じインデックスにマップできます。 「_list_item」として圧縮された場合、NOPオプションにはコンテンツがないため、アイテムリストには表示されません。一貫性を保つため、他のタイプのオプションの場合と同様に、圧縮プログラムはプレゼンスビットを設定して、リストにエントリを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
List compression always preserves the original order of each item in the decompressed list, whether or not the item is present in the compressed &#34;_list_item&#34; or if multiple items of the same type can be mapped to the same index, as for the NOP option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
リスト圧縮は、圧縮された &#34;_list_item&#34;にアイテムが存在するかどうかに関係なく、またはNOPオプションのように同じタイプの複数のアイテムを同じインデックスにマップできるかどうかに関係なく、圧縮解除リスト内の各アイテムの元の順序を常に保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The EOL option
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EOLオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The size of the compressed format for the EOL option can be larger than one octet, and it is defined so that it includes the option padding. This is because the EOL should terminate the parsing of the options, but it can also be followed by padding octets that all have the value zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
EOLオプションの圧縮形式のサイズは1オクテットより大きくすることができ、オプションパディングを含むように定義されています。これは、EOLがオプションの解析を終了する必要があるためですが、その後にすべての値がゼロのパディングオクテットが続く場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Generic option
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的なオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The Generic option can be used to compress any type of TCP option that does not have a reserved index in the item table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Genericオプションは、アイテムテーブルに予約済みインデックスを持たない、あらゆるタイプのTCPオプションを圧縮するために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.5. Compressed Lists in Dynamic Chain
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.5. 動的チェーンの圧縮リスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A compressed list for TCP options that is part of the dynamic chain (e.g., in IR or IR-DYN packets) must have all its list items present, i.e., all X-bits in the XI list MUST be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動的チェーンの一部である（IRパケットやIR-DYNパケットなどの）TCPオプションの圧縮リストには、そのすべてのリスト項目が存在する必要があります。つまり、XIリストのすべてのXビットが設定されている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.6. Irregular Chain Items for TCP Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.6. TCPオプションの不規則なチェーンアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;_list_item&#34; represents the option inside the compressed item list, and the &#34;_irregular&#34; format is used for the option fields that are expected to change with each packet. When an item of the specified type is present in the current context, these irregular fields are present in each compressed packet, as part of the irregular chain. Since many of the TCP option types are not expected to change for the duration of a flow, many of the &#34;_irregular&#34; formats are empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「_list_item」は圧縮された項目リスト内のオプションを表し、「_ irregular」形式は各パケットで変更されることが予想されるオプションフィールドに使用されます。指定されたタイプのアイテムが現在のコンテキストに存在する場合、これらの不規則なフィールドは、不規則なチェーンの一部として、各圧縮パケットに存在します。 TCPオプションタイプの多くはフローの期間中は変更されないため、「_ irregular」フォーマットの多くは空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The irregular chain for TCP options is structured analogously to the structure of the TCP options in the uncompressed packet. If a compressed list is present in the compressed packet, then the irregular chain for TCP options must not contain irregular items for the list items that are transmitted inside the compressed list (i.e., items in the list that have the X-bit set in its XI). The items that are not present in the compressed list, but are present in the uncompressed list, must have their respective irregular items present in the irregular chain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPオプションの不規則なチェーンは、非圧縮パケットのTCPオプションの構造と同様に構造化されています。圧縮リストに圧縮リストが存在する場合、TCPオプションの不規則なチェーンに、圧縮リスト内で送信されるリストアイテムの不規則なアイテム（Xビットが設定されているリストのアイテム）を含めることはできません。 XI）。圧縮リストには存在しないが、非圧縮リストには存在するアイテムは、それぞれの不規則なアイテムが不規則なチェーンに存在する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.7. Replication of TCP Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.7. TCPオプションの複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The entire table of TCP options items is always replicated when using the IR-CR packet. In the IR-CR packet, the list of options for the new flow is also transmitted as a compressed list in the IR-CR packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IR-CRパケットを使用する場合、TCPオプション項目のテーブル全体が常に複製されます。 IR-CRパケットでは、新しいフローのオプションのリストも圧縮リストとしてIR-CRパケットで送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Profile-Specific Encoding Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. プロファイル固有のエンコード方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines encoding methods that are specific to this profile. These methods are used in the formal definition of the packet formats in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、このプロファイルに固有のエンコード方式を定義します。これらのメソッドは、セクション8のパケット形式の正式な定義で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. inferred_ip_v4_header_checksum
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. inferred_ip_v4_header_checksum
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method compresses the Header Checksum field of the IPv4 header. This checksum is defined in [RFC0791] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方式は、IPv4ヘッダーのヘッダーチェックサムフィールドを圧縮します。このチェックサムは、[RFC0791]で次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Header Checksum: 16 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ヘッダーチェックサム：16ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
A checksum on the header only. Since some header fields change (e.g., time to live), this is recomputed and verified at each point that the internet header is processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ヘッダーのみのチェックサム。一部のヘッダーフィールドは変更されるため（存続時間など）、これはインターネットヘッダーが処理されるたびに再計算および検証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The checksum algorithm is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
チェックサムアルゴリズムは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The checksum field is the 16-bit one&#39;s complement of the one&#39;s complement sum of all 16-bit words in the header. For purposes of computing the checksum, the value of the checksum field is zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
チェックサムフィールドは、ヘッダー内のすべての16ビットワードの1の補数合計の16ビットの1の補数です。チェックサムを計算するために、チェックサムフィールドの値はゼロです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described above, the header checksum protects individual hops from processing a corrupted header. When almost all IP header information is compressed away, and when decompression is verified by a CRC computed over the original header for every compressed packet, there is no point in having this additional checksum; instead, it can be recomputed at the decompressor side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、ヘッダーチェックサムは、個々のホップを破損したヘッダーの処理から保護します。ほとんどすべてのIPヘッダー情報が圧縮され、すべての圧縮パケットの元のヘッダーに対して計算されたCRCによって解凍が検証される場合、この追加のチェックサムを使用しても意味がありません。代わりに、圧縮解除側で再計算できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;inferred_ip_v4_header_checksum&#34; encoding method thus compresses the IPv4 header checksum down to a size of zero bits. Using this encoding method, the decompressor infers the value of this field using the computation above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、「inferred_ip_v4_header_checksum」エンコーディング方式は、IPv4ヘッダーチェックサムをゼロビットのサイズに圧縮します。このエンコード方式を使用すると、デコンプレッサは上記の計算を使用してこのフィールドの値を推測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method implicitly assumes that the compressor will not process a corrupted header; otherwise, it cannot guarantee that the checksum as recomputed by the decompressor will be bitwise identical to its original value before compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方式は、圧縮プログラムが破損したヘッダーを処理しないことを暗黙的に想定しています。それ以外の場合、圧縮解除プログラムによって再計算されたチェックサムが圧縮前の元の値とビットごとに同一になることは保証できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. inferred_mine_header_checksum
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. inferred_mine_header_checksum
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method compresses the minimal encapsulation header checksum. This checksum is defined in [RFC2004] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方式は、最小限のカプセル化ヘッダーチェックサムを圧縮します。このチェックサムは、[RFC2004]で次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Header Checksum
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ヘッダーチェックサム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The 16-bit one&#39;s complement of the one&#39;s complement sum of all 16-bit words in the minimal forwarding header. For purposes of computing the checksum, the value of the checksum field is zero. The IP header and IP payload (after the minimal forwarding header) are not included in this checksum computation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
最小転送ヘッダー内のすべての16ビットワードの1の補数の和の16ビットの1の補数。チェックサムを計算するために、チェックサムフィールドの値はゼロです。 IPヘッダーとIPペイロード（最小限の転送ヘッダーの後）は、このチェックサムの計算には含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;inferred_mine_header_checksum&#34; encoding method compresses the minimal encapsulation header checksum down to a size of zero bits, i.e., no bits are transmitted in compressed headers for this field. Using this encoding method, the decompressor infers the value of this field using the above computation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「inferred_mine_header_checksum」エンコーディング方式は、最小のカプセル化ヘッダーチェックサムをゼロビットのサイズに圧縮します。つまり、このフィールドの圧縮ヘッダーでビットは送信されません。このエンコード方式を使用すると、デコンプレッサは上記の計算を使用してこのフィールドの値を推測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The motivations and the assumptions for inferring this checksum are similar to the ones explained above in Section 6.4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチェックサムを推論する動機と仮定は、セクション6.4.1で説明したものと同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3. inferred_ip_v4_length
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3. inferred_ip_v4_length
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method compresses the Total Length field of the IPv4 header. The Total Length field of the IPv4 header is defined in [RFC0791] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方式は、IPv4ヘッダーのTotal Lengthフィールドを圧縮します。 IPv4ヘッダーの全長フィールドは、[RFC0791]で次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Total Length: 16 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
全長：16ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Total Length is the length of the datagram, measured in octets, including internet header and data. This field allows the length of a datagram to be up to 65,535 octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
全長は、インターネットヘッダーとデータを含むオクテットで測定されたデータグラムの長さです。このフィールドでは、データグラムの長さを最大65,535オクテットにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;inferred_ip_v4_length&#34; encoding method compresses the IPv4 Total Length field down to a size of zero bits. Using this encoding method, the decompressor infers the value of this field by counting in octets the length of the entire packet after decompression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「inferred_ip_v4_length」エンコーディング方式は、IPv4全長フィールドをゼロビットのサイズに圧縮します。このエンコード方式を使用して、圧縮解除プログラムは、圧縮解除後のパケット全体の長さをオクテット単位でカウントすることにより、このフィールドの値を推測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.4. inferred_ip_v6_length
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.4. inferred_ip_v6_length
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method compresses the Payload Length field of the IPv6 header. This length field is defined in [RFC2460] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方式は、IPv6ヘッダーのペイロード長フィールドを圧縮します。この長さフィールドは、[RFC2460]で次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Payload Length: 16-bit unsigned integer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ペイロード長：16ビット符号なし整数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Length of the IPv6 payload, i.e., the rest of the packet following this IPv6 header, in octets. (Note that any extension headers present are considered part of the payload, i.e., included in the length count.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
IPv6ペイロードの長さ、つまり、このIPv6ヘッダーに続くパケットの残りの部分（オクテット単位）。 （存在するすべての拡張ヘッダーはペイロードの一部と見なされる、つまり長さのカウントに含まれることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;inferred_ip_v6_length&#34; encoding method compresses the Payload Length field of the IPv6 header down to a size of zero bits. Using this encoding method, the decompressor infers the value of this field by counting in octets the length of the entire packet after decompression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「inferred_ip_v6_length」エンコーディング方式は、IPv6ヘッダーのペイロード長フィールドをゼロビットのサイズに圧縮します。このエンコード方式を使用して、圧縮解除プログラムは、圧縮解除後のパケット全体の長さをオクテット単位でカウントすることにより、このフィールドの値を推測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.5. inferred_offset
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.5. inferred_offset
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method compresses the data offset field of the TCP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方式は、TCPヘッダーのデータオフセットフィールドを圧縮します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;inferred_offset&#34; encoding method is used on the Data Offset field of the TCP header. This field is defined in [RFC0793] as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「inferred_offset」エンコーディング方式は、TCPヘッダーのデータオフセットフィールドで使用されます。このフィールドは、[RFC0793]で次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Data Offset: 4 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
データオフセット：4ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The number of 32-bit words in the TCP header. This indicates where the data begins. The TCP header (even one including options) is an integral number of 32 bits long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
TCPヘッダー内の32ビットワードの数。これは、データが始まる場所を示します。 TCPヘッダー（オプションを含むものでも）は、32ビット長の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;inferred_offset&#34; encoding method compresses the Data Offset field of the TCP header down to a size of zero bits. Using this encoding method, the decompressor infers the value of this field by first decompressing the TCP options list, and by then setting:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「inferred_offset」エンコーディング方式は、TCPヘッダーのデータオフセットフィールドをゼロビットのサイズに圧縮します。このエンコード方式を使用して、圧縮解除プログラムは、最初にTCPオプションリストを圧縮解除し、次に以下を設定することにより、このフィールドの値を推測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              data offset = (options length / 4) + 5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The equation above uses integer arithmetic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の方程式は整数演算を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.6. baseheader_extension_headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.6. baseheader_extension_headers
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In CO packets (see Section 7.3), the innermost IP header and the TCP header are combined to create a compressed base header. In some cases, the IP header will have a number of extension headers between itself and the TCP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COパケット（セクション7.3を参照）では、最も内側のIPヘッダーとTCPヘッダーが結合されて、圧縮された基本ヘッダーが作成されます。場合によっては、IPヘッダーはそれ自体とTCPヘッダーの間にいくつかの拡張ヘッダーを持つことになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To remain formally correct, the base header must define some representation of these extension headers, which is what this encoding method is used for. This encoding method skips over all the extension headers and does not encode any of the fields. Changed fields in these headers are encoded in the irregular chain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
形式的に正しいままにするには、ベースヘッダーでこれらの拡張ヘッダーの表現を定義する必要があります。これは、このエンコード方式が使用される目的です。このエンコード方法では、すべての拡張ヘッダーがスキップされ、フィールドはエンコードされません。これらのヘッダーの変更されたフィールドは、不規則なチェーンでエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.7. baseheader_outer_headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.7. baseheader_outer_headers
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method, as well as the baseheader_extension_headers encoding method described above, is needed for the specification to remain formally correct. It is used in CO packets (see Section 7.3) to describe tunneling IP headers and their respective extension headers (i.e., all headers located before the innermost IP header).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方法は、上記のbaseheader_extension_headersエンコード方法と同様に、仕様が正式に正しいままであるのに必要です。 COパケット（セクション7.3を参照）で使用され、トンネリングIPヘッダーとそれぞれの拡張ヘッダー（つまり、最も内側のIPヘッダーの前にあるすべてのヘッダー）を記述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method skips over all the fields in these headers and does not perform any encoding. Changed fields in outer headers are instead handled by the irregular chain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方式は、これらのヘッダーのすべてのフィールドをスキップし、エンコードを実行しません。代わりに、外部ヘッダーの変更されたフィールドは、不規則なチェーンによって処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.8. Scaled Encoding of Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.8. フィールドのスケーリングされたエンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some header fields will exhibit a change pattern where the field increases by a constant value or by multiples of the same value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のヘッダーフィールドは、フィールドが定数値または同じ値の倍数で増加する変更パターンを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Examples of fields that may have this behavior are the TCP Sequence Number and the TCP Acknowledgment Number. For such fields, ROHC-TCP provides the means to downscale the field value before applying LSB encoding, which allows the compressor to transmit fewer bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この動作をする可能性のあるフィールドの例は、TCPシーケンス番号とTCP確認応答番号です。そのようなフィールドの場合、ROHC-TCPは、LSBエンコーディングを適用する前にフィールド値をダウンスケールする手段を提供します。これにより、コンプレッサーはより少ないビットを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To be able to use scaled encoding, the field is required to fulfill the following equation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スケーリングされたエンコーディングを使用できるようにするには、フィールドは次の方程式を満たす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        unscaled_value = scaling_factor * scaled_value + residue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To use the scaled encoding, the compressor must be confident that the decompressor has established values for the &#34;residue&#34; and the &#34;scaling_factor&#34;, so that it can correctly decompress the field when only an LSB-encoded &#34;scaled_value&#34; is present in the compressed packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スケーリングされたエンコーディングを使用するには、LSBエンコードされた「scaled_value」だけが圧縮された状態で存在する場合に、フィールドが正しく圧縮解除できるように、圧縮プログラムがデコンプレッサが「residue」と「scaling_factor」の値を確立していることを確信している必要があります。パケット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the compressor is confident that the value of the scaling_factor and the value of the residue have been established in the decompressor, the compressor may send compressed packets using the scaled representation of the field. The compressor MUST NOT use scaled encoding with the value of the scaling_factor set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮プログラムが、scaling_factorの値と残差の値が圧縮解除プログラムで確立されたと確信すると、圧縮プログラムは、フィールドのスケーリングされた表現を使用して圧縮パケットを送信できます。コンプレッサーは、scaling_factorの値がゼロに設定されたスケーリングされたエンコードを使用してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the compressor detects that the value of the residue has changed, or if the compressor uses a different value for the scaling factor, it MUST NOT use scaled encoding until it is confident that the decompressor has received the new value(s) of these fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残差の値が変更されたことをコンプレッサーが検出した場合、またはコンプレッサーがスケーリングファクターに別の値を使用する場合、コンプレッサーがこれらのフィールドの新しい値を受け取ったと確信できるまで、スケーリングされたエンコーディングを使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the unscaled value of the field wraps around, the value of the residue is likely to change, even if the scaling_factor remains constant. In such a case, the compressor must act in the same way as for any other change in the residue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドのスケーリングされていない値が折り返されると、scaleing_factorが一定のままであっても、残差の値が変化する可能性があります。このような場合、コンプレッサーは、他の残留物変化と同じように動作する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections describe how the scaled encoding is applied to specific fields in ROHC-TCP, in particular, how the scaling_factor and residue values are established for the different fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブセクションでは、スケーリングされたエンコーディングがROHC-TCPの特定のフィールドにどのように適用されるか、特に、さまざまなフィールドに対してscaling_factorと残留値がどのように確立されるかについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.8.1. Scaled TCP Sequence Number Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.8.1. スケーリングされたTCPシーケンス番号エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some TCP flows, such as data transfers, the payload size will be constant over periods of time. For such flows, the TCP Sequence Number is bound to increase by multiples of the payload size between packets, which means that this field can be a suitable target for scaled encoding. When using this encoding, the payload size will be used as the scaling factor (i.e., as the value for scaling_factor) of this encoding. This means that the scaling factor does not need to be explicitly transmitted, but is instead inferred from the length of the payload in the compressed packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ転送などの一部のTCPフローでは、ペイロードサイズは一定期間一定です。このようなフローの場合、TCPシーケンス番号はパケット間のペイロードサイズの倍数で増加するようにバインドされています。つまり、このフィールドはスケーリングされたエンコーディングの適切なターゲットになる可能性があります。このエンコーディングを使用する場合、ペイロードサイズはこのエンコーディングのスケーリング係数（つまり、scaling_factorの値）として使用されます。これは、スケーリング係数を明示的に送信する必要がないことを意味しますが、代わりに圧縮パケットのペイロードの長さから推測されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Establishing scaling_factor:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
scaling_factorの確立：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The scaling factor is established by sending unscaled TCP Sequence Number bits, so that the decompressor can infer the scaling_factor from the payload size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
スケーリング係数は、スケーリングされていないTCPシーケンス番号ビットを送信することによって確立されるため、デコンプレッサはペイロードサイズからscaling_factorを推測できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Establishing residue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残留物の確立：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The residue is established identically as the scaling_factor, i.e., by sending unscaled TCP Sequence Number bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
残差は、scaling_factorと同じように、つまり、スケーリングされていないTCPシーケンス番号ビットを送信することによって確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A detailed specification of how the TCP Sequence Number uses the scaled encoding can be found in the definitions of the packet formats, in Section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPシーケンス番号がスケーリングされたエンコーディングを使用する方法の詳細な仕様は、セクション8.2のパケット形式の定義にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.8.2. Scaled Acknowledgment Number Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.8.2. スケーリングされた確認応答番号のエンコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similar to the pattern exhibited by the TCP Sequence Number, the expected increase in the TCP Acknowledgment Number is often constant and is therefore suitable for scaled encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPシーケンス番号が示すパターンと同様に、TCP確認応答番号の予想される増加は一定であることが多いため、スケーリングされたエンコーディングに適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the TCP Acknowledgment Number, the scaling factor depends on the size of packets flowing in the opposite direction; this information might not be available to the compressor/decompressor pair. For this reason, ROHC-TCP uses an explicitly transmitted scaling factor to compress the TCP Acknowledgment Number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP確認応答番号の場合、スケーリング係数は反対方向に流れるパケットのサイズに依存します。この情報は、コンプレッサー/デコンプレッサーのペアでは利用できない場合があります。このため、ROHC-TCPは明示的に送信されたスケーリング係数を使用して、TCP確認応答番号を圧縮します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Establishing scaling_factor:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
scaling_factorの確立：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The scaling factor is established by explicitly transmitting the value of the scaling factor (called ack_stride in the formal notation in Section 8.2) to the decompressor, using one of the packet types that can carry this information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
スケーリングファクターは、この情報を運ぶことができるパケットタイプの1つを使用して、スケーリングファクターの値（セクション8.2では正式な表記ではack_strideと呼ばれます）をデコンプレッサに明示的に送信することによって確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Establishing residue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残留物の確立：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The scaling residue is established by sending unscaled TCP Acknowledgment Number bits, so that the decompressor can infer its value from the unscaled value and the scaling factor (ack_stride).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
スケーリング残差は、スケーリングされていないTCP確認番号ビットを送信することによって確立されるため、デコンプレッサは、スケーリングされていない値とスケーリング係数（ack_stride）からその値を推測できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A detailed specification of how the TCP Acknowledgment Number uses the scaled encoding can be found in the definitions of the packet formats, in Section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP確認応答番号がスケーリングされたエンコーディングを使用する方法の詳細な仕様は、セクション8.2のパケット形式の定義にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressor MAY use the scaled acknowledgment number encoding; what value it will use as the scaling factor is up to the compressor implementation. In the case where there is a co-located decompressor processing packets of the same TCP flow in the opposite direction, the scaling factor for the sequence number used for that flow can be used by the compressor to determine a suitable scaling factor for the TCP Acknowledgment number for this flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンプレッサーは、スケーリングされた確認応答番号エンコーディングを使用してもよい（MAY）。スケーリング係数として使用する値は、コンプレッサーの実装次第です。逆方向に同じTCPフローのパケットを処理する同じ場所に配置されたデコンプレッサが存在する場合、そのフローに使用されるシーケンス番号のスケーリング係数をコンプレッサーが使用して、TCP確認応答の適切なスケーリング係数を決定できます。このフローの番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. Encoding Methods with External Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. 外部パラメーターを使用したメソッドのエンコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of encoding methods in Section 8.2 have one or more arguments for which the derivation of the parameter&#39;s value is outside the scope of the ROHC-FN specification of the header formats. This section lists the encoding methods together with a definition of each of their parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション8.2の多くのエンコード方式には、パラメーターの値の導出がヘッダー形式のROHC-FN仕様の範囲外である1つ以上の引数があります。このセクションでは、エンコード方法と、各パラメーターの定義をリストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ipv6(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ipv6（is_innermost、ttl_irregular_chain_flag、ip_inner_ecn）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
is_innermost: This Boolean flag is set to true when processing the innermost IP header; otherwise, it is set to false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
is_innermost：このブールフラグは、最も内側のIPヘッダーを処理するときにtrueに設定されます。それ以外の場合は、falseに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ttl_irregular_chain_flag: This parameter must be set to the value that was used for the corresponding &#34;ttl_irregular_chain_flag&#34; parameter of the &#34;co_baseheader&#34; encoding method (as defined below) when extracting the irregular chain for a compressed header; otherwise, it is set to zero and ignored for other types of chains.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ttl_irregular_chain_flag：このパラメーターは、圧縮ヘッダーの不規則なチェーンを抽出するときに、「co_baseheader」エンコーディング方式（以下で定義）の対応する「ttl_irregular_chain_flag」パラメーターに使用された値に設定する必要があります。それ以外の場合は、ゼロに設定され、他のタイプのチェーンでは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 ip_inner_ecn: This parameter is bound by the encoding method; therefore, it should be undefined when calling this encoding method. This value is then used to bind the corresponding parameter in the &#34;tcp&#34; encoding method, as its value is needed when processing the irregular chain for TCP. See the definition of the &#34;ip_inner_ecn&#34; parameter for the &#34;tcp&#34; encoding method below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ip_inner_ecn：このパラメーターはエンコード方式によってバインドされます。したがって、このエンコーディングメソッドを呼び出すときは、未定義にする必要があります。この値は、TCPの不規則なチェーンを処理するときに必要になるため、「tcp」エンコーディング方式で対応するパラメータをバインドするために使用されます。以下の「tcp」エンコーディング方式については、「ip_inner_ecn」パラメータの定義を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ipv4(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn, ip_id_behavior_value):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ipv4（is_innermost、ttl_irregular_chain_flag、ip_inner_ecn、ip_id_behavior_value）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
See definition of arguments for &#34;ipv6&#34; above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
上記の「ipv6」の引数の定義を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ip_id_behavior_value: Set to a 2-bit integer value, using one of the constants whose name begins with the prefix IP_ID_BEHAVIOR_ and as defined in Section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ip_id_behavior_value：名前が接頭辞IP_ID_BEHAVIOR_で始まり、セクション8.2で定義されている定数の1つを使用して、2ビット整数値に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o tcp_opt_eol(nbits):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o tcp_opt_eol（nbits）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nbits: This parameter is set to the length of the padding data located after the EOL option type octet to the end of the TCP options in the uncompressed header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nbits：このパラメーターは、EOLオプションタイプオクテットの後ろから非圧縮ヘッダーのTCPオプションの最後までのパディングデータの長さに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o tcp_opt_sack(ack_value):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o tcp_opt_sack（ack_value）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ack_value: Set to the value of the Acknowledgment Number field of the TCP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ack_value：TCPヘッダーの確認番号フィールドの値に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o tcp(payload_size, ack_stride_value, ip_inner_ecn):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o tcp（payload_size、ack_stride_value、ip_inner_ecn）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
payload_size: Set to the length (in octets) of the payload following the TCP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
payload_size：TCPヘッダーに続くペイロードの長さ（オクテット単位）に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ack_stride_value: This parameter is the scaling factor used when scaling the TCP Acknowledgment Number. Its value is set by the compressor implementation. See Section 6.4.8.2 for recommendations on how to set this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ack_stride_value：このパラメーターは、TCP確認応答番号をスケーリングするときに使用されるスケーリング係数です。その値は、コンプレッサーの実装によって設定されます。この値の設定方法に関する推奨事項については、6.4.8.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ip_inner_ecn: This parameter binds with the value given to the corresponding &#34;ip_inner_ecn&#34; parameter by the &#34;ipv4&#34; or the &#34;ipv6&#34; encoding method when processing the innermost IP header of this packet. See also the definition of the &#34;ip_inner_ecn&#34; parameter to the &#34;ipv6&#34; and &#34;ipv4&#34; encoding method above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ip_inner_ecn：このパラメーターは、このパケットの最も内側のIPヘッダーを処理するときに、「ipv4」または「ipv6」エンコード方式によって対応する「ip_inner_ecn」パラメーターに指定された値とバインドします。上記の「ipv6」および「ipv4」エンコーディングメソッドに対する「ip_inner_ecn」パラメータの定義も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o co_baseheader(payload_size, ack_stride_value, ttl_irregular_chain_flag, ip_id_behavior_value):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o co_baseheader（payload_size、ack_stride_value、ttl_irregular_chain_flag、ip_id_behavior_value）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
payload_size: Set to the length (in octets) of the payload following the TCP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
payload_size：TCPヘッダーに続くペイロードの長さ（オクテット単位）に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ack_stride_value: This parameter is the scaling factor used when scaling the TCP Acknowledgment Number. Its value is set by the compressor implementation. See Section 6.4.8.2 for recommendations on how to set this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ack_stride_value：このパラメーターは、TCP確認応答番号をスケーリングするときに使用されるスケーリング係数です。その値は、コンプレッサーの実装によって設定されます。この値の設定方法に関する推奨事項については、6.4.8.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ttl_irregular_chain_flag: This parameter is set to one if the TTL/Hop Limit of an outer header has changed compared to its reference in the context; otherwise, it is set to zero. The value used for this parameter is also used for the &#34;ttl_irregular_chain_flag&#34; argument for the &#34;ipv4&#34; and &#34;ipv6&#34; encoding methods when processing the irregular chain, as defined above for the &#34;ipv6&#34; and &#34;ipv4&#34; encoding methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ttl_irregular_chain_flag：このパラメーターは、外部ヘッダーのTTL /ホップ制限がコンテキスト内の参照と比較して変更された場合に1に設定されます。それ以外の場合は、ゼロに設定されます。このパラメーターに使用される値は、「ipv6」および「ipv4」エンコーディングメソッドについて上記で定義されているように、不規則なチェーンを処理するときに、「ipv4」および「ipv6」エンコーディングメソッドの「ttl_irregular_chain_flag」引数にも使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ip_id_behavior_value: Set to a 2-bit integer value, using one of the constants whose name begins with the prefix IP_ID_BEHAVIOR_ and as defined in Section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ip_id_behavior_value：名前が接頭辞IP_ID_BEHAVIOR_で始まり、セクション8.2で定義されている定数の1つを使用して、2ビット整数値に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Packet Types (Normative)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. パケットタイプ（規定）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP uses three different packet types: the Initialization and Refresh (IR) packet type, the Context Replication (IR-CR) packet type, and the Compressed (CO) packet type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPは、3つの異なるパケットタイプを使用します。初期化およびリフレッシュ（IR）パケットタイプ、コンテキストレプリケーション（IR-CR）パケットタイプ、および圧縮（CO）パケットタイプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each packet type defines a number of packet formats: two packet formats are defined for the IR type, one packet format is defined for the IR-CR type, and two sets of eight base header formats are defined for the CO type with one additional format that is common to both sets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各パケットタイプは、いくつかのパケットフォーマットを定義します。IRタイプには2つのパケットフォーマットが定義され、IR-CRタイプには1つのパケットフォーマットが定義され、追加のフォーマットが1つあるCOタイプには8つの基本ヘッダーフォーマットが2セット定義されます。それは両方のセットに共通です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The profile identifier for ROHC-TCP is 0x0006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPのプロファイル識別子は0x0006です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Initialization and Refresh (IR) Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 初期化および更新（IR）パケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP uses the basic structure of the ROHC IR and IR-DYN packets as defined in [RFC5795] (Sections 5.2.2.1 and 5.2.2.2, respectively).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPは、[RFC5795]で定義されているROHC IRおよびIR-DYNパケットの基本構造を使用します（それぞれセクション5.2.2.1および5.2.2.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet type: IR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットタイプ：IR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This packet type communicates the static part and the dynamic part of the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このパケットタイプは、コンテキストの静的部分と動的部分を伝達します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For the ROHC-TCP IR packet, the value of the x bit MUST be set to one. It has the following format, which corresponds to the &#34;Header&#34; and &#34;Payload&#34; fields described in Section 5.2.1 of [RFC5795]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ROHC-TCP IRパケットの場合、xビットの値を1に設定する必要があります。 [RFC5795]のセクション5.2.1で説明されている「Header」フィールドと「Payload」フィールドに対応する次の形式があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0   1   2   3   4   5   6   7
       --- --- --- --- --- --- --- ---
      :        Add-CID octet          : if for small CIDs and (CID != 0)
      +---+---+---+---+---+---+---+---+
      | 1   1   1   1   1   1   0   1 | IR type octet
      +---+---+---+---+---+---+---+---+
      :                               :
      /       0-2 octets of CID       / 1-2 octets if for large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      |         Profile = 0x06        | 1 octet
      +---+---+---+---+---+---+---+---+
      |              CRC              | 1 octet
      +---+---+---+---+---+---+---+---+
      |                               |
      /         Static chain          / variable length
      |                               |
       - - - - - - - - - - - - - - - -
      |                               |
      /         Dynamic chain         / variable length
      |                               |
       - - - - - - - - - - - - - - - -
      |                               |
      /            Payload            / variable length
      |                               |
       - - - - - - - - - - - - - - - -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC: 8-bit CRC, computed according to Section 5.3.1.1 of [RFC5795]. The CRC covers the entire IR header, thus excluding payload, padding, and feedback, if any.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC：[RFC5795]のセクション5.3.1.1に従って計算された8ビットCRC。 CRCはIRヘッダー全体をカバーするため、ペイロード、パディング、およびフィードバックがあればそれを除外します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Static chain: See Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
静的チェーン：セクション6.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Dynamic chain: See Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
動的チェーン：セクション6.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Payload: The payload of the corresponding original packet, if any. The payload consists of all data after the last octet of the TCP header to the end of the uncompressed packet. The presence of a payload is inferred from the packet length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ペイロード：対応する元のパケットのペイロード（ある場合）。ペイロードは、TCPヘッダーの最後のオクテットから非圧縮パケットの最後までのすべてのデータで構成されます。ペイロードの存在は、パケット長から推測されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet type: IR-DYN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットタイプ：IR-DYN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This packet type communicates the dynamic part of the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このパケットタイプは、コンテキストの動的な部分を伝達します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The ROHC-TCP IR-DYN packet has the following format, which corresponds to the &#34;Header&#34; and &#34;Payload&#34; fields described in Section 5.2.1 of [RFC5795]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ROHC-TCP IR-DYNパケットの形式は次のとおりです。これは、[RFC5795]のセクション5.2.1で説明されている「ヘッダー」および「ペイロード」フィールドに対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0   1   2   3   4   5   6   7
       --- --- --- --- --- --- --- ---
      :         Add-CID octet         : if for small CIDs and (CID != 0)
      +---+---+---+---+---+---+---+---+
      | 1   1   1   1   1   0   0   0 | IR-DYN type octet
      +---+---+---+---+---+---+---+---+
      :                               :
      /       0-2 octets of CID       / 1-2 octets if for large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      |         Profile = 0x06        | 1 octet
      +---+---+---+---+---+---+---+---+
      |              CRC              | 1 octet
      +---+---+---+---+---+---+---+---+
      |                               |
      /         Dynamic chain         / variable length
      |                               |
       - - - - - - - - - - - - - - - -
      |                               |
      /            Payload            / variable length
      |                               |
       - - - - - - - - - - - - - - - -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC: 8-bit CRC, computed according to Section 5.3.1.1 of [RFC5795]. The CRC covers the entire IR-DYN header, thus excluding payload, padding, and feedback, if any.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC：[RFC5795]のセクション5.3.1.1に従って計算された8ビットCRC。 CRCはIR-DYNヘッダー全体をカバーするため、ペイロード、パディング、フィードバックがあれば除外されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Dynamic chain: See Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
動的チェーン：セクション6.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Payload: The payload of the corresponding original packet, if any. The payload consists of all data after the last octet of the TCP header to end of the uncompressed packet. The presence of a payload is inferred from the packet length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ペイロード：対応する元のパケットのペイロード（ある場合）。ペイロードは、TCPヘッダーの最後のオクテットから非圧縮パケットの終わりまでのすべてのデータで構成されます。ペイロードの存在は、パケット長から推測されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Context Replication (IR-CR) Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. コンテキスト複製（IR-CR）パケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Context replication requires a dedicated IR packet format that uniquely identifies the IR-CR packet for the ROHC-TCP profile. This section defines the profile-specific part of the IR-CR packet [RFC4164].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキストレプリケーションには、ROHC-TCPプロファイルのIR-CRパケットを一意に識別する専用のIRパケット形式が必要です。このセクションでは、IR-CRパケットのプロファイル固有の部分を定義します[RFC4164]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet type: IR-CR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットタイプ：IR-CR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This packet type communicates a reference to a base context along with the static and dynamic parts of the replicated context that differs from the base context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このパケットタイプは、ベースコンテキストとは異なる、複製されたコンテキストの静的および動的な部分とともに、ベースコンテキストへの参照を伝達します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ROHC-TCP IR-CR packet follows the general format of the ROHC IR-CR packet, as defined in [RFC4164], Section 3.5.2. With consideration to the extensibility of the IR packet type defined in [RFC5795], the ROHC-TCP profile supports context replication through the profile-specific part of the IR packet. This is achieved using the bit (x) left in the IR header for &#34;Profile specific information&#34;. For ROHC-TCP, this bit is defined as a flag indicating whether this packet is an IR packet or an IR-CR packet. For the ROHC-TCP IR-CR packet, the value of the x bit MUST be set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP IR-CRパケットは、[RFC4164]のセクション3.5.2で定義されているROHC IR-CRパケットの一般的な形式に従います。 [RFC5795]で定義されているIRパケットタイプの拡張性を考慮して、ROHC-TCPプロファイルは、IRパケットのプロファイル固有の部分によるコンテキストレプリケーションをサポートしています。これは、「プロファイル固有情報」のIRヘッダーに残っているビット（x）を使用して実現されます。 ROHC-TCPの場合、このビットは、このパケットがIRパケットであるかIR-CRパケットであるかを示すフラグとして定義されます。 ROHC-TCP IR-CRパケットの場合、xビットの値をゼロに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ROHC-TCP IR-CR has the following format, which corresponds to the &#34;Header&#34; and &#34;Payload&#34; fields described in Section 5.2.1 of [RFC5795]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP IR-CRの形式は次のとおりです。これは、[RFC5795]のセクション5.2.1で説明されている「ヘッダー」および「ペイロード」フィールドに対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0   1   2   3   4   5   6   7
       --- --- --- --- --- --- --- ---
      :         Add-CID octet         : if for small CIDs and (CID != 0)
      +---+---+---+---+---+---+---+---+
      | 1   1   1   1   1   1   0   0 | IR-CR type octet
      +---+---+---+---+---+---+---+---+
      :                               :
      /       0-2 octets of CID       / 1-2 octets if for large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      |         Profile = 0x06        | 1 octet
      +---+---+---+---+---+---+---+---+
      |              CRC              | 1 octet
      +---+---+---+---+---+---+---+---+
      | B |             CRC7          | 1 octet
      +---+---+---+---+---+---+---+---+
      :   Reserved    |   Base CID    : 1 octet, for small CID, if B=1
      +---+---+---+---+---+---+---+---+
      :                               :
      /           Base CID            / 1-2 octets, for large CIDs,
      :                               : if B=1
      +---+---+---+---+---+---+---+---+
      |                               |
      /        Replicate chain        / variable length
      |                               |
       - - - - - - - - - - - - - - - -
      |                               |
      /            Payload            / variable length
      |                               |
       - - - - - - - - - - - - - - - -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
B: B = 1 indicates that the Base CID field is present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
B：B = 1は、Base CIDフィールドが存在することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC: This CRC covers the entire IR-CR header, thus excluding payload, padding, and feedback, if any. This 8-bit CRC is calculated according to Section 5.3.1.1 of [RFC5795].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC：このCRCはIR-CRヘッダー全体をカバーするため、ペイロード、パディング、およびフィードバックがあればそれを除外します。この8ビットCRCは、[RFC5795]のセクション5.3.1.1に従って計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC7: The CRC over the original, uncompressed, header. Calculated according to Section 3.5.1.1 of [RFC4164].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC7：元の非圧縮ヘッダーのCRC。 [RFC4164]のセクション3.5.1.1に従って計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Reserved: MUST be set to zero; otherwise, the decompressor MUST discard the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
予約済み：ゼロに設定する必要があります。それ以外の場合、圧縮解除プログラムはパケットを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Base CID: CID of base context. Encoded according to [RFC4164], Section 3.5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ベースCID：ベースコンテキストのCID。 [RFC4164]のセクション3.5.3に従ってエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Replicate chain: See Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
複製チェーン：セクション6.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Payload: The payload of the corresponding original packet, if any. The presence of a payload is inferred from the packet length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ペイロード：対応する元のパケットのペイロード（ある場合）。ペイロードの存在は、パケット長から推測されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Compressed (CO) Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 圧縮（CO）パケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ROHC-TCP CO packets communicate irregularities in the packet header. All CO packets carry a CRC and can update the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCP COパケットは、パケットヘッダーの不規則性を伝達します。すべてのCOパケットはCRCを伝送し、コンテキストを更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general format for a compressed TCP header is as follows, which corresponds to the &#34;Header&#34; and &#34;Payload&#34; fields described in Section 5.2.1 of [RFC5795]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮されたTCPヘッダーの一般的な形式は次のとおりです。これは、[RFC5795]のセクション5.2.1で説明されている「Header」および「Payload」フィールドに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         0   1   2   3   4   5   6   7
        --- --- --- --- --- --- --- ---
       :         Add-CID octet         :  if for small CIDs and CID 1-15
       +---+---+---+---+---+---+---+---+
       |   First octet of base header  |  (with type indication)
       +---+---+---+---+---+---+---+---+
       :                               :
       /   0, 1, or 2 octets of CID    /  1-2 octets if large CIDs
       :                               :
       +---+---+---+---+---+---+---+---+
       /   Remainder of base header    /  variable number of octets
       +---+---+---+---+---+---+---+---+
       :        Irregular chain        :
       /   (including irregular chain  /  variable
       :    items for TCP options)     :
        --- --- --- --- --- --- --- ---
       |                               |
       /            Payload            / variable length
       |                               |
        - - - - - - - - - - - - - - - -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Base header: The complete set of base headers is defined in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
基本ヘッダー：基本ヘッダーの完全なセットは、セクション8で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Irregular chain: See Sections 6.2 and 6.3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
不規則なチェーン：セクション6.2および6.3.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Payload: The payload of the corresponding original packet, if any. The presence of a payload is inferred from the packet length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ペイロード：対応する元のパケットのペイロード（ある場合）。ペイロードの存在は、パケット長から推測されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Header Formats (Normative)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. ヘッダー形式（規定）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the set of compressed TCP/IP packet formats. The normative description of the packet formats is given using the formal notation for ROHC profiles defined in [RFC4997]. The formal description of the packet formats specifies all of the information needed to compress and decompress a header relative to the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、圧縮されたTCP / IPパケット形式のセットについて説明します。パケット形式の規範的な説明は、[RFC4997]で定義されているROHCプロファイルの正式な表記法を使用して与えられます。パケット形式の正式な説明は、コンテキストに関連するヘッダーの圧縮と解凍に必要なすべての情報を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, the notation provides a list of all the fields present in the uncompressed and compressed TCP/IP headers, and defines how to map from each uncompressed packet to its compressed equivalent and vice versa.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、この表記は、非圧縮および圧縮TCP / IPヘッダーに存在するすべてのフィールドのリストを提供し、各非圧縮パケットから圧縮された同等のパケットへ、およびその逆にマッピングする方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Design Rationale for Compressed Base Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 圧縮ベースヘッダーの設計根拠
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressed header formats are defined as two separate sets: one set for the packets where the innermost IP header contains a sequential IP-ID (either network byte order or byte swapped), and one set for the packets without sequential IP-ID (either random, zero, or no IP-ID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮ヘッダー形式は2つの別個のセットとして定義されます。1つは、最も内側のIPヘッダーに順次IP-ID（ネットワークバイトオーダーまたはバイトスワップ）が含まれるパケット用のセットと、順次IP-IDがないパケット用（いずれか）です。ランダム、ゼロ、またはIP-IDなし）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These two sets of header formats are referred to as the &#34;sequential&#34; and the &#34;random&#34; set of header formats, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これら2つのヘッダー形式のセットは、それぞれ「シーケンシャル」および「ランダム」ヘッダー形式のセットと呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there is one compressed format that is common to both sets of header formats and that can thus be used regardless of the type of IP-ID behavior. This format can transmit rarely changing fields and also send the frequently changing fields coded in variable lengths. It can also change the value of control fields such as IP-ID behavior and ECN behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、ヘッダー形式の両方のセットに共通で、IP-ID動作のタイプに関係なく使用できる1つの圧縮形式があります。このフォーマットは、めったに変化しないフィールドを送信し、可変長でコード化された頻繁に変化するフィールドを送信することもできます。また、IP-IDの動作やECNの動作などの制御フィールドの値を変更することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All compressed base headers contain a 3-bit CRC, unless they update control fields such as &#34;ip_id_behavior&#34; or &#34;ecn_used&#34; that affect the interpretation of subsequent headers. Headers that can modify these control fields carry a 7-bit CRC instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後続のヘッダーの解釈に影響する「ip_id_behavior」や「ecn_used」などの制御フィールドを更新しない限り、すべての圧縮ベースヘッダーには3ビットCRCが含まれます。これらの制御フィールドを変更できるヘッダーは、代わりに7ビットCRCを伝送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When discussing LSB-encoded fields below, &#34;p&#34; equals the &#34;offset_param&#34; and &#34;k&#34; equals the &#34;num_lsbs_param&#34; in [RFC4997].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のLSBエンコードフィールドについて説明する場合、[RFC4997]の「p」は「offset_param」に等しく、「k」は「num_lsbs_param」に等しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encoding methods used in the compressed base headers are based on the following design criteria:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮された基本ヘッダーで使用されるエンコード方式は、次の設計基準に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MSN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MSN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Since the MSN is a number generated by the compressor, it only needs to be large enough to ensure robust operation and to accommodate a small amount of reordering [RFC4163]. Therefore, each compressed base header has an MSN field that is LSB-encoded with k=4 and p=4 to handle a reordering depth of up to 4 packets. Additional guidance to improve robustness when reordering is possible can be found in [RFC4224].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
MSNはコンプレッサーによって生成される数値であるため、堅牢な動作を保証し、少量の並べ替えに対応するのに十分な大きさである必要があります[RFC4163]。したがって、各圧縮ベースヘッダーには、最大4パケットの並べ替えの深さを処理するためにk = 4およびp = 4でLSBエンコードされたMSNフィールドがあります。並べ替えが可能な場合の堅牢性を向上させるための追加のガイダンスは、[RFC4224]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP Sequence Number
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCPシーケンス番号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 ROHC-TCP has the capability to handle bulk data transfers efficiently, for which the sequence number is expected to increase by about 1460 octets (which can be represented by 11 bits). For the compressed base headers to handle retransmissions (i.e., negative delta to the sequence number), the LSB interpretation interval has to handle negative offsets about as large as positive offsets, which means that one more bit is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ROHC-TCPには、大量のデータ転送を効率的に処理する機能があり、シーケンス番号は約1460オクテット（11ビットで表すことができる）増加すると予想されます。圧縮されたベースヘッダーが再送信（つまり、シーケンス番号への負のデルタ）を処理するためには、LSB解釈間隔は、正のオフセットと同じくらい大きい負のオフセットを処理する必要があります。つまり、もう1ビットが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Also, for ROHC-TCP to be robust to losses, two additional bits are added to the LSB encoding of the sequence number. This means that the base headers should contain at least 14 bits of LSB-encoded sequence number when present. According to the logic above, the LSB offset value is set to be as large as the positive offset, i.e., p = 2^(k-1)-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
また、ROHC-TCPが損失に強いために、シーケンス番号のLSBエンコーディングに2つのビットが追加されます。つまり、ベースヘッダーには、少なくとも14ビットのLSBエンコードされたシーケンス番号が含まれている必要があります。上記のロジックに従って、LSBオフセット値は正のオフセットと同じ大きさに設定されます。つまり、p = 2 ^（k-1）-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP Acknowledgment Number
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP確認番号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The design criterion for the acknowledgment number is similar to that of the TCP Sequence Number. However, often only every other data packet is acknowledged, which means that the expected delta value is twice as large as for sequence numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認応答番号の設計基準は、TCPシーケンス番号の設計基準と同様です。ただし、確認されるデータパケットは他のすべてのデータパケットのみであることがよくあります。これは、予想されるデルタ値がシーケンス番号の2倍であることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Therefore, at least 15 bits of acknowledgment number should be used in compressed base headers. Since the acknowledgment number is expected to constantly increase, and the only exception to this is packet reordering (either on the ROHC channel [RFC3759] or prior to the compression point), the negative offset for LSB encoding is set to be 1/4 of the total interval, i.e., p = 2^(k-2)-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
したがって、圧縮された基本ヘッダーでは、少なくとも15ビットの確認応答番号を使用する必要があります。確認応答番号は常に増加することが予想され、これに対する唯一の例外はパケットの並べ替え（ROHCチャネル[RFC3759]または圧縮ポイントの前）であるため、LSBエンコーディングの負のオフセットは1/4に設定されます。合計間隔、つまりp = 2 ^（k-2）-1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP Window
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCPウィンドウ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The TCP Window field is expected to increase in increments of similar size as the TCP Sequence Number; therefore, the design criterion for the TCP window is to send at least 14 bits when used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
TCPウィンドウフィールドは、TCPシーケンス番号と同様のサイズの増分で増加すると予想されます。したがって、TCPウィンドウの設計基準は、使用時に少なくとも14ビットを送信することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IP-ID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IP-ID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
For the &#34;sequential&#34; set of packet formats, all the compressed base headers contain LSB-encoded IP-ID offset bits, where the offset is the difference between the value of the MSN field and the value of the IP-ID field. The requirement is that at least 3 bits of IP-ID should always be present, but it is preferable to use 4 to 7 bits. When k=3 then p=1, and if k&gt;3 then p=3 since the offset is expected to increase most of the time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
パケット形式の「順次」セットの場合、すべての圧縮ベースヘッダーには、LSBエンコードされたIP-IDオフセットビットが含まれます。オフセットは、MSNフィールドの値とIP-IDフィールドの値の差です。少なくとも3ビットのIP-IDが常に存在している必要がありますが、4〜7ビットを使用することをお勧めします。 k = 3の場合はp = 1、k&gt; 3の場合はp = 3です。これは、オフセットがほとんどの時間で増加すると予想されるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each set of header formats contains eight different compressed base headers. The reason for having this large number of header formats is that the TCP Sequence Number, TCP Acknowledgment Number, and TCP Window are frequently changing in a non-linear pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダー形式の各セットには、8つの異なる圧縮基本ヘッダーが含まれています。このように多数のヘッダー形式がある理由は、TCPシーケンス番号、TCP確認応答番号、およびTCPウィンドウが非線形パターンで頻繁に変化するためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The design of the header formats is derived from the field behavior analysis found in [RFC4413].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダー形式の設計は、[RFC4413]にあるフィールド動作分析から派生しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the compressed base headers transmit LSB-encoded MSN bits, the TCP Push flag, and a CRC, and in addition to this, all the base headers in the sequential packet format set contain LSB-encoded IP-ID bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての圧縮ベースヘッダーは、LSBエンコードされたMSNビット、TCPプッシュフラグ、およびCRCを送信します。さらに、順次パケットフォーマットセットのすべてのベースヘッダーには、LSBエンコードされたIP-IDビットが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following header formats exist in both the sequential and random packet format sets:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のヘッダー形式は、シーケンシャルとランダムの両方のパケット形式セットに存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Format 1: This header format carries changes to the TCP Sequence Number and is expected to be used on the downstream of a data transfer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形式1：このヘッダー形式は、TCPシーケンス番号の変更を伝達し、データ転送のダウンストリームで使用されることが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Format 2: This header format carries the TCP Sequence Number in scaled form and is expected to be useful for the downstream of a data transfer where the payload size is constant for multiple packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形式2：このヘッダー形式は、スケーリングされた形式でTCPシーケンス番号を伝達し、ペイロードサイズが複数のパケットに対して一定であるデータ転送のダウンストリームに役立つと予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Format 3: This header format carries changes in the TCP Acknowledgment Number and is expected to be useful for the acknowledgment direction of a data transfer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形式3：このヘッダー形式は、TCP確認応答番号の変更を伝達し、データ転送の確認応答方向に役立つことが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Format 4: This header format is similar to format 3, but carries a scaled TCP Acknowledgment Number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形式4：このヘッダー形式は形式3と似ていますが、スケーリングされたTCP確認応答番号が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Format 5: This header format carries both the TCP Sequence Number and the TCP Acknowledgment Number and is expected to be useful for flows that send data in both directions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形式5：このヘッダー形式は、TCPシーケンス番号とTCP確認応答番号の両方を伝送し、双方向でデータを送信するフローに役立つことが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Format 6: This header format is similar to format 5, but carries the TCP Sequence Number in scaled form, when the payload size is static for certain intervals in a data flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形式6：このヘッダー形式は形式5に似ていますが、ペイロードサイズがデータフローの特定の間隔で静的である場合、TCPシーケンス番号をスケーリングされた形式で伝送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Format 7: This header format carries changes to both the TCP Acknowledgment Number and the TCP Window and is expected to be useful for the acknowledgment flows of data connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形式7：このヘッダー形式は、TCP確認応答番号とTCPウィンドウの両方に変更を加え、データ接続の確認応答フローに役立つことが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Format 8: This header format is used to convey changes to some of the more seldom changing fields in the TCP flow, such as ECN behavior, RST/SYN/FIN flags, the TTL/Hop Limit, and the TCP options list. This format carries a 7-bit CRC, since it can change the structure of the contents of the irregular chain for subsequent packets. Note that this can be seen as a reduced form of the common packet format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形式8：このヘッダー形式は、ECN動作、RST / SYN / FINフラグ、TTL /ホップ制限、TCPオプションリストなど、TCPフローであまり変更されないいくつかのフィールドに変更を伝えるために使用されます。このフォーマットは、後続のパケットの不規則なチェーンの内容の構造を変更できるため、7ビットのCRCを伝送します。これは、一般的なパケット形式の縮小形式と見なすことができることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Common header format: The common header format can be used for all kinds of IP-ID behavior and should be useful when some of the more rarely changing fields in the IP or TCP header change. Since this header format can update control fields that decide how the decompressor interprets packets, it carries a 7-bit CRC to reduce the probability of context corruption. This header can basically convey changes to any of the dynamic fields in the IP and TCP headers, and it uses a large set of flags to provide information about which fields are present in the header format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 共通ヘッダー形式：共通ヘッダー形式は、あらゆる種類のIP-ID動作に使用でき、IPまたはTCPヘッダーのほとんど変更されないフィールドの一部が変更される場合に役立ちます。このヘッダー形式は、圧縮解除プログラムがパケットをどのように解釈するかを決定する制御フィールドを更新できるため、7ビットCRCを伝送して、コンテキストが破損する可能性を減らします。このヘッダーは基本的に、IPヘッダーとTCPヘッダーの動的フィールドのいずれかに変更を伝えることができ、大量のフラグを使用して、ヘッダーフィールドに存在するフィールドに関する情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Formal Definition of Header Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. ヘッダー形式の正式な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// NOTE: The irregular, static, and dynamic chains (see Section 6.2)
// are defined across multiple encoding methods and are embodied
// in the correspondingly named formats within those encoding
// methods.  In particular, note that the static and dynamic
// chains ordinarily go together.  The uncompressed fields are
// defined across these two formats combined, rather than in one
// or the other of them.  The irregular chain items are likewise
// combined with a baseheader format.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
////////////////////////////////////////////
// Constants
////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
IP_ID_BEHAVIOR_SEQUENTIAL = 0;
IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED = 1;
IP_ID_BEHAVIOR_RANDOM = 2;
IP_ID_BEHAVIOR_ZERO = 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
////////////////////////////////////////////
// Global control fields
////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
CONTROL {
  ecn_used            [ 1 ];
  msn                 [ 16 ];
  // ip_id fields are for innermost IP header only
  ip_id_offset                               [ 16 ];
  ip_id_behavior_innermost                   [  2 ];
  // ACK-related
  ack_stride                                 [ 32 ];
  ack_number_scaled                          [ 32 ];
  ack_number_residue                         [ 32 ];
  seq_number_scaled                          [ 32 ];
  seq_number_residue                         [ 32 ];
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
///////////////////////////////////////////////
// Encoding methods not specified in FN syntax
///////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
list_tcp_options               &#34;defined in Section 6.3.3&#34;;
inferred_ip_v4_header_checksum &#34;defined in Section 6.4.1&#34;;
inferred_mine_header_checksum  &#34;defined in Section 6.4.2&#34;;
inferred_ip_v4_length          &#34;defined in Section 6.4.3&#34;;
inferred_ip_v6_length          &#34;defined in Section 6.4.4&#34;;
inferred_offset                &#34;defined in Section 6.4.5&#34;;
baseheader_extension_headers   &#34;defined in Section 6.4.6&#34;;
baseheader_outer_headers       &#34;defined in Section 6.4.7&#34;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
////////////////////////////////////////////
// General encoding methods
////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static_or_irreg(flag, width)
{
  UNCOMPRESSED {
    field [ width ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED irreg_enc {
    field =:= irregular(width) [ width ];
    ENFORCE(flag == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED static_enc {
    field =:= static [ 0 ];
    ENFORCE(flag == 0);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
zero_or_irreg(flag, width)
{
  UNCOMPRESSED {
    field [ width ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED non_zero {
    field =:= irregular(width) [ width ];
    ENFORCE(flag == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED zero {
    field =:= uncompressed_value(width, 0) [ 0 ];
    ENFORCE(flag == 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
variable_length_32_enc(flag)
{
  UNCOMPRESSED {
    field [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED not_present {
    field =:= static [ 0 ];
    ENFORCE(flag == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED lsb_8_bit {
    field =:= lsb(8, 63) [ 8 ];
    ENFORCE(flag == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED lsb_16_bit {
    field =:= lsb(16, 16383) [ 16 ];
    ENFORCE(flag == 2);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED irreg_32_bit {
    field =:= irregular(32) [ 32 ];
    ENFORCE(flag == 3);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
optional32(flag)
{
  UNCOMPRESSED {
    item [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED present {
    item =:= irregular(32) [ 32 ];
    ENFORCE(flag == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED not_present {
    item =:= compressed_value(0, 0) [ 0 ];
    ENFORCE(flag == 0);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
lsb_7_or_31
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
lsb_7_or_31
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
{
  UNCOMPRESSED {
    item [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED lsb_7 {
    discriminator =:= &#39;0&#39;       [ 1 ];
    item          =:= lsb(7, 8) [ 7 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED lsb_31 {
    discriminator =:= &#39;1&#39;          [ 1 ];
    item          =:= lsb(31, 256) [ 31 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
opt_lsb_7_or_31(flag)
{
  UNCOMPRESSED {
    item [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED present {
    item =:= lsb_7_or_31 [ 8, 32 ];
    ENFORCE(flag == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED not_present {
    item =:= compressed_value(0, 0) [ 0 ];
    ENFORCE(flag == 0);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
crc3(data_value, data_length)
{
  UNCOMPRESSED {
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED {
    crc_value =:=
      crc(3, 0x06, 0x07, data_value, data_length) [ 3 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
crc7(data_value, data_length)
{
  UNCOMPRESSED {
  }
  COMPRESSED {
    crc_value =:=
      crc(7, 0x79, 0x7f, data_value, data_length) [ 7 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
one_bit_choice
{
  UNCOMPRESSED {
    field [ 1 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED zero {
    field [ 1 ];
    ENFORCE(field.UVALUE == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED nonzero {
    field [ 1 ];
    ENFORCE(field.UVALUE == 1);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// Encoding method for updating a scaled field and its associated
// control fields.  Should be used both when the value is scaled
// or unscaled in a compressed format.
// Does not have an uncompressed side.
field_scaling(stride_value, scaled_value, unscaled_value, residue_value)
{
  UNCOMPRESSED {
    // Nothing
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED no_scaling {
    ENFORCE(stride_value == 0);
    ENFORCE(residue_value == unscaled_value);
    ENFORCE(scaled_value == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED scaling_used {
    ENFORCE(stride_value != 0);
    ENFORCE(residue_value == (unscaled_value % stride_value));
    ENFORCE(unscaled_value ==
            scaled_value * stride_value + residue_value);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
////////////////////////////////////////////
// IPv6 Destination options header
////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
ip_dest_opt
{
  UNCOMPRESSED {
    next_header [ 8 ];
    length      [ 8 ];
    value       [ length.UVALUE * 64 + 48 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    length      =:= static;
    next_header =:= static;
    value       =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED dest_opt_static {
    next_header =:= irregular(8) [ 8 ];
    length      =:= irregular(8) [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED dest_opt_dynamic {
    value =:=
      irregular(length.UVALUE * 64 + 48) [ length.UVALUE * 64 + 48 ];
  }
  COMPRESSED dest_opt_0_replicate {
    discriminator =:= &#39;00000000&#39; [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED dest_opt_1_replicate {
    discriminator =:= &#39;10000000&#39;                     [ 8 ];
    length        =:= irregular(8)                   [ 8 ];
    value         =:=
      irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED dest_opt_irregular {
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
////////////////////////////////////////////
// IPv6 Hop-by-Hop options header
////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ip_hop_opt {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ip_hop_opt {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  UNCOMPRESSED {
    next_header [ 8 ];
    length      [ 8 ];
    value       [ length.UVALUE * 64 + 48 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    length      =:= static;
    next_header =:= static;
    value       =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED hop_opt_static {
    next_header =:= irregular(8) [ 8 ];
    length      =:= irregular(8) [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED hop_opt_dynamic {
    value =:=
      irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED hop_opt_0_replicate {
    discriminator =:= &#39;00000000&#39; [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED hop_opt_1_replicate {
    discriminator =:= &#39;10000000&#39;                     [ 8 ];
    length        =:= irregular(8)                   [ 8 ];
    value         =:=
      irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED hop_opt_irregular {
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
////////////////////////////////////////////
// IPv6 Routing header
////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
ip_rout_opt
{
  UNCOMPRESSED {
    next_header [ 8 ];
    length      [ 8 ];
    value       [ length.UVALUE * 64 + 48 ];
  }
  DEFAULT {
    length      =:= static;
    next_header =:= static;
    value       =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED rout_opt_static {
    next_header =:= irregular(8)                   [ 8 ];
    length      =:= irregular(8)                   [ 8 ];
    value       =:=
      irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED rout_opt_dynamic {
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED rout_opt_0_replicate {
    discriminator =:= &#39;00000000&#39; [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED rout_opt_0_replicate {
    discriminator =:= &#39;10000000&#39;                     [ 8 ];
    length        =:= irregular(8)                   [ 8 ];
    value         =:=
      irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];
  }
  COMPRESSED rout_opt_irregular {
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
////////////////////////////////////////////
// GRE Header
////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
optional_checksum(flag_value)
{
  UNCOMPRESSED {
    value     [ 0, 16 ];
    reserved1 [ 0, 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED cs_present {
    value     =:= irregular(16)             [ 16 ];
    reserved1 =:= uncompressed_value(16, 0) [ 0 ];
    ENFORCE(flag_value == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
COMPRESSED not_present {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
COMPRESSED not_present {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    value     =:= compressed_value(0, 0) [ 0 ];
    reserved1 =:= compressed_value(0, 0) [ 0 ];
    ENFORCE(flag_value == 0);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
gre_proto
{
  UNCOMPRESSED {
    protocol [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ether_v4 {
    discriminator =:= compressed_value(1, 0)         [ 1 ];
    protocol      =:= uncompressed_value(16, 0x0800) [ 0 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ether_v6 {
    discriminator =:= compressed_value(1, 1)         [ 1 ];
    protocol      =:= uncompressed_value(16, 0x86DD) [ 0 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
gre
{
  UNCOMPRESSED {
    c_flag                                 [ 1 ];
    r_flag    =:= uncompressed_value(1, 0) [ 1 ];
    k_flag                                 [ 1 ];
    s_flag                                 [ 1 ];
    reserved0 =:= uncompressed_value(9, 0) [ 9 ];
    version   =:= uncompressed_value(3, 0) [ 3 ];
    protocol                               [ 16 ];
    checksum_and_res                       [ 0, 32 ];
    key                                    [ 0, 32 ];
    sequence_number                        [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    c_flag           =:= static;
    k_flag           =:= static;
    s_flag           =:= static;
    protocol         =:= static;
    key              =:= static;
    sequence_number  =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
COMPRESSED gre_static {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
圧縮gre_static {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ENFORCE((c_flag.UVALUE == 1 &amp;&amp; checksum_and_res.ULENGTH == 32)
            || checksum_and_res.ULENGTH == 0);
    ENFORCE((s_flag.UVALUE == 1 &amp;&amp; sequence_number.ULENGTH == 32)
            || sequence_number.ULENGTH == 0);
    protocol =:= gre_proto                 [ 1 ];
    c_flag   =:= irregular(1)              [ 1 ];
    k_flag   =:= irregular(1)              [ 1 ];
    s_flag   =:= irregular(1)              [ 1 ];
    padding  =:= compressed_value(4, 0)    [ 4 ];
    key      =:= optional32(k_flag.UVALUE) [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED gre_dynamic {
    checksum_and_res =:=
      optional_checksum(c_flag.UVALUE)             [ 0, 16 ];
    sequence_number  =:= optional32(s_flag.UVALUE) [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED gre_0_replicate {
    discriminator    =:= &#39;00000000&#39;    [ 8 ];
    checksum_and_res =:=
      optional_checksum(c_flag.UVALUE) [ 0, 16 ];
    sequence_number  =:=
      optional32(s_flag.UVALUE)        [ 0, 8, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED gre_1_replicate {
    discriminator    =:= &#39;10000&#39;                   [ 5 ];
    c_flag           =:= irregular(1)              [ 1 ];
    k_flag           =:= irregular(1)              [ 1 ];
    s_flag           =:= irregular(1)              [ 1 ];
    checksum_and_res =:=
      optional_checksum(c_flag.UVALUE)             [ 0, 16 ];
    key              =:= optional32(k_flag.UVALUE) [ 0, 32 ];
    sequence_number  =:= optional32(s_flag.UVALUE) [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED gre_irregular {
    checksum_and_res =:=
      optional_checksum(c_flag.UVALUE) [ 0, 16 ];
    sequence_number  =:=
      opt_lsb_7_or_31(s_flag.UVALUE)   [ 0, 8, 32 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/////////////////////////////////////////////
// MINE header
/////////////////////////////////////////////
mine
{
  UNCOMPRESSED {
    next_header [ 8 ];
    s_bit       [ 1 ];
    res_bits    [ 7 ];
    checksum    [ 16 ];
    orig_dest   [ 32 ];
    orig_src    [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    next_header =:= static;
    s_bit       =:= static;
    res_bits    =:= static;
    checksum    =:= inferred_mine_header_checksum;
    orig_dest   =:= static;
    orig_src    =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED mine_static {
    next_header =:= irregular(8)             [ 8 ];
    s_bit       =:= irregular(1)             [ 1 ];
    // Reserved bits are included to achieve byte-alignment
    res_bits    =:= irregular(7)             [ 7 ];
    orig_dest   =:= irregular(32)            [ 32 ];
    orig_src    =:= optional32(s_bit.UVALUE) [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED mine_dynamic {
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED mine_0_replicate {
    discriminator =:= &#39;00000000&#39; [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED mine_1_replicate {
    discriminator =:= &#39;10000000&#39;               [ 8 ];
    s_bit         =:= irregular(1)             [ 1 ];
    res_bits      =:= irregular(7)             [ 7 ];
    orig_dest     =:= irregular(32)            [ 32 ];
    orig_src      =:= optional32(s_bit.UVALUE) [ 0, 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED mine_irregular {
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/////////////////////////////////////////////
// Authentication Header (AH)
/////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
ah
{
  UNCOMPRESSED {
    next_header     [ 8 ];
    length          [ 8 ];
    res_bits        [ 16 ];
    spi             [ 32 ];
    sequence_number [ 32 ];
    icv             [ length.UVALUE*32-32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    next_header     =:= static;
    length          =:= static;
    res_bits        =:= static;
    spi             =:= static;
    sequence_number =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ah_static {
    next_header =:= irregular(8)  [ 8 ];
    length      =:= irregular(8)  [ 8 ];
    spi         =:= irregular(32) [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ah_dynamic {
    res_bits        =:= irregular(16) [ 16 ];
    sequence_number =:= irregular(32) [ 32 ];
    icv       =:=
      irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ah_0_replicate {
    discriminator   =:= &#39;00000000&#39;    [ 8 ];
    sequence_number =:= irregular(32) [ 32 ];
    icv             =:=
      irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ah_1_replicate {
    discriminator   =:= &#39;10000000&#39;    [ 8 ];
    length          =:= irregular(8)  [ 8 ];
    res_bits        =:= irregular(16) [ 16 ];
    spi             =:= irregular(32) [ 32 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    sequence_number =:= irregular(32) [ 32 ];
    icv             =:=
      irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ah_irregular {
    sequence_number =:= lsb_7_or_31  [ 8, 32 ];
    icv       =:=
      irregular(length.UVALUE*32-32) [ length.UVALUE*32-32 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/////////////////////////////////////////////
// IPv6 Header
/////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
fl_enc
{
  UNCOMPRESSED {
    flow_label [ 20 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED fl_zero {
    discriminator =:= &#39;0&#39;                       [ 1 ];
    flow_label    =:= uncompressed_value(20, 0) [ 0 ];
    reserved      =:= &#39;0000&#39;                    [ 4 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED fl_non_zero {
    discriminator =:= &#39;1&#39;           [ 1 ];
    flow_label    =:= irregular(20) [ 20 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// The is_innermost flag is true if this is the innermost IP header
// If extracting the irregular chain for a compressed packet:
//   - ttl_irregular_chain_flag must have the same value as it had when
//     processing co_baseheader.
//   - ip_inner_ecn is bound in this encoding method and the value that
//     it gets bound to should be passed to the tcp encoding method
//   For other formats than the irregular chain, these two are ignored
ipv6(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn)
{
  UNCOMPRESSED {
    version         =:= uncompressed_value(4, 6) [ 4 ];
    dscp                                         [ 6 ];
    ip_ecn_flags                                 [ 2 ];
    flow_label                                   [ 20 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    payload_length                               [ 16 ];
    next_header                                  [ 8 ];
    ttl_hopl                                     [ 8 ];
    src_addr                                     [ 128 ];
    dst_addr                                     [ 128 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    dscp           =:= static;
    ip_ecn_flags   =:= static;
    flow_label     =:= static;
    payload_length =:= inferred_ip_v6_length;
    next_header    =:= static;
    ttl_hopl       =:= static;
    src_addr       =:= static;
    dst_addr       =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv6_static {
    version_flag =:= &#39;1&#39;            [ 1 ];
    reserved     =:= &#39;00&#39;           [ 2 ];
    flow_label   =:= fl_enc         [ 5, 21 ];
    next_header  =:= irregular(8)   [ 8 ];
    src_addr     =:= irregular(128) [ 128 ];
    dst_addr     =:= irregular(128) [ 128 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv6_dynamic {
    dscp         =:= irregular(6) [ 6 ];
    ip_ecn_flags =:= irregular(2) [ 2 ];
    ttl_hopl     =:= irregular(8) [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv6_replicate {
    dscp         =:= irregular(6) [ 6 ];
    ip_ecn_flags =:= irregular(2) [ 2 ];
    reserved     =:= &#39;000&#39;        [ 3 ];
    flow_label   =:= fl_enc       [ 5, 21 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv6_outer_without_ttl_irregular {
    dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];
    ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];
    ENFORCE(ttl_irregular_chain_flag == 0);
    ENFORCE(is_innermost == false);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
COMPRESSED ipv6_outer_with_ttl_irregular {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
圧縮されたipv6_outer_with_ttl_irregular {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];
    ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];
    ttl_hopl     =:= irregular(8)                        [ 8 ];
    ENFORCE(ttl_irregular_chain_flag == 1);
    ENFORCE(is_innermost == false);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv6_innermost_irregular {
    ENFORCE(ip_inner_ecn == ip_ecn_flags.UVALUE);
    ENFORCE(is_innermost == true);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/////////////////////////////////////////////
// IPv4 Header
/////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
ip_id_enc_dyn(behavior)
{
  UNCOMPRESSED {
    ip_id [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ip_id_seq {
    ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
    ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE - msn.UVALUE);
    ip_id =:= irregular(16) [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ip_id_random {
    ENFORCE(behavior == IP_ID_BEHAVIOR_RANDOM);
    ip_id =:= irregular(16) [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ip_id_zero {
    ENFORCE(behavior == IP_ID_BEHAVIOR_ZERO);
    ip_id =:= uncompressed_value(16, 0) [ 0 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
ip_id_enc_irreg(behavior)
{
  UNCOMPRESSED {
    ip_id [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
COMPRESSED ip_id_seq {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
圧縮されたip_id_seq {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ip_id_seq_swapped {
    ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ip_id_rand {
    ip_id =:= irregular(16) [ 16 ];
    ENFORCE(behavior == IP_ID_BEHAVIOR_RANDOM);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ip_id_zero {
    ip_id =:= uncompressed_value(16, 0) [ 0 ];
    ENFORCE(behavior == IP_ID_BEHAVIOR_ZERO);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// The is_innermost flag is true if this is the innermost IP header
// If extracting the irregular chain for a compressed packet:
//   - ttl_irregular_chain_flag must have the same value as it had when
//     processing co_baseheader.
//   - ip_inner_ecn is bound in this encoding method and the value that
//     it gets bound to should be passed to the tcp encoding method
//   For other formats than the irregular chain, these two are ignored
ipv4(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn,
     ip_id_behavior_value)
{
  UNCOMPRESSED {
    version        =:= uncompressed_value(4, 4)  [ 4 ];
    hdr_length     =:= uncompressed_value(4, 5)  [ 4 ];
    dscp                                         [ 6 ];
    ip_ecn_flags                                 [ 2 ];
    length         =:= inferred_ip_v4_length     [ 16 ];
    ip_id                                        [ 16 ];
    rf             =:= uncompressed_value(1, 0)  [ 1 ];
    df                                           [ 1 ];
    mf             =:= uncompressed_value(1, 0)  [ 1 ];
    frag_offset    =:= uncompressed_value(13, 0) [ 13 ];
    ttl_hopl                                     [ 8 ];
    protocol                                     [ 8 ];
    checksum    =:= inferred_ip_v4_header_checksum [ 16 ];
    src_addr                                     [ 32 ];
    dst_addr                                     [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  CONTROL {
    ENFORCE(reorder_ratio.UVALUE == reorder_ratio_value);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ENFORCE(innermost_ip.UVALUE == is_innermost);
    ip_id_behavior_outer [ 2 ];
    innermost_ip [ 1 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    dscp           =:= static;
    ip_ecn_flags   =:= static;
    df             =:= static;
    ttl_hopl       =:= static;
    protocol       =:= static;
    src_addr       =:= static;
    dst_addr       =:= static;
    ip_id_behavior_outer =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv4_static {
    version_flag =:= &#39;0&#39;           [ 1 ];
    reserved     =:= &#39;0000000&#39;     [ 7 ];
    protocol     =:= irregular(8)  [ 8 ];
    src_addr     =:= irregular(32) [ 32 ];
    dst_addr     =:= irregular(32) [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv4_innermost_dynamic {
    ENFORCE(is_innermost == 1);
    ENFORCE(ip_id_behavior_innermost.UVALUE == ip_id_behavior_value);
    reserved       =:= &#39;00000&#39;             [ 5 ];
    df             =:= irregular(1)        [ 1 ];
    ip_id_behavior_innermost =:= irregular(2) [ 2 ];
    dscp           =:= irregular(6)        [ 6 ];
    ip_ecn_flags   =:= irregular(2)        [ 2 ];
    ttl_hopl       =:= irregular(8)        [ 8 ];
    ip_id          =:=
      ip_id_enc_dyn(ip_id_behavior_innermost.UVALUE) [ 0, 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv4_outer_dynamic {
    ENFORCE(is_innermost == 0);
    ENFORCE(ip_id_behavior_outer.UVALUE == ip_id_behavior_value);
    reserved       =:= &#39;00000&#39;             [ 5 ];
    df             =:= irregular(1)        [ 1 ];
    ip_id_behavior_outer =:=     irregular(2)              [ 2 ];
    dscp           =:= irregular(6)        [ 6 ];
    ip_ecn_flags   =:= irregular(2)        [ 2 ];
    ttl_hopl       =:= irregular(8)        [ 8 ];
    ip_id          =:=
      ip_id_enc_dyn(ip_id_behavior_outer.UVALUE) [ 0, 16 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv4_innermost_replicate {
    ENFORCE(is_innermost == 1);
    ENFORCE(ip_id_behavior_innermost.UVALUE == ip_id_behavior_value);
    reserved       =:= &#39;0000&#39;              [ 4 ];
    ip_id_behavior_innermost =:= irregular(2) [ 2 ];
    ttl_flag       =:= irregular(1)        [ 1 ];
    df             =:= irregular(1)        [ 1 ];
    dscp           =:= irregular(6)        [ 6 ];
    ip_ecn_flags   =:= irregular(2)        [ 2 ];
    ip_id          =:=
      ip_id_enc_dyn(ip_id_behavior_innermost.UVALUE) [ 0, 16 ];
    ttl_hopl     =:=
        static_or_irreg(ttl_flag.UVALUE, 8) [ 0, 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv4_outer_replicate {
    ENFORCE(is_innermost == 0);
    ENFORCE(ip_id_behavior_outer.UVALUE == ip_id_behavior_value);
    reserved       =:= &#39;0000&#39;              [ 4 ];
    ip_id_behavior_outer =:= irregular(2)  [ 2 ]
    ttl_flag       =:= irregular(1)        [ 1 ];
    df             =:= irregular(1)        [ 1 ];
    dscp           =:= irregular(6)        [ 6 ];
    ip_ecn_flags   =:= irregular(2)        [ 2 ];
    ip_id          =:=
      ip_id_enc_dyn(ip_id_behavior_outer.UVALUE) [ 0, 16 ];
    ttl_hopl     =:=
        static_or_irreg(ttl_flag.UVALUE, 8) [ 0, 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv4_outer_without_ttl_irregular {
    ENFORCE(is_innermost == 0);
    ip_id        =:=
      ip_id_enc_irreg(ip_id_behavior_outer.UVALUE) [ 0, 16 ];
    dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];
    ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];
    ENFORCE(ttl_irregular_chain_flag == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv4_outer_with_ttl_irregular {
    ENFORCE(is_innermost == 0);
    ip_id        =:=
      ip_id_enc_irreg(ip_id_behavior_outer.UVALUE)       [ 0, 16 ];
    dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];
    ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];
    ttl_hopl     =:= irregular(8)                        [ 8 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ENFORCE(ttl_irregular_chain_flag == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ipv4_innermost_irregular {
    ENFORCE(is_innermost == 1);
    ip_id          =:=
      ip_id_enc_irreg(ip_id_behavior_innermost.UVALUE) [ 0, 16 ];
    ENFORCE(ip_inner_ecn == ip_ecn_flags.UVALUE);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/////////////////////////////////////////////
// TCP Options
/////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// nbits is bound to the remaining length (in bits) of TCP
// options, including the EOL type byte.
tcp_opt_eol(nbits)
{
  UNCOMPRESSED {
    type     =:= uncompressed_value(8, 0) [ 8 ];
    padding  =:=
      uncompressed_value(nbits-8, 0)      [ nbits-8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  CONTROL {
    pad_len [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED eol_list_item {
    pad_len =:= compressed_value(8, nbits-8) [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED eol_irregular {
    pad_len =:= static;
    ENFORCE(nbits-8 == pad_len.UVALUE);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
tcp_opt_nop
{
  UNCOMPRESSED {
    type =:= uncompressed_value(8, 1) [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED nop_list_item {
  }
  COMPRESSED nop_irregular {
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
tcp_opt_mss
{
  UNCOMPRESSED {
    type   =:= uncompressed_value(8, 2) [ 8 ];
    length =:= uncompressed_value(8, 4) [ 8 ];
    mss                                 [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED mss_list_item {
    mss =:= irregular(16) [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED mss_irregular {
    mss    =:= static;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
tcp_opt_wscale
{
  UNCOMPRESSED {
    type   =:= uncompressed_value(8, 3) [ 8 ];
    length =:= uncompressed_value(8, 3) [ 8 ];
    wscale                              [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED wscale_list_item {
    wscale =:= irregular(8) [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED wscale_irregular {
    wscale =:= static;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
ts_lsb
{
  UNCOMPRESSED {
    tsval [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED tsval_7 {
    discriminator =:= &#39;0&#39;        [ 1 ];
    tsval         =:= lsb(7, -1) [ 7 ];
  }
  COMPRESSED tsval_14 {
    discriminator =:= &#39;10&#39;        [ 2 ];
    tsval         =:= lsb(14, -1) [ 14 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED tsval_21 {
    discriminator =:= &#39;110&#39;               [ 3 ];
    tsval         =:= lsb(21, 0x00040000) [ 21 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED tsval_29 {
    discriminator =:= &#39;111&#39;               [ 3 ];
    tsval         =:= lsb(29, 0x04000000) [ 29 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
tcp_opt_ts
{
  UNCOMPRESSED {
    type   =:= uncompressed_value(8, 8)  [ 8 ];
    length =:= uncompressed_value(8, 10) [ 8 ];
    tsval                                [ 32 ];
    tsecho                               [ 32 ];
  }
  COMPRESSED tsopt_list_item {
    tsval  =:= irregular(32) [ 32 ];
    tsecho =:= irregular(32) [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED tsopt_irregular {
    tsval  =:= ts_lsb [ 8, 16, 24, 32 ];
    tsecho =:= ts_lsb [ 8, 16, 24, 32 ];
  }
}
sack_pure_lsb(base)
{
  UNCOMPRESSED {
    sack_field [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  CONTROL {
    ENFORCE(sack_field.CVALUE == (sack_field.UVALUE - base));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED lsb_15 {
    ENFORCE(sack_field.CVALUE == sack_field.CVALUE &lt;= 0x7fff);
    discriminator =:= &#39;0&#39;           [ 1 ];
    sack_field                      [ 15 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED lsb_22 {
    ENFORCE(sack_field.CVALUE == sack_field.CVALUE &lt;= 0x3fffff);
    discriminator =:= &#39;10&#39;          [ 2 ];
    sack_field                      [ 22 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED lsb_29 {
    ENFORCE(sack_field.CVALUE == sack_field.CVALUE &lt;= 0x1fffffff);
    discriminator =:= &#39;110&#39;         [ 3 ];
    sack_field                      [ 29 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED full_offset {
    discriminator =:= &#39;11111111&#39;    [ 8 ];
    sack_field                      [ 32 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
sack_block(reference)
{
  UNCOMPRESSED {
    block_start [ 32 ];
    block_end   [ 32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED {
    block_start =:=
      sack_pure_lsb(reference)          [ 16, 24, 32, 40 ];
    block_end   =:=
      sack_pure_lsb(block_start.UVALUE) [ 16, 24, 32, 40 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// The value of the parameter is set to the ack_number value
// of the TCP header
tcp_opt_sack(ack_value)
{
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  UNCOMPRESSED {
    type    =:= uncompressed_value(8, 5) [ 8 ];
    length                               [ 8 ];
    block_1                              [ 64 ];
    block_2                              [ 0, 64 ];
    block_3                              [ 0, 64 ];
    block_4                              [ 0, 64 ];
  }
  DEFAULT {
    length  =:= static;
    block_2 =:= uncompressed_value(0, 0);
    block_3 =:= uncompressed_value(0, 0);
    block_4 =:= uncompressed_value(0, 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED sack1_list_item {
    discriminator =:= &#39;00000001&#39;;
    block_1       =:= sack_block(ack_value);
    ENFORCE(length.UVALUE == 10);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED sack2_list_item {
    discriminator =:= &#39;00000010&#39;;
    block_1       =:= sack_block(ack_value);
    block_2       =:= sack_block(block_1.UVALUE &amp;&amp; 0xFFFFFFFF);
    ENFORCE(length.UVALUE == 18);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
COMPRESSED sack3_list_item {
   discriminator =:= &#39;00000011&#39;;
   block_1       =:= sack_block(ack_value);
   block_2       =:= sack_block(block_1.UVALUE &amp;&amp; 0xFFFFFFFF);
   block_3       =:= sack_block(block_2.UVALUE &amp;&amp; 0xFFFFFFFF);
   ENFORCE(length.UVALUE == 26);
 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 COMPRESSED sack4_list_item {
   discriminator =:= &#39;00000100&#39;;
   block_1       =:= sack_block(ack_value);
   block_2       =:= sack_block(block_1.UVALUE &amp;&amp; 0xFFFFFFFF);
   block_3       =:= sack_block(block_2.UVALUE &amp;&amp; 0xFFFFFFFF);
   block_4       =:= sack_block(block_3.UVALUE &amp;&amp; 0xFFFFFFFF);
   ENFORCE(length.UVALUE == 34);
 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED sack_unchanged_irregular {
    discriminator =:= &#39;00000000&#39;;
    block_1       =:= static;
    block_2       =:= static;
    block_3       =:= static;
    block_4       =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED sack1_irregular {
    discriminator =:= &#39;00000001&#39;;
    block_1       =:= sack_block(ack_value);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ENFORCE(length.UVALUE == 10);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 COMPRESSED sack2_irregular {
   discriminator =:= &#39;00000010&#39;;
   block_1       =:= sack_block(ack_value);
   block_2       =:= sack_block(block_1.UVALUE &amp;&amp; 0xFFFFFFFF);
   ENFORCE(length.UVALUE == 18);
 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 COMPRESSED sack3_irregular {
   discriminator =:= &#39;00000011&#39;;
   block_1       =:= sack_block(ack_value);
   block_2       =:= sack_block(block_1.UVALUE &amp;&amp; 0xFFFFFFFF);
   block_3       =:= sack_block(block_1.UVALUE &amp;&amp; 0xFFFFFFFF);
   ENFORCE(length.UVALUE == 26);
 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 COMPRESSED sack4_irregular {
   discriminator =:= &#39;00000100&#39;;
   block_1       =:= sack_block(ack_value);
   block_2       =:= sack_block(block_1.UVALUE &amp;&amp; 0xFFFFFFFF);
   block_3       =:= sack_block(block_2.UVALUE &amp;&amp; 0xFFFFFFFF);
   block_4       =:= sack_block(block_3.UVALUE &amp;&amp; 0xFFFFFFFF);
   ENFORCE(length.UVALUE == 34);
 }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
tcp_opt_sack_permitted
{
  UNCOMPRESSED {
    type   =:= uncompressed_value(8, 4) [ 8 ];
    length =:= uncompressed_value(8, 2) [ 8 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED sack_permitted_list_item {
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED sack_permitted_irregular {
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
tcp_opt_generic
{
  UNCOMPRESSED {
    type                                    [ 8 ];
    length_msb =:= uncompressed_value(1, 0) [ 1 ];
    length_lsb                              [ 7 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    contents                           [ length_lsb.UVALUE*8-16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  CONTROL {
    option_static [ 1 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    type       =:= static;
    length_lsb =:= static;
    contents   =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED generic_list_item {
    type          =:= irregular(8)      [ 8 ];
    option_static =:= one_bit_choice    [ 1 ];
    length_lsb    =:= irregular(7)      [ 7 ];
    contents      =:=
      irregular(length_lsb.UVALUE*8-16) [ length_lsb.UVALUE*8-16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Used when context of option has option_static set to one
  COMPRESSED generic_static_irregular {
    ENFORCE(option_static.UVALUE == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // An item that can change, but currently is unchanged
  COMPRESSED generic_stable_irregular {
    discriminator =:= &#39;11111111&#39; [ 8 ];
    ENFORCE(option_static.UVALUE == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // An item that is assumed to change constantly.
  // Length is not allowed to change here, since a length change is
  // most likely to cause new NOPs or an EOL length change.
  COMPRESSED generic_full_irregular {
    discriminator =:= &#39;00000000&#39;        [ 8 ];
    contents      =:=
      irregular(length_lsb.UVALUE*8-16) [ length_lsb.UVALUE*8-16 ];
    ENFORCE(option_static.UVALUE == 0);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
tcp_list_presence_enc(presence)
{
  UNCOMPRESSED {
    tcp_options;
  }
  COMPRESSED list_not_present {
    tcp_options =:= static [ 0 ];
    ENFORCE(presence == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED list_present {
    tcp_options =:= list_tcp_options [ VARIABLE ];
    ENFORCE(presence == 1);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/////////////////////////////////////////////
// TCP Header
/////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
port_replicate(flags)
{
  UNCOMPRESSED {
    port [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED port_static_enc {
    port =:= static [ 0 ];
    ENFORCE(flags == 0b00);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED port_lsb8 {
    port =:= lsb(8, 64) [ 8 ];
    ENFORCE(flags == 0b01);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED port_irr_enc {
    port =:= irregular(16) [ 16 ];
    ENFORCE(flags == 0b10);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
tcp_irreg_ip_ecn(ip_inner_ecn)
{
  UNCOMPRESSED {
    ip_ecn_flags [ 2 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ecn_present {
    // This field does not exist in the uncompressed header
    // and therefore cannot use uncompressed_value.
    ip_ecn_flags =:=
      compressed_value(2, ip_inner_ecn) [ 2 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ENFORCE(ecn_used.UVALUE == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED ecn_not_present {
    ip_ecn_flags =:= static [ 0 ];
    ENFORCE(ecn_used.UVALUE == 0);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
rsf_index_enc
{
  UNCOMPRESSED {
    rsf_flag [ 3 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED none {
    rsf_idx  =:= &#39;00&#39; [ 2 ];
    rsf_flag =:= uncompressed_value(3, 0x00);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED rst_only {
    rsf_idx  =:= &#39;01&#39; [ 2 ];
    rsf_flag =:= uncompressed_value(3, 0x04);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED syn_only {
    rsf_idx  =:= &#39;10&#39; [ 2 ];
    rsf_flag =:= uncompressed_value(3, 0x02);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED fin_only {
    rsf_idx  =:= &#39;11&#39; [ 2 ];
    rsf_flag =:= uncompressed_value(3, 0x01);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
optional_2bit_padding(used_flag)
{
  UNCOMPRESSED {
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED used {
    padding =:= compressed_value(2, 0x0) [ 2 ];
    ENFORCE(used_flag == 1);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED unused {
    padding =:= compressed_value(0, 0x0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ENFORCE(used_flag == 0);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// ack_stride_value is the user-selected stride for scaling the
// TCP ack_number
// ip_inner_ecn is the value bound when processing the innermost
// IP header (ipv4 or ipv6 encoding method)
tcp(payload_size, ack_stride_value, ip_inner_ecn)
{
  UNCOMPRESSED {
    src_port      [ 16 ];
    dst_port      [ 16 ];
    seq_number    [ 32 ];
    ack_number    [ 32 ];
    data_offset   [ 4 ];
    tcp_res_flags [ 4 ];
    tcp_ecn_flags [ 2 ];
    urg_flag      [ 1 ];
    ack_flag      [ 1 ];
    psh_flag      [ 1 ];
    rsf_flags     [ 3 ];
    window        [ 16 ];
    checksum      [ 16 ];
    urg_ptr       [ 16 ];
    options       [ (data_offset.UVALUE-5)*32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  CONTROL {
    dummy_field_s =:= field_scaling(payload_size,
      seq_number_scaled.UVALUE, seq_number.UVALUE,
      seq_number_residue.UVALUE) [ 0 ];
    dummy_field_a =:= field_scaling(ack_stride.UVALUE,
      ack_number_scaled.UVALUE, ack_number.UVALUE,
      ack_number_residue.UVALUE) [ 0 ];
    ENFORCE(ack_stride.UVALUE == ack_stride_value);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  INITIAL {
    ack_stride     =:= uncompressed_value(16, 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    src_port      =:= static;
    dst_port      =:= static;
    seq_number    =:= static;
    ack_number    =:= static;
    data_offset   =:= inferred_offset;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    tcp_res_flags =:= static;
    tcp_ecn_flags =:= static;
    urg_flag      =:= static;
    ack_flag      =:= uncompressed_value(1, 1);
    rsf_flags     =:= uncompressed_value(3, 0);
    window        =:= static;
    urg_ptr       =:= static;
    ack_stride    =:= static;
    ack_number_scaled =:= static;
    seq_number_scaled =:= static;
    ack_number_residue =:= static;
    seq_number_residue =:= static;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED tcp_static {
    src_port =:= irregular(16) [ 16 ];
    dst_port =:= irregular(16) [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED tcp_dynamic {
    ecn_used        =:= one_bit_choice          [ 1 ];
    ack_stride_flag =:= irregular(1)            [ 1 ];
    ack_zero        =:= irregular(1)            [ 1 ];
    urp_zero        =:= irregular(1)            [ 1 ];
    tcp_res_flags   =:= irregular(4)            [ 4 ];
    tcp_ecn_flags   =:= irregular(2)            [ 2 ];
    urg_flag        =:= irregular(1)            [ 1 ];
    ack_flag        =:= irregular(1)            [ 1 ];
    psh_flag        =:= irregular(1)            [ 1 ];
    rsf_flags       =:= irregular(3)            [ 3 ];
    msn             =:= irregular(16)           [ 16 ];
    seq_number      =:= irregular(32)           [ 32 ];
    ack_number      =:=
      zero_or_irreg(ack_zero.CVALUE, 32)        [ 0, 32 ];
    window          =:= irregular(16)           [ 16 ];
    checksum        =:= irregular(16)           [ 16 ];
    urg_ptr         =:=
      zero_or_irreg(urp_zero.CVALUE, 16)        [ 0, 16 ];
    ack_stride      =:=
      static_or_irreg(ack_stride_flag.CVALUE, 16) [ 0, 16 ];
    options         =:= list_tcp_options        [ VARIABLE ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED tcp_replicate {
    reserved          =:= &#39;0&#39;                      [ 1 ];
    window_presence   =:= irregular(1)             [ 1 ];
    list_present      =:= irregular(1)             [ 1 ];
    src_port_presence =:= irregular(2)             [ 2 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    dst_port_presence =:= irregular(2)             [ 2 ];
    ack_stride_flag   =:= irregular(1)             [ 1 ];
    ack_presence      =:= irregular(1)             [ 1 ];
    urp_presence      =:= irregular(1)             [ 1 ];
    urg_flag          =:= irregular(1)             [ 1 ];
    ack_flag          =:= irregular(1)             [ 1 ];
    psh_flag          =:= irregular(1)             [ 1 ];
    rsf_flags         =:= rsf_index_enc            [ 2 ];
    ecn_used          =:= one_bit_choice           [ 1 ];
    msn               =:= irregular(16)            [ 16 ];
    seq_number        =:= irregular(32)            [ 32 ];
    src_port          =:=
      port_replicate(src_port_presence)      [ 0, 8, 16 ];
    dst_port          =:=
      port_replicate(dst_port_presence)      [ 0, 8, 16 ];
    window            =:=
      static_or_irreg(window_presence, 16)   [ 0, 16 ];
    urg_point         =:=
      static_or_irreg(urp_presence, 16)    [ 0, 16 ];
    ack_number        =:=
      static_or_irreg(ack_presence, 32)    [ 0, 32 ];
    ecn_padding       =:=
      optional_2bit_padding(ecn_used.CVALUE)     [ 0, 2 ];
    tcp_res_flags =:=
      static_or_irreg(ecn_used.CVALUE, 4)        [ 0, 4 ];
    tcp_ecn_flags     =:=
      static_or_irreg(ecn_used.CVALUE, 2)        [ 0, 2 ];
    checksum          =:= irregular(16)            [ 16 ];
    ack_stride        =:=
      static_or_irreg(ack_stride_flag.CVALUE, 16)  [ 0, 16 ];
    options           =:=
      tcp_list_presence_enc(list_present.CVALUE) [ VARIABLE ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED tcp_irregular {
    ip_ecn_flags  =:= tcp_irreg_ip_ecn(ip_inner_ecn)  [ 0, 2 ];
    tcp_res_flags =:=
      static_or_irreg(ecn_used.CVALUE, 4)            [ 0, 4 ];
    tcp_ecn_flags =:=
      static_or_irreg(ecn_used.CVALUE, 2)             [ 0, 2 ];
    checksum      =:= irregular(16)                   [ 16 ];
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
///////////////////////////////////////////////////
// Encoding methods used in compressed base headers
///////////////////////////////////////////////////
dscp_enc(flag)
{
  UNCOMPRESSED {
    dscp [ 6 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED static_enc {
    dscp =:= static [ 0 ];
    ENFORCE(flag == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED irreg {
    dscp    =:= irregular(6)           [ 6 ];
    padding =:= compressed_value(2, 0) [ 2 ];
    ENFORCE(flag == 1);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
ip_id_lsb(behavior, k, p)
{
  UNCOMPRESSED {
    ip_id [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  CONTROL {
    ip_id_nbo    [ 16 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED nbo {
    ip_id_offset =:= lsb(k, p) [ k ];
    ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL);
    ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE - msn.UVALUE);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED non_nbo {
    ip_id_offset =:= lsb(k, p) [ k ];
    ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);
    ENFORCE(ip_id_nbo.UVALUE ==
            (ip_id.UVALUE / 256) + (ip_id.UVALUE % 256) * 256);
    ENFORCE(ip_id_nbo.ULENGTH == 16);
    ENFORCE(ip_id_offset.UVALUE == ip_id_nbo.UVALUE - msn.UVALUE);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
optional_ip_id_lsb(behavior, indicator)
{
  UNCOMPRESSED {
    ip_id [ 16 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED short {
    ip_id =:= ip_id_lsb(behavior, 8, 3) [ 8 ];
    ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
    ENFORCE(indicator == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED long {
    ip_id =:= irregular(16)  [ 16 ];
    ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
    ENFORCE(indicator == 1);
    ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE - msn.UVALUE);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED not_present {
    ENFORCE((behavior == IP_ID_BEHAVIOR_RANDOM) ||
            (behavior == IP_ID_BEHAVIOR_ZERO));
  }
}
dont_fragment(version)
{
  UNCOMPRESSED {
    df [ 1 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED v4 {
    df =:= irregular(1) [ 1 ];
    ENFORCE(version == 4);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED v6 {
    df =:= compressed_value(1, 0) [ 1 ];
    ENFORCE(version == 6);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
//////////////////////////////////
// Actual start of compressed packet formats
// Important note:
//   The base header is the compressed representation
//   of the innermost IP header AND the TCP header.
//////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// ttl_irregular_chain_flag is set by the user if the TTL/Hop Limit
// of an outer header has changed.  The same value must be passed as
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
// an argument to the ipv4/ipv6 encoding methods when extracting
// the irregular chain items.
co_baseheader(payload_size, ack_stride_value,
              ttl_irregular_chain_flag, ip_id_behavior_value)
{
  UNCOMPRESSED v4 {
    outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];
    version        =:= uncompressed_value(4, 4)        [ 4 ];
    header_length  =:= uncompressed_value(4, 5)        [ 4 ];
    dscp                                               [ 6 ];
    ip_ecn_flags                                       [ 2 ];
    length                                             [ 16 ];
    ip_id                                              [ 16 ];
    rf             =:= uncompressed_value(1, 0)        [ 1 ];
    df                                                 [ 1 ];
    mf             =:= uncompressed_value(1, 0)        [ 1 ];
    frag_offset    =:= uncompressed_value(13, 0)       [ 13 ];
    ttl_hopl                                           [ 8 ];
    next_header                                        [ 8 ];
    checksum                                           [ 16 ];
    src_addr                                           [ 32 ];
    dest_addr                                          [ 32 ];
    extension_headers =:= baseheader_extension_headers [ VARIABLE ];
    src_port                                           [ 16 ];
    dest_port                                          [ 16 ];
    seq_number                                         [ 32 ];
    ack_number                                         [ 32 ];
    data_offset                                        [ 4 ];
    tcp_res_flags                                      [ 4 ];
    tcp_ecn_flags                                      [ 2 ];
    urg_flag                                           [ 1 ];
    ack_flag                                           [ 1 ];
    psh_flag                                           [ 1 ];
    rsf_flags                                          [ 3 ];
    window                                             [ 16 ];
    tcp_checksum                                       [ 16 ];
    urg_ptr                                            [ 16 ];
    options                           [ (data_offset.UVALUE-5)*32 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  UNCOMPRESSED v6 {
    ENFORCE(ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_RANDOM);
    outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];
    version =:= uncompressed_value(4, 6)               [ 4 ];
    dscp                                               [ 6 ];
    ip_ecn_flags                                       [ 2 ];
    flow_label                                         [ 20 ];
    payload_length                                     [ 16 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    next_header                                        [ 8 ];
    ttl_hopl                                           [ 8 ];
    src_addr                                           [ 128 ];
    dest_addr                                          [ 128 ];
    extension_headers =:= baseheader_extension_headers [ VARIABLE ];
    src_port                                           [ 16 ];
    dest_port                                          [ 16 ];
    seq_number                                         [ 32 ];
    ack_number                                         [ 32 ];
    data_offset                                        [ 4 ];
    tcp_res_flags                                      [ 4 ];
    tcp_ecn_flags                                      [ 2 ];
    urg_flag                                           [ 1 ];
    ack_flag                                           [ 1 ];
    psh_flag                                           [ 1 ];
    rsf_flags                                          [ 3 ];
    window                                             [ 16 ];
    tcp_checksum                                       [ 16 ];
    urg_ptr                                            [ 16 ];
    options                           [ (data_offset.UVALUE-5)*32 ];
    df    =:= uncompressed_value(0,0)                  [   0 ];
    ip_id =:= uncompressed_value(0,0)                  [   0 ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  CONTROL {
    dummy_field_s =:= field_scaling(payload_size,
      seq_number_scaled.UVALUE, seq_number.UVALUE,
      seq_number_residue.UVALUE) [ 0 ];
    dummy_field_a =:= field_scaling(ack_stride.UVALUE,
      ack_number_scaled.UVALUE, ack_number.UVALUE,
      ack_number_residue.UVALUE) [ 0 ];
    ENFORCE(ack_stride.UVALUE == ack_stride_value);
    ENFORCE(ip_id_behavior_innermost.UVALUE == ip_id_behavior_value);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  INITIAL {
    ack_stride     =:= uncompressed_value(16, 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  DEFAULT {
    tcp_ecn_flags  =:= static;
    data_offset    =:= inferred_offset;
    tcp_res_flags  =:= static;
    rsf_flags      =:= uncompressed_value(3, 0);
    dest_port      =:= static;
    dscp           =:= static;
    src_port       =:= static;
    urg_flag       =:= uncompressed_value(1, 0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    window         =:= static;
    dest_addr      =:= static;
    version        =:= static;
    ttl_hopl       =:= static;
    src_addr       =:= static;
    df             =:= static;
    ack_number     =:= static;
    urg_ptr        =:= static;
    seq_number     =:= static;
    ack_flag       =:= uncompressed_value(1, 1);
    // The default for &#34;options&#34; is case 2) and 3) from
    // the list in Section 6.3.1 (i.e., nothing present in the
    // baseheader itself).
    payload_length =:= inferred_ip_v6_length;
    checksum       =:= inferred_ip_v4_header_checksum;
    length         =:= inferred_ip_v4_length;
    flow_label     =:= static;
    next_header    =:= static;
    ip_ecn_flags   =:= static;
    // The tcp_checksum has no default,
    // it is considered a part of tcp_irregular
    ip_id_behavior_innermost =:= static;
    ecn_used       =:= static;
    ack_stride    =:= static;
    ack_number_scaled =:= static;
    seq_number_scaled =:= static;
    ack_number_residue =:= static;
    seq_number_residue =:= static;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    // Default is to have no TTL in irregular chain
    // Can only be nonzero if co_common is used
    ENFORCE(ttl_irregular_chain_flag == 0);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  ////////////////////////////////////////////
  // Common compressed packet format
  ////////////////////////////////////////////
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  COMPRESSED co_common {
    discriminator        =:= &#39;1111101&#39;                [ 7 ];
    ttl_hopl_outer_flag  =:=
        compressed_value(1, ttl_irregular_chain_flag) [ 1 ];
    ack_flag             =:= irregular(1)             [ 1 ];
    psh_flag             =:= irregular(1)             [ 1 ];
    rsf_flags            =:= rsf_index_enc            [ 2 ];
    msn                  =:= lsb(4, 4)                [ 4 ];
    seq_indicator        =:= irregular(2)             [ 2 ];
    ack_indicator        =:= irregular(2)             [ 2 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ack_stride_indicator =:= irregular(1)             [ 1 ];
    window_indicator     =:= irregular(1)             [ 1 ];
    ip_id_indicator      =:= irregular(1)             [ 1 ];
    urg_ptr_present      =:= irregular(1)             [ 1 ];
    reserved             =:= compressed_value(1, 0)   [ 1 ];
    ecn_used             =:= one_bit_choice           [ 1 ];
    dscp_present         =:= irregular(1)             [ 1 ];
    ttl_hopl_present     =:= irregular(1)             [ 1 ];
    list_present         =:= irregular(1)             [ 1 ];
    ip_id_behavior_innermost       =:= irregular(2)             [ 2 ];
    urg_flag             =:= irregular(1)             [ 1 ];
    df                   =:= dont_fragment(version.UVALUE)   [ 1 ];
    header_crc           =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];
    seq_number           =:=
      variable_length_32_enc(seq_indicator.CVALUE) [ 0, 8, 16, 32 ];
    ack_number           =:=
      variable_length_32_enc(ack_indicator.CVALUE) [ 0, 8, 16, 32 ];
    ack_stride           =:=
      static_or_irreg(ack_stride_indicator.CVALUE, 16)  [ 0, 16 ];
    window               =:=
      static_or_irreg(window_indicator.CVALUE, 16)      [ 0, 16 ];
    ip_id                =:=
      optional_ip_id_lsb(ip_id_behavior_innermost.UVALUE,
                         ip_id_indicator.CVALUE)      [ 0, 8, 16 ];
    urg_ptr              =:=
      static_or_irreg(urg_ptr_present.CVALUE, 16)     [ 0, 16 ];
    dscp                 =:=
      dscp_enc(dscp_present.CVALUE)                   [ 0, 8 ];
    ttl_hopl             =:=
      static_or_irreg(ttl_hopl_present.CVALUE, 8)     [ 0, 8 ];
    options              =:=
      tcp_list_presence_enc(list_present.CVALUE)      [ VARIABLE ];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send LSBs of sequence number
  COMPRESSED rnd_1 {
    discriminator =:= &#39;101110&#39;                        [ 6 ];
    seq_number    =:= lsb(18, 65535)                  [ 18 ];
    msn           =:= lsb(4, 4)                       [ 4 ];
    psh_flag      =:= irregular(1)                    [ 1 ];
    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_RANDOM) ||
            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
// Send scaled sequence number LSBs COMPRESSED rnd_2 {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
//スケーリングされたシーケンス番号LSBを送信しますCOMPRESSED rnd_2 {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    discriminator      =:= &#39;1100&#39;                          [ 4 ];
    seq_number_scaled  =:= lsb(4, 7)                       [ 4 ];
    msn                =:= lsb(4, 4)                       [ 4 ];
    psh_flag           =:= irregular(1)                    [ 1 ];
    header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    ENFORCE(payload_size != 0);
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_RANDOM) ||
            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send acknowledgment number LSBs
  COMPRESSED rnd_3 {
    discriminator =:= &#39;0&#39;                             [ 1 ];
    ack_number    =:= lsb(15, 8191)                   [ 15 ];
    msn           =:= lsb(4, 4)                       [ 4 ];
    psh_flag      =:= irregular(1)                    [ 1 ];
    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_RANDOM) ||
            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send acknowledgment number scaled
  COMPRESSED rnd_4 {
    discriminator      =:= &#39;1101&#39;                          [ 4 ];
    ack_number_scaled  =:= lsb(4, 3)                       [ 4 ];
    msn                =:= lsb(4, 4)                       [ 4 ];
    psh_flag           =:= irregular(1)                    [ 1 ];
    header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    ENFORCE(ack_stride.UVALUE != 0);
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_RANDOM) ||
            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send ACK and sequence number
  COMPRESSED rnd_5 {
    discriminator =:= &#39;100&#39;                           [ 3 ];
    psh_flag      =:= irregular(1)                    [ 1 ];
    msn           =:= lsb(4, 4)                       [ 4 ];
    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    seq_number    =:= lsb(14, 8191)                   [ 14 ];
    ack_number    =:= lsb(15, 8191)                   [ 15 ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_RANDOM) ||
            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send both ACK and scaled sequence number LSBs
  COMPRESSED rnd_6 {
    discriminator      =:= &#39;1010&#39;                          [ 4 ];
    header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    psh_flag           =:= irregular(1)                    [ 1 ];
    ack_number         =:= lsb(16, 16383)                  [ 16 ];
    msn                =:= lsb(4, 4)                       [ 4 ];
    seq_number_scaled  =:= lsb(4, 7)                       [ 4 ];
    ENFORCE(payload_size != 0);
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_RANDOM) ||
            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send ACK and window
  COMPRESSED rnd_7 {
    discriminator =:= &#39;101111&#39;                        [ 6 ];
    ack_number    =:= lsb(18, 65535)                  [ 18 ];
    window        =:= irregular(16)                   [ 16 ];
    msn           =:= lsb(4, 4)                       [ 4 ];
    psh_flag      =:= irregular(1)                    [ 1 ];
    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_RANDOM) ||
            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // An extended packet type for seldom-changing fields
  // Can send LSBs of TTL, RSF flags, change ECN behavior, and
  // options list
  COMPRESSED rnd_8 {
    discriminator =:= &#39;10110&#39;                         [ 5 ];
    rsf_flags     =:= rsf_index_enc                   [ 2 ];
    list_present  =:= irregular(1)                    [ 1 ];
    header_crc    =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];
    msn           =:= lsb(4, 4)                       [ 4 ];
    psh_flag      =:= irregular(1)                    [ 1 ];
    ttl_hopl      =:= lsb(3, 3)                       [ 3 ];
    ecn_used      =:= one_bit_choice                  [ 1 ];
    seq_number    =:= lsb(16, 65535)                  [ 16 ];
    ack_number    =:= lsb(16, 16383)                  [ 16 ];
    options       =:=
      tcp_list_presence_enc(list_present.CVALUE)      [ VARIABLE ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_RANDOM) ||
            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send LSBs of sequence number
  COMPRESSED seq_1 {
    discriminator =:= &#39;1010&#39;                                 [ 4 ];
    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 4, 3) [ 4 ];
    seq_number    =:= lsb(16, 32767)                         [ 16 ];
    msn           =:= lsb(4, 4)                              [ 4 ];
    psh_flag      =:= irregular(1)                           [ 1 ];
    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send scaled sequence number LSBs
  COMPRESSED seq_2 {
    discriminator      =:= &#39;11010&#39;                         [ 5 ];
    ip_id              =:=
      ip_id_lsb(ip_id_behavior_innermost.UVALUE, 7, 3)     [ 7 ];
    seq_number_scaled  =:= lsb(4, 7)                       [ 4 ];
    msn                =:= lsb(4, 4)                       [ 4 ];
    psh_flag           =:= irregular(1)                    [ 1 ];
    header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    ENFORCE(payload_size != 0);
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send acknowledgment number LSBs
  COMPRESSED seq_3 {
    discriminator =:= &#39;1001&#39;                                 [ 4 ];
    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 4, 3) [ 4 ];
    ack_number    =:= lsb(16, 16383)                         [ 16 ];
    msn           =:= lsb(4, 4)                              [ 4 ];
    psh_flag      =:= irregular(1)                           [ 1 ];
    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send scaled acknowledgment number scaled
  COMPRESSED seq_4 {
    discriminator     =:= &#39;0&#39;                             [ 1 ];
    ack_number_scaled =:= lsb(4, 3)                       [ 4 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    // Due to having very few ip_id bits, no negative offset
    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 3, 1) [ 3 ];
    msn               =:= lsb(4, 4)                       [ 4 ];
    psh_flag          =:= irregular(1)                    [ 1 ];
    header_crc        =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];
    ENFORCE(ack_stride.UVALUE != 0);
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send ACK and sequence number
  COMPRESSED seq_5 {
    discriminator =:= &#39;1000&#39;                                 [ 4 ];
    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 4, 3) [ 4 ];
    ack_number    =:= lsb(16, 16383)                         [ 16 ];
    seq_number    =:= lsb(16, 32767)                         [ 16 ];
    msn           =:= lsb(4, 4)                              [ 4 ];
    psh_flag      =:= irregular(1)                           [ 1 ];
    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send both ACK and scaled sequence number LSBs
  COMPRESSED seq_6 {
    discriminator      =:= &#39;11011&#39;                          [ 5 ];
    seq_number_scaled  =:= lsb(4, 7)                        [ 4 ];
    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 7, 3) [ 7 ];
    ack_number         =:= lsb(16, 16383)                   [ 16 ];
    msn                =:= lsb(4, 4)                        [ 4 ];
    psh_flag           =:= irregular(1)                     [ 1 ];
    header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH)  [ 3 ];
    ENFORCE(payload_size != 0);
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // Send ACK and window
  COMPRESSED seq_7 {
    discriminator =:= &#39;1100&#39;                                 [ 4 ];
    window        =:= lsb(15, 16383)                         [ 15 ];
    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 5, 3) [ 5 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ack_number    =:= lsb(16, 32767)                         [ 16 ];
    msn           =:= lsb(4, 4)                              [ 4 ];
    psh_flag      =:= irregular(1)                           [ 1 ];
    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  // An extended packet type for seldom-changing fields
  // Can send LSBs of TTL, RSF flags, change ECN behavior, and
  // options list
  COMPRESSED seq_8 {
    discriminator =:= &#39;1011&#39;                                 [ 4 ];
    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 4, 3) [ 4 ];
    list_present  =:= irregular(1)                           [ 1 ];
    header_crc    =:= crc7(THIS.UVALUE, THIS.ULENGTH)        [ 7 ];
    msn           =:= lsb(4, 4)                              [ 4 ];
    psh_flag      =:= irregular(1)                           [ 1 ];
    ttl_hopl      =:= lsb(3, 3)                              [ 3 ];
    ecn_used      =:= one_bit_choice                         [ 1 ];
    ack_number    =:= lsb(15, 8191)                          [ 15 ];
    rsf_flags     =:= rsf_index_enc                          [ 2 ];
    seq_number    =:= lsb(14, 8191)                          [ 14 ];
    options       =:=
      tcp_list_presence_enc(list_present.CVALUE)       [ VARIABLE ];
    ENFORCE((ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL) ||
            (ip_id_behavior_innermost.UVALUE ==
             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Feedback Formats and Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. フィードバックの形式とオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1. Feedback Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1. フィードバック形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the feedback formats for the ROHC-TCP profile, following the general ROHC feedback format described in Section 5.2.4 of [RFC5795].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[RFC5795]のセクション5.2.4で説明されている一般的なROHCフィードバック形式に従って、ROHC-TCPプロファイルのフィードバック形式について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All feedback formats carry a field labeled MSN. The MSN field contains LSBs of the MSN control field described in Section 6.1.1. The sequence number to use is the MSN corresponding to the last header that was successfully CRC-8 validated or CRC verified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのフィードバック形式には、MSNというラベルの付いたフィールドがあります。 MSNフィールドには、セクション6.1.1で説明されているMSNコントロールフィールドのLSBが含まれています。使用するシーケンス番号は、CRC-8の検証またはCRCの検証に成功した最後のヘッダーに対応するMSNです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FEEDBACK-1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FEEDBACK-1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      |              MSN              |
      +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
MSN: The LSB-encoded master sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
MSN：LSBエンコードされたマスターシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A FEEDBACK-1 is an ACK. In order to send a NACK or a STATIC-NACK, FEEDBACK-2 must be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FEEDBACK-1はACKです。 NACKまたはSTATIC-NACKを送信するには、FEEDBACK-2を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FEEDBACK-2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバック2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      |Acktype|          MSN          |
      +---+---+---+---+---+---+---+---+
      |              MSN              |
      +---+---+---+---+---+---+---+---+
      |              CRC              |
      +---+---+---+---+---+---+---+---+
      /       Feedback options        /
      +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Acktype:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Acktype：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         0 = ACK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         1 = NACK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         2 = STATIC-NACK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
3 is reserved (MUST NOT be used for parsability)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
3は予約されています（解析性のために使用してはいけません）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
MSN: The LSB-encoded master sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
MSN：LSBエンコードされたマスターシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC: 8-bit CRC computed over the entire feedback element (as defined in Section 5.3.1.1 of [RFC5795]). For the purpose of computing the CRC, the CRC field is zero. The CRC is calculated using the polynomial defined in [RFC5795].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CRC: 8-bit CRC computed over the entire feedback element (as defined in Section 5.3.1.1 of [RFC5795]). For the purpose of computing the CRC, the CRC field is zero. The CRC is calculated using the polynomial defined in [RFC5795].
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Feedback options: A variable number of feedback options, see Section 8.3.2. Options may appear in any order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Feedback options: A variable number of feedback options, see Section 8.3.2. Options may appear in any order.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A FEEDBACK-2 of type NACK or STATIC-NACK is always implicitly an acknowledgment for a successfully decompressed packet, which packet corresponds to the MSN of the feedback element, unless the MSN-NOT-VALID option (Section 8.3.2.2) appears in the feedback element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプNACKまたはSTATIC-NACKのFEEDBACK-2は、MSN-NOT-VALIDオプション（セクション8.3.2.2）がに表示されていない限り、常に正常に圧縮解除されたパケットの肯定応答です。このパケットは、フィードバック要素のMSNに対応します。フィードバック要素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FEEDBACK-2 format always carries a CRC and is thus more robust than the FEEDBACK-1 format. When receiving FEEDBACK-2, the compressor MUST verify the information by computing the CRC and by comparing the result with the CRC carried in the feedback format. If the two are not identical, the feedback element MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FEEDBACK-2形式は常にCRCを伝送するため、FEEDBACK-1形式よりも堅牢です。フィードバック2を受信すると、コンプレッサーは、CRCを計算し、その結果をフィードバック形式で伝送されるCRCと比較することにより、情報を検証する必要があります。 2つが同一でない場合は、フィードバック要素を破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2. Feedback Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2. フィードバックオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ROHC-TCP feedback option has variable length and the following general format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-TCPフィードバックオプションには、可変長と次の一般的な形式があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      |   Opt Type    |    Opt Len    |
      +---+---+---+---+---+---+---+---+
      /          option data          /  Opt Length (octets)
      +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ROHC-TCP feedback option can appear at most once within a FEEDBACK-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ROHC-TCP feedback option can appear at most once within a FEEDBACK-2.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.1. The REJECT Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.1. REJECTオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REJECT option informs the compressor that the decompressor does not have sufficient resources to handle the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REJECTオプションは、圧縮解除プログラムにフローを処理するための十分なリソースがないことを圧縮プログラムに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +---+---+---+---+---+---+---+---+
      |  Opt Type = 2 |  Opt Len = 0  |
      +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When receiving a REJECT option, the compressor MUST stop compressing the packet flow, and SHOULD refrain from attempting to increase the number of compressed packet flows for some time. The REJECT option MUST NOT appear more than once in the FEEDBACK-2 format; otherwise, the compressor MUST discard the entire feedback element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REJECTオプションを受信すると、圧縮プログラムはパケットフローの圧縮を停止する必要があり、しばらくの間、圧縮されたパケットフローの数を増加させないようにする必要があります（SHOULD）。 REJECTオプションは、FEEDBACK-2形式で複数回使用してはなりません（MUST NOT）。それ以外の場合、コンプレッサーはフィードバック要素全体を破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.2. The MSN-NOT-VALID Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.2. MSN-NOT-VALIDオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MSN-NOT-VALID option indicates that the MSN of the feedback is not valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MSN-NOT-VALID option indicates that the MSN of the feedback is not valid.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +---+---+---+---+---+---+---+---+
      |  Opt Type = 3 |  Opt Len = 0  |
      +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A compressor MUST ignore the MSN of the feedback element when this option is present. Consequently, a NACK or a STATIC-NACK feedback type sent with the MSN-NOT-VALID option is equivalent to a STATIC-NACK with respect to the semantics of the feedback message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A compressor MUST ignore the MSN of the feedback element when this option is present. Consequently, a NACK or a STATIC-NACK feedback type sent with the MSN-NOT-VALID option is equivalent to a STATIC-NACK with respect to the semantics of the feedback message.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MSN-NOT-VALID option MUST NOT appear more than once in the FEEDBACK-2 format and MUST NOT appear in the same feedback element as the MSN option; otherwise, the compressor MUST discard the entire feedback element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MSN-NOT-VALIDオプションは、FEEDBACK-2形式で2回以上表示してはならず、MSNオプションと同じフィードバック要素に表示してはなりません。それ以外の場合、コンプレッサーはフィードバック要素全体を破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.3. The MSN Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.3. MSNオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MSN option provides 2 additional bits of MSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MSNオプションは、MSNの2つの追加ビットを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +---+---+---+---+---+---+---+---+
      |  Opt Type = 4 |  Opt Len = 1  |
      +---+---+---+---+---+---+---+---+
      |  MSN  |        Reserved       |
      +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These 2 bits are the least significant bits of the MSN and are thus concatenated with the 14 bits already present in the FEEDBACK-2 format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの2ビットはMSNの最下位ビットであるため、FEEDBACK-2形式ですでに存在する14ビットと連結されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MSN option MUST NOT appear more than once in the FEEDBACK-2 format and MUST NOT appear in the same feedback element as the MSN-NOT-VALID option; otherwise, the compressor MUST discard the entire feedback element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MSN option MUST NOT appear more than once in the FEEDBACK-2 format and MUST NOT appear in the same feedback element as the MSN-NOT-VALID option; otherwise, the compressor MUST discard the entire feedback element.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.4. The CONTEXT_MEMORY Feedback Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.4. The CONTEXT_MEMORY Feedback Option
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CONTEXT_MEMORY option means that the decompressor does not have sufficient memory resources to handle the context of the packet flow, as the flow is currently compressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONTEXT_MEMORYオプションは、フローが現在圧縮されているため、デコンプレッサにパケットフローのコンテキストを処理するための十分なメモリリソースがないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      |  Opt Type = 9 |  Opt Len = 0  |
      +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When receiving a CONTEXT_MEMORY option, the compressor SHOULD take actions to compress the packet flow in a way that requires less decompressor memory resources, or stop compressing the packet flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONTEXT_MEMORYオプションを受信すると、コンプレッサーは、必要なデコンプレッサーメモリリソースを少なくする方法でパケットフローを圧縮するか、パケットフローの圧縮を停止するアクションを実行する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CONTEXT_MEMORY option MUST NOT appear more than once in the FEEDBACK-2 format; otherwise, the compressor MUST discard the entire feedback element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONTEXT_MEMORYオプションは、FEEDBACK-2形式で複数回使用してはなりません。それ以外の場合、コンプレッサーはフィードバック要素全体を破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.5. Unknown Option Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2.5. Unknown Option Types
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an option type unknown to the compressor is encountered, the compressor MUST continue parsing the rest of the FEEDBACK element, which is possible since the length of the option is explicit, but MUST otherwise ignore the unknown option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an option type unknown to the compressor is encountered, the compressor MUST continue parsing the rest of the FEEDBACK element, which is possible since the length of the option is explicit, but MUST otherwise ignore the unknown option.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Changes from RFC 4996
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Changes from RFC 4996
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This RFC revises RFC 4996. It is mostly backwards-compatible with RFC 4996, except for two cases that did not interoperate as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このRFCはRFC 4996を改訂します。以下に説明するように相互運用しなかった2つのケースを除いて、RFC 4996との後方互換性がほとんどあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Functional Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Functional Changes
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The SACK option compression in [RFC4996] assumed that multiple SACK blocks within the same option would be in sorted order so that the block starts were LSB-encoded from the end of the previous block. This meant that SACK blocks that are not in sorted order could be impossible to compress in some cases. Therefore, the SACK compression in the formal notation has changed and therefore also the bits-on-the-wire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o [RFC4996]のSACKオプション圧縮は、同じオプション内の複数のSACKブロックがソートされた順序であり、ブロックの開始が前のブロックの終了からLSBエンコードされると想定していました。つまり、並べ替えられていないSACKブロックは、場合によっては圧縮できないことがあります。したがって、正式な表記でのSACK圧縮が変更され、ビットオンザワイヤーも変更されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The ESP NULL header compression has been deprecated due to interoperability problems with needing to know information from the trailer. The ESP NULL compression was already removed from ROHCv2 [RFC5225] for the same reason and it was considered better to remove it from this profile rather than try to fix the interoperability issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The ESP NULL header compression has been deprecated due to interoperability problems with needing to know information from the trailer. The ESP NULL compression was already removed from ROHCv2 [RFC5225] for the same reason and it was considered better to remove it from this profile rather than try to fix the interoperability issue.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Non-functional Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 非機能的な変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The way sequential IP-ID compression was described in the FN code was incorrect and the code used for ROHCv2 [RFC5225] has been imported into this specification (e.g., offset is made into a global control field). This does not change the bits-on-the-wire. The only change is how this encoding is described in the formal notation, not how the compression occurs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The way sequential IP-ID compression was described in the FN code was incorrect and the code used for ROHCv2 [RFC5225] has been imported into this specification (e.g., offset is made into a global control field). This does not change the bits-on-the-wire. The only change is how this encoding is described in the formal notation, not how the compression occurs.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Default encoding for the &#39;df&#39; and &#39;ip_id&#39; fields have been added for IPv6 with 0-bit uncompressed format to clarify that these never appear in IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Default encoding for the &#39;df&#39; and &#39;ip_id&#39; fields have been added for IPv6 with 0-bit uncompressed format to clarify that these never appear in IPv6.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The scaled encoding of the Acknowledgment Number and Sequence Number were incorrectly described in the FN code in [RFC4996] and have been updated in the same style as in ROHCv2 [RFC5225]. This does not change the bits-on-the-wire, only the way the compression is described in the FN code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The scaled encoding of the Acknowledgment Number and Sequence Number were incorrectly described in the FN code in [RFC4996] and have been updated in the same style as in ROHCv2 [RFC5225]. This does not change the bits-on-the-wire, only the way the compression is described in the FN code.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The external arguments to ipv4 and co_baseheader have been updated. This is again only a change for FN correctness and does not affect interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The external arguments to ipv4 and co_baseheader have been updated. This is again only a change for FN correctness and does not affect interoperability.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Errata for [RFC4996] related to minor errors in the FN and textual errors have also been corrected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Errata for [RFC4996] related to minor errors in the FN and textual errors have also been corrected.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A malfunctioning or malicious header compressor could cause the header decompressor to reconstitute packets that do not match the original packets but still have valid IP and TCP headers, and possibly also valid TCP checksums. Such corruption may be detected with end-to-end authentication and integrity mechanisms that will not be affected by the compression. Moreover, this header compression scheme uses an internal checksum for verification of reconstructed headers. This reduces the probability of producing decompressed headers not matching the original ones without this being noticed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A malfunctioning or malicious header compressor could cause the header decompressor to reconstitute packets that do not match the original packets but still have valid IP and TCP headers, and possibly also valid TCP checksums. Such corruption may be detected with end-to-end authentication and integrity mechanisms that will not be affected by the compression. Moreover, this header compression scheme uses an internal checksum for verification of reconstructed headers. This reduces the probability of producing decompressed headers not matching the original ones without this being noticed.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Denial-of-service attacks are possible if an intruder can introduce (for example) bogus IR, CO, or FEEDBACK packets onto the link and thereby cause compression efficiency to be reduced. However, an intruder having the ability to inject arbitrary packets at the link layer in this manner raises additional security issues that dwarf those related to the use of header compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Denial-of-service attacks are possible if an intruder can introduce (for example) bogus IR, CO, or FEEDBACK packets onto the link and thereby cause compression efficiency to be reduced. However, an intruder having the ability to inject arbitrary packets at the link layer in this manner raises additional security issues that dwarf those related to the use of header compression.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference for the ROHC profile identifier 0x0006 has been updated to reference this document instead of RFC 4996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference for the ROHC profile identifier 0x0006 has been updated to reference this document instead of RFC 4996.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ROHC profile identifier has been reserved by IANA for the profile defined in this document. Profiles 0x0000-0x0005 have previously been reserved; this profile is 0x0006. As for previous ROHC profiles, profile numbers 0xnn06 have been reserved for future updates of this profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ROHC profile identifier has been reserved by IANA for the profile defined in this document. Profiles 0x0000-0x0005 have previously been reserved; this profile is 0x0006. As for previous ROHC profiles, profile numbers 0xnn06 have been reserved for future updates of this profile.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Profile Usage Document identifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Profile Usage Document identifier
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
0x0006 ROHC TCP [RFC6846] 0xnn06 Reserved
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
0x0006 ROHC TCP [RFC6846] 0xnn06 Reserved
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Acknowledgments
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Qian Zhang, Hong Bin Liao, Richard Price, and Fredrik Lindstroem for their work with early versions of this specification. Thanks also to Robert Finking and Carsten Bormann for valuable input and to Carl Knutsson and Gilbert Strom for suggestions and review of the updates made in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Qian Zhang, Hong Bin Liao, Richard Price, and Fredrik Lindstroem for their work with early versions of this specification. Thanks also to Robert Finking and Carsten Bormann for valuable input and to Carl Knutsson and Gilbert Strom for suggestions and review of the updates made in this document.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional thanks: this document was reviewed during working group last-call by committed reviewers Joe Touch and Ted Faber, as well as by Sally Floyd, who provided a review at the request of the Transport Area Directors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追記：このドキュメントは、作業部会の最終会議で、熱心なレビュアーのJoe TouchとTed Faber、およびTransport Area Directorsのリクエストでレビューを提供したSally Floydによってレビューされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0791] Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0791] Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791, September 1981.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0793] Postel、J。、「Transmission Control Protocol」、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2004] Perkins, C., &#34;Minimal Encapsulation within IP&#34;, RFC 2004, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2004] Perkins, C., &#34;Minimal Encapsulation within IP&#34;, RFC 2004, October 1996.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2784] Farinacci, D., Li, T., Hanks, S., Meyer, D., and P. Traina, &#34;Generic Routing Encapsulation (GRE)&#34;, RFC 2784, March 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2784] Farinacci, D., Li, T., Hanks, S., Meyer, D., and P. Traina, &#34;Generic Routing Encapsulation (GRE)&#34;, RFC 2784, March 2000.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2890] Dommety, G., &#34;Key and Sequence Number Extensions to GRE&#34;, RFC 2890, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2890] Dommety, G., &#34;Key and Sequence Number Extensions to GRE&#34;, RFC 2890, September 2000.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4164] Pelletier, G., &#34;RObust Header Compression (ROHC): Context Replication for ROHC Profiles&#34;, RFC 4164, August 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4164] Pelletier, G., &#34;RObust Header Compression (ROHC): Context Replication for ROHC Profiles&#34;, RFC 4164, August 2005.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, December 2005.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4997] Finking, R. and G. Pelletier, &#34;Formal Notation for RObust Header Compression (ROHC-FN)&#34;, RFC 4997, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4997] Finking, R. and G. Pelletier, &#34;Formal Notation for RObust Header Compression (ROHC-FN)&#34;, RFC 4997, July 2007.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5795] Sandlund, K., Pelletier, G., and L-E. Jonsson, &#34;The RObust Header Compression (ROHC) Framework&#34;, RFC 5795, March 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5795] Sandlund, K., Pelletier, G., and L-E. Jonsson, &#34;The RObust Header Compression (ROHC) Framework&#34;, RFC 5795, March 2010.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1144] Jacobson, V., &#34;Compressing TCP/IP headers for low-speed serial links&#34;, RFC 1144, February 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1144] Jacobson、V。、「低速シリアルリンクのTCP / IPヘッダーの圧縮」、RFC 1144、1990年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1323] Jacobson, V., Braden, B., and D. Borman, &#34;TCP Extensions for High Performance&#34;, RFC 1323, May 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1323] Jacobson, V., Braden, B., and D. Borman, &#34;TCP Extensions for High Performance&#34;, RFC 1323, May 1992.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, October 1996.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2507] Degermark, M., Nordgren, B., and S. Pink, &#34;IP Header Compression&#34;, RFC 2507, February 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2507] Degermark, M., Nordgren, B., and S. Pink, &#34;IP Header Compression&#34;, RFC 2507, February 1999.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, &#34;An Extension to the Selective Acknowledgement (SACK) Option for TCP&#34;, RFC 2883, July 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, &#34;An Extension to the Selective Acknowledgement (SACK) Option for TCP&#34;, RFC 2883, July 2000.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &#34;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed&#34;, RFC 3095, July 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &#34;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed&#34;, RFC 3095, July 2001.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, September 2001.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3759] Jonsson, L-E., &#34;RObust Header Compression (ROHC): Terminology and Channel Mapping Examples&#34;, RFC 3759, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3759] Jonsson, L-E., &#34;RObust Header Compression (ROHC): Terminology and Channel Mapping Examples&#34;, RFC 3759, April 2004.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4163] Jonsson, L-E., &#34;RObust Header Compression (ROHC): Requirements on TCP/IP Header Compression&#34;, RFC 4163, August 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4163] Jonsson, L-E., &#34;RObust Header Compression (ROHC): Requirements on TCP/IP Header Compression&#34;, RFC 4163, August 2005.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4224] Pelletier, G., Jonsson, L-E., and K. Sandlund, &#34;RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets&#34;, RFC 4224, January 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4224] Pelletier, G., Jonsson, L-E., and K. Sandlund, &#34;RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets&#34;, RFC 4224, January 2006.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4413] West, M. and S. McCann, &#34;TCP/IP Field Behavior&#34;, RFC 4413, March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4413] West, M. and S. McCann, &#34;TCP/IP Field Behavior&#34;, RFC 4413, March 2006.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4996] Pelletier, G., Sandlund, K., Jonsson, L-E., and M. West, &#34;RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)&#34;, RFC 4996, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4996] Pelletier, G., Sandlund, K., Jonsson, L-E., and M. West, &#34;RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)&#34;, RFC 4996, July 2007.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5225] Pelletier, G. and K. Sandlund, &#34;RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP and UDP-Lite&#34;, RFC 5225, April 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5225] Pelletier, G. and K. Sandlund, &#34;RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP and UDP-Lite&#34;, RFC 5225, April 2008.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ghyslain Pelletier InterDigital Communications 1000, Sherbrooke Street West, 10th floor Montreal, Quebec H3A 3G4 Canada
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ghyslain Pelletier InterDigital Communications 1000, Sherbrooke Street West, 10th floor Montreal, Quebec H3A 3G4 Canada
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +46 (0) 70 609 27 73
   EMail: ghyslain.pelletier@interdigital.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kristofer Sandlund Ericsson Box 920 Lulea SE-971 28 Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kristofer Sandlund Ericsson Box 920 Lulea SE-971 28 Sweden
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +46 (0) 8 404 41 58
   EMail: kristofer.sandlund@ericsson.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lars-Erik Jonsson Optand 737 Ostersund SE-831 92 Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lars-Erik Jonsson Optand 737エステルスンドSE-831 92スウェーデン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +46 70 365 20 58
   EMail: lars-erik@lejonsson.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark A West Siemens/Roke Manor Roke Manor Research Ltd. Romsey, Hampshire SO51 0ZN UK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark A West Siemens / Roke Manor Roke Manor Research Ltd. Romsey、Hampshire SO51 0ZN UK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +44 1794 833311
   EMail: mark.a.west@roke.co.uk
   URI:   http://www.roke.co.uk
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
