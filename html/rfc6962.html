<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 6962 - Certificate Transparency 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6962</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc6962">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <!-- <div class="row"> -->
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6962 - Certificate Transparency 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc6962">
              https://datatracker.ietf.org/doc/html/rfc6962
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6962 - 証明書の透明性</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    <!-- </div> -->
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         B. Laurie
Request for Comments: 6962                                    A. Langley
Category: Experimental                                         E. Kasper
ISSN: 2070-1721                                                   Google
                                                               June 2013
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Certificate Transparency
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
証明書の透明性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes an experimental protocol for publicly logging the existence of Transport Layer Security (TLS) certificates as they are issued or observed, in a manner that allows anyone to audit certificate authority (CA) activity and notice the issuance of suspect certificates as well as to audit the certificate logs themselves. The intent is that eventually clients would refuse to honor certificates that do not appear in a log, effectively forcing CAs to add all issued certificates to the logs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、トランスポート層セキュリティ（TLS）証明書の発行または監視時に、誰でも認証局（CA）のアクティビティを監査し、疑わしい証明書の発行に気付くことができるように、その存在を公に記録するための実験的なプロトコルについて説明します。証明書ログ自体を監査します。その意図は、最終的にクライアントがログに表示されない証明書を受け入れることを拒否し、発行されたすべての証明書をログに追加することをCAに効果的に強制することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Logs are network services that implement the protocol operations for submissions and queries that are defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログは、このドキュメントで定義されている送信とクエリのプロトコル操作を実装するネットワークサービスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。 RFC 5741のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6962.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6962で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2013 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Informal Introduction ...........................................3
      1.1. Requirements Language ......................................4
      1.2. Data Structures ............................................4
   2. Cryptographic Components ........................................4
      2.1. Merkle Hash Trees ..........................................4
           2.1.1. Merkle Audit Paths ..................................5
           2.1.2. Merkle Consistency Proofs ...........................6
           2.1.3. Example .............................................7
           2.1.4. Signatures ..........................................8
   3. Log Format and Operation ........................................9
      3.1. Log Entries ................................................9
      3.2. Structure of the Signed Certificate Timestamp .............12
      3.3. Including the Signed Certificate Timestamp in the
           TLS Handshake .............................................13
           3.3.1. TLS Extension ......................................15
      3.4. Merkle Tree ...............................................15
      3.5. Signed Tree Head ..........................................16
   4. Log Client Messages ............................................17
      4.1. Add Chain to Log ..........................................17
      4.2. Add PreCertChain to Log ...................................18
      4.3. Retrieve Latest Signed Tree Head ..........................18
      4.4. Retrieve Merkle Consistency Proof between Two
           Signed Tree Heads .........................................19
      4.5. Retrieve Merkle Audit Proof from Log by Leaf Hash .........19
      4.6. Retrieve Entries from Log .................................20
      4.7. Retrieve Accepted Root Certificates .......................21
      4.8. Retrieve Entry+Merkle Audit Proof from Log ................21
   5. Clients ........................................................21
      5.1. Submitters ................................................22
      5.2. TLS Client ................................................22
      5.3. Monitor ...................................................22
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
      5.4. Auditor ...................................................23
   6. IANA Considerations ............................................23
   7. Security Considerations ........................................23
      7.1. Misissued Certificates ....................................24
      7.2. Detection of Misissue .....................................24
      7.3. Misbehaving Logs ..........................................24
   8. Efficiency Considerations ......................................25
   9. Future Changes .................................................25
   10. Acknowledgements ..............................................25
   11. References ....................................................25
      11.1. Normative Reference ......................................25
      11.2. Informative References ...................................26
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Informal Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 非公式な紹介
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certificate transparency aims to mitigate the problem of misissued certificates by providing publicly auditable, append-only, untrusted logs of all issued certificates. The logs are publicly auditable so that it is possible for anyone to verify the correctness of each log and to monitor when new certificates are added to it. The logs do not themselves prevent misissue, but they ensure that interested parties (particularly those named in certificates) can detect such misissuance. Note that this is a general mechanism, but in this document, we only describe its use for public TLS server certificates issued by public certificate authorities (CAs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書の透明性は、発行されたすべての証明書の公に監査可能な、追加のみの信頼できないログを提供することにより、誤って発行された証明書の問題を軽減することを目的としています。ログは公に監査可能であるため、誰でも各ログの正確性を検証し、新しいログがいつ追加されるかを監視できます。ログ自体は誤発行を防止するものではありませんが、関係者（特に証明書で指定された者）がそのような誤発行を検出できるようにします。これは一般的なメカニズムですが、このドキュメントでは、公的認証機関（CA）が発行したパブリックTLSサーバー証明書の使用についてのみ説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each log consists of certificate chains, which can be submitted by anyone. It is expected that public CAs will contribute all their newly issued certificates to one or more logs; it is also expected that certificate holders will contribute their own certificate chains. In order to avoid logs being spammed into uselessness, it is required that each chain is rooted in a known CA certificate. When a chain is submitted to a log, a signed timestamp is returned, which can later be used to provide evidence to clients that the chain has been submitted. TLS clients can thus require that all certificates they see have been logged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ログは、誰でも送信できる証明書チェーンで構成されています。パブリックCAは、新しく発行されたすべての証明書を1つ以上のログに提供することが期待されています。証明書保有者が独自の証明書チェーンを提供することも期待されています。ログが無用にスパム送信されるのを防ぐために、各チェーンが既知のCA証明書をルートとしていることが必要です。チェーンがログに送信されると、署名されたタイムスタンプが返されます。これは、後でチェーンが送信されたことの証拠をクライアントに提供するために使用できます。したがって、TLSクライアントは、表示するすべての証明書がログに記録されていることを要求できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Those who are concerned about misissue can monitor the logs, asking them regularly for all new entries, and can thus check whether domains they are responsible for have had certificates issued that they did not expect. What they do with this information, particularly when they find that a misissuance has happened, is beyond the scope of this document, but broadly speaking, they can invoke existing business mechanisms for dealing with misissued certificates. Of course, anyone who wants can monitor the logs and, if they believe a certificate is incorrectly issued, take action as they see fit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
誤発行が心配な場合は、ログを監視して、すべての新しいエントリを定期的に確認し、担当するドメインに予期しない証明書が発行されていないかどうかを確認できます。彼らがこの情報を使って何をするか、特にミス発行が発生したことがわかった場合は、このドキュメントの範囲外ですが、大まかに言えば、発行された証明書を処理するための既存のビジネスメカニズムを呼び出すことができます。もちろん、必要な人は誰でもログを監視でき、証明書が誤って発行されたと思われる場合は、適切と思われるアクションを実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, those who have seen signed timestamps from a particular log can later demand a proof of inclusion from that log. If the log is unable to provide this (or, indeed, if the corresponding certificate is absent from monitors&#39; copies of that log), that is evidence of the incorrect operation of the log. The checking operation is asynchronous to allow TLS connections to proceed without delay, despite network connectivity issues and the vagaries of firewalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、特定のログからの署名付きタイムスタンプを見た人は、後でそのログからの包含の証明を要求できます。ログがこれを提供できない場合（または、対応する証明書がそのログのモニターのコピーにない場合）、それはログの不正な操作の証拠です。チェック操作は非同期であり、ネットワーク接続の問題やファイアウォールの変化にもかかわらず、TLS接続を遅延なく続行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The append-only property of each log is technically achieved using Merkle Trees, which can be used to show that any particular version of the log is a superset of any particular previous version. Likewise, Merkle Trees avoid the need to blindly trust logs: if a log attempts to show different things to different people, this can be efficiently detected by comparing tree roots and consistency proofs. Similarly, other misbehaviors of any log (e.g., issuing signed timestamps for certificates they then don&#39;t log) can be efficiently detected and proved to the world at large.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ログの追加のみのプロパティは技術的にはマークルツリーを使用して実現されます。これは、ログの特定のバージョンが特定の以前のバージョンのスーパーセットであることを示すために使用できます。同様に、マークルツリーはログを盲目的に信頼する必要性を回避します。ログが別の人に異なるものを表示しようとする場合、これはツリーのルートと整合性の証明を比較することで効率的に検出できます。同様に、ログの他の不正行為（たとえば、ログに記録しない証明書に対して署名付きタイムスタンプを発行する）を効率的に検出して、世界中に証明することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Data Structures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. データ構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data structures are defined according to the conventions laid out in Section 4 of [RFC5246].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ構造は、[RFC5246]のセクション4で説明されている規則に従って定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Cryptographic Components
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 暗号化コンポーネント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Merkle Hash Trees
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. マークルハッシュツリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Logs use a binary Merkle Hash Tree for efficient auditing.  The
   hashing algorithm is SHA-256 [FIPS.180-4] (note that this is fixed
   for this experiment, but it is anticipated that each log would be
   able to specify a hash algorithm).  The input to the Merkle Tree Hash
   is a list of data entries; these entries will be hashed to form the
   leaves of the Merkle Hash Tree.  The output is a single 32-byte
   Merkle Tree Hash.  Given an ordered list of n inputs, D[n] = {d(0),
   d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH) is thus defined as
   follows:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hash of an empty list is the hash of an empty string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空のリストのハッシュは、空の文字列のハッシュです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MTH({}) = SHA-256().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ＭＴＨ（｛｝） ＝ しゃー２５６()。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hash of a list with one entry (also known as a leaf hash) is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つのエントリを持つリストのハッシュ（リーフハッシュとも呼ばれます）は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MTH({d(0)}) = SHA-256(0x00 || d(0)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MTH（{d（0）}）= SHA-256（0x00 || d（0））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For n &gt; 1, let k be the largest power of two smaller than n (i.e., k &lt; n &lt;= 2k). The Merkle Tree Hash of an n-element list D[n] is then defined recursively as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n&gt; 1の場合、kをnより小さい2の最大のべき乗とします（つまり、k &lt;n &lt;= 2k）。 n要素リストD [n]のマークルツリーハッシュは、次のように再帰的に定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MTH(D[n]) = SHA-256(0x01 || MTH(D[0:k]) || MTH(D[k:n])),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MTH（D [n]）= SHA-256（0x01 || MTH（D [0：k]）|| MTH（D [k：n]））、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where || is concatenation and D[k1:k2] denotes the list {d(k1), d(k1+1),..., d(k2-1)} of length (k2 - k1). (Note that the hash calculations for leaves and nodes differ. This domain separation is required to give second preimage resistance.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこ||は連結であり、D [k1：k2]は長さ（k2-k1）のリスト{d（k1）、d（k1 + 1）、...、d（k2-1）}を示します。 （葉とノードのハッシュ計算は異なることに注意してください。このドメイン分離は、2番目のプリイメージ耐性を与えるために必要です。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that we do not require the length of the input list to be a power of two. The resulting Merkle Tree may thus not be balanced; however, its shape is uniquely determined by the number of leaves. (Note: This Merkle Tree is essentially the same as the history tree [CrosbyWallach] proposal, except our definition handles non-full trees differently.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力リストの長さが2の累乗である必要はないことに注意してください。したがって、結果のマークルツリーはバランスが取れていない可能性があります。ただし、その形状は葉の数によって一意に決まります。 （注：このマークルツリーは、定義が完全でないツリーを異なる方法で処理することを除いて、基本的に履歴ツリー[CrosbyWallach]提案と同じです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1. Merkle Audit Paths
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1. マークル監査パス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Merkle audit path for a leaf in a Merkle Hash Tree is the shortest list of additional nodes in the Merkle Tree required to compute the Merkle Tree Hash for that tree. Each node in the tree is either a leaf node or is computed from the two nodes immediately below it (i.e., towards the leaves). At each step up the tree (towards the root), a node from the audit path is combined with the node computed so far. In other words, the audit path consists of the list of missing nodes required to compute the nodes leading from a leaf to the root of the tree. If the root computed from the audit path matches the true root, then the audit path is proof that the leaf exists in the tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークルハッシュツリー内の葉のマークル監査パスは、そのツリーのマークルツリーハッシュを計算するために必要なマークルツリー内の追加ノードの最短リストです。ツリー内の各ノードは、リーフノードであるか、またはそのすぐ下（つまり、リーフに向かって）の2つのノードから計算されます。ツリー（ルートに向かって）の各ステップで、監査パスのノードが、これまでに計算されたノードと結合されます。言い換えると、監査パスは、リーフからツリーのルートに至るノードを計算するために必要な欠落ノードのリストで構成されます。監査パスから計算されたルートが真のルートと一致する場合、監査パスはリーフがツリーに存在することの証明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Given an ordered list of n inputs to the tree, D[n] = {d(0), ...,
   d(n-1)}, the Merkle audit path PATH(m, D[n]) for the (m+1)th input
   d(m), 0 &lt;= m &lt; n, is defined as follows:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The path for the single leaf in a tree with a one-element input list
   D[1] = {d(0)} is empty:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   PATH(0, {d(0)}) = {}
   For n &gt; 1, let k be the largest power of two smaller than n.  The
   path for the (m+1)th element d(m) in a list of n &gt; m elements is then
   defined recursively as
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   PATH(m, D[n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m &lt; k; and
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PATH(m, D[n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m &gt;= k,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PATH（m、D [n]）= PATH（m-k、D [k：n]）：M&gt; = kのMTH（D [0：k]）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、：はリストの連結であり、D [k1：k2]は長さ（k2-k1）リスト{d（k1）、d（k1 + 1）、...、d（k2-1）}を以前と同じように示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2. Merkle Consistency Proofs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2. マークル整合性証明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the Merkle Tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークル一貫性の証明は、ツリーの追加のみの特性を証明します。マークルツリーハッシュMTH（D [n]）および最初にm個の葉（m &lt;= n）の以前に通知されたハッシュMTH（D [0：m]）のマークル整合性証明は、マークルツリーのノードのリストです。最初のm個の入力D [0：m]が両方のツリーで等しいことを確認する必要があります。したがって、一貫性の証明には、MTH（D [n]）を検証するのに十分な一連の中間ノード（つまり、入力へのコミットメント）が含まれている必要があります。これにより、同じノード（のサブセット）を使用してMTH（D [0 ：m]）。 （一意の）最小一貫性証明を出力するアルゴリズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Given an ordered list of n inputs to the tree, D[n] = {d(0), ...,
   d(n-1)}, the Merkle consistency proof PROOF(m, D[n]) for a previous
   Merkle Tree Hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   PROOF(m, D[n]) = SUBPROOF(m, D[n], true)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree Merkle Tree Hash MTH(D[0:m]) is known):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
m = nの副証明は、mが最初にPROOFが要求された値である場合は空です（つまり、サブツリーマークルツリーハッシュMTH（D [0：m]）が既知である）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SUBPROOF(m, D[m], true) = {}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The subproof for m = n is the Merkle Tree Hash committing inputs D[0:m]; otherwise:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
m = nの副証明は、入力D [0：m]をコミットするマークルツリーハッシュです。さもないと：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SUBPROOF(m, D[m], false) = {MTH(D[m])}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For m &lt; n, let k be the largest power of two smaller than n. The subproof is then defined recursively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
m &lt;nの場合、kをnより小さい2の最大べき乗とします。次に、副証明が再帰的に定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If m &lt;= k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
m &lt;= kの場合、正しいサブツリーエントリD [k：n]は現在のツリーにのみ存在します。左側のサブツリーエントリD [0：k]が一貫していることを証明し、D [k：n]にコミットメントを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 SUBPROOF(m, D[n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n]) If m &gt; k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
SUBPROOF（m、D [n]、b）= SUBPROOF（m、D [0：k]、b）：MTH（D [k：n]）m&gt; kの場合、左側のサブツリーエントリD [0：k]両方のツリーで同一です。正しいサブツリーエントリD [k：n]が一貫していることを証明し、D [0：k]にコミットメントを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SUBPROOF(m, D[n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, : is a concatenation of lists, and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、：はリストの連結であり、D [k1：k2]は長さ（k2-k1）リスト{d（k1）、d（k1 + 1）、...、d（k2-1）}を次のように表します前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の証明のノード数は、ceil（log2（n））+ 1によって制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.3. Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.3. 例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The binary Merkle Tree with 7 leaves:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7葉のバイナリマークルツリー：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               hash
              /    \
             /      \
            /        \
           /          \
          /            \
         k              l
        / \            / \
       /   \          /   \
      /     \        /     \
     g       h      i      j
    / \     / \    / \     |
    a b     c d    e f     d6
    | |     | |    | |
   d0 d1   d2 d3  d4 d5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The audit path for d0 is [b, h, l].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d0の監査パスは[b、h、l]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The audit path for d3 is [c, g, l].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d3の監査パスは[c、g、l]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The audit path for d4 is [f, j, k].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d4の監査パスは[f、j、k]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The audit path for d6 is [i, k].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d6の監査パスは[i、k]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same tree, built incrementally in four steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4つのステップで段階的に構築された同じツリー：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       hash0          hash1=k
       / \              /  \
      /   \            /    \
     /     \          /      \
     g      c         g       h
    / \     |        / \     / \
    a b     d2       a b     c d
    | |              | |     | |
   d0 d1            d0 d1   d2 d3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             hash2                    hash
             /  \                    /    \
            /    \                  /      \
           /      \                /        \
          /        \              /          \
         /          \            /            \
        k            i          k              l
       / \          / \        / \            / \
      /   \         e f       /   \          /   \
     /     \        | |      /     \        /     \
    g       h      d4 d5    g       h      i      j
   / \     / \             / \     / \    / \     |
   a b     c d             a b     c d    e f     d6
   | |     | |             | |     | |    | |
   d0 d1   d2 d3           d0 d1   d2 d3  d4 d5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The consistency proof between hash0 and hash is PROOF(3, D[7]) = [c,
   d, g, l].  c, g are used to verify hash0, and d, l are additionally
   used to show hash is consistent with hash0.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The consistency proof between hash1 and hash is PROOF(4, D[7]) = [l].
   hash can be verified using hash1=k and l.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The consistency proof between hash2 and hash is PROOF(6, D[7]) = [i,
   j, k].  k, i are used to verify hash2, and j is additionally used to
   show hash is consistent with hash2.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.4. Signatures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.4. 署名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Various data structures are signed. A log MUST use either elliptic curve signatures using the NIST P-256 curve (Section D.1.2.3 of the Digital Signature Standard [DSS]) or RSA signatures (RSASSA-PKCS1- V1_5 with SHA-256, Section 8.2 of [RFC3447]) using a key of at least 2048 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さまざまなデータ構造が署名されています。ログは、NIST P-256曲線を使用した楕円曲線署名（デジタル署名標準[DSS]のセクションD.1.2.3）またはRSA署名（SAS-256を使用したRSASSA-PKCS1-V1_5、[RFC3447のセクション8.2]のいずれかを使用する必要があります]）少なくとも2048ビットのキーを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Log Format and Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. ログの形式と操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anyone can submit certificates to certificate logs for public auditing; however, since certificates will not be accepted by TLS clients unless logged, it is expected that certificate owners or their CAs will usually submit them. A log is a single, ever-growing, append-only Merkle Tree of such certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
誰でも証明書を証明書ログに送信して、公開監査を行うことができます。ただし、証明書はログに記録されない限りTLSクライアントによって受け入れられないため、証明書の所有者またはそのCAが通常は証明書を送信することが期待されています。ログは、そのような証明書の単一の、増え続ける、追加のみのマークルツリーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a valid certificate is submitted to a log, the log MUST immediately return a Signed Certificate Timestamp (SCT). The SCT is the log&#39;s promise to incorporate the certificate in the Merkle Tree within a fixed amount of time known as the Maximum Merge Delay (MMD). If the log has previously seen the certificate, it MAY return the same SCT as it returned before. TLS servers MUST present an SCT from one or more logs to the TLS client together with the certificate. TLS clients MUST reject certificates that do not have a valid SCT for the end-entity certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有効な証明書がログに送信されると、ログはただちに署名済み証明書タイムスタンプ（SCT）を返す必要があります。 SCTは、最大マージ遅延（MMD）と呼ばれる一定の時間内に証明書をマークルツリーに組み込むというログの約束です。ログが以前に証明書を見た場合、以前に返されたものと同じSCTを返す場合があります。 TLSサーバーは、1つ以上のログからのSCTを証明書と共にTLSクライアントに提示する必要があります。 TLSクライアントは、エンドエンティティ証明書に有効なSCTがない証明書を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Periodically, each log appends all its new entries to the Merkle Tree and signs the root of the tree. Auditors can thus verify that each certificate for which an SCT has been issued indeed appears in the log. The log MUST incorporate a certificate in its Merkle Tree within the Maximum Merge Delay period after the issuance of the SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定期的に、各ログはすべての新しいエントリをマークルツリーに追加し、ツリーのルートに署名します。したがって、監査人は、SCTが発行された各証明書が実際にログに表示されることを確認できます。ログは、SCTの発行後の最大マージ遅延期間内に、そのマークルツリーに証明書を組み込む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Log operators MUST NOT impose any conditions on retrieving or sharing data from the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログオペレーターは、ログからのデータの取得または共有に条件を課してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Log Entries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. ログエントリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anyone can submit a certificate to any log. In order to enable attribution of each logged certificate to its issuer, the log SHALL publish a list of acceptable root certificates (this list might usefully be the union of root certificates trusted by major browser vendors). Each submitted certificate MUST be accompanied by all additional certificates required to verify the certificate chain up to an accepted root certificate. The root certificate itself MAY be omitted from the chain submitted to the log server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
誰でも任意のログに証明書を送信できます。ログに記録された各証明書の発行者への帰属を有効にするために、ログは、受け入れ可能なルート証明書のリストを公開する必要があります（このリストは、主要なブラウザベンダーが信頼するルート証明書の和集合である場合があります）。提出された各証明書には、受け入れられたルート証明書までの証明書チェーンを検証するために必要なすべての追加の証明書を添付する必要があります。ルート証明書自体は、ログサーバーに送信されるチェーンから省略される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Alternatively, (root as well as intermediate) certificate authorities may submit a certificate to logs prior to issuance. To do so, the CA submits a Precertificate that the log can use to create an entry that will be valid against the issued certificate. The Precertificate is constructed from the certificate to be issued by adding a special critical poison extension (OID 1.3.6.1.4.1.11129.2.4.3, whose extnValue OCTET STRING contains ASN.1 NULL data (0x05 0x00)) to the end-entity TBSCertificate (this extension is to ensure that the Precertificate cannot be validated by a standard X.509v3 client) and signing the resulting TBSCertificate [RFC5280] with either o a special-purpose (CA:true, Extended Key Usage: Certificate Transparency, OID 1.3.6.1.4.1.11129.2.4.4) Precertificate Signing Certificate. The Precertificate Signing Certificate MUST be directly certified by the (root or intermediate) CA certificate that will ultimately sign the end-entity TBSCertificate yielding the end-entity certificate (note that the log may relax standard validation rules to allow this, so long as the issued certificate will be valid),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
または、（ルートと中間の）認証局が発行前に証明書をログに送信することもできます。そのために、CAは、発行された証明書に対して有効なエントリを作成するためにログが使用できる事前証明書を送信します。 Precertificateは、特別なクリティカルポイズンエクステンション（OID 1.3.6.1.4.1.11129.2.4.3、extnValue OCTET STRINGにASN.1 NULLデータ（0x05 0x00）が含まれている）をエンドエンティティTBSCertificateに追加することによって発行される証明書から構築されます（この拡張は、Precertificateが標準のX.509v3クライアントによって検証されないことを保証するためのものです）、結果として得られるTBSCertificate [RFC5280]に、特別な目的（CA：true、Extended Key Usage：Certificate Transparency、OID 1.3.6.1）のいずれかで署名します。 .4.1.11129.2.4.4）事前証明書署名証明書。事前証明書署名証明書は、最終的にエンドエンティティTBSCertificateに署名する（ルートまたは中間）CA証明書によって直接認証される必要があります（ログが、これを許可する限り、ログが標準の検証ルールを緩和してこれを許可することに注意してください）発行された証明書が有効になります）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o or, the CA certificate that will sign the final certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o または、最終的な証明書に署名するCA証明書。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As above, the Precertificate submission MUST be accompanied by the Precertificate Signing Certificate, if used, and all additional certificates required to verify the chain up to an accepted root certificate. The signature on the TBSCertificate indicates the certificate authority&#39;s intent to issue a certificate. This intent is considered binding (i.e., misissuance of the Precertificate is considered equal to misissuance of the final certificate). Each log verifies the Precertificate signature chain and issues a Signed Certificate Timestamp on the corresponding TBSCertificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、事前証明書の提出には、使用する場合は事前証明書署名証明書と、受け入れられたルート証明書までのチェーンを検証するために必要なすべての追加の証明書を添付する必要があります。 TBSCertificateの署名は、認証局が証明書を発行する意図を示しています。この意図は拘束力があると見なされます（つまり、事前証明書の発行が最終的な証明書の発行と同じであると見なされます）。各ログは、事前証明書の署名チェーンを検証し、対応するTBSCertificateに署名済み証明書のタイムスタンプを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Logs MUST verify that the submitted end-entity certificate or Precertificate has a valid signature chain leading back to a trusted root CA certificate, using the chain of intermediate CA certificates provided by the submitter. Logs MAY accept certificates that have expired, are not yet valid, have been revoked, or are otherwise not fully valid according to X.509 verification rules in order to accommodate quirks of CA certificate-issuing software. However, logs MUST refuse to publish certificates without a valid chain to a known root CA. If a certificate is accepted and an SCT issued, the accepting log MUST store the entire chain used for verification, including the certificate or Precertificate itself and including the root certificate used to verify the chain (even if it was omitted from the submission), and MUST present this chain for auditing upon request. This chain is required to prevent a CA from avoiding blame by logging a partial or empty chain. (Note: This effectively excludes self-signed and DANE-based certificates until some mechanism to control spam for those certificates is found. The authors welcome suggestions.) Each certificate entry in a log MUST include the following components:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ログは、提出されたエンドエンティティ証明書または事前証明書が、提出者によって提供された中間CA証明書のチェーンを使用して、信頼されたルートCA証明書につながる有効な署名チェーンを持っていることを確認する必要があります。ログは、CA証明書発行ソフトウェアの癖に対応するために、有効期限が切れている、まだ有効ではない、取り消されている、またはX.509検証ルールに従って完全に有効ではない証明書を受け入れる場合があります。ただし、ログは既知のルートCAへの有効なチェーンがない証明書の公開を拒否する必要があります。証明書が受け入れられ、SCTが発行された場合、受け入れログには、証明書または事前証明書自体、およびチェーンの検証に使用されたルート証明書（提出から省略された場合でも）を含む、検証に使用されたチェーン全体を格納する必要があります。リクエストに応じて、監査のためにこのチェーンを提示する必要があります。このチェーンは、CAが部分的または空のチェーンをログに記録して責任を回避しないようにするために必要です。 （注：自己署名証明書とDANEベースの証明書は、それらの証明書のスパムを制御するメカニズムが見つかるまで事実上除外されます。作成者は提案を歓迎します。）ログの各証明書エントリには、次のコンポーネントを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { x509_entry(0), precert_entry(1), (65535) } LogEntryType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           LogEntryType entry_type;
           select (entry_type) {
               case x509_entry: X509ChainEntry;
               case precert_entry: PrecertChainEntry;
           } entry;
       } LogEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       opaque ASN.1Cert&lt;1..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ASN.1Cert leaf_certificate;
           ASN.1Cert certificate_chain&lt;0..2^24-1&gt;;
       } X509ChainEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ASN.1Cert pre_certificate;
           ASN.1Cert precertificate_chain&lt;0..2^24-1&gt;;
       } PrecertChainEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Logs MAY limit the length of chain they will accept.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログは、受け入れるチェーンの長さを制限する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;entry_type&#34; is the type of this entry. Future revisions of this protocol version may add new LogEntryType values. Section 4 explains how clients should handle unknown entry types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「entry_type」はこのエントリのタイプです。このプロトコルバージョンの将来のリビジョンでは、新しいLogEntryType値が追加される可能性があります。セクション4では、クライアントが不明なエントリタイプを処理する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;leaf_certificate&#34; is the end-entity certificate submitted for auditing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「leaf_certificate」は、監査のために送信されたエンドエンティティ証明書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;certificate_chain&#34; is a chain of additional certificates required to verify the end-entity certificate. The first certificate MUST certify the end-entity certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「certificate_chain」は、エンドエンティティ証明書を検証するために必要な追加の証明書のチェーンです。最初の証明書は、エンドエンティティ証明書を証明する必要があります。次の各証明書は、その前の証明書を直接証明する必要があります。最終的な証明書は、ログによって受け入れられたルート証明書でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;pre_certificate&#34; is the Precertificate submitted for auditing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「pre_certificate」は、監査のために提出された事前証明書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;precertificate_chain&#34; is a chain of additional certificates required to verify the Precertificate submission. The first certificate MAY be a valid Precertificate Signing Certificate and MUST certify the first certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「precertificate_chain」は、Precertificate送信を検証するために必要な追加の証明書のチェーンです。最初の証明書は有効な事前証明書署名証明書である場合があり、最初の証明書を認証する必要があります。次の各証明書は、その前の証明書を直接証明する必要があります。最終的な証明書は、ログによって受け入れられたルート証明書でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Structure of the Signed Certificate Timestamp
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 署名付き証明書のタイムスタンプの構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { certificate_timestamp(0), tree_hash(1), (255) }
         SignatureType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { v1(0), (255) }
         Version;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
             opaque key_id[32];
         } LogID;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         opaque TBSCertificate&lt;1..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           opaque issuer_key_hash[32];
           TBSCertificate tbs_certificate;
         } PreCert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         opaque CtExtensions&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;key_id&#34; is the SHA-256 hash of the log&#39;s public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「key_id」は、SubjectPublicKeyInfoとして表される鍵のDERエンコードで計算された、ログの公開鍵のSHA-256ハッシュです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;issuer_key_hash&#34; is the SHA-256 hash of the certificate issuer&#39;s public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo. This is needed to bind the issuer to the final certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「issuer_key_hash」は、証明書発行者の公開鍵のSHA-256ハッシュであり、SubjectPublicKeyInfoとして表される鍵のDERエンコーディングで計算されます。これは、発行者を最終的な証明書にバインドするために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;tbs_certificate&#34; is the DER-encoded TBSCertificate (see [RFC5280]) component of the Precertificate -- that is, without the signature and the poison extension. If the Precertificate is not signed with the CA certificate that will issue the final certificate, then the TBSCertificate also has its issuer changed to that of the CA that will issue the final certificate. Note that it is also possible to reconstruct this TBSCertificate from the final certificate by extracting the TBSCertificate from it and deleting the SCT extension. Also note that since the TBSCertificate contains an AlgorithmIdentifier that must match both the Precertificate signature algorithm and final certificate signature algorithm, they must be signed with the same algorithm and parameters. If the Precertificate is issued using a Precertificate Signing Certificate and an Authority Key Identifier extension is present in the TBSCertificate, the corresponding extension must also be present in the Precertificate Signing Certificate -- in this case, the TBSCertificate also has its Authority Key Identifier changed to match the final issuer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「tbs_certificate」は、PrecertificateのDERエンコードTBSCertificate（[RFC5280]を参照）コンポーネントです。つまり、署名とポイズン拡張なしです。最終証明書を発行するCA証明書で事前証明書が署名されていない場合、TBSCertificateの発行者も最終証明書を発行するCAの発行者に変更されます。 TBSCertificateを抽出してSCT拡張を削除することにより、最終的な証明書からこのTBSCertificateを再構築することもできます。 TBSCertificateには、Precertificate署名アルゴリズムと最終証明書署名アルゴリズムの両方と一致する必要があるAlgorithmIdentifierが含まれているため、同じアルゴリズムとパラメーターで署名する必要があることにも注意してください。 PrecertificateがPrecertificate Signing Certificateを使用して発行され、Authority Key IdentifierエクステンションがTBSCertificateに存在する場合、対応するエクステンションもPrecertificate Signing Certificateに存在する必要があります。この場合、TBSCertificateのオーソリティキー識別子も次のように変更されます。最終的な発行者と一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           Version sct_version;
           LogID id;
           uint64 timestamp;
           CtExtensions extensions;
           digitally-signed struct {
               Version sct_version;
               SignatureType signature_type = certificate_timestamp;
               uint64 timestamp;
               LogEntryType entry_type;
               select(entry_type) {
                   case x509_entry: ASN.1Cert;
                   case precert_entry: PreCert;
               } signed_entry;
              CtExtensions extensions;
           };
       } SignedCertificateTimestamp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encoding of the digitally-signed element is defined in [RFC5246].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デジタル署名された要素のエンコーディングは[RFC5246]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;sct_version&#34; is the version of the protocol to which the SCT conforms. This version is v1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「sct_version」は、SCTが準拠するプロトコルのバージョンです。このバージョンはv1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;timestamp&#34; is the current NTP Time [RFC5905], measured since the epoch (January 1, 1970, 00:00), ignoring leap seconds, in milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;timestamp&#34;は、うるう秒を無視して、エポック（1970年1月1日、00：00）以降に測定された現在のNTP時間[RFC5905]で、ミリ秒単位です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;entry_type&#34; may be implicit from the context in which the SCT is presented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「entry_type」は、SCTが提示されているコンテキストから暗黙的である場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;signed_entry&#34; is the &#34;leaf_certificate&#34; (in the case of an X509ChainEntry) or is the PreCert (in the case of a PrecertChainEntry), as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、「signed_entry」は「leaf_certificate」（X509ChainEntryの場合）またはPreCert（PrecertChainEntryの場合）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;extensions&#34; are future extensions to this protocol version (v1). Currently, no extensions are specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「拡張機能」は、このプロトコルバージョン（v1）の将来の拡張機能です。現在、拡張子は指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Including the Signed Certificate Timestamp in the TLS Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. TLSハンドシェイクに署名済み証明書のタイムスタンプを含める
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The SCT data corresponding to the end-entity certificate from at least one log must be included in the TLS handshake, either by using an X509v3 certificate extension as described below, by using a TLS extension (Section 7.4.1.4 of [RFC5246]) with type &#34;signed_certificate_timestamp&#34;, or by using Online Certificate Status Protocol (OCSP) Stapling (also known as the &#34;Certificate Status Request&#34; TLS extension; see [RFC6066]), where the response includes an OCSP extension with OID 1.3.6.1.4.1.11129.2.4.5 (see [RFC2560]) and body:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
少なくとも1つのログからのエンドエンティティ証明書に対応するSCTデータは、以下で説明するX509v3証明書拡張を使用するか、TLS拡張（[RFC5246]のセクション7.4.1.4）を使用して、TLSハンドシェイクに含める必要があります。 「signed_certificate_timestamp」と入力するか、オンライン証明書ステータスプロトコル（OCSP）ステイプル（「証明書ステータス要求」TLS拡張とも呼ばれます。[RFC6066]を参照）を使用して、応答にOID 1.3.6.1.4.1のOCSP拡張を含めます。 11129.2.4.5（[RFC2560]を参照）および本文：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       SignedCertificateTimestampList ::= OCTET STRING
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At least one SCT MUST be included. Server operators MAY include more than one SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも1つのSCTを含める必要があります。サーバーオペレーターは複数のSCTを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, a certificate authority MAY submit a Precertificate to more than one log, and all obtained SCTs can be directly embedded in the final certificate, by encoding the SignedCertificateTimestampList structure as an ASN.1 OCTET STRING and inserting the resulting data in the TBSCertificate as an X.509v3 certificate extension (OID 1.3.6.1.4.1.11129.2.4.2). Upon receiving the certificate, clients can reconstruct the original TBSCertificate to verify the SCT signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、認証局はPrecertificateを複数のログに送信できます。SignedCertificateTimestampList構造をASN.1 OCTET STRINGとしてエンコードし、結果のデータをTBSCertificateに挿入することにより、取得したすべてのSCTを最終的な証明書に直接埋め込むことができますX.509v3証明書拡張（OID 1.3.6.1.4.1.11129.2.4.2）。証明書を受け取ると、クライアントは元のTBSCertificateを再構築してSCT署名を検証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the ASN.1 OCTET STRING embedded in an OCSP extension or X509v3 certificate extension are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OCSP拡張またはX509v3証明書拡張に埋め込まれたASN.1 OCTET STRINGの内容は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        opaque SerializedSCT&lt;1..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
            SerializedSCT sct_list &lt;1..2^16-1&gt;;
        } SignedCertificateTimestampList;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, &#34;SerializedSCT&#34; is an opaque byte string that contains the serialized TLS structure. This encoding ensures that TLS clients can decode each SCT individually (i.e., if there is a version upgrade, out-of-date clients can still parse old SCTs while skipping over new SCTs whose versions they don&#39;t understand).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、「SerializedSCT」は、シリアル化されたTLS構造を含む不透明なバイト文字列です。このエンコーディングにより、TLSクライアントは各SCTを個別にデコードできます（つまり、バージョンのアップグレードがある場合、古いクライアントは古いSCTを解析しながら、バージョンがわからない新しいSCTをスキップできます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Likewise, SCTs can be embedded in a TLS extension. See below for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、SCTはTLS拡張に埋め込むことができます。詳細については、以下を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS clients MUST implement all three mechanisms. Servers MUST implement at least one of the three mechanisms. Note that existing TLS servers can generally use the certificate extension mechanism without modification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSクライアントは、3つのメカニズムすべてを実装する必要があります。サーバーは、3つのメカニズムのうち少なくとも1つを実装する必要があります。既存のTLSサーバーは通常、変更なしで証明書拡張メカニズムを使用できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS servers should send SCTs from multiple logs in case one or more logs are not acceptable to the client (for example, if a log has been struck off for misbehavior or has had a key compromise).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSサーバーは、1つ以上のログがクライアントに受け入れられない場合（たとえば、動作不良のためにログが打ち消されたり、キーが侵害されたりした場合）、複数のログからSCTを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. TLS Extension
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. TLS拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SCT can be sent during the TLS handshake using a TLS extension with type &#34;signed_certificate_timestamp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCTは、「signed_certificate_timestamp」タイプのTLS拡張を使用して、TLSハンドシェイク中に送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients that support the extension SHOULD send a ClientHello extension with the appropriate type and empty &#34;extension_data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張をサポートするクライアントは、適切なタイプと空の「extension_data」を含むClientHello拡張を送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers MUST only send SCTs to clients who have indicated support for the extension in the ClientHello, in which case the SCTs are sent by setting the &#34;extension_data&#34; to a &#34;SignedCertificateTimestampList&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ClientHelloで拡張機能のサポートを示しているクライアントにのみSCTを送信する必要があります。その場合、SCTは、「extension_data」を「SignedCertificateTimestampList」に設定することによって送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Session resumption uses the original session information: clients SHOULD include the extension type in the ClientHello, but if the session is resumed, the server is not expected to process it or include the extension in the ServerHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの再開は元のセッション情報を使用します。クライアントはClientHelloに拡張タイプを含める必要がありますが、セッションが再開された場合、サーバーはそれを処理したり、ServerHelloに拡張を含めたりすることは想定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Merkle Tree
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. マークルツリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hashing algorithm for the Merkle Tree Hash is SHA-256.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークルツリーハッシュのハッシュアルゴリズムはSHA-256です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of the Merkle Tree input:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークルツリー入力の構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { timestamped_entry(0), (255) }
         MerkleLeafType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           uint64 timestamp;
           LogEntryType entry_type;
           select(entry_type) {
               case x509_entry: ASN.1Cert;
               case precert_entry: PreCert;
           } signed_entry;
           CtExtensions extensions;
       } TimestampedEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           Version version;
           MerkleLeafType leaf_type;
           select (leaf_type) {
               case timestamped_entry: TimestampedEntry;
           }
       } MerkleTreeLeaf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, &#34;version&#34; is the version of the protocol to which the MerkleTreeLeaf corresponds. This version is v1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、「バージョン」は、MerkleTreeLeafが対応するプロトコルのバージョンです。このバージョンはv1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;leaf_type&#34; is the type of the leaf input. Currently, only &#34;timestamped_entry&#34; (corresponding to an SCT) is defined. Future revisions of this protocol version may add new MerkleLeafType types. Section 4 explains how clients should handle unknown leaf types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「leaf_type」はリーフ入力のタイプです。現在、 &#34;timestamped_entry&#34;（SCTに対応）のみが定義されています。このプロトコルバージョンの将来のリビジョンでは、新しいMerkleLeafTypeタイプが追加される可能性があります。セクション4では、クライアントが不明なリーフタイプを処理する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;timestamp&#34; is the timestamp of the corresponding SCT issued for this certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「timestamp」は、この証明書に対して発行された対応するSCTのタイムスタンプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;signed_entry&#34; is the &#34;signed_entry&#34; of the corresponding SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「signed_entry」は、対応するACTの「signed_entry」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;extensions&#34; are &#34;extensions&#34; of the corresponding SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「拡張子」は、対応するACTの「拡張子」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The leaves of the Merkle Tree are the leaf hashes of the corresponding &#34;MerkleTreeLeaf&#34; structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークルツリーの葉は、対応する「MerkleTreeLeaf」構造のリーフハッシュです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Signed Tree Head
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 署名された木の頭
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every time a log appends new entries to the tree, the log SHOULD sign the corresponding tree hash and tree information (see the corresponding Signed Tree Head client message in Section 4.3). The signature for that data is structured as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログがツリーに新しいエントリを追加するたびに、ログは対応するツリーハッシュとツリー情報に署名する必要があります（セクション4.3の対応する署名付きツリーヘッドクライアントメッセージを参照）。そのデータの署名は次のように構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       digitally-signed struct {
           Version version;
           SignatureType signature_type = tree_hash;
           uint64 timestamp;
           uint64 tree_size;
           opaque sha256_root_hash[32];
       } TreeHeadSignature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;version&#34; is the version of the protocol to which the TreeHeadSignature conforms. This version is v1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「バージョン」は、TreeHeadSignatureが準拠するプロトコルのバージョンです。このバージョンはv1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;timestamp&#34; is the current time. The timestamp MUST be at least as recent as the most recent SCT timestamp in the tree. Each subsequent timestamp MUST be more recent than the timestamp of the previous update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「timestamp」は現在の時刻です。タイムスタンプは、ツリー内の最新のSCTタイムスタンプと少なくとも同じでなければなりません。後続の各タイムスタンプは、前の更新のタイムスタンプよりも新しいものである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;tree_size&#34; equals the number of entries in the new tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「tree_size」は、新しいツリーのエントリ数と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;sha256_root_hash&#34; is the root of the Merkle Hash Tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「sha256_root_hash」は、マークルハッシュツリーのルートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each log MUST produce on demand a Signed Tree Head that is no older than the Maximum Merge Delay. In the unlikely event that it receives no new submissions during an MMD period, the log SHALL sign the same Merkle Tree Hash with a fresh timestamp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ログは、最大マージ遅延よりも古い署名済みツリーヘッドをオンデマンドで生成する必要があります。 MMD期間中に新しいサブミッションを受信しないというまれなイベントでは、ログは同じマークルツリーハッシュに新しいタイムスタンプで署名する必要があります（SHALL）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Log Client Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. クライアントメッセージのログ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Messages are sent as HTTPS GET or POST requests. Parameters for POSTs and all responses are encoded as JavaScript Object Notation (JSON) objects [RFC4627]. Parameters for GETs are encoded as order-independent key/value URL parameters, using the &#34;application/ x-www-form-urlencoded&#34; format described in the &#34;HTML 4.01 Specification&#34; [HTML401]. Binary data is base64 encoded [RFC4648] as specified in the individual messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージはHTTPS GETまたはPOST要求として送信されます。 POSTおよびすべての応答のパラメーターは、JavaScript Object Notation（JSON）オブジェクト[RFC4627]としてエンコードされます。 GETのパラメーターは、「HTML 4.01仕様」[HTML401]で説明されている「application / x-www-form-urlencoded」形式を使用して、順序に依存しないキー/値URLパラメーターとしてエンコードされます。バイナリデータは、個々のメッセージで指定されているようにbase64エンコード[RFC4648]されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that JSON objects and URL parameters may contain fields not specified here. These extra fields should be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSONオブジェクトとURLパラメータには、ここで指定されていないフィールドが含まれる場合があることに注意してください。これらの余分なフィールドは無視してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &lt;log server&gt; prefix can include a path as well as a server name and a port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;log server&gt;プレフィックスには、パス、サーバー名、ポートを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, where needed, the &#34;version&#34; is v1 and the &#34;id&#34; is the log id for the log server queried.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、必要な場合、「バージョン」はv1であり、「id」は照会されたログサーバーのログIDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any errors will be returned as HTTP 4xx or 5xx responses, with human-readable error messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーはHTTP 4xxまたは5xx応答として返され、人間が読めるエラーメッセージが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Add Chain to Log
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. ログにチェーンを追加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   POST https://&lt;log server&gt;/ct/v1/add-chain
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
chain: An array of base64-encoded certificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
chain：base64でエンコードされた証明書の配列。最初の要素はエンドエンティティ証明書です。 2番目は最初のチェーンに続き、最後も同様です。これは、ルート証明書、または既知のルート証明書にチェーンする証明書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
sct_version: The version of the SignedCertificateTimestamp structure, in decimal. A compliant v1 implementation MUST NOT expect this to be 0 (i.e., v1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
sct_version：10進数のSignedCertificateTimestamp構造のバージョン。準拠するv1実装では、これが0であることを期待してはなりません（つまり、v1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
id: The log ID, base64 encoded. Since log clients who request an SCT for inclusion in TLS handshakes are not required to verify it, we do not assume they know the ID of the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
id：base64でエンコードされたログID。 TLSハンドシェイクに含めるためにSCTを要求するログクライアントは検証する必要がないため、ログのIDを知っているとは限りません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
timestamp: The SCT timestamp, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
timestamp：SCTタイムスタンプ（10進数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
extensions: An opaque type for future expansion. It is likely that not all participants will need to understand data in this field. Logs should set this to the empty string. Clients should decode the base64-encoded data and include it in the SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
extensions：将来の拡張のための不透明なタイプ。すべての参加者がこのフィールドのデータを理解する必要があるとは限りません。ログでは、これを空の文字列に設定する必要があります。クライアントは、base64でエンコードされたデータをデコードし、SCTに含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
signature: The SCT signature, base64 encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
signature：base64でエンコードされたSCT署名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the &#34;sct_version&#34; is not v1, then a v1 client may be unable to verify the signature. It MUST NOT construe this as an error. (Note: Log clients don&#39;t need to be able to verify this structure; only TLS clients do. If we were to serve the structure as a binary blob, then we could completely change it without requiring an upgrade to v1 clients.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「sct_version」がv1でない場合、v1クライアントは署名を検証できない可能性があります。これをエラーとして解釈してはなりません。 （注：ログクライアントはこの構造を検証できる必要はありません。TLSクライアントのみが可能です。構造をバイナリBLOBとして提供する場合は、v1クライアントにアップグレードする必要なく完全に変更できます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Add PreCertChain to Log
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. PreCertChainをログに追加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   POST https://&lt;log server&gt;/ct/v1/add-pre-chain
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
chain: An array of base64-encoded Precertificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
chain：base64でエンコードされた事前証明書の配列。最初の要素はエンドエンティティ証明書です。 2番目は最初のチェーンに続き、最後も同様です。これは、ルート証明書、または既知のルート証明書にチェーンする証明書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outputs are the same as in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力はセクション4.1と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Retrieve Latest Signed Tree Head
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 最新の署名付きツリーヘッドを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET https://&lt;log server&gt;/ct/v1/get-sth
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No inputs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力なし。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tree_size: The size of the tree, in entries, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tree_size：ツリーのサイズ（エントリ数、10進数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
timestamp: The timestamp, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
timestamp：10進数のタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
sha256_root_hash: The Merkle Tree Hash of the tree, in base64.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
sha256_root_hash：base64でのツリーのマークルツリーハッシュ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tree_head_signature: A TreeHeadSignature for the above data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tree_head_signature：上記のデータのTreeHeadSignature。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Retrieve Merkle Consistency Proof between Two Signed Tree Heads
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 2つの署名されたツリーヘッド間のマークル整合性証明を取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET https://&lt;log server&gt;/ct/v1/get-sth-consistency
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
first: The tree_size of the first tree, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
first：最初のツリーのtree_size（10進数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
second: The tree_size of the second tree, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
second：2番目のツリーのtree_size（10進数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both tree sizes must be from existing v1 STHs (Signed Tree Heads).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらのツリーサイズも、既存のv1 STH（Signed Tree Heads）からのものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
consistency: An array of Merkle Tree nodes, base64 encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
一貫性：base64エンコードされたマークルツリーノードの配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that no signature is required on this data, as it is used to verify an STH, which is signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータは署名されたSTHを検証するために使用されるため、このデータに署名は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Retrieve Merkle Audit Proof from Log by Leaf Hash
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. リーフハッシュによるログからのマークル監査証明の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET https://&lt;log server&gt;/ct/v1/get-proof-by-hash
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
hash: A base64-encoded v1 leaf hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
hash：base64でエンコードされたv1リーフハッシュ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tree_size: The tree_size of the tree on which to base the proof, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tree_size：証明の基となるツリーのtree_size（10進数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;hash&#34; must be calculated as defined in Section 3.4. The &#34;tree_size&#34; must designate an existing v1 STH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ハッシュ」は、セクション3.4の定義に従って計算する必要があります。 「tree_size」は、既存のv1 STHを指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
leaf_index: The 0-based index of the end entity corresponding to the &#34;hash&#34; parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
leaf_index：「ハッシュ」パラメーターに対応するエンドエンティティの0ベースのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
audit_path: An array of base64-encoded Merkle Tree nodes proving the inclusion of the chosen certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
audit_path：選択した証明書が含まれていることを証明するbase64でエンコードされたマークルツリーノードの配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Retrieve Entries from Log
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. ログからエントリを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET https://&lt;log server&gt;/ct/v1/get-entries
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
start: 0-based index of first entry to retrieve, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
start：取得する最初のエントリの0ベースのインデックス（10進数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
end: 0-based index of last entry to retrieve, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
end：取得する最後のエントリの0ベースのインデックス（10進数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
entries: An array of objects, each consisting of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エントリ：オブジェクトの配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
leaf_input: The base64-encoded MerkleTreeLeaf structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
leaf_input：base64でエンコードされたMerkleTreeLeaf構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
extra_data: The base64-encoded unsigned data pertaining to the log entry. In the case of an X509ChainEntry, this is the &#34;certificate_chain&#34;. In the case of a PrecertChainEntry, this is the whole &#34;PrecertChainEntry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
extra_data：ログエントリに関連するbase64でエンコードされた符号なしデータ。 X509ChainEntryの場合、これは「certificate_chain」です。 PrecertChainEntryの場合、これは「PrecertChainEntry」全体です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this message is not signed -- the retrieved data can be verified by constructing the Merkle Tree Hash corresponding to a retrieved STH. All leaves MUST be v1. However, a compliant v1 client MUST NOT construe an unrecognized MerkleLeafType or LogEntryType value as an error. This means it may be unable to parse some entries, but note that each client can inspect the entries it does recognize as well as verify the integrity of the data by treating unrecognized leaves as opaque input to the tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージは署名されていないことに注意してください。取得したデータは、取得したSTHに対応するマークルツリーハッシュを作成することで確認できます。すべての葉はv1でなければなりません。ただし、準拠するv1クライアントは、認識されないMerkleLeafTypeまたはLogEntryType値をエラーとして解釈してはなりません（MUST NOT）。これは、一部のエントリを解析できない可能性があることを意味しますが、各クライアントは、認識しないエントリを検査し、認識されていない葉をツリーへの不透明な入力として扱うことにより、データの整合性を検証できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;start&#34; and &#34;end&#34; parameters SHOULD be within the range 0 &lt;= x &lt; &#34;tree_size&#34; as returned by &#34;get-sth&#34; in Section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「start」および「end」パラメータは、セクション4.3の「get-sth」で返される0 &lt;= x &lt;「tree_size」の範囲内にある必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Logs MAY honor requests where 0 &lt;= &#34;start&#34; &lt; &#34;tree_size&#34; and &#34;end&#34; &gt;= &#34;tree_size&#34; by returning a partial response covering only the valid entries in the specified range. Note that the following restriction may also apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログは、0 &lt;= &#34;start&#34; &lt;&#34;tree_size&#34;および &#34;end&#34;&gt; = &#34;tree_size&#34;であるリクエストを尊重しても、指定された範囲内の有効なエントリのみをカバーする部分的な応答を返す場合があります。次の制限も適用される場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Logs MAY restrict the number of entries that can be retrieved per &#34;get-entries&#34; request. If a client requests more than the permitted number of entries, the log SHALL return the maximum number of entries permissible. These entries SHALL be sequential beginning with the entry specified by &#34;start&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログは、「get-entries」リクエストごとに取得できるエントリの数を制限する場合があります。クライアントが許可された数よりも多くのエントリを要求した場合、ログは許容されるエントリの最大数を返す必要があります（SHALL）。これらのエントリは、 &#34;start&#34;で指定されたエントリから始まるシーケンシャルである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. Retrieve Accepted Root Certificates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 承認されたルート証明書を取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET https://&lt;log server&gt;/ct/v1/get-roots
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No inputs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力なし。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
certificates: An array of base64-encoded root certificates that are acceptable to the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
証明書：ログに受け入れ可能なbase64でエンコードされたルート証明書の配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. Retrieve Entry+Merkle Audit Proof from Log
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. ログからエントリ+マークル監査証明を取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   GET https://&lt;log server&gt;/ct/v1/get-entry-and-proof
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
leaf_index: The index of the desired entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
leaf_index：目的のエントリのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tree_size: The tree_size of the tree for which the proof is desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tree_size：証明が必要なツリーのtree_size。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The tree size must designate an existing STH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ツリーのサイズは、既存のSTHを指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
leaf_input: The base64-encoded MerkleTreeLeaf structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
leaf_input：base64でエンコードされたMerkleTreeLeaf構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
extra_data: The base64-encoded unsigned data, same as in Section 4.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
extra_data：4.6と同じ、base64でエンコードされた符号なしデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
audit_path: An array of base64-encoded Merkle Tree nodes proving the inclusion of the chosen certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
audit_path：選択した証明書が含まれていることを証明するbase64でエンコードされたマークルツリーノードの配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This API is probably only useful for debugging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このAPIはおそらくデバッグにのみ役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. クライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are various different functions clients of logs might perform. We describe here some typical clients and how they could function. Any inconsistency may be used as evidence that a log has not behaved correctly, and the signatures on the data structures prevent the log from denying that misbehavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログのクライアントが実行するさまざまな機能があります。ここでは、いくつかの典型的なクライアントとその機能について説明します。不整合があれば、ログが正しく動作しなかった証拠として使用できます。データ構造の署名により、ログがその不正動作を否定できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All clients should gossip with each other, exchanging STHs at least; this is all that is required to ensure that they all have a consistent view. The exact mechanism for gossip will be described in a separate document, but it is expected there will be a variety.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのクライアントは、少なくともSTHを交換しながら、互いにゴシップする必要があります。これらすべてが一貫したビューを持つようにするために必要なことはこれだけです。ゴシップの正確なメカニズムは別のドキュメントで説明されますが、さまざまなものが存在すると予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Submitters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 提出者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Submitters submit certificates or Precertificates to the log as described above. They may go on to use the returned SCT to construct a certificate or use it directly in a TLS handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、上記のように証明書または事前証明書をログに送信します。返されたSCTを使用して証明書を作成するか、TLSハンドシェイクで直接使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. TLS Client
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. TLSクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS clients are not directly clients of the log, but they receive SCTs alongside or in server certificates. In addition to normal validation of the certificate and its chain, they should validate the SCT by computing the signature input from the SCT data as well as the certificate and verifying the signature, using the corresponding log&#39;s public key. Note that this document does not describe how clients obtain the logs&#39; public keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSクライアントは直接ログのクライアントではありませんが、サーバー証明書と一緒に、またはサーバー証明書でSCTを受け取ります。証明書とそのチェーンの通常の検証に加えて、SCTデータと証明書から入力された署名を計算し、対応するログの公開鍵を使用して署名を検証することにより、SCTを検証する必要があります。このドキュメントでは、クライアントがログの公開鍵を取得する方法については説明していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS clients MUST reject SCTs whose timestamp is in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSクライアントは、タイムスタンプが将来のSCTを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Monitor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. モニター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Monitors watch logs and check that they behave correctly. They also watch for certificates of interest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モニターはログを監視し、正しく動作することを確認します。彼らはまた、関心のある証明書を監視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A monitor needs to, at least, inspect every new entry in each log it watches. It may also want to keep copies of entire logs. In order to do this, it should follow these steps for each log:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モニターは、少なくとも、監視する各ログのすべての新しいエントリを検査する必要があります。また、ログ全体のコピーを保持することもできます。これを行うには、ログごとに次の手順を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Fetch the current STH (Section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 現在のSTHをフェッチします（セクション4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Verify the STH signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. STH署名を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Fetch all the entries in the tree corresponding to the STH (Section 4.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. STHに対応するツリー内のすべてのエントリをフェッチします（セクション4.6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Confirm that the tree made from the fetched entries produces the same hash as that in the STH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 取得したエントリから作成されたツリーがSTHと同じハッシュを生成することを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Fetch the current STH (Section 4.3). Repeat until the STH changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 現在のSTHをフェッチします（セクション4.3）。 STHが変化するまで繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Verify the STH signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. STH署名を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Fetch all the new entries in the tree corresponding to the STH (Section 4.6). If they remain unavailable for an extended period, then this should be viewed as misbehavior on the part of the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. STHに対応するツリー内のすべての新しいエントリをフェッチします（セクション4.6）。それらが長期間使用できないままの場合、これはログの一部での不正な動作と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. どちらか：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. Verify that the updated list of all entries generates a tree with the same hash as the new STH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. すべてのエントリの更新されたリストが、新しいSTHと同じハッシュを持つツリーを生成することを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Or, if it is not keeping all log entries:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
または、すべてのログエントリが保持されていない場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. Fetch a consistency proof for the new STH with the previous STH (Section 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. 以前のSTHとの新しいSTHの一貫性の証明をフェッチします（セクション4.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. Verify the consistency proof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. 整合性の証明を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
4. Verify that the new entries generate the corresponding elements in the consistency proof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
4. 新しいエントリが整合性証明の対応する要素を生成することを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Go to Step 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. 手順5に進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Auditor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 監査人
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Auditors take partial information about a log as input and verify that this information is consistent with other partial information they have. An auditor might be an integral component of a TLS client; it might be a standalone service; or it might be a secondary function of a monitor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
監査人はログに関する部分的な情報を入力として受け取り、この情報が他の部分的な情報と一致していることを確認します。監査人はTLSクライアントの不可欠なコンポーネントかもしれません。スタンドアロンサービスの可能性があります。またはそれはモニターの二次機能かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any pair of STHs from the same log can be verified by requesting a consistency proof (Section 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じログからのSTHのペアは、一貫性の証明を要求することで検証できます（セクション4.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A certificate accompanied by an SCT can be verified against any STH dated after the SCT timestamp + the Maximum Merge Delay by requesting a Merkle audit proof (Section 4.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCTに付随する証明書は、マークル監査証明（セクション4.5）を要求することにより、SCTタイムスタンプ+最大マージ遅延より後の日付のSTHに対して検証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Auditors can fetch STHs from time to time of their own accord, of course (Section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もちろん、監査人はSTHを随時取得することができます（セクション4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has allocated an RFC 5246 ExtensionType value (18) for the SCT TLS extension. The extension name is &#34;signed_certificate_timestamp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAはSCT TLS拡張にRFC 5246 ExtensionType値（18）を割り当てました。拡張名は「signed_certificate_timestamp」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 With CAs, logs, and servers performing the actions described here, TLS clients can use logs and signed timestamps to reduce the likelihood that they will accept misissued certificates. If a server presents a valid signed timestamp for a certificate, then the client knows that the certificate has been published in a log. From this, the client knows that the subject of the certificate has had some time to notice the misissue and take some action, such as asking a CA to revoke a misissued certificate. A signed timestamp is not a guarantee that the certificate is not misissued, since the subject of the certificate might not have checked the logs or the CA might have refused to revoke the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ここで説明するアクションを実行するCA、ログ、サーバーでは、TLSクライアントはログと署名付きタイムスタンプを使用して、誤って発行された証明書を受け入れる可能性を減らすことができます。サーバーが証明書の有効な署名付きタイムスタンプを提示すると、クライアントは証明書がログに公開されたことを認識します。これにより、クライアントは、証明書のサブジェクトが誤発行に気付き、CAに誤って発行された証明書の取り消しを要求するなどのアクションを実行する時間があったことを知っています。証明書のサブジェクトがログをチェックしていないか、CAが証明書の取り消しを拒否している可能性があるため、署名付きタイムスタンプは、証明書が誤って発行されないことを保証するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, if TLS clients will not accept unlogged certificates, then site owners will have a greater incentive to submit certificates to logs, possibly with the assistance of their CA, increasing the overall transparency of the system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、TLSクライアントがログに記録されていない証明書を受け入れない場合、サイト所有者は、おそらくCAの支援により、ログに証明書を送信するインセンティブが高くなり、システムの全体的な透明性が向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Misissued Certificates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 誤って発行された証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Misissued certificates that have not been publicly logged, and thus do not have a valid SCT, will be rejected by TLS clients. Misissued certificates that do have an SCT from a log will appear in that public log within the Maximum Merge Delay, assuming the log is operating correctly. Thus, the maximum period of time during which a misissued certificate can be used without being available for audit is the MMD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開ログに記録されておらず、したがって有効なSCTを持たない、誤って発行された証明書は、TLSクライアントによって拒否されます。ログが正しく動作している場合、ログからSCTが発行された誤って発行された証明書は、最大マージ遅延内にそのパブリックログに表示されます。したがって、誤って発行された証明書を監査に利用できない状態で使用できる最大期間はMMDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Detection of Misissue
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 問題の検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The logs do not themselves detect misissued certificates; they rely instead on interested parties, such as domain owners, to monitor them and take corrective action when a misissue is detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログ自体は、誤って発行された証明書を検出しません。代わりに、ドメイン所有者などの関係者に監視を依頼し、問題が検出された場合は是正措置を講じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Misbehaving Logs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 不正なログ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A log can misbehave in two ways: (1) by failing to incorporate a certificate with an SCT in the Merkle Tree within the MMD and (2) by violating its append-only property by presenting two different, conflicting views of the Merkle Tree at different times and/or to different parties. Both forms of violation will be promptly and publicly detectable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログは2つの方法で誤動作する可能性があります：（1）証明書をSCTでMMD内のマークルツリーに組み込むことに失敗した場合、および（2）マークアップツリーの2つの異なる競合するビューを表示して、追加のみのプロパティに違反した場合異なる時間および/または異なるパーティーに。違反の両方の形式は、迅速かつ公的に検出可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Violation of the MMD contract is detected by log clients requesting a Merkle audit proof for each observed SCT. These checks can be asynchronous and need only be done once per each certificate. In order to protect the clients&#39; privacy, these checks need not reveal the exact certificate to the log. Clients can instead request the proof from a trusted auditor (since anyone can compute the audit proofs from the log) or request Merkle proofs for a batch of certificates around the SCT timestamp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MMD契約の違反は、観察されたSCTごとにマークル監査証明を要求するログクライアントによって検出されます。これらのチェックは非同期にすることができ、証明書ごとに1回だけ実行する必要があります。クライアントのプライバシーを保護するために、これらのチェックは正確な証明書をログに公開する必要はありません。代わりに、クライアントは信頼できる監査人に証明を要求するか（だれでもログから監査証明を計算できるため）、SCTタイムスタンプに関連する証明書のバッチに対するマークル証明を要求できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Violation of the append-only property is detected by global gossiping, i.e., everyone auditing logs comparing their versions of the latest Signed Tree Heads. As soon as two conflicting Signed Tree Heads for the same log are detected, this is cryptographic proof of that log&#39;s misbehavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
追加専用プロパティの違反は、グローバルゴシップによって検出されます。つまり、すべての監査ログが最新の署名付きツリーヘッドのバージョンを比較しています。同じログに対して2つの競合する署名済みツリーヘッドが検出されるとすぐに、これはそのログの不正な動作の暗号による証明になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Efficiency Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 効率に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Merkle Tree design serves the purpose of keeping communication overhead low.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークルツリーの設計は、通信のオーバーヘッドを低く抑える目的を果たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Auditing logs for integrity does not require third parties to maintain a copy of each entire log. The Signed Tree Heads can be updated as new entries become available, without recomputing entire trees. Third-party auditors need only fetch the Merkle consistency proofs against a log&#39;s existing STH to efficiently verify the append-only property of updates to their Merkle Trees, without auditing the entire tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログの整合性を監査する場合、第三者がログ全体のコピーを保持する必要はありません。署名されたツリーヘッドは、ツリー全体を再計算することなく、新しいエントリが利用可能になったときに更新できます。サードパーティの監査人は、ログ全体の監査を行わずに、ログの既存のSTHに対してマークル一貫性証明をフェッチするだけで、マークルツリーへの更新の追加のみのプロパティを効率的に検証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Future Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 将来の変化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section lists things we might address in a Standards Track version of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、このドキュメントのStandards Trackバージョンで対処する可能性のある事項を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Rather than forcing a log operator to create a new log in order to change the log signing key, we may allow some key roll mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ログ署名キーを変更するためにログオペレーターに新しいログの作成を強制するのではなく、いくつかのキーロールメカニズムを許可する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o We may add hash and signing algorithm agility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ハッシュと署名アルゴリズムの俊敏性を追加できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o We may describe some gossip protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一部のゴシッププロトコルについて説明する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Erwann Abelea, Robin Alden, Al Cutter, Francis Dupont, Stephen Farrell, Brad Hill, Jeff Hodges, Paul Hoffman, Jeffrey Hutzelman, SM, Alexey Melnikov, Chris Palmer, Trevor Perrin, Ryan Sleevi, Rob Stradling, and Carl Wallace for their valuable contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は、Erwann Abelea、Robin Alden、Al Cutter、Francis Dupont、Stephen Farrell、Brad Hill、Jeff Hodges、Paul Hoffman、Jeffrey Hutzelman、SM、Alexey Melnikov、Chris Palmer、Trevor Perrin、Ryan Sleevi、Rob Stradling、貴重な貢献をしてくれたカールウォレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Normative Reference
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. 規範的なリファレンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CrosbyWallach] Crosby, S. and D. Wallach, &#34;Efficient Data Structures for Tamper-Evident Logging&#34;, Proceedings of the 18th USENIX Security Symposium, Montreal, August 2009, &lt;http://static.usenix.org/event/sec09/ tech/full_papers/crosby.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CrosbyWallach] Crosby、S。およびD. Wallach、「改ざん防止のログ記録のための効率的なデータ構造」、第18回USENIXセキュリティシンポジウムの議事録、モントリオール、2009年8月、&lt;http://static.usenix.org/event/sec09 / tech / full_papers / crosby.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS] National Institute of Standards and Technology, &#34;Digital Signature Standard (DSS)&#34;, FIPS 186-3, June 2009, &lt;http://csrc.nist.gov/publications/fips/ fips186-3/fips_186-3.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS]米国国立標準技術研究所、「デジタル署名標準（DSS）」、FIPS 186-3、2009年6月、&lt;http://csrc.nist.gov/publications/fips/ fips186-3 / fips_186-3。 pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS.180-4] National Institute of Standards and Technology, &#34;Secure Hash Standard&#34;, FIPS PUB 180-4, March 2012, &lt;http://csrc.nist.gov/publications/fips/fips180-4/ fips-180-4.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS.180-4]米国国立標準技術研究所、「Secure Hash Standard」、FIPS PUB 180-4、2012年3月、&lt;http://csrc.nist.gov/publications/fips/fips180-4/ fips- 180-4.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTML401] Raggett, D., Le Hors, A., and I. Jacobs, &#34;HTML 4.01 Specification&#34;, World Wide Web Consortium Recommendation REC-html401-19991224, December 1999, &lt;http://www.w3.org/TR/1999/REC-html401-19991224&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTML401] Raggett、D.、Le Hors、A。、およびI. Jacobs、「HTML 4.01 Specification」、World Wide Web Consortium Recommendation REC-html401-19991224、1999年12月、&lt;http://www.w3.org/ TR / 1999 / REC-html401-19991224&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2560] Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, &#34;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&#34;, RFC 2560, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2560]マイヤーズ、M。、アンクニー、R。、マルパニ、A。、ガルペリン、S。、およびC.アダムス、「X.509インターネット公開鍵インフラストラクチャオンライン証明書ステータスプロトコル-OCSP」、RFC 2560、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3447] Jonsson, J. and B. Kaliski, &#34;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1&#34;, RFC 3447, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3447] Jonsson、J。およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA Cryptography Specifications Version 2.1」、RFC 3447、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4627] Crockford, D., &#34;The application/json Media Type for JavaScript Object Notation (JSON)&#34;, RFC 4627, July 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4627] Crockford、D。、「JavaScript Object Notation（JSON）のアプリケーション/ jsonメディアタイプ」、RFC 4627、2006年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson, S., &#34;The Base16, Base32, and Base64 Data Encodings&#34;, RFC 4648, October 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、2006年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 5280, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R。、およびW. Polk、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile &#34;、RFC 5280、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5905] Mills, D., Martin, J., Burbank, J., and W. Kasch, &#34;Network Time Protocol Version 4: Protocol and Algorithms Specification&#34;, RFC 5905, June 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5905] Mills、D.、Martin、J.、Burbank、J。、およびW. Kasch、「Network Time Protocol Version 4：Protocol and Algorithms Specification」、RFC 5905、2010年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6066] Eastlake, D., &#34;Transport Layer Security (TLS) Extensions: Extension Definitions&#34;, RFC 6066, January 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6066] Eastlake、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、2011年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ben Laurie Google UK Ltd.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ben Laurie Google UK Ltd.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: benl@google.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adam Langley Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adam Langley Google Inc.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: agl@google.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Emilia Kasper Google Switzerland GmbH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Emilia Kasper Google Switzerland GmbH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: ekasper@google.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
