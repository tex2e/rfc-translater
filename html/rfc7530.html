<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 7530 - Network File System (NFS) Version 4 Protocol 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7530</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://tools.ietf.org/html/rfc7530">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7530 - Network File System (NFS) Version 4 Protocol 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7530">
              https://tools.ietf.org/html/rfc7530
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7530 - ネットワークファイルシステム（NFS）バージョン4プロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                    T. Haynes, Ed.
Request for Comments: 7530                                  Primary Data
Obsoletes: 3530                                           D. Noveck, Ed.
Category: Standards Track                                           Dell
ISSN: 2070-1721                                               March 2015
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Network File System (NFS) Version 4 Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
ネットワークファイルシステム（NFS）バージョン4プロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Network File System (NFS) version 4 protocol is a distributed file system protocol that builds on the heritage of NFS protocol version 2 (RFC 1094) and version 3 (RFC 1813). Unlike earlier versions, the NFS version 4 protocol supports traditional file access while integrating support for file locking and the MOUNT protocol. In addition, support for strong security (and its negotiation), COMPOUND operations, client caching, and internationalization has been added. Of course, attention has been applied to making NFS version 4 operate well in an Internet environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークファイルシステム（NFS）バージョン4プロトコルは、NFSプロトコルバージョン2（RFC 1094）およびバージョン3（RFC 1813）の遺産を基に構築された分散ファイルシステムプロトコルです。以前のバージョンとは異なり、NFSバージョン4プロトコルは、ファイルロックのサポートとMOUNTプロトコルを統合しながら、従来のファイルアクセスをサポートします。さらに、強力なセキュリティ（およびそのネゴシエーション）、COMPOUND操作、クライアントキャッシング、および国際化のサポートが追加されました。もちろん、NFSバージョン4がインターネット環境で適切に動作するように注意が払われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document, together with the companion External Data Representation (XDR) description document, RFC 7531, obsoletes RFC 3530 as the definition of the NFS version 4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、関連する外部データ表現（XDR）記述ドキュメントであるRFC 7531とともに、NFSバージョン4プロトコルの定義としてRFC 3530を廃止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはInternet Standards Trackドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7530.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7530で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2015 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの素材が含まれている場合があります。この素材の一部の著作権を管理する人は、IETFトラストにそのような素材の変更を許可する権利を付与していない可能性がありますIETF標準プロセス外。このような資料の著作権を管理する人から適切なライセンスを取得しない限り、このドキュメントはIETF標準プロセス外で変更できません。また、その派生物は、IETF標準プロセス外で作成できません。 RFCとして、またはそれを英語以外の言語に翻訳するための出版物。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................8
      1.1. Requirements Language ......................................8
      1.2. NFS Version 4 Goals ........................................8
      1.3. Definitions in the Companion Document RFC 7531 Are
           Authoritative ..............................................9
      1.4. Overview of NFSv4 Features .................................9
           1.4.1. RPC and Security ....................................9
           1.4.2. Procedure and Operation Structure ..................10
           1.4.3. File System Model ..................................10
           1.4.4. OPEN and CLOSE .....................................12
           1.4.5. File Locking .......................................12
           1.4.6. Client Caching and Delegation ......................13
      1.5. General Definitions .......................................14
      1.6. Changes since RFC 3530 ....................................16
      1.7. Changes between RFC 3010 and RFC 3530 .....................16
   2. Protocol Data Types ............................................18
      2.1. Basic Data Types ..........................................18
      2.2. Structured Data Types .....................................21
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   3. RPC and Security Flavor ........................................25
      3.1. Ports and Transports ......................................25
           3.1.1. Client Retransmission Behavior .....................26
      3.2. Security Flavors ..........................................27
           3.2.1. Security Mechanisms for NFSv4 ......................27
      3.3. Security Negotiation ......................................28
           3.3.1. SECINFO ............................................29
           3.3.2. Security Error .....................................29
           3.3.3. Callback RPC Authentication ........................29
   4. Filehandles ....................................................30
      4.1. Obtaining the First Filehandle ............................30
           4.1.1. Root Filehandle ....................................31
           4.1.2. Public Filehandle ..................................31
      4.2. Filehandle Types ..........................................31
           4.2.1. General Properties of a Filehandle .................32
           4.2.2. Persistent Filehandle ..............................32
           4.2.3. Volatile Filehandle ................................33
           4.2.4. One Method of Constructing a Volatile Filehandle ...34
      4.3. Client Recovery from Filehandle Expiration ................35
   5. Attributes .....................................................35
      5.1. REQUIRED Attributes .......................................37
      5.2. RECOMMENDED Attributes ....................................37
      5.3. Named Attributes ..........................................37
      5.4. Classification of Attributes ..............................39
      5.5. Set-Only and Get-Only Attributes ..........................40
      5.6. REQUIRED Attributes - List and Definition References ......40
      5.7. RECOMMENDED Attributes - List and Definition References ...41
      5.8. Attribute Definitions .....................................42
           5.8.1. Definitions of REQUIRED Attributes .................42
           5.8.2. Definitions of Uncategorized RECOMMENDED
                  Attributes .........................................45
      5.9. Interpreting owner and owner_group ........................51
      5.10. Character Case Attributes ................................53
   6. Access Control Attributes ......................................54
      6.1. Goals .....................................................54
      6.2. File Attributes Discussion ................................55
           6.2.1. Attribute 12: acl ..................................55
           6.2.2. Attribute 33: mode .................................70
      6.3. Common Methods ............................................71
           6.3.1. Interpreting an ACL ................................71
           6.3.2. Computing a mode Attribute from an ACL .............72
      6.4. Requirements ..............................................73
           6.4.1. Setting the mode and/or ACL Attributes .............74
           6.4.2. Retrieving the mode and/or ACL Attributes ..........75
           6.4.3. Creating New Objects ...............................75
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   7. NFS Server Namespace ...........................................77
      7.1. Server Exports ............................................77
      7.2. Browsing Exports ..........................................77
      7.3. Server Pseudo-File System .................................78
      7.4. Multiple Roots ............................................79
      7.5. Filehandle Volatility .....................................79
      7.6. Exported Root .............................................79
      7.7. Mount Point Crossing ......................................79
      7.8. Security Policy and Namespace Presentation ................80
   8. Multi-Server Namespace .........................................81
      8.1. Location Attributes .......................................81
      8.2. File System Presence or Absence ...........................81
      8.3. Getting Attributes for an Absent File System ..............83
           8.3.1. GETATTR within an Absent File System ...............83
           8.3.2. READDIR and Absent File Systems ....................84
      8.4. Uses of Location Information ..............................84
           8.4.1. File System Replication ............................85
           8.4.2. File System Migration ..............................86
           8.4.3. Referrals ..........................................86
      8.5. Location Entries and Server Identity ......................87
      8.6. Additional Client-Side Considerations .....................88
      8.7. Effecting File System Referrals ...........................89
           8.7.1. Referral Example (LOOKUP) ..........................89
           8.7.2. Referral Example (READDIR) .........................93
      8.8. The Attribute fs_locations ................................96
   9. File Locking and Share Reservations ............................98
      9.1. Opens and Byte-Range Locks ................................99
           9.1.1. Client ID ..........................................99
           9.1.2. Server Release of Client ID .......................102
           9.1.3. Use of Seqids .....................................103
           9.1.4. Stateid Definition ................................104
           9.1.5. Lock-Owner ........................................110
           9.1.6. Use of the Stateid and Locking ....................110
           9.1.7. Sequencing of Lock Requests .......................113
           9.1.8. Recovery from Replayed Requests ...................114
           9.1.9. Interactions of Multiple Sequence Values ..........114
           9.1.10. Releasing State-Owner State ......................115
           9.1.11. Use of Open Confirmation .........................116
      9.2. Lock Ranges ..............................................117
      9.3. Upgrading and Downgrading Locks ..........................117
      9.4. Blocking Locks ...........................................118
      9.5. Lease Renewal ............................................119
      9.6. Crash Recovery ...........................................120
           9.6.1. Client Failure and Recovery .......................120
           9.6.2. Server Failure and Recovery .......................120
           9.6.3. Network Partitions and Recovery ...................122
      9.7. Recovery from a Lock Request Timeout or Abort ............130
      9.8. Server Revocation of Locks ...............................130
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      9.9. Share Reservations .......................................132
      9.10. OPEN/CLOSE Operations ...................................132
           9.10.1. Close and Retention of State Information .........133
      9.11. Open Upgrade and Downgrade ..............................134
      9.12. Short and Long Leases ...................................135
      9.13. Clocks, Propagation Delay, and Calculating Lease
            Expiration ..............................................135
      9.14. Migration, Replication, and State .......................136
           9.14.1. Migration and State ..............................136
           9.14.2. Replication and State ............................137
           9.14.3. Notification of Migrated Lease ...................137
           9.14.4. Migration and the lease_time Attribute ...........138
   10. Client-Side Caching ..........................................139
      10.1. Performance Challenges for Client-Side Caching ..........139
      10.2. Delegation and Callbacks ................................140
           10.2.1. Delegation Recovery ..............................142
      10.3. Data Caching ............................................147
           10.3.1. Data Caching and OPENs ...........................147
           10.3.2. Data Caching and File Locking ....................148
           10.3.3. Data Caching and Mandatory File Locking ..........150
           10.3.4. Data Caching and File Identity ...................150
      10.4. Open Delegation .........................................151
           10.4.1. Open Delegation and Data Caching .................154
           10.4.2. Open Delegation and File Locks ...................155
           10.4.3. Handling of CB_GETATTR ...........................155
           10.4.4. Recall of Open Delegation ........................158
           10.4.5. OPEN Delegation Race with CB_RECALL ..............160
           10.4.6. Clients That Fail to Honor Delegation Recalls ....161
           10.4.7. Delegation Revocation ............................162
      10.5. Data Caching and Revocation .............................162
           10.5.1. Revocation Recovery for Write Open Delegation ....163
      10.6. Attribute Caching .......................................164
      10.7. Data and Metadata Caching and Memory-Mapped Files .......166
      10.8. Name Caching ............................................168
      10.9. Directory Caching .......................................169
   11. Minor Versioning .............................................170
   12. Internationalization .........................................170
      12.1. Introduction ............................................170
      12.2. Limitations on Internationalization-Related
            Processing in the NFSv4 Context .........................172
      12.3. Summary of Server Behavior Types ........................173
      12.4. String Encoding .........................................173
      12.5. Normalization ...........................................174
      12.6. Types with Processing Defined by Other Internet Areas ...175
      12.7. Errors Related to UTF-8 .................................177
      12.8. Servers That Accept File Component Names That
            Are Not Valid UTF-8 Strings .............................177
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   13. Error Values .................................................178
      13.1. Error Definitions .......................................179
           13.1.1. General Errors ...................................180
           13.1.2. Filehandle Errors ................................181
           13.1.3. Compound Structure Errors ........................183
           13.1.4. File System Errors ...............................184
           13.1.5. State Management Errors ..........................186
           13.1.6. Security Errors ..................................187
           13.1.7. Name Errors ......................................187
           13.1.8. Locking Errors ...................................188
           13.1.9. Reclaim Errors ...................................190
           13.1.10. Client Management Errors ........................191
           13.1.11. Attribute Handling Errors .......................191
           13.1.12. Miscellaneous Errors ............................191
      13.2. Operations and Their Valid Errors .......................192
      13.3. Callback Operations and Their Valid Errors ..............200
      13.4. Errors and the Operations That Use Them .................201
   14. NFSv4 Requests ...............................................206
      14.1. COMPOUND Procedure ......................................207
      14.2. Evaluation of a COMPOUND Request ........................207
      14.3. Synchronous Modifying Operations ........................208
      14.4. Operation Values ........................................208
   15. NFSv4 Procedures .............................................209
      15.1. Procedure 0: NULL - No Operation ........................209
      15.2. Procedure 1: COMPOUND - COMPOUND Operations .............210
   16. NFSv4 Operations .............................................214
      16.1. Operation 3: ACCESS - Check Access Rights ...............214
      16.2. Operation 4: CLOSE - Close File .........................217
      16.3. Operation 5: COMMIT - Commit Cached Data ................218
      16.4. Operation 6: CREATE - Create a Non-regular File Object ..221
      16.5. Operation 7: DELEGPURGE - Purge Delegations
            Awaiting Recovery .......................................224
      16.6. Operation 8: DELEGRETURN - Return Delegation ............226
      16.7. Operation 9: GETATTR - Get Attributes ...................227
      16.8. Operation 10: GETFH - Get Current Filehandle ............229
      16.9. Operation 11: LINK - Create Link to a File ..............230
      16.10. Operation 12: LOCK - Create Lock .......................232
      16.11. Operation 13: LOCKT - Test for Lock ....................236
      16.12. Operation 14: LOCKU - Unlock File ......................238
      16.13. Operation 15: LOOKUP - Look Up Filename ................240
      16.14. Operation 16: LOOKUPP - Look Up Parent Directory .......242
      16.15. Operation 17: NVERIFY - Verify Difference in
             Attributes .............................................243
      16.16. Operation 18: OPEN - Open a Regular File ...............245
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      16.17. Operation 19: OPENATTR - Open Named Attribute
             Directory ..............................................256
      16.18. Operation 20: OPEN_CONFIRM - Confirm Open ..............257
      16.19. Operation 21: OPEN_DOWNGRADE - Reduce Open File
             Access .................................................260
      16.20. Operation 22: PUTFH - Set Current Filehandle ...........262
      16.21. Operation 23: PUTPUBFH - Set Public Filehandle .........263
      16.22. Operation 24: PUTROOTFH - Set Root Filehandle ..........265
      16.23. Operation 25: READ - Read from File ....................266
      16.24. Operation 26: READDIR - Read Directory .................269
      16.25. Operation 27: READLINK - Read Symbolic Link ............273
      16.26. Operation 28: REMOVE - Remove File System Object .......274
      16.27. Operation 29: RENAME - Rename Directory Entry ..........276
      16.28. Operation 30: RENEW - Renew a Lease ....................278
      16.29. Operation 31: RESTOREFH - Restore Saved Filehandle .....280
      16.30. Operation 32: SAVEFH - Save Current Filehandle .........281
      16.31. Operation 33: SECINFO - Obtain Available Security ......282
      16.32. Operation 34: SETATTR - Set Attributes .................286
      16.33. Operation 35: SETCLIENTID - Negotiate Client ID ........289
      16.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Client ID ..293
      16.35. Operation 37: VERIFY - Verify Same Attributes ..........297
      16.36. Operation 38: WRITE - Write to File ....................299
      16.37. Operation 39: RELEASE_LOCKOWNER - Release
             Lock-Owner State .......................................304
      16.38. Operation 10044: ILLEGAL - Illegal Operation ...........305
   17. NFSv4 Callback Procedures ....................................306
      17.1. Procedure 0: CB_NULL - No Operation .....................306
      17.2. Procedure 1: CB_COMPOUND - COMPOUND Operations ..........307
   18. NFSv4 Callback Operations ....................................309
      18.1. Operation 3: CB_GETATTR - Get Attributes ................309
      18.2. Operation 4: CB_RECALL - Recall an Open Delegation ......310
      18.3. Operation 10044: CB_ILLEGAL - Illegal Callback
            Operation ...............................................311
   19. Security Considerations ......................................312
   20. IANA Considerations ..........................................314
      20.1. Named Attribute Definitions .............................314
           20.1.1. Initial Registry .................................315
           20.1.2. Updating Registrations ...........................315
      20.2. Updates to Existing IANA Registries .....................315
   21. References ...................................................316
      21.1. Normative References ....................................316
      21.2. Informative References ..................................318
   Acknowledgments ..................................................322
   Authors&#39; Addresses ...............................................323
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119], except where &#34;REQUIRED&#34; and &#34;RECOMMENDED&#34; are used as qualifiers to distinguish classes of attributes as described in Sections 1.4.3.2 and 5 of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、このドキュメントのセクション1.4.3.2および5で説明されているように、属性のクラスを区別するための修飾子として「必須」および「推奨」が使用されている場合を除き、RFC 2119 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. NFS Version 4 Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. NFSバージョン4の目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Network File System version 4 (NFSv4) protocol is a further revision of the NFS protocol defined already by versions 2 [RFC1094] and 3 [RFC1813]. It retains the essential characteristics of previous versions: design for easy recovery; independent of transport protocols, operating systems, and file systems; simplicity; and good performance. The NFSv4 revision has the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Network File Systemバージョン4（NFSv4）プロトコルは、バージョン2 [RFC1094]および3 [RFC1813]ですでに定義されているNFSプロトコルのさらなる改訂版です。以前のバージョンの本質的な特徴を保持しています。トランスポートプロトコル、オペレーティングシステム、ファイルシステムに依存しない。シンプルさ。そして良いパフォーマンス。 NFSv4リビジョンには次の目標があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Improved access and good performance on the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o インターネット上でのアクセスとパフォーマンスの向上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol is designed to transit firewalls easily, perform well where latency is high and bandwidth is low, and scale to very large numbers of clients per server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、ファイアウォールを簡単に通過できるように設計されており、レイテンシが高く帯域幅が低い場合に良好に機能し、サーバーごとに非常に多くのクライアントに対応できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Strong security with negotiation built into the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロトコルにネゴシエーションが組み込まれた強力なセキュリティ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol builds on the work of the Open Network Computing (ONC) Remote Procedure Call (RPC) working group in supporting the RPCSEC_GSS protocol (see both [RFC2203] and [RFC5403]). Additionally, the NFSv4 protocol provides a mechanism to allow clients and servers the ability to negotiate security and require clients and servers to support a minimal set of security schemes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、RPCSEC_GSSプロトコル（[RFC2203]と[RFC5403]の両方を参照）をサポートするOpen Network Computing（ONC）リモートプロシージャコール（RPC）ワーキンググループの作業に基づいています。さらに、NFSv4プロトコルは、クライアントとサーバーがセキュリティをネゴシエートできるようにするメカニズムを提供し、クライアントとサーバーが最小限のセキュリティスキームのセットをサポートすることを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Good cross-platform interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 優れたクロスプラットフォームの相互運用性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol features a file system model that provides a useful, common set of features that does not unduly favor one file system or operating system over another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルは、ファイルシステムまたはオペレーティングシステムを過度に優先しない便利で一般的な機能セットを提供するファイルシステムモデルを備えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Designed for protocol extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロトコル拡張用に設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol is designed to accept standard extensions that do not compromise backward compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、下位互換性を損なわない標準の拡張機能を受け入れるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document, together with the companion External Data Representation (XDR) description document [RFC7531], obsoletes [RFC3530] as the authoritative document describing NFSv4. It does not introduce any over-the-wire protocol changes, in the sense that previously valid requests remain valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、付随する外部データ表現（XDR）記述ドキュメント[RFC7531]とともに、NFSv4を説明する信頼できるドキュメントとして[RFC3530]を廃止します。以前に有効だったリクエストが有効なままであるという意味で、ネットワーク上のプロトコル変更は導入されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Definitions in the Companion Document RFC 7531 Are Authoritative
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. コンパニオンドキュメントRFC 7531の定義は信頼できる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;Network File System (NFS) Version 4 External Data Representation Standard (XDR) Description&#34; [RFC7531] contains the definitions in XDR description language of the constructs used by the protocol. Inside this document, several of the constructs are reproduced for purposes of explanation. The reader is warned of the possibility of errors in the reproduced constructs outside of [RFC7531]. For any part of the document that is inconsistent with [RFC7531], [RFC7531] is to be considered authoritative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ネットワークファイルシステム（NFS）バージョン4外部データ表現標準（XDR）記述」[RFC7531]には、プロトコルで使用される構成のXDR記述言語での定義が含まれています。このドキュメントでは、説明のためにいくつかの構成要素が複製されています。読者は、[RFC7531]の外で複製された構成にエラーの可能性があることを警告されます。 [RFC7531]と矛盾するドキュメントの部分については、[RFC7531]は信頼できると見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Overview of NFSv4 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. NFSv4機能の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a reasonable context for the reader, the major features of the NFSv4 protocol will be reviewed in brief. This is done to provide an appropriate context for both the reader who is familiar with the previous versions of the NFS protocol and the reader who is new to the NFS protocols. For the reader new to the NFS protocols, some fundamental knowledge is still expected. The reader should be familiar with the XDR and RPC protocols as described in [RFC4506] and [RFC5531]. A basic knowledge of file systems and distributed file systems is expected as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読者に妥当なコンテキストを提供するために、NFSv4プロトコルの主要な機能を簡単に復習します。これは、NFSプロトコルの以前のバージョンに精通している読者と、NFSプロトコルに不慣れな読者の両方に適切なコンテキストを提供するために行われます。 NFSプロトコルに不慣れな読者のために、いくつかの基本的な知識がまだ期待されています。 [RFC4506]および[RFC5531]で説明されているように、読者はXDRおよびRPCプロトコルに精通している必要があります。ファイルシステムと分散ファイルシステムの基本的な知識も必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1. RPC and Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1. RPCとセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with previous versions of NFS, the XDR and RPC mechanisms used for the NFSv4 protocol are those defined in [RFC4506] and [RFC5531]. To meet end-to-end security requirements, the RPCSEC_GSS framework (both version 1 in [RFC2203] and version 2 in [RFC5403]) will be used to extend the basic RPC security. With the use of RPCSEC_GSS, various mechanisms can be provided to offer authentication, integrity, and privacy to the NFSv4 protocol. Kerberos V5 will be used as described in [RFC4121] to provide one security framework. With the use of RPCSEC_GSS, other mechanisms may also be specified and used for NFSv4 security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFSと同様に、NFSv4プロトコルに使用されるXDRおよびRPCメカニズムは、[RFC4506]および[RFC5531]で定義されたものです。エンドツーエンドのセキュリティ要件を満たすために、RPCSEC_GSSフレームワーク（[RFC2203]のバージョン1と[RFC5403]のバージョン2の両方）を使用して、基本的なRPCセキュリティを拡張します。 RPCSEC_GSSを使用すると、NFSv4プロトコルに認証、整合性、およびプライバシーを提供するさまざまなメカニズムを提供できます。 [RFC4121]で説明されているようにKerberos V5を使用して、1つのセキュリティフレームワークを提供します。 RPCSEC_GSSを使用すると、NFSv4セキュリティーに他のメカニズムを指定して使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To enable in-band security negotiation, the NFSv4 protocol has added a new operation that provides the client with a method of querying the server about its policies regarding which security mechanisms must be used for access to the server&#39;s file system resources. With this, the client can securely match the security mechanism that meets the policies specified at both the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インバンドセキュリティネゴシエーションを有効にするために、NFSv4プロトコルには、サーバーのファイルシステムリソースへのアクセスに使用する必要のあるセキュリティメカニズムに関するポリシーをサーバーに照会する方法をクライアントに提供する新しい操作が追加されています。これにより、クライアントは、クライアントとサーバーの両方で指定されたポリシーを満たすセキュリティメカニズムに安全に一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2. Procedure and Operation Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2. 手順と操作構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A significant departure from the previous versions of the NFS protocol is the introduction of the COMPOUND procedure. For the NFSv4 protocol, there are two RPC procedures: NULL and COMPOUND. The COMPOUND procedure is defined in terms of operations, and these operations correspond more closely to the traditional NFS procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの以前のバージョンからの大きな違いは、COMPOUNDプロシージャの導入です。 NFSv4プロトコルの場合、NULLとCOMPOUNDの2つのRPCプロシージャがあります。 COMPOUNDプロシージャは操作に関して定義されており、これらの操作は従来のNFSプロシージャにより密接に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of the COMPOUND procedure, the client is able to build simple or complex requests. These COMPOUND requests allow for a reduction in the number of RPCs needed for logical file system operations. For example, without previous contact with a server a client will be able to read data from a file in one request by combining LOOKUP, OPEN, and READ operations in a single COMPOUND RPC. With previous versions of the NFS protocol, this type of single request was not possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャを使用すると、クライアントは単純または複雑な要求を作成できます。これらのCOMPOUND要求により、論理ファイルシステム操作に必要なRPCの数を減らすことができます。たとえば、サーバーとの以前の接続がなければ、クライアントは、LOOKUP、OPEN、およびREAD操作を1つのCOMPOUND RPCで組み合わせることにより、1つの要求でファイルからデータを読み取ることができます。以前のバージョンのNFSプロトコルでは、このタイプの単一要求は不可能でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model used for COMPOUND is very simple. There is no logical OR or ANDing of operations. The operations combined within a COMPOUND request are evaluated in order by the server. Once an operation returns a failing result, the evaluation ends and the results of all evaluated operations are returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDに使用されるモデルは非常に単純です。操作の論理ORまたはAND演算はありません。 COMPOUNDリクエスト内で結合された操作は、サーバーによって順番に評価されます。操作が失敗した結果を返すと、評価は終了し、評価されたすべての操作の結果がクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol continues to have the client refer to a file or directory at the server by a &#34;filehandle&#34;. The COMPOUND procedure has a method of passing a filehandle from one operation to another within the sequence of operations. There is a concept of a current filehandle and a saved filehandle. Most operations use the current filehandle as the file system object to operate upon. The saved filehandle is used as temporary filehandle storage within a COMPOUND procedure as well as an additional operand for certain operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルは、クライアントに「ファイルハンドル」によってサーバーのファイルまたはディレクトリを参照させ続けます。 COMPOUNDプロシージャには、一連の操作内である操作から別の操作にファイルハンドルを渡す方法があります。現在のファイルハンドルと保存されたファイルハンドルの概念があります。ほとんどの操作は、操作対象のファイルシステムオブジェクトとして現在のファイルハンドルを使用します。保存されたファイルハンドルは、COMPOUNDプロシージャ内の一時ファイルハンドルストレージとして使用され、特定の操作の追加のオペランドとしても使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3. File System Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3. ファイルシステムモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general file system model used for the NFSv4 protocol is the same as previous versions. The server file system is hierarchical, with the regular files contained within being treated as opaque byte streams. In a slight departure, file and directory names are encoded with UTF-8 to deal with the basics of internationalization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルに使用される一般的なファイルシステムモデルは、以前のバージョンと同じです。サーバーファイルシステムは階層構造になっており、通常のファイルは、不透明なバイトストリームとして扱われます。わずかな出発点として、ファイル名とディレクトリ名は国際化の基本に対処するためにUTF-8でエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol does not require a separate protocol to provide for the initial mapping between pathname and filehandle. Instead of using the older MOUNT protocol for this mapping, the server provides a root filehandle that represents the logical root or top of the file system tree provided by the server. The server provides multiple file systems by gluing them together with pseudo-file systems. These pseudo-file systems provide for potential gaps in the pathnames between real file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルは、パス名とファイルハンドル間の初期マッピングを提供するために、別個のプロトコルを必要としません。このマッピングに古いMOUNTプロトコルを使用する代わりに、サーバーは、サーバーによって提供されるファイルシステムツリーの論理ルートまたは最上位を表すルートファイルハンドルを提供します。サーバーは、疑似ファイルシステムと一緒に接着することにより、複数のファイルシステムを提供します。これらの疑似ファイルシステムは、実際のファイルシステム間のパス名に潜在的なギャップを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.1. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.1. ファイルハンドルのタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In previous versions of the NFS protocol, the filehandle provided by the server was guaranteed to be valid or persistent for the lifetime of the file system object to which it referred. For some server implementations, this persistence requirement has been difficult to meet. For the NFSv4 protocol, this requirement has been relaxed by introducing another type of filehandle -- volatile. With persistent and volatile filehandle types, the server implementation can match the abilities of the file system at the server along with the operating environment. The client will have knowledge of the type of filehandle being provided by the server and can be prepared to deal with the semantics of each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFSプロトコルでは、サーバーが提供するファイルハンドルは、それが参照するファイルシステムオブジェクトの存続期間中、有効または永続的であることが保証されていました。一部のサーバー実装では、この永続性要件を満たすのが困難でした。 NFSv4プロトコルの場合、この要件は、別のタイプのファイルハンドル-揮発性-を導入することで緩和されました。永続的で揮発性のファイルハンドルタイプを使用すると、サーバーの実装は、サーバーのファイルシステムの機能と動作環境を一致させることができます。クライアントは、サーバーによって提供されるファイルハンドルのタイプの知識を持ち、それぞれのセマンティクスを処理する準備ができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.2. Attribute Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.2. 属性タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol has a rich and extensible file object attribute structure, which is divided into REQUIRED, RECOMMENDED, and named attributes (see Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルには、豊富で拡張可能なファイルオブジェクト属性構造があり、REQUIRED、RECOMMENDED、および名前付き属性に分かれています（セクション5を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several (but not all) of the REQUIRED attributes are derived from the attributes of NFSv3 (see the definition of the fattr3 data type in [RFC1813]). An example of a REQUIRED attribute is the file object&#39;s type (Section 5.8.1.2) so that regular files can be distinguished from directories (also known as folders in some operating environments) and other types of objects. REQUIRED attributes are discussed in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須（すべてではない）のいくつかの属性は、NFSv3の属性から派生しています（[RFC1813]のfattr3データ型の定義を参照してください）。 REQUIRED属性の例は、ファイルオブジェクトのタイプ（5.8.1.2項）です。これにより、通常のファイルをディレクトリ（一部の動作環境ではフォルダとも呼ばれます）や他のタイプのオブジェクトと区別できます。必須属性については、セクション5.1で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of the RECOMMENDED attributes is an acl (Section 6.2.1). This attribute defines an Access Control List (ACL) on a file object. An ACL provides file access control beyond the model used in NFSv3. The ACL definition allows for specification of specific sets of permissions for individual users and groups. In addition, ACL inheritance allows propagation of access permissions and restriction down a directory tree as file system objects are created. RECOMMENDED attributes are discussed in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECOMMENDED属性の例はaclです（セクション6.2.1）。この属性は、ファイルオブジェクトのアクセス制御リスト（ACL）を定義します。 ACLは、NFSv3で使用されるモデルを超えたファイルアクセス制御を提供します。 ACL定義では、個々のユーザーとグループに特定の権限セットを指定できます。さらに、ACLの継承により、ファイルシステムオブジェクトが作成されるときに、ディレクトリツリーの下にアクセス許可と制限を伝達できます。推奨される属性については、セクション5.2で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A named attribute is an opaque byte stream that is associated with a directory or file and referred to by a string name. Named attributes are meant to be used by client applications as a method to associate application-specific data with a regular file or directory. NFSv4.1 modifies named attributes relative to NFSv4.0 by tightening the allowed operations in order to prevent the development of non-interoperable implementations. Named attributes are discussed in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、ディレクトリまたはファイルに関連付けられ、文字列名で参照される不透明なバイトストリームです。名前付き属性は、アプリケーション固有のデータを通常のファイルまたはディレクトリに関連付ける方法としてクライアントアプリケーションによって使用されることを意図しています。 NFSv4.1は、相互運用性のない実装の開発を防ぐために、許可される操作を厳しくすることにより、NFSv4.0に関連する名前付き属性を変更します。名前付き属性については、セクション5.3で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.3. Multi-Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.3. マルチサーバー名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single-server namespace is the file system hierarchy that the server presents for remote access. It is a proper subset of all the file systems available locally. NFSv4 contains a number of features to allow implementation of namespaces that cross server boundaries and that allow and facilitate a non-disruptive transfer of support for individual file systems between servers. They are all based upon attributes that allow one file system to specify alternative or new locations for that file system. That is, just as a client might traverse across local file systems on a single server, it can now traverse to a remote file system on a different server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一サーバーの名前空間は、サーバーがリモートアクセスのために提示するファイルシステム階層です。ローカルで利用可能なすべてのファイルシステムの適切なサブセットです。 NFSv4には、サーバーの境界を越える名前空間の実装を可能にし、サーバー間の個々のファイルシステムのサポートを無停止で転送できるようにする多数の機能が含まれています。これらはすべて、1つのファイルシステムがそのファイルシステムの代替または新しい場所を指定できるようにする属性に基づいています。つまり、クライアントが単一のサーバー上のローカルファイルシステムを横断するように、クライアントは別のサーバー上のリモートファイルシステムを横断することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes may be used together with the concept of absent file systems, which provide specifications for additional locations but no actual file system content. This allows a number of important facilities:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、追加の場所の仕様を提供しますが、実際のファイルシステムのコンテンツは提供しない、存在しないファイルシステムの概念と一緒に使用できます。これにより、いくつかの重要な機能が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Location attributes may be used with absent file systems to implement referrals whereby one server may direct the client to a file system provided by another server. This allows extensive multi-server namespaces to be constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ロケーション属性は、存在しないファイルシステムで使用して紹介を実装することができます。これにより、あるサーバーが別のサーバーが提供するファイルシステムにクライアントを誘導できます。これにより、広範なマルチサーバー名前空間を構築できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Location attributes may be provided for present file systems to provide the locations of alternative file system instances or replicas to be used in the event that the current file system instance becomes unavailable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在のファイルシステムインスタンスが使用できなくなった場合に使用される代替ファイルシステムインスタンスまたはレプリカの場所を提供するために、現在のファイルシステムに場所属性を提供できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Location attributes may be provided when a previously present file system becomes absent. This allows non-disruptive migration of file systems to alternative servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以前に存在していたファイルシステムが存在しなくなったときに、場所属性が提供される場合があります。これにより、ファイルシステムを無停止で代替サーバーに移行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4. OPEN and CLOSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4. 開くと閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol introduces OPEN and CLOSE operations. The OPEN operation provides a single point where file lookup, creation, and share semantics (see Section 9.9) can be combined. The CLOSE operation also provides for the release of state accumulated by OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルでは、OPENおよびCLOSE操作が導入されています。 OPEN操作は、ファイルの検索、作成、および共有のセマンティクス（セクション9.9を参照）を組み合わせることができる単一のポイントを提供します。 CLOSE操作は、OPENによって蓄積された状態の解放も提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5. File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5. ファイルのロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFSv4 protocol, the support for byte-range file locking is part of the NFS protocol. The file locking support is structured so that an RPC callback mechanism is not required. This is a departure from the previous versions of the NFS file locking protocol, Network Lock Manager (NLM) [RFC1813]. The state associated with file locks is maintained at the server under a lease-based model. The server defines a single lease period for all state held by an NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルでは、バイト範囲のファイルロックのサポートはNFSプロトコルの一部です。ファイルロックのサポートは、RPCコールバックメカニズムが不要になるように構造化されています。これは、NFSファイルロックプロトコルの以前のバージョン、Network Lock Manager（NLM）[RFC1813]からの逸脱です。ファイルロックに関連付けられた状態は、リースベースのモデルの下でサーバーで維持されます。サーバーは、NFSクライアントが保持するすべての状態に対して単一のリース期間を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client does not renew its lease within the defined period, all state associated with the client&#39;s lease may be released by the server. The client may renew its lease by use of the RENEW operation or implicitly by use of other operations (primarily READ).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが定義された期間内にリースを更新しない場合、クライアントのリースに関連付けられたすべての状態がサーバーによって解放される可能性があります。クライアントは、RENEW操作を使用して、または他の操作（主にREAD）を使用して暗黙的にリースを更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6. Client Caching and Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6. クライアントのキャッシュと委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file, attribute, and directory caching for the NFSv4 protocol is similar to previous versions. Attributes and directory information are cached for a duration determined by the client. At the end of a predefined timeout, the client will query the server to see if the related file system object has been updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルのファイル、属性、およびディレクトリキャッシングは、以前のバージョンと同様です。属性とディレクトリ情報は、クライアントによって決定された期間キャッシュされます。事前定義されたタイムアウトの最後に、クライアントはサーバーに問い合わせて、関連するファイルシステムオブジェクトが更新されているかどうかを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For file data, the client checks its cache validity when the file is opened. A query is sent to the server to determine if the file has been changed. Based on this information, the client determines if the data cache for the file should be kept or released. Also, when the file is closed, any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルデータの場合、クライアントはファイルが開かれるときにキャッシュの有効性をチェックします。クエリがサーバーに送信され、ファイルが変更されたかどうかが判断されます。この情報に基づいて、クライアントはファイルのデータキャッシュを保持するか解放するかを決定します。また、ファイルを閉じると、変更されたデータがサーバーに書き込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application wants to serialize access to file data, file locking of the file data ranges in question should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがファイルデータへのアクセスをシリアル化する場合は、問題のファイルデータ範囲のファイルロックを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The major addition to NFSv4 in the area of caching is the ability of the server to delegate certain responsibilities to the client. When the server grants a delegation for a file to a client, the client is guaranteed certain semantics with respect to the sharing of that file with other clients. At OPEN, the server may provide the client either a read (OPEN_DELEGATE_READ) or a write (OPEN_DELEGATE_WRITE) delegation for the file (see Section 10.4). If the client is granted an OPEN_DELEGATE_READ delegation, it is assured that no other client has the ability to write to the file for the duration of the delegation. If the client is granted an OPEN_DELEGATE_WRITE delegation, the client is assured that no other client has read or write access to the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシングの領域でNFSv4に追加された主な点は、サーバーが特定の責任をクライアントに委任する機能です。サーバーがクライアントにファイルの委任を許可すると、クライアントは他のクライアントとのそのファイルの共有に関して特定のセマンティクスが保証されます。 OPENでは、サーバーはクライアントにファイルの読み取り（OPEN_DELEGATE_READ）または書き込み（OPEN_DELEGATE_WRITE）委任を提供します（セクション10.4を参照）。クライアントにOPEN_DELEGATE_READ委任が付与されている場合、委任の間、他のクライアントがファイルに書き込むことができないことが保証されます。クライアントにOPEN_DELEGATE_WRITE委譲が許可されている場合、クライアントは、他のクライアントがファイルへの読み取りまたは書き込みアクセス権を持たないことが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations can be recalled by the server. If another client requests access to the file in such a way that the access conflicts with the granted delegation, the server is able to notify the initial client and recall the delegation. This requires that a callback path exist between the server and client. If this callback path does not exist, then delegations cannot be granted. The essence of a delegation is that it allows the client to locally service operations such as OPEN, CLOSE, LOCK, LOCKU, READ, or WRITE without immediate interaction with the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任はサーバーによって取り消すことができます。別のクライアントがアクセスを許可された委任と競合するような方法でファイルへのアクセスを要求した場合、サーバーは最初のクライアントに通知して委任を取り消すことができます。これには、サーバーとクライアントの間にコールバックパスが存在する必要があります。このコールバックパスが存在しない場合、委任は許可されません。委任の本質は、クライアントがサーバーと直接対話することなく、OPEN、CLOSE、LOCK、LOCKU、READ、またはWRITEなどの操作をローカルでサービスできるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. General Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. 一般的な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definitions are provided for the purpose of providing an appropriate context for the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の定義は、読者に適切なコンテキストを提供する目的で提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Absent File System: A file system is &#34;absent&#34; when a namespace component does not have a backing file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不在のファイルシステム：名前空間コンポーネントにバッキングファイルシステムがない場合、ファイルシステムは「不在」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anonymous Stateid: The Anonymous Stateid is a special locking object and is defined in Section 9.1.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
匿名状態ID：匿名状態IDは特別なロックオブジェクトであり、セクション9.1.4.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Byte: In this document, a byte is an octet, i.e., a datum exactly 8 bits in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト：このドキュメントでは、バイトはオクテット、つまり長さがちょうど8ビットのデータムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client: The client is the entity that accesses the NFS server&#39;s resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント：クライアントは、NFSサーバーのリソースにアクセスするエンティティです。クライアントは、NFSサーバーに直接アクセスするためのロジックを含むアプリケーションである場合があります。クライアントは、一連のアプリケーションにリモートファイルシステムサービスを提供する従来のオペレーティングシステムクライアントでもかまいません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
With reference to byte-range locking, the client is also the entity that maintains a set of locks on behalf of one or more applications. This client is responsible for crash or failure recovery for those locks it manages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バイト範囲のロックに関して、クライアントは、1つ以上のアプリケーションのために一連のロックを維持するエンティティでもあります。このクライアントは、管理するロックのクラッシュまたは障害回復を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that multiple clients may share the same transport and connection, and multiple clients may exist on the same network node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
複数のクライアントが同じトランスポートと接続を共有し、複数のクライアントが同じネットワークノードに存在する場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client ID: The client ID is a 64-bit quantity used as a unique, shorthand reference to a client-supplied verifier and ID. The server is responsible for supplying the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントID：クライアントIDは、クライアント提供のベリファイアとIDへの一意の省略形参照として使用される64ビットの数量です。サーバーは、クライアントIDを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File System: The file system is the collection of objects on a server that share the same fsid attribute (see Section 5.8.1.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステム：ファイルシステムは、同じfsid属性を共有するサーバー上のオブジェクトのコレクションです（セクション5.8.1.9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lease: A lease is an interval of time defined by the server for which the client is irrevocably granted a lock. At the end of a lease period the lock may be revoked if the lease has not been extended. The lock must be revoked if a conflicting lock has been granted after the lease interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リース：リースは、クライアントがロックを取り返しのつかない形で許可されるサーバーによって定義される時間間隔です。リース期間が終了すると、リースが延長されていない場合、ロックが取り消されることがあります。リース期間後に競合するロックが付与されている場合は、ロックを取り消す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
All leases granted by a server have the same fixed duration. Note that the fixed interval duration was chosen to alleviate the expense a server would have in maintaining state about variable-length leases across server failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーによって付与されたすべてのリースの固定期間は同じです。固定間隔の期間は、サーバーの障害が発生しても可変長のリースに関する状態をサーバーが維持するための費用を軽減するために選択されたことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lock: The term &#34;lock&#34; is used to refer to record (byte-range) locks as well as share reservations unless specifically stated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック：「ロック」という用語は、特に明記されていない限り、レコード（バイト範囲）ロックおよび共有予約を指すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lock-Owner: Each byte-range lock is associated with a specific lock-owner and an open-owner. The lock-owner consists of a client ID and an opaque owner string. The client presents this to the server to establish the ownership of the byte-range lock as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック所有者：各バイト範囲ロックは、特定のロック所有者とオープン所有者に関連付けられています。ロック所有者は、クライアントIDと不透明な所有者文字列で構成されます。クライアントはこれをサーバーに提示して、必要に応じてバイト範囲ロックの所有権を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Open-Owner: Each open file is associated with a specific open-owner, which consists of a client ID and an opaque owner string. The client presents this to the server to establish the ownership of the open as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープンオーナー：開いている各ファイルは、クライアントIDと不透明なオーナー文字列で構成される特定のオープンオーナーに関連付けられています。クライアントはこれをサーバーに提示して、必要に応じてオープンの所有権を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ Bypass Stateid: The READ Bypass Stateid is a special locking object and is defined in Section 9.1.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ Bypass Stateid：READ Bypass Stateidは特別なロックオブジェクトであり、セクション9.1.4.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server: The &#34;server&#34; is the entity responsible for coordinating client access to a set of file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー：「サーバー」は、一連のファイルシステムへのクライアントアクセスの調整を担当するエンティティです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stable Storage: NFSv4 servers must be able to recover without data loss from multiple power failures (including cascading power failures, that is, several power failures in quick succession), operating system failures, and hardware failure of components other than the storage medium itself (for example, disk, non-volatile RAM).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したストレージ：NFSv4サーバーは、複数の電源障害（カスケード電源障害、つまり連続した複数の電源障害を含む）、オペレーティングシステム障害、およびストレージメディア自体以外のコンポーネントのハードウェア障害からデータを失うことなく回復できる必要があります（たとえば、ディスク、不揮発性RAM）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Some examples of stable storage that are allowable for an NFS server include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFSサーバーで許容される安定したストレージの例には次のものがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) Media commit of data. That is, the modified data has been successfully written to the disk media -- for example, the disk platter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（1）データのメディアコミット。つまり、変更されたデータはディスクメディア（ディスクプラッターなど）に正常に書き込まれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) An immediate reply disk drive with battery-backed on-drive intermediate storage or uninterruptible power system (UPS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（2）バッテリバックアップ式のドライブ上の中間ストレージまたは無停電電源システム（UPS）を備えた即時応答ディスクドライブ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(3) Server commit of data with battery-backed intermediate storage and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（3）バッテリバックアップ式中間ストレージおよびリカバリソフトウェアを使用したデータのサーバーコミット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(4) Cache commit with UPS and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（4）UPSおよびリカバリソフトウェアを使用したキャッシュコミット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid: A stateid is a 128-bit quantity returned by a server that uniquely identifies the open and locking states provided by the server for a specific open-owner or lock-owner/open-owner pair for a specific file and type of lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid：Stateidは、サーバーによって返される128ビットの数量であり、特定のファイルとロックのタイプについて、特定のオープン所有者またはロック所有者/オープン所有者のペアに対してサーバーによって提供されるオープン状態とロック状態を一意に識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Verifier: A verifier is a 64-bit quantity generated by the client that the server can use to determine if the client has restarted and lost all previous lock state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイア：ベリファイアはクライアントによって生成された64ビットの量であり、サーバーがクライアントを再起動して以前のロック状態をすべて失ったかどうかを判断するために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.6. Changes since RFC 3530
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.6. RFC 3530以降の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The main changes from RFC 3530 [RFC3530] are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3530 [RFC3530]からの主な変更点は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The XDR definition has been moved to a companion document [RFC7531].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o XDR定義は、関連ドキュメント[RFC7531]に移動されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The IETF intellectual property statements were updated to the latest version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IETFの知的財産に関する声明が最新バージョンに更新されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is a restructured and more complete explanation of multi-server namespace features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o マルチサーバー名前空間機能の再構成されたより完全な説明があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The handling of domain names was updated to reflect Internationalized Domain Names in Applications (IDNA) [RFC5891].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ドメイン名の処理が更新され、アプリケーションにおける国際化ドメイン名（IDNA）[RFC5891]が反映されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The previously required LIPKEY and SPKM-3 security mechanisms have been removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以前は必要だったLIPKEYおよびSPKM-3セキュリティメカニズムが削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Some clarification was provided regarding a client re-establishing callback information to the new server if state has been migrated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 状態が移行された場合にクライアントが新しいサーバーへのコールバック情報を再確立することに関して、いくつかの説明が提供されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A third edge case was added for courtesy locks and network partitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 3番目のエッジケースは、礼儀ロックおよびネットワークパーティション用に追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The definition of stateid was strengthened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stateidの定義が強化されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7. Changes between RFC 3010 and RFC 3530
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7. RFC 3010とRFC 3530の間の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of the NFSv4 protocol in [RFC3530] replaced and obsoleted the definition present in [RFC3010]. While portions of the two documents remained the same, there were substantive changes in others. The changes made between [RFC3010] and [RFC3530] reflect implementation experience and further review of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3530]のNFSv4プロトコルの定義は、[RFC3010]にある定義に取って代わり、廃止されました。 2つのドキュメントの一部は同じままでしたが、他のドキュメントには実質的な変更がありました。 [RFC3010]と[RFC3530]の間で行われた変更は、実装の経験とプロトコルのさらなるレビューを反映しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following list is not inclusive of all changes but presents some of the most notable changes or additions made:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のリストはすべての変更を含んでいるわけではありませんが、行われた最も注目すべき変更または追加のいくつかを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state model has added an open_owner4 identifier. This was done to accommodate POSIX-based clients and the model they use for file locking. For POSIX clients, an open_owner4 would correspond to a file descriptor potentially shared amongst a set of processes and the lock_owner4 identifier would correspond to a process that is locking a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 状態モデルにopen_owner4識別子が追加されました。これは、POSIXベースのクライアントとファイルロックに使用するモデルに対応するために行われました。 POSIXクライアントの場合、open_owner4は一連のプロセス間で共有される可能性のあるファイル記述子に対応し、lock_owner4識別子はファイルをロックしているプロセスに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added clarifications and error conditions for the handling of the owner and group attributes. Since these attributes are string based (as opposed to the numeric uid/gid of previous versions of NFS), translations may not be available and hence the changes made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 所有者とグループの属性の処理に関する説明とエラー条件が追加されました。これらの属性は（以前のバージョンのNFSの数値のuid / gidとは対照的に）文字列ベースであるため、変換が利用できず、変更が行われる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added clarifications for the ACL and mode attributes to address evaluation and partial support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 評価と部分的なサポートに対処するために、ACLおよびモード属性の説明が追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For identifiers that are defined as XDR opaque, set limits on their size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o XDR不透明として定義されている識別子の場合、サイズに制限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added the mounted_on_fileid attribute to allow POSIX clients to correctly construct local mounts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o POSIXクライアントがローカルマウントを正しく構築できるように、mounted_on_fileid属性を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Modified the SETCLIENTID/SETCLIENTID_CONFIRM operations to deal correctly with confirmation details along with adding the ability to specify new client callback information. Also added clarification of the callback information itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETCLIENTID / SETCLIENTID_CONFIRM操作を変更し、確認の詳細を正しく処理するとともに、新しいクライアントコールバック情報を指定する機能を追加しました。コールバック情報自体の説明も追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added a new operation RELEASE_LOCKOWNER to enable notifying the server that a lock_owner4 will no longer be used by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 新しい操作RELEASE_LOCKOWNERが追加され、lock_owner4がクライアントによって使用されなくなることをサーバーに通知できるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added RENEW operation changes to identify the client correctly and allow for additional error returns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントを正しく識別し、追加のエラーが返されるようにするRENEWオペレーションの変更を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Verified error return possibilities for all operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべての操作でエラーが返される可能性を確認しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Removed use of the pathname4 data type from LOOKUP and OPEN in favor of having the client construct a sequence of LOOKUP operations to achieve the same effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが一連のLOOKUP操作を構築して同じ効果を得るようにして、LOOKUPおよびOPENからpathname4データ型の使用を削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Protocol Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. プロトコルデータタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax and semantics to describe the data types of the NFSv4 protocol are defined in the XDR [RFC4506] and RPC [RFC5531] documents. The next sections build upon the XDR data types to define types and structures specific to this protocol. As a reminder, the size constants and authoritative definitions can be found in [RFC7531].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルのデータ型を記述するための構文とセマンティクスは、XDR [RFC4506]およびRPC [RFC5531]ドキュメントで定義されています。次のセクションでは、XDRデータ型に基づいて、このプロトコルに固有の型と構造を定義します。注意として、サイズ定数と信頼できる定義は[RFC7531]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Basic Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 基本的なデータ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 1 lists the base NFSv4 data types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表1に、基本NFSv4データ型を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------+-------------------------------------------------+
   | Data Type       | Definition                                      |
   +-----------------+-------------------------------------------------+
   | int32_t         | typedef int int32_t;                            |
   |                 |                                                 |
   | uint32_t        | typedef unsigned int uint32_t;                  |
   |                 |                                                 |
   | int64_t         | typedef hyper int64_t;                          |
   |                 |                                                 |
   | uint64_t        | typedef unsigned hyper uint64_t;                |
   |                 |                                                 |
   | attrlist4       | typedef opaque attrlist4&lt;&gt;;                     |
   |                 |                                                 |
   |                 | Used for file/directory attributes.             |
   |                 |                                                 |
   | bitmap4         | typedef uint32_t bitmap4&lt;&gt;;                     |
   |                 |                                                 |
   |                 | Used in attribute array encoding.               |
   |                 |                                                 |
   | changeid4       | typedef uint64_t changeid4;                     |
   |                 |                                                 |
   |                 | Used in the definition of change_info4.         |
   |                 |                                                 |
   | clientid4       | typedef uint64_t clientid4;                     |
   |                 |                                                 |
   |                 | Shorthand reference to client identification.   |
   |                 |                                                 |
   | count4          | typedef uint32_t count4;                        |
   |                 |                                                 |
   |                 | Various count parameters (READ, WRITE, COMMIT). |
   |                 |                                                 |
   | length4         | typedef uint64_t length4;                       |
   |                 |                                                 |
   |                 | Describes LOCK lengths.                         |
   |                 |                                                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | mode4           | typedef uint32_t mode4;                         |
   |                 |                                                 |
   |                 | Mode attribute data type.                       |
   |                 |                                                 |
   | nfs_cookie4     | typedef uint64_t nfs_cookie4;                   |
   |                 |                                                 |
   |                 | Opaque cookie value for READDIR.                |
   |                 |                                                 |
   | nfs_fh4         | typedef opaque nfs_fh4&lt;NFS4_FHSIZE&gt;;            |
   |                 |                                                 |
   |                 | Filehandle definition.                          |
   |                 |                                                 |
   | nfs_ftype4      | enum nfs_ftype4;                                |
   |                 |                                                 |
   |                 | Various defined file types.                     |
   |                 |                                                 |
   | nfsstat4        | enum nfsstat4;                                  |
   |                 |                                                 |
   |                 | Return value for operations.                    |
   |                 |                                                 |
   | nfs_lease4      | typedef uint32_t nfs_lease4;                    |
   |                 |                                                 |
   |                 | Duration of a lease in seconds.                 |
   |                 |                                                 |
   | offset4         | typedef uint64_t offset4;                       |
   |                 |                                                 |
   |                 | Various offset designations (READ, WRITE, LOCK, |
   |                 | COMMIT).                                        |
   |                 |                                                 |
   | qop4            | typedef uint32_t qop4;                          |
   |                 |                                                 |
   |                 | Quality of protection designation in SECINFO.   |
   |                 |                                                 |
   | sec_oid4        | typedef opaque sec_oid4&lt;&gt;;                      |
   |                 |                                                 |
   |                 | Security Object Identifier.  The sec_oid4 data  |
   |                 | type is not really opaque.  Instead, it         |
   |                 | contains an ASN.1 OBJECT IDENTIFIER as used by  |
   |                 | GSS-API in the mech_type argument to            |
   |                 | GSS_Init_sec_context.  See [RFC2743] for        |
   |                 | details.                                        |
   |                 |                                                 |
   | seqid4          | typedef uint32_t seqid4;                        |
   |                 |                                                 |
   |                 | Sequence identifier used for file locking.      |
   |                 |                                                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | utf8string      | typedef opaque utf8string&lt;&gt;;                    |
   |                 |                                                 |
   |                 | UTF-8 encoding for strings.                     |
   |                 |                                                 |
   | utf8str_cis     | typedef utf8string utf8str_cis;                 |
   |                 |                                                 |
   |                 | Case-insensitive UTF-8 string.                  |
   |                 |                                                 |
   | utf8str_cs      | typedef utf8string utf8str_cs;                  |
   |                 |                                                 |
   |                 | Case-sensitive UTF-8 string.                    |
   |                 |                                                 |
   | utf8str_mixed   | typedef utf8string utf8str_mixed;               |
   |                 |                                                 |
   |                 | UTF-8 strings with a case-sensitive prefix and  |
   |                 | a case-insensitive suffix.                      |
   |                 |                                                 |
   | component4      | typedef utf8str_cs component4;                  |
   |                 |                                                 |
   |                 | Represents pathname components.                 |
   |                 |                                                 |
   | linktext4       | typedef opaque linktext4&lt;&gt;;                     |
   |                 |                                                 |
   |                 | Symbolic link contents (&#34;symbolic link&#34; is      |
   |                 | defined in an Open Group [Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 7&#34;&#34;&gt;openg_symlink]        |
   |                 | standard).                                      |
   |                 |                                                 |
   | ascii_REQUIRED4 | typedef utf8string ascii_REQUIRED4;             |
   |                 |                                                 |
   |                 | String is sent as ASCII and thus is             |
   |                 | automatically UTF-8.                            |
   |                 |                                                 |
   | pathname4       | typedef component4 pathname4&lt;&gt;;                 |
   |                 |                                                 |
   |                 | Represents pathname for fs_locations.           |
   |                 |                                                 |
   | nfs_lockid4     | typedef uint64_t nfs_lockid4;                   |
   |                 |                                                 |
   | verifier4       | typedef opaque verifier4[NFS4_VERIFIER_SIZE];   |
   |                 |                                                 |
   |                 | Verifier used for various operations (COMMIT,   |
   |                 | CREATE, OPEN, READDIR, WRITE)                   |
   |                 | NFS4_VERIFIER_SIZE is defined as 8.             |
   +-----------------+-------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Table 1: Base NFSv4 Data Types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
表1：基本NFSv4データ型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Structured Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 構造化データタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. nfstime4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. nfstime4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfstime4 structure gives the number of seconds and nanoseconds since midnight or 0 hour January 1, 1970 Coordinated Universal Time (UTC). Values greater than zero for the seconds field denote dates after the 0 hour January 1, 1970. Values less than zero for the seconds field denote dates before the 0 hour January 1, 1970. In both cases, the nseconds field is to be added to the seconds field for the final time representation. For example, if the time to be represented is one-half second before 0 hour January 1, 1970, the seconds field would have a value of negative one (-1) and the nseconds fields would have a value of one-half second (500000000). Values greater than 999,999,999 for nseconds are considered invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfstime4構造体は、1970年1月1日午前0時または0時からの秒数およびナノ秒数を示します。協定世界時（UTC）。秒フィールドのゼロより大きい値は、1970年1月1日0時間より後の日付を示します。秒フィールドのゼロより小さい値は、1970年1月1日0時間より前の日付を示します。どちらの場合も、n秒フィールドは、最終時刻表現の秒フィールド。たとえば、表現される時間が1970年1月1日0時間前の0.5秒である場合、秒フィールドの値は負の1（-1）になり、n秒フィールドの値は0.5秒（ 500000000）。 n秒の999,999,999より大きい値は無効と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used to pass time and date information. A server converts to and from its local representation of time when processing time values, preserving as much accuracy as possible. If the precision of timestamps stored for a file system object is less than defined, loss of precision can occur. An adjunct time maintenance protocol is recommended to reduce client and server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、日時情報を渡すために使用されます。サーバーは、時間値を処理するときに、時間のローカル表現との間で変換を行い、可能な限り正確さを維持します。ファイルシステムオブジェクトに格納されているタイムスタンプの精度が定義されている精度よりも低い場合、精度が失われる可能性があります。クライアントとサーバーの時間のずれを減らすために、付属の時間保守プロトコルをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. time_how4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. time_how4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum time_how4 {
           SET_TO_SERVER_TIME4 = 0,
           SET_TO_CLIENT_TIME4 = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3. settime4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3. 第7 4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union settime4 switch (time_how4 set_it) {
    case SET_TO_CLIENT_TIME4:
            nfstime4       time;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above definitions are used as the attribute definitions to set time values. If set_it is SET_TO_SERVER_TIME4, then the server uses its local representation of time for the time value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の定義は、時間値を設定するための属性定義として使用されます。 set_itがSET_TO_SERVER_TIME4の場合、サーバーは時間の値としてローカルの時間表現を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.4. specdata4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.4. specdata4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct specdata4 {
           uint32_t specdata1; /* major device number */
           uint32_t specdata2; /* minor device number */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type represents additional information for the device file types NF4CHR and NF4BLK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータタイプは、デバイスファイルタイプNF4CHRおよびNF4BLKの追加情報を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.5. fsid4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.5. fsid4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fsid4 {
           uint64_t        major;
           uint64_t        minor;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This type is the file system identifier that is used as a REQUIRED attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタイプは、REQUIRED属性として使用されるファイルシステム識別子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.6. fs_location4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.6. fs_location4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_location4 {
           utf8str_cis             server&lt;&gt;;
           pathname4               rootpath;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.7. fs_locations4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.7. fs_locations4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_locations4 {
           pathname4       fs_root;
           fs_location4    locations&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_location4 and fs_locations4 data types are used for the fs_locations RECOMMENDED attribute, which is used for migration and replication support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location4およびfs_locations4データ型は、移行およびレプリケーションのサポートに使用されるfs_locations RECOMMENDED属性に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.8. fattr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.8. fattr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fattr4 {
           bitmap4         attrmask;
           attrlist4       attr_vals;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fattr4 structure is used to represent file and directory attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fattr4構造は、ファイルとディレクトリの属性を表すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmap is a counted array of 32-bit integers used to contain bit values. The position of the integer in the array that contains bit n can be computed from the expression (n / 32), and its bit within that integer is (n mod 32).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットマップは、ビット値を含めるために使用される32ビット整数のカウントされた配列です。ビットnを含む配列内の整数の位置は、式（n / 32）から計算でき、その整数内のビットは（n mod 32）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       0            1
     +-----------+-----------+-----------+--
     |  count    | 31  ..  0 | 63  .. 32 |
     +-----------+-----------+-----------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.9. change_info4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.9. change_info4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct change_info4 {
           bool            atomic;
           changeid4       before;
           changeid4       after;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used with the CREATE, LINK, REMOVE, and RENAME operations to let the client know the value of the change attribute for the directory in which the target file system object resides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造はCREATE、LINK、REMOVE、およびRENAME操作で使用され、ターゲットファイルシステムオブジェクトが存在するディレクトリの変更属性の値をクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.10. clientaddr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.10. clientaddr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct clientaddr4 {
           /* see struct rpcb in RFC 1833 */
           string r_netid&lt;&gt;;    /* network id */
           string r_addr&lt;&gt;;     /* universal address */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The clientaddr4 structure is used as part of the SETCLIENTID operation, either (1) to specify the address of the client that is using a client ID or (2) as part of the callback registration. The r_netid and r_addr fields respectively contain a network id and universal address. The network id and universal address concepts, together with formats for TCP over IPv4 and TCP over IPv6, are defined in [RFC5665], specifically Tables 2 and 3 and Sections 5.2.3.3 and 5.2.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientaddr4構造体は、SETCLIENTID操作の一部として使用されます。（1）クライアントIDを使用しているクライアントのアドレスを指定するか、（2）コールバック登録の一部として使用されます。 r_netidフィールドとr_addrフィールドには、それぞれネットワークIDとユニバーサルアドレスが含まれています。ネットワークIDとユニバーサルアドレスの概念、およびTCP over IPv4とTCP over IPv6の形式は、[RFC5665]、具体的には表2と3、およびセクション5.2.3.3と5.2.3.4で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.11. cb_client4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.11. cb_client4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct cb_client4 {
           unsigned int    cb_program;
           clientaddr4     cb_location;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used by the client to inform the server of its callback address; it includes the program number and client address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、クライアントにサーバーにそのコールバックアドレスを通知するために使用されます。プログラム番号とクライアントアドレスが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.12. nfs_client_id4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.12. nfs_client_id4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is part of the arguments to the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、SETCLIENTID操作の引数の一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.13. open_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.13. open_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_owner4 {
           clientid4       clientid;
           opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used to identify the owner of open state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、オープン状態の所有者を識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.14. lock_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.14. lock_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct lock_owner4 {
           clientid4       clientid;
           opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used to identify the owner of file locking state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、ファイルロック状態の所有者を識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.15. open_to_lock_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.15. open_to_lock_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used for the first LOCK operation done for an open_owner4. It provides both the open_stateid and lock_owner such that the transition is made from a valid open_stateid sequence to that of the new lock_stateid sequence. Using this mechanism avoids the confirmation of the lock_owner/lock_seqid pair since it is tied to established state in the form of the open_stateid/open_seqid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、open_owner4に対して行われる最初のLOCK操作に使用されます。有効なopen_stateidシーケンスから新しいlock_stateidシーケンスへの移行が行われるように、open_stateidとlock_ownerの両方を提供します。このメカニズムを使用すると、open_stateid / open_seqidの形式で確立された状態に関連付けられるため、lock_owner / lock_seqidペアの確認が回避されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.16. stateid4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.16. stateid4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct stateid4 {
           uint32_t        seqid;
           opaque          other[NFS4_OTHER_SIZE];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used for the various state-sharing mechanisms between the client and server. For the client, this data structure is read-only. The server is required to increment the seqid field monotonically at each transition of the stateid. This is important since the client will inspect the seqid in OPEN stateids to determine the order of OPEN processing done by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、クライアントとサーバー間のさまざまな状態共有メカニズムに使用されます。クライアントの場合、このデータ構造は読み取り専用です。サーバーは、stateidの各遷移でseqidフィールドを単調に増分する必要があります。クライアントはOPENステートIDのseqidを検査して、サーバーが行うOPEN処理の順序を決定するため、これは重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RPC and Security Flavor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RPCとセキュリティの味
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol is an RPC application that uses RPC version 2 and the XDR as defined in [RFC5531] and [RFC4506]. The RPCSEC_GSS security flavors as defined in version 1 ([RFC2203]) and version 2 ([RFC5403]) MUST be implemented as the mechanism to deliver stronger security for the NFSv4 protocol. However, deployment of RPCSEC_GSS is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルは、RPCバージョン2および[RFC5531]と[RFC4506]で定義されているXDRを使用するRPCアプリケーションです。バージョン1（[RFC2203]）およびバージョン2（[RFC5403]）で定義されているRPCSEC_GSSセキュリティフレーバーは、NFSv4プロトコルのより強力なセキュリティを提供するメカニズムとして実装する必要があります。ただし、RPCSEC_GSSの展開はオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Ports and Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. ポートとトランスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, NFSv2 and NFSv3 servers have resided on port 2049. The registered port 2049 [RFC3232] for the NFS protocol SHOULD be the default configuration. Using the registered port for NFS services means the NFS client will not need to use the RPC binding protocols as described in [RFC1833]; this will allow NFS to transit firewalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的に、NFSv2およびNFSv3サーバーはポート2049に常駐していました。NFSプロトコル用の登録済みポート2049 [RFC3232]は、デフォルトの構成である必要があります（SHOULD）。 NFSサービスに登録されたポートを使用することは、[RFC1833]で説明されているように、NFSクライアントがRPCバインディングプロトコルを使用する必要がないことを意味します。これにより、NFSがファイアウォールを通過できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where an NFSv4 implementation supports operation over the IP network protocol, the supported transport layer between NFS and IP MUST be an IETF standardized transport protocol that is specified to avoid network congestion; such transports include TCP and the Stream Control Transmission Protocol (SCTP). To enhance the possibilities for interoperability, an NFSv4 implementation MUST support operation over the TCP transport protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4実装がIPネットワークプロトコルでの動作をサポートする場合、NFSとIPの間でサポートされるトランスポート層は、ネットワークの輻輳を回避するために指定されたIETF標準トランスポートプロトコルでなければなりません。このようなトランスポートには、TCPおよびStream Control Transmission Protocol（SCTP）が含まれます。相互運用性の可能性を高めるために、NFSv4実装は、TCPトランスポートプロトコルを介した操作をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If TCP is used as the transport, the client and server SHOULD use persistent connections. This will prevent the weakening of TCP&#39;s congestion control via short-lived connections and will improve performance for the Wide Area Network (WAN) environment by eliminating the need for SYN handshakes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPがトランスポートとして使用される場合、クライアントとサーバーは永続的な接続を使用する必要があります（SHOULD）。これにより、存続期間の短い接続によるTCPの輻輳制御の弱体化が防止され、SYNハンドシェイクが不要になるため、ワイドエリアネットワーク（WAN）環境のパフォーマンスが向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As noted in Section 19, the authentication model for NFSv4 has moved from machine-based to principal-based. However, this modification of the authentication model does not imply a technical requirement to move the TCP connection management model from whole machine-based to one based on a per-user model. In particular, NFS over TCP client implementations have traditionally multiplexed traffic for multiple users over a common TCP connection between an NFS client and server. This has been true, regardless of whether the NFS client is using AUTH_SYS, AUTH_DH, RPCSEC_GSS, or any other flavor. Similarly, NFS over TCP server implementations have assumed such a model and thus scale the implementation of TCP connection management in proportion to the number of expected client machines. It is intended that NFSv4 will not modify this connection management model. NFSv4 clients that violate this assumption can expect scaling issues on the server and hence reduced service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
セクション19で述べたように、NFSv4の認証モデルは、マシンベースからプリンシパルベースに移行しました。ただし、この認証モデルの変更は、TCP接続管理モデルをマシンベース全体からユーザーごとのモデルに基づくものに移行するための技術的要件を意味するものではありません。特に、NFS over TCPクライアントの実装では、NFSクライアントとサーバー間の共通のTCP接続を介して、複数のユーザーのトラフィックを従来から多重化しています。これは、NFSクライアントがAUTH_SYS、AUTH_DH、RPCSEC_GSS、またはその他のフレーバーを使用しているかどうかに関係なく当てはまります。同様に、NFS over TCPサーバーの実装ではこのようなモデルを想定しているため、TCP接続管理の実装は、予想されるクライアントマシンの数に比例してスケーリングされます。 NFSv4がこの接続管理モデルを変更しないことを意図しています。この仮定に違反するNFSv4クライアントは、サーバーでのスケーリングの問題を予期し、それによりサービスが低下する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Client Retransmission Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. クライアントの再送信動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When processing an NFSv4 request received over a reliable transport such as TCP, the NFSv4 server MUST NOT silently drop the request, except if the established transport connection has been broken. Given such a contract between NFSv4 clients and servers, clients MUST NOT retry a request unless one or both of the following are true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPなどの信頼できるトランスポートを介して受信したNFSv4要求を処理する場合、NFSv4サーバーは、確立されたトランスポート接続が切断されている場合を除いて、要求を黙ってドロップしてはなりません（MUST NOT）。 NFSv4クライアントとサーバーの間でそのような契約が与えられている場合、次のいずれかまたは両方が当てはまらない限り、クライアントは要求を再試行してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The transport connection has been broken
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トランスポート接続が切断されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The procedure being retried is the NULL procedure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 再試行中のプロシージャはNULLプロシージャです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since reliable transports, such as TCP, do not always synchronously inform a peer when the other peer has broken the connection (for example, when an NFS server reboots), the NFSv4 client may want to actively &#34;probe&#34; the connection to see if has been broken. Use of the NULL procedure is one recommended way to do so. So, when a client experiences a remote procedure call timeout (of some arbitrary implementation-specific amount), rather than retrying the remote procedure call, it could instead issue a NULL procedure call to the server. If the server has died, the transport connection break will eventually be indicated to the NFSv4 client. The client can then reconnect, and then retry the original request. If the NULL procedure call gets a response, the connection has not broken. The client can decide to wait longer for the original request&#39;s response, or it can break the transport connection and reconnect before re-sending the original request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPなどの信頼性の高いトランスポートは、他のピアが接続を切断したとき（たとえば、NFSサーバーが再起動したとき）に常に同期的にピアに通知するわけではないため、NFSv4クライアントは接続をアクティブに「調査」して、壊れた。 NULLプロシージャの使用は、そのための1つの推奨される方法です。したがって、クライアントがリモートプロシージャコールを再試行するのではなく、リモートプロシージャコールタイムアウト（実装固有の任意の量）が発生した場合、代わりにサーバーにNULLプロシージャコールを発行できます。サーバーが停止すると、トランスポート接続の切断が最終的にNFSv4クライアントに示されます。その後、クライアントは再接続して、元の要求を再試行できます。 NULLプロシージャコールが応答を受け取った場合、接続は切断されていません。クライアントは、元の要求の応答をさらに長く待つか、元の要求を再送信する前にトランスポート接続を切断して再接続するかを決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For callbacks from the server to the client, the same rules apply, but the server doing the callback becomes the client, and the client receiving the callback becomes the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーからクライアントへのコールバックにも同じルールが適用されますが、コールバックを実行するサーバーがクライアントになり、コールバックを受信するクライアントがサーバーになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Security Flavors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. セキュリティフレーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traditional RPC implementations have included AUTH_NONE, AUTH_SYS, AUTH_DH, and AUTH_KRB4 as security flavors. With [RFC2203], an additional security flavor of RPCSEC_GSS has been introduced, which uses the functionality of GSS-API [RFC2743]. This allows for the use of various security mechanisms by the RPC layer without the additional implementation overhead of adding RPC security flavors. For NFSv4, the RPCSEC_GSS security flavor MUST be used to enable the mandatory-to-implement security mechanism. Other flavors, such as AUTH_NONE, AUTH_SYS, and AUTH_DH, MAY be implemented as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従来のRPC実装には、セキュリティフレーバーとしてAUTH_NONE、AUTH_SYS、AUTH_DH、AUTH_KRB4が含まれていました。 [RFC2203]で、GSS-API [RFC2743]の機能を使用するRPCSEC_GSSの追加のセキュリティフレーバーが導入されました。これにより、RPCセキュリティフレーバーを追加することによる追加の実装オーバーヘッドなしで、RPCレイヤーによるさまざまなセキュリティメカニズムの使用が可能になります。 NFSv4の場合、RPCSEC_GSSセキュリティフレーバーを使用して、必須から実装までのセキュリティメカニズムを有効にする必要があります。 AUTH_NONE、AUTH_SYS、AUTH_DHなどの他のフレーバーも実装される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Security Mechanisms for NFSv4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. NFSv4のセキュリティメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSS, via GSS-API, supports multiple mechanisms that provide security services. For interoperability, NFSv4 clients and servers MUST support the Kerberos V5 security mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSは、GSS-APIを介して、セキュリティサービスを提供する複数のメカニズムをサポートします。相互運用性のために、NFSv4クライアントとサーバーはKerberos V5セキュリティメカニズムをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of RPCSEC_GSS requires selection of mechanism, quality of protection (QOP), and service (authentication, integrity, privacy). For the mandated security mechanisms, NFSv4 specifies that a QOP of zero is used, leaving it up to the mechanism or the mechanism&#39;s configuration to map QOP zero to an appropriate level of protection. Each mandated mechanism specifies a minimum set of cryptographic algorithms for implementing integrity and privacy. NFSv4 clients and servers MUST be implemented on operating environments that comply with the required cryptographic algorithms of each required mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSを使用するには、メカニズム、保護品質（QOP）、およびサービス（認証、整合性、プライバシー）を選択する必要があります。必須のセキュリティメカニズムの場合、NFSv4はゼロのQOPが使用されることを指定し、メカニズムまたはメカニズムの構成に任せて、QOPゼロを適切な保護レベルにマップします。各必須メカニズムは、整合性とプライバシーを実装するための暗号化アルゴリズムの最小セットを指定します。 NFSv4クライアントとサーバーは、必要な各メカニズムの必要な暗号化アルゴリズムに準拠する動作環境に実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.1. Kerberos V5 as a Security Triple
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.1. セキュリティトリプルとしてのKerberos V5
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Kerberos V5 GSS-API mechanism as described in [RFC4121] MUST be implemented with the RPCSEC_GSS services as specified in Table 2. Both client and server MUST support each of the pseudo-flavors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4121]で説明されているKerberos V5 GSS-APIメカニズムは、表2で指定されているRPCSEC_GSSサービスを使用して実装する必要があります。クライアントとサーバーの両方が、それぞれの疑似フレーバーをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +--------+-------+----------------------+-----------------------+
     | Number | Name  | Mechanism&#39;s OID      | RPCSEC_GSS service    |
     +--------+-------+----------------------+-----------------------+
     | 390003 | krb5  | 1.2.840.113554.1.2.2 | rpc_gss_svc_none      |
     | 390004 | krb5i | 1.2.840.113554.1.2.2 | rpc_gss_svc_integrity |
     | 390005 | krb5p | 1.2.840.113554.1.2.2 | rpc_gss_svc_privacy   |
     +--------+-------+----------------------+-----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Table 2: Mapping Pseudo-Flavor to Service
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
表2：疑似フレーバーとサービスのマッピング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Note that the pseudo-flavor is presented here as a mapping aid to the implementer. Because this NFS protocol includes a method to negotiate security and it understands the GSS-API mechanism, the pseudo-flavor is not needed. The pseudo-flavor is needed for NFSv3 since the security negotiation is done via the MOUNT protocol as described in [RFC2623].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ここでは、疑似フレーバーが実装者へのマッピング支援として提示されていることに注意してください。このNFSプロトコルには、セキュリティをネゴシエートする方法が含まれており、GSS-APIメカニズムを理解しているため、疑似フレーバーは必要ありません。 [RFC2623]で説明されているように、セキュリティネゴシエーションはMOUNTプロトコルを介して行われるため、NFSv3には疑似フレーバーが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the time this document was specified, the Advanced Encryption Standard (AES) with HMAC-SHA1 was a required algorithm set for Kerberos V5. In contrast, when NFSv4.0 was first specified in [RFC3530], weaker algorithm sets were REQUIRED for Kerberos V5, and were REQUIRED in the NFSv4.0 specification, because the Kerberos V5 specification at the time did not specify stronger algorithms. The NFSv4 specification does not specify required algorithms for Kerberos V5, and instead, the implementer is expected to track the evolution of the Kerberos V5 standard if and when stronger algorithms are specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントが指定された時点では、HMAC-SHA1を使用したAdvanced Encryption Standard（AES）がKerberos V5に必要なアルゴリズムセットでした。対照的に、[RFC3530]でNFSv4.0が最初に指定されたとき、Kerberos V5仕様はより強力なアルゴリズムを指定していなかったため、より弱いアルゴリズムセットはKerberos V5で必須であり、NFSv4.0仕様で必須でした。 NFSv4仕様はKerberos V5に必要なアルゴリズムを指定していません。代わりに、より強力なアルゴリズムが指定されている場合、実装者はKerberos V5標準の進化を追跡することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.2.1.1.1. Security Considerations for Cryptographic Algorithms in Kerberos V5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.2.1.1.1. Kerberos V5の暗号化アルゴリズムのセキュリティに関する考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When deploying NFSv4, the strength of the security achieved depends on the existing Kerberos V5 infrastructure. The algorithms of Kerberos V5 are not directly exposed to or selectable by the client or server, so there is some due diligence required by the user of NFSv4 to ensure that security is acceptable where needed. Guidance is provided in [RFC6649] as to why weak algorithms should be disabled by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4を導入する場合、達成されるセキュリティの強度は、既存のKerberos V5インフラストラクチャに依存します。 Kerberos V5のアルゴリズムは、クライアントやサーバーに直接公開されたり、選択したりすることはできないため、NFSv4のユーザーは、必要な場所でセキュリティを確実に受け入れるために、ある程度の注意が必要です。 [RFC6649]では、弱いアルゴリズムをデフォルトで無効にする必要がある理由についてのガイダンスが提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Security Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. セキュリティ交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFSv4 server potentially offering multiple security mechanisms, the client needs a method to determine or negotiate which mechanism is to be used for its communication with the server. The NFS server can have multiple points within its file system namespace that are available for use by NFS clients. In turn, the NFS server can be configured such that each of these entry points can have different or multiple security mechanisms in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4サーバーは複数のセキュリティメカニズムを提供する可能性があるため、クライアントは、サーバーとの通信に使用するメカニズムを決定またはネゴシエートする方法を必要とします。 NFSサーバーは、NFSクライアントが使用できるファイルシステム名前空間内に複数のポイントを持つことができます。次に、NFSサーバーは、これらの各エントリポイントが異なるセキュリティメカニズムまたは複数のセキュリティメカニズムを使用できるように構成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security negotiation between client and server SHOULD be done with a secure channel to eliminate the possibility of a third party intercepting the negotiation sequence and forcing the client and server to choose a lower level of security than required or desired. See Section 19 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバー間のセキュリティネゴシエーションは、第三者がネゴシエーションシーケンスを傍受し、クライアントとサーバーが必要または望ましいレベルよりも低いセキュリティレベルを選択する可能性を排除するために、安全なチャネルで行う必要があります。詳細については、セクション19を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. SECINFO
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. SECINFO
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO operation will allow the client to determine, on a per-filehandle basis, what security triple (see [RFC2743] and Section 16.31.4) is to be used for server access. In general, the client will not have to use the SECINFO operation, except during initial communication with the server or when the client encounters a new security policy as the client navigates the namespace. Either condition will force the client to negotiate a new security triple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO操作により、クライアントはファイルハンドルごとに、サーバーアクセスに使用するセキュリティトリプル（[RFC2743]とセクション16.31.4を参照）を決定できます。一般に、クライアントは、サーバーとの最初の通信中、またはクライアントが名前空間をナビゲートするときにクライアントが新しいセキュリティポリシーに遭遇したときを除いて、SECINFO操作を使用する必要はありません。どちらの条件でも、クライアントは新しいセキュリティトリプルをネゴシエートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. Security Error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. セキュリティエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the assumption that each NFSv4 client and server MUST support a minimum set of security (i.e., Kerberos V5 under RPCSEC_GSS), the NFS client will start its communication with the server with one of the minimal security triples. During communication with the server, the client can receive an NFS error of NFS4ERR_WRONGSEC. This error allows the server to notify the client that the security triple currently being used is not appropriate for access to the server&#39;s file system resources. The client is then responsible for determining what security triples are available at the server and choosing one that is appropriate for the client. See Section 16.31 for further discussion of how the client will respond to the NFS4ERR_WRONGSEC error and use SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各NFSv4クライアントとサーバーは最小限のセキュリティセット（つまり、RPCSEC_GSSでのKerberos V5）をサポートする必要があるという想定に基づいて、NFSクライアントはサーバーとの通信を最小限のセキュリティトリプルの1つで開始します。サーバーとの通信中に、クライアントはNFS4ERR_WRONGSECのNFSエラーを受け取ることがあります。このエラーにより、サーバーは、現在使用されているセキュリティトリプルがサーバーのファイルシステムリソースへのアクセスに適切でないことをクライアントに通知できます。次に、クライアントは、サーバーで利用可能なセキュリティトリプルを決定し、クライアントに適したものを選択する責任があります。クライアントがNFS4ERR_WRONGSECエラーに応答し、SECINFOを使用する方法の詳細については、セクション16.31を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3. Callback RPC Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3. コールバックRPC認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except as noted elsewhere in this section, the callback RPC (described later) MUST mutually authenticate the NFS server to the principal that acquired the client ID (also described later), using the security flavor of the original SETCLIENTID operation used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの他の箇所で言及されている場合を除き、コールバックRPC（後述）は、使用された元のSETCLIENTID操作のセキュリティフレーバーを使用して、クライアントID（これも後述）を取得したプリンシパルに対してNFSサーバーを相互認証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AUTH_NONE, there are no principals, so this is a non-issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_NONEの場合、プリンシパルがないため、これは問題にはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_SYS has no notions of mutual authentication or a server principal, so the callback from the server simply uses the AUTH_SYS credential that the user used when he set up the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_SYSには相互認証やサーバープリンシパルの概念がないため、サーバーからのコールバックは、ユーザーが委任を設定したときに使用したAUTH_SYS資格情報を使用するだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AUTH_DH, one commonly used convention is that the server uses the credential corresponding to this AUTH_DH principal:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_DHの場合、一般的に使用される規則の1つは、サーバーがこのAUTH_DHプリンシパルに対応する資格を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
unix.host@domain
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
うにｘ。ほｓｔ＠どまいん
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where host and domain are variables corresponding to the name of the server host and directory services domain in which it lives, such as a Network Information System domain or a DNS domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、hostおよびdomainは、ネットワーク情報システムドメインやDNSドメインなど、サーバーが存在するサーバーホストおよびディレクトリサービスドメインの名前に対応する変数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of what security mechanism under RPCSEC_GSS is being used, the NFS server MUST identify itself in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type. GSS_C_NT_HOSTBASED_SERVICE names are of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSで使用されているセキュリティメカニズムに関係なく、NFSサーバーはGSS_C_NT_HOSTBASED_SERVICE名前タイプを介してGSS-APIで自身を識別しなければなりません。 GSS_C_NT_HOSTBASED_SERVICEの名前の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
service@hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
service @ hostname
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For NFS, the &#34;service&#34; element is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSの場合、「service」要素は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
nfs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
同じ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of security mechanisms will convert nfs@hostname to various different forms. For Kerberos V5, the following form is RECOMMENDED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティメカニズムを実装すると、nfs @ hostnameがさまざまな形式に変換されます。 Kerberos V5の場合、次の形式が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
nfs/hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
nfs /ホスト名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Kerberos V5, nfs/hostname would be a server principal in the Kerberos Key Distribution Center database. This is the same principal the client acquired a GSS-API context for when it issued the SETCLIENTID operation; therefore, the realm name for the server principal must be the same for the callback as it was for the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kerberos V5の場合、nfs / hostnameはKerberosキー配布センターデータベースのサーバープリンシパルになります。これは、クライアントがSETCLIENTID操作を発行したときにGSS-APIコンテキストを取得したのと同じプリンシパルです。したがって、サーバープリンシパルのレルム名は、SETCLIENTIDの場合と同じである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Filehandles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle in the NFS protocol is a per-server unique identifier for a file system object. The contents of the filehandle are opaque to the client. Therefore, the server is responsible for translating the filehandle to an internal representation of the file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルのファイルハンドルは、ファイルシステムオブジェクトのサーバーごとの一意の識別子です。ファイルハンドルの内容はクライアントに対して不透明です。したがって、サーバーはファイルハンドルをファイルシステムオブジェクトの内部表現に変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Obtaining the First Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 最初のファイルハンドルを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations of the NFS protocol are defined in terms of one or more filehandles. Therefore, the client needs a filehandle to initiate communication with the server. With the NFSv2 protocol [RFC1094] and the NFSv3 protocol [RFC1813], there exists an ancillary protocol to obtain this first filehandle. The MOUNT protocol, RPC program number 100005, provides the mechanism of translating a string-based file system pathname to a filehandle that can then be used by the NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの操作は、1つ以上のファイルハンドルで定義されます。したがって、クライアントはサーバーとの通信を開始するためにファイルハンドルを必要とします。 NFSv2プロトコル[RFC1094]およびNFSv3プロトコル[RFC1813]では、この最初のファイルハンドルを取得するための補助的なプロトコルが存在します。 MOUNTプロトコル、RPCプログラム番号100005は、文字列ベースのファイルシステムパス名を、NFSプロトコルで使用できるファイルハンドルに変換するメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The MOUNT protocol has deficiencies in the area of security and use via firewalls. This is one reason that the use of the public filehandle was introduced in [RFC2054] and [RFC2055]. With the use of the public filehandle in combination with the LOOKUP operation in the NFSv2 and NFSv3 protocols, it has been demonstrated that the MOUNT protocol is unnecessary for viable interaction between the NFS client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
MOUNTプロトコルには、セキュリティおよびファイアウォール経由の使用の分野での欠点があります。これは、パブリックファイルハンドルの使用が[RFC2054]と[RFC2055]で導入された1つの理由です。 NFSv2およびNFSv3プロトコルのLOOKUP操作と組み合わせてパブリックファイルハンドルを使用すると、NFSクライアントとサーバー間の実行可能な対話にはMOUNTプロトコルが不要であることが実証されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the NFSv4 protocol will not use an ancillary protocol for translation from string-based pathnames to a filehandle. Two special filehandles will be used as starting points for the NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、NFSv4プロトコルは、文字列ベースのパス名からファイルハンドルへの変換に補助プロトコルを使用しません。 NFSクライアントの開始点として、2つの特別なファイルハンドルが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. ルートファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first of the special filehandles is the root filehandle. The root filehandle is the &#34;conceptual&#34; root of the file system namespace at the NFS server. The client uses or starts with the root filehandle by employing the PUTROOTFH operation. The PUTROOTFH operation instructs the server to set the current filehandle to the root of the server&#39;s file tree. Once this PUTROOTFH operation is used, the client can then traverse the entirety of the server&#39;s file tree with the LOOKUP operation. A complete discussion of the server namespace is in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別なファイルハンドルの最初のものはルートファイルハンドルです。ルートファイルハンドルは、NFSサーバーでのファイルシステム名前空間の「概念的な」ルートです。クライアントは、PUTROOTFH操作を使用して、ルートファイルハンドルを使用するか、ルートファイルハンドルで開始します。 PUTROOTFH操作は、現在のファイルハンドルをサーバーのファイルツリーのルートに設定するようサーバーに指示します。このPUTROOTFH操作を使用すると、クライアントはLOOKUP操作を使用してサーバーのファイルツリー全体をトラバースできます。サーバーの名前空間の詳細については、セクション7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 公開ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second special filehandle is the public filehandle. Unlike the root filehandle, the public filehandle may be bound or represent an arbitrary file system object at the server. The server is responsible for this binding. It may be that the public filehandle and the root filehandle refer to the same file system object. However, it is up to the administrative software at the server and the policies of the server administrator to define the binding of the public filehandle and server file system object. The client may not make any assumptions about this binding. The client uses the public filehandle via the PUTPUBFH operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目の特別なファイルハンドルは、公開ファイルハンドルです。ルートファイルハンドルとは異なり、パブリックファイルハンドルはバインドされているか、サーバーで任意のファイルシステムオブジェクトを表します。サーバーはこのバインディングを担当します。パブリックファイルハンドルとルートファイルハンドルが同じファイルシステムオブジェクトを参照している可能性があります。ただし、パブリックファイルハンドルとサーバーファイルシステムオブジェクトのバインディングを定義するのは、サーバーの管理ソフトウェアとサーバー管理者のポリシー次第です。クライアントは、このバインディングについて何も想定していません。クライアントは、PUTPUBFH操作を介してパブリックファイルハンドルを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. ファイルハンドルのタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFSv2 and NFSv3 protocols, there was one type of filehandle with a single set of semantics, of which the primary one was that it was persistent across a server reboot. As such, this type of filehandle is termed &#34;persistent&#34; in NFSv4. The semantics of a persistent filehandle remain the same as before. A new type of filehandle introduced in NFSv4 is the volatile filehandle, which attempts to accommodate certain server environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv2およびNFSv3プロトコルでは、単一のセマンティクスのセットを持つ1種類のファイルハンドルがあり、その主なものはサーバーの再起動後も永続的であるというものでした。そのため、このタイプのファイルハンドルは、NFSv4では「永続的」と呼ばれています。永続ファイルハンドルのセマンティクスは以前と同じままです。 NFSv4で導入された新しいタイプのファイルハンドルは、特定のサーバー環境に対応しようとする揮発性ファイルハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The volatile filehandle type was introduced to address server functionality or implementation issues that make correct implementation of a persistent filehandle infeasible. Some server environments do not provide a file system level invariant that can be used to construct a persistent filehandle. The underlying server file system may not provide the invariant, or the server&#39;s file system programming interfaces may not provide access to the needed invariant. Volatile filehandles may ease the implementation of server functionality, such as hierarchical storage management or file system reorganization or migration. However, the volatile filehandle increases the implementation burden for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
揮発性ファイルハンドルタイプは、永続ファイルハンドルの正しい実装を実行不可能にするサーバーの機能または実装の問題に対処するために導入されました。一部のサーバー環境では、永続的なファイルハンドルの構築に使用できるファイルシステムレベルの不変条件が提供されていません。基盤となるサーバーファイルシステムが不変条件を提供していないか、サーバーのファイルシステムプログラミングインターフェイスが必要な不変条件へのアクセスを提供していない可能性があります。揮発性ファイルハンドルにより、階層ストレージ管理やファイルシステムの再編成や移行などのサーバー機能の実装が容易になる場合があります。ただし、揮発性ファイルハンドルは、クライアントの実装負担を増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the client will need to handle persistent and volatile filehandles differently, a file attribute is defined that may be used by the client to determine the filehandle types being returned by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは永続的なファイルハンドルと揮発性のファイルハンドルを別々に処理する必要があるため、サーバーが返すファイルハンドルのタイプを決定するためにクライアントが使用できるファイル属性が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. General Properties of a Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. ファイルハンドルの一般的なプロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle contains all the information the server needs to distinguish an individual file. To the client, the filehandle is opaque. The client stores filehandles for use in a later request and can compare two filehandles from the same server for equality by doing a byte-by-byte comparison. However, the client MUST NOT otherwise interpret the contents of filehandles. If two filehandles from the same server are equal, they MUST refer to the same file. However, it is not required that two different filehandles refer to different file system objects. Servers SHOULD try to maintain a one-to-one correspondence between filehandles and file system objects but there may be situations in which the mapping is not one-to-one. Clients MUST use filehandle comparisons only to improve performance, not for correct behavior. All clients need to be prepared for situations in which it cannot be determined whether two different filehandles denote the same object and in such cases need to avoid assuming that objects denoted are different, as this might cause incorrect behavior. Further discussion of filehandle and attribute comparison in the context of data caching is presented in Section 10.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルには、サーバーが個々のファイルを区別するために必要なすべての情報が含まれています。クライアントにとって、ファイルハンドルは不透明です。クライアントは、後の要求で使用するためにファイルハンドルを格納し、バイトごとの比較を行うことにより、同じサーバーからの2つのファイルハンドルが等しいかどうかを比較できます。ただし、クライアントはファイルハンドルの内容を別の方法で解釈してはなりません（MUST NOT）。同じサーバーからの2つのファイルハンドルが等しい場合、それらは同じファイルを参照する必要があります。ただし、2つの異なるファイルハンドルが異なるファイルシステムオブジェクトを参照する必要はありません。サーバーは、ファイルハンドルとファイルシステムオブジェクト間の1対1の対応を維持する必要がありますが、マッピングが1対1ではない場合があります。クライアントは、正しい動作ではなく、パフォーマンスを向上させるためにのみファイルハンドル比較を使用する必要があります。すべてのクライアントは、2つの異なるファイルハンドルが同じオブジェクトを示しているかどうかを判断できない状況に備える必要があります。その場合、誤った動作を引き起こす可能性があるため、示されているオブジェクトが異なると想定しないようにする必要があります。データキャッシュのコンテキストでのファイルハンドルと属性比較の詳細については、セクション10.3.4で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, in the case that two different pathnames when traversed at the server terminate at the same file system object, the server SHOULD return the same filehandle for each path. This can occur if a hard link is used to create two filenames that refer to the same underlying file object and associated data. For example, if paths /a/b/c and /a/d/c refer to the same file, the server SHOULD return the same filehandle for both pathname traversals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、サーバーでトラバースしたときに2つの異なるパス名が同じファイルシステムオブジェクトで終了する場合、サーバーは各パスに対して同じファイルハンドルを返す必要があります（SHOULD）。これは、ハードリンクを使用して、同じ基本的なファイルオブジェクトと関連データを参照する2つのファイル名を作成した場合に発生する可能性があります。たとえば、パス/ a / b / cと/ a / d / cが同じファイルを参照している場合、サーバーは両方のパス名トラバーサルに対して同じファイルハンドルを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Persistent Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 永続的なファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A persistent filehandle is defined as having a fixed value for the lifetime of the file system object to which it refers. Once the server creates the filehandle for a file system object, the server MUST accept the same filehandle for the object for the lifetime of the object. If the server restarts or reboots, the NFS server must honor the same filehandle value as it did in the server&#39;s previous instantiation. Similarly, if the file system is migrated, the new NFS server must honor the same filehandle as the old NFS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
永続ファイルハンドルは、それが参照するファイルシステムオブジェクトの存続期間中、固定値を持つものとして定義されます。サーバーがファイルシステムオブジェクトのファイルハンドルを作成すると、サーバーはオブジェクトの存続期間中、オブジェクトの同じファイルハンドルを受け入れる必要があります。サーバーが再起動または再起動する場合、NFSサーバーはサーバーの以前のインスタンス化と同じファイルハンドル値を受け入れる必要があります。同様に、ファイルシステムが移行される場合、新しいNFSサーバーは古いNFSサーバーと同じファイルハンドルを受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The persistent filehandle will become stale or invalid when the file system object is removed. When the server is presented with a persistent filehandle that refers to a deleted object, it MUST return an error of NFS4ERR_STALE. A filehandle may become stale when the file system containing the object is no longer available. The file system may become unavailable if it exists on removable media and the media is no longer available at the server, or if the file system in whole has been destroyed, or if the file system has simply been removed from the server&#39;s namespace (i.e., unmounted in a UNIX environment).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続ファイルハンドルは、ファイルシステムオブジェクトが削除されると、古くなるか無効になります。サーバーが、削除されたオブジェクトを参照する永続的なファイルハンドルを提示されると、NFS4ERR_STALEのエラーを返さなければなりません（MUST）。オブジェクトを含むファイルシステムが使用できなくなると、ファイルハンドルが古くなる場合があります。ファイルシステムがリムーバブルメディアに存在し、メディアがサーバーで使用できなくなった場合、ファイルシステム全体が破壊された場合、またはファイルシステムがサーバーの名前空間から削除された場合（つまり、 UNIX環境ではマウント解除されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. 揮発性ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A volatile filehandle does not share the same longevity characteristics of a persistent filehandle. The server may determine that a volatile filehandle is no longer valid at many different points in time. If the server can definitively determine that a volatile filehandle refers to an object that has been removed, the server should return NFS4ERR_STALE to the client (as is the case for persistent filehandles). In all other cases where the server determines that a volatile filehandle can no longer be used, it should return an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルは、永続ファイルハンドルと同じ寿命特性を共有しません。サーバーは、揮発性ファイルハンドルが多くの異なる時点で有効ではなくなったと判断する場合があります。揮発性ファイルハンドルが削除されたオブジェクトを参照しているとサーバーが明確に判断できる場合、サーバーはNFS4ERR_STALEをクライアントに返す必要があります（永続ファイルハンドルの場合と同様）。揮発性ファイルハンドルが使用できなくなったとサーバーが判断する他のすべてのケースでは、NFS4ERR_FHEXPIREDのエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REQUIRED attribute &#34;fh_expire_type&#34; is used by the client to determine what type of filehandle the server is providing for a particular file system. This attribute is a bitmask with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須属性「fh_expire_type」は、サーバーが特定のファイルシステムに提供するファイルハンドルのタイプを決定するためにクライアントによって使用されます。この属性は、次の値を持つビットマスクです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_PERSISTENT: The value of FH4_PERSISTENT is used to indicate a persistent filehandle, which is valid until the object is removed from the file system. The server will not return NFS4ERR_FHEXPIRED for this filehandle. FH4_PERSISTENT is defined as a value in which none of the bits specified below are set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_PERSISTENT：FH4_PERSISTENTの値は、オブジェクトがファイルシステムから削除されるまで有効な永続的なファイルハンドルを示すために使用されます。サーバーは、このファイルハンドルに対してNFS4ERR_FHEXPIREDを返しません。 FH4_PERSISTENTは、以下に指定されたビットが設定されていない値として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANY: The filehandle may expire at any time, except as specifically excluded (i.e., FH4_NOEXPIRE_WITH_OPEN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANY：特に除外されている場合（FH4_NOEXPIRE_WITH_OPENなど）を除き、ファイルハンドルはいつでも期限切れになる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_NOEXPIRE_WITH_OPEN: May only be set when FH4_VOLATILE_ANY is set. If this bit is set, then the meaning of FH4_VOLATILE_ANY is qualified to exclude any expiration of the filehandle when it is open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_NOEXPIRE_WITH_OPEN：FH4_VOLATILE_ANYが設定されている場合にのみ設定できます。このビットが設定されている場合、FH4_VOLATILE_ANYの意味は、ファイルハンドルが開いているときにファイルハンドルの有効期限を除外するように修飾されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATION: The filehandle will expire as a result of migration. If FH4_VOLATILE_ANY is set, FH4_VOL_MIGRATION is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATION：移行の結果としてファイルハンドルが期限切れになります。 FH4_VOLATILE_ANYが設定されている場合、FH4_VOL_MIGRATIONは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_RENAME: The filehandle will expire during rename. This includes a rename by the requesting client or a rename by any other client. If FH4_VOLATILE_ANY is set, FH4_VOL_RENAME is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_RENAME：ファイルハンドルは名前変更中に期限切れになります。これには、要求元クライアントによる名前変更、または他のクライアントによる名前変更が含まれます。 FH4_VOLATILE_ANYが設定されている場合、FH4_VOL_RENAMEは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that provide volatile filehandles that may expire while open (i.e., if FH4_VOL_MIGRATION or FH4_VOL_RENAME is set or if FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN is not set) should deny a RENAME or REMOVE that would affect an OPEN file of any of the components leading to the OPEN file. In addition, the server SHOULD deny all RENAME or REMOVE requests during the grace period upon server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開いている間に期限切れになる可能性のある揮発性ファイルハンドルを提供するサーバー（つまり、FH4_VOL_MIGRATIONまたはFH4_VOL_RENAMEが設定されている場合、またはFH4_VOLATILE_ANYが設定され、FH4_NOEXPIRE_WITH_OPENが設定されていない場合）は、ファイルを開く。さらに、サーバーはサーバーの再起動時の猶予期間中、すべてのRENAMEまたはREMOVEリクエストを拒否する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the bits FH4_VOL_MIGRATION and FH4_VOL_RENAME allow the client to determine that expiration has occurred whenever a specific event occurs, without an explicit filehandle expiration error from the server. FH4_VOLATILE_ANY does not provide this form of information. In situations where the server will expire many, but not all, filehandles upon migration (e.g., all but those that are open), FH4_VOLATILE_ANY (in this case, with FH4_NOEXPIRE_WITH_OPEN) is a better choice since the client may not assume that all filehandles will expire when migration occurs, and it is likely that additional expirations will occur (as a result of file CLOSE) that are separated in time from the migration event itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATIONビットとFH4_VOL_RENAMEビットを使用すると、クライアントは、サーバーからの明示的なファイルハンドル有効期限エラーなしで、特定のイベントが発生するたびに有効期限が発生したと判断できます。 FH4_VOLATILE_ANYは、この形式の情報を提供しません。サーバーが移行時にすべてではなく多くのファイルハンドル（たとえば、開いているものを除く）を期限切れにする状況では、FH4_VOLATILE_ANY（この場合、FH4_NOEXPIRE_WITH_OPENを使用）は、クライアントがすべてのファイルハンドルが移行が発生すると期限切れになり、移行イベント自体から時間的に分離された（ファイルのCLOSEの結果として）追加の期限切れが発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4. One Method of Constructing a Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4. 揮発性ファイルハンドルを構築する1つの方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A volatile filehandle, while opaque to the client, could contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルは、クライアントには不透明ですが、以下を含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
[volatile bit = 1 | server boot time | slot | generation number]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
[揮発性ビット= 1 |サーバーの起動時間|スロット|世代番号]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o slot is an index in the server volatile filehandle table
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o スロットは、サーバーの揮発性ファイルハンドルテーブルのインデックスです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o generation number is the generation number for the table entry/slot
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 世代番号は、テーブルエントリ/スロットの世代番号です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client presents a volatile filehandle, the server makes the following checks, which assume that the check for the volatile bit has passed. If the server boot time is less than the current server boot time, return NFS4ERR_FHEXPIRED. If slot is out of range, return NFS4ERR_BADHANDLE. If the generation number does not match, return NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが揮発性ファイルハンドルを提示すると、サーバーは次のチェックを行います。これは、揮発性ビットのチェックに合格したことを前提としています。サーバーの起動時間が現在のサーバーの起動時間よりも短い場合は、NFS4ERR_FHEXPIREDを返します。スロットが範囲外の場合は、NFS4ERR_BADHANDLEを返します。世代番号が一致しない場合は、NFS4ERR_FHEXPIREDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server reboots, the table is gone (it is volatile).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが再起動すると、テーブルは消えます（揮発性です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the volatile bit is 0, then it is a persistent filehandle with a different structure following it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ビットが0の場合、それはその後に別の構造を持つ永続ファイルハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Client Recovery from Filehandle Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. ファイルハンドルの有効期限からのクライアントの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If possible, the client should recover from the receipt of an NFS4ERR_FHEXPIRED error. The client must take on additional responsibility so that it may prepare itself to recover from the expiration of a volatile filehandle. If the server returns persistent filehandles, the client does not need these additional steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能であれば、クライアントはNFS4ERR_FHEXPIREDエラーの受信から回復する必要があります。クライアントは、揮発性ファイルハンドルの期限切れから回復する準備をするために、追加の責任を負う必要があります。サーバーが永続的なファイルハンドルを返す場合、クライアントはこれらの追加手順を必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For volatile filehandles, most commonly the client will need to store the component names leading up to and including the file system object in question. With these names, the client should be able to recover by finding a filehandle in the namespace that is still available or by starting at the root of the server&#39;s file system namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルの場合、最も一般的には、クライアントは問題のファイルシステムオブジェクトに至るまでのコンポーネント名を格納する必要があります。これらの名前を使用すると、クライアントは、まだ使用可能なネームスペースでファイルハンドルを見つけるか、サーバーのファイルシステムネームスペースのルートから開始することで回復できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the expired filehandle refers to an object that has been removed from the file system, obviously the client will not be able to recover from the expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れのファイルハンドルがファイルシステムから削除されたオブジェクトを参照している場合、明らかにクライアントは期限切れのファイルハンドルから回復することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also possible that the expired filehandle refers to a file that has been renamed. If the file was renamed by another client, again it is possible that the original client will not be able to recover. However, in the case that the client itself is renaming the file and the file is open, it is possible that the client may be able to recover. The client can determine the new pathname based on the processing of the rename request. The client can then regenerate the new filehandle based on the new pathname. The client could also use the COMPOUND operation mechanism to construct a set of operations like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れのファイルハンドルが名前が変更されたファイルを参照している可能性もあります。ファイルの名前が別のクライアントによって変更された場合、元のクライアントが回復できない可能性があります。ただし、クライアント自体がファイルの名前を変更していて、ファイルが開いている場合は、クライアントが回復できる可能性があります。クライアントは、名前変更要求の処理に基づいて新しいパス名を決定できます。その後、クライアントは新しいパス名に基づいて新しいファイルハンドルを再生成できます。クライアントはCOMPOUND操作メカニズムを使用して、次のような一連の操作を構築することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RENAME A B LOOKUP B GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A B LOOKUP B GETFHの名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the COMPOUND procedure does not provide atomicity. This example only reduces the overhead of recovering from an expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは原子性を提供しないことに注意してください。この例では、期限切れのファイルハンドルからの回復のオーバーヘッドのみを削減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. の属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To meet the requirements of extensibility and increased interoperability with non-UNIX platforms, attributes need to be handled in a flexible manner. The NFSv3 fattr3 structure contains a fixed list of attributes that not all clients and servers are able to support or care about. The fattr3 structure cannot be extended as new needs arise, and it provides no way to indicate non-support. With the NFSv4.0 protocol, the client is able to query what attributes the server supports and construct requests with only those supported attributes (or a subset thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
UNIX以外のプラットフォームとの拡張性と相互運用性の要件を満たすには、属性を柔軟に処理する必要があります。 NFSv3 fattr3構造には、すべてのクライアントとサーバーがサポートまたは処理できる属性の固定リストが含まれています。新しいニーズが発生した場合、fattr3構造を拡張することはできず、サポートされていないことを示す方法はありません。 NFSv4.0プロトコルを使用すると、クライアントはサーバーがサポートする属性を照会し、サポートされている属性（またはそのサブセット）のみを使用して要求を作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To this end, attributes are divided into three groups: REQUIRED, RECOMMENDED, and named. Both REQUIRED and RECOMMENDED attributes are supported in the NFSv4.0 protocol by a specific and well-defined encoding and are identified by number. They are requested by setting a bit in the bit vector sent in the GETATTR request; the server response includes a bit vector to list what attributes were returned in the response. New REQUIRED or RECOMMENDED attributes may be added to the NFSv4 protocol as part of a new minor version by publishing a Standards Track RFC that allocates a new attribute number value and defines the encoding for the attribute. See Section 11 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このために、属性はREQUIRED、RECOMMENDED、およびnamedという3つのグループに分けられます。 REQUIRED属性とRECOMMENDED属性の両方が、NFSv4.0プロトコルで特定の明確に定義されたエンコーディングによってサポートされ、番号で識別されます。これらは、GETATTR要求で送信されたビットベクトルにビットを設定することによって要求されます。サーバー応答には、応答で返された属性をリストするビットベクトルが含まれています。新しい属性番号の値を割り当て、属性のエンコーディングを定義するStandards Track RFCを公開することにより、新しいREQUIREDまたはRECOMMENDED属性を新しいマイナーバージョンの一部としてNFSv4プロトコルに追加できます。詳細については、セクション11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes are accessed by the OPENATTR operation, which accesses a hidden directory of attributes associated with a file system object. OPENATTR takes a filehandle for the object and returns the filehandle for the attribute hierarchy. The filehandle for the named attributes is a directory object accessible by LOOKUP or READDIR and contains files whose names represent the named attributes and whose data bytes are the value of the attribute. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、ファイルシステムオブジェクトに関連付けられた属性の非表示ディレクトリにアクセスするOPENATTR操作によってアクセスされます。 OPENATTRはオブジェクトのファイルハンドルを受け取り、属性階層のファイルハンドルを返します。名前付き属性のファイルハンドルは、LOOKUPまたはREADDIRによってアクセス可能なディレクトリオブジェクトであり、名前が名前付き属性を表し、データバイトが属性の値であるファイルが含まれています。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +----------+-----------+---------------------------------+
        | LOOKUP   | &#34;foo&#34;     | ; look up file                  |
        | GETATTR  | attrbits  |                                 |
        | OPENATTR |           | ; access foo&#39;s named attributes |
        | LOOKUP   | &#34;x11icon&#34; | ; look up specific attribute    |
        | READ     | 0,4096    | ; read stream of bytes          |
        +----------+-----------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes are intended for data needed by applications rather than by an NFS client implementation. NFS implementers are strongly encouraged to define their new attributes as RECOMMENDED attributes by bringing them to the IETF Standards Track process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、NFSクライアント実装ではなく、アプリケーションが必要とするデータを対象としています。 NFS実装者は、IETF標準トラックプロセスにそれらを持ち込むことにより、それらの新しい属性を推奨属性として定義することを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of attributes that are classified as REQUIRED is deliberately small since servers need to do whatever it takes to support them. A server should support as many of the RECOMMENDED attributes as possible; however, by their definition, the server is not required to support all of them. Attributes are deemed REQUIRED if the data is both needed by a large number of clients and is not otherwise reasonably computable by the client when support is not provided on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUIREDとして分類される属性のセットは、サーバーがそれらをサポートするために必要なことを何でも行う必要があるため、意図的に小さくなっています。サーバーは、可能な限り多くのRECOMMENDED属性をサポートする必要があります。ただし、その定義により、サーバーはそれらすべてをサポートする必要はありません。多数のクライアントがデータを必要とし、サーバーでサポートが提供されていない場合にクライアントが合理的に計算できない場合、属性は必須と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the hidden directory returned by OPENATTR is a convenience for protocol processing. The client should not make any assumptions about the server&#39;s implementation of named attributes and whether or not the underlying file system at the server has a named attribute directory. Therefore, operations such as SETATTR and GETATTR on the named attribute directory are undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENATTRによって返される隠しディレクトリは、プロトコル処理に便利です。クライアントは、サーバーの名前付き属性の実装について、およびサーバーの基盤となるファイルシステムに名前付き属性ディレクトリがあるかどうかについて、いかなる仮定も行わないでください。したがって、名前付き属性ディレクトリーに対するSETATTRやGETATTRなどの操作は未定義です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. REQUIRED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 必須の属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes MUST be supported by every NFSv4.0 client and server in order to ensure a minimum level of interoperability. The server MUST store and return these attributes, and the client MUST be able to function with an attribute set limited to these attributes. With just the REQUIRED attributes, some client functionality can be impaired or limited in some ways. A client can ask for any of these attributes to be returned by setting a bit in the GETATTR request. For each such bit set, the server MUST return the corresponding attribute value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小レベルの相互運用性を確保するために、これらの属性はすべてのNFSv4.0クライアントとサーバーでサポートされている必要があります。サーバーはこれらの属性を格納して返す必要があり、クライアントはこれらの属性に限定された属性セットで機能できる必要があります。 REQUIRED属性だけでは、一部のクライアント機能が何らかの方法で損なわれたり制限されたりする可能性があります。クライアントは、GETATTR要求にビットを設定することにより、これらの属性のいずれかが返されるように要求できます。そのようなビットセットごとに、サーバーは対応する属性値を返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. RECOMMENDED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 推奨属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes are understood well enough to warrant support in the NFSv4.0 protocol. However, they may not be supported on all clients and servers. A client MAY ask for any of these attributes to be returned by setting a bit in the GETATTR request but MUST handle the case where the server does not return them. A client MAY ask for the set of attributes the server supports and SHOULD NOT request attributes the server does not support. A server should be tolerant of requests for unsupported attributes and simply not return them, rather than considering the request an error. It is expected that servers will support all attributes they comfortably can and only fail to support attributes that are difficult to support in their operating environments. A server should provide attributes whenever they don&#39;t have to &#34;tell lies&#34; to the client. For example, a file modification time either should be an accurate time or should not be supported by the server. At times this will be difficult for clients, but a client is better positioned to decide whether and how to fabricate or construct an attribute or whether to do without the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、NFSv4.0プロトコルでのサポートを保証するのに十分に理解されています。ただし、すべてのクライアントとサーバーでサポートされているとは限りません。クライアントは、GETATTRリクエストにビットを設定することにより、これらの属性のいずれかが返されるように要求できますが、サーバーがそれらを返さない場合を処理しなければなりません（MUST）。クライアントは、サーバーがサポートする属性のセットを要求する場合があり、サーバーがサポートしない属性を要求してはなりません（SHOULD NOT）。サーバーは、要求をエラーと見なすのではなく、サポートされていない属性に対する要求を許容し、それらを単に返さないようにする必要があります。サーバーは快適に使用できるすべての属性をサポートし、オペレーティング環境でサポートするのが難しい属性のみをサポートすることが期待されます。サーバーは、クライアントに「嘘をつく」必要がない場合はいつでも属性を提供する必要があります。たとえば、ファイルの変更時刻は正確な時刻であるか、サーバーでサポートされていない必要があります。これはクライアントにとって困難な場合がありますが、クライアントは、属性を作成または構築するかどうか、どのように作成するか、または属性なしで実行するかどうかを決定するのに適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Named Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 名前付き属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 These attributes are not supported by direct encoding in the NFSv4 protocol but are accessed by string names rather than numbers and correspond to an uninterpreted stream of bytes that are stored with the file system object. The namespace for these attributes may be accessed by using the OPENATTR operation. The OPENATTR operation returns a filehandle for a virtual &#34;named attribute directory&#34;, and further perusal and modification of the namespace may be done using operations that work on more typical directories. In particular, READDIR may be used to get a list of such named attributes, and LOOKUP and OPEN may select a particular attribute. Creation of a new named attribute may be the result of an OPEN specifying file creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これらの属性は、NFSv4プロトコルの直接エンコーディングではサポートされていませんが、数値ではなく文字列名でアクセスされ、ファイルシステムオブジェクトと共に格納される解釈されないバイトストリームに対応しています。これらの属性の名前空間には、OPENATTR操作を使用してアクセスできます。 OPENATTR操作は、仮想の「名前付き属性ディレクトリ」のファイルハンドルを返します。さらに一般的なディレクトリで機能する操作を使用して、名前空間の詳細を調べたり変更したりできます。特に、READDIRはそのような名前付き属性のリストを取得するために使用でき、LOOKUPとOPENは特定の属性を選択できます。新しい名前付き属性の作成は、OPENを指定したファイル作成の結果である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once an OPEN is done, named attributes may be examined and changed by normal READ and WRITE operations using the filehandles and stateids returned by OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが完了すると、名前付き属性は、OPENによって返されるファイルハンドルとステートIDを使用して、通常のREADおよびWRITE操作によって検査および変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes and the named attribute directory may have their own (non-named) attributes. Each of these objects must have all of the REQUIRED attributes and may have additional RECOMMENDED attributes. However, the set of attributes for named attributes and the named attribute directory need not be, and typically will not be, as large as that for other objects in that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性と名前付き属性ディレクトリは、独自の（名前なし）属性を持つことができます。これらの各オブジェクトには、すべてのREQUIRED属性が必要であり、追加のRECOMMENDED属性が含まれる場合があります。ただし、名前付き属性と名前付き属性ディレクトリの一連の属性は、そのファイルシステム内の他のオブジェクトの属性と同じ大きさである必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes might be the target of delegations. However, since granting of delegations is at the server&#39;s discretion, a server need not support delegations on named attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性が委任のターゲットになる場合があります。ただし、委任の付与はサーバーの裁量によるため、サーバーは名前付き属性の委任をサポートする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that servers support arbitrary named attributes. A client should not depend on the ability to store any named attributes in the server&#39;s file system. If a server does support named attributes, a client that is also able to handle them should be able to copy a file&#39;s data and metadata with complete transparency from one location to another; this would imply that names allowed for regular directory entries are valid for named attribute names as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが任意の名前付き属性をサポートすることをお勧めします。クライアントは、サーバーのファイルシステムに名前付き属性を格納する機能に依存してはなりません。サーバーが名前付き属性をサポートしている場合、それらも処理できるクライアントは、ファイルのデータとメタデータをある場所から別の場所に完全に透過的にコピーできるはずです。これは、通常のディレクトリエントリに許可されている名前が名前付き属性名にも有効であることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In NFSv4.0, the structure of named attribute directories is restricted in a number of ways, in order to prevent the development of non-interoperable implementations in which some servers support a fully general hierarchical directory structure for named attributes while others support a limited but adequate structure for named attributes. In such an environment, clients or applications might come to depend on non-portable extensions. The restrictions are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0では、いくつかのサーバーが名前付き属性の完全に一般的な階層ディレクトリ構造をサポートし、他のサーバーは制限されているがサポートするという相互運用できない実装の開発を防ぐために、名前付き属性ディレクトリの構造はいくつかの方法で制限されています名前付き属性の適切な構造。このような環境では、クライアントまたはアプリケーションは、移植できない拡張機能に依存するようになる可能性があります。制限は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CREATE is not allowed in a named attribute directory. Thus, such objects as symbolic links and special files are not allowed to be named attributes. Further, directories may not be created in a named attribute directory, so no hierarchical structure of named attributes for a single object is allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前付き属性ディレクトリではCREATEは許可されていません。したがって、シンボリックリンクや特殊ファイルなどのオブジェクトを名前付き属性にすることはできません。さらに、名前付き属性ディレクトリにディレクトリを作成できないため、単一オブジェクトの名前付き属性の階層構造は許可されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If OPENATTR is done on a named attribute directory or on a named attribute, the server MUST return an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPENATTRが名前付き属性ディレクトリまたは名前付き属性で行われる場合、サーバーはエラーを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Doing a RENAME of a named attribute to a different named attribute directory or to an ordinary (i.e., non-named-attribute) directory is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前付き属性のRENAMEを別の名前付き属性ディレクトリまたは通常の（つまり、非名前付き属性）ディレクトリに実行することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Creating hard links between named attribute directories or between named attribute directories and ordinary directories is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前付き属性ディレクトリ間、または名前付き属性ディレクトリと通常のディレクトリ間にハードリンクを作成することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names of attributes will not be controlled by this document or other IETF Standards Track documents. See Section 20 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性の名前は、このドキュメントまたは他のIETF標準トラックドキュメントによって制御されません。詳細については、セクション20を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Classification of Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 属性の分類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the attributes accessed using SETATTR and GETATTR (i.e., REQUIRED and RECOMMENDED attributes) can be classified in one of three categories:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRおよびGETATTRを使用してアクセスされる各属性（つまり、REQUIREDおよびRECOMMENDED属性）は、次の3つのカテゴリのいずれかに分類できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. per-server attributes for which the value of the attribute will be the same for all file objects that share the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 同じサーバーを共有するすべてのファイルオブジェクトで属性の値が同じになるサーバーごとの属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. per-file system attributes for which the value of the attribute will be the same for some or all file objects that share the same server and fsid attribute (Section 5.8.1.9). See below for details regarding when such sharing is in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 同じサーバーとfsid属性を共有する一部またはすべてのファイルオブジェクトで属性の値が同じになる、ファイルシステムごとの属性（セクション5.8.1.9）。そのような共有がいつ有効になるかについての詳細は、以下を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. per-file system object attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ファイルシステムオブジェクトの属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handling of per-file system attributes depends on the particular attribute and the setting of the homogeneous (Section 5.8.2.12) attribute. The following rules apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルごとのシステム属性の処理は、特定の属性と同種（5.8.2.12項）属性の設定に依存します。次の規則が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The values of the attributes supported_attrs, fsid, homogeneous, link_support, and symlink_support are always common to all objects within the given file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 属性supported_attrs、fsid、ホモジニアス、link_support、symlink_supportの値は常に、特定のファイルシステム内のすべてのオブジェクトに共通です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. For other attributes, different values may be returned for different file system objects if the attribute homogeneous is supported within the file system in question and has the value false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 他の属性の場合、問題のファイルシステム内で同種の属性がサポートされており、値がfalseの場合、ファイルシステムオブジェクトごとに異なる値が返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The classification of attributes is as follows. Note that the attributes time_access_set and time_modify_set are not listed in this section, because they are write-only attributes corresponding to time_access and time_modify and are used in a special instance of SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性の分類は次のとおりです。属性time_access_setおよびtime_modify_setは、time_accessおよびtime_modifyに対応する書き込み専用属性であり、SETATTRの特別なインスタンスで使用されるため、このセクションにはリストされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per-server attribute is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーごとの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
lease_time
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リース時間
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per-file system attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルごとのシステム属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
supported_attrs, fh_expire_type, link_support, symlink_support, unique_handles, aclsupport, cansettime, case_insensitive, case_preserving, chown_restricted, files_avail, files_free, files_total, fs_locations, homogeneous, maxfilesize, maxname, maxread, maxwrite, no_trunc, space_avail, space_free, space_total, and time_delta
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
supported_attrs、fh_expire_type、link_support、symlink_support、unique_handles、aclsupport、cansettime、case_insensitive、case_preserving、chown_restricted、files_avail、files_free、files_total、fs_locations、同種、maxfilesize、maxname、maxread、maxwrite、no_trunc、space_avdelta、space_avail、space_avail
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per-file system object attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムオブジェクトごとの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
type, change, size, named_attr, fsid, rdattr_error, filehandle, acl, archive, fileid, hidden, maxlink, mimetype, mode, numlinks, owner, owner_group, rawdev, space_used, system, time_access, time_backup, time_create, time_metadata, time_modify, and mounted_on_fileid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
タイプ、変更、サイズ、named_attr、fsid、rdattr_error、filehandle、acl、archive、fileid、hidden、maxlink、mimetype、mode、numlinks、owner、owner_group、rawdev、space_used、system、time_access、time_backup、time_create、time_metadata、time_modify、そしてmounted_on_fileid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For quota_avail_hard, quota_avail_soft, and quota_used, see their definitions below for the appropriate classification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard、quota_avail_soft、およびquota_usedの適切な分類については、以下の定義を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Set-Only and Get-Only Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Set-OnlyおよびGet-Only属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some REQUIRED and RECOMMENDED attributes are set-only; i.e., they can be set via SETATTR but not retrieved via GETATTR. Similarly, some REQUIRED and RECOMMENDED attributes are get-only; i.e., they can be retrieved via GETATTR but not set via SETATTR. If a client attempts to set a get-only attribute or get a set-only attribute, the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のREQUIREDおよびRECOMMENDED属性は設定のみです。つまり、SETATTRを介して設定できますが、GETATTRを介して取得することはできません。同様に、一部のREQUIREDおよびRECOMMENDED属性は取得専用です。つまり、GETATTRを介して取得できますが、SETATTRを介して設定することはできません。クライアントがget-only属性の設定またはset-only属性の取得を試みる場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. REQUIRED Attributes - List and Definition References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. 必須属性-リストと定義の参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The list of REQUIRED attributes appears in Table 3. The meanings of the columns of the table are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須属性のリストを表3に示します。表の列の意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Name: The name of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前：属性の名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ID: The number assigned to the attribute. In the event of conflicts between the assigned number and [RFC7531], the latter is authoritative, but in such an event, it should be resolved with errata to this document and/or [RFC7531]. See [IESG_ERRATA] for the errata process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ID：属性に割り当てられた番号。割り当てられた番号と[RFC7531]の間に矛盾がある場合、後者は信頼できますが、そのような場合は、このドキュメントまたは[RFC7531]への正誤表で解決する必要があります。エラータプロセスについては、[IESG_ERRATA]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Data Type: The XDR data type of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データ型：属性のXDRデータ型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Acc: Access allowed to the attribute. R means read-only (GETATTR may retrieve, SETATTR may not set). W means write-only (SETATTR may set, GETATTR may not retrieve). R W means read/write (GETATTR may retrieve, SETATTR may set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Acc：属性へのアクセスが許可されています。 Rは読み取り専用を意味します（GETATTRは取得、SETATTRは設定されない場合があります）。 Wは書き込み専用を意味します（SETATTRが設定され、GETATTRが取得されない場合があります）。 R Wは読み取り/書き込みを意味します（GETATTRは取得、SETATTRは設定可能）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Defined in: The section of this specification that describes the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 定義先：属性を説明するこの仕様のセクション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-----------------+----+------------+-----+-------------------+
      | Name            | ID | Data Type  | Acc | Defined in        |
      +-----------------+----+------------+-----+-------------------+
      | supported_attrs | 0  | bitmap4    | R   | Section 5.8.1.1   |
      | type            | 1  | nfs_ftype4 | R   | Section 5.8.1.2   |
      | fh_expire_type  | 2  | uint32_t   | R   | Section 5.8.1.3   |
      | change          | 3  | changeid4  | R   | Section 5.8.1.4   |
      | size            | 4  | uint64_t   | R W | Section 5.8.1.5   |
      | link_support    | 5  | bool       | R   | Section 5.8.1.6   |
      | symlink_support | 6  | bool       | R   | Section 5.8.1.7   |
      | named_attr      | 7  | bool       | R   | Section 5.8.1.8   |
      | fsid            | 8  | fsid4      | R   | Section 5.8.1.9   |
      | unique_handles  | 9  | bool       | R   | Section 5.8.1.10  |
      | lease_time      | 10 | nfs_lease4 | R   | Section 5.8.1.11  |
      | rdattr_error    | 11 | nfsstat4   | R   | Section 5.8.1.12  |
      | filehandle      | 19 | nfs_fh4    | R   | Section 5.8.1.13  |
      +-----------------+----+------------+-----+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Table 3: REQUIRED Attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
表3：必須属性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. RECOMMENDED Attributes - List and Definition References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. 推奨属性-リストおよび定義の参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED attributes are defined in Table 4. The meanings of the column headers are the same as Table 3; see Section 5.6 for the meanings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECOMMENDED属性は、表4で定義されています。列ヘッダーの意味は、表3と同じです。意味については、5.6項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------+----+-----------------+-----+------------------+
   | Name              | ID | Data Type       | Acc | Defined in       |
   +-------------------+----+-----------------+-----+------------------+
   | acl               | 12 | nfsace4&lt;&gt;       | R W | Section 6.2.1    |
   | aclsupport        | 13 | uint32_t        | R   | Section 6.2.1.2  |
   | archive           | 14 | bool            | R W | Section 5.8.2.1  |
   | cansettime        | 15 | bool            | R   | Section 5.8.2.2  |
   | case_insensitive  | 16 | bool            | R   | Section 5.8.2.3  |
   | case_preserving   | 17 | bool            | R   | Section 5.8.2.4  |
   | chown_restricted  | 18 | bool            | R   | Section 5.8.2.5  |
   | fileid            | 20 | uint64_t        | R   | Section 5.8.2.6  |
   | files_avail       | 21 | uint64_t        | R   | Section 5.8.2.7  |
   | files_free        | 22 | uint64_t        | R   | Section 5.8.2.8  |
   | files_total       | 23 | uint64_t        | R   | Section 5.8.2.9  |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | fs_locations      | 24 | fs_locations4   | R   | Section 5.8.2.10 |
   | hidden            | 25 | bool            | R W | Section 5.8.2.11 |
   | homogeneous       | 26 | bool            | R   | Section 5.8.2.12 |
   | maxfilesize       | 27 | uint64_t        | R   | Section 5.8.2.13 |
   | maxlink           | 28 | uint32_t        | R   | Section 5.8.2.14 |
   | maxname           | 29 | uint32_t        | R   | Section 5.8.2.15 |
   | maxread           | 30 | uint64_t        | R   | Section 5.8.2.16 |
   | maxwrite          | 31 | uint64_t        | R   | Section 5.8.2.17 |
   | mimetype          | 32 | ascii_          | R W | Section 5.8.2.18 |
   |                   |    |   REQUIRED4&lt;&gt;   |     |                  |
   | mode              | 33 | mode4           | R W | Section 6.2.2    |
   | mounted_on_fileid | 55 | uint64_t        | R   | Section 5.8.2.19 |
   | no_trunc          | 34 | bool            | R   | Section 5.8.2.20 |
   | numlinks          | 35 | uint32_t        | R   | Section 5.8.2.21 |
   | owner             | 36 | utf8str_mixed   | R W | Section 5.8.2.22 |
   | owner_group       | 37 | utf8str_mixed   | R W | Section 5.8.2.23 |
   | quota_avail_hard  | 38 | uint64_t        | R   | Section 5.8.2.24 |
   | quota_avail_soft  | 39 | uint64_t        | R   | Section 5.8.2.25 |
   | quota_used        | 40 | uint64_t        | R   | Section 5.8.2.26 |
   | rawdev            | 41 | specdata4       | R   | Section 5.8.2.27 |
   | space_avail       | 42 | uint64_t        | R   | Section 5.8.2.28 |
   | space_free        | 43 | uint64_t        | R   | Section 5.8.2.29 |
   | space_total       | 44 | uint64_t        | R   | Section 5.8.2.30 |
   | space_used        | 45 | uint64_t        | R   | Section 5.8.2.31 |
   | system            | 46 | bool            | R W | Section 5.8.2.32 |
   | time_access       | 47 | nfstime4        | R   | Section 5.8.2.33 |
   | time_access_set   | 48 | settime4        | W   | Section 5.8.2.34 |
   | time_backup       | 49 | nfstime4        | R W | Section 5.8.2.35 |
   | time_create       | 50 | nfstime4        | R W | Section 5.8.2.36 |
   | time_delta        | 51 | nfstime4        | R   | Section 5.8.2.37 |
   | time_metadata     | 52 | nfstime4        | R   | Section 5.8.2.38 |
   | time_modify       | 53 | nfstime4        | R   | Section 5.8.2.39 |
   | time_modify_set   | 54 | settime4        | W   | Section 5.8.2.40 |
   +-------------------+----+-----------------+-----+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Table 4: RECOMMENDED Attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
表4：推奨される属性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. 属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1. Definitions of REQUIRED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1. 必須属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.1. Attribute 0: supported_attrs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.1. 属性0：supported_attrs
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bit vector that would retrieve all REQUIRED and RECOMMENDED attributes that are supported for this object. The scope of this attribute applies to all objects with a matching fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトでサポートされているすべてのREQUIREDおよびRECOMMENDED属性を取得するビットベクトル。この属性のスコープは、一致するfsidを持つすべてのオブジェクトに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.2. Attribute 1: type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.2. 属性1：タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Designates the type of an object in terms of one of a number of special constants:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの特別な定数の1つに関してオブジェクトのタイプを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4REG designates a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4REGは通常のファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4DIR designates a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4DIRはディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4BLK designates a block device special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4BLKは、ブロックデバイス特殊ファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4CHR designates a character device special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4CHRは、キャラクタデバイススペシャルファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4LNK designates a symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4LNKはシンボリックリンクを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4SOCK designates a named socket special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4SOCKは、名前付きソケット特殊ファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4FIFO designates a fifo special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4FIFOは、FIFOスペシャルファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4ATTRDIR designates a named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4ATTRDIRは、名前付き属性ディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4NAMEDATTR designates a named attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4NAMEDATTRは名前付き属性を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within the explanatory text and operation descriptions, the following phrases will be used with the meanings given below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明文と操作説明では、次の語句は以下の意味で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The phrase &#34;is a directory&#34; means that the object&#39;s type attribute is NF4DIR or NF4ATTRDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「is a directory」という語句は、オブジェクトのtype属性がNF4DIRまたはNF4ATTRDIRであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The phrase &#34;is a special file&#34; means that the object&#39;s type attribute is NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「特殊ファイルです」という語句は、オブジェクトのタイプ属性がNF4BLK、NF4CHR、NF4SOCK、またはNF4FIFOであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The phrase &#34;is a regular file&#34; means that the object&#39;s type attribute is NF4REG or NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「通常のファイルです」という語句は、オブジェクトのタイプ属性がNF4REGまたはNF4NAMEDATTRであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The phrase &#34;is a symbolic link&#34; means that the object&#39;s type attribute is NF4LNK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「シンボリックリンクです」という語句は、オブジェクトのタイプ属性がNF4LNKであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.3. Attribute 2: fh_expire_type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.3. 属性2：fh_expire_type
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server uses this to specify filehandle expiration behavior to the client. See Section 4 for additional description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこれを使用して、ファイルハンドルの有効期限の動作をクライアントに指定します。詳細については、セクション4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.4. Attribute 3: change
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.4. 属性3：変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A value created by the server that the client can use to determine if file data, directory contents, or attributes of the object have been modified. The server MAY return the object&#39;s time_metadata attribute for this attribute&#39;s value but only if the file system object cannot be updated more frequently than the resolution of time_metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが作成した値で、クライアントがオブジェクトのファイルデータ、ディレクトリの内容、または属性が変更されているかどうかを判断するために使用できます。サーバーは、この属性の値に対してオブジェクトのtime_metadata属性を返す場合がありますが、それは、ファイルシステムオブジェクトがtime_metadataの解像度よりも頻繁に更新できない場合に限られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.5. Attribute 4: size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.5. 属性4：サイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of the object in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのサイズ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.6. Attribute 5: link_support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.6. 属性5：link_support
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the object&#39;s file system supports hard links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのファイルシステムがハードリンクをサポートしている場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.7. Attribute 6: symlink_support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.7. 属性6：symlink_support
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the object&#39;s file system supports symbolic links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのファイルシステムがシンボリックリンクをサポートしている場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.8. Attribute 7: named_attr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.8. 属性7：named_attr
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if this object has named attributes. In other words, this object has a non-empty named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに名前付き属性がある場合はTRUE。つまり、このオブジェクトには空でない名前付き属性ディレクトリがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.9. Attribute 8: fsid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.9. 属性8：fsid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unique file system identifier for the file system holding this object. The fsid attribute has major and minor components, each of which are of data type uint64_t.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを保持するファイルシステムの一意のファイルシステム識別子。 fsid属性には、メジャーコンポーネントとマイナーコンポーネントがあり、それぞれデータタイプuint64_tです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.10. Attribute 9: unique_handles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.10. 属性9：unique_handles
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if two distinct filehandles are guaranteed to refer to two different file system objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの異なるファイルハンドルが2つの異なるファイルシステムオブジェクトを参照することが保証されている場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.11. Attribute 10: lease_time
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.11. 属性10：lease_time
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Duration of the lease at the server in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーでのリース期間（秒単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.12. Attribute 11: rdattr_error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.12. 属性11：rdattr_error
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error returned from an attempt to retrieve attributes during a READDIR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作中に属性を取得しようとしたときに返されたエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.13. Attribute 19: filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.13. 属性19：ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle of this object (primarily for READDIR requests).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのファイルハンドル（主にREADDIRリクエスト用）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2. Definitions of Uncategorized RECOMMENDED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2. 未分類の推奨属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definitions of most of the RECOMMENDED attributes follow. Collections that share a common category are defined in other sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどのRECOMMENDED属性の定義は次のとおりです。共通のカテゴリを共有するコレクションは、他のセクションで定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.1. Attribute 14: archive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.1. 属性14：アーカイブ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if this file has been archived since the time of the last modification (deprecated in favor of time_backup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE、このファイルが最後に変更された時刻以降にアーカイブされている場合（time_backupの代わりに非推奨）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.2. Attribute 15: cansettime
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.2. 属性15：cansettime
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the server is able to change the times for a file system object as specified in a SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがSETATTR操作で指定されたファイルシステムオブジェクトの時間を変更できる場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.3. Attribute 16: case_insensitive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.3. 属性16：case_insensitive
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if filename comparisons on this file system are case insensitive. This refers only to comparisons, and not to the case in which filenames are stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステムでのファイル名の比較で大文字と小文字が区別されない場合はTRUE。これは比較のみを指し、ファイル名が格納されている場合は指しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.4. Attribute 17: case_preserving
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.4. 属性17：case_preserving
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the filename case on this file system is preserved. This refers only to how filenames are stored, and not to how they are compared. Filenames stored in mixed case might be compared using either case-insensitive or case-sensitive comparisons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステムのファイル名の大文字と小文字が保持される場合はTRUE。これは、ファイル名の保存方法のみを指し、比較方法は指しません。大/小文字混合で保管されたファイル名は、大/小文字を区別しない比較または大/小文字を区別する比較のいずれかを使用して比較される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.5. Attribute 18: chown_restricted
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.5. 属性18：chown_restricted
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If TRUE, the server will reject any request to change either the owner or the group associated with a file if the caller is not a privileged user (for example, &#34;root&#34; in UNIX operating environments or the &#34;Take Ownership&#34; privilege in Windows 2000).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUEの場合、呼び出し元が特権ユーザー（たとえば、UNIXオペレーティング環境の「root」またはWindows 2000の「Take Ownership」特権）でない場合、サーバーは、ファイルに関連付けられた所有者またはグループのいずれかを変更する要求を拒否します。 ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.6. Attribute 20: fileid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.6. 属性20：fileid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number uniquely identifying the file within the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステム内でファイルを一意に識別する番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.7. Attribute 21: files_avail
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.7. 属性21：files_avail
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File slots available to this user on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステムでこのユーザーが使用できるファイルスロット-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.8. Attribute 22: files_free
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.8. 属性22：files_free
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Free file slots on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステムの空きファイルスロット-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.9. Attribute 23: files_total
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.9. 属性23：files_total
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Total file slots on the file system containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステム上の合計ファイルスロット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.10. Attribute 24: fs_locations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.10. 属性24：fs_locations
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Locations where this file system may be found. If the server returns NFS4ERR_MOVED as an error, this attribute MUST be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステムが見つかる可能性のある場所。サーバーがエラーとしてNFS4ERR_MOVEDを返す場合、この属性はサポートされている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server specifies the rootpath for a given server by returning a path consisting of zero path components.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ゼロパスコンポーネントで構成されるパスを返すことにより、特定のサーバーのルートパスを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.11. Attribute 25: hidden
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.11. 属性25：非表示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the file is considered hidden with respect to the Windows API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Windows APIに関してファイルが非表示と見なされる場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.12. Attribute 26: homogeneous
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.12. 属性26：同種
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if this object&#39;s file system is homogeneous, i.e., all objects in the file system (all objects on the server with the same fsid) have common values for all per-file system attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのファイルシステムが同種の場合、つまりファイルシステム内のすべてのオブジェクト（同じfsidを持つサーバー上のすべてのオブジェクト）が、ファイルシステムごとのすべての属性に共通の値を持つ場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.13. Attribute 27: maxfilesize
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.13. 属性27：maxfilesize
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum supported file size for the file system of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのファイルシステムでサポートされる最大ファイルサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.14. Attribute 28: maxlink
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.14. 属性28：maxlink
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum number of hard links for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのハードリンクの最大数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.15. Attribute 29: maxname
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.15. 属性29：maxname
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum filename size supported for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトでサポートされるファイル名の最大サイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.16. Attribute 30: maxread
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.16. 属性30：maxread
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum amount of data the READ operation will return for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに対してREAD操作が返すデータの最大量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.17. Attribute 31: maxwrite
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.17. 属性31：maxwrite
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum amount of data the WRITE operation will accept for this object. This attribute SHOULD be supported if the file is writable. Lack of this attribute can lead to the client either wasting bandwidth or not receiving the best performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに対してWRITE操作が受け入れるデータの最大量。ファイルが書き込み可能である場合、この属性はサポートされるべきです（SHOULD）。この属性がないと、クライアントが帯域幅を浪費したり、最高のパフォーマンスを受け取っていない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.18. Attribute 32: mimetype
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.18. 属性32：mimetype
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIME media type/subtype of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのMIMEメディアタイプ/サブタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.19. Attribute 55: mounted_on_fileid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.19. 属性55：Mounted_on_fileid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like fileid, but if the target filehandle is the root of a file system, this attribute represents the fileid of the underlying directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fileidに似ていますが、ターゲットファイルハンドルがファイルシステムのルートである場合、この属性は基礎となるディレクトリのfileidを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIX-based operating environments connect a file system into the namespace by connecting (mounting) the file system onto the existing file object (the mount point, usually a directory) of an existing file system. When the mount point&#39;s parent directory is read via an API such as readdir() [readdir_api], the return results are directory entries, each with a component name and a fileid. The fileid of the mount point&#39;s directory entry will be different from the fileid that the stat() [stat] system call returns. The stat() system call is returning the fileid of the root of the mounted file system, whereas readdir() is returning the fileid that stat() would have returned before any file systems were mounted on the mount point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXベースのオペレーティング環境では、ファイルシステムを既存のファイルシステムの既存のファイルオブジェクト（マウントポイント、通常はディレクトリ）に接続（マウント）することにより、ファイルシステムをネームスペースに接続します。マウントポイントの親ディレクトリがreaddir()[readdir_api]などのAPIを介して読み取られる場合、返される結果はディレクトリエントリで、それぞれにコンポーネント名とファイルIDが含まれます。マウントポイントのディレクトリエントリのファイルIDは、stat()[stat]システムコールが返すファイルIDとは異なります。 stat()システムコールはマウントされたファイルシステムのルートのファイルIDを返しますが、readdir()は、ファイルシステムがマウントポイントにマウントされる前にstat()が返したはずのファイルIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike NFSv3, NFSv4.0 allows a client&#39;s LOOKUP request to cross other file systems. The client detects the file system crossing whenever the filehandle argument of LOOKUP has an fsid attribute different from that of the filehandle returned by LOOKUP. A UNIX-based client will consider this a &#34;mount point crossing&#34;. UNIX has a legacy scheme for allowing a process to determine its current working directory. This relies on readdir() of a mount point&#39;s parent and stat() of the mount point returning fileids as previously described. The mounted_on_fileid attribute corresponds to the fileid that readdir() would have returned, as described previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3とは異なり、NFSv4.0では、クライアントのLOOKUP要求が他のファイルシステムを越えることができます。クライアントは、LOOKUPのfilehandle引数に、LOOKUPから返されたファイルハンドルのfsid属性とは異なるfsid属性がある場合に、ファイルシステムの交差を検出します。 UNIXベースのクライアントは、これを「マウントポイントクロッシング」と見なします。 UNIXには、プロセスが現在の作業ディレクトリを決定できるようにするためのレガシースキームがあります。これは、前述のように、マウントポイントの親のreaddir()とマウントポイントのstat()がファイルIDを返すことに依存しています。前述のように、mounted_on_fileid属性は、readdir()が返すファイルIDに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the NFSv4.0 client could simply fabricate a fileid corresponding to what mounted_on_fileid provides (and if the server does not support mounted_on_fileid, the client has no choice), there is a risk that the client will generate a fileid that conflicts with one that is already assigned to another object in the file system. Instead, if the server can provide the mounted_on_fileid, the potential for client operational problems in this area is eliminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0クライアントは、mounted_on_fileidが提供するものに対応するfileidを単純に作成することができます（サーバーがMounted_on_fileidをサポートしていない場合、クライアントは選択肢がありません）、クライアントは、ファイルIDと競合するファイルIDを生成するリスクがありますファイルシステム内の別のオブジェクトに既に割り当てられています。代わりに、サーバーがMounted_on_fileidを提供できる場合、この領域でのクライアントの操作上の問題の可能性は排除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server detects that there is nothing mounted on top of the target file object, then the value for mounted_on_fileid that it returns is the same as that of the fileid attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットファイルオブジェクトの上に何もマウントされていないことをサーバーが検出した場合、サーバーが返すMounted_on_fileidの値は、fileid属性の値と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mounted_on_fileid attribute is RECOMMENDED, so the server SHOULD provide it if possible, and for a UNIX-based server, this is straightforward. Usually, mounted_on_fileid will be requested during a READDIR operation, in which case it is trivial (at least for UNIX-based servers) to return mounted_on_fileid since it is equal to the fileid of a directory entry returned by readdir(). If mounted_on_fileid is requested in a GETATTR operation, the server should obey an invariant that has it returning a value that is equal to the file object&#39;s entry in the object&#39;s parent directory, i.e., what readdir() would have returned. Some operating environments allow a series of two or more file systems to be mounted onto a single mount point. In this case, for the server to obey the aforementioned invariant, it will need to find the base mount point, and not the intermediate mount points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mounted_on_fileid属性は推奨されるので、サーバーは可能であればそれを提供する必要があります（SHOULD）。UNIXベースのサーバーの場合、これは簡単です。通常、mounted_on_fileidはREADDIR操作中に要求されます。その場合、readdir()によって返されるディレクトリエントリのfileidと等しいため、mounted_on_fileidを返すのは（少なくともUNIXベースのサーバーの場合）簡単です。 GETATTR操作でMounted_on_fileidが要求された場合、サーバーは、オブジェクトの親ディレクトリにあるファイルオブジェクトのエントリと等しい値を返す不変条件に従う必要があります。つまり、readdir()が返す結果になります。一部の動作環境では、一連の2つ以上のファイルシステムを単一のマウントポイントにマウントできます。この場合、サーバーが前述の不変式に従うためには、中間マウントポイントではなく、ベースマウントポイントを見つける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.20. Attribute 34: no_trunc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.20. 属性34：no_trunc
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this attribute is TRUE, then if the client uses a filename longer than name_max, an error will be returned instead of the name being truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この属性がTRUEの場合、クライアントがname_maxより長いファイル名を使用すると、名前が切り捨てられる代わりにエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.21. Attribute 35: numlinks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.21. 属性35：numlinks
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of hard links to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトへのハードリンクの数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.22. Attribute 36: owner
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.22. 属性36：所有者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The string name of the owner of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトの所有者の文字列名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.23. Attribute 37: owner_group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.23. 属性37：owner_group
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The string name of the group ownership of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのグループ所有権の文字列名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.24. Attribute 38: quota_avail_hard
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.24. 属性38：quota_avail_hard
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value in bytes that represents the amount of additional disk space beyond the current allocation that can be allocated to this file or directory before further allocations will be refused. It is understood that this space may be consumed by allocations to other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これ以上の割り当てが拒否される前に、このファイルまたはディレクトリに割り当てることができる現在の割り当てを超える追加のディスク領域の量を表すバイト単位の値。このスペースは、他のファイルまたはディレクトリへの割り当てによって消費される可能性があることを理解してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.25. Attribute 39: quota_avail_soft
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.25. 属性39：quota_avail_soft
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value in bytes that represents the amount of additional disk space that can be allocated to this file or directory before the user may reasonably be warned. It is understood that this space may be consumed by allocations to other files or directories, though there may exist server-side rules as to which other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーに警告が出る前にこのファイルまたはディレクトリに割り当てることができる追加のディスク容量を表すバイト単位の値。このスペースは他のファイルまたはディレクトリへの割り当てによって消費される可能性がありますが、他のどのファイルまたはディレクトリに関するサーバー側のルールが存在する場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.26. Attribute 40: quota_used
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.26. 属性40：quota_used
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value in bytes that represents the amount of disk space used by this file or directory and possibly a number of other similar files or directories, where the set of &#34;similar&#34; meets at least the criterion that allocating space to any file or directory in the set will reduce the &#34;quota_avail_hard&#34; of every other file or directory in the set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルまたはディレクトリ、および場合によっては他の類似のファイルまたはディレクトリによって使用されるディスク領域の量を表すバイト単位の値。「類似」のセットは、少なくともファイル内の任意のファイルまたはディレクトリに領域を割り当てる基準を満たします。セットは、セット内の他のすべてのファイルまたはディレクトリの「quota_avail_hard」を減らします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there may be a number of distinct but overlapping sets of files or directories for which a quota_used value is maintained, e.g., &#34;all files with a given owner&#34;, &#34;all files with a given group owner&#34;, etc. The server is at liberty to choose any of those sets when providing the content of the quota_used attribute but should do so in a repeatable way. The rule may be configured per file system or may be &#34;choose the set with the smallest quota&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_used値が維持されるファイルまたはディレクトリのセットは、重複している場合があります。たとえば、「特定の所有者を持つすべてのファイル」、「特定のグループ所有者を持つすべてのファイル」などです。サーバーはquota_used属性のコンテンツを提供するときにこれらのセットのいずれかを自由に選択できますが、繰り返し可能な方法で行う必要があります。ルールはファイルシステムごとに構成することも、「クォータが最小のセットを選択する」こともできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.27. Attribute 41: rawdev
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.27. 属性41：rawdev
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Raw device number of file of type NF4BLK or NF4CHR. The device number is split into major and minor numbers. If the file&#39;s type attribute is not NF4BLK or NF4CHR, this attribute SHOULD NOT be returned, and any value returned SHOULD NOT be considered useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプNF4BLKまたはNF4CHRのファイルのrawデバイス番号。デバイス番号は、メジャー番号とマイナー番号に分かれています。ファイルのtype属性がNF4BLKまたはNF4CHRでない場合、この属性は返されるべきではなく（SHOULD NOT）、返された値は有用であるとは見なされません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.28. Attribute 42: space_avail
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.28. 属性42：space_avail
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Disk space in bytes available to this user on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステム上でこのユーザーが使用できるディスク容量（バイト単位）-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.29. Attribute 43: space_free
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.29. 属性43：space_free
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Free disk space in bytes on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステムの空きディスク容量（バイト単位）-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.30. Attribute 44: space_total
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.30. 属性44：space_total
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Total disk space in bytes on the file system containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステムの合計ディスク容量（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.31. Attribute 45: space_used
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.31. 属性45：space_used
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of file system bytes allocated to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに割り当てられているファイルシステムのバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.32. Attribute 46: system
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.32. 属性46：システム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if this file is a &#34;system&#34; file with respect to the Windows operating environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルがWindowsオペレーティング環境に関する「システム」ファイルである場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.33. Attribute 47: time_access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.33. 属性47：time_access
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Represents the time of last access to the object by a READ operation sent to the server. The notion of what is an &#34;access&#34; depends on the server&#39;s operating environment and/or the server&#39;s file system semantics. For example, for servers obeying Portable Operating System Interface (POSIX) semantics, time_access would be updated only by the READ and READDIR operations and not any of the operations that modify the content of the object [read_api], [readdir_api], [write_api]. Of course, setting the corresponding time_access_set attribute is another way to modify the time_access attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーに送信されたREAD操作によってオブジェクトに最後にアクセスした時刻を表します。 「アクセス」とは何かの概念は、サーバーの動作環境やサーバーのファイルシステムのセマンティクスによって異なります。たとえば、ポータブルオペレーティングシステムインターフェイス（POSIX）のセマンティクスに従うサーバーの場合、time_accessはREADおよびREADDIR操作によってのみ更新され、オブジェクトの内容を変更する操作[read_api]、[readdir_api]、[write_api]では更新されません。もちろん、対応するtime_access_set属性を設定することは、time_access属性を変更するもう1つの方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever the file object resides on a writable file system, the server should make its best efforts to record time_access into stable storage. However, to mitigate the performance effects of doing so, and most especially whenever the server is satisfying the read of the object&#39;s content from its cache, the server MAY cache access time updates and lazily write them to stable storage. It is also acceptable to give administrators of the server the option to disable time_access updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルオブジェクトが書き込み可能なファイルシステムに存在する場合は常に、サーバーはtime_accessを安定したストレージに記録するために最善の努力をする必要があります。ただし、そうすることによるパフォーマンスへの影響を軽減するために、特にサーバーがキャッシュからのオブジェクトのコンテンツの読み取りを満たしている場合は常に、サーバーはアクセス時間の更新をキャッシュして、それらを安定したストレージに遅延書き込みする場合があります。サーバーの管理者に、time_access更新を無効にするオプションを与えることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.34. Attribute 48: time_access_set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.34. 属性48：time_access_set
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sets the time of last access to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトに最後にアクセスした時刻を設定します。 SETATTRの使用のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.35. Attribute 49: time_backup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.35. 属性49：time_backup
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time of last backup of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトの最後のバックアップの時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.36. Attribute 50: time_create
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.36. 属性50：time_create
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time of creation of the object. This attribute does not have any relation to the traditional UNIX file attribute &#34;ctime&#34; (&#34;change time&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトの作成時刻。この属性は、従来のUNIXファイル属性 &#34;ctime&#34;（ &#34;変更時刻&#34;）とは関係ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.37. Attribute 51: time_delta
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.37. 属性51：time_delta
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Smallest useful server time granularity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小の有用なサーバー時間の細分性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.38. Attribute 52: time_metadata
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.38. 属性52：time_metadata
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time of last metadata modification of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのメタデータが最後に変更された時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.39. Attribute 53: time_modify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.39. 属性53：time_modify
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time of last modification to the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトが最後に変更された時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.40. Attribute 54: time_modify_set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.40. 属性54：time_modify_set
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sets the time of last modification to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトの最終変更時刻を設定します。 SETATTRの使用のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. Interpreting owner and owner_group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. ownerおよびowner_groupの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED attributes &#34;owner&#34; and &#34;owner_group&#34; (and also users and groups used as values of the who field within nfs4ace structures used in the acl attribute) are represented in the form of UTF-8 strings. This format avoids the use of a representation that is tied to a particular underlying implementation at the client or server. Note that Section 6.1 of [RFC2624] provides additional rationale. It is expected that the client and server will have their own local representation of owners and groups that is used for local storage or presentation to the application via APIs that expect such a representation. Therefore, the protocol requires that when these attributes are transferred between the client and server, the local representation is translated to a string of the form &#34;identifier@dns_domain&#34;. This allows clients and servers that do not use the same local representation to effectively interoperate since they both use a common syntax that can be interpreted by both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨属性「owner」と「owner_group」（およびacl属性で使用されるnfs4ace構造内のwhoフィールドの値として使用されるユーザーとグループ）は、UTF-8文字列の形式で表されます。この形式では、クライアントまたはサーバーで特定の基本的な実装に関連付けられている表現の使用が回避されます。 [RFC2624]のセクション6.1が追加の根拠を提供していることに注意してください。クライアントとサーバーは、所有者とグループの独自のローカル表現を持ち、ローカルストレージまたはそのような表現を期待するAPIを介したアプリケーションへのプレゼンテーションに使用されることが期待されます。したがって、プロトコルでは、これらの属性がクライアントとサーバー間で転送されるときに、ローカル表現が「identifier @ dns_domain」の形式の文字列に変換される必要があります。これにより、同じローカル表現を使用しないクライアントとサーバーは、両方で解釈できる共通の構文を使用するため、効率的に相互運用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, security principals may be represented in different ways by different security mechanisms. Servers normally translate these representations into a common format, generally that used by local storage, to serve as a means of identifying the users corresponding to these security principals. When these local identifiers are translated to the form of the owner attribute, associated with files created by such principals, they identify, in a common format, the users associated with each corresponding set of security principals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、セキュリティプリンシパルは、さまざまなセキュリティメカニズムによってさまざまな方法で表すことができます。サーバーは通常、これらの表現を一般的にローカルストレージで使用される一般的な形式に変換し、これらのセキュリティプリンシパルに対応するユーザーを識別する手段として機能します。これらのローカル識別子は、そのようなプリンシパルによって作成されたファイルに関連付けられた所有者属性の形式に変換されると、対応する各セキュリティプリンシパルのセットに関連付けられたユーザーを共通の形式で識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The translation used to interpret owner and group strings is not specified as part of the protocol. This allows various solutions to be employed. For example, a local translation table may be consulted that maps a numeric identifier to the user@dns_domain syntax. A name service may also be used to accomplish the translation. A server may provide a more general service, not limited by any particular translation (which would only translate a limited set of possible strings) by storing the owner and owner_group attributes in local storage without any translation, or it may augment a translation method by storing the entire string for attributes for which no translation is available while using the local representation for those cases in which a translation is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
所有者とグループの文字列を解釈するために使用される変換は、プロトコルの一部として指定されていません。これにより、さまざまなソリューションを使用できます。たとえば、数値識別子をuser @ dns_domain構文にマップするローカル変換テーブルが参照される場合があります。ネームサービスを使用して、変換を行うこともできます。サーバーは、owner属性とowner_group属性を翻訳なしでローカルストレージに保存することにより、特定の翻訳に限定されない（可能な文字列の限られたセットのみを翻訳する）より一般的なサービスを提供するか、または保存することで翻訳方法を強化できます。翻訳が利用可能な場合にローカル表現を使用しているときに、翻訳が利用できない属性の文字列全体。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that do not provide support for all possible values of user and group strings SHOULD return an error (NFS4ERR_BADOWNER) when a string is presented that has no translation, as the value to be set for a SETATTR of the owner or owner_group attributes or as part of the value of the acl attribute. When a server does accept a user or group string as valid on a SETATTR, it is promising to return that same string (see below) when a corresponding GETATTR is done, as long as there has been no further change in the corresponding attribute before the GETATTR. For some internationalization-related exceptions where this is not possible, see below. Configuration changes (including changes from the mapping of the string to the local representation) and ill-constructed name translations (those that contain aliasing) may make that promise impossible to honor. Servers should make appropriate efforts to avoid a situation in which these attributes have their values changed when no real change to either ownership or acls has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーおよびグループ文字列のすべての可能な値のサポートを提供しないサーバーは、所有者またはowner_group属性のSETATTRに設定される値として、または一部として、翻訳されていない文字列が提示されるとエラー（NFS4ERR_BADOWNER）を返す必要があります（SHOULD） acl属性の値の。サーバーがユーザーまたはグループの文字列をSETATTRで有効なものとして受け入れる場合、対応する属性に変更が加えられていない限り、対応するGETATTRが実行されたときに同じ文字列（以下を参照）を返すことが約束されています。 GETATTR。これが不可能な一部の国際化関連の例外については、以下を参照してください。構成の変更（文字列のローカル表現へのマッピングからの変更を含む）および不適切に構築された名前の変換（エイリアスを含むもの）により、その約束を守ることができなくなる場合があります。サーバーは、所有権またはACLのいずれかに実際の変更が発生していないときにこれらの属性の値が変更される状況を回避するために、適切な努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;dns_domain&#34; portion of the owner string is meant to be a DNS domain name -- for example, &#34;user@example.org&#34;. Servers should accept as valid a set of users for at least one domain. A server may treat other domains as having no valid translations. A more general service is provided when a server is capable of accepting users for multiple domains, or for all domains, subject to security constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者文字列の「dns_domain」の部分は、DNSドメイン名（たとえば、「user@example.org」）であることを意味します。サーバーは、少なくとも1つのドメインのユーザーのセットを有効なものとして受け入れる必要があります。サーバーは他のドメインを有効な翻訳がないものとして扱う場合があります。サーバーが複数のドメインまたはすべてのドメインのユーザーを受け入れることができる場合、より一般的なサービスが提供され、セキュリティの制約を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an implementation guide, both clients and servers may provide a means to configure the &#34;dns_domain&#34; portion of the owner string. For example, the DNS domain name of the host running the NFS server might be &#34;lab.example.org&#34;, but the user names are defined in &#34;example.org&#34;. In the absence of such a configuration, or as a default, the current DNS domain name of the server should be the value used for the &#34;dns_domain&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装ガイドとして、クライアントとサーバーの両方が、所有者文字列の「dns_domain」部分を構成する手段を提供する場合があります。たとえば、NFSサーバーを実行しているホストのDNSドメイン名は「lab.example.org」かもしれませんが、ユーザー名は「example.org」で定義されています。そのような構成がない場合、またはデフォルトとして、サーバーの現在のDNSドメイン名は「dns_domain」に使用される値である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, it is desirable that a server, when accepting a string of the form &#34;user@domain&#34; or &#34;group@domain&#34; in an attribute, return this same string when that corresponding attribute is fetched. Internationalization issues make this impossible under certain circumstances, and the client needs to take note of these. See Section 12 for a detailed discussion of these issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、サーバーが属性で「user @ domain」または「group @ domain」の形式の文字列を受け入れる場合、対応する属性がフェッチされたときにこの同じ文字列を返すことが望ましいです。国際化の問題は特定の状況下ではこれを不可能にし、クライアントはこれらに注意する必要があります。これらの問題の詳細については、セクション12を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In the case where there is no translation available to the client or server, the attribute value will be constructed without the &#34;@&#34;. Therefore, the absence of the &#34;@&#34; from the owner or owner_group attribute signifies that no translation was available at the sender and that the receiver of the attribute should not use that string as a basis for translation into its own internal format. Even though the attribute value cannot be translated, it may still be useful. In the case of a client, the attribute string may be used for local display of ownership.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントまたはサーバーで使用可能な変換がない場合、属性値は「@」なしで構築されます。したがって、ownerまたはowner_group属性に「@」がない場合は、送信側で変換が利用できなかったこと、および属性の受信側がその文字列を独自の内部形式への変換の基礎として使用してはならないことを意味します。属性値は変換できませんが、それでも役立つ場合があります。クライアントの場合、所有権のローカル表示に属性文字列を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a greater degree of compatibility with NFSv3, which identified users and groups by 32-bit unsigned user identifiers and group identifiers, owner and group strings that consist of ASCII-encoded decimal numeric values with no leading zeros can be given a special interpretation by clients and servers that choose to provide such support. The receiver may treat such a user or group string as representing the same user as would be represented by an NFSv3 uid or gid having the corresponding numeric value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットの署名されていないユーザー識別子とグループ識別子によってユーザーとグループを識別したNFSv3との互換性を高めるために、先行ゼロのないASCIIエンコードされた10進数の数値で構成される所有者とグループの文字列は、そのようなサポートを提供することを選択したクライアントとサーバー。受信者は、そのようなユーザーまたはグループ文字列を、対応する数値を持つNFSv3 uidまたはgidによって表されるのと同じユーザーを表すものとして扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server SHOULD reject such a numeric value if the security mechanism is using Kerberos. That is, in such a scenario, the client will already need to form &#34;user@domain&#34; strings. For any other security mechanism, the server SHOULD accept such numeric values. As an implementation note, the server could make such an acceptance be configurable. If the server does not support numeric values or if it is configured off, then it MUST return an NFS4ERR_BADOWNER error. If the security mechanism is using Kerberos and the client attempts to use the special form, then the server SHOULD return an NFS4ERR_BADOWNER error when there is a valid translation for the user or owner designated in this way. In that case, the client must use the appropriate user@domain string and not the special form for compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティメカニズムがKerberosを使用している場合、サーバーはこのような数値を拒否する必要があります（SHOULD）。つまり、このようなシナリオでは、クライアントはすでに「user @ domain」文字列を形成する必要があります。他のセキュリティメカニズムでは、サーバーはそのような数値を受け入れる必要があります（SHOULD）。実装上の注意として、サーバーはそのような受け入れを構成可能にすることができます。サーバーが数値をサポートしていない場合、またはサーバーがオフに構成されている場合は、NFS4ERR_BADOWNERエラーを返す必要があります。セキュリティメカニズムがKerberosを使用していて、クライアントが特別な形式を使用しようとした場合、この方法で指定されたユーザーまたは所有者の有効な変換があると、サーバーはNFS4ERR_BADOWNERエラーを返す必要があります。その場合、クライアントは、互換性のための特別な形式ではなく、適切なuser @ domain文字列を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST always accept numeric values if the security mechanism is not RPCSEC_GSS. A client can determine if a server supports numeric identifiers by first attempting to provide a numeric identifier. If this attempt is rejected with an NFS4ERR_BADOWNER error, then the client should only use named identifiers of the form &#34;user@dns_domain&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティメカニズムがRPCSEC_GSSでない場合、クライアントは常に数値を受け入れる必要があります。クライアントは、最初に数値識別子を提供しようとすることにより、サーバーが数値識別子をサポートしているかどうかを判断できます。この試みがNFS4ERR_BADOWNERエラーで拒否された場合、クライアントは「user @ dns_domain」形式の名前付き識別子のみを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The owner string &#34;nobody&#34; may be used to designate an anonymous user, which will be associated with a file created by a security principal that cannot be mapped through normal means to the owner attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者文字列「nobody」は、匿名ユーザーを指定するために使用できます。匿名ユーザーは、通常の方法では所有者属性にマップできないセキュリティプリンシパルによって作成されたファイルに関連付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10. Character Case Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10. 文字ケース属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With respect to the case_insensitive and case_preserving attributes, case-insensitive comparisons of Unicode characters SHOULD use Unicode Default Case Folding as defined in Chapter 3 of the Unicode Standard [UNICODE] and MAY override that behavior for specific selected characters with the case folding defined in the SpecialCasing.txt [SPECIALCASING] file; see Section 3.13 of the Unicode Standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_insensitive属性とcase_preserving属性に関して、Unicode文字の比較では大文字と小文字を区別せず、Unicode Standard [UNICODE]の第3章で定義されているUnicodeデフォルトのCase Foldingを使用して（SHOULD）、特定の選択された文字の動作を、 SpecialCasing.txt [SPECIALCASING]ファイル。 Unicode標準のセクション3.13を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SpecialCasing.txt file replaces the Default Case Folding with locale- and context-dependent case folding for specific situations. An example of locale- and context-dependent case folding is that LATIN CAPITAL LETTER I (&#34;I&#34;, U+0049) is default case folded to LATIN SMALL LETTER I (&#34;i&#34;, U+0069). However, several languages (e.g., Turkish) treat an &#34;I&#34; character with a dot as a different letter than an &#34;I&#34; character without a dot; therefore, in such languages, unless an I is before a dot_above, the &#34;I&#34; (U+0049) character should be case folded to a different character, LATIN SMALL LETTER DOTLESS I (U+0131).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SpecialCasing.txtファイルは、デフォルトのケースフォールディングを、特定の状況でロケールおよびコンテキストに依存するケースフォールディングに置き換えます。ロケールとコンテキストに依存する大文字小文字の折りたたみの例は、ラテン大文字I（ &#34;I&#34;、U + 0049）がデフォルトの小文字小文字I（ &#34;i&#34;、U + 0069）に折りたたまれていることです。ただし、いくつかの言語（トルコ語など）では、ドットのある「I」文字を、ドットのない「I」文字とは異なる文字として扱います。したがって、そのような言語では、Iがdot_aboveの前にない限り、「I」（U + 0049）文字は大文字小文字の異なる文字、ラテン文字小文字ドットI（U + 0131）に変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The [UNICODE] and [SPECIALCASING] references in this RFC are for version 7.0.0 of the Unicode standard, as that was the latest version of Unicode when this RFC was published. Implementations SHOULD always use the latest version of Unicode (&lt;http://www.unicode.org/versions/latest/&gt;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このRFCの[UNICODE]および[SPECIALCASING]の参照は、このRFCが公開されたときのUnicodeの最新バージョンであるため、Unicode標準のバージョン7.0.0に関するものです。実装では常に最新バージョンのUnicode（&lt;http://www.unicode.org/versions/latest/&gt;）を使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Access Control Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. アクセス制御属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access Control Lists (ACLs) are file attributes that specify fine-grained access control. This section covers the &#34;acl&#34;, &#34;aclsupport&#34;, and &#34;mode&#34; file attributes, and their interactions. Note that file attributes may apply to any file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセス制御リスト（ACL）は、きめ細かいアクセス制御を指定するファイル属性です。このセクションでは、「acl」、「aclsupport」、および「mode」ファイルの属性とそれらの相互作用について説明します。ファイル属性は任意のファイルシステムオブジェクトに適用できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. ゴール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACLs and modes represent two well-established models for specifying permissions. This section specifies requirements that attempt to meet the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACLとモードは、権限を指定するための2つの確立されたモデルを表します。このセクションでは、次の目標を達成しようとする要件を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a server supports the mode attribute, it should provide reasonable semantics to clients that only set and retrieve the mode attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーがモード属性をサポートしている場合、モード属性の設定と取得のみを行うクライアントに適切なセマンティクスを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a server supports ACL attributes, it should provide reasonable semantics to clients that only set and retrieve those attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーがACL属性をサポートする場合、それらの属性の設定と取得のみを行うクライアントに適切なセマンティクスを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On servers that support the mode attribute, if ACL attributes have never been set on an object, via inheritance or explicitly, the behavior should be traditional UNIX-like behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mode属性をサポートするサーバーでは、継承または明示的にオブジェクトにACL属性が設定されていない場合、動作は従来のUNIXに似た動作である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On servers that support the mode attribute, if the ACL attributes have been previously set on an object, either explicitly or via inheritance:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o モード属性をサポートするサーバーで、ACL属性がオブジェクトに以前に明示的または継承によって設定されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Setting only the mode attribute should effectively control the traditional UNIX-like permissions of read, write, and execute on owner, owner_group, and other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* mode属性のみを設定することで、owner、owner_groupなどに対する、従来のUNIXに似た読み取り、書き込み、実行のアクセス許可を効果的に制御できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Setting only the mode attribute should provide reasonable security. For example, setting a mode of 000 should be enough to ensure that future opens for read or write by any principal fail, regardless of a previously existing or inherited ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* mode属性のみを設定すると、妥当なセキュリティが提供されます。たとえば、000のモードを設定すれば、既存のACLや継承されたACLに関係なく、プリンシパルによる読み取りまたは書き込みの将来のオープンが失敗することを保証するには十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a mode attribute is set on an object, the ACL attributes may need to be modified so as to not conflict with the new mode. In such cases, it is desirable that the ACL keep as much information as possible. This includes information about inheritance, AUDIT and ALARM access control entries (ACEs), and permissions granted and denied that do not conflict with the new mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o オブジェクトにモード属性が設定されている場合、新しいモードと競合しないようにACL属性を変更する必要がある場合があります。そのような場合、ACLができるだけ多くの情報を保持することが望ましいです。これには、継承、AUDITおよびALARMアクセスコントロールエントリ（ACE）、および新しいモードと競合しない許可および拒否されたアクセス許可に関する情報が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. File Attributes Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. ファイル属性のディスカッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Support for each of the ACL attributes is RECOMMENDED and not required, since file systems accessed using NFSv4 might not support ACLs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4を使用してアクセスされるファイルシステムはACLをサポートしない可能性があるため、各ACL属性のサポートは推奨されており、必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. Attribute 12: acl
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. 属性12：acl
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.0 ACL attribute contains an array of ACEs that are associated with the file system object. Although the client can read and write the acl attribute, the server is responsible for using the ACL to perform access control. The client can use the OPEN or ACCESS operations to check access without modifying or reading data or metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0 ACL属性には、ファイルシステムオブジェクトに関連付けられているACEの配列が含まれています。クライアントはacl属性を読み書きできますが、サーバーはACLを使用してアクセス制御を実行する必要があります。クライアントは、OPENまたはACCESS操作を使用して、データやメタデータを変更したり読み取ったりせずにアクセスを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS ACE structure is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS ACE構造は次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t acetype4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t acetype4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t aceflag4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t aceflag4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t acemask4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t acemask4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfsace4 {
           acetype4                type;
           aceflag4                flag;
           acemask4                access_mask;
           utf8str_mixed           who;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To determine if a request succeeds, the server processes each nfsace4 entry in order. Only ACEs that have a &#34;who&#34; that matches the requester are considered. Each ACE is processed until all of the bits of the requester&#39;s access have been ALLOWED. Once a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it is no longer considered in the processing of later ACEs. If an ACCESS_DENIED_ACE is encountered where the requester&#39;s access still has unALLOWED bits in common with the &#34;access_mask&#34; of the ACE, the request is denied. When the ACL is fully processed, if there are bits in the requester&#39;s mask that have not been ALLOWED or DENIED, access is denied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リクエストが成功したかどうかを判断するために、サーバーは各nfsace4エントリを順番に処理します。要求者に一致する「who」を持つACEのみが考慮されます。各ACEは、要求者のアクセスのすべてのビットが許可されるまで処理されます。 ACCESS_ALLOWED_ACEによってビット（以下を参照）が許可されると、以降のACEの処理では考慮されなくなります。リクエスターのアクセスにACEの「access_mask」と共通のunALLOWEDビットがまだあるACCESS_DENIED_ACEが検出された場合、要求は拒否されます。 ACLが完全に処理されたときに、リクエスタのマスクに許可または拒否されていないビットがある場合、アクセスは拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike the ALLOW and DENY ACE types, the ALARM and AUDIT ACE types do not affect a requester&#39;s access and instead are for triggering events as a result of a requester&#39;s access attempt. Therefore, AUDIT and ALARM ACEs are processed only after processing ALLOW and DENY ACEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOWおよびDENY ACEタイプとは異なり、ALARMおよびAUDIT ACEタイプはリクエスターのアクセスに影響せず、リクエスターのアクセス試行の結果としてイベントをトリガーするためのものです。したがって、AUDITおよびALARM ACEは、ALLOWおよびDENY ACEを処理した後でのみ処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.0 ACL model is quite rich. Some server platforms may provide access control functionality that goes beyond the UNIX-style mode attribute but that is not as rich as the NFS ACL model. So that users can take advantage of this more limited functionality, the server may support the acl attributes by mapping between its ACL model and the NFSv4.0 ACL model. Servers must ensure that the ACL they actually store or enforce is at least as strict as the NFSv4 ACL that was set. It is tempting to accomplish this by rejecting any ACL that falls outside the small set that can be represented accurately. However, such an approach can render ACLs unusable without special client-side knowledge of the server&#39;s mapping, which defeats the purpose of having a common NFSv4 ACL protocol. Therefore, servers should accept every ACL that they can without compromising security. To help accomplish this, servers may make a special exception, in the case of unsupported permission bits, to the rule that bits not ALLOWED or DENIED by an ACL must be denied. For example, a UNIX-style server might choose to silently allow read attribute permissions even though an ACL does not explicitly allow those permissions. (An ACL that explicitly denies permission to read attributes should still result in a denial.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0 ACLモデルは非常に豊富です。一部のサーバープラットフォームは、UNIXスタイルのモード属性を超えるアクセス制御機能を提供しますが、NFS ACLモデルほど豊富ではありません。ユーザーがこのより限定された機能を利用できるように、サーバーはACLモデルとNFSv4.0 ACLモデルの間のマッピングによってacl属性をサポートする場合があります。サーバーは、サーバーが実際に格納または実施するACLが、少なくとも設定されたNFSv4 ACLと同じくらい厳格であることを確認する必要があります。正確に表すことができる小さなセットの外にあるACLを拒否することでこれを実現したくなります。ただし、このようなアプローチでは、サーバー側のマッピングに関するクライアント側の特別な知識がなければ、ACLが使用できなくなる可能性があり、これは一般的なNFSv4 ACLプロトコルを持つ目的に反します。したがって、サーバーはセキュリティを犠牲にすることなく、可能なすべてのACLを受け入れる必要があります。これを実現するために、サーバーは、サポートされていない許可ビットの場合、ACLによって許可または拒否されていないビットを拒否する必要があるという規則に対して、特別な例外を作成する場合があります。たとえば、UNIXスタイルのサーバーは、ACLが明示的にアクセス許可を許可していなくても、読み取り属性アクセス許可をサイレントに許可することを選択する場合があります。 （属性の読み取り権限を明示的に拒否するACLでも、拒否が発生するはずです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The situation is complicated by the fact that a server may have multiple modules that enforce ACLs. For example, the enforcement for NFSv4.0 access may be different from, but not weaker than, the enforcement for local access, and both may be different from the enforcement for access through other protocols such as Server Message Block (SMB) [MS-SMB]. So it may be useful for a server to accept an ACL even if not all of its modules are able to support it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーには、ACLを適用する複数のモジュールがある場合があるため、状況は複雑です。たとえば、NFSv4.0アクセスの施行は、ローカルアクセスの施行とは異なる場合がありますが、それよりも弱くはなく、どちらもサーバーメッセージブロック（SMB）などのその他のプロトコルを介したアクセスの施行とは異なる場合があります[MS- SMB]。そのため、すべてのモジュールがACLをサポートできるわけではない場合でも、サーバーがACLを受け入れると便利な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guiding principle with regard to NFSv4 access is that the server must not accept ACLs that give an appearance of more restricted access to a file than what is actually enforced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4アクセスに関する基本原則は、サーバーは、実際に適用されているものよりもファイルへのアクセスが制限されているように見えるACLを受け入れてはならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.1. ACE Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.1. ACEタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constants used for the type field (acetype4) are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプフィールド（acetype4）に使用される定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All four bit types are permitted in the acl attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4つのビットタイプはすべてacl属性で許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------------+--------------+---------------------+
   | Value                        | Abbreviation | Description         |
   +------------------------------+--------------+---------------------+
   | ACE4_ACCESS_ALLOWED_ACE_TYPE | ALLOW        | Explicitly grants   |
   |                              |              | the access defined  |
   |                              |              | in acemask4 to the  |
   |                              |              | file or directory.  |
   |                              |              |                     |
   | ACE4_ACCESS_DENIED_ACE_TYPE  | DENY         | Explicitly denies   |
   |                              |              | the access defined  |
   |                              |              | in acemask4 to the  |
   |                              |              | file or directory.  |
   |                              |              |                     |
   | ACE4_SYSTEM_AUDIT_ACE_TYPE   | AUDIT        | LOG (in a system-   |
   |                              |              | dependent way) any  |
   |                              |              | access attempt to a |
   |                              |              | file or directory   |
   |                              |              | that uses any of    |
   |                              |              | the access methods  |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   |                              |              |                     |
   | ACE4_SYSTEM_ALARM_ACE_TYPE   | ALARM        | Generate a system   |
   |                              |              | ALARM (system       |
   |                              |              | dependent) when any |
   |                              |              | access attempt is   |
   |                              |              | made to a file or   |
   |                              |              | directory for the   |
   |                              |              | access methods      |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   +------------------------------+--------------+---------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
The &#34;Abbreviation&#34; column denotes how the types will be referred to throughout the rest of this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
「略語」の列は、このセクションの残りの部分でタイプがどのように参照されるかを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.2. Attribute 13: aclsupport
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.2. 属性13：aclsupport
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server need not support all of the above ACE types. This attribute indicates which ACE types are supported for the current file system. The bitmask constants used to represent the above definitions within the aclsupport attribute are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、上記のACEタイプのすべてをサポートする必要はありません。この属性は、現在のファイルシステムでサポートされているACEタイプを示します。 aclsupport属性内の上記の定義を表すために使用されるビットマスク定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that support either the ALLOW or DENY ACE type SHOULD support both ALLOW and DENY ACE types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOWまたはDENY ACEタイプをサポートするサーバーは、ALLOWおよびDENY ACEタイプの両方をサポートする必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should not attempt to set an ACE unless the server claims support for that ACE type. If the server receives a request to set an ACE that it cannot store, it MUST reject the request with NFS4ERR_ATTRNOTSUPP. If the server receives a request to set an ACE that it can store but cannot enforce, the server SHOULD reject the request with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがそのACEタイプのサポートを要求しない限り、クライアントはACEを設定しないでください。サーバーは、格納できないACEを設定する要求を受信した場合、NFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。サーバーが格納できるが強制できないACEを設定する要求を受信した場合、サーバーはNFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3. ACE Access Mask
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3. ACEアクセスマスク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmask constants used for the access mask field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスマスクフィールドに使用されるビットマスク定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that some masks have coincident values -- for example, ACE4_READ_DATA and ACE4_LIST_DIRECTORY. The mask entries ACE4_LIST_DIRECTORY, ACE4_ADD_FILE, and ACE4_ADD_SUBDIRECTORY are intended to be used with directory objects, while ACE4_READ_DATA, ACE4_WRITE_DATA, and ACE4_APPEND_DATA are intended to be used with non-directory objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_DATAとACE4_LIST_DIRECTORYなど、一部のマスクには一致する値があることに注意してください。マスクエントリACE4_LIST_DIRECTORY、ACE4_ADD_FILE、およびACE4_ADD_SUBDIRECTORYは、ディレクトリオブジェクトでの使用を目的としていますが、ACE4_READ_DATA、ACE4_WRITE_DATA、およびACE4_APPEND_DATAは、非ディレクトリオブジェクトでの使用を目的としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.1. Discussion of Mask Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.1. マスク属性の説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READ
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
読んだ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to read the data of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルのデータを読み取る権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サーバーは、ACE4_EXECUTEアクセスマスクビットのみが設定されている場合に、ユーザーがファイルのデータを読み取ることができるようにする必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_LIST_DIRECTORY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_LIST_DIRECTORY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READDIR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READDIR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to list the contents of a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリの内容を一覧表示する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
書く
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サイズのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to modify a file&#39;s data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルのデータを変更する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_ADD_FILE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_ADD_FILE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
作成する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
LINK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リンク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to add a new file in a directory. The CREATE operation is affected when nfs_ftype4 is NF4LNK, NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO. (NF4DIR is not listed because it is covered by ACE4_ADD_SUBDIRECTORY.) OPEN is affected when used to create a regular file. LINK and RENAME are always affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリに新しいファイルを追加する権限。 nfs_ftype4がNF4LNK、NF4BLK、NF4CHR、NF4SOCK、またはNF4FIFOの場合、CREATE操作が影響を受けます。 （NF4DIRはACE4_ADD_SUBDIRECTORYでカバーされているため、リストに含まれていません。）OPENは、通常のファイルの作成に使用された場合に影響を受けます。 LINKとRENAMEは常に影響を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_APPEND_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_APPEND_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
書く
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サイズのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The ability to modify a file&#39;s data, but only starting at EOF. This allows for the notion of append-only files, by allowing ACE4_APPEND_DATA and denying ACE4_WRITE_DATA to the same user or group. If a file has an ACL such as the one described above and a WRITE request is made for somewhere other than EOF, the server SHOULD return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルのデータを変更する機能。ただし、EOFからのみ開始。これにより、ACE4_APPEND_DATAを許可し、同じユーザーまたはグループに対してACE4_WRITE_DATAを拒否することで、追加専用ファイルの概念が可能になります。ファイルに上記のようなACLがあり、EOF以外の場所に対してWRITE要求が行われた場合、サーバーはNFS4ERR_ACCESSを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_ADD_SUBDIRECTORY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_ADD_SUBDIRECTORY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
作成する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to create a subdirectory in a directory. The CREATE operation is affected when nfs_ftype4 is NF4DIR. The RENAME operation is always affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリにサブディレクトリを作成する権限。 nfs_ftype4がNF4DIRの場合、CREATE操作が影響を受けます。 RENAME操作は常に影響を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_NAMED_ATTRS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_NAMED_ATTRS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPENATTR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPENATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to read the named attributes of a file or to look up the named attributes directory. OPENATTR is affected when it is not used to create a named attribute directory. This is when 1) createdir is TRUE but a named attribute directory already exists or 2) createdir is FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルの名前付き属性を読み取る権限、または名前付き属性ディレクトリを検索する権限。 OPENATTRは、名前付き属性ディレクトリの作成に使用されない場合に影響を受けます。これは、1）createdirがTRUEであるが、名前付き属性ディレクトリがすでに存在する場合、または2）createdirがFALSEの場合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_NAMED_ATTRS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_NAMED_ATTRS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPENATTR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPENATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to write the named attributes of a file or to create a named attribute directory. OPENATTR is affected when it is used to create a named attribute directory. This is when createdir is TRUE and no named attribute directory exists. The ability to check whether or not a named attribute directory exists depends on the ability to look it up; therefore, users also need the ACE4_READ_NAMED_ATTRS permission in order to create a named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルの名前付き属性を書き込む権限、または名前付き属性ディレクトリを作成する権限。 OPENATTRを使用して名前付き属性ディレクトリを作成すると、OPENATTRが影響を受けます。これは、createdirがTRUEで、名前付き属性ディレクトリが存在しない場合です。名前付き属性ディレクトリが存在するかどうかを確認する機能は、それを検索する機能に依存します。したがって、名前付き属性ディレクトリを作成するには、ユーザーにもACE4_READ_NAMED_ATTRS権限が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_EXECUTE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_EXECUTE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READ
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
読んだ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to execute a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルを実行する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is set. This is because there is no way to execute a file without reading the contents. Though a server may treat ACE4_EXECUTE and ACE4_READ_DATA bits identically when deciding to permit a READ operation, it SHOULD still allow the two bits to be set independently in ACLs and MUST distinguish between them when replying to ACCESS operations. In particular, servers SHOULD NOT silently turn on one of the two bits when the other is set, as that would make it impossible for the client to correctly enforce the distinction between read and execute permissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サーバーは、ACE4_EXECUTEアクセスマスクビットのみが設定されている場合に、ユーザーがファイルのデータを読み取ることができるようにする必要があります（SHOULD）。これは、内容を読み取らずにファイルを実行する方法がないためです。サーバーはREAD操作を許可することを決定する際にACE4_EXECUTEおよびACE4_READ_DATAビットを同じように扱うかもしれませんが、それでも2つのビットがACLで独立して設定されることを許可し、ACCESS操作に応答するときにそれらを区別しなければなりません。特に、サーバーは2つのビットのいずれかが設定されている場合、一方をオンにしないでください。これにより、クライアントが読み取りと実行のアクセス許可を正しく区別できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
As an example, following a SETATTR of the following ACL:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
例として、次のACLのSETATTRに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfsuser:ACE4_EXECUTE:ALLOW
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfsuser：ACE4_EXECUTE：ALLOW
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
A subsequent GETATTR of ACL for that file SHOULD return:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
そのファイルのACLの後続のGETATTRは以下を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfsuser:ACE4_EXECUTE:ALLOW
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfsuser：ACE4_EXECUTE：ALLOW
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Rather than:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
のではなく：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_EXECUTE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_EXECUTE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
LOOKUP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
調べる
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
REMOVE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
削除する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
LINK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リンク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
作成する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to traverse/search a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリを全探索/検索する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DELETE_CHILD
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DELETE_CHILD
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
REMOVE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
削除する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to delete a file or directory within a directory. See Section 6.2.1.3.2 for information on how ACE4_DELETE and ACE4_DELETE_CHILD interact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリ内のファイルまたはディレクトリを削除する権限。 ACE4_DELETEとACE4_DELETE_CHILDがどのように相互作用するかについては、セクション6.2.1.3.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_ATTRIBUTES
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_ATTRIBUTES
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
GETATTR of file system object attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルシステムオブジェクト属性のGETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
VERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
NVERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認しない
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READDIR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READDIR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The ability to read basic attributes (non-ACLs) of a file. On a UNIX system, basic attributes can be thought of as the stat-level attributes. Allowing this access mask bit would mean the entity can execute &#34;ls -l&#34; and stat. If a READDIR operation requests attributes, this mask must be allowed for the READDIR to succeed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルの基本属性（非ACL）を読み取る機能。 UNIXシステムでは、基本的な属性は統計レベルの属性と考えることができます。このアクセスマスクビットを許可すると、エンティティは &#34;ls -l&#34;およびstatを実行できます。 READDIR操作が属性を要求する場合、READDIRが成功するには、このマスクが許可されている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_ATTRIBUTES
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_ATTRIBUTES
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of time_access_set, time_backup, time_create, time_modify_set, mimetype, hidden, and system
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
time_access_set、time_backup、time_create、time_modify_set、mimetype、hidden、およびsystemのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to change the times associated with a file or directory to an arbitrary value. Also, permission to change the mimetype, hidden and system attributes. A user having ACE4_WRITE_DATA or ACE4_WRITE_ATTRIBUTES will be allowed to set the times associated with a file to the current server time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルまたはディレクトリに関連付けられた時間を任意の値に変更する権限。また、mimetype、hidden、およびsystem属性を変更する権限。 ACE4_WRITE_DATAまたはACE4_WRITE_ATTRIBUTESを持つユーザーは、ファイルに関連付けられた時刻を現在のサーバー時刻に設定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DELETE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DELETE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
REMOVE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
削除する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to delete the file or directory. See Section 6.2.1.3.2 for information on ACE4_DELETE and ACE4_DELETE_CHILD interact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルまたはディレクトリを削除する権限。 ACE4_DELETEとACE4_DELETE_CHILDの相互作用については、セクション6.2.1.3.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_ACL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_ACL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
GETATTR of acl
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ACLのGETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
NVERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認しない
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
VERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to read the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ACLを読み取る権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_ACL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_ACL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of acl and mode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ACLとモードのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to write the acl and mode attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
aclおよびmode属性を書き込む権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_OWNER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_OWNER
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of owner and owner_group
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
所有者とowner_groupのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to write the owner and owner_group attributes. On UNIX systems, this is the ability to execute chown() and chgrp().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ownerおよびowner_group属性を書き込む権限。 UNIXシステムでは、これはchown()およびchgrp()を実行する機能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SYNCHRONIZE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SYNCHRONIZE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
NONE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to use the file object as a synchronization primitive for interprocess communication. This permission is not enforced or interpreted by the NFSv4.0 server on behalf of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
プロセス間通信の同期プリミティブとしてファイルオブジェクトを使用する権限。この許可は、クライアントに代わってNFSv4.0サーバーによって強制または解釈されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Typically, the ACE4_SYNCHRONIZE permission is only meaningful on local file systems, i.e., file systems not accessed via NFSv4.0. The reason that the permission bit exists is that some operating environments, such as Windows, use ACE4_SYNCHRONIZE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
通常、ACE4_SYNCHRONIZE権限は、ローカルファイルシステム、つまりNFSv4.0を介してアクセスされないファイルシステムでのみ意味があります。許可ビットが存在する理由は、Windowsなどの一部のオペレーティング環境がACE4_SYNCHRONIZEを使用するためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
For example, if a client copies a file that has ACE4_SYNCHRONIZE set from a local file system to an NFSv4.0 server, and then later copies the file from the NFSv4.0 server to a local file system, it is likely that if ACE4_SYNCHRONIZE was set in the original file, the client will want it set in the second copy. The first copy will not have the permission set unless the NFSv4.0 server has the means to set the ACE4_SYNCHRONIZE bit. The second copy will not have the permission set unless the NFSv4.0 server has the means to retrieve the ACE4_SYNCHRONIZE bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
たとえば、クライアントがACE4_SYNCHRONIZEが設定されたファイルをローカルファイルシステムからNFSv4.0サーバーにコピーし、その後NFSv4.0サーバーからローカルファイルシステムにファイルをコピーした場合、ACE4_SYNCHRONIZEが元のファイルに設定した場合、クライアントは2番目のコピーに設定する必要があります。 NFSv4.0サーバーがACE4_SYNCHRONIZEビットを設定する手段を備えていない限り、最初のコピーには権限が設定されません。 NFSv4.0サーバーがACE4_SYNCHRONIZEビットを取得する手段を備えていない限り、2番目のコピーには権限が設定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server implementations need not provide the granularity of control that is implied by this list of masks. For example, POSIX-based systems might not distinguish ACE4_APPEND_DATA (the ability to append to a file) from ACE4_WRITE_DATA (the ability to modify existing contents); both masks would be tied to a single &#34;write&#34; permission. When such a server returns attributes to the client, it would show both ACE4_APPEND_DATA and ACE4_WRITE_DATA if and only if the write permission is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装は、このマスクのリストが意味する細かい制御を提供する必要はありません。たとえば、POSIXベースのシステムでは、ACE4_APPEND_DATA（ファイルに追加する機能）とACE4_WRITE_DATA（既存のコンテンツを変更する機能）を区別できない場合があります。両方のマスクは、単一の「書き込み」権限に関連付けられます。このようなサーバーが属性をクライアントに返す場合、書き込み権限が有効になっている場合にのみ、ACE4_APPEND_DATAとACE4_WRITE_DATAの両方が表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server receives a SETATTR request that it cannot accurately implement, it should err in the direction of more restricted access, except in the previously discussed cases of execute and read. For example, suppose a server cannot distinguish overwriting data from appending new data, as described in the previous paragraph. If a client submits an ALLOW ACE where ACE4_APPEND_DATA is set but ACE4_WRITE_DATA is not (or vice versa), the server should either turn off ACE4_APPEND_DATA or reject the request with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが正確に実装できないSETATTR要求を受け取った場合、前述の実行と読み取りの場合を除いて、より制限されたアクセスの方向にエラーが発生するはずです。たとえば、前の段落で説明したように、サーバーがデータの上書きと新しいデータの追加を区別できないとします。クライアントがACE4_APPEND_DATAが設定されているがACE4_WRITE_DATAが設定されていない（またはその逆の）ALLOW ACEを送信する場合、サーバーはACE4_APPEND_DATAをオフにするか、NFS4ERR_ATTRNOTSUPPで要求を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.2. ACE4_DELETE versus ACE4_DELETE_CHILD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.2. ACE4_DELETEとACE4_DELETE_CHILD
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two access mask bits govern the ability to delete a directory entry: ACE4_DELETE on the object itself (the &#34;target&#34;) and ACE4_DELETE_CHILD on the containing directory (the &#34;parent&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのアクセスマスクビットは、ディレクトリエントリを削除する機能を管理します。オブジェクト自体（「ターゲット」）のACE4_DELETEと、それを含むディレクトリ（「親」）のACE4_DELETE_CHILDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many systems also take the &#34;sticky bit&#34; (MODE4_SVTX) on a directory to allow unlink only to a user that owns either the target or the parent; on some such systems, the decision also depends on whether the target is writable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのシステムでは、ディレクトリで「スティッキービット」（MODE4_SVTX）を使用して、ターゲットまたは親のいずれかを所有するユーザーのみへのリンク解除を許可します。一部のそのようなシステムでは、決定はターゲットが書き込み可能かどうかにも依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers SHOULD allow unlink if either ACE4_DELETE is permitted on the target or ACE4_DELETE_CHILD is permitted on the parent. (Note that this is true even if the parent or target explicitly denies the other of these permissions.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットでACE4_DELETEが許可されているか、親でACE4_DELETE_CHILDが許可されている場合、サーバーはリンク解除を許可する必要があります（SHOULD）。 （これは、親またはターゲットがこれらの権限の他方を明示的に拒否した場合でも当てはまります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the ACLs in question neither explicitly ALLOW nor DENY either of the above, and if MODE4_SVTX is not set on the parent, then the server SHOULD allow the removal if and only if ACE4_ADD_FILE is permitted. In the case where MODE4_SVTX is set, the server may also require the remover to own either the parent or the target, or may require the target to be writable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題のACLが上記のいずれかを明示的に許可も拒否もしない場合、および親にMODE4_SVTXが設定されていない場合、サーバーは、ACE4_ADD_FILEが許可されている場合に限り、削除を許可する必要があります（SHOULD）。 MODE4_SVTXが設定されている場合、サーバーはリムーバーが親またはターゲットのいずれかを所有することを要求するか、ターゲットが書き込み可能であることを要求する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This allows servers to support something close to traditional UNIX-like semantics, with ACE4_ADD_FILE taking the place of the write bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、サーバーは、書き込みビットの代わりにACE4_ADD_FILEを使用して、従来のUNIXに似たセマンティクスに近いものをサポートできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4. ACE flag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4. ACEフラグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmask constants used for the flag field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグフィールドに使用されるビットマスク定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server need not support any of these flags. If the server supports flags that are similar to, but not exactly the same as, these flags, the implementation may define a mapping between the protocol-defined flags and the implementation-defined flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこれらのフラグをサポートする必要はありません。サーバーがこれらのフラグに類似しているがまったく同じではないフラグをサポートしている場合、実装はプロトコル定義のフラグと実装定義のフラグの間のマッピングを定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For example, suppose a client tries to set an ACE with ACE4_FILE_INHERIT_ACE set but not ACE4_DIRECTORY_INHERIT_ACE. If the server does not support any form of ACL inheritance, the server should reject the request with NFS4ERR_ATTRNOTSUPP. If the server supports a single &#34;inherit ACE&#34; flag that applies to both files and directories, the server may reject the request (i.e., requiring the client to set both the file and directory inheritance flags). The server may also accept the request and silently turn on the ACE4_DIRECTORY_INHERIT_ACE flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
たとえば、クライアントがACE4_FILE_INHERIT_ACEを設定してACE4_DIRECTORY_INHERIT_ACEを設定せずにACEを設定しようとしているとします。サーバーがどの形式のACL継承もサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。サーバーがファイルとディレクトリの両方に適用される単一の「継承ACE」フラグをサポートしている場合、サーバーはリクエストを拒否する可能性があります（つまり、クライアントにファイルとディレクトリの両方の継承フラグを設定するよう要求する）。サーバーは要求を受け入れ、サイレントにACE4_DIRECTORY_INHERIT_ACEフラグをオンにすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4.1. Discussion of Flag Bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4.1. フラグビットの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FILE_INHERIT_ACE Any non-directory file in any subdirectory will get this ACE inherited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FILE_INHERIT_ACEサブディレクトリ内の非ディレクトリファイルは、このACEを継承します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DIRECTORY_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new directory created. If this flag is set in an ACE in an ACL attribute to be set on a non-directory file system object, the operation attempting to set the ACL SHOULD fail with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DIRECTORY_INHERIT_ACEディレクトリに配置でき、このACEを、作成される新しい各ディレクトリに追加する必要があることを示します。このフラグが、ディレクトリ以外のファイルシステムオブジェクトに設定されるACL属性のACEで設定されている場合、ACLを設定しようとする操作はNFS4ERR_ATTRNOTSUPPで失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERIT_ONLY_ACE Can be placed on a directory but does not apply to the directory; ALLOW and DENY ACEs with this bit set do not affect access to the directory, and AUDIT and ALARM ACEs with this bit set do not trigger log or alarm events. Such ACEs only take effect once they are applied (with this bit cleared) to newly created files and directories as specified by the above two flags. If this flag is present on an ACE, but neither ACE4_DIRECTORY_INHERIT_ACE nor ACE4_FILE_INHERIT_ACE is present, then an operation attempting to set such an attribute SHOULD fail with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERIT_ONLY_ACEディレクトリに配置できますが、ディレクトリには適用されません。このビットが設定されたALLOWおよびDENY ACEは、ディレクトリへのアクセスに影響を与えません。また、このビットが設定されたAUDITおよびALARM ACEは、ログまたはアラームイベントをトリガーしません。このようなACEは、上記の2つのフラグで指定されたように、新しく作成されたファイルとディレクトリに適用された（このビットがクリアされている）場合にのみ有効になります。このフラグがACEに存在するが、ACE4_DIRECTORY_INHERIT_ACEもACE4_FILE_INHERIT_ACEも存在しない場合、そのような属性を設定しようとする操作はNFS4ERR_ATTRNOTSUPPで失敗する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_NO_PROPAGATE_INHERIT_ACE Can be placed on a directory. This flag tells the server that inheritance of this ACE should stop at newly created child directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_NO_PROPAGATE_INHERIT_ACEディレクトリに配置できます。このフラグは、このACEの継承が新しく作成された子ディレクトリで停止することをサーバーに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 ACE4_FAILED_ACCESS_ACE_FLAG The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS) and ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits may be set only on ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE types. If, during the processing of the file&#39;s ACL, the server encounters an AUDIT or ALARM ACE that matches the principal attempting the OPEN, the server notes that fact and notes the presence, if any, of the SUCCESS and FAILED flags encountered in the AUDIT or ALARM ACE. Once the server completes the ACL processing, it then notes if the operation succeeded or failed. If the operation succeeded, and if the SUCCESS flag was set for a matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. If the operation failed, and if the FAILED flag was set for the matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. Either or both of the SUCCESS or FAILED can be set, but if neither is set, the AUDIT or ALARM ACE is not useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ACE4_FAILED_ACCESS_ACE_FLAG ACE4_SUCCESSFUL_ACCESS_ACE_FLAG（SUCCESS）およびACE4_FAILED_ACCESS_ACE_FLAG（FAILED）フラグビットは、ACE4_SYSTEM_AUDIT_ACE_TYPE（AUDIT）およびACE4_SYSTEM_ALARM_ACE_TYPE（。ファイルのACLの処理中に、サーバーがOPENを試行するプリンシパルと一致するAUDITまたはALARM ACEを検出すると、サーバーはその事実を記録し、AUDITまたはFAILEDフラグで発生したSUCCESSおよびFAILEDフラグの存在を記録します。アラームエース。サーバーはACL処理を完了すると、操作が成功したか失敗したかを記録します。操作が成功し、一致するAUDITまたはALARM ACEにSUCCESSフラグが設定されている場合、適切なAUDITまたはALARMイベントが発生します。操作が失敗し、一致するAUDITまたはALARM ACEにFAILEDフラグが設定されている場合、適切なAUDITまたはALARMイベントが発生します。 SUCCESSまたはFAILEDのいずれかまたは両方を設定できますが、どちらも設定されていない場合、AUDITまたはALARM ACEは役に立ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The previously described processing applies to ACCESS operations even when they return NFS4_OK. For the purposes of AUDIT and ALARM, we consider an ACCESS operation to be a &#34;failure&#34; if it fails to return a bit that was requested and supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
前述の処理は、NFS4_OKを返す場合でも、ACCESS操作に適用されます。 AUDITとALARMの目的のために、要求されサポートされているビットを返すことができない場合、ACCESS操作は「失敗」と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_IDENTIFIER_GROUP Indicates that the &#34;who&#34; refers to a GROUP as defined under UNIX or a GROUP ACCOUNT as defined under Windows. Clients and servers MUST ignore the ACE4_IDENTIFIER_GROUP flag on ACEs with a who value equal to one of the special identifiers outlined in Section 6.2.1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_IDENTIFIER_GROUP「who」がUNIXで定義されたGROUPまたはWindowsで定義されたGROUP ACCOUNTを指すことを示します。クライアントとサーバーは、セクション6.2.1.5で概説されている特別な識別子の1つに等しいwho値を持つACEのACE4_IDENTIFIER_GROUPフラグを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5. ACE Who
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5. エースフー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The who field of an ACE is an identifier that specifies the principal or principals to whom the ACE applies. It may refer to a user or a group, with the flag bit ACE4_IDENTIFIER_GROUP specifying which.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACEのwhoフィールドは、ACEが適用されるプリンシパルを指定する識別子です。フラグビットACE4_IDENTIFIER_GROUPがどちらを指定するかで、ユーザーまたはグループを参照する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several special identifiers that need to be understood universally, rather than in the context of a particular DNS domain. Some of these identifiers cannot be understood when an NFS client accesses the server but have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over NFS, even if none of the access methods on the server understand the identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のDNSドメインのコンテキストではなく、普遍的に理解する必要があるいくつかの特別な識別子があります。これらの識別子の一部は、NFSクライアントがサーバーにアクセスするときには理解できませんが、ローカルプロセスがファイルにアクセスするときには意味があります。これらのアクセス許可を表示および変更する機能は、サーバー上のアクセス方法が識別子を理解していない場合でも、NFSを介して許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------+---------------------------------------------------+
   | Who           | Description                                       |
   +---------------+---------------------------------------------------+
   | OWNER         | The owner of the file.                            |
   | GROUP         | The group associated with the file.               |
   | EVERYONE      | The world, including the owner and owning group.  |
   | INTERACTIVE   | Accessed from an interactive terminal.            |
   | NETWORK       | Accessed via the network.                         |
   | DIALUP        | Accessed as a dialup user to the server.          |
   | BATCH         | Accessed from a batch job.                        |
   | ANONYMOUS     | Accessed without any authentication.              |
   | AUTHENTICATED | Any authenticated user (opposite of ANONYMOUS).   |
   | SERVICE       | Access from a system service.                     |
   +---------------+---------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Table 5: Special Identifiers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
表5：特別な識別子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid conflict, these special identifiers are distinguished by an appended &#34;@&#34; and should appear in the form &#34;xxxx@&#34; (with no domain name after the &#34;@&#34;) -- for example, ANONYMOUS@.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合を回避するために、これらの特別な識別子は「@」が付加されて区別され、「xxxx @」（「@」の後にドメイン名はありません）の形式で表示されます（例：ANONYMOUS @）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ACE4_IDENTIFIER_GROUP flag MUST be ignored on entries with these special identifiers. When encoding entries with these special identifiers, the ACE4_IDENTIFIER_GROUP flag SHOULD be set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの特別な識別子を持つエントリでは、ACE4_IDENTIFIER_GROUPフラグを無視する必要があります。これらの特別な識別子でエントリをエンコードするとき、ACE4_IDENTIFIER_GROUPフラグはゼロに設定されるべきです（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5.1. Discussion of EVERYONE@
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5.1. EVERYONE @の議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that &#34;EVERYONE@&#34; is not equivalent to the UNIX &#34;other&#34; entity. This is because, by definition, UNIX &#34;other&#34; does not include the owner or owning group of a file. &#34;EVERYONE@&#34; means literally everyone, including the owner or owning group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「EVERYONE @」はUNIXの「その他」のエンティティと同等ではないことに注意することが重要です。これは、UNIXの「その他」にファイルの所有者または所有グループが含まれていないためです。 「EVERYONE @」は、所有者または所有グループを含む文字通り全員を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. Attribute 33: mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. 属性33：モード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.0 mode attribute is based on the UNIX mode bits. The following bits are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0モード属性は、UNIXモードビットに基づいています。次のビットが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const MODE4_SUID = 0x800;  /* set user id on execution */
   const MODE4_SGID = 0x400;  /* set group id on execution */
   const MODE4_SVTX = 0x200;  /* save text even after use */
   const MODE4_RUSR = 0x100;  /* read permission: owner */
   const MODE4_WUSR = 0x080;  /* write permission: owner */
   const MODE4_XUSR = 0x040;  /* execute permission: owner */
   const MODE4_RGRP = 0x020;  /* read permission: group */
   const MODE4_WGRP = 0x010;  /* write permission: group */
   const MODE4_XGRP = 0x008;  /* execute permission: group */
   const MODE4_ROTH = 0x004;  /* read permission: other */
   const MODE4_WOTH = 0x002;  /* write permission: other */
   const MODE4_XOTH = 0x001;  /* execute permission: other */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the principal identified in the owner attribute. Bits MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP apply to principals identified in the owner_group attribute but who are not identified in the owner attribute. Bits MODE4_ROTH, MODE4_WOTH, and MODE4_XOTH apply to any principal that does not match that in the owner attribute and does not have a group matching that of the owner_group attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットMODE4_RUSR、MODE4_WUSR、およびMODE4_XUSRは、所有者属性で識別されるプリンシパルに適用されます。ビットMODE4_RGRP、MODE4_WGRP、およびMODE4_XGRPは、owner_group属性で識別されるが、owner属性で識別されないプリンシパルに適用されます。ビットMODE4_ROTH、MODE4_WOTH、およびMODE4_XOTHは、所有者属性のプリンシパルと一致せず、owner_group属性のグループと一致するグループを持たないプリンシパルに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bits within the mode other than those specified above are not defined by this protocol. A server MUST NOT return bits other than those defined above in a GETATTR or READDIR operation, and it MUST return NFS4ERR_INVAL if bits other than those defined above are set in a SETATTR, CREATE, OPEN, VERIFY, or NVERIFY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で指定されたもの以外のモード内のビットは、このプロトコルでは定義されていません。サーバーは、GETATTRまたはREADDIR操作で上記で定義されたもの以外のビットを返さないでください。また、上記で定義されたもの以外のビットがSETATTR、CREATE、OPEN、VERIFY、またはNVERIFY操作で設定されている場合は、NFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Common Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 一般的な方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirements in this section will be referred to in future sections, especially Section 6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの要件は、今後のセクション、特にセクション6.4で参照されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Interpreting an ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. ACLの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1. Server Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1. サーバーに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server uses the algorithm described in Section 6.2.1 to determine whether an ACL allows access to an object. However, the ACL may not be the sole determiner of access. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、セクション6.2.1で説明されているアルゴリズムを使用して、ACLがオブジェクトへのアクセスを許可するかどうかを決定します。ただし、ACLがアクセスの唯一の決定者であるとは限りません。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case of a file system exported as read-only, the server may deny write permissions even though an object&#39;s ACL grants it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 読み取り専用としてエクスポートされたファイルシステムの場合、オブジェクトのACLで許可されていても、サーバーは書き込み権限を拒否することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server implementations MAY grant ACE4_WRITE_ACL and ACE4_READ_ACL permissions to prevent a situation from arising in which there is no valid way to ever modify the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーの実装は、ACE4_WRITE_ACLおよびACE4_READ_ACLアクセス許可を付与して、ACLを変更する有効な方法がない状況が発生しないようにすることができます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All servers will allow a user the ability to read the data of the file when only the execute permission is granted (i.e., if the ACL denies the user ACE4_READ_DATA access and allows the user ACE4_EXECUTE, the server will allow the user to read the data of the file).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべてのサーバーは、実行権限のみが付与されている場合に、ユーザーがファイルのデータを読み取ることができるようにします（つまり、ACLがユーザーACE4_READ_DATAアクセスを拒否し、ユーザーACE4_EXECUTEを許可すると、サーバーはユーザーにデータの読み取りを許可しますファイル）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Many servers have the notion of owner-override, in which the owner of the object is allowed to override accesses that are denied by the ACL. This may be helpful, for example, to allow users continued access to open files on which the permissions have changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 多くのサーバーには、オブジェクトの所有者がACLによって拒否されたアクセスをオーバーライドすることが許可されている、所有者オーバーライドの概念があります。これは、たとえば、アクセス許可が変更された開いているファイルにユーザーが引き続きアクセスできるようにする場合に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Many servers have the notion of a &#34;superuser&#34; that has privileges beyond an ordinary user. The superuser may be able to read or write data or metadata in ways that would not be permitted by the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 多くのサーバーには、通常のユーザー以上の特権を持つ「スーパーユーザー」という概念があります。スーパーユーザーは、ACLで許可されていない方法でデータまたはメタデータを読み書きできる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.2. Client Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.2. クライアントの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients SHOULD NOT do their own access checks based on their interpretation of the ACL but rather use the OPEN and ACCESS operations to do access checks. This allows the client to act on the results of having the server determine whether or not access should be granted based on its interpretation of the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ACLの解釈に基づいて独自のアクセスチェックを行うべきではなく、OPENおよびACCESS操作を使用してアクセスチェックを行う必要があります。これにより、クライアントは、ACLの解釈に基づいてアクセスを許可するかどうかをサーバーに決定させた結果に基づいて行動できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients must be aware of situations in which an object&#39;s ACL will define a certain access even though the server will not have adequate information to enforce it. For example, the server has no way of determining whether a particular OPEN reflects a user&#39;s open for read access or is done as part of executing the file in question. In such situations, the client needs to do its part in the enforcement of access as defined by the ACL. To do this, the client will send the appropriate ACCESS operation (or use a cached previous determination) prior to servicing the request of the user or application in order to determine whether the user or application should be granted the access requested. For examples in which the ACL may define accesses that the server does not enforce, see Section 6.3.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、オブジェクトのACLが特定のアクセスを定義する状況を認識している必要がありますが、サーバーはそれを実施するための適切な情報を持っていません。たとえば、サーバーには、特定のOPENがユーザーの読み取りアクセスのためのオープンを反映しているか、問題のファイルの実行の一部として行われているかを判断する方法がありません。このような状況では、クライアントは、ACLで定義されているアクセスの実施においてその役割を果たす必要があります。これを行うために、ユーザーまたはアプリケーションに要求されたアクセスを許可するかどうかを決定するために、クライアントはユーザーまたはアプリケーションの要求を処理する前に適切なACCESS操作を送信します（またはキャッシュされた以前の決定を使用します）。 ACLがサーバーが実施しないアクセスを定義する例については、セクション6.3.1.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. Computing a mode Attribute from an ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. ACLからのモード属性の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following method can be used to calculate the MODE4_R*, MODE4_W*, and MODE4_X* bits of a mode attribute, based upon an ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のメソッドは、ACLに基づいて、モード属性のMODE4_R *、MODE4_W *、およびMODE4_X *ビットを計算するために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, for each of the special identifiers OWNER@, GROUP@, and EVERYONE@, evaluate the ACL in order, considering only ALLOW and DENY ACEs for the identifier EVERYONE@ and for the identifier under consideration. The result of the evaluation will be an NFSv4 ACL mask showing exactly which bits are permitted to that identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初に、特別な識別子OWNER @、GROUP @、およびEVERYONE @のそれぞれについて、順番にACLを評価します。識別子EVERYONE @および考慮中の識別子のALLOWおよびDENY ACEのみを考慮します。評価の結果は、その識別子に許可されているビットを正確に示すNFSv4 ACLマスクになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Then translate the calculated mask for OWNER@, GROUP@, and EVERYONE@ into mode bits for the user, group, and other, respectively, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、OWNER @、GROUP @、およびEVERYONE @の計算されたマスクを、次のように、それぞれユーザー、グループ、およびその他のモードビットに変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set the read bit (MODE4_RUSR, MODE4_RGRP, or MODE4_ROTH) if and only if ACE4_READ_DATA is set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set the read bit (MODE4_RUSR, MODE4_RGRP, or MODE4_ROTH) if and only if ACE4_READ_DATA is set in the corresponding mask.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set the write bit (MODE4_WUSR, MODE4_WGRP, or MODE4_WOTH) if and only if ACE4_WRITE_DATA and ACE4_APPEND_DATA are both set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ACE4_WRITE_DATAとACE4_APPEND_DATAの両方が対応するマスクに設定されている場合にのみ、書き込みビット（MODE4_WUSR、MODE4_WGRP、またはMODE4_WOTH）を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Set the execute bit (MODE4_XUSR, MODE4_XGRP, or MODE4_XOTH), if and only if ACE4_EXECUTE is set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ACE4_EXECUTEが対応するマスクで設定されている場合にのみ、実行ビット（MODE4_XUSR、MODE4_XGRP、またはMODE4_XOTH）を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. 討論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some server implementations also add bits permitted to named users and groups to the group bits (MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバー実装では、指定されたユーザーおよびグループに許可されたビットをグループビット（MODE4_RGRP、MODE4_WGRP、およびMODE4_XGRP）に追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations are discouraged from doing this, because it has been found to cause confusion for users who see members of a file&#39;s group denied access that the mode bits appear to allow. (The presence of DENY ACEs may also lead to such behavior, but DENY ACEs are expected to be more rarely used.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードビットが許可しているように見えるファイルのグループのメンバーがアクセスを拒否しているのを見るユーザーに混乱を引き起こすことが判明しているため、実装はこれを行わないようにしてください。 （DENY ACEの存在もこのような動作につながる可能性がありますが、DENY ACEが使用されることはほとんどありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same user confusion seen when fetching the mode also results if setting the mode does not effectively control permissions for the owner, group, and other users; this motivates some of the requirements that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードを取得するときに見られるのと同じユーザーの混乱は、モードの設定が所有者、グループ、および他のユーザーのアクセス許可を効果的に制御しない場合にも発生します。これにより、以下の要件の一部が動機付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. 必要条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server that supports both mode and ACL must take care to synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits with the ACEs that have respective who fields of &#34;OWNER@&#34;, &#34;GROUP@&#34;, and &#34;EVERYONE@&#34; so that the client can see that semantically equivalent access permissions exist whether the client asks for just the ACL or any of the owner, owner_group, and mode attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードとACLの両方をサポートするサーバーは、MODE4_ * USR、MODE4_ * GRP、およびMODE4_ * OTHビットを、「OWNER @」、「GROUP @」、および「EVERYONE @」のそれぞれのwhoフィールドを持つACEと同期するように注意する必要があります&#34;クライアントがACLだけを要求するか、owner、owner_group、mode属性のいずれを要求するかに関係なく、意味的に同等のアクセス許可が存在することをクライアントが確認できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many requirements refer to Section 6.3.2, but note that the methods have behaviors specified with &#34;SHOULD&#34;. This is intentional, to avoid invalidating existing implementations that compute the mode according to the withdrawn POSIX ACL draft ([P1003.1e]), rather than by actual permissions on owner, group, and other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの要件は6.3.2項を参照していますが、メソッドには「SHOULD」で指定された動作があることに注意してください。これは、所有者、グループなどに対する実際の権限ではなく、撤回されたPOSIX ACLドラフト（[P1003.1e]）に従ってモードを計算する既存の実装が無効になるのを避けるための意図的なものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. Setting the mode and/or ACL Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. モードやACL属性の設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.1. Setting mode and Not ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.1. ACLではなく設定モード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When any of the nine low-order mode bits are changed because the mode attribute was set, and no ACL attribute is explicitly set, the acl attribute must be modified in accordance with the updated value of those bits. This must happen even if the value of the low-order bits is the same after the mode is set as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モード属性が設定されたために9つの下位モードビットのいずれかが変更され、ACL属性が明示的に設定されていない場合、それらのビットの更新された値に従ってacl属性を変更する必要があります。これは、モードが以前に設定された後、下位ビットの値が同じであっても発生する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that any AUDIT or ALARM ACEs are unaffected by changes to the mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that any AUDIT or ALARM ACEs are unaffected by changes to the mode.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases in which the permissions bits are subject to change, the acl attribute MUST be modified such that the mode computed via the method described in Section 6.3.2 yields the low-order nine bits (MODE4_R*, MODE4_W*, MODE4_X*) of the mode attribute as modified by the change attribute. The ACL attributes SHOULD also be modified such that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
許可ビットが変更される可能性がある場合、セクション6.3.2で説明されている方法で計算されたモードが下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）を生成するように、acl属性を変更する必要があります。 change属性によって変更されたモード属性。 ACL属性は、次のように変更する必要もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If MODE4_RGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_READ_DATA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If MODE4_RGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_READ_DATA.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If MODE4_WGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_WRITE_DATA or ACE4_APPEND_DATA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. MODE4_WGRPが設定されていない場合、OWNER @およびEVERYONE @以外のACLに明示的にリストされているエンティティには、ACE4_WRITE_DATAまたはACE4_APPEND_DATAを付与しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If MODE4_XGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_EXECUTE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. MODE4_XGRPが設定されていない場合、OWNER @およびEVERYONE @以外のACLに明示的にリストされているエンティティには、ACE4_EXECUTEを付与しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access mask bits other than those listed above, appearing in ALLOW ACEs, MAY also be disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOW ACEに表示される上記以外のアクセスマスクビットも無効にできます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that ACEs with the flag ACE4_INHERIT_ONLY_ACE set do not affect the permissions of the ACL itself, nor do ACEs of the types AUDIT and ALARM. As such, it is desirable to leave these ACEs unmodified when modifying the ACL attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグACE4_INHERIT_ONLY_ACEが設定されたACEは、ACL自体のアクセス許可には影響せず、タイプAU​​DITおよびALARMのACEにも影響しないことに注意してください。そのため、ACL属性を変更するときは、これらのACEを変更しないでおくことが望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also note that the requirement may be met by discarding the acl in favor of an ACL that represents the mode and only the mode. This is permitted, but it is preferable for a server to preserve as much of the ACL as possible without violating the above requirements. Discarding the ACL makes it effectively impossible for a file created with a mode attribute to inherit an ACL (see Section 6.4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、モードを表し、モードのみを表すACLを優先して、ACLを破棄することで要件が満たされる場合があることに注意してください。これは許可されていますが、サーバーが上記の要件に違反することなく、できるだけ多くのACLを保持することをお勧めします。 ACLを破棄すると、mode属性で作成されたファイルがACLを継承することが事実上不可能になります（6.4.3項を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.2. Setting ACL and Not mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.2. ACLおよびNotモードの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When setting the acl and not setting the mode attribute, the permission bits of the mode need to be derived from the ACL. In this case, the ACL attribute SHOULD be set as given. The nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) MUST be modified to match the result of the method described in Section 6.3.2. The three high-order bits of the mode (MODE4_SUID, MODE4_SGID, MODE4_SVTX) SHOULD remain unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclを設定し、mode属性を設定しない場合、モードの許可ビットはACLから取得する必要があります。この場合、ACL属性は指定されたとおりに設定する必要があります（SHOULD）。モード属性の下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）は、セクション6.3.2で説明されているメソッドの結果と一致するように変更する必要があります。モードの3つの上位ビット（MODE4_SUID、MODE4_SGID、MODE4_SVTX）は変更されないままにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.3. Setting Both ACL and mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.3. ACLとモードの両方を設定する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When setting both the mode and the acl attribute in the same operation, the attributes MUST be applied in this order: mode, then ACL. The mode-related attribute is set as given, then the ACL attribute is set as given, possibly changing the final mode, as described above in Section 6.4.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When setting both the mode and the acl attribute in the same operation, the attributes MUST be applied in this order: mode, then ACL. The mode-related attribute is set as given, then the ACL attribute is set as given, possibly changing the final mode, as described above in Section 6.4.1.2.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. Retrieving the mode and/or ACL Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. モードおよび/またはACL属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section applies only to servers that support both the mode and ACL attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは、モードとACL属性の両方をサポートするサーバーにのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some server implementations may have a concept of &#34;objects without ACLs&#34;, meaning that all permissions are granted and denied according to the mode attribute, and that no ACL attribute is stored for that object. If an ACL attribute is requested of such a server, the server SHOULD return an ACL that does not conflict with the mode; that is to say, the ACL returned SHOULD represent the nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) as described in Section 6.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some server implementations may have a concept of &#34;objects without ACLs&#34;, meaning that all permissions are granted and denied according to the mode attribute, and that no ACL attribute is stored for that object. If an ACL attribute is requested of such a server, the server SHOULD return an ACL that does not conflict with the mode; that is to say, the ACL returned SHOULD represent the nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) as described in Section 6.3.2.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For other server implementations, the ACL attribute is always present for every object. Such servers SHOULD store at least the three high-order bits of the mode attribute (MODE4_SUID, MODE4_SGID, MODE4_SVTX). The server SHOULD return a mode attribute if one is requested, and the low-order nine bits of the mode (MODE4_R*, MODE4_W*, MODE4_X*) MUST match the result of applying the method in Section 6.3.2 to the ACL attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のサーバー実装の場合、ACL属性は常にすべてのオブジェクトに存在します。このようなサーバーは、モード属性（MODE4_SUID、MODE4_SGID、MODE4_SVTX）の少なくとも上位3ビットを格納する必要があります（SHOULD）。モード属性が要求された場合、サーバーはモード属性を返す必要があり（SHOULD）、モードの下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）は、セクション6.3.2のメソッドをACL属性に適用した結果と一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3. Creating New Objects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3. 新しいオブジェクトの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If a server supports any ACL attributes, it may use the ACL attributes on the parent directory to compute an initial ACL attribute for a newly created object. This will be referred to as the inherited ACL within this section. The act of adding one or more ACEs to the inherited ACL that are based upon ACEs in the parent directory&#39;s ACL will be referred to as inheriting an ACE within this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーがACL属性をサポートしている場合、サーバーは親ディレクトリのACL属性を使用して、新しく作成されたオブジェクトの初期ACL属性を計算できます。これは、このセクションでは継承されたACLと呼ばれます。親ディレクトリのACLにあるACEに基づいて、継承されたACLに1つ以上のACEを追加することを、このセクションではACEの継承と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the presence or absence of the mode and ACL attributes, the behavior of CREATE and OPEN SHOULD be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the presence or absence of the mode and ACL attributes, the behavior of CREATE and OPEN SHOULD be:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If just the mode is given in the call:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 呼び出しでモードのみが指定されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, inheritance SHOULD take place, but the mode MUST be applied to the inherited ACL as described in Section 6.4.1.1, thereby modifying the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この場合、継承が行われる必要があります（SHOULD）が、6.4.1.1項で説明されているように、継承されたACLにモードを適用して、ACLを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If just the ACL is given in the call:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 呼び出しでACLのみが指定されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, inheritance SHOULD NOT take place, and the ACL as defined in the CREATE or OPEN will be set without modification, and the mode modified as in Section 6.4.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この場合、継承は行われるべきではなく（SHOULD NOT）、CREATEまたはOPENで定義されたACLは変更せずに設定され、モードは6.4.1.2のように変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If both mode and ACL are given in the call:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 呼び出しでモードとACLの両方が指定されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, inheritance SHOULD NOT take place, and both attributes will be set as described in Section 6.4.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この場合、継承は行われるべきではなく（SHOULD NOT）、両方の属性がセクション6.4.1.3で説明されているように設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If neither mode nor ACL is given in the call:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 呼び出しでモードもACLも指定されていない場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In the case where an object is being created without any initial attributes at all, e.g., an OPEN operation with an opentype4 of OPEN4_CREATE and a createmode4 of EXCLUSIVE4, inheritance SHOULD NOT take place. Instead, the server SHOULD set permissions to deny all access to the newly created object. It is expected that the appropriate client will set the desired attributes in a subsequent SETATTR operation, and the server SHOULD allow that operation to succeed, regardless of what permissions the object is created with. For example, an empty ACL denies all permissions, but the server should allow the owner&#39;s SETATTR to succeed even though WRITE_ACL is implicitly denied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
オブジェクトが初期属性なしで作成されている場合（たとえば、opentype4がOPEN4_CREATEで、createmode4がEXCLUSIVE4であるOPEN操作）、継承は行われません（SHOULD NOT）。代わりに、サーバーは、新しく作成されたオブジェクトへのすべてのアクセスを拒否するアクセス許可を設定する必要があります（SHOULD）。適切なクライアントが後続のSETATTR操作で必要な属性を設定することが期待されており、サーバーは、オブジェクトの作成に使用する権限に関係なく、その操作を成功させる必要があります（SHOULD）。たとえば、空のACLはすべての権限を拒否しますが、WRITE_ACLが暗黙的に拒否されている場合でも、サーバーは所有者のSETATTRを成功させる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In other cases, inheritance SHOULD take place, and no modifications to the ACL will happen. The mode attribute, if supported, MUST be as computed via the method described in Section 6.3.2, with the MODE4_SUID, MODE4_SGID, and MODE4_SVTX bits clear. If no inheritable ACEs exist on the parent directory, the rules for creating acl attributes are implementation defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
他の場合では、継承が行われる必要があり（SHOULD）、ACLへの変更は行われません。サポートされている場合、モード属性は、セクション6.3.2で説明されているメソッドを介して計算され、MODE4_SUID、MODE4_SGID、およびMODE4_SVTXビットがクリアされている必要があります。継承可能なACEが親ディレクトリに存在しない場合、ACL属性の作成規則は実装で定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3.1. The Inherited ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3.1. 継承されたACL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object being created is not a directory, the inherited ACL SHOULD NOT inherit ACEs from the parent directory ACL unless the ACE4_FILE_INHERIT_FLAG is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作成されるオブジェクトがディレクトリでない場合、継承されたACLは、ACE4_FILE_INHERIT_FLAGが設定されていない限り、親ディレクトリACLからACEを継承してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object being created is a directory, the inherited ACL should inherit all inheritable ACEs from the parent directory, i.e., those that have the ACE4_FILE_INHERIT_ACE or ACE4_DIRECTORY_INHERIT_ACE flag set. If the inheritable ACE has ACE4_FILE_INHERIT_ACE set, but ACE4_DIRECTORY_INHERIT_ACE is clear, the inherited ACE on the newly created directory MUST have the ACE4_INHERIT_ONLY_ACE flag set to prevent the directory from being affected by ACEs meant for non-directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作成されるオブジェクトがディレクトリの場合、継承されたACLは、親ディレクトリから継承可能なすべてのACE、つまりACE4_FILE_INHERIT_ACEまたはACE4_DIRECTORY_INHERIT_ACEフラグが設定されているACEを継承する必要があります。継承可能なACEにACE4_FILE_INHERIT_ACEが設定されているが、ACE4_DIRECTORY_INHERIT_ACEがクリアされている場合、新しく作成されたディレクトリの継承されたACEにACE4_INHERIT_ONLY_ACEフラグを設定して、ディレクトリがディレクトリ以外のACEの影響を受けないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a new directory is created, the server MAY split any inherited ACE that is both inheritable and effective (in other words, that has neither ACE4_INHERIT_ONLY_ACE nor ACE4_NO_PROPAGATE_INHERIT_ACE set) into two ACEs -- one with no inheritance flags, and one with ACE4_INHERIT_ONLY_ACE set. This makes it simpler to modify the effective permissions on the directory without modifying the ACE that is to be inherited to the new directory&#39;s children.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいディレクトリが作成されると、サーバーは、継承可能かつ有効である（つまり、ACE4_INHERIT_ONLY_ACEもACE4_NO_PROPAGATE_INHERIT_ACEも設定されていない）継承されたACEを2つのACEに分割できます（1つは継承フラグなし、もう1つはACE4_INHERIT_ONLY_ACEセット付き）。これにより、新しいディレクトリの子に継承されるACEを変更せずに、ディレクトリの有効なアクセス許可を簡単に変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. NFS Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. NFSサーバー名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Server Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. サーバーのエクスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a UNIX server, the namespace describes all the files reachable by pathnames under the root directory or &#34;/&#34;. On a Windows server, the namespace constitutes all the files on disks named by mapped disk letters. NFS server administrators rarely make the entire server&#39;s file system namespace available to NFS clients. More often, portions of the namespace are made available via an &#34;export&#34; feature. In previous versions of the NFS protocol, the root filehandle for each export is obtained through the MOUNT protocol; the client sends a string that identifies an object in the exported namespace, and the server returns the root filehandle for it. The MOUNT protocol supports an EXPORTS procedure that will enumerate the server&#39;s exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXサーバーでは、ネームスペースは、ルートディレクトリまたは「/」の下のパス名によって到達可能なすべてのファイルを記述します。 Windowsサーバーでは、名前空間は、マップされたディスク文字で名前が付けられたディスク上のすべてのファイルを構成します。 NFSサーバー管理者がサーバーのファイルシステム全体の名前空間をNFSクライアントが利用できるようにすることはほとんどありません。多くの場合、名前空間の一部は、「エクスポート」機能を介して利用可能になります。以前のバージョンのNFSプロトコルでは、各エクスポートのルートファイルハンドルはMOUNTプロトコルを介して取得されました。クライアントはエクスポートされた名前空間のオブジェクトを識別する文字列を送信し、サーバーはそのオブジェクトのルートファイルハンドルを返します。 MOUNTプロトコルは、サーバーのエクスポートを列挙するEXPORTSプロシージャをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Browsing Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. エクスポートの閲覧
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The NFSv4 protocol provides a root filehandle that clients can use to obtain filehandles for these exports via a multi-component LOOKUP. A common user experience is to use a graphical user interface (perhaps a file &#34;Open&#34; dialog window) to find a file via progressive browsing through a directory tree. The client must be able to move from one export to another export via single-component, progressive LOOKUP operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4プロトコルは、クライアントがマルチコンポーネントLOOKUPを介してこれらのエクスポートのファイルハンドルを取得するために使用できるルートファイルハンドルを提供します。一般的なユーザーエクスペリエンスは、グラフィカルユーザーインターフェイス（おそらく「ファイルを開く」ダイアログウィンドウ）を使用して、ディレクトリツリーを順次参照してファイルを見つけることです。クライアントは、単一コンポーネントのプログレッシブLOOKUP操作を介して、あるエクスポートから別のエクスポートに移動できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This style of browsing is not well supported by the NFSv2 and NFSv3 protocols. The client expects all LOOKUP operations to remain within a single-server file system. For example, the device attribute will not change. This prevents a client from taking namespace paths that span exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このブラウジングのスタイルは、NFSv2およびNFSv3プロトコルでは十分にサポートされていません。クライアントは、すべてのLOOKUP操作が単一サーバーのファイルシステム内に留まることを期待しています。たとえば、デバイス属性は変更されません。これにより、クライアントは、複数のエクスポートにまたがる名前空間パスを取得できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An automounter on the client can obtain a snapshot of the server&#39;s namespace using the EXPORTS procedure of the MOUNT protocol. If it understands the server&#39;s pathname syntax, it can create an image of the server&#39;s namespace on the client. The parts of the namespace that are not exported by the server are filled in with a &#34;pseudo-file system&#34; that allows the user to browse from one mounted file system to another. There is a drawback to this representation of the server&#39;s namespace on the client: it is static. If the server administrator adds a new export, the client will be unaware of it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのオートマウンタは、MOUNTプロトコルのEXPORTSプロシージャを使用して、サーバーのネームスペースのスナップショットを取得できます。サーバーのパス名構文を理解していれば、クライアント上にサーバーの名前空間のイメージを作成できます。サーバーによってエクスポートされない名前空間の部分は、ユーザーが1つのマウントされたファイルシステムから別のファイルシステムにブラウズできるようにする「疑似ファイルシステム」で埋められます。クライアント上のサーバーの名前空間のこの表現には欠点があります。それは静的なものです。サーバー管理者が新しいエクスポートを追加しても、クライアントはそれを認識しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Server Pseudo-File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. サーバー疑似ファイルシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 servers avoid this namespace inconsistency by presenting all the exports within the framework of a single-server namespace. An NFSv4 client uses LOOKUP and READDIR operations to browse seamlessly from one export to another. Portions of the server namespace that are not exported are bridged via a &#34;pseudo-file system&#34; that provides a view of exported directories only. A pseudo-file system has a unique fsid and behaves like a normal, read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4サーバーは、単一サーバー名前空間のフレームワーク内ですべてのエクスポートを提示することにより、この名前空間の不整合を回避します。 NFSv4クライアントは、LOOKUPおよびREADDIR操作を使用して、1つのエクスポートから別のエクスポートへシームレスにブラウズします。エクスポートされないサーバー名前空間の部分は、エクスポートされたディレクトリのみのビューを提供する「疑似ファイルシステム」を介してブリッジされます。疑似ファイルシステムには固有のfsidがあり、通常の読み取り専用ファイルシステムのように動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the construction of the server&#39;s namespace, it is possible that multiple pseudo-file systems may exist. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの名前空間の構成に基づいて、複数の疑似ファイルシステムが存在する可能性があります。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /a         pseudo-file system
     /a/b       real file system
     /a/b/c     pseudo-file system
     /a/b/c/d   real file system
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the pseudo-file systems are considered separate entities and therefore will have a unique fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疑似ファイルシステムはそれぞれ別個のエンティティと見なされるため、一意のfsidを持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Multiple Roots
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 複数の根
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DOS and Windows operating environments are sometimes described as having &#34;multiple roots&#34;. File systems are commonly represented as disk letters. MacOS represents file systems as top-level names. NFSv4 servers for these platforms can construct a pseudo-file system above these root names so that disk letters or volume names are simply directory names in the pseudo-root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DOSおよびWindowsオペレーティング環境は、「複数のルート」を持つものとして説明されることがあります。ファイルシステムは通常、ディスク文字として表されます。 MacOSは、ファイルシステムをトップレベルの名前として表します。これらのプラットフォーム用のNFSv4サーバーは、これらのルート名の上に疑似ファイルシステムを構築して、ディスク文字またはボリューム名が疑似ルート内の単なるディレクトリ名になるようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. Filehandle Volatility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. ファイルハンドルのボラティリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nature of the server&#39;s pseudo-file system is that it is a logical representation of file system(s) available from the server. Therefore, the pseudo-file system is most likely constructed dynamically when the server is first instantiated. It is expected that the pseudo-file system may not have an on-disk counterpart from which persistent filehandles could be constructed. Even though it is preferable that the server provide persistent filehandles for the pseudo-file system, the NFS client should expect that pseudo-file system filehandles are volatile. This can be confirmed by checking the associated &#34;fh_expire_type&#34; attribute for those filehandles in question. If the filehandles are volatile, the NFS client must be prepared to recover a filehandle value (e.g., with a multi-component LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの疑似ファイルシステムの性質は、サーバーから利用可能なファイルシステムの論理表現であるということです。したがって、サーバーが最初にインスタンス化されるときに、疑似ファイルシステムが動的に構築される可能性が最も高くなります。疑似ファイルシステムには、永続的なファイルハンドルを構築できるディスク上の対応物がない可能性があります。サーバーが疑似ファイルシステムに永続的なファイルハンドルを提供することが望ましい場合でも、NFSクライアントは疑似ファイルシステムファイルハンドルが揮発性であることを期待する必要があります。これは、問題のファイルハンドルの関連する「fh_expire_type」属性を確認することで確認できます。ファイルハンドルが揮発性である場合、NFS4ERR_FHEXPIREDのエラーを受信したときに、ファイルハンドル値を回復するために（たとえば、マルチコンポーネントLOOKUPを使用して）NFSクライアントを準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. Exported Root
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. エクスポートされたルート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server&#39;s root file system is exported, one might conclude that a pseudo-file system is not needed. This would be wrong. Assume the following file systems on a server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのルートファイルシステムがエクスポートされた場合、疑似ファイルシステムは不要であると結論付けることができます。これは間違っているでしょう。サーバー上の次のファイルシステムを想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /       disk1  (exported)
     /a      disk2  (not exported)
     /a/b    disk3  (exported)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because disk2 is not exported, disk3 cannot be reached with simple LOOKUPs. The server must bridge the gap with a pseudo-file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
disk2はエクスポートされないため、単純なLOOKUPでdisk3に到達することはできません。サーバーは、疑似ファイルシステムとのギャップを埋める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. Mount Point Crossing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. マウントポイントクロッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server file system environment may be constructed in such a way that one file system contains a directory that is &#39;covered&#39; or mounted upon by a second file system. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーファイルシステム環境は、1つのファイルシステムが、2番目のファイルシステムによって「カバー」またはマウントされるディレクトリを含むように構築できます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /a/b            (file system 1)
     /a/b/c/d        (file system 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pseudo-file system for this server may be constructed to look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このサーバーの疑似ファイルシステムは、次のように構築できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /               (placeholder/not exported)
     /a/b            (file system 1)
     /a/b/c/d        (file system 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the server&#39;s responsibility to present the pseudo-file system that is complete to the client. If the client sends a LOOKUP request for the path &#34;/a/b/c/d&#34;, the server&#39;s response is the filehandle of the file system &#34;/a/b/c/d&#34;. In previous versions of the NFS protocol, the server would respond with the filehandle of directory &#34;/a/b/c/d&#34; within the file system &#34;/a/b&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the server&#39;s responsibility to present the pseudo-file system that is complete to the client. If the client sends a LOOKUP request for the path &#34;/a/b/c/d&#34;, the server&#39;s response is the filehandle of the file system &#34;/a/b/c/d&#34;. In previous versions of the NFS protocol, the server would respond with the filehandle of directory &#34;/a/b/c/d&#34; within the file system &#34;/a/b&#34;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS client will be able to determine if it crosses a server mount point by a change in the value of the &#34;fsid&#34; attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSクライアントは、「fsid」属性の値を変更することで、サーバーのマウントポイントを通過するかどうかを判別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8. Security Policy and Namespace Presentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8. セキュリティポリシーと名前空間の表示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because NFSv4 clients possess the ability to change the security mechanisms used, after determining what is allowed, by using SECINFO the server SHOULD NOT present a different view of the namespace based on the security mechanism being used by a client. Instead, it should present a consistent view and return NFS4ERR_WRONGSEC if an attempt is made to access data with an inappropriate security mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because NFSv4 clients possess the ability to change the security mechanisms used, after determining what is allowed, by using SECINFO the server SHOULD NOT present a different view of the namespace based on the security mechanism being used by a client. Instead, it should present a consistent view and return NFS4ERR_WRONGSEC if an attempt is made to access data with an inappropriate security mechanism.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If security considerations make it necessary to hide the existence of a particular file system, as opposed to all of the data within it, the server can apply the security policy of a shared resource in the server&#39;s namespace to components of the resource&#39;s ancestors. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ上の考慮事項により、特定のファイルシステムの存在を、その中のすべてのデータではなく非表示にする必要がある場合、サーバーはサーバーの名前空間にある共有リソースのセキュリティポリシーをリソースの祖先のコンポーネントに適用できます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /                       (placeholder/not exported)
       /a/b                    (file system 1)
       /a/b/MySecretProject    (file system 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The /a/b/MySecretProject directory is a real file system and is the shared resource. Suppose the security policy for /a/b/ MySecretProject is Kerberos with integrity and it is desired to limit knowledge of the existence of this file system. In this case, the server should apply the same security policy to /a/b. This allows for knowledge of the existence of a file system to be secured when desirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The /a/b/MySecretProject directory is a real file system and is the shared resource. Suppose the security policy for /a/b/ MySecretProject is Kerberos with integrity and it is desired to limit knowledge of the existence of this file system. In this case, the server should apply the same security policy to /a/b. This allows for knowledge of the existence of a file system to be secured when desirable.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For the case of the use of multiple, disjoint security mechanisms in the server&#39;s resources, applying that sort of policy would result in the higher-level file system not being accessible using any security flavor. Therefore, that sort of configuration is not compatible with hiding the existence (as opposed to the contents) from clients using multiple disjoint sets of security flavors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーのリソースで複数の分離したセキュリティメカニズムを使用する場合、そのようなポリシーを適用すると、セキュリティフレーバーを使用して上位レベルのファイルシステムにアクセスできなくなります。したがって、この種の構成は、セキュリティフレーバーのばらばらのセットを複数使用してクライアントから（コンテンツではなく）存在を隠すことと互換性がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In other circumstances, a desirable policy is for the security of a particular object in the server&#39;s namespace to include the union of all security mechanisms of all direct descendants. A common and convenient practice, unless strong security requirements dictate otherwise, is to make the entire pseudo-file system accessible by all of the valid security mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の状況では、望ましいポリシーは、サーバーの名前空間内の特定のオブジェクトのセキュリティに、すべての直接の子孫のすべてのセキュリティメカニズムの結合を含めることです。強力なセキュリティ要件で特に指示されていない限り、一般的で便利な方法は、すべての有効なセキュリティメカニズムで疑似ファイルシステム全体にアクセスできるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where there is concern about the security of data on the network, clients should use strong security mechanisms to access the pseudo-file system in order to prevent man-in-the-middle attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワーク上のデータのセキュリティについて懸念がある場合、クライアントは中間者攻撃を防ぐために、強力なセキュリティメカニズムを使用して疑似ファイルシステムにアクセスする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Multi-Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. マルチサーバー名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 supports attributes that allow a namespace to extend beyond the boundaries of a single server. It is RECOMMENDED that clients and servers support construction of such multi-server namespaces. Use of such multi-server namespaces is optional, however, and for many purposes, single-server namespaces are perfectly acceptable. Use of multi-server namespaces can provide many advantages, however, by separating a file system&#39;s logical position in a namespace from the (possibly changing) logistical and administrative considerations that result in particular file systems being located on particular servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4は、名前空間が単一サーバーの境界を越えて拡張できるようにする属性をサポートしています。クライアントとサーバーがこのようなマルチサーバー名前空間の構築をサポートすることをお勧めします。このようなマルチサーバー名前空間の使用はオプションですが、多くの目的で、シングルサーバー名前空間は完全に許容されます。ただし、マルチサーバー名前空間を使用すると、名前空間におけるファイルシステムの論理的な位置を、特定のファイルシステムが特定のサーバーに配置されることになる（変更される可能性がある）ロジスティックおよび管理上の考慮事項から切り離すことにより、多くの利点が得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Location Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. ロケーション属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 contains RECOMMENDED attributes that allow file systems on one server to be associated with one or more instances of that file system on other servers. These attributes specify such file system instances by specifying a server address target (as either a DNS name representing one or more IP addresses, or a literal IP address), together with the path of that file system within the associated single-server namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4には、あるサーバー上のファイルシステムを他のサーバー上のそのファイルシステムの1つ以上のインスタンスに関連付けることができるRECOMMENDED属性が含まれています。これらの属性は、サーバーアドレスターゲット（1つ以上のIPアドレスを表すDNS名、またはリテラルIPアドレスのいずれか）と、関連付けられた単一サーバー名前空間内のファイルシステムのパスを指定することにより、そのようなファイルシステムインスタンスを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations RECOMMENDED attribute allows specification of the file system locations where the data corresponding to a given file system may be found.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations RECOMMENDED属性を使用すると、特定のファイルシステムに対応するデータを見つけることができるファイルシステムの場所を指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. File System Presence or Absence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. ファイルシステムの有無
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A given location in an NFSv4 namespace (typically but not necessarily a multi-server namespace) can have a number of file system instance locations associated with it via the fs_locations attribute. There may also be an actual current file system at that location, accessible via normal namespace operations (e.g., LOOKUP). In this case, the file system is said to be &#34;present&#34; at that position in the namespace, and clients will typically use it, reserving use of additional locations specified via the location-related attributes to situations in which the principal location is no longer available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4名前空間の特定の場所（通常、必ずしもマルチサーバー名前空間ではない）には、fs_locations属性を使用して、ファイルシステムインスタンスの場所を関連付けることができます。その場所に実際の現在のファイルシステムが存在する場合もあり、通常のネームスペース操作（LOOKUPなど）を介してアクセスできます。この場合、ファイルシステムはネームスペースのその位置に「存在する」と言われ、クライアントは通常それを使用し、主要な場所がもはや存在しない状況に対して、場所関連の属性によって指定された追加の場所の使用を予約します。利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When there is no actual file system at the namespace location in question, the file system is said to be &#34;absent&#34;. An absent file system contains no files or directories other than the root. Any reference to it, except to access a small set of attributes useful in determining alternative locations, will result in an error, NFS4ERR_MOVED. Note that if the server ever returns the error NFS4ERR_MOVED, it MUST support the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題のネームスペースの場所に実際のファイルシステムがない場合、ファイルシステムは「存在しない」と言われます。存在しないファイルシステムには、ルート以外のファイルやディレクトリは含まれません。代替の場所を決定するのに役立つ少数の属性セットにアクセスする場合を除いて、それを参照すると、エラーNFS4ERR_MOVEDが発生します。サーバーがエラーNFS4ERR_MOVEDを返す場合は、fs_locations属性をサポートする必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the error name suggests that we have a case of a file system that once was present, and has only become absent later, this is only one possibility. A position in the namespace may be permanently absent with the set of file system(s) designated by the location attributes being the only realization. The name NFS4ERR_MOVED reflects an earlier, more limited conception of its function, but this error will be returned whenever the referenced file system is absent, whether it has moved or simply never existed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラー名は、かつて存在し、後でなくなったファイルシステムのケースがあることを示していますが、これは1つの可能性にすぎません。名前空間内の位置は永続的に存在しない場合があり、ロケーション属性によって指定されたファイルシステムのセットが唯一の実現です。 NFS4ERR_MOVEDという名前は、その機能の以前のより限定された概念を反映していますが、このエラーは、参照されたファイルシステムが存在しないか、移動されたか、単に存在しなかったかに関係なく返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except in the case of GETATTR-type operations (to be discussed later), when the current filehandle at the start of an operation is within an absent file system, that operation is not performed and the error NFS4ERR_MOVED is returned, to indicate that the file system is absent on the current server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTRタイプの操作（後で説明します）の場合を除いて、操作の開始時の現在のファイルハンドルが存在しないファイルシステム内にある場合、その操作は実行されず、エラーNFS4ERR_MOVEDが返され、ファイル現在のサーバーにはシステムがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because a GETFH cannot succeed if the current filehandle is within an absent file system, filehandles within an absent file system cannot be transferred to the client. When a client does have filehandles within an absent file system, it is the result of obtaining them when the file system was present, and having the file system become absent subsequently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because a GETFH cannot succeed if the current filehandle is within an absent file system, filehandles within an absent file system cannot be transferred to the client. When a client does have filehandles within an absent file system, it is the result of obtaining them when the file system was present, and having the file system become absent subsequently.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that because the check for the current filehandle being within an absent file system happens at the start of every operation, operations that change the current filehandle so that it is within an absent file system will not result in an error. This allows such combinations as PUTFH-GETATTR and LOOKUP-GETATTR to be used to get attribute information, particularly location attribute information, as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが存在しないファイルシステム内にあるかどうかの確認はすべての操作の開始時に行われるため、存在しないファイルシステム内に存在するように現在のファイルハンドルを変更する操作はエラーになりません。これにより、PUTFH-GETATTRやLOOKUP-GETATTRなどの組み合わせを使用して、属性情報、特に位置属性情報を取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Getting Attributes for an Absent File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. 存在しないファイルシステムの属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system is absent, most attributes are not available, but it is necessary to allow the client access to the small set of attributes that are available, and most particularly that which gives information about the correct current locations for this file system, fs_locations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムが存在しない場合、ほとんどの属性は利用できませんが、利用可能な属性の小さなセットへのクライアントアクセスを許可する必要があります。特に、このファイルシステムの正しい現在の場所に関する情報を提供するfs_locations 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1. GETATTR within an Absent File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1. 存在しないファイルシステム内でのGETATTR
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, an exception is made for GETATTR in that attributes may be obtained for a filehandle within an absent file system. This exception only applies if the attribute mask contains at least the fs_locations attribute bit, which indicates that the client is interested in a result regarding an absent file system. If it is not requested, GETATTR will result in an NFS4ERR_MOVED error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, an exception is made for GETATTR in that attributes may be obtained for a filehandle within an absent file system. This exception only applies if the attribute mask contains at least the fs_locations attribute bit, which indicates that the client is interested in a result regarding an absent file system. If it is not requested, GETATTR will result in an NFS4ERR_MOVED error.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a GETATTR is done on an absent file system, the set of supported attributes is very limited. Many attributes, including those that are normally REQUIRED, will not be available on an absent file system. In addition to the fs_locations attribute, the following attributes SHOULD be available on absent file systems. In the case of RECOMMENDED attributes, they should be available at least to the same degree that they are available on present file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a GETATTR is done on an absent file system, the set of supported attributes is very limited. Many attributes, including those that are normally REQUIRED, will not be available on an absent file system. In addition to the fs_locations attribute, the following attributes SHOULD be available on absent file systems. In the case of RECOMMENDED attributes, they should be available at least to the same degree that they are available on present file systems.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid: This attribute should be provided so that the client can determine file system boundaries, including, in particular, the boundary between present and absent file systems. This value must be different from any other fsid on the current server and need have no particular relationship to fsids on any particular destination to which the client might be directed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid：この属性は、クライアントがファイルシステムの境界（特に、存在するファイルシステムと存在しないファイルシステムの間の境界を含む）を判別できるように提供する必要があります。この値は、現在のサーバーの他のfsidとは異なる必要があり、クライアントが向けられる可能性のある特定の宛先のfsidと特定の関係を持つ必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mounted_on_fileid: For objects at the top of an absent file system, this attribute needs to be available. Since the fileid is within the present parent file system, there should be no need to reference the absent file system to provide this information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mounted_on_fileid：存在しないファイルシステムの最上部にあるオブジェクトの場合、この属性が使用可能である必要があります。 fileidは現在の親ファイルシステム内にあるため、存在しないファイルシステムを参照してこの情報を提供する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other attributes SHOULD NOT be made available for absent file systems, even when it is possible to provide them. The server should not assume that more information is always better and should avoid gratuitously providing additional information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の属性は、それらを提供することが可能な場合でも、存在しないファイルシステムで利用可能にするべきではありません（SHOULD NOT）。サーバーは、より多くの情報が常に優れていると想定してはならず、不必要に追加の情報を提供することは避けてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a GETATTR operation includes a bitmask for the attribute fs_locations, but where the bitmask includes attributes that are not supported, GETATTR will not return an error but will return the mask of the actual attributes supported with the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTR操作に属性fs_locationsのビットマスクが含まれているが、ビットマスクにサポートされていない属性が含まれている場合、GETATTRはエラーを返しませんが、結果でサポートされている実際の属性のマスクを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Handling of VERIFY/NVERIFY is similar to GETATTR in that if the attribute mask does not include fs_locations the error NFS4ERR_MOVED will result. It differs in that any appearance in the attribute mask of an attribute not supported for an absent file system (and note that this will include some normally REQUIRED attributes) will also cause an NFS4ERR_MOVED result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY / NVERIFYの処理は、属性マスクにfs_locationsが含まれていない場合にエラーNFS4ERR_MOVEDが発生するという点でGETATTRに似ています。これは、存在しないファイルシステムでサポートされていない属性の属性マスクの外観（これには、通常は必須の属性が含まれることに注意してください）も、NFS4ERR_MOVED結果を引き起こす点で異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2. READDIR and Absent File Systems
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2. READDIRと不在のファイルシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A READDIR performed when the current filehandle is within an absent file system will result in an NFS4ERR_MOVED error, since, unlike the case of GETATTR, no such exception is made for READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが存在しないファイルシステム内にあるときにREADDIRを実行すると、NFS4ERR_MOVEDエラーが発生します。これは、GETATTRの場合とは異なり、READDIRにはそのような例外は発生しないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attributes for an absent file system may be fetched via a READDIR for a directory in a present file system, when that directory contains the root directories of one or more absent file systems. In this case, the handling is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在しないファイルシステムの属性は、そのディレクトリに1つ以上の存在しないファイルシステムのルートディレクトリが含まれている場合、現在のファイルシステム内のディレクトリのREADDIRを介してフェッチできます。この場合の処理​​は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the attribute set requested includes fs_locations, then the fetching of attributes proceeds normally, and no NFS4ERR_MOVED indication is returned even when the rdattr_error attribute is requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された属性セットにfs_locationsが含まれている場合、属性のフェッチは正常に行われ、rdattr_error属性が要求された場合でもNFS4ERR_MOVED通知は返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the attribute set requested does not include fs_locations, then if the rdattr_error attribute is requested, each directory entry for the root of an absent file system will report NFS4ERR_MOVED as the value of the rdattr_error attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された属性セットにfs_locationsが含まれていない場合、rdattr_error属性が要求されると、存在しないファイルシステムのルートの各ディレクトリエントリは、rdattr_error属性の値としてNFS4ERR_MOVEDを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the attribute set requested does not include either of the attributes fs_locations or rdattr_error, then the occurrence of the root of an absent file system within the directory will result in the READDIR failing with an NFS4ERR_MOVED error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された属性セットに属性fs_locationsまたはrdattr_errorのいずれも含まれていない場合、ディレクトリ内に存在しないファイルシステムのルートが発生すると、READDIRはNFS4ERR_MOVEDエラーで失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The unavailability of an attribute because of a file system&#39;s absence, even one that is ordinarily REQUIRED, does not result in any error indication. The set of attributes returned for the root directory of the absent file system in that case is simply restricted to those actually available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムが存在しないために属性を使用できない場合でも、通常は必須であるにもかかわらず、エラーは表示されません。その場合、存在しないファイルシステムのルートディレクトリに返される属性のセットは、実際に使用可能な属性に制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. Uses of Location Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. 位置情報の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The location-bearing attribute of fs_locations provides, together with the possibility of absent file systems, a number of important facilities in providing reliable, manageable, and scalable data access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locationsの場所を指定する属性は、ファイルシステムが存在しない可能性とともに、信頼性が高く、管理しやすく、スケーラブルなデータアクセスを提供する上で、いくつかの重要な機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system is present, these attributes can provide alternative locations, to be used to access the same data, in the event of server failures, communications problems, or other difficulties that make continued access to the current file system impossible or otherwise impractical. Under some circumstances, multiple alternative locations may be used simultaneously to provide higher-performance access to the file system in question. Provision of such alternative locations is referred to as &#34;replication&#34;, although there are cases in which replicated sets of data are not in fact present and the replicas are instead different paths to the same data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムが存在する場合、これらの属性は、サーバー障害、通信の問題、または現在のファイルシステムへの継続的なアクセスを不可能にするか、そうでなければ非現実的である他の問題が発生した場合に、同じデータにアクセスするために使用される代替の場所を提供できます。状況によっては、複数の代替ロケーションを同時に使用して、問題のファイルシステムへのより高いパフォーマンスのアクセスを提供できます。そのような代替の場所の提供は「複製」と呼ばれますが、複製されたデータのセットが実際には存在せず、代わりに複製が同じデータへの異なるパスである場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system is present and subsequently becomes absent, clients can be given the opportunity to have continued access to their data, at an alternative location. Transfer of the file system contents to the new location is referred to as &#34;migration&#34;. See Section 8.4.2 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムが存在し、その後不在になった場合、クライアントは別の場所でデータへのアクセスを継続する機会を与えられます。ファイルシステムの内容を新しい場所に転送することを「移行」と呼びます。詳細については、セクション8.4.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternative locations may be physical replicas of the file system data or alternative communication paths to the same server or, in the case of various forms of server clustering, another server providing access to the same physical file system. The client&#39;s responsibilities in dealing with this transition depend on the specific nature of the new access path as well as how and whether data was in fact migrated. These issues will be discussed in detail below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代替の場所は、ファイルシステムデータの物理的なレプリカ、または同じサーバーへの代替の通信パス、さまざまな形式のサーバークラスタリングの場合は、同じ物理ファイルシステムへのアクセスを提供する別のサーバーです。この移行への対処におけるクライアントの責任は、新しいアクセスパスの特定の性質、およびデータが実際に移行された方法と方法によって異なります。これらの問題については、以下で詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where a file system was not previously present, specification of file system location provides a means by which file systems located on one server can be associated with a namespace defined by another server, thus allowing a general multi-server namespace facility. A designation of such a location, in place of an absent file system, is called a &#34;referral&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前にファイルシステムが存在しなかった場合、ファイルシステムの場所を指定すると、あるサーバーにあるファイルシステムを別のサーバーで定義された名前空間に関連付けることができるため、一般的なマルチサーバー名前空間機能を使用できます。存在しないファイルシステムの代わりにそのような場所を指定することを、「参照」と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because client support for location-related attributes is OPTIONAL, a server may (but is not required to) take action to hide migration and referral events from such clients, by acting as a proxy, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロケーション関連の属性に対するクライアントのサポートはオプションであるため、サーバーは、たとえばプロキシとして機能することにより、そのようなクライアントからの移行および参照イベントを非表示にするアクションを実行できます（必須ではありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1. File System Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1. ファイルシステムのレプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations attribute provides alternative locations, to be used to access data in place of, or in addition to, the current file system instance. On first access to a file system, the client should obtain the value of the set of alternative locations by interrogating the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations属性は、現在のファイルシステムインスタンスの代わりに、またはそれに加えて、データにアクセスするために使用される代替の場所を提供します。ファイルシステムへの最初のアクセス時に、クライアントはfs_locations属性を調べることにより、代替ロケーションのセットの値を取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that server failures, communications problems, or other difficulties make continued access to the current file system impossible or otherwise impractical, the client can use the alternative locations as a way to get continued access to its data. Multiple locations may be used simultaneously, to provide higher performance through the exploitation of multiple paths between client and target file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの障害、通信の問題、またはその他の問題により、現在のファイルシステムへの継続的なアクセスが不可能または実用的でない場合、クライアントは代替の場所を使用して、データへの継続的なアクセスを取得できます。複数の場所を同時に使用して、クライアントとターゲットファイルシステム間の複数のパスを活用することにより、より高いパフォーマンスを提供できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple server addresses, whether they are derived from a single entry with a DNS name representing a set of IP addresses or from multiple entries each with its own server address, may correspond to the same actual server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のサーバーアドレスは、IPアドレスのセットを表すDNS名を持つ単一のエントリから取得される場合も、独自のサーバーアドレスを持つ複数のエントリから取得される場合も、同じ実際のサーバーに対応する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2. File System Migration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2. ファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system is present and becomes absent, clients can be given the opportunity to have continued access to their data, at an alternative location, as specified by the fs_locations attribute. Typically, a client will be accessing the file system in question, get an NFS4ERR_MOVED error, and then use the fs_locations attribute to determine the new location of the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムが存在し、存在しなくなった場合、fs_locations属性で指定された別の場所にあるデータにクライアントが引き続きアクセスできるようにすることができます。通常、クライアントは問題のファイルシステムにアクセスし、NFS4ERR_MOVEDエラーを取得してから、fs_locations属性を使用してデータの新しい場所を特定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such migration can be helpful in providing load balancing or general resource reallocation. The protocol does not specify how the file system will be moved between servers. It is anticipated that a number of different server-to-server transfer mechanisms might be used, with the choice left to the server implementer. The NFSv4 protocol specifies the method used to communicate the migration event between client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような移行は、ロードバランシングまたは一般的なリソースの再割り当てに役立ちます。プロトコルは、サーバー間でのファイルシステムの移動方法を指定しません。多数の異なるサーバー間転送メカニズムが使用される可能性があり、その選択はサーバー実装者に任されると予想されます。 NFSv4プロトコルは、クライアントとサーバー間の移行イベントの通信に使用される方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an alternative location is designated as the target for migration, it must designate the same data. Where file systems are writable, a change made on the original file system must be visible on all migration targets. Where a file system is not writable but represents a read-only copy (possibly periodically updated) of a writable file system, similar requirements apply to the propagation of updates. Any change visible in the original file system must already be effected on all migration targets, to avoid any possibility that a client, in effecting a transition to the migration target, will see any reversion in file system state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代替の場所が移行のターゲットとして指定されている場合は、同じデータを指定する必要があります。ファイルシステムが書き込み可能である場合、元のファイルシステムで行われた変更は、すべての移行ターゲットで可視である必要があります。ファイルシステムが書き込み可能ではないが、書き込み可能なファイルシステムの読み取り専用のコピー（定期的に更新される可能性がある）を表す場合、同様の要件が更新の伝達に適用されます。元のファイルシステムに表示される変更はすべて、すべての移行ターゲットに影響を与えている必要があります。これにより、クライアントが移行ターゲットに移行するときに、ファイルシステムの状態が元に戻される可能性がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.3. Referrals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.3. 紹介
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Referrals provide a way of placing a file system in a location within the namespace essentially without respect to its physical location on a given server. This allows a single server or a set of servers to present a multi-server namespace that encompasses file systems located on multiple servers. Some likely uses of this include establishment of site-wide or organization-wide namespaces, or even knitting such together into a truly global namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参照は、ファイルシステムをネームスペース内の場所に配置する方法を提供します。基本的に、特定のサーバー上の物理的な場所は考慮されません。これにより、単一のサーバーまたはサーバーのセットが、複数のサーバーにあるファイルシステムを含むマルチサーバーの名前空間を提供できます。この使用例としては、サイト全体または組織全体の名前空間の確立、またはそれらを組み合わせて真にグローバルな名前空間を作成することなどがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Referrals occur when a client determines, upon first referencing a position in the current namespace, that it is part of a new file system and that the file system is absent. When this occurs, typically by receiving the error NFS4ERR_MOVED, the actual location or locations of the file system can be determined by fetching the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
紹介は、クライアントが現在のネームスペース内の位置を最初に参照したときに、それが新しいファイルシステムの一部であり、ファイルシステムが存在しないと判断したときに発生します。これが発生すると、通常はエラーNFS4ERR_MOVEDを受け取り、fs_locations属性をフェッチすることで、ファイルシステムの実際の場所を特定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The location-related attribute may designate a single file system location or multiple file system locations, to be selected based on the needs of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロケーション関連属性は、クライアントのニーズに基づいて選択される単一のファイルシステムロケーションまたは複数のファイルシステムロケーションを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of multi-server namespaces is enabled by NFSv4 but is not required. The use of multi-server namespaces and their scope will depend on the applications used and system administration preferences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチサーバー名前空間の使用はNFSv4によって有効になりますが、必須ではありません。マルチサーバー名前空間とそのスコープの使用は、使用するアプリケーションとシステム管理設定に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multi-server namespaces can be established by a single server providing a large set of referrals to all of the included file systems. Alternatively, a single multi-server namespace may be administratively segmented with separate referral file systems (on separate servers) for each separately administered portion of the namespace. The top-level referral file system or any segment may use replicated referral file systems for higher availability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチサーバー名前空間は、含まれているすべてのファイルシステムへの参照の大規模なセットを提供する単一のサーバーによって確立できます。あるいは、単一のマルチサーバー名前空間は、名前空間の個別に管理される部分ごとに、個別の参照ファイルシステム（個別のサーバー上）で管理上セグメント化される場合があります。トップレベルの紹介ファイルシステムまたは任意のセグメントは、可用性を高めるために複製された紹介ファイルシステムを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generally, multi-server namespaces are for the most part uniform, in that the same data made available to one client at a given location in the namespace is made available to all clients at that location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、マルチサーバー名前空間は、名前空間の特定の場所にある1つのクライアントが利用できるようにされた同じデータが、その場所にあるすべてのクライアントが利用できるという点で、ほとんどが統一されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. Location Entries and Server Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. ロケーションエントリとサーバーID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, a single location entry may have a server address target in the form of a DNS name that may represent multiple IP addresses, while multiple location entries may have their own server address targets that reference the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、単一のロケーションエントリには、複数のIPアドレスを表すDNS名の形式のサーバーアドレスターゲットがあり、複数のロケーションエントリには、同じサーバーを参照する独自のサーバーアドレスターゲットがある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple addresses for the same server exist, the client may assume that for each file system in the namespace of a given server network address, there exist file systems at corresponding namespace locations for each of the other server network addresses. It may do this even in the absence of explicit listing in fs_locations. Such corresponding file system locations can be used as alternative locations, just as those explicitly specified via the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じサーバーに複数のアドレスが存在する場合、クライアントは、特定のサーバーネットワークアドレスのネームスペース内の各ファイルシステムについて、他の各サーバーネットワークアドレスの対応するネームスペースの場所にファイルシステムが存在すると想定します。 fs_locationsに明示的なリストがない場合でも、これを行うことがあります。このような対応するファイルシステムの場所は、fs_locations属性で明示的に指定されている場所と同じように、代替場所として使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a single location entry designates multiple server IP addresses, the client should choose a single one to use. When two server addresses are designated by a single location entry and they correspond to different servers, this normally indicates some sort of misconfiguration, and so the client should avoid using such location entries when alternatives are available. When they are not, clients should pick one of the IP addresses and use it, without using others that are not directed to the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一の場所エントリが複数のサーバーIPアドレスを指定している場合、クライアントは使用する単一のアドレスを選択する必要があります。 2つのサーバーアドレスが単一の場所エントリによって指定され、それらが異なるサーバーに対応する場合、これは通常、ある種の構成ミスを示しているため、代替が利用可能な場合、クライアントはそのような場所エントリの使用を避ける必要があります。そうでない場合、クライアントは、同じサーバーに向けられていない他のIPアドレスを使用せずに、IPアドレスの1つを選択して使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. Additional Client-Side Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. 追加のクライアント側の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When clients make use of servers that implement referrals, replication, and migration, care should be taken that a user who mounts a given file system that includes a referral or a relocated file system continues to see a coherent picture of that user-side file system despite the fact that it contains a number of server-side file systems that may be on different servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが参照、複製、および移行を実装するサーバーを利用する場合、参照または再配置されたファイルシステムを含む特定のファイルシステムをマウントするユーザーが、そのユーザー側のファイルシステムの一貫した状況を引き続き表示するように注意する必要があります。異なるサーバー上にある可能性のあるサーバー側のファイルシステムが多数含まれているという事実にもかかわらず。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One important issue is upward navigation from the root of a server-side file system to its parent (specified as &#34;..&#34; in UNIX), in the case in which it transitions to that file system as a result of referral, migration, or a transition as a result of replication. When the client is at such a point, and it needs to ascend to the parent, it must go back to the parent as seen within the multi-server namespace rather than sending a LOOKUPP operation to the server, which would result in the parent within that server&#39;s single-server namespace. In order to do this, the client needs to remember the filehandles that represent such file system roots and use these instead of issuing a LOOKUPP operation to the current server. This will allow the client to present to applications a consistent namespace, where upward navigation and downward navigation are consistent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One important issue is upward navigation from the root of a server-side file system to its parent (specified as &#34;..&#34; in UNIX), in the case in which it transitions to that file system as a result of referral, migration, or a transition as a result of replication. When the client is at such a point, and it needs to ascend to the parent, it must go back to the parent as seen within the multi-server namespace rather than sending a LOOKUPP operation to the server, which would result in the parent within that server&#39;s single-server namespace. In order to do this, the client needs to remember the filehandles that represent such file system roots and use these instead of issuing a LOOKUPP operation to the current server. This will allow the client to present to applications a consistent namespace, where upward navigation and downward navigation are consistent.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another issue concerns refresh of referral locations. When referrals are used extensively, they may change as server configurations change. It is expected that clients will cache information related to traversing referrals so that future client-side requests are resolved locally without server communication. This is usually rooted in client-side name lookup caching. Clients should periodically purge this data for referral points in order to detect changes in location information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つの問題は、参照場所の更新に関するものです。紹介が広範囲に使用される場合、サーバー構成が変更されると紹介が変更される可能性があります。クライアントは紹介のトラバースに関連する情報をキャッシュし、将来のクライアント側の要求がサーバー通信なしでローカルに解決されることが期待されます。これは通常、クライアント側の名前検索キャッシュに根ざしています。クライアントは、位置情報の変更を検出するために、参照ポイントのこのデータを定期的に削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A potential problem exists if a client were to allow an open-owner to have state on multiple file systems on a server, in that it is unclear how the sequence numbers associated with open-owners are to be dealt with, in the event of transparent state migration. A client can avoid such a situation if it ensures that any use of an open-owner is confined to a single file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがオープンオーナーにサーバー上の複数のファイルシステムの状態を許可すると、透過的な場合にオープンオーナーに関連付けられたシーケンス番号がどのように処理されるかが不明確になる可能性があります。状態移行。オープンオーナーの使用が単一のファイルシステムに限定されることが保証されている場合、クライアントはこのような状況を回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY decline to migrate state associated with open-owners that span multiple file systems. In cases in which the server chooses not to migrate such state, the server MUST return NFS4ERR_BAD_STATEID when the client uses those stateids on the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY decline to migrate state associated with open-owners that span multiple file systems. In cases in which the server chooses not to migrate such state, the server MUST return NFS4ERR_BAD_STATEID when the client uses those stateids on the new server.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST return NFS4ERR_STALE_STATEID when the client uses those stateids on the old server, regardless of whether migration has occurred or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST return NFS4ERR_STALE_STATEID when the client uses those stateids on the old server, regardless of whether migration has occurred or not.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. Effecting File System Referrals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. ファイルシステムの参照に影響を与える
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Referrals are effected when an absent file system is encountered and one or more alternative locations are made available by the fs_locations attribute. The client will typically get an NFS4ERR_MOVED error, fetch the appropriate location information, and proceed to access the file system on a different server, even though it retains its logical position within the original namespace. Referrals differ from migration events in that they happen only when the client has not previously referenced the file system in question (so there is nothing to transition). Referrals can only come into effect when an absent file system is encountered at its root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照は、存在しないファイルシステムが検出され、fs_locations属性によって1つ以上の代替の場所が利用可能になると影響を受けます。クライアントは通常、NFS4ERR_MOVEDエラーを受け取り、適切な場所情報をフェッチし、元の名前空間内の論理的な位置を保持していても、別のサーバー上のファイルシステムにアクセスします。紹介は、クライアントが以前に問題のファイルシステムを参照していない場合にのみ発生するという点で、移行イベントとは異なります（移行するものはありません）。参照は、ルートにファイルシステムがない場合にのみ有効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The examples given in the sections below are somewhat artificial in that an actual client will not typically do a multi-component lookup but will have cached information regarding the upper levels of the name hierarchy. However, these example are chosen to make the required behavior clear and easy to put within the scope of a small number of requests, without getting unduly into details of how specific clients might choose to cache things.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The examples given in the sections below are somewhat artificial in that an actual client will not typically do a multi-component lookup but will have cached information regarding the upper levels of the name hierarchy. However, these example are chosen to make the required behavior clear and easy to put within the scope of a small number of requests, without getting unduly into details of how specific clients might choose to cache things.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.1. Referral Example (LOOKUP)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.1. Referral Example (LOOKUP)
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let us suppose that the following COMPOUND is sent in an environment in which /this/is/the/path is absent from the target server. This may be for a number of reasons. It may be the case that the file system has moved, or it may be the case that the target server is functioning mainly, or solely, to refer clients to the servers on which various file systems are located.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のCOMPOUNDが、ターゲットサーバーに/ this / is / the / pathがない環境で送信されたと仮定します。これにはいくつかの理由が考えられます。ファイルシステムが移動した場合や、ターゲットサーバーが主に、または単独で、さまざまなファイルシステムが配置されているサーバーをクライアントに参照するように機能している場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP「これ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ルックアップ「the」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;path&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;パス&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTR(fsid, fileid, size, time_modify)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTR（fsid、fileid、size、time_modify）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under the given circumstances, the following will be the result:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の状況下では、次の結果になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH --&gt; NFS_OK. The current fh is now the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH-&gt; NFS_OK。現在のfhが疑似fsのルートになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;-&gt; NFS_OK。現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;-&gt; NFS_OK。現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;-&gt; NFS_OK。現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;path&#34; --&gt; NFS_OK. The current fh is for /this/is/the/path and is within a new, absent file system, but ... the client will never see the value of that fh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;パス&#34;-&gt; NFS_OK。現在のfhは/ this / is / the / path用であり、新しく存在しないファイルシステム内にありますが、クライアントはそのfhの値を見ることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETFH --&gt; NFS4ERR_MOVED. Fails, because the current fh is in an absent file system at the start of the operation and the specification makes no exception for GETFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETFH-&gt; NFS4ERR_MOVED。操作の開始時に現在のfhが存在しないファイルシステムにあり、仕様ではGETFHの例外が発生しないため、失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTR(fsid, fileid, size, time_modify). Not executed, because the failure of the GETFH stops the processing of the COMPOUND.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTR（fsid、fileid、size、time_modify）。 GETFHの失敗によりCOMPOUNDの処理が停止するため、実行されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Given the failure of the GETFH, the client has the job of determining the root of the absent file system and where to find that file system, i.e., the server and path relative to that server&#39;s root fh. Note here that in this example, the client did not obtain filehandles and attribute information (e.g., fsid) for the intermediate directories, so that it would not be sure where the absent file system starts. It could be the case, for example, that /this/is/the is the root of the moved file system and that the reason that the lookup of &#34;path&#34; succeeded is that the file system was not absent on that operation but was moved between the last LOOKUP and the GETFH (since COMPOUND is not atomic). Even if we had the fsids for all of the intermediate directories, we could have no way of knowing that /this/is/the/path was the root of a new file system, since we don&#39;t yet have its fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
GETFHが失敗した場合、クライアントは、存在しないファイルシステムのルートと、そのファイルシステムを見つける場所、つまり、サーバーとそのサーバーのルートからの相対パスを決定する役割を果たします。この例では、クライアントが中間ディレクトリのファイルハンドルと属性情報（fsidなど）を取得しなかったため、存在しないファイルシステムがどこから始まるのかがわからないことに注意してください。たとえば、/ this / is / theが移動されたファイルシステムのルートであり、「パス」の検索が成功した理由は、ファイルシステムがその操作に存在せず、移動されたためです。最後のLOOKUPとGETFHの間（COMPOUNDはアトミックではないため）。すべての中間ディレクトリにfsidがあったとしても、まだfsidがないため、/ this / is / the / pathが新しいファイルシステムのルートであることを知る方法がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to get the necessary information, let us re-send the chain of LOOKUPs with GETFHs and GETATTRs to at least get the fsids so we can be sure where the appropriate file system boundaries are. The client could choose to get fs_locations at the same time, but in most cases the client will have a good guess as to where the file system boundaries are (because of where NFS4ERR_MOVED was, and was not, received), making the fetching of fs_locations unnecessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to get the necessary information, let us re-send the chain of LOOKUPs with GETFHs and GETATTRs to at least get the fsids so we can be sure where the appropriate file system boundaries are. The client could choose to get fs_locations at the same time, but in most cases the client will have a good guess as to where the file system boundaries are (because of where NFS4ERR_MOVED was, and was not, received), making the fetching of fs_locations unnecessary.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP01:  PUTROOTFH --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは疑似fsのルートにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP02:  GETATTR(fsid) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Just for completeness. Normally, clients will know the fsid of the pseudo-fs as soon as they establish communication with a server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 完全を期すために。通常、クライアントは、サーバーとの通信を確立するとすぐに、疑似fsのfsidを認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP03:  LOOKUP &#34;this&#34; --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP04:  GETATTR(fsid) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Get the current fsid to see where the file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfsidを取得して、ファイルシステムの境界がどこにあるかを確認します。 fsidは、この例の疑似fsのfsidになるため、境界はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP05:  GETFH --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP06:  LOOKUP &#34;is&#34; --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP07:  GETATTR(fsid) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Get the current fsid to see where the file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfsidを取得して、ファイルシステムの境界がどこにあるかを確認します。 fsidは、この例の疑似fsのfsidになるため、境界はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP08:  GETFH --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP09:  LOOKUP &#34;the&#34; --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP10:  GETATTR(fsid) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Get the current fsid to see where the file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfsidを取得して、ファイルシステムの境界がどこにあるかを確認します。 fsidは、この例の疑似fsのfsidになるため、境界はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP11:  GETFH --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP12:  LOOKUP &#34;path&#34; --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The current fh is for /this/is/the/path and is within a new, absent file system, but ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this / is / the / path用であり、新しく存在しないファイルシステム内にありますが...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The client will never see the value of that fh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The client will never see the value of that fh.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP13:  GETATTR(fsid, fs_locations) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- We are getting the fsid to know where the file system boundaries are. In this operation, the fsid will be different than that of the parent directory (which in turn was retrieved in OP10). Note that the fsid we are given will not necessarily be preserved at the new location. That fsid might be different, and in fact the fsid we have for this file system might be a valid fsid of a different file system on that new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- We are getting the fsid to know where the file system boundaries are. In this operation, the fsid will be different than that of the parent directory (which in turn was retrieved in OP10). Note that the fsid we are given will not necessarily be preserved at the new location. That fsid might be different, and in fact the fsid we have for this file system might be a valid fsid of a different file system on that new server.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- In this particular case, we are pretty sure anyway that what has moved is /this/is/the/path rather than /this/is/the since we have the fsid of the latter and it is that of the pseudo-fs, which presumably cannot move. However, in other examples, we might not have this kind of information to rely on (e.g., /this/is/the might be a non-pseudo-file system separate from /this/is/the/path), so we need to have other reliable source information on the boundary of the file system that is moved. If, for example, the file system /this/is had moved, we would have a case of migration rather than referral, and once the boundaries of the migrated file system were clear we could fetch fs_locations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- この特定のケースでは、移動したものが/ this / is / theではなく/ this / is / the / pathであると確信しています。後者のfsidと疑似fsのfsidがあるためです。おそらく移動できません。ただし、他の例では、この種の情報を利用できない場合があります（たとえば、/ this / is / theは/ this / is / the / pathとは別の疑似ファイルシステムである可能性があります）。移動するファイルシステムの境界に他の信頼できるソース情報を保持する。たとえば、ファイルシステム/ this / isが移動された場合、参照ではなく移行のケースがあり、移行されたファイルシステムの境界が明確になれば、fs_locationsをフェッチできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- We are fetching fs_locations because the fact that we got an NFS4ERR_MOVED at this point means that this is most likely a referral and we need the destination. Even if it is the case that /this/is/the is a file system that has migrated, we will still need the location information for that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- この時点でNFS4ERR_MOVEDを取得したという事実は、これがおそらく参照であり、宛先が必要であることを意味するため、fs_locationsをフェッチしています。 / this / is / theが移行したファイルシステムである場合でも、そのファイルシステムの場所情報が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP14:  GETFH --&gt; NFS4ERR_MOVED
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Fails because current fh is in an absent file system at the start of the operation, and the specification makes no exception for GETFH. Note that this means the server will never send the client a filehandle from within an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 操作の開始時に現在のfhが存在しないファイルシステムにあり、仕様ではGETFHの例外が発生しないため、失敗します。これは、存在しないファイルシステム内からサーバーがクライアントにファイルハンドルを送信しないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above, the client knows where the root of the absent file system is (/this/is/the/path) by noting where the change of fsid occurred (between &#34;the&#34; and &#34;path&#34;). The fs_locations attribute also gives the client the actual location of the absent file system so that the referral can proceed. The server gives the client the bare minimum of information about the absent file system so that there will be very little scope for problems of conflict between information sent by the referring server and information of the file system&#39;s home. No filehandles and very few attributes are present on the referring server, and the client can treat those it receives as transient information with the function of enabling the referral.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の場合、クライアントは、fsidの変更が発生した場所（「the」と「path」の間）に注目することにより、存在しないファイルシステムのルートがどこにあるか（/ this / is / the / path）を認識します。 fs_locations属性は、クライアントに不在のファイルシステムの実際の場所も提供するため、参照を続行できます。サーバーはクライアントに、存在しないファイルシステムに関する最低限の情報を提供するため、参照サーバーによって送信された情報とファイルシステムのホームの情報との間の競合の問題が生じる可能性はほとんどありません。参照サーバーにはファイルハンドルはなく、属性はほとんどありません。クライアントは、参照を有効にする機能を使用して、受け取った属性を一時的な情報として扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.2. Referral Example (READDIR)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.2. 紹介例（READDIR）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another context in which a client may encounter referrals is when it does a READDIR on a directory in which some of the subdirectories are the roots of absent file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが紹介に遭遇する可能性のあるもう1つの状況は、サブディレクトリの一部が存在しないファイルシステムのルートであるディレクトリでREADDIRを実行する場合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose such a directory is read as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなディレクトリが次のように読み取られると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP「これ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ルックアップ「the」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o READDIR(fsid, size, time_modify, mounted_on_fileid) In this case, because rdattr_error is not requested, fs_locations is not requested, and some of the attributes cannot be provided, the result will be an NFS4ERR_MOVED error on the READDIR, with the detailed results as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o READDIR（fsid、size、time_modify、mounted_on_fileid）この場合、rdattr_errorは要求されず、fs_locationsは要求されず、一部の属性が提供されないため、結果はREADDIRでNFS4ERR_MOVEDエラーとなり、詳細な結果が表示されます。次のように：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH-&gt; NFS_OK。現在のfhは疑似fsのルートにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;-&gt; NFS_OK。現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;-&gt; NFS_OK。現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;-&gt; NFS_OK。現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR(fsid, size, time_modify, mounted_on_fileid) --&gt; NFS4ERR_MOVED. Note that the same error would have been returned if /this/is/the had migrated, but it is returned because the directory contains the root of an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（fsid、サイズ、time_modify、mounted_on_fileid）-&gt; NFS4ERR_MOVED。 / this / is / theが移行された場合も同じエラーが返されますが、ディレクトリには存在しないファイルシステムのルートが含まれているため、このエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So now suppose that we re-send with rdattr_error:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それでは、rdattr_errorで再送信するとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP「これ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ルックアップ「the」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR(rdattr_error, fsid, size, time_modify, mounted_on_fileid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（rdattr_error、fsid、size、time_modify、mounted_on_fileid）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH-&gt; NFS_OK。現在のfhは疑似fsのルートにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;-&gt; NFS_OK。現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;-&gt; NFS_OK。現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;-&gt; NFS_OK。現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR(rdattr_error, fsid, size, time_modify, mounted_on_fileid) --&gt; NFS_OK. The attributes for the directory entry with the component named &#34;path&#34; will only contain rdattr_error with the value NFS4ERR_MOVED, together with an fsid value and a value for mounted_on_fileid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（rdattr_error、fsid、size、time_modify、mounted_on_fileid）-&gt; NFS_OK。 「path」という名前のコンポーネントを持つディレクトリエントリの属性には、fsid値とMounted_on_fileidの値とともに、値NFS4ERR_MOVEDのrdattr_errorのみが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So suppose we do another READDIR to get fs_locations (although we could have used a GETATTR directly, as in Section 8.7.1):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、fs_locationsを取得するために別のREADDIRを実行するとします（セクション8.7.1のように、GETATTRを直接使用することもできます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP「これ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ルックアップ「the」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR(rdattr_error, fs_locations, mounted_on_fileid, fsid, size, time_modify)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（rdattr_error、fs_locations、mounted_on_fileid、fsid、size、time_modify）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH-&gt; NFS_OK。現在のfhは疑似fsのルートにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;-&gt; NFS_OK。現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;-&gt; NFS_OK。現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;-&gt; NFS_OK。現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR(rdattr_error, fs_locations, mounted_on_fileid, fsid, size, time_modify) --&gt; NFS_OK. The attributes will be as shown below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（rdattr_error、fs_locations、mounted_on_fileid、fsid、size、time_modify）-&gt; NFS_OK。属性は以下のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes for the directory entry with the component named &#34;path&#34; will only contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「パス」という名前のコンポーネントを持つディレクトリエントリの属性には、次の情報のみが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rdattr_error (value: NFS_OK)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rdattr_error（値：NFS_OK）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fs_locations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fs_locations
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mounted_on_fileid (value: unique fileid within referring file system)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Mounted_on_fileid（値：参照ファイルシステム内の一意のファイルID）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o fsid (value: unique value within referring server) The attributes for entry &#34;path&#34; will not contain size or time_modify, because these attributes are not available within an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o fsid（値：参照サーバー内の一意の値）エントリ &#34;path&#34;の属性には、サイズやtime_modifyは含まれません。これらの属性は、存在しないファイルシステム内では使用できないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. The Attribute fs_locations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. The Attribute fs_locations
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations attribute is defined by both fs_location4 (Section 2.2.6) and fs_locations4 (Section 2.2.7). It is used to represent the location of a file system by providing a server name and the path to the root of the file system within that server&#39;s namespace. When a set of servers have corresponding file systems at the same path within their namespaces, an array of server names may be provided. An entry in the server array is a UTF-8 string and represents one of a traditional DNS host name, IPv4 address, IPv6 address, or a zero-length string. A zero-length string SHOULD be used to indicate the current address being used for the RPC. It is not a requirement that all servers that share the same rootpath be listed in one fs_location4 instance. The array of server names is provided for convenience. Servers that share the same rootpath may also be listed in separate fs_location4 entries in the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations属性は、fs_location4（セクション2.2.6）とfs_locations4（セクション2.2.7）の両方で定義されます。これは、サーバー名とそのサーバーの名前空間内のファイルシステムのルートへのパスを提供することにより、ファイルシステムの場所を表すために使用されます。一連のサーバーの名前空間内の同じパスに対応するファイルシステムがある場合、サーバー名の配列を指定できます。サーバー配列のエントリはUTF-8文字列であり、従来のDNSホスト名、IPv4アドレス、IPv6アドレス、または長さゼロの文字列の1つを表します。 RPCに使用されている現在のアドレスを示すには、長さがゼロの文字列を使用する必要があります（SHOULD）。同じrootpathを共有するすべてのサーバーを1つのfs_location4インスタンスにリストする必要はありません。サーバー名の配列は、便宜上提供されています。同じルートパスを共有するサーバーは、fs_locations属性の個別のfs_location4エントリにリストされる場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations4 data type and fs_locations attribute contain an array of such locations. Since the namespace of each server may be constructed differently, the fs_root field is provided. The path represented by the fs_root represents the location of the file system in the current server&#39;s namespace, i.e., that of the server from which the fs_locations attribute was obtained. The fs_root path is meant to aid the client by clearly referencing the root of the file system whose locations are being reported, no matter what object within the current file system the current filehandle designates. The fs_root is simply the pathname the client used to reach the object on the current server (i.e., the object to which the fs_locations attribute applies).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations4データ型とfs_locations属性には、そのような場所の配列が含まれています。各サーバーの名前空間は異なる方法で構築される可能性があるため、fs_rootフィールドが提供されます。 fs_rootで表されるパスは、現在のサーバーの名前空間内のファイルシステムの場所、つまり、fs_locations属性の取得元のサーバーの場所を表します。 fs_rootパスは、現在のファイルハンドルが指定する現在のファイルシステム内のオブジェクトに関係なく、場所が報告されているファイルシステムのルートを明確に参照することにより、クライアントを支援することを目的としています。 fs_rootは、クライアントが現在のサーバー上のオブジェクト（つまり、fs_locations属性が適用されるオブジェクト）に到達するために使用したパス名です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the fs_locations attribute is interrogated and there are no alternative file system locations, the server SHOULD return a zero-length array of fs_location4 structures, together with a valid fs_root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations属性が照会され、代替ファイルシステムの場所がない場合、サーバーは、有効なfs_rootとともに、fs_location4構造体の長さがゼロの配列を返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As an example, suppose there is a replicated file system located at two servers (servA and servB). At servA, the file system is located at path /a/b/c. At servB, the file system is located at path /x/y/z. If the client were to obtain the fs_locations value for the directory at /a/b/c/d, it might not necessarily know that the file system&#39;s root is located in servA&#39;s namespace at /a/b/c. When the client switches to servB, it will need to determine that the directory it first referenced at servA is now represented by the path /x/y/z/d on servB. To facilitate this, the fs_locations attribute provided by servA would have an fs_root value of /a/b/c and two entries in fs_locations. One entry in fs_locations will be for itself (servA), and the other will be for servB with a path of /x/y/z. With this information, the client is able to substitute /x/y/z for /a/b/c at the beginning of its access path and construct /x/y/z/d to use for the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
例として、2つのサーバー（servAとservB）に複製されたファイルシステムがあるとします。 servAでは、ファイルシステムはパス/ a / b / cにあります。 servBでは、ファイルシステムはパス/ x / y / zにあります。クライアントが/ a / b / c / dにあるディレクトリのfs_locations値を取得する場合、ファイルシステムのルートが/ a / b / cにあるservAのネームスペースにあることを必ずしも認識していない場合があります。クライアントがservBに切り替わるとき、servAで最初に参照されたディレクトリがservBのパス/ x / y / z / dで表されていることを確認する必要があります。これを容易にするために、servAによって提供されるfs_locations属性は、fs_root値が/ a / b / cであり、fs_locationsに2つのエントリがあります。 fs_locationsの1つのエントリはそれ自体（servA）用で、もう1つのエントリは/ x / y / zのパスを持つservB用です。この情報を使用して、クライアントはアクセスパスの先頭で/ a / b / cを/ x / y / zに置き換え、新しいサーバーに使用する/ x / y / z / dを構築できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there is no requirement that the number of components in each rootpath be the same; there is no relation between the number of components in the rootpath or fs_root, and none of the components in each rootpath and fs_root have to be the same. In the above example, we could have had a third element in the locations array, with server equal to &#34;servC&#34; and rootpath equal to &#34;/I/II&#34;, and a fourth element in the locations array, with server equal to &#34;servD&#34; and rootpath equal to &#34;/aleph/beth/gimel/daleth/he&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各rootpathのコンポーネント数が同じである必要はないことに注意してください。ルートパスまたはfs_rootのコンポーネント数には関係がなく、各rootpathとfs_rootのコンポーネントが同じである必要はありません。上記の例では、サーバーが &#34;servC&#34;でルートパスが &#34;/ I / II&#34;の3番目の要素と、サーバーが &#34;servD&#34;の4番目の要素を、locations配列で持つことができます。 &#34;およびrootpathは&#34; / aleph / beth / gimel / daleth / he &#34;に等しい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The relationship between an fs_root and a rootpath is that the client replaces the pathname indicated in the fs_root for the current server for the substitute indicated in the rootpath for the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The relationship between an fs_root and a rootpath is that the client replaces the pathname indicated in the fs_root for the current server for the substitute indicated in the rootpath for the new server.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For an example of a referred or migrated file system, suppose there is a file system located at serv1. At serv1, the file system is located at /az/buky/vedi/glagoli. The client finds that the object at glagoli has migrated (or is a referral). The client gets the fs_locations attribute, which contains an fs_root of /az/buky/vedi/ glagoli, and one element in the locations array, with server equal to serv2, and rootpath equal to /izhitsa/fita. The client replaces /az/buky/vedi/glagoli with /izhitsa/fita and uses the latter pathname on serv2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照または移行されたファイルシステムの例として、serv1にファイルシステムがあるとします。 serv1では、ファイルシステムは/ az / buky / vedi / glagoliにあります。クライアントは、glagoliのオブジェクトが移行した（または紹介である）ことを発見しました。クライアントはfs_locations属性を取得します。これには、/ az / buky / vedi / glagoliのfs_rootと、locations配列の1つの要素が含まれます。サーバーはserv2、ルートパスは/ izhitsa / fitaです。クライアントは/ az / buky / vedi / glagoliを/ izhitsa / fitaに置き換え、serv2で後者のパス名を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the server MUST return an fs_root that is equal to the path the client used to reach the object to which the fs_locations attribute applies. Otherwise, the client cannot determine the new path to use on the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、サーバーはfs_locations属性が適用されるオブジェクトに到達するためにクライアントが使用したパスに等しいfs_rootを返さなければなりません（MUST）。そうしないと、クライアントは新しいサーバーで使用する新しいパスを決定できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. File Locking and Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. ファイルのロックと共有の予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Integrating locking into the NFS protocol necessarily causes it to be stateful. With the inclusion of share reservations, the protocol becomes substantially more dependent on state than the traditional combination of NFS and NLM (Network Lock Manager) [xnfs]. There are three components to making this state manageable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックをNFSプロトコルに統合すると、必然的にそれがステートフルになります。共有予約を含めると、プロトコルは、NFSとNLM（ネットワークロックマネージャー）[xnfs]の従来の組み合わせよりも、状態に大きく依存するようになります。この状態を管理可能にするための3つのコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o clear division between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーの明確な区別
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ability to reliably detect inconsistency in state between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバー間の状態の不整合を確実に検出する機能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o simple and robust recovery mechanisms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o シンプルで堅牢な回復メカニズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this model, the server owns the state information. The client requests changes in locks, and the server responds with the changes made. Non-client-initiated changes in locking state are infrequent. The client receives prompt notification of such changes and can adjust its view of the locking state to reflect the server&#39;s changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このモデルでは、サーバーが状態情報を所有します。クライアントはロックの変更を要求し、サーバーは行われた変更で応答します。クライアントが開始しないロック状態の変更はまれです。クライアントは、そのような変更のプロンプト通知を受け取り、サーバーの変更を反映するようにロック状態のビューを調整できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Individual pieces of state created by the server and passed to the client at its request are represented by 128-bit stateids. These stateids may represent a particular open file, a set of byte-range locks held by a particular owner, or a recallable delegation of privileges to access a file in particular ways or at a particular location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって作成され、要求時にクライアントに渡される個々の状態は、128ビットの状態IDで表されます。これらの状態IDは、特定の開いているファイル、特定の所有者が保持している一連のバイト範囲ロック、または特定の方法または特定の場所でファイルにアクセスするための呼び出し可能な特権の委任を表す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all cases, there is a transition from the most general information that represents a client as a whole to the eventual lightweight stateid used for most client and server locking interactions. The details of this transition will vary with the type of object, but it always starts with a client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての場合において、クライアント全体を表す最も一般的な情報から、ほとんどのクライアントとサーバーのロック相互作用に使用される最終的な軽量のステートIDへの移行があります。この遷移の詳細はオブジェクトのタイプによって異なりますが、常にクライアントIDから始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support Win32 share reservations, it is necessary to atomically OPEN or CREATE files and apply the appropriate locks in the same operation. Having a separate share/unshare operation would not allow correct implementation of the Win32 OpenFile API. In order to correctly implement share semantics, the previous NFS protocol mechanisms used when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be replaced. The NFSv4 protocol has an OPEN operation that subsumes the NFSv3 methodology of LOOKUP, CREATE, and ACCESS. However, because many operations require a filehandle, the traditional LOOKUP is preserved to map a filename to a filehandle without establishing state on the server. The policy of granting access or modifying files is managed by the server based on the client&#39;s state. These mechanisms can implement policy ranging from advisory only locking to full mandatory locking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Win32共有予約をサポートするには、ファイルをアトミックにOPENまたはCREATEし、同じ操作で適切なロックを適用する必要があります。個別の共有/共有解除操作があると、Win32 OpenFile APIを正しく実装できません。共有セマンティクスを正しく実装するには、ファイルを開いたり作成したりするときに使用されていた以前のNFSプロトコルメカニズム（LOOKUP、CREATE、ACCESS）を置き換える必要があります。 NFSv4プロトコルには、LOOKUP、CREATE、およびACCESSのNFSv3方法論を包含するOPEN操作があります。ただし、多くの操作にはファイルハンドルが必要なため、サーバーで状態を確立せずにファイル名をファイルハンドルにマップするために、従来のLOOKUPが保持されます。アクセスの許可またはファイルの変更のポリシーは、クライアントの状態に基づいてサーバーによって管理されます。これらのメカニズムは、アドバイザリーのみのロックから完全な必須ロックまでのポリシーを実装できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Opens and Byte-Range Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. オープンおよびバイト範囲ロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that manipulating a byte-range lock is rare when compared to READ and WRITE operations. It is also assumed that server restarts and network partitions are relatively rare. Therefore, it is important that the READ and WRITE operations have a lightweight mechanism to indicate if they possess a held lock. A byte-range lock request contains the heavyweight information required to establish a lock and uniquely define the owner of the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READおよびWRITE操作と比較した場合、バイト範囲ロックの操作はまれであると想定されています。また、サーバーの再起動やネットワークのパーティション化は比較的まれであると想定されています。したがって、READおよびWRITE操作には、ロックが保持されているかどうかを示す軽量のメカニズムがあることが重要です。バイト範囲のロック要求には、ロックを確立し、ロックの所有者を一意に定義するために必要な重い情報が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe the transition from the heavyweight information to the eventual stateid used for most client and server locking and lease interactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、重い情報から、ほとんどのクライアントおよびサーバーのロックとリースの相互作用に使用される最終的なステートIDへの移行について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1. Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1. クライアントID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each LOCK request, the client must identify itself to the server. This is done in such a way as to allow for correct lock identification and crash recovery. A sequence of a SETCLIENTID operation followed by a SETCLIENTID_CONFIRM operation is required to establish the identification onto the server. Establishment of identification by a new incarnation of the client also has the effect of immediately breaking any leased state that a previous incarnation of the client might have had on the server, as opposed to forcing the new client incarnation to wait for the leases to expire. Breaking the lease state amounts to the server removing all lock, share reservation, and, where the server is not supporting the CLAIM_DELEGATE_PREV claim type, all delegation state associated with the same client with the same identity. For a discussion of delegation state recovery, see Section 10.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK要求ごとに、クライアントはサーバーに対して自身を識別する必要があります。これは、正しいロックの識別とクラッシュの回復を可能にするような方法で行われます。サーバー上でIDを確立するには、SETCLIENTID操作とそれに続くSETCLIENTID_CONFIRM操作のシーケンスが必要です。クライアントの新しいインカネーションによる識別の確立は、クライアントの以前のインカネーションがサーバー上で持っていた可能性のあるリース状態を、新しいクライアントのインカネーションがリースが期限切れになるのを待つのを強いるのとは対照的に、即座に壊す効果もあります。リース状態を解除すると、サーバーはすべてのロック、共有予約を削除し、サーバーがCLAIM_DELEGATE_PREVクレームタイプをサポートしていない場合は、同じIDを持つ同じクライアントに関連付けられたすべての委任状態になります。委任状態の回復については、10.2.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Owners of opens and owners of byte-range locks are separate entities and remain separate even if the same opaque arrays are used to designate owners of each. The protocol distinguishes between open-owners (represented by open_owner4 structures) and lock-owners (represented by lock_owner4 structures).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープンの所有者とバイト範囲ロックの所有者は別々のエンティティであり、同じ不透明な配列を使用してそれぞれの所有者を指定しても、別々のままです。プロトコルは、open-owners（open_owner4構造体で表される）とlock-owners（lock_owner4構造体で表される）を区別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both sorts of owners consist of a clientid and an opaque owner string. For each client, the set of distinct owner values used with that client constitutes the set of owners of that type, for the given client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらの種類の所有者も、clientidと不透明な所有者文字列で構成されます。クライアントごとに、そのクライアントで使用される個別の所有者値のセットは、特定のクライアントのそのタイプの所有者のセットを構成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each open is associated with a specific open-owner, while each byte-range lock is associated with a lock-owner and an open-owner, the latter being the open-owner associated with the open file under which the LOCK operation was done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各オープンは特定のオープンオーナーに関連付けられていますが、各バイト範囲ロックはロックオーナーとオープンオーナーに関連付けられています。後者は、LOCK操作が実行されたオープンファイルに関連付けられたオープンオーナーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client identification is encapsulated in the following structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDは次の構造でカプセル化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first field, verifier, is a client incarnation verifier that is used to detect client reboots. Only if the verifier is different from that which the server has previously recorded for the client (as identified by the second field of the structure, id) does the server start the process of canceling the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のフィールドであるベリファイアは、クライアントの再起動を検出するために使用されるクライアントインカネーションベリファイアです。ベリファイアがサーバーに対して以前にクライアント用に記録したもの（構造の2番目のフィールド、idで識別される）と異なる場合のみ、サーバーはクライアントのリース状態をキャンセルするプロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second field, id, is a variable-length string that uniquely defines the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のフィールドidは、クライアントを一意に定義する可変長文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several considerations for how the client generates the id string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがID文字列を生成する方法には、いくつかの考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be unique so that multiple clients do not present the same string. The consequences of two clients presenting the same string range from one client getting an error to one client having its leased state abruptly and unexpectedly canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 複数のクライアントが同じ文字列を提示しないように、文字列は一意である必要があります。 2つのクライアントが同じ文字列を提示することによる影響は、1つのクライアントがエラーを取得することから、1つのクライアントがリース状態を突然予期せずにキャンセルすることまでさまざまです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be selected so the subsequent incarnations (e.g., reboots) of the same client cause the client to present the same string. The implementer is cautioned against an approach that requires the string to be recorded in a local file because this precludes the use of the implementation in an environment where there is no local disk and all file access is from an NFSv4 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じクライアントの後続のインカネーション（再起動など）がクライアントに同じ文字列を表示させるように、文字列を選択する必要があります。ローカルディスクがなく、すべてのファイルアクセスがNFSv4サーバーからである環境での実装の使用が妨げられるため、実装者は文字列をローカルファイルに記録する必要があるアプローチに対して警告されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be different for each server network address that the client accesses, rather than common to all server network addresses. The reason is that it may not be possible for the client to tell if the same server is listening on multiple network addresses. If the client issues SETCLIENTID with the same id string to each network address of such a server, the server will think it is the same client, and each successive SETCLIENTID will cause the server to begin the process of removing the client&#39;s previous leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 文字列は、すべてのサーバーネットワークアドレスに共通するのではなく、クライアントがアクセスするサーバーネットワークアドレスごとに異なる必要があります。その理由は、同じサーバーが複数のネットワークアドレスでリッスンしているかどうかをクライアントが判断できない可能性があるためです。クライアントが同じID文字列のSETCLIENTIDをそのようなサーバーの各ネットワークアドレスに発行すると、サーバーはそれを同じクライアントであると見なし、後続の各SETCLIENTIDによってサーバーはクライアントの以前のリース状態を削除するプロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o The algorithm for generating the string should not assume that the client&#39;s network address won&#39;t change. This includes changes between client incarnations and even changes while the client is still running in its current incarnation. This means that if the client includes just the client&#39;s and server&#39;s network address in the id string, there is a real risk, after the client gives up the network address, that another client, using a similar algorithm for generating the id string, will generate a conflicting id string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o文字列を生成するアルゴリズムは、クライアントのネットワークアドレスが変更されないことを前提としてはなりません。これには、クライアントインカネーション間の変更や、クライアントが現在のインカネーションでまだ実行されている間の変更も含まれます。これは、クライアントがid文字列にクライアントとサーバーのネットワークアドレスのみを含む場合、クライアントがネットワークアドレスを放棄した後に、ID文字列を生成するための同様のアルゴリズムを使用して別のクライアントが生成するという実際のリスクがあることを意味します競合するID文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above considerations, an example of a well-generated id string is one that includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の考慮事項を踏まえると、適切に生成されたid文字列の例は、次のものを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server&#39;s network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーのネットワークアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのネットワークアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a user-level NFSv4 client, it should contain additional information to distinguish the client from other user-level clients running on the same host, such as a universally unique identifier (UUID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーレベルのNFSv4クライアントの場合、ユニバーサル一意識別子（UUID）など、同じホストで実行されている他のユーザーレベルのクライアントからクライアントを区別するための追加情報が含まれている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Additional information that tends to be unique, such as one or more of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以下の1つ以上など、一意になる傾向がある追加情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The client machine&#39;s serial number (for privacy reasons, it is best to perform some one-way function on the serial number).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントマシンのシリアル番号（プライバシー上の理由から、シリアル番号に対して一方向の機能を実行することをお勧めします）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* A MAC address (for privacy reasons, it is best to perform some one-way function on the MAC address).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* MACアドレス（プライバシー上の理由から、MACアドレスに対して一方向の機能を実行することをお勧めします）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The timestamp of when the NFSv4 software was first installed on the client (though this is subject to the previously mentioned caution about using information that is stored in a file, because the file might only be accessible over NFSv4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* NFSv4ソフトウェアがクライアントに最初にインストールされたときのタイムスタンプ（ただし、ファイルにはNFSv4経由でしかアクセスできないため、ファイルに格納されている情報の使用に関する前述の注意が必要です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* A true random number. However, since this number ought to be the same between client incarnations, this shares the same problem as that of using the timestamp of the software installation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 真の乱数。ただし、この数はクライアントのインカネーション間で同じである必要があるため、ソフトウェアインストールのタイムスタンプを使用する場合と同じ問題を共有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a security measure, the server MUST NOT cancel a client&#39;s leased state if the principal that established the state for a given id string is not the same as the principal issuing the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ対策として、特定のid文字列の状態を確立したプリンシパルがSETCLIENTIDを発行するプリンシパルと同じでない場合、サーバーはクライアントのリース状態をキャンセルしてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that SETCLIENTID (Section 16.33) and SETCLIENTID_CONFIRM (Section 16.34) have a secondary purpose of establishing the information the server needs to make callbacks to the client for the purpose of supporting delegations. It is permitted to change this information via SETCLIENTID and SETCLIENTID_CONFIRM within the same incarnation of the client without removing the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that SETCLIENTID (Section 16.33) and SETCLIENTID_CONFIRM (Section 16.34) have a secondary purpose of establishing the information the server needs to make callbacks to the client for the purpose of supporting delegations. It is permitted to change this information via SETCLIENTID and SETCLIENTID_CONFIRM within the same incarnation of the client without removing the client&#39;s leased state.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a SETCLIENTID and SETCLIENTID_CONFIRM sequence has successfully completed, the client uses the shorthand client identifier, of type clientid4, instead of the longer and less compact nfs_client_id4 structure. This shorthand client identifier (a client ID) is assigned by the server and should be chosen so that it will not conflict with a client ID previously assigned by the server. This applies across server restarts or reboots. When a client ID is presented to a server and that client ID is not recognized, as would happen after a server reboot, the server will reject the request with the error NFS4ERR_STALE_CLIENTID. When this happens, the client must obtain a new client ID by use of the SETCLIENTID operation and then proceed to any other necessary recovery for the server reboot case (see Section 9.6.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDおよびSETCLIENTID_CONFIRMシーケンスが正常に完了すると、クライアントは、長くてコンパクトでないnfs_client_id4構造体ではなく、clientid4タイプの省略形のクライアント識別子を使用します。この短縮クライアントID（クライアントID）はサーバーによって割り当てられ、サーバーによって以前に割り当てられたクライアントIDと競合しないように選択する必要があります。これは、サーバーの再起動または再起動全体に適用されます。サーバーにクライアントIDが提示され、そのクライアントIDが認識されない場合（サーバーの再起動後に発生する可能性があります）、サーバーはエラーNFS4ERR_STALE_CLIENTIDで要求を拒否します。これが発生した場合、クライアントは、SETCLIENTID操作を使用して新しいクライアントIDを取得し、サーバーの再起動の場合に必要なその他のリカバリに進む必要があります（セクション9.6.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client must also employ the SETCLIENTID operation when it receives an NFS4ERR_STALE_STATEID error using a stateid derived from its current client ID, since this also indicates a server reboot, which has invalidated the existing client ID (see Section 9.6.2 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、現在のクライアントIDから導出された状態IDを使用してNFS4ERR_STALE_STATEIDエラーを受信したときに、既存のクライアントIDを無効にしたサーバーの再起動を示すため、SETCLIENTID操作も使用する必要があります（詳細は、セクション9.6.2を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the detailed descriptions of SETCLIENTID (Section 16.33.4) and SETCLIENTID_CONFIRM (Section 16.34.4) for a complete specification of the operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the detailed descriptions of SETCLIENTID (Section 16.33.4) and SETCLIENTID_CONFIRM (Section 16.34.4) for a complete specification of the operations.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.2. Server Release of Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.2. Server Release of Client ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server determines that the client holds no associated state for its client ID, the server may choose to release the client ID. The server may make this choice for an inactive client so that resources are not consumed by those intermittently active clients. If the client contacts the server after this release, the server must ensure that the client receives the appropriate error so that it will use the SETCLIENTID/SETCLIENTID_CONFIRM sequence to establish a new identity. It should be clear that the server must be very hesitant to release a client ID since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically, a server would not release a client ID unless there had been no activity from that client for many minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがそのクライアントIDに関連付けられた状態を保持していないとサーバーが判断した場合、サーバーはクライアントIDを解放することを選択できます。サーバーは、非アクティブなクライアントに対してこの選択を行って、断続的にアクティブなクライアントによってリソースが消費されないようにすることができます。このリリース後にクライアントがサーバーに接続する場合、サーバーは、クライアントが適切なエラーを受信して​​、SETCLIENTID / SETCLIENTID_CONFIRMシーケンスを使用して新しいIDを確立できるようにする必要があります。サーバーがクライアントIDを解放することをためらう必要があることは明らかです。このようなイベントから回復するためのクライアントでの作業は、サーバーに障害が発生して再起動した場合と同じ負担になるためです。通常、サーバーは、そのクライアントから何分間もアクティビティがない場合を除いて、クライアントIDを解放しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the id string in a SETCLIENTID request is properly constructed, and if the client takes care to use the same principal for each successive use of SETCLIENTID, then, barring an active denial-of-service attack, NFS4ERR_CLID_INUSE should never be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDリクエストのid文字列が適切に構成されていて、クライアントがSETCLIENTIDを連続して使用するたびに同じプリンシパルを使用する場合、アクティブなサービス拒否攻撃を禁止すると、NFS4ERR_CLID_INUSEが返されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, client bugs, server bugs, or perhaps a deliberate change of the principal owner of the id string (such as the case of a client that changes security flavors, and under the new flavor there is no mapping to the previous owner) will in rare cases result in NFS4ERR_CLID_INUSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、クライアントのバグ、サーバーのバグ、またはおそらくID文字列の主な所有者の意図的な変更（セキュリティフレーバーを変更するクライアントの場合、新しいフレーバーでは以前の所有者へのマッピングはありません）は、まれに、NFS4ERR_CLID_INUSEが発生する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In that event, when the server gets a SETCLIENTID for a client ID that currently has no state, or it has state but the lease has expired, rather than returning NFS4ERR_CLID_INUSE, the server MUST allow the SETCLIENTID and confirm the new client ID if followed by the appropriate SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その場合、サーバーは、現在状態がないクライアントID、または状態はあるがリースの期限が切れているクライアントIDのSETCLIENTIDを取得すると、NFS4ERR_CLID_INUSEを返すのではなく、SETCLIENTIDを許可して、次の場合は新しいクライアントIDを確認する必要があります。適切なSETCLIENTID_CONFIRM。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.3. Use of Seqids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.3. 配列の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In several contexts, 32-bit sequence values called &#34;seqids&#34; are used as part of managing locking state. Such values are used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのコンテキストでは、「seqids」と呼ばれる32ビットのシーケンス値が、ロック状態の管理の一部として使用されます。そのような値が使用されます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To provide an ordering of locking-related operations associated with a particular lock-owner or open-owner. See Section 9.1.7 for a detailed explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To provide an ordering of locking-related operations associated with a particular lock-owner or open-owner. See Section 9.1.7 for a detailed explanation.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To define an ordered set of instances of a set of locks sharing a particular set of ownership characteristics. See Section 9.1.4.2 for a detailed explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定の所有権特性のセットを共有するロックのセットのインスタンスの順序付けられたセットを定義します。詳細な説明については、9.1.4.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Successive seqid values for the same object are normally arrived at by incrementing the current value by one. This pattern continues until the seqid is incremented past NFS4_UINT32_MAX, in which case one (rather than zero) is to be the next seqid value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じオブジェクトの連続するseqid値は、通常、現在の値を1ずつ増やすことで到達します。このパターンは、seqidがNFS4_UINT32_MAXを超えてインクリメントされるまで続きます。この場合、（ゼロではなく）1が次のseqid値になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When two seqid values are to be compared to determine which of the two is later, the possibility of wraparound needs to be considered. In many cases, the values are such that simple numeric comparisons can be used. For example, if the seqid values to be compared are both less than one million, the higher value can be considered the later. On the other hand, if one of the values is at or near NFS_UINT32_MAX and the other is less than one million, then implementations can reasonably decide that the lower value has had one more wraparound and is thus, while numerically lower, actually later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのseqid値を比較して、2つのうちどちらが後であるかを判別する場合、ラップアラウンドの可能性を考慮する必要があります。多くの場合、値は単純な数値比較を使用できるようなものです。たとえば、比較するseqid値がどちらも100万未満の場合、高い方の値が後であると見なすことができます。一方、値の1つがNFS_UINT32_MAXかそれに近い値で、もう一方が100万未満の場合、実装は、低い方の値のラップアラウンドが1つ多いと合理的に判断できるため、数値的には低くなりますが、実際には後でなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Implementations can compare seqids in the presence of potential wraparound by adopting the reasonable assumption that the chain of increments from one to the other is shorter than 2**31. So, if the difference between the two seqids is less than 2**31, then the lower seqid is to be treated as earlier. If, however, the difference between the two seqids is greater than or equal to 2**31, then it can be assumed that the lower seqid has encountered one more wraparound and can be treated as later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
実装は、1から他への増分のチェーンが2 ** 31よりも短いという合理的な仮定を採用することにより、潜在的なラップアラウンドが存在する場合にseqidを比較できます。したがって、2つのseqidの差が2 ** 31未満の場合、低い方のseqidは以前と同じように処理されます。ただし、2つのseqidの差が2 ** 31以上の場合、下位のseqidがもう1つのラップアラウンドを検出し、後で処理できると見なすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4. Stateid Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4. Stateidの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server grants a lock of any type (including opens, byte-range locks, and delegations), it responds with a unique stateid that represents a set of locks (often a single lock) for the same file, of the same type, and sharing the same ownership characteristics. Thus, opens of the same file by different open-owners each have an identifying stateid. Similarly, each set of byte-range locks on a file owned by a specific lock-owner has its own identifying stateid. Delegations also have associated stateids by which they may be referenced. The stateid is used as a shorthand reference to a lock or set of locks, and given a stateid, the server can determine the associated state-owner or state-owners (in the case of an open-owner/lock-owner pair) and the associated filehandle. When stateids are used, the current filehandle must be the one associated with that stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが任意のタイプのロック（オープン、バイト範囲ロック、委任を含む）を許可すると、サーバーは、同じファイルの同じタイプのロックのセット（多くの場合、単一のロック）を表す一意の状態IDで応答します。同じ所有特性を共有します。したがって、異なるオープンオーナーによる同じファイルのオープンには、それぞれ識別状態IDがあります。同様に、特定のロック所有者が所有するファイルのバイト範囲ロックの各セットには、独自の識別状態IDがあります。委任には、参照される可能性がある関連付けられた状態IDもあります。状態IDは、ロックまたはロックのセットへの省略参照として使用され、状態IDが与えられると、サーバーは関連する状態所有者または状態所有者（オープン所有者/ロック所有者のペアの場合）および関連するファイルハンドル。状態IDを使用する場合、現在のファイルハンドルは、その状態IDに関連付けられているものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All stateids associated with a given client ID are associated with a common lease that represents the claim of those stateids and the objects they represent to be maintained by the server. See Section 9.5 for a discussion of the lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のクライアントIDに関連付けられているすべての状態IDは、それらの状態IDとサーバーが維持するためにそれらが表すオブジェクトの主張を表す共通リースに関連付けられています。リースの説明については、セクション9.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each stateid must be unique to the server. Many operations take a stateid as an argument but not a clientid, so the server must be able to infer the client from the stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各stateidはサーバーに固有である必要があります。多くの操作は、stateidを引数として受け取りますが、clientidは受け取りません。そのため、サーバーは、stateidからクライアントを推測できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.1. Stateid Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.1. Stateidタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the exception of special stateids (see Section 9.1.4.3), each stateid represents locking objects of one of a set of types defined by the NFSv4 protocol. Note that in all these cases, where we speak of a guarantee, it is understood there are situations such as a client restart, or lock revocation, that allow the guarantee to be voided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な状態IDを除いて（セクション9.1.4.3を参照）、各状態IDは、NFSv4プロトコルで定義されたタイプのセットの1つのロックオブジェクトを表します。保証について述べているこれらすべてのケースでは、クライアントの再起動やロックの取り消しなど、保証を無効にできる状況があると理解されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent opens of files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateidはファイルのオープンを表す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Each stateid in this case represents the OPEN state for a given client ID/open-owner/filehandle triple. Such stateids are subject to change (with consequent incrementing of the stateid&#39;s seqid) in response to OPENs that result in upgrade and OPEN_DOWNGRADE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この場合の各stateidは、特定のクライアントID / open-owner / filehandleトリプルのOPEN状態を表します。このような状態IDは、アップグレードとOPEN_DOWNGRADE操作を引き起こすOPENに応じて、変更（状態IDのseqidが増加する）の影響を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent sets of byte-range locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateidは、一連のバイト範囲ロックを表す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
All locks held on a particular file by a particular owner and all gotten under the aegis of a particular open file are associated with a single stateid, with the seqid being incremented whenever LOCK and LOCKU operations affect that set of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
All locks held on a particular file by a particular owner and all gotten under the aegis of a particular open file are associated with a single stateid, with the seqid being incremented whenever LOCK and LOCKU operations affect that set of locks.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent file delegations, which are recallable guarantees by the server to the client that other clients will not reference, or will not modify, a particular file until the delegation is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateidはファイルの委任を表す場合があります。これは、委任が返されるまで、特定のファイルを他のクライアントが参照したり変更したりしないことをサーバーがクライアントに保証する保証です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A stateid represents a single delegation held by a client for a particular filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
stateidは、特定のファイルハンドルに対してクライアントが保持する単一の委任を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.2. Stateid Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.2. Stateid Structure
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateids are divided into two fields: a 96-bit &#34;other&#34; field identifying the specific set of locks and a 32-bit &#34;seqid&#34; sequence value. Except in the case of special stateids (see Section 9.1.4.3), a particular value of the &#34;other&#34; field denotes a set of locks of the same type (for example, byte-range locks, opens, or delegations), for a specific file or directory, and sharing the same ownership characteristics. The seqid designates a specific instance of such a set of locks, and is incremented to indicate changes in such a set of locks, by either the addition or deletion of locks from the set, a change in the byte-range they apply to, or an upgrade or downgrade in the type of one or more locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateidは、2つのフィールドに分かれています。ロックの特定のセットを識別する96ビットの「その他」フィールドと、32ビットの「seqid」シーケンス値です。特別な状態ID（セクション9.1.4.3を参照）の場合を除き、「other」フィールドの特定の値は、同じタイプのロックのセット（たとえば、バイト範囲ロック、オープン、または委任）を示します。特定のファイルまたはディレクトリ、および同じ所有権特性を共有します。 seqidは、そのようなロックのセットの特定のインスタンスを指定し、セットからのロックの追加または削除、それらが適用されるバイト範囲の変更、またはそのようなロックのセットの変更を示すためにインクリメントされます。 1つ以上のロックのタイプでのアップグレードまたはダウングレード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When such a set of locks is first created, the server returns a stateid with a seqid value of one. On subsequent operations that modify the set of locks, the server is required to advance the seqid field by one whenever it returns a stateid for the same state-owner/file/type combination and the operation is one that might make some change in the set of locks actually designated. In this case, the server will return a stateid with an &#34;other&#34; field the same as previously used for that state-owner/file/type combination, with an incremented seqid field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなロックのセットが最初に作成されると、サーバーはseqid値が1のstateidを返します。ロックのセットを変更する後続の操作では、サーバーは、同じ状態所有者/ファイル/タイプの組み合わせのstateidを返し、操作がセットに変更を加える可能性がある操作である場合は常に、seqidフィールドを1つ進める必要があります。実際に指定されたロックの数。この場合、サーバーは、state-owner / file / typeの組み合わせに以前に使用されたものと同じ「other」フィールドを含むstateidを、seqidフィールドを増分して返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Seqids will be compared, by both the client and the server. The client uses such comparisons to determine the order of operations, while the server uses them to determine whether the NFS4ERR_OLD_STATEID error is to be returned. In all cases, the possibility of seqid wraparound needs to be taken into account, as discussed in Section 9.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスは、クライアントとサーバーの両方で比較されます。クライアントはそのような比較を使用して操作の順序を決定し、サーバーはそれらを使用してNFS4ERR_OLD_STATEIDエラーが返されるかどうかを決定します。セクション9.1.3で説明したように、すべての場合において、seqidラップアラウンドの可能性を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.3. Special Stateids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.3. 特別国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid values whose &#34;other&#34; field is either all zeros or all ones are reserved. They MUST NOT be assigned by the server but have special meanings defined by the protocol. The particular meaning depends on whether the &#34;other&#34; field is all zeros or all ones and the specific value of the seqid field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid values whose &#34;other&#34; field is either all zeros or all ones are reserved. They MUST NOT be assigned by the server but have special meanings defined by the protocol. The particular meaning depends on whether the &#34;other&#34; field is all zeros or all ones and the specific value of the seqid field.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following combinations of &#34;other&#34; and seqid are defined in NFSv4:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4では、「その他」とseqidの次の組み合わせが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anonymous Stateid: When &#34;other&#34; and seqid are both zero, the stateid is treated as a special anonymous stateid, which can be used in READ, WRITE, and SETATTR requests to indicate the absence of any open state associated with the request. When an anonymous stateid value is used, and an existing open denies the form of access requested, then access will be denied to the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
匿名のStateid：「other」とseqidの両方がゼロの場合、stateidは特別な匿名のstateidとして扱われ、READ、WRITE、およびSETATTR要求で使用して、要求に関連付けられている開いている状態がないことを示します。匿名のstateid値が使用され、既存のオープンが要求されたアクセスの形式を拒否した場合、要求へのアクセスは拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ Bypass Stateid: When &#34;other&#34; and seqid are both all ones, the stateid is a special READ bypass stateid. When this value is used in WRITE or SETATTR, it is treated like the anonymous value. When used in READ, the server MAY grant access, even if access would normally be denied to READ requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READバイパス状態ID：「other」とseqidが両方とも1の場合、stateidは特別なREADバイパス状態IDです。この値をWRITEまたはSETATTRで使用すると、匿名値のように扱われます。 READで使用すると、通常はREAD要求へのアクセスが拒否される場合でも、サーバーはアクセスを許可できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a stateid value is used that has all zeros or all ones in the &#34;other&#34; field but does not match one of the cases above, the server MUST return the error NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a stateid value is used that has all zeros or all ones in the &#34;other&#34; field but does not match one of the cases above, the server MUST return the error NFS4ERR_BAD_STATEID.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special stateids, unlike other stateids, are not associated with individual client IDs or filehandles and can be used with all valid client IDs and filehandles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の状態IDとは異なり、特別な状態IDは個々のクライアントIDまたはファイルハンドルに関連付けられておらず、すべての有効なクライアントIDおよびファイルハンドルで使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.4. Stateid Lifetime and Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.4. Stateidのライフタイムと検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateids must remain valid until either a client restart or a server restart, or until the client returns all of the locks associated with the stateid by means of an operation such as CLOSE or DELEGRETURN. If the locks are lost due to revocation, as long as the client ID is valid, the stateid remains a valid designation of that revoked state. Stateids associated with byte-range locks are an exception. They remain valid even if a LOCKU frees all remaining locks, so long as the open file with which they are associated remains open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateidは、クライアントが再起動するかサーバーが再起動するか、クライアントがCLOSEやDELEGRETURNなどの操作によってstateidに関連付けられたすべてのロックを返すまで、有効なままである必要があります。取り消しによってロックが失われた場合、クライアントIDが有効である限り、stateidはその取り消された状態の有効な指定のままです。バイト範囲ロックに関連付けられたステートIDは例外です。それらが関連付けられている開いているファイルが開いたままである限り、LOCKUが残りのすべてのロックを解放しても、それらは有効なままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that there are situations in which the client&#39;s locks become invalid, without the client requesting they be returned. These include lease expiration and a number of forms of lock revocation within the lease period. It is important to note that in these situations, the stateid remains valid and the client can use it to determine the disposition of the associated lost locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのロックの返却を要求せずに、クライアントのロックが無効になる状況があることに注意してください。これには、リースの有効期限と、リース期間内のロックの取り消しのいくつかの形式が含まれます。これらの状況では、stateidは有効なままであり、クライアントはそれを使用して、関連付けられている失われたロックの性質を判断できることに注意することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An &#34;other&#34; value must never be reused for a different purpose (i.e., different filehandle, owner, or type of locks) within the context of a single client ID. A server may retain the &#34;other&#34; value for the same purpose beyond the point where it may otherwise be freed, but if it does so, it must maintain seqid continuity with previous values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「その他」の値は、単一のクライアントIDのコンテキスト内で、異なる目的（つまり、異なるファイルハンドル、所有者、またはロックのタイプ）に再利用してはなりません。サーバーは、他の方法で解放される可能性があるポイントを超えて、同じ目的で「その他」の値を保持できますが、解放する場合は、以前の値との連続性を維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One mechanism that may be used to satisfy the requirement that the server recognize invalid and out-of-date stateids is for the server to divide the &#34;other&#34; field of the stateid into two fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが無効で古い状態IDを認識するという要件を満たすために使用できるメカニズムの1つは、サーバーが状態IDの「その他」フィールドを2つのフィールドに分割することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An index into a table of locking-state structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ロック状態構造のテーブルへのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A generation number that is incremented on each allocation of a table entry for a particular use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定の用途のためのテーブルエントリの割り当てごとに増分される世代番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
And then store the following in each table entry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして、各テーブルエントリに以下を格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client ID with which the stateid is associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stateidが関連付けられているクライアントID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The current generation number for the (at most one) valid stateid sharing this index value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o このインデックス値を共有する（最大で1つの）有効な状態IDの現在の世代番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The filehandle of the file on which the locks are taken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ロックが行われるファイルのファイルハンドル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An indication of the type of stateid (open, byte-range lock, file delegation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An indication of the type of stateid (open, byte-range lock, file delegation).
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The last seqid value returned corresponding to the current &#34;other&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在の「その他」の値に対応して返された最後のseqid値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An indication of the current status of the locks associated with this stateid -- in particular, whether these have been revoked and, if so, for what reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o このstateidに関連付けられているロックの現在のステータスの表示-特に、これらが取り消されたかどうか、取り消されている場合は、その理由を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With this information, an incoming stateid can be validated and the appropriate error returned when necessary. Special and non-special stateids are handled separately. (See Section 9.1.4.3 for a discussion of special stateids.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With this information, an incoming stateid can be validated and the appropriate error returned when necessary. Special and non-special stateids are handled separately. (See Section 9.1.4.3 for a discussion of special stateids.)
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a stateid is being tested, and the &#34;other&#34; field is all zeros or all ones, a check that the &#34;other&#34; and seqid fields match a defined combination for a special stateid is done and the results determined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a stateid is being tested, and the &#34;other&#34; field is all zeros or all ones, a check that the &#34;other&#34; and seqid fields match a defined combination for a special stateid is done and the results determined as follows:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the &#34;other&#34; and seqid fields do not match a defined combination associated with a special stateid, the error NFS4ERR_BAD_STATEID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「その他」およびseqidフィールドが、特別な状態IDに関連付けられた定義済みの組み合わせと一致しない場合、エラーNFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the combination is valid in general but is not appropriate to the context in which the stateid is used (e.g., an all-zero stateid is used when an open stateid is required in a LOCK operation), the error NFS4ERR_BAD_STATEID is also returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 組み合わせは一般的には有効ですが、stateidが使用されるコンテキストに適さない場合（たとえば、LOCK操作でopen stateidが必要なときにすべてゼロのstateidが使用される場合）、エラーNFS4ERR_BAD_STATEIDも返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, the check is completed and the special stateid is accepted as valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合、チェックは完了し、特別な状態IDが有効として受け入れられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a stateid is being tested, and the &#34;other&#34; field is neither all zeros nor all ones, the following procedure could be used to validate an incoming stateid and return an appropriate error, when necessary, assuming that the &#34;other&#34; field would be divided into a table index and an entry generation. Note that the terms &#34;earlier&#34; and &#34;later&#34; used in connection with seqid comparison are to be understood as explained in Section 9.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態IDがテストされており、「その他」フィールドがすべて0でもすべて1でもない場合、次の手順を使用して、受信した状態IDを検証し、必要に応じて「その他」フィールドがテーブルインデックスとエントリ生成に分かれています。 seqidの比較に関連して使用される「以前」および「後で」という用語は、セクション9.1.3で説明されているように理解されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the table index field is outside the range of the associated table, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o テーブルインデックスフィールドが関連するテーブルの範囲外の場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the selected table entry is of a different generation than that specified in the incoming stateid, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 選択されたテーブルエントリが、受信状態IDで指定された世代とは異なる世代である場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the selected table entry does not match the current filehandle, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 選択したテーブルエントリが現在のファイルハンドルと一致しない場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the stateid represents revoked state or state lost as a result of lease expiration, then return NFS4ERR_EXPIRED, NFS4ERR_BAD_STATEID, or NFS4ERR_ADMIN_REVOKED, as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 状態IDが、取り消された状態またはリースの期限切れの結果として失われた状態を表す場合、NFS4ERR_EXPIRED、NFS4ERR_BAD_STATEID、またはNFS4ERR_ADMIN_REVOKEDを適宜返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the stateid type is not valid for the context in which the stateid appears, return NFS4ERR_BAD_STATEID. Note that a stateid may be valid in general but invalid for a particular operation, as, for example, when a stateid that doesn&#39;t represent byte-range locks is passed to the non-from_open case of LOCK or to LOCKU, or when a stateid that does not represent an open is passed to CLOSE or OPEN_DOWNGRADE. In such cases, the server MUST return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 状態IDが表示されるコンテキストに対して状態IDのタイプが有効でない場合は、NFS4ERR_BAD_STATEIDを返します。たとえば、バイト範囲のロックを表さない状態IDがLOCKのnon-from_openケースまたはLOCKUに渡されたとき、またはオープンを表していない状態IDは、CLOSEまたはOPEN_DOWNGRADEに渡されます。このような場合、サーバーはNFS4ERR_BAD_STATEIDを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the seqid field is not zero and it is later than the current sequence value corresponding to the current &#34;other&#34; field, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o seqidフィールドがゼロではなく、現在の「その他」フィールドに対応する現在のシーケンス値よりも遅い場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the seqid field is earlier than the current sequence value corresponding to the current &#34;other&#34; field, return NFS4ERR_OLD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o seqidフィールドが現在の「その他」フィールドに対応する現在のシーケンス値よりも古い場合は、NFS4ERR_OLD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, the stateid is valid, and the table entry should contain any additional information about the type of stateid and information associated with that particular type of stateid, such as the associated set of locks (e.g., open-owner and lock-owner information), as well as information on the specific locks themselves, such as open modes and byte ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合、stateidは有効であり、テーブルエントリには、stateidのタイプに関する追加情報と、関連するロックのセットなどの特定のタイプのstateidに関連付けられた情報（たとえば、open-ownerおよびlock-owner情報）が含まれている必要があります。 、およびオープンモードやバイト範囲などの特定のロック自体に関する情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.5. Stateid Use for I/O Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.5. I / O操作のステートイド使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients performing Input/Output (I/O) operations need to select an appropriate stateid based on the locks (including opens and delegations) held by the client and the various types of state-owners sending the I/O requests. SETATTR operations that change the file size are treated like I/O operations in this regard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入出力（I / O）操作を実行するクライアントは、クライアントが保持しているロック（オープンと委任を含む）およびI / O要求を送信するさまざまなタイプの状態所有者に基づいて、適切な状態IDを選択する必要があります。ファイルサイズを変更するSETATTR操作は、この点でI / O操作と同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules, applied in order of decreasing priority, govern the selection of the appropriate stateid. In following these rules, the client will only consider locks of which it has actually received notification by an appropriate operation response or callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のルールは、優先度の高い順に適用され、適切なステートIDの選択を管理します。これらのルールに従うと、クライアントは、適切な操作応答またはコールバックによって実際に通知を受け取ったロックのみを考慮します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client holds a delegation for the file in question, the delegation stateid SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが問題のファイルの委任を保持している場合は、委任のstateidを使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, if the entity corresponding to the lock-owner (e.g., a process) sending the I/O has a byte-range lock stateid for the associated open file, then the byte-range lock stateid for that lock-owner and open file SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合、I / Oを送信するロック所有者（たとえば、プロセス）に対応するエンティティに、関連付けられたオープンファイルのバイト範囲ロック状態IDがある場合、そのロック所有者とオープンファイルのバイト範囲ロック状態ID使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is no byte-range lock stateid, then the OPEN stateid for the current open-owner, i.e., the OPEN stateid for the open file in question, SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイト範囲のロック状態IDがない場合は、現在のオープン所有者のOPEN状態ID、つまり問題のオープンファイルのOPEN状態IDを使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Finally, if none of the above apply, then a special stateid SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 最後に、上記のいずれにも該当しない場合は、特別な状態IDを使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ignoring these rules may result in situations in which the server does not have information necessary to properly process the request. For example, when mandatory byte-range locks are in effect, if the stateid does not indicate the proper lock-owner, via a lock stateid, a request might be avoidably rejected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのルールを無視すると、リクエストを適切に処理するために必要な情報がサーバーにない場合があります。たとえば、必須のバイト範囲ロックが有効な場合、stateidがロックのstateidを介して適切なロック所有者を示していない場合、要求が拒否される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server, however, should not try to enforce these ordering rules and should use whatever information is available to properly process I/O requests. In particular, when a client has a delegation for a given file, it SHOULD take note of this fact in processing a request, even if it is sent with a special stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server, however, should not try to enforce these ordering rules and should use whatever information is available to properly process I/O requests. In particular, when a client has a delegation for a given file, it SHOULD take note of this fact in processing a request, even if it is sent with a special stateid.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.6. Stateid Use for SETATTR Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.6. Stateid Use for SETATTR Operations
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of SETATTR operations, a stateid is present. In cases other than those that set the file size, the client may send either a special stateid or, when a delegation is held for the file in question, a delegation stateid. While the server SHOULD validate the stateid and may use the stateid to optimize the determination as to whether a delegation is held, it SHOULD note the presence of a delegation even when a special stateid is sent, and MUST accept a valid delegation stateid when sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作の場合、stateidが存在します。ファイルサイズを設定したもの以外の場合、クライアントは特別な状態IDを送信するか、問題のファイルの委任が保持されている場合は委任状態IDを送信します。サーバーは、stateidを検証する必要があり、stateidを使用して委任が保持されているかどうかの判断を最適化できますが、特別なstateidが送信された場合でも委任の存在に注意し、送信時に有効な委任stateidを受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.5. Lock-Owner
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.5. ロック所有者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When requesting a lock, the client must present to the server the client ID and an identifier for the owner of the requested lock. These two fields comprise the lock-owner and are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When requesting a lock, the client must present to the server the client ID and an identifier for the owner of the requested lock. These two fields comprise the lock-owner and are defined as follows:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client ID returned by the server as part of the client&#39;s use of the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントによるSETCLIENTID操作の使用の一部としてサーバーから返されたクライアントID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A variable-length opaque array used to uniquely define the owner of a lock managed by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが管理するロックの所有者を一意に定義するために使用される可変長の不透明な配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This may be a thread id, process id, or other unique value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、スレッドID、プロセスID、またはその他の一意の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server grants the lock, it responds with a unique stateid. The stateid is used as a shorthand reference to the lock-owner, since the server will be maintaining the correspondence between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがロックを許可すると、サーバーは一意の状態IDで応答します。サーバーはロック所有者間の対応を維持するため、stateidはロック所有者への省略参照として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.6. Use of the Stateid and Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.6. Stateidとロックの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All READ, WRITE, and SETATTR operations contain a stateid. For the purposes of this section, SETATTR operations that change the size attribute of a file are treated as if they are writing the area between the old and new size (i.e., the range truncated or added to the file by means of the SETATTR), even where SETATTR is not explicitly mentioned in the text. The stateid passed to one of these operations must be one that represents an OPEN (e.g., via the open-owner), a set of byte-range locks, or a delegation, or it may be a special stateid representing anonymous access or the READ bypass stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのREAD、WRITE、およびSETATTR操作には、stateidが含まれます。このセクションの目的のために、ファイルのサイズ属性を変更するSETATTR操作は、古いサイズと新しいサイズの間の領域（つまり、SETATTRによって切り捨てられた、またはファイルに追加された範囲）を書き込むかのように扱われます。 SETATTRがテキストで明示的に言及されていない場合でも。これらの操作の1つに渡される状態IDは、OPEN（たとえば、open-ownerを介して）、一連のバイト範囲ロック、または委任を表すものであるか、匿名アクセスまたはREADを表す特別な状態IDである可能性があります。ステートIDをバイパスします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If the state-owner performs a READ or WRITE in a situation in which it has established a lock or share reservation on the server (any OPEN constitutes a share reservation), the stateid (previously returned by the server) must be used to indicate what locks, including both byte-range locks and share reservations, are held by the state-owner. If no state is established by the client -- either byte-range lock or share reservation -- the anonymous stateid is used. Regardless of whether an anonymous stateid or a stateid returned by the server is used, if there is a conflicting share reservation or mandatory byte-range lock held on the file, the server MUST refuse to service the READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
状態所有者がサーバーでロックまたは共有予約を確立した状況でREADまたはWRITEを実行する場合（OPENは共有予約を構成します）、stateid（以前にサーバーから返された）を使用して、バイト範囲ロックと共有予約の両方を含むロックは、国の所有者によって保持されます。クライアントによって状態が確立されていない場合（バイト範囲ロックまたは共有予約）、匿名の状態IDが使用されます。匿名のstateidとサーバーから返されたstateidのどちらを使用するかに関係なく、ファイルで保持されている共有予約または必須のバイト範囲ロックが競合している場合、サーバーはREADまたはWRITE操作のサービスを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Share reservations are established by OPEN operations and by their nature are mandatory in that when the OPEN denies READ or WRITE operations, that denial results in such operations being rejected with error NFS4ERR_LOCKED. Byte-range locks may be implemented by the server as either mandatory or advisory, or the choice of mandatory or advisory behavior may be determined by the server on the basis of the file being accessed (for example, some UNIX-based servers support a &#34;mandatory lock bit&#34; on the mode attribute such that if set, byte-range locks are required on the file before I/O is possible). When byte-range locks are advisory, they only prevent the granting of conflicting lock requests and have no effect on READs or WRITEs. Mandatory byte-range locks, however, prevent conflicting I/O operations. When they are attempted, they are rejected with NFS4ERR_LOCKED. When the client gets NFS4ERR_LOCKED on a file it knows it has the proper share reservation for, it will need to issue a LOCK request on the region of the file that includes the region the I/O was to be performed on, with an appropriate locktype (i.e., READ*_LT for a READ operation, WRITE*_LT for a WRITE operation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有の予約はOPEN操作によって確立されます。OPEN予約がREADまたはWRITE操作を拒否すると、そのような操作はエラーNFS4ERR_LOCKEDで拒否されます。バイト範囲ロックは、必須または助言としてサーバーによって実装される場合があります。または、必須または助言の動作の選択は、アクセスされるファイルに基づいてサーバーによって決定される場合があります（たとえば、一部のUNIXベースのサーバーは「必須のロックビット」が設定されている場合は、I / Oが可能になる前にファイルにバイト範囲のロックが必要になります。バイト範囲ロックが助言である場合、それらは競合するロック要求の許可を防ぐだけで、READまたはWRITEには影響を与えません。ただし、必須のバイト範囲ロックは、I / O操作の競合を防ぎます。試行された場合、NFS4ERR_LOCKEDで拒否されます。クライアントは、適切な共有予約があることを知っているファイルでNFS4ERR_LOCKEDを取得すると、適切なロックタイプを使用して、I / Oが実行される領域を含むファイルの領域でLOCK要求を発行する必要があります。 （つまり、READ操作の場合はREAD * _LT、WRITE操作の場合はWRITE * _LT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With NFSv3, there was no notion of a stateid, so there was no way to tell if the application process of the client sending the READ or WRITE operation had also acquired the appropriate byte-range lock on the file. Thus, there was no way to implement mandatory locking. With the stateid construct, this barrier has been removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3では、stateidの概念がなかったため、READまたはWRITE操作を送信するクライアントのアプリケーションプロセスがファイルの適切なバイト範囲ロックも取得したかどうかを判断する方法がありませんでした。したがって、強制ロックを実装する方法はありませんでした。 stateidコンストラクトにより、この障壁が取り除かれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for UNIX environments that support mandatory file locking, the distinction between advisory and mandatory locking is subtle. In fact, advisory and mandatory byte-range locks are exactly the same insofar as the APIs and requirements on implementation are concerned. If the mandatory lock attribute is set on the file, the server checks to see if the lock-owner has an appropriate shared (read) or exclusive (write) byte-range lock on the region it wishes to read or write to. If there is no appropriate lock, the server checks if there is a conflicting lock (which can be done by attempting to acquire the conflicting lock on behalf of the lock-owner and, if successful, release the lock after the READ or WRITE is done), and if there is, the server returns NFS4ERR_LOCKED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for UNIX environments that support mandatory file locking, the distinction between advisory and mandatory locking is subtle. In fact, advisory and mandatory byte-range locks are exactly the same insofar as the APIs and requirements on implementation are concerned. If the mandatory lock attribute is set on the file, the server checks to see if the lock-owner has an appropriate shared (read) or exclusive (write) byte-range lock on the region it wishes to read or write to. If there is no appropriate lock, the server checks if there is a conflicting lock (which can be done by attempting to acquire the conflicting lock on behalf of the lock-owner and, if successful, release the lock after the READ or WRITE is done), and if there is, the server returns NFS4ERR_LOCKED.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Windows environments, there are no advisory byte-range locks, so the server always checks for byte-range locks during I/O requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Windows環境の場合、勧告的なバイト範囲ロックはないため、サーバーはI / O要求時に常にバイト範囲ロックをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the NFSv4 LOCK operation does not need to distinguish between advisory and mandatory byte-range locks. It is the NFSv4 server&#39;s processing of the READ and WRITE operations that introduces the distinction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、NFSv4 LOCK操作は、勧告的ロックと必須バイト範囲ロックを区別する必要はありません。区別を導入するのは、NFSv4サーバーのREADおよびWRITE操作の処理です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every stateid other than the special stateid values noted in this section, whether returned by an OPEN-type operation (i.e., OPEN, OPEN_DOWNGRADE) or by a LOCK-type operation (i.e., LOCK or LOCKU), defines an access mode for the file (i.e., READ, WRITE, or READ-WRITE) as established by the original OPEN that began the stateid sequence, and as modified by subsequent OPENs and OPEN_DOWNGRADEs within that stateid sequence. When a READ, WRITE, or SETATTR that specifies the size attribute is done, the operation is subject to checking against the access mode to verify that the operation is appropriate given the OPEN with which the operation is associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションに記載されている特殊なstateid値以外のすべてのstateidは、OPENタイプの操作（OPEN、OPEN_DOWNGRADEなど）によって返されるか、LOCKタイプの操作（LOCKまたはLOCKUなど）によって返されるかに関係なく、ファイルのアクセスモードを定義します（つまり、READ、WRITE、またはREAD-WRITE）。stateidシーケンスを開始した元のOPENによって確立され、そのstateidシーケンス内の後続のOPENおよびOPEN_DOWNGRADEによって変更されます。サイズ属性を指定するREAD、WRITE、またはSETATTRが実行されると、操作はアクセスモードに対してチェックされ、操作が関連付けられているOPENが指定されている場合、操作が適切であることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of WRITE-type operations (i.e., WRITEs and SETATTRs that set size), the server must verify that the access mode allows writing and return an NFS4ERR_OPENMODE error if it does not. In the case of READ, the server may perform the corresponding check on the access mode, or it may choose to allow READ on opens for WRITE only, to accommodate clients whose write implementation may unavoidably do reads (e.g., due to buffer cache constraints). However, even if READs are allowed in these circumstances, the server MUST still check for locks that conflict with the READ (e.g., another open specifying denial of READs). Note that a server that does enforce the access mode check on READs need not explicitly check for conflicting share reservations since the existence of OPEN for read access guarantees that no conflicting share reservation can exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITEタイプの操作（つまり、サイズを設定するWRITEおよびSETATTR）の場合、サーバーはアクセスモードが書き込みを許可していることを確認し、許可していない場合はNFS4ERR_OPENMODEエラーを返す必要があります。 READの場合、サーバーはアクセスモードで対応するチェックを実行するか、書き込みの実装が読み取りを不可避的に行う可能性のあるクライアント（バッファキャッシュの制約など）に対応するために、オープン時にREADをWRITEのみに許可することを選択できます。 。ただし、これらの状況でREADが許可されている場合でも、サーバーはREADと競合するロックを確認する必要があります（たとえば、READの拒否を指定する別のオープン）。読み取りアクセスにOPENが存在すると、競合する共有予約が存在しないことが保証されるため、READでアクセスモードチェックを実行するサーバーは、競合する共有予約を明示的にチェックする必要がないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A READ bypass stateid MAY allow READ operations to bypass locking checks at the server. However, WRITE operations with a READ bypass stateid MUST NOT bypass locking checks and are treated exactly the same as if an anonymous stateid were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READバイパス状態IDは、READ操作がサーバーでのロックチェックをバイパスすることを許可する場合があります。ただし、READバイパス状態IDを使用した書き込み操作は、ロックチェックをバイパスしてはならず（MUST NOT）、匿名の状態IDが使用された場合とまったく同じように扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A lock may not be granted while a READ or WRITE operation using one of the special stateids is being performed and the range of the lock request conflicts with the range of the READ or WRITE operation. For the purposes of this paragraph, a conflict occurs when a shared lock is requested and a WRITE operation is being performed, or an exclusive lock is requested and either a READ or a WRITE operation is being performed. A SETATTR that sets size is treated similarly to a WRITE as discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な状態IDの1つを使用するREADまたはWRITE操作が実行されている間、ロックが許可されず、ロック要求の範囲がREADまたはWRITE操作の範囲と競合します。この段落では、共有ロックが要求されてWRITE操作が実行されているとき、または排他ロックが要求されてREADまたはWRITE操作が実行されているときに競合が発生します。サイズを設定するSETATTRは、前述のWRITEと同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.7. Sequencing of Lock Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.7. ロック要求の順序付け
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Locking is different than most NFS operations as it requires &#34;at-most-one&#34; semantics that are not provided by ONC RPC. ONC RPC over a reliable transport is not sufficient because a sequence of locking requests may span multiple TCP connections. In the face of retransmission or reordering, lock or unlock requests must have a well-defined and consistent behavior. To accomplish this, each lock request contains a sequence number that is a consecutively increasing integer. Different state-owners have different sequences. The server maintains the last sequence number (L) received and the response that was returned. The server SHOULD assign a seqid value of one for the first request issued for any given state-owner. Subsequent values are arrived at by incrementing the seqid value, subject to wraparound as described in Section 9.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックは、ONC RPCによって提供されない「最大1つ」のセマンティクスを必要とするため、ほとんどのNFS操作とは異なります。一連のロック要求が複数のTCP接続にまたがることがあるため、信頼性の高いトランスポートを介したONC RPCでは不十分です。再送信または並べ替えに直面して、ロックまたはロック解除要求は、明確に定義された一貫した動作を持つ必要があります。これを実現するために、各ロック要求には、連続的に増加する整数であるシーケンス番号が含まれています。国の所有者が異なれば、シーケンスも異なります。サーバーは、最後に受信したシーケンス番号（L）と返された応答を保持します。サーバーは、任意の状態所有者に対して発行された最初の要求に1のseqid値を割り当てる必要があります。後続の値は、セクション9.1.3で説明されているようにラップアラウンドに従って、seqid値を増分することによって到達します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for requests that contain a sequence number, for each state-owner, there should be no more than one outstanding request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号を含む要求の場合、各状態所有者ごとに、未解決の要求が1つだけあることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a request is received, its sequence number (r) is compared to that of the last one received (L). Only if it has the correct next sequence, normally L + 1, is the request processed beyond the point of seqid checking. Given a properly functioning client, the response to (r) must have been received before the last request (L) was sent. If a duplicate of last request (r == L) is received, the stored response is returned. If the sequence value received is any other value, it is rejected with the return of error NFS4ERR_BAD_SEQID. Sequence history is reinitialized whenever the SETCLIENTID/ SETCLIENTID_CONFIRM sequence changes the client verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求を受信すると、そのシーケンス番号（r）が最後に受信したもの（L）と比較されます。正しい次のシーケンス（通常はL + 1）がある場合のみ、リクエストはseqidチェックのポイントを超えて処理されます。クライアントが適切に機能している場合、（r）への応答は、最後の要求（L）が送信される前に受信されている必要があります。最後のリクエストの重複（r == L）が受信されると、保存されているレスポンスが返されます。受け取ったシーケンス値が他の値の場合、エラーNFS4ERR_BAD_SEQIDが返されて拒否されます。 SETCLIENTID / SETCLIENTID_CONFIRMシーケンスがクライアントベリファイアを変更するたびに、シーケンス履歴が再初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is critical that the server maintain the last response sent to the client to provide a more reliable cache of duplicate non-idempotent requests than that of the traditional cache described in [Chet]. The traditional duplicate request cache uses a least recently used algorithm for removing unneeded requests. However, the last lock request and response on a given state-owner must be cached as long as the lock state exists on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chet]で説明されている従来のキャッシュよりも信頼性の高い重複しない非べきリクエストのキャッシュを提供するために、サーバーがクライアントに送信された最後の応答を維持することが重要です。従来の重複リクエストキャッシュは、最も古い使用頻度の低いアルゴリズムを使用して、不要なリクエストを削除します。ただし、サーバーにロック状態が存在する限り、特定の状態所有者に対する最後のロック要求とロック応答をキャッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST advance the sequence number for the CLOSE, LOCK, LOCKU, OPEN, OPEN_CONFIRM, and OPEN_DOWNGRADE operations. This is true even in the event that the previous operation that used the sequence number received an error. The only exception to this rule is if the previous operation received one of the following errors: NFS4ERR_STALE_CLIENTID, NFS4ERR_STALE_STATEID, NFS4ERR_BAD_STATEID, NFS4ERR_BAD_SEQID, NFS4ERR_BADXDR, NFS4ERR_RESOURCE, NFS4ERR_NOFILEHANDLE, or NFS4ERR_MOVED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、CLOSE、LOCK、LOCKU、OPEN、OPEN_CONFIRM、およびOPEN_DOWNGRADE操作のシーケンス番号を進める必要があります。これは、シーケンス番号を使用した前の操作がエラーを受け取った場合にも当てはまります。このルールの唯一の例外は、前の操作が次のエラーのいずれかを受け取った場合です：NFS4ERR_STALE_CLIENTID、NFS4ERR_STALE_STATEID、NFS4ERR_BAD_STATEID、NFS4ERR_BAD_SEQID、NFS4ERR_BADXDR、NFS4ERR_RESOURCE、NFS4ERR_NOFILEHANDLE、またはNFS4ERR_MOVED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.8. Recovery from Replayed Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.8. リプレイされたリクエストからの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described above, the sequence number is per state-owner. As long as the server maintains the last sequence number received and follows the methods described above, there are no risks of a Byzantine router re-sending old requests. The server need only maintain the (state-owner, sequence number) state as long as there are open files or closed files with locks outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、シーケンス番号は国の所有者ごとです。サーバーが受信した最後のシーケンス番号を維持し、上記の方法に従う限り、ビザンチンルーターが古いリクエストを再送信するリスクはありません。開いているファイルまたはロックが未処理の閉じたファイルがある限り、サーバーは（状態所有者、シーケンス番号）状態を維持するだけで済みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK, LOCKU, OPEN, OPEN_DOWNGRADE, and CLOSE each contain a sequence number, and therefore the risk of the replay of these operations resulting in undesired effects is non-existent while the server maintains the state-owner state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK、LOCKU、OPEN、OPEN_DOWNGRADE、およびCLOSEにはそれぞれシーケンス番号が含まれているため、サーバーが状態所有者の状態を維持している間、これらの操作が再現されて望ましくない結果が生じるリスクはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.9. Interactions of Multiple Sequence Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.9. 複数のシーケンス値の相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some operations may have multiple sources of data for request sequence checking and retransmission determination. Some operations have multiple sequence values associated with multiple types of state-owners. In addition, such operations may also have a stateid with its own seqid value, that will be checked for validity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の操作には、要求シーケンスのチェックと再送信の決定のために複数のデータソースがある場合があります。一部の操作には、複数のタイプの状態所有者に関連付けられた複数のシーケンス値があります。さらに、そのような操作には、独自のseqid値を持つstateidがあり、有効性がチェックされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted above, there may be multiple sequence values to check. The following rules should be followed by the server in processing these multiple sequence values within a single operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、チェックするシーケンス値が複数ある場合があります。サーバーは、これらの複数のシーケンス値を1回の操作で処理する際に、次のルールに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a sequence value associated with a state-owner is unavailable for checking because the state-owner is unknown to the server, it takes no part in the comparison.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a sequence value associated with a state-owner is unavailable for checking because the state-owner is unknown to the server, it takes no part in the comparison.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When any of the state-owner sequence values are invalid, NFS4ERR_BAD_SEQID is returned. When a stateid sequence is checked, NFS4ERR_BAD_STATEID or NFS4ERR_OLD_STATEID is returned as appropriate, but NFS4ERR_BAD_SEQID has priority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 状態所有者のシーケンス値のいずれかが無効な場合、NFS4ERR_BAD_SEQIDが返されます。 stateidシーケンスがチェックされると、NFS4ERR_BAD_STATEIDまたはNFS4ERR_OLD_STATEIDが適切に返されますが、NFS4ERR_BAD_SEQIDが優先されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When any one of the sequence values matches a previous request, for a state-owner, it is treated as a retransmission and not re-executed. When the type of the operation does not match that originally used, NFS4ERR_BAD_SEQID is returned. When the server can determine that the request differs from the original, it may return NFS4ERR_BAD_SEQID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o シーケンス値のいずれかが前の要求と一致する場合、状態所有者の場合、それは再送信として扱われ、再実行されません。操作のタイプが最初に使用されたものと一致しない場合、NFS4ERR_BAD_SEQIDが返されます。サーバーが要求が元の要求と異なると判断できる場合、サーバーはNFS4ERR_BAD_SEQIDを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When multiple sequence values match previous operations but the operations are not the same, NFS4ERR_BAD_SEQID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 複数のシーケンス値が前の操作と一致するが、操作が同じでない場合、NFS4ERR_BAD_SEQIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When there are no sequence values available for comparison and the operation is an OPEN, the server indicates to the client that an OPEN_CONFIRM is required, unless it can conclusively determine that confirmation is not required (e.g., by knowing that no open-owner state has ever been released for the current clientid).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 比較に使用できるシーケンス値がなく、操作がOPENの場合、サーバーはクライアントにOPEN_CONFIRMが必要であることをクライアントに示します。現在のclientid用にリリースされています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.10. Releasing State-Owner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.10. 状態所有者状態の解放
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a particular state-owner no longer holds open or file locking state at the server, the server may choose to release the sequence number state associated with the state-owner. The server may make this choice based on lease expiration, the reclamation of server memory, or other implementation-specific details. Note that when this is done, a retransmitted request, normally identified by a matching state-owner sequence, may not be correctly recognized, so that the client will not receive the original response that it would have if the state-owner state was not released.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の状態所有者がサーバーでオープン状態またはファイルロック状態を保持しなくなった場合、サーバーは状態所有者に関連付けられたシーケンス番号状態を解放することを選択できます。サーバーは、リースの有効期限、サーバーメモリの再生、またはその他の実装固有の詳細に基づいて、この選択を行う場合があります。これが行われると、通常は一致する状態所有者のシーケンスによって識別される再送信された要求が正しく認識されない可能性があるため、状態所有者の状態が解放されなかった場合の元の応答をクライアントが受信しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server were able to be sure that a given state-owner would never again be used by a client, such an issue could not arise. Even when the state-owner state is released and the client subsequently uses that state-owner, retransmitted requests will be detected as invalid and the request not executed, although the client may have a recovery path that is more complicated than simply getting the original response back transparently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが、特定の状態所有者がクライアントによって二度と使用されないことを確認できた場合、そのような問題は発生しません。状態所有者の状態が解放され、その後クライアントがその状態所有者を使用する場合でも、再送信された要求は無効として検出され、要求は実行されませんが、クライアントには元の応答を取得するよりも複雑な回復パスがある場合があります透明に戻る。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any event, the server is able to safely release state-owner state (in the sense that retransmitted requests will not be erroneously acted upon) when the state-owner is not currently being utilized by the client (i.e., there are no open files associated with an open-owner and no lock stateids associated with a lock-owner). The server may choose to hold the state-owner state in order to simplify the recovery path, in the case in which retransmissions of currently active requests are received. However, the period for which it chooses to hold this state is implementation specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれにせよ、サーバーは、状態所有者が現在クライアントによって利用されていない（つまり、開いているファイルがない）ときに、状態所有者の状態を安全に解放できます（再送信された要求が誤って処理されないという意味で）。オープンオーナーに関連付けられており、ロックオーナーに関連付けられているロックステートIDはありません）。サーバーは、現在アクティブな要求の再送信が受信された場合に、回復パスを簡略化するために状態所有者状態を保持することを選択できます。ただし、この状態を保持することを選択する期間は、実装によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a LOCK, LOCKU, OPEN_DOWNGRADE, or CLOSE is retransmitted after the server has previously released the state-owner state, the server will find that the state-owner has no files open and an error will be returned to the client. If the state-owner does have a file open, the stateid will not match and again an error is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが以前に状態所有者の状態を解放した後で、LOCK、LOCKU、OPEN_DOWNGRADE、またはCLOSEが再送信された場合、サーバーは状態所有者が開いているファイルがないことを検出し、エラーがクライアントに返されます。状態所有者がファイルを開いている場合、stateidは一致せず、再びエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.11. Use of Open Confirmation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.11. オープン確認の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that an OPEN is retransmitted and the open-owner is being used for the first time or the open-owner state has been previously released by the server, the use of the OPEN_CONFIRM operation will prevent incorrect behavior. When the server observes the use of the open-owner for the first time, it will direct the client to perform the OPEN_CONFIRM for the corresponding OPEN. This sequence establishes the use of an open-owner and associated sequence number. Since the OPEN_CONFIRM sequence connects a new open-owner on the server with an existing open-owner on a client, the sequence number may have any valid (i.e., non-zero) value. The OPEN_CONFIRM step assures the server that the value received is the correct one. (See Section 16.18 for further details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが再送信され、open-ownerが初めて使用される場合、またはopen-owner状態がサーバーによって以前に解放されている場合、OPEN_CONFIRM操作を使用すると、不正な動作を防ぐことができます。サーバーは、open-ownerの使用を初めて確認するときに、対応するOPENに対してOPEN_CONFIRMを実行するようにクライアントに指示します。このシーケンスは、オープンオーナーと関連するシーケンス番号の使用を確立します。 OPEN_CONFIRMシーケンスは、サーバー上の新しいオープンオーナーをクライアント上の既存のオープンオーナーに接続するため、シーケンス番号には有効な（つまり、ゼロ以外の）値が含まれる場合があります。 OPEN_CONFIRMステップは、受け取った値が正しいものであることをサーバーに保証します。 （詳細については、セクション16.18を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of situations in which the requirement to confirm an OPEN would pose difficulties for the client and server, in that they would be prevented from acting in a timely fashion on information received, because that information would be provisional, subject to deletion upon non-confirmation. Fortunately, these are situations in which the server can avoid the need for confirmation when responding to open requests. The two constraints are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENを確認する要件がクライアントとサーバーに困難をもたらす多くの状況があります。それらの情報は暫定的なものであり、削除される可能性があるため、受信した情報に対してタイムリーに機能することが妨げられます。未確認。幸いなことに、これらは、サーバーがオープン要求に応答するときに確認の必要を回避できる状況です。 2つの制約は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server must not bestow a delegation for any open that would require confirmation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、確認を必要とするオープンに対して委任を与えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server MUST NOT require confirmation on a reclaim-type open (i.e., one specifying claim type CLAIM_PREVIOUS or CLAIM_DELEGATE_PREV).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、再利用タイプのオープン（つまり、クレームタイプCLAIM_PREVIOUSまたはCLAIM_DELEGATE_PREVを指定するもの）の確認を要求してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These constraints are related in that reclaim-type opens are the only ones in which the server may be required to send a delegation. For CLAIM_NULL, sending the delegation is optional, while for CLAIM_DELEGATE_CUR, no delegation is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの制約は、サーバーが委任を送信する必要がある場合があるのは、再利用タイプのオープンだけであるという点で関連しています。 CLAIM_NULLの場合、委任の送信はオプションですが、CLAIM_DELEGATE_CURの場合、委任は送信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations being sent with an open requiring confirmation are troublesome because recovering from non-confirmation adds undue complexity to the protocol, while requiring confirmation on reclaim-type opens poses difficulties in that the inability to resolve the status of the reclaim until lease expiration may make it difficult to have timely determination of the set of locks being reclaimed (since the grace period may expire).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認を必要とするオープンで送信される委任は、非確認から回復するとプロトコルが過度に複雑になるので厄介ですが、再利用タイプのオープンで確認を要求すると、リースの期限が切れるまで再利用のステータスを解決できないために困難になる場合があります。 （猶予期間が期限切れになる可能性があるため）再利用されるロックのセットをタイムリーに決定することが困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Requiring open confirmation on reclaim-type opens is avoidable because of the nature of the environments in which such opens are done. For CLAIM_PREVIOUS opens, this is immediately after server reboot, so there should be no time for open-owners to be created, found to be unused, and recycled. For CLAIM_DELEGATE_PREV opens, we are dealing with either a client reboot situation or a network partition resulting in deletion of lease state (and returning NFS4ERR_EXPIRED). A server that supports delegations can be sure that no open-owners for that client have been recycled since client initialization or deletion of lease state and thus can be confident that confirmation will not be required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このようなオープンが行われる環境の性質上、再利用タイプのオープンでオープン確認を要求することは避けられます。 CLAIM_PREVIOUSオープンの場合、これはサーバーの再起動直後なので、オープンオーナーが作成され、未使用であることが判明し、リサイクルされる時間はありません。 CLAIM_DELEGATE_PREVオープンの場合、クライアントの再起動状況またはネットワークパーティションのいずれかを処理しており、リース状態が削除されます（NFS4ERR_EXPIREDが返されます）。委任をサポートするサーバーは、クライアントの初期化またはリース状態の削除以降、そのクライアントのオープンオーナーがリサイクルされていないことを確認できるため、確認が不要であることを確信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Lock Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. ロック範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol allows a lock-owner to request a lock with a byte range and then either upgrade or unlock a sub-range of the initial lock. It is expected that this will be an uncommon type of request. In any case, servers or server file systems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock-owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol allows a lock-owner to request a lock with a byte range and then either upgrade or unlock a sub-range of the initial lock. It is expected that this will be an uncommon type of request. In any case, servers or server file systems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock-owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is discouraged from combining multiple independent locking ranges that happen to be adjacent into a single request, since the server may not support sub-range requests, and for reasons related to the recovery of file locking state in the event of server failure. As discussed in Section 9.6.2 below, the server may employ certain optimizations during recovery that work effectively only when the client&#39;s behavior during lock recovery is similar to the client&#39;s locking behavior prior to server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはサブレンジリクエストをサポートしていない可能性があるため、またサーバーに障害が発生した場合のファイルロック状態の回復に関連する理由により、クライアントは、偶然に隣接する複数の独立したロック範囲を1つのリクエストに組み合わせないようにしてください。以下のセクション9.6.2で説明するように、サーバーは、ロック回復中のクライアントの動作がサーバー障害前のクライアントのロック動作に類似している場合にのみ効果的に機能する、回復中に特定の最適化を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. Upgrading and Downgrading Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. ロックのアップグレードとダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client has a write lock on a record, it can request an atomic downgrade of the lock to a read lock via the LOCK request, by setting the type to READ_LT. If the server supports atomic downgrade, the request will succeed. If not, it will return NFS4ERR_LOCK_NOTSUPP. The client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client has a write lock on a record, it can request an atomic downgrade of the lock to a read lock via the LOCK request, by setting the type to READ_LT. If the server supports atomic downgrade, the request will succeed. If not, it will return NFS4ERR_LOCK_NOTSUPP. The client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If a client has a read lock on a record, it can request an atomic upgrade of the lock to a write lock via the LOCK request by setting the type to WRITE_LT or WRITEW_LT. If the server does not support atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP. If the upgrade can be achieved without an existing conflict, the request will succeed. Otherwise, the server will return either NFS4ERR_DENIED or NFS4ERR_DEADLOCK. The error NFS4ERR_DEADLOCK is returned if the client issued the LOCK request with the type set to WRITEW_LT and the server has detected a deadlock. The client should be prepared to receive such errors and, if appropriate, report them to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントがレコードに読み取りロックを持っている場合、タイプをWRITE_LTまたはWRITEW_LTに設定することで、LOCKリクエストを介してロックの書き込みロックへのアトミックアップグレードを要求できます。サーバーがアトミックアップグレードをサポートしていない場合、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。既存の競合なしでアップグレードを達成できる場合、要求は成功します。それ以外の場合、サーバーはNFS4ERR_DENIEDまたはNFS4ERR_DEADLOCKを返します。クライアントがタイプをWRITEW_LTに設定してLOCK要求を発行し、サーバーがデッドロックを検出した場合、エラーNFS4ERR_DEADLOCKが返されます。クライアントは、このようなエラーを受け取る準備ができており、必要に応じて、要求元のアプリケーションにエラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. Blocking Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. ロックのブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some clients require the support of blocking locks. The NFSv4 protocol must not rely on a callback mechanism and therefore is unable to notify a client when a previously denied lock has been granted. Clients have no choice but to continually poll for the lock. This presents a fairness problem. Two new lock types are added, READW and WRITEW, and are used to indicate to the server that the client is requesting a blocking lock. The server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait the lease period for the first waiting client to re-request the lock. After the lease period expires, the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks, as it is not used to provide correct operation but only to increase fairness. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some clients require the support of blocking locks. The NFSv4 protocol must not rely on a callback mechanism and therefore is unable to notify a client when a previously denied lock has been granted. Clients have no choice but to continually poll for the lock. This presents a fairness problem. Two new lock types are added, READW and WRITEW, and are used to indicate to the server that the client is requesting a blocking lock. The server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait the lease period for the first waiting client to re-request the lock. After the lease period expires, the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks, as it is not used to provide correct operation but only to increase fairness. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may also note the lock types and delay returning denial of the request to allow extra time for a conflicting lock to be released, allowing a successful return. In this way, clients can avoid the burden of needlessly frequent polling for blocking locks. The server should take care with the length of delay in the event that the client retransmits the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ロックのタイプを記録し、要求の拒否の拒否を遅らせて、競合するロックが解放されるまでの時間を追加して、正常な戻りを可能にすることもできます。このようにして、クライアントは、ロックをブロックするための不必要に頻繁なポーリングの負担を回避できます。サーバーは、クライアントが要求を再送信する場合の遅延の長さに注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server receives a blocking lock request, denies it, and then later receives a non-blocking request for the same lock, which is also denied, then it should remove the lock in question from its list of pending blocking locks. Clients should use such a non-blocking request to indicate to the server that this is the last time they intend to poll for the lock, as may happen when the process requesting the lock is interrupted. This is a courtesy to the server, to prevent it from unnecessarily waiting a lease period before granting other lock requests. However, clients are not required to perform this courtesy, and servers must not depend on them doing so. Also, clients must be prepared for the possibility that this final locking request will be accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがブロッキングロックリクエストを受信して​​拒否し、その後同じロックに対する非ブロッキングリクエストを受信した場合も同様に拒否され、保留中のブロッキングロックのリストから問題のロックを削除する必要があります。クライアントは、このような非ブロッキング要求を使用して、ロックを要求するプロセスが中断された場合に発生する可能性があるように、これがロックをポーリングする最後の時刻であることをサーバーに示す必要があります。これは、他のロック要求を許可する前にリース期間を不必要に待機しないようにするためのサーバーの礼儀です。ただし、クライアントはこの礼儀を実行する必要はなく、サーバーはクライアントに依存することはできません。また、クライアントは、この最後のロック要求が受け入れられる可能性に備える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. Lease Renewal
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. リース更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of a lease is to allow a server to remove stale locks that are held by a client that has crashed or is otherwise unreachable. It is not a mechanism for cache consistency, and lease renewals may not be denied if the lease interval has not expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースの目的は、クラッシュしたクライアントや他の方法で到達できないクライアントが保持している古いロックをサーバーが削除できるようにすることです。これはキャッシュの整合性のメカニズムではなく、リース間隔が経過していない場合、リースの更新が拒否されない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can implicitly provide a positive indication that it is still active and that the associated state held at the server, for the client, is still valid. Any operation made with a valid clientid (DELEGPURGE, LOCK, LOCKT, OPEN, RELEASE_LOCKOWNER, or RENEW) or a valid stateid (CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, OPEN_CONFIRM, OPEN_DOWNGRADE, READ, SETATTR, or WRITE) informs the server to renew all of the leases for that client (i.e., all those sharing a given client ID). In the latter case, the stateid must not be one of the special stateids (anonymous stateid or READ bypass stateid).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、それがまだアクティブであり、クライアントでサーバーに保持されている関連する状態がまだ有効であることを示す肯定的な指示を暗黙的に提供できます。有効なclientid（DELEGPURGE、LOCK、LOCKT、OPEN、RELEASE_LOCKOWNER、またはRENEW）または有効なstateid（CLOSE、DELEGRETURN、LOCK、LOCKU、OPEN、OPEN_CONFIRM、OPEN_DOWNGRADE、READ、SETATTR、またはWRITE）で行われた操作はサーバーに通知しますそのクライアントのリースをすべて更新します（つまり、特定のクライアントIDを共有するすべてのリース）。後者の場合、stateidは特別なstateid（匿名のstateidまたはREAD bypass stateid）の1つであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the client had restarted or rebooted, the client would not be making these requests without issuing the SETCLIENTID/ SETCLIENTID_CONFIRM sequence. The use of the SETCLIENTID/ SETCLIENTID_CONFIRM sequence (one that changes the client verifier) notifies the server to drop the locking state associated with the client. SETCLIENTID/SETCLIENTID_CONFIRM never renews a lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが再起動または再起動した場合、クライアントはSETCLIENTID / SETCLIENTID_CONFIRMシーケンスを発行せずにこれらの要求を作成しないことに注意してください。 SETCLIENTID / SETCLIENTID_CONFIRMシーケンス（クライアントベリファイアを変更するシーケンス）を使用すると、クライアントに関連付けられているロック状態を削除するようにサーバーに通知されます。 SETCLIENTID / SETCLIENTID_CONFIRMがリースを更新することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server has rebooted, the stateids (NFS4ERR_STALE_STATEID error) or the client ID (NFS4ERR_STALE_CLIENTID error) will not be valid, hence preventing spurious renewals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが再起動した場合、stateids（NFS4ERR_STALE_STATEIDエラー）またはクライアントID（NFS4ERR_STALE_CLIENTIDエラー）は無効になり、誤った更新を防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This approach allows for low-overhead lease renewal, which scales well. In the typical case, no extra RPCs are required for lease renewal, and in the worst case, one RPC is required every lease period (i.e., a RENEW operation). The number of locks held by the client is not a factor since all state for the client is involved with the lease renewal action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプローチにより、オーバーヘッドの少ないリースの更新が可能になり、拡張性が向上します。一般的なケースでは、リースの更新に追加のRPCは必要ありません。最悪の場合、リース期間ごとに1つのRPCが必要です（つまり、RENEW操作）。クライアントのすべての状態はリースの更新アクションに関係しているため、クライアントが保持しているロックの数は要因ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since all operations that create a new lease also renew existing leases, the server must maintain a common lease expiration time for all valid leases for a given client. This lease time can then be easily updated upon implicit lease renewal actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいリースを作成するすべての操作は既存のリースも更新するため、サーバーは、特定のクライアントのすべての有効なリースについて、共通のリース有効期限を維持する必要があります。このリース時間は、暗黙のリース更新アクションで簡単に更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. Crash Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. クラッシュリカバリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The important requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts or reboots. All READ and WRITE operations that may have been queued within the client or network buffers must wait until the client has successfully recovered the locks protecting the READ and WRITE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラッシュリカバリの重要な要件は、クライアントとサーバーの両方が、もう一方に障害が発生したことを認識していることです。さらに、サーバーの再起動または再起動後も、クライアントはデータの一貫したビューを見る必要があります。クライアントまたはネットワークバッファー内でキューに入れられた可能性のあるすべてのREADおよびWRITE操作は、クライアントがREADおよびWRITE操作を保護するロックを正常に回復するまで待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.1. Client Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.1. クライアントの障害と回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that a client fails, the server may recover the client&#39;s locks when the associated leases have expired. Conflicting locks from another client may only be granted after this lease expiration. If the client is able to restart or reinitialize within the lease period, the client may be forced to wait the remainder of the lease period before obtaining new locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに障害が発生した場合、関連するリースの有効期限が切れると、サーバーはクライアントのロックを回復できます。別のクライアントからの競合するロックは、このリースの有効期限が切れた後にのみ許可されます。クライアントがリース期間内に再起動または再初期化できる場合、クライアントは、新しいロックを取得する前に、リース期間の残りの期間を待機せざるを得ない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To minimize client delay upon restart, open and lock requests are associated with an instance of the client by a client-supplied verifier. This verifier is part of the initial SETCLIENTID call made by the client. The server returns a client ID as a result of the SETCLIENTID operation. The client then confirms the use of the client ID with SETCLIENTID_CONFIRM. The client ID in combination with an opaque owner field is then used by the client to identify the open-owner for OPEN. This chain of associations is then used to identify all locks for a particular client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再起動時のクライアントの遅延を最小限に抑えるために、オープンおよびロック要求は、クライアント提供のベリファイアによってクライアントのインスタンスに関連付けられます。このベリファイアは、クライアントが行った最初のSETCLIENTID呼び出しの一部です。サーバーは、SETCLIENTID操作の結果としてクライアントIDを返します。次にクライアントは、SETCLIENTID_CONFIRMを使用してクライアントIDの使用を確認します。次に、クライアントは、不透明な所有者フィールドと組み合わせたクライアントIDを使用して、OPENのオープン所有者を識別します。この関連付けのチェーンは、特定のクライアントのすべてのロックを識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the verifier will be changed by the client upon each initialization, the server can compare a new verifier to the verifier associated with currently held locks and determine that they do not match. This signifies the client&#39;s new instantiation and subsequent loss of locking state. As a result, the server is free to release all locks held that are associated with the old client ID that was derived from the old verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアは初期化のたびにクライアントによって変更されるため、サーバーは新しいベリファイアを現在保持されているロックに関連付けられているベリファイアと比較し、それらが一致しないことを確認できます。これは、クライアントの新しいインスタンス化とその後のロック状態の喪失を意味します。その結果、サーバーは、古いベリファイアから派生した古いクライアントIDに関連付けられている、保持されているすべてのロックを解放できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the verifier must have the same uniqueness properties of the verifier for the COMMIT operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアには、COMMIT操作のベリファイアと同じ一意性プロパティが必要であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.2. Server Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.2. サーバーの障害と回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If the server loses locking state (usually as a result of a restart or reboot), it must allow clients time to discover this fact and re-establish the lost locking state. The client must be able to re-establish the locking state without having the server deny valid requests because the server has granted conflicting access to another client. Likewise, if there is the possibility that clients have not yet re-established their locking state for a file, the server must disallow READ and WRITE operations for that file. The duration of this recovery period is equal to the duration of the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーがロック状態を失うと（通常は再起動または再起動の結果として）、クライアントがこの事実を発見して、失われたロック状態を再確立できるようにする必要があります。サーバーは別のクライアントに競合するアクセスを許可しているため、サーバーは有効な要求を拒否せずに、クライアントはロック状態を再確立できる必要があります。同様に、クライアントがファイルのロック状態をまだ再確立していない可能性がある場合、サーバーはそのファイルのREADおよびWRITE操作を禁止する必要があります。この回復期間の期間は、リース期間の期間と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can determine that server failure (and thus loss of locking state) has occurred, when it receives one of two errors. The NFS4ERR_STALE_STATEID error indicates a stateid invalidated by a reboot or restart. The NFS4ERR_STALE_CLIENTID error indicates a client ID invalidated by reboot or restart. When either of these is received, the client must establish a new client ID (see Section 9.1.1) and re-establish the locking state as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、2つのエラーのいずれかを受け取ったときに、サーバー障害（およびロック状態の喪失）が発生したと判断できます。 NFS4ERR_STALE_STATEIDエラーは、再起動または再起動によって無効にされた状態IDを示します。 NFS4ERR_STALE_CLIENTIDエラーは、クライアントIDが再起動または再起動によって無効化されたことを示します。これらのいずれかが受信されると、クライアントは新しいクライアントID（セクション9.1.1を参照）を確立し、以下で説明するようにロック状態を再確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The period of special handling of locking and READs and WRITEs, equal in duration to the lease period, is referred to as the &#34;grace period&#34;. During the grace period, clients recover locks and the associated state by reclaim-type locking requests (i.e., LOCK requests with reclaim set to TRUE and OPEN operations with a claim type of either CLAIM_PREVIOUS or CLAIM_DELEGATE_PREV). During the grace period, the server must reject READ and WRITE operations and non-reclaim locking requests (i.e., other LOCK and OPEN operations) with an error of NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックとREADおよびWRITEの特別な処理の期間は、リース期間と同じ長さで、「猶予期間」と呼ばれます。猶予期間中、クライアントは再利用タイプのロックリクエスト（つまり、再利用がTRUEに設定されたLOCKリクエストと、CLAIM_PREVIOUSまたはCLAIM_DELEGATE_PREVのいずれかのクレームタイプのOPEN操作）によって、ロックと関連する状態を回復します。猶予期間中、サーバーはREADおよびWRITE操作と非再利用ロック要求（つまり、他のLOCKおよびOPEN操作）をNFS4ERR_GRACEのエラーで拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server can reliably determine that granting a non-reclaim request will not conflict with reclamation of locks by other clients, the NFS4ERR_GRACE error does not have to be returned and the non-reclaim client request can be serviced. For the server to be able to service READ and WRITE operations during the grace period, it must again be able to guarantee that no possible conflict could arise between an impending reclaim locking request and the READ or WRITE operation. If the server is unable to offer that guarantee, the NFS4ERR_GRACE error must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非再利用リクエストの許可が他のクライアントによるロックの再利用と競合しないことをサーバーが確実に判断できる場合、NFS4ERR_GRACEエラーを返す必要はなく、非再利用クライアントリクエストを処理できます。サーバーが猶予期間中にREADおよびWRITE操作を処理できるようにするには、差し迫った再利用ロック要求とREADまたはWRITE操作の間に起こり得る競合が発生しないことを保証できる必要があります。サーバーがその保証を提供できない場合は、NFS4ERR_GRACEエラーをクライアントに返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a server to provide simple, valid handling during the grace period, the easiest method is to simply reject all non-reclaim locking requests and READ and WRITE operations by returning the NFS4ERR_GRACE error. However, a server may keep information about granted locks in stable storage. With this information, the server could determine if a regular lock or READ or WRITE operation can be safely processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが猶予期間中に単純で有効な処理を提供するための最も簡単な方法は、NFS4ERR_GRACEエラーを返すことにより、すべての非再利用ロック要求とREADおよびWRITE操作を単に拒否することです。ただし、サーバーは、許可されたロックに関する情報を安定したストレージに保持する場合があります。この情報を使用して、サーバーは、通常のロックまたはREADまたはWRITE操作を安全に処理できるかどうかを判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For example, if a count of locks on a given file is available in stable storage, the server can track reclaimed locks for the file, and when all reclaims have been processed, non-reclaim locking requests may be processed. This way, the server can ensure that non-reclaim locking requests will not conflict with potential reclaim requests. With respect to I/O requests, if the server is able to determine that there are no outstanding reclaim requests for a file by information from stable storage or another similar mechanism, the processing of I/O requests could proceed normally for the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
たとえば、特定のファイルのロックの数が安定したストレージで利用できる場合、サーバーはファイルの再利用されたロックを追跡でき、すべての再利用が処理されると、非再利用のロック要求が処理される場合があります。このようにして、サーバーは非再利用ロック要求が潜在的な再利用要求と競合しないようにすることができます。 I / O要求に関して、サーバーが安定したストレージまたは他の同様のメカニズムからの情報によってファイルの未解決の再利用要求がないと判断できる場合、I / O要求の処理はファイルに対して正常に続行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To reiterate, for a server that allows non-reclaim lock and I/O requests to be processed during the grace period, it MUST determine that no lock subsequently reclaimed will be rejected and that no lock subsequently reclaimed would have prevented any I/O operation processed during the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
繰り返しますが、非再利用ロックとI / O要求が猶予期間中に処理されることを許可するサーバーでは、その後再利用されるロックは拒否されず、その後再利用されるロックはI / O操作を妨げなかったと判断する必要があります。猶予期間中に処理されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should be prepared for the return of NFS4ERR_GRACE errors for non-reclaim lock and I/O requests. In this case, the client should employ a retry mechanism for the request. A delay (on the order of several seconds) between retries should be used to avoid overwhelming the server. Further discussion of the general issue is included in [Floyd]. The client must account for the server that is able to perform I/O and non-reclaim locking requests within the grace period as well as those that cannot do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、非再利用ロックおよびI / O要求に対してNFS4ERR_GRACEエラーが返されるように準備する必要があります。この場合、クライアントは要求に対して再試行メカニズムを採用する必要があります。サーバーが過負荷にならないように、再試行間の遅延（数秒程度）を使用する必要があります。一般的な問題の詳細については、[Floyd]に記載されています。クライアントは、猶予期間内にI / Oおよび非再利用ロック要求を実行できるサーバーと、そうできないサーバーを説明する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reclaim-type locking request outside the server&#39;s grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since reboot or restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reclaim-type locking request outside the server&#39;s grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since reboot or restart.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server may, upon restart, establish a new value for the lease period. Therefore, clients should, once a new client ID is established, refetch the lease_time attribute and use it as the basis for lease renewal for the lease associated with that server. However, the server must establish, for this restart event, a grace period at least as long as the lease period for the previous server instantiation. This allows the client state obtained during the previous server instance to be reliably re-established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、再起動時に、リース期間の新しい値を確立できます。したがって、クライアントは、新しいクライアントIDが確​​立されたら、lease_time属性を再フェッチして、そのサーバーに関連付けられているリースのリース更新の基礎として使用する必要があります。ただし、サーバーは、この再起動イベントに対して、少なくとも前回のサーバーのインスタンス化のリース期間と同じくらいの猶予期間を確立する必要があります。これにより、前のサーバーインスタンスで取得したクライアントの状態を確実に再確立できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3. Network Partitions and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3. ネットワークパーティションとリカバリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the duration of a network partition is greater than the lease period provided by the server, the server will have not received a lease renewal from the client. If this occurs, the server may cancel the lease and free all locks held for the client. As a result, all stateids held by the client will become invalid or stale. Once the client is able to reach the server after such a network partition, all I/O submitted by the client with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once this error is received, the client will suitably notify the application that held the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションの期間がサーバーによって提供されるリース期間よりも長い場合、サーバーはクライアントからリースの更新を受信して​​いません。これが発生した場合、サーバーはリースをキャンセルし、クライアントのために保持していたすべてのロックを解放します。その結果、クライアントが保持するすべての状態IDが無効または古くなります。このようなネットワークパーティションの後でクライアントがサーバーに到達すると、無効な状態IDでクライアントから送信されたすべてのI / Oが失敗し、サーバーはエラーNFS4ERR_EXPIREDを返します。このエラーが受信されると、クライアントは、ロックを保持していたアプリケーションに適切に通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.1. Courtesy Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.1. 礼儀ロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a courtesy to the client or as an optimization, the server may continue to hold locks, including delegations, on behalf of a client for which recent communication has extended beyond the lease period, delaying the cancellation of the lease. If the server receives a lock or I/O request that conflicts with one of these courtesy locks or if it runs out of resources, the server MAY cause lease cancellation to occur at that time and henceforth return NFS4ERR_EXPIRED when any of the stateids associated with the freed locks is used. If lease cancellation has not occurred and the server receives a lock or I/O request that conflicts with one of the courtesy locks, the requirements are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントへの礼儀として、または最適化として、サーバーは、最近の通信がリース期間を超えて延長されたクライアントに代わって、委任を含むロックを保持し続け、リースのキャンセルを遅らせます。サーバーがこれらのサービスロックのいずれかと競合するロックまたはI / O要求を受信した場合、またはリソースが不足した場合、サーバーはその時点でリースのキャンセルを発生させ、それ以降、解放されたロックが使用されます。リースのキャンセルが行われておらず、サーバーがロックまたはI / O要求を受信して​​、サービスロックのいずれかと競合する場合、要件は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case of a courtesy lock that is not a delegation, it MUST free the courtesy lock and grant the new request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任ではないサービスロックの場合は、サービスロックを解放し、新しいリクエストを許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case of a lock or an I/O request that conflicts with a delegation that is being held as a courtesy lock, the server MAY delay resolution of the request but MUST NOT reject the request and MUST free the delegation and grant the new request eventually.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 礼儀ロックとして保持されている委任と競合するロックまたはI / O要求の場合、サーバーは要求の解決を遅らせてもよいが、要求を拒否してはならず、委任を解放して新しい要求を許可しなければならない（MUST）最終的に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case of a request for a delegation that conflicts with a delegation that is being held as a courtesy lock, the server MAY grant the new request or not as it chooses, but if it grants the conflicting request, the delegation held as a courtesy lock MUST be freed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 礼儀ロックとして保持されている委任と競合する委任の要求の場合、サーバーは選択したとおりに新しい要求を許可するかどうかは問わないが、競合する要求を許可する場合、委任は礼儀として保持されるロックを解放する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not reboot or cancel the lease before the network partition is healed, when the original client tries to access a courtesy lock that was freed, the server SHOULD send back an NFS4ERR_BAD_STATEID to the client. If the client tries to access a courtesy lock that was not freed, then the server SHOULD mark all of the courtesy locks as implicitly being renewed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションが修復される前にサーバーが再起動またはリースをキャンセルしない場合、元のクライアントが解放されたサービスロックにアクセスしようとすると、サーバーはクライアントにNFS4ERR_BAD_STATEIDを送信する必要があります（SHOULD）。クライアントが解放されなかったサービスロックにアクセスしようとすると、サーバーはサービスロックのすべてに暗黙的に更新されるものとしてマークを付ける必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.2. Lease Cancellation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.2. リースキャンセル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result of lease expiration, leases may be canceled, either immediately upon expiration or subsequently, depending on the occurrence of a conflicting lock or extension of the period of partition beyond what the server will tolerate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースの有効期限の結果として、競合するロックの発生、またはサーバーが許容できる範囲を超えたパーティション期間の延長に応じて、有効期限が切れると同時に、またはその後に、リースがキャンセルされる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a lease is canceled, all locking state associated with it is freed, and the use of any of the associated stateids will result in NFS4ERR_EXPIRED being returned. Similarly, the use of the associated clientid will result in NFS4ERR_EXPIRED being returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースがキャンセルされると、それに関連付けられたすべてのロック状態が解放され、関連付けられた任意の状態IDを使用すると、NFS4ERR_EXPIREDが返されます。同様に、関連するclientidを使用すると、NFS4ERR_EXPIREDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should recover from this situation by using SETCLIENTID followed by SETCLIENTID_CONFIRM, in order to establish a new clientid. Once a lock is obtained using this clientid, a lease will be established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、新しいクライアントIDを確立するために、SETCLIENTIDに続いてSETCLIENTID_CONFIRMを使用して、この状況から回復する必要があります。このclientidを使用してロックが取得されると、リースが確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.3. Client&#39;s Reaction to a Freed Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.3. Client&#39;s Reaction to a Freed Lock
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no way for a client to predetermine how a given server is going to behave during a network partition. When the partition heals, the client still has either all of its locks, some of its locks, or none of them. The client will be able to examine the various error return values to determine its response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがネットワークパーティション中に特定のサーバーがどのように動作するかを事前に決定する方法はありません。パーティションが回復しても、クライアントはすべてのロックを持っているか、一部のロックを持っているか、まったく持っていません。クライアントは、さまざまなエラー戻り値を調べて、その応答を判別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXPIRED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXPIRED：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
All locks have been freed as a result of a lease cancellation that occurred during the partition. The client should use a SETCLIENTID to recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パーティション中に発生したリースのキャンセルの結果、すべてのロックが解放されました。クライアントはSETCLIENTIDを使用して回復する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ADMIN_REVOKED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ADMIN_REVOKED:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The current lock has been revoked before, during, or after the partition. The client SHOULD handle this error as it normally would.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
現在のロックは、パーティションの前、間、または後に取り消されました。クライアントは、通常どおりにこのエラーを処理する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_STATEID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_STATEID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The current lock has been revoked/released during the partition, and the server did not reboot. Other locks MAY still be renewed. The client need not do a SETCLIENTID and instead SHOULD probe via a RENEW call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パーティション中に現在のロックが取り消されたか、解放されました。サーバーは再起動しませんでした。他のロックは引き続き更新される場合があります。クライアントはSETCLIENTIDを実行する必要はなく、代わりにRENEW呼び出しを介してプローブする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_BAD:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_BAD：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The current lock has been revoked during the partition, and the server rebooted. The server might have no information on the other locks. They may still be renewable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The current lock has been revoked during the partition, and the server rebooted. The server might have no information on the other locks. They may still be renewable.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NO_GRACE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NO_GRACE：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client&#39;s locks have been revoked during the partition, and the server rebooted. None of the client&#39;s locks will be renewable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パーティション中にクライアントのロックが取り消され、サーバーが再起動しました。クライアントのロックはどれも更新できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OLD_STATEID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OLD_STATEID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server has not rebooted. The client SHOULD handle this error as it normally would.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは再起動していません。クライアントは、通常どおりにこのエラーを処理する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4. Edge Conditions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4. エッジ条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition is combined with a server reboot, then both the server and client have responsibilities to ensure that the client does not reclaim a lock that it should no longer be able to access. Briefly, those are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションをサーバーの再起動と組み合わせると、サーバーとクライアントの両方に、クライアントがアクセスできなくなったロックを再利用しないようにする責任があります。簡単に言えば、それらは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client&#39;s responsibility: A client MUST NOT attempt to reclaim any locks that it did not hold at the end of its most recent successfully established client lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントの責任：クライアントは、正常に確立された最新のクライアントリースの最後に保持しなかったロックを取り戻そうとしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server&#39;s responsibility: A server MUST NOT allow a client to reclaim a lock unless it knows that it could not have since granted a conflicting lock. However, in deciding whether a conflicting lock could have been granted, it is permitted to assume that its clients are responsible, as above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーの責任：サーバーは、競合するロックを許可できなかったことがわかっていない限り、クライアントがロックを取り戻すことを許可してはなりません。ただし、競合するロックが許可されている可能性があるかどうかを判断する場合、上記のように、そのクライアントに責任があると想定することが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server may consider a client&#39;s lease &#34;successfully established&#34; once it has received an OPEN operation from that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントからOPEN操作を受信すると、クライアントのリースが「正常に確立された」と見なします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above are directed to CLAIM_PREVIOUS reclaims and not to CLAIM_DELEGATE_PREV reclaims, which generally do not involve a server reboot. However, when a server persistently stores delegation information to support CLAIM_DELEGATE_PREV across a period in which both client and server are down at the same time, similar strictures apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記は、CLAIM_PREVIOUS再利用に関するものであり、一般にサーバーの再起動を必要としないCLAIM_DELEGATE_PREV再利用に関するものではありません。ただし、サーバーが委任情報を永続的に保存して、クライアントとサーバーの両方が同時にダウンしている期間にわたってCLAIM_DELEGATE_PREVをサポートする場合、同様の制限が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next sections give examples showing what can go wrong if these responsibilities are neglected and also provide examples of server implementation strategies that could meet a server&#39;s responsibilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、これらの責任が無視された場合に問題が発生する可能性があることを示す例と、サーバーの責任を満たすことができるサーバー実装戦略の例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.1. First Server Edge Condition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.1. 最初のサーバーエッジの状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first edge condition has the following scenario:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のエッジ条件には、次のシナリオがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Client A acquires a lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Client A acquires a lock.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Client A and the server experience mutual network partition, such that client A is unable to renew its lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. クライアントAとサーバーで相互ネットワークパーティションが発生しているため、クライアントAはリースを更新できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Client A&#39;s lease expires, so the server releases the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントAのリースが期限切れになるため、サーバーはロックを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Client B acquires a lock that would have conflicted with that of client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. クライアントBは、クライアントAのロックと競合するロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Client B releases the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Client B releases the lock.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. The server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. サーバーが再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The network partition between client A and the server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. クライアントAとサーバー間のネットワークパーティションが修復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Client A issues a RENEW operation and gets back an NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Client A reclaims its lock within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. クライアントAは、サーバーの猶予期間内にロックを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, at the final step, the server has erroneously granted client A&#39;s lock reclaim. If client B modified the object the lock was protecting, client A will experience object corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、最後のステップで、サーバーは誤ってクライアントAのロック再利用を許可しました。ロックが保護していたオブジェクトをクライアントBが変更した場合、クライアントAはオブジェクトの破損を経験します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.2. Second Server Edge Condition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.2. 2番目のサーバーエッジの状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second known edge condition follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目の既知のエッジ条件は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Client A acquires a lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントAがロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. サーバーが再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Client A and the server experience mutual network partition, such that client A is unable to reclaim its lock within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントAとサーバーは相互ネットワークパーティションを経験しているため、クライアントAは猶予期間内にロックを取り戻すことができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The server&#39;s reclaim grace period ends. Client A has no locks recorded on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. サーバーの再利用猶予期間が終了します。クライアントAには、サーバーに記録されたロックはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Client B acquires a lock that would have conflicted with that of client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. クライアントBは、クライアントAのロックと競合するロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Client B releases the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. クライアントBがロックを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The server reboots a second time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. サーバーがもう一度再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. The network partition between client A and the server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. クライアントAとサーバー間のネットワークパーティションが修復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Client A issues a RENEW operation and gets back an NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Client A reclaims its lock within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. クライアントAは、サーバーの猶予期間内にロックを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with the first edge condition, the final step of the scenario of the second edge condition has the server erroneously granting client A&#39;s lock reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のエッジ条件と同様に、2番目のエッジ条件のシナリオの最後のステップでは、サーバーが誤ってクライアントAにロックの再利用を許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.3. Handling Server Edge Conditions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.3. サーバーエッジ条件の処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In both of the above examples, the client attempts reclaim of a lock that it held at the end of its most recent successfully established lease; thus, it has fulfilled its responsibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のどちらの例でも、クライアントは、正常に確立された最新のリースの最後に保持していたロックの再利用を試みます。したがって、それはその責任を果たしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server, however, has failed, by granting a reclaim, despite having granted a conflicting lock since the reclaimed lock was last held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server, however, has failed, by granting a reclaim, despite having granted a conflicting lock since the reclaimed lock was last held.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Solving these edge conditions requires that the server either (1) assume after it reboots that an edge condition occurs, and thus return NFS4ERR_NO_GRACE for all reclaim attempts, or (2) record some information in stable storage. The amount of information the server records in stable storage is in inverse proportion to how harsh the server wants to be whenever the edge conditions occur. The server that is completely tolerant of all edge conditions will record in stable storage every lock that is acquired, removing the lock record from stable storage only when the lock is unlocked by the client and the lock&#39;s owner advances the sequence number such that the lock release is not the last stateful event for the owner&#39;s sequence. For the two aforementioned edge conditions, the harshest a server can be, and still support a grace period for reclaims, requires that the server record in stable storage some minimal information. For example, a server implementation could, for each client, save in stable storage a record containing:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエッジ条件を解決するには、サーバーが（1）再起動後にエッジ条件が発生したと想定し、すべての再利用試行に対してNFS4ERR_NO_GRACEを返すか、（2）安定したストレージに情報を記録する必要があります。サーバーが安定したストレージに記録する情報の量は、エッジ条件が発生するたびにサーバーがどの程度厳しくなりたいかに反比例します。すべてのエッジ条件を完全に許容するサーバーは、取得されたすべてのロックを安定したストレージに記録し、ロックがクライアントによってロック解除され、ロックの所有者がシーケンス番号を進めてロックが解放される場合にのみ、安定したストレージからロックレコードを削除します所有者のシーケンスの最後のステートフルイベントではありません。前述の2つのエッジ条件の場合、サーバーが最も過酷な状態であり、再利用の猶予期間をサポートするには、サーバーが最小限の情報を安定したストレージに記録する必要があります。たとえば、サーバーの実装では、クライアントごとに、以下を含むレコードを安定したストレージに保存できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the client&#39;s id string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのID文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a boolean that indicates if the client&#39;s lease expired or if there was administrative intervention (see Section 9.8) to revoke a byte-range lock, share reservation, or delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのリースが期限切れになったかどうか、またはバイト範囲ロック、共有予約、または委任を取り消すための管理上の介入（セクション9.8を参照）があったかどうかを示すブール値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a timestamp that is updated the first time after a server boot or reboot the client acquires byte-range locking, share reservation, or delegation state on the server. The timestamp need not be updated on subsequent lock requests until the server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a timestamp that is updated the first time after a server boot or reboot the client acquires byte-range locking, share reservation, or delegation state on the server. The timestamp need not be updated on subsequent lock requests until the server reboots.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server implementation would also record in stable storage the timestamps from the two most recent server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装では、最新の2つのサーバー再起動からのタイムスタンプも安定したストレージに記録されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the above record keeping, for the first edge condition, after the server reboots, the record that client A&#39;s lease expired means that another client could have acquired a conflicting record lock, share reservation, or delegation. Hence, the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE or NFS4ERR_RECLAIM_BAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の記録を保持すると仮定すると、最初のエッジ条件で、サーバーの再起動後、クライアントAのリースが期限切れになったという記録は、別のクライアントが競合するレコードロック、共有予約、または委任を取得した可能性があることを意味します。したがって、サーバーは、エラーNFS4ERR_NO_GRACEまたはNFS4ERR_RECLAIM_BADでクライアントAからの再利用を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the second edge condition, after the server reboots for a second time, the record that the client had an unexpired record lock, share reservation, or delegation established before the server&#39;s previous incarnation means that the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE or NFS4ERR_RECLAIM_BAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のエッジ条件の場合、サーバーが2回再起動した後、サーバーの以前のインカネーションの前にクライアントが期限切れのないレコードロック、共有予約、または委任を確立したというレコードは、サーバーがクライアントAからの再利用を拒否する必要があることを意味しますエラーNFS4ERR_NO_GRACEまたはNFS4ERR_RECLAIM_BAD。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the level and approach to record keeping, the server MUST implement one of the following strategies (which apply to reclaims of share reservations, byte-range locks, and delegations):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
記録保持のレベルとアプローチに関係なく、サーバーは次の戦略の1つを実装する必要があります（共有予約、バイト範囲ロック、および委任の再利用に適用されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Reject all reclaims with NFS4ERR_NO_GRACE. This is extremely harsh but is necessary if the server does not want to record lock state in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. NFS4ERR_NO_GRACEを使用してすべての再利用を拒否します。これは非常に厳しいですが、サーバーが安定したストレージにロック状態を記録したくない場合に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Record sufficient state in stable storage to meet its responsibilities. In doubt, the server should err on the side of being harsh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. その責任を満たすために、安定した保管場所に十分な状態を記録します。疑わしいことに、サーバーは過酷であるという誤解を招くはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In the event that, after a server reboot, the server determines that there is unrecoverable damage or corruption to stable storage, then for all clients and/or locks affected, the server MUST return NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーの再起動後、サーバーが安定したストレージに回復不可能な損傷または破損があると判断した場合、影響を受けるすべてのクライアントまたはロック、あるいはその両方について、サーバーはNFS4ERR_NO_GRACEを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.4. Client Edge Condition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.4. Client Edge Condition
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A third edge condition affects the client and not the server. If the server reboots in the middle of the client reclaiming some locks and then a network partition is established, the client might be in the situation of having reclaimed some, but not all, locks. In that case, a conservative client would assume that the non-reclaimed locks were revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3番目のエッジ条件は、サーバーではなくクライアントに影響します。一部のロックを再利用しているクライアントの途中でサーバーが再起動し、その後ネットワークパーティションが確立された場合、クライアントはすべてではなく一部のロックを再利用している可能性があります。その場合、保守的なクライアントは、再利用されていないロックが取り消されたと想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third known edge condition follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3番目の既知のエッジ条件は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Client A acquires a lock 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントAはロック1を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Client A acquires a lock 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Client A acquires a lock 2.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. サーバーが再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Client A issues a RENEW operation and gets back an NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Client A reclaims its lock 1 within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. クライアントAは、サーバーの猶予期間内にロック1を取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Client A and the server experience mutual network partition, such that client A is unable to reclaim its remaining locks within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. クライアントAとサーバーは相互ネットワークパーティションを経験するため、猶予期間内にクライアントAは残りのロックを再利用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The server&#39;s reclaim grace period ends.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. サーバーの再利用猶予期間が終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Client B acquires a lock that would have conflicted with client A&#39;s lock 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. クライアントBは、クライアントAのロックと競合するロックを取得します2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Client B releases the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. クライアントBがロックを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. The server reboots a second time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. サーバーがもう一度再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. The network partition between client A and the server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. クライアントAとサーバー間のネットワークパーティションが修復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. Client A issues a RENEW operation and gets back an NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
13. Client A reclaims both lock 1 and lock 2 within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
13. クライアントAは、サーバーの猶予期間内にロック1とロック2の両方を取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the last step, the client reclaims lock 2 as if it had held that lock continuously, when in fact a conflicting lock was granted to client B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後のステップで、実際には競合するロックがクライアントBに付与された場合、クライアントは、ロック2を継続的に保持しているかのようにロック2を取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This occurs because the client failed its responsibility, by attempting to reclaim lock 2 even though it had not held that lock at the end of the lease that was established by the SETCLIENTID after the first server reboot. (The client did hold lock 2 on a previous lease, but it is only the most recent lease that matters.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、最初のサーバーの再起動後にSETCLIENTIDによって確立されたリースの最後にロック2を保持していなくても、クライアントがロック2を再利用しようとしたために、クライアントがその責任を果たせなかったために発生します。 （クライアントは以前のリースでロック2を保持していましたが、問題になるのは最新のリースのみです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server could avoid this situation by rejecting the reclaim of lock 2. However, to do so accurately, it would have to ensure that additional information about individual locks held survives a reboot. Server implementations are not required to do that, so the client must not assume that the server will.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ロック2の再利用を拒否することでこの状況を回避できます。ただし、正確に行うには、保持されている個々のロックに関する追加情報が再起動後も維持されるようにする必要があります。サーバーの実装はこれを行う必要はないので、クライアントはサーバーがそうすることを想定してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead, a client MUST reclaim only those locks that it successfully acquired from the previous server instance, omitting any that it failed to reclaim before a new reboot. Thus, in the last step above, client A should reclaim only lock 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代わりに、クライアントは以前のサーバーインスタンスから正常に取得したロックのみを再利用する必要があり、新しい再起動前に再利用に失敗したロックは省略します。したがって、上記の最後のステップでは、クライアントAはロック1のみを取り戻す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.5. Client&#39;s Handling of Reclaim Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.5. 再利用エラーのクライアントの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A mandate for the client&#39;s handling of the NFS4ERR_NO_GRACE and NFS4ERR_RECLAIM_BAD errors is outside the scope of this specification, since the strategies for such handling are very dependent on the client&#39;s operating environment. However, one potential approach is described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのNFS4ERR_NO_GRACEおよびNFS4ERR_RECLAIM_BADエラーの処理の義務は、このような処理の戦略はクライアントの動作環境に大きく依存するため、この仕様の範囲外です。ただし、考えられるアプローチの1つを以下で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client&#39;s reclaim fails, it could examine the change attribute of the objects the client is trying to reclaim state for, and use that to determine whether to re-establish the state via normal OPEN or LOCK requests. This is acceptable, provided the client&#39;s operating environment allows it. In other words, the client implementer is advised to document the behavior for his users. The client could also inform the application that its byte-range lock or share reservations (whether they were delegated or not) have been lost, such as via a UNIX signal, a GUI pop-up window, etc. See Section 10.5 for a discussion of what the client should do for dealing with unreclaimed delegations on client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの再利用が失敗すると、クライアントは状態を再利用しようとしているオブジェクトの変更属性を調べ、その属性を使用して、通常のOPEN要求またはLOCK要求によって状態を再確立するかどうかを判断できます。これは、クライアントの動作環境で許可されている場合は許容されます。つまり、クライアントの実装者は、ユーザーの動作を文書化することをお勧めします。クライアントは、UNIX信号、GUIポップアップウィンドウなどを介して、バイト範囲ロックまたは共有予約（委任されているかどうかにかかわらず）が失われたことをアプリケーションに通知することもできます。詳細については、セクション10.5を参照してください。クライアントの状態に関する未回収の委任に対処するためにクライアントが行うべきことの説明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For further discussion of revocation of locks, see Section 9.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックの取り消しの詳細については、セクション9.8を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. Recovery from a Lock Request Timeout or Abort
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. ロックリクエストのタイムアウトまたは中止からの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event a lock request times out, a client may decide to not retry the request. The client may also abort the request when the process for which it was issued is terminated (e.g., in UNIX due to a signal). It is possible, though, that the server received the request and acted upon it. This would change the state on the server without the client being aware of the change. It is paramount that the client resynchronize state with the server before it attempts any other operation that takes a seqid and/or a stateid with the same state-owner. This is straightforward to do without a special resynchronize operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック要求がタイムアウトした場合、クライアントは要求を再試行しないことを決定できます。クライアントは、それが発行されたプロセスが終了したときに要求を中止することもできます（たとえば、UNIXでシグナルが原因で）。ただし、サーバーがリクエストを受信し、それを処理することは可能です。これにより、クライアントが変更を意識することなく、サーバーの状態が変更されます。クライアントが、seqidやstateidを取得する他の操作を実行する前に、サーバーが状態を再同期することが最も重要です。これは、特別な再同期操作なしで簡単に実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the server maintains the last lock request and response received on the state-owner, for each state-owner, the client should cache the last lock request it sent such that the lock request did not receive a response. From this, the next time the client does a lock operation for the state-owner, it can send the cached request, if there is one, and if the request was one that established state (e.g., a LOCK or OPEN operation), the server will return the cached result or, if it never saw the request, perform it. The client can follow up with a request to remove the state (e.g., a LOCKU or CLOSE operation). With this approach, the sequencing and stateid information on the client and server for the given state-owner will resynchronize, and in turn the lock state will resynchronize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、状態所有者で受信した最後のロック要求と応答を維持するため、状態所有者ごとに、クライアントが送信した最後のロック要求をキャッシュして、ロック要求が応答を受信しないようにする必要があります。これにより、次にクライアントが状態所有者に対してロック操作を行うときに、キャッシュされた要求があればそれを送信でき、要求がその確立された状態（たとえば、LOCKまたはOPEN操作）の場合は、サーバーはキャッシュされた結果を返すか、リクエストを確認したことがない場合は実行します。クライアントは、状態を削除する要求をフォローアップできます（LOCKUまたはCLOSE操作など）。このアプローチを使用すると、指定された状態所有者のクライアントとサーバーのシーケンス情報とstateid情報が再同期され、ロック状態が再同期されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. Server Revocation of Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. ロックのサーバー失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At any point, the server can revoke locks held by a client and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いつでも、サーバーはクライアントが保持しているロックを取り消すことができ、クライアントはこのイベントに備える必要があります。ロックが取り消されたか、取り消された可能性があることをクライアントが検出した場合、クライアントは自身とサーバーの間の状態情報を検証する責任があります。クライアントのロック状態を検証するとは、現在保持されている各ロックの状態を確認または再利用する必要があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first instance of lock revocation is upon server reboot or re-initialization. In this instance, the client will receive an error (NFS4ERR_STALE_STATEID or NFS4ERR_STALE_CLIENTID) and the client will proceed with normal crash recovery as described in the previous section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックの取り消しの最初のインスタンスは、サーバーの再起動時または再初期化時です。この場合、クライアントはエラー（NFS4ERR_STALE_STATEIDまたはNFS4ERR_STALE_CLIENTID）を受け取り、クライアントは前のセクションで説明したように通常のクラッシュリカバリを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second lock revocation event is the inability to renew the lease before expiration. While this is considered a rare or unusual event, the client must be prepared to recover. Both the server and client will be able to detect the failure to renew the lease and are capable of recovering without data corruption. For the server, it tracks the last renewal event serviced for the client and knows when the lease will expire. Similarly, the client must track operations that will renew the lease period. Using the time that each such request was sent and the time that the corresponding reply was received, the client should bound the time that the corresponding renewal could have occurred on the server and thus determine if it is possible that a lease period expiration could have occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のロック失効イベントは、有効期限が切れる前にリースを更新できないことです。これはまれまたは異常なイベントと見なされますが、クライアントは回復する準備をする必要があります。サーバーとクライアントの両方がリースの更新の失敗を検出でき、データを破損することなく回復できます。サーバーの場合、クライアントに提供された最後の更新イベントを追跡し、リースの期限が切れる時期を認識します。同様に、クライアントはリース期間を更新する操作を追跡する必要があります。そのような各要求が送信された時間と対応する応答が受信された時間を使用して、クライアントは、対応する更新がサーバーで発生する可能性がある時間をバインドし、リース期間の期限切れが発生する可能性があるかどうかを判断する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third lock revocation event can occur as a result of administrative intervention within the lease period. While this is considered a rare event, it is possible that the server&#39;s administrator has decided to release or revoke a particular lock held by the client. As a result of revocation, the client will receive an error of NFS4ERR_ADMIN_REVOKED. In this instance, the client may assume that only the state-owner&#39;s locks have been lost. The client notifies the lock holder appropriately. The client cannot assume that the lease period has been renewed as a result of a failed operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3番目のロック失効イベントは、リース期間内の管理者の介入の結果として発生する可能性があります。これはまれなイベントと考えられていますが、サーバーの管理者がクライアントによって保持されている特定のロックを解放または取り消すことを決定した可能性があります。失効の結果として、クライアントはNFS4ERR_ADMIN_REVOKEDのエラーを受け取ります。この場合、クライアントは、状態所有者のロックのみが失われたと想定する場合があります。クライアントはロックホルダーに適切に通知します。クライアントは、失敗した操作の結果としてリース期間が更新されたと想定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client determines the lease period may have expired, the client must mark all locks held for the associated lease as &#34;unvalidated&#34;. This means the client has been unable to re-establish or confirm the appropriate lock state with the server. As described in Section 9.6, there are scenarios in which the server may grant conflicting locks after the lease period has expired for a client. When it is possible that the lease period has expired, the client must validate each lock currently held to ensure that a conflicting lock has not been granted. The client may accomplish this task by issuing an I/O request; if there is no relevant I/O pending, a zero-length read specifying the stateid associated with the lock in question can be synthesized to trigger the renewal. If the response to the request is success, the client has validated all of the locks governed by that stateid and re-established the appropriate state between itself and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、リース期間が終了した可能性があると判断した場合、関連付けられたリースに対して保持されているすべてのロックを「未検証」としてマークする必要があります。これは、クライアントがサーバーとの適切なロック状態を再確立または確認できなかったことを意味します。セクション9.6で説明したように、クライアントのリース期間が終了した後、サーバーが競合するロックを許可するシナリオがあります。リース期間が終了した可能性がある場合、クライアントは現在保持されている各ロックを検証して、競合するロックが許可されていないことを確認する必要があります。クライアントは、I / O要求を発行してこのタスクを実行できます。保留中の関連するI / Oがない場合は、問題のロックに関連付けられた状態IDを指定する長さ0の読み取りを合成して、更新をトリガーできます。要求への応答が成功した場合、クライアントはその状態IDによって管理されるすべてのロックを検証し、クライアントとサーバーの間の適切な状態を再確立しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the I/O request is not successful, then one or more of the locks associated with the stateid were revoked by the server, and the client must notify the owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / O要求が成功しない場合、stateidに関連付けられた1つ以上のロックがサーバーによって取り消され、クライアントは所有者に通知する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. 予約を共有する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A share reservation is a mechanism to control access to a file. It is a separate and independent mechanism from byte-range locking. When a client opens a file, it issues an OPEN operation to the server specifying the type of access required (READ, WRITE, or BOTH) and the type of access to deny others (OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH). If the OPEN fails, the client will fail the application&#39;s open request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約は、ファイルへのアクセスを制御するメカニズムです。これは、バイト範囲ロックとは別の独立したメカニズムです。クライアントがファイルを開くと、必要なアクセスのタイプ（READ、WRITE、またはBOTH）と他を拒否するアクセスのタイプ（OPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTH）を指定して、OPEN操作をサーバーに発行します。 OPENが失敗すると、クライアントはアプリケーションのオープンリクエストに失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pseudo-code definition of the semantics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セマンティクスの疑似コード定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if (request.access == 0) return (NFS4ERR_INVAL) else if ((request.access &amp; file_state.deny) || (request.deny &amp; file_state.access)) return (NFS4ERR_DENIED)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if（request.access == 0）return（NFS4ERR_INVAL）else if（（request.access＆file_state.deny）||（request.deny＆file_state.access））return（NFS4ERR_DENIED）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This checking of share reservations on OPEN is done with no exception for an existing OPEN for the same open-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このOPENでの共有予約のチェックは、同じオープンオーナーの既存のOPENを例外として行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constants used for the OPEN and OPEN_DOWNGRADE operations for the access and deny fields are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスおよび拒否フィールドのOPENおよびOPEN_DOWNGRADE操作に使用される定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10. OPEN/CLOSE Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10. OPEN / CLOSE操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To provide correct share semantics, a client MUST use the OPEN operation to obtain the initial filehandle and indicate the desired access and what access, if any, to deny. Even if the client intends to use one of the special stateids (anonymous stateid or READ bypass stateid), it must still obtain the filehandle for the regular file with the OPEN operation so the appropriate share semantics can be applied. Clients that do not have a deny mode built into their programming interfaces for opening a file should request a deny mode of OPEN4_SHARE_DENY_NONE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
正しい共有セマンティクスを提供するには、クライアントはOPEN操作を使用して初期ファイルハンドルを取得し、必要なアクセスと拒否するアクセス（ある場合）を示す必要があります。クライアントが特別な状態ID（匿名状態IDまたはREADバイパス状態ID）の1つを使用する場合でも、適切な共有セマンティクスを適用できるように、OPEN操作で通常のファイルのファイルハンドルを取得する必要があります。ファイルを開くためのプログラミングインターフェイスに拒否モードが組み込まれていないクライアントは、OPEN4_SHARE_DENY_NONEの拒否モードを要求する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation with the CREATE flag also subsumes the CREATE operation for regular files as used in previous versions of the NFS protocol. This allows a create with a share to be done atomically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATEフラグを指定したOPEN操作は、NFSプロトコルの以前のバージョンで使用されていた通常のファイルのCREATE操作も含みます。これにより、共有を使用した作成をアトミックに実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLOSE operation removes all share reservations held by the open-owner on that file. If byte-range locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure, NFS4ERR_LOCKS_HELD, if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作は、そのファイルのオープンオーナーによって保持されているすべての共有予約を削除します。バイト範囲のロックが保持されている場合、クライアントはCLOSEを発行する前にすべてのロックを解放する必要があります（SHOULD）。サーバーはCLOSEですべての未解決のロックを解放してもかまいませんが、一部のサーバーは、バイト範囲のロックが保持されているファイルのCLOSEをサポートしない場合があります。 CLOSEの後にロックが存在する場合、サーバーは失敗、NFS4ERR_LOCKS_HELDを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOOKUP operation will return a filehandle without establishing any lock state on the server. Without a valid stateid, the server will assume that the client has the least access. For example, if one client opened a file with OPEN4_SHARE_DENY_BOTH and another client accesses the file via a filehandle obtained through LOOKUP, the second client could only read the file using the special READ bypass stateid. The second client could not WRITE the file at all because it would not have a valid stateid from OPEN and the special anonymous stateid would not be allowed access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUP操作は、サーバーでロック状態を確立せずにファイルハンドルを返します。有効な状態IDがない場合、サーバーはクライアントのアクセスが最小であると想定します。たとえば、あるクライアントがOPEN4_SHARE_DENY_BOTHを使用してファイルを開き、別のクライアントがLOOKUPを通じて取得したファイルハンドルを介してファイルにアクセスした場合、2番目のクライアントは特別なREADバイパス状態IDを使用してのみファイルを読み取ることができます。 OPENからの有効な状態IDがなく、特別な匿名の状態IDがアクセスを許可されていないため、2番目のクライアントはファイルをまったく書き込むことができませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10.1. Close and Retention of State Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10.1. 状態情報のクローズと保持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a CLOSE operation requests deallocation of a stateid, dealing with retransmission of the CLOSE may pose special difficulties, since the state information, which normally would be used to determine the state of the open file being designated, might be deallocated, resulting in an NFS4ERR_BAD_STATEID error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作はstateidの割り当て解除を要求するので、CLOSEの再送信を処理すると特別な問題が発生する可能性があります。通常、指定されているオープンファイルの状態を判断するために使用される状態情報が割り当て解除され、NFS4ERR_BAD_STATEIDが発生する可能性があるためです。エラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may deal with this problem in a number of ways. To provide the greatest degree of assurance that the protocol is being used properly, a server should, rather than deallocate the stateid, mark it as close-pending, and retain the stateid with this status, until later deallocation. In this way, a retransmitted CLOSE can be recognized since the stateid points to state information with this distinctive status, so that it can be handled without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこの問題をさまざまな方法で処理します。プロトコルが適切に使用されていることを最大限保証するには、サーバーは、stateidの割り当てを解除するのではなく、それをクローズペンディングとしてマークし、後で割り当てを解除するまで、stateidをこのステータスで保持する必要があります。このようにして、stateidがこの特徴的なステータスの状態情報を指すため、再送信されたCLOSEを認識でき、エラーなしで処理できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When adopting this strategy, a server should retain the state information until the earliest of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この戦略を採用する場合、サーバーは次の最も早い段階まで状態情報を保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Another validly sequenced request for the same open-owner, that is not a retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じオープンオーナーに対する有効にシーケンス化された別のリクエスト。これは再送信ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The time that an open-owner is freed by the server due to period with no activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 活動のない期間のために、オープンオーナーがサーバーによって解放された時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All locks for the client are freed as a result of a SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのすべてのロックは、SETCLIENTIDの結果として解放されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may avoid this complexity, at the cost of less complete protocol error checking, by simply responding NFS4_OK in the event of a CLOSE for a deallocated stateid, on the assumption that this case must be caused by a retransmitted close. When adopting this approach, it is desirable to at least log an error when returning a no-error indication in this situation. If the server maintains a reply-cache mechanism, it can verify that the CLOSE is indeed a retransmission and avoid error logging in most cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこの複雑さを回避できますが、プロトコルエラーチェックの完全性は低下しますが、割り当て解除された状態IDのCLOSEのイベントでNFS4_OKに応答するだけで、このケースは再送されたクローズが原因であると想定されます。このアプローチを採用する場合、この状況でエラーなしの表示を返すときは、少なくともエラーをログに記録することが望ましいです。サーバーが応答キャッシュメカニズムを維持している場合、CLOSEが実際に再送信であることを確認でき、ほとんどの場合、エラーログを回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11. Open Upgrade and Downgrade
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11. オープンアップグレードとダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an OPEN is done for a file and the open-owner for which the open is being done already has the file open, the result is to upgrade the open file status maintained on the server to include the access and deny bits specified by the new OPEN as well as those for the existing OPEN. The result is that there is one open file, as far as the protocol is concerned, and it includes the union of the access and deny bits for all of the OPEN requests completed. Only a single CLOSE will be done to reset the effects of both OPENs. Note that the client, when issuing the OPEN, may not know that the same file is in fact being opened. The above only applies if both OPENs result in the OPENed object being designated by the same filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルに対してOPENが行われ、オープンが行われているオープンオーナーがすでにファイルを開いている場合、結果はサーバー上で維持されているオープンファイルのステータスをアップグレードして、新しいファイルで指定されたアクセスおよび拒否ビットを含めます。 OPENおよび既存のOPENのOPEN。その結果、プロトコルに関する限り、1つのオープンファイルがあり、完了したすべてのOPEN要求のアクセスおよび拒否ビットの結合が含まれます。両方のOPENの影響をリセットするために、単一のCLOSEのみが実行されます。クライアントは、OPENを発行するときに、同じファイルが実際に開かれていることを認識していない場合があることに注意してください。上記は、両方のOPENの結果、OPENedオブジェクトが同じファイルハンドルによって指定される場合にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server chooses to export multiple filehandles corresponding to the same file object and returns different filehandles on two different OPENs of the same file object, the server MUST NOT &#34;OR&#34; together the access and deny bits and coalesce the two open files. Instead, the server must maintain separate OPENs with separate stateids and will require separate CLOSEs to free them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが同じファイルオブジェクトに対応する複数のファイルハンドルをエクスポートすることを選択し、同じファイルオブジェクトの2つの異なるOPENで異なるファイルハンドルを返す場合、サーバーはアクセスと拒否ビットを一緒に「OR」して、2つの開いているファイルを結合してはなりません（MUST NOT）。代わりに、サーバーは個別の状態IDを持つ個別のOPENを維持する必要があり、それらを解放するには個別のCLOSEが必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When multiple open files on the client are merged into a single open file object on the server, the close of one of the open files (on the client) may necessitate change of the access and deny status of the open file on the server. This is because the union of the access and deny bits for the remaining opens may be smaller (i.e., a proper subset) than previously. The OPEN_DOWNGRADE operation is used to make the necessary change, and the client should use it to update the server so that share reservation requests by other clients are handled properly. The stateid returned has the same &#34;other&#34; field as that passed to the server. The seqid value in the returned stateid MUST be incremented (Section 9.1.4), even in situations in which there has been no change to the access and deny bits for the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアント上の複数の開いているファイルがサーバー上の単一の開いているファイルオブジェクトにマージされると、開いているファイルの1つ（クライアント上）を閉じると、アクセスの変更とサーバー上の開いているファイルのステータスの拒否が必要になる場合があります。これは、残りのオープンのアクセスおよび拒否ビットの和集合が以前よりも小さい（つまり、適切なサブセットである）可能性があるためです。 OPEN_DOWNGRADE操作は必要な変更を行うために使用され、クライアントは他のクライアントによる共有予約要求が適切に処理されるようにサーバーを更新するためにそれを使用する必要があります。返された状態IDには、サーバーに渡されたものと同じ「その他」フィールドがあります。返されたstateidのseqid値は、ファイルのアクセスおよび拒否ビットが変更されていない状況でも、インクリメントする必要があります（セクション9.1.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.12. Short and Long Leases
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.12. 短期および長期リース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When determining the time period for the server lease, the usual lease trade-offs apply. Short leases are good for fast server recovery at a cost of increased RENEW or READ (with zero length) requests. Longer leases are certainly kinder and gentler to servers trying to handle very large numbers of clients. The number of RENEW requests drops in proportion to the lease time. The disadvantages of long leases are slower recovery after server failure (the server must wait for the leases to expire and the grace period to elapse before granting new lock requests) and increased file contention (if the client fails to transmit an unlock request, then the server must wait for lease expiration before granting new locks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーリースの期間を決定するときは、通常のリーストレードオフが適用されます。短いリースは、RENEWまたはREAD（長さが0の）要求の増加を犠牲にして、サーバーの高速回復に適しています。リースが長いほど、非常に多くのクライアントを処理しようとするサーバーにとって、より親切で穏やかになります。 RENEW要求の数は、リース時間に比例して減少します。長いリースの欠点は、サーバー障害後の回復が遅くなることです（サーバーは、リースが期限切れになり、猶予期間が経過するまで待機してから新しいロック要求を許可する必要があります）、ファイルの競合が増加します（クライアントがロック解除要求の送信に失敗した場合、サーバーは、新しいロックを許可する前にリースの期限切れを待つ必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Long leases are usable if the server is able to store lease state in non-volatile memory. Upon recovery, the server can reconstruct the lease state from its non-volatile memory and continue operation with its clients, and therefore long leases would not be an issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがリース状態を不揮発性メモリに保存できる場合は、長いリースを使用できます。リカバリ時に、サーバーはその不揮発性メモリからリース状態を再構築し、クライアントとの操作を続行できるため、長いリースは問題になりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.13. Clocks, Propagation Delay, and Calculating Lease Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.13. クロック、伝搬遅延、およびリースの有効期限の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid the need for synchronized clocks, lease times are granted by the server as a time delta. However, there is a requirement that the client and server clocks do not drift excessively over the duration of the lock. There is also the issue of propagation delay across the network -- which could easily be several hundred milliseconds -- as well as the possibility that requests will be lost and need to be retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期されたクロックの必要性を回避するために、リース時間はサーバーによってタイムデルタとして付与されます。ただし、クライアントとサーバーのクロックがロックの期間にわたって過度にドリフトしないという要件があります。また、ネットワーク全体での伝播遅延の問題（簡単に数百ミリ秒になることもあります）や、リクエストが失われ、再送信が必要になる可能性もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To take propagation delay into account, the client should subtract it from lease times (e.g., if the client estimates the one-way propagation delay as 200 msec, then it can assume that the lease is already 200 msec old when it gets it). In addition, it will take another 200 msec to get a response back to the server. So the client must send a lock renewal or write data back to the server 400 msec before the lease would expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
伝播遅延を考慮に入れるには、クライアントはそれをリース時間から差し引く必要があります（たとえば、クライアントが一方向の伝播遅延を200ミリ秒と推定した場合、リースを取得した時点でリースがすでに200ミリ秒古いと想定できます）。さらに、サーバーに応答を返すまでにさらに200ミリ秒かかります。したがって、リースが期限切れになる前に、クライアントはロック更新を送信するか、データをサーバーに400ミリ秒書き戻す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server&#39;s lease period configuration should take into account the network distance of the clients that will be accessing the server&#39;s resources. It is expected that the lease period will take into account the network propagation delays and other network delay factors for the client population. Since the protocol does not allow for an automatic method to determine an appropriate lease period, the server&#39;s administrator may have to tune the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーのリース期間の構成では、サーバーのリソースにアクセスするクライアントのネットワーク距離を考慮する必要があります。リース期間では、クライアントの人口に対するネットワークの伝播の遅延やその他のネットワークの遅延要因が考慮されることが予想されます。プロトコルでは適切なリース期間を決定するための自動方法が許可されていないため、サーバーの管理者はリース期間を調整する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14. Migration, Replication, and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14. 移行、複製、および状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When responsibility for handling a given file system is transferred to a new server (migration) or the client chooses to use an alternative server (e.g., in response to server unresponsiveness) in the context of file system replication, the appropriate handling of state shared between the client and server (i.e., locks, leases, stateids, and client IDs) is as described below. The handling differs between migration and replication. For a related discussion of file server state and recovery of same, see the subsections of Section 9.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のファイルシステムを処理する責任が新しいサーバーに移行される場合（移行）、またはクライアントがファイルシステムレプリケーションのコンテキストで代替サーバーを使用することを選択した場合（たとえば、サーバーの無応答に対応する場合）、クライアントとサーバー（つまり、ロック、リース、ステートID、およびクライアントID）は以下のとおりです。移行とレプリケーションでは処理が異なります。ファイルサーバーの状態とその回復の関連する説明については、セクション9.6のサブセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases in which one server is expected to accept opaque values from the client that originated from another server, the servers SHOULD encode the opaque values in big-endian byte order. If this is done, the new server will be able to parse values like stateids, directory cookies, filehandles, etc. even if their native byte order is different from that of other servers cooperating in the replication and migration of the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるサーバーが別のサーバーから発信されたクライアントからの不透明な値を受け入れると予想される場合、サーバーは不透明な値をビッグエンディアンバイトオーダーでエンコードする必要があります（SHOULD）。これを行うと、新しいサーバーは、ネイティブのバイト順がファイルシステムのレプリケーションと移行で連携している他のサーバーのバイト順と異なる場合でも、stateid、ディレクトリCookie、ファイルハンドルなどの値を解析できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.1. Migration and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.1. 移行と状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of migration, the servers involved in the migration of a file system SHOULD transfer all server state from the original server to the new server. This must be done in a way that is transparent to the client. This state transfer will ease the client&#39;s transition when a file system migration occurs. If the servers are successful in transferring all state, the client will continue to use stateids assigned by the original server. Therefore, the new server must recognize these stateids as valid. This holds true for the client ID as well. Since responsibility for an entire file system is transferred with a migration event, there is no possibility that conflicts will arise on the new server as a result of the transfer of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行の場合、ファイルシステムの移行に関与するサーバーは、すべてのサーバーの状態を元のサーバーから新しいサーバーに転送する必要があります（SHOULD）。これは、クライアントに対して透過的な方法で行う必要があります。この状態転送により、ファイルシステムの移行が発生したときのクライアントの移行が容易になります。サーバーがすべての状態の転送に成功した場合、クライアントは元のサーバーによって割り当てられた状態IDを引き続き使用します。したがって、新しいサーバーはこれらの状態IDを有効として認識する必要があります。これは、クライアントIDにも当てはまります。ファイルシステム全体の責任は移行イベントで転送されるため、ロックの転送の結果として新しいサーバーで競合が発生する可能性はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As part of the transfer of information between servers, leases would be transferred as well. The leases being transferred to the new server will typically have a different expiration time from those for the same client, previously on the old server. To maintain the property that all leases on a given server for a given client expire at the same time, the server should advance the expiration time to the later of the leases being transferred or the leases already present. This allows the client to maintain lease renewal of both classes without special effort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー間の情報転送の一部として、リースも転送されます。新しいサーバーに転送されるリースは、通常、以前のサーバーにあった同じクライアントのリースとは異なる有効期限があります。特定のクライアントの特定のサーバーのすべてのリースが同時に期限切れになるという特性を維持するには、サーバーは、転送されるリースまたはすでに存在するリースの遅い方に期限を早める必要があります。これにより、クライアントは特別な作業なしで両方のクラスのリース更新を維持できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The servers may choose not to transfer the state information upon migration. However, this choice is discouraged. In this case, when the client presents state information from the original server (e.g., in a RENEW operation or a READ operation of zero length), the client must be prepared to receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server. The client should then recover its state information as it normally would in response to a server failure. The new server must take care to allow for the recovery of state information as it would in the event of server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、移行時に状態情報を転送しないことを選択できます。ただし、この選択はお勧めできません。この場合、クライアントが元のサーバーから状態情報を提示するとき（たとえば、RENEW操作または長さがゼロのREAD操作）、クライアントは、新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDのいずれかを受信する準備をする必要があります。その後、クライアントは、サーバーの障害に応じて通常のように状態情報を回復する必要があります。新しいサーバーは、サーバーが再起動した場合と同様に、状態情報を回復できるように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client SHOULD re-establish new callback information with the new server as soon as possible, according to sequences described in Sections 16.33 and 16.34. This ensures that server operations are not blocked by the inability to recall delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション16.33と16.34で説明されているシーケンスに従って、クライアントはできるだけ早く新しいサーバーで新しいコールバック情報を再確立する必要があります。これにより、委任を呼び戻せないことによってサーバー操作がブロックされることがなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.2. Replication and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.2. レプリケーションと状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since client switch-over in the case of replication is not under server control, the handling of state is different. In this case, leases, stateids, and client IDs do not have validity across a transition from one server to another. The client must re-establish its locks on the new server. This can be compared to the re-establishment of locks by means of reclaim-type requests after a server reboot. The difference is that the server has no provision to distinguish requests reclaiming locks from those obtaining new locks or to defer the latter. Thus, a client re-establishing a lock on the new server (by means of a LOCK or OPEN request), may have the requests denied due to a conflicting lock. Since replication is intended for read-only use of file systems, such denial of locks should not pose large difficulties in practice. When an attempt to re-establish a lock on a new server is denied, the client should treat the situation as if its original lock had been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レプリケーションの場合のクライアントの切り替えはサーバーの制御下にないため、状態の処理は異なります。この場合、リース、ステートID、およびクライアントIDは、あるサーバーから別のサーバーへの移行にわたって有効ではありません。クライアントは、新しいサーバーでロックを再確立する必要があります。これは、サーバーの再起動後の再利用タイプの要求によるロックの再確立と比較できます。違いは、サーバーには、ロックを再利用する要求と新しいロックを取得する要求を区別したり、ロックを延期したりする機能がないことです。したがって、クライアントが（LOCKまたはOPEN要求によって）新しいサーバーでロックを再確立すると、競合するロックのために要求が拒否される場合があります。レプリケーションはファイルシステムの読み取り専用の使用を目的としているため、このようなロックの拒否は、実際には大きな困難をもたらすことはありません。新しいサーバーのロックを再確立する試みが拒否された場合、クライアントは、元のロックが取り消されたかのように状況を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.3. Notification of Migrated Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.3. 移行したリースの通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of lease renewal, the client may not be submitting requests for a file system that has been migrated to another server. This can occur because of the implicit lease renewal mechanism. The client renews leases for all file systems when submitting a request to any one file system at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースの更新の場合、クライアントは別のサーバーに移行されたファイルシステムのリクエストを送信していない可能性があります。これは、暗黙的なリース更新メカニズムが原因で発生する可能性があります。クライアントは、サーバーのいずれかのファイルシステムに要求を送信すると、すべてのファイルシステムのリースを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In order for the client to schedule renewal of leases that may have been relocated to the new server, the client must find out about lease relocation before those leases expire. To accomplish this, all operations that implicitly renew leases for a client (such as OPEN, CLOSE, READ, WRITE, RENEW, LOCK, and others) will return the error NFS4ERR_LEASE_MOVED if responsibility for any of the leases to be renewed has been transferred to a new server. This condition will continue until the client receives an NFS4ERR_MOVED error and the server receives the subsequent GETATTR(fs_locations) for an access to each file system for which a lease has been moved to a new server. By convention, the compound including the GETATTR(fs_locations) SHOULD append a RENEW operation to permit the server to identify the client doing the access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが新しいサーバーに再配置された可能性のあるリースの更新をスケジュールするためには、クライアントはそれらのリースの有効期限が切れる前にリースの再配置について調べる必要があります。これを実現するために、クライアントのリースを暗黙的に更新するすべての操作（OPEN、CLOSE、READ、WRITE、RENEW、LOCKなど）は、更新されるリースのいずれかの責任がに転送された場合、エラーNFS4ERR_LEASE_MOVEDを返します。新しいサーバー。この状態は、クライアントがNFS4ERR_MOVEDエラーを受け取り、サーバーが、リースが新しいサーバーに移動された各ファイルシステムへのアクセスに対する後続のGETATTR（fs_locations）を受け取るまで続きます。慣例により、GETATTR（fs_locations）を含むコンパウンドは、サーバーがアクセスを行うクライアントを識別できるようにRENEW操作を追加する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving the NFS4ERR_LEASE_MOVED error, a client that supports file system migration MUST probe all file systems from that server on which it holds open state. Once the client has successfully probed all those file systems that are migrated, the server MUST resume normal handling of stateful requests from that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LEASE_MOVEDエラーを受信すると、ファイルシステムの移行をサポートするクライアントは、オープン状態を保持しているサーバーからすべてのファイルシステムをプローブする必要があります。クライアントが移行されたすべてのファイルシステムのプローブに成功したら、サーバーはそのクライアントからのステートフルな要求の通常の処理を再開する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to support legacy clients that do not handle the NFS4ERR_LEASE_MOVED error correctly, the server SHOULD time out after a wait of at least two lease periods, at which time it will resume normal handling of stateful requests from all clients. If a client attempts to access the migrated files, the server MUST reply with NFS4ERR_MOVED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LEASE_MOVEDエラーを正しく処理しないレガシークライアントをサポートするために、サーバーは少なくとも2つのリース期間の待機後にタイムアウトする必要があり、その時点ですべてのクライアントからのステートフル要求の通常の処理を再開します。クライアントが移行されたファイルにアクセスしようとする場合、サーバーはNFS4ERR_MOVEDで応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client receives an NFS4ERR_MOVED error, the client can follow the normal process to obtain the new server information (through the fs_locations attribute) and perform renewal of those leases on the new server. If the server has not had state transferred to it transparently, the client will receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server, as described above. The client can then recover state information as it does in the event of server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_MOVEDエラーを受信すると、クライアントは通常のプロセスに従って（fs_locations属性を通じて）新しいサーバー情報を取得し、新しいサーバーでこれらのリースの更新を実行できます。サーバーが透過的に状態を転送していない場合、クライアントは、上記のように、新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDを受け取ります。その後、クライアントは、サーバーに障害が発生した場合と同様に、状態情報を回復できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.4. Migration and the lease_time Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.4. 移行とlease_time属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order that the client may appropriately manage its leases in the case of migration, the destination server must establish proper values for the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行時にクライアントがリースを適切に管理できるようにするために、移行先サーバーは、lease_time属性に適切な値を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When state is transferred transparently, that state should include the correct value of the lease_time attribute. The lease_time attribute on the destination server must never be less than that on the source since this would result in premature expiration of leases granted by the source server. Upon migration, in which state is transferred transparently, the client is under no obligation to refetch the lease_time attribute and may continue to use the value previously fetched (on the source server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態が透過的に転送される場合、その状態には、lease_time属性の正しい値が含まれている必要があります。ソースサーバーによって付与されたリースの期限切れが早まるため、宛先サーバーのlease_time属性をソースの属性よりも小さくすることはできません。移行時に状態が透過的に転送される場合、クライアントは、lease_time属性を再フェッチする義務はなく、以前にフェッチした値（ソースサーバー上）を引き続き使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If state has not been transferred transparently (i.e., the client sees a real or simulated server reboot), the client should fetch the value of lease_time on the new (i.e., destination) server and use it for subsequent locking requests. However, the server must respect a grace period at least as long as the lease_time on the source server, in order to ensure that clients have ample time to reclaim their locks before potentially conflicting non-reclaimed locks are granted. The means by which the new server obtains the value of lease_time on the old server is left to the server implementations. It is not specified by the NFSv4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
状態が透過的に転送されなかった場合（つまり、クライアントが実際のサーバーまたは再起動されたサーバーの再起動を確認した場合）、クライアントは新しい（つまり、宛先）サーバーのlease_timeの値をフェッチし、それを後続のロック要求に使用する必要があります。ただし、サーバーは、少なくともソースサーバーのlease_timeの間は猶予期間を尊重する必要があります。これにより、競合する可能性のある非再利用ロックが許可される前に、クライアントがロックを再利用する十分な時間を確保できます。新しいサーバーが古いサーバーのlease_timeの値を取得する方法は、サーバーの実装に任されています。 NFSv4プロトコルでは指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. クライアント側のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client-side caching of data, file attributes, and filenames is essential to providing good performance with the NFS protocol. Providing distributed cache coherence is a difficult problem, and previous versions of the NFS protocol have not attempted it. Instead, several NFS client implementation techniques have been used to reduce the problems that a lack of coherence poses for users. These techniques have not been clearly defined by earlier protocol specifications, and it is often unclear what is valid or invalid client behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ、ファイル属性、およびファイル名のクライアント側キャッシュは、NFSプロトコルで良好なパフォーマンスを提供するために不可欠です。分散キャッシュコヒーレンスを提供することは困難な問題であり、NFSプロトコルの以前のバージョンではこれを試みていません。代わりに、一貫性の欠如がユーザーにもたらす問題を軽減するために、いくつかのNFSクライアント実装手法が使用されています。これらの手法は、以前のプロトコル仕様では明確に定義されておらず、有効または無効なクライアントの動作が不明であることがよくあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol uses many techniques similar to those that have been used in previous protocol versions. The NFSv4 protocol does not provide distributed cache coherence. However, it defines a more limited set of caching guarantees to allow locks and share reservations to be used without destructive interference from client-side caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルは、以前のバージョンのプロトコルで使用されていたものと同様の多くの手法を使用します。 NFSv4プロトコルは、分散キャッシュの一貫性を提供しません。ただし、クライアント側のキャッシングによる破壊的な干渉なしにロックと共有の予約を使用できるように、より限定的なキャッシング保証のセットを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the NFSv4 protocol introduces a delegation mechanism that allows many decisions normally made by the server to be made locally by clients. This mechanism provides efficient support of the common cases where sharing is infrequent or where sharing is read-only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、NFSv4プロトコルは、サーバーによって通常行われる多くの決定がクライアントによってローカルで行われることを可能にする委任メカニズムを導入します。このメカニズムは、共有頻度が低い、または共有が読み取り専用である一般的なケースを効率的にサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Performance Challenges for Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. クライアント側キャッシュのパフォーマンスの課題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed, which classically increases the latency for cache revalidation requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFSプロトコルで使用されていたキャッシュ技術は、優れたパフォーマンスを提供することに成功しています。ただし、これらの手法を非常に多数のクライアントで使用する場合、いくつかのスケーラビリティの課題が発生する可能性があります。これは、クライアントが地理的に分散している場合に特に当てはまります。これにより、キャッシュの再検証リクエストのレイテンシが従来より長くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFSプロトコルは、ファイルが開かれたときにファイルデータキャッシュの検証要求を繰り返します。この動作は、パフォーマンスに重大な欠点をもたらす可能性があります。一般的なケースは、ファイルが単一のクライアントによってのみアクセスされる場合です。したがって、共有はまれです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, repeated reference to the server to find that no conflicts exist is expensive. A better option with regards to performance is to allow a client that repeatedly opens a file to do so without reference to the server. This is done until potentially conflicting operations from another client actually occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、サーバーを繰り返し参照して競合が存在しないことを確認すると、コストがかかります。パフォーマンスに関するより良いオプションは、サーバーを参照せずにファイルを繰り返し開くクライアントがファイルを開くことを許可することです。これは、別のクライアントからの潜在的に競合する操作が実際に発生するまで行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A similar situation arises in connection with file locking. Sending file lock and unlock requests to the server as well as the READ and WRITE requests necessary to make data caching consistent with the locking semantics (see Section 10.3.2) can severely limit performance. When locking is used to provide protection against infrequent conflicts, a large penalty is incurred. This penalty may discourage the use of file locking by applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルのロックに関しても同様の状況が発生します。ファイルのロックとロック解除のリクエストをサーバーに送信し、データのキャッシングをロックのセマンティクス（セクション10.3.2を参照）と一致させるために必要なREADおよびWRITEリクエストを送信すると、パフォーマンスが大幅に制限される可能性があります。まれな競合に対する保護を提供するためにロックを使用すると、大きなペナルティが発生します。このペナルティにより、アプリケーションによるファイルロックの使用が妨げられる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol provides more aggressive caching strategies with the following design goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルは、次の設計目標でより積極的なキャッシング戦略を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Compatibility with a large range of server semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 幅広いサーバーセマンティクスとの互換性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Providing the same caching benefits as previous versions of the NFS protocol when unable to provide the more aggressive model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o より積極的なモデルを提供できない場合、NFSプロトコルの以前のバージョンと同じキャッシュの利点を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Organizing requirements for aggressive caching so that a large portion of the benefit can be obtained even when not all of the requirements can be met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アグレッシブキャッシングの要件を整理して、要件のすべてが満たされなくても、メリットの大部分を獲得できるようにする。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The appropriate requirements for the server are discussed in later sections, in which specific forms of caching are covered (see Section 10.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの適切な要件については、後のセクションで説明します。このセクションでは、特定の形式のキャッシュについて説明します（セクション10.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Delegation and Callbacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 委任とコールバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recallable delegation of server responsibilities for a file to a client improves performance by avoiding repeated requests to the server in the absence of inter-client conflict. With the use of a &#34;callback&#34; RPC from server to client, a server recalls delegated responsibilities when another client engages in the sharing of a delegated file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルに対するサーバーの責任をクライアントに呼び戻せる委任は、クライアント間の競合がない場合にサーバーへの要求が繰り返されることを回避することにより、パフォーマンスを向上させます。サーバーからクライアントへの「コールバック」RPCを使用すると、サーバーは、他のクライアントが委任されたファイルの共有に従事するときに、委任された責任を呼び戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A delegation is passed from the server to the client, specifying the object of the delegation and the type of delegation. There are different types of delegations, but each type contains a stateid to be used to represent the delegation when performing operations that depend on the delegation. This stateid is similar to those associated with locks and share reservations but differs in that the stateid for a delegation is associated with a client ID and may be used on behalf of all the open-owners for the given client. A delegation is made to the client as a whole and not to any specific process or thread of control within it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
委任はサーバーからクライアントに渡され、委任のオブジェクトと委任のタイプが指定されます。委任にはさまざまなタイプがありますが、各タイプには、委任に依存する操作を実行するときに委任を表すために使用される状態IDが含まれています。この状態IDは、ロックと共有予約に関連付けられているものと似ていますが、委任の状態IDがクライアントIDに関連付けられており、特定のクライアントのすべてのオープン所有者の代わりに使用できるという点が異なります。委任はクライアント全体に対して行われ、その中の特定のプロセスや制御のスレッドに対しては行われません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because callback RPCs may not work in all environments (due to firewalls, for example), correct protocol operation does not depend on them. Preliminary testing of callback functionality by means of a CB_NULL procedure determines whether callbacks can be supported. The CB_NULL procedure checks the continuity of the callback path. A server makes a preliminary assessment of callback availability to a given client and avoids delegating responsibilities until it has determined that callbacks are supported. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients must not assume that a delegation will be granted, and they must always be prepared for OPENs to be processed without any delegations being granted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックRPCはすべての環境（ファイアウォールなど）で機能しない場合があるため、正しいプロトコル操作はそれらに依存しません。 CB_NULLプロシージャを使用したコールバック機能の予備テストにより、コールバックをサポートできるかどうかが決まります。 CB_NULLプロシージャは、コールバックパスの連続性をチェックします。サーバーは、指定されたクライアントへのコールバックの可用性を事前に評価し、コールバックがサポートされていると判断するまで責任の委任を回避します。委任の付与は常にアクセスの競合がないことを条件としているため、クライアントは委任が付与されることを想定してはならず、委任が付与されずにOPENが処理されるように常に準備しておく必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once granted, a delegation behaves in most ways like a lock. There is an associated lease that is subject to renewal, together with all of the other leases held by that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付与された委任は、ロックのようにほとんどの方法で動作します。更新される可能性のある関連リースと、そのクライアントが保持している他のすべてのリースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike locks, an operation by a second client to a delegated file will cause the server to recall a delegation through a callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックとは異なり、委任されたファイルに対する2番目のクライアントの操作では、サーバーがコールバックを通じて委任を呼び戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On recall, the client holding the delegation must flush modified state (such as modified data) to the server and return the delegation. The conflicting request will not be acted on until the recall is complete. The recall is considered complete when the client returns the delegation or the server times out its wait for the delegation to be returned and revokes the delegation as a result of the timeout. In the interim, the server will either delay responding to conflicting requests or respond to them with NFS4ERR_DELAY. Following the resolution of the recall, the server has the information necessary to grant or deny the second client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
呼び戻し時に、委任を保持しているクライアントは、変更された状態（変更されたデータなど）をサーバーにフラッシュし、委任を返す必要があります。競合する要求は、再呼び出しが完了するまで処理されません。クライアントが委任を返すか、サーバーが委任が返されるのを待機してタイムアウトし、タイムアウトの結果として委任を取り消すと、再呼び出しは完了したと見なされます。その間、サーバーは競合する要求への応答を遅らせるか、NFS4ERR_DELAYで応答します。再呼び出しの解決後、サーバーは2番目のクライアントの要求を許可または拒否するために必要な情報を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the time the client receives a delegation recall, it may have substantial state that needs to be flushed to the server. Therefore, the server should allow sufficient time for the delegation to be returned since it may involve numerous RPCs to the server. If the server is able to determine that the client is diligently flushing state to the server as a result of the recall, the server MAY extend the usual time allowed for a recall. However, the time allowed for recall completion should not be unbounded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが委任の取り消しを受け取った時点で、サーバーにフラッシュする必要のあるかなりの状態がある場合があります。したがって、サーバーには多数のRPCが含まれる可能性があるため、サーバーは委任が返されるのに十分な時間を確保する必要があります。再呼び出しの結果として、サーバーがクライアントがサーバーに状態を注意深くフラッシュしているとサーバーが判断できる場合、サーバーは再呼び出しに許可されている通常の時間を延長できます（MAY）。ただし、リコール完了に許可される時間には制限がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of this is when responsibility to mediate opens on a given file is delegated to a client (see Section 10.4). The server will not know what opens are in effect on the client. Without this knowledge, the server will be unable to determine if the access and deny state for the file allows any particular open until the delegation for the file has been returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例は、特定のファイルのオープンを仲​​介する責任がクライアントに委任されている場合です（セクション10.4を参照）。サーバーは、クライアントでどのオープンが有効であるかを認識しません。この知識がないと、サーバーは、ファイルの委任が返されるまで、ファイルのアクセスと拒否の状態が特定のオープンを許可するかどうかを判断できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client failure or a network partition can result in failure to respond to a recall callback. In this case, the server will revoke the delegation; this in turn will render useless any modified state still on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント障害またはネットワークパーティションにより、再呼び出しコールバックへの応答が失敗する可能性があります。この場合、サーバーは委任を取り消します。これにより、クライアント上で変更された状態が無効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients need to be aware that server implementers may enforce practical limitations on the number of delegations issued. Further, as there is no way to determine which delegations to revoke, the server is allowed to revoke any. If the server is implemented to revoke another delegation held by that client, then the client may be able to determine that a limit has been reached because each new delegation request results in a revoke. The client could then determine which delegations it may not need and preemptively release them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーの実装者が発行される委任の数に実際的な制限を課す可能性があることを認識する必要があります。さらに、取り消す委任を決定する方法がないため、サーバーは取り消すことができます。サーバーがそのクライアントによって保持されている別の委任を取り消すように実装されている場合、クライアントは、新しい委任要求のたびに取り消しが行われるため、制限に達したと判断できる場合があります。次に、クライアントは、必要のない委任を判別し、それらを事前に解放できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.1. Delegation Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.1. 委任の回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three situations that delegation recovery must deal with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任の回復では、3つの状況に対処する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client reboot or restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントの再起動または再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server reboot or restart (see Section 9.6.3.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーの再起動または再起動（セクション9.6.3.1を参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Network partition (full or callback-only)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワークパーティション（フルまたはコールバックのみ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that the client reboots or restarts, the confirmation of a SETCLIENTID done with an nfs_client_id4 with a new verifier4 value will result in the release of byte-range locks and share reservations. Delegations, however, may be treated a bit differently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが再起動または再起動した場合、nfs_client_id4で新しいverifier4値を使用して行われたSETCLIENTIDの確認により、バイト範囲ロックと共有予約が解放されます。ただし、委任の扱いは少し異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There will be situations in which delegations will need to be re-established after a client reboots or restarts. The reason for this is the client may have file data stored locally and this data was associated with the previously held delegations. The client will need to re-establish the appropriate file state on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが再起動または再起動した後、委任を再確立する必要がある状況があります。これは、クライアントにファイルデータがローカルに格納されている可能性があり、このデータが以前に保持されていた委任に関連付けられていたためです。クライアントはサーバー上で適切なファイル状態を再確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To allow for this type of client recovery, the server MAY allow delegations to be retained after other sorts of locks are released. This implies that requests from other clients that conflict with these delegations will need to wait. Because the normal recall process may require significant time for the client to flush changed state to the server, other clients need to be prepared for delays that occur because of a conflicting delegation. In order to give clients a chance to get through the reboot process -- during which leases will not be renewed -- the server MAY extend the period for delegation recovery beyond the typical lease expiration period. For open delegations, such delegations that are not released are reclaimed using OPEN with a claim type of CLAIM_DELEGATE_PREV. (See Sections 10.5 and 16.16 for discussions of open delegation and the details of OPEN, respectively.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このタイプのクライアント回復を可能にするために、サーバーは、他の種類のロックが解放された後に委任が保持されることを許可する場合があります。これは、これらの委任と競合する他のクライアントからの要求は待機する必要があることを意味します。通常の再呼び出しプロセスでは、クライアントが変更された状態をサーバーにフラッシュするのにかなりの時間がかかる場合があるため、他のクライアントは、委任の競合が原因で発生する遅延に備える必要があります。クライアントが再起動プロセス（リースが更新されない期間）を通過する機会を提供するために、サーバーは委任回復の期間を通常のリースの有効期限を超えて延長できます（MAY）。オープンな委任の場合、解放されないそのような委任は、クレームタイプがCLAIM_DELEGATE_PREVのOPENを使用して再利用されます。 （オープン委任とOPENの詳細については、それぞれセクション10.5と16.16を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY support a claim type of CLAIM_DELEGATE_PREV, but if it does, it MUST NOT remove delegations upon SETCLIENTID_CONFIRM and instead MUST make them available for client reclaim using CLAIM_DELEGATE_PREV. The server MUST NOT remove the delegations until either the client does a DELEGPURGE or one lease period has elapsed from the time -- whichever is later -- of the SETCLIENTID_CONFIRM or the last successful CLAIM_DELEGATE_PREV reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはクレームタイプCLAIM_DELEGATE_PREVをサポートしてもかまいませんが、サポートする場合は、SETCLIENTID_CONFIRMで委任を削除してはならず、CLAIM_DELEGATE_PREVを使用してクライアントが再利用できるようにする必要があります。サーバーは、クライアントがDELEGPURGEを実行するか、SETCLIENTID_CONFIRMまたは最後に成功したCLAIM_DELEGATE_PREVの再利用の時間（どちらか遅い方）から1つのリース期間が経過するまで、委任を削除してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the requirement stated above is not meant to imply that, when the server is no longer obliged, as required above, to retain delegation information, it should necessarily dispose of it. Some specific cases are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の要件は、サーバーに委任情報を保持する義務がなくなった場合、必ずしもそれを破棄する必要があることを意味するものではないことに注意してください。特定のケースは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the period is terminated by the occurrence of DELEGPURGE, deletion of unreclaimed delegations is appropriate and desirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DELEGPURGEの発生により期間が終了する場合は、未回収の委任を削除することが適切で望ましい方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the period is terminated by a lease period elapsing without a successful CLAIM_DELEGATE_PREV reclaim, and that situation appears to be the result of a network partition (i.e., lease expiration has occurred), a server&#39;s lease expiration approach, possibly including the use of courtesy locks, would normally provide for the retention of unreclaimed delegations. Even in the event that lease cancellation occurs, such delegation should be reclaimed using CLAIM_DELEGATE_PREV as part of network partition recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CLAIM_DELEGATE_PREVの再利用が成功せずに経過するリース期間によって期間が終了し、その状況がネットワークパーティションの結果であると思われる場合（つまり、リースの期限切れが発生した場合）、サーバーのリース期限切れアプローチ（礼儀ロックの使用を含む） 、通常、未回収の委任の保持を提供します。リースのキャンセルが発生した場合でも、CLAIM_DELEGATE_PREVをネットワークパーティションの回復の一部として使用して、このような委任を取り戻す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the period of non-communicating is followed by a client reboot, unreclaimed delegations should also be reclaimable by use of CLAIM_DELEGATE_PREV as part of client reboot recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 非通信の期間の後にクライアントの再起動が続く場合、クライアントの再起動の回復の一部としてCLAIM_DELEGATE_PREVを使用することにより、再利用されていない委任も再利用できるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the period is terminated by a lease period elapsing without a successful CLAIM_DELEGATE_PREV reclaim, and lease renewal is occurring, the server may well conclude that unreclaimed delegations have been abandoned and consider the situation as one in which an implied DELEGPURGE should be assumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CLAIM_DELEGATE_PREVの再利用が成功せずにリース期間が経過して期間が終了し、リースの更新が行われている場合、サーバーは、再利用されていない委任が放棄されたと結論付け、暗黙のDELEGPURGEが想定される状況と見なす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that supports a claim type of CLAIM_DELEGATE_PREV MUST support the DELEGPURGE operation, and similarly, a server that supports DELEGPURGE MUST support CLAIM_DELEGATE_PREV. A server that does not support CLAIM_DELEGATE_PREV MUST return NFS4ERR_NOTSUPP if the client attempts to use that feature or performs a DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_PREVのクレームタイプをサポートするサーバーは、DELEGPURGE操作をサポートする必要があり、同様に、DELEGPURGEをサポートするサーバーは、CLAIM_DELEGATE_PREVをサポートする必要があります。 CLAIM_DELEGATE_PREVをサポートしないサーバーは、クライアントがその機能を使用するか、DELEGPURGE操作を実行する場合、NFS4ERR_NOTSUPPを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Support for a claim type of CLAIM_DELEGATE_PREV is often referred to as providing for &#34;client-persistent delegations&#34; in that they allow the use of persistent storage on the client to store data written by the client, even across a client restart. It should be noted that, with the optional exception noted below, this feature requires persistent storage to be used on the client and does not add to persistent storage requirements on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_PREVのクレームタイプのサポートは、クライアントの永続的なストレージを使用して、クライアントが再書き込みした場合でも、クライアントによって書き込まれたデータを格納できるという点で、「クライアント永続的な委任」の提供と呼ばれます。以下に示すオプションの例外を除いて、この機能ではクライアントで永続ストレージを使用する必要があり、サーバーの永続ストレージ要件に追加されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One good way to think about client-persistent delegations is that for the most part, they function like &#34;courtesy locks&#34;, with special semantic adjustments to allow them to be retained across a client restart, which cause all other sorts of locks to be freed. Such locks are generally not retained across a server restart. The one exception is the case of simultaneous failure of the client and server and is discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント永続的な委任について考える良い方法の1つは、ほとんどの場合、「礼儀ロック」のように機能し、特別なセマンティック調整によってクライアントの再起動後も保持できるようにすることです。これにより、他のすべての種類のロックが解放されます。 。このようなロックは通常、サーバーを再起動しても保持されません。 1つの例外は、クライアントとサーバーの同時障害の場合であり、以下で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server indicates support of CLAIM_DELEGATE_PREV (implicitly) by returning NFS_OK to DELEGPURGE, a client with a write delegation can use write-back caching for data to be written to the server, deferring the write-back until such time as the delegation is recalled, possibly after intervening client restarts. Similarly, when the server indicates support of CLAIM_DELEGATE_PREV, a client with a read delegation and an open-for-write subordinate to that delegation may be sure of the integrity of its persistently cached copy of the file after a client restart without specific verification of the change attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがCLAIM_DELEGATE_PREVのサポートを（暗黙的に）示し、NFS_OKをDELEGPURGEに戻すと、書き込み委任を持つクライアントは、サーバーに書き込まれるデータにライトバックキャッシュを使用して、委任がリコールされるまでライトバックを延期できます。 、おそらく介在するクライアントの再起動後。同様に、サーバーがCLAIM_DELEGATE_PREVのサポートを示している場合、読み取り委任とその委任に従属する書き込み用にオープンされたクライアントは、クライアントを再起動した後、永続的にキャッシュされたファイルのコピーの完全性を確認できます。属性を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the server reboots or restarts, delegations are reclaimed (using the OPEN operation with CLAIM_PREVIOUS) in a similar fashion to byte-range locks and share reservations. However, there is a slight semantic difference. In the normal case, if the server decides that a delegation should not be granted, it performs the requested action (e.g., OPEN) without granting any delegation. For reclaim, the server grants the delegation, but a special designation is applied so that the client treats the delegation as having been granted but recalled by the server. Because of this, the client has the duty to write all modified state to the server and then return the delegation. This process of handling delegation reclaim reconciles three principles of the NFSv4 protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーが再起動または再起動すると、デリゲートはバイト範囲のロックや共有の予約と同様の方法で（CLAIM_PREVIOUSを指定したOPEN操作を使用して）再利用されます。ただし、わずかな意味上の違いがあります。通常の場合、サーバーが委任を許可しないと決定すると、サーバーは委任を許可せずに要求されたアクション（OPENなど）を実行します。再利用の場合、サーバーは委任を許可しますが、クライアントが委任を許可されたがサーバーによって呼び出されたものとして扱うように、特別な指定が適用されます。このため、クライアントには、変更されたすべての状態をサーバーに書き込んでから委任を返す義務があります。委任再利用を処理するこのプロセスは、NFSv4プロトコルの3つの原則を調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upon reclaim, a client claiming resources assigned to it by an earlier server instance must be granted those resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 再利用時に、以前のサーバーインスタンスによって割り当てられたリソースを要求するクライアントには、それらのリソースを付与する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has unquestionable authority to determine whether delegations are to be granted and, once granted, whether they are to be continued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーには、委任を許可するかどうかを決定し、一度許可すると、続行するかどうかを決定する疑いのない権限があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of callbacks is not to be depended upon until the client has proven its ability to receive them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コールバックの使用は、クライアントがそれらを受信する能力を証明するまでは依存しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has more than a single open associated with a delegation, state for those additional opens can be established using OPEN operations of type CLAIM_DELEGATE_CUR. When these are used to establish opens associated with reclaimed delegations, the server MUST allow them when made within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに委任に関連付けられた複数のオープンがある場合、それらの追加のオープンの状態は、タイプCLAIM_DELEGATE_CURのOPEN操作を使用して確立できます。これらが再利用された委任に関連するオープンを確立するために使用される場合、サーバーは猶予期間内に作成されたときにそれらを許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Situations in which there is a series of client and server restarts where there is no restart of both at the same time are dealt with via a combination of CLAIM_DELEGATE_PREV and CLAIM_PREVIOUS reclaim cycles. Persistent storage is needed only on the client. For each server failure, a CLAIM_PREVIOUS reclaim cycle is done, while for each client restart, a CLAIM_DELEGATE_PREV reclaim cycle is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーの一連の再起動があり、両方の再起動が同時に行われない状況は、CLAIM_DELEGATE_PREVとCLAIM_PREVIOUSの再利用サイクルの組み合わせによって処理されます。永続ストレージはクライアントでのみ必要です。サーバーの障害ごとにCLAIM_PREVIOUS再利用サイクルが実行され、クライアントの再起動ごとにCLAIM_DELEGATE_PREV再利用サイクルが実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To deal with the possibility of simultaneous failure of client and server (e.g., a data center power outage), the server MAY persistently store delegation information so that it can respond to a CLAIM_DELEGATE_PREV reclaim request that it receives from a restarting client. This is the one case in which persistent delegation state can be retained across a server restart. A server is not required to store this information, but if it does do so, it should do so for write delegations and for read delegations, during the pendency of which (across multiple client and/or server instances), some open-for-write was done as part of delegation. When the space to persistently record such information is limited, the server should recall delegations in this class in preference to keeping them active without persistent storage recording.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーの同時障害（データセンターの停電など）の可能性に対処するために、サーバーは委任情報を永続的に格納して、再起動中のクライアントから受信したCLAIM_DELEGATE_PREV再利用要求に応答できるようにする場合があります。これは、サーバーの再起動後も永続的な委任状態を保持できる1つのケースです。サーバーはこの情報を保存する必要はありませんが、そうする場合は、書き込み委任と読み取り委任のために、複数のクライアントまたはサーバーインスタンス間で、いくつかのオープンペンディングの間、書き込みは委任の一部として行われました。そのような情報を永続的に記録するスペースが限られている場合、サーバーはこのクラスの委任を呼び戻し、永続的なストレージの記録なしでそれらをアクティブに保つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations, and as for locks and share reservations, it may be modified by support for &#34;courtesy locks&#34; in which locks are not freed in the absence of a conflicting lock request. Whereas for locks and share reservations the freeing of locks will occur immediately upon the appearance of a conflicting request, for delegations, the server MAY institute a period during which conflicting requests are held off. Eventually, the occurrence of a conflicting request from another client will cause revocation of the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ネットワークパーティションが発生すると、リースの更新期間が終了すると、委任はサーバーによって解放されます。これは、ロックと共有予約の動作に似ています。ロックと共有予約については、競合するロックリクエストがない場合にロックが解放されない「礼儀ロック」のサポートによって変更される場合があります。ロックおよび共有予約の場合、ロックの解放は、競合する要求が出現するとすぐに発生しますが、委任の場合、サーバーは、競合する要求が保留される期間を設定できます（MAY）。最終的に、別のクライアントからの要求の競合が発生すると、委任が取り消されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A loss of the callback path (e.g., by a later network configuration change) will have a similar effect in that it can also result in revocation of a delegation. A recall request will fail, and revocation of the delegation will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックパスが失われると（後のネットワーク構成の変更などにより）、委任が取り消される可能性があるという同様の影響があります。取り消し要求は失敗し、委任の取り消しが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client normally finds out about revocation of a delegation when it uses a stateid associated with a delegation and receives one of the errors NFS4ERR_EXPIRED, NFS4ERR_BAD_STATEID, or NFS4ERR_ADMIN_REVOKED (NFS4ERR_EXPIRED indicates that all lock state associated with the client has been lost). It also may find out about delegation revocation after a client reboot when it attempts to reclaim a delegation and receives NFS4ERR_EXPIRED. Note that in the case of a revoked OPEN_DELEGATE_WRITE delegation, there are issues because data may have been modified by the client whose delegation is revoked and, separately, by other clients. See Section 10.5.1 for a discussion of such issues. Note also that when delegations are revoked, information about the revoked delegation will be written by the server to stable storage (as described in Section 9.6). This is done to deal with the case in which a server reboots after revoking a delegation but before the client holding the revoked delegation is notified about the revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは通常、委任に関連付けられた状態IDを使用し、エラーNFS4ERR_EXPIRED、NFS4ERR_BAD_STATEID、またはNFS4ERR_ADMIN_REVOKED（NFS4ERR_EXPIREDは、クライアントに関連付けられたすべてのロック状態が失われたことを示します）のいずれかを受け取ると、委任の取り消しについて調べます。また、クライアントの再起動後に委任を再利用しようとしてNFS4ERR_EXPIREDを受け取ったときに、委任の取り消しについても知ることができます。 OPEN_DELEGATE_WRITE委任が取り消された場合は、委任が取り消されたクライアントによって、また他のクライアントによって個別にデータが変更された可能性があるため、問題が発生することに注意してください。このような問題については、セクション10.5.1を参照してください。委任が取り消されると、取り消された委任に関する情報がサーバーによって安定したストレージに書き込まれることにも注意してください（セクション9.6で説明）。これは、委任を取り消した後で、取り消された委任を保持しているクライアントに取り消しが通知される前にサーバーが再起動する場合に対処するために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when there is a loss of a delegation, due to a network partition in which all locks associated with the lease are lost, the client will also receive the error NFS4ERR_EXPIRED. This case can be distinguished from other situations in which delegations are revoked by seeing that the associated clientid becomes invalid so that NFS4ERR_STALE_CLIENTID is returned when it is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースに関連付けられたすべてのロックが失われたネットワークパーティションが原因で委任が失われた場合、クライアントはエラーNFS4ERR_EXPIREDも受け取ります。このケースは、関連付けられたclientidが無効になり、使用時にNFS4ERR_STALE_CLIENTIDが返されることを確認することにより、委任が取り消される他の状況と区別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When NFS4ERR_EXPIRED is returned, the server MAY retain information about the delegations held by the client, deleting those that are invalidated by a conflicting request. Retaining such information will allow the client to recover all non-invalidated delegations using the claim type CLAIM_DELEGATE_PREV, once the SETCLIENTID_CONFIRM is done to recover. Attempted recovery of a delegation that the client has no record of, typically because they were invalidated by conflicting requests, will result in the error NFS4ERR_BAD_RECLAIM. Once a reclaim is attempted for all delegations that the client held, it SHOULD do a DELEGPURGE to allow any remaining server delegation information to be freed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXPIREDが返されると、サーバーはクライアントが保持している委任に関する情報を保持してもよい（MAY）、競合する要求によって無効化された委任を削除します。このような情報を保持することで、クライアントは、SETCLIENTID_CONFIRMの回復が完了すると、クレームタイプCLAIM_DELEGATE_PREVを使用して、無効ではないすべての委任を回復できます。クライアントに記録されていない委任を回復しようとすると、通常、要求が競合して無効にされたため、エラーNFS4ERR_BAD_RECLAIMが発生します。クライアントが保持していたすべての委任に対して再利用が試行されると、残りのサーバー委任情報を解放できるようにDELEGPURGEを実行する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. データキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When applications share access to a set of files, they need to be implemented so as to take account of the possibility of conflicting access by another application. This is true whether the applications in question execute on different clients or reside on the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが一連のファイルへのアクセスを共有する場合、別のアプリケーションによるアクセスの競合の可能性を考慮に入れるために、それらを実装する必要があります。これは、問題のアプリケーションが異なるクライアントで実行されているか、同じクライアントに存在しているかに関係なく当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Share reservations and byte-range locks are the facilities the NFSv4 protocol provides to allow applications to coordinate access by providing mutual exclusion facilities. The NFSv4 protocol&#39;s data caching must be implemented such that it does not invalidate the assumptions that those using these facilities depend upon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約とバイト範囲ロックは、NFSv4プロトコルが提供する機能であり、相互排除機能を提供することにより、アプリケーションがアクセスを調整できるようにします。 NFSv4プロトコルのデータキャッシングは、これらの機能を使用するユーザーが依存する前提を無効にしないように実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.1. Data Caching and OPENs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.1. データキャッシングとOPEN
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid invalidating the sharing assumptions that applications rely on, NFSv4 clients should not provide cached data to applications or modify it on behalf of an application when it would not be valid to obtain or modify that same data via a READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが依存する共有の仮定が無効になるのを防ぐために、NFSv4クライアントは、キャッシュされたデータをアプリケーションに提供したり、READまたはWRITE操作で同じデータを取得または変更することが有効でない場合に、アプリケーションに代わって変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, in the absence of open delegation (see Section 10.4), two additional rules apply. Note that these rules are obeyed in practice by many NFSv2 and NFSv3 clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、オープンな委任がない場合（セクション10.4を参照）、2つの追加ルールが適用されます。これらのルールは、実際には多くのNFSv2およびNFSv3クライアントによって遵守されていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, cached data present on a client must be revalidated after doing an OPEN. Revalidating means that the client fetches the change attribute from the server, compares it with the cached change attribute, and, if different, declares the cached data (as well as the cached attributes) as invalid. This is to ensure that the data for the OPENed file is still correctly reflected in the client&#39;s cache. This validation must be done at least when the client&#39;s OPEN operation includes DENY=WRITE or BOTH, thus terminating a period in which other clients may have had the opportunity to open the file with WRITE access. Clients may choose to do the revalidation more often (such as at OPENs specifying DENY=NONE) to parallel the NFSv3 protocol&#39;s practice for the benefit of users assuming this degree of cache revalidation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まず、クライアントに存在するキャッシュされたデータは、OPENの実行後に再検証する必要があります。再検証とは、クライアントがサーバーから変更属性をフェッチし、それをキャッシュされた変更属性と比較し、異なる場合は、キャッシュされたデータ（およびキャッシュされた属性）を無効として宣言することを意味します。これは、OPENedファイルのデータがクライアントのキャッシュに正しく反映されるようにするためです。この検証は、少なくともクライアントのOPEN操作にDENY = WRITEまたはBOTHが含まれている場合に実行する必要があります。これにより、他のクライアントがWRITEアクセスでファイルを開く機会があった可能性がある期間が終了します。クライアントは、より頻繁に再検証を行うこと（OPENでDENY = NONEを指定するなど）を選択して、この程度のキャッシュの再検証を想定しているユーザーの利益のために、NFSv3プロトコルの実践に対応することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Since the change attribute is updated for data and metadata modifications, some client implementers may be tempted to use the time_modify attribute and not the change attribute to validate cached data, so that metadata changes do not spuriously invalidate clean data. The implementer is cautioned against this approach. The change attribute is guaranteed to change for each update to the file, whereas time_modify is guaranteed to change only at the granularity of the time_delta attribute. Use by the client&#39;s data cache validation logic of time_modify and not the change attribute runs the risk of the client incorrectly marking stale data as valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
変更属性はデータとメタデータの変更のために更新されるため、一部のクライアント実装者は変更属性ではなくtime_modify属性を使用して、キャッシュされたデータを検証するように誘惑され、メタデータの変更がクリーンなデータを誤って無効にすることがなくなります。実装者は、このアプローチに対して警告されます。 change属性は、ファイルの更新ごとに変更されることが保証されていますが、time_modifyは、time_delta属性の粒度でのみ変更されることが保証されています。クライアントのデータキャッシュ検証ロジックでtime_modifyを使用し、change属性では使用しないと、クライアントが古いデータを有効として誤ってマークするリスクがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second, modified data must be flushed to the server before closing a file OPENed for write. This is complementary to the first rule. If the data is not flushed at CLOSE, the revalidation done after the client OPENs a file is unable to achieve its purpose. The other aspect to flushing the data before close is that the data must be committed to stable storage, at the server, before the CLOSE operation is requested by the client. In the case of a server reboot or restart and a CLOSEd file, it may not be possible to retransmit the data to be written to the file -- hence, this requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第2に、書き込み用にOPENされたファイルを閉じる前に、変更されたデータをサーバーにフラッシュする必要があります。これは最初のルールを補足するものです。データがCLOSEでフラッシュされない場合、クライアントがファイルをOPENした後に行われる再検証は、その目的を達成できません。閉じる前にデータをフラッシュするもう1つの側面は、クライアントがCLOSE操作を要求する前に、サーバーでデータを安定したストレージにコミットする必要があることです。サーバーの再起動または再起動とCLOSEdファイルの場合、ファイルに書き込まれるデータを再送信できない可能性があるため、この要件が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.2. Data Caching and File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.2. データのキャッシュとファイルのロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For those applications that choose to use file locking instead of share reservations to exclude inconsistent file access, there is an analogous set of constraints that apply to client-side data caching. These rules are effective only if the file locking is used in a way that matches in an equivalent way the actual READ and WRITE operations executed. This is as opposed to file locking that is based on pure convention. For example, it is possible to manipulate a two-megabyte file by dividing the file into two one-megabyte regions and protecting access to the two regions by file locks on bytes zero and one. A lock for write on byte zero of the file would represent the right to do READ and WRITE operations on the first region. A lock for write on byte one of the file would represent the right to do READ and WRITE operations on the second region. As long as all applications manipulating the file obey this convention, they will work on a local file system. However, they may not work with the NFSv4 protocol unless clients refrain from data caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約の代わりにファイルロックを使用して、一貫性のないファイルアクセスを除外することを選択するアプリケーションには、クライアント側のデータキャッシュに適用される一連の類似した制約があります。これらのルールは、実際のREADおよびWRITE操作が実行されたのと同等の方法で一致する方法でファイルロックが使用されている場合にのみ有効です。これは、純粋な規則に基づくファイルロックとは対照的です。たとえば、ファイルを2つの1メガバイトの領域に分割し、2つの領域へのアクセスをバイト0と1のファイルロックによって保護することで、2メガバイトのファイルを操作できます。ファイルのバイト0に対する書き込みのロックは、最初の領域でREADおよびWRITE操作を実行する権利を表します。ファイルのバイト1に対する書き込みのロックは、2番目の領域でREADおよびWRITE操作を実行する権利を表します。ファイルを操作するすべてのアプリケーションがこの規則に従う限り、ローカルファイルシステムで動作します。ただし、クライアントがデータキャッシングを控えない限り、NFSv4プロトコルでは機能しない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for data caching in the file locking environment are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルロック環境でのデータキャッシングのルールは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, when a client obtains a file lock for a particular region, the data cache corresponding to that region (if any cached data exists) must be revalidated. If the change attribute indicates that the file may have been updated since the cached data was obtained, the client must flush or invalidate the cached data for the newly locked region. A client might choose to invalidate all of the non-modified cached data that it has for the file, but the only requirement for correct operation is to invalidate all of the data in the newly locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まず、クライアントが特定の領域のファイルロックを取得すると、その領域に対応するデータキャッシュ（キャッシュされたデータが存在する場合）を再検証する必要があります。変更された属性が、キャッシュされたデータの取得後にファイルが更新された可能性があることを示している場合、クライアントは、新しくロックされた領域のキャッシュされたデータをフラッシュまたは無効にする必要があります。クライアントは、ファイルにある変更されていないキャッシュデータをすべて無効にすることを選択する場合がありますが、正しく動作するための唯一の要件は、新しくロックされた領域のすべてのデータを無効にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second, before releasing a write lock for a region, all modified data for that region must be flushed to the server. The modified data must also be written to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 次に、リージョンの書き込みロックを解放する前に、そのリージョンのすべての変更データをサーバーにフラッシュする必要があります。変更されたデータも安定したストレージに書き込む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that flushing data to the server and the invalidation of cached data must reflect the actual byte ranges locked or unlocked. Rounding these up or down to reflect client cache block boundaries will cause problems if not carefully done. For example, writing a modified block when only half of that block is within an area being unlocked may cause invalid modification to the region outside the unlocked area. This, in turn, may be part of a region locked by another client. Clients can avoid this situation by synchronously performing portions of WRITE operations that overlap that portion (initial or final) that is not a full block. Similarly, invalidating a locked area that is not an integral number of full buffer blocks would require the client to read one or two partial blocks from the server if the revalidation procedure shows that the data that the client possesses may not be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーへのデータのフラッシュとキャッシュデータの無効化は、ロックまたはロック解除された実際のバイト範囲を反映する必要があることに注意してください。これらを切り上げまたは切り下げてクライアントキャッシュブロックの境界を反映させると、注意深く行わないと問題が発生します。たとえば、ブロックの半分だけがロック解除されている領域内にあるときに変更されたブロックを書き込むと、ロック解除された領域の外側の領域が無効に変更される可能性があります。これは、別のクライアントによってロックされている領域の一部である可能性があります。クライアントは、完全なブロックではない部分（初期または最終）とオーバーラップするWRITE操作の部分を同期的に実行することにより、この状況を回避できます。同様に、完全なバッファーブロックの整数ではないロックされた領域を無効にすると、クライアントが所有するデータが有効でない可能性があることが再検証手順で示される場合、クライアントはサーバーから1つまたは2つの部分ブロックを読み取る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data that is written to the server as a prerequisite to the unlocking of a region must be written, at the server, to stable storage. The client may accomplish this either with synchronous writes or by following asynchronous writes with a COMMIT operation. This is required because retransmission of the modified data after a server reboot might conflict with a lock held by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リージョンのロック解除の前提条件としてサーバーに書き込まれるデータは、サーバーで安定したストレージに書き込まれる必要があります。クライアントは、同期書き込みを使用するか、COMMIT操作で非同期書き込みを実行することにより、これを実行できます。これは、サーバーの再起動後の変更されたデータの再送信が別のクライアントによって保持されているロックと競合する可能性があるために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client implementation may choose to accommodate applications that use byte-range locking in non-standard ways (e.g., using a byte-range lock as a global semaphore) by flushing to the server more data upon a LOCKU than is covered by the locked range. This may include modified data within files other than the one for which the unlocks are being done. In such cases, the client must not interfere with applications whose READs and WRITEs are being done only within the bounds of record locks that the application holds. For example, an application locks a single byte of a file and proceeds to write that single byte. A client that chose to handle a LOCKU by flushing all modified data to the server could validly write that single byte in response to an unrelated unlock. However, it would not be valid to write the entire block in which that single written byte was located since it includes an area that is not locked and might be locked by another client. Client implementations can avoid this problem by dividing files with modified data into those for which all modifications are done to areas covered by an appropriate byte-range lock and those for which there are modifications not covered by a byte-range lock. Any writes done for the former class of files must not include areas not locked and thus not modified on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの実装は、非標準の方法でバイト範囲ロックを使用するアプリケーション（たとえば、グローバルセマフォとしてバイト範囲ロックを使用する）に対応することを選択できます。 。これには、ロック解除が行われているファイル以外のファイル内の変更されたデータが含まれる場合があります。このような場合、クライアントは、アプリケーションが保持するレコードロックの境界内でのみREADおよびWRITEが実行されるアプリケーションに干渉してはなりません。たとえば、アプリケーションはファイルの1バイトをロックし、その1バイトの書き込みを続行します。変更されたすべてのデータをサーバーにフラッシュすることによってLOCKUを処理することを選択したクライアントは、無関係なロック解除に応答してその1バイトを有効に書き込むことができます。ただし、ロックされていない領域が含まれていて、別のクライアントによってロックされている可能性があるため、その単一の書き込まれたバイトが配置されたブロック全体を書き込むことは無効です。クライアントの実装では、データが変更されたファイルを、適切なバイト範囲ロックでカバーされる領域にすべての変更が加えられるファイルと、バイト範囲ロックでカバーされない変更があるファイルに分割することで、この問題を回避できます。前のクラスのファイルに対して行われた書き込みには、ロックされていない領域が含まれていて、クライアントで変更されていないことが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.3. Data Caching and Mandatory File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.3. データキャッシングと必須ファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client-side data caching needs to respect mandatory file locking when it is in effect. The presence of mandatory file locking for a given file is indicated when the client gets back NFS4ERR_LOCKED from a READ or WRITE on a file it has an appropriate share reservation for. When mandatory locking is in effect for a file, the client must check for an appropriate file lock for data being read or written. If a lock exists for the range being read or written, the client may satisfy the request using the client&#39;s validated cache. If an appropriate file lock is not held for the range of the READ or WRITE, the READ or WRITE request must not be satisfied by the client&#39;s cache and the request must be sent to the server for processing. When a READ or WRITE request partially overlaps a locked region, the request should be subdivided into multiple pieces with each region (locked or not) treated appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント側のデータキャッシュは、有効な場合、必須のファイルロックを尊重する必要があります。特定のファイルの必須ファイルロックの存在は、クライアントが適切な共有予約を持っているファイルの読み取りまたは書き込みからNFS4ERR_LOCKEDを取得したときに示されます。ファイルに対して強制ロックが有効になっている場合、クライアントは、読み取りまたは書き込み中のデータに対して適切なファイルロックを確認する必要があります。読み取りまたは書き込みされている範囲にロックが存在する場合、クライアントは、クライアントの検証済みキャッシュを使用して要求を満たすことができます。 READまたはWRITEの範囲で適切なファイルロックが保持されていない場合、READまたはWRITE要求はクライアントのキャッシュによって満たされず、要求はサーバーに送信されて処理される必要があります。 READまたはWRITE要求がロックされた領域と部分的にオーバーラップする場合、要求は複数の部分に分割され、各領域（ロックされているかどうかにかかわらず）が適切に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.4. Data Caching and File Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.4. データキャッシングとファイルID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When clients cache data, the file data needs to be organized according to the file system object to which the data belongs. For NFSv3 clients, the typical practice has been to assume for the purpose of caching that distinct filehandles represent distinct file system objects. The client then has the choice to organize and maintain the data cache on this basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがデータをキャッシュする場合、ファイルデータは、データが属するファイルシステムオブジェクトに従って編成する必要があります。 NFSv3クライアントの場合、典型的な慣例は、キャッシングの目的で、個別のファイルハンドルが個別のファイルシステムオブジェクトを表すと想定することでした。その後、クライアントは、これに基づいてデータキャッシュを整理および維持することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFSv4 protocol, there is now the possibility of having significant deviations from a &#34;one filehandle per object&#34; model, because a filehandle may be constructed on the basis of the object&#39;s pathname. Therefore, clients need a reliable method to determine if two filehandles designate the same file system object. If clients were simply to assume that all distinct filehandles denote distinct objects and proceed to do data caching on this basis, caching inconsistencies would arise between the distinct client-side objects that mapped to the same server-side object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルでは、ファイルハンドルはオブジェクトのパス名に基づいて構築される可能性があるため、「オブジェクトごとに1つのファイルハンドル」モデルから大幅に逸脱する可能性があります。したがって、クライアントは、2つのファイルハンドルが同じファイルシステムオブジェクトを指定しているかどうかを判断するための信頼できる方法を必要とします。クライアントがすべての個別のファイルハンドルが個別のオブジェクトを表すと単純に想定し、これに基づいてデータキャッシュを実行すると、同じサーバー側オブジェクトにマップされた個別のクライアント側オブジェクト間でキャッシュの不整合が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By providing a method to differentiate filehandles, the NFSv4 protocol alleviates a potential functional regression in comparison with the NFSv3 protocol. Without this method, caching inconsistencies within the same client could occur, and this has not been present in previous versions of the NFS protocol. Note that it is possible to have such inconsistencies with applications executing on multiple clients, but that is not the issue being addressed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルを区別する方法を提供することにより、NFSv4プロトコルは、NFSv3プロトコルと比較して潜在的な機能低下を緩和します。この方法がないと、同じクライアント内でキャッシュの不整合が発生する可能性があり、これは以前のバージョンのNFSプロトコルには存在しませんでした。複数のクライアントで実行されているアプリケーションとこのような不整合が生じる可能性がありますが、ここでは対処されていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of data caching, the following steps allow an NFSv4 client to determine whether two distinct filehandles denote the same server-side object:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データキャッシングの目的で、次の手順により、NFSv4クライアントは2つの異なるファイルハンドルが同じサーバー側オブジェクトを表すかどうかを判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to two filehandles returns different values of the fsid attribute, then the filehandles represent distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つのファイルハンドルに向けられたGETATTRがfsid属性の異なる値を返す場合、ファイルハンドルは異なるオブジェクトを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR for any file with an fsid that matches the fsid of the two filehandles in question returns a unique_handles attribute with a value of TRUE, then the two objects are distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 問題の2つのファイルハンドルのfsidと一致するfsidを持つファイルのGETATTRが値がTRUEのunique_handles属性を返す場合、2つのオブジェクトは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to the two filehandles does not return the fileid attribute for both of the handles, then it cannot be determined whether the two objects are the same. Therefore, operations that depend on that knowledge (e.g., client-side data caching) cannot be done reliably. Note that if GETATTR does not return the fileid attribute for both filehandles, it will return it for neither of the filehandles, since the fsid for both filehandles is the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つのファイルハンドルに向けられたGETATTRが両方のハンドルのfileid属性を返さない場合、2つのオブジェクトが同じかどうかを判断できません。したがって、その知識に依存する操作（クライアント側のデータキャッシュなど）は確実に実行できません。 GETATTRが両方のファイルハンドルのfileid属性を返さない場合、両方のファイルハンドルのfsidが同じであるため、どちらのファイルハンドルにもそれを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to the two filehandles returns different values for the fileid attribute, then they are distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つのファイルハンドルに向けられたGETATTRがfileid属性に異なる値を返す場合、それらは異なるオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, they are the same object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合は、同じオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. オープンな委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file is being OPENed, the server may delegate further handling of opens and closes for that file to the opening client. Any such delegation is recallable, since the circumstances that allowed for the delegation are subject to change. In particular, the server may receive a conflicting OPEN from another client; the server must recall the delegation before deciding whether the OPEN from the other client may be granted. Making a delegation is up to the server, and clients should not assume that any particular OPEN either will or will not result in an open delegation. The following is a typical set of conditions that servers might use in deciding whether OPEN should be delegated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがOPENされているとき、サーバーはそのファイルのオープンとクローズの処理をオープンしているクライアントに委任する場合があります。委任を許可された状況は変更される可能性があるため、このような委任は再呼び出し可能です。特に、サーバーは別のクライアントから競合するOPENを受け取る場合があります。サーバーは、他のクライアントからのOPENが許可されるかどうかを決定する前に、委任を呼び出す必要があります。委任を行うかどうかはサーバー次第であり、クライアントは、特定のOPENがオープン委任をもたらすかどうかを想定しないでください。以下は、OPENを委任する必要があるかどうかを決定する際にサーバーが使用する可能性のある典型的な一連の条件です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client must be able to respond to the server&#39;s callback requests. The server will use the CB_NULL procedure for a test of callback ability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、サーバーのコールバック要求に応答できる必要があります。サーバーは、コールバック機能のテストにCB_NULLプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client must have responded properly to previous recalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは以前のリコールに適切に応答している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There must be no current open conflicting with the requested delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在、要求された委任と競合するオープンオープンがあってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There should be no current delegation that conflicts with the delegation being requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求されている委任と競合する現在の委任があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The probability of future conflicting open requests should be low, based on the recent history of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルの最近の履歴に基づいて、将来の競合するオープンリクエストの可能性は低くなるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The existence of any server-specific semantics of OPEN/CLOSE that would make the required handling incompatible with the prescribed handling that the delegated client would apply (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 必要な処理を、委任されたクライアントが適用する規定の処理と互換性のないものにする、OPEN / CLOSEのサーバー固有のセマンティクスの存在（以下を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two types of open delegations: OPEN_DELEGATE_READ and OPEN_DELEGATE_WRITE. An OPEN_DELEGATE_READ delegation allows a client to handle, on its own, requests to open a file for reading that do not deny read access to others. It MUST, however, continue to send all requests to open a file for writing to the server. Multiple OPEN_DELEGATE_READ delegations may be outstanding simultaneously and do not conflict. An OPEN_DELEGATE_WRITE delegation allows the client to handle, on its own, all opens. Only one OPEN_DELEGATE_WRITE delegation may exist for a given file at a given time, and it is inconsistent with any OPEN_DELEGATE_READ delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN_DELEGATE_READとOPEN_DELEGATE_WRITEの2つのタイプのオープンな委任があります。 OPEN_DELEGATE_READ委任を使用すると、クライアントは、他のユーザーへの読み取りアクセスを拒否しない読み取り専用のファイルを開く要求を、それ自体で処理できます。ただし、サーバーに書き込むためにファイルを開くためのすべての要求を送信し続ける必要があります。複数のOPEN_DELEGATE_READ委任が同時に未解決であり、競合しない場合があります。 OPEN_DELEGATE_WRITE委任により、クライアントは単独ですべてのオープンを処理できます。特定の時間に特定のファイルに対して存在できるOPEN_DELEGATE_WRITE委任は1つだけであり、OPEN_DELEGATE_READ委任と矛盾します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a single client holds an OPEN_DELEGATE_READ delegation, it is assured that no other client may modify the contents or attributes of the file. If more than one client holds an OPEN_DELEGATE_READ delegation, then the contents and attributes of that file are not allowed to change. When a client has an OPEN_DELEGATE_WRITE delegation, it may modify the file data since no other client will be accessing the file&#39;s data. The client holding an OPEN_DELEGATE_WRITE delegation may only affect file attributes that are intimately connected with the file data: size, time_modify, and change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のクライアントがOPEN_DELEGATE_READ委任を保持している場合、他のクライアントがファイルの内容または属性を変更できないことが保証されます。複数のクライアントがOPEN_DELEGATE_READ委任を保持している場合、そのファイルの内容と属性は変更できません。クライアントにOPEN_DELEGATE_WRITE委任がある場合、他のクライアントがファイルのデータにアクセスしないため、クライアントはファイルデータを変更する可能性があります。 OPEN_DELEGATE_WRITE委任を保持しているクライアントは、サイズ、time_modify、およびchangeなど、ファイルデータと密接に関連しているファイル属性にのみ影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has an open delegation, it does not send OPENs or CLOSEs to the server but updates the appropriate status internally. For an OPEN_DELEGATE_READ delegation, opens that cannot be handled locally (opens for write or that deny read access) must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントにオープンな委任がある場合、クライアントはサーバーにOPENまたはCLOSEを送信しませんが、内部で適切なステータスを更新します。 OPEN_DELEGATE_READ委任の場合、ローカルで処理できないオープン（書き込み用のオープンまたは読み取りアクセスを拒否する）をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an open delegation is made, the response to the OPEN contains an open delegation structure that specifies the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン委任が行われると、OPENへの応答には、以下を指定するオープン委任構造が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the type of delegation (read or write)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任のタイプ（読み取りまたは書き込み）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o space limitation information to control flushing of data on close (OPEN_DELEGATE_WRITE delegation only; see Section 10.4.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クローズ時のデータのフラッシュを制御するスペース制限情報（OPEN_DELEGATE_WRITE委任のみ。セクション10.4.1を参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an nfsace4 specifying read and write permissions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 読み取りおよび書き込み権限を指定するnfsace4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a stateid to represent the delegation for READ and WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READおよびWRITEの委任を表す状態ID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The delegation stateid is separate and distinct from the stateid for the OPEN proper. The standard stateid, unlike the delegation stateid, is associated with a particular open-owner and will continue to be valid after the delegation is recalled and the file remains open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任状態IDは、OPEN固有の状態IDとは別のものです。委任状態IDとは異なり、標準状態IDは特定のオープン所有者に関連付けられており、委任が呼び出されてファイルが開いたままになった後も引き続き有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a request internal to the client is made to open a file and open delegation is in effect, it will be accepted or rejected solely on the basis of the following conditions. Any requirement for other checks to be made by the delegate should result in open delegation being denied so that the checks can be made by the server itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント内部の要求がファイルを開くように行われ、オープン委任が有効である場合、次の条件に基づいてのみ、それが受け入れられるか拒否されます。デリゲートが他のチェックを行う必要があると、サーバー自体がチェックできるように、オープンな委任が拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The access and deny bits for the request and the file, as described in Section 9.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セクション9.9で説明されている、リクエストとファイルのアクセスビットと拒否ビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The read and write permissions, as determined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以下に示すように、読み取りおよび書き込み権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfsace4 passed with delegation can be used to avoid frequent ACCESS calls. The permission check should be as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任で渡されたnfsace4は、頻繁なACCESS呼び出しを回避するために使用できます。権限チェックは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the nfsace4 indicates that the open may be done, then it should be granted without reference to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o nfsace4がオープンを実行できることを示している場合は、サーバーを参照せずに許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the nfsace4 indicates that the open may not be done, then an ACCESS request must be sent to the server to obtain the definitive answer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o nfsace4がオープンが実行されない可能性があることを示している場合、最終的な回答を取得するには、ACCESS要求をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may return an nfsace4 that is more restrictive than the actual ACL of the file. This includes an nfsace4 that specifies denial of all access. Note that some common practices, such as mapping the traditional user &#34;root&#34; to the user &#34;nobody&#34;, may make it incorrect to return the actual ACL of the file in the delegation response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ファイルの実際のACLよりも制限の厳しいnfsace4を返す場合があります。これには、すべてのアクセスの拒否を指定するnfsace4が含まれます。従来のユーザー「root」をユーザー「nobody」にマッピングするなど、一部の一般的な方法では、委任応答でファイルの実際のACLを返すことが正しくない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of delegation, together with various other forms of caching, creates the possibility that no server authentication will ever be performed for a given user since all of the user&#39;s requests might be satisfied locally. Where the client is depending on the server for authentication, the client should be sure authentication occurs for each user by use of the ACCESS operation. This should be the case even if an ACCESS operation would not be required otherwise. As mentioned before, the server may enforce frequent authentication by returning an nfsace4 denying all access with every open delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任の使用は、他のさまざまな形式のキャッシングとともに、ユーザーのすべての要求がローカルで満たされる可能性があるため、特定のユーザーに対してサーバー認証が実行されない可能性を生み出します。クライアントが認証をサーバーに依存している場合、クライアントはACCESS操作を使用して、ユーザーごとに認証が行われるようにする必要があります。これは、ACCESS操作が必要でない場合でも当てはまります。前述のように、サーバーは、開いているすべての委任ですべてのアクセスを拒否するnfsace4を返すことにより、頻繁な認証を実施する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.1. Open Delegation and Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.1. オープンな委任とデータキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN delegation allows much of the message overhead associated with the opening and closing files to be eliminated. An open when an open delegation is in effect does not require that a validation message be sent to the server unless there exists a potential for conflict with the requested share mode. The continued endurance of the &#34;OPEN_DELEGATE_READ delegation&#34; provides a guarantee that no OPEN for write and thus no write has occurred that did not originate from this client. Similarly, when closing a file opened for write and if OPEN_DELEGATE_WRITE delegation is in effect, the data written does not have to be flushed to the server until the open delegation is recalled. The continued endurance of the open delegation provides a guarantee that no open and thus no read or write has been done by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN委任により、ファイルのオープンとクローズに関連するメッセージオーバーヘッドの多くを排除できます。開いている委任が有効なときに開く場合、要求された共有モードとの競合の可能性がない限り、検証メッセージをサーバーに送信する必要はありません。 「OPEN_DELEGATE_READ委任」の継続的な耐久性により、書き込み用のOPENがないため、このクライアントから発生していない書き込みが発生していないことが保証されます。同様に、書き込み用に開いたファイルを閉じるとき、OPEN_DELEGATE_WRITE委任が有効な場合、開いた委任が呼び出されるまで、書き込まれたデータをサーバーにフラッシュする必要はありません。オープンな委任の継続的な耐久性は、他のクライアントによってオープンが行われず、したがって読み取りまたは書き込みが行われないことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of open delegation, READs and WRITEs done without an OPEN (anonymous and READ bypass stateids) are treated as the functional equivalents of a corresponding type of OPEN. READs and WRITEs done with an anonymous stateid done by another client will force the server to recall an OPEN_DELEGATE_WRITE delegation. A WRITE with an anonymous stateid done by another client will force a recall of OPEN_DELEGATE_READ delegations. The handling of a READ bypass stateid is identical, except that a READ done with a READ bypass stateid will not force a recall of an OPEN_DELEGATE_READ delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン委任の目的で、OPENなしで実行されるREADおよびWRITE（匿名およびREADバイパスステートID）は、対応するタイプのOPENと機能的に同等のものとして扱われます。別のクライアントによって行われた匿名状態IDで行われた読み取りと書き込みは、サーバーにOPEN_DELEGATE_WRITE委任を再呼び出しさせます。別のクライアントが匿名の状態IDを使用してWRITEを実行すると、OPEN_DELEGATE_READ委任が強制的に呼び出されます。 READバイパスステートIDの処理は同じですが、READバイパスステートIDを使用して実行されたREADはOPEN_DELEGATE_READ委任の再呼び出しを強制しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With delegations, a client is able to avoid writing data to the server when the CLOSE of a file is serviced. The file close system call is the usual point at which the client is notified of a lack of stable storage for the modified file data generated by the application. At the close, file data is written to the server, and through normal accounting the server is able to determine if the available file system space for the data has been exceeded (i.e., the server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT). This accounting includes quotas. The introduction of delegations requires that an alternative method be in place for the same type of communication to occur between client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任を使用すると、クライアントは、ファイルのCLOSEが処理されるときに、サーバーへのデータの書き込みを回避できます。ファイルクローズシステムコールは、アプリケーションによって生成された変更されたファイルデータ用の安定したストレージの不足をクライアントに通知する通常のポイントです。終了時に、ファイルデータがサーバーに書き込まれ、通常のアカウンティングを通じて、サーバーはデータに使用可能なファイルシステム領域を超えたかどうかを判別できます（つまり、サーバーはNFS4ERR_NOSPCまたはNFS4ERR_DQUOTを返します）。このアカウンティングには割り当てが含まれます。委任を導入するには、クライアントとサーバー間で同じ種類の通信を行うための代替方法を用意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In the delegation response, the server provides either the limit of the size of the file or the number of modified blocks and associated block size. The server must ensure that the client will be able to flush to the server data of a size equal to that provided in the original delegation. The server must make this assurance for all outstanding delegations. Therefore, the server must be careful in its management of available space for new or modified data, taking into account available file system space and any applicable quotas. The server can recall delegations as a result of managing the available file system space. The client should abide by the server&#39;s state space limits for delegations. If the client exceeds the stated limits for the delegation, the server&#39;s behavior is undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
委任応答では、サーバーはファイルのサイズの制限、または変更されたブロックの数と関連するブロックサイズのいずれかを提供します。サーバーは、クライアントが元の委任で提供されたものと同じサイズのデータ​​をサーバーにフラッシュできるようにする必要があります。サーバーは、すべての未解決の委任に対してこの保証を行う必要があります。したがって、サーバーは、使用可能なファイルシステムのスペースと適用可能なクォータを考慮して、新規または変更されたデータ用の使用可能なスペースの管理に注意する必要があります。サーバーは、使用可能なファイルシステム領域を管理した結果、委任を呼び出すことができます。クライアントは、委任に関するサーバーの状態スペース制限を遵守する必要があります。クライアントが指定された委任の制限を超えると、サーバーの動作は未定義になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on server conditions, quotas, or available file system space, the server may grant OPEN_DELEGATE_WRITE delegations with very restrictive space limitations. The limitations may be defined in a way that will always force modified data to be flushed to the server on close.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの状態、割り当て量、または使用可能なファイルシステム領域に基づいて、サーバーは、OPEN_DELEGATE_WRITE委任を非常に制限された領域制限で許可する場合があります。制限は、変更されたデータを常に閉じるときに強制的にサーバーにフラッシュするように定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With respect to authentication, flushing modified data to the server after a CLOSE has occurred may be problematic. For example, the user of the application may have logged off the client, and unexpired authentication credentials may not be present. In this case, the client may need to take special care to ensure that local unexpired credentials will in fact be available. One way that this may be accomplished is by tracking the expiration time of credentials and flushing data well in advance of their expiration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証に関しては、CLOSEが発生した後に変更されたデータをサーバーにフラッシュすることは問題となる場合があります。たとえば、アプリケーションのユーザーがクライアントからログオフし、有効期限が切れていない認証資格情報が存在しない場合があります。この場合、クライアントは、有効期限が切れていないローカルの資格情報が実際に使用可能になるように特別な注意を払う必要がある場合があります。これを実現する方法の1つは、資格情報の有効期限を追跡し、有効期限が切れる前にデータをフラッシュすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.2. Open Delegation and File Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.2. 委任とファイルロックを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_WRITE delegation, lock operations may be performed locally. This includes those required for mandatory file locking. This can be done since the delegation implies that there can be no conflicting locks. Similarly, all of the revalidations that would normally be associated with obtaining locks and the flushing of data associated with the releasing of locks need not be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合、ロック操作がローカルで実行される場合があります。これには、必須のファイルロックに必要なものが含まれます。委任は競合するロックがないことを暗示しているため、これを行うことができます。同様に、通常はロックの取得に関連するすべての再検証と、ロックの解放に関連するデータのフラッシュを実行する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_READ delegation, lock operations are not performed locally. All lock operations, including those requesting non-exclusive locks, are sent to the server for resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_READ委任を保持している場合、ロック操作はローカルでは実行されません。非排他的ロックを要求するものを含むすべてのロック操作は、解決のためにサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.3. Handling of CB_GETATTR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.3. CB_GETATTRの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server needs to employ special handling for a GETATTR where the target is a file that has an OPEN_DELEGATE_WRITE delegation in effect. The reason for this is that the client holding the OPEN_DELEGATE_WRITE delegation may have modified the data, and the server needs to reflect this change to the second client that submitted the GETATTR. Therefore, the client holding the OPEN_DELEGATE_WRITE delegation needs to be interrogated. The server will use the CB_GETATTR operation. The only attributes that the server can reliably query via CB_GETATTR are size and change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ターゲットがOPEN_DELEGATE_WRITE委任が有効になっているファイルであるGETATTRに対して特別な処理を採用する必要があります。これは、OPEN_DELEGATE_WRITE委任を保持しているクライアントがデータを変更した可能性があり、サーバーがこの変更をGETATTRを送信した2番目のクライアントに反映する必要があるためです。したがって、OPEN_DELEGATE_WRITE委任を保持しているクライアントに問い合わせる必要があります。サーバーはCB_GETATTR操作を使用します。サーバーがCB_GETATTRを介して確実に照会できる属性は、サイズと変更のみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since CB_GETATTR is being used to satisfy another client&#39;s GETATTR request, the server only needs to know if the client holding the delegation has a modified version of the file. If the client&#39;s copy of the delegated file is not modified (data or size), the server can satisfy the second client&#39;s GETATTR request from the attributes stored locally at the server. If the file is modified, the server only needs to know about this modified state. If the server determines that the file is currently modified, it will respond to the second client&#39;s GETATTR as if the file had been modified locally at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_GETATTRは別のクライアントのGETATTR要求を満たすために使用されているため、サーバーは、委任を保持しているクライアントが変更されたバージョンのファイルを持っているかどうかを知るだけで済みます。委任されたファイルのクライアントのコピーが変更されていない場合（データまたはサイズ）、サーバーは、サーバーにローカルに格納されている属性からの2番目のクライアントのGETATTR要求を満たすことができます。ファイルが変更された場合、サーバーはこの変更された状態についてのみ知る必要があります。ファイルが現在変更されているとサーバーが判断すると、サーバーでファイルがローカルで変更されたかのように、2番目のクライアントのGETATTRに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the form of the change attribute is determined by the server and is opaque to the client, the client and server need to agree on a method of communicating the modified state of the file. For the size attribute, the client will report its current view of the file size. For the change attribute, the handling is more involved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性の形式はサーバーによって決定され、クライアントに対して不透明であるため、クライアントとサーバーは、ファイルの変更された状態を通信する方法について合意する必要があります。 size属性の場合、クライアントはファイルサイズの現在のビューを報告します。変更属性の場合、処理はより複雑になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the client, the following steps will be taken when receiving an OPEN_DELEGATE_WRITE delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの場合、OPEN_DELEGATE_WRITE委任を受信すると、次の手順が実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value of the change attribute will be obtained from the server and cached. Let this value be represented by c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 変更属性の値はサーバーから取得され、キャッシュされます。この値をcで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client will create a value greater than c that will be used for communicating that modified data is held at the client. Let this value be represented by d.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、変更されたデータがクライアントで保持されていることを伝えるために使用されるcより大きい値を作成します。この値をdで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the client is queried via CB_GETATTR for the change attribute, it checks to see if it holds modified data. If the file is modified, the value d is returned for the change attribute value. If this file is not currently modified, the client returns the value c for the change attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、CB_GETATTRを介して変更属性を照会されると、変更されたデータを保持しているかどうかを確認します。ファイルが変更されると、変更属性値として値dが返されます。このファイルが現在変更されていない場合、クライアントは、変更属性の値cを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For simplicity of implementation, the client MAY for each CB_GETATTR return the same value d. This is true even if, between successive CB_GETATTR operations, the client again modifies in the file&#39;s data or metadata in its cache. The client can return the same value because the only requirement is that the client be able to indicate to the server that the client holds modified data. Therefore, the value of d may always be c + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装を簡単にするために、各CB_GETATTRのクライアントは同じ値dを返す場合があります。これは、連続するCB_GETATTR操作の間に、クライアントがキャッシュ内のファイルのデータまたはメタデータを再度変更した場合でも当てはまります。クライアントが変更されたデータを保持していることをクライアントがサーバーに示すことができることが唯一の要件であるため、クライアントは同じ値を返すことができます。したがって、dの値は常にc + 1になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 While the change attribute is opaque to the client in the sense that it has no idea what units of time, if any, the server is counting change with, it is not opaque in that the client has to treat it as an unsigned integer, and the server has to be able to see the results of the client&#39;s changes to that integer. Therefore, the server MUST encode the change attribute in network byte order when sending it to the client. The client MUST decode it from network byte order to its native order when receiving it, and the client MUST encode it in network byte order when sending it to the server. For this reason, the change attribute is defined as an unsigned integer rather than an opaque array of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
change属性は、サーバーが変更をカウントしている時間単位がある場合、その意味がわからないという意味でクライアントに対して不透明ですが、クライアントがそれを符号なし整数として処理する必要があるという点では不透明ではありません。サーバーは、その整数に対するクライアントの変更の結果を見ることができる必要があります。したがって、サーバーは、クライアントに送信するときに、変更属性をネットワークバイトオーダーでエンコードする必要があります。クライアントはそれを受信するときに、ネットワークバイトオーダーからそのネイティブオーダーにデコードする必要があり、クライアントは、サーバーに送信するときにネットワークバイトオーダーでエンコードする必要があります。このため、変更属性は、不透明なバイト配列ではなく、符号なし整数として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the server, the following steps will be taken when providing an OPEN_DELEGATE_WRITE delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの場合、OPEN_DELEGATE_WRITE委任を提供するときに次の手順が実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upon providing an OPEN_DELEGATE_WRITE delegation, the server will cache a copy of the change attribute in the data structure it uses to record the delegation. Let this value be represented by sc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任を提供すると、サーバーは、変更属性のコピーを、委任の記録に使用するデータ構造にキャッシュします。この値をscで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a second client sends a GETATTR operation on the same file to the server, the server obtains the change attribute from the first client. Let this value be cc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2番目のクライアントが同じファイルのGETATTR操作をサーバーに送信すると、サーバーは最初のクライアントから変更属性を取得します。この値をccとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the value cc is equal to sc, the file is not modified and the server returns the current values for change, time_metadata, and time_modify (for example) to the second client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 値ccがscと等しい場合、ファイルは変更されず、サーバーは変更、time_metadata、time_modifyなどの現在の値を2番目のクライアントに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the value cc is NOT equal to sc, the file is currently modified at the first client and most likely will be modified at the server at a future time. The server then uses its current time to construct attribute values for time_metadata and time_modify. A new value of sc, which we will call nsc, is computed by the server, such that nsc &gt;= sc + 1. The server then returns the constructed time_metadata, time_modify, and nsc values to the requester. The server replaces sc in the delegation record with nsc. To prevent the possibility of time_modify, time_metadata, and change from appearing to go backward (which would happen if the client holding the delegation fails to write its modified data to the server before the delegation is revoked or returned), the server SHOULD update the file&#39;s metadata record with the constructed attribute values. For reasons of reasonable performance, committing the constructed attribute values to stable storage is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 値ccがscと等しくない場合、ファイルは現在最初のクライアントで変更されており、おそらくサーバーで将来変更されます。次に、サーバーは現在の時刻を使用して、time_metadataおよびtime_modifyの属性値を作成します。 nscと呼ぶscの新しい値は、nsc&gt; = sc + 1のようにサーバーによって計算されます。サーバーは、構築されたtime_metadata、time_modify、およびnscの値をリクエスターに返します。サーバーは、委任レコードのscをnscに置き換えます。 time_modify、time_metadata、およびchangeが後退するように見える可能性を回避するには（委任が取り消されるか戻される前に、委任を保持しているクライアントが変更されたデータをサーバーに書き込めなかった場合に発生します）、サーバーはファイルの更新を行う必要があります（SHOULD）構築された属性値を持つメタデータレコード。妥当なパフォーマンスの理由から、構築された属性値を安定したストレージにコミットすることはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As discussed earlier in this section, the client MAY return the same cc value on subsequent CB_GETATTR calls, even if the file was modified in the client&#39;s cache yet again between successive CB_GETATTR calls. Therefore, the server must assume that the file has been modified yet again and MUST take care to ensure that the new nsc it constructs and returns is greater than the previous nsc it returned. An example implementation&#39;s delegation record would satisfy this mandate by including a boolean field (let us call it &#34;modified&#34;) that is set to FALSE when the delegation is granted, and an sc value set at the time of grant to the change attribute value. The modified field would be set to TRUE the first time cc != sc and would stay TRUE until the delegation is returned or revoked. The processing for constructing nsc, time_modify, and time_metadata would use this pseudo-code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このセクションの前半で説明したように、連続するCB_GETATTR呼び出しの間にファイルがクライアントのキャッシュで変更されていても、クライアントは後続のCB_GETATTR呼び出しで同じcc値を返す場合があります。したがって、サーバーはファイルがまだ変更されていると想定する必要があり、作成して返す新しいnscが以前に返したnscよりも大きくなるように注意する必要があります。実装例の委任レコードは、委任が許可されたときにFALSEに設定されたブールフィールド（「変更済み」と呼ぶ）と、変更属性値への許可時に設定されたsc値を含めることにより、この要件を満たします。変更されたフィールドは、初めてcc！= scにTRUEに設定され、委任が返されるか取り消されるまでTRUEのままになります。 nsc、time_modify、およびtime_metadataを作成する処理では、次の疑似コードを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (!modified) {
           do CB_GETATTR for change and size;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (cc != sc)
               modified = TRUE;
       } else {
           do CB_GETATTR for size;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (modified) {
           sc = sc + 1;
           time_modify = time_metadata = current_time;
           update sc, time_modify, time_metadata into file&#39;s metadata;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This would return to the client (that sent GETATTR) the attributes it requested but would make sure that size comes from what CB_GETATTR returned. The server would not update the file&#39;s metadata with the client&#39;s modified size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、要求された属性（GETATTRを送信した）がクライアントに返されますが、サイズがCB_GETATTRが返したものに由来することが確認されます。サーバーは、クライアントの変更されたサイズでファイルのメタデータを更新しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the file attribute size is different than the server&#39;s current value, the server treats this as a modification regardless of the value of the change attribute retrieved via CB_GETATTR and responds to the second client as in the last step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル属性のサイズがサーバーの現在の値と異なる場合、サーバーは、CB_GETATTRを介して取得した変更属性の値に関係なく、これを変更として扱い、最後の手順と同様に2番目のクライアントに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This methodology resolves issues of clock differences between client and server and other scenarios where the use of CB_GETATTR breaks down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法論は、クライアントとサーバー間のクロックの違いの問題と、CB_GETATTRの使用が失敗する他のシナリオを解決します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that the server is under no obligation to use CB_GETATTR; therefore, the server MAY simply recall the delegation to avoid its use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCB_GETATTRを使用する義務がないことに注意してください。したがって、サーバーはその使用を回避するために委任を単に呼び出してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.4. Recall of Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.4. オープンな委任の想起
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following events necessitate the recall of an open delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のイベントでは、オープンな委任を呼び戻す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Potentially conflicting OPEN request (or READ/WRITE done with &#34;special&#34; stateid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 競合する可能性のあるOPEN要求（または「特別な」stateidで行われるREAD / WRITE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o SETATTR issued by another client o REMOVE request for the file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o別のクライアントによって発行されたSETATTR oファイルのREMOVE要求
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAME request for the file as either source or target of the RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAMEのソースまたはターゲットとしてのファイルのRENAME要求
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether a RENAME of a directory in the path leading to the file results in the recall of an open delegation depends on the semantics of the server file system. If that file system denies such RENAMEs when a file is open, the recall must be performed to determine whether the file in question is, in fact, open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルへのパスにあるディレクトリのRENAMEによってオープンな委任が呼び戻されるかどうかは、サーバーファイルシステムのセマンティクスによって異なります。ファイルが開いているときにそのファイルシステムがそのようなRENAMEを拒否した場合、問題のファイルが実際に開いているかどうかを判断するために再呼び出しを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the situations above, the server may choose to recall open delegations at any time if resource constraints make it advisable to do so. Clients should always be prepared for the possibility of a recall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の状況に加えて、リソースの制約によりそうすることが推奨されている場合、サーバーはいつでも開いている委任を呼び出すことを選択できます。クライアントは常にリコールの可能性に備える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives a recall for an open delegation, it needs to update state on the server before returning the delegation. These same updates must be done whenever a client chooses to return a delegation voluntarily. The following items of state need to be dealt with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、開いている委任の取り消しを受信すると、委任を返す前にサーバーの状態を更新する必要があります。これらの同じ更新は、クライアントが自発的に委任を返すことを選択するたびに実行する必要があります。以下の状態の項目を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the file associated with the delegation is no longer open and no previous CLOSE operation has been sent to the server, a CLOSE operation must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任に関連付けられているファイルが開かれておらず、以前のCLOSE操作がサーバーに送信されていない場合は、CLOSE操作をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a file has other open references at the client, then OPEN operations must be sent to the server. The appropriate stateids will be provided by the server for subsequent use by the client since the delegation stateid will not longer be valid. These OPEN requests are done with the claim type of CLAIM_DELEGATE_CUR. This will allow the presentation of the delegation stateid so that the client can establish the appropriate rights to perform the OPEN. (See Section 16.16 for details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルにクライアントで他の開いている参照がある場合、OPEN操作をサーバーに送信する必要があります。委任状態IDは有効でなくなるため、サーバーが適切な状態IDを提供し、クライアントが後で使用できるようにします。これらのOPEN要求は、CLAIM_DELEGATE_CURのクレームタイプで実行されます。これにより、クライアントがOPENを実行するための適切な権限を確立できるように、委任状態IDを提示できます。 （詳細については、セクション16.16を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there are granted file locks, the corresponding LOCK operations need to be performed. This applies to the OPEN_DELEGATE_WRITE delegation case only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 許可されたファイルロックがある場合、対応するLOCK操作を実行する必要があります。これは、OPEN_DELEGATE_WRITE委任の場合にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For an OPEN_DELEGATE_WRITE delegation, if at the time of the recall the file is not open for write, all modified data for the file must be flushed to the server. If the delegation had not existed, the client would have done this data flush before the CLOSE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任の場合、再呼び出し時にファイルが書き込み用に開かれていない場合、ファイルのすべての変更済みデータをサーバーにフラッシュする必要があります。委任が存在しなかった場合、クライアントはCLOSE操作の前にこのデータフラッシュを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For an OPEN_DELEGATE_WRITE delegation, when a file is still open at the time of the recall, any modified data for the file needs to be flushed to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任の場合、再呼び出し時にファイルがまだ開いているときは、ファイルの変更されたデータをサーバーにフラッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o With the OPEN_DELEGATE_WRITE delegation in place, it is possible that the file was truncated during the duration of the delegation. For example, the truncation could have occurred as a result of an OPEN UNCHECKED4 with a size attribute value of zero. Therefore, if a truncation of the file has occurred and this operation has not been propagated to the server, the truncation must occur before any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任が設定されていると、委任の実行中にファイルが切り捨てられた可能性があります。たとえば、サイズ属性値がゼロのOPEN UNCHECKED4の結果として切り捨てが発生した可能性があります。したがって、ファイルの切り捨てが発生し、この操作がサーバーに伝達されていない場合、変更されたデータがサーバーに書き込まれる前に切り捨てが行われる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of an OPEN_DELEGATE_WRITE delegation, file locking imposes some additional requirements. To precisely maintain the associated invariant, it is required to flush any modified data in any region for which a write lock was released while the OPEN_DELEGATE_WRITE delegation was in effect. However, because the OPEN_DELEGATE_WRITE delegation implies no other locking by other clients, a simpler implementation is to flush all modified data for the file (as described just above) if any write lock has been released while the OPEN_DELEGATE_WRITE delegation was in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN_DELEGATE_WRITE委任の場合、ファイルロックはいくつかの追加要件を課します。関連する不変条件を正確に維持するには、OPEN_DELEGATE_WRITE委任が有効である間に書き込みロックが解放されたすべての領域で、変更されたデータをフラッシュする必要があります。ただし、OPEN_DELEGATE_WRITE委任が他のクライアントによる他のロックを意味しないため、OPEN_DELEGATE_WRITE委任が有効である間に書き込みロックが解放された場合、より簡単な実装は、（上記のように）ファイルのすべての変更データをフラッシュすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation need not wait until delegation recall (or deciding to voluntarily return a delegation) to perform any of the above actions, if implementation considerations (e.g., resource availability constraints) make that desirable. Generally, however, the fact that the actual open state of the file may continue to change makes it not worthwhile to send information about opens and closes to the server, except as part of delegation return. Only in the case of closing the open that resulted in obtaining the delegation would clients be likely to do this early, since, in that case, the close once done will not be undone. Regardless of the client&#39;s choices on scheduling these actions, all must be performed before the delegation is returned, including (when applicable) the close that corresponds to the open that resulted in the delegation. These actions can be performed either in previous requests or in previous operations in the same COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装の考慮事項（リソースの可用性の制約など）により望ましい場合は、実装は、委任の取り消し（または委任を自発的に返すことを決定する）まで待機して、上記のアクションを実行する必要はありません。ただし、一般に、ファイルの実際のオープン状態が変化し続ける可能性があるため、委任の返却の場合を除いて、オープンとクローズに関する情報をサーバーに送信する価値はありません。委任を取得する結果となったオープンを閉じる場合にのみ、クライアントはこれを早期に行う可能性があります。その場合、一度行われたクローズは元に戻されないためです。これらのアクションのスケジュールに関するクライアントの選択に関係なく、委任が発生したオープンに対応するクローズ（該当する場合）を含め、すべてが委任が返される前に実行する必要があります。これらのアクションは、同じCOMPOUNDリクエストの以前のリクエストまたは以前の操作で実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.5. OPEN Delegation Race with CB_RECALL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.5. CB_RECALLによるOPEN委任レース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server informs the client of a recall via a CB_RECALL. A race case that may develop is when the delegation is immediately recalled before the COMPOUND that established the delegation is returned to the client. As the CB_RECALL provides both a stateid and a filehandle for which the client has no mapping, it cannot honor the recall attempt. At this point, the client has two choices: either do not respond or respond with NFS4ERR_BADHANDLE. If it does not respond, then it runs the risk of the server deciding to not grant it further delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、CB_RECALLを介して再呼び出しをクライアントに通知します。発生する可能性があるレースケースは、委任を確立したCOMPOUNDがクライアントに返される前に、委任がすぐにリコールされる場合です。 CB_RECALLは、クライアントがマッピングしていない状態IDとファイルハンドルの両方を提供するため、再呼び出しの試みを受け入れることができません。この時点で、クライアントには2つの選択肢があります。応答しないか、NFS4ERR_BADHANDLEで応答します。応答しない場合は、サーバーにそれ以上の委任を許可しないと決定するリスクがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If instead it does reply with NFS4ERR_BADHANDLE, then both the client and the server might be able to detect that a race condition is occurring. The client can keep a list of pending delegations. When it receives a CB_RECALL for an unknown delegation, it can cache the stateid and filehandle on a list of pending recalls. When it is provided with a delegation, it would only use it if it was not on the pending recall list. Upon the next CB_RECALL, it could immediately return the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代わりにNFS4ERR_BADHANDLEで応答する場合、クライアントとサーバーの両方が競合状態が発生していることを検出できる可能性があります。クライアントは保留中の委任のリストを保持できます。不明な委任のCB_RECALLを受信すると、保留中の再呼び出しのリストにstateidとファイルハンドルをキャッシュできます。委任が提供されると、保留中のリコールリストにない場合にのみ使用されます。次のCB_RECALLで、すぐに委任を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In turn, the server can keep track of when it issues a delegation and assume that if a client responds to the CB_RECALL with an NFS4ERR_BADHANDLE, then the client has yet to receive the delegation. The server SHOULD give the client a reasonable time both to get this delegation and to return it before revoking the delegation. Unlike a failed callback path, the server should periodically probe the client with CB_RECALL to see if it has received the delegation and is ready to return it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、サーバーは委任を発行するタイミングを追跡し、クライアントがNFS4ERR_BADHANDLEでCB_RECALLに応答した場合、クライアントはまだ委任を受信して​​いないと想定できます。サーバーは、この委任を取得するためと、委任を取り消す前にそれを返すための適切な時間をクライアントに与える必要があります。失敗したコールバックパスとは異なり、サーバーは定期的にCB_RECALLを使用してクライアントを調査し、委任を受信して​​それを返す準備ができているかどうかを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server finally determines that enough time has elapsed, it SHOULD revoke the delegation and it SHOULD NOT revoke the lease. During this extended recall process, the server SHOULD be renewing the client lease. The intent here is that the client not pay too onerous a burden for a condition caused by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
十分な時間が経過したとサーバーが最終的に判断した場合、サーバーは委任を取り消す必要があり（SHOULD）、リースを取り消すべきではありません（SHOULD NOT）。この拡張再呼び出しプロセスの間、サーバーはクライアントのリースを更新する必要があります（SHOULD）。ここでの意図は、クライアントがサーバーによって引き起こされた状態に負担をかけすぎないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.6. Clients That Fail to Honor Delegation Recalls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.6. 委任取り消しを受け入れられないクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may fail to respond to a recall for various reasons, such as a failure of the callback path from the server to the client. The client may be unaware of a failure in the callback path. This lack of awareness could result in the client finding out long after the failure that its delegation has been revoked, and another client has modified the data for which the client had a delegation. This is especially a problem for the client that held an OPEN_DELEGATE_WRITE delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーからクライアントへのコールバックパスの失敗など、さまざまな理由でリコールに応答できない場合があります。クライアントは、コールバックパスの障害に気付かない可能性があります。この認識の欠如により、クライアントは、委任が取り消されたことが障害のずっと後に判明し、別のクライアントがクライアントが委任したデータを変更した可能性があります。これは、OPEN_DELEGATE_WRITE委任を保持していたクライアントにとって特に問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server also has a dilemma in that the client that fails to respond to the recall might also be sending other NFS requests, including those that renew the lease before the lease expires. Without returning an error for those lease-renewing operations, the server leads the client to believe that the delegation it has is in force.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、サーバーは、呼び戻しに応答しないクライアントが他のNFS要求を送信している可能性があるというジレンマも抱えています。これには、リースの有効期限が切れる前にリースを更新するものも含まれます。これらのリース更新操作についてエラーを返さずに、サーバーはクライアントに、委任が有効であると信じ込ませます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This difficulty is solved by the following rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題は、次のルールによって解決されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the callback path is down, the server MUST NOT revoke the delegation if one of the following occurs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コールバックパスがダウンしているときに、次のいずれかが発生した場合、サーバーは委任を取り消してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The client has issued a RENEW operation, and the server has returned an NFS4ERR_CB_PATH_DOWN error. The server MUST renew the lease for any byte-range locks and share reservations the client has that the server has known about (as opposed to those locks and share reservations the client has established but not yet sent to the server, due to the delegation). The server SHOULD give the client a reasonable time to return its delegations to the server before revoking the client&#39;s delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントがRENEW操作を発行し、サーバーがNFS4ERR_CB_PATH_DOWNエラーを返しました。サーバーは、クライアントがサーバーが認識しているバイト範囲ロックおよび共有予約のリースを更新する必要があります（委任により、クライアントが確立したがサーバーにまだ送信されていないロックおよび共有予約とは対照的） 。サーバーは、クライアントの委任を取り消す前に、その委任をサーバーに返すための適切な時間をクライアントに与える必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The client has not issued a RENEW operation for some period of time after the server attempted to recall the delegation. This period of time MUST NOT be less than the value of the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* サーバーが委任を取り消そうとした後、クライアントはしばらくの間RENEW操作を発行しませんでした。この期間は、lease_time属性の値よりも小さくしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the client holds a delegation, it cannot rely on operations, except for RENEW, that take a stateid, to renew delegation leases across callback path failures. The client that wants to keep delegations in force across callback path failures must use RENEW to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが委任を保持している場合、stateidを使用するRENEWを除いて、コールバックパスの障害が発生したときに委任リースを更新する操作に依存することはできません。コールバックパスの障害が発生しても委任を有効に保ちたいクライアントは、RENEWを使用してこれを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.7. Delegation Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.7. 委任の取り消し
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the point a delegation is revoked, if there are associated opens on the client, the applications holding these opens need to be notified. This notification usually occurs by returning errors for READ/WRITE operations or when a close is attempted for the open file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が取り消された時点で、クライアントに関連付けられたオープンがある場合、これらのオープンを保持しているアプリケーションに通知する必要があります。この通知は通常、READ / WRITE操作のエラーを返すことによって、または開いているファイルに対してクローズが試行されたときに発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If no opens exist for the file at the point the delegation is revoked, then notification of the revocation is unnecessary. However, if there is modified data present at the client for the file, the user of the application should be notified. Unfortunately, it may not be possible to notify the user since active applications may not be present at the client. See Section 10.5.1 for additional details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が取り消された時点でファイルのオープンが存在しない場合、取り消しの通知は不要です。ただし、ファイルにクライアントで変更されたデータが存在する場合は、アプリケーションのユーザーに通知する必要があります。残念ながら、アクティブなアプリケーションがクライアントに存在しない可能性があるため、ユーザーに通知することができない場合があります。詳細については、セクション10.5.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. Data Caching and Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. データのキャッシュと失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When locks and delegations are revoked, the assumptions upon which successful caching depend are no longer guaranteed. For any locks or share reservations that have been revoked, the corresponding owner needs to be notified. This notification includes applications with a file open that has a corresponding delegation that has been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックと委任が取り消されると、キャッシュの成功に依存する前提は保証されなくなります。取り消されたロックまたは共有の予約については、対応する所有者に通知する必要があります。この通知には、取り消された対応する委任を持つファイルが開かれているアプリケーションが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cached data associated with the revocation must be removed from the client. In the case of modified data existing in the client&#39;s cache, that data must be removed from the client without it being written to the server. As mentioned, the assumptions made by the client are no longer valid at the point when a lock or delegation has been revoked. For example, another client may have been granted a conflicting lock after the revocation of the lock at the first client. Therefore, the data within the lock range may have been modified by the other client. Obviously, the first client is unable to guarantee to the application what has occurred to the file in the case of revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
失効に関連付けられたキャッシュデータは、クライアントから削除する必要があります。クライアントのキャッシュに存在する変更されたデータの場合、そのデータはサーバーに書き込まれずにクライアントから削除する必要があります。前述のように、クライアントが行った前提は、ロックまたは委任が取り消された時点では無効になります。たとえば、別のクライアントは、最初のクライアントでのロックの取り消し後に、競合するロックを許可されている場合があります。したがって、ロック範囲内のデータが他のクライアントによって変更された可能性があります。明らかに、最初のクライアントは、失効の場合にファイルに何が起こったかをアプリケーションに保証することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notification to a lock-owner will in many cases consist of simply returning an error on the next and all subsequent READs/WRITEs to the open file or on the close. Where the methods available to a client make such notification impossible because errors for certain operations may not be returned, more drastic action, such as signals or process termination, may be appropriate. The justification for this is that an invariant on which an application depends may be violated. Depending on how errors are typically treated for the client operating environment, further levels of notification, including logging, console messages, and GUI pop-ups, may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック所有者への通知は、多くの場合、開いているファイルへの次の、およびその後のすべての読み取り/書き込みまたは閉じるときにエラーを返すだけです。特定の操作のエラーが返されない可能性があるため、クライアントが使用できるメソッドがそのような通知を不可能にする場合は、シグナルやプロセスの終了などのより徹底的なアクションが適切な場合があります。これの正当性は、アプリケーションが依存する不変条件に違反する可能性があることです。クライアントのオペレーティング環境でエラーが通常どのように処理されるかに応じて、ロギング、コンソールメッセージ、GUIポップアップなど、さらに高いレベルの通知が適切な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.1. Revocation Recovery for Write Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.1. 書き込みオープン委任の失効回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Revocation recovery for an OPEN_DELEGATE_WRITE delegation poses the special issue of modified data in the client cache while the file is not open. In this situation, any client that does not flush modified data to the server on each close must ensure that the user receives appropriate notification of the failure as a result of the revocation. Since such situations may require human action to correct problems, notification schemes in which the appropriate user or administrator is notified may be necessary. Logging and console messages are typical examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN_DELEGATE_WRITE委任の失効回復は、ファイルが開いていないときにクライアントキャッシュに変更されたデータの特別な問題を引き起こします。この状況では、閉じるたびに変更されたデータをサーバーにフラッシュしないクライアントは、失効の結果としてユーザーが失敗の適切な通知を確実に受け取るようにする必要があります。このような状況では、問題を修正するために人間のアクションが必要になる場合があるため、適切なユーザーまたは管理者に通知する通知スキームが必要になる場合があります。ロギングおよびコンソールメッセージは典型的な例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is modified data on the client, it must not be flushed normally to the server. A client may attempt to provide a copy of the file data as modified during the delegation under a different name in the file system namespace to ease recovery. Note that when the client can determine that the file has not been modified by any other client, or when the client has a complete cached copy of the file in question, such a saved copy of the client&#39;s view of the file may be of particular value for recovery. In other cases, recovery using a copy of the file, based partially on the client&#39;s cached data and partially on the server copy as modified by other clients, will be anything but straightforward, so clients may avoid saving file contents in these situations or mark the results specially to warn users of possible problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント上に変更されたデータがある場合、それをサーバーに正常にフラッシュしてはなりません。クライアントは、委任中に変更されたファイルデータのコピーを、回復を容易にするためにファイルシステムの名前空間の別の名前で提供しようとする場合があります。クライアントがファイルが他のクライアントによって変更されていないことを判別できる場合、またはクライアントに問題のファイルの完全なキャッシュされたコピーがある場合、ファイルのクライアントのビューのそのような保存されたコピーは特定の値である可能性があることに注意してください回復のため。他の場合では、一部がクライアントのキャッシュデータに、一部が他のクライアントによって変更されたサーバーコピーに基づいてファイルのコピーを使用したリカバリは簡単ではないため、クライアントはこれらの状況でファイルの内容を保存しないか、結果は特に可能性のある問題をユーザーに警告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The saving of such modified data in delegation revocation situations may be limited to files of a certain size or might be used only when sufficient disk space is available within the target file system. Such saving may also be restricted to situations when the client has sufficient buffering resources to keep the cached copy available until it is properly stored to the target file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任の取り消し状況でのこのような変更されたデータの保存は、特定のサイズのファイルに制限されるか、ターゲットファイルシステム内で十分なディスク領域が利用可能な場合にのみ使用されます。このような保存は、ターゲットファイルシステムに適切に保存されるまで、キャッシュされたコピーを利用可能な状態に保つのに十分なバッファリングリソースがクライアントにある場合にも制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. Attribute Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. 属性キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes discussed in this section do not include named attributes. Individual named attributes are analogous to files, and caching of the data for these needs to be handled just as data caching is for regular files. Similarly, LOOKUP results from an OPENATTR directory are to be cached on the same basis as any other pathnames and similarly for directory contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションで説明する属性には、名前付き属性は含まれていません。個々の名前付き属性はファイルに類似しており、これらのデータのキャッシュは、通常のファイルのデータキャッシュと同様に処理する必要があります。同様に、OPENATTRディレクトリからのLOOKUPの結果は、他のパス名と同じ基準で、ディレクトリの内容についても同様にキャッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients may cache file attributes obtained from the server and use them to avoid subsequent GETATTR requests. This cache is write through caching in that any modifications to the file attributes are always done by means of requests to the server, which means the modifications should not be done locally and should not be cached. Exceptions to this are modifications to attributes that are intimately connected with data caching. Therefore, extending a file by writing data to the local data cache is reflected immediately in the size as seen on the client without this change being immediately reflected on the server. Normally, such changes are not propagated directly to the server, but when the modified data is flushed to the server, analogous attribute changes are made on the server. When open delegation is in effect, the modified attributes may be returned to the server in the response to a CB_GETATTR call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはサーバーから取得したファイル属性をキャッシュし、それを使用して後続のGETATTR要求を回避できます。このキャッシュは、ファイル属性の変更が常にサーバーへの要求によって行われるという点で、キャッシュを介して書き込みが行われます。つまり、変更はローカルで行われるべきではなく、キャッシュされるべきではありません。これの例外は、データキャッシングと密接に関連している属性の変更です。したがって、ローカルデータキャッシュにデータを書き込んでファイルを拡張すると、この変更がサーバーにすぐに反映されることなく、クライアントに表示されるサイズにすぐに反映されます。通常、このような変更はサーバーに直接伝達されませんが、変更されたデータがサーバーにフラッシュされると、サーバーで同様の属性の変更が行われます。オープン委任が有効な場合、CB_GETATTR呼び出しへの応答で、変更された属性がサーバーに返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result of local caching of attributes is that the attribute caches maintained on individual clients will not be coherent. Changes made in one order on the server may be seen in a different order on one client and in a third order on a different client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性のローカルキャッシングの結果、個々のクライアントで維持される属性キャッシュは一貫しなくなります。サーバーで1つの順序で行われた変更は、1つのクライアントでは別の順序で、別のクライアントでは3番目の順序で表示される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The typical file system application programming interfaces do not provide means to atomically modify or interrogate attributes for multiple files at the same time. The following rules provide an environment where the potential incoherency mentioned above can be reasonably managed. These rules are derived from the practice of previous NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的なファイルシステムアプリケーションプログラミングインターフェイスは、複数のファイルの属性を同時にアトミックに変更または照会する手段を提供しません。次のルールは、上記の潜在的な矛盾を合理的に管理できる環境を提供します。これらのルールは、以前のNFSプロトコルの慣習から派生しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All attributes for a given file (per-fsid attributes excepted) are cached as a unit at the client so that no non-serializability can arise within the context of a single file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定のファイルのすべての属性（fsidごとの属性を除く）は、単一のファイルのコンテキスト内で非直列化が発生しないように、クライアントでユニットとしてキャッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An upper time boundary is maintained on how long a client cache entry can be kept without being refreshed from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのキャッシュエントリをサーバーから更新せずに保持できる時間の上限は維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When operations are performed that modify attributes at the server, the updated attribute set is requested as part of the containing RPC. This includes directory operations that update attributes indirectly. This is accomplished by following the modifying operation with a GETATTR operation and then using the results of the GETATTR to update the client&#39;s cached attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーで属性を変更する操作が実行されると、更新された属性セットが、含まれているRPCの一部として要求されます。これには、属性を間接的に更新するディレクトリ操作が含まれます。これは、GETATTR操作で変更操作を実行し、GETATTRの結果を使用してクライアントのキャッシュされた属性を更新することで実現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the full set of attributes to be cached is requested by READDIR, the results can be cached by the client on the same basis as attributes obtained via GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュする属性の完全なセットがREADDIRによって要求された場合、GETATTRを介して取得した属性と同じ基準で、クライアントが結果をキャッシュできることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may validate its cached version of attributes for a file by only fetching both the change and time_access attributes and assuming that if the change attribute has the same value as it did when the attributes were cached, then no attributes other than time_access have changed. The time_access attribute is also fetched because many servers operate in environments where the operation that updates change does not update time_access. For example, POSIX file semantics do not update access time when a file is modified by the write system call. Therefore, the client that wants a current time_access value should fetch it with change during the attribute cache validation processing and update its cached time_access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、change属性とtime_access属性の両方をフェッチするだけで、ファイルのキャッシュされたバージョンの属性を検証できます。また、change属性の値が属性のキャッシュ時と同じである場合、time_access以外の属性は変更されていないと想定します。多くのサーバーは、更新を変更する操作がtime_accessを更新しない環境で動作するため、time_access属性もフェッチされます。たとえば、POSIXファイルセマンティクスは、writeシステムコールによってファイルが変更された場合、アクセス時間を更新しません。したがって、現在のtime_access値を必要とするクライアントは、属性キャッシュの検証処理中に変更を加えてフェッチし、キャッシュされたtime_accessを更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client may maintain a cache of modified attributes for those attributes intimately connected with data of modified regular files (size, time_modify, and change). Other than those three attributes, the client MUST NOT maintain a cache of modified attributes. Instead, attribute changes are immediately sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、変更された通常のファイル（サイズ、time_modify、および変更）のデータと密接に関連している属性の変更された属性のキャッシュを維持できます。これらの3つの属性以外では、クライアントは変更された属性のキャッシュを維持してはなりません（MUST NOT）。代わりに、属性の変更はすぐにサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In some operating environments, the equivalent to time_access is expected to be implicitly updated by each read of the content of the file object. If an NFS client is caching the content of a file object, whether it is a regular file, directory, or symbolic link, the client SHOULD NOT update the time_access attribute (via SETATTR or a small READ or READDIR request) on the server with each read that is satisfied from cache. The reason is that this can defeat the performance benefits of caching content, especially since an explicit SETATTR of time_access may alter the change attribute on the server. If the change attribute changes, clients that are caching the content will think the content has changed and will re-read unmodified data from the server. Nor is the client encouraged to maintain a modified version of time_access in its cache, since this would mean that the client either will eventually have to write the access time to the server with bad performance effects or would never update the server&#39;s time_access, thereby resulting in a situation where an application that caches access time between a close and open of the same file observes the access time oscillating between the past and present. The time_access attribute always means the time of last access to a file by a READ that was satisfied by the server. This way, clients will tend to see only time_access changes that go forward in time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
一部のオペレーティング環境では、time_accessに相当するものが、ファイルオブジェクトのコンテンツを読み取るたびに暗黙的に更新されることが期待されます。通常のファイル、ディレクトリ、シンボリックリンクのいずれであるかに関係なく、NFSクライアントがファイルオブジェクトのコンテンツをキャッシュしている場合、クライアントは、サーバーのtime_access属性を（SETATTRまたは小さなREADまたはREADDIRリクエストを介して）更新しないでください。キャッシュから満たされる読み取り。その理由は、これにより、特にtime_accessの明示的なSETATTRがサーバーの変更属性を変更する可能性があるため、コンテンツのキャッシュによるパフォーマンスの利点が損なわれる可能性があるためです。変更属性が変更されると、コンテンツをキャッシュしているクライアントは、コンテンツが変更されたと見なし、変更されていないデータをサーバーから再度読み取ります。また、クライアントは変更されたバージョンのtime_accessをキャッシュに保持することを推奨されません。これは、クライアントが最終的にサーバーにアクセス時間を書き込み、パフォーマンスに悪影響を与えるか、サーバーのtime_accessを更新しないことを意味します。同じファイルのクローズとオープンの間のアクセス時間をキャッシュするアプリケーションが、過去と現在の間で変動するアクセス時間を観察する状況。 time_access属性は常に、サーバーによって満たされたREADによるファイルへの最後のアクセスの時刻を意味します。このようにして、クライアントは時間的に進むtime_accessの変更のみを確認する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. Data and Metadata Caching and Memory-Mapped Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. データとメタデータのキャッシュとメモリマップファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some operating environments include the capability for an application to map a file&#39;s content into the application&#39;s address space. Each time the application accesses a memory location that corresponds to a block that has not been loaded into the address space, a page fault occurs and the file is read (or if the block does not exist in the file, the block is allocated and then instantiated in the application&#39;s address space).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のオペレーティング環境には、アプリケーションがファイルのコンテンツをアプリケーションのアドレス空間にマップする機能が含まれています。アプリケーションがアドレス空間にロードされていないブロックに対応するメモリロケーションにアクセスするたびに、ページフォールトが発生し、ファイルが読み取られます（または、ブロックがファイルに存在しない場合は、ブロックが割り当てられてからアプリケーションのアドレス空間でインスタンス化されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As long as each memory-mapped access to the file requires a page fault, the relevant attributes of the file that are used to detect access and modification (time_access, time_metadata, time_modify, and change) will be updated. However, in many operating environments, when page faults are not required, these attributes will not be updated on reads or updates to the file via memory access (regardless of whether the file is a local file or is being accessed remotely). A client or server MAY fail to update attributes of a file that is being accessed via memory-mapped I/O. This has several implications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルへの各メモリマップアクセスにページフォールトが必要である限り、アクセスと変更の検出に使用されるファイルの関連属性（time_access、time_metadata、time_modify、およびchange）が更新されます。ただし、多くの動作環境では、ページフォールトが必要ない場合、これらの属性は、ファイルへの読み取りまたは更新時にメモリアクセスを介して更新されません（ファイルがローカルファイルであるか、リモートでアクセスされているかは関係ありません）。クライアントまたはサーバーは、メモリマップI / Oを介してアクセスされているファイルの属性の更新に失敗する場合があります。これにはいくつかの意味があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is an application on the server that has memory mapped a file that a client is also accessing, the client may not be able to get a consistent value of the change attribute to determine whether its cache is stale or not. A server that knows that the file is memory mapped could always pessimistically return updated values for change so as to force the application to always get the most up-to-date data and metadata for the file. However, due to the negative performance implications of this, such behavior is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントがアクセスしているファイルをメモリマップしたサーバー上のアプリケーションがある場合、クライアントは変更属性の一貫した値を取得できず、キャッシュが古いかどうかを判断できない場合があります。ファイルがメモリマップされていることを認識しているサーバーは、常に変更に対して更新された値を悲観的に返し、アプリケーションに常にファイルの最新のデータとメタデータを取得させることができます。ただし、これはパフォーマンスに悪影響を及ぼすため、このような動作はオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the memory-mapped file is not being modified on the server and instead is just being read by an application via the memory-mapped interface, the client will not see an updated time_access attribute. However, in many operating environments, neither will any process running on the server. Thus, NFS clients are at no disadvantage with respect to local processes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーでメモリマップファイルが変更されておらず、メモリマップインターフェイスを介してアプリケーションによって読み取られているだけの場合、クライアントには更新されたtime_access属性が表示されません。ただし、多くのオペレーティング環境では、サーバーで実行されるプロセスもありません。したがって、NFSクライアントは、ローカルプロセスに関して不利になることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o If there is another client that is memory mapping the file and if that client is holding an OPEN_DELEGATE_WRITE delegation, the same set of issues as discussed in the previous two bullet items apply. So, when a server does a CB_GETATTR to a file that the client has modified in its cache, the response from CB_GETATTR will not necessarily be accurate. As discussed earlier, the client&#39;s obligation is to report that the file has been modified since the delegation was granted, not whether it has been modified again between successive CB_GETATTR calls, and the server MUST assume that any file the client has modified in cache has been modified again between successive CB_GETATTR calls. Depending on the nature of the client&#39;s memory management system, this weak obligation may not be possible. A client MAY return stale information in CB_GETATTR whenever the file is memory mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oファイルをメモリマッピングしている別のクライアントがあり、そのクライアントがOPEN_DELEGATE_WRITE委任を保持している場合、前の2つの箇条書きで説明したのと同じ一連の問題が適用されます。したがって、クライアントがキャッシュで変更したファイルに対してサーバーがCB_GETATTRを実行する場合、CB_GETATTRからの応答は必ずしも正確ではありません。前述のように、クライアントの義務は、委任が許可されてからファイルが変更されたことを報告することであり、連続するCB_GETATTR呼び出しの間に再度変更されたかどうかではなく、サーバーは、クライアントがキャッシュで変更したファイルが連続するCB_GETATTR呼び出しの間で再度変更されました。クライアントのメモリ管理システムの性質によっては、この弱い義務が不可能な場合があります。クライアントは、ファイルがメモリマップされている場合は常に、古い情報をCB_GETATTRに返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The mixture of memory mapping and file locking on the same file is problematic. Consider the following scenario, where the page size on each client is 8192 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じファイルでのメモリマッピングとファイルロックの混在は問題があります。各クライアントのページサイズが8192バイトである次のシナリオを考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client A memory maps first page (8192 bytes) of file X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントAのメモリは、ファイルXの最初のページ（8192バイト）をマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client B memory maps first page (8192 bytes) of file X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントBのメモリは、ファイルXの最初のページ（8192バイト）をマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client A write locks first 4096 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントAの書き込みは、最初の4096バイトをロックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client B write locks second 4096 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントBの書き込みは、2番目の4096バイトをロックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client A, via a STORE instruction, modifies part of its locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントAは、STORE命令を使用して、ロックされた領域の一部を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Simultaneous to client A, client B issues a STORE on part of its locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントAと同時に、クライアントBはロックされた領域の一部にSTOREを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, the challenge is for each client to resynchronize to get a correct view of the first page. In many operating environments, the virtual memory management systems on each client only know a page is modified, not that a subset of the page corresponding to the respective lock regions has been modified. So it is not possible for each client to do the right thing, which is to only write to the server that portion of the page that is locked. For example, if client A simply writes out the page, and then client B writes out the page, client A&#39;s data is lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでの課題は、各クライアントが再同期して最初のページを正しく表示することです。多くのオペレーティング環境では、各クライアントの仮想メモリ管理システムはページが変更されたことだけを認識し、それぞれのロック領域に対応するページのサブセットが変更されたことを認識しません。そのため、各クライアントが正しいことを行うことはできません。つまり、ページのロックされている部分のみをサーバーに書き込みます。たとえば、クライアントAが単にページを書き込んだ後、クライアントBがそのページを書き込んだ場合、クライアントAのデータは失われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Moreover, if mandatory locking is enabled on the file, then we have a different problem. When clients A and B issue the STORE instructions, the resulting page faults require a byte-range lock on the entire page. Each client then tries to extend their locked range to the entire page, which results in a deadlock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、ファイルで強制ロックが有効になっている場合は、別の問題があります。クライアントAとBがSTORE命令を発行すると、結果として生じるページフォールトは、ページ全体のバイト範囲ロックを必要とします。次に、各クライアントはロックされた範囲をページ全体に拡張しようとしますが、デッドロックが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is difficult at best.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DEADLOCKエラーをSTORE命令に伝達することは、せいぜい困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client is locking the entire memory-mapped file, there is no problem with advisory or mandatory byte-range locking, at least until the client unlocks a region in the middle of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがメモリマップファイル全体をロックしている場合、少なくともクライアントがファイルの中央にある領域をロック解除するまで、勧告的または必須のバイト範囲ロックで問題はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above issues, the following are permitted:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の問題を考慮すると、次のことが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clients and servers MAY deny memory mapping a file they know there are byte-range locks for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーは、バイト範囲のロックがあることがわかっているファイルのメモリマッピングを拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clients and servers MAY deny a byte-range lock on a file they know is memory mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーは、メモリがマップされていることがわかっているファイルのバイト範囲ロックを拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client MAY deny memory mapping a file that it knows requires mandatory locking for I/O. If mandatory locking is enabled after the file is opened and mapped, the client MAY deny the application further access to its mapped file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、I / Oの必須ロックが必要であることがわかっているファイルのメモリマッピングを拒否する場合があります。ファイルが開かれてマップされた後に強制ロックが有効になっている場合、クライアントは、アプリケーションがマップされたファイルにそれ以上アクセスすることを拒否できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. Name Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. 名前のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of LOOKUP and READDIR operations may be cached to avoid the cost of subsequent LOOKUP operations. Just as in the case of attribute caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies and given the context of typical file system APIs, an upper time boundary is maintained on how long a client name cache entry can be kept without verifying that the entry has not been made invalid by a directory change operation performed by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPおよびREADDIR操作の結果は、後続のLOOKUP操作のコストを回避するためにキャッシュされる場合があります。属性キャッシュの場合と同様に、さまざまなクライアントキャッシュ間で不整合が発生する可能性があります。これらの不整合の影響を軽減し、一般的なファイルシステムAPIのコンテキストを考慮して、実行されたディレクトリ変更操作によってエントリが無効にされていないことを確認せずに、クライアント名キャッシュエントリを保持できる期間の上限が維持されます。別のクライアントによる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client is not making changes to a directory for which there exist name cache entries, the client needs to periodically fetch attributes for that directory to ensure that it is not being modified. After determining that no modification has occurred, the expiration time for the associated name cache entries may be updated to be the current time plus the name cache staleness bound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが名前キャッシュエントリが存在するディレクトリに変更を加えていない場合、クライアントはそのディレクトリの属性を定期的にフェッチして、変更されていないことを確認する必要があります。変更が発生していないと判断した後、関連付けられた名前キャッシュエントリの有効期限は、現在の時間に名前キャッシュの古さの限界を加えたものに更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a client is making changes to a given directory, it needs to determine whether there have been changes made to the directory by other clients. It does this by using the change attribute as reported before and after the directory operation in the associated change_info4 value returned for the operation. The server is able to communicate to the client whether the change_info4 data is provided atomically with respect to the directory operation. If the change values are provided atomically, the client is then able to compare the pre-operation change value with the change value in the client&#39;s name cache. If the comparison indicates that the directory was updated by another client, the name cache associated with the modified directory is purged from the client. If the comparison indicates no modification, the name cache can be updated on the client to reflect the directory operation and the associated timeout extended. The post-operation change value needs to be saved as the basis for future change_info4 comparisons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが特定のディレクトリに変更を加えているとき、他のクライアントによってディレクトリに加えられた変更があるかどうかを判断する必要があります。これは、操作に対して返された関連するchange_info4値のディレクトリ操作の前後に報告されているように、change属性を使用して行われます。サーバーは、change_info4データがディレクトリ操作に関してアトミックに提供されているかどうかをクライアントと通信できます。変更値がアトミックに提供される場合、クライアントは操作前の変更値をクライアントの名前キャッシュ内の変更値と比較できます。比較により、ディレクトリが別のクライアントによって更新されたことが示された場合、変更されたディレクトリに関連付けられた名前キャッシュはクライアントから削除されます。比較によって変更がないことが示された場合、クライアントで名前キャッシュを更新して、ディレクトリ操作と関連するタイムアウトを延長することができます。操作後の変更値は、将来のchange_info4比較の基礎として保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As demonstrated by the scenario above, name caching requires that the client revalidate name cache data by inspecting the change attribute of a directory at the point when the name cache item was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory are modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のシナリオで示されているように、名前キャッシュでは、名前キャッシュアイテムがキャッシュされた時点でディレクトリの変更属性を検査して、クライアントが名前キャッシュデータを再検証する必要があります。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがchange_info4情報を適切かつ正しく使用するには、サーバーは操作前および操作後の変更属性値をアトミックに報告する必要があります。サーバーがディレクトリ操作に関して前の値と後の値をアトミックに報告できない場合、サーバーはその事実をchange_info4の戻り値に示す必要があります。情報がアトミックに報告されない場合、クライアントは、他のクライアントがディレクトリを変更していないと想定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. Directory Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. ディレクトリキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of READDIR operations may be used to avoid subsequent READDIR operations. Just as in the cases of attribute and name caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies, and given the context of typical file system APIs, the following rules should be followed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作の結果は、後続のREADDIR操作を回避するために使用できます。属性と名前のキャッシュの場合と同様に、さまざまなクライアントキャッシュ間で不整合が発生する可能性があります。これらの不整合の影響を軽減し、一般的なファイルシステムAPIのコンテキストを前提として、次のルールに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cached READDIR information for a directory that is not obtained in a single READDIR operation must always be a consistent snapshot of directory contents. This is determined by using a GETATTR before the first READDIR and after the last READDIR that contributes to the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 単一のREADDIR操作で取得されないディレクトリのキャッシュされたREADDIR情報は、常にディレクトリの内容の一貫したスナップショットである必要があります。これは、最初のREADDIRの前と、キャッシュに寄与する最後のREADDIRの後にGETATTRを使用することによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An upper time boundary is maintained to indicate the length of time a directory cache entry is considered valid before the client must revalidate the cached information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントがキャッシュされた情報を再検証する必要がある前に、ディレクトリキャッシュエントリが有効と見なされる時間の長さを示すために、時間の上限が維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The revalidation technique parallels that discussed in the case of name caching. When the client is not changing the directory in question, checking the change attribute of the directory with GETATTR is adequate. The lifetime of the cache entry can be extended at these checkpoints. When a client is modifying the directory, the client needs to use the change_info4 data to determine whether there are other clients modifying the directory. If it is determined that no other client modifications are occurring, the client may update its directory cache to reflect its own changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再検証手法は、名前のキャッシングの場合で説明した手法と類似しています。クライアントが問題のディレクトリを変更していない場合は、GETATTRを使用してディレクトリの変更属性を確認するのが適切です。キャッシュエントリの有効期間は、これらのチェックポイントで延長できます。クライアントがディレクトリを変更しているとき、クライアントはchange_info4データを使用して、ディレクトリを変更している他のクライアントがあるかどうかを判断する必要があります。他のクライアントの変更が発生していないと判断された場合、クライアントは自身の変更を反映するためにディレクトリキャッシュを更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As demonstrated previously, directory caching requires that the client revalidate directory cache data by inspecting the change attribute of a directory at the point when the directory was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory are modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前に示したように、ディレクトリキャッシュでは、クライアントがディレクトリがキャッシュされた時点でディレクトリの変更属性を検査して、ディレクトリキャッシュデータを再検証する必要があります。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがchange_info4情報を適切かつ正しく使用するには、サーバーは操作前および操作後の変更属性値をアトミックに報告する必要があります。サーバーがディレクトリ操作に関して前の値と後の値をアトミックに報告できない場合、サーバーはその事実をchange_info4の戻り値に示す必要があります。情報がアトミックに報告されない場合、クライアントは、他のクライアントがディレクトリを変更していないと想定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Minor Versioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. マイナーバージョン管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To address the requirement of an NFS protocol that can evolve as the need arises, the NFSv4 protocol contains the rules and framework to allow for future minor changes or versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要に応じて進化する可能性があるNFSプロトコルの要件に対処するために、NFSv4プロトコルには、将来のマイナーな変更やバージョン管理を可能にするルールとフレームワークが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base assumption with respect to minor versioning is that any future accepted minor version must follow the IETF process and be documented in a Standards Track RFC. Therefore, each minor version number will correspond to an RFC. Minor version 0 of the NFSv4 protocol is represented by this RFC. The COMPOUND and CB_COMPOUND procedures support the encoding of the minor version being requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイナーバージョン管理に関する基本的な前提は、将来受け入れられるマイナーバージョンはIETFプロセスに従い、Standards Track RFCに文書化されている必要があることです。したがって、各マイナーバージョン番号はRFCに対応します。 NFSv4プロトコルのマイナーバージョン0は、このRFCで表されています。 COMPOUNDおよびCB_COMPOUNDプロシージャは、クライアントによって要求されているマイナーバージョンのエンコーディングをサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future minor versions will extend, rather than replace, the XDR for the preceding minor version, as had been done in moving from NFSv2 to NFSv3 and from NFSv3 to NFSv4.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv2からNFSv3への移行、およびNFSv3からNFSv4.0への移行で行われていたように、将来のマイナーバージョンは、前のマイナーバージョンのXDRを置き換えるのではなく拡張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specification of detailed rules for the construction of minor versions will be addressed in documents defining early minor versions or, more desirably, in an RFC establishing a versioning framework for NFSv4 as a whole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイナーバージョンの構築に関する詳細なルールの仕様は、初期のマイナーバージョンを定義するドキュメント、またはより望ましくは、NFSv4全体のバージョニングフレームワークを確立するRFCで対処されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Internationalization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 国際化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internationalization is a complex topic with its own set of terminology (see [RFC6365]). The topic is made more complex in NFSv4.0 by the tangled history and state of NFS implementations. This section describes what we might call &#34;NFSv4.0 internationalization&#34; (i.e., internationalization as implemented by existing clients and servers) as the basis upon which NFSv4.0 clients may implement internationalization support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
国際化は、独自の用語セットを持つ複雑なトピックです（[RFC6365]を参照）。このトピックは、複雑な歴史とNFS実装の状態によって、NFSv4.0ではより複雑になっています。このセクションでは、NFSv4.0クライアントが国際化サポートを実装する基礎として、「NFSv4.0国際化」（つまり、既存のクライアントとサーバーによって実装される国際化）と呼ぶものについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is based on the behavior of existing implementations. Note that the behaviors described are each demonstrated by a combination of an NFSv4 server implementation proper and a server-side physical file system. It is common for servers and physical file systems to be configurable as to the behavior shown. In the discussion below, each configuration that shows different behavior is considered separately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは、既存の実装の動作に基づいています。ここで説明する動作は、NFSv4サーバーの適切な実装とサーバー側の物理ファイルシステムの組み合わせによってそれぞれ示されることに注意してください。サーバーと物理ファイルシステムは、示されている動作に関して構成可能であることが一般的です。以下の説明では、異なる動作を示す各構成を個別に検討します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in this section, the key words &#34;MUST&#34;, &#34;SHOULD&#34;, and &#34;MAY&#34; retain their normal meanings. However, in deriving this specification from implementation patterns, we document below how the normative terms used derive from the behavior of existing implementations, in those situations in which existing implementation behavior patterns can be determined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、キーワード「MUST」、「SHOULD」、および「MAY」は通常の意味を保持していることに注意してください。ただし、この仕様を実装パターンから導出する際に、既存の実装の動作パターンを決定できる状況で、使用される規範的な用語が既存の実装の動作からどのように派生するかを以下に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Behavior implemented by all existing clients or servers is described using &#34;MUST&#34;, since new implementations need to follow existing ones to be assured of interoperability. While it is possible that different behavior might be workable, we have found no case where this seems reasonable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 新しい実装は相互運用性を保証するために既存の実装に従う必要があるため、すべての既存のクライアントまたはサーバーによって実装される動作は「MUST」を使用して記述されます。異なる動作が実行可能である可能性はありますが、これが妥当であると思われるケースは見つかりませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The converse holds for &#34;MUST NOT&#34;: if a type of behavior poses interoperability problems, it MUST NOT be implemented by any existing clients or servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
逆は「MUST NOT」に当てはまります。あるタイプの動作が相互運用性の問題を引き起こす場合、既存のクライアントまたはサーバーによって実装してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Behavior implemented by most existing clients or servers, where that behavior is more desirable than any alternative, is described using &#34;SHOULD&#34;, since new implementations need to follow that existing practice unless there are strong reasons to do otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ほとんどの既存のクライアントまたはサーバーによって実装された動作は、他の方法よりも望ましい動作であり、「SHOULD」を使用して記述されます。これは、新しい実装は、特に理由がない限り、既存の慣行に従う必要があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The converse holds for &#34;SHOULD NOT&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
その逆は「SHOULD NOT」に当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Behavior implemented by some, but not all, existing clients or servers is described using &#34;MAY&#34;, indicating that new implementations have a choice as to whether they will behave in that way. Thus, new implementations will have the same flexibility that existing ones do.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべてではなく一部の既存のクライアントまたはサーバーによって実装された動作は、「MAY」を使用して記述されます。これは、新しい実装がそのように動作するかどうかを選択できることを示します。したがって、新しい実装には、既存の実装と同じ柔軟性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Behavior implemented by all existing clients or servers, so far as is known -- but where there remains some uncertainty as to details -- is described using &#34;should&#34;. Such cases primarily concern details of error returns. New implementations should follow existing practice even though such situations generally do not affect interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 既知である限り、既存のすべてのクライアントまたはサーバーによって実装される動作（ただし、詳細について不確実性が残っている場合）は、「should」を使用して記述されます。このような場合は、主にエラーの戻りの詳細に関係します。そのような状況は一般に相互運用性に影響を与えませんが、新しい実装は既存の慣行に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 There are also cases in which certain server behaviors, while not known to exist, cannot be reliably determined not to exist. In part, this is a consequence of the long period of time that has elapsed since the publication of [RFC3530], resulting in a situation in which those involved in the implementation may no longer be involved in or aware of working group activities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
また、特定のサーバービヘイビアーが存在するかどうかは不明ですが、存在しないと確実に判断できない場合もあります。これは部分的には、[RFC3530]の公開から経過した長い期間の結果であり、その結果、実装に関与している人々がワーキンググループの活動に関与または気付かなくなっている状況が発生しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of possible server behavior that is neither known to exist nor known not to exist, we use &#34;SHOULD NOT&#34; and &#34;MUST NOT&#34; as follows, and similarly for &#34;SHOULD&#34; and &#34;MUST&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在することも存在しないことも知られていない可能性のあるサーバー動作の場合、「SHOULD NOT」と「MUST NOT」を次のように使用します。「SHOULD」と「MUST」についても同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In some cases, the potential behavior is not known to exist but is of such a nature that, if it were in fact implemented, interoperability difficulties would be expected and reported, giving us cause to conclude that the potential behavior is not implemented. For such behavior, we use &#34;MUST NOT&#34;. Similarly, we use &#34;MUST&#34; to apply to the contrary behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 潜在的な動作が存在することがわかっていない場合がありますが、実際に実装された場合、相互運用性の問題が予想され、報告されるため、潜在的な動作が実装されていないと結論付ける原因になります。そのような動作については、「MUST NOT」を使用します。同様に、「MUST」を使用して、反対の動作に適用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In other cases, potential behavior is not known to exist but the behavior, while undesirable, is not of such a nature that we are able to draw any conclusions about its potential existence. In such cases, we use &#34;SHOULD NOT&#34;. Similarly, we use &#34;SHOULD&#34; to apply to the contrary behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 他の場合では、潜在的な動作が存在することがわかっていませんが、その動作は望ましくないものの、その潜在的な存在について結論を出すことができる性質のものではありません。そのような場合、「SHOULD NOT」を使用します。同様に、「SHOULD」を使用して、反対の動作に適用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a &#34;MAY&#34;, &#34;SHOULD&#34;, or &#34;SHOULD NOT&#34; that applies to servers, clients need to be aware that there are servers that may or may not take the specified action, and they need to be prepared for either eventuality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーに適用される「MAY」、「SHOULD」、または「SHOULD NOT」の場合、クライアントは、指定されたアクションを実行する場合と実行しない場合があるサーバーがあることを認識しておく必要があり、いずれかの準備をする必要があります。偶然。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.2. Limitations on Internationalization-Related Processing in the NFSv4 Context
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.2. NFSv4コンテキストでの国際化関連の処理の制限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of noteworthy circumstances that limit the degree to which internationalization-related processing can be made universal with regard to NFSv4 clients and servers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4クライアントとサーバーに関して、国際化関連の処理を普遍化できる度合いを制限する注目すべき状況がいくつかあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The NFSv4 client is part of an extensive set of client-side software components whose design and internal interfaces are not within the IETF&#39;s purview, limiting the degree to which a particular character encoding may be made standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4クライアントは、クライアント側のソフトウェアコンポーネントの広範なセットの一部であり、そのデザインと内部インターフェイスはIETFの範囲外であり、特定の文字エンコーディングが標準化される程度を制限します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server-side handling of file component names is typically implemented within a server-side physical file system, whose handling of character encoding and normalization is not specifiable by the IETF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバー側のファイルコンポーネント名の処理は、通常、サーバー側の物理ファイルシステム内に実装されます。そのファイルシステムの文字エンコードと正規化の処理は、IETFでは指定できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Typical implementation patterns in UNIX systems result in the NFSv4 client having no knowledge of the character encoding being used, which may even vary between processes on the same client system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o UNIXシステムでの典型的な実装パターンの結果、NFSv4クライアントは、使用されている文字エンコーディングを認識できません。これは、同じクライアントシステム上のプロセス間でさえ異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Users may need access to files stored previously with non-UTF-8 encodings, or with UTF-8 encodings that do not match any particular normalization form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーは、以前に非UTF-8エンコーディングで格納されたファイル、または特定の正規化形式に一致しないUTF-8エンコーディングでアクセスする必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. Summary of Server Behavior Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. サーバー動作タイプの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned in Section 12.6, servers MAY reject component name strings that are not valid UTF-8. This leads to a number of types of valid server behavior, as outlined below. When these are combined with the valid normalization-related behaviors as described in Section 12.4, this leads to the combined behaviors outlined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション12.6で述べたように、サーバーは有効なUTF-8でないコンポーネント名文字列を拒否してもよい（MAY）。これにより、以下に概説するように、いくつかのタイプの有効なサーバー動作が発生します。セクション12.4で説明されているように、これらが有効な正規化関連の動作と組み合わされると、以下で概説される組み合わされた動作になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Servers that limit file component names to UTF-8 strings exist with normalization-related handling as described in Section 12.4. These are best described as &#34;UTF-8-only servers&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セクション12.4で説明されているように、ファイルコンポーネント名をUTF-8文字列に制限するサーバーが存在します。これらは、「UTF-8のみのサーバー」として最もよく説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Servers that do not limit file component names to UTF-8 strings are very common and are necessary to deal with clients/ applications not oriented to the use of UTF-8. Such servers ignore normalization-related issues, and there is no way for them to implement either normalization or representation-independent lookups. These are best described as &#34;UTF-8-unaware servers&#34;, since they treat file component names as uninterpreted strings of bytes and have no knowledge of the characters represented. See Section 12.7 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルコンポーネント名をUTF-8文字列に制限しないサーバーは非常に一般的であり、UTF-8の使用を指向しないクライアント/アプリケーションを処理するために必要です。このようなサーバーは正規化に関連する問題を無視し、正規化または表現に依存しないルックアップを実装する方法はありません。これらは、ファイルコンポーネント名を解釈されないバイト文字列として扱い、表される文字についての知識がないため、「UTF-8非対応サーバー」として最もよく説明されています。詳細については、セクション12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is possible for a server to allow component names that are not valid UTF-8, while still being aware of the structure of UTF-8 strings. Such servers could implement either normalization or representation-independent lookups but apply those techniques only to valid UTF-8 strings. Such servers are not common, but it is possible to configure at least one known server to have this behavior. This behavior SHOULD NOT be used due to the possibility that a filename using one character set may, by coincidence, have the appearance of a UTF-8 filename; the results of UTF-8 normalization or representation-independent lookups are unlikely to be correct in all cases with respect to the other character set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、UTF-8文字列の構造を認識しながら、有効なUTF-8ではないコンポーネント名を許可することができます。このようなサーバーは、正規化または表現に依存しないルックアップを実装できますが、これらの手法は有効なUTF-8文字列にのみ適用されます。このようなサーバーは一般的ではありませんが、この動作をするように少なくとも1つの既知のサーバーを構成することができます。この動作は、1つの文字セットを使用するファイル名が、偶然にもUTF-8ファイル名のように見える可能性があるため、使用しないでください。 UTF-8正規化または表現に依存しないルックアップの結果は、他の文字セットに関してすべての場合において正しいとは限りません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4. String Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4. 文字列エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Strings that potentially contain characters outside the ASCII range [RFC20] are generally represented in NFSv4 using the UTF-8 encoding [RFC3629] of Unicode [UNICODE]. See [RFC3629] for precise encoding and decoding rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASCII範囲[RFC20]の外の文字を含む可能性のある文字列は、通常、Unicode [UNICODE]のUTF-8エンコーディング[RFC3629]を使用してNFSv4で表されます。正確なエンコードとデコードのルールについては、[RFC3629]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some details of the protocol treatment depend on the type of string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコル処理の詳細は、文字列のタイプによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For strings that are component names, the preferred encoding for any non-ASCII characters is the UTF-8 representation of Unicode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コンポーネント名である文字列の場合、非ASCII文字の優先エンコーディングはUnicodeのUTF-8表現です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In many cases, clients have no knowledge of the encoding being used, with the encoding done at the user level under the control of a per-process locale specification. As a result, it may be impossible for the NFSv4 client to enforce the use of UTF-8. The use of non-UTF-8 encodings can be problematic, since it may interfere with access to files stored using other forms of name encoding. Also, normalization-related processing (see Section 12.5) of a string not encoded in UTF-8 could result in inappropriate name modification or aliasing. In cases in which one has a non-UTF-8 encoded name that accidentally conforms to UTF-8 rules, substitution of canonically equivalent strings can change the non-UTF-8 encoded name drastically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
多くの場合、クライアントは使用されているエンコーディングについて何も知りません。エンコーディングは、プロセスごとのロケール指定の制御下でユーザーレベルで行われます。その結果、NFSv4クライアントがUTF-8の使用を強制できない場合があります。非UTF-8エンコーディングを使用すると、他の形式の名前エンコーディングを使用して保存されたファイルへのアクセスが妨げられる可能性があるため、問題が発生する可能性があります。また、UTF-8でエンコードされていない文字列の正規化関連の処理（セクション12.5を参照）により、不適切な名前の変更やエイリアスが発生する可能性があります。誤ってUTF-8規則に準拠する非UTF-8エンコード名がある場合、正規に等価な文字列を置き換えると、非UTF-8エンコード名が大幅に変更される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The kinds of modification and aliasing mentioned here can lead to both false negatives and false positives, depending on the strings in question, which can result in security issues such as elevation of privilege and denial of service (see [RFC6943] for further discussion).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ここで説明されている種類の変更とエイリアスは、問題の文字列に応じて、偽陰性と偽陽性の両方につながる可能性があり、特権の昇格やサービス拒否などのセキュリティ問題を引き起こす可能性があります（詳細については、[RFC6943]を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For strings based on domain names, non-ASCII characters MUST be represented using the UTF-8 encoding of Unicode, and additional string format restrictions apply. See Section 12.6 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ドメイン名に基づく文字列の場合、非ASCII文字はUnicodeのUTF-8エンコーディングを使用して表現する必要があり、追加の文字列形式の制限が適用されます。詳細については、セクション12.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The contents of symbolic links (of type linktext4 in the XDR) MUST be treated as opaque data by NFSv4 servers. Although UTF-8 encoding is often used, it need not be. In this respect, the contents of symbolic links are like the contents of regular files in that their encoding is not within the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o （XDRのタイプlinktext4の）シンボリックリンクの内容は、NFSv4サーバーによって不透明なデータとして扱われる必要があります。 UTF-8エンコーディングがよく使用されますが、そうである必要はありません。この点で、シンボリックリンクの内容は通常のファイルの内容と同様であり、そのエンコードはこの仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For other sorts of strings, any non-ASCII characters SHOULD be represented using the UTF-8 encoding of Unicode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 他の種類の文字列の場合、非ASCII文字はUnicodeのUTF-8エンコーディングを使用して表現する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5. Normalization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5. 正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The client and server operating environments may differ in their policies and operational methods with respect to character normalization (see [UNICODE] for a discussion of normalization forms). This difference may also exist between applications on the same client. This adds to the difficulty of providing a single normalization policy for the protocol that allows for maximal interoperability. This issue is similar to the issues of character case where the server may or may not support case-insensitive filename matching and may or may not preserve the character case when storing filenames. The protocol does not mandate a particular behavior but allows for a range of useful behaviors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントとサーバーの動作環境は、文字の正規化に関してポリシーと操作方法が異なる場合があります（正規化形式の説明については、[UNICODE]を参照してください）。この違いは、同じクライアント上のアプリケーション間でも存在する可能性があります。これにより、最大の相互運用性を可能にするプロトコルに対して単一の正規化ポリシーを提供することがさらに困難になります。この問題は、大文字と小文字を区別しないファイル名の照合をサーバーがサポートする場合とサポートしない場合の文字の大文字と小文字の問題に似ており、ファイル名を格納するときに大文字と小文字を保持する場合としない場合があります。プロトコルは特定の動作を強制しませんが、一連の有用な動作を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol does not mandate the use of a particular normalization form at this time. A subsequent minor version of the NFSv4 protocol might specify a particular normalization form. Therefore, the server and client can expect that they may receive unnormalized characters within protocol requests and responses. If the operating environment requires normalization, then the implementation will need to normalize the various UTF-8 encoded strings within the protocol before presenting the information to an application (at the client) or local file system (at the server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルは、現時点では特定の正規化形式の使用を義務付けていません。 NFSv4プロトコルの後続のマイナーバージョンでは、特定の正規化形式を指定する場合があります。したがって、サーバーとクライアントは、プロトコルの要求と応答内で正規化されていない文字を受け取る可能性があることを期待できます。動作環境で正規化が必要な場合、実装では、情報をアプリケーション（クライアント）またはローカルファイルシステム（サーバー）に提示する前に、プロトコル内のさまざまなUTF-8エンコード文字列を正規化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server implementations MAY normalize filenames to conform to a particular normalization form before using the resulting string when looking up or creating a file. Servers MAY also perform normalization-insensitive string comparisons without modifying the names to match a particular normalization form. Except in cases in which component names are excluded from normalization-related handling because they are not valid UTF-8 strings, a server MUST make the same choice (as to whether to normalize or not, the target form of normalization, and whether to do normalization-insensitive string comparisons) in the same way for all accesses to a particular file system. Servers SHOULD NOT reject a filename because it does not conform to a particular normalization form, as this may deny access to clients that use a different normalization form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装は、ファイルを検索または作成するときに結果の文字列を使用する前に、ファイル名を特定の正規化形式に準拠するように正規化できます。サーバーは、特定の正規化形式に一致するように名前を変更せずに、正規化に依存しない文字列比較を実行してもよい（MAY）。コンポーネント名が有効なUTF-8文字列ではないために正規化関連の処理から除外される場合を除いて、サーバーは同じ選択を行う必要があります（正規化するかどうか、正規化のターゲット形式、および実行するかどうか）特定のファイルシステムへのすべてのアクセスに対して同じ方法で正規化の影響を受けない文字列比較）。ファイル名は特定の正規化形式に準拠していないため、サーバーはファイル名を拒否しないでください。これは、異なる正規化形式を使用するクライアントへのアクセスを拒否する可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6. Types with Processing Defined by Other Internet Areas
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6. 他のインターネット領域によって処理が定義されているタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two types of strings that NFSv4 deals with that are based on domain names. Processing of such strings is defined by other Internet standards, and hence the processing behavior for such strings should be consistent across all server operating systems and server file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4が扱う文字列には、ドメイン名に基づいた2つのタイプがあります。このような文字列の処理は他のインターネット標準によって定義されているため、このような文字列の処理動作は、すべてのサーバーオペレーティングシステムとサーバーファイルシステムで一貫している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server names as they appear in the fs_locations attribute. Note that for most purposes, such server names will only be sent by the server to the client. The exception is the use of the fs_locations attribute in a VERIFY or NVERIFY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fs_locations属性に表示されるサーバー名。ほとんどの場合、このようなサーバー名はサーバーからクライアントにのみ送信されることに注意してください。例外は、VERIFYまたはNVERIFY操作でのfs_locations属性の使用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Principal suffixes that are used to denote sets of users and groups, and are in the form of domain names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーとグループのセットを示すために使用され、ドメイン名の形式のプリンシパルサフィックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general rules for handling all of these domain-related strings are similar and independent of the role of the sender or receiver as client or server, although the consequences of failure to obey these rules may be different for client or server. The server can report errors when it is sent invalid strings, whereas the client will simply ignore invalid string or use a default value in their place.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのドメイン関連の文字列をすべて処理するための一般的なルールは、クライアントまたはサーバーとしての送信者または受信者の役割に類似していて独立していますが、これらのルールに従わない場合の結果はクライアントまたはサーバーによって異なる場合があります。サーバーは、無効な文字列が送信されるとエラーを報告できますが、クライアントは無効な文字列を無視するか、代わりにデフォルト値を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The string sent SHOULD be in the form of one or more U-labels as defined by [RFC5890]. If that is impractical, it can instead be in the form of one or more LDH labels [RFC5890] or a UTF-8 domain name that contains labels that are not properly formatted U-labels. The receiver needs to be able to accept domain and server names in any of the formats allowed. The server MUST reject, using the error NFS4ERR_INVAL, a string that is not valid UTF-8, or that contains an ASCII label that is not a valid LDH label, or that contains an XN-label (begins with &#34;xn--&#34;) for which the characters after &#34;xn--&#34; are not valid output of the Punycode algorithm [RFC3492].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信される文字列は、[RFC5890]で定義されている1つ以上のUラベルの形式である必要があります（SHOULD）。それが実用的でない場合は、1つ以上のLDHラベル[RFC5890]または適切にフォーマットされていないUラベルを含むUTF-8ドメイン名の形式にすることができます。受信者は、許可されている任意の形式でドメイン名とサーバー名を受け入れることができる必要があります。サーバーは、エラーNFS4ERR_INVAL、有効なUTF-8ではない文字列、または有効なLDHラベルではないASCIIラベルを含む文字列、またはXNラベル（「xn--」で始まる）を含む文字列を拒否しなければなりません（MUST）。 「xn--」の後の文字は、Punycodeアルゴリズム[RFC3492]の有効な出力ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a domain string is part of id@domain or group@domain, there are two possible approaches:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ドメイン文字列がid @ domainまたはgroup @ domainの一部である場合、2つの可能なアプローチがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The server treats the domain string as a series of U-labels. In cases where the domain string is a series of A-labels or Non-Reserved LDH (NR-LDH) labels, it converts them to U-labels using the Punycode algorithm [RFC3492]. In cases where the domain string is a series of other sorts of LDH labels, the server can use the ToUnicode function defined in [RFC3490] to convert the string to a series of labels that generally conform to the U-label syntax. In cases where the domain string is a UTF-8 string that contains non-U-labels, the server can attempt to use the ToASCII function defined in [RFC3490] and then the ToUnicode function on the string to convert it to a series of labels that generally conform to the U-label syntax. As a result, the domain string returned within a user id on a GETATTR may not match that sent when the user id is set using SETATTR, although when this happens, the domain will be in the form that generally conforms to the U-label syntax.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. サーバーはドメイン文字列を一連のUラベルとして扱います。ドメイン文字列が一連のAラベルまたは非予約LDH（NR-LDH）ラベルである場合、それはPunycodeアルゴリズム[RFC3492]を使用してUラベルに変換します。ドメイン文字列が一連の他の種類のLDHラベルである場合、サーバーは[RFC3490]で定義されているToUnicode関数を使用して、文字列を一般にUラベル構文に準拠する一連のラベルに変換できます。ドメイン文字列が非Uラベルを含むUTF-8文字列である場合、サーバーは[RFC3490]で定義されているToASCII関数を使用してから、文字列に対してToUnicode関数を使用して、一連のラベルに変換できます。これは通常、Uラベル構文に準拠しています。その結果、GETATTRのユーザーID内で返されたドメイン文字列は、SETATTRを使用してユーザーIDが設定されたときに送信されたものと一致しない場合がありますが、これが発生すると、ドメインは一般にUラベル構文に準拠した形式になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The server does not attempt to treat the domain string as a series of U-labels; specifically, it does not map a domain string that is not a U-label into a U-label using the methods described above. As a result, the domain string returned on a GETATTR of the user id MUST be the same as that used when setting the user id by the SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. サーバーは、ドメイン文字列を一連のUラベルとして処理しようとしません。具体的には、上記の方法を使用して、Uラベルではないドメイン文字列をUラベルにマッピングしません。その結果、ユーザーIDのGETATTRで返されるドメイン文字列は、SETATTRでユーザーIDを設定するときに使用したものと同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server SHOULD use the first method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは最初の方法を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For VERIFY and NVERIFY, additional string processing requirements apply to verification of the owner and owner_group attributes; see Section 5.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFYおよびNVERIFYの場合、追加の文字列処理要件がownerおよびowner_group属性の検証に適用されます。セクション5.9を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7. Errors Related to UTF-8
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7. UTF-8に関連するエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the client sends an invalid UTF-8 string, the server MAY return an NFS4ERR_INVAL error. This includes cases in which inappropriate prefixes are detected and where the count includes trailing bytes that do not constitute a full Universal Multiple-Octet Coded Character Set (UCS) character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが無効なUTF-8文字列を送信する場合、サーバーはNFS4ERR_INVALエラーを返す場合があります。これには、不適切なプレフィックスが検出された場合や、完全なUniversal Multi-Octet Coded Character Set（UCS）文字を構成しない末尾のバイトがカウントに含まれる場合が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requirements for server handling of component names that are not valid UTF-8, when a server does not return NFS4ERR_INVAL in response to receiving them, are described in Section 12.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有効なUTF-8でないコンポーネント名をサーバーが処理するための要件は、サーバーがそれらの受信に応答してNFS4ERR_INVALを返さない場合、セクション12.8で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the string supplied by the client is not rejected with NFS4ERR_INVAL but contains characters that are not supported by the server as a value for that string (e.g., names containing slashes, or characters that do not fit into 16 bits when converted from UTF-8 to a Unicode codepoint), the server should return an NFS4ERR_BADCHAR error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントから提供された文字列がNFS4ERR_INVALで拒否されないが、その文字列の値としてサーバーでサポートされていない文字が含まれている場合（たとえば、スラッシュを含む名前、またはUTF-8から変換すると16ビットに適合しない文字Unicodeコードポイントに）、サーバーはNFS4ERR_BADCHARエラーを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where a UTF-8 string is used as a filename, and the file system, while supporting all of the characters within the name, does not allow that particular name to be used, the server should return the error NFS4ERR_BADNAME. This includes such situations as file system prohibitions of &#34;.&#34; and &#34;..&#34; as filenames for certain operations, and similar constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UTF-8文字列がファイル名として使用され、ファイルシステムは、名前内のすべての文字をサポートしているが、その特定の名前の使用を許可していない場合、サーバーはエラーNFS4ERR_BADNAMEを返す必要があります。これには、「。」のファイルシステム禁止などの状況が含まれます。および「..」は、特定の操作のファイル名および同様の制約です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.8. Servers That Accept File Component Names That Are Not Valid UTF-8 Strings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.8. 有効なUTF-8文字列ではないファイルコンポーネント名を受け入れるサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated previously, servers MAY accept, on all or on some subset of the physical file systems exported, component names that are not valid UTF-8 strings. A typical pattern is for a server to use UTF-8-unaware physical file systems that treat component names as uninterpreted strings of bytes, rather than having any awareness of the character set being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、サーバーは、エクスポートされる物理ファイルシステムのすべてまたは一部のサブセットで、有効なUTF-8文字列ではないコンポーネント名を受け入れる場合があります。典型的なパターンは、サーバーがUTF-8非対応の物理ファイルシステムを使用するコンポーネントで、コンポーネント名を、使用されている文字セットを意識するのではなく、バイトの解釈されない文字列として扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such servers SHOULD NOT change the stored representation of component names from those received on the wire and SHOULD use an octet-by-octet comparison of component name strings to determine equivalence (as opposed to any broader notion of string comparison). This is because the server has no knowledge of the character encoding being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなサーバーは、コンポーネント名の格納された表現を回線で受信したものから変更すべきではなく（SHOULD）、コンポーネント名文字列のオクテットごとの比較を使用して（文字列比較のより広い概念とは対照的に）同等性を判断する必要があります。これは、サーバーが使用されている文字エンコーディングを認識していないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nonetheless, when such a server uses a broader notion of string equivalence than what is recommended in the preceding paragraph, the following considerations apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それでも、そのようなサーバーが前の段落で推奨されているものよりも広い範囲の文字列等価の概念を使用する場合、次の考慮事項が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Outside of 7-bit ASCII, string processing that changes string contents is usually specific to a character set and hence is generally unsafe when the character set is unknown. This processing could change the filename in an unexpected fashion, rendering the file inaccessible to the application or client that created or renamed the file and to others expecting the original filename. Hence, such processing should not be performed, because doing so is likely to result in incorrect string modification or aliasing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 7ビットASCII以外では、文字列の内容を変更する文字列処理は通常、文字セットに固有であるため、文字セットが不明な場合は一般に安全ではありません。この処理により、予期しない方法でファイル名が変更され、ファイルを作成または名前変更したアプリケーションやクライアント、および元のファイル名を予期している他のユーザーがファイルにアクセスできなくなる可能性があります。したがって、このような処理は実行しないでください。実行すると、誤った文字列の変更やエイリアスが発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Unicode normalization is particularly dangerous, as such processing assumes that the string is UTF-8. When that assumption is false because a different character set was used to create the filename, normalization may corrupt the filename with respect to that character set, rendering the file inaccessible to the application that created it and others expecting the original filename. Hence, Unicode normalization SHOULD NOT be performed, because it may cause incorrect string modification or aliasing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o このような処理では文字列がUTF-8であると想定されるため、Unicodeの正規化は特に危険です。ファイル名の作成に別の文字セットが使用されたためにその仮定が偽である場合、正規化によってその文字セットに関するファイル名が破損し、ファイルを作成したアプリケーションや元のファイル名を期待する他のユーザーがファイルにアクセスできなくなる可能性があります。したがって、Unicodeの正規化は実行しないでください。不適切な文字列の変更やエイリアスが発生する可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the above recommendations are not followed, the resulting string modification and aliasing can lead to both false negatives and false positives, depending on the strings in question, which can result in security issues such as elevation of privilege and denial of service (see [RFC6943] for further discussion).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の推奨事項に従わない場合、結果の文字列の変更とエイリアスにより、問題の文字列によっては誤検出と誤検出の両方が発生し、特権の昇格やサービス拒否などのセキュリティ問題が発生する可能性があります（[RFC6943 ]詳細については）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Error Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. エラー値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS error numbers are assigned to failed operations within a COMPOUND or CB_COMPOUND request. A COMPOUND request contains a number of NFS operations that have their results encoded in sequence in a COMPOUND reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply, and the COMPOUND request will be terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSエラー番号は、COMPOUNDまたはCB_COMPOUND要求内の失敗した操作に割り当てられます。 COMPOUND要求には、その結果がCOMPOUND応答で順番にエンコードされたいくつかのNFS操作が含まれています。成功した操作の結果は、NFS4_OKステータスと、それに続く操作のエンコードされた結果で構成されます。 NFS操作が失敗した場合、エラーステータスが応答に入力され、COMPOUND要求が終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Error Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. エラー定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +-----------------------------+--------+-------------------+
       | Error                       | Number | Description       |
       +-----------------------------+--------+-------------------+
       | NFS4_OK                     | 0      | Section 13.1.3.1  |
       | NFS4ERR_ACCESS              | 13     | Section 13.1.6.1  |
       | NFS4ERR_ADMIN_REVOKED       | 10047  | Section 13.1.5.1  |
       | NFS4ERR_ATTRNOTSUPP         | 10032  | Section 13.1.11.1 |
       | NFS4ERR_BADCHAR             | 10040  | Section 13.1.7.1  |
       | NFS4ERR_BADHANDLE           | 10001  | Section 13.1.2.1  |
       | NFS4ERR_BADNAME             | 10041  | Section 13.1.7.2  |
       | NFS4ERR_BADOWNER            | 10039  | Section 13.1.11.2 |
       | NFS4ERR_BADTYPE             | 10007  | Section 13.1.4.1  |
       | NFS4ERR_BADXDR              | 10036  | Section 13.1.1.1  |
       | NFS4ERR_BAD_COOKIE          | 10003  | Section 13.1.1.2  |
       | NFS4ERR_BAD_RANGE           | 10042  | Section 13.1.8.1  |
       | NFS4ERR_BAD_SEQID           | 10026  | Section 13.1.8.2  |
       | NFS4ERR_BAD_STATEID         | 10025  | Section 13.1.5.2  |
       | NFS4ERR_CB_PATH_DOWN        | 10048  | Section 13.1.12.1 |
       | NFS4ERR_CLID_INUSE          | 10017  | Section 13.1.10.1 |
       | NFS4ERR_DEADLOCK            | 10045  | Section 13.1.8.3  |
       | NFS4ERR_DELAY               | 10008  | Section 13.1.1.3  |
       | NFS4ERR_DENIED              | 10010  | Section 13.1.8.4  |
       | NFS4ERR_DQUOT               | 69     | Section 13.1.4.2  |
       | NFS4ERR_EXIST               | 17     | Section 13.1.4.3  |
       | NFS4ERR_EXPIRED             | 10011  | Section 13.1.5.3  |
       | NFS4ERR_FBIG                | 27     | Section 13.1.4.4  |
       | NFS4ERR_FHEXPIRED           | 10014  | Section 13.1.2.2  |
       | NFS4ERR_FILE_OPEN           | 10046  | Section 13.1.4.5  |
       | NFS4ERR_GRACE               | 10013  | Section 13.1.9.1  |
       | NFS4ERR_INVAL               | 22     | Section 13.1.1.4  |
       | NFS4ERR_IO                  | 5      | Section 13.1.4.6  |
       | NFS4ERR_ISDIR               | 21     | Section 13.1.2.3  |
       | NFS4ERR_LEASE_MOVED         | 10031  | Section 13.1.5.4  |
       | NFS4ERR_LOCKED              | 10012  | Section 13.1.8.5  |
       | NFS4ERR_LOCKS_HELD          | 10037  | Section 13.1.8.6  |
       | NFS4ERR_LOCK_NOTSUPP        | 10043  | Section 13.1.8.7  |
       | NFS4ERR_LOCK_RANGE          | 10028  | Section 13.1.8.8  |
       | NFS4ERR_MINOR_VERS_MISMATCH | 10021  | Section 13.1.3.2  |
       | NFS4ERR_MLINK               | 31     | Section 13.1.4.7  |
       | NFS4ERR_MOVED               | 10019  | Section 13.1.2.4  |
       | NFS4ERR_NAMETOOLONG         | 63     | Section 13.1.7.3  |
       | NFS4ERR_NOENT               | 2      | Section 13.1.4.8  |
       | NFS4ERR_NOFILEHANDLE        | 10020  | Section 13.1.2.5  |
       | NFS4ERR_NOSPC               | 28     | Section 13.1.4.9  |
       | NFS4ERR_NOTDIR              | 20     | Section 13.1.2.6  |
       | NFS4ERR_NOTEMPTY            | 66     | Section 13.1.4.10 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       | NFS4ERR_NOTSUPP             | 10004  | Section 13.1.1.5  |
       | NFS4ERR_NOT_SAME            | 10027  | Section 13.1.11.3 |
       | NFS4ERR_NO_GRACE            | 10033  | Section 13.1.9.2  |
       | NFS4ERR_NXIO                | 6      | Section 13.1.4.11 |
       | NFS4ERR_OLD_STATEID         | 10024  | Section 13.1.5.5  |
       | NFS4ERR_OPENMODE            | 10038  | Section 13.1.8.9  |
       | NFS4ERR_OP_ILLEGAL          | 10044  | Section 13.1.3.3  |
       | NFS4ERR_PERM                | 1      | Section 13.1.6.2  |
       | NFS4ERR_RECLAIM_BAD         | 10034  | Section 13.1.9.3  |
       | NFS4ERR_RECLAIM_CONFLICT    | 10035  | Section 13.1.9.4  |
       | NFS4ERR_RESOURCE            | 10018  | Section 13.1.3.4  |
       | NFS4ERR_RESTOREFH           | 10030  | Section 13.1.4.12 |
       | NFS4ERR_ROFS                | 30     | Section 13.1.4.13 |
       | NFS4ERR_SAME                | 10009  | Section 13.1.11.4 |
       | NFS4ERR_SERVERFAULT         | 10006  | Section 13.1.1.6  |
       | NFS4ERR_SHARE_DENIED        | 10015  | Section 13.1.8.10 |
       | NFS4ERR_STALE               | 70     | Section 13.1.2.7  |
       | NFS4ERR_STALE_CLIENTID      | 10022  | Section 13.1.10.2 |
       | NFS4ERR_STALE_STATEID       | 10023  | Section 13.1.5.6  |
       | NFS4ERR_SYMLINK             | 10029  | Section 13.1.2.8  |
       | NFS4ERR_TOOSMALL            | 10005  | Section 13.1.1.7  |
       | NFS4ERR_WRONGSEC            | 10016  | Section 13.1.6.3  |
       | NFS4ERR_XDEV                | 18     | Section 13.1.4.14 |
       +-----------------------------+--------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Table 6: Protocol Error Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
表6：プロトコルエラーの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1. General Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1. 一般的なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors that are applicable to a broad set of different purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、さまざまな目的に適用できるエラーについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.1. NFS4ERR_BADXDR (Error Code 10036)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.1. NFS4ERR_BADXDR（エラーコード10036）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments for this operation do not match those specified in the XDR definition. This includes situations in which the request ends before all the arguments have been seen. Note that this error applies when fixed enumerations (these include booleans) have a value within the input stream that is not valid for the enum. A replier may pre-parse all operations for a COMPOUND procedure before doing any operation execution and return RPC-level XDR errors in that case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の引数は、XDR定義で指定されたものと一致しません。これには、すべての引数が確認される前に要求が終了する状況が含まれます。このエラーは、固定列挙（これらのブール値を含む）が入力ストリーム内で列挙に対して無効な値を持っている場合に適用されることに注意してください。返信者は、操作を実行する前にCOMPOUNDプロシージャのすべての操作を事前に解析し、その場合はRPCレベルのXDRエラーを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.2. NFS4ERR_BAD_COOKIE (Error Code 10003)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.2. NFS4ERR_BAD_COOKIE（エラーコード10003）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is used for operations that provide a set of information indexed by some quantity provided by the client or cookie sent by the server for an earlier invocation. Where the value cannot be used for its intended purpose, this error results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーは、クライアントによって提供されたある量によって索引付けされた一連の情報、または以前の呼び出しのためにサーバーによって送信されたCookieを提供する操作に使用されます。意図した目的に値を使用できない場合、このエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.3. NFS4ERR_DELAY (Error Code 10008)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.3. NFS4ERR_DELAY（エラーコード10008）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any of a number of reasons, the replier could not process this operation in what was deemed a reasonable time. The client should wait and then try the request with a new RPC transaction ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの理由のいずれかにより、返信者はこの操作を妥当な時間と見なされた時間内に処理できませんでした。クライアントは待機してから、新しいRPCトランザクションIDを使用して要求を試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following are two examples of what might lead to this situation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、この状況につながる可能性のある2つの例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A server that supports hierarchical storage receives a request to process a file that had been migrated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 階層ストレージをサポートするサーバーが、移行されたファイルの処理要求を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An operation requires a delegation recall to proceed, and waiting for this delegation recall makes processing this request in a timely fashion impossible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 操作は委任の取り消しを続行する必要があり、この委任の取り消しを待機すると、この要求をタイムリーに処理できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.4. NFS4ERR_INVAL (Error Code 22)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.4. NFS4ERR_INVAL（エラーコード22）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments for this operation are not valid for some reason, even though they do match those specified in the XDR definition for the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の引数は、要求のXDR定義で指定された引数と一致していても、何らかの理由で無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.5. NFS4ERR_NOTSUPP (Error Code 10004)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.5. NFS4ERR_NOTSUPP（エラーコード10004）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operation is not supported, either because the operation is an OPTIONAL one and is not supported by this server or because the operation MUST NOT be implemented in the current minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作がオプションであり、このサーバーでサポートされていないため、または現在のマイナーバージョンで操作を実装してはならないため、操作はサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.6. NFS4ERR_SERVERFAULT (Error Code 10006)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.6. NFS4ERR_SERVERFAULT（エラーコード10006）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An error that does not map to any of the specific legal NFSv4 protocol error values occurred on the server. The client should translate this into an appropriate error. UNIX clients may choose to translate this to EIO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーで特定の正当なNFSv4プロトコルエラー値のいずれにもマップしないエラーが発生しました。クライアントはこれを適切なエラーに変換する必要があります。 UNIXクライアントは、これをEIOに変換することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.7. NFS4ERR_TOOSMALL (Error Code 10005)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.7. NFS4ERR_TOOSMALL（エラーコード10005）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is used where an operation returns a variable amount of data, with a limit specified by the client. Where the data returned cannot be fitted within the limit specified by the client, this error results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーは、クライアントが指定した制限で、操作が可変量のデータを返す場合に使用されます。返されたデータがクライアントによって指定された制限内に収まらない場合、このエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2. Filehandle Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2. ファイルハンドルエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors deal with the situation in which the current or saved filehandle, or the filehandle passed to PUTFH intended to become the current filehandle, is invalid in some way. This includes situations in which the filehandle is a valid filehandle in general but is not of the appropriate object type for the current operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、現在または保存されているファイルハンドル、または現在のファイルハンドルになることを目的としてPUTFHに渡されたファイルハンドルが何らかの方法で無効である状況に対処します。これには、ファイルハンドルが一般に有効なファイルハンドルであるが、現在の操作に適切なオブジェクトタイプではない状況が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the error description indicates a problem with the current or saved filehandle, it is to be understood that filehandles are only checked for the condition if they are implicit arguments of the operation in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーの説明が現在または保存されているファイルハンドルの問題を示している場合、問題の操作の暗黙的な引数である場合にのみ、ファイルハンドルの条件がチェックされることを理解してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.1. NFS4ERR_BADHANDLE (Error Code 10001)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.1. NFS4ERR_BADHANDLE（エラーコード10001）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is generated for an illegal NFS filehandle for the current server. The current filehandle failed internal consistency checks. Once accepted as valid (by PUTFH), no subsequent status change can cause the filehandle to generate this error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーは、現在のサーバーの不正なNFSファイルハンドルに対して生成されます。現在のファイルハンドルは内部の整合性チェックに失敗しました。 （PUTFHによって）有効として受け入れられると、その後のステータス変更によってファイルハンドルがこのエラーを生成することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.2. NFS4ERR_FHEXPIRED (Error Code 10014)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.2. NFS4ERR_FHEXPIRED（エラーコード10014）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A current or saved filehandle that is an argument to the current operation is volatile and has expired at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の操作の引数である現在または保存されているファイルハンドルは揮発性であり、サーバーで有効期限が切れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.3. NFS4ERR_ISDIR (Error Code 21)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.3. NFS4ERR_ISDIR（エラーコード21）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current or saved filehandle designates a directory when the current operation does not allow a directory to be accepted as the target of this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルまたは保存されたファイルハンドルは、現在の操作でディレクトリをこの操作のターゲットとして受け入れることができない場合にディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.4. NFS4ERR_MOVED (Error Code 10019)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.4. NFS4ERR_MOVED（エラーコード10019）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file system that contains the current filehandle object is not present at the server. It may have been relocated or migrated to another server, or may have never been present. The client may obtain the new file system location by obtaining the &#34;fs_locations&#34; attribute for the current filehandle. For further discussion, refer to Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルオブジェクトを含むファイルシステムがサーバーに存在しません。別のサーバーに再配置または移行されたか、存在しなかった可能性があります。クライアントは、現在のファイルハンドルの「fs_locations」属性を取得することにより、新しいファイルシステムの場所を取得できます。詳細については、セクション8を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.5. NFS4ERR_NOFILEHANDLE (Error Code 10020)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.5. NFS4ERR_NOFILEHANDLE（エラーコード10020）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The logical current or saved filehandle value is required by the current operation and is not set. This may be a result of a malformed COMPOUND operation (i.e., no PUTFH or PUTROOTFH before an operation that requires that the current filehandle be set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の論理または保存されたファイルハンドル値は、現在の操作に必要であり、設定されていません。これは、不正なCOMPOUND操作の結果である可能性があります（つまり、現在のファイルハンドルの設定を必要とする操作の前にPUTFHまたはPUTROOTFHがありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.6. NFS4ERR_NOTDIR (Error Code 20)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.6. NFS4ERR_NOTDIR（エラーコード20）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current (or saved) filehandle designates an object that is not a directory for an operation in which a directory is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の（または保存された）ファイルハンドルは、ディレクトリが必要な操作のディレクトリではないオブジェクトを指定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.7. NFS4ERR_STALE (Error Code 70)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.7. NFS4ERR_STALE（エラーコード70）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current or saved filehandle value designating an argument to the current operation is invalid. The file system object referred to by that filehandle no longer exists, or access to it has been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の操作への引数を指定する現在または保存されているファイルハンドル値は無効です。そのファイルハンドルによって参照されているファイルシステムオブジェクトが存在しないか、そのオブジェクトへのアクセスが取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.8. NFS4ERR_SYMLINK (Error Code 10029)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.8. NFS4ERR_SYMLINK（エラーコード10029）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle designates a symbolic link when the current operation does not allow a symbolic link as the target.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、現在の操作がシンボリックリンクをターゲットとして許可しない場合にシンボリックリンクを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3. Compound Structure Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3. 複合構造エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors that relate to the overall structure of a COMPOUND request (by which we mean to include both COMPOUND and CB_COMPOUND), rather than to particular operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、特定の操作ではなく、COMPOUND要求の全体的な構造（COMPOUNDとCB_COMPOUNDの両方を含めることを意味します）に関連するエラーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of basic constraints on the operations that may appear in a COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDリクエストに表示される可能性のある操作には、いくつかの基本的な制約があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.1. NFS_OK (Error Code 0)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.1. NFS_OK（エラーコード0）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS_OK indicates that the operation completed successfully, in that all of the constituent operations completed without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS_OKは、すべての構成要素の操作がエラーなしで完了したという意味で、操作が正常に完了したことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.2. NFS4ERR_MINOR_VERS_MISMATCH (Error Code 10021)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.2. NFS4ERR_MINOR_VERS_MISMATCH（エラーコード10021）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minor version specified is not one that the current listener supports. This value is returned in the overall status for the COMPOUND procedure but is not associated with a specific operation, since the results must specify a result count of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたマイナーバージョンは、現在のリスナーがサポートしているものではありません。この値はCOMPOUNDプロシージャの全体的なステータスで返されますが、結果はゼロの結果カウントを指定する必要があるため、特定の操作には関連付けられていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.3. NFS4ERR_OP_ILLEGAL (Error Code 10044)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.3. NFS4ERR_OP_ILLEGAL（エラーコード10044）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operation code is not a valid one for the current COMPOUND procedure. The opcode in the result stream matched with this error is the ILLEGAL value, although the value that appears in the request stream may be different. Where an illegal value appears and the replier pre-parses all operations for a COMPOUND procedure before doing any operation execution, an RPC-level XDR error may be returned in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペレーションコードは、現在のCOMPOUNDプロシージャでは無効です。このエラーと一致する結果ストリームのオペコードはILLEGAL値ですが、要求ストリームに表示される値は異なる場合があります。不正な値が表示され、リプライヤが操作を実行する前にCOMPOUNDプロシージャのすべての操作を事前に解析する場合、この場合RPCレベルのXDRエラーが返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.4. NFS4ERR_RESOURCE (Error Code 10018)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.4. NFS4ERR_RESOURCE（エラーコード10018）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the processing of the COMPOUND procedure, the server may exhaust available resources and cannot continue processing operations within the COMPOUND procedure. This error will be returned from the server in those instances of resource exhaustion related to the processing of the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャの処理では、サーバーは使用可能なリソースを使い果たし、COMPOUNDプロシージャ内の処理を続行できません。このエラーは、COMPOUNDプロシージャの処理に関連するリソース枯渇のインスタンスでサーバーから返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4. File System Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4. ファイルシステムエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors describe situations that occurred in the underlying file system implementation rather than in the protocol or any NFSv4.x feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、プロトコルやNFSv4.x機能ではなく、基になるファイルシステムの実装で発生した状況を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.1. NFS4ERR_BADTYPE (Error Code 10007)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.1. NFS4ERR_BADTYPE（エラーコード10007）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt was made to create an object with an inappropriate type specified to CREATE. This may be because the type is undefined; because it is a type not supported by the server; or because it is a type for which create is not intended, such as a regular file or named attribute, for which OPEN is used to do the file creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATEに指定された不適切なタイプでオブジェクトを作成しようとしました。タイプが定義されていないことが原因である可能性があります。サーバーでサポートされていないタイプであるため。または、OPENを使用してファイルの作成を行う通常のファイルや名前付き属性など、作成を意図していないタイプであるため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.2. NFS4ERR_DQUOT (Error Code 69)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.2. NFS4ERR_DQUOT（エラーコード69）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resource (quota) hard limit has been exceeded. The user&#39;s resource limit on the server has been exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソース（割り当て量）のハード制限を超えました。サーバー上のユーザーのリソース制限を超えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.3. NFS4ERR_EXIST (Error Code 17)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.3. NFS4ERR_EXIST（エラーコード17）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A file system object of the specified target name (when creating, renaming, or linking) already exists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたターゲット名（作成、名前変更、またはリンク時）のファイルシステムオブジェクトがすでに存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.4. NFS4ERR_FBIG (Error Code 27)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.4. NFS4ERR_FBIG（エラーコード27）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file system object is too large. The operation would have caused a file system object to grow beyond the server&#39;s limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムオブジェクトが大きすぎます。この操作により、ファイルシステムオブジェクトがサーバーの制限を超えて大きくなっていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.5. NFS4ERR_FILE_OPEN (Error Code 10046)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.5. NFS4ERR_FILE_OPEN（エラーコード10046）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operation is not allowed because a file system object involved in the operation is currently open. Servers may, but are not required to, disallow linking to, removing, or renaming open file system objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作に関連するファイルシステムオブジェクトが現在開いているため、操作は許可されません。サーバーは、開いているファイルシステムオブジェクトへのリンクを禁止したり、削除したり、名前を変更したりできますが、必須ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.6. NFS4ERR_IO (Error Code 5)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.6. NFS4ERR_IO（エラーコード5）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates that an I/O error occurred for which the file system was unable to provide recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、ファイルシステムがリカバリを提供できなかったI / Oエラーが発生したことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.7. NFS4ERR_MLINK (Error Code 31)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.7. NFS4ERR_MLINK（エラーコード31）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The request would have caused the server&#39;s limit for the number of hard links a file system object may have to be exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求により、サーバーのファイルシステムオブジェクトのハードリンク数の制限を超える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.8. NFS4ERR_NOENT (Error Code 2)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.8. NFS4ERR_NOENT（エラーコード2）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates no such file or directory. The file system object referenced by the name specified does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、そのようなファイルまたはディレクトリがないことを示します。指定された名前で参照されているファイルシステムオブジェクトは存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.9. NFS4ERR_NOSPC (Error Code 28)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.9. NFS4ERR_NOSPC（エラーコード28）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates no space left on the device. The operation would have caused the server&#39;s file system to exceed its limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、デバイスにスペースが残っていないことを示します。この操作により、サーバーのファイルシステムが制限を超えていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.10. NFS4ERR_NOTEMPTY (Error Code 66)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.10. NFS4ERR_NOTEMPTY（エラーコード66）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt was made to remove a directory that was not empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空でないディレクトリを削除しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.11. NFS4ERR_NXIO (Error Code 6)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.11. NFS4ERR_NXIO（エラーコード6）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates an I/O error. There is no such device or address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、I / Oエラーを示します。そのようなデバイスやアドレスはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.12. NFS4ERR_RESTOREFH (Error Code 10030)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.12. NFS4ERR_RESTOREFH（エラーコード10030）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RESTOREFH operation does not have a saved filehandle (identified by SAVEFH) to operate upon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESTOREFH操作には、操作対象の保存されたファイルハンドル（SAVEFHで識別）がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.13. NFS4ERR_ROFS (Error Code 30)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.13. NFS4ERR_ROFS（エラーコード30）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates a read-only file system. A modifying operation was attempted on a read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、読み取り専用のファイルシステムを示します。読み取り専用ファイルシステムで変更操作が試行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.14. NFS4ERR_XDEV (Error Code 18)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.14. NFS4ERR_XDEV（エラーコード18）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates an attempt to do an operation, such as linking, that inappropriately crosses a boundary. For example, this may be due to a boundary between:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、リンクなど、境界を不適切に横切る操作を実行しようとしたことを示しています。たとえば、これは次の境界が原因である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o File systems (where the fsids are different).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステム（fsidが異なる場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Different named attribute directories, or between a named attribute directory and an ordinary directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 異なる名前付き属性ディレクトリ、または名前付き属性ディレクトリと通常のディレクトリの間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Regions of a file system that the file system implementation treats as separate (for example, for space accounting purposes), and where cross-connection between the regions is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムの実装が個別に（たとえば、スペースアカウンティングの目的で）扱うファイルシステムの領域で、領域間の相互接続は許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5. State Management Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5. 状態管理エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors indicate problems with the stateid (or one of the stateids) passed to a given operation. This includes situations in which the stateid is invalid, as well as situations in which the stateid is valid but designates revoked locking state. Depending on the operation, the stateid, when valid, may designate opens, byte-range locks, or file delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、特定の操作に渡された状態ID（または状態IDの1つ）に問題があることを示しています。これには、stateidが無効である状況と、stateidは有効であるが取り消されたロック状態を指定する状況が含まれます。操作に応じて、stateidは、有効な場合、オープン、バイト範囲ロック、またはファイルの委任を指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.1. NFS4ERR_ADMIN_REVOKED (Error Code 10047)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.1. NFS4ERR_ADMIN_REVOKED（エラーコード10047）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid designates locking state of any type that has been revoked due to administrative interaction, possibly while the lease is valid, or because a delegation was revoked because of failure to return it, while the lease was valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidは、リースが有効である間、またはリースが有効であるにもかかわらず、委任が返されなかったために委任が取り消されたために、管理上の相互作用により取り消された任意のタイプのロック状態を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.2. NFS4ERR_BAD_STATEID (Error Code 10025)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.2. NFS4ERR_BAD_STATEID（エラーコード10025）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid generated by the current server instance was used that either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のサーバーインスタンスによって生成された状態IDが使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Does not designate any locking state (either current or superseded) for a current (state-owner, file) pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在の（状態所有者、ファイル）ペアのロック状態（現在または優先）を指定しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Designates locking state that was freed after lease expiration but without any lease cancellation, as may happen in the handling of &#34;courtesy locks&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「礼儀ロック」の処理で発生する可能性があるように、リースの期限切れ後に解放されたが、リースのキャンセルは行われなかったロック状態を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.3. NFS4ERR_EXPIRED (Error Code 10011)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.3. NFS4ERR_EXPIRED（エラーコード10011）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid or clientid designates locking state of any type that has been revoked or released due to cancellation of the client&#39;s lease, either immediately upon lease expiration, or following a later request for a conflicting lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidまたはclientidは、クライアントのリースがキャンセルされたために、リースの有効期限が切れた直後、またはその後の競合するロックの要求に応じて、取り消されたか解放されたタイプのロック状態を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.4. NFS4ERR_LEASE_MOVED (Error Code 10031)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.4. NFS4ERR_LEASE_MOVED（エラーコード10031）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A lease being renewed is associated with a file system that has been migrated to a new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新されるリースは、新しいサーバーに移行されたファイルシステムに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.5. NFS4ERR_OLD_STATEID (Error Code 10024)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.5. NFS4ERR_OLD_STATEID（エラーコード10024）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid is provided with a seqid value that is not the most current.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidには、最新ではないseqid値が指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.6. NFS4ERR_STALE_STATEID (Error Code 10023)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.6. NFS4ERR_STALE_STATEID（エラーコード10023）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid generated by an earlier server instance was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のサーバーインスタンスによって生成された状態IDが使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6. Security Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6. セキュリティエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are the various permission-related errors in NFSv4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは、NFSv4のさまざまな権限関連のエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.1. NFS4ERR_ACCESS (Error Code 13)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.1. NFS4ERR_ACCESS（エラーコード13）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates permission denied. The caller does not have the correct permission to perform the requested operation. Contrast this with NFS4ERR_PERM (Section 13.1.6.2), which restricts itself to owner or privileged user permission failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、許可が拒否されたことを示します。呼び出し元には、要求された操作を実行するための適切な権限がありません。これとは対照的に、NFS4ERR_PERM（13.1.6.2項）と比較すると、所有者または特権ユーザーのアクセス許可の失敗に限定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.2. NFS4ERR_PERM (Error Code 1)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.2. NFS4ERR_PERM（エラーコード1）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates that the requester is not the owner. The operation was not allowed because the caller is neither a privileged user (root) nor the owner of the target of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、要求者が所有者ではないことを示しています。呼び出し元が特権ユーザー（root）でも操作のターゲットの所有者でもないため、操作は許可されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.3. NFS4ERR_WRONGSEC (Error Code 10016)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.3. NFS4ERR_WRONGSEC（エラーコード10016）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates that the security mechanism being used by the client for the operation does not match the server&#39;s security policy. The client should change the security mechanism being used and re-send the operation. SECINFO can be used to determine the appropriate mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、クライアントが操作に使用しているセキュリティメカニズムがサーバーのセキュリティポリシーと一致しないことを示しています。クライアントは、使用されているセキュリティメカニズムを変更して、操作を再送信する必要があります。 SECINFOを使用して、適切なメカニズムを決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7. Name Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7. 名前エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names in NFSv4 are UTF-8 strings. When the strings are not of length zero, the error NFS4ERR_INVAL results. When they are not valid UTF-8, the error NFS4ERR_INVAL also results, but servers may accommodate file systems with different character formats and not return this error. Besides this, there are a number of other errors to indicate specific problems with names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4の名前はUTF-8文字列です。文字列の長さがゼロでない場合、エラーNFS4ERR_INVALが発生します。それらが有効なUTF-8でない場合、エラーNFS4ERR_INVALも発生しますが、サーバーは異なる文字フォーマットのファイルシステムに対応し、このエラーを返さない場合があります。これ以外にも、名前に関する特定の問題を示す他の多くのエラーがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.1. NFS4ERR_BADCHAR (Error Code 10040)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.1. NFS4ERR_BADCHAR（エラーコード10040）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UTF-8 string contains a character that is not supported by the server in the context in which it is being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UTF-8文字列に、使用されているコンテキストでサーバーがサポートしていない文字が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.2. NFS4ERR_BADNAME (Error Code 10041)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.2. NFS4ERR_BADNAME（エラーコード10041）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A name string in a request consisted of valid UTF-8 characters supported by the server, but the name is not supported by the server as a valid name for current operation. An example might be creating a file or directory named &#34;..&#34; on a server whose file system uses that name for links to parent directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスト内の名前文字列はサーバーでサポートされている有効なUTF-8文字で構成されていますが、サーバーでは現在の操作の有効な名前としてサポートされていません。例としては、ファイルシステムが親ディレクトリへのリンクにその名前を使用するサーバー上に「..」という名前のファイルまたはディレクトリを作成する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error should not be returned due to a normalization issue in a string. When a file system keeps names in a particular normalization form, it is the server&#39;s responsibility to do the appropriate normalization, rather than rejecting the name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文字列の正規化の問題により、このエラーは返されません。ファイルシステムが名前を特定の正規化形式で保持している場合、名前を拒否するのではなく、適切な正規化を行うのはサーバーの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.3. NFS4ERR_NAMETOOLONG (Error Code 63)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.3. NFS4ERR_NAMETOOLONG（エラーコード63）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is returned when the filename in an operation exceeds the server&#39;s implementation limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、操作のファイル名がサーバーの実装制限を超えたときに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8. Locking Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8. エラーのロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors related to locking -- both share reservations and byte-range locking. It does not deal with errors specific to the process of reclaiming locks. Those are dealt with in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ロックに関連するエラーを扱います-共有予約とバイト範囲ロックの両方。ロックを再利用するプロセスに固有のエラーは処理しません。これらについては次のセクションで扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.1. NFS4ERR_BAD_RANGE (Error Code 10042)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.1. NFS4ERR_BAD_RANGE（エラーコード10042）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The range for a LOCK, LOCKT, or LOCKU operation is not appropriate to the allowable range of offsets for the server. For example, this error results when a server that only supports 32-bit ranges receives a range that cannot be handled by that server. (See Section 16.10.4.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK、LOCKT、またはLOCKU操作の範囲は、サーバーのオフセットの許容範囲に適していません。たとえば、このエラーは、32ビットの範囲のみをサポートするサーバーが、そのサーバーでは処理できない範囲を受け取った場合に発生します。 （16.10.4項を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.2. NFS4ERR_BAD_SEQID (Error Code 10026)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.2. NFS4ERR_BAD_SEQID（エラーコード10026）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence number (seqid) in a locking request is neither the next expected number nor the last number processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック要求のシーケンス番号（seqid）は、次に予期される番号でも、最後に処理された番号でもありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.3. NFS4ERR_DEADLOCK (Error Code 10045)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.3. NFS4ERR_DEADLOCK（エラーコード10045）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server has been able to determine a file locking deadlock condition for a blocking lock request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ブロッキングロックリクエストのファイルロックデッドロック状態を判別できました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.4. NFS4ERR_DENIED (Error Code 10010)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.4. NFS4ERR_DENIED（エラーコード10010）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt to lock a file is denied. Since this may be a temporary condition, the client is encouraged to re-send the lock request until the lock is accepted. See Section 9.4 for a discussion of the re-send.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルをロックする試みは拒否されます。これは一時的な状態である可能性があるため、クライアントは、ロックが受け入れられるまでロック要求を再送信することをお勧めします。再送信の説明については、9.4項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.5. NFS4ERR_LOCKED (Error Code 10012)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.5. NFS4ERR_LOCKED（エラーコード10012）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A READ or WRITE operation was attempted on a file where there was a conflict between the I/O and an existing lock:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / Oと既存のロックの間に競合があったファイルに対して、READまたはWRITE操作が試行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is a share reservation inconsistent with the I/O being done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 実行中のI / Oと矛盾する共有予約があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The range to be read or written intersects an existing mandatory byte-range lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 読み取りまたは書き込みの範囲が、既存の必須のバイト範囲ロックと交差しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.6. NFS4ERR_LOCKS_HELD (Error Code 10037)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.6. NFS4ERR_LOCKS_HELD（エラーコード10037）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An operation was prevented by the unexpected presence of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予期しないロックの存在によって操作が妨げられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.7. NFS4ERR_LOCK_NOTSUPP (Error Code 10043)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.7. NFS4ERR_LOCK_NOTSUPP（エラーコード10043）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A locking request was attempted that would require the upgrade or downgrade of a lock range already held by the owner when the server does not support atomic upgrade or downgrade of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがロックのアトミックアップグレードまたはダウングレードをサポートしていない場合に、所有者が既に保持しているロック範囲のアップグレードまたはダウングレードを必要とするロック要求が試行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.8. NFS4ERR_LOCK_RANGE (Error Code 10028)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.8. NFS4ERR_LOCK_RANGE（エラーコード10028）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A lock request is operating on a range that partially overlaps a currently held lock for the current lock-owner and does not precisely match a single such lock, where the server does not support this type of request and thus does not implement POSIX locking semantics [fcntl]. See Sections 16.10.5, 16.11.5, and 16.12.5 for a discussion of how this applies to LOCK, LOCKT, and LOCKU, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック要求は、現在のロック所有者が現在保持しているロックと部分的に重複し、単一のそのようなロックと正確には一致しない範囲で動作しています。サーバーはこのタイプの要求をサポートしていないため、POSIXロックセマンティクスを実装していません[ fcntl]。これがLOCK、LOCKT、LOCKUにそれぞれどのように適用されるかについては、セクション16.10.5、16.11.5、16.12.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.9. NFS4ERR_OPENMODE (Error Code 10038)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.9. NFS4ERR_OPENMODE（エラーコード10038）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client attempted a READ, WRITE, LOCK, or other operation not sanctioned by the stateid passed (e.g., writing to a file opened only for read).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、渡された状態IDによって許可されていない読み取り、書き込み、ロック、またはその他の操作（たとえば、読み取り専用に開かれたファイルへの書き込み）を試みました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.10. NFS4ERR_SHARE_DENIED (Error Code 10015)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.10. NFS4ERR_SHARE_DENIED（エラーコード10015）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt to OPEN a file with a share reservation has failed because of a share conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有の競合のため、共有予約を使用してファイルを開く試みが失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9. Reclaim Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9. エラーを取り戻す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors relate to the process of reclaiming locks after a server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、サーバーの再起動後にロックを再利用するプロセスに関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.1. NFS4ERR_GRACE (Error Code 10013)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.1. NFS4ERR_GRACE（エラーコード10013）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server is in its recovery or grace period, which should at least match the lease period of the server. A locking request other than a reclaim could not be granted during that period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは回復または猶予期間にあり、少なくともサーバーのリース期間と一致している必要があります。その期間中、再利用以外のロック要求は許可されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.2. NFS4ERR_NO_GRACE (Error Code 10033)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.2. NFS4ERR_NO_GRACE（エラーコード10033）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server cannot guarantee that it has not granted state to another client that may conflict with this client&#39;s state. No further reclaims from this client will succeed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、このクライアントの状態と競合する可能性のある別のクライアントに状態を許可していないことを保証できません。このクライアントからの再要求は成功しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.3. NFS4ERR_RECLAIM_BAD (Error Code 10034)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.3. NFS4ERR_RECLAIM_BAD（エラーコード10034）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server cannot guarantee that it has not granted state to another client that may conflict with the requested state. However, this applies only to the state requested in this call; further reclaims may succeed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、要求された状態と競合する可能性がある状態を別のクライアントに許可していないことを保証できません。ただし、これはこの呼び出しで要求された状態にのみ適用されます。さらに再利用が成功する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike NFS4ERR_RECLAIM_CONFLICT, this can occur between correctly functioning clients and servers: the &#34;edge condition&#34; scenarios described in Section 9.6.3.4 leave only the server knowing whether the client&#39;s locks are still valid, and NFS4ERR_RECLAIM_BAD is the server&#39;s way of informing the client that they are not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_CONFLICTとは異なり、これは正常に機能しているクライアントとサーバーの間で発生する可能性があります。セクション9.6.3.4で説明されている「エッジ条件」シナリオは、クライアントのロックがまだ有効であるかどうかをサーバーのみに知らせ、NFS4ERR_RECLAIM_BADはサーバーにクライアントに通知する方法ですそうではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.4. NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.4. NFS4ERR_RECLAIM_CONFLICT（エラーコード10035）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reclaim attempted by the client conflicts with a lock already held by another client. Unlike NFS4ERR_RECLAIM_BAD, this can only occur if one of the clients misbehaved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが試みた再利用は、別のクライアントがすでに保持しているロックと競合します。 NFS4ERR_RECLAIM_BADとは異なり、これはクライアントの1つが誤動作した場合にのみ発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10. Client Management Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10. クライアント管理エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors associated with requests used to create and manage client IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、クライアントIDの作成と管理に使用されるリクエストに関連するエラーについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10.1. NFS4ERR_CLID_INUSE (Error Code 10017)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10.1. NFS4ERR_CLID_INUSE（エラーコード10017）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETCLIENTID operation has found that a clientid is already in use by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID操作で、clientidがすでに別のクライアントによって使用されていることがわかりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10.2. NFS4ERR_STALE_CLIENTID (Error Code 10022)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10.2. NFS4ERR_STALE_CLIENTID（エラーコード10022）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client ID not recognized by the server was used in a locking or SETCLIENTID_CONFIRM request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーで認識されないクライアントIDが、ロックまたはSETCLIENTID_CONFIRM要求で使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11. Attribute Handling Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11. 属性処理エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors specific to attribute handling within NFSv4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、NFSv4内の属性処理に固有のエラーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.1. NFS4ERR_ATTRNOTSUPP (Error Code 10032)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.1. NFS4ERR_ATTRNOTSUPP（エラーコード10032）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attribute specified is not supported by the server. This error MUST NOT be returned by the GETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定された属性はサーバーでサポートされていません。このエラーは、GETATTR操作によって返されてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.2. NFS4ERR_BADOWNER (Error Code 10039)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.2. NFS4ERR_BADOWNER（エラーコード10039）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is returned when an owner or owner_group attribute value or the who field of an ace within an ACL attribute value cannot be translated to a local representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーは、ownerまたはowner_group属性値、またはACL属性値内のaceのwhoフィールドをローカル表現に変換できない場合に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.3. NFS4ERR_NOT_SAME (Error Code 10027)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.3. NFS4ERR_NOT_SAME（エラーコード10027）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is returned by the VERIFY operation to signify that the attributes compared were not the same as those provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーは、VERIFY操作によって返され、比較された属性がクライアントの要求で提供された属性と同じではなかったことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.4. NFS4ERR_SAME (Error Code 10009)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.4. NFS4ERR_SAME（エラーコード10009）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is returned by the NVERIFY operation to signify that the attributes compared were the same as those provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーはNVERIFY操作によって返され、比較された属性がクライアントのリクエストで提供されたものと同じであることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.12. Miscellaneous Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.12. その他のエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.12.1. NFS4ERR_CB_PATH_DOWN (Error Code 10048)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.12.1. NFS4ERR_CB_PATH_DOWN（エラーコード10048）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a problem contacting the client via the callback path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックパスを介したクライアントへの接続に問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. 操作とその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a table that gives the valid error returns for each protocol operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all operations except ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、各プロトコル操作の有効なエラーの戻り値を示す表が含まれています。エラーコードNFS4_OK（エラーがないことを示す）はリストされていませんが、ILLEGALを除くすべての操作で返されることが理解されているはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------------+---------------------------------------------+
   | Operation           | Errors                                      |
   +---------------------+---------------------------------------------+
   | ACCESS              | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED,                  |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | CLOSE               | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_INVAL, NFS4ERR_ISDIR,               |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKS_HELD,    |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | COMMIT              | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK              |
   |                     |                                             |
   | CREATE              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |
   |                     | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |
   |                     | NFS4ERR_BADNAME, NFS4ERR_BADOWNER,          |
   |                     | NFS4ERR_BADTYPE, NFS4ERR_BADXDR,            |
   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |
   |                     | NFS4ERR_EXIST, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOFILEHANDLE,  |
   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,              |
   |                     | NFS4ERR_PERM, NFS4ERR_RESOURCE,             |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE                               |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                     |                                             |
   | DELEGPURGE          | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_NOTSUPP,       |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE_CLIENTID                      |
   |                     |                                             |
   | DELEGRETURN         | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BAD_STATEID, |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_INVAL,             |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_MOVED,         |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,      |
   |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | GETATTR             | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | GETFH               | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE                               |
   |                     |                                             |
   | ILLEGAL             | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL          |
   |                     |                                             |
   | LINK                | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_EXIST,               |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,       |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,   |
   |                     | NFS4ERR_MLINK, NFS4ERR_MOVED,               |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,         |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,        |
   |                     | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP,            |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_WRONGSEC, NFS4ERR_XDEV              |
   |                     |                                             |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | LOCK                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_RANGE,       |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DEADLOCK,           |
   |                     | NFS4ERR_DELAY, NFS4ERR_DENIED,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCK_NOTSUPP, NFS4ERR_LOCK_RANGE,   |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID,      |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_RECLAIM_BAD,      |
   |                     | NFS4ERR_RECLAIM_CONFLICT, NFS4ERR_RESOURCE, |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_CLIENTID,                     |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | LOCKT               | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BAD_RANGE, NFS4ERR_BADXDR,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_DENIED,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,          |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_CLIENTID                      |
   |                     |                                             |
   | LOCKU               | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_RANGE,       |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,          |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE, NFS4ERR_STALE_STATEID        |
   |                     |                                             |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | LOOKUP              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED,                  |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,         |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,       |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK,             |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |
   | LOOKUPP             | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,       |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK,             |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |
   | NVERIFY             | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |
   |                     | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_SAME,         |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | OPEN                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,       |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADOWNER, NFS4ERR_BAD_SEQID,        |
   |                     | NFS4ERR_BAD_STATEID, NFS4ERR_BADXDR,        |
   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |
   |                     | NFS4ERR_EXIST, NFS4ERR_EXPIRED,             |
   |                     | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,            |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_ISDIR, NFS4ERR_MOVED,               |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,         |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NO_GRACE,     |
   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,              |
   |                     | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,       |
   |                     | NFS4ERR_PERM, NFS4ERR_RECLAIM_BAD,          |
   |                     | NFS4ERR_RECLAIM_CONFLICT, NFS4ERR_RESOURCE, |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_SHARE_DENIED, NFS4ERR_STALE,        |
   |                     | NFS4ERR_STALE_CLIENTID, NFS4ERR_SYMLINK,    |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | OPENATTR            | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,        |
   |                     | NFS4ERR_NOTSUPP, NFS4ERR_RESOURCE,          |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE                               |
   |                     |                                             |
   | OPEN_CONFIRM        | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_EXPIRED,            |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | OPEN_DOWNGRADE      | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_INVAL, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCKS_HELD, NFS4ERR_MOVED,          |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | PUTFH               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_MOVED, NFS4ERR_SERVERFAULT,         |
   |                     | NFS4ERR_STALE, NFS4ERR_WRONGSEC             |
   |                     |                                             |
   | PUTPUBFH            | NFS4ERR_DELAY, NFS4ERR_SERVERFAULT,         |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |
   | PUTROOTFH           | NFS4ERR_DELAY, NFS4ERR_SERVERFAULT,         |
   |                     | NFS4ERR_WRONGSEC                            |
   |                     |                                             |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | READ                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCKED, NFS4ERR_MOVED,              |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID, NFS4ERR_SYMLINK      |
   |                     |                                             |
   | READDIR             | NFS4ERR_ACCESS, NFS4ERR_BAD_COOKIE,         |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,       |
   |                     | NFS4ERR_NOT_SAME, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_TOOSMALL                            |
   |                     |                                             |
   | READLINK            | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,   |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOTSUPP, NFS4ERR_RESOURCE,          |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | RELEASE_LOCKOWNER   | NFS4ERR_BADXDR, NFS4ERR_EXPIRED,            |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKS_HELD,    |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE_CLIENTID                      |
   |                     |                                             |
   | REMOVE              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,       |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,         |
   |                     | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOTDIR, NFS4ERR_NOTEMPTY,           |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | RENAME              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_EXIST,               |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,       |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,         |
   |                     | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,              |
   |                     | NFS4ERR_NOTEMPTY, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE, NFS4ERR_WRONGSEC,            |
   |                     | NFS4ERR_XDEV                                |
   |                     |                                             |
   | RENEW               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,             |
   |                     | NFS4ERR_CB_PATH_DOWN, NFS4ERR_EXPIRED,      |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE_CLIENTID |
   |                     |                                             |
   | RESTOREFH           | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |
   |                     | NFS4ERR_MOVED, NFS4ERR_RESOURCE,            |
   |                     | NFS4ERR_RESTOREFH, NFS4ERR_SERVERFAULT,     |
   |                     | NFS4ERR_STALE, NFS4ERR_WRONGSEC             |
   |                     |                                             |
   | SAVEFH              | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE                               |
   |                     |                                             |
   | SECINFO             | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,         |
   |                     | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOTDIR, NFS4ERR_RESOURCE,           |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | SETATTR             | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,       |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BADOWNER,        |
   |                     | NFS4ERR_BAD_STATEID, NFS4ERR_BADXDR,        |
   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FBIG,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,   |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKED,        |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_NOSPC, NFS4ERR_OLD_STATEID,         |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_PERM,             |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | SETCLIENTID         | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,         |
   |                     | NFS4ERR_DELAY, NFS4ERR_INVAL,               |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT       |
   |                     |                                             |
   | SETCLIENTID_CONFIRM | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,         |
   |                     | NFS4ERR_DELAY, NFS4ERR_RESOURCE,            |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE_CLIENTID |
   |                     |                                             |
   | VERIFY              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |
   |                     | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOT_SAME,     |
   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |
   |                     | NFS4ERR_STALE                               |
   |                     |                                             |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | WRITE               | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_EXPIRED,             |
   |                     | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,            |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCKED, NFS4ERR_MOVED,              |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,        |
   |                     | NFS4ERR_NXIO, NFS4ERR_OLD_STATEID,          |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE, NFS4ERR_STALE_STATEID,       |
   |                     | NFS4ERR_SYMLINK                             |
   |                     |                                             |
   +---------------------+---------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Table 7: Valid Error Returns for Each Protocol Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
表7：各プロトコル操作の有効なエラーの戻り値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. Callback Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. コールバック操作とその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a table that gives the valid error returns for each callback operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all callback operations, with the exception of CB_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、コールバック操作ごとに有効なエラーが返される表が含まれています。エラーコードNFS4_OK（エラーがないことを示す）はリストされていませんが、CB_ILLEGALを除いて、すべてのコールバック操作で返されると理解されているはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------+-----------------------------------------------------+
   | Callback    | Errors                                              |
   | Operation   |                                                     |
   +-------------+-----------------------------------------------------+
   | CB_GETATTR  | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, NFS4ERR_DELAY,   |
   |             | NFS4ERR_INVAL, NFS4ERR_SERVERFAULT                  |
   |             |                                                     |
   | CB_ILLEGAL  | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL                  |
   |             |                                                     |
   | CB_RECALL   | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,             |
   |             | NFS4ERR_BADXDR, NFS4ERR_DELAY, NFS4ERR_SERVERFAULT  |
   |             |                                                     |
   +-------------+-----------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Table 8: Valid Error Returns for Each Protocol Callback Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
表8：各プロトコルコールバック操作の有効なエラーの戻り値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. Errors and the Operations That Use Them
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. エラーとそれらを使用する操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------------------------+----------------------------------------+
   | Error                    | Operations                             |
   +--------------------------+----------------------------------------+
   | NFS4ERR_ACCESS           | ACCESS, COMMIT, CREATE, GETATTR, LINK, |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, READ,         |
   |                          | READDIR, READLINK, REMOVE, RENAME,     |
   |                          | RENEW, SECINFO, SETATTR, VERIFY, WRITE |
   |                          |                                        |
   | NFS4ERR_ADMIN_REVOKED    | CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_ATTRNOTSUPP      | CREATE, NVERIFY, OPEN, SETATTR, VERIFY |
   |                          |                                        |
   | NFS4ERR_BADCHAR          | CREATE, LINK, LOOKUP, NVERIFY, OPEN,   |
   |                          | REMOVE, RENAME, SECINFO, SETATTR,      |
   |                          | VERIFY                                 |
   |                          |                                        |
   | NFS4ERR_BADHANDLE        | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |
   |                          | COMMIT, CREATE, GETATTR, GETFH, LINK,  |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_BADNAME          | CREATE, LINK, LOOKUP, OPEN, REMOVE,    |
   |                          | RENAME, SECINFO                        |
   |                          |                                        |
   | NFS4ERR_BADOWNER         | CREATE, OPEN, SETATTR                  |
   |                          |                                        |
   | NFS4ERR_BADTYPE          | CREATE                                 |
   |                          |                                        |
   | NFS4ERR_BADXDR           | ACCESS, CB_GETATTR, CB_ILLEGAL,        |
   |                          | CB_RECALL, CLOSE, COMMIT, CREATE,      |
   |                          | DELEGPURGE, DELEGRETURN, GETATTR,      |
   |                          | ILLEGAL, LINK, LOCK, LOCKT, LOCKU,     |
   |                          | LOOKUP, NVERIFY, OPEN, OPENATTR,       |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, PUTFH,   |
   |                          | READ, READDIR, RELEASE_LOCKOWNER,      |
   |                          | REMOVE, RENAME, RENEW, SECINFO,        |
   |                          | SETATTR, SETCLIENTID,                  |
   |                          | SETCLIENTID_CONFIRM, VERIFY, WRITE     |
   |                          |                                        |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | NFS4ERR_BAD_COOKIE       | READDIR                                |
   |                          |                                        |
   | NFS4ERR_BAD_RANGE        | LOCK, LOCKT, LOCKU                     |
   |                          |                                        |
   | NFS4ERR_BAD_SEQID        | CLOSE, LOCK, LOCKU, OPEN,              |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE           |
   |                          |                                        |
   | NFS4ERR_BAD_STATEID      | CB_RECALL, CLOSE, DELEGRETURN, LOCK,   |
   |                          | LOCKU, OPEN, OPEN_CONFIRM,             |
   |                          | OPEN_DOWNGRADE, READ, SETATTR, WRITE   |
   |                          |                                        |
   | NFS4ERR_CB_PATH_DOWN     | RENEW                                  |
   |                          |                                        |
   | NFS4ERR_CLID_INUSE       | SETCLIENTID, SETCLIENTID_CONFIRM       |
   |                          |                                        |
   | NFS4ERR_DEADLOCK         | LOCK                                   |
   |                          |                                        |
   | NFS4ERR_DELAY            | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |
   |                          | COMMIT, CREATE, DELEGPURGE,            |
   |                          | DELEGRETURN, GETATTR, LINK, LOCK,      |
   |                          | LOCKT, LOCKU, LOOKUP, LOOKUPP,         |
   |                          | NVERIFY, OPEN, OPENATTR,               |
   |                          | OPEN_DOWNGRADE, PUTFH, PUTPUBFH,       |
   |                          | PUTROOTFH, READ, READDIR, READLINK,    |
   |                          | REMOVE, RENAME, SECINFO, SETATTR,      |
   |                          | SETCLIENTID, SETCLIENTID_CONFIRM,      |
   |                          | VERIFY, WRITE                          |
   |                          |                                        |
   | NFS4ERR_DENIED           | LOCK, LOCKT                            |
   |                          |                                        |
   | NFS4ERR_DQUOT            | CREATE, LINK, OPEN, OPENATTR, RENAME,  |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_EXIST            | CREATE, LINK, OPEN, RENAME             |
   |                          |                                        |
   | NFS4ERR_EXPIRED          | CLOSE, DELEGRETURN, LOCK, LOCKT,       |
   |                          | LOCKU, OPEN, OPEN_CONFIRM,             |
   |                          | OPEN_DOWNGRADE, READ,                  |
   |                          | RELEASE_LOCKOWNER, RENEW, SETATTR,     |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_FBIG             | OPEN, SETATTR, WRITE                   |
   |                          |                                        |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | NFS4ERR_FHEXPIRED        | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | GETATTR, GETFH, LINK, LOCK, LOCKT,     |
   |                          | LOCKU, LOOKUP, LOOKUPP, NVERIFY, OPEN, |
   |                          | OPENATTR, OPEN_CONFIRM,                |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_FILE_OPEN        | LINK, REMOVE, RENAME                   |
   |                          |                                        |
   | NFS4ERR_GRACE            | GETATTR, LOCK, LOCKT, LOCKU, NVERIFY,  |
   |                          | OPEN, READ, REMOVE, RENAME, SETATTR,   |
   |                          | VERIFY, WRITE                          |
   |                          |                                        |
   | NFS4ERR_INVAL            | ACCESS, CB_GETATTR, CLOSE, COMMIT,     |
   |                          | CREATE, DELEGRETURN, GETATTR, LINK,    |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, NVERIFY,   |
   |                          | OPEN, OPEN_CONFIRM, OPEN_DOWNGRADE,    |
   |                          | READ, READDIR, READLINK, REMOVE,       |
   |                          | RENAME, SECINFO, SETATTR, SETCLIENTID, |
   |                          | VERIFY, WRITE                          |
   |                          |                                        |
   | NFS4ERR_IO               | ACCESS, COMMIT, CREATE, GETATTR, LINK, |
   |                          | LOOKUP, LOOKUPP, NVERIFY, OPEN,        |
   |                          | OPENATTR, READ, READDIR, READLINK,     |
   |                          | REMOVE, RENAME, SETATTR, VERIFY, WRITE |
   |                          |                                        |
   | NFS4ERR_ISDIR            | CLOSE, COMMIT, LINK, LOCK, LOCKT,      |
   |                          | LOCKU, OPEN, OPEN_CONFIRM, READ,       |
   |                          | READLINK, SETATTR, WRITE               |
   |                          |                                        |
   | NFS4ERR_LEASE_MOVED      | CLOSE, DELEGPURGE, DELEGRETURN, LOCK,  |
   |                          | LOCKT, LOCKU, OPEN_CONFIRM,            |
   |                          | OPEN_DOWNGRADE, READ,                  |
   |                          | RELEASE_LOCKOWNER, RENEW, SETATTR,     |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_LOCKED           | READ, SETATTR, WRITE                   |
   |                          |                                        |
   | NFS4ERR_LOCKS_HELD       | CLOSE, OPEN_DOWNGRADE,                 |
   |                          | RELEASE_LOCKOWNER                      |
   |                          |                                        |
   | NFS4ERR_LOCK_NOTSUPP     | LOCK                                   |
   |                          |                                        |
   | NFS4ERR_LOCK_RANGE       | LOCK, LOCKT, LOCKU                     |
   |                          |                                        |
   | NFS4ERR_MLINK            | LINK                                   |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                          |                                        |
   | NFS4ERR_MOVED            | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | DELEGRETURN, GETATTR, GETFH, LINK,     |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_NAMETOOLONG      | CREATE, LINK, LOOKUP, OPEN, REMOVE,    |
   |                          | RENAME, SECINFO                        |
   |                          |                                        |
   | NFS4ERR_NOENT            | LINK, LOOKUP, LOOKUPP, OPEN, OPENATTR, |
   |                          | REMOVE, RENAME, SECINFO                |
   |                          |                                        |
   | NFS4ERR_NOFILEHANDLE     | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | DELEGRETURN, GETATTR, GETFH, LINK,     |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, READ, READDIR,         |
   |                          | READLINK, REMOVE, RENAME, SAVEFH,      |
   |                          | SECINFO, SETATTR, VERIFY, WRITE        |
   |                          |                                        |
   | NFS4ERR_NOSPC            | CREATE, LINK, OPEN, OPENATTR, RENAME,  |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_NOTDIR           | CREATE, LINK, LOOKUP, LOOKUPP, OPEN,   |
   |                          | READDIR, REMOVE, RENAME, SECINFO       |
   |                          |                                        |
   | NFS4ERR_NOTEMPTY         | REMOVE, RENAME                         |
   |                          |                                        |
   | NFS4ERR_NOTSUPP          | DELEGPURGE, DELEGRETURN, LINK, OPEN,   |
   |                          | OPENATTR, READLINK                     |
   |                          |                                        |
   | NFS4ERR_NOT_SAME         | READDIR, VERIFY                        |
   |                          |                                        |
   | NFS4ERR_NO_GRACE         | LOCK, OPEN                             |
   |                          |                                        |
   | NFS4ERR_NXIO             | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_OLD_STATEID      | CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_OPENMODE         | LOCK, READ, SETATTR, WRITE             |
   |                          |                                        |
   | NFS4ERR_OP_ILLEGAL       | CB_ILLEGAL, ILLEGAL                    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                          |                                        |
   | NFS4ERR_PERM             | CREATE, OPEN, SETATTR                  |
   |                          |                                        |
   | NFS4ERR_RECLAIM_BAD      | LOCK, OPEN                             |
   |                          |                                        |
   | NFS4ERR_RECLAIM_CONFLICT | LOCK, OPEN                             |
   |                          |                                        |
   | NFS4ERR_RESOURCE         | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | DELEGPURGE, DELEGRETURN, GETATTR,      |
   |                          | GETFH, LINK, LOCK, LOCKT, LOCKU,       |
   |                          | LOOKUP, LOOKUPP, OPEN, OPENATTR,       |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | READDIR, READLINK, RELEASE_LOCKOWNER,  |
   |                          | REMOVE, RENAME, RENEW, RESTOREFH,      |
   |                          | SAVEFH, SECINFO, SETATTR, SETCLIENTID, |
   |                          | SETCLIENTID_CONFIRM, VERIFY, WRITE     |
   |                          |                                        |
   | NFS4ERR_RESTOREFH        | RESTOREFH                              |
   |                          |                                        |
   | NFS4ERR_ROFS             | COMMIT, CREATE, LINK, OPEN, OPENATTR,  |
   |                          | OPEN_DOWNGRADE, REMOVE, RENAME,        |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_SAME             | NVERIFY                                |
   |                          |                                        |
   | NFS4ERR_SERVERFAULT      | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |
   |                          | COMMIT, CREATE, DELEGPURGE,            |
   |                          | DELEGRETURN, GETATTR, GETFH, LINK,     |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, PUTPUBFH,       |
   |                          | PUTROOTFH, READ, READDIR, READLINK,    |
   |                          | RELEASE_LOCKOWNER, REMOVE, RENAME,     |
   |                          | RENEW, RESTOREFH, SAVEFH, SECINFO,     |
   |                          | SETATTR, SETCLIENTID,                  |
   |                          | SETCLIENTID_CONFIRM, VERIFY, WRITE     |
   |                          |                                        |
   | NFS4ERR_SHARE_DENIED     | OPEN                                   |
   |                          |                                        |
   | NFS4ERR_STALE            | ACCESS, CLOSE, COMMIT, CREATE,         |
   |                          | DELEGRETURN, GETATTR, GETFH, LINK,     |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | NFS4ERR_STALE_CLIENTID   | DELEGPURGE, LOCK, LOCKT, OPEN,         |
   |                          | RELEASE_LOCKOWNER, RENEW,              |
   |                          | SETCLIENTID_CONFIRM                    |
   |                          |                                        |
   | NFS4ERR_STALE_STATEID    | CLOSE, DELEGRETURN, LOCK, LOCKU,       |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_SYMLINK          | COMMIT, LOOKUP, LOOKUPP, OPEN, READ,   |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_TOOSMALL         | READDIR                                |
   |                          |                                        |
   | NFS4ERR_WRONGSEC         | LINK, LOOKUP, LOOKUPP, OPEN, PUTFH,    |
   |                          | PUTPUBFH, PUTROOTFH, RENAME, RESTOREFH |
   |                          |                                        |
   | NFS4ERR_XDEV             | LINK, RENAME                           |
   |                          |                                        |
   +--------------------------+----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Table 9: Errors and the Operations That Use Them
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
表9：エラーとそれらを使用する操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. NFSv4 Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. NFSv4リクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the NFSv4 RPC program, there are two traditional RPC procedures: NULL and COMPOUND. All other functionality is defined as a set of operations, and these operations are defined in normal XDR/RPC syntax and semantics. However, these operations are encapsulated within the COMPOUND procedure. This requires that the client combine one or more of the NFSv4 operations into a single request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 RPCプログラムには、NULLとCOMPOUNDの2つの従来のRPCプロシージャがあります。他のすべての機能は一連の操作として定義され、これらの操作は通常のXDR / RPC構文とセマンティクスで定義されます。ただし、これらの操作はCOMPOUNDプロシージャ内にカプセル化されています。これには、クライアントが1つ以上のNFSv4操作を単一の要求に結合することが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS4_CALLBACK program is used to provide server-to-client signaling and is constructed in a fashion similar to the NFSv4 program. The procedures CB_NULL and CB_COMPOUND are defined in the same way as NULL and COMPOUND are within the NFS program. The CB_COMPOUND request also encapsulates the remaining operations of the NFS4_CALLBACK program. There is no predefined RPC program number for the NFS4_CALLBACK program. It is up to the client to specify a program number in the &#34;transient&#34; program range. The program and port numbers of the NFS4_CALLBACK program are provided by the client as part of the SETCLIENTID/SETCLIENTID_CONFIRM sequence. The program and port can be changed by another SETCLIENTID/SETCLIENTID_CONFIRM sequence, and it is possible to use the sequence to change them within a client incarnation without removing relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CALLBACKプログラムは、サーバーからクライアントへのシグナリングを提供するために使用され、NFSv4プログラムと同様の方法で構築されます。プロシージャCB_NULLおよびCB_COMPOUNDは、NFSプログラム内のNULLおよびCOMPOUNDと同じ方法で定義されます。 CB_COMPOUND要求は、NFS4_CALLBACKプログラムの残りの操作もカプセル化します。 NFS4_CALLBACKプログラムには、事前定義されたRPCプログラム番号はありません。 「一時的な」プログラム範囲でプログラム番号を指定するのはクライアントの責任です。 NFS4_CALLBACKプログラムのプログラムとポート番号は、SETCLIENTID / SETCLIENTID_CONFIRMシーケンスの一部としてクライアントから提供されます。プログラムとポートは、別のSETCLIENTID / SETCLIENTID_CONFIRMシーケンスで変更できます。このシーケンスを使用して、関連するリースクライアントの状態を削除せずに、クライアントインカネーション内でそれらを変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. COMPOUND Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. COMPOUNDプロシージャ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure provides the opportunity for better performance within high-latency networks. The client can avoid cumulative latency of multiple RPCs by combining multiple dependent operations into a single COMPOUND procedure. A COMPOUND operation may provide for protocol simplification by allowing the client to combine basic procedures into a single request that is customized for the client&#39;s environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは、高遅延ネットワーク内でパフォーマンスを向上させる機会を提供します。クライアントは、複数の依存操作を1つのCOMPOUNDプロシージャに結合することにより、複数のRPCの累積待ち時間を回避できます。 COMPOUNDオペレーションは、クライアントがクライアントの環境に合わせてカスタマイズされた単一のリクエストに基本的な手順を組み合わせることができるようにすることで、プロトコルの簡素化を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure precisely parallels the features of COMPOUND as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャは、上記のCOMPOUNDの機能に正確に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic structure of the COMPOUND procedure is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャの基本構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----+--------------+--------+-----------+-----------+-----------+--
   | tag | minorversion | numops | op + args | op + args | op + args |
   +-----+--------------+--------+-----------+-----------+-----------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the reply&#39;s structure is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返信の構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +------------+-----+--------+-----------------------+--
     |last status | tag | numres | status + op + results |
     +------------+-----+--------+-----------------------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The numops and numres fields, used in the depiction above, represent the count for the counted array encoding used to signify the number of arguments or results encoded in the request and response. As per the XDR encoding, these counts must match exactly the number of operation arguments or results encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上の図で使用されているnumopsおよびnumresフィールドは、要求と応答でエンコードされた引数または結果の数を示すために使用される、カウントされた配列エンコードのカウントを表します。 XDRエンコードに従って、これらのカウントは、エンコードされた操作引数または結果の数と正確に一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Evaluation of a COMPOUND Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. COMPOUNDリクエストの評価
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will process the COMPOUND procedure by evaluating each of the operations within the COMPOUND procedure in order. Each component operation consists of a 32-bit operation code, followed by the argument of length determined by the type of operation. The results of each operation are encoded in sequence into a reply buffer. The results of each operation are preceded by the opcode and a status code (normally zero). If an operation results in a non-zero status code, the status will be encoded, evaluation of the COMPOUND sequence will halt, and the reply will be returned. Note that evaluation stops even in the event of &#34;non-error&#34; conditions such as NFS4ERR_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、COMPOUNDプロシージャ内の各操作を順番に評価して、COMPOUNDプロシージャを処理します。各コンポーネント操作は32ビットの操作コードで構成され、その後に操作のタイプによって決定される長さの引数が続きます。各操作の結果は、応答バッファーに順番にエンコードされます。各操作の結果の前には、オペコードとステータスコード（通常はゼロ）が付きます。操作の結果がゼロ以外のステータスコードである場合、ステータスはエンコードされ、COMPOUNDシーケンスの評価が停止し、応答が返されます。 NFS4ERR_SAMEなどの「非エラー」条件が発生した場合でも、評価は停止することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are no atomicity requirements for the operations contained within the COMPOUND procedure. The operations being evaluated as part of a COMPOUND request may be evaluated simultaneously with other COMPOUND requests that the server receives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャに含まれる操作には、原子性の要件はありません。 COMPOUNDリクエストの一部として評価される操作は、サーバーが受信する他のCOMPOUNDリクエストと同時に評価される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A COMPOUND is not a transaction, and it is the client&#39;s responsibility to recover from any partially completed COMPOUND procedure. These may occur at any point due to errors such as NFS4ERR_RESOURCE and NFS4ERR_DELAY. Note that these errors can occur in an otherwise valid operation string. Further, a server reboot that occurs in the middle of processing a COMPOUND procedure may leave the client with the difficult task of determining how far COMPOUND processing has proceeded. Therefore, the client should avoid overly complex COMPOUND procedures in the event of the failure of an operation within the procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDはトランザクションではなく、部分的に完了したCOMPOUNDプロシージャから回復するのはクライアントの責任です。これらは、NFS4ERR_RESOURCEやNFS4ERR_DELAYなどのエラーが原因で、いつでも発生する可能性があります。これらのエラーは、それ以外の場合は有効な操作文字列で発生する可能性があることに注意してください。さらに、COMPOUNDプロシージャの処理中にサーバーが再起動すると、COMPOUND処理がどこまで進んだかを判断するという難しいタスクがクライアントに残る場合があります。したがって、クライアントは、プロシージャ内の操作が失敗した場合に、過度に複雑なCOMPOUNDプロシージャを回避する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each operation assumes a current filehandle and a saved filehandle that are available as part of the execution context of the COMPOUND request. Operations may set, change, or return the current filehandle. The saved filehandle is used for temporary storage of a filehandle value and as operands for the RENAME and LINK operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各操作は、COMPOUND要求の実行コンテキストの一部として使用可能な現在のファイルハンドルと保存されたファイルハンドルを想定しています。操作は、現在のファイルハンドルを設定、変更、または返す場合があります。保存されたファイルハンドルは、ファイルハンドル値の一時的な保存に使用され、RENAMEおよびLINK操作のオペランドとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. Synchronous Modifying Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. 同期修正操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 operations that modify the file system are synchronous. When an operation is successfully completed at the server, the client can trust that any data associated with the request is now in stable storage (the one exception is in the case of the file data in a WRITE operation with the UNSTABLE4 option specified).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムを変更するNFSv4操作は同期的です。サーバーで操作が正常に完了すると、クライアントは、要求に関連付けられたすべてのデータが安定したストレージにあることを信頼できます（1つの例外は、UNSTABLE4オプションが指定されたWRITE操作のファイルデータの場合です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This implies that any previous operations within the same COMPOUND request are also reflected in stable storage. This behavior enables the client&#39;s ability to recover from a partially executed COMPOUND request that may have resulted from the failure of the server. For example, if a COMPOUND request contains operations A and B and the server is unable to send a response to the client, then depending on the progress the server made in servicing the request, the result of both operations may be reflected in stable storage or just operation A may be reflected. The server must not have just the results of operation B in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、同じCOMPOUNDリクエスト内の以前の操作も安定したストレージに反映されることを意味します。この動作により、サーバーの障害が原因である可能性がある部分的に実行されたCOMPOUND要求からクライアントが回復できるようになります。たとえば、COMPOUNDリクエストに操作AとBが含まれ、サーバーがクライアントに応答を送信できない場合、サーバーがリクエストの処理で行った進行状況によっては、両方の操作の結果が安定したストレージまたは操作Aだけが反映される場合があります。サーバーは、操作Bの結果だけを安定したストレージに保管してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. Operation Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. 操作値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations encoded in the COMPOUND procedure are identified by operation values. To avoid overlap with the RPC procedure numbers, operations 0 (zero) and 1 are not defined. Operation 2 is not defined but is reserved for future use with minor versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャでエンコードされた操作は、操作値によって識別されます。 RPCプロシージャ番号との重複を避けるため、操作0（ゼロ）と1は定義されていません。操作2は定義されていませんが、マイナーバージョン管理で将来使用するために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSv4 Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSv4の手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. Procedure 0: NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. 手順0：NULL-操作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standard NULL procedure. Void argument, void response. This procedure has no functionality associated with it. Because of this, it is sometimes used to measure the overhead of processing a service request. Therefore, the server should ensure that no unnecessary work is done in servicing this procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準のNULLプロシージャ。無効な引数、無効な応答。この手順には、関連する機能はありません。このため、サービス要求の処理のオーバーヘッドを測定するために使用されることがあります。したがって、サーバーは、この手順を実行する際に不要な作業が行われないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. Procedure 1: COMPOUND - COMPOUND Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. 手順1：COMPOUND-COMPOUNDオペレーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
compoundargs -&gt; compoundres
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
複合引数-&gt;複合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_argop4 switch (nfs_opnum4 argop) {
             case &lt;OPCODE&gt;: &lt;argument&gt;;
             ...
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           nfs_argop4      argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_resop4 switch (nfs_opnum4 resop) {
             case &lt;OPCODE&gt;: &lt;argument&gt;;
             ...
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMPOUND4res {
           nfsstat4        status;
           utf8str_cs      tag;
           nfs_resop4      resarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure is used to combine one or more of the NFS operations into a single RPC request. The main NFS RPC program has two main procedures: NULL and COMPOUND. All other operations use the COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは、1つ以上のNFS操作を1つのRPC要求に結合するために使用されます。メインのNFS RPCプログラムには、NULLとCOMPOUNDの2つの主要な手順があります。他のすべての操作では、COMPOUNDプロシージャがラッパーとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure is used to combine individual operations into a single RPC request. The server interprets each of the operations in turn. If an operation is executed by the server and the status of that operation is NFS4_OK, then the next operation in the COMPOUND procedure is executed. The server continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは、個々の操作を1つのRPC要求に結合するために使用されます。サーバーは各操作を順番に解釈します。サーバーによって操作が実行され、その操作のステータスがNFS4_OKである場合、COMPOUNDプロシージャの次の操作が実行されます。サーバーは、実行する操作がなくなるか、操作の1つがNFS4_OK以外のステータス値になるまで、このプロセスを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the processing of the COMPOUND procedure, the server may find that it does not have the available resources to execute any or all of the operations within the COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the COMPOUND sequence have been evaluated successfully. The results for all of the evaluated operations must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャの処理中に、サーバーは、COMPOUNDシーケンス内の操作の一部またはすべてを実行するために使用できるリソースがないことに気付く場合があります。この場合、リソースの枯渇が発生したCOMPOUNDプロシージャ内の特定の操作に対して、エラーNFS4ERR_RESOURCEが返されます。これは、COMPOUNDシーケンス内の以前のすべての操作が正常に評価されていることを前提としています。評価されたすべての操作の結果をクライアントに返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will generally choose between two methods of decoding the client&#39;s request. The first would be the traditional one-pass XDR decode, in which decoding of the entire COMPOUND precedes execution of any operation within it. If there is an XDR decoding error in this case, an RPC XDR decode error would be returned. The second method would be to make an initial pass to decode the basic COMPOUND request and then to XDR decode each of the individual operations, as the server is ready to execute it. In this case, the server may encounter an XDR decode error during such an operation decode, after previous operations within the COMPOUND have been executed. In this case, the server would return the error NFS4ERR_BADXDR to signify the decode error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは通常、クライアントの要求をデコードする2つの方法から選択します。 1つ目は、従来のワンパスXDRデコードです。この場合、COMPOUND全体のデコードは、その内部での操作の実行に先行します。この場合にXDRデコードエラーが発生すると、RPC XDRデコードエラーが返されます。 2番目の方法は、基本的なCOMPOUNDリクエストをデコードするための初期パスを作成し、サーバーがそれを実行する準備ができているので、個々のオペレーションのそれぞれをXDRデコードすることです。この場合、COMPOUND内の以前の操作が実行された後、サーバーはそのような操作のデコード中にXDRデコードエラーに遭遇する可能性があります。この場合、サーバーはNFS4ERR_BADXDRエラーを返し、デコードエラーを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND arguments contain a minorversion field. The initial and default value for this field is 0 (zero). This field will be used by future minor versions such that the client can communicate to the server what minor version is being requested. If the server receives a COMPOUND procedure with a minorversion field value that it does not support, the server MUST return an error of NFS4ERR_MINOR_VERS_MISMATCH and a zero-length resultdata array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND引数には、minorversionフィールドが含まれています。このフィールドの初期値とデフォルト値は0（ゼロ）です。このフィールドは、クライアントがどのマイナーバージョンが要求されているかをサーバーと通信できるように、将来のマイナーバージョンで使用されます。サーバーがサポートしていないマイナーバージョンフィールド値を含むCOMPOUNDプロシージャを受信した場合、サーバーはNFS4ERR_MINOR_VERS_MISMATCHのエラーと長さゼロの結果データ配列を返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contained within the COMPOUND results is a status field. If the results array length is non-zero, this status must be equivalent to the status of the last operation that was executed within the COMPOUND procedure. Therefore, if an operation incurred an error, then the status value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND結果には、ステータスフィールドが含まれています。結果の配列の長さがゼロ以外の場合、このステータスはCOMPOUNDプロシージャ内で実行された最後の操作のステータスと同じである必要があります。したがって、操作でエラーが発生した場合、ステータス値は、失敗した操作で返されるエラー値と同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that operations 0 (zero), 1 (one), and 2 (two) are not defined for the COMPOUND procedure. It is possible that the server receives a request that contains an operation that is less than the first legal operation (OP_ACCESS) or greater than the last legal operation (OP_RELEASE_LOCKOWNER). In this case, the server&#39;s response will encode the opcode OP_ILLEGAL rather than the illegal opcode of the request. The status field in the ILLEGAL return results will be set to NFS4ERR_OP_ILLEGAL. The COMPOUND procedure&#39;s return results will also be NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャには、操作0（ゼロ）、1（1）、および2（2）が定義されていないことに注意してください。サーバーは、最初の正当な操作（OP_ACCESS）よりも小さい操作、または最後の正当な操作（OP_RELEASE_LOCKOWNER）よりも大きい操作を含む要求を受信する可能性があります。この場合、サーバーの応答は、要求の不正なオペコードではなく、オペコードOP_ILLEGALをエンコードします。 ILLEGALの戻り結果のステータスフィールドはNFS4ERR_OP_ILLEGALに設定されます。 COMPOUNDプロシージャの戻り結果もNFS4ERR_OP_ILLEGALになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of the &#34;tag&#34; in the request is left to the implementer. It may be used to summarize the content of the COMPOUND request for the benefit of packet sniffers and engineers debugging implementations. However, the value of &#34;tag&#34; in the response SHOULD be the same value as the value provided in the request. This applies to the tag field of the CB_COMPOUND procedure as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスト内の「タグ」の定義は実装者に任されています。これは、パケットスニファとエンジニアのデバッグ実装のために、COMPOUND要求の内容を要約するために使用できます。ただし、応答の「タグ」の値は、要求で提供された値と同じ値である必要があります。これは、CB_COMPOUNDプロシージャのタグフィールドにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.4.1. Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.4.1. 現在のファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle and the saved filehandle are used throughout the protocol. Most operations implicitly use the current filehandle as an argument, and many set the current filehandle as part of the results. The combination of client-specified sequences of operations and current and saved filehandle arguments and results allows for greater protocol flexibility. The best or easiest example of current filehandle usage is a sequence like the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルと保存されたファイルハンドルは、プロトコル全体で使用されます。ほとんどの操作は暗黙的に現在のファイルハンドルを引数として使用し、多くの操作は現在のファイルハンドルを結果の一部として設定します。クライアント指定の操作シーケンスと、現在および保存されているファイルハンドル引数と結果の組み合わせにより、プロトコルの柔軟性が向上します。現在のファイルハンドルの使用法の最良または最も簡単な例は、次のようなシーケンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        PUTFH fh1              {fh1}
                        LOOKUP &#34;compA&#34;         {fh2}
                        GETATTR                {fh2}
                        LOOKUP &#34;compB&#34;         {fh3}
                        GETATTR                {fh3}
                        LOOKUP &#34;compC&#34;         {fh4}
                        GETATTR                {fh4}
                        GETFH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Figure 1: Filehandle Usage Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
図1：ファイルハンドルの使用例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this example, the PUTFH (Section 16.20) operation explicitly sets the current filehandle value, while the result of each LOOKUP operation sets the current filehandle value to the resultant file system object. Also, the client is able to insert GETATTR operations using the current filehandle as an argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、PUTFH（セクション16.20）操作が現在のファイルハンドル値を明示的に設定し、各LOOKUP操作の結果が現在のファイルハンドル値を結果のファイルシステムオブジェクトに設定します。また、クライアントは、現在のファイルハンドルを引数として使用して、GETATTR操作を挿入できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PUTROOTFH (Section 16.22) and PUTPUBFH (Section 16.21) operations also set the current filehandle. The above example would replace &#34;PUTFH fh1&#34; with PUTROOTFH or PUTPUBFH with no filehandle argument in order to achieve the same effect (on the assumption that &#34;compA&#34; is directly below the root of the namespace).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTROOTFH（セクション16.22）およびPUTPUBFH（セクション16.21）操作も、現在のファイルハンドルを設定します。上記の例では、同じ効果を達成するために、「PUTFH fh1」をファイルハンドル引数なしでPUTROOTFHまたはPUTPUBFHに置き換えます（「compA」が名前空間のルートのすぐ下にあるという前提）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Along with the current filehandle, there is a saved filehandle. While the current filehandle is set as the result of operations like LOOKUP, the saved filehandle must be set directly with the use of the SAVEFH operation. The SAVEFH operation copies the current filehandle value to the saved value. The saved filehandle value is used in combination with the current filehandle value for the LINK and RENAME operations. The RESTOREFH operation will copy the saved filehandle value to the current filehandle value; as a result, the saved filehandle value may be used as a sort of &#34;scratch&#34; area for the client&#39;s series of operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
現在のファイルハンドルに加えて、保存されたファイルハンドルがあります。現在のファイルハンドルはLOOKUPなどの操作の結果として設定されますが、保存されたファイルハンドルはSAVEFH操作を使用して直接設定する必要があります。 SAVEFH操作は、現在のファイルハンドル値を保存された値にコピーします。保存されたファイルハンドル値は、LINKおよびRENAME操作の現在のファイルハンドル値と組み合わせて使用​​されます。 RESTOREFH操作は、保存されたファイルハンドル値を現在のファイルハンドル値にコピーします。その結果、保存されたファイルハンドル値は、クライアントの一連の操作の一種の「スクラッチ」領域として使用される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since an error of any type may occur after only a portion of the operations have been evaluated, the client must be prepared to recover from any failure. If the source of an NFS4ERR_RESOURCE error was a complex or lengthy set of operations, it is likely that if the number of operations were reduced the server would be able to evaluate them successfully. Therefore, the client is responsible for dealing with this type of complexity in recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の操作のみが評価された後で、あらゆるタイプのエラーが発生する可能性があるため、クライアントは、障害から回復する準備をする必要があります。 NFS4ERR_RESOURCEエラーの原因が複雑な、または長い操作のセットであった場合、操作の数が減った場合、サーバーはそれらを正常に評価できる可能性があります。したがって、クライアントは、回復におけるこの種の複雑さを処理する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single compound should not contain multiple operations that have different values for the clientid field used in OPEN, LOCK, or RENEW. This can cause confusion in cases in which operations that do not contain clientids have potential interactions with operations that do. When only a single clientid has been used, it is clear what client is being referenced. For a particular example involving the interaction of OPEN and GETATTR, see Section 16.16.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のコンパウンドには、OPEN、LOCK、またはRENEWで使用されるclientidフィールドの値が異なる複数の操作を含めることはできません。これにより、クライアントIDを含まない操作が、操作を含む操作と潜在的に相互作用する場合に混乱が生じる可能性があります。単一のclientidのみが使用されている場合、どのクライアントが参照されているかは明らかです。 OPENとGETATTRの相互作用を含む特定の例については、セクション16.16.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. NFSv4 Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. NFSv4操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. Operation 3: ACCESS - Check Access Rights
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. 操作3：アクセス-アクセス権の確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), accessreq -&gt; supported, accessrights
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、accessreq-&gt;サポート、アクセス権
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACCESS4_READ      = 0x00000001;
   const ACCESS4_LOOKUP    = 0x00000002;
   const ACCESS4_MODIFY    = 0x00000004;
   const ACCESS4_EXTEND    = 0x00000008;
   const ACCESS4_DELETE    = 0x00000010;
   const ACCESS4_EXECUTE   = 0x00000020;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4resok {
           uint32_t        supported;
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS determines the access rights that a user, as identified by the credentials in the RPC request, has with respect to the file system object specified by the current filehandle. The client encodes the set of access rights that are to be checked in the bitmask &#34;access&#34;. The server checks the permissions encoded in the bitmask. If a status of NFS4_OK is returned, two bitmasks are included in the response. The first, &#34;supported&#34;, represents the access rights for which the server can verify reliably. The second, &#34;access&#34;, represents the access rights available to the user for the filehandle provided. On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESSは、RPC要求の資格情報によって識別されるように、ユーザーが現在のファイルハンドルで指定されたファイルシステムオブジェクトに対して持つアクセス権を決定します。クライアントは、ビットマスク「アクセス」でチェックされるアクセス権のセットをエンコードします。サーバーは、ビットマスクにエンコードされた権限をチェックします。 NFS4_OKのステータスが返された場合、2つのビットマスクが応答に含まれます。最初の「サポートされる」は、サーバーが確実に検証できるアクセス権を表します。 2番目の「アクセス」は、提供されたファイルハンドルに対してユーザーが利用できるアクセス権を表します。成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the supported field will contain only as many values as were originally sent in the arguments. For example, if the client sends an ACCESS operation with only the ACCESS4_READ value set and the server supports this value, the server will return only ACCESS4_READ even if it could have reliably checked other values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サポートされるフィールドには、最初に引数で送信されたのと同じ数の値のみが含まれることに注意してください。たとえば、クライアントがACCESS4_READ値のみを設定してACCESS操作を送信し、サーバーがこの値をサポートしている場合、サーバーは他の値を確実にチェックできたとしてもACCESS4_READのみを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of this operation are necessarily advisory in nature. A return status of NFS4_OK and the appropriate bit set in the bitmask do not imply that such access will be allowed to the file system object in the future. This is because access rights can be revoked by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の結果は、必然的に助言です。 NFS4_OKの戻りステータスとビットマスクに設定された適切なビットは、そのようなアクセスが将来ファイルシステムオブジェクトに許可されることを意味しません。これは、サーバーがいつでもアクセス権を取り消すことができるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following access permissions may be requested:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のアクセス許可が要求される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_READ: Read data from file or read a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_READ：ファイルからデータを読み取るか、ディレクトリを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_LOOKUP: Look up a name in a directory (no meaning for non-directory objects).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_LOOKUP：ディレクトリで名前を検索します（ディレクトリ以外のオブジェクトには意味がありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_MODIFY: Rewrite existing file data or modify existing directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_MODIFY：既存のファイルデータを書き換えるか、既存のディレクトリエントリを変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXTEND: Write new data or add directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXTEND：新しいデータを書き込むか、ディレクトリエントリを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_DELETE: Delete an existing directory entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_DELETE：既存のディレクトリエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTE: Execute file (no meaning for a directory).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTE：ファイルを実行します（ディレクトリには意味がありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, it is not sufficient for the client to attempt to deduce access permissions by inspecting the uid, gid, and mode fields in the file attributes or by attempting to interpret the contents of the ACL attribute. This is because the server may perform uid or gid mapping or enforce additional access control restrictions. It is also possible that the server may not be in the same ID space as the client. In these cases (and perhaps others), the client cannot reliably perform an access check with only current file attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、クライアントがファイル属性のuid、gid、およびmodeフィールドを調べたり、ACL属性の内容を解釈したりして、アクセス許可を推測しようとするだけでは不十分です。これは、サーバーがuidまたはgidマッピングを実行したり、追加のアクセス制御制限を適用したりする可能性があるためです。また、サーバーがクライアントと同じIDスペースにない場合もあります。これらのケース（およびその他のケース）では、クライアントは現在のファイル属性のみでアクセスチェックを確実に実行できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In the NFSv2 protocol, the only reliable way to determine whether an operation was allowed was to try it and see if it succeeded or failed. Using the ACCESS operation in the NFSv4 protocol, the client can ask the server to indicate whether or not one or more classes of operations are permitted. The ACCESS operation is provided to allow clients to check before doing a series of operations that might result in an access failure. The OPEN operation provides a point where the server can verify access to the file object and the method to return that information to the client. The ACCESS operation is still useful for directory operations or for use in the case where the UNIX API &#34;access&#34; is used on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv2プロトコルでは、操作が許可されているかどうかを判断する唯一の信頼できる方法は、操作を試行して、操作が成功したか失敗したかを確認することでした。クライアントは、NFSv4プロトコルのACCESS操作を使用して、1つ以上の操作のクラスが許可されているかどうかをサーバーに要求することができます。 ACCESS操作は、アクセス障害を引き起こす可能性のある一連の操作を実行する前にクライアントが確認できるようにするために提供されています。 OPEN操作は、サーバーがファイルオブジェクトへのアクセスを確認できるポイントと、その情報をクライアントに返すメソッドを提供します。 ACCESS操作は、ディレクトリ操作や、UNIX API「アクセス」がクライアントで使用されている場合に使用する場合にも役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information returned by the server in response to an ACCESS call is not permanent. It was correct at the exact time that the server performed the checks, but not necessarily afterward. The server can revoke access permission at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS呼び出しへの応答としてサーバーから返される情報は永続的なものではありません。サーバーがチェックを実行した正確な時点で正しかったが、必ずしもその後ではなかった。サーバーはいつでもアクセス許可を取り消すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should use the effective credentials of the user to build the authentication information in the ACCESS request used to determine access rights. It is the effective user and group credentials that are used in subsequent READ and WRITE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ユーザーの有効な資格情報を使用して、アクセス権を決定するために使用されるACCESSリクエストで認証情報を構築する必要があります。後続のREADおよびWRITE操作で使用されるのは、有効なユーザーおよびグループの資格情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many implementations do not directly support the ACCESS4_DELETE permission. Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object. In these systems, delete permission on a file is determined by the access permissions on the directory in which the file resides, instead of being determined by the permissions of the file itself. Therefore, the mask returned enumerating which access rights can be supported will have the ACCESS4_DELETE value set to 0. This indicates to the client that the server was unable to check that particular access right. The ACCESS4_DELETE bit in the access mask returned will then be ignored by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの実装では、ACCESS4_DELETE権限を直接サポートしていません。 UNIXなどのオペレーティングシステムは、非ディレクトリオブジェクトに対するアクセス要求で設定されている場合、ACCESS4_DELETEビットを無視します。これらのシステムでは、ファイルの削除権限は、ファイル自体の権限ではなく、ファイルが存在するディレクトリへのアクセス権限によって決定されます。したがって、サポートされるアクセス権を列挙して返されたマスクでは、ACCESS4_DELETE値が0に設定されます。これは、サーバーがその特定のアクセス権をチェックできなかったことをクライアントに示します。返されたアクセスマスクのACCESS4_DELETEビットは、クライアントによって無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. Operation 4: CLOSE - Close File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. 操作4：CLOSE-ファイルを閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, open_stateid -&gt; open_stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、seqid、open_stateid-&gt; open_stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CLOSE4args {
           /* CURRENT_FH: object */
           seqid4          seqid;
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CLOSE4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       open_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLOSE operation releases share reservations for the regular or named attribute file as specified by the current filehandle. The share reservations and other state information released at the server as a result of this CLOSE are only associated with the supplied stateid. The sequence id provides for the correct ordering. State associated with other OPENs is not affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作は、現在のファイルハンドルで指定された通常または名前付きの属性ファイルの共有予約を解放します。このCLOSEの結果としてサーバーで解放された共有予約およびその他の状態情報は、指定されたstateidにのみ関連付けられます。シーケンスIDは正しい順序を提供します。他のOPENに関連する状態は影響を受けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If byte-range locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト範囲のロックが保持されている場合、クライアントはCLOSEを発行する前にすべてのロックを解放する必要があります（SHOULD）。サーバーはCLOSEですべての未解決のロックを解放してもかまいませんが、一部のサーバーは、バイト範囲のロックが保持されているファイルのCLOSEをサポートしない場合があります。 CLOSEの後にロックが存在する場合、サーバーは失敗を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though CLOSE returns a stateid, this stateid is not useful to the client and should be treated as deprecated. CLOSE &#34;shuts down&#34; the state associated with all OPENs for the file by a single open-owner. As noted above, CLOSE will either release all file locking state or return an error. Therefore, the stateid returned by CLOSE is not useful for the operations that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEはstateidを返しますが、このstateidはクライアントには役立ちません。非推奨として扱う必要があります。 CLOSEは、単一のオープン所有者によるファイルのすべてのOPENに関連付けられた状態を「シャットダウン」します。上記のように、CLOSEはすべてのファイルロック状態を解除するか、エラーを返します。したがって、CLOSEによって返される状態IDは、その後の操作には役立ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3. Operation 5: COMMIT - Commit Cached Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3. 操作5：COMMIT-キャッシュデータのコミット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), offset, count -&gt; verifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、オフセット、カウント-&gt;検証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMMIT4resok {
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMMIT operation forces or flushes data to stable storage for the file specified by the current filehandle. The flushed data is that which was previously written with a WRITE operation that had the stable field set to UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT操作は、現在のファイルハンドルで指定されたファイルのデータを強制的に保存するか、安定したストレージにフラッシュします。フラッシュされたデータは、安定したフィールドがUNSTABLE4に設定されたWRITE操作で以前に書き込まれたデータです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The offset specifies the position within the file where the flush is to begin. An offset value of 0 (zero) means to flush data starting at the beginning of the file. The count specifies the number of bytes of data to flush. If count is 0 (zero), a flush from the offset to the end of the file is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセットは、フラッシュを開始するファイル内の位置を指定します。オフセット値0（ゼロ）は、ファイルの先頭からデータをフラッシュすることを意味します。カウントは、フラッシュするデータのバイト数を指定します。 countが0（ゼロ）の場合、オフセットからファイルの最後までのフラッシュが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server returns a write verifier upon successful completion of the COMMIT. The write verifier is used by the client to determine if the server has restarted or rebooted between the initial WRITE(s) and the COMMIT. The client does this by comparing the write verifier returned from the initial writes and the verifier returned by the COMMIT operation. The server must vary the value of the write verifier at each server event or instantiation that may lead to a loss of uncommitted data. Most commonly, this occurs when the server is rebooted; however, other events at the server may result in uncommitted data loss as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
COMMITが正常に完了すると、サーバーは書き込みベリファイアを返します。クライアントが書き込みベリファイアを使用して、サーバーが最初のWRITEとCOMMITの間に再起動または再起動したかどうかを判断します。クライアントは、最初の書き込みから返された書き込みベリファイアとCOMMIT操作によって返されたベリファイアを比較することにより、これを行います。サーバーは、コミットされていないデータの損失につながる可能性のあるサーバーイベントまたはインスタンス化ごとに、書き込みベリファイアの値を変更する必要があります。最も一般的には、これはサーバーの再起動時に発生します。ただし、サーバーで他のイベントが発生すると、コミットされていないデータが失われる可能性もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMMIT operation is similar in operation and semantics to the POSIX fsync() [fsync] system call that synchronizes a file&#39;s state with the disk (file data and metadata are flushed to disk or stable storage). COMMIT performs the same operation for a client, flushing any unsynchronized data and metadata on the server to the server&#39;s disk or stable storage for the specified file. Like fsync(), it may be that there is some modified data or no modified data to synchronize. The data may have been synchronized by the server&#39;s normal periodic buffer synchronization activity. COMMIT should return NFS4_OK, unless there has been an unexpected error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT操作の操作とセマンティクスは、ファイルの状態をディスクと同期するPOSIX fsync()[fsync]システムコールと似ています（ファイルデータとメタデータはディスクまたは安定したストレージにフラッシュされます）。 COMMITはクライアントに対して同じ操作を実行し、サーバー上の同期されていないデータとメタデータをサーバーのディスクまたは指定されたファイルの安定したストレージにフラッシュします。 fsync()と同様に、同期する変更されたデータがあるか、変更されたデータがない可能性があります。データは、サーバーの通常の定期的なバッファー同期アクティビティによって同期された可能性があります。予期しないエラーが発生していない限り、COMMITはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT differs from fsync() in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before the file has been completely written).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITは、クライアントがファイルの範囲をフラッシュすることができるという点でfsync()とは異なります（ファイルが完全に書き込まれる前に、クライアントのバッファー再利用スキームによってトリガーされる可能性が高いです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server implementation of COMMIT is reasonably simple. If the server receives a full file COMMIT request that is starting at offset 0 and count 0, it should do the equivalent of fsync()&#39;ing the file. Otherwise, it should arrange to have the cached data in the range specified by offset and count to be flushed to stable storage. In both cases, any metadata associated with the file must be flushed to stable storage before returning. It is not an error for there to be nothing to flush on the server. This means that the data and metadata that needed to be flushed have already been flushed or lost during the last server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITのサーバー実装はかなり単純です。サーバーがオフセット0とカウント0で始まる完全なファイルCOMMIT要求を受信した場合、サーバーはファイルをfsync()するのと同じことを行う必要があります。それ以外の場合は、キャッシュされたデータをオフセットとカウントで指定された範囲にして、安定したストレージにフラッシュするように調整する必要があります。どちらの場合も、ファイルに関連付けられているメタデータは、戻る前に安定したストレージにフラッシュする必要があります。サーバー上でフラッシュするものが何もないことはエラーではありません。これは、フラッシュする必要のあるデータとメタデータが、最後のサーバー障害時にすでにフラッシュされたか、失われたことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client implementation of COMMIT is a little more complex. There are two reasons for wanting to commit a client buffer to stable storage. The first is that the client wants to reuse a buffer. In this case, the offset and count of the buffer are sent to the server in the COMMIT request. The server then flushes any cached data based on the offset and count, and flushes any metadata associated with the file. It then returns the status of the flush and the write verifier. The other reason for the client to generate a COMMIT is for a full file flush, such as may be done at CLOSE. In this case, the client would gather all of the buffers for this file that contain uncommitted data, do the COMMIT operation with an offset of 0 and count of 0, and then free all of those buffers. Any other dirty buffers would be sent to the server in the normal fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITのクライアント実装はもう少し複雑です。クライアントバッファを安定したストレージにコミットする理由は2つあります。 1つ目は、クライアントがバッファを再利用することです。この場合、バッファのオフセットとカウントは、COMMITリクエストでサーバーに送信されます。次に、サーバーはオフセットとカウントに基づいてキャッシュされたデータをフラッシュし、ファイルに関連付けられているメタデータをフラッシュします。次に、フラッシュと書き込みベリファイアのステータスを返します。クライアントがCOMMITを生成するもう1つの理由は、CLOSEで実行されるなど、ファイル全体をフラッシュするためです。この場合、クライアントは、コミットされていないデータを含むこのファイルのすべてのバッファーを収集し、オフセット0とカウント0でCOMMIT操作を実行してから、それらのバッファーをすべて解放します。他のダーティバッファは通常の方法でサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a buffer is written by the client with the stable parameter set to UNSTABLE4, the buffer must be considered modified by the client until the buffer has been either flushed via a COMMIT operation or written via a WRITE operation with the stable parameter set to FILE_SYNC4 or DATA_SYNC4. This is done to prevent the buffer from being freed and reused before the data can be flushed to stable storage on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したパラメータをUNSTABLE4に設定してクライアントによってバッファが書き込まれた後、COMMIT操作を介してバッファがフラッシュされるか、安定したパラメータをFILE_SYNC4に設定してWRITE操作を介して書き込まれるまで、クライアントはバッファを変更したと見なす必要があります。 DATA_SYNC4。これは、サーバー上の安定したストレージにデータをフラッシュする前に、バッファーが解放されて再利用されるのを防ぐために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a response is returned from either a WRITE or a COMMIT operation and it contains a write verifier that is different than previously returned by the server, the client will need to retransmit all of the buffers containing uncommitted cached data to the server. How this is to be done is up to the implementer. If there is only one buffer of interest, then it should probably be sent back over in a WRITE request with the appropriate stable parameter. If there is more than one buffer, it might be worthwhile to retransmit all of the buffers in WRITE requests with the stable parameter set to UNSTABLE4 and then retransmit the COMMIT operation to flush all of the data on the server to stable storage. The timing of these retransmissions is left to the implementer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込み操作またはCOMMIT操作から応答が返され、サーバーから以前に返されたものとは異なる書き込みベリファイアが含まれている場合、クライアントは、コミットされていないキャッシュデータを含むすべてのバッファーをサーバーに再送信する必要があります。これをどのように行うかは、実装者次第です。対象となるバッファが1つしかない場合は、適切な安定したパラメータを指定して、WRITEリクエストで送信する必要があります。複数のバッファがある場合は、stableパラメータをUNSTABLE4に設定してWRITEリクエストですべてのバッファを再送信してから、COMMIT操作を再送信して、サーバー上のすべてのデータを安定したストレージにフラッシュすることをお勧めします。これらの再送信のタイミングは実装者に任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above description applies to page-cache-based systems as well as buffer-cache-based systems. In those systems, the virtual memory system will need to be modified instead of the buffer cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の説明は、ページキャッシュベースのシステムとバッファキャッシュベースのシステムに適用されます。これらのシステムでは、バッファキャッシュの代わりに仮想メモリシステムを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4. Operation 6: CREATE - Create a Non-regular File Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4. 操作6：作成-通常以外のファイルオブジェクトを作成する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), name, type, attrs -&gt; (cfh), cinfo, attrset
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、名前、タイプ、attrs-&gt;（cfh）、cinfo、attrset
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union createtype4 switch (nfs_ftype4 type) {
    case NF4LNK:
            linktext4 linkdata;
    case NF4BLK:
    case NF4CHR:
            specdata4 devdata;
    case NF4SOCK:
    case NF4FIFO:
    case NF4DIR:
            void;
    default:
            void;  /* server should return NFS4ERR_BADTYPE */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           createtype4     objtype;
           component4      objname;
           fattr4          createattrs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4resok {
           change_info4    cinfo;
           bitmap4         attrset;        /* attributes set */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CREATE4res switch (nfsstat4 status) {
    case NFS4_OK:
            CREATE4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CREATE operation creates a non-regular file object in a directory with a given name. The OPEN operation is used to create a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE操作は、指定された名前のディレクトリに通常でないファイルオブジェクトを作成します。 OPEN操作は、通常のファイルを作成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The objname specifies the name for the new object. The objtype determines the type of object to be created: directory, symlink, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
objnameは、新しいオブジェクトの名前を指定します。 objtypeは、作成されるオブジェクトのタイプ（ディレクトリ、シンボリックリンクなど）を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ名前のオブジェクトがディレクトリにすでに存在する場合、サーバーはエラーNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the directory where the new file object was created, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the file object creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいファイルオブジェクトが作成されたディレクトリの場合、サーバーはchange_info4情報をcinfoに返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、変更前と変更後の属性がファイルオブジェクトの作成に関してアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the objname is of zero length, NFS4ERR_INVAL will be returned. The objname is also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
objnameの長さがゼロの場合、NFS4ERR_INVALが返されます。 objnameは、通常のUTF-8、文字サポート、および名前のチェックも受けます。詳細については、セクション12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、新しいオブジェクトのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The createattrs field specifies the initial set of attributes for the object. The set of attributes may include any writable attribute valid for the object type. When the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createattrsフィールドは、オブジェクトの属性の初期セットを指定します。属性のセットには、オブジェクトタイプに有効な書き込み可能な属性を含めることができます。操作が成功すると、サーバーは、オブジェクトにどの属性が正常に設定されたかを示す属性マスクをクライアントに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If createattrs includes neither the owner attribute nor an ACL with an ACE for the owner, and if the server&#39;s file system both supports and requires an owner attribute (or an owner ACE), then the server MUST derive the owner (or the owner ACE). This would typically be from the principal indicated in the RPC credentials of the call, but the server&#39;s operating environment or file system semantics may dictate other methods of derivation. Similarly, if createattrs includes neither the group attribute nor a group ACE, and if the server&#39;s file system both supports and requires the notion of a group attribute (or group ACE), the server MUST derive the group attribute (or the corresponding owner ACE) for the file. This could be from the RPC&#39;s credentials, such as the group principal if the credentials include it (such as with AUTH_SYS), from the group identifier associated with the principal in the credentials (e.g., POSIX systems have a user database [getpwnam] that has the group identifier for every user identifier), inherited from the directory the object is created in, or whatever else the server&#39;s operating environment or file system semantics dictate. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
createattrsに所有者属性も、所有者のACEを含むACLも含まれておらず、サーバーのファイルシステムが所有者属性（または所有者ACE）をサポートおよび要求している場合、サーバーは所有者（または所有者ACE）を導出する必要があります。 。これは通常、呼び出しのRPC資格情報に示されているプリンシパルからのものですが、サーバーの動作環境またはファイルシステムのセマンティクスによって、他の派生方法が決まる場合があります。同様に、createattrsにグループ属性もグループACEも含まれておらず、サーバーのファイルシステムがグループ属性（またはグループACE）の概念をサポートおよび要求している場合、サーバーはグループ属性（または対応する所有者ACE）を導出する必要があります。ファイル用。これは、RPCの資格情報（AUTH_SYSなどを使用して資格情報に含まれている場合はグループプリンシパルなど）から、資格情報内のプリンシパルに関連付けられたグループ識別子から（たとえば、POSIXシステムにユーザーデータベース[getpwnam]がある）すべてのユーザー識別子のグループ識別子）、オブジェクトが作成されたディレクトリ、またはサーバーの動作環境やファイルシステムのセマンティクスで指定されたものから継承されます。これは、OPEN操作にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversely, it is possible the client will specify in createattrs an owner attribute, group attribute, or ACL that the principal indicated the RPC&#39;s credentials does not have permissions to create files for. The error to be returned in this instance is NFS4ERR_PERM. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆に、クライアントがcreateattrsで所有者属性、グループ属性、またはACLを指定する可能性があります。この場合、プリンシパルはRPCの資格情報にファイルを作成する権限がないことを示します。このインスタンスで返されるエラーはNFS4ERR_PERMです。これは、OPEN操作にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client desires to set attribute values after the create, a SETATTR operation can be added to the COMPOUND request so that the appropriate attributes will be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが作成後に属性値を設定することを望む場合、適切な属性が設定されるように、SETATTR操作をCOMPOUND要求に追加できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5. Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5. 操作7：DELEGPURGE-回復を待機している委任のパージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid -&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid-&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGPURGE4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGPURGE4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DELEGPURGE purges all of the delegations awaiting recovery for a given client. This is useful for clients that do not commit delegation information to stable storage, to indicate that conflicting requests need not be delayed by the server awaiting recovery of delegation information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DELEGPURGEは、指定されたクライアントの回復を待機しているすべての委任を削除します。これは、委任情報を安定したストレージにコミットしないクライアントに役立ちます。サーバーが委任情報の回復を待つことで、競合する要求を遅らせる必要がないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is provided to support clients that record delegation information in stable storage on the client. In this case, DELEGPURGE should be issued immediately after doing delegation recovery (using CLAIM_DELEGATE_PREV) on all delegations known to the client. Doing so will notify the server that no additional delegations for the client will be recovered, allowing it to free resources and avoid delaying other clients who make requests that conflict with the unrecovered delegations. All clients SHOULD use DELEGPURGE as part of recovery once it is known that no further CLAIM_DELEGATE_PREV recovery will be done. This includes clients that do not record delegation information in stable storage, who would then do a DELEGPURGE immediately after SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、クライアント上の安定したストレージに委任情報を記録するクライアントをサポートするために提供されています。この場合、クライアントに認識されているすべての委任に対して委任リカバリーを（CLAIM_DELEGATE_PREVを使用して）実行した直後に、DELEGPURGEを発行する必要があります。これにより、サーバーにクライアントの追加の委任が回復されないことが通知され、リソースを解放して、回復されていない委任と競合する要求を行う他のクライアントの遅延を回避できます。すべてのクライアントは、CLAIM_DELEGATE_PREVの回復がこれ以上行われないことがわかったら、回復の一部としてDELEGPURGEを使用する必要があります（SHOULD）。これには、安定したストレージに委任情報を記録しないクライアントが含まれ、SETCLIENTID_CONFIRMの直後にDELEGPURGEを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of delegations known to the server and the client may be different. The reasons for this include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーとクライアントが認識している委任のセットは異なる場合があります。この理由は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client may fail after making a request that resulted in delegation but before it received the results and committed them to the client&#39;s stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任の原因となった要求を行った後、結果を受信して​​クライアントの安定したストレージにコミットする前に、クライアントが失敗する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client may fail after deleting its indication that a delegation exists but before the delegation return is fully processed by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任が存在するという表示を削除した後、委任の戻りがサーバーによって完全に処理される前に、クライアントが失敗する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case in which the server and the client restart, the server may have limited persistent recording of delegations to a subset of those in existence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーとクライアントが再起動した場合、サーバーは、委任の永続的な記録を、存在する委任のサブセットに限定して制限することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client may have only persistently recorded information about a subset of delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントには、委任のサブセットに関する情報が永続的に記録されている場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY support DELEGPURGE, but its support or non-support should match that of CLAIM_DELEGATE_PREV:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはDELEGPURGEをサポートする場合がありますが、そのサポートまたは非サポートは、CLAIM_DELEGATE_PREVのサポートと一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A server may support both DELEGPURGE and CLAIM_DELEGATE_PREV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、DELEGPURGEとCLAIM_DELEGATE_PREVの両方をサポートする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A server may support neither DELEGPURGE nor CLAIM_DELEGATE_PREV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、DELEGPURGEもCLAIM_DELEGATE_PREVもサポートしない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This fact allows a client starting up to determine if the server is prepared to support persistent storage of delegation information and thus whether it may use write-back caching to local persistent storage, relying on CLAIM_DELEGATE_PREV recovery to allow such changed data to be flushed safely to the server in the event of client restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この事実により、クライアントは、サーバーが委任情報の永続ストレージをサポートする準備ができているかどうか、したがってローカル永続ストレージへのライトバックキャッシュを使用できるかどうかを判断し、CLAIM_DELEGATE_PREVリカバリに依存して、変更されたデータを安全にフラッシュできるようにします。クライアントが再起動した場合のサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6. Operation 8: DELEGRETURN - Return Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6. 操作8：DELEGRETURN-委任を返す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid -&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid-&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGRETURN4args {
           /* CURRENT_FH: delegated file */
           stateid4        deleg_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGRETURN4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DELEGRETURN returns the delegation represented by the current filehandle and stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DELEGRETURNは、現在のファイルハンドルと状態IDで表される委任を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations may be returned when recalled or voluntarily (i.e., before the server has recalled them). In either case, the client must properly propagate state changed under the context of the delegation to the server before returning the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任は、リコールされたとき、または自発的に（つまり、サーバーがリコールする前に）返される場合があります。どちらの場合も、クライアントは、委任を返す前に、委任のコンテキストで変更された状態をサーバーに適切に伝達する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7. Operation 9: GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7. 操作9：GETATTR-属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), attrbits -&gt; attrbits, attrvals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、attrbits-&gt; attrbits、attrvals
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETATTR4args {
           /* CURRENT_FH: directory or file */
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETATTR4resok {
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GETATTR operation will obtain attributes for the file system object specified by the current filehandle. The client sets a bit in the bitmap argument for each attribute value that it would like the server to return. The server returns an attribute bitmap that indicates the attribute values for which it was able to return values, followed by the attribute values ordered lowest attribute number first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTR操作は、現在のファイルハンドルで指定されたファイルシステムオブジェクトの属性を取得します。クライアントは、サーバーが返す各属性値のビットマップ引数にビットを設定します。サーバーは、値を返すことができた属性値を示す属性ビットマップを返し、次に、属性値が最小の属性番号順に並べられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST return a value for each attribute that the client requests if the attribute is supported by the server. If the server does not support an attribute or cannot approximate a useful value, then it MUST NOT return the attribute value and MUST NOT set the attribute bit in the result bitmap. The server MUST return an error if it supports an attribute on the target but cannot obtain its value. In that case, no attribute values will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが属性をサポートしている場合、サーバーは、クライアントが要求する各属性の値を返す必要があります。サーバーが属性をサポートしていないか、有用な値を概算できない場合は、属性値を返してはならず、結果のビットマップに属性ビットを設定してはなりません（MUST NOT）。サーバーは、ターゲットの属性をサポートしているがその値を取得できない場合、エラーを返さなければなりません（MUST）。その場合、属性値は返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File systems that are absent should be treated as having support for a very small set of attributes as described in Section 8.3.1 -- even if previously, when the file system was present, more attributes were supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在しないファイルシステムは、セクション8.3.1で説明されているように、非常に小さな属性のセットをサポートしているものとして扱う必要があります。以前は、ファイルシステムが存在していたときに、より多くの属性がサポートされていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All servers MUST support the REQUIRED attributes, as specified in Section 5, for all file systems, with the exception of absent file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのサーバーは、セクション5で指定されているように、存在しないファイルシステムを除いて、すべてのファイルシステムのREQUIRED属性をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose there is an OPEN_DELEGATE_WRITE delegation held by another client for the file in question, and size and/or change are among the set of attributes being interrogated. The server has two choices. First, the server can obtain the actual current value of these attributes from the client holding the delegation by using the CB_GETATTR callback. Second, the server, particularly when the delegated client is unresponsive, can recall the delegation in question. The GETATTR MUST NOT proceed until one of the following occurs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題のファイルについて別のクライアントによって保持されているOPEN_DELEGATE_WRITE委任があり、サイズまたは変更、あるいはその両方が、照会される属性のセットに含まれているとします。サーバーには2つの選択肢があります。最初に、サーバーはCB_GETATTRコールバックを使用して、委任を保持しているクライアントからこれらの属性の実際の現在の値を取得できます。次に、サーバーは、特に委任されたクライアントが応答しない場合、問題の委任を呼び出すことができます。 GETATTRは、次のいずれかが発生するまで続行してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The requested attribute values are returned in the response to CB_GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された属性値は、CB_GETATTRへの応答で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The OPEN_DELEGATE_WRITE delegation is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The OPEN_DELEGATE_WRITE delegation is revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任は取り消されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless one of the above happens very quickly, one or more NFS4ERR_DELAY errors will be returned while a delegation is outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のいずれかが非常に迅速に発生しない限り、委任が未解決である間、1つ以上のNFS4ERR_DELAYエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8. Operation 10: GETFH - Get Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8. 操作10：GETFH-現在のファイルハンドルを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; filehandle
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）-&gt;ファイルハンドル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETFH4resok {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETFH4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation returns the current filehandle value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、現在のファイルハンドル値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operations that change the current filehandle, like LOOKUP or CREATE, do not automatically return the new filehandle as a result. For instance, if a client needs to look up a directory entry and obtain its filehandle, then the following request is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPやCREATEなどの現在のファイルハンドルを変更する操作は、結果として新しいファイルハンドルを自動的に返しません。たとえば、クライアントがディレクトリエントリを検索してそのファイルハンドルを取得する必要がある場合、次のリクエストが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH (directory filehandle) LOOKUP (entry name) GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH（ディレクトリファイルハンドル）LOOKUP（エントリ名）GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9. Operation 11: LINK - Create Link to a File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9. 操作11：リンク-ファイルへのリンクを作成する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh), (cfh), newname -&gt; (cfh), cinfo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（sfh）、（cfh）、newname-&gt;（cfh）、cinfo
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LINK4args {
           /* SAVED_FH: source object */
           /* CURRENT_FH: target directory */
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LINK4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LINK operation creates an additional newname for the file represented by the saved filehandle, as set by the SAVEFH operation, in the directory represented by the current filehandle. The existing file and the target directory must reside within the same file system on the server. On success, the current filehandle will continue to be the target directory. If an object exists in the target directory with the same name as newname, the server must return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LINK操作は、SAVEFH操作で設定された、保存されたファイルハンドルで表されるファイルの追加の新しい名前を、現在のファイルハンドルで表されるディレクトリに作成します。既存のファイルとターゲットディレクトリは、サーバー上の同じファイルシステム内に存在する必要があります。成功した場合、現在のファイルハンドルは引き続きターゲットディレクトリになります。 newnameと同じ名前のオブジェクトがターゲットディレクトリに存在する場合、サーバーはNFS4ERR_EXISTを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリの場合、サーバーはchange_info4情報をcinfoに返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、リンクの作成に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If newname has a length of 0 (zero), or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
newnameの長さが0（ゼロ）である場合、またはnewnameがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes to any property of the &#34;hard&#34; linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ハード」リンクファイルのプロパティへの変更は、すべてのリンクファイルに反映されます。ファイルへのリンクが作成されるとき、ファイルの属性には、リンク操作の前の値よりも1だけ大きいnumlinksの値が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The statement &#34;file and the target directory must reside within the same file system on the server&#34; means that the fsid fields in the attributes for the objects are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned. This error may be returned by some servers when there is an internal partitioning of a file system that the LINK operation would violate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ファイルとターゲットディレクトリはサーバー上の同じファイルシステム内に存在する必要がある」という文は、オブジェクトの属性のfsidフィールドが同じであることを意味します。それらが異なるファイルシステムに存在する場合、エラーNFS4ERR_XDEVが返されます。このエラーは、LINK操作に違反するファイルシステムの内部パーティションがある場合に、一部のサーバーから返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On some servers, &#34;.&#34; and &#34;..&#34; are illegal values for newname, and the error NFS4ERR_BADNAME will be returned if they are specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーでは、「。」と &#34;..&#34;はnewnameに対して無効な値であり、指定されている場合はエラーNFS4ERR_BADNAMEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is not a named attribute for the same object, the error NFS4ERR_XDEV MUST be returned. When the saved filehandle designates a named attribute and the current filehandle is not the appropriate named attribute directory, the error NFS4ERR_XDEV MUST also be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが名前付き属性ディレクトリを指定し、リンクされるオブジェクト（保存されたファイルハンドル）が同じオブジェクトの名前付き属性でない場合、エラーNFS4ERR_XDEVを返さなければなりません（MUST）。保存されたファイルハンドルが名前付き属性を指定し、現在のファイルハンドルが適切な名前付き属性ディレクトリでない場合、エラーNFS4ERR_XDEVも返されなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is a named attribute within that directory, the server MAY return the error NFS4ERR_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが名前付き属性ディレクトリを指定し、リンクされるオブジェクト（保存されたファイルハンドル）がそのディレクトリ内の名前付き属性である場合、サーバーはエラーNFS4ERR_NOTSUPPを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that newname is already linked to the file represented by the saved filehandle, the server will return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存されたファイルハンドルによって表されるファイルにnewnameがすでにリンクされている場合、サーバーはNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that symbolic links are created with the CREATE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンボリックリンクはCREATE操作で作成されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10. Operation 12: LOCK - Create Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10. 操作12：LOCK-ロックの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) locktype, reclaim, offset, length, locker -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）locktype、reclaim、offset、length、locker-&gt; stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum nfs_lock_type4 {
           READ_LT         = 1,
           WRITE_LT        = 2,
           READW_LT        = 3,    /* blocking read */
           WRITEW_LT       = 4     /* blocking write */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, transition from open_owner to new lock_owner
    */
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, existing lock_owner continues to request file locks
    */
   struct exist_lock_owner4 {
           stateid4        lock_stateid;
           seqid4          lock_seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union locker4 switch (bool new_lock_owner) {
    case TRUE:
            open_to_lock_owner4     open_owner;
    case FALSE:
            exist_lock_owner4       lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           bool            reclaim;
           offset4         offset;
           length4         length;
           locker4         locker;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4denied {
           offset4         offset;
           length4         length;
           nfs_lock_type4  locktype;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4resok {
           stateid4        lock_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LOCK4resok     resok4;
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCK operation requests a byte-range lock for the byte range specified by the offset and length parameters. The lock type is also specified to be one of the nfs_lock_type4s. If this is a reclaim request, the reclaim parameter will be TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK操作は、offsetパラメータとlengthパラメータで指定されたバイト範囲のバイト範囲ロックを要求します。ロックタイプもnfs_lock_type4sの1つとして指定されています。これが再利用リクエストの場合、再利用パラメーターはTRUEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bytes in a file may be locked even if those bytes are not currently allocated to the file. To lock the file from a specific offset through the end-of-file (no matter how long the file actually is), use a length field with all bits set to 1 (one). If the length is zero, or if a length that is not all bits set to one is specified, and the length when added to the offset exceeds the maximum 64-bit unsigned integer value, the error NFS4ERR_INVAL will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル内のバイトは、それらのバイトが現在ファイルに割り当てられていなくてもロックされる場合があります。特定のオフセットからファイルの終わりまでファイルをロックするには（ファイルが実際にどのくらい長くても）、すべてのビットを1に設定した長さフィールドを使用します。長さがゼロの場合、またはすべてのビットが1に設定されていない長さが指定され、オフセットに追加したときの長さが最大64ビットの符号なし整数値を超える場合、エラーNFS4ERR_INVALが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32-bit servers are servers that support locking for byte offsets that fit within 32 bits (i.e., less than or equal to NFS4_UINT32_MAX). If the client specifies a range that overlaps one or more bytes beyond offset NFS4_UINT32_MAX but does not end at offset NFS4_UINT64_MAX, then such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットサーバーは、32ビット内に収まるバイトオフセット（つまり、NFS4_UINT32_MAX以下）のロックをサポートするサーバーです。クライアントがオフセットNFS4_UINT32_MAXを超えて1バイト以上オーバーラップする範囲を指定しているが、オフセットNFS4_UINT64_MAXで終わっていない場合、そのような32ビットサーバーはエラーNFS4ERR_BAD_RANGEを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the lock is denied, the owner, offset, and length of a conflicting lock are returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックが拒否された場合、競合するロックの所有者、オフセット、および長さが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. Section 9 contains a full description of this and the other file locking operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが競合するロックの正確なオフセットと長さを判別できない場合、引数で指定されたものと同じオフセットと長さが拒否された結果に返されます。セクション9には、これとその他のファイルロック操作の詳細な説明が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK operations are subject to permission checks and to checks against the access type of the associated file. However, the specific rights and modes required for various types of locks reflect the semantics of the server-exported file system, and are not specified by the protocol. For example, Windows 2000 allows a write lock of a file open for READ, while a POSIX-compliant system does not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK操作は、権限チェックと、関連ファイルのアクセスタイプに対するチェックの対象となります。ただし、さまざまなタイプのロックに必要な特定の権限とモードは、サーバーでエクスポートされたファイルシステムのセマンティクスを反映しており、プロトコルでは指定されていません。たとえば、Windows 2000では、読み取り用に開いているファイルの書き込みロックが許可されていますが、POSIX準拠のシステムでは許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client makes a lock request that corresponds to a range that the lock-owner has locked already (with the same or different lock type), or to a sub-region of such a range, or to a region that includes multiple locks already granted to that lock-owner, in whole or in part, and the server does not support such locking operations (i.e., does not support POSIX locking semantics), the server will return the error NFS4ERR_LOCK_RANGE. In that case, the client may return an error, or it may emulate the required operations, using only LOCK for ranges that do not include any bytes already locked by that lock-owner and LOCKU of locks held by that lock-owner (specifying an exactly matching range and type). Similarly, when the client makes a lock request that amounts to upgrading (changing from a read lock to a write lock) or downgrading (changing from a write lock to a read lock) an existing record lock and the server does not support such a lock, the server will return NFS4ERR_LOCK_NOTSUPP. Such operations may not perfectly reflect the required semantics in the face of conflicting lock requests from other clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが、ロック所有者がすでにロックした（同じまたは異なるロックタイプで）範囲、またはそのような範囲のサブ領域、またはすでに複数のロックを含む領域に対応するロック要求を出したときそのロック所有者に全体的または部分的に付与され、サーバーがそのようなロック操作をサポートしない（つまり、POSIXロックセマンティクスをサポートしない）場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返します。その場合、クライアントはエラーを返すか、必要な操作をエミュレートし、そのロック所有者によってすでにロックされているバイトとそのロック所有者によって保持されているロックのLOCKUを含まない範囲のLOCKのみを使用します（指定する正確に一致する範囲とタイプ）。同様に、クライアントが既存のレコードロックをアップグレード（読み取りロックから書き込みロックに変更）またはダウングレード（書き込みロックから読み取りロックに変更）するロック要求を行うと、サーバーはそのようなロックをサポートしません。 、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。このような操作は、他のクライアントからのロック要求の競合に直面して、必要なセマンティクスを完全に反映していない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a client holds an OPEN_DELEGATE_WRITE delegation, the client holding that delegation is assured that there are no opens by other clients. Thus, there can be no conflicting LOCK operations from such clients. Therefore, the client may be handling locking requests locally, without doing LOCK operations on the server. If it does that, it must be prepared to update the lock status on the server by sending appropriate LOCK and LOCKU operations before returning the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合、その委任を保持しているクライアントは、他のクライアントによるオープンがないことが保証されます。したがって、そのようなクライアントからのLOCK操作の競合はありません。したがって、クライアントは、サーバーでLOCK操作を実行せずに、ローカルでロック要求を処理している可能性があります。その場合、委任を返す前に、適切なLOCKおよびLOCKU操作を送信して、サーバーのロックステータスを更新する準備をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When one or more clients hold OPEN_DELEGATE_READ delegations, any LOCK operation where the server is implementing mandatory locking semantics MUST result in the recall of all such delegations. The LOCK operation may not be granted until all such delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つ以上のクライアントがOPEN_DELEGATE_READ委任を保持している場合、サーバーが必須のロックセマンティクスを実装しているLOCK操作では、そのようなすべての委任が再呼び出しされる必要があります。 LOCK操作は、そのような委任がすべて返されるか取り消されるまで許可されない場合があります。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The locker argument specifies the lock-owner that is associated with the LOCK request. The locker4 structure is a switched union that indicates whether the client has already created byte-range locking state associated with the current open file and lock-owner. There are multiple cases to be considered, corresponding to possible combinations of whether locking state has been created for the current open file and lock-owner, and whether the boolean new_lock_owner is set. In all of the cases, there is a lock_seqid specified, whether the lock-owner is specified explicitly or implicitly. This seqid value is used for checking lock-owner sequencing/replay issues. When the given lock-owner is not known to the server, this establishes an initial sequence value for the new lock-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
locker引数は、LOCK要求に関連付けられているロック所有者を指定します。 locker4構造は、クライアントが現在開いているファイルとロック所有者に関連付けられたバイト範囲ロック状態をすでに作成しているかどうかを示すスイッチドユニオンです。現在のオープンファイルとロック所有者に対してロック状態が作成されているかどうか、およびブール値new_lock_ownerが設定されているかどうかの可能な組み合わせに対応して、考慮すべき複数のケースがあります。すべてのケースで、lock_seqidが指定されています。これは、ロック所有者が明示的に指定されているか、暗黙的に指定されているかに関係ありません。このseqid値は、ロック所有者の順序付け/再生の問題をチェックするために使用されます。指定されたロック所有者がサーバーに知られていない場合、これは新しいロック所有者の初期シーケンス値を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case in which the state has been created and the boolean is false, the only part of the argument other than lock_seqid is just a stateid representing the set of locks associated with that open file and lock-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 状態が作成されており、ブール値がfalseの場合、lock_seqid以外の引数の一部は、その開いているファイルとロック所有者に関連付けられたロックのセットを表す状態IDだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case in which the state has been created and the boolean is true, the server rejects the request with the error NFS4ERR_BAD_SEQID. The only exception is where there is a retransmission of a previous request in which the boolean was true. In this case, the lock_seqid will match the original request, and the response will reflect the final case, below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 状態が作成され、ブール値がtrueの場合、サーバーはエラーNFS4ERR_BAD_SEQIDで要求を拒否します。唯一の例外は、ブール値がtrueだった前の要求の再送信がある場合です。この場合、lock_seqidは元のリクエストと一致し、応答は以下の最後のケースを反映します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case where no byte-range locking state has been established and the boolean is true, the argument contains an open_to_lock_owner structure that specifies the stateid of the open file and the lock-owner to be used for the lock. Note that although the open-owner is not given explicitly, the open_seqid associated with it is used to check for open-owner sequencing issues. This case provides a method to use the established state of the open_stateid to transition to the use of a lock stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイト範囲のロック状態が確立されておらず、ブール値がtrueの場合、引数には、開いているファイルの状態IDとロックに使用されるロック所有者を指定するopen_to_lock_owner構造体が含まれます。 open-ownerは明示的に指定されていませんが、それに関連付けられているopen_seqidはopen-ownerのシーケンスの問題をチェックするために使用されることに注意してください。このケースは、open_stateidの確立された状態を使用してロックstateidの使用に移行するメソッドを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11. Operation 13: LOCKT - Test for Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11. 操作13：LOCKT-ロックのテスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh) locktype, offset, length, owner -&gt; {void, NFS4ERR_DENIED -&gt;
     owner}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKT4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           offset4         offset;
           length4         length;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    case NFS4_OK:
            void;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKT operation tests the lock as specified in the arguments. If a conflicting lock exists, the owner, offset, length, and type of the conflicting lock are returned; if no lock is held, nothing other than NFS4_OK is returned. Lock types READ_LT and READW_LT are processed in the same way in that a conflicting lock test is done without regard to blocking or non-blocking. The same is true for WRITE_LT and WRITEW_LT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT操作は、引数で指定されたロックをテストします。競合するロックが存在する場合、競合するロックの所有者、オフセット、長さ、およびタイプが返されます。ロックが保持されていない場合、NFS4_OK以外は何も返されません。ロック・タイプREAD_LTおよびREADW_LTは、ブロッキングまたは非ブロッキングに関係なく、競合するロック・テストが行​​われるのと同じ方法で処理されます。 WRITE_LTおよびWRITEW_LTについても同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲はLOCKの場合と同様に指定されます。 NFS4ERR_INVALおよびNFS4ERR_BAD_RANGEエラーは、LOCKの場合と同じ状況で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. Section 9 contains further discussion of the file locking mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが競合するロックの正確なオフセットと長さを判別できない場合、引数で指定されたものと同じオフセットと長さが拒否された結果に返されます。セクション9には、ファイルロックメカニズムの詳細が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT uses a lock_owner4, rather than a stateid4 as is used in LOCK, to identify the owner. This is because the client does not have to open the file to test for the existence of a lock, so a stateid may not be available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKTは、LOCKで使用されるstateid4ではなく、lock_owner4を使用して所有者を識別します。これは、クライアントがロックの存在をテストするためにファイルを開く必要がないため、stateidが使用できない場合があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The test for conflicting locks SHOULD exclude locks for the current lock-owner. Note that since such locks are not examined the possible existence of overlapping ranges may not affect the results of LOCKT. If the server does examine locks that match the lock-owner for the purpose of range checking, NFS4ERR_LOCK_RANGE may be returned. In the event that it returns NFS4_OK, clients may do a LOCK and receive NFS4ERR_LOCK_RANGE on the LOCK request because of the flexibility provided to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合するロックのテストでは、現在のロック所有者のロックを除外する必要があります（SHOULD）。このようなロックは検査されないため、重複する範囲が存在しても、LOCKTの結果に影響しない可能性があることに注意してください。サーバーが範囲チェックの目的でロック所有者と一致するロックを検査する場合、NFS4ERR_LOCK_RANGEが返されることがあります。 NFS4_OKを返す場合、サーバーに柔軟性が提供されるため、クライアントはLOCKを実行し、LOCK要求でNFS4ERR_LOCK_RANGEを受け取ることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 16.10.5) to handle LOCK requests locally. In such a case, LOCKT requests will similarly be handled locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合、LOCK要求をローカルで処理することを選択できます（セクション16.10.5を参照）。このような場合、LOCKT要求は同様にローカルで処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12. Operation 14: LOCKU - Unlock File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12. 操作14：LOCKU-ファイルのロック解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) type, seqid, stateid, offset, length -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）type、seqid、stateid、offset、length-&gt; stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKU4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           seqid4          seqid;
           stateid4        lock_stateid;
           offset4         offset;
           length4         length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKU4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       lock_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKU operation unlocks the byte-range lock specified by the parameters. The client may set the locktype field to any value that is legal for the nfs_lock_type4 enumerated type, and the server MUST accept any legal value for locktype. Any legal value for locktype has no effect on the success or failure of the LOCKU operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKU操作は、パラメーターで指定されたバイト範囲ロックをアンロックします。クライアントは、locktypeフィールドをnfs_lock_type4列挙型に有効な任意の値に設定できます。サーバーは、locktypeに有効な任意の値を受け入れる必要があります。 locktypeの正当な値は、LOCKU操作の成功または失敗には影響しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲はLOCKの場合と同様に指定されます。 NFS4ERR_INVALおよびNFS4ERR_BAD_RANGEエラーは、LOCKの場合と同じ状況で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the area to be unlocked does not correspond exactly to a lock actually held by the lock-owner, the server may return the error NFS4ERR_LOCK_RANGE. This includes the cases where (1) the area is not locked, (2) the area is a sub-range of the area locked, (3) it overlaps the area locked without matching exactly, or (4) the area specified includes multiple locks held by the lock-owner. In all of these cases, allowed by POSIX locking [fcntl] semantics, a client receiving this error should, if it desires support for such operations, simulate the operation using LOCKU on ranges corresponding to locks it actually holds, possibly followed by LOCK requests for the sub-ranges not being unlocked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック解除する領域が、ロック所有者が実際に保持しているロックに正確に対応していない場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返すことがあります。これには、（1）エリアがロックされていない、（2）エリアがロックされたエリアのサブ範囲である、（3）完全に一致せずにロックされたエリアと重なる、（4）指定されたエリアに複数が含まれる場合が含まれますロック所有者が保持するロック。 POSIXロック[fcntl]セマンティクスで許可されているこれらすべてのケースで、このエラーを受信するクライアントは、そのような操作のサポートが必要な場合、実際に保持しているロックに対応する範囲でLOCKUを使用して操作をシミュレートし、その後にLOCK要求を実行する必要があります。ロック解除されていないサブ範囲。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 16.10.5) to handle LOCK requests locally. In such a case, LOCKU requests will similarly be handled locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合、LOCK要求をローカルで処理することを選択できます（セクション16.10.5を参照）。このような場合、LOCKU要求も同様にローカルで処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13. Operation 15: LOOKUP - Look Up Filename
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13. 操作15：LOOKUP-ファイル名を検索
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), component -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、コンポーネント-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           component4      objname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUP4res {
           /* CURRENT_FH: object */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation performs a LOOKUP or finds a file system object using the directory specified by the current filehandle. LOOKUP evaluates the component and if the object exists the current filehandle is replaced with the component&#39;s filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、LOOKUPを実行するか、現在のファイルハンドルで指定されたディレクトリを使用してファイルシステムオブジェクトを見つけます。 LOOKUPはコンポーネントを評価し、オブジェクトが存在する場合、現在のファイルハンドルがコンポーネントのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component cannot be evaluated because either it does not exist or the client does not have permission to evaluate it, then an error will be returned, and the current filehandle will be unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントが存在しないか、クライアントにそれを評価する権限がないためにコンポーネントを評価できない場合、エラーが返され、現在のファイルハンドルは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントの長さがゼロの場合、NFS4ERR_INVALが返されます。このコンポーネントは、通常のUTF-8、文字サポート、および名前のチェックも受けます。詳細については、セクション12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to achieve the effect of a multi-component lookup, it may construct a COMPOUND request such as the following (and obtain each filehandle):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがマルチコンポーネントルックアップの効果を実現したい場合、クライアントは次のようなCOMPOUNDリクエストを作成します（そして各ファイルハンドルを取得します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH (directory filehandle) LOOKUP &#34;pub&#34; GETFH LOOKUP &#34;foo&#34; GETFH LOOKUP &#34;bar&#34; GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH（ディレクトリファイルハンドル）LOOKUP &#34;pub&#34; GETFH LOOKUP &#34;foo&#34; GETFH LOOKUP &#34;bar&#34; GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 servers depart from the semantics of previous NFS versions in allowing LOOKUP requests to cross mount points on the server. The client can detect a mount point crossing by comparing the fsid attribute of the directory with the fsid attribute of the directory looked up. If the fsids are different, then the new directory is a server mount point. UNIX clients that detect a mount point crossing will need to mount the server&#39;s file system. This needs to be done to maintain the file object identity-checking mechanisms common to UNIX clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4サーバーは、サーバー上のマウントポイントを横断するLOOKUP要求を許可するという点で、以前のNFSバージョンのセマンティクスから逸脱しています。クライアントは、ディレクトリのfsid属性と、検索されたディレクトリのfsid属性を比較することにより、マウントポイントの交差を検出できます。 fsidが異なる場合、新しいディレクトリはサーバーのマウントポイントです。マウントポイントの交差を検出するUNIXクライアントは、サーバーのファイルシステムをマウントする必要があります。これは、UNIXクライアントに共通のファイルオブジェクトIDチェックメカニズムを維持するために実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that limit NFS access to &#34;shares&#34; or &#34;exported&#34; file systems should provide a pseudo-file system into which the exported file systems can be integrated, so that clients can browse the server&#39;s namespace. The clients&#39; view of a pseudo-file system will be limited to paths that lead to exported file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSアクセスを「共有」または「エクスポート」ファイルシステムに制限するサーバーは、クライアントがサーバーの名前空間を参照できるように、エクスポートファイルシステムを統合できる疑似ファイルシステムを提供する必要があります。疑似ファイルシステムのクライアントのビューは、エクスポートされたファイルシステムにつながるパスに制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Previous versions of the protocol assigned special semantics to the names &#34;.&#34; and &#34;..&#34;. NFSv4 assigns no special semantics to these names. The LOOKUPP operator must be used to look up a parent directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：プロトコルの以前のバージョンでは、名前「。」に特別なセマンティクスが割り当てられていました。そして「..」。 NFSv4は、これらの名前に特別なセマンティクスを割り当てません。親ディレクトリを検索するには、LOOKUPP演算子を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this operation does not follow symbolic links. The client is responsible for all parsing of filenames, including filenames that are modified by symbolic links encountered during the lookup process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作はシンボリックリンクをたどらないことに注意してください。クライアントは、ルックアッププロセス中に検出されたシンボリックリンクによって変更されたファイル名を含む、ファイル名のすべての解析を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle supplied is not a directory but a symbolic link, NFS4ERR_SYMLINK is returned as the error. For all other non-directory file types, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
提供された現在のファイルハンドルがディレクトリではなくシンボリックリンクの場合、NFS4ERR_SYMLINKがエラーとして返されます。他のすべての非ディレクトリファイルタイプの場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14. Operation 16: LOOKUPP - Look Up Parent Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14. 操作16：LOOKUPP-親ディレクトリを検索
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: object */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUPP4res {
           /* CURRENT_FH: directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle is assumed to refer to a regular directory or a named attribute directory. LOOKUPP assigns the filehandle for its parent directory to be the current filehandle. If there is no parent directory, an NFS4ERR_NOENT error must be returned. Therefore, NFS4ERR_NOENT will be returned by the server when the current filehandle is at the root or top of the server&#39;s file tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、通常のディレクトリまたは名前付き属性ディレクトリを参照すると想定されています。 LOOKUPPは、親ディレクトリのファイルハンドルを現在のファイルハンドルに割り当てます。親ディレクトリがない場合は、NFS4ERR_NOENTエラーを返す必要があります。したがって、現在のファイルハンドルがサーバーのファイルツリーのルートまたは最上位にある場合、サーバーはNFS4ERR_NOENTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As for LOOKUP, LOOKUPP will also cross mount points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPについては、LOOKUPPもマウントポイントを通過します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not a directory or named attribute directory, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルがディレクトリまたは名前付き属性ディレクトリでない場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is a named attribute directory that is associated with a file system object via OPENATTR (i.e., not a subdirectory of a named attribute directory), LOOKUPP SHOULD return the filehandle of the associated file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルがOPENATTRを介してファイルシステムオブジェクトに関連付けられている名前付き属性ディレクトリである場合（つまり、名前付き属性ディレクトリのサブディレクトリではない場合）、LOOKUPPは関連付けられているファイルシステムオブジェクトのファイルハンドルを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15. Operation 17: NVERIFY - Verify Difference in Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15. 操作17：NVERIFY-属性の違いを確認する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), fattr -&gt; -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct NVERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct NVERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to prefix a sequence of operations to be performed if one or more attributes have changed on some file system object. If all the attributes match, then the error NFS4ERR_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、ファイルシステムオブジェクトの1つ以上の属性が変更された場合に実行される一連の操作の前に付けるために使用されます。すべての属性が一致する場合、エラーNFS4ERR_SAMEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is useful as a cache validation operator. If the object to which the attributes belong has changed, then the following operations may obtain new data associated with that object -- for instance, to check if a file has been changed and obtain new data if it has:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、キャッシュ検証演算子として役立ちます。属性が属するオブジェクトが変更された場合、次の操作は、そのオブジェクトに関連付けられた新しいデータを取得する場合があります。たとえば、ファイルが変更されたかどうかを確認し、変更されている場合は新しいデータを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH (public) LOOKUP &#34;foobar&#34; NVERIFY attrbits attrs READ 0 32767
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH（パブリック）LOOKUP &#34;foobar&#34; NVERIFY attrbits attrs READ 0 32767
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a RECOMMENDED attribute is specified in the NVERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NVERIFY操作でRECOMMENDED属性が指定されていて、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性rdattr_errorまたは書き込み専用属性（time_modify_setなど）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16. Operation 18: OPEN - Open a Regular File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16. 操作18：OPEN-通常のファイルを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, share_access, share_deny, owner, openhow, claim -&gt; (cfh), stateid, cinfo, rflags, attrset, delegation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、seqid、share_access、share_deny、所有者、openhow、クレーム-&gt;（cfh）、stateid、cinfo、rflags、attrset、委任
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various definitions for OPEN
    */
   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           EXCLUSIVE4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            verifier4      createverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum opentype4 {
           OPEN4_NOCREATE  = 0,
           OPEN4_CREATE    = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union openflag4 switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Next definitions used for OPEN delegation */
   enum limit_by4 {
           NFS_LIMIT_SIZE          = 1,
           NFS_LIMIT_BLOCKS        = 2
           /* others as needed */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_modified_limit4 {
           uint32_t        num_blocks;
           uint32_t        bytes_per_block;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_space_limit4 switch (limit_by4 limitby) {
    /* limit specified as file size */
    case NFS_LIMIT_SIZE:
            uint64_t               filesize;
    /* limit specified by number of blocks */
    case NFS_LIMIT_BLOCKS:
            nfs_modified_limit4    mod_blocks;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum open_delegation_type4 {
           OPEN_DELEGATE_NONE      = 0,
           OPEN_DELEGATE_READ      = 1,
           OPEN_DELEGATE_WRITE     = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum open_claim_type4 {
           CLAIM_NULL              = 0,
           CLAIM_PREVIOUS          = 1,
           CLAIM_DELEGATE_CUR      = 2,
           CLAIM_DELEGATE_PREV     = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_claim_delegate_cur4 {
           stateid4        delegate_stateid;
           component4      file;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_claim4 switch (open_claim_type4 claim) {
    /*
     * No special rights to file.
     * Ordinary OPEN of the specified file.
     */
    case CLAIM_NULL:
            /* CURRENT_FH: directory */
            component4      file;
    /*
     * Right to the file established by an
     * open previous to server reboot.  File
     * identified by filehandle obtained at
     * that time rather than by name.
     */
    case CLAIM_PREVIOUS:
            /* CURRENT_FH: file being reclaimed */
            open_delegation_type4   delegate_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to file based on a delegation
     * granted by the server.  File is
     * specified by name.
     */
    case CLAIM_DELEGATE_CUR:
            /* CURRENT_FH: directory */
            open_claim_delegate_cur4        delegate_cur_info;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to file based on a delegation
     * granted to a previous boot instance
     * of the client.  File is specified by name.
     */
    case CLAIM_DELEGATE_PREV:
            /* CURRENT_FH: directory */
            component4      file_delegate_prev;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN: Open a file, potentially receiving an open delegation
    */
   struct OPEN4args {
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
           open_owner4     owner;
           openflag4       openhow;
           open_claim4     claim;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_read_delegation4 {
    stateid4 stateid;    /* Stateid for delegation */
    bool     recall;     /* Pre-recalled flag for
                            delegations obtained
                            by reclaim (CLAIM_PREVIOUS) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfsace4 permissions; /* Defines users who don&#39;t
                            need an ACCESS call to
                            open for read */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_write_delegation4 {
    stateid4 stateid;      /* Stateid for delegation */
    bool     recall;       /* Pre-recalled flag for
                              delegations obtained
                              by reclaim
                              (CLAIM_PREVIOUS) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfs_space_limit4
              space_limit; /* Defines condition that
                              the client must check to
                              determine whether the
                              file needs to be flushed
                              to the server on close */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfsace4   permissions; /* Defines users who don&#39;t
                              need an ACCESS call as
                              part of a delegated
                              open */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_delegation4 switch
      (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Result flags
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Client must confirm open */
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   /* Type of file locking behavior at the server */
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN4resok {
    stateid4       stateid;      /* Stateid for open */
    change_info4   cinfo;        /* Directory change info */
    uint32_t       rflags;       /* Result flags */
    bitmap4        attrset;      /* attribute set for create */
    open_delegation4 delegation; /* Info on any open
                                    delegation */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
            /* CURRENT_FH: opened file */
            OPEN4resok      resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.4. Warning to Client Implementers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.4. クライアント実装者への警告
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN resembles LOOKUP in that it generates a filehandle for the client to use. Unlike LOOKUP, though, OPEN creates server state on the filehandle. In normal circumstances, the client can only release this state with a CLOSE operation. CLOSE uses the current filehandle to determine which file to close. Therefore, the client MUST follow every OPEN operation with a GETFH operation in the same COMPOUND procedure. This will supply the client with the filehandle such that CLOSE can be used appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENは、クライアントが使用するファイルハンドルを生成する点でLOOKUPに似ています。ただし、LOOKUPとは異なり、OPENはファイルハンドルにサーバー状態を作成します。通常の状況では、クライアントはCLOSE操作でのみこの状態を解放できます。 CLOSEは、現在のファイルハンドルを使用して、閉じるファイルを決定します。したがって、クライアントはすべてのOPEN操作の後に、同じCOMPOUNDプロシージャのGETFH操作を実行する必要があります。これにより、クライアントにファイルハンドルが提供され、CLOSEを適切に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のクライアントが同じファイルへの競合するアクセスを試みない限り、サーバーは状態を無期限に維持できるため、ファイルのリースが期限切れになるのを待つだけでは不十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.5. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.5. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation creates and/or opens a regular file in a directory with the provided name. If the file does not exist at the server and creation is desired, specification of the method of creation is provided by the openhow parameter. The client has the choice of three creation methods: UNCHECKED4, GUARDED4, or EXCLUSIVE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作は、指定された名前のディレクトリに通常のファイルを作成またはオープンします。ファイルがサーバーに存在せず、作成が必要な場合は、作成方法の指定がopenhowパラメータによって提供されます。クライアントは、UNCHECKED4、GUARDED4、またはEXCLUSIVE4の3つの作成方法を選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is a named attribute directory, OPEN will then create or open a named attribute file. Note that exclusive create of a named attribute is not supported. If the createmode is EXCLUSIVE4 and the current filehandle is a named attribute directory, the server will return EINVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが名前付き属性ディレクトリである場合、OPENは名前付き属性ファイルを作成または開きます。名前付き属性の排他的な作成はサポートされていないことに注意してください。 createmodeがEXCLUSIVE4で、現在のファイルハンドルが名前付き属性ディレクトリである場合、サーバーはEINVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNCHECKED4 means that the file should be created if a file of that name does not exist and encountering an existing regular file of that name is not an error. For this type of create, createattrs specifies the initial set of attributes for the file. The set of attributes may include any writable attribute valid for regular files. When an UNCHECKED4 create encounters an existing file, the attributes specified by createattrs are not used, except that when a size of zero is specified, the existing file is truncated. If GUARDED4 is specified, the server checks for the presence of a duplicate object by name before performing the create. If a duplicate exists, an error of NFS4ERR_EXIST is returned as the status. If the object does not exist, the request is performed as described for UNCHECKED4. For each of these cases (UNCHECKED4 and GUARDED4), where the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNCHECKED4は、その名前のファイルが存在せず、その名前の既存の通常のファイルに遭遇してもエラーではない場合に、ファイルを作成する必要があることを意味します。このタイプの作成の場合、createattrsはファイルの属性の初期セットを指定します。属性のセットには、通常のファイルに有効な任意の書き込み可能な属性を含めることができます。 UNCHECKED4の作成で既存のファイルが検出されると、createattrsで指定された属性は使用されません。ただし、サイズにゼロを指定した場合、既存のファイルは切り捨てられます。 GUARDED4が指定されている場合、サーバーは、作成を実行する前に、名前で重複オブジェクトの存在を確認します。重複が存在する場合、ステータスとしてNFS4ERR_EXISTのエラーが返されます。オブジェクトが存在しない場合、UNCHECKED4の説明に従って要求が実行されます。これらの各ケース（UNCHECKED4およびGUARDED4）では、操作が成功すると、サーバーはクライアントに属性マスクを返し、オブジェクトにどの属性が正常に設定されたかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE4 specifies that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. The server should check for the presence of a duplicate object by name. If the object does not exist, the server creates the object and stores the verifier with the object. If the object does exist and the stored verifier matches the verifier provided by the client, the server uses the existing object as the newly created object. If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned. No attributes may be provided in this case, since the server may use an attribute of the target object to store the verifier. If the server uses an attribute to store the exclusive create verifier, it will signify which attribute was used by setting the appropriate bit in the attribute mask that is returned in the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE4は、ターゲットの排他的作成を確実にするためにベリファイアを使用して、サーバーが排他的作成セマンティクスに従うことを指定します。サーバーは名前で重複オブジェクトの存在を確認する必要があります。オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、オブジェクトとともにベリファイアを格納します。オブジェクトが存在し、格納されているベリファイアがクライアントから提供されたベリファイアと一致する場合、サーバーは既存のオブジェクトを新しく作成されたオブジェクトとして使用します。保存されたベリファイアが一致しない場合、NFS4ERR_EXISTのエラーが返されます。この場合、サーバーはターゲットオブジェクトの属性を使用してベリファイアを格納できるため、属性を指定できません。サーバーが属性を使用して排他的作成ベリファイアを格納する場合、結果で返される属性マスクに適切なビットを設定することにより、どの属性が使用されたかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリの場合、サーバーはchange_info4情報をcinfoに返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、リンクの作成に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon successful creation, the current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作成が成功すると、現在のファイルハンドルは新しいオブジェクトのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The OPEN operation provides for Windows share reservation capability with the use of the share_access and share_deny fields of the OPEN arguments. The client specifies at OPEN the required share_access and share_deny modes. For clients that do not directly support SHAREs (i.e., UNIX), the expected deny value is DENY_NONE. In the case that there is an existing share reservation that conflicts with the OPEN request, the server returns the error NFS4ERR_SHARE_DENIED. For a complete SHARE request, the client must provide values for the owner and seqid fields for the OPEN argument. For additional discussion of share semantics, see Section 9.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
OPEN操作は、OPEN引数のshare_accessおよびshare_denyフィールドを使用して、Windows共有予約機能を提供します。クライアントは、OPENで必要なshare_accessおよびshare_denyモードを指定します。 SHAREを直接サポートしないクライアント（UNIXなど）の場合、予期される拒否値はDENY_NONEです。 OPEN要求と競合する既存の共有予約がある場合、サーバーはエラーNFS4ERR_SHARE_DENIEDを返します。完全なSHARE要求の場合、クライアントはOPEN引数の所有者およびseqidフィールドに値を提供する必要があります。共有セマンティクスの詳細については、セクション9.9を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the client is recovering state from a server failure, the claim field of the OPEN argument is used to signify that the request is meant to reclaim state previously held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバーの障害から状態を回復している場合、OPEN引数のクレームフィールドは、要求が以前に保持された状態を取り戻すことを意図していることを示すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The claim field of the OPEN argument is used to specify the file to be opened and the state information that the client claims to possess. There are four basic claim types that cover the various situations for an OPEN. They are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN引数のクレームフィールドは、開かれるファイルとクライアントが所有すると主張する状態情報を指定するために使用されます。 OPENのさまざまな状況をカバーする4つの基本的なクレームタイプがあります。それらは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_NULL: For the client, this is a new OPEN request, and there is no previous state associated with the file for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_NULL：クライアントの場合、これは新しいOPEN要求であり、クライアントのファイルに関連付けられた以前の状態はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_PREVIOUS: The client is claiming basic OPEN state for a file that was held previous to a server reboot. This is generally used when a server is returning persistent filehandles; the client may not have the filename to reclaim the OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_PREVIOUS：クライアントは、サーバーの再起動前に保持されていたファイルの基本的なOPEN状態を要求しています。これは通常、サーバーが永続ファイルハンドルを返すときに使用されます。クライアントには、OPENを再利用するためのファイル名がない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_CUR: The client is claiming a delegation for OPEN as granted by the server. This is generally done as part of recalling a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_CUR：クライアントは、サーバーによって許可されたOPENの委任を要求しています。これは通常、委任を呼び戻す一環として行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_PREV: The client is claiming a delegation granted to a previous client instance. This claim type is for use after a SETCLIENTID_CONFIRM and before the corresponding DELEGPURGE in two situations: after a client reboot and after a lease expiration that resulted in loss of all lock state. The server MAY support CLAIM_DELEGATE_PREV. If it does support CLAIM_DELEGATE_PREV, SETCLIENTID_CONFIRM MUST NOT remove the client&#39;s delegation state, and the server MUST support the DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_PREV：クライアントは、以前のクライアントインスタンスに付与された委任を要求しています。この要求の種類は、SETCLIENTID_CONFIRMの後、対応するDELEGPURGEの前に、クライアントの再起動後と、すべてのロック状態が失われるリース期限切れ後の2つの状況で使用されます。サーバーはCLAIM_DELEGATE_PREVをサポートしてもよい（MAY）。 CLAIM_DELEGATE_PREVをサポートする場合、SETCLIENTID_CONFIRMはクライアントの委任状態を削除してはならず（MUST NOT）、サーバーはDELEGPURGE操作をサポートしなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following errors apply to use of the CLAIM_DELEGATE_PREV claim type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のエラーは、CLAIM_DELEGATE_PREVクレームタイプの使用に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4ERR_NOTSUPP is returned if the server does not support this claim type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーがこの要求タイプをサポートしていない場合、NFS4ERR_NOTSUPPが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4ERR_INVAL is returned if the reclaim is done at an inappropriate time, e.g., after DELEGPURGE has been done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4ERR_INVALは、例えばDELEGPURGEが行われた後など、不適切なときに再利用が行われた場合に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4ERR_BAD_RECLAIM is returned if the other error conditions do not apply and the server has no record of the delegation whose reclaim is being attempted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4ERR_BAD_RECLAIM-他のエラー条件が適用されず、サーバーに再利用が試行されている委任の記録がない場合に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For OPEN requests whose claim type is other than CLAIM_PREVIOUS (i.e., requests other than those devoted to reclaiming opens after a server reboot) that reach the server during its grace or lease expiration period, the server returns an error of NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クレームタイプがCLAIM_PREVIOUS以外のOPENリクエスト（つまり、サーバーの再起動後のオープンの再利用に特化したリクエスト以外のリクエスト）が猶予期間またはリースの有効期限中にサーバーに到達すると、サーバーはNFS4ERR_GRACEのエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any OPEN request, the server may return an open delegation, which allows further opens and closes to be handled locally on the client as described in Section 10.4. Note that delegation is up to the server to decide. The client should never assume that delegation will or will not be granted in a particular instance. It should always be prepared for either case. A partial exception is the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed. In this case, delegation will always be granted, although the server may specify an immediate recall in the delegation structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN要求の場合、サーバーはオープン委譲を返す場合があります。これにより、セクション10.4で説明されているように、クライアント上でローカルでさらにオープンとクローズを処理できます。委任は決定するサーバー次第であることに注意してください。クライアントは、特定のインスタンスで委任が許可されるかどうかを決して想定しないでください。どちらの場合も常に準備する必要があります。部分的な例外は、委任タイプが要求される再利用（CLAIM_PREVIOUS）の場合です。この場合、サーバーは委任構造で即時の再呼び出しを指定できますが、委任は常に許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rflags returned by a successful OPEN allow the server to return information governing how the open file is to be handled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが成功すると返されるrflagsにより、サーバーは開いているファイルの処理方法を管理する情報を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_RESULT_CONFIRM indicates that the client MUST execute an OPEN_CONFIRM operation before using the open file. OPEN4_RESULT_LOCKTYPE_POSIX indicates that the server&#39;s file locking behavior supports the complete set of POSIX locking techniques [fcntl]. From this, the client can choose to manage file locking state in such a way as to handle a mismatch of file locking management.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_RESULT_CONFIRMは、クライアントがオープンファイルを使用する前にOPEN_CONFIRM操作を実行する必要があることを示します。 OPEN4_RESULT_LOCKTYPE_POSIXは、サーバーのファイルロック動作がPOSIXロック手法[fcntl]の完全なセットをサポートすることを示します。これにより、クライアントは、ファイルロック管理の不一致を処理するような方法でファイルロック状態を管理することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントの長さがゼロの場合、NFS4ERR_INVALが返されます。このコンポーネントは、通常のUTF-8、文字サポート、および名前のチェックも受けます。詳細については、セクション12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an OPEN is done and the specified open-owner already has the resulting filehandle open, the result is to &#34;OR&#34; together the new share and deny status, together with the existing status. In this case, only a single CLOSE need be done, even though multiple OPENs were completed. When such an OPEN is done, checking of share reservations for the new OPEN proceeds normally, with no exception for the existing OPEN held by the same owner. In this case, the stateid returned has an &#34;other&#34; field that matches that of the previous open, while the seqid field is incremented to reflect the changed status due to the new open (Section 9.1.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが実行され、指定されたopen-ownerが既にファイルハンドルを開いている場合、結果は新しい共有と拒否のステータスを既存のステータスと一緒に「OR」します。この場合、複数のOPENが完了した場合でも、1回のCLOSEで済みます。そのようなOPENが行われると、新しいOPENの共有予約のチェックは、同じ所有者が保持している既存のOPENを例外として、通常どおりに進行します。この場合、返されるstateidには、以前のオープンのフィールドと一致する「other」フィールドがあり、seqidフィールドは、新しいオープンによって変更されたステータスを反映するために増分されます（セクション9.1.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the underlying file system at the server is only accessible in a read-only mode and the OPEN request has specified OPEN4_SHARE_ACCESS_WRITE or OPEN4_SHARE_ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの基礎となるファイルシステムが読み取り専用モードでのみアクセス可能で、OPEN要求がOPEN4_SHARE_ACCESS_WRITEまたはOPEN4_SHARE_ACCESS_BOTHを指定している場合、サーバーはNFS4ERR_ROFSを返し、読み取り専用ファイルシステムを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with the CREATE operation, the server MUST derive the owner, owner ACE, group, or group ACE if any of the four attributes are required and supported by the server&#39;s file system. For an OPEN with the EXCLUSIVE4 createmode, the server has no choice, since such OPEN calls do not include the createattrs field. Conversely, if createattrs is specified and includes owner or group (or corresponding ACEs) that the principal in the RPC&#39;s credentials does not have authorization to create files for, then the server may return NFS4ERR_PERM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE操作と同様に、4つの属性のいずれかが必要であり、サーバーのファイルシステムでサポートされている場合、サーバーは所有者、所有者ACE、グループ、またはグループACEを導出する必要があります。 EXCLUSIVE4 createmodeを使用したOPENの場合、そのようなOPEN呼び出しにはcreateattrsフィールドが含まれていないため、サーバーには選択肢がありません。逆に、createattrsが指定され、RPCの資格情報のプリンシパルがファイルを作成する権限を持っていない所有者またはグループ（または対応するACE）を含む場合、サーバーはNFS4ERR_PERMを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case where an OPEN specifies a size of zero (e.g., truncation) and the file has named attributes, the named attributes are left as is. They are not removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENがゼロのサイズを指定している場合（切り捨てなど）、ファイルに名前付き属性がある場合、名前付き属性はそのままになります。それらは削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.6. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.6. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation contains support for EXCLUSIVE4 create. The mechanism is similar to the support in NFSv3 [RFC1813]. As in NFSv3, this mechanism provides reliable exclusive creation. Exclusive create is invoked when the how parameter is EXCLUSIVE4. In this case, the client provides a verifier that can reasonably be expected to be unique. A combination of a client identifier, perhaps the client network address, and a unique number generated by the client, perhaps the RPC transaction identifier, may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作には、EXCLUSIVE4作成のサポートが含まれています。このメカニズムは、NFSv3 [RFC1813]のサポートに似ています。 NFSv3と同様に、このメカニズムは信頼できる排他的作成を提供します。排他的作成は、howパラメーターがEXCLUSIVE4のときに呼び出されます。この場合、クライアントは、一意であると合理的に期待できるベリファイアを提供します。クライアント識別子（おそらくクライアントのネットワークアドレス）と、クライアントによって生成された一意の番号（おそらくRPCトランザクション識別子）の組み合わせが適切な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object does not exist, the server creates the object and stores the verifier in stable storage. For file systems that do not provide a mechanism for the storage of arbitrary file attributes, the server may use one or more elements of the object metadata to store the verifier. The verifier must be stored in stable storage to prevent erroneous failure on retransmission of the request. It is assumed that an exclusive create is being performed because exclusive semantics are critical to the application. Because of the expected usage, exclusive create does not rely solely on the normally volatile duplicate request cache for storage of the verifier. The duplicate request cache in volatile storage does not survive a crash and may actually flush on a long network partition, opening failure windows. In the UNIX local file system environment, the expected storage location for the verifier on creation is the metadata (timestamps) of the object. For this reason, an exclusive object create may not include initial attributes because the server would have nowhere to store the verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、ベリファイアを安定したストレージに保存します。任意のファイル属性を保存するメカニズムを提供しないファイルシステムの場合、サーバーはオブジェクトメタデータの1つ以上の要素を使用してベリファイアを保存します。ベリファイアは、リクエストの再送信での誤った失敗を防ぐために、安定したストレージに保存する必要があります。排他的なセマンティクスがアプリケーションにとって重要であるため、排他的な作成が実行されていると想定されます。予想される使用法のため、排他的作成は、ベリファイアのストレージを通常揮発性の複製リクエストキャッシュだけに依存するわけではありません。揮発性ストレージの重複したリクエストキャッシュはクラッシュに耐えられず、実際には長いネットワークパーティションでフラッシュされ、失敗ウィンドウが開くことがあります。 UNIXローカルファイルシステム環境では、作成時にベリファイアに予想される格納場所は、オブジェクトのメタデータ（タイムスタンプ）です。このため、サーバーにはベリファイアを格納する場所がないため、排他オブジェクトの作成には初期属性が含まれない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server cannot support these exclusive create semantics, possibly because of the requirement to commit the verifier to stable storage, it should fail the OPEN request with the error NFS4ERR_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがこれらの排他的作成セマンティクスをサポートできない場合、おそらくベリファイアを安定したストレージにコミットする必要があるため、エラーNFS4ERR_NOTSUPPでOPEN要求が失敗するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During an exclusive CREATE request, if the object already exists, the server reconstructs the object&#39;s verifier and compares it with the verifier in the request. If they match, the server treats the request as a success. The request is presumed to be a duplicate of an earlier, successful request for which the reply was lost and that the server duplicate request cache mechanism did not detect. If the verifiers do not match, the request is rejected with the status NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
排他的CREATEリクエスト中に、オブジェクトがすでに存在する場合、サーバーはオブジェクトのベリファイアを再構築し、リクエスト内のベリファイアと比較します。それらが一致する場合、サーバーは要求を成功として扱います。要求は、応答が失われ、サーバーの複製要求キャッシュメカニズムが検出しなかった、以前の成功した要求の複製であると推定されます。ベリファイアが一致しない場合、リクエストはステータスNFS4ERR_EXISTで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client has performed a successful exclusive create, it must issue a SETATTR to set the correct object attributes. Until it does so, it should not rely upon any of the object attributes, since the server implementation may need to overload object metadata to store the verifier. The subsequent SETATTR must not occur in the same COMPOUND request as the OPEN. This separation will guarantee that the exclusive create mechanism will continue to function properly in the face of retransmission of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、排他的作成を正常に実行した後、SETATTRを発行して正しいオブジェクト属性を設定する必要があります。そうするまでは、サーバー実装がベリファイアを格納するためにオブジェクトのメタデータをオーバーロードする必要がある場合があるため、オブジェクトの属性に依存するべきではありません。後続のSETATTRは、OPENと同じCOMPOUND要求で発生してはなりません。この分離により、リクエストの再送信に直面しても、排他的な作成メカニズムが引き続き適切に機能することが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of the GUARDED4 attribute does not provide &#34;exactly-once&#34; semantics. In particular, if a reply is lost and the server does not detect the retransmission of the request, the operation can fail with NFS4ERR_EXIST, even though the create was performed successfully. The client would use this behavior in the case that the application has not requested an exclusive create but has asked to have the file truncated when the file is opened. In the case of the client timing out and retransmitting the create request, the client can use GUARDED4 to prevent a sequence such as create, write, create (retransmitted) from occurring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GUARDED4属性を使用しても、「1回だけ」のセマンティクスは提供されません。特に、応答が失われ、サーバーが要求の再送信を検出しない場合、作成が正常に実行された場合でも、NFS4ERR_EXISTで操作が失敗する可能性があります。クライアントがこの動作を使用するのは、アプリケーションが排他的作成を要求していないが、ファイルを開くときにファイルを切り捨てるように要求した場合です。クライアントがタイムアウトして作成要求を再送信する場合、クライアントはGUARDED4を使用して、作成、書き込み、作成（再送信）などのシーケンスが発生しないようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For share reservations (see Section 9.9), the client must specify a value for share_access that is one of OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH. For share_deny, the client must specify one of OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH. If the client fails to do this, the server must return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約（セクション9.9を参照）の場合、クライアントは、OPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTHのいずれかであるshare_accessの値を指定する必要があります。 share_denyの場合、クライアントはOPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_READ、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTHのいずれかを指定する必要があります。クライアントがこれに失敗した場合、サーバーはNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Based on the share_access value (OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH), the client should check that the requester has the proper access rights to perform the specified operation. This would generally be the results of applying the ACL access rules to the file for the current requester. However, just as with the ACCESS operation, the client should not attempt to second-guess the server&#39;s decisions, as access rights may change and may be subject to server administrative controls outside the ACL framework. If the requester is not authorized to READ or WRITE (depending on the share_access value), the server must return NFS4ERR_ACCESS. Note that since the NFSv4 protocol does not impose any requirement that READs and WRITEs issued for an open file have the same credentials as the OPEN itself, the server still must do appropriate access checking on the READs and WRITEs themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
share_access値（OPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTH）に基づいて、クライアントは、リクエスターが指定された操作を実行するための適切なアクセス権を持っていることを確認する必要があります。これは通常、現在のリクエスターのファイルにACLアクセスルールを適用した結果です。ただし、ACCESS操作と同様に、アクセス権が変更されたり、ACLフレームワークの外部でサーバーの管理制御が行われたりする可能性があるため、クライアントはサーバーの決定を推測することを試みるべきではありません。リクエスターが（share_access値に応じて）READまたはWRITEを許可されていない場合、サーバーはNFS4ERR_ACCESSを返す必要があります。 NFSv4プロトコルは、開いているファイルに対して発行されたREADおよびWRITEがOPEN自体と同じ資格情報を持つ必要がないため、サーバーはREADおよびWRITE自体に対して適切なアクセスチェックを実行する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component provided to OPEN resolves to something other than a regular file (or a named attribute), an error will be returned to the client. If it is a directory, NFS4ERR_ISDIR is returned; otherwise, NFS4ERR_SYMLINK is returned. Note that NFS4ERR_SYMLINK is returned for both symlinks and for special files of other types; NFS4ERR_INVAL would be inappropriate, since the arguments provided by the client were correct, and the client cannot necessarily know at the time it sent the OPEN that the component would resolve to a non-regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENに提供されたコンポーネントが通常のファイル（または名前付き属性）以外のものに解決される場合、エラーがクライアントに返されます。ディレクトリの場合、NFS4ERR_ISDIRが返されます。それ以外の場合は、NFS4ERR_SYMLINKが返されます。 NFS4ERR_SYMLINKは、シンボリックリンクと他のタイプの特殊ファイルの両方に対して返されることに注意してください。 NFS4ERR_INVALは不適切です。これは、クライアントによって提供された引数が正しく、クライアントがOPENを送信したときに、コンポーネントが通常でないファイルに解決することを必ずしも認識できないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not a directory, the error NFS4ERR_NOTDIR will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルがディレクトリでない場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a COMPOUND contains an OPEN that establishes an OPEN_DELEGATE_WRITE delegation, then subsequent GETATTRs normally result in a CB_GETATTR being sent to the client holding the delegation. However, in the case in which the OPEN and GETATTR are part of the same COMPOUND, the server SHOULD understand that the operations are for the same client ID and avoid querying the client, which will not be able to respond. This sequence of OPEN and GETATTR SHOULD be understood to be the retrieval of the size and change attributes at the time of OPEN. Further, as explained in Section 15.2.5, the client should not construct a COMPOUND that mixes operations for different client IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDにOPEN_DELEGATE_WRITE委任を確立するOPENが含まれている場合、後続のGETATTRは通常、委任を保持しているクライアントにCB_GETATTRを送信します。ただし、OPENとGETATTRが同じCOMPOUNDの一部である場合、サーバーは、操作が同じクライアントIDに対するものであることを理解し、応答できないクライアントへのクエリを回避する必要があります（SHOULD）。このOPENとGETATTRのシーケンスは、OPEN時のサイズの取得と属性の変更であると理解してください。さらに、セクション15.2.5で説明されているように、クライアントは、異なるクライアントIDの操作を混合するCOMPOUNDを構築しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17. Operation 19: OPENATTR - Open Named Attribute Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17. 操作19：OPENATTR-名前付き属性ディレクトリを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) createdir -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）createdir-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPENATTR4args {
           /* CURRENT_FH: object */
           bool    createdir;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPENATTR4res {
           /* CURRENT_FH: named attr directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPENATTR operation is used to obtain the filehandle of the named attribute directory associated with the current filehandle. The result of the OPENATTR will be a filehandle to an object of type NF4ATTRDIR. From this filehandle, READDIR and LOOKUP operations can be used to obtain filehandles for the various named attributes associated with the original file system object. Filehandles returned within the named attribute directory will have a type of NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENATTR操作は、現在のファイルハンドルに関連付けられている名前付き属性ディレクトリのファイルハンドルを取得するために使用されます。 OPENATTRの結果は、NF4ATTRDIRタイプのオブジェクトへのファイルハンドルになります。このファイルハンドルから、READDIRおよびLOOKUP操作を使用して、元のファイルシステムオブジェクトに関連付けられたさまざまな名前付き属性のファイルハンドルを取得できます。名前付き属性ディレクトリ内で返されるファイルハンドルは、NF4NAMEDATTRのタイプになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The createdir argument allows the client to signify if a named attribute directory should be created as a result of the OPENATTR operation. Some clients may use the OPENATTR operation with a value of FALSE for createdir to determine if any named attributes exist for the object. If none exist, then NFS4ERR_NOENT will be returned. If createdir has a value of TRUE and no named attribute directory exists, one is created. The creation of a named attribute directory assumes that the server has implemented named attribute support in this fashion and is not required to do so by this definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createdir引数を使用すると、OPENATTR操作の結果として名前付き属性ディレクトリを作成する必要があるかどうかをクライアントが示すことができます。一部のクライアントは、createdirの値がFALSEのOPENATTR操作を使用して、オブジェクトに名前付き属性が存在するかどうかを判断します。存在しない場合は、NFS4ERR_NOENTが返されます。 createdirの値がTRUEで、名前付き属性ディレクトリが存在しない場合は、1つ作成されます。名前付き属性ディレクトリの作成は、サーバーがこの方法で名前付き属性のサポートを実装していることを前提としており、この定義ではそうする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not support named attributes for the current filehandle, an error of NFS4ERR_NOTSUPP will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが現在のファイルハンドルの名前付き属性をサポートしていない場合、NFS4ERR_NOTSUPPのエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18. Operation 20: OPEN_CONFIRM - Confirm Open
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18. 操作20：OPEN_CONFIRM-オープンの確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, stateid -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、seqid、stateid-&gt; stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_CONFIRM4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_CONFIRM4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_CONFIRM4res switch (nfsstat4 status) {
    case NFS4_OK:
            OPEN_CONFIRM4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to confirm the sequence id usage for the first time that an open-owner is used by a client. The stateid returned from the OPEN operation is used as the argument for this operation along with the next sequence id for the open-owner. The sequence id passed to the OPEN_CONFIRM must be 1 (one) greater than the seqid passed to the OPEN operation (Section 9.1.4). If the server receives an unexpected sequence id with respect to the original OPEN, then the server assumes that the client will not confirm the original OPEN and all state associated with the original OPEN is released by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、open-ownerがクライアントによって初めて使用されたときに、シーケンスIDの使用を確認するために使用されます。 OPEN操作から返されたstateidは、open-ownerの次のシーケンスIDとともに、この操作の引数として使用されます。 OPEN_CONFIRMに渡されるシーケンスIDは、OPEN操作に渡されるseqidよりも1大きい必要があります（セクション9.1.4）。サーバーが元のOPENに関して予期しないシーケンスIDを受信した場合、サーバーはクライアントが元のOPENを確認せず、元のOPENに関連付けられたすべての状態がサーバーによって解放されたと見なします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A given client might generate many open_owner4 data structures for a given client ID. The client will periodically either dispose of its open_owner4s or stop using them for indefinite periods of time. The latter situation is why the NFSv4 protocol does not have an explicit operation to exit an open_owner4: such an operation is of no use in that situation. Instead, to avoid unbounded memory use, the server needs to implement a strategy for disposing of open_owner4s that have no current open state for any files and have not been used recently. The time period used to determine when to dispose of open_owner4s is an implementation choice. The time period should certainly be no less than the lease time plus any grace period the server wishes to implement beyond a lease time. The OPEN_CONFIRM operation allows the server to safely dispose of unused open_owner4 data structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
特定のクライアントは、特定のクライアントIDに対して多くのopen_owner4データ構造を生成する場合があります。クライアントは定期的にopen_owner4sを破棄するか、無期限に使用を停止します。後者の状況は、NFSv4プロトコルにopen_owner4を終了する明示的な操作がない理由です。そのような操作は、この状況では役に立ちません。代わりに、無制限のメモリ使用を回避するために、サーバーは、ファイルの現在のオープン状態がなく、最近使用されていないopen_owner4を破棄する戦略を実装する必要があります。 open_owner4sをいつ破棄するかを決定するために使用される期間は、実装の選択です。この期間は、確かにリース時間と、サーバーがリース時間を超えて実装したい猶予期間を足したものでなければなりません。 OPEN_CONFIRM操作により、サーバーは未使用のopen_owner4データ構造を安全に破棄できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a client issues an OPEN operation and the server no longer has a record of the open_owner4, the server needs to ensure that this is a new OPEN and not a replay or retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN操作を発行し、サーバーにopen_owner4のレコードがなくなった場合、サーバーはこれが新しいOPENであり、再生や再送信ではないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers MUST NOT require confirmation on OPENs that grant delegations or are doing reclaim operations. See Section 9.1.11 for details. The server can easily avoid this by noting whether it has disposed of one open_owner4 for the given client ID. If the server does not support delegation, it might simply maintain a single bit that notes whether any open_owner4 (for any client) has been disposed of.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、委任を許可する、または再利用操作を行うOPENの確認を要求してはなりません（MUST NOT）。詳細については、セクション9.1.11を参照してください。サーバーは、指定されたクライアントIDに対して1つのopen_owner4を破棄したかどうかを確認することで、これを簡単に回避できます。サーバーが委任をサポートしていない場合は、open_owner4（任意のクライアント用）が破棄されたかどうかを示す単一のビットを維持するだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server must hold unconfirmed OPEN state until one of three events occurs. First, the client sends an OPEN_CONFIRM request with the appropriate sequence id and stateid within the lease period. In this case, the OPEN state on the server goes to confirmed, and the open_owner4 on the server is fully established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、3つのイベントのいずれかが発生するまで、未確認のOPEN状態を保持する必要があります。最初に、クライアントは適切なシーケンスIDとステートIDを含むOPEN_CONFIRMリクエストをリース期間内に送信します。この場合、サーバーのOPEN状態は確認済みになり、サーバーのopen_owner4は完全に確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Second, the client sends another OPEN request with a sequence id that is incorrect for the open_owner4 (out of sequence). In this case, the server assumes the second OPEN request is valid and the first one is a replay. The server cancels the OPEN state of the first OPEN request, establishes an unconfirmed OPEN state for the second OPEN request, and responds to the second OPEN request with an indication that an OPEN_CONFIRM is needed. The process then repeats itself. While there is a potential for a denial-of-service attack on the client, it is mitigated if the client and server require the use of a security flavor based on Kerberos V5 or some other flavor that uses cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目に、クライアントは、open_owner4に対して正しくないシーケンスID（シーケンス外）を含む別のOPEN要求を送信します。この場合、サーバーは2番目のOPEN要求が有効であり、最初の要求が再生であると想定します。サーバーは、最初のOPEN要求のOPEN状態をキャンセルし、2番目のOPEN要求に対して未確認のOPEN状態を確立し、OPEN_CONFIRMが必要であることを示す2番目のOPEN要求に応答します。その後、プロセスは繰り返されます。クライアントでのサービス拒否攻撃の可能性がありますが、クライアントとサーバーがKerberos V5に基づくセキュリティフレーバーまたは暗号化を使用する他のフレーバーの使用を必要とする場合は軽減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
What if the server is in the unconfirmed OPEN state for a given open_owner4, and it receives an operation on the open_owner4 that has a stateid but the operation is not OPEN, or it is OPEN_CONFIRM but with the wrong stateid? Then, even if the seqid is correct, the server returns NFS4ERR_BAD_STATEID, because the server assumes the operation is a replay: if the server has no established OPEN state, then there is no way, for example, a LOCK operation could be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが特定のopen_owner4に対して未確認のOPEN状態にあり、stateidを持つが操作がOPENではないopen_owner4で操作を受信した場合、または操作がOPEN_CONFIRMであるが間違ったstateidである場合はどうなりますか？次に、seqidが正しい場合でも、サーバーはNFS4ERR_BAD_STATEIDを返します。これは、サーバーが操作を再生であると想定しているためです。サーバーにOPEN状態が確立されていない場合、たとえばLOCK操作が有効であるなどの方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Third, neither of the two aforementioned events occurs for the open_owner4 within the lease period. In this case, the OPEN state is canceled and disposal of the open_owner4 can occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3番目に、前述の2つのイベントのどちらも、リース期間内のopen_owner4では発生しません。この場合、OPEN状態が取り消され、open_owner4が破棄される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19. 操作21：OPEN_DOWNGRADE-オープンファイルアクセスを減らす
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, seqid, access, deny -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid、seqid、access、deny-&gt; stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_DOWNGRADE4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_DOWNGRADE4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_DOWNGRADE4res switch (nfsstat4 status) {
    case NFS4_OK:
            OPEN_DOWNGRADE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to adjust the share_access and share_deny bits for a given open. This is necessary when a given open-owner opens the same file multiple times with different share_access and share_deny flags. In this situation, a close of one of the opens may change the appropriate share_access and share_deny flags to remove bits associated with opens no longer in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、特定のオープンのshare_accessおよびshare_denyビットを調整するために使用されます。これは、特定のopen-ownerが同じファイルを異なるshare_accessフラグとshare_denyフラグで複数回開いたときに必要です。この状況では、オープンの1つを閉じると、適切なshare_accessフラグとshare_denyフラグが変更され、オープンに関連しないビットが削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The share_access and share_deny bits specified in this operation replace the current ones for the specified open file. The share_access and share_deny bits specified must be exactly equal to the union of the share_access and share_deny bits specified for some subset of the OPENs in effect for the current open-owner on the current file. If that constraint is not respected, the error NFS4ERR_INVAL should be returned. Since share_access and share_deny bits are subsets of those already granted, it is not possible for this request to be denied because of conflicting share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作で指定されたshare_accessビットとshare_denyビットは、指定された開いているファイルの現在のビットを置き換えます。指定されたshare_accessビットとshare_denyビットは、現在のファイルの現在のオープン所有者に対して有効なOPENの一部のサブセットに指定されたshare_accessビットとshare_denyビットの和集合と正確に等しくなければなりません。その制約が守られない場合、エラーNFS4ERR_INVALが返されます。 share_accessビットとshare_denyビットはすでに付与されているもののサブセットであるため、共有予約の競合が原因でこの要求が拒否されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the OPEN_DOWNGRADE may change a file to be not-open-for-write and a write byte-range lock might be held, the server may have to reject the OPEN_DOWNGRADE with an NFS4ERR_LOCKS_HELD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN_DOWNGRADEがファイルを書き込み用にオープンしないように変更し、書き込みバイト範囲ロックが保持される可能性があるため、サーバーはNFS4ERR_LOCKS_HELDでOPEN_DOWNGRADEを拒否する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20. Operation 22: PUTFH - Set Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20. 操作22：PUTFH-現在のファイルハンドルの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
filehandle -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ファイルハンドル-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTFH4args {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTFH4res {
           /* CURRENT_FH: */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTFH replaces the current filehandle with the filehandle provided as an argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTFHは、現在のファイルハンドルを引数として提供されたファイルハンドルに置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the security mechanism used by the requester does not meet the requirements of the filehandle provided to this operation, the server MUST return NFS4ERR_WRONGSEC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタが使用するセキュリティメカニズムがこの操作に提供されるファイルハンドルの要件を満たさない場合、サーバーはNFS4ERR_WRONGSECを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 15.2.4.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルの詳細については、セクション15.2.4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTFH is commonly used as the first operator in an NFS request to set the context for operations that follow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTFHは通常、NFS要求の最初のオペレーターとして使用され、その後の操作のコンテキストを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21. Operation 23: PUTPUBFH - Set Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21. 操作23：PUTPUBFH-パブリックファイルハンドルの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTPUBFH4res {
           /* CURRENT_FH: public fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTPUBFH replaces the current filehandle with the filehandle that represents the public filehandle of the server&#39;s namespace. This filehandle may be different from the root filehandle, which may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTPUBFHは、現在のファイルハンドルをサーバーの名前空間のパブリックファイルハンドルを表すファイルハンドルに置き換えます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けられているルートファイルハンドルとは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The public filehandle concept was introduced in [RFC2054], [RFC2055], and [RFC2224]. The intent for NFSv4 is that the public filehandle (represented by the PUTPUBFH operation) be used as a method of providing compatibility with the WebNFS server of NFSv2 and NFSv3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パブリックファイルハンドルの概念は、[RFC2054]、[RFC2055]、および[RFC2224]で導入されました。 NFSv4の目的は、NFSv2およびNFSv3のWebNFSサーバーとの互換性を提供する方法として、（PUTPUBFH操作によって表される）パブリックファイルハンドルを使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The public filehandle and the root filehandle (represented by the PUTROOTFH operation) should be equivalent. If the public and root filehandles are not equivalent, then the public filehandle MUST be a descendant of the root filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パブリックファイルハンドルとルートファイルハンドル（PUTROOTFH操作で表される）は同等である必要があります。パブリックファイルハンドルとルートファイルハンドルが同等でない場合、パブリックファイルハンドルはルートファイルハンドルの子孫である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTPUBFH is used as the first operator in an NFS request to set the context for operations that follow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTPUBFHは、NFS要求の最初の演算子として使用され、それに続く操作のコンテキストを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFSv2 and NFSv3 public filehandle, the client is able to specify whether the pathname provided in the LOOKUP should be evaluated as either an absolute path relative to the server&#39;s root or relative to the public filehandle. [RFC2224] contains further discussion of the functionality. With NFSv4, that type of specification is not directly available in the LOOKUP operation. The reason for this is because the component separators needed to specify absolute versus relative are not allowed in NFSv4. Therefore, the client is responsible for constructing its request such that either PUTROOTFH or PUTPUBFH is used to signify absolute or relative evaluation of an NFS URL, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv2およびNFSv3パブリックファイルハンドルを使用すると、クライアントは、LOOKUPで提供されるパス名を、サーバーのルートからの絶対パスとパブリックファイルハンドルからの絶対パスのどちらとして評価するかを指定できます。 [RFC2224]には、機能の詳細な説明が含まれています。 NFSv4では、LOOKUP操作でそのタイプの仕様を直接使用することはできません。これは、絶対と相対の指定に必要なコンポーネントの区切り文字がNFSv4では許可されていないためです。したがって、クライアントは、PUTROOTFHまたはPUTPUBFHのいずれかを使用して、NFS URLの絶対評価または相対評価をそれぞれ示すように、その要求を作成する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there are warnings mentioned in [RFC2224] with respect to the use of absolute evaluation and the restrictions the server may place on that evaluation with respect to how much of its namespace has been made available. These same warnings apply to NFSv4. It is likely, therefore, that because of server implementation details an NFSv3 absolute public filehandle lookup may behave differently than an NFSv4 absolute resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
絶対評価の使用に関して[RFC2224]で言及されている警告と、サーバーがその名前空間の使用可能量に関してその評価に課す制限に注意してください。これらの同じ警告がNFSv4に適用されます。したがって、サーバーの実装の詳細により、NFSv3の絶対的なパブリックファイルハンドルのルックアップは、NFSv4の絶対的な解決とは異なる動作をする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a form of security negotiation as described in [RFC2755] that uses the public filehandle as a method of employing the Simple and Protected GSS-API Negotiation Mechanism (SNEGO) [RFC4178]. This method is not available with NFSv4, as filehandles are not overloaded with special meaning and therefore do not provide the same framework as NFSv2 and NFSv3. Clients should therefore use the security negotiation mechanisms described in this RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンプルで保護されたGSS-APIネゴシエーションメカニズム（SNEGO）[RFC4178]を使用する方法としてパブリックファイルハンドルを使用する[RFC2755]で説明されている形式のセキュリティネゴシエーションがあります。ファイルハンドルが特別な意味でオーバーロードされないため、NFSv4およびNFSv3と同じフレームワークを提供しないため、このメソッドはNFSv4では使用できません。したがって、クライアントはこのRFCで説明されているセキュリティネゴシエーションメカニズムを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22. Operation 24: PUTROOTFH - Set Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22. 操作24：PUTROOTFH-ルートファイルハンドルの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTROOTFH4res {
           /* CURRENT_FH: root fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTROOTFH replaces the current filehandle with the filehandle that represents the root of the server&#39;s namespace. From this filehandle, a LOOKUP operation can locate any other filehandle on the server. This filehandle may be different from the public filehandle, which may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTROOTFHは、現在のファイルハンドルをサーバーのネームスペースのルートを表すファイルハンドルに置き換えます。このファイルハンドルから、LOOKUP操作はサーバー上の他のファイルハンドルを見つけることができます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けられているパブリックファイルハンドルとは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 15.2.4.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルの詳細については、セクション15.2.4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTROOTFH is commonly used as the first operator in an NFS request to set the context for operations that follow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTROOTFHは通常、NFS要求の最初のオペレーターとして使用され、その後の操作のコンテキストを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23. Operation 25: READ - Read from File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23. 操作25：読み取り-ファイルから読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, offset, count -&gt; eof, data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid、offset、count-&gt; eof、data
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ4resok {
           bool            eof;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READ operation reads data from the regular file identified by the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ操作は、現在のファイルハンドルで識別される通常のファイルからデータを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client provides an offset of where the READ is to start and a count of how many bytes are to be read. An offset of 0 (zero) means to read data starting at the beginning of the file. If the offset is greater than or equal to the size of the file, the status, NFS4_OK, is returned with a data length set to 0 (zero), and eof is set to TRUE. The READ is subject to access permissions checking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、READの開始位置のオフセットと、読み取るバイト数のカウントを提供します。オフセット0（ゼロ）は、ファイルの先頭からデータを読み取ることを意味します。オフセットがファイルのサイズ以上の場合、ステータスNFS4_OKが返され、データ長は0（ゼロ）に設定され、eofはTRUEに設定されます。 READは、アクセス許可チェックの対象です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specifies a count value of 0 (zero), the READ succeeds and returns 0 (zero) bytes of data (subject to access permissions checking). The server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが0（ゼロ）のカウント値を指定した場合、READは成功し、0（ゼロ）バイトのデータを返します（アクセス許可チェックの対象）。サーバーは、クライアントが指定したよりも少ないバイト数を返すことを選択できます。クライアントはこの状態を確認し、状態を適切に処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid value for a READ request represents a value returned from a previous byte-range lock or share reservation request, or the stateid associated with a delegation. The stateid is used by the server to verify that the associated share reservation and any byte-range locks are still valid and to update lease timeouts for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ要求のstateid値は、以前のバイト範囲ロックまたは共有予約要求から返された値、または委任に関連付けられたstateidを表します。サーバーはstateidを使用して、関連付けられた共有予約とバイト範囲ロックがまだ有効であることを確認し、クライアントのリースタイムアウトを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the READ ended at the end-of-file (formally, in a correctly formed READ request, if offset + count is equal to the size of the file), or the READ request extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE; otherwise, it is FALSE. A successful READ of an empty file will always return eof as TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READがファイルの終わりで終了した場合（正式には、正しく形成されたREAD要求で、offset + countがファイルのサイズに等しい場合）、またはREAD要求がファイルのサイズを超えている場合（offset + countがファイルのサイズより大きい場合）、eofはTRUEとして返されます。それ以外の場合はFALSEです。空のファイルの読み取りが成功すると、常にeofがTRUEとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not a regular file, an error will be returned to the client. In the case where the current filehandle represents a directory, NFS4ERR_ISDIR is returned; otherwise, NFS4ERR_INVAL is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが通常のファイルでない場合、エラーがクライアントに返されます。現在のファイルハンドルがディレクトリを表す場合、NFS4ERR_ISDIRが返されます。それ以外の場合は、NFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a READ using the special anonymous stateid, the server MAY allow the READ to be serviced subject to mandatory file locks or the current share_deny modes for the file. For a READ using the special READ bypass stateid, the server MAY allow READ operations to bypass locking checks at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な匿名状態IDを使用するREADの場合、サーバーは、必須のファイルロックまたはファイルの現在のshare_denyモードに従って、READのサービスを許可できます（MAY）。特別なREADバイパス状態IDを使用するREADの場合、サーバーは、READ操作がサーバーでのロックチェックをバイパスすることを許可する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server returns a &#34;short read&#34; (i.e., less data than requested and eof is set to FALSE), the client should send another READ to get the remaining data. A server may return less data than requested under several circumstances. The file may have been truncated by another client or perhaps on the server itself, changing the file size from what the requesting client believes to be the case. This would reduce the actual amount of data available to the client. It is possible that the server reduces the transfer size and so returns a short read result. Server resource exhaustion may also result in a short read.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが「短い読み取り」（つまり、要求されたデータよりも少ないデータでeofがFALSEに設定されている）を返す場合、クライアントは残りのデータを取得するために別のREADを送信する必要があります。サーバーは、いくつかの状況下で要求されたよりも少ないデータを返す場合があります。ファイルが別のクライアントまたはサーバー自体で切り捨てられている可能性があり、要求元のクライアントがそうであると信じているファイルサイズを変更しています。これにより、クライアントが使用できる実際のデータ量が減少します。サーバーが転送サイズを減らし、短い読み取り結果を返す可能性があります。サーバーリソースの枯渇により、読み取り時間が短くなる場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory byte-range locking is in effect for the file, and if the byte range corresponding to the data to be read from the file is WRITE_LT locked by an owner not associated with the stateid, the server will return the NFS4ERR_LOCKED error. The client should try to get the appropriate READ_LT via the LOCK operation before re-attempting the READ. When the READ completes, the client should release the byte-range lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須のバイト範囲ロックがファイルに対して有効であり、ファイルから読み取られるデータに対応するバイト範囲が、stateidに関連付けられていない所有者によってWRITE_LTロックされている場合、サーバーはNFS4ERR_LOCKEDエラーを返します。クライアントは、READを再試行する前に、LOCK操作を介して適切なREAD_LTを取得しようとする必要があります。 READが完了すると、クライアントはLOCKUを介してバイト範囲ロックを解放する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If another client has an OPEN_DELEGATE_WRITE delegation for the file being read, the delegation must be recalled, and the operation cannot proceed until that delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding. Normally, delegations will not be recalled as a result of a READ operation, since the recall will occur as a result of an earlier OPEN. However, since it is possible for a READ to be done with a special stateid, the server needs to check for this case even though the client should have done an OPEN previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のクライアントが、読み取られるファイルに対してOPEN_DELEGATE_WRITE委任を持っている場合、委任を再呼び出しする必要があり、その委任が返されるか取り消されるまで操作を続行できません。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。以前のOPENの結果として再呼び出しが発生するため、通常、READ操作の結果として委任は再呼び出しされません。ただし、READが特別な状態IDで実行される可能性があるため、クライアントが以前にOPENを実行していたとしても、サーバーはこのケースを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24. Operation 26: READDIR - Read Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24. 操作26：READDIR-ディレクトリの読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), cookie, cookieverf, dircount, maxcount, attr_request -&gt;
     cookieverf { cookie, name, attrs }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           verifier4       cookieverf;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct entry4 {
           nfs_cookie4     cookie;
           component4      name;
           fattr4          attrs;
           entry4          *nextentry;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dirlist4 {
           entry4          *entries;
           bool            eof;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READDIR4resok {
           verifier4       cookieverf;
           dirlist4        reply;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READDIR operation retrieves a variable number of entries from a file system directory and for each entry returns attributes that were requested by the client, along with information to allow the client to request additional directory entries in a subsequent READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作は、ファイルシステムディレクトリから可変数のエントリを取得し、各エントリについて、クライアントが要求した属性と、クライアントが後続のREADDIRで追加のディレクトリエントリを要求できるようにするための情報を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of 0 (zero) for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server in a previous READDIR request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数には、READDIRがディレクトリ内のどこから始まるかを表すcookie値が含まれています。 Cookieの値0（ゼロ）は、ディレクトリの先頭から読み取りを開始するために使用されます。後続のREADDIR要求の場合、クライアントは、前のREADDIR要求でサーバーによって提供されたCookie値を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookieverf value should be set to 0 (zero) when the cookie value is 0 (zero) (first directory read). On subsequent requests, it should be a cookieverf as returned by the server. The cookieverf must match that returned by the READDIR in which the cookie was acquired. If the server determines that the cookieverf is no longer valid for the directory, the error NFS4ERR_NOT_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieverf値は、cookie値が0（ゼロ）（最初のディレクトリー読み取り）の場合、0（ゼロ）に設定する必要があります。後続のリクエストでは、サーバーから返されるcookieverfである必要があります。 cookieverfは、Cookieが取得されたREADDIRによって返されるものと一致する必要があります。サーバーがcookieverfがディレクトリに対して無効であると判断した場合、エラーNFS4ERR_NOT_SAMEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dircount portion of the argument is a hint of the maximum number of bytes of directory information that should be returned. This value represents the length of the names of the directory entries and the cookie value for these entries. This length represents the XDR encoding of the data (names and cookies) and not the length in the native format of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数のdircount部分は、返されるディレクトリ情報の最大バイト数のヒントです。この値は、ディレクトリエントリの名前の長さとこれらのエントリのCookie値を表します。この長さは、データ（名前とCookie）のXDRエンコードを表し、サーバーのネイティブ形式の長さではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The maxcount value of the argument is the maximum number of bytes for the result. This maximum size represents all of the data being returned within the READDIR4resok structure and includes the XDR overhead. The server may return less data. If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_TOOSMALL will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数のmaxcount値は、結果の最大バイト数です。この最大サイズは、READDIR4resok構造内で返されるすべてのデータを表し、XDRオーバーヘッドが含まれます。サーバーが返すデータが少なくなる場合があります。サーバーがmaxcount制限内の単一のディレクトリエントリを返すことができない場合、エラーNFS4ERR_TOOSMALLがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, attr_request represents the list of attributes to be returned for each directory entry supplied by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、attr_requestは、サーバーから提供された各ディレクトリエントリに対して返される属性のリストを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On successful return, the server&#39;s response will provide a list of directory entries. Each of these entries contains the name of the directory entry, a cookie value for that entry, and the associated attributes as requested. The &#34;eof&#34; flag has a value of TRUE if there are no more entries in the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常に戻ると、サーバーの応答はディレクトリエントリのリストを提供します。これらの各エントリには、ディレクトリエントリの名前、そのエントリのCookie値、および要求された関連属性が含まれています。 「eof」フラグの値は、ディレクトリにエントリがなくなるとTRUEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The cookie value is only meaningful to the server and is used as a &#34;bookmark&#34; for the directory entry. As mentioned, this cookie is used by the client for subsequent READDIR operations so that it may continue reading a directory. The cookie is similar in concept to a READ offset but should not be interpreted as such by the client. The server SHOULD try to accept cookie values issued with READDIR responses even if the directory has been modified between the READDIR calls but MAY return NFS4ERR_NOT_VALID if this is not possible, as might be the case if the server has rebooted in the interim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
cookie値はサーバーにとってのみ意味があり、ディレクトリエントリの「ブックマーク」として使用されます。前述のように、このCookieは、後続のREADDIR操作でクライアントによって使用されるため、ディレクトリの読み取りを続行できます。 Cookieの概念はREADオフセットと似ていますが、クライアントがそのように解釈するべきではありません。サーバーはREADDIR呼び出しの間にディレクトリが変更されていても、サーバーがREADDIR応答で発行されたCookie値を受け入れようとする必要がありますが、サーバーがその間に再起動した場合など、これが不可能な場合はNFS4ERR_NOT_VALIDを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute &#39;fattr4_rdattr_error&#39;. With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
場合によっては、ディレクトリエントリの属性を取得中に、サーバーでエラーが発生することがあります。 READDIR操作全体のエラーを返す代わりに、サーバーは属性 &#39;fattr4_rdattr_error&#39;を返すことができます。これにより、サーバーはクライアントに障害を通知でき、一時的な障害の可能性があるインスタンスの操作全体を失敗させることはありません。明らかに、このメソッドが適切に機能するには、クライアントがfattr4_rdattr_error属性を要求する必要があります。クライアントが属性を要求しない場合、サーバーはREADDIR操作全体の失敗を返すしかありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some file system environments, the directory entries &#34;.&#34; and &#34;..&#34; have special meaning, and in other environments, they may not. If the server supports these special entries within a directory, they should not be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of 0, 1, and 2 are to be considered reserved. Note that the UNIX client will use these values when combining the server&#39;s response and local representations to enable a fully formed UNIX directory presentation to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のファイルシステム環境では、ディレクトリエントリ「。」と「..」には特別な意味があり、他の環境ではそうでない場合があります。サーバーがディレクトリ内のこれらの特別なエントリをサポートしている場合、それらはREADDIR応答の一部としてクライアントに返されるべきではありません。一部のクライアント環境を有効にするために、0、1、および2のCookie値は予約済みと見なされます。 UNIXクライアントは、サーバーの応答とローカル表現を組み合わせるときにこれらの値を使用して、アプリケーションへの完全に形成されたUNIXディレクトリプレゼンテーションを有効にすることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For READDIR arguments, cookie values of 1 and 2 SHOULD NOT be used, and for READDIR results, cookie values of 0, 1, and 2 MUST NOT be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR引数の場合、Cookie値1および2は使用してはいけません（SHOULD NOT）。READDIRの結果の場合、Cookie値0、1、および2を返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server&#39;s file system directory representations can differ greatly. A client&#39;s programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore, the dircount and maxcount fields are provided to allow the client the ability to provide guidelines to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response. The dircount field provides a hint on the number of entries based solely on the names of the directory entries. Since it is a hint, it may be possible that a dircount value is zero. In this case, the server is free to ignore the dircount value and return directory information based on the specified maxcount value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのファイルシステムのディレクトリ表現は、大きく異なる場合があります。クライアントのプログラミングインターフェイスは、NFSプロトコルにうまく変換できない方法でローカルのオペレーティング環境にバインドされる場合もあります。したがって、dircountおよびmaxcountフィールドは、クライアントがサーバーにガイドラインを提供できるようにするために提供されています。クライアントがREADDIR中の属性収集に積極的である場合、サーバーは、エンコードされた応答を制限する方法を知っています。 dircountフィールドは、ディレクトリエントリの名前のみに基づいて、エントリ数に関するヒントを提供します。これはヒントなので、dircount値がゼロになる可能性があります。この場合、サーバーは自由にdircount値を無視し、指定されたmaxcount値に基づいてディレクトリ情報を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As there is no way for the client to indicate that a cookie value, once received, will not be subsequently used, server implementations should avoid schemes that allocate memory corresponding to a returned cookie. Such allocation can be avoided if the server bases cookie values on a value such as the offset within the directory where the scan is to be resumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したCookieの値が後で使用されないことをクライアントが示す方法がないため、サーバーの実装では、返されたCookieに対応するメモリを割り当てるスキームを回避する必要があります。サーバーがcookie値を、スキャンを再開するディレクトリ内のオフセットなどの値に基づいている場合は、このような割り当てを回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cookies generated by such techniques should be designed to remain valid despite modification of the associated directory. If a server were to invalidate a cookie because of a directory modification, READDIRs of large directories might never finish.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような手法で生成されたCookieは、関連するディレクトリが変更されても有効であるように設計する必要があります。ディレクトリの変更が原因でサーバーがCookieを無効にすると、大きなディレクトリのREADDIRが終了しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a directory is deleted after the client has carried out one or more READDIR operations on the directory, the cookies returned will become invalid; however, the server does not need to be concerned, as the directory filehandle used previously would have become stale and would be reported as such on subsequent READDIR operations. The server would not need to check the cookie verifier in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがディレクトリに対して1つ以上のREADDIR操作を実行した後でディレクトリが削除されると、返されるCookieは無効になります。ただし、以前に使用されていたディレクトリファイルハンドルが古くなり、後続のREADDIR操作でそのように報告されるため、サーバーを考慮する必要はありません。この場合、サーバーはCookie Verifierをチェックする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, certain reorganization operations on a directory (including directory compaction) may invalidate READDIR cookies previously given out. When such a situation occurs, the server should modify the cookie verifier so as to disallow the use of cookies that would otherwise no longer be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、ディレクトリに対する特定の再編成操作（ディレクトリの圧縮を含む）により、以前に提供されたREADDIR Cookieが無効になる場合があります。このような状況が発生した場合、サーバーはCookieベリファイアを変更して、そうでなければ有効でなくなるCookieの使用を禁止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookieverf may be used by the server to help manage cookie values that may become stale. It should be a rare occurrence that a server is unable to continue properly reading a directory with the provided cookie/cookieverf pair. The server should make every effort to avoid this condition since the application at the client may not be able to properly handle this type of failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはcookieverfを使用して、古くなる可能性のあるCookie値の管理を支援します。サーバーが提供されたcookie / cookieverfペアでディレクトリを適切に読み続けることができないのはまれなことです。クライアントのアプリケーションはこのタイプの障害を適切に処理できない可能性があるため、サーバーはこの状態を回避するためにあらゆる努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the cookieverf will also protect the client from using READDIR cookie values that may be stale. For example, if the file system has been migrated, the server may or may not be able to use the same cookie values to service READDIR as the previous server used. With the client providing the cookieverf, the server is able to provide the appropriate response to the client. This prevents the case where the server may accept a cookie value but the underlying directory has changed and the response is invalid from the client&#39;s context of its previous READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieverfを使用すると、古くなっている可能性のあるREADDIR Cookie値を使用してクライアントを保護することもできます。たとえば、ファイルシステムが移行されている場合、サーバーは、以前のサーバーが使用していたものと同じCookie値を使用してREADDIRを処理できる場合とできない場合があります。クライアントがcookieverfを提供すると、サーバーはクライアントに適切な応答を提供できます。これにより、サーバーがCookie値を受け入れることができるが、基になるディレクトリが変更され、クライアントの以前のREADDIRのコンテキストからの応答が無効になるという事態を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since some servers will not be returning &#34;.&#34; and &#34;..&#34; entries as has been done with previous versions of the NFS protocol, the client that requires these entries be present in READDIR responses must fabricate them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーは &#34;。&#34;を返さないため。以前のバージョンのNFSプロトコルで行われていた「..」エントリと同様に、これらのエントリがREADDIR応答に存在する必要があるクライアントは、それらを作成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25. Operation 27: READLINK - Read Symbolic Link
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25. 操作27：READLINK-シンボリックリンクの読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; linktext
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）-&gt; linktext
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: symlink */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READLINK4resok {
           linktext4       link;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK reads the data associated with a symbolic link. The data is a UTF-8 string that is opaque to the server. That is, whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted when created but is simply stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINKは、シンボリックリンクに関連付けられたデータを読み取ります。データは、サーバーに対して不透明なUTF-8文字列です。つまり、NFSクライアントによって作成されたものか、サーバー上でローカルに作成されたものかにかかわらず、シンボリックリンクのデータは作成時に解釈されず、単に格納されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A symbolic link is nominally a pointer to another file. The data is not necessarily interpreted by the server; it is just stored in the file. It is possible for a client implementation to store a pathname that is not meaningful to the server operating system in a symbolic link. A READLINK operation returns the data to the client for interpretation. If different implementations want to share access to symbolic links, then they must agree on the interpretation of the data in the symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンボリックリンクは、名目上は別のファイルへのポインタです。データは必ずしもサーバーによって解釈されるとは限りません。ファイルに保存されるだけです。クライアントの実装が、サーバーのオペレーティングシステムにとって意味のないパス名をシンボリックリンクに格納する可能性があります。 READLINK操作は、解釈のためにデータをクライアントに返します。異なる実装がシンボリックリンクへのアクセスを共有する場合は、シンボリックリンクのデータの解釈に同意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READLINK operation is only allowed on objects of type NF4LNK. The server should return the error NFS4ERR_INVAL if the object is not of type NF4LNK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK操作は、NF4LNKタイプのオブジェクトでのみ許可されます。オブジェクトがNF4LNKタイプでない場合、サーバーはエラーNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26. Operation 28: REMOVE - Remove File System Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26. 操作28：REMOVE-ファイルシステムオブジェクトの削除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), filename -&gt; change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、ファイル名-&gt; change_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           component4      target;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct REMOVE4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union REMOVE4res switch (nfsstat4 status) {
    case NFS4_OK:
            REMOVE4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding file system object, the object may be destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REMOVE操作は、filenameで指定されたディレクトリエントリを現在のファイルハンドルに対応するディレクトリから削除（削除）します。ディレクトリ内のエントリが対応するファイルシステムオブジェクトへの最後の参照であった場合、オブジェクトは破棄される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the directory where the filename was removed, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the removal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル名が削除されたディレクトリの場合、サーバーはcinfoにchange_info4情報を返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、変更に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target is of zero length, NFS4ERR_INVAL will be returned. The target is also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットの長さがゼロの場合、NFS4ERR_INVALが返されます。ターゲットは、通常のUTF-8、文字サポート、および名前のチェックも受けます。詳細については、セクション12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3 required a different operator -- RMDIR -- for directory removal, and REMOVE for non-directory removal. This allowed clients to skip checking the file type when being passed a non-directory delete system call (e.g., unlink() [unlink] in POSIX) to remove a directory, as well as the converse (e.g., a rmdir() on a non-directory), because they knew the server would check the file type. NFSv4 REMOVE can be used to delete any directory entry, independent of its file type. The implementer of an NFSv4 client&#39;s entry points from the unlink() and rmdir() system calls should first check the file type against the types the system call is allowed to remove before issuing a REMOVE. Alternatively, the implementer can produce a COMPOUND call that includes a LOOKUP/VERIFY sequence to verify the file type before a REMOVE operation in the same COMPOUND call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3では、ディレクトリの削除には別の演算子（RMDIR）が必要であり、ディレクトリ以外の削除にはREMOVEが必要でした。これにより、クライアントは、ディレクトリを削除するための非ディレクトリ削除システムコール（たとえば、POSIXのunlink()[unlink]）が渡されたときにファイルタイプのチェックをスキップし、逆に（たとえば、rmdir()非ディレクトリ）、サーバーがファイルタイプをチェックすることを知っていたためです。 NFSv4 REMOVEを使用すると、ファイルタイプに関係なく、任意のディレクトリエントリを削除できます。 unlink()およびrmdir()システムコールからのNFSv4クライアントのエントリポイントの実装者は、REMOVEを発行する前に、システムコールが削除できるタイプに対してファイルタイプを最初にチェックする必要があります。または、実装者は、LOOKUP / VERIFYシーケンスを含むCOMPOUND呼び出しを生成して、同じCOMPOUND呼び出しのREMOVE操作の前にファイルタイプを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The concept of last reference is server specific. However, if the numlinks field in the previous attributes of the object had the value 1, the client should not rely on referring to the object via a filehandle. Likewise, the client should not rely on the resources (disk space, directory entry, and so on) formerly associated with the object becoming immediately available. Thus, if a client needs to be able to continue to access a file after using REMOVE to remove it, the client should take steps to make sure that the file will still be accessible. The usual mechanism used is to RENAME the file from its old name to a new hidden name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の参照の概念はサーバー固有です。ただし、オブジェクトの以前の属性のnumlinksフィールドの値が1の場合、クライアントはファイルハンドルを介してオブジェクトを参照することに依存すべきではありません。同様に、クライアントは、以前オブジェクトに関連付けられていたリソース（ディスク領域、ディレクトリエントリなど）がすぐに利用可能になることに依存してはなりません。したがって、クライアントがREMOVEを使用してファイルを削除した後も引き続きファイルにアクセスできるようにする必要がある場合、クライアントは、ファイルが引き続きアクセス可能であることを確認する手順を実行する必要があります。使用される通常のメカニズムは、ファイルの名前を古い名前から新しい非表示の名前に変更することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server finds that the file is still open when the REMOVE arrives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REMOVEが到着したときにサーバーがファイルがまだ開いていることを検出した場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server SHOULD NOT delete the file&#39;s directory entry if the file was opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれた場合、サーバーはファイルのディレクトリエントリを削除してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the file was not opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, the server SHOULD delete the file&#39;s directory entry. However, until the last CLOSE of the file, the server MAY continue to allow access to the file via its filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれなかった場合、サーバーはファイルのディレクトリエントリを削除する必要があります（SHOULD）。ただし、ファイルの最後のCLOSEまで、サーバーはそのファイルハンドルを介してファイルへのアクセスを許可し続ける場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27. Operation 29: RENAME - Rename Directory Entry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27. 操作29：RENAME-ディレクトリエントリの名前変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh), oldname, (cfh), newname -&gt; source_cinfo, target_cinfo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（sfh）、oldname、（cfh）、newname-&gt; source_cinfo、target_cinfo
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENAME4args {
           /* SAVED_FH: source directory */
           component4      oldname;
           /* CURRENT_FH: target directory */
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENAME4resok {
           change_info4    source_cinfo;
           change_info4    target_cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union RENAME4res switch (nfsstat4 status) {
    case NFS4_OK:
            RENAME4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENAME operation renames the object identified by oldname in the source directory corresponding to the saved filehandle, as set by the SAVEFH operation, to newname in the target directory corresponding to the current filehandle. The operation is required to be atomic to the client. Source and target directories must reside on the same file system on the server. On success, the current filehandle will continue to be the target directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAMEオペレーションは、SAVEFHオペレーションで設定された、保存されたファイルハンドルに対応するソースディレクトリのoldnameで識別されるオブジェクトの名前を、現在のファイルハンドルに対応するターゲットディレクトリのnewnameに変更します。操作はクライアントに対してアトミックである必要があります。ソースディレクトリとターゲットディレクトリは、サーバー上の同じファイルシステムに存在する必要があります。成功した場合、現在のファイルハンドルは引き続きターゲットディレクトリになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target directory already contains an entry with the name newname, the source object must be compatible with the target: either both are non-directories, or both are directories, and the target must be empty. If compatible, the existing target is removed before the rename occurs (see Section 16.26 for client and server actions whenever a target is removed). If they are not compatible or if the target is a directory but not empty, the server will return the error NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリにnewnameという名前のエントリが既に含まれている場合、ソースオブジェクトはターゲットと互換性がある必要があります。両方ともディレクトリではないか、両方ともディレクトリであり、ターゲットは空である必要があります。互換性がある場合、名前が変更される前に既存のターゲットが削除されます（ターゲットが削除されるときのクライアントとサーバーのアクションについては、セクション16.26を参照してください）。互換性がない場合、またはターゲットがディレクトリであるが空ではない場合、サーバーはエラーNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If oldname and newname both refer to the same file (they might be hard links of each other), then RENAME should perform no action and return success.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameとnewnameの両方が同じファイルを参照している場合（お互いのハードリンクである可能性があります）、RENAMEは何も実行せず、成功を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For both directories involved in the RENAME, the server returns change_info4 information. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the rename.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAMEに関係する両方のディレクトリについて、サーバーはchange_info4情報を返します。 change_info4構造体のアトミックフィールドを使用すると、サーバーは、名前変更に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the oldname refers to a named attribute and the saved and current filehandles refer to the named attribute directories of different file system objects, the server will return NFS4ERR_XDEV, just as if the saved and current filehandles represented directories on different file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameが名前付き属性を参照し、保存済みおよび現在のファイルハンドルが異なるファイルシステムオブジェクトの名前付き属性ディレクトリを参照する場合、サーバーは、保存済みおよび現在のファイルハンドルが異なるファイルシステム上のディレクトリを表す場合と同様に、NFS4ERR_XDEVを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the oldname or newname is of zero length, NFS4ERR_INVAL will be returned. The oldname and newname are also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameまたはnewnameの長さがゼロの場合、NFS4ERR_INVALが返されます。 oldnameとnewnameも、通常のUTF-8、文字サポート、および名前チェックの対象です。詳細については、セクション12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENAME operation must be atomic to the client. The statement &#34;source and target directories must reside on the same file system on the server&#34; means that the fsid fields in the attributes for the directories are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAME操作は、クライアントに対してアトミックである必要があります。 「ソースディレクトリとターゲットディレクトリはサーバー上の同じファイルシステムに存在する必要がある」という文は、ディレクトリの属性のfsidフィールドが同じであることを意味します。それらが異なるファイルシステムに存在する場合、エラーNFS4ERR_XDEVが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the value of the fh_expire_type attribute for the object, the filehandle may or may not expire on a RENAME. However, server implementers are strongly encouraged to attempt to keep filehandles from expiring in this fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのfh_expire_type属性の値に基づいて、ファイルハンドルはRENAMEで期限切れになる場合とされない場合があります。ただし、サーバーの実装者は、この方法でファイルハンドルが期限切れにならないようにすることを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On some servers, the filenames &#34;.&#34; and &#34;..&#34; are illegal as either oldname or newname and will result in the error NFS4ERR_BADNAME. In addition, on many servers the case of oldname or newname being an alias for the source directory will be checked for. Such servers will return the error NFS4ERR_INVAL in these cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーでは、ファイル名「。」および「..」はoldnameまたはnewnameとしては不正であり、エラーNFS4ERR_BADNAMEが発生します。さらに、多くのサーバーでは、oldnameまたはnewnameがソースディレクトリのエイリアスであるかどうかがチェックされます。このようなサーバーは、これらの場合にエラーNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If either of the source or target filehandles are not directories, the server will return NFS4ERR_NOTDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースまたはターゲットのファイルハンドルのいずれかがディレクトリでない場合、サーバーはNFS4ERR_NOTDIRを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28. Operation 30: RENEW - Renew a Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28. 操作30：RENEW-リースを更新する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid-&gt;()
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENEW4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENEW4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENEW operation is used by the client to renew leases that it currently holds at a server. In processing the RENEW request, the server renews all leases associated with the client. The associated leases are determined by the clientid provided via the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENEW操作は、クライアントが現在サーバーで保持しているリースを更新するために使用されます。 RENEW要求の処理中に、サーバーはクライアントに関連付けられたすべてのリースを更新します。関連するリースは、SETCLIENTID操作で提供されるクライアントIDによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client holds delegations, it needs to use RENEW to detect when the server has determined that the callback path is down. When the server has made such a determination, only the RENEW operation will renew the lease on delegations. If the server determines the callback path is down, it returns NFS4ERR_CB_PATH_DOWN. Even though it returns NFS4ERR_CB_PATH_DOWN, the server MUST renew the lease on the byte-range locks and share reservations that the client has established on the server. If for some reason the lock and share reservation lease cannot be renewed, then the server MUST return an error other than NFS4ERR_CB_PATH_DOWN, even if the callback path is also down. In the event that the server has conditions such that it could return either NFS4ERR_CB_PATH_DOWN or NFS4ERR_LEASE_MOVED, NFS4ERR_LEASE_MOVED MUST be handled first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが委任を保持している場合、RENEWを使用して、サーバーがコールバックパスがダウンしていると判断したことを検出する必要があります。サーバーがこのような決定を行った場合、RENEW操作のみが委任のリースを更新します。サーバーは、コールバックパスがダウンしていると判断すると、NFS4ERR_CB_PATH_DOWNを返します。 NFS4ERR_CB_PATH_DOWNを返しますが、サーバーはバイト範囲ロックのリースを更新し、クライアントがサーバー上で確立した予約を共有する必要があります。何らかの理由でロックアンドシェア予約リースを更新できない場合、コールバックパスもダウンしている場合でも、サーバーはNFS4ERR_CB_PATH_DOWN以外のエラーを返す必要があります。サーバーがNFS4ERR_CB_PATH_DOWNまたはNFS4ERR_LEASE_MOVEDのいずれかを返す可能性のある状況にある場合、NFS4ERR_LEASE_MOVEDを最初に処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client that issues RENEW MUST choose the principal, RPC security flavor, and, if applicable, GSS-API mechanism and service via one of the following algorithms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENEWを発行するクライアントは、次のアルゴリズムのいずれかを使用して、プリンシパル、RPCセキュリティフレーバー、および該当する場合はGSS-APIメカニズムとサービスを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client uses the same principal, RPC security flavor, and -- if the flavor was RPCSEC_GSS -- the same mechanism and service that were used when the client ID was established via SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは同じプリンシパル、RPCセキュリティフレーバー、およびフレーバーがRPCSEC_GSSの場合は、SETCLIENTID_CONFIRMを介してクライアントIDが確​​立されたときに使用されたのと同じメカニズムとサービスを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client uses any principal, RPC security flavor, mechanism, and service combination that currently has an OPEN file on the server. That is, the same principal had a successful OPEN operation; the file is still open by that principal; and the flavor, mechanism, and service of RENEW match that of the previous OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、現在サーバー上にOPENファイルがあるプリンシパル、RPCセキュリティフレーバー、メカニズム、およびサービスの組み合わせを使用します。つまり、同じプリンシパルがOPEN操作を成功させました。ファイルはそのプリンシパルによってまだ開かれています。また、RENEWのフレーバー、メカニズム、およびサービスは、以前のOPENのものと一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST reject a RENEW that does not use one of the aforementioned algorithms, with the error NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、前述のアルゴリズムのいずれかを使用しないRENEWをエラーNFS4ERR_ACCESSで拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29. Operation 31: RESTOREFH - Restore Saved Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29. 操作31：RESTOREFH-保存されたファイルハンドルの復元
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh) -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（sfh）-&gt;（cfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* SAVED_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RESTOREFH4res {
           /* CURRENT_FH: value of saved fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Set the current filehandle to the value in the saved filehandle. If there is no saved filehandle, then return the error NFS4ERR_RESTOREFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルを保存されたファイルハンドルの値に設定します。保存されたファイルハンドルがない場合は、エラーNFS4ERR_RESTOREFHを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operations like OPEN and LOOKUP use the current filehandle to represent a directory and replace it with a new filehandle. Assuming that the previous filehandle was saved with a SAVEFH operator, the previous filehandle can be restored as the current filehandle. This is commonly used to obtain post-operation attributes for the directory, e.g.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENやLOOKUPなどの操作では、現在のファイルハンドルを使用してディレクトリを表し、それを新しいファイルハンドルで置き換えます。以前のファイルハンドルがSAVEFH演算子で保存されたと仮定すると、以前のファイルハンドルを現在のファイルハンドルとして復元できます。これは通常、ディレクトリの操作後の属性を取得するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH (directory filehandle) SAVEFH GETATTR attrbits (pre-op dir attrs) CREATE optbits &#34;foo&#34; attrs GETATTR attrbits (file attributes) RESTOREFH GETATTR attrbits (post-op dir attrs)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH（ディレクトリファイルハンドル）SAVEFH GETATTR attrbits（pre-op dir attrs）CREATE optbits &#34;foo&#34; attrs GETATTR attrbits（file attributes）RESTOREFH GETATTR attrbits（post-op dir attrs）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30. Operation 32: SAVEFH - Save Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30. 操作32：SAVEFH-現在のファイルハンドルを保存
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; (sfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）-&gt;（sfh）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SAVEFH4res {
           /* SAVED_FH: value of current fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Save the current filehandle. If a previous filehandle was saved, then it is no longer accessible. The saved filehandle can be restored as the current filehandle with the RESTOREFH operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルを保存します。以前のファイルハンドルが保存されている場合は、アクセスできなくなります。保存されたファイルハンドルは、RESTOREFHオペレーターを使用して現在のファイルハンドルとして復元できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31. Operation 33: SECINFO - Obtain Available Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31. 操作33：SECINFO-利用可能なセキュリティを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), name -&gt; { secinfo }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SECINFO4args {
           /* CURRENT_FH: directory */
           component4      name;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * From RFC 2203
    */
   enum rpc_gss_svc_t {
           RPC_GSS_SVC_NONE        = 1,
           RPC_GSS_SVC_INTEGRITY   = 2,
           RPC_GSS_SVC_PRIVACY     = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rpcsec_gss_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* RPCSEC_GSS has a value of &#39;6&#39;.  See RFC 2203 */
   union secinfo4 switch (uint32_t flavor) {
    case RPCSEC_GSS:
            rpcsec_gss_info        flavor_info;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef secinfo4 SECINFO4resok&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
            SECINFO4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO operation is used by the client to obtain a list of valid RPC authentication flavors for a specific directory filehandle, filename pair. SECINFO should apply the same access methodology used for LOOKUP when evaluating the name. Therefore, if the requester does not have the appropriate access to perform a LOOKUP for the name, then SECINFO must behave the same way and return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはSECINFO操作を使用して、特定のディレクトリファイルハンドルとファイル名のペアの有効なRPC認証フレーバーのリストを取得します。 SECINFOは、名前を評価するときにLOOKUPに使用されるものと同じアクセス方法を適用する必要があります。したがって、リクエスターが名前のLOOKUPを実行するための適切なアクセス権を持っていない場合、SECINFOは同じように動作し、NFS4ERR_ACCESSを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result will contain an array that represents the security mechanisms available, with an order corresponding to the server&#39;s preferences, the most preferred being first in the array. The client is free to pick whatever security mechanism it both desires and supports, or to pick -- in the server&#39;s preference order -- the first one it supports. The array entries are represented by the secinfo4 structure. The field &#39;flavor&#39; will contain a value of AUTH_NONE, AUTH_SYS (as defined in [RFC5531]), or RPCSEC_GSS (as defined in [RFC2203]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果には、サーバーの設定に対応する順序で利用可能なセキュリティメカニズムを表す配列が含まれます。最も優先されるのは配列の最初です。クライアントは、希望とサポートの両方のセキュリティメカニズムを自由に選択することも、サーバーの優先順で、サポートする最初のセキュリティメカニズムを自由に選択することもできます。配列エントリは、secinfo4構造によって表されます。フィールド「フレーバー」には、AUTH_NONE、AUTH_SYS（[RFC5531]で定義）、またはRPCSEC_GSS（[RFC2203]で定義）の値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the flavors AUTH_NONE and AUTH_SYS, no additional security information is returned. For a return value of RPCSEC_GSS, a security triple is returned that contains the mechanism object id (as defined in [RFC2743]), the quality of protection (as defined in [RFC2743]), and the service type (as defined in [RFC2203]). It is possible for SECINFO to return multiple entries with flavor equal to RPCSEC_GSS, with different security triple values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_NONEおよびAUTH_SYSフレーバーの場合、追加のセキュリティ情報は返されません。 RPCSEC_GSSの戻り値の場合、メカニズムオブジェクトID（[RFC2743]で定義）、保護品質（[RFC2743]で定義）、およびサービスタイプ（[RFC2203]で定義）を含むセキュリティトリプルが返されます]）。 SECINFOは、RPCSEC_GSSと同じフレーバーで、異なるセキュリティトリプル値を持つ複数のエントリを返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the name has a length of 0 (zero), or if the name does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前の長さが0（ゼロ）である場合、または名前がUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO operation is expected to be used by the NFS client when the error value of NFS4ERR_WRONGSEC is returned from another NFS operation. This signifies to the client that the server&#39;s security policy is different from what the client is currently using. At this point, the client is expected to obtain a list of possible security flavors and choose what best suits its policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO操作は、NFS4ERR_WRONGSECのエラー値が別のNFS操作から返されたときに、NFSクライアントによって使用されることが期待されています。これは、サーバーのセキュリティポリシーがクライアントが現在使用しているものとは異なることをクライアントに示します。この時点で、クライアントは可能なセキュリティフレーバーのリストを取得し、そのポリシーに最適なものを選択することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As mentioned, the server&#39;s security policies will determine when a client request receives NFS4ERR_WRONGSEC. The operations that may receive this error are LINK, LOOKUP, LOOKUPP, OPEN, PUTFH, PUTPUBFH, PUTROOTFH, RENAME, RESTOREFH, and, indirectly, READDIR. LINK and RENAME will only receive this error if the security used for the operation is inappropriate for the saved filehandle. With the exception of READDIR, these operations represent the point at which the client can instantiate a filehandle into the current filehandle at the server. The filehandle is either provided by the client (PUTFH, PUTPUBFH, PUTROOTFH) or generated as a result of a name-to-filehandle translation (LOOKUP and OPEN). RESTOREFH is different because the filehandle is a result of a previous SAVEFH. Even though the filehandle, for RESTOREFH, might have previously passed the server&#39;s inspection for a security match, the server will check it again on RESTOREFH to ensure that the security policy has not changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
前述のように、サーバーのセキュリティポリシーは、クライアント要求がNFS4ERR_WRONGSECを受信するタイミングを決定します。このエラーを受け取る可能性のある操作は、LINK、LOOKUP、LOOKUPP、OPEN、PUTFH、PUTPUBFH、PUTROOTFH、RENAME、RESTOREFH、および間接的にはREADDIRです。 LINKおよびRENAMEは、操作に使用されたセキュリティが保存されたファイルハンドルに対して不適切である場合にのみ、このエラーを受け取ります。 READDIRを除いて、これらの操作は、クライアントがサーバーの現在のファイルハンドルにファイルハンドルをインスタンス化できるポイントを表します。ファイルハンドルは、クライアント（PUTFH、PUTPUBFH、PUTROOTFH）によって提供されるか、名前からファイルハンドルへの変換（LOOKUPおよびOPEN）の結果として生成されます。ファイルハンドルは以前のSAVEFHの結果であるため、RESTOREFHは異なります。 RESTOREFHのファイルハンドルは以前にサーバーのセキュリティ一致の検査に合格した可能性がありますが、サーバーはRESTOREFHでファイルハンドルを再度チェックして、セキュリティポリシーが変更されていないことを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to resolve an error return of NFS4ERR_WRONGSEC, the following will occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_WRONGSECのエラーリターンを解決する場合、次のことが起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LOOKUP and OPEN, the client will use SECINFO with the same current filehandle and name as provided in the original LOOKUP or OPEN to enumerate the available security triples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUPおよびOPENの場合、クライアントは、元のLOOKUPまたはOPENで提供されているものと同じ現在のファイルハンドルおよび名前のSECINFOを使用して、使用可能なセキュリティトリプルを列挙します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LINK, PUTFH, RENAME, and RESTOREFH, the client will use SECINFO and provide the parent directory filehandle and the object name that corresponds to the filehandle originally provided by the PUTFH or RESTOREFH, or, for LINK and RENAME, the SAVEFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LINK、PUTFH、RENAME、およびRESTOREFHの場合、クライアントはSECINFOを使用して、PUTFHまたはRESTOREFH、またはLINKおよびRENAMEの場合はSAVEFHによって最初に提供されたファイルハンドルに対応する親ディレクトリのファイルハンドルとオブジェクト名を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LOOKUPP, PUTROOTFH, and PUTPUBFH, the client will be unable to use the SECINFO operation since SECINFO requires a current filehandle and none exist for these three operations. Therefore, the client must iterate through the security triples available at the client and re-attempt the PUTROOTFH or PUTPUBFH operation. In the unfortunate event that none of the MANDATORY security triples are supported by the client and server, the client SHOULD try using others that support integrity. Failing that, the client can try using AUTH_NONE, but because such forms lack integrity checks, this puts the client at risk. Nonetheless, the server SHOULD allow the client to use whatever security form the client requests and the server supports, since the risks of doing so are on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUPP、PUTROOTFH、およびPUTPUBFHの場合、SECINFOは現在のファイルハンドルを必要とし、これら3つの操作には何も存在しないため、クライアントはSECINFO操作を使用できません。したがって、クライアントは、クライアントで使用可能なセキュリティトリプルを反復処理し、PUTROOTFHまたはPUTPUBFH操作を再試行する必要があります。残念なことに、必須のセキュリティトリプルがクライアントとサーバーでサポートされていない場合、クライアントは整合性をサポートする他のものを使用する必要があります（SHOULD）。これに失敗すると、クライアントはAUTH_NONEの使用を試みることができますが、そのようなフォームには整合性チェックがないため、これによりクライアントが危険にさらされます。それにも関わらず、サーバーのリスクはクライアント側にあるため、サーバーはクライアントがクライアントの要求とサーバーがサポートするセキュリティ形式を使用することを許可する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READDIR operation will not directly return the NFS4ERR_WRONGSEC error. However, if the READDIR request included a request for attributes, it is possible that the READDIR request&#39;s security triple does not match that of a directory entry. If this is the case and the client has requested the rdattr_error attribute, the server will return the NFS4ERR_WRONGSEC error in rdattr_error for the entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作は、NFS4ERR_WRONGSECエラーを直接返しません。ただし、READDIR要求に属性の要求が含まれている場合、READDIR要求のセキュリティトリプルがディレクトリエントリのセキュリティトリプルと一致しない可能性があります。これが当てはまり、クライアントがrdattr_error属性を要求した場合、サーバーはエントリのrdattr_errorでNFS4ERR_WRONGSECエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a server MAY use the AUTH_NONE flavor to signify that the client is allowed to attempt to use authentication flavors that are not explicitly listed in the SECINFO results. Instead of using a listed flavor, the client might then, for instance, opt to use an otherwise unlisted RPCSEC_GSS mechanism instead of AUTH_NONE. It may wish to do so in order to meet an application requirement for data integrity or privacy. In choosing to use an unlisted flavor, the client SHOULD always be prepared to handle a failure by falling back to using AUTH_NONE or another listed flavor. It cannot assume that identity mapping is supported and should be prepared for the fact that its identity is squashed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはAUTH_NONEフレーバーを使用して、クライアントがSECINFO結果に明示的にリストされていない認証フレーバーの使用を試行できることを示す場合があることに注意してください。リストされたフレーバーを使用する代わりに、クライアントは、たとえば、AUTH_NONEの代わりにリストされていないRPCSEC_GSSメカニズムを使用することを選択できます。データの整合性またはプライバシーのアプリケーション要件を満たすために、そうすることを望む場合があります。リストにないフレーバーを使用することを選択する場合、クライアントは、AUTH_NONEまたはリストにある別のフレーバーを使用するようにフォールバックすることで、障害を処理する準備を常に行う必要があります。アイデンティティーマッピングがサポートされているとは想定できず、アイデンティティーが押しつぶされるという事実に備える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 19 for a discussion on the recommendations for security flavors used by SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFOが使用するセキュリティフレーバーの推奨事項については、セクション19を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32. Operation 34: SETATTR - Set Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32. 操作34：SETATTR-属性の設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, attrmask, attr_vals -&gt; attrsset
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid、attrmask、attr_vals-&gt; attrsset
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETATTR4args {
           /* CURRENT_FH: target object */
           stateid4        stateid;
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETATTR4res {
           nfsstat4        status;
           bitmap4         attrsset;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETATTR operation changes one or more of the attributes of a file system object. The new attributes are specified with a bitmap and the attributes that follow the bitmap in bit order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作は、ファイルシステムオブジェクトの1つ以上の属性を変更します。新しい属性は、ビットマップとビットマップのビットオーダーに続く属性で指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid argument for SETATTR is used to provide byte-range locking context that is necessary for SETATTR requests that set the size attribute. Since setting the size attribute modifies the file&#39;s data, it has the same locking requirements as a corresponding WRITE. Any SETATTR that sets the size attribute is incompatible with a share reservation that specifies OPEN4_SHARE_DENY_WRITE. The area between the old end-of-file and the new end-of-file is considered to be modified just as would have been the case had the area in question been specified as the target of WRITE, for the purpose of checking conflicts with byte-range locks, for those cases in which a server is implementing mandatory byte-range locking behavior. A valid stateid SHOULD always be specified. When the file size attribute is not set, the special anonymous stateid MAY be passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRのstateid引数は、サイズ属性を設定するSETATTR要求に必要なバイト範囲のロックコンテキストを提供するために使用されます。 size属性を設定するとファイルのデータが変更されるため、対応するWRITEと同じロック要件があります。サイズ属性を設定するSETATTRは、OPEN4_SHARE_DENY_WRITEを指定する共有予約と互換性がありません。古いファイルの終わりと新しいファイルの終わりの間の領域は、問題の領域がWRITEのターゲットとして指定されている場合と同様に、との競合をチェックするために変更されたと見なされます。バイト範囲ロック（サーバーが必須のバイト範囲ロック動作を実装している場合）。有効な状態IDを常に指定する必要があります（SHOULD）。ファイルサイズ属性が設定されていない場合、特別な匿名のステートIDが渡される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On either success or failure of the operation, the server will return the attrsset bitmask to represent what (if any) attributes were successfully set. The attrsset in the response is a subset of the bitmap4 that is part of the obj_attributes in the argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の成功または失敗のいずれかで、サーバーは、attrssetビットマスクを返し、正常に設定された属性（存在する場合）を表します。応答のattrssetは、引数のobj_attributesの一部であるビットマップ4のサブセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request specifies the owner attribute to be set, the server SHOULD allow the operation to succeed if the current owner of the object matches the value specified in the request. Some servers may be implemented in such a way as to prohibit the setting of the owner attribute unless the requester has the privilege to do so. If the server is lenient in this one case of matching owner values, the client implementation may be simplified in cases of creation of an object (e.g., an exclusive create via OPEN) followed by a SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストが設定される所有者属性を指定する場合、オブジェクトの現在の所有者がリクエストで指定された値と一致する場合、サーバーは操作が成功することを許可する必要があります。一部のサーバーは、リクエスターがそうする特権を持たない限り、所有者属性の設定を禁止するような方法で実装される場合があります。所有者の値が一致するこの1つのケースでサーバーが寛容である場合、オブジェクトの作成（たとえば、OPENによる排他的な作成）の後にSETATTRを実行すると、クライアントの実装が簡略化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file size attribute is used to request changes to the size of a file. A value of zero causes the file to be truncated, a value less than the current size of the file causes data from the new size to the end of the file to be discarded, and a size greater than the current size of the file causes logically zeroed data bytes to be added to the end of the file. Servers are free to implement this using holes or actual zero data bytes. Clients should not make any assumptions regarding a server&#39;s implementation of this feature, beyond that the bytes returned will be zeroed. Servers MUST support extending the file size via SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルサイズ属性は、ファイルサイズの変更を要求するために使用されます。値0はファイルを切り捨て、ファイルの現在のサイズよりも小さい値は新しいサイズからファイルの最後までのデータを破棄し、ファイルの現在のサイズより大きいサイズは論理的にはファイルの最後に追加されるゼロ化されたデータバイト。サーバーは、ホールまたは実際のゼロデータバイトを使用してこれを自由に実装できます。クライアントは、サーバーのこの機能の実装に関して、返されたバイトがゼロになることを前提にしてはなりません。サーバーは、SETATTRによるファイルサイズの拡張をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR is not guaranteed atomic. A failed SETATTR may partially change a file&#39;s attributes -- hence, the reason why the reply always includes the status and the list of attributes that were set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRはアトミックではありません。失敗したSETATTRは、ファイルの属性を部分的に変更する可能性があります。そのため、応答にステータスと設定された属性のリストが常に含まれる理由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object whose attributes are being changed has a file delegation that is held by a client other than the one doing the SETATTR, the delegation(s) must be recalled, and the operation cannot proceed to actually change an attribute until each such delegation is returned or revoked. In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while the delegation(s) remains outstanding, although it might not do that if the delegations are returned quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性が変更されているオブジェクトに、SETATTRを実行しているクライアント以外のクライアントが保持するファイル委任がある場合、委任を再呼び出しする必要があり、そのような各委任が完了するまで、操作は実際に属性を変更できません。返却または取り消されました。委任がリコールされるすべての場合において、サーバーは、委任が未処理のままである間、1つ以上のNFS4ERR_DELAYエラーを返す可能性がありますが、委任が迅速に返された場合はそうはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changing the size of a file with SETATTR indirectly changes the time_modify and change attributes. A client must account for this, as size changes can result in data deletion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRを使用してファイルのサイズを変更すると、time_modifyおよびchange属性が間接的に変更されます。サイズを変更するとデータが削除される可能性があるため、クライアントはこれを考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes time_access_set and time_modify_set are write-only attributes constructed as a switched union so the client can direct the server in setting the time values. If the switched union specifies SET_TO_CLIENT_TIME4, the client has provided an nfstime4 to be used for the operation. If the switch union does not specify SET_TO_CLIENT_TIME4, the server is to use its current time for the SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性time_access_setおよびtime_modify_setは、クライアントがサーバーに時間値の設定を指示できるように、スイッチドユニオンとして構築された書き込み専用属性です。スイッチドユニオンがSET_TO_CLIENT_TIME4を指定している場合、クライアントは操作に使用するnfstime4を提供しています。スイッチユニオンでSET_TO_CLIENT_TIME4が指定されていない場合、サーバーはSETATTR操作に現在の時刻を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If server and client times differ, programs that compare client times to file times can break. A time maintenance protocol should be used to limit client/server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーとクライアントの時間が異なる場合、クライアントの時間とファイルの時間を比較するプログラムが機能しなくなる可能性があります。時間保守プロトコルを使用して、クライアント/サーバーの時間のずれを制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of a COMPOUND containing a VERIFY operation specifying only the change attribute, immediately followed by a SETATTR, provides a means whereby a client may specify a request that emulates the functionality of the SETATTR guard mechanism of NFSv3. Since the function of the guard mechanism is to avoid changes to the file attributes based on stale information, delays between checking of the guard condition and the setting of the attributes have the potential to compromise this function, as would the corresponding delay in the NFSv4 emulation. Therefore, NFSv4 servers should take care to avoid such delays, to the degree possible, when executing such a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性のみを指定し、直後にSETATTRを指定するVERIFY操作を含むCOMPOUNDを使用すると、クライアントがNFSv3のSETATTRガードメカニズムの機能をエミュレートする要求を指定できるようになります。ガードメカニズムの機能は古い情報に基づくファイル属性の変更を回避することであるため、ガード条件のチェックと属性の設定の間の遅延は、NFSv4エミュレーションの対応する遅延と同様に、この機能を危うくする可能性があります。 。したがって、NFSv4サーバーは、このような要求を実行するときに、このような遅延を可能な限り回避するように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not support an attribute as requested by the client, the server should return NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントから要求された属性をサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A mask of the attributes actually set is returned by SETATTR in all cases. That mask MUST NOT include attribute bits not requested to be set by the client. If the attribute masks in the request and reply are equal, the status field in the reply MUST be NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際に設定される属性のマスクは、すべての場合にSETATTRによって返されます。そのマスクには、クライアントによって設定されるように要求されていない属性ビットを含めてはなりません（MUST NOT）。リクエストとリプライの属性マスクが等しい場合、リプライのステータスフィールドはNFS4_OKでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33. Operation 35: SETCLIENTID - Negotiate Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33. 操作35：SETCLIENTID-クライアントIDのネゴシエート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
client, callback, callback_ident -&gt; clientid, setclientid_confirm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
client、callback、callback_ident-&gt; clientid、setclientid_confirm
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID4args {
           nfs_client_id4  client;
           cb_client4      callback;
           uint32_t        callback_ident;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID4resok {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SETCLIENTID4res switch (nfsstat4 status) {
    case NFS4_OK:
            SETCLIENTID4resok      resok4;
    case NFS4ERR_CLID_INUSE:
            clientaddr4    client_using;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client uses the SETCLIENTID operation to notify the server of its intention to use a particular client identifier, callback, and callback_ident for subsequent requests that entail creating lock, share reservation, and delegation state on the server. Upon successful completion the server will return a shorthand client ID that, if confirmed via a separate step, will be used in subsequent file locking and file open requests. Confirmation of the client ID must be done via the SETCLIENTID_CONFIRM operation to return the client ID and setclientid_confirm values, as verifiers, to the server. Two verifiers are necessary because it is possible to use SETCLIENTID and SETCLIENTID_CONFIRM to modify the callback and callback_ident information but not the shorthand client ID. In that event, the setclientid_confirm value is effectively the only verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはSETCLIENTID操作を使用して、サーバー上でのロック、共有予約、および委任状態の作成を伴う後続の要求に対して、特定のクライアント識別子、コールバック、およびcallback_identを使用する意図をサーバーに通知します。正常に完了すると、サーバーは省略形のクライアントIDを返します。別の手順で確認された場合は、後続のファイルロックおよびファイルオープンリクエストで使用されます。クライアントIDの確認は、クライアントIDとsetclientid_confirmの値をベリファイアとしてサーバーに返すために、SETCLIENTID_CONFIRM操作を介して行う必要があります。 SETCLIENTIDとSETCLIENTID_CONFIRMを使用して、コールバックとcallback_identの情報を変更できますが、省略形のクライアントIDは変更できないため、2つの検証が必要です。その場合、事実上、setclientid_confirm値が唯一のベリファイアになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback information provided in this operation will be used if the client is provided an open delegation at a future point. Therefore, the client must correctly reflect the program and port numbers for the callback program at the time SETCLIENTID is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作で提供されるコールバック情報は、将来クライアントにオープンな委任が提供される場合に使用されます。したがって、クライアントは、SETCLIENTIDの使用時に、コールバックプログラムのプログラムとポート番号を正しく反映する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback_ident value is used by the server on the callback. The client can leverage the callback_ident to eliminate the need for more than one callback RPC program number, while still being able to determine which server is initiating the callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
callback_ident値は、サーバーがコールバックで使用します。クライアントは、callback_identを利用して、コールバックを開始しているサーバーを判別しながら、複数のコールバックRPCプログラム番号を不要にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To understand how to implement SETCLIENTID, make the following notations. Let:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDを実装する方法を理解するには、次の表記を行います。みましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
x be the value of the client.id subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
xは、SETCLIENTID4args構造体のclient.idサブフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
v be the value of the client.verifier subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
v SETCLIENTID4args構造のclient.verifierサブフィールドの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c be the value of the client ID field returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cは、SETCLIENTID4resok構造体で返されるクライアントIDフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
k represent the value combination of the callback and callback_ident fields of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kは、SETCLIENTID4args構造体のcallbackおよびcallback_identフィールドの値の組み合わせを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
s be the setclientid_confirm value returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
■SETCLIENTID4resok構造体で返されるsetclientid_confirm値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ v, x, c, k, s } be a quintuple for a client record. A client record is confirmed if there has been a SETCLIENTID_CONFIRM operation to confirm it. Otherwise, it is unconfirmed. An unconfirmed record is established by a SETCLIENTID call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{v、x、c、k、s}は、クライアントレコードの5つ組です。確認のためのSETCLIENTID_CONFIRM操作があった場合、クライアントレコードが確認されます。それ以外の場合は未確認です。未確認のレコードは、SETCLIENTID呼び出しによって確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since SETCLIENTID is a non-idempotent operation, let us assume that the server is implementing the duplicate request cache (DRC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDはべき等ではない操作であるため、サーバーが重複要求キャッシュ（DRC）を実装していると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets a SETCLIENTID { v, x, k } request, it processes it in the following manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがSETCLIENTID {v、x、k}リクエストを受け取ると、次の方法でそれを処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does NOT remove client state (locks, shares, delegations), nor does it modify any recorded callback and callback_ident information for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まずDRCでリクエストを検索します。ヒットがある場合、DRCにキャッシュされた結果を返します。サーバーはクライアントの状態（ロック、共有、委任）を削除せず、クライアント{x}の記録されたコールバックとcallback_ident情報も変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For any DRC miss, the server takes the client ID string x, and searches for client records for x that the server may have recorded from previous SETCLIENTID calls. For any confirmed record with the same id string x, if the recorded principal does not match that of the SETCLIENTID call, then the server returns an NFS4ERR_CLID_INUSE error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DRCミスの場合、サーバーはクライアントID文字列xを取得し、サーバーが以前のSETCLIENTID呼び出しから記録した可能性のあるxのクライアントレコードを検索します。同じID文字列xの確認済みレコードの場合、記録されたプリンシパルがSETCLIENTID呼び出しのプリンシパルと一致しない場合、サーバーはNFS4ERR_CLID_INUSEエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For brevity of discussion, the remaining description of the processing assumes that there was a DRC miss, and that where the server has previously recorded a confirmed record for client x, the aforementioned principal check has successfully passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
説明を簡潔にするため、残りの処理の説明では、DRCミスがあったこと、およびサーバーがクライアントxの確認済みレコードを以前に記録したことがある場合に、前述のプリンシパルチェックが正常に成功したことを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server checks if it has recorded a confirmed record for { v, x, c, l, s }, where l may or may not equal k. If so, and since the id verifier v of the request matches that which is confirmed and recorded, the server treats this as a probable callback information update and records an unconfirmed { v, x, c, k, t } and leaves the confirmed { v, x, c, l, s } in place, such that t != s. It does not matter whether k equals l or not. Any pre-existing unconfirmed { v, x, c, *, * } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、{v、x、c、l、s}の確認済みレコードを記録したかどうかをチェックします。ここで、lはkと等しい場合と等しくない場合があります。その場合、リクエストのIDベリファイアvが確認および記録されたものと一致するため、サーバーはこれをコールバック情報の更新の可能性として扱い、未確認の{v、x、c、k、t}を記録して確認済みの{ v、x、c、l、s}が所定の位置に配置され、t！= s kがlと等しいかどうかは関係ありません。既存の未確認の{v、x、c、*、*}は削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { c, t }. It is indeed returning the old clientid4 value c, because the client apparently only wants to update callback value k to value l. It&#39;s possible this request is one from the Byzantine router that has stale callback information, but this is not a problem. The callback information update is only confirmed if followed up by a SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは{c、t}を返します。実際、クライアントはコールバック値kを値lに更新したいだけなので、古いclientid4値cを返します。このリクエストは、古いコールバック情報を持つビザンチンルーターからのリクエストである可能性がありますが、これは問題ではありません。コールバック情報の更新は、SETCLIENTID_CONFIRM {c、t}が続く場合にのみ確認されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of k via SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、SETCLIENTID_CONFIRM {c、t}によるkの確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのクライアント（ロック/共有/委任）状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and has not recorded any unconfirmed { *, x, *, *, * } record for x. The server records an unconfirmed { v, x, d, k, t } (d != c, t != s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは以前に、確認済みの{u、x、c、l、s}レコードを記録したため、v！= u、lはkに等しい場合と等しくない場合があり、未確認の{*、x、*、*、*は記録していません。 xのレコード。サーバーは未確認の{v、x、d、k、t}（d！= c、t！= s）を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは{d、t}を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、SETCLIENTID_CONFIRM {d、t}による{d、k}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのクライアント（ロック/共有/委任）状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and recorded an unconfirmed { w, x, d, m, t } record such that c != d, t != s, m may or may not equal k, m may or may not equal l, and k may or may not equal l. Whether w == v or w != v makes no difference. The server simply removes the unconfirmed { w, x, d, m, t } record and replaces it with an unconfirmed { v, x, e, k, r } record, such that e != d, e != c, r != t, r != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは以前に、確認済みの{u、x、c、l、s}レコードを記録したため、v！= u、lはkに等しい場合と等しくない場合があり、未確認の{w、x、d、m、t}レコードを記録しましたc！= d、t！= s、mはkと等しくても等しくなくてもよく、mはlと等しくても等しくなくてもよく、kはlと等しくても等しくなくてもかまいません。 w == vでもw！= vでも違いはありません。サーバーは、未確認の{w、x、d、m、t}レコードを削除し、それを未確認の{v、x、e、k、r}レコードに置き換えるだけで、e！= d、e！= c、r ！= t、r！= s。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは{e、r}を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { e, k } via SETCLIENTID_CONFIRM { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、SETCLIENTID_CONFIRM {e、r}による{e、k}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのクライアント（ロック/共有/委任）状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has no confirmed { *, x, *, *, * } for x. It may or may not have recorded an unconfirmed { u, x, c, l, s }, where l may or may not equal k, and u may or may not equal v. Any unconfirmed record { u, x, c, l, * }, regardless of whether u == v or l == k, is replaced with an unconfirmed record { v, x, d, k, t } where d != c, t != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーにはxの確認済み{*、x、*、*、*}がありません。未確認の{u、x、c、l、s}が記録されている場合と記録されていない場合があり、lはkと等しい場合と異なる場合があり、uはvと異なる場合があります。未確認のレコード{u、x、c、l 、*}は、u == vでもl == kでも、未確認のレコード{v、x、d、k、t}に置き換えられます。ここで、d！= c、t！= sです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは{d、t}を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }. The server does NOT remove client (lock/share/ delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、SETCLIENTID_CONFIRM {d、t}による{d、k}の確認を待ちます。サーバーは、xのクライアント（ロック/共有/委任）状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server generates the clientid and setclientid_confirm values and must take care to ensure that these values are extremely unlikely to ever be regenerated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはclientidとsetclientid_confirmの値を生成し、これらの値が再生成される可能性が極めて低いことを確認するように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34. 操作36：SETCLIENTID_CONFIRM-クライアントIDの確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     clientid, setclientid_confirm -&gt; -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID_CONFIRM4args {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID_CONFIRM4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used by the client to confirm the results from a previous call to SETCLIENTID. The client provides the server-supplied (from a SETCLIENTID response) client ID. The server responds with a simple status of success or failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、クライアントが以前のSETCLIENTIDの呼び出しの結果を確認するために使用されます。クライアントは、サーバー提供（SETCLIENTID応答から）のクライアントIDを提供します。サーバーは、成功または失敗の単純なステータスで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client must use the SETCLIENTID_CONFIRM operation to confirm the following two distinct cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、SETCLIENTID_CONFIRM操作を使用して、次の2つの異なるケースを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s use of a new shorthand client identifier (as returned from the server in the response to SETCLIENTID), a new callback value (as specified in the arguments to SETCLIENTID), and a new callback_ident value (as specified in the arguments to SETCLIENTID). The client&#39;s use of SETCLIENTID_CONFIRM in this case also confirms the removal of any of the client&#39;s previous relevant leased state. Relevant leased client state includes byte-range locks, share reservations, and -- where the server does not support the CLAIM_DELEGATE_PREV claim type -- delegations. If the server supports CLAIM_DELEGATE_PREV, then SETCLIENTID_CONFIRM MUST NOT remove delegations for this client; relevant leased client state would then just include byte-range locks and share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントによる新しい省略形クライアント識別子（SETCLIENTIDへの応答でサーバーから返されたもの）、新しいコールバック値（SETCLIENTIDの引数で指定されたもの）、および新しいcallback_ident値（SETCLIENTIDの引数で指定されたもの）の使用。この場合のクライアントのSETCLIENTID_CONFIRMの使用は、クライアントの以前の関連するリース状態の削除も確認します。関連するリースクライアントの状態には、バイト範囲のロック、共有の予約、およびサーバーがCLAIM_DELEGATE_PREVクレームタイプをサポートしていない場合の委任が含まれます。サーバーがCLAIM_DELEGATE_PREVをサポートする場合、SETCLIENTID_CONFIRMはこのクライアントの委任を削除してはなりません（MUST NOT）。関連するリースされたクライアントの状態には、バイト範囲のロックと共有の予約のみが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s reuse of an old, previously confirmed shorthand client identifier; a new callback value; and a new callback_ident value. The client&#39;s use of SETCLIENTID_CONFIRM in this case MUST NOT result in the removal of any previous leased state (locks, share reservations, and delegations).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以前に確認された古い速記クライアント識別子のクライアントの再利用。新しいコールバック値。新しいcallback_ident値。この場合のクライアントのSETCLIENTID_CONFIRMの使用は、以前のリース状態（ロック、共有予約、および委任）を削除してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We use the same notation and definitions for v, x, c, k, s, and unconfirmed and confirmed client records as introduced in the description of the SETCLIENTID operation. The arguments to SETCLIENTID_CONFIRM are indicated by the notation { c, s }, where c is a value of type clientid4, and s is a value of type verifier4 corresponding to the setclientid_confirm field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID操作の説明で紹介したv、x、c、k、s、および未確認および確認済みのクライアントレコードには、同じ表記法と定義を使用します。 SETCLIENTID_CONFIRMへの引数は、表記{c、s}で示されます。ここで、cはclientid4型の値、sはsetclientid_confirmフィールドに対応するverifier4型の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with SETCLIENTID, SETCLIENTID_CONFIRM is a non-idempotent operation, and we assume that the server is implementing the duplicate request cache (DRC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDと同様に、SETCLIENTID_CONFIRMはべき等ではない操作であり、サーバーは重複リクエストキャッシュ（DRC）を実装していると想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets a SETCLIENTID_CONFIRM { c, s } request, it processes it in the following manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがSETCLIENTID_CONFIRM {c、s}リクエストを受け取ると、次の方法で処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does not remove any relevant leased client state, nor does it modify any recorded callback and callback_ident information for client { x } as represented by the shorthand value c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まずDRCでリクエストを検索します。ヒットがある場合、DRCにキャッシュされた結果を返します。サーバーは、関連するリースされたクライアントの状態を削除せず、省略値cで表されるクライアント{x}の記録されたコールバックおよびcallback_ident情報も変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a DRC miss, the server checks for client records that match the shorthand value c. The processing cases are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DRCミスの場合、サーバーは、省略値cに一致するクライアントレコードをチェックします。処理ケースは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has recorded an unconfirmed { v, x, c, k, s } record and a confirmed { v, x, c, l, t } record, such that s != t. If the principals of the records do not match that of the SETCLIENTID_CONFIRM, the server returns NFS4ERR_CLID_INUSE, and no relevant leased client state is removed and no recorded callback and callback_ident information for client { x } is changed. Otherwise, the confirmed { v, x, c, l, t } record is removed and the unconfirmed { v, x, c, k, s } is marked as confirmed, thereby modifying recorded and confirmed callback and callback_ident information for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは未確認の{v、x、c、k、s}レコードと確認済みの{v、x、c、l、t}レコードを記録しました（s！= tなど）。レコードのプリンシパルがSETCLIENTID_CONFIRMのプリンシパルと一致しない場合、サーバーはNFS4ERR_CLID_INUSEを返し、関連するリースされたクライアントの状態は削除されず、クライアント{x}の記録されたコールバックおよびcallback_ident情報は変更されません。それ以外の場合は、確認済みの{v、x、c、l、t}レコードが削除され、未確認の{v、x、c、k、s}が確認済みとしてマークされ、クライアント{xの記録および確認済みのコールバックとcallback_ident情報が変更されます}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does not remove any relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、関連するリースされたクライアントの状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has not recorded an unconfirmed { v, x, c, *, * } and has recorded a confirmed { v, x, c, *, s }. If the principals of the record and of SETCLIENTID_CONFIRM do not match, the server returns NFS4ERR_CLID_INUSE without removing any relevant leased client state, and without changing recorded callback and callback_ident values for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは未確認の{v、x、c、*、*}を記録しておらず、確認済みの{v、x、c、*、s}を記録しています。レコードのプリンシパルとSETCLIENTID_CONFIRMのプリンシパルが一致しない場合、サーバーは関連するリースされたクライアントの状態を削除せずに、クライアント{x}の記録されたコールバックとcallback_identの値を変更せずに、NFS4ERR_CLID_INUSEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the principals match, then what has likely happened is that the client never got the response from the SETCLIENTID_CONFIRM, and the DRC entry has been purged. Whatever the scenario, since the principals match, as well as { c, s } matching a confirmed record, the server leaves client x&#39;s relevant leased client state intact, leaves its callback and callback_ident values unmodified, and returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プリンシパルが一致する場合は、クライアントがSETCLIENTID_CONFIRMから応答を受け取っておらず、DRCエントリがパージされている可能性があります。どのようなシナリオでも、プリンシパルが一致し、{c、s}が確認済みレコードと一致するため、サーバーはクライアントxの関連するリースされたクライアントの状態をそのまま残し、コールバックとcallback_identの値を変更せずに、NFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has not recorded a confirmed { *, *, c, *, * } and has recorded an unconfirmed { *, x, c, k, s }. Even if this is a retry from the client, nonetheless the client&#39;s first SETCLIENTID_CONFIRM attempt was not received by the server. Retry or not, the server doesn&#39;t know, but it processes it as if it were a first try. If the principal of the unconfirmed { *, x, c, k, s } record mismatches that of the SETCLIENTID_CONFIRM request, the server returns NFS4ERR_CLID_INUSE without removing any relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは確認済みの{*、*、c、*、*}を記録しておらず、未確認の{*、x、c、k、s}を記録しています。これがクライアントからの再試行であっても、クライアントの最初のSETCLIENTID_CONFIRM試行はサーバーによって受信されませんでした。再試行するかどうか、サーバーは認識しませんが、最初の試行のように処理します。未確認の{*、x、c、k、s}レコードのプリンシパルがSETCLIENTID_CONFIRMリクエストのプリンシパルと一致しない場合、サーバーは関連するリースクライアントの状態を削除せずにNFS4ERR_CLID_INUSEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Otherwise, the server records a confirmed { *, x, c, k, s }. If there is also a confirmed { *, x, d, *, t }, the server MUST remove client x&#39;s relevant leased client state and overwrite the callback state with k. The confirmed record { *, x, d, *, t } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
それ以外の場合、サーバーは確認済みの{*、x、c、k、s}を記録します。確認済みの{*、x、d、*、t}もある場合、サーバーはクライアントxの関連するリースされたクライアント状態を削除し、コールバック状態をkで上書きする必要があります。確認されたレコード{*、x、d、*、t}が削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has no record of a confirmed or unconfirmed { *, *, c, *, s }. The server returns NFS4ERR_STALE_CLIENTID. The server does not remove any relevant leased client state, nor does it modify any recorded callback and callback_ident information for any client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーには確認済みまたは未確認の{*、*、c、*、s}の記録がありません。サーバーはNFS4ERR_STALE_CLIENTIDを返します。サーバーは、関連するリースされたクライアントの状態を削除したり、クライアントの記録されたコールバックやcallback_ident情報を変更したりしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server needs to cache unconfirmed { v, x, c, k, s } client records and await for some time their confirmation. As should be clear from the discussions of record processing for SETCLIENTID and SETCLIENTID_CONFIRM, there are cases where the server does not deterministically remove unconfirmed client records. To avoid running out of resources, the server is not required to hold unconfirmed records indefinitely. One strategy the server might use is to set a limit on how many unconfirmed client records it will maintain and then, when the limit would be exceeded, remove the oldest record. Another strategy might be to remove an unconfirmed record when some amount of time has elapsed. The choice of the amount of time is fairly arbitrary, but it is surely no higher than the server&#39;s lease time period. Consider that leases need to be renewed before the lease time expires via an operation from the client. If the client cannot issue a SETCLIENTID_CONFIRM after a SETCLIENTID before a period of time equal to a lease expiration time, then the client is unlikely to be able to maintain state on the server during steady-state operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーは未確認の{v、x、c、k、s}クライアントレコードをキャッシュし、しばらくの間それらの確認を待つ必要があります。 SETCLIENTIDおよびSETCLIENTID_CONFIRMのレコード処理の説明から明らかなように、サーバーが未確認のクライアントレコードを確定的に削除しない場合があります。リソースの不足を回避するために、サーバーは未確認のレコードを無期限に保持する必要はありません。サーバーが使用する可能性のある1つの戦略は、サーバーが保持する未確認のクライアントレコードの数に制限を設定し、制限を超える場合は最も古いレコードを削除することです。別の戦略は、一定の時間が経過したときに未確認のレコードを削除することです。時間の選択はかなり恣意的ですが、サーバーのリース期間より長くなることはありません。クライアントからの操作によってリース時間が期限切れになる前に、リースを更新する必要があることを考慮してください。クライアントがSETCLIENTIDの後でリースの有効期限と等しい期間の前にSETCLIENTID_CONFIRMを発行できない場合、クライアントは定常状態の操作中にサーバーの状態を維持できない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client does send a SETCLIENTID_CONFIRM for an unconfirmed record that the server has already deleted, the client will get NFS4ERR_STALE_CLIENTID back. If so, the client should then start over, and send SETCLIENTID to re-establish an unconfirmed client record and get back an unconfirmed client ID and setclientid_confirm verifier. The client should then send the SETCLIENTID_CONFIRM to confirm the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバーがすでに削除した未確認のレコードに対してSETCLIENTID_CONFIRMを送信した場合、クライアントはNFS4ERR_STALE_CLIENTIDを返します。その場合は、クライアントは最初からやり直し、SETCLIENTIDを送信して未確認のクライアントレコードを再確立し、未確認のクライアントIDとsetclientid_confirmベリファイアを取得します。次に、クライアントはSETCLIENTID_CONFIRMを送信してクライアントIDを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID_CONFIRM does not establish or renew a lease. However, if SETCLIENTID_CONFIRM removes relevant leased client state, and that state does not include existing delegations, the server MUST allow the client a period of time no less than the value of the lease_time attribute, to reclaim (via the CLAIM_DELEGATE_PREV claim type of the OPEN operation) its delegations before removing unreclaimed delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID_CONFIRMは、リースを確立または更新しません。ただし、SETCLIENTID_CONFIRMが関連するリースされたクライアント状態を削除し、その状態に既存の委任が含まれていない場合、サーバーは、クライアントがlease_time属性の値以上の期間、（OPENのCLAIM_DELEGATE_PREVクレームタイプを介して）再要求することを許可する必要があります。オペレーション）未回収の委任を削除する前のその委任。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35. Operation 37: VERIFY - Verify Same Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35. 操作37：VERIFY-同じ属性を確認する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), fattr -&gt; -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct VERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct VERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The VERIFY operation is used to verify that attributes have a value assumed by the client before proceeding with subsequent operations in the COMPOUND request. If any of the attributes do not match, then the error NFS4ERR_NOT_SAME must be returned. The current filehandle retains its value after successful completion of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作は、COMPOUND要求の後続の操作に進む前に、属性がクライアントによって想定された値を持っていることを確認するために使用されます。いずれかの属性が一致しない場合は、エラーNFS4ERR_NOT_SAMEを返す必要があります。現在のファイルハンドルは、操作が正常に完了した後もその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible use of the VERIFY operation is the following COMPOUND sequence. With this, the client is attempting to verify that the file being removed will match what the client expects to be removed. This sequence can help prevent the unintended deletion of a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作の1つの可能な使用法は、次のCOMPOUNDシーケンスです。これにより、クライアントは、削除されるファイルが、クライアントが削除することを期待しているものと一致することを確認しようとしています。このシーケンスは、意図しないファイルの削除を防ぐのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH (directory filehandle) LOOKUP (filename) VERIFY (filehandle == fh) PUTFH (directory filehandle) REMOVE (filename)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PUTFH（ディレクトリファイルハンドル）LOOKUP（ファイル名）VERIFY（ファイルハンドル== fh）PUTFH（ディレクトリファイルハンドル）REMOVE（ファイル名）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This sequence does not prevent a second client from removing and creating a new file in the middle of this sequence, but it does help avoid the unintended result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このシーケンスは、2番目のクライアントがこのシーケンスの途中で新しいファイルを削除および作成することを防ぎませんが、意図しない結果を回避するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a RECOMMENDED attribute is specified in the VERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作でRECOMMENDED属性が指定されていて、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性rdattr_errorまたは書き込み専用属性（time_modify_setなど）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36. Operation 38: WRITE - Write to File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36. 操作38：書き込み-ファイルへの書き込み
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, offset, stable, data -&gt; count, committed, writeverf
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（cfh）、stateid、offset、stable、data-&gt; count、commited、writeverf
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           stable_how4     stable;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WRITE operation is used to write data to a regular file. The target file is specified by the current filehandle. The offset specifies the offset where the data should be written. An offset of 0 (zero) specifies that the write should start at the beginning of the file. The count, as encoded as part of the opaque data parameter, represents the number of bytes of data that are to be written. If the count is 0 (zero), the WRITE will succeed and return a count of 0 (zero) subject to permissions checking. The server may choose to write fewer bytes than requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE操作は、通常のファイルにデータを書き込むために使用されます。ターゲットファイルは、現在のファイルハンドルによって指定されます。オフセットは、データが書き込まれるオフセットを指定します。オフセット0（ゼロ）は、ファイルの先頭から書き込みを開始することを指定します。不透明なデータパラメータの一部としてエンコードされたカウントは、書き込まれるデータのバイト数を表します。カウントが0（ゼロ）の場合、WRITEは成功し、権限チェックの対象として0（ゼロ）のカウントを返します。サーバーは、クライアントが要求したよりも少ないバイト数を書き込むことを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Part of the WRITE request is a specification of how the WRITE is to be performed. The client specifies with the stable parameter the method of how the data is to be processed by the server. If stable is FILE_SYNC4, the server must commit the data written plus all file system metadata to stable storage before returning results. This corresponds to the NFSv2 protocol semantics. Any other behavior constitutes a protocol violation. If stable is DATA_SYNC4, then the server must commit all of the data to stable storage and enough of the metadata to retrieve the data before returning. The server implementer is free to implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a possible performance drop. If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage, including all or none, before returning a reply to the client. There is no guarantee whether or when any uncommitted data will subsequently be committed to stable storage. The only guarantees made by the server are that it will not destroy any data without changing the value of verf and that it will not commit the data and metadata at a level less than that requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE要求の一部は、WRITEの実行方法の指定です。クライアントは、stableパラメーターを使用して、サーバーによるデータの処理方法を指定します。 stableがFILE_SYNC4の場合、サーバーは、結果を返す前に、書き込まれたデータとすべてのファイルシステムメタデータを安定したストレージにコミットする必要があります。これは、NFSv2プロトコルのセマンティクスに対応しています。その他の動作はプロトコル違反になります。 stableがDATA_SYNC4の場合、サーバーはすべてのデータを安定したストレージにコミットし、戻る前にデータを取得するのに十分なメタデータをコミットする必要があります。サーバー実装者は、FILE_SYNC4と同じ方法でDATA_SYNC4を自由に実装できますが、パフォーマンスが低下する可能性があります。 stableがUNSTABLE4の場合、サーバーは、クライアントに応答を返す前に、データとメタデータのすべてまたは一部を、すべてまたは何も含めずに、安定したストレージに自由にコミットできます。コミットされていないデータが後で安定したストレージにコミットされるかどうか、またはいつコミットされるかは保証されません。サーバーが行う唯一の保証は、verfの値を変更せずにデータを破壊しないこと、およびクライアントから要求されたレベルよりも低いレベルでデータとメタデータをコミットしないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid value for a WRITE request represents a value returned from a previous byte-range lock or share reservation request or the stateid associated with a delegation. The stateid is used by the server to verify that the associated share reservation and any byte-range locks are still valid and to update lease timeouts for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE要求のstateid値は、以前のバイト範囲ロックまたは共有予約要求から返された値、または委任に関連付けられたstateidを表します。サーバーはstateidを使用して、関連付けられた共有予約とバイト範囲ロックがまだ有効であることを確認し、クライアントのリースタイムアウトを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon successful completion, the following results are returned. The count result is the number of bytes of data written to the file. The server may write fewer bytes than requested. If so, the actual number of bytes written starting at location, offset, is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常に完了すると、次の結果が返されます。カウント結果は、ファイルに書き込まれたデータのバイト数です。サーバーは要求されたよりも少ないバイトを書き込む場合があります。その場合、オフセットで始まる場所に書き込まれた実際のバイト数が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server also returns an indication of the level of commitment of the data and metadata via committed. If the server committed all data and metadata to stable storage, committed should be set to FILE_SYNC4. If the level of commitment was at least as strong as DATA_SYNC4, then committed should be set to DATA_SYNC4. Otherwise, committed must be returned as UNSTABLE4. If stable was FILE4_SYNC, then committed must also be FILE_SYNC4: anything else constitutes a protocol violation. If stable was DATA_SYNC4, then committed may be FILE_SYNC4 or DATA_SYNC4: anything else constitutes a protocol violation. If stable was UNSTABLE4, then committed may be either FILE_SYNC4, DATA_SYNC4, or UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、commitedを介したデータとメタデータのコミットメントのレベルの指標も返します。サーバーがすべてのデータとメタデータを安定したストレージにコミットした場合、committedをFILE_SYNC4に設定する必要があります。コミットメントのレベルが少なくともDATA_SYNC4と同じくらい強い場合は、committedをDATA_SYNC4に設定する必要があります。それ以外の場合、commitedはUNSTABLE4として返される必要があります。 stableがFILE4_SYNCの場合、commitedもFILE_SYNC4でなければなりません。それ以外はプロトコル違反になります。安定がDATA_SYNC4の場合、コミットされるのはFILE_SYNC4またはDATA_SYNC4である可能性があります。それ以外はプロトコル違反を構成します。 stableがUNSTABLE4の場合、commitedはFILE_SYNC4、DATA_SYNC4、またはUNSTABLE4のいずれかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final portion of the result is the write verifier. The write verifier is a cookie that the client can use to determine whether the server has changed instance (boot) state between a call to WRITE and a subsequent call to either WRITE or COMMIT. This cookie must be consistent during a single instance of the NFSv4 protocol service and must be unique between instances of the NFSv4 protocol server, where uncommitted data may be lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の最後の部分は書き込みベリファイアです。書き込みベリファイアは、クライアントがWRITEへの呼び出しとWRITEまたはCOMMITへの後続の呼び出しの間でインスタンス（ブート）状態を変更したかどうかを判断するために使用できるCookieです。このCookieは、NFSv4プロトコルサービスの単一のインスタンスで一貫している必要があり、コミットされていないデータが失われる可能性があるNFSv4プロトコルサーバーのインスタンス間で一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client writes data to the server with the stable argument set to UNSTABLE4 and the reply yields a committed response of DATA_SYNC4 or UNSTABLE4, the client will follow up at some time in the future with a COMMIT operation to synchronize outstanding asynchronous data and metadata with the server&#39;s stable storage, barring client error. It is possible that due to client crash or other error a subsequent COMMIT will not be received by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが安定した引数をUNSTABLE4に設定してサーバーにデータを書き込み、その応答がDATA_SYNC4またはUNSTABLE4のコミットされた応答を生成する場合、クライアントは将来のある時点でCOMMIT操作を追跡し、未処理の非同期データとメタデータを同期します。サーバーの安定したストレージ。クライアントエラーはありません。クライアントのクラッシュまたはその他のエラーが原因で、後続のCOMMITがサーバーで受信されない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a WRITE using the special anonymous stateid, the server MAY allow the WRITE to be serviced subject to mandatory file locks or the current share deny modes for the file. For a WRITE using the special READ bypass stateid, the server MUST NOT allow the WRITE operation to bypass locking checks at the server, and the WRITE is treated exactly the same as if the anonymous stateid were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な匿名状態IDを使用するWRITEの場合、サーバーは、必須のファイルロックまたはファイルの現在の共有拒否モードに従って、WRITEのサービスを許可できます（MAY）。特別なREADバイパス状態IDを使用するWRITEの場合、サーバーはWRITE操作がサーバーでのロックチェックをバイパスすることを許可してはならず（MUST）、WRITEは匿名の状態IDが使用された場合とまったく同じように扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible for the server to write fewer bytes of data than requested by the client. In this case, the server should not return an error unless no data was written at all. If the server writes less than the number of bytes specified, the client should issue another WRITE to write the remaining data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントの要求よりも少ないバイト数のデータを書き込む可能性があります。この場合、データがまったく書き込まれていなければ、サーバーはエラーを返すべきではありません。サーバーが指定したバイト数より少ない数を書き込む場合、クライアントは残りのデータを書き込むために別のWRITEを発行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that the act of writing data to a file will cause the time_modify attribute of the file to be updated. However, the time_modify attribute of the file should not be changed unless the contents of the file are changed. Thus, a WRITE request with count set to 0 should not cause the time_modify attribute of the file to be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データをファイルに書き込む動作により、ファイルのtime_modify属性が更新されることが想定されています。ただし、ファイルの内容が変更されない限り、ファイルのtime_modify属性は変更しないでください。したがって、カウントが0に設定されたWRITE要求によって、ファイルのtime_modify属性が更新されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of stable storage has been historically a point of contention. The following expected properties of stable storage may help in resolving design issues in the implementation. Stable storage is persistent storage that survives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したストレージの定義は、歴史的に論争の的となってきました。安定したストレージの次の予想されるプロパティは、実装における設計問題の解決に役立つ場合があります。安定したストレージは存続する永続的なストレージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Repeated power failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 繰り返し停電。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Hardware failures (of any board, power supply, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ハードウェア障害（ボード、電源装置など）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Repeated software crashes, including reboot cycle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 再起動サイクルを含め、ソフトウェアが繰り返しクラッシュします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This definition does not address failure of the stable storage module itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この定義は、安定したストレージモジュール自体の障害には対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The verifier is defined to allow a client to detect different instances of an NFSv4 protocol server over which cached, uncommitted data may be lost. In the most likely case, the verifier allows the client to detect server reboots. This information is required so that the client can safely determine whether the server could have lost cached data. If the server fails unexpectedly and the client has uncommitted data from previous WRITE requests (done with the stable argument set to UNSTABLE4 and in which the result committed was returned as UNSTABLE4 as well), it may not have flushed cached data to stable storage. The burden of recovery is on the client, and the client will need to retransmit the data to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアは、キャッシュされたコミットされていないデータが失われる可能性があるNFSv4プロトコルサーバーのさまざまなインスタンスをクライアントが検出できるように定義されています。ほとんどの場合、ベリファイアにより、クライアントはサーバーの再起動を検出できます。この情報は、サーバーがキャッシュされたデータを失ったかどうかをクライアントが安全に判断できるようにするために必要です。サーバーが予期せずに失敗し、クライアントが以前のWRITEリクエストからコミットされていないデータを持っている場合（stable引数をUNSTABLE4に設定し、コミットされた結果がUNSTABLE4としても返された場合）、キャッシュされたデータが安定したストレージにフラッシュされていない可能性があります。リカバリの負担はクライアントにあり、クライアントはサーバーにデータを再送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One suggested way to use the verifier would be to use the time that the server was booted or the time the server was last started (if restarting the server without a reboot results in lost buffers).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアを使用する1つの推奨される方法は、サーバーが起動された時刻またはサーバーが最後に起動された時刻を使用することです（再起動せずにサーバーを再起動するとバッファーが失われる場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The committed field in the results allows the client to do more effective caching. If the server is committing all WRITE requests to stable storage, then it should return with committed set to FILE_SYNC4, regardless of the value of the stable field in the arguments. A server that uses an NVRAM accelerator may choose to implement this policy. The client can use this to increase the effectiveness of the cache by discarding cached data that has already been committed on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の認定フィールドにより、クライアントはより効果的なキャッシュを実行できます。サーバーがすべてのWRITE要求を安定したストレージにコミットしている場合、引数のstableフィールドの値に関係なく、committedをFILE_SYNC4に設定して戻る必要があります。 NVRAMアクセラレータを使用するサーバーは、このポリシーの実装を選択できます。クライアントはこれを使用して、サーバーで既にコミットされているキャッシュデータを破棄することで、キャッシュの効果を高めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some implementations may return NFS4ERR_NOSPC instead of NFS4ERR_DQUOT when a user&#39;s quota is exceeded. In the case that the current filehandle is a directory, the server will return NFS4ERR_ISDIR. If the current filehandle is not a regular file or a directory, the server will return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の実装では、ユーザーのクォータを超えると、NFS4ERR_DQUOTではなくNFS4ERR_NOSPCが返される場合があります。現在のファイルハンドルがディレクトリの場合、サーバーはNFS4ERR_ISDIRを返します。現在のファイルハンドルが通常のファイルまたはディレクトリでない場合、サーバーはNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory file locking is on for the file, and a corresponding record of the data to be written to file is read or write locked by an owner that is not associated with the stateid, the server will return NFS4ERR_LOCKED. If so, the client must check if the owner corresponding to the stateid used with the WRITE operation has a conflicting read lock that overlaps with the region that was to be written. If the stateid&#39;s owner has no conflicting read lock, then the client should try to get the appropriate write byte-range lock via the LOCK operation before re-attempting the WRITE. When the WRITE completes, the client should release the byte-range lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルの必須ファイルロックがオンになっていて、ファイルに書き込まれるデータの対応するレコードが、stateidに関連付けられていない所有者によって読み取りまたは書き込みロックされている場合、サーバーはNFS4ERR_LOCKEDを返します。その場合、クライアントは、WRITE操作で使用された状態IDに対応する所有者が、書き込まれる予定の領域と重複する競合する読み取りロックを持っているかどうかを確認する必要があります。状態IDの所有者に競合する読み取りロックがない場合、クライアントはWRITEを再試行する前に、LOCK操作を介して適切な書き込みバイト範囲ロックを取得しようとする必要があります。 WRITEが完了すると、クライアントはLOCKUを介してバイト範囲ロックを解放する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the stateid&#39;s owner had a conflicting read lock, then the client has no choice but to return an error to the application that attempted the WRITE. The reason is that since the stateid&#39;s owner had a read lock, the server either (1) attempted to temporarily effectively upgrade this read lock to a write lock or (2) has no upgrade capability. If the server attempted to upgrade the read lock and failed, it is pointless for the client to re-attempt the upgrade via the LOCK operation, because there might be another client also trying to upgrade. If two clients are blocked trying to upgrade the same lock, the clients deadlock. If the server has no upgrade capability, then it is pointless to try a LOCK operation to upgrade.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態IDの所有者が競合する読み取りロックを持っていた場合、クライアントは書き込みを試みたアプリケーションにエラーを返す以外に選択肢はありません。その理由は、stateidの所有者が読み取りロックを持っていたため、サーバーが（1）この読み取りロックを一時的に効果的に書き込みロックにアップグレードしようとしたか、（2）アップグレード機能がないためです。サーバーが読み取りロックをアップグレードしようとして失敗した場合、別のクライアントもアップグレードを試みている可能性があるため、クライアントがLOCK操作を介してアップグレードを再試行しても意味がありません。 2つのクライアントが同じロックをアップグレードしようとしてブロックされた場合、クライアントはデッドロックします。サーバーにアップグレード機能がない場合は、LOCK操作を実行してアップグレードしても意味がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37. Operation 39: RELEASE_LOCKOWNER - Release Lock-Owner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37. 操作39：RELEASE_LOCKOWNER-ロック所有者状態の解放
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
lock-owner -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ロック所有者-&gt;()
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RELEASE_LOCKOWNER4args {
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RELEASE_LOCKOWNER4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to notify the server that the lock_owner is no longer in use by the client and that future client requests will not reference this lock_owner. This allows the server to release cached state related to the specified lock_owner. If file locks associated with the lock_owner are held at the server, the error NFS4ERR_LOCKS_HELD will be returned and no further action will be taken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、lock_ownerがクライアントによって使用されなくなったこと、および将来のクライアント要求がこのlock_ownerを参照しないことをサーバーに通知するために使用されます。これにより、サーバーは指定されたlock_ownerに関連するキャッシュされた状態を解放できます。 lock_ownerに関連付けられたファイルロックがサーバーで保持されている場合、エラーNFS4ERR_LOCKS_HELDが返され、それ以上のアクションは行われません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client may choose to use this operation to ease the amount of server state that is held. Information that can be released when a RELEASE_LOCKOWNER is done includes the specified lock-owner string, the seqid associated with the lock-owner, any saved reply for the lock-owner, and any lock stateids associated with that lock-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、この操作を使用して、保持されるサーバー状態の量を軽減することを選択できます。 RELEASE_LOCKOWNERの実行時に解放できる情報には、指定されたロック所有者文字列、ロック所有者に関連付けられたseqid、ロック所有者に対する保存された応答、およびそのロック所有者に関連付けられたロック状態IDが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the behavior of applications at the client, it may be important for the client to use this operation since the server has certain obligations with respect to holding a reference to lock-owner-associated state as long as an associated file is open. Therefore, if the client knows for certain that the lock_owner will no longer be used to either reference existing lock stateids associated with the lock-owner or create new ones, it should use RELEASE_LOCKOWNER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントでのアプリケーションの動作によっては、関連ファイルが開いている限り、サーバーがロック所有者関連状態への参照を保持することに関して特定の義務を負うため、クライアントがこの操作を使用することが重要になる場合があります。したがって、lock_ownerを使用して、lock-ownerに関連付けられた既存のロックステートIDを参照したり、新しいロックステートIDを作成したりしないことがクライアントに確実にわかっている場合は、RELEASE_LOCKOWNERを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38. Operation 10044: ILLEGAL - Illegal Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38. 操作10044：違法-違法操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;null&gt; -&gt; ()
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See Section 15.2.4 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、サポートされていないCOMPOUND内の操作コードを送信するクライアントのケースを処理する結果をエンコードするためのプレースホルダーです。詳細は項15.2.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client will probably not send an operation with code OP_ILLEGAL, but if it does, the response will be ILLEGAL4res, just as it would be with any other invalid operation code. Note that if the server gets an illegal operation code that is not OP_ILLEGAL, and if the server checks for legal operation codes during the XDR decode phase, then the ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはおそらくコードOP_ILLEGALの操作を送信しませんが、送信すると、他の無効な操作コードの場合と同様に、応答はILLEGAL4resになります。サーバーがOP_ILLEGAL以外の不正な操作コードを取得した場合、およびサーバーがXDRデコードフェーズ中に有効な操作コードをチェックした場合、ILLEGAL4resは返されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. NFSv4 Callback Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. NFSv4コールバック手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures used for callbacks are defined in the following sections. In the interest of clarity, the terms &#34;client&#34; and &#34;server&#34; refer to NFS clients and servers, despite the fact that for an individual callback RPC, the sense of these terms would be precisely the opposite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックに使用される手順は、次のセクションで定義されています。明確にするために、「クライアント」と「サーバー」という用語はNFSのクライアントとサーバーを指しますが、個々のコールバックRPCの場合、これらの用語の意味はまったく逆になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. Procedure 0: CB_NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. 手順0：CB_NULL-操作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standard NULL procedure. Void argument, void response. Even though there is no direct functionality associated with this procedure, the server will use CB_NULL to confirm the existence of a path for RPCs from server to client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準のNULLプロシージャ。無効な引数、無効な応答。この手順に直接関連する機能はありませんが、サーバーはCB_NULLを使用して、サーバーからクライアントへのRPCのパスの存在を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. Procedure 1: CB_COMPOUND - COMPOUND Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. 手順1：CB_COMPOUND-COMPOUND操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
compoundargs -&gt; compoundres
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
複合引数-&gt;複合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum nfs_cb_opnum4 {
           OP_CB_GETATTR           = 3,
           OP_CB_RECALL            = 4,
           OP_CB_ILLEGAL           = 10044
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_argop4 switch (unsigned argop) {
    case OP_CB_GETATTR:
         CB_GETATTR4args           opcbgetattr;
    case OP_CB_RECALL:
         CB_RECALL4args            opcbrecall;
    case OP_CB_ILLEGAL:            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           uint32_t        callback_ident;
           nfs_cb_argop4   argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_resop4 switch (unsigned resop) {
    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4res {
           nfsstat4        status;
           utf8str_cs      tag;
           nfs_cb_resop4   resarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャは、1つ以上のコールバックプロシージャを1つのRPC要求に結合するために使用されます。メインコールバックRPCプログラムには、CB_NULLとCB_COMPOUNDの2つのメインプロシージャがあります。他のすべての操作は、ラッパーとしてCB_COMPOUNDプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the processing of the CB_COMPOUND procedure, the client may find that it does not have the available resources to execute any or all of the operations within the CB_COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the CB_COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the CB_COMPOUND sequence have been evaluated successfully.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャの処理中に、クライアントは、CB_COMPOUNDシーケンス内の操作の一部またはすべてを実行するために使用できるリソースがないことに気付く場合があります。この場合、リソースの枯渇が発生したCB_COMPOUNDプロシージャ内の特定の操作に対して、エラーNFS4ERR_RESOURCEが返されます。これは、CB_COMPOUNDシーケンス内の以前のすべての操作が正常に評価されていることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contained within the CB_COMPOUND results is a status field. This status must be equivalent to the status of the last operation that was executed within the CB_COMPOUND procedure. Therefore, if an operation incurred an error, then the status value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDの結果には、ステータスフィールドが含まれています。このステータスは、CB_COMPOUNDプロシージャ内で実行された最後の操作のステータスと同等である必要があります。したがって、操作でエラーが発生した場合、ステータス値は、失敗した操作で返されるエラー値と同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the definition of the tag field, see Section 15.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タグフィールドの定義については、セクション15.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of callback_ident is supplied by the client during SETCLIENTID. The server must use the client-supplied callback_ident during the CB_COMPOUND to allow the client to properly identify the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
callback_identの値は、SETCLIENTID中にクライアントによって提供されます。サーバーは、クライアントがサーバーを適切に識別できるように、CB_COMPOUND中にクライアント提供のcallback_identを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Illegal operation codes are handled in the same way as they are handled for the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不正な操作コードは、COMPOUNDプロシージャで処理されるのと同じ方法で処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine individual operations into a single RPC request. The client interprets each of the operations in turn. If an operation is executed by the client and the status of that operation is NFS4_OK, then the next operation in the CB_COMPOUND procedure is executed. The client continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャは、個々の操作を1つのRPC要求に結合するために使用されます。クライアントは各操作を順番に解釈します。操作がクライアントによって実行され、その操作のステータスがNFS4_OKの場合、CB_COMPOUNDプロシージャの次の操作が実行されます。クライアントは、実行する操作がなくなるか、操作の1つがNFS4_OK以外のステータス値になるまで、このプロセスを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. NFSv4 Callback Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. NFSv4コールバック操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. Operation 3: CB_GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. 操作3：CB_GETATTR-属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
fh, attr_request -&gt; attrmask, attr_vals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
fh、attr_request-&gt; attrmask、attr_vals
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_GETATTR4args {
           nfs_fh4 fh;
           bitmap4 attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_GETATTR4resok {
           fattr4  obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CB_GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            CB_GETATTR4resok       resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_GETATTR operation is used by the server to obtain the current modified state of a file that has been OPEN_DELEGATE_WRITE delegated. The size attribute and the change attribute are the only ones guaranteed to be serviced by the client. See Section 10.4.3 for a full description of how the client and server are to interact with the use of CB_GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCB_GETATTR操作を使用して、OPEN_DELEGATE_WRITE委任されたファイルの現在の変更状態を取得します。サイズ属性と変更属性は、クライアントによるサービスが保証されている唯一の属性です。クライアントとサーバーがCB_GETATTRの使用と対話する方法の詳細については、セクション10.4.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the filehandle specified is not one for which the client holds an OPEN_DELEGATE_WRITE delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたファイルハンドルが、クライアントがOPEN_DELEGATE_WRITE委任を保持しているものではない場合、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client returns attrmask bits and the associated attribute values only for the change attribute, and attributes that it may change (time_modify and size).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、変更属性および変更される可能性のある属性（time_modifyおよびsize）についてのみ、attrmaskビットと関連する属性値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. Operation 4: CB_RECALL - Recall an Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. 操作4：CB_RECALL-開いている委任を呼び出す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
stateid, truncate, fh -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
状態ID、切り捨て、fh-&gt;()
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL4args {
           stateid4        stateid;
           bool            truncate;
           nfs_fh4         fh;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_RECALL operation is used to begin the process of recalling an open delegation and returning it to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL操作は、開いている委任を呼び出してサーバーに返すプロセスを開始するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The truncate flag is used to optimize a recall for a file that is about to be truncated to zero. When it is set, the client is freed of obligation to propagate modified data for the file to the server, since this data is irrelevant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
切り捨てフラグは、ゼロに切り捨てられようとしているファイルの再呼び出しを最適化するために使用されます。これが設定されると、ファイルの変更されたデータは無関係であるため、クライアントはファイルに変更されたデータをサーバーに伝搬する義務がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the handle specified is not one for which the client holds an open delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたハンドルが、クライアントが開いている委任を保持するハンドルでない場合、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the stateid specified is not one corresponding to an open delegation for the file specified by the filehandle, an NFS4ERR_BAD_STATEID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定された状態IDが、ファイルハンドルで指定されたファイルの開いている委任に対応するものではない場合、NFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should reply to the callback immediately. Replying does not complete the recall, except when an error was returned. The recall is not complete until the delegation is returned using a DELEGRETURN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはすぐにコールバックに応答する必要があります。エラーが返された場合を除いて、返信してもリコールは完了しません。 DELEGRETURNを使用して委任が返されるまで、再呼び出しは完了しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3. Operation 10044: CB_ILLEGAL - Illegal Callback Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3. 操作10044：CB_ILLEGAL-不正なコールバック操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.1. あらすじ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;null&gt; -&gt; ()
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_ILLEGAL: Response for illegal operation numbers
    */
   struct CB_ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See Section 15.2.4 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、サポートされていないCOMPOUND内の操作コードを送信するクライアントのケースを処理する結果をエンコードするためのプレースホルダーです。詳細は項15.2.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server will probably not send an operation with code OP_CB_ILLEGAL, but if it does, the response will be CB_ILLEGAL4res, just as it would be with any other invalid operation code. Note that if the client gets an illegal operation code that is not OP_ILLEGAL, and if the client checks for legal operation codes during the XDR decode phase, then the CB_ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはおそらくコードOP_CB_ILLEGALの操作を送信しませんが、送信すると、他の無効な操作コードの場合と同様に、応答はCB_ILLEGAL4resになります。クライアントがOP_ILLEGAL以外の不正なオペレーションコードを取得した場合、およびクライアントがXDRデコードフェーズ中に正当なオペレーションコードをチェックした場合、CB_ILLEGAL4resは返されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS has historically used a model where, from an authentication perspective, the client was the entire machine, or at least the source IP address of the machine. The NFS server relied on the NFS client to make the proper authentication of the end-user. The NFS server in turn shared its files only to specific clients, as identified by the client&#39;s source IP address. Given this model, the AUTH_SYS RPC security flavor simply identified the end-user using the client to the NFS server. When processing NFS responses, the client ensured that the responses came from the same IP address and port number that the request was sent to. While such a model is easy to implement and simple to deploy and use, it is certainly not a safe model. Thus, NFSv4 mandates that implementations support a security model that uses end-to-end authentication, where an end-user on a client mutually authenticates (via cryptographic schemes that do not expose passwords or keys in the clear on the network) to a principal on an NFS server. Consideration should also be given to the integrity and privacy of NFS requests and responses. The issues of end-to-end mutual authentication, integrity, and privacy are discussed as part of Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSはこれまで、認証の観点から見ると、クライアントがマシン全体、または少なくともマシンのソースIPアドレスであるモデルを使用してきました。 NFSサーバーは、NFSクライアントに依存して、エンドユーザーの適切な認証を行いました。次に、NFSサーバーは、クライアントのソースIPアドレスによって識別されるように、特定のクライアントのみにファイルを共有しました。このモデルを前提として、AUTH_SYS RPCセキュリティフレーバーは、NFSサーバーに対してクライアントを使用するエンドユーザーを単純に識別しました。 NFS応答を処理するとき、クライアントは、要求が送信されたのと同じIPアドレスとポート番号から応答が送信されることを確認しました。このようなモデルは実装が簡単で、展開と使用が簡単ですが、確かに安全なモデルではありません。したがって、NFSv4は、実装がエンドツーエンド認証を使用するセキュリティモデルをサポートすることを義務付けています。クライアントのエンドユーザーは、（ネットワーク上でパスワードまたはキーを平文で公開しない暗号化スキームを介して）プリンシパルに相互認証します。 NFSサーバー上。 NFSの要求と応答の整合性とプライバシーについても考慮する必要があります。エンドツーエンドの相互認証、整合性、およびプライバシーの問題については、セクション3で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an NFSv4 mandated security model is used and a security principal or an NFSv4 name in user@dns_domain form needs to be translated to or from a local representation as described in Section 5.9, the translation SHOULD be done in a secure manner that preserves the integrity of the translation. For communication with a name service such as the Lightweight Directory Access Protocol (LDAP) ([RFC4511]), this means employing a security service that uses authentication and data integrity. Kerberos and Transport Layer Security (TLS) ([RFC5246]) are examples of such a security service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4必須のセキュリティモデルが使用され、セクション5.9で説明されているように、user @ dns_domain形式のセキュリティプリンシパルまたはNFSv4名をローカル表現との間で変換する必要がある場合、整合性を維持する安全な方法で変換を行う必要があります（SHOULD）翻訳の。ライトウェイトディレクトリアクセスプロトコル（LDAP）（[RFC4511]）などのネームサービスとの通信では、これは認証とデータの整合性を使用するセキュリティサービスを採用することを意味します。 Kerberosおよびトランスポート層セキュリティ（TLS）（[RFC5246]）は、このようなセキュリティサービスの例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that being REQUIRED to implement does not mean REQUIRED to use; AUTH_SYS can be used by NFSv4 clients and servers. However, AUTH_SYS is merely an OPTIONAL security flavor in NFSv4, and so interoperability via AUTH_SYS is not assured.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装する必要があるということは、使用する必要があるという意味ではないことに注意してください。 AUTH_SYSは、NFSv4クライアントおよびサーバーで使用できます。ただし、AUTH_SYSはNFSv4のオプションのセキュリティフレーバーにすぎないため、AUTH_SYSによる相互運用性は保証されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For reasons of reduced administration overhead, better performance, and/or reduction of CPU utilization, users of NFSv4 implementations may choose to not use security mechanisms that enable integrity protection on each remote procedure call and response. The use of mechanisms without integrity leaves the customer vulnerable to an attacker in between the NFS client and server that modifies the RPC request and/or the response. While implementations are free to provide the option to use weaker security mechanisms, there are two operations in particular that warrant the implementation overriding user choices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
管理オーバーヘッドの削減、パフォーマンスの向上、および/またはCPU使用率の削減の理由から、NFSv4実装のユーザーは、各リモートプロシージャコールと応答で整合性保護を可能にするセキュリティメカニズムを使用しないことを選択する場合があります。整合性のないメカニズムを使用すると、RPC要求や応答を変更するNFSクライアントとサーバーの間の攻撃者に対して顧客が脆弱になります。実装はより弱いセキュリティメカニズムを使用するオプションを自由に提供できますが、特にユーザーの選択を上書きする実装を保証する2つの操作があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first such operation is SECINFO. It is recommended that the client issue the SECINFO call such that it is protected with a security flavor that has integrity protection, such as RPCSEC_GSS with a security triple that uses either rpc_gss_svc_integrity or rpc_gss_svc_privacy (rpc_gss_svc_privacy includes integrity protection) service. Without integrity protection encapsulating SECINFO and therefore its results, an attacker in the middle could modify results such that the client might select a weaker algorithm in the set allowed by the server, making the client and/or server vulnerable to further attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のそのような操作はSECINFOです。クライアントは、rpc_gss_svc_integrityまたはrpc_gss_svc_privacy（rpc_gss_svc_privacyが整合性保護を含む）サービスを使用するセキュリティトリプルを持つRPCSEC_GSSなどの整合性保護を備えたセキュリティフレーバーで保護されるように、SECINFO呼び出しを発行することをお勧めします。 SECINFOとその結果をカプセル化する整合性保護がないと、途中の攻撃者が結果を変更して、クライアントがサーバーによって許可されたセットでより弱いアルゴリズムを選択し、クライアントやサーバーがさらなる攻撃に対して脆弱になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second operation that SHOULD use integrity protection is any GETATTR for the fs_locations attribute. The attack has two steps. First, the attacker modifies the unprotected results of some operation to return NFS4ERR_MOVED. Second, when the client follows up with a GETATTR for the fs_locations attribute, the attacker modifies the results to cause the client to migrate its traffic to a server controlled by the attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
整合性保護を使用する必要がある2番目の操作は、fs_locations属性のGETATTRです。攻撃には2つのステップがあります。まず、攻撃者は何らかの操作の保護されていない結果を変更して、NFS4ERR_MOVEDを返します。次に、クライアントがfs_locations属性のGETATTRをフォローアップすると、攻撃者は結果を変更して、クライアントに攻撃者が制御するサーバーにトラフィックを移行させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the operations SETCLIENTID/SETCLIENTID_CONFIRM are responsible for the release of client state, it is imperative that the principal used for these operations is checked against and matches with the previous use of these operations. See Section 9.1.1 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作SETCLIENTID / SETCLIENTID_CONFIRMはクライアント状態の解放を担当するため、これらの操作に使用されるプリンシパルがチェックされ、これらの操作の以前の使用と一致することが不可欠です。詳細については、セクション9.1.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unicode in the form of UTF-8 is used for file component names (i.e., both directory and file components), as well as the owner and owner_group attributes; other character sets may also be allowed for file component names. String processing (e.g., Unicode normalization) raises security concerns for string comparison. See Sections 5.9 and 12 for further discussion, and see [RFC6943] for related identifier comparison security considerations. File component names are identifiers with respect to the identifier comparison discussion in [RFC6943] because they are used to identify the objects to which ACLs are applied; see Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UTF-8形式のUnicodeは、ファイルコンポーネント名（つまり、ディレクトリコンポーネントとファイルコンポーネントの両方）、およびowner属性とowner_group属性に使用されます。他の文字セットもファイルコンポーネント名に使用できます。文字列処理（たとえば、Unicodeの正規化）は、文字列比較に関するセキュリティ上の懸念を引き起こします。詳細については、セクション5.9および12を参照してください。関連する識別子比較のセキュリティに関する考慮事項については、[RFC6943]を参照してください。ファイルコンポーネント名は、ACLが適用されるオブジェクトを識別するために使用されるため、[RFC6943]での識別子の比較に関する識別子です。セクション6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section uses terms that are defined in [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[RFC5226]で定義されている用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1. Named Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1. 名前付き属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a registry called the &#34;NFSv4 Named Attribute Definitions Registry&#34; for [RFC3530] and [RFC5661]. This section introduces no new changes, but it does recap the intent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、[RFC3530]および[RFC5661]用の「NFSv4名前付き属性定義レジストリ」と呼ばれるレジストリを作成しました。このセクションでは、新しい変更はありませんが、意図を要約します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol supports the association of a file with zero or more named attributes. The namespace identifiers for these attributes are defined as string names. The protocol does not define the specific assignment of the namespace for these file attributes. The IANA registry promotes interoperability where common interests exist. While application developers are allowed to define and use attributes as needed, they are encouraged to register the attributes with IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルは、0個以上の名前付き属性を持つファイルの関連付けをサポートします。これらの属性の名前空間識別子は、文字列名として定義されます。プロトコルは、これらのファイル属性の名前空間の特定の割り当てを定義していません。 IANAレジストリは、共通の利益が存在する場合の相互運用性を促進します。アプリケーション開発者は必要に応じて属性を定義して使用することができますが、IANAに属性を登録することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such registered named attributes are presumed to apply to all minor versions of NFSv4, including those defined subsequently to the registration. Where the named attribute is intended to be limited with regard to the minor versions for which they are not to be used, the assignment in the registry will clearly state the applicable limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような登録された名前付き属性は、登録後に定義されたものを含め、NFSv4のすべてのマイナーバージョンに適用されると想定されています。名前付き属性が、それらが使用されないマイナーバージョンに関して制限されることが意図されている場合、レジストリーの割り当ては、適用可能な制限を明確に述べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry is to be maintained using the Specification Required policy as defined in Section 4.1 of [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリは、[RFC5226]のセクション4.1で定義されている仕様必須ポリシーを使用して維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under the NFSv4 specification, the name of a named attribute can in theory be up to 2^32 - 1 bytes in length, but in practice NFSv4 clients and servers will be unable to handle a string that long. IANA should reject any assignment request with a named attribute that exceeds 128 UTF-8 characters. To give the IESG the flexibility to set up bases of assignment of Experimental Use and Standards Action, the prefixes of &#34;EXPE&#34; and &#34;STDS&#34; are Reserved. The zero-length named attribute name is Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4仕様では、名前付き属性の名前は理論的には最大2 ^ 32-1バイトですが、実際にはNFSv4クライアントとサーバーはその長い文字列を処理できません。 IANAは、128 UTF-8文字を超える名前付き属性を持つ割り当て要求を拒否する必要があります。 IESGに実験的使用と標準アクションの割り当てのベースを設定する柔軟性を与えるために、「EXPE」と「STDS」のプレフィックスは予約されています。長さがゼロの名前付き属性名は予約済みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prefix &#34;PRIV&#34; is allocated for Private Use. A site that wants to make use of unregistered named attributes without risk of conflicting with an assignment in IANA&#39;s registry should use the prefix &#34;PRIV&#34; in all of its named attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接頭辞「PRIV」は私的使用のために割り当てられます。 IANAのレジストリでの割り当てと競合するリスクなしに未登録の名前付き属性を利用したいサイトは、すべての名前付き属性でプレフィックス「PRIV」を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because some NFSv4 clients and servers have case-insensitive semantics, the fifteen additional lowercase and mixed-case permutations of each of &#34;EXPE&#34;, &#34;PRIV&#34;, and &#34;STDS&#34; are Reserved (e.g., &#34;expe&#34;, &#34;expE&#34;, &#34;exPe&#34;, etc. are Reserved). Similarly, IANA must not allow two assignments that would conflict if both named attributes were converted to a common case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のNFSv4クライアントとサーバーは大文字と小文字を区別しないセマンティクスを持っているため、「EXPE」、「PRIV」、および「STDS」のそれぞれの15個の追加の小文字および大文字と小文字の組み合わせは予約されています（たとえば、「expe」、「expE」、「 exPe」などは予約されています）。同様に、IANAは、両方の名前付き属性が共通のケースに変換された場合に競合する2つの割り当てを許可してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry of named attributes is a list of assignments, each containing three fields for each assignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性のレジストリは、割り当てのリストであり、割り当てごとに3つのフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A US-ASCII string name that is the actual name of the attribute. This name must be unique. This string name can be 1 to 128 UTF-8 characters long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 属性の実際の名前であるUS-ASCII文字列名。この名前は一意である必要があります。この文字列名には、1〜128文字のUTF-8文字を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A reference to the specification of the named attribute. The reference can consume up to 256 bytes (or more, if IANA permits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 名前付き属性の仕様への参照。参照は最大256バイト（IANAが許可する場合はそれ以上）を消費する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The point of contact of the registrant. The point of contact can consume up to 256 bytes (or more, if IANA permits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 登録者の連絡先。連絡先は最大256バイト（IANAが許可する場合はそれ以上）を消費する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.1. 初期レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no initial registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期レジストリはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.2. 登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registrant is always permitted to update the point of contact field. To make any other change will require Expert Review or IESG Approval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者は、連絡先フィールドの更新を常に許可されています。その他の変更を行うには、エキスパートレビューまたはIESG承認が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2. Updates to Existing IANA Registries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2. 既存のIANAレジストリの更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, because this document obsoletes RFC 3530, IANA has
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、このドキュメントはRFC 3530を廃止したため、IANAは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o replaced all references to RFC 3530 in the Network Identifier (r_netid) registry with references to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワーク識別子（r_netid）レジストリのRFC 3530へのすべての参照を、このドキュメントへの参照に置き換えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o replaced the reference to the nfs registration&#39;s reference to RFC 3530 in the GSSAPI/Kerberos/SASL Service names registry with a reference to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GSSAPI / Kerberos / SASLサービス名レジストリのnfs登録のRFC 3530への参照への参照を、このドキュメントへの参照に置き換えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC20] Cerf, V., &#34;ASCII format for network interchange&#34;, STD 80, RFC 20, October 1969, &lt;http://www.rfc-editor.org/info/rfc20&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC20] Cerf、V。、「ネットワーク交換用のASCII形式」、STD 80、RFC 20、1969年10月、&lt;http://www.rfc-editor.org/info/rfc20&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月、&lt;http://www.rfc-editor.org/info/rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2203] Eisler, M., Chiu, A., and L. Ling, &#34;RPCSEC_GSS Protocol Specification&#34;, RFC 2203, September 1997, &lt;http://www.rfc-editor.org/info/rfc2203&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2203] Eisler、M.、Chiu、A。、およびL. Ling、「RPCSEC_GSS Protocol Specification」、RFC 2203、1997年9月、&lt;http://www.rfc-editor.org/info/rfc2203&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn, J., &#34;Generic Security Service Application Program Interface Version 2, Update 1&#34;, RFC 2743, January 2000, &lt;http://www.rfc-editor.org/info/rfc2743&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn、J。、「Generic Security Service Application Program Interface Version 2、Update 1」、RFC 2743、2000年1月、&lt;http://www.rfc-editor.org/info/rfc2743&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3490] Faltstrom, P., Hoffman, P., and A. Costello, &#34;Internationalizing Domain Names in Applications (IDNA)&#34;, RFC 3490, March 2003, &lt;http://www.rfc-editor.org/info/rfc3490&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3490] Faltstrom、P.、Hoffman、P。、およびA. Costello、「Internationalizing Domain Names in Applications（IDNA）」、RFC 3490、2003年3月、&lt;http://www.rfc-editor.org/info/ rfc3490&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3492] Costello, A., &#34;Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)&#34;, RFC 3492, March 2003, &lt;http://www.rfc-editor.org/info/rfc3492&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3492] Costello、A。、「Punycode：A Bootstring encoding for Unicode for Internationalized Domain Names in Applications（IDNA）」、RFC 3492、2003年3月、&lt;http://www.rfc-editor.org/info/rfc3492&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, STD 63, RFC 3629, November 2003, &lt;http://www.rfc-editor.org/info/rfc3629&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、2003年11月、&lt;http://www.rfc-editor.org/info/rfc3629&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, May 2008, &lt;http://www.rfc-editor.org/info/rfc5226&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、2008年5月、&lt;http://www.rfc-editor.org/info/rfc5226&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5403] Eisler, M., &#34;RPCSEC_GSS Version 2&#34;, RFC 5403, February 2009, &lt;http://www.rfc-editor.org/info/rfc5403&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5403] Eisler、M。、「RPCSEC_GSSバージョン2」、RFC 5403、2009年2月、&lt;http://www.rfc-editor.org/info/rfc5403&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5531] Thurlow, R., &#34;RPC: Remote Procedure Call Protocol Specification Version 2&#34;, RFC 5531, May 2009, &lt;http://www.rfc-editor.org/info/rfc5531&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5531] Thurlow、R。、「RPC：Remote Procedure Call Protocol Specification Version 2」、RFC 5531、2009年5月、&lt;http://www.rfc-editor.org/info/rfc5531&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5665] Eisler, M., &#34;IANA Considerations for Remote Procedure Call (RPC) Network Identifiers and Universal Address Formats&#34;, RFC 5665, January 2010, &lt;http://www.rfc-editor.org/info/rfc5665&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5665] Eisler、M。、「リモートプロシージャコール（RPC）ネットワーク識別子およびユニバーサルアドレスフォーマットに関するIANAの考慮事項」、RFC 5665、2010年1月、&lt;http://www.rfc-editor.org/info/rfc5665&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5890] Klensin, J., &#34;Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework&#34;, RFC 5890, August 2010, &lt;http://www.rfc-editor.org/info/rfc5890&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5890] Klensin、J。、「Internationalized Domain Names for Applications（IDNA）：Definitions and Document Framework」、RFC 5890、2010年8月、&lt;http://www.rfc-editor.org/info/rfc5890&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5891] Klensin, J., &#34;Internationalized Domain Names in Applications (IDNA): Protocol&#34;, RFC 5891, August 2010, &lt;http://www.rfc-editor.org/info/rfc5891&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5891] Klensin、J。、「Internationalized Domain Names in Applications（IDNA）：Protocol」、RFC 5891、2010年8月、&lt;http://www.rfc-editor.org/info/rfc5891&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6649] Hornquist Astrand, L. and T. Yu, &#34;Deprecate DES, RC4-HMAC-EXP, and Other Weak Cryptographic Algorithms in Kerberos&#34;, BCP 179, RFC 6649, July 2012, &lt;http://www.rfc-editor.org/info/rfc6649&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6649] Hornquist Astrand、L。およびT. Yu、「非推奨のDES、RC4-HMAC-EXP、およびその他のKerberosの弱い暗号アルゴリズム」、BCP 179、RFC 6649、2012年7月、&lt;http：//www.rfc- editor.org/info/rfc6649&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7531] Haynes, T., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 External Data Representation Standard (XDR) Description&#34;, RFC 7531, March 2015, &lt;http://www.rfc-editor.org/info/rfc7531&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7531] Haynes、T。、編、およびD. Noveck、編、「Network File System（NFS）Version 4 External Data Representation Standard（XDR）Description」、RFC 7531、2015年3月、&lt;http：// www .rfc-editor.org / info / rfc7531&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SPECIALCASING] The Unicode Consortium, &#34;SpecialCasing-7.0.0.txt&#34;, Unicode Character Database, March 2014, &lt;http://www.unicode.org/ Public/UCD/latest/ucd/SpecialCasing.txt&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SPECIALCASING] Unicodeコンソーシアム、「SpecialCasing-7.0.0.txt」、Unicode Character Database、2014年3月、&lt;http://www.unicode.org/ Public / UCD / latest / ucd / SpecialCasing.txt&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] The Unicode Consortium, &#34;The Unicode Standard, Version 7.0.0&#34;, (Mountain View, CA: The Unicode Consortium, 2014 ISBN 978-1-936213-09-2), June 2014, &lt;http://www.unicode.org/versions/latest/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] Unicodeコンソーシアム「The Unicode Standard、Version 7.0.0」（Mountain View、CA：The Unicode Consortium、2014 ISBN 978-1-936213-09-2）、2014年6月、&lt;http：// www .unicode.org / versions / latest /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[openg_symlink] The Open Group, &#34;Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[openg_symlink] The Open Group、「Open Group Base Specifications Issue 7のベース定義の第3章、セクション3.372」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www。 opengroup.org/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chet] Juszczak, C., &#34;Improving the Performance and Correctness of an NFS Server&#34;, USENIX Conference Proceedings, June 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chet] Juszczak、C。、「NFSサーバーのパフォーマンスと正確さの向上」、USENIX会議議事録、1990年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Floyd] Floyd, S. and V. Jacobson, &#34;The Synchronization of Periodic Routing Messages&#34;, IEEE/ACM Transactions on Networking 2(2), pp. 122-136, April 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Floyd] Floyd、S.およびV. Jacobson、「The Synchronization of Periodic Routing Messages」、IEEE / ACM Transactions on Networking 2（2）、pp。122-136、1994年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IESG_ERRATA] IESG, &#34;IESG Processing of RFC Errata for the IETF Stream&#34;, July 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IESG_ERRATA] IESG、「IESG Streaming for RFC Errata for the IETF Stream」、2008年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MS-SMB] Microsoft Corporation, &#34;Server Message Block (SMB) Protocol Specification&#34;, MS-SMB 43.0, May 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MS-SMB] Microsoft Corporation、「Server Message Block（SMB）Protocol Specification」、MS-SMB 43.0、2014年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P1003.1e] Institute of Electrical and Electronics Engineers, Inc., &#34;IEEE Draft P1003.1e&#34;, 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P1003.1e] Institute of Electrical and Electronics Engineers、Inc。、「IEEE Draft P1003.1e」、1997。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1094] Nowicki, B., &#34;NFS: Network File System Protocol specification&#34;, RFC 1094, March 1989, &lt;http://www.rfc-editor.org/info/rfc1094&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1094] Nowicki、B。、「NFS：Network File System Protocol specification」、RFC 1094、1989年3月、&lt;http://www.rfc-editor.org/info/rfc1094&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813] Callaghan, B., Pawlowski, B., and P. Staubach, &#34;NFS Version 3 Protocol Specification&#34;, RFC 1813, June 1995, &lt;http://www.rfc-editor.org/info/rfc1813&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813] Callaghan、B.、Pawlowski、B。、およびP. Staubach、「NFSバージョン3プロトコル仕様」、RFC 1813、1995年6月、&lt;http://www.rfc-editor.org/info/rfc1813&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1833] Srinivasan, R., &#34;Binding Protocols for ONC RPC Version 2&#34;, RFC 1833, August 1995, &lt;http://www.rfc-editor.org/info/rfc1833&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1833] Srinivasan、R。、「Binding Protocols for ONC RPC Version 2」、RFC 1833、1995年8月、&lt;http://www.rfc-editor.org/info/rfc1833&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2054] Callaghan, B., &#34;WebNFS Client Specification&#34;, RFC 2054, October 1996, &lt;http://www.rfc-editor.org/info/rfc2054&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2054] Callaghan、B。、「WebNFSクライアント仕様」、RFC 2054、1996年10月、&lt;http://www.rfc-editor.org/info/rfc2054&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2055] Callaghan, B., &#34;WebNFS Server Specification&#34;, RFC 2055, October 1996, &lt;http://www.rfc-editor.org/info/rfc2055&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2055] Callaghan、B。、「WebNFS Server Specification」、RFC 2055、1996年10月、&lt;http://www.rfc-editor.org/info/rfc2055&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2224] Callaghan, B., &#34;NFS URL Scheme&#34;, RFC 2224, October 1997, &lt;http://www.rfc-editor.org/info/rfc2224&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2224] Callaghan、B。、「NFS URLスキーム」、RFC 2224、1997年10月、&lt;http://www.rfc-editor.org/info/rfc2224&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2623] Eisler, M., &#34;NFS Version 2 and Version 3 Security Issues and the NFS Protocol&#39;s Use of RPCSEC_GSS and Kerberos V5&#34;, RFC 2623, June 1999, &lt;http://www.rfc-editor.org/info/rfc2623&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2623] Eisler、M。、「NFSバージョン2およびバージョン3のセキュリティ問題とNFSプロトコルによるRPCSEC_GSSおよびKerberos V5の使用」、RFC 2623、1999年6月、&lt;http://www.rfc-editor.org/info/ rfc2623&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2624] Shepler, S., &#34;NFS Version 4 Design Considerations&#34;, RFC 2624, June 1999, &lt;http://www.rfc-editor.org/info/rfc2624&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2624] Shepler、S。、「NFSバージョン4の設計上の考慮事項」、RFC 2624、1999年6月、&lt;http://www.rfc-editor.org/info/rfc2624&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2755] Chiu, A., Eisler, M., and B. Callaghan, &#34;Security Negotiation for WebNFS&#34;, RFC 2755, January 2000, &lt;http://www.rfc-editor.org/info/rfc2755&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2755] Chiu、A.、Eisler、M。、およびB. Callaghan、「WebNFSのセキュリティネゴシエーション」、RFC 2755、2000年1月、&lt;http://www.rfc-editor.org/info/rfc2755&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3010] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, &#34;NFS version 4 Protocol&#34;, RFC 3010, December 2000, &lt;http://www.rfc-editor.org/info/rfc3010&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3010] Shepler、S.、Callaghan、B.、Robinson、D.、Thurlow、R.、Beame、C.、Eisler、M。、およびD. Noveck、「NFSバージョン4プロトコル」、RFC 3010、2000年12月、&lt;http://www.rfc-editor.org/info/rfc3010&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3232] Reynolds, J., Ed., &#34;Assigned Numbers: RFC 1700 is Replaced by an On-line Database&#34;, RFC 3232, January 2002, &lt;http://www.rfc-editor.org/info/rfc3232&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3232] Reynolds、J。、編、「割り当てられた番号：RFC 1700はオンラインデータベースに置き換えられました」、RFC 3232、2002年1月、&lt;http://www.rfc-editor.org/info/rfc3232&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3530] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, &#34;Network File System (NFS) version 4 Protocol&#34;, RFC 3530, April 2003, &lt;http://www.rfc-editor.org/info/rfc3530&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3530] Shepler、S.、Callaghan、B.、Robinson、D.、Thurlow、R.、Beame、C.、Eisler、M。、およびD. Noveck、「Network File System（NFS）version 4 Protocol」、 RFC 3530、2003年4月、&lt;http://www.rfc-editor.org/info/rfc3530&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, &#34;The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2&#34;, RFC 4121, July 2005, &lt;http://www.rfc-editor.org/info/rfc4121&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4121] Zhu、L.、Jaganathan、K。、およびS. Hartman、「Kerberosバージョン5 Generic Security Serviceアプリケーションプログラムインターフェイス（GSS-API）メカニズム：バージョン2」、RFC 4121、2005年7月、&lt;http：/ /www.rfc-editor.org/info/rfc4121&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4178] Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &#34;The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism&#34;, RFC 4178, October 2005, &lt;http://www.rfc-editor.org/info/rfc4178&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4178] Zhu、L.、Leach、P.、Jaganathan、K。、およびW. Ingersoll、「The Simple and Protected Generic Security Service Application Program Interface（GSS-API）Negotiation Mechanism」、RFC 4178、2005年10月、&lt; http://www.rfc-editor.org/info/rfc4178&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4506] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, May 2006, &lt;http://www.rfc-editor.org/info/rfc4506&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4506] Eisler、M。、編、「XDR：外部データ表現標準」、STD 67、RFC 4506、2006年5月、&lt;http://www.rfc-editor.org/info/rfc4506&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4511] Sermersheim, J., Ed., &#34;Lightweight Directory Access Protocol (LDAP): The Protocol&#34;, RFC 4511, June 2006, &lt;http://www.rfc-editor.org/info/rfc4511&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4511] Sermersheim、J。、編、「ライトウェイトディレクトリアクセスプロトコル（LDAP）：プロトコル」、RFC 4511、2006年6月、&lt;http://www.rfc-editor.org/info/rfc4511&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008, &lt;http://www.rfc-editor.org/info/rfc5246&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月、&lt;http://www.rfc-editor.org/info/rfc5246&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 Protocol&#34;, RFC 5661, January 2010, &lt;http://www.rfc-editor.org/info/rfc5661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 &#34;Network File System（NFS）Version 4 Minor Version 1 Protocol&#34;、RFC 5661、January 2010、&lt;http ：//www.rfc-editor.org/info/rfc5661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6365] Hoffman, P. and J. Klensin, &#34;Terminology Used in Internationalization in the IETF&#34;, BCP 166, RFC 6365, September 2011, &lt;http://www.rfc-editor.org/info/rfc6365&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6365] Hoffman、P。およびJ. Klensin、「IETFの国際化で使用される用語」、BCP 166、RFC 6365、2011年9月、&lt;http://www.rfc-editor.org/info/rfc6365&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6943] Thaler, D., Ed., &#34;Issues in Identifier Comparison for Security Purposes&#34;, RFC 6943, May 2013, &lt;http://www.rfc-editor.org/info/rfc6943&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6943] Thaler、D。、編、「セキュリティ上の目的での識別子比較の問題」、RFC 6943、2013年5月、&lt;http://www.rfc-editor.org/info/rfc6943&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[fcntl] The Open Group, &#34;Section &#39;fcntl()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[fcntl] The Open Group、「Open Group Base Specifications Issue 7のシステムインターフェースのセクション &#39;fcntl()」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[fsync] The Open Group, &#34;Section &#39;fsync()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[fsync] The Open Group、「Open Group Base Specifications Issue 7のシステムインターフェイスのセクション &#39;fsync()&#39;」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[getpwnam] The Open Group, &#34;Section &#39;getpwnam()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[getpwnam] Open Group、「Open Group Base Specifications Issue 7のシステムインターフェースのセクション「getpwnam()」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[read_api] The Open Group, &#34;Section &#39;read()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[read_api]オープングループ、「オープングループの基本仕様の問題7のシステムインターフェースのセクション「read()」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[readdir_api] The Open Group, &#34;Section &#39;readdir()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[readdir_api] The Open Group、「Open Group Base Specifications Issue 7のシステムインターフェイスのセクション「readdir()」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[stat] The Open Group, &#34;Section &#39;stat()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[stat] The Open Group、「Open Group Base Specifications Issue 7のシステムインターフェースのセクション「stat()」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[unlink] The Open Group, &#34;Section &#39;unlink()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[unlink] The Open Group、「The Open Group Base Specifications Issue 7のシステムインターフェイスのセクション「unlink()」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[write_api] The Open Group, &#34;Section &#39;write()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[write_api] The Open Group、「Open Group Base Specifications Issue 7のシステムインターフェースのセクション &#39;write()」、IEEE Std 1003.1、2013年版（HTMLバージョン）、ISBN 1937218287、2013年4月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[xnfs] The Open Group, &#34;Protocols for Interworking: XNFS, Version 3W, ISBN 1-85912-184-5&#34;, February 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[xnfs] The Open Group、「Protocols for Interworking：XNFS、Version 3W、ISBN 1-85912-184-5」、1998年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A bis is certainly built on the shoulders of the first attempt. Spencer Shepler, Brent Callaghan, David Robinson, Robert Thurlow, Carl Beame, Mike Eisler, and David Noveck are responsible for a great deal of the effort in this work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビスは確かに最初の試みの肩の上に構築されます。スペンサーシェプラー、ブレントカラガン、デビッドロビンソン、ロバートサーロウ、カールビーム、マイクアイスラー、デビッドノベックは、この作業における多大な努力の責任者です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tom Haynes would like to thank NetApp, Inc. for its funding of his time on this project.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トム・ヘインズは、このプロジェクトに費やしたNetApp、Inc.に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rob Thurlow clarified how a client should contact a new server if a migration has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rob Thurlowさんは、移行が発生した場合にクライアントが新しいサーバーに連絡する方法を明確にしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Black, Nico Williams, Mike Eisler, Trond Myklebust, James Lentini, and Mike Kupfer read many earlier draft versions of Section 12 and contributed numerous useful suggestions, without which the necessary revision of that section for this document would not have been possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Black、Nico Williams、Mike Eisler、Trond Myklebust、James Lentini、およびMike Kupferは、セクション12の以前のドラフトバージョンを多数読み、数多くの有用な提案を提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peter Staubach read almost all of the earlier draft versions of Section 12, leading to the published result, and his numerous comments were always useful and contributed substantially to improving the quality of the final result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peter Staubachは、セクション12の初期のドラフトバージョンのほぼすべてを読んで結果を公開しました。彼の多数のコメントは常に有用であり、最終結果の品質の向上に大きく貢献しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peter Saint-Andre was gracious enough to read the most recent draft version of Section 12 and provided some key insight as to the concerns of the Internationalization community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peter Saint-Andreは、セクション12の最新のドラフトバージョンを読むのに十分なほど礼儀正しく、国際化コミュニティの懸念に関していくつかの重要な洞察を提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
James Lentini graciously read the rewrite of Section 8, and his comments were vital in improving the quality of that effort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
James Lentiniはセクション8の書き直しを丁寧に読み、彼のコメントはその取り組みの質の向上に不可欠でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rob Thurlow, Sorin Faibish, James Lentini, Bruce Fields, and Trond Myklebust were faithful attendants of the biweekly triage meeting and accepted many an action item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロブ・サーロウ、ソリン・ファイビッシュ、ジェームズ・レンティーニ、ブルース・フィールズ、トロンド・マークルバストは隔週のトリアージ会議の忠実な出席者であり、多くのアクションアイテムを受け入れました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bruce Fields was a good sounding board for both the third edge condition and courtesy locks in general. He was also the leading advocate of stamping out backport issues from [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブルースフィールズは、第3のエッジ条件と一般的な礼儀ロックの両方に適した優れたボードでした。彼はまた、[RFC5661]からバックポートの問題を根絶することの第一人者でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Marcel Telka was a champion of straightening out the difference between a lock-owner and an open-owner. He has also been diligent in reviewing the final document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルセルテルカは、ロック所有者とオープン所有者の違いを正すことのチャンピオンでした。彼はまた、最終的な文書のレビューにも熱心に取り組んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Benjamin Kaduk reminded us that DES is dead, and Nico Williams helped us close the lid on the coffin.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Benjamin KadukはDESが死んでいることを思い出させ、Nico Williamsは私たちが棺の蓋を閉めるのを手伝ってくれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Elwyn Davies provided a very thorough and engaging Gen-ART review; thanks!
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Elwyn Daviesは、非常に徹底的で魅力的なGen-ARTレビューを提供しました。ありがとう！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Haynes (editor) Primary Data, Inc. 4300 El Camino Real Ste 100 Los Altos, CA 94022 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Haynes（編集者）Primary Data、Inc. 4300 El Camino Real Ste 100 Los Altos、CA 94022アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 408 215 1519
   EMail: thomas.haynes@primarydata.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Noveck (editor) Dell 300 Innovative Way Nashua, NH 03062 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Noveck（編集者）Dell 300 Innovative Way Nashua、NH 03062アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 781 572 8038
   EMail: dave_noveck@dell.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
